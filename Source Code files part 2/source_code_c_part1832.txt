oid SetButtonID( int iButtonID );

protected:
    int m_iButtonID;

    void DrawTextProc( HDC hDC, const RECT *prc, BOOL fDown );
};


//
// CUIFBalloonWindow
//  = Balloon window class =
//

#define UIBALLOON_OK        0x00010000
#define UIBALLOON_YESNO     0x00020000
#define UIBALLOON_BUTTONS   0x000F0000      /* mask bit */


typedef enum _BALLOONWNDPOS
{
    BALLOONPOS_ABOVE,
    BALLOONPOS_BELLOW,
    BALLOONPOS_LEFT,
    BALLOONPOS_RIGHT,
} BALLOONWNDPOS;


typedef enum _BALLONWNDDIR
{
    BALLOONDIR_LEFT,
    BALLOONDIR_RIGHT,
    BALLOONDIR_UP,
    BALLOONDIR_DOWN,
} BALLOONWNDDIR;


typedef enum _BALLONWNDALIGN
{
    BALLOONALIGN_CENTER,
    BALLOONALIGN_LEFT,
    BALLOONALIGN_TOP    = BALLOONALIGN_LEFT,
    BALLOONALIGN_RIGHT,
    BALLOONALIGN_BOTTOM = BALLOONALIGN_RIGHT,
} BALLOONWNDALIGN;


class CUIFBalloonWindow : public CUIFWindow
{
public:
    CUIFBalloonWindow( HINSTANCE hInst, DWORD dwStyle );
    virtual ~CUIFBalloonWindow( void );

    LPCTSTR GetClassName( void );
    LPCTSTR GetWndTitle( void );

    //
    // CUIFObject methods
    //
    virtual CUIFObject *Initialize( void );
    virtual void OnCreate( HWND hWnd );
    virtual void OnDestroy( HWND hWnd );
    virtual void OnPaint( HDC hDC );
    virtual void OnKeyDown( HWND hWnd, WPARAM wParam, LPARAM lParam );
    virtual LRESULT OnObjectNotify( CUIFObject *pUIObj, DWORD dwCommand, LPARAM lParam );

    //
    //
    //
    LRESULT SetText( LPCWSTR pwchMessage );
    LRESULT SetNotifyWindow( HWND hWndNotify, UINT uiMsgNotify );
    LRESULT SetBalloonPos( BALLOONWNDPOS pos );
    LRESULT SetBalloonAlign( BALLOONWNDALIGN align );
    LRESULT GetBalloonBkColor( void );
    LRESULT GetBalloonTextColor( void );
    LRESULT GetMargin( RECT *prc );
    LRESULT GetMaxBalloonWidth( void );
    LRESULT SetBalloonBkColor( COLORREF col );
    LRESULT SetBalloonTextColor( COLORREF col );
    LRESULT SetMargin( RECT *prc );
    LRESULT SetMaxBalloonWidth( INT iWidth );
    LRESULT SetButtonText( int idCmd, LPCWSTR pwszText );
    LRESULT SetTargetPos( POINT ptTarget );
    LRESULT SetExcludeRect( const RECT *prcExclude );

protected:
    WCHAR           *m_pwszText;
    HRGN            m_hWindowRgn;
    RECT            m_rcMargin;
    INT             m_iMaxTxtWidth;
    BOOL            m_fColBack;
    BOOL            m_fColText;
    COLORREF        m_colBack;
    COLORREF        m_colText;
    POINT           m_ptTarget;
    RECT            m_rcExclude;
    POINT           m_ptTail;
    BALLOONWNDPOS   m_posDef;
    BALLOONWNDPOS   m_pos;
    BALLOONWNDDIR   m_dir;
    BALLOONWNDALIGN m_align;
    int             m_nButton;

    int             m_iCmd;
    HWND            m_hWndNotify;
    UINT            m_uiMsgNotify;

    HRGN CreateRegion( RECT *prc );
    void InitWindowRegion( void );
    void DoneWindowRegion( void );
    void PaintFrameProc( HDC hDC, RECT *prc );
    void PaintMessageProc( HDC hDC, RECT *prc, WCHAR *pwszText );
    void GetButtonSize( SIZE *pSize );
    void AdjustPos( void );
    void LayoutObject( void );
    void AddButton( int idCmd );
    CUIFObject *FindUIObject( DWORD dwID );
    CUIFBalloonButton *FindButton( int idCmd );
    void SendNotification( int iCmd );
};

#endif /* CUIBLN_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\ctf.64\sptip\server.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       server.cpp
//
//  Contents:   COM server functionality.
//
//----------------------------------------------------------------------------
#include "windows.h"

//  DLL part of the Object
//
STDAPI_(BOOL) DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID pvReserved)
{
    return TRUE;
}

STDAPI DllRegisterServer(void)
{
    return S_OK;
}

STDAPI DllUnregisterServer(void)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuibln.cpp ===
//
// cuibln.cpp - ui frame object for balloon message window
//

#include "private.h"
#include "cuiobj.h"
#include "cuiwnd.h"
#include "cuibln.h"
#include "cuiutil.h"
#include "cresstr.h"
#include "cuires.h"


//
// constants
//

#define cxyTailWidth        10
#define cxyTailHeight       16
#define cxRoundSize         16
#define cyRoundSize         16

#define WM_HOOKEDKEY        (WM_USER + 0x0001)


//

/*   C  U I F  B A L L O O N  B U T T O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFBalloonButton::CUIFBalloonButton( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFButton( pParent, dwID, prc, dwStyle )
{
    m_iButtonID = 0;
}


/*   ~  C  U I F  B A L L O O N  B U T T O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFBalloonButton::~CUIFBalloonButton( void )
{
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFBalloonButton::OnPaint( HDC hDC )
{
    HDC      hDCMem = NULL;
    HBITMAP  hBmMem = NULL;
    HBITMAP  hBmMemOld = NULL;
    BOOL     fDownFace = FALSE;
    COLORREF colLTFrame;
    COLORREF colRBFrame;
    HBRUSH   hBrush;
    HBRUSH   hBrushOld;
    HPEN     hPen;
    HPEN     hPenOld;
    RECT     rcItem;

    rcItem = GetRectRef();
    OffsetRect( &rcItem, -rcItem.left, -rcItem.top );

    // create memory DC

    hDCMem = CreateCompatibleDC( hDC );
    hBmMem = CreateCompatibleBitmap( hDC, rcItem.right, rcItem.bottom );
    hBmMemOld = (HBITMAP)SelectObject( hDCMem, hBmMem );

    // determine button image

    switch (m_dwStatus) {
        default: {
            colLTFrame = GetSysColor( COLOR_INFOBK );
            colRBFrame = GetSysColor( COLOR_INFOBK );
            fDownFace = FALSE;
            break;
        }

        case UIBUTTON_DOWN: {
            colLTFrame = GetSysColor( COLOR_3DSHADOW );
            colRBFrame = GetSysColor( COLOR_3DHILIGHT );
            fDownFace = TRUE;
            break;
        }

        case UIBUTTON_HOVER: {
            colLTFrame = GetSysColor( COLOR_3DHILIGHT );
            colRBFrame = GetSysColor( COLOR_3DSHADOW );
            fDownFace = FALSE;
            break;
        }

        case UIBUTTON_DOWNOUT: {
            colLTFrame = GetSysColor( COLOR_3DHILIGHT );
            colRBFrame = GetSysColor( COLOR_3DSHADOW );
            fDownFace = FALSE;
            break;
        }
    }

    // paint button face

    hBrush = CreateSolidBrush( GetSysColor( COLOR_INFOBK ) );
    FillRect( hDCMem, &rcItem, hBrush );
    DeleteObject( hBrush );

    // paint image on button

    DrawTextProc( hDCMem, &rcItem, fDownFace );

    // paint button frame (hilight/shadow)

    hBrushOld = (HBRUSH)SelectObject( hDCMem, GetStockObject( NULL_BRUSH ) );
    hPen = CreatePen( PS_SOLID, 0, colLTFrame );
    hPenOld = (HPEN)SelectObject( hDCMem, hPen );
    RoundRect( hDCMem, rcItem.left, rcItem.top, rcItem.right - 1, rcItem.bottom - 1, 6, 6 );
    SelectObject( hDCMem, hPenOld );
    DeleteObject( hPen );

    hPen = CreatePen( PS_SOLID, 0, colRBFrame );
    hPenOld = (HPEN)SelectObject( hDCMem, hPen );
    RoundRect( hDCMem, rcItem.left + 1, rcItem.top + 1, rcItem.right, rcItem.bottom, 6, 6 );
    SelectObject( hDCMem, hPenOld );
    DeleteObject( hPen );

    // paint button frame (fixed)

    hPen = CreatePen( PS_SOLID, 0, GetSysColor( COLOR_3DFACE ) );
    hPenOld = (HPEN)SelectObject( hDCMem, hPen );
    RoundRect( hDCMem, rcItem.left + 1, rcItem.top + 1, rcItem.right - 1, rcItem.bottom - 1, 6, 6 );
    SelectObject( hDCMem, hPenOld );
    DeleteObject( hPen );

    SelectObject( hDCMem, hBrushOld );

    //

    BitBlt( hDC, 
            GetRectRef().left, 
            GetRectRef().top, 
            GetRectRef().right - GetRectRef().left, 
            GetRectRef().bottom - GetRectRef().top, 
            hDCMem, 
            rcItem.left, 
            rcItem.top, 
            SRCCOPY );

    //

    SelectObject( hDCMem, hBmMemOld );
    DeleteObject( hBmMem );
    DeleteDC( hDCMem );
}


/*   G E T  B U T T O N  I D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFBalloonButton::GetButtonID( void )
{
    return m_iButtonID;
}


/*   S E T  B U T T O N  I D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFBalloonButton::SetButtonID( int iButtonID )
{
    m_iButtonID = iButtonID;
}


/*   D R A W  T E X T  P R O C   */
/*------------------------------------------------------------------------------

    Draw text on button face

------------------------------------------------------------------------------*/
void CUIFBalloonButton::DrawTextProc( HDC hDC, const RECT *prc, BOOL fDown )
{
    HFONT       hFontOld;
    COLORREF    colTextOld;
    int         iBkModeOld;
    DWORD       dwAlign = 0;
    RECT        rc;

    //

    if (m_pwchText == NULL) {
        return;
    }

    //

    hFontOld = (HFONT)SelectObject( hDC, GetFont() );

    // calc text width

    switch (m_dwStyle & UIBUTTON_HALIGNMASK) {
        case UIBUTTON_LEFT:
        default: {
            dwAlign |= DT_LEFT;
            break;
        }

        case UIBUTTON_CENTER: {
            dwAlign |= DT_CENTER;
            break;
        }

        case UIBUTTON_RIGHT: {
            dwAlign |= DT_RIGHT;
            break;
        }
    }

    switch (m_dwStyle & UIBUTTON_VALIGNMASK) {
        case UIBUTTON_TOP:
        default: {
            dwAlign |= DT_TOP;
            break;
        }

        case UIBUTTON_VCENTER: {
            dwAlign |= DT_VCENTER;
            break;
        }

        case UIBUTTON_BOTTOM: {
            dwAlign |= DT_BOTTOM;
            break;
        }
    }

    //

    colTextOld = SetTextColor( hDC, GetSysColor( COLOR_BTNTEXT ) );
    iBkModeOld = SetBkMode( hDC, TRANSPARENT );

    rc = *prc;
    if (fDown) {
        OffsetRect( &rc, +1, +1 );
    }
    CUIDrawText( hDC, m_pwchText, -1, &rc, dwAlign | DT_SINGLELINE );

    SetBkMode( hDC, iBkModeOld );
    SetTextColor( hDC, colTextOld );
    SelectObject( hDC, hFontOld );
}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  B A L L O O N  W I N D O W                                      */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  B A L L O O N  W I N D O W   */
/*------------------------------------------------------------------------------

    Constructor of CUIFBalloonWindow

------------------------------------------------------------------------------*/
CUIFBalloonWindow::CUIFBalloonWindow( HINSTANCE hInst, DWORD dwStyle ) : CUIFWindow( hInst, dwStyle )
{
    m_hWindowRgn        = NULL;
    m_pwszText          = NULL;
    m_rcMargin.left     = 8;
    m_rcMargin.top      = 8;
    m_rcMargin.right    = 8;
    m_rcMargin.bottom   = 8;
    m_iMaxTxtWidth      = -1;
    m_fColBack          = FALSE;
    m_fColText          = FALSE;
    m_colBack           = RGB( 0, 0, 0 );
    m_colText           = RGB( 0, 0, 0 );
    m_ptTarget.x        = 0;
    m_ptTarget.y        = 0;
    m_rcExclude.left    = 0;
    m_rcExclude.right   = 0;
    m_rcExclude.top     = 0;
    m_rcExclude.bottom  = 0;
    m_posDef            = BALLOONPOS_ABOVE;
    m_pos               = BALLOONPOS_ABOVE;
    m_dir               = BALLOONDIR_LEFT;
    m_align             = BALLOONALIGN_CENTER;
    m_ptTail.x          = 0;
    m_ptTail.y          = 0;
    m_nButton           = 0;
    m_iCmd              = -1;
    m_hWndNotify        = 0;
    m_uiMsgNotify       = WM_NULL;
}


/*   ~  C  U I F  B A L L O O N  W I N D O W   */
/*------------------------------------------------------------------------------

    Destructor of CUIFBalloonWindow

------------------------------------------------------------------------------*/
CUIFBalloonWindow::~CUIFBalloonWindow( void )
{
    if (m_pwszText != NULL) {
        delete m_pwszText;
    }
}


/*   G E T  C L A S S  N A M E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LPCTSTR CUIFBalloonWindow::GetClassName( void )
{
    return TEXT(WNDCLASS_BALLOONWND);
}


/*   G E T  W N D  T I T L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LPCTSTR CUIFBalloonWindow::GetWndTitle( void )
{
    return TEXT(WNDTITLE_BALLOONWND);
}


/*   I N I T I A L I Z E   */
/*------------------------------------------------------------------------------

    Initialize UI window object
    (UIFObject method)

------------------------------------------------------------------------------*/
CUIFObject *CUIFBalloonWindow::Initialize( void )
{
    CUIFObject *pUIObj = CUIFWindow::Initialize();

    // create buttons

    switch (GetStyleBits( UIBALLOON_BUTTONS )) {
        case UIBALLOON_OK: {
            AddButton( IDOK );
            break;
        }

        case UIBALLOON_YESNO: {
            AddButton( IDYES );
            AddButton( IDNO );
            break;
        }
    }

    return pUIObj;
}


/*   O N  C R E A T E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFBalloonWindow::OnCreate( HWND hWnd )
{
    UNREFERENCED_PARAMETER( hWnd );

    m_iCmd = -1;
    AdjustPos();
}


/*   O N  D E S T R O Y   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFBalloonWindow::OnDestroy( HWND hWnd )
{
    UNREFERENCED_PARAMETER( hWnd );

    SendNotification( m_iCmd );
    DoneWindowRegion();
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

    Paint window object
    (UIFObject method)

------------------------------------------------------------------------------*/
void CUIFBalloonWindow::OnPaint( HDC hDC )
{
    RECT rcClient;
    RECT rcMargin;

    // paint balloon frame

    GetRect( &rcClient );
    PaintFrameProc( hDC, &rcClient );

    // paint message

    switch (m_pos) {
        default:
        case BALLOONPOS_ABOVE: {
            rcClient.bottom -= cxyTailHeight;
            break;
        }

        case BALLOONPOS_BELLOW: {
            rcClient.top += cxyTailHeight;
            break;
        }

        case BALLOONPOS_LEFT: {
            rcClient.right -= cxyTailHeight;
            break;
        }

        case BALLOONPOS_RIGHT: {
            rcClient.left += cxyTailHeight;
            break;
        }
    }

    GetMargin( &rcMargin );
    rcClient.left   = rcClient.left   + rcMargin.left;
    rcClient.top    = rcClient.top    + rcMargin.top;
    rcClient.right  = rcClient.right  - rcMargin.right;
    rcClient.bottom = rcClient.bottom - rcMargin.bottom;

    PaintMessageProc( hDC, &rcClient, m_pwszText );
}


/*   O N  K E Y  D O W N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFBalloonWindow::OnKeyDown( HWND hWnd, WPARAM wParam, LPARAM lParam )
{
    UNREFERENCED_PARAMETER( hWnd );
    UNREFERENCED_PARAMETER( lParam );

    BOOL fEnd = FALSE;

    switch (wParam) {
        case VK_RETURN: {
            CUIFBalloonButton *pUIBtn = (CUIFBalloonButton *)FindUIObject( 0 ); /* first button */

            if (pUIBtn != NULL) {
                m_iCmd = pUIBtn->GetButtonID();
                fEnd = TRUE;
            }
            break;
        }

        case VK_ESCAPE: {
            m_iCmd = -1;
            fEnd = TRUE;
            break;
        }

        case 'Y': {
            CUIFBalloonButton *pUIBtn = FindButton( IDYES );

            if (pUIBtn != NULL) {
                m_iCmd = pUIBtn->GetButtonID();
                fEnd = TRUE;
            }
            break;
        }

        case 'N': {
            CUIFBalloonButton *pUIBtn = FindButton( IDNO );

            if (pUIBtn != NULL) {
                m_iCmd = pUIBtn->GetButtonID();
                fEnd = TRUE;
            }
            break;
        }
    }

    if (fEnd) {
        DestroyWindow( GetWnd() );
    }
}


/*   O N  O B J E C T  N O T I F Y   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::OnObjectNotify( CUIFObject *pUIObj, DWORD dwCommand, LPARAM lParam )
{
    UNREFERENCED_PARAMETER( dwCommand );
    UNREFERENCED_PARAMETER( lParam );

    m_iCmd = ((CUIFBalloonButton*)pUIObj)->GetButtonID();
    DestroyWindow( GetWnd() );

    return 0;
}


/*   S E T  T E X T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::SetText( LPCWSTR pwchMessage )
{
    if (m_pwszText != NULL) {
        delete m_pwszText;
        m_pwszText = NULL;
    }

    if (pwchMessage != NULL) {
        int l = lstrlenW( pwchMessage );

        m_pwszText = new WCHAR[ l+1 ];
        if (m_pwszText)
            StrCpyW( m_pwszText, pwchMessage );
    }
    else {
        m_pwszText = new WCHAR[1];
        if (m_pwszText)
            *m_pwszText = L'\0';
    }

    AdjustPos();
    return 0;
}


/*   S E T  N O T I F Y  W I N D O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::SetNotifyWindow( HWND hWndNotify, UINT uiMsgNotify )
{
    m_hWndNotify = hWndNotify;
    m_uiMsgNotify = uiMsgNotify;

    return 0;
}


/*   S E T  B A L L O O N  P O S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::SetBalloonPos( BALLOONWNDPOS pos )
{
    m_posDef = pos;
    AdjustPos();

    return 0;
}


/*   S E T  B A L L O O N  A L I G N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::SetBalloonAlign( BALLOONWNDALIGN align )
{
    m_align = align;
    AdjustPos();

    return 0;
}


/*   G E T  B K  C O L O R   */
/*------------------------------------------------------------------------------

    Retrieves the background color in a tooltip window. 

------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::GetBalloonBkColor( void )
{ 
    if (m_fColBack) {
        return (LRESULT)m_colBack;
    }
    else {
        return (LRESULT)GetSysColor( COLOR_INFOBK );
    }
}


/*   G E T  T E X T  C O L O R   */
/*------------------------------------------------------------------------------

    Retrieves the text color in a tooltip window. 

------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::GetBalloonTextColor( void )
{ 
    if (m_fColText) {
        return (LRESULT)m_colText;
    }
    else {
        return (LRESULT)GetSysColor( COLOR_INFOTEXT );
    }
}


/*   G E T  M A R G I N   */
/*------------------------------------------------------------------------------

    Retrieves the top, left, bottom, and right margins set for a tooltip window. 
    A margin is the distance, in pixels, between the tooltip window border and 
    the text contained within the tooltip window. 

------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::GetMargin( RECT *prc )
{
    if (prc == NULL) {
        return 0;
    }

    *prc = m_rcMargin;
    return 0;
}


/*   G E T  M A X  T I P  W I D T H   */
/*------------------------------------------------------------------------------

    Retrieves the maximum width for a tooltip window. 

------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::GetMaxBalloonWidth( void )
{
    return m_iMaxTxtWidth;
}


/*   S E T  B K  C O L O R   */
/*------------------------------------------------------------------------------

    Sets the background color in a tooltip window. 

------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::SetBalloonBkColor( COLORREF col )
{ 
    m_fColBack = TRUE;
    m_colBack = col;

    return 0;
}


/*   S E T  T E X T  C O L O R   */
/*------------------------------------------------------------------------------

    Sets the text color in a tooltip window. 

------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::SetBalloonTextColor( COLORREF col )
{ 
    m_fColText = TRUE;
    m_colText = col;

    return 0;
}


/*   S E T  M A R G I N   */
/*------------------------------------------------------------------------------

    Sets the top, left, bottom, and right margins for a tooltip window. A margin 
    is the distance, in pixels, between the tooltip window border and the text 
    contained within the tooltip window. 

------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::SetMargin( RECT *prc )
{
    if (prc == NULL) {
        return 0;
    }

    m_rcMargin = *prc;
    return 0;
}


/*   S E T  M A X  T I P  W I D T H   */
/*------------------------------------------------------------------------------

     Sets the maximum width for a tooltip window. 

------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::SetMaxBalloonWidth( INT iWidth )
{
    m_iMaxTxtWidth = iWidth;
    return 0;
}


/*   S E T  B U T T O N  T E X T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::SetButtonText( int idCmd, LPCWSTR pwszText )
{
    CUIFBalloonButton *pUIBtn = FindButton( idCmd );

    if (pUIBtn != NULL) {
        pUIBtn->SetText( pwszText );
    }

    return 0;
}


/*   S E T  T A R G E T  P O S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::SetTargetPos( POINT pt )
{
    m_ptTarget = pt;
    AdjustPos();

    return 0;
}


/*   S E T  E X C L U D E  R E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::SetExcludeRect( const RECT *prcExclude )
{
    m_rcExclude = *prcExclude;
    AdjustPos();

    return 0;
}


/*   C R E A T E  R E G I O N   */
/*------------------------------------------------------------------------------


    
------------------------------------------------------------------------------*/
HRGN CUIFBalloonWindow::CreateRegion( RECT *prc )
{
    POINT   rgPt[4];
    HRGN    hRgn;
    HRGN    hRgnTail;

    // create message body window

    switch (m_pos) {
        default:
        case BALLOONPOS_ABOVE: {
#ifndef UNDER_CE // CE does not support RoundRectRgn
            hRgn = CreateRoundRectRgn( 
                        prc->left, 
                        prc->top, 
                        prc->right, 
                        prc->bottom - cxyTailHeight, 
                        cxRoundSize, 
                        cyRoundSize );
#else // UNDER_CE
            hRgn = CreateRectRgn( 
                        prc->left, 
                        prc->top, 
                        prc->right, 
                        prc->bottom - cxyTailHeight );
#endif // UNDER_CE

            rgPt[0].x = m_ptTail.x;
            rgPt[0].y = prc->bottom - 1 - cxyTailHeight;

            rgPt[1].x = m_ptTail.x;
            rgPt[1].y = m_ptTail.y;

            rgPt[2].x = m_ptTail.x + cxyTailWidth * (m_dir == BALLOONDIR_LEFT ? +1 : -1 );
            rgPt[2].y = prc->bottom - 1 - cxyTailHeight;
            rgPt[3] = rgPt[0];
            break;
        }

        case BALLOONPOS_BELLOW: {
#ifndef UNDER_CE // CE does not support RoundRectRgn
            hRgn = CreateRoundRectRgn( 
                        prc->left, 
                        prc->top + cxyTailHeight, 
                        prc->right, 
                        prc->bottom, 
                        cxRoundSize, 
                        cyRoundSize );
#else // UNDER_CE
            hRgn = CreateRectRgn( 
                        prc->left, 
                        prc->top + cxyTailHeight, 
                        prc->right, 
                        prc->bottom );
#endif // UNDER_CE

            rgPt[0].x = m_ptTail.x;
            rgPt[0].y = prc->top + cxyTailHeight;

            rgPt[1].x = m_ptTail.x;
            rgPt[1].y = m_ptTail.y;

            rgPt[2].x = m_ptTail.x + cxyTailWidth * (m_dir == BALLOONDIR_LEFT ? +1 : -1 );
            rgPt[2].y = prc->top + cxyTailHeight;
            rgPt[3] = rgPt[0];
            break;
        }

        case BALLOONPOS_LEFT: {
#ifndef UNDER_CE // CE does not support RoundRectRgn
            hRgn = CreateRoundRectRgn( 
                        prc->left, 
                        prc->top, 
                        prc->right - cxyTailHeight, 
                        prc->bottom, 
                        cxRoundSize, 
                        cyRoundSize );
#else // UNDER_CE
            hRgn = CreateRectRgn( 
                        prc->left, 
                        prc->top, 
                        prc->right - cxyTailHeight, 
                        prc->bottom );
#endif // UNDER_CE

            rgPt[0].x = prc->right - 1 - cxyTailHeight;
            rgPt[0].y = m_ptTail.y;

            rgPt[1].x = m_ptTail.x;
            rgPt[1].y = m_ptTail.y;

            rgPt[2].x = prc->right - 1 - cxyTailHeight;
            rgPt[2].y = m_ptTail.y + cxyTailWidth * (m_dir == BALLOONDIR_UP ? +1 : -1 );
            rgPt[3] = rgPt[0];
            break;
        }

        case BALLOONPOS_RIGHT: {
#ifndef UNDER_CE // CE does not support RoundRectRgn
            hRgn = CreateRoundRectRgn( 
                        prc->left + cxyTailHeight, 
                        prc->top, 
                        prc->right, 
                        prc->bottom, 
                        cxRoundSize, 
                        cyRoundSize );
#else // UNDER_CE
            hRgn = CreateRectRgn( 
                        prc->left + cxyTailHeight, 
                        prc->top, 
                        prc->right, 
                        prc->bottom );
#endif // UNDER_CE

            rgPt[0].x = prc->left + cxyTailHeight;
            rgPt[0].y = m_ptTail.y;

            rgPt[1].x = m_ptTail.x;
            rgPt[1].y = m_ptTail.y;

            rgPt[2].x = prc->left + cxyTailHeight;
            rgPt[2].y = m_ptTail.y + cxyTailWidth * (m_dir == BALLOONDIR_UP ? +1 : -1 );
            rgPt[3] = rgPt[0];
            break;
        }
    }

    // add balloon tail region

#ifndef UNDER_CE // tmptmp CE does not support. check later !!
    hRgnTail = CreatePolygonRgn( rgPt, 4, WINDING );
#endif // UNDER_CE
    CombineRgn( hRgn, hRgn, hRgnTail, RGN_OR );
    DeleteRgn( hRgnTail );

    return hRgn;
}


/*   P A I N T  F R A M E  P R O C   */
/*------------------------------------------------------------------------------


    
------------------------------------------------------------------------------*/
void CUIFBalloonWindow::PaintFrameProc( HDC hDC, RECT *prc )
{
    HRGN        hRgn;
    HBRUSH      hBrushFrm;
    HBRUSH      hBrushWnd;

    Assert( hDC != NULL );

    hRgn = CreateRegion( prc );
    hBrushWnd = CreateSolidBrush( (COLORREF)GetBalloonBkColor() );
    hBrushFrm = CreateSolidBrush( GetSysColor( COLOR_WINDOWFRAME ) );

    FillRgn( hDC, hRgn, hBrushWnd );
#ifndef UNDER_CE // tmptmp CE does not support. check later !!
    FrameRgn( hDC, hRgn, hBrushFrm, 1, 1 );
#endif // UNDER_CE

    DeleteObject( hBrushWnd );
    DeleteObject( hBrushFrm );

    DeleteObject( hRgn );
}


/*   P A I N T  M E S S A G E  P R O C   */
/*------------------------------------------------------------------------------


    
------------------------------------------------------------------------------*/
void CUIFBalloonWindow::PaintMessageProc( HDC hDC, RECT *prc, WCHAR *pwszText )
{
    HFONT       hFontOld;
    COLORREF    colTextOld;
    int         iBkModeOld;

    Assert( hDC != NULL );

    hFontOld = (HFONT)SelectObject( hDC, m_hFont );
    colTextOld = SetTextColor( hDC, (COLORREF)GetBalloonTextColor() );
    iBkModeOld = SetBkMode( hDC, TRANSPARENT );

    CUIDrawText( hDC, pwszText, -1, prc, DT_LEFT | DT_WORDBREAK );

    SelectObject( hDC, hFontOld );
    SetTextColor( hDC, colTextOld );
    SetBkMode( hDC, iBkModeOld );
}


/*   I N I T  W I N D O W  R E G I O N   */
/*------------------------------------------------------------------------------

    Set window region

------------------------------------------------------------------------------*/
void CUIFBalloonWindow::InitWindowRegion( void )
{
    RECT rcClient;

    GetRect( &rcClient );
    m_hWindowRgn = CreateRegion( &rcClient );

    if (m_hWindowRgn != NULL) {
        SetWindowRgn( GetWnd(), m_hWindowRgn, TRUE );
    }
}


/*   D O N E  W I N D O W  R E G I O N   */
/*------------------------------------------------------------------------------

    Reset window region

------------------------------------------------------------------------------*/
void CUIFBalloonWindow::DoneWindowRegion( void )
{
    if (m_hWindowRgn != NULL) {
        SetWindowRgn( GetWnd(), NULL, TRUE );

        DeleteObject( m_hWindowRgn );
        m_hWindowRgn = NULL;
    }
}


/*   G E T  B U T T O N  S I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFBalloonWindow::GetButtonSize( SIZE *pSize )
{
    HDC         hDC;
    HFONT       hFontOld;
    TEXTMETRIC  TM;

    // get text metrics

#ifndef UNDER_CE // DCA => DCW
    hDC = CreateDC( "DISPLAY", NULL, NULL, NULL );
#else // UNDER_CE
    hDC = CreateDCW( L"DISPLAY", NULL, NULL, NULL );
#endif // UNDER_CE
    hFontOld = (HFONT)SelectObject( hDC, GetFont() );
    GetTextMetrics( hDC, &TM );
    SelectObject( hDC, hFontOld );
    DeleteDC( hDC );

    // calc button size

    pSize->cx = TM.tmAveCharWidth * 16;
    pSize->cy = TM.tmHeight + 10;
}


/*   A D J U S T  P O S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFBalloonWindow::AdjustPos( void )
{
    HDC        hDC;
    HFONT      hFontOld;
    TEXTMETRIC TM;
    RECT       rcWork;
    RECT       rcWindow = {0};
    SIZE       WndSize;
    RECT       rcText;
    SIZE       BtnSize;

    if (!IsWindow( GetWnd() )) {
        return;
    }
    if (m_pwszText == NULL) {
        return;
    }

    //

    GetButtonSize( &BtnSize );

    // get text size

#ifndef UNDER_CE // DCA => DCW
    hDC = GetDC( GetWnd() );    //CreateDC( "DISPLAY", NULL, NULL, NULL );
#else // UNDER_CE
    hDC = GetDCW( GetWnd() );   //CreateDCW( L"DISPLAY", NULL, NULL, NULL );
#endif // UNDER_CE
    hFontOld = (HFONT)SelectObject( hDC, GetFont() );

    GetTextMetrics( hDC, &TM );
    rcText.left   = 0;
    rcText.right  = TM.tmAveCharWidth * 40;
    rcText.top    = 0;
    rcText.bottom = 0;

    if (0 < m_nButton) {
        rcText.right  = max( rcText.right, BtnSize.cx*m_nButton + BtnSize.cx/2*(m_nButton-1) );
    }
    
    CUIDrawText( hDC, m_pwszText, -1, &rcText, DT_LEFT | DT_WORDBREAK | DT_CALCRECT );

    SelectObject( hDC, hFontOld );
    ReleaseDC( GetWnd(), hDC );

    //
    // determine window size
    //

    // max width

    if (0 < m_nButton) {
        rcText.right  = max( rcText.right, BtnSize.cx*m_nButton + BtnSize.cx/2*(m_nButton-1) );
    }

    // client width

    WndSize.cx = (rcText.right - rcText.left)
                + m_rcMargin.left
                + m_rcMargin.right;
    WndSize.cy = (rcText.bottom - rcText.top)
                + m_rcMargin.top
                + m_rcMargin.bottom;

    // tail width

    switch (m_pos) {
        default:
        case BALLOONPOS_ABOVE:
        case BALLOONPOS_BELLOW: {
            WndSize.cy += cxyTailHeight;     /* balloon tail height */
            break;
        }

        case BALLOONPOS_LEFT:
        case BALLOONPOS_RIGHT: {
            WndSize.cx += cxyTailHeight;     /* balloon tail height */
            break;
        }
    }

    // buton height

    if (0 < m_nButton) {
        WndSize.cy += m_rcMargin.bottom + BtnSize.cy;        /* margin and button height */ 
    }

    //
    // determine tip window place
    //

    SystemParametersInfo( SPI_GETWORKAREA, 0, &rcWork, 0 );
    if (CUIIsMonitorAPIAvail()) {
        HMONITOR    hMonitor;
        MONITORINFO MonitorInfo;

        hMonitor = CUIMonitorFromPoint( m_ptTarget, MONITOR_DEFAULTTONEAREST );
        if (hMonitor != NULL) {
            MonitorInfo.cbSize = sizeof(MonitorInfo);
            if (CUIGetMonitorInfo( hMonitor, &MonitorInfo )) {
                rcWork = MonitorInfo.rcMonitor;
            }
        }
    }

    m_pos = m_posDef;
    switch (m_pos) {
        default:
        case BALLOONPOS_ABOVE: {
            if (m_rcExclude.top - WndSize.cy < rcWork.top) {
                // cannot locate the tip window at above. can put it at bellow?

                if (m_rcExclude.bottom + WndSize.cy < rcWork.bottom) { 
                    m_pos = BALLOONPOS_BELLOW;
                }
            }
            break;
        }

        case BALLOONPOS_BELLOW: {
            if (rcWork.bottom <= m_rcExclude.bottom + WndSize.cy) {
                // cannot locate the tip window at bellow. can put it at above?

                if (rcWork.top < m_rcExclude.top - WndSize.cy) { 
                    m_pos = BALLOONPOS_ABOVE;
                }
            }
            break;
        }

        case BALLOONPOS_LEFT: {
            if (m_rcExclude.left - WndSize.cx < rcWork.left) {
                // cannot locate the tip window at left. can put it at right?

                if (m_rcExclude.right + WndSize.cx < rcWork.right) { 
                    m_pos = BALLOONPOS_RIGHT;
                }
            }
            break;
        }

        case BALLOONPOS_RIGHT: {
            if (rcWork.right <= m_rcExclude.right + WndSize.cx) {
                // cannot locate the tip window at right. can put it at left?

                if (rcWork.left < m_rcExclude.left - WndSize.cx) { 
                    m_pos = BALLOONPOS_LEFT;
                }
            }
            break;
        }
    }

    //
    // calc window position
    //

    switch (m_pos) {
        default:
        case BALLOONPOS_ABOVE: {
            switch (m_align) {
                default:
                case BALLOONALIGN_CENTER: {
                    rcWindow.left = m_ptTarget.x - WndSize.cx / 2;
                    break;
                }

                case BALLOONALIGN_LEFT: {
                    rcWindow.left = m_rcExclude.left;
                    break;
                }

                case BALLOONALIGN_RIGHT: {
                    rcWindow.left = m_rcExclude.right - WndSize.cx;
                    break;
                }
            }

            rcWindow.top  = m_rcExclude.top - WndSize.cy;
            break;
        }

        case BALLOONPOS_BELLOW: {
            switch (m_align) {
                default:
                case BALLOONALIGN_CENTER: {
                    rcWindow.left = m_ptTarget.x - WndSize.cx / 2;
                    break;
                }

                case BALLOONALIGN_LEFT: {
                    rcWindow.left = m_rcExclude.left;
                    break;
                }

                case BALLOONALIGN_RIGHT: {
                    rcWindow.left = m_rcExclude.right - WndSize.cx;
                    break;
                }
            }

            rcWindow.top  = m_rcExclude.bottom;
            break;
        }

        case BALLOONPOS_LEFT: {
            rcWindow.left = m_rcExclude.left - WndSize.cx;

            switch (m_align) {
                default:
                case BALLOONALIGN_CENTER: {
                    rcWindow.top  = m_ptTarget.y - WndSize.cy / 2;
                    break;
                }

                case BALLOONALIGN_TOP: {
                    rcWindow.top  = m_rcExclude.top;
                    break;
                }

                case BALLOONALIGN_BOTTOM: {
                    rcWindow.top = m_rcExclude.bottom - WndSize.cy;
                    break;
                }
            }
            break;
        }

        case BALLOONPOS_RIGHT: {
            rcWindow.left = m_rcExclude.right;

            switch (m_align) {
                default:
                case BALLOONALIGN_CENTER: {
                    rcWindow.top  = m_ptTarget.y - WndSize.cy / 2;
                    break;
                }

                case BALLOONALIGN_TOP: {
                    rcWindow.top  = m_rcExclude.top;
                    break;
                }

                case BALLOONALIGN_BOTTOM: {
                    rcWindow.top = m_rcExclude.bottom - WndSize.cy;
                    break;
                }
            }
            break;
        }
    }

    rcWindow.right  = rcWindow.left + WndSize.cx;
    rcWindow.bottom = rcWindow.top  + WndSize.cy;

    if (rcWindow.left < rcWork.left) {
        OffsetRect( &rcWindow, rcWork.left - rcWindow.left, 0 );
    }
    else if (rcWork.right < rcWindow.right) {
        OffsetRect( &rcWindow, rcWork.right - rcWindow.right, 0 );
    }

    if (rcWindow.top < rcWork.top) {
        OffsetRect( &rcWindow, 0, rcWork.top - rcWindow.top );
    }
    else if (rcWork.bottom < rcWindow.bottom) {
        OffsetRect( &rcWindow, 0, rcWork.bottom - rcWindow.bottom );
    }

    //
    // calc target (end of balloon tail) point and direction
    //

    switch (m_pos) {
        default:
        case BALLOONPOS_ABOVE: {
            m_ptTail.x = m_ptTarget.x;
            m_ptTail.x = max( m_ptTail.x, rcWindow.left + cxRoundSize/2 );
            m_ptTail.x = min( m_ptTail.x, rcWindow.right - cxRoundSize/2 - 1 );
            m_ptTail.y = rcWindow.bottom - 1;

            m_dir = ((m_ptTail.x < (rcWindow.left + rcWindow.right)/2) ? BALLOONDIR_LEFT : BALLOONDIR_RIGHT);
            break;
        }

        case BALLOONPOS_BELLOW: {
            m_ptTail.x = m_ptTarget.x;
            m_ptTail.x = max( m_ptTail.x, rcWindow.left + cxRoundSize/2 );
            m_ptTail.x = min( m_ptTail.x, rcWindow.right - cxRoundSize/2 - 1 );
            m_ptTail.y = rcWindow.top;

            m_dir = ((m_ptTail.x < (rcWindow.left + rcWindow.right)/2) ? BALLOONDIR_LEFT : BALLOONDIR_RIGHT);
            break;
        }

        case BALLOONPOS_LEFT: {
            m_ptTail.x = rcWindow.right - 1;
            m_ptTail.y = m_ptTarget.y;
            m_ptTail.y = max( m_ptTail.y, rcWindow.top + cyRoundSize/2 );
            m_ptTail.y = min( m_ptTail.y, rcWindow.bottom - cyRoundSize/2 - 1 );

            m_dir = ((m_ptTail.y < (rcWindow.top + rcWindow.bottom)/2) ? BALLOONDIR_UP : BALLOONDIR_DOWN);
            break;
        }

        case BALLOONPOS_RIGHT: {
            m_ptTail.x = rcWindow.left;
            m_ptTail.y = m_ptTarget.y;
            m_ptTail.y = max( m_ptTail.y, rcWindow.top + cyRoundSize/2 );
            m_ptTail.y = min( m_ptTail.y, rcWindow.bottom - cyRoundSize/2 - 1 );

            m_dir = ((m_ptTail.y < (rcWindow.top + rcWindow.bottom)/2) ? BALLOONDIR_UP : BALLOONDIR_DOWN);
            break;
        }
    }

    m_ptTail.x -= rcWindow.left;        // client pos
    m_ptTail.y -= rcWindow.top;         // client pos

    //

    Show( FALSE );
    DoneWindowRegion();

    Move( rcWindow.left, rcWindow.top, rcWindow.right - rcWindow.left, rcWindow.bottom - rcWindow.top );
    LayoutObject();

    InitWindowRegion();
    Show( TRUE );
}


/*   L A Y O U T  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFBalloonWindow::LayoutObject( void )
{
    RECT rcClient;
    RECT rcMargin;
    SIZE BtnSize;
    int  i;

    //

    GetButtonSize( &BtnSize );

    // layout buttons

    GetRect( &rcClient );
    switch (m_pos) {
        default:
        case BALLOONPOS_ABOVE: {
            rcClient.bottom -= cxyTailHeight;
            break;
        }

        case BALLOONPOS_BELLOW: {
            rcClient.top += cxyTailHeight;
            break;
        }

        case BALLOONPOS_LEFT: {
            rcClient.right -= cxyTailHeight;
            break;
        }

        case BALLOONPOS_RIGHT: {
            rcClient.left += cxyTailHeight;
            break;
        }
    }

    GetMargin( &rcMargin );
    rcClient.left   = rcClient.left   + rcMargin.left;
    rcClient.top    = rcClient.top    + rcMargin.top;
    rcClient.right  = rcClient.right  - rcMargin.right;
    rcClient.bottom = rcClient.bottom - rcMargin.bottom;

    //

    for (i = 0; i < m_nButton; i++) {
        CUIFObject *pUIBtn = FindUIObject( i );

        if (pUIBtn != NULL) {
            RECT rcButton;

            rcButton.left   = ((rcClient.left + rcClient.right) - (BtnSize.cx*m_nButton + BtnSize.cx/2*(m_nButton-1))) / 2 + BtnSize.cx*i + BtnSize.cx/2*i;
            rcButton.top    = rcClient.bottom - BtnSize.cy;
            rcButton.right  = rcButton.left + BtnSize.cx;
            rcButton.bottom = rcButton.top  + BtnSize.cy;

            pUIBtn->SetRect( &rcButton );
            pUIBtn->Show( TRUE );
        }
    }
}


/*   A D D  B U T T O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFBalloonWindow::AddButton( int idCmd )
{
    CUIFBalloonButton *pUIBtn = NULL;
    RECT rcNull = { 0, 0, 0, 0 };

    switch (idCmd) {
        case IDOK:
        case IDCANCEL:
        case IDABORT:
        case IDRETRY:
        case IDIGNORE:
        case IDYES:
        case IDNO: {
            pUIBtn = new CUIFBalloonButton( this, (DWORD)m_nButton, &rcNull, UIBUTTON_PUSH | UIBUTTON_CENTER | UIBUTTON_VCENTER );
            break;
        }
    }

    if (pUIBtn != NULL) {
        // 

        WCHAR *pwsz;
        pUIBtn->Initialize();
        pUIBtn->SetButtonID( idCmd );

        switch (idCmd) {
            case IDOK: {
                pwsz = CRStr(CUI_IDS_OK);
                pUIBtn->SetText( *pwsz ? pwsz : L"OK" );
                break;
            }

            case IDCANCEL: {
                pwsz = CRStr(CUI_IDS_CANCEL);
                pUIBtn->SetText( *pwsz ? pwsz : L"Cancel" );
                break;
            }

            case IDABORT: {
                pwsz = CRStr(CUI_IDS_ABORT);
                pUIBtn->SetText( *pwsz ? pwsz : L"&Abort" );
                break;
            }

            case IDRETRY: {
                pwsz = CRStr(CUI_IDS_RETRY);
                pUIBtn->SetText( *pwsz ? pwsz : L"&Retry" );
                break;
            }

            case IDIGNORE: {
                pwsz = CRStr(CUI_IDS_IGNORE);
                pUIBtn->SetText( *pwsz ? pwsz : L"&Ignore" );
                break;
            }

            case IDYES: {
                pwsz = CRStr(CUI_IDS_YES);
                pUIBtn->SetText( *pwsz ? pwsz : L"&Yes" );
                break;
            }

            case IDNO: {
                pwsz = CRStr(CUI_IDS_NO);
                pUIBtn->SetText( *pwsz ? pwsz : L"&No" );
                break;
            }
        }

        AddUIObj( pUIBtn );
        m_nButton++;
    }
}


/*   F I N D  U I  O B J E C T   */
/*------------------------------------------------------------------------------

    Find UI object which has an ID
    When no UI object found, returns NULL.

------------------------------------------------------------------------------*/
CUIFObject *CUIFBalloonWindow::FindUIObject( DWORD dwID )
{
    int nChild;
    int i;

    nChild = m_ChildList.GetCount();
    for (i = 0; i < nChild; i++) {
        CUIFObject *pUIObj = m_ChildList.Get( i );

        Assert(PtrToInt( pUIObj ));
        if (pUIObj->GetID() == dwID) {
            return pUIObj;
        }
    }

    return NULL;
}


/*   F I N D  B U T T O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFBalloonButton *CUIFBalloonWindow::FindButton( int idCmd )
{
    int i;

    for (i = 0; i < m_nButton; i++) {
        CUIFBalloonButton *pUIBtn = (CUIFBalloonButton*)FindUIObject( i );

        if ((pUIBtn != NULL) && (pUIBtn->GetButtonID() == idCmd)) {
            return pUIBtn;
        }
    }

    return NULL;
}


/*   S E N D  N O T I F I C A T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFBalloonWindow::SendNotification( int iCmd )
{
    if (m_hWndNotify != NULL) {
        PostMessage( m_hWndNotify, m_uiMsgNotify, (WPARAM)iCmd, 0 );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuidebug.cpp ===
//
// cuidbg.cpp
//  = debug functions in CUILIB =
//

#include "private.h"
#include "cuidebug.h"

#if defined(_DEBUG) || defined(DEBUG)

/*   C U I  A S S E R T  P R O C   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIAssertProc( LPCTSTR szFile, int iLine, LPCSTR szEval )
{
    TCHAR szMsg[ 2048 ];

    wsprintf( szMsg, TEXT("%s(%d) : %s\n\r"), szFile, iLine, szEval );

    OutputDebugString( TEXT("***** CUILIB ASSERTION FAILED ******\n\r") );
    OutputDebugString( szMsg );
    OutputDebugString( TEXT("\n\r") );
}

#endif /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuiarray.h ===
//
// cuiarray.h
//  = array object in CUILib =
//

#ifndef CUIARRAY_H
#define CUIARRAY_H

//
// CUIFObjectArrayBase
//  = base class of object array = 
//

class CUIFObjectArrayBase
{
public:
    CUIFObjectArrayBase( void );
    virtual ~CUIFObjectArrayBase( void );

    BOOL Add( void *pv );
    BOOL Remove( void *pv );
    int  GetCount( void );
    int  Find( void *pv );
    void *Get( int i );
    void *GetFirst( void );
    void *GetLast( void );

private:
    void **m_pBuffer;
    int  m_nBuffer;
    int  m_nObject;

    BOOL EnsureBuffer( int iSize );
};


//
// CUIFObjectArray
//  = object array = 
//

template<class T>
class CUIFObjectArray : public CUIFObjectArrayBase
{
public:
    CUIFObjectArray( void ) : CUIFObjectArrayBase() 
    {
    }

    virtual ~CUIFObjectArray( void ) 
    {
    }

    T *Get( int i )
    {
        return (T*)CUIFObjectArrayBase::Get( i );
    }

    T *GetFirst( void )
    {
        return (T*)CUIFObjectArrayBase::GetFirst();
    }

    T *GetLast( void )
    {
        return (T*)CUIFObjectArrayBase::GetLast();
    }
};

#endif /* CUIARRAY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuidebug.h ===
//
// cuidebug.h
//  = debug functions in CUILIB =
//

#ifndef CUIDEBUG_H
#define CUIDEBUG_H

#if defined(_DEBUG) || defined(DEBUG)

//
// debug version 
//

void CUIAssertProc( LPCTSTR szFile, int iLine, LPCSTR szEval );

#define Assert( f ) { if (!(BOOL)(f)) { CUIAssertProc( __FILE__, __LINE__, #f ); } }

#else /* !DEBUG */

//
// release version
//

#define Assert( f ) 

#endif /* !DEBUG */

#endif /* CUIDEBUG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuilib.h ===
//
// cuilib.h
//

#ifndef CUILIB_H
#define CUILIB_H

#include "cuiobj.h"
#include "cuiwnd.h"
#include "cuitb.h"
#include "cuimenu.h"
#include "cuitip.h"
#include "cuibln.h"
#include "cuisys.h"
#include "cuischem.h"
#include "cuiutil.h"

extern void InitUIFLib( void );
extern void DoneUIFLib( void );

#endif /* CUILIB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuilib.cpp ===
//
// cuilib.cpp
//

#include "private.h"
#include "cuilib.h"


/*=============================================================================*/
/*                                                                             */
/*   E X P O R T E D  F U N C T I O N S                                        */
/*                                                                             */
/*=============================================================================*/

/*   I N I T  U I F  L I B   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void InitUIFLib( void )
{
	InitUIFSys();
	InitUIFScheme();
	InitUIFUtil();
}


/*   D O N E  U I F  L I B   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void DoneUIFLib( void )
{
	DoneUIFScheme();
	DoneUIFSys();
	DoneUIFUtil();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuimenu.h ===
//
// cuimenu.h
//


#ifndef CUIMENU_H
#define CUIMENU_H

#include "cuiwnd.h"

#define CUI_MENU_UNSELECTED (UINT)(-1)

class CUIFMenu;

#define UIMENUITEM_NONSELECTEDITEM  0x0001
#define UIMENUITEM_MULTICOLUMNITEM  0x0002

//-----------------------------------------------------------------------------
//
// CUIFMenuItem
//
//-----------------------------------------------------------------------------

class CUIFMenuItem : public CUIFObject
{
public:
    CUIFMenuItem(CUIFMenu *pMenu, DWORD dwFlags = 0);
    virtual ~CUIFMenuItem(void);

    BOOL Init(UINT uId, WCHAR *psz);
    void SetBitmap(HBITMAP hbmp);
    void SetBitmapMask( HBITMAP hBmp );
    void Check(BOOL bChecked);
    void RadioCheck(BOOL bChecked);
    void Gray(BOOL bGrayed);
    BOOL IsGrayed() {return _bGrayed;}
    virtual void InitMenuExtent();
    void SetSub(CUIFMenu *pMenu);
    CUIFMenu *GetSub() {return _pSubMenu;}
    CUIFMenu *GetMenu() {return _pMenu;}
    void ShowSubPopup();

    virtual void OnLButtonUp(POINT pt);
    virtual void OnMouseIn(POINT pt);
    virtual void OnMouseOut(POINT pt);

    virtual void OnPaint(HDC hdc);
    virtual void OnPaintDef(HDC hdc);
    virtual void OnPaintO10(HDC hdc);
    virtual void OnTimer();
    virtual BOOL IsSeparator() {return FALSE;}
    BOOL IsNonSelectedItem() {return _bNonSelectedItem;}

    UINT GetId() {return _uId;}

    UINT GetVKey() {return _uShortcutkey;}

    BOOL IsCheck() {return (_bChecked || _bRadioChecked) ? TRUE : FALSE;}
    BOOL IsBmp()   {return (_hbmp) ? TRUE : FALSE;}
    BOOL IsStr()   {return (_psz) ? TRUE : FALSE;}

    BOOL GetMenuExtent(SIZE *psize)
    {
        *psize = _size;
        return TRUE;
    }

    int GetTabTextLength() {return _sizeTab.cx;}

protected:
    void DrawUnderline(HDC hDC, int x, int y, HBRUSH hbr);
    void DrawCheck(HDC hDC, int x, int y);
    void DrawArrow(HDC hDC, int x, int y);
    void DrawBitmapProc( HDC hDC, int x, int y);

    UINT _uId;
    WCHAR *_psz;
    UINT  _cch;
    WCHAR *_pszTab;
    UINT  _cchTab;
    UINT  _uShortcutkey;
    UINT  _uUnderLine;
    HBITMAP _hbmp;
    HBITMAP _hbmpMask;
    BOOL _bChecked;
    BOOL _bRadioChecked;
    BOOL _bGrayed;
    BOOL _bNonSelectedItem;
    CUIFMenu *_pMenu;
    CUIFMenu *_pSubMenu;

    SIZE _size;
    SIZE _sizeTab;
};

//-----------------------------------------------------------------------------
//
// CUIFMenuItemSeparator
//
//-----------------------------------------------------------------------------

class CUIFMenuItemSeparator : public CUIFMenuItem
{
public:
    CUIFMenuItemSeparator(CUIFMenu *pMenu) : CUIFMenuItem(pMenu, UIMENUITEM_NONSELECTEDITEM) 
    {
        _uId = (UINT)-1;
    }

    virtual ~CUIFMenuItemSeparator(void) {}

    virtual void InitMenuExtent();
    virtual void OnPaint(HDC hDC);
    virtual void OnPaintDef(HDC hdc);
    virtual void OnPaintO10(HDC hdc);
    virtual BOOL IsSeparator() {return TRUE;}
};

//-----------------------------------------------------------------------------
//
// CUIFMenu
//
//-----------------------------------------------------------------------------

#define UIMENU_MULTICOLUMN      0x00000001

class CUIFMenu : public CUIFWindow
{
public:
    CUIFMenu(HINSTANCE hInst, DWORD dwWndStyle, DWORD dwMenuStyle);
    virtual ~CUIFMenu(void);

    BOOL InsertItem(CUIFMenuItem *pItem);
    BOOL InsertSeparator();
    UINT ShowModalPopup(CUIFWindow *pcuiWndParent, const RECT *prc, BOOL fVertical);
    void ModalMouseNotify( UINT uMsg, POINT pt);
    void ShowSubPopup(CUIFMenu *pcuiParentMenu, const RECT *prc, BOOL fVertical);
    void HandleMouseMsg( UINT uMsg, POINT pt );

    HFONT GetMarlettFont() {return _hfontMarlett;}

    void CancelMenu();
    void PostKey(BOOL fUp, WPARAM wParam, LPARAM lParam);
    void SetSelectedId(UINT uId);
    void OnKeyDown(HWND hwnd, WPARAM wParam, LPARAM lParam);
    void OnKeyUp(HWND hwnd, WPARAM wParam, LPARAM lParam);

    void CancelSubMenu()
    {
        if (_pCurrentSubMenu)
            _pCurrentSubMenu->CancelMenu();
    }

    CUIFMenu *GetCurrentSubMenu()
    {
        return _pCurrentSubMenu;
    }

    void SetSelectedItem(CUIFMenuItem *pItem)
    {
        if (_pSelectedItem == pItem)
            return;

        CUIFMenuItem *pOldItem = _pSelectedItem;
        _pSelectedItem = pItem;

        if (pOldItem)
            pOldItem->CallOnPaint();
        if (_pSelectedItem)
            _pSelectedItem->CallOnPaint();
    }

    BOOL IsSelectedItem(CUIFMenuItem *pItem)
    {
        return (_pSelectedItem == pItem) ? TRUE : FALSE;
    }

    BOOL IsBmpCheckItem() {return _fIsBmpCheckItem;}
    BOOL IsO10Menu() {return  FHasStyle( UIWINDOW_OFC10MENU ) ? TRUE : FALSE;}
    int GetMenuCheckWidth() {return _cxMenuCheck;}
    int GetMaxTabTextLength() {return _cxMaxTab;}

protected:
    virtual void ModalMessageLoop( void );
    virtual BOOL InitShow(CUIFWindow *pcuiWndParent, const RECT *prc, BOOL fVertical, BOOL fAnimate);
    virtual BOOL UninitShow();
    CUIFMenu *GetTopSubMenu();
    CUIFMenuItem *GetNextItem(CUIFMenuItem *pItem);
    CUIFMenuItem *GetPrevItem(CUIFMenuItem *pItem);
    void SetMenuFont();
    void ClearMenuFont();

    CUIFMenu *_pcuiParentMenu;
    CUIFMenu *_pCurrentSubMenu;
    CUIFMenuItem *_pSelectedItem;

    UINT _uIdSelect;
    CUIFObjectArray<CUIFMenuItem> _rgItems;
    HFONT _hfontMarlett;
    BOOL _fInModal;
    BOOL _fIsBmpCheckItem;
    DWORD _dwMenuStyle;

    int _cxMenuCheck;
    int _cxMaxTab;
};


#endif // CUIMENU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuimenu.cpp ===
//
// cuimenu.cpp
//

#include "private.h"
#include "cuimenu.h"
#include "fontlink.h"


#if (_WIN32_WINNT < 0x0500)
#define SPI_GETMENUANIMATION                0x1002
#define SPI_GETMENUFADE                     0x1012

/*
 * AnimateWindow() Commands
 */
#define AW_HOR_POSITIVE             0x00000001
#define AW_HOR_NEGATIVE             0x00000002
#define AW_VER_POSITIVE             0x00000004
#define AW_VER_NEGATIVE             0x00000008
#define AW_CENTER                   0x00000010
#define AW_HIDE                     0x00010000
#define AW_ACTIVATE                 0x00020000
#define AW_SLIDE                    0x00040000
#define AW_BLEND                    0x00080000
#endif /* _WIN32_WINNT < 0x0500 */

#define MENU_ARROW_MARGIN 2
#define MENU_TEXT_MARGIN  8


/*============================================================================*/
//
//    CUIFMenuItem
//
/*============================================================================*/

/*------------------------------------------------------------------------------

   ctor

------------------------------------------------------------------------------*/
CUIFMenuItem::CUIFMenuItem(CUIFMenu *pMenu, DWORD dwFlags) : CUIFObject(pMenu, 0, NULL, 0)
{
    _uId = 0;
    _psz = NULL;
    _cch = 0;
    _pszTab = NULL;
    _cchTab = 0;
    _uShortcutkey = 0;
    _hbmp = NULL;
    _hbmpMask = NULL;
    _bChecked = FALSE;
    _bGrayed = FALSE;
    _pMenu = pMenu;
    _uUnderLine = -1;
    _bNonSelectedItem = (dwFlags & UIMENUITEM_NONSELECTEDITEM) ? TRUE : FALSE;
}

/*------------------------------------------------------------------------------

   dtor

------------------------------------------------------------------------------*/
CUIFMenuItem::~CUIFMenuItem(void)
{
    if (_psz)
        delete _psz;

    if (_pszTab)
        delete _pszTab;

    if (_pSubMenu)
        delete _pSubMenu;
}

/*------------------------------------------------------------------------------

   Init

------------------------------------------------------------------------------*/
BOOL CUIFMenuItem::Init(UINT uId, WCHAR *psz)
{
    _uId = uId;

    if (!psz)
    {
        _psz = NULL;
        _cch = 0;
        return TRUE;
    }

    UINT cch = StrLenW(psz);
    _psz = new WCHAR[cch + 1];
    if (!_psz)
        return FALSE;

    int i = 0;
    while (*psz && (*psz != L'\t'))
    {
        if (*psz == L'&')
        {
            psz++;
            if (*psz != L'&')
            {
                _uShortcutkey = LOBYTE(VkKeyScanW(*psz));
                if (!_uShortcutkey)
                {
                    Assert(!HIBYTE(*psz));
                    _uShortcutkey = LOBYTE(VkKeyScanA(LOBYTE(*psz)));
                }
                _uUnderLine = i;
            }
        }
        _psz[i] = *psz;
        i++;
        psz++;
    }
    _cch = StrLenW(_psz);

    if (*psz == L'\t')
    {
        _pszTab = new WCHAR[cch + 1];
        if (_pszTab)
        {
            i = 0;
            psz++;
            while (*psz)
            {
                _pszTab[i] = *psz;
                psz++;
                i++;
            }
            _cchTab = StrLenW(_pszTab);
        }
    }

    return TRUE;
}

/*------------------------------------------------------------------------------

   SetBitmap

------------------------------------------------------------------------------*/
void CUIFMenuItem::SetBitmap(HBITMAP hbmp)
{
    _hbmp = hbmp;
}

/*------------------------------------------------------------------------------

    Set bitmap of button face

------------------------------------------------------------------------------*/
void CUIFMenuItem::SetBitmapMask( HBITMAP hBmp )
{
    _hbmpMask = hBmp;
#if 0
    BITMAP bmp;
    GetObject(_hbmp, sizeof(bmp), &bmp);
    RECT rc;
    ::SetRect(&rc, 0, 0, bmp.bmWidth, bmp.bmHeight);
    _hbmpMask = CreateMaskBmp(&rc, _hbmp, hBmp,
                              (HBRUSH)(COLOR_3DFACE + 1) );
#endif
    CallOnPaint();
}

/*------------------------------------------------------------------------------

   Check

------------------------------------------------------------------------------*/
void CUIFMenuItem::Check(BOOL bChecked)
{
    _bChecked = bChecked;
}

/*------------------------------------------------------------------------------

   RadioCheck

------------------------------------------------------------------------------*/
void CUIFMenuItem::RadioCheck(BOOL bRadioChecked)
{
    _bRadioChecked = bRadioChecked;
}

/*------------------------------------------------------------------------------

   Gray

------------------------------------------------------------------------------*/
void CUIFMenuItem::Gray(BOOL bGrayed)
{
    _bGrayed = bGrayed;
}

/*------------------------------------------------------------------------------

   SetSub

------------------------------------------------------------------------------*/
void CUIFMenuItem::SetSub(CUIFMenu *pSubMenu)
{
    _pSubMenu = pSubMenu;
}

/*------------------------------------------------------------------------------

   InitMenuExtent

------------------------------------------------------------------------------*/
void CUIFMenuItem::InitMenuExtent()
{
    HDC hdc = GetDC(m_pUIWnd->GetWnd());
    if (_psz)
    {
        HFONT hFontOld= (HFONT)SelectObject( hdc, GetFont() );
        CUIGetTextExtentPoint32( hdc, _psz, _cch, &_size);
        _size.cx += MENU_TEXT_MARGIN * 2;
        _size.cy += MENU_TEXT_MARGIN;

        if (_pszTab)
        {
            CUIGetTextExtentPoint32( hdc, _pszTab, _cchTab, &_sizeTab);
            _sizeTab.cy += MENU_TEXT_MARGIN;
        }

        SelectObject( hdc, hFontOld);

        if (GetSub())
        {
            _size.cx += (_size.cy + MENU_ARROW_MARGIN);
        }

        if (_pMenu->IsO10Menu())
            _size.cx += 24;
    }
    else if (_hbmp)
    {
        BITMAP bmp;
        GetObject(_hbmp, sizeof(bmp), &bmp);
        _size.cx = bmp.bmWidth + 2;
        _size.cy = bmp.bmHeight + 4;
    }
    else
    {
        _size.cy = 0;
        _size.cx = 0;
    }


    ReleaseDC(m_pUIWnd->GetWnd(), hdc);

}



/*------------------------------------------------------------------------------

   OnLButtonUp

------------------------------------------------------------------------------*/
void CUIFMenuItem::OnLButtonUp(POINT pt)
{
    if (IsGrayed())
        return;

    if (IsNonSelectedItem())
        return;

    if (_pSubMenu)
        return;

    _pMenu->SetSelectedId(_uId);
    PostMessage(m_pUIWnd->GetWnd(), WM_NULL, 0, 0);
}

/*------------------------------------------------------------------------------

   OnMouseIn

------------------------------------------------------------------------------*/
void CUIFMenuItem::OnMouseIn(POINT pt)
{
    _pMenu->CancelSubMenu();

    //
    // start timer to open submenu.
    //
    if (_pSubMenu)
    {
        UINT uElipse;
        if (!SystemParametersInfo(SPI_GETMENUSHOWDELAY, 
                                  0, 
                                  (void *)&uElipse, 
                                  FALSE))
        {
            uElipse = 300;
        }

        StartTimer(uElipse);
    }

    // 
    // darw this.
    // 
    _pMenu->SetSelectedItem(this);
}

/*------------------------------------------------------------------------------

   OnMouseOut

------------------------------------------------------------------------------*/
void CUIFMenuItem::OnMouseOut(POINT pt)
{

}

/*------------------------------------------------------------------------------

   OnTimer

------------------------------------------------------------------------------*/
void CUIFMenuItem::OnTimer()
{
    EndTimer();
    Assert(PtrToInt(_pSubMenu));

    if (!_pMenu->IsPointed(this))
        return;

    ShowSubPopup();

}
/*------------------------------------------------------------------------------

   ShowSubPopup

------------------------------------------------------------------------------*/
void CUIFMenuItem::ShowSubPopup()
{
    Assert(PtrToInt(_pSubMenu));

    RECT rc = GetRectRef();
    ClientToScreen(m_pUIWnd->GetWnd(), (POINT *)&rc.left);
    ClientToScreen(m_pUIWnd->GetWnd(), (POINT *)&rc.right);
    _pSubMenu->ShowSubPopup(_pMenu, &rc, FALSE);
}

/*------------------------------------------------------------------------------

   OnPaint

------------------------------------------------------------------------------*/
void CUIFMenuItem::OnPaint(HDC hDC)
{
    if (_pMenu->IsO10Menu())
        OnPaintO10(hDC);
    else
        OnPaintDef(hDC);
}

/*------------------------------------------------------------------------------

   OnPaintDef

------------------------------------------------------------------------------*/
void CUIFMenuItem::OnPaintDef(HDC hDC)
{
    HFONT hFontOld;
    int xAlign;
    int yAlign;
    int xText;
    int yText;
    int xCheck;
    int yCheck;
    int xBmp;
    int yBmp;
    int xArrow;
    int yArrow;
    SIZE size;

    hFontOld= (HFONT)SelectObject( hDC, GetFont() );

    // calc alignment

    CUIGetTextExtentPoint32( hDC, _psz, _cch, &size );

    xAlign = 0;
    yAlign = (GetRectRef().bottom - GetRectRef().top - size.cy) / 2;

    xCheck = GetRectRef().left + xAlign;
    yCheck = GetRectRef().top + yAlign;

    xBmp   = xCheck + (_pMenu->IsBmpCheckItem() ? _pMenu->GetMenuCheckWidth() : 0);
    yBmp   = GetRectRef().top;

    xText  = xCheck + 2 + _pMenu->GetMenuCheckWidth() + (_pMenu->IsBmpCheckItem() ? _pMenu->GetMenuCheckWidth() : 0);
    yText  = GetRectRef().top + yAlign;
    xArrow = GetRectRef().left + GetRectRef().right - 10, 
    yArrow = GetRectRef().top + yAlign;

    // draw

    SetBkMode( hDC, TRANSPARENT );

    if (!_bGrayed)
    {
        if (!_pMenu->IsSelectedItem(this) || IsNonSelectedItem())
        {
            SetTextColor( hDC, GetSysColor(COLOR_MENUTEXT) );

            CUIExtTextOut( hDC,
                           xText,
                           yText,
                           ETO_CLIPPED,
                           &GetRectRef(),
                           _psz,
                           _cch,
                           NULL );

            DrawUnderline(hDC,
                           xText,
                           yText,
                          (HBRUSH)(COLOR_MENUTEXT + 1));

            DrawCheck(hDC, xCheck, yCheck);

            DrawBitmapProc(hDC, xBmp, yBmp);

            DrawArrow(hDC, xArrow, yArrow);

        }
        else
        {
            SetTextColor( hDC, GetSysColor(COLOR_HIGHLIGHTTEXT) );
            SetBkColor( hDC, GetSysColor(COLOR_HIGHLIGHT) );
            CUIExtTextOut( hDC,
                           xText,
                           yText,
                           ETO_CLIPPED | ETO_OPAQUE,
                           &GetRectRef(),
                           _psz,
                           _cch,
                           NULL );

            DrawUnderline(hDC,
                          xText,
                          yText,
                          (HBRUSH)(COLOR_HIGHLIGHTTEXT + 1));

            DrawCheck(hDC, xCheck, yCheck);

            DrawBitmapProc(hDC, xBmp, yBmp);

            DrawArrow(hDC, xArrow, yArrow);
        }
    }
    else 
    {
        UINT ueto = ETO_CLIPPED;

        if (!_pMenu->IsSelectedItem(this) || IsNonSelectedItem())
        {
            SetTextColor( hDC, GetSysColor(COLOR_3DHIGHLIGHT) );
            CUIExtTextOut( hDC,
                        xText + 1,
                        yText + 1,
                        ueto,
                        &GetRectRef(),
                        _psz,
                        _cch,
                        NULL );

            DrawCheck(hDC, xCheck + 1, yCheck + 1);
    
            DrawBitmapProc(hDC, xBmp + 1, yBmp + 1);

            DrawArrow(hDC, xArrow + 1, yArrow + 1);
        }
        else
        {
            SetBkColor( hDC, GetSysColor(COLOR_HIGHLIGHT) );
            ueto |= ETO_OPAQUE;
        }

        SetTextColor(hDC, GetSysColor(COLOR_3DSHADOW) );
        CUIExtTextOut(hDC,
                      xText,
                      yText,
                      ueto,
                      &GetRectRef(),
                      _psz,
                      _cch,
                      NULL );

        DrawUnderline(hDC,
                      xText,
                      yText,
                      (HBRUSH)(COLOR_3DSHADOW + 1));

        DrawCheck(hDC, xCheck, yCheck);

        DrawBitmapProc(hDC, xBmp, yBmp);

        DrawArrow(hDC, xArrow, yArrow);
    }

    // restore objects

    SelectObject( hDC, hFontOld);
}

/*------------------------------------------------------------------------------

   OnPaintO10

------------------------------------------------------------------------------*/
void CUIFMenuItem::OnPaintO10(HDC hDC)
{
    HFONT hFontOld;
    int xAlign;
    int yAlign;
    int xText;
    int yText;
    int xCheck;
    int yCheck;
    int xBmp;
    int yBmp;
    int xArrow;
    int yArrow;
    SIZE size;
    RECT rc;

    if (!m_pUIFScheme)
        return;

    hFontOld= (HFONT)SelectObject( hDC, GetFont() );

    // calc alignment

    CUIGetTextExtentPoint32( hDC, _psz, _cch, &size );

    xAlign = 0;
    yAlign = (GetRectRef().bottom - GetRectRef().top - size.cy) / 2;

    xCheck = GetRectRef().left + xAlign;
    yCheck = GetRectRef().top + yAlign;

    xBmp   = xCheck + (_pMenu->IsBmpCheckItem() ? _pMenu->GetMenuCheckWidth() : 0);
    yBmp   = GetRectRef().top;

    xText  = xBmp + 8 + _pMenu->GetMenuCheckWidth();

    yText  = GetRectRef().top + yAlign;
    xArrow = GetRectRef().left + GetRectRef().right - size.cy - MENU_ARROW_MARGIN; //size.cy may be enough for size of arrow...
    yArrow = GetRectRef().top + yAlign;

    // draw
    GetRect(&rc);
    if (!_pMenu->IsSelectedItem(this) || IsNonSelectedItem())
    {
        rc.right = rc.left + _pMenu->GetMenuCheckWidth() + 2;
        if (_pMenu->IsBmpCheckItem())
            rc.right += _pMenu->GetMenuCheckWidth();

        ::FillRect(hDC, &rc, m_pUIFScheme->GetBrush(UIFCOLOR_CTRLBKGND));
    }
    else
    {
        m_pUIFScheme->DrawCtrlBkgd(hDC, &rc, 0, UIFDCS_SELECTED);
        m_pUIFScheme->DrawCtrlEdge(hDC, &rc, 0, UIFDCS_SELECTED);
    }

    SetBkMode( hDC, TRANSPARENT );

    if (!_bGrayed)
    {
        if (!_pMenu->IsSelectedItem(this) || IsNonSelectedItem())
        {
            SetTextColor( hDC, m_pUIFScheme->GetColor(UIFCOLOR_CTRLTEXT) );

            CUIExtTextOut( hDC,
                           xText,
                           yText,
                           ETO_CLIPPED,
                           &GetRectRef(),
                           _psz,
                           _cch,
                           NULL );

            DrawUnderline(hDC,
                           xText,
                           yText,
                          (HBRUSH)m_pUIFScheme->GetBrush(UIFCOLOR_CTRLTEXT));

            if (_pszTab)
                CUIExtTextOut( hDC,
                               GetRectRef().right - _pMenu->GetMaxTabTextLength() - MENU_TEXT_MARGIN,
                               yText,
                               ETO_CLIPPED,
                               &GetRectRef(),
                               _pszTab,
                               _cchTab,
                               NULL );

            DrawCheck(hDC, xCheck, yCheck);

            DrawBitmapProc(hDC, xBmp, yBmp);

            DrawArrow(hDC, xArrow, yArrow);

        }
        else
        {
            SetTextColor( hDC, m_pUIFScheme->GetColor(UIFCOLOR_MOUSEOVERTEXT) );

            CUIExtTextOut( hDC,
                           xText,
                           yText,
                           ETO_CLIPPED,
                           &GetRectRef(),
                           _psz,
                           _cch,
                           NULL );

            DrawUnderline(hDC,
                          xText,
                          yText,
                          (HBRUSH)m_pUIFScheme->GetBrush(UIFCOLOR_MOUSEOVERTEXT));

            if (_pszTab)
                CUIExtTextOut( hDC,
                               GetRectRef().right - _pMenu->GetMaxTabTextLength() - MENU_TEXT_MARGIN,
                               yText,
                               ETO_CLIPPED,
                               &GetRectRef(),
                               _pszTab,
                               _cchTab,
                               NULL );

            DrawCheck(hDC, xCheck, yCheck);

            DrawBitmapProc(hDC, xBmp, yBmp);

            DrawArrow(hDC, xArrow, yArrow);
        }
    }
    else 
    {
#if 1
        SetTextColor( hDC, m_pUIFScheme->GetColor(UIFCOLOR_CTRLTEXTDISABLED) );
        CUIExtTextOut(hDC,
                      xText,
                      yText,
                      ETO_CLIPPED,
                      &GetRectRef(),
                      _psz,
                      _cch,
                      NULL );

        DrawUnderline(hDC,
                      xText,
                      yText,
                      (HBRUSH)m_pUIFScheme->GetBrush(UIFCOLOR_CTRLTEXTDISABLED));

        if (_pszTab)
            CUIExtTextOut( hDC,
                           GetRectRef().right - _pMenu->GetMaxTabTextLength() - MENU_TEXT_MARGIN,
                           yText,
                           ETO_CLIPPED,
                           &GetRectRef(),
                           _pszTab,
                           _cchTab,
                           NULL );

        DrawCheck(hDC, xCheck, yCheck);

        DrawBitmapProc(hDC, xBmp, yBmp);

        DrawArrow(hDC, xArrow, yArrow);
#else
        UINT ueto = ETO_CLIPPED;

        if (!_pMenu->IsSelectedItem(this) || IsNonSelectedItem())
        {
            SetTextColor( hDC, GetSysColor(COLOR_3DHIGHLIGHT) );
            CUIExtTextOut( hDC,
                        xText + 1,
                        yText + 1,
                        ueto,
                        &GetRectRef(),
                        _psz,
                        _cch,
                        NULL );

            if (_pszTab)
                CUIExtTextOut( hDC,
                               GetRectRef().right - _pMenu->GetMaxTabTextLength() - 3,
                               yText + 1,
                               ETO_CLIPPED,
                               &GetRectRef(),
                               _pszTab,
                               _cchTab,
                               NULL );

            DrawCheck(hDC, xCheck + 1, yCheck + 1);
    
            DrawBitmapProc(hDC, xBmp + 1, yBmp + 1);

            DrawArrow(hDC, xArrow + 1, yArrow + 1);
        }
        else
        {
            SetBkColor( hDC, GetSysColor(COLOR_HIGHLIGHT) );
            ueto |= ETO_OPAQUE;
        }

        SetTextColor(hDC, GetSysColor(COLOR_3DSHADOW) );
        CUIExtTextOut(hDC,
                      xText,
                      yText,
                      ueto,
                      &GetRectRef(),
                      _psz,
                      _cch,
                      NULL );

        DrawUnderline(hDC,
                      xText,
                      yText,
                      (HBRUSH)(COLOR_3DSHADOW + 1));

        CUIExtTextOut( hDC,
                       GetRectRef().right - _pMenu->GetMaxTabTextLength() - MENU_TEXT_MARGIN,
                       yText,
                       ETO_CLIPPED,
                       &GetRectRef(),
                       _pszTab,
                       _cchTab,
                       NULL );

        DrawCheck(hDC, xCheck, yCheck);

        DrawBitmapProc(hDC, xBmp, yBmp);

        DrawArrow(hDC, xArrow, yArrow);
#endif
    }

    // restore objects

    SelectObject( hDC, hFontOld);
}

/*------------------------------------------------------------------------------

   DrawUnderline

------------------------------------------------------------------------------*/
void CUIFMenuItem::DrawUnderline(HDC hDC, int x, int y, HBRUSH hbr)
{
    if (_uUnderLine > _cch)
        return;

    SIZE size0, size1;
    CUIGetTextExtentPoint32( hDC, _psz, _uUnderLine, &size0 );
    CUIGetTextExtentPoint32( hDC, _psz, _uUnderLine + 1, &size1 );

    RECT rc;
    rc.left   = x + size0.cx;
    if (_uUnderLine)
        rc.left++;

    rc.right  = x + size1.cx;
    rc.top    = y + size1.cy - 1;
    rc.bottom = y + size1.cy;
    FillRect(hDC, &rc, hbr);

}

/*------------------------------------------------------------------------------

   DrawCheck

------------------------------------------------------------------------------*/
void CUIFMenuItem::DrawCheck(HDC hDC, int x, int y)
{
    if (!IsCheck())
         return;

    HFONT hFontOld = (HFONT)SelectObject( hDC, _pMenu->GetMarlettFont());

    TextOut(hDC,  x,  y,  _bChecked ? "a" : "h",  1);

    SelectObject( hDC, hFontOld);
}

/*------------------------------------------------------------------------------

   DrawArrow

------------------------------------------------------------------------------*/
void CUIFMenuItem::DrawArrow(HDC hDC, int x, int y)
{
    if (!_pSubMenu)
        return;

    HFONT hFontOld = (HFONT)SelectObject( hDC, _pMenu->GetMarlettFont());
    TextOut( hDC, x, y, "4", 1);
    SelectObject( hDC, hFontOld);
}

/*   D R A W  B I T M A P  P R O C   */
/*------------------------------------------------------------------------------

    Draw bitmap on button face 

------------------------------------------------------------------------------*/
void CUIFMenuItem::DrawBitmapProc( HDC hDC, int x, int y)
{
    BITMAP bmp;
    DWORD dwState = 0;

    if (!m_pUIFScheme)
        return;

    if (!_hbmp)
        return;
    
    int cx;
    int cy;

    cx = _pMenu->GetMenuCheckWidth();

    cy = GetRectRef().bottom - GetRectRef().top;

    // we have to do this viewport trick to get around the fact that 
    // DrawState has a GDI bug in NT4, such that it handles offsets improperly.
    // so we do the offset by hand.
    // POINT ptOldOrg;
    // BOOL fRetVal = SetViewportOrgEx( hDC, 0, 0, &ptOldOrg );
    // Assert( fRetVal );

    GetObject(_hbmp, sizeof(bmp), &bmp);
    if (cx > bmp.bmWidth)
    {
        x += (cx - bmp.bmWidth) / 2;
        cx = bmp.bmWidth;
    }

    if (cy > bmp.bmHeight)
    {
        y += (cy - bmp.bmHeight) / 2;
        cy = bmp.bmHeight;
    }
   
    RECT rc;
    // ::SetRect(&rc, x + ptOldOrg.x, 
    //                y + ptOldOrg.y, 
    //                x + ptOldOrg.x + cx, 
    //                y + ptOldOrg.y + cy);
    ::SetRect(&rc, x,  y,  x + cx,  y + cy);

    if (IsRTL())
        m_pUIFScheme->SetLayout(LAYOUT_RTL);

    if (_pMenu->IsSelectedItem(this) && !IsNonSelectedItem())
    {
        dwState |=  UIFDCS_SELECTED;
        m_pUIFScheme->DrawMenuBitmap(hDC, &rc, _hbmp, _hbmpMask, dwState);
    }
#if 0
    else if (IsCheck())
    {
        dwState |=  UIFDCS_MOUSEOVER;
        m_pUIFScheme->DrawMenuBitmap(hDC, &rc, _hbmp, _hbmpMask, dwState);
        ::OffsetRect(&rc, -1, -1);
        ::InflateRect(&rc, 2, 2);
        m_pUIFScheme->DrawCtrlEdge(hDC, &rc, 0, UIFDCS_SELECTED);
    }
#endif
    else
    {
        m_pUIFScheme->DrawMenuBitmap(hDC, &rc, _hbmp, _hbmpMask, dwState);
    }

    if (IsRTL())
        m_pUIFScheme->SetLayout(0);


    // SetViewportOrgEx( hDC, ptOldOrg.x, ptOldOrg.y, NULL );
}

/*============================================================================*/
//
//    CUIFMenuItemSeparator
//
/*============================================================================*/


/*------------------------------------------------------------------------------

   OnPaint

------------------------------------------------------------------------------*/
void CUIFMenuItemSeparator::OnPaint(HDC hDC)
{
    if (_pMenu->IsO10Menu())
       OnPaintO10(hDC);
    else
       OnPaintDef(hDC);
}

/*------------------------------------------------------------------------------

   OnPaintDef

------------------------------------------------------------------------------*/
void CUIFMenuItemSeparator::OnPaintDef(HDC hDC)
{
    if (!m_pUIFScheme)
        return;

    int xAlign = 2;
    int yAlign = (GetRectRef().bottom - GetRectRef().top - 2) / 2;
    int cx = (GetRectRef().right - GetRectRef().left - 2 * xAlign);

    RECT rc;
    ::SetRect(&rc,
              GetRectRef().left + xAlign,
              GetRectRef().top + yAlign,
              GetRectRef().left + xAlign + cx, 
              GetRectRef().top + yAlign + 2);

    m_pUIFScheme->DrawMenuSeparator( hDC, &rc);
}


/*------------------------------------------------------------------------------

   OnPaintO10
    
------------------------------------------------------------------------------*/
void CUIFMenuItemSeparator::OnPaintO10(HDC hDC)
{
    if (!m_pUIFScheme)
        return;

    int xAlign = 2;
    int yAlign = (GetRectRef().bottom - GetRectRef().top - 2) / 2;
    int cx = (GetRectRef().right - GetRectRef().left - 2 * xAlign);
    int xStart = 0;
    RECT rc;

    GetRect(&rc);
    rc.right = rc.left + _pMenu->GetMenuCheckWidth() + 2;
    if (_pMenu->IsBmpCheckItem())
        rc.right += _pMenu->GetMenuCheckWidth();

    ::FillRect(hDC, &rc, m_pUIFScheme->GetBrush(UIFCOLOR_CTRLBKGND));
    xStart = _pMenu->GetMenuCheckWidth() + 2;

    ::SetRect(&rc,
              GetRectRef().left + xAlign + xStart, 
              GetRectRef().top + yAlign,
              GetRectRef().left + xAlign + cx, 
              GetRectRef().top + yAlign + 1);

    m_pUIFScheme->DrawMenuSeparator( hDC, &rc);
}

/*------------------------------------------------------------------------------

   InitMenuExtent

------------------------------------------------------------------------------*/
void CUIFMenuItemSeparator::InitMenuExtent()
{
    _size.cx = 0;
    _size.cy = 6;
}

/*============================================================================*/
//
//    CUIFMenu
//
/*============================================================================*/

/*------------------------------------------------------------------------------

   ctor

------------------------------------------------------------------------------*/
CUIFMenu::CUIFMenu(HINSTANCE hInst, DWORD dwWndStyle, DWORD dwMenuStyle) : CUIFWindow(hInst, dwWndStyle)
{
    _uIdSelect = CUI_MENU_UNSELECTED;
    _dwMenuStyle = dwMenuStyle;

    SetMenuFont();
}

/*------------------------------------------------------------------------------

   dtor

------------------------------------------------------------------------------*/
CUIFMenu::~CUIFMenu( void )
{
    int i;
    for (i = 0; i < _rgItems.GetCount(); i++)
    {
        CUIFMenuItem *pItem = _rgItems.Get(i);
        delete pItem;
    }
    DeleteObject(_hfontMarlett);
    ClearMenuFont();
}

/*------------------------------------------------------------------------------

   InsertItem

------------------------------------------------------------------------------*/
BOOL CUIFMenu::InsertItem(CUIFMenuItem *pItem)
{
    if (!_rgItems.Add( pItem ))
        return FALSE;

    pItem->SetFont(GetFont());
    return TRUE;
}

/*------------------------------------------------------------------------------

   InsertSeparator

------------------------------------------------------------------------------*/
BOOL CUIFMenu::InsertSeparator()
{
    CUIFMenuItemSeparator *pSep;

    pSep = new CUIFMenuItemSeparator(this);
    if (!pSep)
        return FALSE;

    pSep->Initialize();

    if (!_rgItems.Add( pSep ))
    {
        delete pSep;
        return FALSE;
    }

    return TRUE;
}

/*------------------------------------------------------------------------------

   ShowModalPopup

------------------------------------------------------------------------------*/
UINT CUIFMenu::ShowModalPopup(CUIFWindow *pcuiWndParent, const RECT *prc, BOOL fVertical)
{
    UINT uId;
    CUIFObject *puicap;

    if (pcuiWndParent)
    {
        puicap = pcuiWndParent->GetCaptureObject();
        pcuiWndParent->SetCaptureObject(NULL);
    }

    if (InitShow(pcuiWndParent, prc, fVertical, TRUE)) {
        _fInModal = TRUE;
        pcuiWndParent->SetBehindModal(this);

        ModalMessageLoop();

        uId = _uIdSelect;
        pcuiWndParent->SetBehindModal(NULL);
        _fInModal = FALSE;
    }
    else 
    {
        uId = CUI_MENU_UNSELECTED;
    }

    UninitShow();

    if (pcuiWndParent)
    {
        pcuiWndParent->SetCaptureObject(puicap);
    }

    return uId;
}


/*------------------------------------------------------------------------------

    ModalMessageLoop

------------------------------------------------------------------------------*/
void CUIFMenu::ModalMessageLoop( void )
{
    MSG msg;

    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (msg.message == WM_NULL)
            break;

        if (msg.hwnd != GetWnd())
        {
            if ((msg.message > WM_MOUSEFIRST) &&
                (msg.message <= WM_MOUSELAST))
            {
                break;
            }
        }

        //
        // Dispatch key message to Sub menu.
        //
        if ((msg.message >= WM_KEYFIRST) &&
            (msg.message <= WM_KEYLAST))
        {
            if (!msg.hwnd)
            {
                CUIFMenu *pSubMenu = GetTopSubMenu();
                msg.hwnd = pSubMenu->GetWnd();
            }
        }


        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}


/*------------------------------------------------------------------------------

   InitShow

------------------------------------------------------------------------------*/
BOOL CUIFMenu::InitShow(CUIFWindow *pcuiWndParent, const RECT *prc, BOOL fVertical, BOOL fAnimate)
{
    int i;
    int cxMax = 0;
    SIZE size = {0, 0};
    RECT rc = {0, 0, 0, 0};
    RECT rcScreen;
    HMONITOR hMonitor;
    CUIFMenuItem *pItem;
    BOOL fMenuAnimation = FALSE;
    BOOL fAnimated      = FALSE;
    DWORD dwSlideFlag   = 0;
    int x;
    int y;


    CreateWnd((pcuiWndParent != NULL) ? pcuiWndParent->GetWnd() : NULL);

    _fIsBmpCheckItem = FALSE;

    for (i = 0; i < _rgItems.GetCount(); i++)
    {
        pItem = _rgItems.Get(i);
        pItem->InitMenuExtent();
    }

    _cxMaxTab = 0;
    for (i = 0; i < _rgItems.GetCount(); i++)
    {
        pItem = _rgItems.Get(i);

        pItem->GetMenuExtent(&size);

        size.cx += GetMenuCheckWidth();

        cxMax = (size.cx > cxMax) ? size.cx : cxMax;
        _cxMaxTab = (pItem->GetTabTextLength() > _cxMaxTab) ? 
                    pItem->GetTabTextLength() : 
                    _cxMaxTab;

        _fIsBmpCheckItem |= (pItem->IsBmp() && pItem->IsCheck()) ? TRUE : FALSE;
    }

    for (i = 0; i < _rgItems.GetCount(); i++)
    {
        pItem = _rgItems.Get(i);

        pItem->GetMenuExtent(&size);

        rc.right = rc.left + cxMax + _cxMaxTab;
        rc.bottom = rc.top + size.cy;
        pItem->SetRect(&rc);
        rc.top += size.cy;

        AddUIObj(pItem);
    }

    rc.top = 0;
    LONG_PTR dwStyle = GetWindowLongPtr(GetWnd(), GWL_STYLE);

    int nWidth = rc.right;
    int nHeight = rc.bottom;


    if (dwStyle & WS_DLGFRAME)
    {
        nWidth += GetSystemMetrics(SM_CXDLGFRAME) * 2;
        nHeight += GetSystemMetrics(SM_CYDLGFRAME) * 2;
    }
    else if (dwStyle & WS_BORDER)
    {
        nWidth += GetSystemMetrics(SM_CXBORDER) * 2;
        nHeight += GetSystemMetrics(SM_CYBORDER) * 2;
    }

    ::SetRect( &rcScreen, 0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN) );
    RECT rcT;
    rcT = *prc;
    hMonitor = CUIMonitorFromRect( &rcT, MONITOR_DEFAULTTONEAREST );
    if (hMonitor != NULL) {
        MONITORINFO MonitorInfo = {0};

        MonitorInfo.cbSize = sizeof(MONITORINFO);
        if (CUIGetMonitorInfo( hMonitor, &MonitorInfo )) {
            rcScreen = MonitorInfo.rcMonitor;
        }
    }

    if (FHasStyle( UIWINDOW_LAYOUTRTL ))
        rc.left -= nWidth;

    if (fVertical)
    {
        x = rc.left + prc->left;
        if (rc.top + prc->bottom + nHeight <= rcScreen.bottom)
        {
            y = rc.top + prc->bottom;
            dwSlideFlag  = AW_VER_POSITIVE;
        }
        else
        {
            y = rc.top + prc->top - nHeight;
            dwSlideFlag  = AW_VER_NEGATIVE;
        }

        if (rc.left + prc->right + nWidth > rcScreen.right)
            x = rcScreen.right - nWidth;
    }
    else
    {
        y = rc.top + prc->top;
        if (rc.left + prc->right + nWidth <= rcScreen.right)
        {
            x = rc.left + prc->right;
            dwSlideFlag  = AW_HOR_POSITIVE;
        }
        else
        {
            x = rc.left + prc->left - nWidth;
            dwSlideFlag  = AW_HOR_NEGATIVE;
        }

        if (rc.top + prc->bottom + nHeight > rcScreen.bottom)
            y = rcScreen.bottom - nHeight;
    }


    x = min( rcScreen.right - nWidth, x );
    x = max( rcScreen.left, x );
    y = min( rcScreen.bottom - nHeight, y );
    y = max( rcScreen.top, y );
    Move(x, y, nWidth, nHeight);

    SetRect(NULL);

    // animation support

    fAnimated = FALSE;
    if (fAnimate) {
        if (SystemParametersInfo( SPI_GETMENUANIMATION, 0, &fMenuAnimation, FALSE ) && fMenuAnimation) {
            BOOL  fFade = FALSE;
            DWORD dwFlags;

            if (!SystemParametersInfo( SPI_GETMENUFADE, 0, &fFade, FALSE )) {
                fFade = FALSE;
            }

            // determine animation flag

            if (fFade) {
                dwFlags = AW_BLEND;
            }
            else {
                dwFlags = AW_SLIDE | dwSlideFlag;
            }

            fAnimated = AnimateWnd( 200, dwFlags );
        }
    }
    if (!fAnimated) {
        Show(TRUE);
    }

    if (_pcuiParentMenu)
        _pcuiParentMenu->_pCurrentSubMenu = this;

    return TRUE;
}

/*------------------------------------------------------------------------------

   UninitShow

------------------------------------------------------------------------------*/
BOOL CUIFMenu::UninitShow()
{
    int i;

    if (_pCurrentSubMenu)
        _pCurrentSubMenu->UninitShow();

    Show(FALSE);

    if (_pcuiParentMenu)
        _pcuiParentMenu->_pCurrentSubMenu = NULL;


    for (i = 0; i < _rgItems.GetCount(); i++)
        RemoveUIObj(_rgItems.Get(i));

    DestroyWindow(GetWnd());


    return TRUE;
}

/*------------------------------------------------------------------------------

   ShowSubPopup

------------------------------------------------------------------------------*/
void CUIFMenu::ShowSubPopup(CUIFMenu *pcuiParentMenu, const RECT *prc, BOOL fVertical)
{
    _pcuiParentMenu = pcuiParentMenu;
    InitShow(pcuiParentMenu, prc, fVertical, TRUE);    // TODO: fAnimate = FALSE if submenu has already been shown, or going to be changed contibuously
}

/*------------------------------------------------------------------------------

   OnLButtonUp

------------------------------------------------------------------------------*/
void CUIFMenu::HandleMouseMsg( UINT uMsg, POINT pt )
{
    if (!PtInRect(&GetRectRef(), pt))
    {
        if ((uMsg == WM_LBUTTONDOWN) || (uMsg == WM_RBUTTONDOWN) ||
            (uMsg == WM_LBUTTONUP) || (uMsg == WM_RBUTTONUP))
        {
            SetSelectedId(CUI_MENU_UNSELECTED);
            PostMessage(GetWnd(), WM_NULL, 0, 0);
        }
    }

    CUIFWindow::HandleMouseMsg( uMsg, pt );
}

/*------------------------------------------------------------------------------

   CancelMenu

------------------------------------------------------------------------------*/
void CUIFMenu::CancelMenu()
{
    if (_pcuiParentMenu)
    {
        UninitShow();
        return;
    }

    if (!_fInModal)
        return;

    SetSelectedId(CUI_MENU_UNSELECTED);
    PostMessage(GetWnd(), WM_NULL, 0, 0);
}

/*------------------------------------------------------------------------------

   CancelMenu

------------------------------------------------------------------------------*/
void CUIFMenu::SetSelectedId(UINT uId)
{
    if (_pcuiParentMenu)
    {
        _pcuiParentMenu->SetSelectedId(uId);
        return;
    }
    _uIdSelect = uId;
}

/*------------------------------------------------------------------------------

   GetTopSubMenu

------------------------------------------------------------------------------*/
CUIFMenu *CUIFMenu::GetTopSubMenu()
{
    if (_pCurrentSubMenu)
        return _pCurrentSubMenu->GetTopSubMenu();

    return this;
}

/*------------------------------------------------------------------------------

   PostKey

------------------------------------------------------------------------------*/
void CUIFMenu::PostKey(BOOL fUp, WPARAM wParam, LPARAM lParam)
{
    if (!_fInModal)
        return;

    if (fUp)
        PostMessage(0, WM_KEYUP, wParam, lParam);
    else
        PostMessage(0, WM_KEYDOWN, wParam, lParam);
}

/*------------------------------------------------------------------------------

   ModalMouseNotify

------------------------------------------------------------------------------*/
void CUIFMenu::ModalMouseNotify( UINT uMsg, POINT pt)
{
    if ((uMsg == WM_LBUTTONDOWN) || (uMsg == WM_RBUTTONDOWN))
        CancelMenu();
}

/*------------------------------------------------------------------------------

   OnKeyDown

------------------------------------------------------------------------------*/
void CUIFMenu::OnKeyDown(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    UINT uVKey = (UINT)wParam & 0xff;
    CUIFMenuItem *pItem;

    switch (uVKey)
    {
         case VK_ESCAPE:
            CancelMenu();
            break;

         case VK_UP:
            pItem = GetPrevItem(_pSelectedItem);
            goto MoveToItem;

         case VK_DOWN:
            pItem = GetNextItem(_pSelectedItem);
MoveToItem:
            SetSelectedItem(pItem);
            break;

         case VK_RIGHT:
            if (_pSelectedItem && _pSelectedItem->GetSub())
            {
                _pSelectedItem->ShowSubPopup();
                CUIFMenu *pSubMenu = _pSelectedItem->GetSub();
                CUIFMenuItem *pSubMenuItem = pSubMenu->GetNextItem(NULL);
                pSubMenu->SetSelectedItem(pSubMenuItem);
            }
            break;

         case VK_LEFT:
            if (_pcuiParentMenu)
                CancelMenu();
            break;

         case VK_RETURN:
DoReturn:
            if (_pSelectedItem)
            {
                if (_pSelectedItem->IsGrayed())
                    break;

                if (_pSelectedItem->GetSub())
                {
                    _pSelectedItem->ShowSubPopup();
                    CUIFMenu *pSubMenu = _pSelectedItem->GetSub();
                    CUIFMenuItem *pSubMenuItem = pSubMenu->GetNextItem(NULL);
                    pSubMenu->SetSelectedItem(pSubMenuItem);
                }
                else
                {
                    SetSelectedId(_pSelectedItem->GetId());
                    PostMessage(GetWnd(), WM_NULL, 0, 0);
                }
            }
            else
            { 
                CancelMenu();
            }
            break;

         default:
            if ((uVKey >= 'A' && uVKey <= 'Z') ||
                (uVKey >= '0' && uVKey <= '9'))
            {
                int nCnt = _rgItems.GetCount();
                int i;
                for (i = 0; i < nCnt; i++)
                {
                    pItem = _rgItems.Get(i);
                    Assert(PtrToInt(pItem));
                    if (pItem->GetVKey() == uVKey)
                    {
                        SetSelectedItem(pItem);
                        goto DoReturn;
                    }
                }
            }
            break;

    }
}

/*------------------------------------------------------------------------------

   OnKeyUp

------------------------------------------------------------------------------*/
void CUIFMenu::OnKeyUp(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
}

/*------------------------------------------------------------------------------

   GetNextItem

------------------------------------------------------------------------------*/
CUIFMenuItem *CUIFMenu::GetNextItem(CUIFMenuItem *pItem)
{
    int nCnt = _rgItems.GetCount();
    CUIFMenuItem *pItemTmp;
    int i;

    if (!nCnt)
        return NULL;

    if (!_pSelectedItem)
        return _rgItems.Get(0);

    for (i = 0; i < nCnt; i++)
    {
        pItemTmp = _rgItems.Get(i);
        Assert(PtrToInt(pItemTmp));

        if (pItem == pItemTmp)
        {
            i++;
            break;
        }
    }

    if (i == nCnt)
        i = 0;

    pItemTmp = _rgItems.Get(i);
    while (pItemTmp && pItemTmp->IsNonSelectedItem())
    {
        i++;
        if (i == nCnt)
            i = 0;
        pItemTmp = _rgItems.Get(i);
    }

    return pItemTmp;
}

/*------------------------------------------------------------------------------

   GetPrevItem

------------------------------------------------------------------------------*/
CUIFMenuItem *CUIFMenu::GetPrevItem(CUIFMenuItem *pItem)
{
    int nCnt = _rgItems.GetCount();
    CUIFMenuItem *pItemTmp = NULL;
    int i;

    if (!nCnt)
        return NULL;

    if (!_pSelectedItem)
        return _rgItems.Get(nCnt - 1);

    for (i = nCnt - 1; i >= 0; i--)
    {
        pItemTmp = _rgItems.Get(i);
        Assert(PtrToInt(pItemTmp));

        if (pItem == pItemTmp)
        {
            i--;
            break;
        }
    }

    if (i < 0)
        i = nCnt - 1;

    pItemTmp = _rgItems.Get(i);
    while (pItemTmp && pItemTmp->IsNonSelectedItem())
    {
        i--;
        if (i < 0)
            i = nCnt - 1;
        pItemTmp = _rgItems.Get(i);
    }

    return pItemTmp;
}

/*------------------------------------------------------------------------------

   SetMenuFont

------------------------------------------------------------------------------*/

void CUIFMenu::SetMenuFont()
{
    NONCLIENTMETRICS ncm;
    int nMarlettFontSize = 14;

    ncm.cbSize = sizeof(ncm);
    if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, FALSE))
    {
        HFONT hFont = CreateFontIndirect(&ncm.lfMenuFont);
        SetFont(hFont);
        nMarlettFontSize = (ncm.lfMenuFont.lfHeight > 0) ?
                            ncm.lfMenuFont.lfHeight :
                            -ncm.lfMenuFont.lfHeight;
        nMarlettFontSize = (ncm.iMenuHeight + nMarlettFontSize) / 2;
    }

    _hfontMarlett = CreateFont(nMarlettFontSize, 0, 0, 0, 400, FALSE, FALSE, FALSE, SYMBOL_CHARSET, 0, 0, 0, 0, "Marlett");

    _cxMenuCheck = nMarlettFontSize;

    int cxSmIcon = GetSystemMetrics( SM_CXSMICON );
    if (_cxMenuCheck < cxSmIcon)
        _cxMenuCheck = cxSmIcon;

    _cxMenuCheck += 2;
}

/*------------------------------------------------------------------------------

   ClearMenuFont

------------------------------------------------------------------------------*/

void CUIFMenu::ClearMenuFont()
{
    HFONT hFont = GetFont();
    SetFont(NULL);
    DeleteObject(hFont);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuiicon.h ===
//
// cuiicon.h
//

#ifndef CUIICON_H
#define CUIICON_H

#include "cuiutil.h"
#include "delay.h"
#include "osver.h"


//////////////////////////////////////////////////////////////////////////////
//
// CUIFIcon
//
// Substitue hIcon to support single imagelist.
//
// todo:
//   We want to share the imagelist in future.
//
//////////////////////////////////////////////////////////////////////////////

class CUIFIcon
{
public:
    CUIFIcon()
    {
        m_hIcon = NULL;
        m_himl = NULL;
        m_nimlId = 0;
    }

    ~CUIFIcon()
    {
        if (m_himl)
            ImageList_Destroy( m_himl );
    }

    const CUIFIcon& operator=(HICON hIcon)
    {
        m_hIcon = hIcon;
        if (m_himl)
        {
            ImageList_Destroy( m_himl );
            m_himl = NULL;
        }
 
        return *this;
    }

    operator HICON() {return m_hIcon;}

    HIMAGELIST GetImageList(BOOL fMirror) 
    {
        SIZE size;
        if (m_himl)
            return m_himl;

        if (!m_hIcon)
            return NULL;

        CUIGetIconSize( m_hIcon, &size );

        DWORD dwFlags = ILC_COLOR32 | ILC_MASK;
        if (fMirror && IsOnNT51())
            dwFlags |= ILC_MIRROR;

        m_himl = ImageList_Create(size.cx, size.cy, dwFlags, 1, 0);

        if (m_himl)
            ImageList_AddIcon( m_himl, m_hIcon );

        return m_himl;
    }
    int GetImageListId() {return m_nimlId;}

private:
    HICON m_hIcon;
    HIMAGELIST m_himl;
    int m_nimlId;
};

#endif CUIICON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuiobj.cpp ===
//
// cuiobj.cpp
//  = ui object library =
//

#include "private.h"
#include "delay.h"
#include "cuiobj.h"
#include "cuiwnd.h"
#include "cuitip.h"
#include "cmydc.h"
#include "cuiutil.h"
#include "cuitheme.h"


#define SCROLLTHUMBHEIGHT_MIN   6


/*   G E T  S C R O L L  D E L A Y   */
/*------------------------------------------------------------------------------

    Get delay time to start auto scroll (while the scroll button down)
    The time is in milli-second

------------------------------------------------------------------------------*/
__inline UINT GetScrollDelay( void )
{
    return (GetDoubleClickTime() * 4 / 5);
}


/*   G E T  S C R O L L  S P E E D   */
/*------------------------------------------------------------------------------

    Get repeat time in auto scroll (while the scroll button down)
    The time is in milli-second

------------------------------------------------------------------------------*/
__inline UINT GetScrollSpeed( void )
{
    return (GetScrollDelay() / 8);
}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  O B J E C T                                                     */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  O B J E C T   */
/*------------------------------------------------------------------------------

    Constructor of CUIFObject

------------------------------------------------------------------------------*/
CUIFObject::CUIFObject( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle )
{
    m_pParent = pParent;
    m_dwID    = dwID;
    m_dwStyle = dwStyle;

    ::SetRect( &m_rc, 0, 0, 0, 0 );
    if (prc != NULL) {
        m_rc = *prc;
    }

    m_pUIWnd = NULL;
    if (m_pParent != NULL) {
        m_pUIWnd = pParent->GetUIWnd();
    }

    m_pUIFScheme = NULL;
    if (m_pParent != NULL) {
        m_pUIFScheme = pParent->GetUIFScheme();
    }

    m_fEnabled = TRUE;
    m_fVisible = TRUE;
    m_hFont    = (HFONT)GetStockObject( DEFAULT_GUI_FONT );
    m_fUseCustomFont = FALSE;
    m_pwchToolTip = NULL;

    m_pointPreferredSize.x=m_pointPreferredSize.y=-1;

#if defined(_DEBUG) || defined(DEBUG)
    m_fInitialized = FALSE;
#endif /* DEBUG */
}


/*   ~  C  U I F  O B J E C T   */
/*------------------------------------------------------------------------------

    Destructor of CUIFObject

------------------------------------------------------------------------------*/
CUIFObject::~CUIFObject( void )
{
    CUIFObject *pUIObj;

#if defined(_DEBUG) || defined(DEBUG)
    Assert( m_fInitialized );
#endif /* DEBUG */

    // dispose buffer
    if (m_pUIWnd != NULL) {
        CUIFToolTip *pTipWnd = m_pUIWnd->GetToolTipWnd();
        if (pTipWnd && (this == pTipWnd->GetCurrentObj()))
            pTipWnd->ClearCurrentObj();
    }

    if (m_pwchToolTip != NULL) {
        delete m_pwchToolTip;
    }

    // delete children

    while (pUIObj = m_ChildList.GetLast()) {
        m_ChildList.Remove( pUIObj );
        delete pUIObj;
    }

    // to clear capture/timer/pointed status call RemoveUIObj of UIFrameWindow

    if (m_pUIWnd != NULL) {
        m_pUIWnd->RemoveUIObj( this );
    }
}


/*   I N I T I A L I Z E   */
/*------------------------------------------------------------------------------

    Inititalize the object
    Returns TRUE when succeed to initialize, FALSE when failed.
    This function MUST be called when create a object.

------------------------------------------------------------------------------*/
CUIFObject *CUIFObject::Initialize( void )
{
#if defined(_DEBUG) || defined(DEBUG)
    Assert( !m_fInitialized );
    m_fInitialized = TRUE;
#endif /* DEBUG */

    return this;
}


/*   C A L L  O N  P A I N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFObject::CallOnPaint( void )
{
    if (m_pUIWnd != NULL) {
        m_pUIWnd->UpdateUI(&GetRectRef());
    }
}

/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

    Paint procedure of button object

------------------------------------------------------------------------------*/
void CUIFObject::OnPaint( HDC hDC )
{
    BOOL fDefault = TRUE;

    if ((GetUIWnd()->GetStyle() & UIWINDOW_WHISTLERLOOK) != 0) {
        fDefault = !OnPaintTheme( hDC );
    }

    if (fDefault) {
        OnPaintNoTheme( hDC );
    }
}


/*   S T A R T  C A P T U R E   */
/*------------------------------------------------------------------------------

    Start capturing mouse

------------------------------------------------------------------------------*/
void CUIFObject::StartCapture( void )
{
    if (m_pUIWnd != NULL) {
        m_pUIWnd->SetCaptureObject( this );
    }
}


/*   E N D  C A P T U R E   */
/*------------------------------------------------------------------------------

    End capturing mouse

------------------------------------------------------------------------------*/
void CUIFObject::EndCapture( void )
{
    if (m_pUIWnd != NULL) {
        m_pUIWnd->SetCaptureObject( NULL );
    }
}


/*   S T A R T  T I M E R   */
/*------------------------------------------------------------------------------

    Make timer

------------------------------------------------------------------------------*/
void CUIFObject::StartTimer( UINT uElapse )
{
    if (m_pUIWnd != NULL) {
        m_pUIWnd->SetTimerObject( this, uElapse );
    }
}


/*   E N D  T I M E R   */
/*------------------------------------------------------------------------------

    Kill timer

------------------------------------------------------------------------------*/
void CUIFObject::EndTimer( void )
{
    if (m_pUIWnd != NULL) {
        m_pUIWnd->SetTimerObject( NULL );
    }
}


/*   I S  C A P T U R E   */
/*------------------------------------------------------------------------------

    Check if the object is capturing mouse

------------------------------------------------------------------------------*/
BOOL CUIFObject::IsCapture( void )
{
    if (m_pUIWnd != NULL) {
        return (m_pUIWnd->GetCaptureObject() == this);
    }

    return FALSE;
}


/*   I S  T I M E R   */
/*------------------------------------------------------------------------------

    Check if the object has timer

------------------------------------------------------------------------------*/
BOOL CUIFObject::IsTimer( void )
{
    if (m_pUIWnd != NULL) {
        return (m_pUIWnd->GetTimerObject() == this);
    }

    return FALSE;
}


/*   G E T  R E C T   */
/*------------------------------------------------------------------------------

    Get rectangle of object

------------------------------------------------------------------------------*/
void CUIFObject::GetRect( RECT *prc )
{
    *prc = GetRectRef();
}


/*   S E T  R E C T   */
/*------------------------------------------------------------------------------

    Set rectangle of object

------------------------------------------------------------------------------*/
void CUIFObject::SetRect( const RECT *prc )
{
    Assert(PtrToInt(prc));
    m_rc = *prc;

    if (m_pUIWnd != NULL) {
        m_pUIWnd->OnObjectMoved( this );
    }

    CallOnPaint();
}


/*   P T  I N  O B J E C T   */
/*------------------------------------------------------------------------------

    Check if point is in the object

------------------------------------------------------------------------------*/
BOOL CUIFObject::PtInObject( POINT pt )
{
    return m_fVisible && PtInRect( &GetRectRef(), pt );
}


/*   E N A B L E   */
/*------------------------------------------------------------------------------

    Enable/disable object

------------------------------------------------------------------------------*/
void CUIFObject::Enable( BOOL fEnable )
{
    if (m_fEnabled != fEnable) {
        int nChild;
        int i;

        m_fEnabled = fEnable;
        
        // enable/disable all children

        nChild = m_ChildList.GetCount();
        for (i = 0; i < nChild; i++) {
            CUIFObject *pUIObj = m_ChildList.Get( i );

            Assert( pUIObj != NULL );
            pUIObj->Enable( fEnable );
        }

        CallOnPaint();
    }
}


/*   S H O W   */
/*------------------------------------------------------------------------------

    Show/hide object

------------------------------------------------------------------------------*/
void CUIFObject::Show( BOOL fShow )
{
    if (m_fVisible != fShow) {
        int nChild;
        int i;

        m_fVisible = fShow;

        // show/hide all children

        nChild = m_ChildList.GetCount();
        for (i = 0; i < nChild; i++) {
            CUIFObject *pUIObj = m_ChildList.Get( i );

            Assert( pUIObj != NULL );
            pUIObj->Show( fShow );
        }

        // let parent paint the object when it's hidden

        if (!m_fVisible) {
            if (m_pParent != NULL) {
               m_pParent->CallOnPaint();
            }
        }
        else {
            CallOnPaint();
        }
    }
}


/*   S E T  F O N T   */
/*------------------------------------------------------------------------------

    Set font

------------------------------------------------------------------------------*/
void CUIFObject::SetFontToThis( HFONT hFont )
{
    if (hFont == NULL) {
        hFont = (HFONT)GetStockObject( DEFAULT_GUI_FONT );
        m_fUseCustomFont = FALSE;
    } else {
        m_fUseCustomFont = TRUE;
    }
    m_hFont = hFont;
}

/*   S E T  F O N T   */
/*------------------------------------------------------------------------------

    Set font

------------------------------------------------------------------------------*/
void CUIFObject::SetFont( HFONT hFont )
{
    int nChild;
    int i;

    SetFontToThis(hFont);

    // set font to all children

    nChild = m_ChildList.GetCount();
    for (i = 0; i < nChild; i++) {
        CUIFObject *pUIObj = m_ChildList.Get( i );

        Assert( pUIObj != NULL );
        pUIObj->SetFont( hFont );
    }

    CallOnPaint();
}


/*   S E T  S T Y L E   */
/*------------------------------------------------------------------------------

    Set the style of object

------------------------------------------------------------------------------*/
void CUIFObject::SetStyle( DWORD dwStyle )
{
    m_dwStyle = dwStyle;
}


/*   P A I N T  O B J E C T   */
/*------------------------------------------------------------------------------

    Paint object
    NOTE: Paint itself at first (actual paint is done in OnPaint()), and then
    paint all children if exist.

------------------------------------------------------------------------------*/
void CUIFObject::PaintObject( HDC hDC, const RECT *prcUpdate )
{
    int nChild;
    int i;

    if (prcUpdate == NULL) {
        prcUpdate = &GetRectRef();
    }

    if (m_fVisible) {
        // paint itself at first

        OnPaint( hDC );

        // paint all children

        nChild = m_ChildList.GetCount();
        for (i = 0; i < nChild; i++) {
            CUIFObject *pUIObj = m_ChildList.Get( i );
            RECT rcDest;

            Assert( pUIObj != NULL );
            if (IntersectRect( &rcDest, prcUpdate, &pUIObj->GetRectRef() )) {
                pUIObj->PaintObject( hDC, &rcDest );
            }
        }
    }
}


/*   A D D  U I  O B J   */
/*------------------------------------------------------------------------------

    Add child UI object

------------------------------------------------------------------------------*/
void CUIFObject::AddUIObj( CUIFObject *pUIObj )
{
    Assert( pUIObj != NULL );
    Assert( pUIObj->FInitialized() );

    if (m_ChildList.Add( pUIObj )) {
        CallOnPaint();
    }
}


/*   R E M O V E  U I  O B J   */
/*------------------------------------------------------------------------------

    Remove child UI object

------------------------------------------------------------------------------*/
void CUIFObject::RemoveUIObj( CUIFObject *pUIObj )
{
    Assert( pUIObj != NULL );

    if (m_ChildList.Remove( pUIObj )) {
        CallOnPaint();
    }
}


/*   O B J E C T  F R O M  P O I N T   */
/*------------------------------------------------------------------------------

    Get UI object from point
    Returns UI object which is under of the point.  If no UI object found,
    returns NULL.

------------------------------------------------------------------------------*/
CUIFObject *CUIFObject::ObjectFromPoint( POINT pt )
{
    CUIFObject *pUIObjFromPoint = NULL;

    if (PtInObject( pt )) {
        int nChild;
        int i;

        pUIObjFromPoint = this;

        nChild = m_ChildList.GetCount();
        for (i = 0; i < nChild; i++) {
            CUIFObject *pUIObj = m_ChildList.Get( i );
            CUIFObject *pUIObjFromPointChild = NULL;

            Assert( pUIObj != NULL );
            pUIObjFromPointChild = pUIObj->ObjectFromPoint( pt );
            if (pUIObjFromPointChild != NULL) {
                pUIObjFromPoint = pUIObjFromPointChild;
            }
        }
    }

    return pUIObjFromPoint;
}


/*   O N  O B J E C T  N O T I F Y     */
/*------------------------------------------------------------------------------

    Default handler: Send notification to the parent object
    This allows for heirarchies of objects administrated from the top.

------------------------------------------------------------------------------*/
LRESULT CUIFObject::OnObjectNotify( CUIFObject *pUIObj, DWORD dwCode, LPARAM lParam )
{
    LRESULT lResult = 0;

    if (m_pParent != NULL) {
        lResult = m_pParent->OnObjectNotify( pUIObj, dwCode, lParam );
    }

    return lResult;
}


/*   S E T  T O O L  T I P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFObject::SetToolTip( LPCWSTR pwchToolTip )
{
    if (m_pwchToolTip != NULL) {
        delete m_pwchToolTip;
        m_pwchToolTip = NULL;
    }

    if (pwchToolTip != NULL) {
        m_pwchToolTip = new WCHAR[ StrLenW( pwchToolTip ) + 1 ];
        if (m_pwchToolTip)
            StrCpyW( m_pwchToolTip, pwchToolTip );
    }
}


/*   G E T  T O O L  T I P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LPCWSTR CUIFObject::GetToolTip( void )
{
    return m_pwchToolTip;
}


/*   N O T I F Y  C O M M A N D   */
/*------------------------------------------------------------------------------

    Send notification to the parent object

------------------------------------------------------------------------------*/
LRESULT CUIFObject::NotifyCommand( DWORD dwCode, LPARAM lParam )
{
    LRESULT lResult = 0;

    if (m_pParent != NULL) {
        lResult = m_pParent->OnObjectNotify( this, dwCode, lParam );
    }

    return lResult;
}


/*   G E T  F O N T  H E I G H T   */
/*------------------------------------------------------------------------------

    Get the height of font set to the object

------------------------------------------------------------------------------*/
int CUIFObject::GetFontHeight( void )
{
    HDC hDC;
    HFONT hFontOld;
    TEXTMETRIC tm;

    hDC = GetDC( m_pUIWnd->GetWnd() );
    hFontOld = (HFONT)SelectObject( hDC, m_hFont );

    GetTextMetrics( hDC, &tm );

    SelectObject( hDC, hFontOld );
    ReleaseDC( m_pUIWnd->GetWnd(), hDC );

    return tm.tmHeight + tm.tmExternalLeading;
}


/*   G E T  U I F  C O L O R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
COLORREF CUIFObject::GetUIFColor( UIFCOLOR iCol )
{ 
    return (m_pUIFScheme != NULL) ? m_pUIFScheme->GetColor( iCol ) : RGB( 0, 0, 0 );
}


/*   G E T  U I F  B R U S H   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HBRUSH CUIFObject::GetUIFBrush( UIFCOLOR iCol )
{ 
    return (m_pUIFScheme != NULL) ? m_pUIFScheme->GetBrush( iCol ) : NULL; 
}

/*   D E T A C H W N D O B J   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFObject::DetachWndObj( void )
{
    if (m_pUIWnd != NULL) {
        CUIFToolTip *pTipWnd = m_pUIWnd->GetToolTipWnd();
        if (pTipWnd && (this == pTipWnd->GetCurrentObj()))
            pTipWnd->ClearCurrentObj();
        m_pUIWnd->RemoveUIObj( this );
    }
    m_pUIWnd = NULL;
}

/*   C L E A R W N D O B J */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFObject::ClearWndObj( void )
{
    int i;

    m_pUIWnd = NULL;

    for (i = 0; i < m_ChildList.GetCount(); i ++)
    {
        CUIFObject *pObj;
        pObj = m_ChildList.Get(i);
        if (pObj)
            pObj->ClearWndObj();
    }
}

/*   O N T H E M E C H A N G E D
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFObject::ClearTheme( void )
{
    int i;
    CloseThemeData();

    for (i = 0; i < m_ChildList.GetCount(); i ++)
    {
        CUIFObject *pObj;
        pObj = m_ChildList.Get(i);
        if (pObj)
            pObj->ClearTheme();
    }
}

/*   O N T H E M E C H A N G E D
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFObject::SetScheme(CUIFScheme *pUIFScheme)
{
    int i;
    m_pUIFScheme = pUIFScheme;; 

    for (i = 0; i < m_ChildList.GetCount(); i ++)
    {
        CUIFObject *pObj;
        pObj = m_ChildList.Get(i);
        if (pObj)
            pObj->SetScheme(pUIFScheme);
    }
}

/*   I S R T L  */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CUIFObject::IsRTL()
{
    if (!m_pUIWnd)
        return FALSE;

    if (!m_pUIWnd->FHasStyle( UIWINDOW_LAYOUTRTL ))
        return FALSE;

    return TRUE;
}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  B O R D E R                                                     */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  B O R D E R   */
/*------------------------------------------------------------------------------

    Constructor of  CUIFBorder

------------------------------------------------------------------------------*/
CUIFBorder::CUIFBorder( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFObject( pParent, dwID, prc, dwStyle )
{
}


/*   ~  C  U I F  B O R D E R   */
/*------------------------------------------------------------------------------

    Destructor of CUIFBorder

------------------------------------------------------------------------------*/
CUIFBorder::~CUIFBorder( void )
{
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

    Paint procedure of border object

------------------------------------------------------------------------------*/
void CUIFBorder::OnPaint( HDC hDC )
{
    RECT rc = GetRectRef();

    switch (m_dwStyle & UIBORDER_DIRMASK) {
        default:
        case UIBORDER_HORZ: {
            DrawEdge( hDC, &rc, EDGE_ETCHED, BF_TOP );
            break;
        }

        case UIBORDER_VERT: {
            DrawEdge( hDC, &rc, EDGE_ETCHED, BF_LEFT );
            break;
        }
    }
}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  S T A T I C                                                     */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  S T A T I C   */
/*------------------------------------------------------------------------------

    Constructor of CUIFStatic

------------------------------------------------------------------------------*/
CUIFStatic::CUIFStatic( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFObject( pParent, dwID, prc, dwStyle )
{
    m_pwchText = NULL;
}


/*   ~  C  U I F  S T A T I C   */
/*------------------------------------------------------------------------------

    Destructor of CUIFStatic

------------------------------------------------------------------------------*/
CUIFStatic::~CUIFStatic( void )
{
    if (m_pwchText != NULL) {
        delete m_pwchText;
    }
}


/*   S E T  T E X T   */
/*------------------------------------------------------------------------------

    Set text to display

------------------------------------------------------------------------------*/
void CUIFStatic::SetText( LPCWSTR pwchText )
{
    if (m_pwchText != NULL) {
        delete m_pwchText;
        m_pwchText = NULL;
    }

    if (pwchText != NULL) {
        int cwch = StrLenW( pwchText ) + 1;

        m_pwchText = new WCHAR[ cwch ];
        if (m_pwchText)
            MemCopy( m_pwchText, pwchText, cwch * sizeof(WCHAR) );
    }

    // update window

    CallOnPaint();
}


/*   G E T  T E X T   */
/*------------------------------------------------------------------------------

    Get text

------------------------------------------------------------------------------*/
int CUIFStatic::GetText( LPWSTR pwchBuf, int cwchBuf )
{
    int cwchText = (m_pwchText == NULL) ? 0 : StrLenW(m_pwchText);

    if (cwchBuf <= 0) {
        // return text length in cwch (not including null-terminater)

        return cwchText;
    }
    else if (pwchBuf == NULL) {
        // return error code

        return (-1);
    }

    if (0 < cwchText) {
        cwchText = min( cwchText, cwchBuf-1 );
        MemCopy( pwchBuf, m_pwchText, cwchText * sizeof(WCHAR) );
        *(pwchBuf + cwchText) = L'\0';      // always null terminate
    }

    return cwchText;
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

    Paint procedure of static object

------------------------------------------------------------------------------*/
void CUIFStatic::OnPaint( HDC hDC )
{
    HFONT hFontOld;
    int xAlign;
    int yAlign;
    SIZE size;
    int cwch;

    if (m_pwchText == NULL) {
        return;
    }

    cwch = StrLenW(m_pwchText);

    // prepare objects

    hFontOld= (HFONT)SelectObject( hDC, GetFont() );

    // calc alignment

    GetTextExtentPointW( hDC, m_pwchText, cwch, &size );
    switch (m_dwStyle & UISTATIC_HALIGNMASK) {
        case UISTATIC_LEFT:
        default: {
            xAlign = 0;
            break;
        }

        case UISTATIC_CENTER: {
            xAlign = (GetRectRef().right - GetRectRef().left - size.cx) / 2;
            break;
        }

        case UISTATIC_RIGHT: {
            xAlign = GetRectRef().right - GetRectRef().left - size.cx;
            break;
        }
    }

    switch (m_dwStyle & UISTATIC_VALIGNMASK) {
        case UISTATIC_TOP:
        default: {
            yAlign = 0;
            break;
        }

        case UISTATIC_VCENTER: {
            yAlign = (GetRectRef().bottom - GetRectRef().top - size.cy) / 2;
            break;
        }

        case UISTATIC_BOTTOM: {
            yAlign = GetRectRef().bottom - GetRectRef().top - size.cy;
            break;
        }
    }

    // draw

    SetBkMode( hDC, TRANSPARENT );
    if (IsEnabled()) {
        SetTextColor( hDC, GetSysColor(COLOR_BTNTEXT) );
        CUIExtTextOut( hDC,
                    GetRectRef().left + xAlign,
                    GetRectRef().top + yAlign,
                    ETO_CLIPPED,
                    &GetRectRef(),
                    m_pwchText,
                    cwch,
                    NULL );
    }
    else {
        SetTextColor( hDC, GetSysColor(COLOR_3DHIGHLIGHT) );
        CUIExtTextOut( hDC,
                    GetRectRef().left + xAlign + 1,
                    GetRectRef().top + yAlign + 1,
                    ETO_CLIPPED,
                    &GetRectRef(),
                    m_pwchText,
                    cwch,
                    NULL );

        SetTextColor( hDC, GetSysColor(COLOR_3DSHADOW) );
        CUIExtTextOut( hDC,
                    GetRectRef().left + xAlign,
                    GetRectRef().top + yAlign,
                    ETO_CLIPPED,
                    &GetRectRef(),
                    m_pwchText,
                    cwch,
                    NULL );
    }

    // restore objects

    SelectObject( hDC, hFontOld);
}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  B U T T O N                                                     */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  B U T T O N   */
/*------------------------------------------------------------------------------

    Constructor of CUIFButton

------------------------------------------------------------------------------*/
CUIFButton::CUIFButton( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFObject( pParent, dwID, prc, dwStyle )
{
    m_dwStatus = UIBUTTON_NORMAL;
    m_fToggled = FALSE;

    m_hIcon    = NULL;
    m_hBmp     = NULL;
    m_hBmpMask = NULL;
    m_pwchText = NULL;
}


/*   ~  C  U I F  B U T T O N   */
/*------------------------------------------------------------------------------

    Destructor of CUIFButton

------------------------------------------------------------------------------*/
CUIFButton::~CUIFButton( void )
{
    if (m_pwchText != NULL) {
        delete m_pwchText;
    }
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

    Paint procedure of button object

------------------------------------------------------------------------------*/
void CUIFButton::OnPaintNoTheme( HDC hDC )
{
    BOOL fDownFace;

    // erase face at first

    FillRect( hDC, &GetRectRef(), (HBRUSH)(COLOR_3DFACE + 1) );
#ifndef UNDER_CE
    if (m_fToggled && (m_dwStatus == UIBUTTON_NORMAL || m_dwStatus == UIBUTTON_DOWNOUT)) {
        RECT rc;
        HBRUSH hBrush;
        COLORREF colTextOld;
        COLORREF colBackOld;

        hBrush = CreateDitherBrush();
        if (hBrush)
        {
            colTextOld = SetTextColor( hDC, GetSysColor(COLOR_3DFACE) );
            colBackOld = SetBkColor( hDC, GetSysColor(COLOR_3DHILIGHT) );

            rc = GetRectRef();
            InflateRect( &rc, -2, -2 );
            FillRect( hDC, &rc, hBrush );

            SetTextColor( hDC, colTextOld );
            SetBkColor( hDC, colBackOld );
            DeleteObject( hBrush );
        }
    }
#endif /* !UNDER_CE */

    // draw face

    fDownFace = m_fToggled || (m_dwStatus == UIBUTTON_DOWN);

    if (m_hBmp != NULL) {
        DrawBitmapProc( hDC, &GetRectRef(), fDownFace );
    }
    else if (m_hIcon != NULL) {
        DrawIconProc( hDC, &GetRectRef(), fDownFace );
    }
    else {
        DrawTextProc( hDC, &GetRectRef(), fDownFace );
    }

    // draw button edge

    if (m_fToggled) {
      DrawEdgeProc( hDC, &GetRectRef(), TRUE );
    }
    else {
        switch (m_dwStatus) {
            case UIBUTTON_DOWN: {
                DrawEdgeProc( hDC, &GetRectRef(), TRUE );
                break;
            }

            case UIBUTTON_HOVER:
            case UIBUTTON_DOWNOUT: {
                DrawEdgeProc( hDC, &GetRectRef(), FALSE );
                break;
            }
        }
    }
}


/*   O N  L B U T T O N  D O W N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFButton::OnLButtonDown( POINT pt )
{
    SetStatus( UIBUTTON_DOWN );
    StartCapture();

    switch (m_dwStyle & UIBUTTON_TYPEMASK) {
        default:
        case UIBUTTON_PUSH: {
            break;
        }

        case UIBUTTON_TOGGLE: {
            break;
        }

        case UIBUTTON_PUSHDOWN: {
            NotifyCommand( UIBUTTON_PRESSED, 0 );
            break;
        }
    }
}


/*   O N  L B U T T O N  U P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFButton::OnLButtonUp( POINT pt )
{
    BOOL fCaptured = IsCapture();

    if (fCaptured) {
        EndCapture();
    }

    switch (m_dwStyle & UIBUTTON_TYPEMASK) {
        default:
        case UIBUTTON_PUSH: {
            if (PtInObject( pt )) {
                SetStatus( UIBUTTON_HOVER );
                NotifyCommand( UIBUTTON_PRESSED, 0 );
            }
            else {
                SetStatus( UIBUTTON_NORMAL );
            }
            break;
        }

        case UIBUTTON_TOGGLE: {
            if (PtInObject( pt )) {
                SetStatus( UIBUTTON_HOVER );

                if (fCaptured) {
                    m_fToggled = !m_fToggled;
                    NotifyCommand( UIBUTTON_PRESSED, 0 );
                }
            }
            else {
                SetStatus( UIBUTTON_NORMAL );
            }
            break;
        }

        case UIBUTTON_PUSHDOWN: {
            SetStatus( UIBUTTON_NORMAL );
            break;
        }
    }
}


/*   O N  M O U S E  I N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFButton::OnMouseIn( POINT pt )
{
    switch (m_dwStyle & UIBUTTON_TYPEMASK) {
        default:
        case UIBUTTON_PUSH: {
            SetStatus( IsCapture() ? UIBUTTON_DOWN : UIBUTTON_HOVER );
            break;
        }

        case UIBUTTON_TOGGLE: {
            SetStatus( IsCapture() ? UIBUTTON_DOWN : UIBUTTON_HOVER );
            break;
        }

        case UIBUTTON_PUSHDOWN: {
            SetStatus( IsCapture() ? UIBUTTON_NORMAL : UIBUTTON_HOVER );
            break;
        }
    }
}


/*   O N  M O U S E  O U T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFButton::OnMouseOut( POINT pt )
{
    switch (m_dwStyle & UIBUTTON_TYPEMASK) {
        default:
        case UIBUTTON_PUSH: {
            SetStatus( IsCapture() ? UIBUTTON_DOWNOUT : UIBUTTON_NORMAL );
            break;
        }

        case UIBUTTON_TOGGLE: {
            SetStatus( IsCapture() ? UIBUTTON_DOWNOUT : UIBUTTON_NORMAL );
            break;
        }

        case UIBUTTON_PUSHDOWN: {
            SetStatus( UIBUTTON_NORMAL );
            break;
        }
    }
}


/*   E N A B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFButton::Enable( BOOL fEnable )
{
    CUIFObject::Enable( fEnable );
    if (!IsEnabled()) {
        SetStatus( UIBUTTON_NORMAL );

        if (IsCapture()) {
            EndCapture();
        }
    }
}


/*   D R A W  E D G E  P R O C   */
/*------------------------------------------------------------------------------

    Draw button edge

------------------------------------------------------------------------------*/
void CUIFButton::DrawEdgeProc( HDC hDC, const RECT *prc, BOOL fDown )
{
    RECT rc = *prc;
    DrawEdge( hDC, &rc, fDown ? BDR_SUNKENOUTER : BDR_RAISEDINNER, BF_RECT );
}


/*   S E T  T E X T   */
/*------------------------------------------------------------------------------

    Set text of button face

------------------------------------------------------------------------------*/
void CUIFButton::SetText( LPCWSTR psz )
{
    if (m_pwchText != NULL) {
        delete m_pwchText;
        m_pwchText = NULL;
    }

    // 
    //  init size;
    // 
    MemSet(&m_sizeText, 0, sizeof(SIZE));

    if (psz != NULL) 
    {
        int cwch = StrLenW( psz ) + 1;

        m_pwchText = new WCHAR[ cwch ];
        if (!m_pwchText)
            return;

        MemCopy( m_pwchText, psz, cwch * sizeof(WCHAR) );
        GetTextSize( m_pwchText, &m_sizeText );
    }

    // update window

    CallOnPaint();
}


/*   S E T  I C O N   */
/*------------------------------------------------------------------------------

    Set icon of button face

------------------------------------------------------------------------------*/
void CUIFButton::SetIcon( HICON hIcon )
{
    m_hIcon = hIcon;
    if (m_hIcon)
        GetIconSize(m_hIcon, &m_sizeIcon);
    else
        MemSet(&m_sizeIcon, 0, sizeof(SIZE));
    CallOnPaint();
}


/*   S E T  I C O N   */
/*------------------------------------------------------------------------------

    Set icon of button face

------------------------------------------------------------------------------*/
void CUIFButton::SetIcon( LPCTSTR lpszResName )
{
    SetIcon( LoadIcon( m_pUIWnd->GetInstance(), lpszResName ) );
}


/*   S E T  B I T M A P   */
/*------------------------------------------------------------------------------

    Set bitmap of button face

------------------------------------------------------------------------------*/
void CUIFButton::SetBitmap( HBITMAP hBmp )
{
    m_hBmp = hBmp;
    if (m_hBmp)
        GetBitmapSize(m_hBmp, &m_sizeBmp);
    else
        MemSet(&m_sizeBmp, 0, sizeof(SIZE));
    CallOnPaint();
}


/*   S E T  B I T M A P   */
/*------------------------------------------------------------------------------

    Set bitmap of button face

------------------------------------------------------------------------------*/
void CUIFButton::SetBitmap( LPCTSTR lpszResName )
{
    SetBitmap( LoadBitmap( m_pUIWnd->GetInstance(), lpszResName ) );
}

/*   S E T  B I T M A P M A S K  */
/*------------------------------------------------------------------------------

    Set bitmap of button face

------------------------------------------------------------------------------*/
void CUIFButton::SetBitmapMask( HBITMAP hBmp )
{
    m_hBmpMask = hBmp;

    CallOnPaint();
}


/*   S E T  B I T M A P   */
/*------------------------------------------------------------------------------

    Set bitmap of button face

------------------------------------------------------------------------------*/
void CUIFButton::SetBitmapMask( LPCTSTR lpszResName )
{
    SetBitmapMask( LoadBitmap( m_pUIWnd->GetInstance(), lpszResName ) );
}


/*   D R A W  T E X T  P R O C   */
/*------------------------------------------------------------------------------

    Draw text on button face

------------------------------------------------------------------------------*/
void CUIFButton::DrawTextProc( HDC hDC, const RECT *prc, BOOL fDown )
{
    int nDownPad = fDown ? 1 : 0;
    int xAlign;
    int yAlign;
    SIZE size;
    HFONT hFontOld;

    //

    if (m_pwchText == NULL) {
        return;
    }

    //

    hFontOld = (HFONT)SelectObject( hDC, GetFont() );

    // calc text width

    CUIGetTextExtentPoint32( hDC, m_pwchText, StrLenW(m_pwchText), &size );
    switch (m_dwStyle & UIBUTTON_HALIGNMASK) {
        case UIBUTTON_LEFT:
        default: {
            xAlign = 0;
            break;
        }

        case UIBUTTON_CENTER: {
            xAlign = (GetRectRef().right - GetRectRef().left - size.cx) / 2;
            break;
        }

        case UIBUTTON_RIGHT: {
            xAlign = GetRectRef().right - GetRectRef().left - size.cx;
            break;
        }
    }

    switch (m_dwStyle & UIBUTTON_VALIGNMASK) {
        case UIBUTTON_TOP:
        default: {
            yAlign = 0;
            break;
        }

        case UIBUTTON_VCENTER: {
            yAlign = (GetRectRef().bottom - GetRectRef().top - size.cy) / 2;
            break;
        }

        case UIBUTTON_BOTTOM: {
            yAlign = GetRectRef().bottom - GetRectRef().top - size.cy;
            break;
        }
    }

    //

    SetBkMode( hDC, TRANSPARENT );
    if (IsEnabled()) {
        SetTextColor( hDC, GetSysColor(COLOR_BTNTEXT) );
        CUIExtTextOut( hDC,
                    prc->left + xAlign + nDownPad,
                    prc->top + yAlign + nDownPad,
                    ETO_CLIPPED,
                    prc,
                    m_pwchText,
                    StrLenW(m_pwchText),
                    NULL );
    }
    else {
        SetTextColor( hDC, GetSysColor(COLOR_3DHIGHLIGHT) );
        CUIExtTextOut( hDC,
                    prc->left + xAlign + nDownPad + 1,
                    prc->top + yAlign + nDownPad + 1,
                    ETO_CLIPPED,
                    prc,
                    m_pwchText,
                    StrLenW(m_pwchText),
                    NULL );

        SetTextColor( hDC, GetSysColor(COLOR_3DSHADOW) );
        CUIExtTextOut( hDC,
                    prc->left + xAlign + nDownPad,
                    prc->top + yAlign + nDownPad,
                    ETO_CLIPPED,
                    prc,
                    m_pwchText,
                    StrLenW(m_pwchText),
                    NULL );
    }

    SelectObject( hDC, hFontOld );
}


/*   D R A W  I C O N  P R O C   */
/*------------------------------------------------------------------------------

    Draw icon on button face

------------------------------------------------------------------------------*/
void CUIFButton::DrawIconProc( HDC hDC, const RECT *prc, BOOL fDown )
{
    Assert(hDC && prc && m_hIcon);
    const int nDownPad = fDown ? 1 : 0;
    const int nWidth = prc->right - prc->left;
    const int nHeight= prc->bottom - prc->top;
    const RECT rc = {0, 0, nWidth, nHeight};
    HDC hDCMem = NULL;
    HBITMAP hBmpOld;
    HBITMAP hBmp = NULL;

    // prepare memory dc

    hDCMem = CreateCompatibleDC( hDC );
    if (!hDCMem)
        goto Exit;
       
    hBmp = CreateCompatibleBitmap( hDC, nWidth, nHeight );
    if (!hBmp)
        goto Exit;
       
    hBmpOld = (HBITMAP)SelectObject( hDCMem, hBmp );


    // clear background

    if (IsEnabled()) {
        BitBlt( hDCMem, rc.left, rc.top, nWidth, nHeight, hDC, prc->left, prc->top, SRCCOPY );
    }
    else {
        FillRect( hDCMem, &rc, (HBRUSH)GetStockObject(WHITE_BRUSH) );
    }

    // paint icon into memory dc

    if (m_dwStyle & UIBUTTON_FITIMAGE) {
        DrawIconEx( hDCMem,
            2 + nDownPad,
            2 + nDownPad,
            m_hIcon,
            nWidth  - 4,
            nHeight - 4,
            0,
            NULL,
            DI_NORMAL );
    }
    else {
        DrawIconEx( hDCMem,
            (nWidth - 16) / 2 + nDownPad,
            (nHeight - 16) / 2 + nDownPad,
            m_hIcon,
            16,
            16,
            0,
            NULL,
            DI_NORMAL );
    }

    SelectObject( hDCMem, hBmpOld);

    CUIDrawState( hDC,
        NULL,
        NULL,
        (LPARAM)hBmp,
        0, // we don't pass a WPARAM in this case.
        prc->left,
        prc->top,
        nWidth,
        nHeight,
        DST_BITMAP | (IsEnabled() ? 0 : (DSS_DISABLED | DSS_MONO)) );

Exit:
    if (hBmp)
        DeleteObject( hBmp );
    if (hDCMem)
        DeleteDC( hDCMem );
}


/*   D R A W  B I T M A P  P R O C   */
/*------------------------------------------------------------------------------

    Draw bitmap on button face 

------------------------------------------------------------------------------*/
void CUIFButton::DrawBitmapProc( HDC hDC, const RECT *prc, BOOL fDown )
{
    const int nDownPad = fDown ? 1 : 0;
    const int nWidth = GetRectRef().right - GetRectRef().left;
    const int nHeight= GetRectRef().bottom - GetRectRef().top;

    if (!m_hBmpMask)
    {
        CUIDrawState( hDC,
            NULL,
            NULL,
            (LPARAM)m_hBmp,
            0,
            prc->left + nDownPad,
            prc->top  + nDownPad,
            nWidth  - nDownPad,
            nHeight - nDownPad,
            DST_BITMAP | (IsEnabled() ? 0 : DSS_DISABLED | DSS_MONO) );
    }
    else
    {
        HBITMAP hBmp = CreateMaskBmp(&GetRectRef(), 
                                     m_hBmp, 
                                     m_hBmpMask, 
                                     (HBRUSH)(COLOR_3DFACE + 1) , 0, 0);
        CUIDrawState( hDC,
            NULL,
            NULL,
            (LPARAM)hBmp,
            0,
            prc->left + nDownPad,
            prc->top  + nDownPad,
            nWidth  - nDownPad,
            nHeight - nDownPad,
            DST_BITMAP | (IsEnabled() ? 0 : DSS_DISABLED | DSS_MONO) );

        DeleteObject(hBmp);
    }
}


/*   S E T  S T A T U S   */
/*------------------------------------------------------------------------------

    Set button status

------------------------------------------------------------------------------*/
void CUIFButton::SetStatus( DWORD dwStatus )
{
    if (dwStatus != m_dwStatus) {
        m_dwStatus = dwStatus;
        CallOnPaint();
    }
}


/*   G E T  T O G G L E  S T A T E   */
/*------------------------------------------------------------------------------

    Get toggle status
    Returns TRUE when the button has been toggled.

------------------------------------------------------------------------------*/
BOOL CUIFButton::GetToggleState( void )
{
    return m_fToggled;
}


/*   S E T  T O G G L E  S T A T E   */
/*------------------------------------------------------------------------------

    Set toggle status

------------------------------------------------------------------------------*/
void CUIFButton::SetToggleState( BOOL fToggle )
{
    if ((m_dwStyle & UIBUTTON_TYPEMASK) == UIBUTTON_TOGGLE && m_fToggled != fToggle) {
        m_fToggled = fToggle;
        CallOnPaint();
    }
}


/*   G E T  T E X T  S I Z E   */
/*------------------------------------------------------------------------------

    calc text width

------------------------------------------------------------------------------*/
void CUIFButton::GetTextSize( LPCWSTR pwch, SIZE *psize )
{
    HDC hDC = GetDC( NULL );
    HFONT hFontOld = (HFONT)SelectObject( hDC, GetFont() );

    Assert( pwch != NULL );
    if (!m_fUseCustomFont && SUCCEEDED(EnsureThemeData(m_pUIWnd->GetWnd())))
    {
        RECT rcText;
        GetThemeTextExtent( hDC,0 , pwch, StrLenW(pwch),0, NULL, &rcText);
        psize->cx = rcText.right;
        psize->cy = rcText.bottom;

    }
    else
    {
        CUIGetTextExtentPoint32( hDC, pwch, StrLenW(pwch), psize );
    }

    //
    // swap width and height
    //
    if (IsVertical())
    {
        int nTemp = psize->cx;
        psize->cx = psize->cy;
        psize->cy = nTemp;
    }

    SelectObject( hDC, hFontOld );
    ReleaseDC( NULL, hDC );
}


/*   G E T  I C O N  S I Z E   */
/*------------------------------------------------------------------------------

    get icon size

------------------------------------------------------------------------------*/
void CUIFButton::GetIconSize( HICON hIcon, SIZE *psize )
{
    ICONINFO IconInfo;
    BITMAP   bmp;
    
    Assert( hIcon != NULL );

    if (GetIconInfo( hIcon, &IconInfo ))
    {
        GetObject( IconInfo.hbmColor, sizeof(bmp), &bmp );
        DeleteObject( IconInfo.hbmColor );
        DeleteObject( IconInfo.hbmMask );
        psize->cx = bmp.bmWidth;
        psize->cy = bmp.bmHeight;
    }
    else
    {
        psize->cx = GetSystemMetrics(SM_CXSMICON);
        psize->cy = GetSystemMetrics(SM_CYSMICON);
    }
}


/*   G E T  B I T M A P  S I Z E   */
/*------------------------------------------------------------------------------

    get bitmap size

------------------------------------------------------------------------------*/
void CUIFButton::GetBitmapSize( HBITMAP hBmp, SIZE *psize )
{
    BITMAP bmp;
    
    Assert( hBmp != NULL );

    GetObject( hBmp, sizeof(bmp), &bmp );
    psize->cx = bmp.bmWidth;
    psize->cy = bmp.bmHeight;
}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  B U T T O N  2                                                  */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  B U T T O N  2   */
/*------------------------------------------------------------------------------

    Constructor of CUIFButton2

------------------------------------------------------------------------------*/
CUIFButton2::CUIFButton2( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFButton( pParent, dwID, prc, dwStyle )
{
    SetActiveTheme(L"TOOLBAR", TP_BUTTON, 0);
}


/*   ~  C  U I F  B U T T O N  2   */
/*------------------------------------------------------------------------------

    Destructor of CUIFButton2

------------------------------------------------------------------------------*/
CUIFButton2::~CUIFButton2( void )
{
    CloseThemeData();
}




/*------------------------------------------------------------------------------

    MakeDrawFlag

------------------------------------------------------------------------------*/
DWORD CUIFButton2::MakeDrawFlag()
{
    DWORD   dwState = 0;
    // make draw flag

    dwState |= (m_fToggled) ? UIFDCS_SELECTED : 0;
    switch (m_dwStatus) {
        case UIBUTTON_DOWN: {
            dwState |= UIFDCS_MOUSEDOWN;
            break;
        }

        case UIBUTTON_HOVER:
        case UIBUTTON_DOWNOUT: {
            dwState |= UIFDCS_MOUSEOVER;
            break;
        }
    }
    dwState |= IsEnabled() ? 0 : UIFDCS_DISABLED;

    return dwState;
}

/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

    Paint procedure of button object

------------------------------------------------------------------------------*/
BOOL CUIFButton2::OnPaintTheme( HDC hDC )
{
    DWORD   dwState = 0;
    BOOL    fRet = FALSE;
    SIZE    sizeText  = {0};
    SIZE    sizeImage = {0};
    SIZE    sizeFace  = {0};
    SIZE    offset    = {0};
    RECT    rcText    = {0};
    RECT    rcImage   = {0};
    RECT    rcFace    = {0};
    RECT    rcContent = {0};
    HFONT   hFontOld = NULL;
    DWORD   dwTextFlag = 0;

    // make draw flag

    dwState = MakeDrawFlag();

    if (!CUIIsThemeActive()) {
        goto Exit;
    }

    if (FAILED(EnsureThemeData( GetUIWnd()->GetWnd())))
        goto Exit;

    hFontOld = (HFONT)SelectObject( hDC, GetFont() );

    int    iStateID;


    if (!IsEnabled()) {
        iStateID = TS_DISABLED;
    }
    else if (GetToggleState()) {
        iStateID = TS_CHECKED;
    }
    else if (m_dwStatus == UIBUTTON_DOWN) {
        iStateID = TS_PRESSED;
    }
    else if (m_dwStatus == UIBUTTON_HOVER) {
        iStateID = TS_HOT;
    }
    else {
        iStateID = TS_NORMAL;
    }

    // if (FAILED(GetThemeBackgroundContentRect(hDC, iStateID, &GetRectRef(), &rcContent )))
    //     goto Exit;
    rcContent = GetRectRef();

    // calc face size

    if (m_pwchText != NULL) {
        sizeText  = m_sizeText;
    }
    if (m_hIcon != NULL) { 
        sizeImage  = m_sizeIcon;
    }
    else if (m_hBmp != NULL ) {
        sizeImage  = m_sizeBmp;
    }

    // alignment

    if (!IsVertical())
    {
        sizeFace.cx = sizeText.cx + sizeImage.cx + ((sizeText.cx != 0 && sizeImage.cx != 0) ? 2 : 0);
        sizeFace.cy = max( sizeText.cy, sizeImage.cy );
    }
    else
    {
        sizeFace.cy = sizeText.cy + sizeImage.cy + ((sizeText.cy != 0 && sizeImage.cy != 0) ? 2 : 0);
        sizeFace.cx = max( sizeText.cx, sizeImage.cx );
    }

    switch (GetStyleBits( UIBUTTON_HALIGNMASK )) {
        case UIBUTTON_LEFT:
        default: {
            rcFace.left   = rcContent.left + 2;
            rcFace.right  = rcFace.left + sizeFace.cx;
            dwTextFlag = DT_LEFT;
            break;
        }

        case UIBUTTON_CENTER: {
            rcFace.left   = (rcContent.right + rcContent.left - sizeFace.cx) / 2;
            rcFace.right  = rcFace.left + sizeFace.cx;
            dwTextFlag = DT_CENTER;
            break;
        }

        case UIBUTTON_RIGHT: {
            rcFace.left   = rcContent.right - 2 - sizeText.cx;
            rcFace.right  = rcFace.left + sizeFace.cx;
            dwTextFlag = DT_RIGHT;
            break;
        }
    }

    switch (GetStyleBits( UIBUTTON_VALIGNMASK )) {
        case UIBUTTON_TOP:
        default: {
            rcFace.top    = rcContent.top + 2;
            rcFace.bottom = rcFace.top + sizeFace.cy;
            dwTextFlag = DT_TOP;
            break;
        }

        case UIBUTTON_VCENTER: {
            rcFace.top     = (rcContent.bottom + rcContent.top - sizeFace.cy) / 2;
            rcFace.bottom  = rcFace.top + sizeFace.cy;
            dwTextFlag = DT_VCENTER;
            break;
        }

        case UIBUTTON_BOTTOM: {
            rcFace.top    = rcContent.bottom - 2 - sizeFace.cy;
            rcFace.bottom = rcFace.top + sizeFace.cy;
            dwTextFlag = DT_BOTTOM;
            break;
        }
    }

    if (!IsVertical())
    {
        rcImage.left   = rcFace.left;
        rcImage.top    = (rcFace.bottom + rcFace.top - sizeImage.cy) / 2;
        rcImage.right  = rcImage.left + sizeImage.cx;
        rcImage.bottom = rcImage.top  + sizeImage.cy;

        rcText.left    = rcFace.right - sizeText.cx;
        rcText.top     = (rcFace.bottom + rcFace.top - sizeText.cy) / 2;
        rcText.right   = rcText.left + sizeText.cx;
        rcText.bottom  = rcText.top  + sizeText.cy;
    }
    else
    {
        rcImage.left   = (rcFace.right + rcFace.left - sizeImage.cx) / 2;
        rcImage.top    = rcFace.top;
        rcImage.right  = rcImage.left + sizeImage.cx;
        rcImage.bottom = rcImage.top  + sizeImage.cy;

        rcText.left    = (rcFace.right + rcFace.left - sizeText.cx) / 2;
        rcText.top     = rcFace.bottom - sizeText.cy;
        rcText.right   = rcText.left + sizeText.cx;
        rcText.bottom  = rcText.top  + sizeText.cy;
    }

    if (FAILED(DrawThemeBackground(hDC, iStateID, &GetRectRef(), 0 )))
        goto Exit;

    if (m_pwchText != NULL) 
    {
        int cwch = StrLenW(m_pwchText);
       
        //
        // DrawtThemeText() uses the font from theme so 
        // marlett font won't be used....
        // We need to draw the text when a font is set.
        //
        if (m_fUseCustomFont)
        {
            COLORREF col;
            int xText;
            int yText;

            if (FAILED(GetThemeColor(iStateID, TMT_TEXTCOLOR, &col)))
            {
                col = GetSysColor(COLOR_WINDOWTEXT);
            }

            COLORREF colTextOld = GetTextColor( hDC );
            int      iBkModeOld = SetBkMode( hDC, TRANSPARENT );

            xText = IsVertical() ? rcText.right : rcText.left;
            yText = rcText.top;

 
            //
            // we want to calc the marging correctly for theme. 
            // but somehow MSUTB's langbar is corrupted.
            //
            if (IsRTL())
                xText -= 2;

#if 0
            MARGINS marginsItem = {0};
            GetThemeMargins(NULL, iStateID, TMT_CONTENTMARGINS, 
                            NULL, &marginsItem);
            xText += marginsItem.cxLeftWidth;
            yText += marginsItem.cxRightWidth;
#endif

            SetTextColor( hDC, col);
            CUIExtTextOut( hDC,
                           xText,
                           yText,
                           ETO_CLIPPED,
                           &rcText,
                           m_pwchText,
                           cwch,
                           NULL );

            SetTextColor( hDC, colTextOld );
            SetBkMode( hDC, iBkModeOld );
        } 
        else 
        {
            if (FAILED(DrawThemeText(hDC, 
                                 iStateID, 
                                 m_pwchText, 
                                 cwch,
                                 dwTextFlag, 
                                 0, 
                                 &rcText)))
             goto Exit;
        } 
    }

    if (m_hIcon != NULL) 
    {
        if (FAILED(DrawThemeIcon(hDC, 
                                 iStateID, 
                                 &rcImage, 
                                 m_hIcon.GetImageList(IsRTL()), 
                                 m_hIcon.GetImageListId() )))
            goto Exit;

    }
    else if (m_hBmp != NULL) 
    {
        //
        // Draw Bitmap by ourselves.
        //
        DrawMaskBmpOnDC(hDC, &rcImage, m_hBmp, m_hBmpMask);

    }

    if (hFontOld)
        SelectObject( hDC, hFontOld );

    fRet = TRUE;

Exit:
    return fRet;
}

/*   O N  P A I N T D E F  */
/*------------------------------------------------------------------------------

    Paint procedure of button object

------------------------------------------------------------------------------*/
void CUIFButton2::OnPaintNoTheme( HDC hDC )
{
    DWORD   dwState = 0;
    HDC     hDCMem = NULL;
    HBITMAP hBmpMem = NULL;
    HBITMAP hBmpOld;
    SIZE    size;
    RECT    rc;
    SIZE    sizeText  = {0};
    SIZE    sizeImage = {0};
    SIZE    sizeFace  = {0};
    SIZE    offset    = {0};
    RECT    rcText    = {0};
    RECT    rcImage   = {0};
    RECT    rcFace    = {0};
    HFONT   hFontOld;

    if (!m_pUIFScheme)
        return;

    // make draw flag

    dwState = MakeDrawFlag();

    // prepare memory dc

    size.cx = GetRectRef().right - GetRectRef().left;
    size.cy = GetRectRef().bottom - GetRectRef().top;

    hDCMem = CreateCompatibleDC( hDC );
    if (!hDCMem)
        goto Exit;

    hBmpMem = CreateCompatibleBitmap( hDC, size.cx, size.cy );
    if (!hBmpMem)
        goto Exit;

    hBmpOld = (HBITMAP)SelectObject( hDCMem, hBmpMem );

    ::SetRect( &rc, 0, 0, size.cx, size.cy );
    hFontOld = (HFONT)SelectObject( hDCMem, GetFont() );

    // calc face size

    if (m_pwchText != NULL) {
        sizeText  = m_sizeText;
    }
    if (m_hIcon != NULL) { 
        sizeImage  = m_sizeIcon;
    }
    else if (m_hBmp != NULL ) {
        sizeImage  = m_sizeBmp;
    }

    // alignment

    if (!IsVertical())
    {
        sizeFace.cx = sizeText.cx + sizeImage.cx + ((sizeText.cx != 0 && sizeImage.cx != 0) ? 2 : 0);
        sizeFace.cy = max( sizeText.cy, sizeImage.cy );
    }
    else
    {
        sizeFace.cy = sizeText.cy + sizeImage.cy + ((sizeText.cy != 0 && sizeImage.cy != 0) ? 2 : 0);
        sizeFace.cx = max( sizeText.cx, sizeImage.cx );
    }

    switch (GetStyleBits( UIBUTTON_HALIGNMASK )) {
        case UIBUTTON_LEFT:
        default: {
            rcFace.left   = rc.left + 2;
            rcFace.right  = rcFace.left + sizeFace.cx;
            break;
        }

        case UIBUTTON_CENTER: {
            rcFace.left   = (rc.right + rc.left - sizeFace.cx) / 2;
            rcFace.right  = rcFace.left + sizeFace.cx;
            break;
        }

        case UIBUTTON_RIGHT: {
            rcFace.left   = rc.right - 2 - sizeText.cx;
            rcFace.right  = rcFace.left + sizeFace.cx;
            break;
        }
    }

    switch (GetStyleBits( UIBUTTON_VALIGNMASK )) {
        case UIBUTTON_TOP:
        default: {
            rcFace.top    = rc.top + 2;
            rcFace.bottom = rcFace.top + sizeFace.cy;
            break;
        }

        case UIBUTTON_VCENTER: {
            rcFace.top     = (rc.bottom + rc.top - sizeFace.cy) / 2;
            rcFace.bottom  = rcFace.top + sizeFace.cy;
            break;
        }

        case UIBUTTON_BOTTOM: {
            rcFace.top    = rc.bottom - 2 - sizeFace.cy;
            rcFace.bottom = rcFace.top + sizeFace.cy;
            break;
        }
    }

    m_pUIFScheme->GetCtrlFaceOffset( GetDCF(), dwState, &offset );
    OffsetRect( &rcFace, offset.cx, offset.cy );

    if (!IsVertical())
    {
        rcImage.left   = rcFace.left;
        rcImage.top    = (rcFace.bottom + rcFace.top - sizeImage.cy) / 2;
        rcImage.right  = rcImage.left + sizeImage.cx;
        rcImage.bottom = rcImage.top  + sizeImage.cy;

        rcText.left    = rcFace.right - sizeText.cx;
        rcText.top     = (rcFace.bottom + rcFace.top - sizeText.cy) / 2;
        rcText.right   = rcText.left + sizeText.cx;
        rcText.bottom  = rcText.top  + sizeText.cy;
    }
    else
    {
        rcImage.left   = (rcFace.right + rcFace.left - sizeImage.cx) / 2;
        rcImage.top    = rcFace.top;
        rcImage.right  = rcImage.left + sizeImage.cx;
        rcImage.bottom = rcImage.top  + sizeImage.cy;

        rcText.left    = (rcFace.right + rcFace.left - sizeText.cx) / 2;
        rcText.top     = rcFace.bottom - sizeText.cy;
        rcText.right   = rcText.left + sizeText.cx;
        rcText.bottom  = rcText.top  + sizeText.cy;
    }

    if (IsRTL())
        m_pUIFScheme->SetLayout(LAYOUT_RTL);

    // paint background

    m_pUIFScheme->DrawCtrlBkgd( hDCMem, &rc, GetDCF(), dwState );

    // paint face

    if (m_pwchText != NULL) {
        m_pUIFScheme->DrawCtrlText( hDCMem, &rcText, m_pwchText, -1, dwState , IsVertical());
    }

    if (m_hIcon!= NULL) {
        m_pUIFScheme->DrawCtrlIcon( hDCMem, &rcImage, m_hIcon, dwState, &m_sizeIcon );
    }
    else if (m_hBmp != NULL) {
        m_pUIFScheme->DrawCtrlBitmap( hDCMem, &rcImage, m_hBmp, m_hBmpMask, dwState );
    }

    if (IsRTL())
        m_pUIFScheme->SetLayout(0);

    // draw button edge

    m_pUIFScheme->DrawCtrlEdge( hDCMem, &rc, GetDCF(), dwState );

    //

    BitBlt( hDC, GetRectRef().left, GetRectRef().top, size.cx, size.cy, hDCMem, 0, 0, SRCCOPY );

    SelectObject( hDCMem, hFontOld );
    SelectObject( hDCMem, hBmpOld );

Exit:
    if (hBmpMem)
       DeleteObject( hBmpMem );
    if (hDCMem)
       DeleteDC( hDCMem );

}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  S C R O L L                                                     */
/*                                                                             */
/*=============================================================================*/

//
// CUIFScrollButton
//

/*   C  U I F  S C R O L L  B U T T O N   */
/*------------------------------------------------------------------------------

    Constructor of CUIFScrollButton

------------------------------------------------------------------------------*/
CUIFScrollButton::CUIFScrollButton( CUIFScroll *pUIScroll, const RECT *prc, DWORD dwStyle ) : CUIFButton( pUIScroll, 0, prc, dwStyle )
{
}


/*   ~  C  U I F  S C R O L L  B U T T O N   */
/*------------------------------------------------------------------------------

    Destructor of CUIFScrollButton

------------------------------------------------------------------------------*/
CUIFScrollButton::~CUIFScrollButton( void )
{
}


/*   O N  L B U T T O N  D O W N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScrollButton::OnLButtonDown( POINT pt )
{
    CUIFButton::OnLButtonDown( pt );

    // scroll one item

    NotifyCommand( UISCROLLBUTTON_PRESSED, 0 );

    // create time to auto-repeat

    StartTimer( GetScrollDelay() );
}


/*   O N  L B U T T O N  U P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScrollButton::OnLButtonUp( POINT pt )
{
    CUIFButton::OnLButtonUp( pt );

    // stop auto-repeat

    if (IsTimer()) {
        EndTimer();
    }
}

/*   O N  M O U S E  I N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScrollButton::OnMouseIn( POINT pt )
{
    CUIFButton::OnMouseIn( pt );

    if (IsCapture()) {
        // scroll one item when mouse is in

        NotifyCommand( UISCROLLBUTTON_PRESSED, 0 );

        // create timer to auto-repeat again

        StartTimer( GetScrollSpeed() );
    }
}


/*   O N  M O U S E  O U T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScrollButton::OnMouseOut( POINT pt )
{
    CUIFButton::OnMouseOut( pt );

    // kill timer to prevent from auto-repeat

    if (IsTimer()) {
        EndTimer();
    }
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

    Paint procedure of scroll button object

------------------------------------------------------------------------------*/
void CUIFScrollButton::OnPaint( HDC hDC )
{
    RECT rc = GetRectRef();
    UINT uState = 0;

    switch (m_dwStyle & UISCROLLBUTTON_DIRMASK) {
        case UISCROLLBUTTON_LEFT: {
            uState = DFCS_SCROLLLEFT;
            break;
        }

        case UISCROLLBUTTON_UP: {
            uState = DFCS_SCROLLUP;
            break;
        }

        case UISCROLLBUTTON_RIGHT: {
            uState = DFCS_SCROLLRIGHT;
            break;
        }

        case UISCROLLBUTTON_DOWN: {
            uState = DFCS_SCROLLDOWN;
            break;
        }
    }

    uState |= ((m_dwStatus == UIBUTTON_DOWN) ? DFCS_PUSHED | DFCS_FLAT : 0);
    uState |= ((!IsEnabled()) ? DFCS_INACTIVE : 0);

    DrawFrameControl( hDC, &rc, DFC_SCROLL, uState );
}


/*   O N  T I M E R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScrollButton::OnTimer( void )
{
    POINT pt;

    StartTimer( GetScrollSpeed() );

    GetCursorPos( &pt );
    ScreenToClient( m_pUIWnd->GetWnd(), &pt );

    if (PtInObject( pt )) {
        NotifyCommand( UISCROLLBUTTON_PRESSED, 0 );
    }
}


//
// CUIFScrollThumb
//

/*   C  U I F  S C R O L L  T H U M B   */
/*------------------------------------------------------------------------------

    Constructor of CUIFScrollThumb 

------------------------------------------------------------------------------*/
CUIFScrollThumb::CUIFScrollThumb( CUIFScroll *pUIScroll, const RECT *prc, DWORD dwStyle ) : CUIFObject( pUIScroll, 0 /* no id */, prc, dwStyle )
{
}


/*   ~  C  U I F  S C R O L L  T H U M B   */
/*------------------------------------------------------------------------------

    Destructor of CUIFScrollThumb 

------------------------------------------------------------------------------*/
CUIFScrollThumb::~CUIFScrollThumb( void )
{
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

    Paint procedure of scroll thumb object

------------------------------------------------------------------------------*/
void CUIFScrollThumb::OnPaint(HDC hDC)
{
    RECT rc = GetRectRef();

    if (!IsEnabled()) {
        return;
    }

    FillRect( hDC, &rc, (HBRUSH)(COLOR_3DFACE + 1) );
    DrawEdge( hDC, &rc, EDGE_RAISED, BF_RECT );
}


/*   O N  L B U T T O N  D O W N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScrollThumb::OnLButtonDown( POINT pt )
{
    if (IsEnabled()) {
        StartCapture();

        m_ptDragOrg = pt;
        m_ptDrag.x = pt.x - GetRectRef().left;
        m_ptDrag.y = pt.y - GetRectRef().top;
    }
}


/*   O N  L B U T T O N  U P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScrollThumb::OnLButtonUp( POINT pt )
{
    if (IsCapture()) {
        EndCapture();
        DragProc( pt, TRUE /* end of dragging */ );
    }
}


/*   O N  M O U S E  M O V E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScrollThumb::OnMouseMove( POINT pt )
{
    if (IsCapture()) {
        DragProc( pt, FALSE /* still dragging */ );
    }
}


/*   S E T  S C R O L L  A R E A   */
/*------------------------------------------------------------------------------

    Set scroll area

------------------------------------------------------------------------------*/
void CUIFScrollThumb::SetScrollArea( RECT *prc )
{
    m_rcScrollArea = *prc;
}


/*   D R A G  P R O C   */
/*------------------------------------------------------------------------------

    Handle mouse message while dragging
    Move the thumb and notify to the parent object (Scroll).

------------------------------------------------------------------------------*/
void CUIFScrollThumb::DragProc( POINT pt, BOOL fEndDrag )
{
    RECT rcValid;

    // get valid drag area (TEMP code)

    m_pParent->GetRect( &rcValid );
    InflateRect( &rcValid, 64, 64 );

    // check if drag point is valid

    if (!PtInRect( &rcValid, pt )) {
        RECT rc;

        // back to original position
    
        rc.left   = m_ptDragOrg.x - m_ptDrag.x;
        rc.top    = m_ptDragOrg.y - m_ptDrag.y;
        rc.right  = rc.left + (GetRectRef().right - GetRectRef().left);
        rc.bottom = rc.top  + (GetRectRef().bottom - GetRectRef().top);

        // move myself and notify to parent
    
        SetRect( &rc );
        NotifyCommand( UISCROLLTHUMB_MOVED, 0 );
    }
    else {
        RECT rc;

        // calc new thumb position
    
        rc.left   = pt.x - m_ptDrag.x;
        rc.top    = pt.y - m_ptDrag.y;
        rc.right  = rc.left + (GetRectRef().right - GetRectRef().left);
        rc.bottom = rc.top  + (GetRectRef().bottom - GetRectRef().top);
    
        // adjust thumb position
    
        if (rc.top < m_rcScrollArea.top) {
            rc.bottom += (m_rcScrollArea.top - rc.top);
            rc.top    += (m_rcScrollArea.top - rc.top);
        }
        else if (m_rcScrollArea.bottom < rc.bottom) {
            rc.top    += (m_rcScrollArea.bottom - rc.bottom);
            rc.bottom += (m_rcScrollArea.bottom - rc.bottom);
        }
    
        if (rc.left < m_rcScrollArea.left) {
            rc.right  += (m_rcScrollArea.left - rc.left);
            rc.left   += (m_rcScrollArea.left - rc.left);
        }
        else if (m_rcScrollArea.right < rc.right) {
            rc.left   += (m_rcScrollArea.right - rc.right);
            rc.right  += (m_rcScrollArea.right - rc.right);
        }
    
        // move myself and notify to parent
    
        SetRect( &rc );
        NotifyCommand( fEndDrag ? UISCROLLTHUMB_MOVED : UISCROLLTHUMB_MOVING, 0 );
    }
}


//
// CUIFScroll
//

/*   C  U I F  S C R O L L   */
/*------------------------------------------------------------------------------

    Constructor of CUIFScroll

------------------------------------------------------------------------------*/
CUIFScroll::CUIFScroll( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFObject( pParent, dwID, prc, dwStyle )
{
    m_ScrollInfo.nMax  = 0;
    m_ScrollInfo.nPage = 0;
    m_ScrollInfo.nPos  = 0;
    m_fScrollPage = FALSE;
    m_dwScrollDir = UISCROLL_NONE;

    // get metrics

    GetMetrics();
}


/*   ~  C  U I F  S C R O L L   */
/*------------------------------------------------------------------------------

    Destructor of CUIFScroll

------------------------------------------------------------------------------*/
CUIFScroll::~CUIFScroll( void )
{
}


/*   I N I T I A L I Z E   */
/*------------------------------------------------------------------------------

    Intialize scroll object

------------------------------------------------------------------------------*/
CUIFObject *CUIFScroll::Initialize( void )
{
    RECT rc;

    // create child objects

    GetBtnUpRect( &rc );
    m_pBtnUp = new CUIFScrollButton( this, &rc, GetScrollUpBtnStyle() );
    if (m_pBtnUp)
    {
        m_pBtnUp->Initialize();
        AddUIObj( m_pBtnUp );
    }

    GetBtnDnRect( &rc );
    m_pBtnDn = new CUIFScrollButton( this, &rc, GetScrollDnBtnStyle() );
    if (m_pBtnDn)
    {
        m_pBtnDn->Initialize();
        AddUIObj( m_pBtnDn );
    }

    GetThumbRect( &rc );
    m_pThumb = new CUIFScrollThumb( this, &rc, GetScrollThumbStyle() );
    if (m_pThumb)
    {
       m_pThumb->Initialize();
       AddUIObj( m_pThumb );
       //

       GetScrollArea( &rc );
       m_pThumb->SetScrollArea( &rc );
    }


    //
    
    return CUIFObject::Initialize();
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

    Paint procedure of scroll object

------------------------------------------------------------------------------*/
void CUIFScroll::OnPaint( HDC hDC )
{
    HBRUSH hBrush;

    // paint scroll bar back

    hBrush = (HBRUSH)DefWindowProc( m_pUIWnd->GetWnd(), WM_CTLCOLORSCROLLBAR, (WPARAM)hDC, (LPARAM)m_pUIWnd->GetWnd() );
    if (hBrush == NULL) {
        // never happen?  just in case...
        hBrush = GetSysColorBrush(COLOR_SCROLLBAR);
    }

    FillRect( hDC, &GetRectRef(), hBrush );
    DeleteObject( hBrush );

    // paint scroll area

    if (m_fScrollPage) {
        RECT rc;

        switch (m_dwScrollDir) {
            case UISCROLL_PAGEUP: {
                GetPageUpArea( &rc );
                break;
            }

            case UISCROLL_PAGEDOWN: {
                GetPageDnArea( &rc );
                break;
            }
        }
        InvertRect( hDC, &rc );
    }
}


/*   O N  L B U T T O N  D O W N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScroll::OnLButtonDown( POINT pt )
{
    if (!m_pThumb->IsVisible()) {
        return;
    }

    StartCapture();
    if (PtInPageUpArea( pt )) {
        StartTimer( GetScrollDelay() );
        m_fScrollPage = TRUE;
        m_dwScrollDir = UISCROLL_PAGEUP;

        ShiftPage( -1 );
    }
    else if (PtInPageDnArea( pt )) {
        StartTimer( GetScrollDelay() );
        m_fScrollPage = TRUE;
        m_dwScrollDir = UISCROLL_PAGEDOWN;

        ShiftPage( +1 );
    }
    else {
        Assert( FALSE );
    }

    CallOnPaint();
}


/*   O N  L B U T T O N  U P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScroll::OnLButtonUp( POINT pt )
{
    if (IsCapture()) {
        EndCapture();
    }

    if (IsTimer()) {
        EndTimer();
    }

    m_fScrollPage = FALSE;
    m_dwScrollDir = UISCROLL_NONE;
    CallOnPaint();
}


/*   O N  M O U S E  I N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScroll::OnMouseIn( POINT pt )
{
    if (IsCapture()) {
        switch (m_dwScrollDir) {
            case UISCROLL_PAGEUP: {
                if (PtInPageUpArea( pt )) {
                    StartTimer( GetScrollSpeed() );
                    m_fScrollPage = TRUE;

                    ShiftPage( -1 );
                    CallOnPaint();
                }
                break;
            }

            case UISCROLL_PAGEDOWN: {
                if (PtInPageDnArea( pt )) {
                    StartTimer( GetScrollSpeed() );
                    m_fScrollPage = TRUE;

                    ShiftPage( +1 );
                    CallOnPaint();
                }
                break;
            }
        }
    }
}


/*   O N  M O U S E  O U T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScroll::OnMouseOut( POINT pt )
{
    m_fScrollPage = FALSE;
    if (IsTimer()) {
        EndTimer();
    }

    CallOnPaint();
}


/*   S E T  R E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScroll::SetRect( const RECT *prc )
{
    RECT rc;
    BOOL fThumbVisible;

    CUIFObject::SetRect( prc );

    // adjist child object poisition

    GetBtnUpRect( &rc );
    m_pBtnUp->SetRect( &rc );

    GetBtnDnRect( &rc );
    m_pBtnDn->SetRect( &rc );

    GetScrollArea( &rc );
    m_pThumb->SetScrollArea( &rc );

    fThumbVisible = GetThumbRect( &rc );
    m_pThumb->SetRect( &rc );
    m_pThumb->Show( IsVisible() && fThumbVisible );
}


/*   S E T  S T Y L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScroll::SetStyle( DWORD dwStyle )
{
    RECT rc;
    BOOL fThumbVisible;

    CUIFObject::SetStyle( dwStyle );

    //

    GetMetrics();

    // update child object style

    m_pBtnUp->SetStyle( GetScrollUpBtnStyle() );
    m_pBtnDn->SetStyle( GetScrollDnBtnStyle() );
    m_pThumb->SetStyle( GetScrollThumbStyle() );

    // update child object poisition

    GetBtnUpRect( &rc );
    m_pBtnUp->SetRect( &rc );

    GetBtnDnRect( &rc );
    m_pBtnDn->SetRect( &rc );

    GetScrollArea( &rc );
    m_pThumb->SetScrollArea( &rc );

    fThumbVisible = GetThumbRect( &rc );
    m_pThumb->SetRect( &rc );
    m_pThumb->Show( IsVisible() && fThumbVisible );
}


/*   S H O W   */
/*------------------------------------------------------------------------------

    show/hide scroll bar

------------------------------------------------------------------------------*/
void CUIFScroll::Show( BOOL fShow )
{
    if (m_fVisible != fShow) {
        RECT rcThumb;
        BOOL fThumbVisible;

        m_fVisible = fShow;
        fThumbVisible = GetThumbRect( &rcThumb );

        m_pBtnUp->Show( fShow );
        m_pBtnDn->Show( fShow );
        m_pThumb->Show( fShow && fThumbVisible );

        // let parent paint the object when it's hidden

        if (!m_fVisible) {
            if (m_pParent != NULL) {
               m_pParent->CallOnPaint();
            }
        }
        else {
            CallOnPaint();
        }
    }
}


/*   O N  T I M E R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScroll::OnTimer( void )
{
    POINT pt;

    StartTimer( GetScrollSpeed() );

    GetCursorPos( &pt );
    ScreenToClient( m_pUIWnd->GetWnd(), &pt );

    switch (m_dwScrollDir) {
        case UISCROLL_PAGEUP: {
            if (PtInPageUpArea( pt )) {
                ShiftPage( -1 );
            }
            break;
        }

        case UISCROLL_PAGEDOWN: {
            if (PtInPageDnArea( pt )) {
                ShiftPage( +1 );
            }
            break;
        }
    }
}


/*   S E T  S C R O L L  I N F O   */
/*------------------------------------------------------------------------------

    Set scrollbar info

------------------------------------------------------------------------------*/
void CUIFScroll::SetScrollInfo( UIFSCROLLINFO *pScrollInfo )
{
    BOOL fEnable;

    Assert( pScrollInfo != NULL );

    m_ScrollInfo.nMax  = pScrollInfo->nMax;
    m_ScrollInfo.nPage = pScrollInfo->nPage;

    // disable when cannot scroll

    fEnable = (m_ScrollInfo.nMax > m_ScrollInfo.nPage);

    Enable( fEnable );
    m_pBtnUp->Enable( fEnable );
    m_pBtnDn->Enable( fEnable );
    m_pThumb->Enable( fEnable );

    // clear scrolling page info

    m_fScrollPage = FALSE;
    m_dwScrollDir = UISCROLL_NONE;

    //

    SetCurPos( pScrollInfo->nPos, TRUE /* adjust thumb position */ );
}


/*   G E T  S C R O L L  I N F O   */
/*------------------------------------------------------------------------------

    Get scrollbar info

------------------------------------------------------------------------------*/
void CUIFScroll::GetScrollInfo( UIFSCROLLINFO *pScrollInfo )
{
    Assert( pScrollInfo != NULL );

    *pScrollInfo = m_ScrollInfo;
}


/*   G E T  T H U M B  R E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CUIFScroll::GetThumbRect( RECT *prc )
{
    RECT rcScroll;
    BOOL fVisible;

    // return FALSE when thumb is invisible

    if (m_ScrollInfo.nMax <= 0 || 
        m_ScrollInfo.nPage <= 0 || 
        m_ScrollInfo.nMax <= m_ScrollInfo.nPage) {
        ::SetRect( prc, 0, 0, 0, 0 );
        return FALSE;
    }

    // calc thumb rect from current position

    GetScrollArea( &rcScroll );
    switch (m_dwStyle & UISCROLL_DIRMASK) {
        default:
        case UISCROLL_VERTTB: {
            int nThumbHeight = (rcScroll.bottom - rcScroll.top) * m_ScrollInfo.nPage / m_ScrollInfo.nMax;
            nThumbHeight = max( SCROLLTHUMBHEIGHT_MIN, nThumbHeight );

            fVisible = (nThumbHeight <= (rcScroll.bottom - rcScroll.top));

            prc->left   = GetRectRef().left;
            prc->top    = rcScroll.top + (rcScroll.bottom - rcScroll.top - nThumbHeight) * m_ScrollInfo.nPos / (m_ScrollInfo.nMax - m_ScrollInfo.nPage);
            prc->right  = GetRectRef().right;
            prc->bottom = prc->top + nThumbHeight;
            break;
        }

        case UISCROLL_VERTBT: {
            int nThumbHeight = (rcScroll.bottom - rcScroll.top) * m_ScrollInfo.nPage / m_ScrollInfo.nMax;
            nThumbHeight = max( SCROLLTHUMBHEIGHT_MIN, nThumbHeight );

            fVisible = (nThumbHeight <= (rcScroll.bottom - rcScroll.top));

            prc->left   = GetRectRef().left;
            prc->top    = rcScroll.bottom - (rcScroll.bottom - rcScroll.top - nThumbHeight) * m_ScrollInfo.nPos / (m_ScrollInfo.nMax - m_ScrollInfo.nPage) - nThumbHeight;
            prc->right  = GetRectRef().right;
            prc->bottom = prc->top + nThumbHeight;
            break;
        }

        case UISCROLL_HORZLR: {
            int nThumbWidth = (rcScroll.right - rcScroll.left) * m_ScrollInfo.nPage / m_ScrollInfo.nMax;
            nThumbWidth = max( SCROLLTHUMBHEIGHT_MIN, nThumbWidth );

            fVisible = (nThumbWidth <= (rcScroll.right - rcScroll.left));

            prc->left   = rcScroll.left + (rcScroll.right - rcScroll.left - nThumbWidth) * m_ScrollInfo.nPos / (m_ScrollInfo.nMax - m_ScrollInfo.nPage);
            prc->top    = GetRectRef().top;
            prc->right  = prc->left + nThumbWidth;
            prc->bottom = GetRectRef().bottom;
            break;
        }

        case UISCROLL_HORZRL: {
            int nThumbWidth = (rcScroll.right - rcScroll.left) * m_ScrollInfo.nPage / m_ScrollInfo.nMax;
            nThumbWidth = max( SCROLLTHUMBHEIGHT_MIN, nThumbWidth );

            fVisible = (nThumbWidth <= (rcScroll.right - rcScroll.left));

            prc->left   = rcScroll.right - (rcScroll.right - rcScroll.left - nThumbWidth) * m_ScrollInfo.nPos / (m_ScrollInfo.nMax - m_ScrollInfo.nPage) - nThumbWidth;
            prc->top    = GetRectRef().top;
            prc->right  = prc->left + nThumbWidth;
            prc->bottom = GetRectRef().bottom;
            break;
        }
    }

    return fVisible;
}


/*   G E T  B T N  U P  R E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CUIFScroll::GetBtnUpRect( RECT *prc )
{
    switch (m_dwStyle & UISCROLL_DIRMASK) {
        default:
        case UISCROLL_VERTTB: {
            prc->left   = GetRectRef().left;
            prc->top    = GetRectRef().top;
            prc->right  = GetRectRef().right;
            prc->bottom = GetRectRef().top + min( m_sizeScrollBtn.cy, (GetRectRef().bottom - GetRectRef().top)/2 );
            break;
        }

        case UISCROLL_VERTBT: {
            prc->left   = GetRectRef().left;
            prc->top    = GetRectRef().bottom - min( m_sizeScrollBtn.cy, (GetRectRef().bottom - GetRectRef().top)/2 );
            prc->right  = GetRectRef().right;
            prc->bottom = GetRectRef().bottom;
            break;
        }

        case UISCROLL_HORZLR: {
            prc->left   = GetRectRef().left;
            prc->top    = GetRectRef().top;
            prc->right  = GetRectRef().left + min( m_sizeScrollBtn.cx, (GetRectRef().right - GetRectRef().left)/2 );
            prc->bottom = GetRectRef().bottom;
            break;
        }

        case UISCROLL_HORZRL: {
            prc->left   = GetRectRef().right - min( m_sizeScrollBtn.cx, (GetRectRef().right - GetRectRef().left)/2 );
            prc->top    = GetRectRef().top;
            prc->right  = GetRectRef().right;
            prc->bottom = GetRectRef().bottom;
            break;
        }
    }

    return TRUE;
}


/*   G E T  B T N  D N  R E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CUIFScroll::GetBtnDnRect( RECT *prc )
{
    switch (m_dwStyle & UISCROLL_DIRMASK) {
        default:
        case UISCROLL_VERTTB: {
            prc->left   = GetRectRef().left;
            prc->top    = GetRectRef().bottom - min( m_sizeScrollBtn.cy, (GetRectRef().bottom - GetRectRef().top)/2 );
            prc->right  = GetRectRef().right;
            prc->bottom = GetRectRef().bottom;
            break;
        }

        case UISCROLL_VERTBT: {
            prc->left   = GetRectRef().left;
            prc->top    = GetRectRef().top;
            prc->right  = GetRectRef().right;
            prc->bottom = GetRectRef().top + min( m_sizeScrollBtn.cy, (GetRectRef().bottom - GetRectRef().top)/2 );
            break;
        }

        case UISCROLL_HORZLR: {
            prc->left   = GetRectRef().right - min( m_sizeScrollBtn.cx, (GetRectRef().right - GetRectRef().left)/2 );
            prc->top    = GetRectRef().top;
            prc->right  = GetRectRef().right;
            prc->bottom = GetRectRef().bottom;
            break;
        }

        case UISCROLL_HORZRL: {
            prc->left   = GetRectRef().left;
            prc->top    = GetRectRef().top;
            prc->right  = GetRectRef().left + min( m_sizeScrollBtn.cx, (GetRectRef().right - GetRectRef().left)/2 );
            prc->bottom = GetRectRef().bottom;
            break;
        }
    }

    return TRUE;
}


/*   O N  O B J E C T  N O T I F Y   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CUIFScroll::OnObjectNotify( CUIFObject *pUIObj, DWORD dwCommand, LPARAM lParam )
{
    if (pUIObj == m_pBtnUp) {
        switch (dwCommand) {
            case UISCROLLBUTTON_PRESSED: {
                if (NotifyCommand( UISCROLLNOTIFY_SCROLLLN, -1 ) == 0) {
                    ShiftLine( -1 );
                }
                break;
            }
        }
    }
    else if (pUIObj == m_pBtnDn) {
        switch (dwCommand) {
            case UISCROLLBUTTON_PRESSED: {
                if (NotifyCommand( UISCROLLNOTIFY_SCROLLLN, +1 ) == 0) {
                    ShiftLine( +1 );
                }
                break;
            }
        }
    }
    else if (pUIObj == m_pThumb) {
        switch (dwCommand) {
            case UISCROLLTHUMB_MOVING: 
            case UISCROLLTHUMB_MOVED: {
                RECT rcThumb;
                RECT rcScroll;
                int nPos;
                int nPosMax;
                int ptThumb;
                int ptMax;

                m_pThumb->GetRect( &rcThumb );
                GetScrollArea( &rcScroll );

                nPosMax = m_ScrollInfo.nMax - m_ScrollInfo.nPage;
            
                switch (m_dwStyle & UISCROLL_DIRMASK) {
                    default:
                    case UISCROLL_VERTTB: {
                        ptThumb = rcThumb.top - rcScroll.top;
                        ptMax   = (rcScroll.bottom - rcScroll.top) - (rcThumb.bottom - rcThumb.top);
                        break;
                    }
            
                    case UISCROLL_VERTBT: {
                        ptThumb = rcScroll.bottom - rcThumb.bottom;
                        ptMax   = (rcScroll.bottom - rcScroll.top) - (rcThumb.bottom - rcThumb.top);
                        break;
                    }
            
                    case UISCROLL_HORZLR: {
                        ptThumb = rcThumb.left - rcScroll.left;
                        ptMax   = (rcScroll.right - rcScroll.left) - (rcThumb.right - rcThumb.left);
                        break;
                    }
            
                    case UISCROLL_HORZRL: {
                        ptThumb = rcScroll.right - rcThumb.right;
                        ptMax   = (rcScroll.right - rcScroll.left) - (rcThumb.right - rcThumb.left);
                        break;
                    }
                }

                Assert( (0 <= ptThumb) && (ptThumb <= ptMax) );
                if (ptMax == 0) {
                    nPos = 0;
                }
                else {
                    nPos = (ptThumb * nPosMax + ptMax/2) / ptMax;
                    nPos = max( nPos, 0 );
                    nPos = min( nPos, nPosMax );
                }

                SetCurPos( nPos, (dwCommand == UISCROLLTHUMB_MOVED) /* adjust thumb position */ );
                break;
            }
        } /* of switch */
    }

    return 0;
}


/*   S E T  C U R  P O S   */
/*------------------------------------------------------------------------------

    Set current page position

------------------------------------------------------------------------------*/
void CUIFScroll::SetCurPos( int nPos, BOOL fAdjustThumbPos )
{
    int nPosMax = (m_ScrollInfo.nMax <= m_ScrollInfo.nPage) ? 0 : m_ScrollInfo.nMax - m_ScrollInfo.nPage;

    // set position

    nPosMax = m_ScrollInfo.nMax - m_ScrollInfo.nPage;
    nPos = min( nPos, nPosMax );
    nPos = max( nPos, 0 );

    m_ScrollInfo.nPos = nPos;

    // set thumb position

    if (fAdjustThumbPos) {
        RECT rcThumb;
        BOOL fThumbVisible;

        fThumbVisible = GetThumbRect( &rcThumb );
        m_pThumb->SetRect( &rcThumb );
        m_pThumb->Show( IsVisible() && fThumbVisible );
    }

    if (IsVisible()) {
        CallOnPaint();
    }

    // notify scroll to parent

    NotifyCommand( UISCROLLNOTIFY_SCROLLED, m_ScrollInfo.nPos );
}


/*   G E T  S C R O L L  A R E A   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScroll::GetScrollArea( RECT *prc )
{
    RECT rcBtnUp;
    RECT rcBtnDn;

    Assert( prc != NULL );

    GetBtnUpRect( &rcBtnUp );
    GetBtnDnRect( &rcBtnDn );
    switch (m_dwStyle & UISCROLL_DIRMASK) {
        default:
        case UISCROLL_VERTTB: {
            prc->left   = GetRectRef().left;
            prc->top    = GetRectRef().top    + (rcBtnUp.bottom - rcBtnUp.top);
            prc->right  = GetRectRef().right;
            prc->bottom = GetRectRef().bottom - (rcBtnDn.bottom - rcBtnDn.top);
            break;
        }

        case UISCROLL_VERTBT: {
            prc->left   = GetRectRef().left;
            prc->top    = GetRectRef().top    + (rcBtnDn.bottom - rcBtnDn.top);
            prc->right  = GetRectRef().right;
            prc->bottom = GetRectRef().bottom - (rcBtnUp.bottom - rcBtnUp.top);
            break;
        }

        case UISCROLL_HORZLR: {
            prc->left   = GetRectRef().left   + (rcBtnUp.bottom - rcBtnUp.top);
            prc->top    = GetRectRef().top;
            prc->right  = GetRectRef().right  - (rcBtnDn.bottom - rcBtnDn.top);
            prc->bottom = GetRectRef().bottom;
            break;
        }

        case UISCROLL_HORZRL: {
            prc->left   = GetRectRef().left   + (rcBtnDn.bottom - rcBtnDn.top);
            prc->top    = GetRectRef().top;
            prc->right  = GetRectRef().right  - (rcBtnUp.bottom - rcBtnUp.top);
            prc->bottom = GetRectRef().bottom;
            break;
        }
    }
}


/*   G E T  P A G E  U P  A R E A   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScroll::GetPageUpArea( RECT *prc )
{
    RECT rcThumb;
    RECT rcBtnUp;

    Assert( prc != NULL );

    m_pThumb->GetRect( &rcThumb );
    GetBtnUpRect( &rcBtnUp );
    switch (m_dwStyle & UISCROLL_DIRMASK) {
        default:
        case UISCROLL_VERTTB: {
            prc->left   = GetRectRef().left;
            prc->top    = GetRectRef().top    + (rcBtnUp.bottom - rcBtnUp.top);
            prc->right  = GetRectRef().right;
            prc->bottom = rcThumb.top;
            break;
        }

        case UISCROLL_VERTBT: {
            prc->left   = GetRectRef().left;
            prc->top    = rcThumb.bottom;
            prc->right  = GetRectRef().right;
            prc->bottom = GetRectRef().bottom - (rcBtnUp.bottom - rcBtnUp.top);
            break;
        }

        case UISCROLL_HORZLR: {
            prc->left   = GetRectRef().left   + (rcBtnUp.bottom - rcBtnUp.top);
            prc->top    = GetRectRef().top;;
            prc->right  = rcThumb.left;
            prc->bottom = GetRectRef().bottom;;
            break;
        }

        case UISCROLL_HORZRL: {
            prc->left   = rcThumb.right;
            prc->top    = GetRectRef().top;
            prc->right  = GetRectRef().right  - (rcBtnUp.bottom - rcBtnUp.top);
            prc->bottom = GetRectRef().bottom;;
            break;
        }
    }
}


/*   G E T  P A G E  D N  A R E A   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScroll::GetPageDnArea( RECT *prc )
{
    RECT rcThumb;
    RECT rcBtnDn;

    Assert( prc != NULL );

    m_pThumb->GetRect( &rcThumb );
    GetBtnDnRect( &rcBtnDn );
    switch (m_dwStyle & UISCROLL_DIRMASK) {
        default:
        case UISCROLL_VERTTB: {
            prc->left   = GetRectRef().left;
            prc->top    = rcThumb.bottom;
            prc->right  = GetRectRef().right;
            prc->bottom = GetRectRef().bottom - (rcBtnDn.bottom - rcBtnDn.top);
            break;
        }

        case UISCROLL_VERTBT: {
            prc->left   = GetRectRef().left;
            prc->top    = GetRectRef().top + (rcBtnDn.bottom - rcBtnDn.top);
            prc->right  = GetRectRef().right;
            prc->bottom = rcThumb.top;
            break;
        }

        case UISCROLL_HORZLR: {
            prc->left   = rcThumb.right;
            prc->top    = GetRectRef().top;
            prc->right  = GetRectRef().right - (rcBtnDn.bottom - rcBtnDn.top);
            prc->bottom = GetRectRef().bottom;;
            break;
        }

        case UISCROLL_HORZRL: {
            prc->left   = GetRectRef().left + (rcBtnDn.bottom - rcBtnDn.top) ;
            prc->top    = GetRectRef().top;
            prc->right  = rcThumb.left;
            prc->bottom = GetRectRef().bottom;;
            break;
        }
    }
}


/*   G E T  S C R O L L  T H U M B  S T Y L E   */
/*------------------------------------------------------------------------------

    Get style of scroll thumb

------------------------------------------------------------------------------*/
DWORD CUIFScroll::GetScrollThumbStyle( void )
{
    return 0;
}


/*   G E T  S C R O L L  U P  B T N  S T Y L E   */
/*------------------------------------------------------------------------------

    Get style of scroll up button 

------------------------------------------------------------------------------*/
DWORD CUIFScroll::GetScrollUpBtnStyle( void )
{
    DWORD dwStyle = 0;

    switch (m_dwStyle & UISCROLL_DIRMASK) {
        default:
        case UISCROLL_VERTTB: {
            dwStyle = UISCROLLBUTTON_UP;
            break;
        }

        case UISCROLL_VERTBT: {
            dwStyle = UISCROLLBUTTON_DOWN;
            break;
        }

        case UISCROLL_HORZLR: {
            dwStyle = UISCROLLBUTTON_LEFT;
            break;
        }

        case UISCROLL_HORZRL: {
            dwStyle = UISCROLLBUTTON_RIGHT;
            break;
        }
    }

    return dwStyle;
}


/*   G E T  S C R O L L  D N  B T N  S T Y L E   */
/*------------------------------------------------------------------------------

    Get style of scroll down button

------------------------------------------------------------------------------*/
DWORD CUIFScroll::GetScrollDnBtnStyle( void )
{
    DWORD dwStyle = 0;

    switch (m_dwStyle & UISCROLL_DIRMASK) {
        default:
        case UISCROLL_VERTTB: {
            dwStyle = UISCROLLBUTTON_DOWN;
            break;
        }

        case UISCROLL_VERTBT: {
            dwStyle = UISCROLLBUTTON_UP;
            break;
        }

        case UISCROLL_HORZLR: {
            dwStyle = UISCROLLBUTTON_RIGHT;
            break;
        }

        case UISCROLL_HORZRL: {
            dwStyle = UISCROLLBUTTON_LEFT;
            break;
        }
    }

    return dwStyle;
}


/*   G E T  M E T R I C S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScroll::GetMetrics( void )
{
    switch (m_dwStyle & UISCROLL_DIRMASK) {
        default:
        case UISCROLL_VERTTB:
        case UISCROLL_VERTBT: {
            m_sizeScrollBtn.cx = GetSystemMetrics( SM_CXVSCROLL );
            m_sizeScrollBtn.cy = GetSystemMetrics( SM_CYVSCROLL );
            break;
        }

        case UISCROLL_HORZLR:
        case UISCROLL_HORZRL: {
            m_sizeScrollBtn.cx = GetSystemMetrics( SM_CXHSCROLL );
            m_sizeScrollBtn.cy = GetSystemMetrics( SM_CYHSCROLL );
            break;
        }
    }
}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  L I S T  B A S E                                                */
/*                                                                             */
/*=============================================================================*/

//
// CUIFListBase
//

/*   C  U I F  L I S T  B A S E   */
/*------------------------------------------------------------------------------

    Constructor of CUIFListBase

------------------------------------------------------------------------------*/
CUIFListBase::CUIFListBase( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFObject( pParent, dwID, prc, dwStyle )
{
    m_nItem        = 0;
    m_nLineHeight  = GetFontHeight();
    m_nItemVisible = 0;
    m_iItemTop     = 0;
    m_iItemSelect  = 0;
}


/*   ~  C  U I F  L I S T  B A S E   */
/*------------------------------------------------------------------------------

    Destructor of CUIFListBase

------------------------------------------------------------------------------*/
CUIFListBase::~CUIFListBase( void )
{
    CListItemBase *pItem;

    while ((pItem = m_listItem.GetFirst()) != NULL) {
        m_listItem.Remove(pItem);
        delete pItem;
        m_nItem--;
    }

    Assert( m_nItem == 0 );
}


/*   I N I T I A L I Z E   */
/*------------------------------------------------------------------------------

    Initialize list object

------------------------------------------------------------------------------*/
CUIFObject *CUIFListBase::Initialize( void )
{
    RECT rcScroll;

    // create scrollbar

    GetScrollBarRect( &rcScroll );
    m_pUIScroll = CreateScrollBarObj( this, 0, &rcScroll, GetScrollBarStyle() );
    m_pUIScroll->Initialize();
    AddUIObj( m_pUIScroll );

    // calc visible item count

    CalcVisibleCount();

    // initialize scrollbar

    UpdateScrollBar();

    //

    return CUIFObject::Initialize();
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

    Paint procedure of list object

------------------------------------------------------------------------------*/
void CUIFListBase::OnPaint( HDC hDC )
{
    int iLine;
    HFONT hFontOld = (HFONT)SelectObject( hDC, m_hFont );

    for (iLine = 0; iLine < m_nItemVisible + 1; iLine++) {
        CListItemBase *pItem;
        int iItem = m_iItemTop + iLine;
        RECT rc;

        pItem = GetItem( iItem );
        if (pItem != NULL) {
            GetLineRect( iLine, &rc );
            if (!IsRectEmpty( &rc )) {
                PaintItemProc( hDC, &rc, pItem, (iItem == m_iItemSelect) );
            }
        }
    }

    SelectObject( hDC, hFontOld );
}


/*   O N  L B U T T O N  D O W N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFListBase::OnLButtonDown( POINT pt )
{
    int iItemSelNew = ListItemFromPoint( pt );

    if (iItemSelNew != -1) {
        SetSelection( iItemSelNew, TRUE );
    }

    StartCapture();
    StartTimer( 100 );      // TEMP
}


/*   O N  L B U T T O N  U P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFListBase::OnLButtonUp( POINT pt )
{
    BOOL fSelected = FALSE;

    if (IsCapture()) {
        int iItemSelNew = ListItemFromPoint( pt );

        if (iItemSelNew != -1) {
            SetSelection( iItemSelNew, TRUE );
        }
        EndCapture();

        fSelected = (PtInObject( pt ) && iItemSelNew != -1);
    }

    if (IsTimer()) {
        EndTimer();
    }

    // notify

    if (fSelected) {
        NotifyCommand( UILIST_SELECTED, m_iItemSelect );
    }
}


/*   O N  M O U S E  M O V E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFListBase::OnMouseMove( POINT pt )
{
    if (IsCapture()) {
        int iItemSelNew = ListItemFromPoint( pt );

        if (iItemSelNew != -1) {
            SetSelection( iItemSelNew, TRUE );
        }
    }
}


/*   O N  T I M E R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFListBase::OnTimer( void )
{
    POINT pt;

    if (!IsCapture()) {
        return;
    }

    GetCursorPos( &pt );
    ScreenToClient( m_pUIWnd->GetWnd(), &pt );

    if (!PtInObject( pt )) {
        switch (m_dwStyle & UILIST_DIRMASK) {
            default:
            case UILIST_HORZTB: {
                if (pt.y < GetRectRef().top) {
                    // scroll up

                    SetSelection( m_iItemSelect - 1, TRUE );
                }
                else if (GetRectRef().bottom <= pt.y) {
                    // scroll down

                    SetSelection( m_iItemSelect + 1, TRUE );
                }
                break;
            }

            case UILIST_HORZBT: {
                if (pt.y < GetRectRef().top) {
                    // scroll down

                    SetSelection( m_iItemSelect + 1, TRUE );
                }
                else if (GetRectRef().bottom <= pt.y) {
                    // scroll up

                    SetSelection( m_iItemSelect - 1, TRUE );
                }
                break;
            }

            case UILIST_VERTLR: {
                if (GetRectRef().right <= pt.x) {
                    // scroll down

                    SetSelection( m_iItemSelect + 1, TRUE );
                }
                else if (pt.x < GetRectRef().left) {
                    // scroll up

                    SetSelection( m_iItemSelect - 1, TRUE );
                }
                break;
            }

            case UILIST_VERTRL: {
                if (GetRectRef().right <= pt.x) {
                    // scroll up

                    SetSelection( m_iItemSelect - 1, TRUE );
                }
                else if (pt.x < GetRectRef().left) {
                    // scroll down

                    SetSelection( m_iItemSelect + 1, TRUE );
                }
                break;
            }
        }
    }
}


/*   S E T  R E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFListBase::SetRect( const RECT *prc )
{
    RECT rcScroll;

    CUIFObject::SetRect( prc );

    // set scrollbar position

    GetScrollBarRect( &rcScroll );
    m_pUIScroll->SetRect( &rcScroll );

    // calc visible item count

    CalcVisibleCount();

    // update scrollbar

    UpdateScrollBar();
}


/*   S E T  S T Y L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFListBase::SetStyle( DWORD dwStyle )
{
    RECT rcScroll;

    CUIFObject::SetStyle( dwStyle );

    // change scroll bar style either

    m_pUIScroll->SetStyle( GetScrollBarStyle() );

    // set scrollbar position

    GetScrollBarRect( &rcScroll );
    m_pUIScroll->SetRect( &rcScroll );

    // calc visible item count

    CalcVisibleCount();

    // update scrollbar

    UpdateScrollBar();
}


/*   O N  O B J E C T  N O T I F Y   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CUIFListBase::OnObjectNotify( CUIFObject *pUIObj, DWORD dwCommand, LPARAM lParam )
{
    LRESULT lResult = 0;
    
    if (pUIObj == m_pUIScroll) {
        switch (dwCommand) {
            case UISCROLLNOTIFY_SCROLLED: {
                int nCur = (int)lParam;
                int iItemTop;

                if ((m_dwStyle & UILIST_VARIABLEHEIGHT) == 0) {
                    // fixed height

                    iItemTop = nCur;
                }
                else {
                    int nItemPos = 0;
                    int nItemHeight;

                    // variable height

                    for (iItemTop = 0; iItemTop < m_nItem; iItemTop++) {
                        nItemHeight = GetItemHeight( iItemTop );

                        if (nCur < nItemPos + nItemHeight/2) {
                            break;
                        }
                        nItemPos += nItemHeight;
                    }

                }

                SetTop( iItemTop, FALSE );
                break;
            }

            case UISCROLLNOTIFY_SCROLLLN: {
                SetTop((int)(GetTop() + lParam), TRUE );

                lResult = 1; /* processed */
                break;
            }
        }
    }

    return lResult;
}


/*   A D D  I T E M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFListBase::AddItem( CListItemBase *pItem )
{
    int iItem = m_nItem;

    // add to list

    //
    // -1 is error code for CUIFList::AddString()
    //
    if (!m_listItem.Add( pItem ))
        return -1;

    m_nItem++;

    // calc visible item count

    if ((m_dwStyle & UILIST_VARIABLEHEIGHT) != 0) {
        CalcVisibleCount();
    }

    // update scrollbar

    UpdateScrollBar();

    // update window

    CallOnPaint();

    return iItem;
}


/*   G E T  C O U N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFListBase::GetCount( void )
{
    return m_nItem;
}


/*   G E T  I T E M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CListItemBase *CUIFListBase::GetItem( int iItem )
{
    if (0 <= iItem && iItem < m_nItem) {
        return m_listItem.Get( iItem );
    }

    return NULL;
}


/*   D E L  I T E M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFListBase::DelItem( int iItem )
{
    CListItemBase *pItem;

    pItem = GetItem( iItem );
    if (pItem != NULL) {
        // delete item

        m_listItem.Remove(pItem);
        delete pItem;
        m_nItem--;

        // calc visible item count

        if ((m_dwStyle & UILIST_VARIABLEHEIGHT) != 0) {
            CalcVisibleCount();
        }

        // update scrollbar

        UpdateScrollBar();

        // update window

        CallOnPaint();
    }
}


/*   D E L  A L L  I T E M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFListBase::DelAllItem( void )
{
    CListItemBase *pItem;

    while ((pItem = m_listItem.GetFirst()) != NULL) {
        m_listItem.Remove(pItem);
        delete pItem;
        m_nItem--;
    }
    Assert( m_nItem == 0 );

    m_iItemTop = 0;
    m_iItemSelect = 0;

    // calc visible item count

    if ((m_dwStyle & UILIST_VARIABLEHEIGHT) != 0) {
        CalcVisibleCount();
    }

    // update scrollbar

    UpdateScrollBar();

    // update window

    CallOnPaint();
}


/*   S E T  S E L E C T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFListBase::SetSelection( int iSelection, BOOL fRedraw )
{
    BOOL fNotify;

    if (iSelection < -1 || m_nItem <= iSelection) {
        return;
    }

    fNotify = (iSelection != m_iItemSelect) && iSelection != -1 && m_iItemSelect != -1;
    m_iItemSelect = iSelection;

    // make the selection visible always

    int iItemTop = GetTop();
    int iItemBottom = GetBottom();

    if (m_iItemSelect < iItemTop) {
        SetTop( m_iItemSelect, TRUE );
    }
    else if (iItemBottom < m_iItemSelect) {
        if ((m_dwStyle & UILIST_VARIABLEHEIGHT) == 0) {
            // fixed height

            SetTop( m_iItemSelect - m_nItemVisible + 1, TRUE );
        }
        else {
            int nHeight = GetListHeight();
            int nItemShift;
            int ptBottom;
            int i;

            // variable height

            ptBottom = 0;
            for (i = iItemTop; i <= m_iItemSelect; i++) {
                ptBottom += GetItemHeight( i );
            }

            // find number of items to shift

            nItemShift = 0;
            while (nHeight < ptBottom && (iItemTop + nItemShift) < m_iItemSelect) {
                ptBottom -= GetItemHeight( iItemTop + nItemShift );
                nItemShift++;
            }

            // set new top

            SetTop( iItemTop + nItemShift, TRUE );
        }
    }

    if (fRedraw) {
        CallOnPaint();
    }

    if (fNotify) {
        NotifyCommand( UILIST_SELCHANGED, m_iItemSelect );
    }
}


/*   C L E A R  S E L E C T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFListBase::ClearSelection( BOOL fRedraw )
{
    if (m_iItemSelect != -1) {
        m_iItemSelect = -1;

        if (fRedraw) {
            CallOnPaint();
        }

        NotifyCommand( UILIST_SELCHANGED, m_iItemSelect );
    }
}


/*   S E T  L I N E  H E I G H T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFListBase::SetLineHeight( int nLineHeight )
{
    m_nLineHeight = nLineHeight;

    // calc visible item count

    CalcVisibleCount();

    // update scrollbar

    UpdateScrollBar();

    // update window

    CallOnPaint();
}


/*   S E T  T O P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFListBase::SetTop( int nTop, BOOL fSetScrollPos )
{
    nTop = min( nTop, m_nItem );
    nTop = max( nTop, 0 );

    if (m_iItemTop != nTop) {
        m_iItemTop = nTop;

        // calc visible count
                
        if ((m_dwStyle & UILIST_VARIABLEHEIGHT) != 0) {
            CalcVisibleCount();
        }

        CallOnPaint();

        if (fSetScrollPos) {
            // update scrollbar

            UpdateScrollBar();
        }
    }
}


/*   G E T  S E L E C T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFListBase::GetSelection( void )
{
    return m_iItemSelect;
}


/*   G E T  L I N E  H E I G H T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFListBase::GetLineHeight( void )
{
    return m_nLineHeight;
}


/*   G E T  T O P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFListBase::GetTop( void )
{
    return m_iItemTop;
}


/*   G E T  B O T T O M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFListBase::GetBottom( void )
{
    return m_iItemTop + m_nItemVisible - 1; 
}


/*   G E T  V I S I B L E  C O U N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFListBase::GetVisibleCount( void )
{
    return m_nItemVisible; 
}


/*   G E T  I T E M  H E I G H T   */
/*------------------------------------------------------------------------------

    (only called in UILIST_VARIABLEHEIGHT)

------------------------------------------------------------------------------*/
int CUIFListBase::GetItemHeight( int iItem )
{
    return m_nLineHeight;
}


/*   G E T  L I S T  H E I G H T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFListBase::GetListHeight( void )
{
    int nHeight;

    switch (m_dwStyle & UILIST_DIRMASK) {
        default:
        case UILIST_HORZTB:
        case UILIST_HORZBT: {
            nHeight = GetRectRef().bottom - GetRectRef().top;
            break;
        }

        case UILIST_VERTLR:
        case UILIST_VERTRL: {
            nHeight = GetRectRef().right - GetRectRef().left;
            break;
        }
    }

    return nHeight;
}


/*   G E T  L I N E  R E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFListBase::GetLineRect( int iLine, RECT *prc )
{
    int pxyItem = 0;
    int cxyItem = 0;

    if ((m_dwStyle & UILIST_VARIABLEHEIGHT) == 0) {
        // fixed height

        cxyItem = GetLineHeight();
        pxyItem = iLine * cxyItem;
    }
    else {
        int i;

        // variable height

        for (i = 0; i <= iLine; i++) {
            pxyItem += cxyItem;
            cxyItem = GetItemHeight( m_iItemTop + i );
        }
    }

    switch (m_dwStyle & UILIST_DIRMASK) {
        default:
        case UILIST_HORZTB: {
            prc->left   = GetRectRef().left;
            prc->top    = GetRectRef().top + pxyItem;
            prc->right  = GetRectRef().right;
            prc->bottom = GetRectRef().top + (pxyItem + cxyItem);
            break;
        }

        case UILIST_HORZBT: {
            prc->left   = GetRectRef().left;
            prc->top    = GetRectRef().bottom - (pxyItem + cxyItem);
            prc->right  = GetRectRef().right;
            prc->bottom = GetRectRef().bottom - pxyItem;
            break;
        }

        case UILIST_VERTLR: {
            prc->left   = GetRectRef().left + pxyItem;
            prc->top    = GetRectRef().top;
            prc->right  = GetRectRef().left + (pxyItem + cxyItem);
            prc->bottom = GetRectRef().bottom;
            break;
        }

        case UILIST_VERTRL: {
            prc->left   = GetRectRef().right - (pxyItem + cxyItem);
            prc->top    = GetRectRef().top;
            prc->right  = GetRectRef().right - pxyItem;
            prc->bottom = GetRectRef().bottom;
            break;
        }
    }

    // exclude scrollbar 

    if (m_pUIScroll != NULL && m_pUIScroll->IsVisible()) {
        RECT rcScroll;

        m_pUIScroll->GetRect( &rcScroll );

        switch (m_dwStyle & UILIST_DIRMASK) {
            default:
            case UILIST_HORZTB:
            case UILIST_HORZBT: {
                prc->right = min( prc->right, rcScroll.left );
                break;
            }

            case UILIST_VERTLR:
            case UILIST_VERTRL: {
                prc->bottom = max( prc->bottom, rcScroll.top );
                break;
            }
        }
    }

    // clip

    IntersectRect( prc, prc, &GetRectRef() );
}


/*   G E T  S C R O L L  B A R  R E C T   */
/*------------------------------------------------------------------------------

    Get scrollbar position

------------------------------------------------------------------------------*/
void CUIFListBase::GetScrollBarRect( RECT *prc )
{
    Assert( prc != NULL );

    switch (m_dwStyle & UILIST_DIRMASK) {
        default:
        case UILIST_HORZTB:
        case UILIST_HORZBT: {
            prc->left   = GetRectRef().right - GetSystemMetrics(SM_CXVSCROLL);
            prc->top    = GetRectRef().top;
            prc->right  = GetRectRef().right;
            prc->bottom = GetRectRef().bottom;
            break;
        }

        case UILIST_VERTLR:
        case UILIST_VERTRL: {
            prc->left   = GetRectRef().left;
            prc->top    = GetRectRef().bottom - GetSystemMetrics(SM_CYHSCROLL);
            prc->right  = GetRectRef().right;
            prc->bottom = GetRectRef().bottom;
            break;
        }
    }
}


/*   G E T  S C R O L L  B A R  S T Y L E   */
/*------------------------------------------------------------------------------

    Get scrollbar style

------------------------------------------------------------------------------*/
DWORD CUIFListBase::GetScrollBarStyle( void )
{
    DWORD dwScrollStyle;

    switch (m_dwStyle & UILIST_DIRMASK) {
        default:
        case UILIST_HORZTB: {
            dwScrollStyle = UISCROLL_VERTTB;
            break;
        }

        case UILIST_HORZBT: {
            dwScrollStyle = UISCROLL_VERTBT;
            break;
        }

        case UILIST_VERTLR: {
            dwScrollStyle = UISCROLL_HORZLR;
            break;
        }

        case UILIST_VERTRL: {
            dwScrollStyle = UISCROLL_HORZRL;
            break;
        }
    }
    return dwScrollStyle;
}


/*   C R E A T E  S C R O L L  B A R  O B J   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFScroll *CUIFListBase::CreateScrollBarObj( CUIFObject *pParent, DWORD dwID, RECT *prc, DWORD dwStyle )
{
    return new CUIFScroll( pParent, dwID, prc, dwStyle );
}


/*   P A I N T  I T E M  P R O C   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFListBase::PaintItemProc( HDC hDC, RECT *prc, CListItemBase *pItem, BOOL fSelected )
{
    COLORREF colText;
    COLORREF colBack;

    Assert( pItem != NULL );

    // set color

    if (fSelected) {
        colText = GetSysColor(COLOR_HIGHLIGHTTEXT);
        colBack = GetSysColor(COLOR_HIGHLIGHT);
    }
    else {
        colText = GetSysColor(COLOR_WINDOWTEXT);
        colBack = GetSysColor(COLOR_3DFACE);
    }

    SetTextColor( hDC, colText );
    SetBkColor( hDC, colBack );

    // 

    CUIExtTextOut( hDC, prc->left, prc->top, ETO_OPAQUE | ETO_CLIPPED, prc, L"", 0, NULL );
}


/*   L I S T  I T E M  F R O M  P O I N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFListBase::ListItemFromPoint( POINT pt )
{
    if (PtInObject( pt )) {
        int iLine;
        RECT rc;

        for (iLine = 0; iLine < m_nItemVisible + 1; iLine++) {
            if (m_nItem <= m_iItemTop + iLine) {
                break;
            }

            GetLineRect( iLine, &rc );
            if (PtInRect( &rc, pt )) {
                return iLine + m_iItemTop;
            }
        }
    }

    return (-1);
}


/*   C A L C  V I S I B L E  C O U N T   */
/*------------------------------------------------------------------------------

    Calculate number of visible item

------------------------------------------------------------------------------*/
void CUIFListBase::CalcVisibleCount( void )
{
    int nHeight = GetListHeight();

    if ((m_dwStyle & UILIST_VARIABLEHEIGHT) == 0) {
        // fixed height

	if (m_nLineHeight <= 0) {
		m_nItemVisible = 0;
	}
	else {
	        m_nItemVisible = nHeight / m_nLineHeight;
	}
    }
    else {
        // variable height

        if (0 < m_nItem) {
            int i = m_iItemTop;

            // count visible item

            m_nItemVisible = 0;
            while (0 < nHeight && i < m_nItem) {
                nHeight -= GetItemHeight( i );
                m_nItemVisible++;
                i++;
            }

            // adjustment

            if (0 < nHeight && m_nItemVisible == 0) {
                // at least, one item is visible

                m_nItemVisible = 1;
            }
            else if (nHeight < 0 && 1 < m_nItemVisible) {
                // exclude last item if clipped

                m_nItemVisible--;
            }
        }
        else {
            m_nItemVisible = 0;
        }
    }
}


/*   U P D A T E  S C R O L L  B A R   */
/*------------------------------------------------------------------------------

    Update scrollbar range and visible status

------------------------------------------------------------------------------*/
void CUIFListBase::UpdateScrollBar( void )
{
    UIFSCROLLINFO ScrollInfo;

    Assert( m_pUIScroll != NULL );

    // set scroll range/current pos

    if ((m_dwStyle & UILIST_VARIABLEHEIGHT) == 0) {
        // fixed height

        ScrollInfo.nMax  = m_nItem;
        ScrollInfo.nPage = m_nItemVisible;
        ScrollInfo.nPos  = m_iItemTop;
    }
    else {
        int nTotal    = 0;
        int nTop      = 0;
        int nVisible  = 0;
        int i;

        // variable height

        nVisible = GetListHeight();
        for (i = 0; i < m_nItem; i++) {
            int nItemHeight = GetItemHeight( i );

            if (i < m_iItemTop) {
              nTop += nItemHeight;
            }

            nTotal += nItemHeight;
        }

        // adjust gap at the end of list

        if (nVisible < nTotal) {
            int nLastPage = 0;

            for (i = m_nItem-1; 0 <= i; i--) {
                int nItemHeight = GetItemHeight( i );

                if (nVisible < nLastPage + nItemHeight) {
                    break;
                }
                nLastPage += nItemHeight;
            }

            if (0 < nLastPage && nLastPage < nVisible) {
                nTotal += (nVisible - nLastPage);
            }
        }

        ScrollInfo.nMax  = nTotal;
        ScrollInfo.nPage = nVisible;
        ScrollInfo.nPos  = nTop;
    }
    m_pUIScroll->SetScrollInfo( &ScrollInfo );

    // show/hide scroll bar

    if ((m_dwStyle & UILIST_DISABLENOSCROLL) == 0) {
        m_pUIScroll->Show( ScrollInfo.nPage < ScrollInfo.nMax );
    }
}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  L I S T                                                         */
/*                                                                             */
/*=============================================================================*/

//
// CListItem
//

class CListItem : public CListItemBase
{
public:
    CListItem( WCHAR *psz, int nId )
    {
        m_pwch = NULL;
        m_nId = nId;
        m_dwData = 0;

        if (psz != NULL) {
            m_pwch = new WCHAR[ StrLenW(psz) + 1 ];
            if (m_pwch != NULL) {
                StrCpyW( m_pwch, psz );
            }
        }
    }

    virtual ~CListItem( void )
    {
        if (m_pwch != NULL) {
            delete m_pwch;
        }
    }

    __inline LPCWSTR GetString( void )
    {
        return m_pwch;
    }

    __inline int GetID( void )
    {
        return m_nId;
    }

    __inline void SetData( DWORD dwData )
    {
        m_dwData = dwData;
    }

    __inline DWORD GetData( void )
    {
        return m_dwData;
    }

protected:
    WCHAR *m_pwch;
    int   m_nId;
    DWORD m_dwData;
};


//
// CUIFList
//

/*   C  U I F  L I S T   */
/*------------------------------------------------------------------------------

    Constructor of CUIFList

------------------------------------------------------------------------------*/
CUIFList::CUIFList( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFListBase( pParent, dwID, prc, dwStyle )
{
}


/*   ~  C  U I F  L I S T   */
/*------------------------------------------------------------------------------

    Destructor of CUIFList

------------------------------------------------------------------------------*/
CUIFList::~CUIFList( void )
{
}


/*   A D D  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFList::AddString( WCHAR *psz )
{
    CListItem *pItem = new CListItem( psz, GetCount() );
    if (!pItem)
    {
        //
        // is it ok to return -1?
        //
        return -1;
    }

    return AddItem( pItem );
}


/*   G E T  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LPCWSTR CUIFList::GetString( int nID )
{
    int iItem = ItemFromID( nID );
    CListItem *pItem;

    pItem = (CListItem *)GetItem( iItem );
    if (pItem != NULL) {
        return pItem->GetString();
    }

    return NULL;
}


/*   D E L E T E  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFList::DeleteString( int nID )
{
    int iItem = ItemFromID( nID );

    if (iItem != -1) {
        DelItem( iItem );
    }
}


/*   D E L E T E  A L L  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFList::DeleteAllString( void )
{
    DelAllItem();
}


/*   S E T  P R I V A T E  D A T A   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFList::SetPrivateData( int nID, DWORD dw )
{
    int iItem = ItemFromID( nID );
    CListItem *pItem;

    pItem = (CListItem *)GetItem( iItem );
    if (pItem != NULL) {
        pItem->SetData( dw );
    }
}


/*   G E T  P R I V A T E  D A T A   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
DWORD CUIFList::GetPrivateData( int nID )
{
    int iItem = ItemFromID( nID );
    CListItem *pItem;

    pItem = (CListItem *)GetItem( iItem );
    if (pItem != NULL) {
        return pItem->GetData();
    }

    return 0;
}


/*   I T E M  F R O M  I D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFList::ItemFromID( int iID )
{
    int nItem;
    int i;

    nItem = GetCount();
    for (i = 0; i < nItem; i++) {
        CListItem *pItem = (CListItem *)GetItem( i );

        if (iID == pItem->GetID()) {
            return i;
        }
    }

    return -1;
}


/*   P A I N T  I T E M  P R O C   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFList::PaintItemProc( HDC hDC, RECT *prc, CListItemBase *pItem, BOOL fSelected )
{
    CListItem *pListItem = (CListItem *)pItem;
    COLORREF colText;
    COLORREF colBack;
    LPCWSTR pwch;
    SIZE  size;
    POINT ptOrg;

    Assert( pListItem != NULL );
    pwch = pListItem->GetString();
    if (pwch == NULL) {
        return;
    }

    // set color

    if (fSelected) {
        colText = GetSysColor(COLOR_HIGHLIGHTTEXT);
        colBack = GetSysColor(COLOR_HIGHLIGHT);
    }
    else {
        colText = GetSysColor(COLOR_WINDOWTEXT);
        colBack = GetSysColor(COLOR_3DFACE);
    }

    SetTextColor( hDC, colText );
    SetBkColor( hDC, colBack );

    // calc origin

    GetTextExtentPointW( hDC, pwch, StrLenW(pwch), &size );
    switch (m_dwStyle & UILIST_DIRMASK) {
        default:
        case UILIST_HORZTB: {
            ptOrg.x = prc->left;
            ptOrg.y = (prc->bottom + prc->top - size.cy) / 2;
            break;
        }

        case UILIST_HORZBT: {
            ptOrg.x = prc->right;
            ptOrg.y = (prc->bottom + prc->top + size.cy) / 2;
            break;
        }

        case UILIST_VERTLR: {
            ptOrg.x = (prc->right + prc->left - size.cy) / 2;
            ptOrg.y = prc->bottom;
            break;
        }

        case UILIST_VERTRL: {
            ptOrg.x = (prc->right + prc->left + size.cy) / 2;
            ptOrg.y = prc->top;
            break;
        }
    }

    CUIExtTextOut( hDC, ptOrg.x, ptOrg.y, ETO_OPAQUE | ETO_CLIPPED, prc, pwch, StrLenW(pwch), NULL );
}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  G R I P P E R                                                   */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  G R I P P E R   */
/*------------------------------------------------------------------------------

    Constructor of CUIFGripper

------------------------------------------------------------------------------*/
CUIFGripper::CUIFGripper( CUIFObject *pParent, const RECT *prc, DWORD dwStyle ) : CUIFObject( pParent, 0, prc, dwStyle )
{
    if (IsVertical())
        SetActiveTheme(L"REBAR", RP_GRIPPERVERT);
    else
        SetActiveTheme(L"REBAR", RP_GRIPPER);
}


/*   ~  C  U I F  G R I P P E R   */
/*------------------------------------------------------------------------------

    Destructor of CUIFGripper

------------------------------------------------------------------------------*/
CUIFGripper::~CUIFGripper( void )
{
}

/*   O N  P A I N T  T H E M E */
/*------------------------------------------------------------------------------

    Paint procedure of gripper object

------------------------------------------------------------------------------*/
void CUIFGripper::SetStyle( DWORD dwStyle )
{
    CUIFObject::SetStyle(dwStyle);
    if (IsVertical())
        SetActiveTheme(L"REBAR", RP_GRIPPERVERT);
    else
        SetActiveTheme(L"REBAR", RP_GRIPPER);
}

/*   O N  P A I N T  T H E M E */
/*------------------------------------------------------------------------------

    Paint procedure of gripper object

------------------------------------------------------------------------------*/
BOOL CUIFGripper::OnPaintTheme( HDC hDC )
{
    BOOL fRet = FALSE;
    int    iStateID;
    RECT rc;

    iStateID = TS_NORMAL;

    if (FAILED(EnsureThemeData( GetUIWnd()->GetWnd())))
        goto Exit;

    rc = GetRectRef();
    if (!IsVertical())
    {
       rc.left  += CUI_GRIPPER_THEME_MARGIN;
       rc.right -= CUI_GRIPPER_THEME_MARGIN;
    }
    else
    {
       rc.top    += CUI_GRIPPER_THEME_MARGIN;
       rc.bottom -= CUI_GRIPPER_THEME_MARGIN;
    }

    if (FAILED(DrawThemeBackground(hDC, iStateID, &rc, 0 )))
        goto Exit;

    fRet = TRUE;
Exit:
    return fRet;
}

/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

    Paint procedure of gripper object

------------------------------------------------------------------------------*/
void CUIFGripper::OnPaintNoTheme( HDC hDC )
{
    CUIFWindow *pWnd = GetUIWnd();
    CUIFScheme *pUIFScheme = pWnd->GetUIFScheme();
    if (pUIFScheme)
    {
        pUIFScheme->DrawDragHandle(hDC, &GetRectRef(), IsVertical());
    }
    else
    {
        RECT rc;
        if (!IsVertical())
        {
            ::SetRect(&rc, 
                      GetRectRef().left + 1, 
                      GetRectRef().top, 
                      GetRectRef().left + 4, 
                      GetRectRef().bottom);
        }
        else
        {
            ::SetRect(&rc, 
                      GetRectRef().left, 
                      GetRectRef().top + 1, 
                      GetRectRef().right, 
                      GetRectRef().top + 4);
        }

        DrawEdge(hDC, &rc, BDR_RAISEDINNER, BF_RECT);
    }

}


/*   O N  S E T  C U R S O R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CUIFGripper::OnSetCursor( UINT uMsg, POINT pt )
{
    SetCursor(LoadCursor(NULL, IDC_SIZEALL));
    return TRUE;
}


/*   O N  L  B U T T O N  D O W N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFGripper::OnLButtonDown( POINT pt )
{
    RECT rc;
    StartCapture();
    _ptCur  = pt;
    ClientToScreen(m_pUIWnd->GetWnd(), &_ptCur);
    GetWindowRect(m_pUIWnd->GetWnd(), &rc);
    _ptCur.x -= rc.left;
    _ptCur.y -= rc.top;
}


/*   O N  L  B U T T O N  U P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFGripper::OnLButtonUp( POINT pt )
{
    if (IsCapture())
    {
        EndCapture();
    }
}


/*   O N  M O U S E  M O V E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFGripper::OnMouseMove( POINT pt )
{
    if (IsCapture())
    {
        POINT ptCursor;
        GetCursorPos(&ptCursor);
        m_pUIWnd->Move(ptCursor.x - _ptCur.x, ptCursor.y - _ptCur.y, -1, -1);
    }
}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  W N D  F R A M E                                                */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  W N D  F R A M E   */
/*------------------------------------------------------------------------------

    Constructor of CUIFWndFrame

------------------------------------------------------------------------------*/
CUIFWndFrame::CUIFWndFrame( CUIFObject *pParent, const RECT *prc, DWORD dwStyle ) : CUIFObject( pParent, 0, prc, dwStyle )
{
    SetActiveTheme(L"WINDOW", WP_FRAMELEFT);

    m_dwHTResizing = 0;

    m_cxFrame = 0;
    m_cyFrame = 0;
    if (GetUIFScheme())
    {
        switch (GetStyle() & UIWNDFRAME_STYLEMASK) {
            default:
            case UIWNDFRAME_THIN: {
                m_cxFrame = GetUIFScheme()->CxWndBorder();
                m_cyFrame = GetUIFScheme()->CxWndBorder();
                break;
            }

            case UIWNDFRAME_THICK:
            case UIWNDFRAME_ROUNDTHICK: {
                m_cxFrame = GetUIFScheme()->CxSizeFrame();
                m_cyFrame = GetUIFScheme()->CySizeFrame();
                break;
            }
        }
    }

    m_cxMin = GetSystemMetrics( SM_CXMIN );
    m_cyMin = GetSystemMetrics( SM_CYMIN );
}


/*   ~  C  U I F  W N D  F R A M E   */
/*------------------------------------------------------------------------------

    Destructor of CUIFWndFrame

------------------------------------------------------------------------------*/
CUIFWndFrame::~CUIFWndFrame( void )
{
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

    Paint procedure of wnd frame object

------------------------------------------------------------------------------*/
BOOL CUIFWndFrame::OnPaintTheme( HDC hDC )
{
    BOOL fRet = FALSE;

    if (FAILED(EnsureThemeData(m_pUIWnd->GetWnd())))
        goto Exit;

    //
    // DrawThemebackground() does not draw caption.
    // so we draw the frame with 4 lines by DrawThemeLine().
    //

    // if (FAILED(DrawThemeBackground(hDC, FS_ACTIVE, &GetRectRef(), 0 )))
    //     goto Exit;

    RECT rc;

    //
    // draw left side
    //
    rc = GetRectRef();
    rc.right = m_cxFrame;
    if (FAILED(DrawThemeEdge(hDC, 0, &rc, EDGE_RAISED, BF_LEFT )))
        goto Exit;

    //
    // draw right side
    //
    rc = GetRectRef();
    rc.left = rc.right - m_cxFrame;
    if (FAILED(DrawThemeEdge(hDC, 0, &rc, EDGE_SUNKEN, BF_RIGHT )))
        goto Exit;

    //
    // draw top side
    //
    rc = GetRectRef();
    rc.bottom = m_cyFrame;
    if (FAILED(DrawThemeEdge(hDC, 0, &rc, EDGE_RAISED, BF_TOP )))
        goto Exit;

    //
    // draw bottom side
    //
    rc = GetRectRef();
    rc.top = rc.bottom - m_cyFrame;
    if (FAILED(DrawThemeEdge(hDC, 0, &rc, EDGE_SUNKEN, BF_BOTTOM )))
        goto Exit;

    fRet = TRUE;
Exit:
    return fRet;
}

/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

    Paint procedure of wnd frame object

------------------------------------------------------------------------------*/
void CUIFWndFrame::OnPaintNoTheme( HDC hDC )
{
    if (!GetUIFScheme())
        return;

    DWORD dwFlag = 0;

    switch (GetStyle() & UIWNDFRAME_STYLEMASK) {
        default:
        case UIWNDFRAME_THIN: {
            dwFlag = UIFDWF_THIN;
            break;
        }

        case UIWNDFRAME_THICK: {
            dwFlag = UIFDWF_THICK;
            break;
        }

        case UIWNDFRAME_ROUNDTHICK: {
            dwFlag = UIFDWF_ROUNDTHICK;
            break;
        }
    }

    GetUIFScheme()->DrawWndFrame( hDC, &GetRectRef(), dwFlag, m_cxFrame, m_cyFrame );
}


/*   O N  S E T  C U R S O R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CUIFWndFrame::OnSetCursor( UINT uMsg, POINT pt )
{
    DWORD   dw;
    LPCTSTR idc = NULL;

    if (IsCapture()) {
        dw = m_dwHTResizing;
    }
    else {
        dw = HitTest( pt ) & GetStyle();
    }

    if (dw == (UIWNDFRAME_RESIZELEFT | UIWNDFRAME_RESIZETOP)) {
        idc = IDC_SIZENWSE;
    }
    else if (dw == (UIWNDFRAME_RESIZELEFT | UIWNDFRAME_RESIZEBOTTOM)) {
        idc = IDC_SIZENESW;
    }
    else if (dw == (UIWNDFRAME_RESIZERIGHT | UIWNDFRAME_RESIZETOP)) {
        idc = IDC_SIZENESW;
    }
    else if (dw == (UIWNDFRAME_RESIZERIGHT | UIWNDFRAME_RESIZEBOTTOM)) {
        idc = IDC_SIZENWSE;
    }
    else if (dw == UIWNDFRAME_RESIZELEFT) {
        idc = IDC_SIZEWE;
    }
    else if (dw == UIWNDFRAME_RESIZETOP) {
        idc = IDC_SIZENS;
    }
    else if (dw == UIWNDFRAME_RESIZERIGHT) {
        idc = IDC_SIZEWE;
    }
    else if (dw == UIWNDFRAME_RESIZEBOTTOM) {
        idc = IDC_SIZENS;
    }

    if (idc != NULL) {
        SetCursor( LoadCursor( NULL, idc ) );
        return TRUE;
    }

    return FALSE;
}


/*   O N  L  B U T T O N  D O W N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWndFrame::OnLButtonDown( POINT pt )
{
    DWORD   dwHT;

    dwHT = HitTest( pt ) & GetStyle();

    if (dwHT != 0) {
        ClientToScreen( m_pUIWnd->GetWnd(), &pt );

        m_ptDrag = pt;
        m_dwHTResizing = dwHT;
        GetWindowRect( m_pUIWnd->GetWnd(), &m_rcOrg );

        StartCapture();
    }
}


/*   O N  L  B U T T O N  U P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWndFrame::OnLButtonUp( POINT pt )
{
    if (IsCapture()) {
        EndCapture();
    }
}


/*   O N  M O U S E  M O V E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWndFrame::OnMouseMove( POINT pt )
{
    if (IsCapture()) {
        RECT rc = m_rcOrg;

        ClientToScreen( m_pUIWnd->GetWnd(), &pt );

        if (m_dwHTResizing & UIWNDFRAME_RESIZELEFT) {
            rc.left = m_rcOrg.left + (pt.x - m_ptDrag.x);
        }
        if (m_dwHTResizing & UIWNDFRAME_RESIZETOP) {
            rc.top = m_rcOrg.top + (pt.y - m_ptDrag.y);
        }
        if (m_dwHTResizing & UIWNDFRAME_RESIZERIGHT) {
            rc.right = m_rcOrg.right + (pt.x - m_ptDrag.x);
            rc.right = max( rc.right, rc.left + m_cxMin );
        }
        if (m_dwHTResizing & UIWNDFRAME_RESIZEBOTTOM) {
            rc.bottom = m_rcOrg.bottom + (pt.y - m_ptDrag.y);
            rc.bottom = max( rc.bottom, rc.top + m_cyMin );
        }

        m_pUIWnd->Move( rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top );
    }
}


/*   G E T  I N T E R N A L  R E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWndFrame::GetInternalRect( RECT *prc )
{
    Assert( prc != NULL );

    *prc = GetRectRef();
    prc->left   = prc->left   + m_cxFrame;
    prc->top    = prc->top    + m_cyFrame;
    prc->right  = prc->right  - m_cxFrame;
    prc->bottom = prc->bottom - m_cyFrame;
}


/*   H I T  T E S T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
DWORD CUIFWndFrame::HitTest( POINT pt )
{
    DWORD dwHT = 0;

    dwHT |= (GetRectRef().left <= pt.x && pt.x < GetRectRef().left + m_cxFrame) ? UIWNDFRAME_RESIZELEFT : 0;
    dwHT |= (GetRectRef().top  <= pt.y && pt.y < GetRectRef().top  + m_cyFrame) ? UIWNDFRAME_RESIZETOP  : 0;
    dwHT |= (GetRectRef().right  - m_cxFrame <= pt.x && pt.x < GetRectRef().right ) ? UIWNDFRAME_RESIZERIGHT  : 0;
    dwHT |= (GetRectRef().bottom - m_cyFrame <= pt.y && pt.y < GetRectRef().bottom) ? UIWNDFRAME_RESIZEBOTTOM : 0;

    return dwHT;
}


/*   G E T  F R A M E  S I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWndFrame::GetFrameSize( SIZE *psize )
{
    Assert( psize != NULL );

    psize->cx = m_cxFrame;
    psize->cy = m_cyFrame;
}


/*   S E T  F R A M E  S I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWndFrame::SetFrameSize( SIZE *psize )
{
    Assert( psize != NULL );

    m_cxFrame = psize->cx;
    m_cyFrame = psize->cy;

    CallOnPaint();
}


/*   G E T  M I N I M U M  S I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWndFrame::GetMinimumSize( SIZE *psize )
{
    Assert( psize != NULL );

    psize->cx = m_cxMin;
    psize->cy = m_cyMin;
}


/*   S E T  M I N I M U M  S I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWndFrame::SetMinimumSize( SIZE *psize )
{
    Assert( psize != NULL );

    if (psize->cx != -1) {
        m_cxMin = psize->cx;
    }
    if (psize->cy != -1) {
        m_cyMin = psize->cy;
    }
}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  W N D  C A P T I O N                                            */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  W N D  C A P T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFWndCaption::CUIFWndCaption( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFStatic( pParent, dwID, prc, dwStyle )
{
}


/*   ~  C  U I F  W N D  C A P T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFWndCaption::~CUIFWndCaption( void )
{
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWndCaption::OnPaint( HDC hDC )
{
    HFONT    hFontOld;
    COLORREF colTextOld;
    int      iBkModeOld;
    int      xAlign;
    int      yAlign;
    SIZE     size;
    int      cwch;
    UIFCOLOR colBkgnd;
    UIFCOLOR colText;

    // 

    if (FHasStyle( UIWNDCAPTION_ACTIVE )) {
        colBkgnd = UIFCOLOR_ACTIVECAPTIONBKGND;
        colText  = UIFCOLOR_ACTIVECAPTIONTEXT;
    }
    else {
        colBkgnd = UIFCOLOR_INACTIVECAPTIONBKGND;
        colText  = UIFCOLOR_INACTIVECAPTIONTEXT;
    }

    // background

    FillRect( hDC, &GetRectRef(), GetUIFBrush( colBkgnd ) );

    // caption text

    if (m_pwchText == NULL) {
        return;
    }

    // prepare objects

    hFontOld= (HFONT)SelectObject( hDC, GetFont() );
    colTextOld = SetTextColor( hDC, GetUIFColor( colText ) );
    iBkModeOld = SetBkMode( hDC, TRANSPARENT );

    // calc alignment

    cwch = StrLenW(m_pwchText);
    GetTextExtentPointW( hDC, m_pwchText, cwch, &size );

    xAlign = 8;
    yAlign = (GetRectRef().bottom - GetRectRef().top - size.cy) / 2;

    // draw

    CUIExtTextOut( hDC,
                    GetRectRef().left + xAlign,
                    GetRectRef().top + yAlign,
                    ETO_CLIPPED,
                    &GetRectRef(),
                    m_pwchText,
                    cwch,
                    NULL );

    // restore objects

    SelectObject( hDC, hFontOld );
    SetTextColor( hDC, colTextOld );
    SetBkMode( hDC, iBkModeOld );
}


/*   O N  L  B U T T O N  D O W N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWndCaption::OnLButtonDown( POINT pt )
{
    RECT rc;

    if (!FHasStyle( UIWNDCAPTION_MOVABLE )) {
        return;
    }

    StartCapture();
    SetCursor( LoadCursor( NULL, IDC_SIZEALL ) );

    m_ptDrag = pt;
    ClientToScreen( m_pUIWnd->GetWnd(), &m_ptDrag );
    GetWindowRect( m_pUIWnd->GetWnd(), &rc );
    m_ptDrag.x -= rc.left;
    m_ptDrag.y -= rc.top;
}


/*   O N  L  B U T T O N  U P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWndCaption::OnLButtonUp( POINT pt )
{
    if (IsCapture()) {
        EndCapture();
        SetCursor( LoadCursor( NULL, IDC_ARROW ) );
    }
}


/*   O N  M O U S E  M O V E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWndCaption::OnMouseMove( POINT pt )
{
    if (IsCapture()) {
        POINT ptCursor;

        GetCursorPos( &ptCursor );
        m_pUIWnd->Move( ptCursor.x - m_ptDrag.x, ptCursor.y - m_ptDrag.y, -1, -1 );
    }
}


/*   O N  S E T  C U R S O R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CUIFWndCaption::OnSetCursor( UINT uMsg, POINT pt )
{
    if (IsCapture()) {
        SetCursor( LoadCursor( NULL, IDC_SIZEALL ) );
    }
    else {
        SetCursor( LoadCursor( NULL, IDC_ARROW ) );
    }
    return TRUE;
}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  C A P T I O N  B U T T O N                                      */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  C A P T I O N  B U T T O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFCaptionButton::CUIFCaptionButton( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFButton2( pParent, dwID, prc, dwStyle )
{
}


/*   ~  C  U I F  C A P T I O N  B U T T O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFCaptionButton::~CUIFCaptionButton( void )
{
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFCaptionButton::OnPaint( HDC hDC )
{
    DWORD   dwState = 0;
    HDC     hDCMem;
    HBITMAP hBmpMem;
    HBITMAP hBmpOld;
    SIZE    size;
    RECT    rc;
    SIZE    sizeText  = {0};
    SIZE    sizeImage = {0};
    SIZE    sizeFace  = {0};
    SIZE    offset    = {0};
    RECT    rcText    = {0};
    RECT    rcImage   = {0};
    RECT    rcFace    = {0};
    HFONT   hFontOld;

    if (!m_pUIFScheme)
        return;

    // make draw flag

    dwState |= (m_fToggled) ? UIFDCS_SELECTED : 0;
    switch (m_dwStatus) {
        case UIBUTTON_DOWN: {
            dwState |= UIFDCS_MOUSEDOWN;
            break;
        }

        case UIBUTTON_HOVER:
        case UIBUTTON_DOWNOUT: {
            dwState |= UIFDCS_MOUSEOVER;
            break;
        }
    }
    dwState |= IsEnabled() ? 0 : UIFDCS_DISABLED;
    dwState |= (FHasStyle( UICAPTIONBUTTON_ACTIVE ) ? UIFDCS_ACTIVE : UIFDCS_INACTIVE);

    // prepare memory dc

    size.cx = GetRectRef().right - GetRectRef().left;
    size.cy = GetRectRef().bottom - GetRectRef().top;

    hDCMem = CreateCompatibleDC( hDC );
    hBmpMem = CreateCompatibleBitmap( hDC, size.cx, size.cy );
    hBmpOld = (HBITMAP)SelectObject( hDCMem, hBmpMem );

    BitBlt( hDCMem, 0, 0, size.cx, size.cy, hDC, GetRectRef().left, GetRectRef().top, SRCCOPY );

    ::SetRect( &rc, 0, 0, size.cx, size.cy );
    hFontOld = (HFONT)SelectObject( hDCMem, GetFont() );


    // calc face size

    if (m_pwchText != NULL) {
        sizeText  = m_sizeText;
    }
    if (m_hIcon != NULL) { 
        sizeImage  = m_sizeIcon;
    }
    else if (m_hBmp != NULL ) {
        sizeImage  = m_sizeBmp;
    }

    // alignment

    sizeFace.cx = sizeText.cx + sizeImage.cx + ((sizeText.cx != 0 && sizeImage.cx != 0) ? 2 : 0);
    sizeFace.cy = max( sizeText.cy, sizeImage.cy );

    switch (GetStyleBits( UIBUTTON_HALIGNMASK )) {
        case UIBUTTON_LEFT:
        default: {
            rcFace.left   = rc.left + 2;
            rcFace.right  = rcFace.left + sizeFace.cx;
            break;
        }

        case UIBUTTON_CENTER: {
            rcFace.left   = (rc.right + rc.left - sizeFace.cx) / 2;
            rcFace.right  = rcFace.left + sizeFace.cx;
            break;
        }

        case UIBUTTON_RIGHT: {
            rcFace.left   = rc.right - 2 - sizeText.cx;
            rcFace.right  = rcFace.left + sizeFace.cx;
            break;
        }
    }

    switch (GetStyleBits( UIBUTTON_VALIGNMASK )) {
        case UIBUTTON_TOP:
        default: {
            rcFace.top    = rc.top + 2;
            rcFace.bottom = rcFace.top + sizeFace.cy;
            break;
        }

        case UIBUTTON_VCENTER: {
            rcFace.top     = (rc.bottom + rc.top - sizeFace.cy) / 2;
            rcFace.bottom  = rcFace.top + sizeFace.cy;
            break;
        }

        case UIBUTTON_BOTTOM: {
            rcFace.top    = rc.bottom - 2 - sizeFace.cy;
            rcFace.bottom = rcFace.top + sizeFace.cy;
            break;
        }
    }

    m_pUIFScheme->GetCtrlFaceOffset( UIFDCF_CAPTIONBUTTON, dwState, &offset );
    OffsetRect( &rcFace, offset.cx, offset.cy );

    rcImage.left   = rcFace.left;
    rcImage.top    = (rcFace.bottom + rcFace.top - sizeImage.cy) / 2;
    rcImage.right  = rcImage.left + sizeImage.cx;
    rcImage.bottom = rcImage.top  + sizeImage.cy;

    rcText.left    = rcFace.right - sizeText.cx;
    rcText.top     = (rcFace.bottom + rcFace.top - sizeText.cy) / 2;
    rcText.right   = rcText.left + sizeText.cx;
    rcText.bottom  = rcText.top  + sizeText.cy;

    // paint background

    m_pUIFScheme->DrawFrameCtrlBkgd( hDCMem, &rc, UIFDCF_CAPTIONBUTTON, dwState );

    // paint face

    if (m_hIcon!= NULL) {
        m_pUIFScheme->DrawFrameCtrlIcon( hDCMem, &rcImage, m_hIcon, dwState, &m_sizeIcon);
    }
    else if (m_hBmp != NULL) {
        m_pUIFScheme->DrawFrameCtrlBitmap( hDCMem, &rcImage, m_hBmp, m_hBmpMask, dwState );
    }

    // draw button edge

    m_pUIFScheme->DrawFrameCtrlEdge( hDCMem, &rc, UIFDCF_CAPTIONBUTTON, dwState );

    //

    BitBlt( hDC, GetRectRef().left, GetRectRef().top, size.cx, size.cy, hDCMem, 0, 0, SRCCOPY );

    SelectObject( hDCMem, hFontOld );
    SelectObject( hDCMem, hBmpOld );
    DeleteObject( hBmpMem );
    DeleteDC( hDCMem );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuiobj.h ===
//
// cuiobj.h
//  = UI object library - define UI objects =
//

//
//      CUIFObject
//        +- CUIFBorder                 border object
//        +- CUIFStatic                 static object
//        +- CUIFButton                 button object
//        |    +- CUIFScrollButton      scrollbar button object (used in CUIFScroll)
//        +- CUIFScrollButton               scrollbar thumb object (used in CUIFScroll)
//        +- CUIFScroll                 scrollbar object
//        +- CUIFList                   listbox object
//        +- CUIFGripper                gripper object
//        +- CUIFWindow                 window frame object (need to be at top of parent)
//


#ifndef CUIOBJ_H
#define CUIOBJ_H

#include "cuischem.h"
#include "cuiarray.h"
#include "cuitheme.h"
#include "cuiicon.h"


class CUIFWindow;

//
// CUIFObject
//-----------------------------------------------------------------------------

//
// CUIFObject
//  = base class of UI object =
//

class CUIFObject: public CUIFTheme
{
public:
    CUIFObject( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
    virtual ~CUIFObject( void );

    virtual CUIFObject *Initialize( void );
    virtual void OnPaint( HDC hDC );
    virtual void OnTimer( void )                        { return; }
    virtual void OnLButtonDown( POINT pt )              { return; }
    virtual void OnMButtonDown( POINT pt )              { return; }
    virtual void OnRButtonDown( POINT pt )              { return; }
    virtual void OnLButtonUp( POINT pt )                { return; }
    virtual void OnMButtonUp( POINT pt )                { return; }
    virtual void OnRButtonUp( POINT pt )                { return; }
    virtual void OnMouseMove( POINT pt )                { return; }
    virtual void OnMouseIn( POINT pt )                  { return; }
    virtual void OnMouseOut( POINT pt )                 { return; }
    virtual BOOL OnSetCursor( UINT uMsg, POINT pt )     { return FALSE; }

    virtual void GetRect( RECT *prc );
    virtual void SetRect( const RECT *prc );
    virtual BOOL PtInObject( POINT pt );

    virtual void PaintObject( HDC hDC, const RECT *prcUpdate );
    virtual void CallOnPaint(void);

    virtual void Enable( BOOL fEnable );
    __inline BOOL IsEnabled( void )
    {
        return m_fEnabled;
    }

    virtual void Show( BOOL fShow );
    __inline BOOL IsVisible( void )
    {
        return m_fVisible;
    }

    virtual void SetFontToThis( HFONT hFont );
    virtual void SetFont( HFONT hFont );
    __inline HFONT GetFont( void )
    {
        return m_hFont;
    }

    virtual void SetStyle( DWORD dwStyle );
    __inline DWORD GetStyle( void )
    {
        return m_dwStyle;
    }

    __inline DWORD GetID( void )
    {
        return m_dwID;
    }

    virtual void AddUIObj( CUIFObject *pUIObj );
    virtual void RemoveUIObj( CUIFObject *pUIObj );
    CUIFObject *ObjectFromPoint( POINT pt );

    __inline CUIFWindow *GetUIWnd( void )
    { 
        return m_pUIWnd; 
    }


    void SetScheme(CUIFScheme *pCUIFScheme);
    __inline CUIFScheme *GetUIFScheme( void )
    {
        return m_pUIFScheme; 
    }

    virtual LRESULT OnObjectNotify( CUIFObject *pUIObj, DWORD dwCode, LPARAM lParam );

    virtual void SetToolTip( LPCWSTR pwchToolTip );
    virtual LPCWSTR GetToolTip( void );

    //
    // Start ToolTip notification. If this return TRUE, the default tooltip
    // won't be shown.
    //
    virtual BOOL OnShowToolTip( void ) {return FALSE;}
    virtual void OnHideToolTip( void ) {return;}
    virtual void DetachWndObj( void );
    virtual void ClearWndObj( void );

#if defined(_DEBUG) || defined(DEBUG)
    __inline BOOL FInitialized( void )
    {
        return m_fInitialized;
    }
#endif /* DEBUG */

protected:
    CUIFObject      *m_pParent;
    CUIFWindow      *m_pUIWnd;
    CUIFScheme      *m_pUIFScheme;
    CUIFObjectArray<CUIFObject> m_ChildList;
    DWORD           m_dwID;
    DWORD           m_dwStyle;
    RECT            m_rc;
    BOOL            m_fEnabled;
    BOOL            m_fVisible;
    HFONT           m_hFont;
    BOOL            m_fUseCustomFont;
    LPWSTR          m_pwchToolTip;

    //
    // Theme support 
    //
    virtual BOOL OnPaintTheme( HDC hDC ) {return FALSE;}
    virtual void OnPaintNoTheme( HDC hDC )   {return;}
    virtual void ClearTheme();

    void StartCapture( void );
    void EndCapture( void );
    void StartTimer( UINT uElapse );
    void EndTimer( void );
    BOOL IsCapture( void );
    BOOL IsTimer( void );
    LRESULT NotifyCommand( DWORD dwCode, LPARAM lParam );
    int GetFontHeight( void );

    //
    // uischeme functions
    //
    COLORREF GetUIFColor( UIFCOLOR iCol );
    HBRUSH GetUIFBrush( UIFCOLOR iCol );

    //
    //
    //
    __inline const RECT &GetRectRef( void ) const 
    { 
        return this->m_rc; 
    }

    __inline DWORD GetStyleBits( DWORD dwMaskBits )
    {
        return (m_dwStyle & dwMaskBits);
    }

    __inline BOOL FHasStyle( DWORD dwStyleBit )
    {
        return ((m_dwStyle & dwStyleBit ) != 0);
    }

    BOOL IsRTL();


public:
    POINT       m_pointPreferredSize;

private:
#if defined(_DEBUG) || defined(DEBUG)
    BOOL        m_fInitialized;
#endif /* DEBUG */
};


//
// CUIFBorder
//-----------------------------------------------------------------------------

// UIFBorder style

#define UIBORDER_HORZ       0x00000000  // horizontal border
#define UIBORDER_VERT       0x00000001  // vertial border

#define UIBORDER_DIRMASK    0x00000001  // (mask bits) border direction


//
// CUIFBorder
//  = border UI object =
//

class CUIFBorder : public CUIFObject
{
public:
    CUIFBorder( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
    ~CUIFBorder( void );

    void OnPaint( HDC hDC );
};


//
// CUIFStatic
//-----------------------------------------------------------------------------

// UIStatic style

#define UISTATIC_LEFT       0x00000000  // left alignment
#define UISTATIC_CENTER     0x00000001  // center alignment (horizontal)
#define UISTATIC_RIGHT      0x00000002  // right alignment
#define UISTATIC_TOP        0x00000000  // top alignment
#define UISTATIC_VCENTER    0x00000010  // center alignment (vertical)
#define UISTATIC_BOTTOM     0x00000020  // bottom alignment

#define UISTATIC_HALIGNMASK 0x00000003  // (mask bits) horizontal alignment mask bits
#define UISTATIC_VALIGNMASK 0x00000030  // (mask bits) vertiacal alignment mask bits

//
// CUIFStatic
//  = static UI object =
//

class CUIFStatic : public CUIFObject
{
public:
    CUIFStatic( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
    virtual ~CUIFStatic( void );

    virtual void OnPaint( HDC hDC );
    virtual void SetText( LPCWSTR pwchText);
    virtual int GetText( LPWSTR pwchBuf, int cwchBuf );

protected:
    LPWSTR m_pwchText;
};


//
// CUIFButton
//-----------------------------------------------------------------------------


// UIFButton style

#define UIBUTTON_LEFT       0x00000000  // horizontal alignment - left align
#define UIBUTTON_CENTER     0x00000001  // horizontal alignment - center align
#define UIBUTTON_RIGHT      0x00000002  // horizontal alignment - right align
#define UIBUTTON_TOP        0x00000000  // vertical alignment - top align
#define UIBUTTON_VCENTER    0x00000004  // vertical alignment - center
#define UIBUTTON_BOTTOM     0x00000008  // vertical alignment - bottom
#define UIBUTTON_PUSH       0x00000000  // button type - push button
#define UIBUTTON_TOGGLE     0x00000010  // button type - toggle button
#define UIBUTTON_PUSHDOWN   0x00000020  // button type - pushdown button
#define UIBUTTON_FITIMAGE   0x00000100  // button style - fit image to the client area
#define UIBUTTON_SUNKENONMOUSEDOWN   0x00000200  // button style - sunken on mouse down
#define UIBUTTON_VERTICAL   0x00000400  // button style - vertical text drawing

#define UIBUTTON_HALIGNMASK 0x00000003  // (mask bits) horizontal alignment
#define UIBUTTON_VALIGNMASK 0x0000000c  // (mask bits) vertiacal alignment
#define UIBUTTON_TYPEMASK   0x00000030  // (mask bits) button type (push/toggle/pushdown)


// UIFButton notification code

#define UIBUTTON_PRESSED    0x00000001


// UIFButton status

#define UIBUTTON_NORMAL     0x00000000
#define UIBUTTON_DOWN       0x00000001
#define UIBUTTON_HOVER      0x00000002
#define UIBUTTON_DOWNOUT    0x00000003


//
// CUIFButton
//  = button UI object =
//

class CUIFButton : public CUIFObject
{
public:
    CUIFButton( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
    virtual ~CUIFButton( void );

    virtual void OnPaintNoTheme( HDC hDC );
    virtual void OnLButtonDown( POINT pt );
    virtual void OnLButtonUp( POINT pt );
    virtual void OnMouseIn( POINT pt );
    virtual void OnMouseOut( POINT pt );
    virtual void Enable( BOOL fEnable );

    void SetText( LPCWSTR pwch );
    void SetIcon( HICON hIcon );
    void SetIcon( LPCTSTR lpszResName );
    void SetBitmap( HBITMAP hBmp );
    void SetBitmap( LPCTSTR lpszResName );
    void SetBitmapMask( HBITMAP hBmp );
    void SetBitmapMask( LPCTSTR lpszResName );

    __inline LPCWSTR GetText( void )        { return m_pwchText; }
    __inline HICON GetIcon( void )          { return m_hIcon; }
    __inline HBITMAP GetBitmap( void )      { return m_hBmp; }
    __inline HBITMAP GetBitmapMask( void )  { return m_hBmpMask; }

    BOOL GetToggleState( void );
    void SetToggleState( BOOL fToggle );

    DWORD GetDCF()
    {
        return (GetStyle() & UIBUTTON_SUNKENONMOUSEDOWN) ? UIFDCF_BUTTONSUNKEN : UIFDCF_BUTTON;
    }

    BOOL IsVertical()
    {
        return (GetStyle() & UIBUTTON_VERTICAL) ? TRUE : FALSE;
    }

protected:
    DWORD   m_dwStatus;
    LPWSTR  m_pwchText;
    CUIFIcon   m_hIcon;
    HBITMAP m_hBmp;
    HBITMAP m_hBmpMask;
    BOOL    m_fToggled;
    SIZE    m_sizeIcon;
    SIZE    m_sizeText;
    SIZE    m_sizeBmp;

    virtual void SetStatus( DWORD dwStatus );
    void DrawEdgeProc( HDC hDC, const RECT *prc, BOOL fDown );
    void DrawTextProc( HDC hDC, const RECT *prc, BOOL fDown );
    void DrawIconProc( HDC hDC, const RECT *prc, BOOL fDown );
    void DrawBitmapProc( HDC hDC, const RECT *prc, BOOL fDown );
    void GetTextSize( LPCWSTR pwch, SIZE *psize );
    void GetIconSize( HICON hIcon, SIZE *psize );
    void GetBitmapSize( HBITMAP hBmp, SIZE *psize );
};


//
// CUIFButton2
//  = button UI object =
//

class CUIFButton2 : public CUIFButton
{
public:
    CUIFButton2( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
    virtual ~CUIFButton2( void );

protected:
    virtual BOOL OnPaintTheme( HDC hDC );
    virtual void OnPaintNoTheme( HDC hDC );

private:
    DWORD MakeDrawFlag();

};


//
// CUIFScroll
//-----------------------------------------------------------------------------

class CUIFScroll;

//
// CUIFScrollButton
//  = scrollbar button UI object =
//

// UIFScrollButton style

#define UISCROLLBUTTON_LEFT     0x00000000
#define UISCROLLBUTTON_UP       0x00010000
#define UISCROLLBUTTON_RIGHT    0x00020000
#define UISCROLLBUTTON_DOWN     0x00030000

#define UISCROLLBUTTON_DIRMASK  0x00030000  /* mask bits */

// UIFScrollButton notification code

#define UISCROLLBUTTON_PRESSED  0x00010000

//

class CUIFScrollButton : public CUIFButton
{
public:
    CUIFScrollButton( CUIFScroll *pUIScroll, const RECT *prc, DWORD dwStyle );
    ~CUIFScrollButton( void );

    virtual void OnLButtonDown( POINT pt );
    virtual void OnLButtonUp( POINT pt );
    virtual void OnMouseIn( POINT pt );
    virtual void OnMouseOut( POINT pt );
    virtual void OnPaint( HDC hDC );
    virtual void OnTimer( void );
};


//
// CUIFScrollThumb
//  = scrollbar thumb UI object =
//

// UIFScrollThumb notifucation code

#define UISCROLLTHUMB_MOVING    0x00000001
#define UISCROLLTHUMB_MOVED     0x00000002

//

class CUIFScrollThumb : public CUIFObject
{
public:
    CUIFScrollThumb( CUIFScroll *pUIScroll, const RECT *prc, DWORD dwStyle );
    virtual ~CUIFScrollThumb( void );

    virtual void OnPaint(HDC hDC);
    virtual void OnLButtonDown( POINT pt );
    virtual void OnLButtonUp( POINT pt );
    virtual void OnMouseMove( POINT pt );
    void SetScrollArea( RECT *prc );

protected:
    void DragProc( POINT pt, BOOL fEndDrag );

    RECT  m_rcScrollArea;
    POINT m_ptDrag;
    POINT m_ptDragOrg;
};


//
// CUIFScroll
//  = scrollbar UI object =
//

// UIFScroll style

#define UISCROLL_VERTTB         0x00000000
#define UISCROLL_VERTBT         0x00000001
#define UISCROLL_HORZLR         0x00000002
#define UISCROLL_HORZRL         0x00000003

#define UISCROLL_DIRMASK        0x00000003  /* mask bits */

// UIFScroll scroll page direction

#define UISCROLL_NONE           0x00000000
#define UISCROLL_PAGEDOWN       0x00000001  // page left
#define UISCROLL_PAGEUP         0x00000002  // page right

// UIFScroll notify codes

#define UISCROLLNOTIFY_SCROLLED 0x00000001  // scrollbar has been moved
#define UISCROLLNOTIFY_SCROLLLN 0x00000002  // scroll up/down line

// UIFScroll info

typedef struct _UIFSCROLLINFO
{
    int nMax;
    int nPage;
    int nPos;
} UIFSCROLLINFO;


//

class CUIFScroll : public CUIFObject
{
public:
    CUIFScroll( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
    virtual ~CUIFScroll( void );

    virtual CUIFObject *Initialize( void );
    virtual void OnPaint(HDC hDC);
    virtual void OnLButtonDown( POINT pt );
    virtual void OnLButtonUp( POINT pt );
    virtual void OnMouseIn( POINT pt );
    virtual void OnMouseOut( POINT pt );
    virtual void SetRect( const RECT *prc );
    virtual void SetStyle( DWORD dwStyle );
    virtual void Show( BOOL fShow );
    virtual void OnTimer( void );
    virtual LRESULT OnObjectNotify( CUIFObject *pUIObj, DWORD dwCommand, LPARAM lParam );

    void SetScrollInfo( UIFSCROLLINFO *pScrollInfo );
    void GetScrollInfo( UIFSCROLLINFO *pScrollInfo );

protected:
    virtual void GetMetrics( void );
    void SetCurPos( int nPos, BOOL fAdjustThumb = TRUE );
    BOOL GetThumbRect( RECT *prc );
    BOOL GetBtnUpRect( RECT *prc );
    BOOL GetBtnDnRect( RECT *prc );
    DWORD GetScrollThumbStyle( void );
    DWORD GetScrollUpBtnStyle( void );
    DWORD GetScrollDnBtnStyle( void );
    void GetScrollArea( RECT *prc );
    void GetPageUpArea( RECT *prc );
    void GetPageDnArea( RECT *prc );

    __inline void ShiftLine( int nLine )
    {
        SetCurPos( m_ScrollInfo.nPos + nLine );
    }

    __inline void ShiftPage( int nPage )
    {
        SetCurPos( m_ScrollInfo.nPos + m_ScrollInfo.nPage * nPage );
    }

    __inline BOOL PtInPageUpArea( POINT pt )
    {
        RECT rc;
        GetPageUpArea( &rc );
        return PtInRect( &rc, pt );
    }

    __inline BOOL PtInPageDnArea( POINT pt )
    {
        RECT rc;
        GetPageDnArea( &rc );
        return PtInRect( &rc, pt );
    }

    CUIFScrollButton *m_pBtnUp;
    CUIFScrollButton *m_pBtnDn;
    CUIFScrollThumb  *m_pThumb;

    UIFSCROLLINFO m_ScrollInfo;
    SIZE  m_sizeScrollBtn;
    BOOL  m_fScrollPage;
    DWORD m_dwScrollDir;
};


//
// CUIFListBase
//-----------------------------------------------------------------------------

// UIFList style

#define UILIST_HORZTB           0x00000000
#define UILIST_HORZBT           0x00000001
#define UILIST_VERTLR           0x00000002
#define UILIST_VERTRL           0x00000003
#define UILIST_DISABLENOSCROLL  0x00000010
#define UILIST_HORZ             UILIST_HORZTB /* for compatibility */
#define UILIST_VERT             UILIST_VERTRL /* for compatibility */
#define UILIST_FIXEDHEIGHT      0x00000000
#define UILIST_VARIABLEHEIGHT   0x00000020
#define UILIST_ICONSNOTNUMBERS  0x00000040

#define UILIST_DIRMASK          0x00000003 /* mask bits */

// UIFList notification code

#define UILIST_SELECTED         0x00000001
#define UILIST_SELCHANGED       0x00000002


//
// CListItemBase
//  = list item data object base class =
//

class CListItemBase
{
public:
    CListItemBase( void )
    {
    }

    virtual ~CListItemBase( void )
    {
    }
};


//
// CUIFListBase
//  = list UI object base class =
//

class CUIFListBase : public CUIFObject
{
public:
    CUIFListBase( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
    virtual ~CUIFListBase( void );

    //
    // CUIFObject method
    //
    virtual CUIFObject *Initialize( void );
    virtual void OnPaint( HDC hDC );
    virtual void OnLButtonDown( POINT pt );
    virtual void OnLButtonUp( POINT pt );
    virtual void OnMouseMove( POINT pt );
    virtual void OnTimer( void );
    virtual void SetRect( const RECT *prc );
    virtual void SetStyle( DWORD dwStyle );
    virtual LRESULT OnObjectNotify( CUIFObject *pUIObj, DWORD dwCommand, LPARAM lParam );

    int AddItem( CListItemBase *pItem );
    int GetCount( void );
    CListItemBase *GetItem( int iItem );
    void DelItem( int iItem );
    void DelAllItem( void );

    void SetSelection( int iSelection, BOOL fRedraw );
    void ClearSelection( BOOL fRedraw );
    void SetLineHeight( int nLineHeight );
    void SetTop( int nStart, BOOL fSetScrollPos );
    int GetSelection( void );
    int GetLineHeight( void );
    int GetTop( void );
    int GetBottom( void );
    int GetVisibleCount( void );

protected:
    CUIFObjectArray<CListItemBase> m_listItem;
    int        m_nItem;
    int        m_nItemVisible;
    int        m_iItemTop;
    int        m_iItemSelect;
    int        m_nLineHeight;
    CUIFScroll *m_pUIScroll;

    virtual int GetItemHeight( int iItem );
    virtual int GetListHeight( void );
    virtual void GetLineRect( int iLine, RECT *prc );
    virtual void GetScrollBarRect( RECT *prc );
    virtual DWORD GetScrollBarStyle( void );
    virtual CUIFScroll *CreateScrollBarObj( CUIFObject *pParent, DWORD dwID, RECT *prc, DWORD dwStyle );
    virtual void PaintItemProc( HDC hDC, RECT *prc, CListItemBase *pItem, BOOL fSelected );

    int ListItemFromPoint( POINT pt );
    void CalcVisibleCount( void );
    void UpdateScrollBar( void );
};


//
// CUIFList
//-----------------------------------------------------------------------------

//
// CUIFList
//  = list UI object =
//

class CUIFList : public CUIFListBase
{
public:
    CUIFList( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
    virtual ~CUIFList( void );

    int AddString( WCHAR *psz );
    LPCWSTR GetString( int iID );
    void DeleteString( int iID );
    void DeleteAllString( void );
    void SetPrivateData( int iID, DWORD dw );
    DWORD GetPrivateData( int iID );

protected:
    virtual void PaintItemProc( HDC hDC, RECT *prc, CListItemBase *pItem, BOOL fSelected );
    int ItemFromID( int iID );
};


//
// CUIFGripper
//-----------------------------------------------------------------------------

//
// CUIFGripper
//  = gripper UI object =
//

#define UIGRIPPER_VERTICAL  0x00000001

//
// Gripper Theme Margin
//
#define CUI_GRIPPER_THEME_MARGIN 2

class CUIFGripper : public CUIFObject
{
public:
    CUIFGripper( CUIFObject *pParent, const RECT *prc, DWORD dwStyle = 0);
    virtual ~CUIFGripper( void );

    virtual void SetStyle( DWORD dwStyle );
    virtual void OnLButtonDown( POINT pt );
    virtual void OnLButtonUp( POINT pt );
    virtual void OnMouseMove( POINT pt );
    virtual BOOL OnSetCursor( UINT uMsg, POINT pt );

protected:
    virtual BOOL OnPaintTheme( HDC hDC );
    virtual void OnPaintNoTheme( HDC hDC );

private:
    BOOL IsVertical()
    {
        return (GetStyle() & UIGRIPPER_VERTICAL) ? TRUE : FALSE;
    }
    POINT _ptCur;
};


//
// CUIFWndFrame
//-----------------------------------------------------------------------------

//
// CUIFWndFrame
//  = window frame obeject =
//

// CUIFWndFrame styles

#define UIWNDFRAME_THIN             0x00000000  // frame style: thin
#define UIWNDFRAME_THICK            0x00000001  // frame style: thick
#define UIWNDFRAME_ROUNDTHICK       0x00000002  // frame style: thick with rounded top corners
#define UIWNDFRAME_RESIZELEFT       0x00000010  // resize flag: resizable at left   border
#define UIWNDFRAME_RESIZETOP        0x00000020  // resize flag: resizable at top    border
#define UIWNDFRAME_RESIZERIGHT      0x00000040  // resize flag: resizable at right  border
#define UIWNDFRAME_RESIZEBOTTOM     0x00000080  // resize flag: resizable at bottom border
#define UIWNDFRAME_NORESIZE         0x00000000  // resize flag: no resizable
#define UIWNDFRAME_RESIZEALL        (UIWNDFRAME_RESIZELEFT | UIWNDFRAME_RESIZETOP | UIWNDFRAME_RESIZERIGHT | UIWNDFRAME_RESIZEBOTTOM)

#define UIWNDFRAME_STYLEMASK        0x0000000f  // (mask bit)

class CUIFWndFrame : public CUIFObject
{
public:
    CUIFWndFrame( CUIFObject *pParent, const RECT *prc, DWORD dwStyle );
    virtual ~CUIFWndFrame( void );

    virtual BOOL OnPaintTheme( HDC hDC );
    virtual void OnPaintNoTheme( HDC hDC );
    virtual void OnLButtonDown( POINT pt );
    virtual void OnLButtonUp( POINT pt );
    virtual void OnMouseMove( POINT pt );
    virtual BOOL OnSetCursor( UINT uMsg, POINT pt );

    void GetInternalRect( RECT *prc );
    void GetFrameSize( SIZE *psize );
    void SetFrameSize( SIZE *psize );
    void GetMinimumSize( SIZE *psize );
    void SetMinimumSize( SIZE *psize );

protected:
    DWORD m_dwHTResizing;
    POINT m_ptDrag;
    RECT  m_rcOrg;
    int   m_cxFrame;
    int   m_cyFrame;
    int   m_cxMin;
    int   m_cyMin;

    DWORD HitTest( POINT pt );
};


//
// CUIFWndCaption
//-----------------------------------------------------------------------------

//
// CUIFWndCaption
//  = window caption object =
//

#define UIWNDCAPTION_INACTIVE       0x00000000
#define UIWNDCAPTION_ACTIVE         0x00000001
#define UIWNDCAPTION_MOVABLE        0x00000002


class CUIFWndCaption : public CUIFStatic
{
public:
    CUIFWndCaption( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
    virtual ~CUIFWndCaption( void );

    virtual void OnPaint( HDC hDC );
    virtual void OnLButtonDown( POINT pt );
    virtual void OnLButtonUp( POINT pt );
    virtual void OnMouseMove( POINT pt );
    virtual BOOL OnSetCursor( UINT uMsg, POINT pt );

private:
    POINT m_ptDrag;
};


//
// CUIFCaptionButton
//-----------------------------------------------------------------------------

//
// CUIFCaptionButton
//  = caption control object =
//

#define UICAPTIONBUTTON_INACTIVE    0x00000000
#define UICAPTIONBUTTON_ACTIVE      0x00010000


class CUIFCaptionButton : public CUIFButton2
{
public:
    CUIFCaptionButton( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
    virtual ~CUIFCaptionButton( void );

    virtual void OnPaint( HDC hDC );
};

#endif /* CUIOBJ_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuimem.h ===
//
// cuimem.h
//  = memory management functions in CUILIB =
//

#ifndef CUIMEM_H
#define CUIMEM_H

// note: temporary, use Cicero memmgr as currently it does.

#include "mem.h"

#define MemAlloc( uCount )              cicMemAllocClear( (uCount) )
#define MemFree( pv )                   cicMemFree( (pv) )
#define MemReAlloc( pv, uCount )        cicMemReAlloc( (pv), (uCount) )

#define MemCopy( dst, src, uCount )     memcpy( (dst), (src), (uCount) )
#define MemMove( dst, src, uCount )     memmove( (dst), (src), (uCount) )
#define MemSet( dst, c, uCount )        memset( (dst), (c), (uCount) )


#endif /* CUIMEM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuires.h ===
//
// cuires.h
//

#ifndef CUIRES_H
#define CUIRES_H

#define CUI_IDS_OK          100
#define CUI_IDS_CANCEL      101
#define CUI_IDS_ABORT       102
#define CUI_IDS_RETRY       103
#define CUI_IDS_IGNORE      104
#define CUI_IDS_YES         105
#define CUI_IDS_NO          106

#endif // CUIRES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuischem.cpp ===
//
// cuischem.cpp
//  = UIF scheme implementation = 
//

#include "private.h"
#include "cuischem.h"
#include "cuisys.h"
#include "cmydc.h"
#include "cuiutil.h"
#include "math.h"


//
// gloval variables
//

static class CUIFColorTableSys   *v_pColTableSys   = NULL;
static class CUIFColorTableOff10 *v_pColTableOfc10 = NULL;



/*=============================================================================*/
/*                                                                             */
/*   C  U I F  C O L O R  T A B L E                                            */
/*                                                                             */
/*=============================================================================*/

typedef enum _SYSCOLOR
{ 
    SYSCOLOR_3DFACE,
    SYSCOLOR_3DSHAODW,
    SYSCOLOR_ACTIVEBORDER,
    SYSCOLOR_ACTIVECAPTION,
    SYSCOLOR_BTNFACE,
    SYSCOLOR_BTNSHADOW,
    SYSCOLOR_BTNTEXT,
    SYSCOLOR_CAPTIONTEXT,
    SYSCOLOR_GRAYTEXT,
    SYSCOLOR_HIGHLIGHT,
    SYSCOLOR_HIGHLIGHTTEXT,
    SYSCOLOR_INACTIVECAPTION,
    SYSCOLOR_INACTIVECAPTIONTEXT,
    SYSCOLOR_MENUTEXT,
    SYSCOLOR_WINDOW,
    SYSCOLOR_WINDOWTEXT,
    
    SYSCOLOR_MAX                /* must be last */
} SYSCOLOR;


typedef enum _OFC10COLOR
{ 
    OFC10COLOR_BKGDTB,                  // msocbvcrCBBkgd
    OFC10COLOR_BKGDMENU,                // msocbvcrCBMenuBkgd
    OFC10COLOR_BKGDWP,                  // msocbvcrWPBkgd
    OFC10COLOR_MENUBARSHORT,            // msocbvcrCBMenuIconBkgd
    OFC10COLOR_MENUBARLONG,             // msocbvcrCBMenuIconBkgdDropped
    OFC10COLOR_MOUSEOVERBKGND,          // msocbvcrCBCtlBkgdMouseOver
    OFC10COLOR_MOUSEOVERBORDER,         // msocbvcrCBCtlBdrMouseOver
    OFC10COLOR_MOUSEOVERTEXT,           // msocbvcrCBCtlTextMouseOver
    OFC10COLOR_MOUSEDOWNBKGND,          // msocbvcrCBCtlBkgdMouseDown
    OFC10COLOR_MOUSEDOWNBORDER,         // msocbvcrCBCtlBdrMouseDown
    OFC10COLOR_MOUSEDOWNTEXT,           // msocbvcrCBCtlTextMouseDown
    OFC10COLOR_CTRLBKGD,                // msocbvcrCBCtlBkgd
    OFC10COLOR_CTRLTEXT,                // msocbvcrCBCtlText
    OFC10COLOR_CTRLTEXTDISABLED,        // msocbvcrCBCtlTextDisabled
    OFC10COLOR_CTRLIMAGESHADOW,         // REVIEW: KOJIW: office calcs shadow color from bkgnd (not constant color)
    OFC10COLOR_CTRLBKGDSELECTED,        // msocbvcrCBCtlBkgdSelected
    OFC10COLOR_CTRLBORDERSELECTED,      // msocbvcrCBCtlBdrSelected
//  OFC10COLOR_CTRLDBRDISABLED,         // 
    OFC10COLOR_BDROUTERMENU,            // msocbvcrCBMenuBdrOuter
    OFC10COLOR_BDRINNERMENU,            // msocbvcrCBMenuBdrInner
    OFC10COLOR_BDROUTERFLOATTB,         // msocbvcrCBBdrOuterFloating
    OFC10COLOR_BDRINNERFLOATTB,         // msocbvcrCBBdrInnerFloating
    OFC10COLOR_BDROUTERFLOATWP,         // msocbvcrWPBdrOuterFloating
    OFC10COLOR_BDRINNERFLOATWP,         // msocbvcrWPBdrInnerFloating
    OFC10COLOR_CAPTIONBKGDTB,           // msocbvcrCBTitleBkgd
    OFC10COLOR_CAPTIONTEXTTB,           // msocbvcrCBTitleText
    OFC10COLOR_ACTIVECAPTIONBKGDWP,     // msocbvcrWPTitleBkgdActive
    OFC10COLOR_ACTIVECAPTIONTEXTWP,     // msocbvcrWPTitleTextActive
    OFC10COLOR_INACTIVECAPTIONBKGDWP,   // msocbvcrWPTitleBkgdInactive
    OFC10COLOR_INACTIVECAPTIONTEXTWP,   // msocbvcrWPTitleTextInactive
    OFC10COLOR_SPLITTERLINE,            // msocbvcrCBSplitterLine
    OFC10COLOR_DRAGHANDLE,              // msocbvcrCBDragHandle
    OFC10COLOR_MENUCTRLTEXT,            // msocbvcrCBMenuCtlText

    OFC10COLOR_MAX              /* must be last */
} OFC10COLOR;

/*============================================================================*/
/*
	Contrast Increasing Code
*/
/*============================================================================*/

typedef double CIC_NUM;
// Sizes of color channels in weighted RGB space.

#define MAX_RED   195
#define MAX_GREEN 390
#define MAX_BLUE   65

/*
A note on "dMinContrast":
0 contrast means the two colors are the same.
Black and White have a contrast of roughly 442, which is the maximum contrast
two colors can have.
The most you can request to have between two colors is 221, since if
one color is 50% grey, the furthest you can be from it is 221 away
(at white or black).
*/

#define MIN_TEXT_CONTRAST 180
#define MIN_ICON_CONTRAST 90
struct COLORCONTRAST
{
	OFC10COLOR colLocked; // will not be changed by CIC
	OFC10COLOR colMoveable; // might be changed by CIC
	CIC_NUM    cMinContrast; // minimum contrast required between locked and moveable
	BOOL       fConsiderDarkness; // take into consideration the effects of dark colors
};
    
static const COLORCONTRAST vrgContrast[] =
{
    // Locked                           Moveable                            Contrast    Darkness
    OFC10COLOR_BKGDTB,            OFC10COLOR_CTRLTEXT,               MIN_TEXT_CONTRAST, TRUE,
    OFC10COLOR_BKGDTB,            OFC10COLOR_CTRLTEXTDISABLED,       80, TRUE,
    OFC10COLOR_BKGDTB,            OFC10COLOR_MOUSEOVERBKGND,         50, TRUE,
    OFC10COLOR_BKGDTB,            OFC10COLOR_MOUSEOVERBORDER,        100, TRUE,
    OFC10COLOR_BKGDTB,            OFC10COLOR_CTRLBKGDSELECTED,      5, TRUE, // TODO DMORTON - need larger value
//  OFC10COLOR_BKGDTB,            OFC10COLOR_MOUSEOVERSELECTED,      30, TRUE,
//  OFC10COLOR_MOUSEOVERSELECTED, OFC10COLOR_MOUSEOVERSELECTEDBORDER,100, TRUE,
    OFC10COLOR_MOUSEOVERBKGND,    OFC10COLOR_MOUSEOVERTEXT,          MIN_TEXT_CONTRAST, TRUE,
    OFC10COLOR_BKGDTB,            OFC10COLOR_MOUSEDOWNBKGND,         30, TRUE,
    OFC10COLOR_MOUSEDOWNBKGND,    OFC10COLOR_MOUSEDOWNTEXT,          MIN_TEXT_CONTRAST, TRUE,
    OFC10COLOR_BKGDMENU,          OFC10COLOR_MENUCTRLTEXT,           MIN_TEXT_CONTRAST, TRUE,
//  OFC10COLOR_BKGDMENU,          OFC10COLOR_MENUCTRLTEXTDISABLED,   80, TRUE,
//  OFC10COLOR_BKGDMENU,          OFC10COLOR_MENUCTRLBORDER,         100, TRUE,
    OFC10COLOR_CAPTIONBKGDTB ,    OFC10COLOR_CAPTIONTEXTTB,          MIN_TEXT_CONTRAST, TRUE,
	OFC10COLOR_BKGDMENU,          OFC10COLOR_DRAGHANDLE,             85, TRUE,
};


//
// CUIFColorTableBase
//

class CUIFColorTable
{
public:
    CUIFColorTable( void )
    {
    }

    virtual ~CUIFColorTable( void )
    {
        DoneColor();
        DoneBrush();
    }

    void Initialize( void )
    {
        InitColor();
        InitBrush();
    }

    void Update( void )
    {
        DoneColor();
        DoneBrush();
        InitColor();
        InitBrush();
    }

protected:
    virtual void InitColor( void ) {}
    virtual void DoneColor( void ) {}
    virtual void InitBrush( void ) {}
    virtual void DoneBrush( void ) {}
};


//
// CUIFColorTableSys
//

class CUIFColorTableSys : public CUIFColorTable
{
public:
    CUIFColorTableSys( void ) : CUIFColorTable()
    {
    }

    virtual ~CUIFColorTableSys( void )
    {
        DoneColor();
        DoneBrush();
    }

    __inline COLORREF GetColor( SYSCOLOR iColor )
    {
        return m_rgColor[ iColor ];
    }

    __inline HBRUSH GetBrush( SYSCOLOR iColor )
    {
        if (!m_rgBrush[iColor])
            m_rgBrush[iColor] = CreateSolidBrush( m_rgColor[iColor] );

        return m_rgBrush[ iColor ];
    }

protected:
    COLORREF m_rgColor[ SYSCOLOR_MAX ];
    HBRUSH   m_rgBrush[ SYSCOLOR_MAX ];

    virtual void InitColor( void )
    {
        m_rgColor[ SYSCOLOR_3DFACE              ] = GetSysColor( COLOR_3DFACE              );
        m_rgColor[ SYSCOLOR_3DSHAODW            ] = GetSysColor( COLOR_3DSHADOW            );
        m_rgColor[ SYSCOLOR_ACTIVEBORDER        ] = GetSysColor( COLOR_ACTIVEBORDER        );
        m_rgColor[ SYSCOLOR_ACTIVECAPTION       ] = GetSysColor( COLOR_ACTIVECAPTION       );
        m_rgColor[ SYSCOLOR_BTNFACE             ] = GetSysColor( COLOR_BTNFACE             );
        m_rgColor[ SYSCOLOR_BTNSHADOW           ] = GetSysColor( COLOR_BTNSHADOW           );
        m_rgColor[ SYSCOLOR_BTNTEXT             ] = GetSysColor( COLOR_BTNTEXT             );
        m_rgColor[ SYSCOLOR_CAPTIONTEXT         ] = GetSysColor( COLOR_CAPTIONTEXT         );
        m_rgColor[ SYSCOLOR_GRAYTEXT            ] = GetSysColor( COLOR_GRAYTEXT            );
        m_rgColor[ SYSCOLOR_HIGHLIGHT           ] = GetSysColor( COLOR_HIGHLIGHT           );
        m_rgColor[ SYSCOLOR_HIGHLIGHTTEXT       ] = GetSysColor( COLOR_HIGHLIGHTTEXT       );
        m_rgColor[ SYSCOLOR_INACTIVECAPTION     ] = GetSysColor( COLOR_INACTIVECAPTION     );
        m_rgColor[ SYSCOLOR_INACTIVECAPTIONTEXT ] = GetSysColor( COLOR_INACTIVECAPTIONTEXT );
        m_rgColor[ SYSCOLOR_MENUTEXT            ] = GetSysColor( COLOR_MENUTEXT            );
        m_rgColor[ SYSCOLOR_WINDOW              ] = GetSysColor( COLOR_WINDOW              );
        m_rgColor[ SYSCOLOR_WINDOWTEXT          ] = GetSysColor( COLOR_WINDOWTEXT          );
        m_rgColor[ SYSCOLOR_3DSHAODW            ] = GetSysColor( COLOR_3DSHADOW            );
    }

    virtual void DoneColor( void )
    {
    }

    virtual void InitBrush( void )
    {
        for (int i = 0; i < SYSCOLOR_MAX; i++) {
            m_rgBrush[i] = NULL;
        }
    }

    virtual void DoneBrush( void )
    {
        for (int i = 0; i < SYSCOLOR_MAX; i++) {
            if (m_rgBrush[i]) {
                DeleteObject( m_rgBrush[i] );
                m_rgBrush[i] = NULL;
            }
        }
    }
};


//
// CUIFColorTableOff10
//

class CUIFColorTableOff10 : public CUIFColorTable
{
public:
    CUIFColorTableOff10( void ) : CUIFColorTable()
    {
    }

    virtual ~CUIFColorTableOff10( void )
    {
        DoneColor();
        DoneBrush();
    }

    __inline COLORREF GetColor( OFC10COLOR iColor )
    {
        return m_rgColor[ iColor ];
    }

    __inline HBRUSH GetBrush( OFC10COLOR iColor )
    {
        if (!m_rgBrush[iColor])
            m_rgBrush[iColor] = CreateSolidBrush( m_rgColor[iColor] );

        return m_rgBrush[ iColor ];
    }

protected:
    COLORREF m_rgColor[ OFC10COLOR_MAX ];
    HBRUSH   m_rgBrush[ OFC10COLOR_MAX ];

    virtual void InitColor( void )
    {
        if (UIFIsLowColor() || UIFIsHighContrast()) {
            if (UIFIsHighContrast()) {
                // high contrast setting
                m_rgColor[ OFC10COLOR_MENUBARLONG           ] = col( COLOR_BTNFACE );
                m_rgColor[ OFC10COLOR_MOUSEOVERBKGND        ] = col( COLOR_HIGHLIGHT );
                m_rgColor[ OFC10COLOR_MOUSEOVERBORDER       ] = col( COLOR_MENUTEXT );
                m_rgColor[ OFC10COLOR_MOUSEOVERTEXT         ] = col( COLOR_HIGHLIGHTTEXT);
                m_rgColor[ OFC10COLOR_CTRLBKGDSELECTED      ] = col( COLOR_HIGHLIGHT );
                m_rgColor[ OFC10COLOR_CTRLBORDERSELECTED    ] = col( COLOR_MENUTEXT );
            }
            else {
                // low color setting
                m_rgColor[ OFC10COLOR_MENUBARLONG           ] = col( COLOR_BTNSHADOW );
                m_rgColor[ OFC10COLOR_MOUSEOVERBKGND        ] = col( COLOR_WINDOW );
                m_rgColor[ OFC10COLOR_MOUSEOVERBORDER       ] = col( COLOR_HIGHLIGHT );
                m_rgColor[ OFC10COLOR_MOUSEOVERTEXT         ] = col( COLOR_WINDOWTEXT );
                m_rgColor[ OFC10COLOR_CTRLBKGDSELECTED      ] = col( COLOR_WINDOW );
                m_rgColor[ OFC10COLOR_CTRLBORDERSELECTED    ] = col( COLOR_HIGHLIGHT );
            }

            // common setting
            m_rgColor[ OFC10COLOR_BKGDTB                ] = col( COLOR_BTNFACE ); 
            m_rgColor[ OFC10COLOR_BKGDMENU              ] = col( COLOR_WINDOW );
            m_rgColor[ OFC10COLOR_BKGDWP                ] = col( COLOR_WINDOW );
            m_rgColor[ OFC10COLOR_MENUBARSHORT          ] = col( COLOR_BTNFACE );
            m_rgColor[ OFC10COLOR_MOUSEDOWNBKGND        ] = col( COLOR_HIGHLIGHT);
            m_rgColor[ OFC10COLOR_MOUSEDOWNBORDER       ] = col( COLOR_HIGHLIGHT );
            m_rgColor[ OFC10COLOR_MOUSEDOWNTEXT         ] = col( COLOR_HIGHLIGHTTEXT);
            m_rgColor[ OFC10COLOR_CTRLBKGD              ] = col( COLOR_BTNFACE );
            m_rgColor[ OFC10COLOR_CTRLTEXT              ] = col( COLOR_BTNTEXT );
            m_rgColor[ OFC10COLOR_CTRLTEXTDISABLED      ] = col( COLOR_BTNSHADOW );
            m_rgColor[ OFC10COLOR_CTRLIMAGESHADOW       ] = col( COLOR_BTNFACE );
            m_rgColor[ OFC10COLOR_BDROUTERMENU          ] = col( COLOR_BTNTEXT );
            m_rgColor[ OFC10COLOR_BDRINNERMENU          ] = col( COLOR_WINDOW );
            m_rgColor[ OFC10COLOR_BDROUTERFLOATTB       ] = col( COLOR_BTNSHADOW );
            m_rgColor[ OFC10COLOR_BDRINNERFLOATTB       ] = col( COLOR_BTNFACE );
            m_rgColor[ OFC10COLOR_BDROUTERFLOATWP       ] = col( COLOR_BTNSHADOW );
            m_rgColor[ OFC10COLOR_BDRINNERFLOATWP       ] = col( COLOR_BTNFACE );
            m_rgColor[ OFC10COLOR_CAPTIONBKGDTB         ] = col( COLOR_BTNSHADOW );
            m_rgColor[ OFC10COLOR_CAPTIONTEXTTB         ] = col( COLOR_CAPTIONTEXT );
            m_rgColor[ OFC10COLOR_ACTIVECAPTIONBKGDWP   ] = col( COLOR_HIGHLIGHT );
            m_rgColor[ OFC10COLOR_ACTIVECAPTIONTEXTWP   ] = col( COLOR_HIGHLIGHTTEXT );
            m_rgColor[ OFC10COLOR_INACTIVECAPTIONBKGDWP ] = col( COLOR_BTNFACE );
            m_rgColor[ OFC10COLOR_INACTIVECAPTIONTEXTWP ] = col( COLOR_BTNTEXT );
            m_rgColor[ OFC10COLOR_SPLITTERLINE          ] = col( COLOR_BTNSHADOW );
            m_rgColor[ OFC10COLOR_DRAGHANDLE            ] = col( COLOR_BTNTEXT );

            m_rgColor[ OFC10COLOR_SPLITTERLINE          ] = col( COLOR_BTNSHADOW );
            m_rgColor[ OFC10COLOR_MENUCTRLTEXT          ] = col( COLOR_WINDOWTEXT );
        }
        else {
            m_rgColor[ OFC10COLOR_BKGDTB                ] = col( 835, col( COLOR_BTNFACE ), 165, col( COLOR_WINDOW ) ); 
            m_rgColor[ OFC10COLOR_BKGDMENU              ] = col( 15, col( COLOR_BTNFACE ),   85, col( COLOR_WINDOW ) );
            m_rgColor[ OFC10COLOR_BKGDWP                ] = col( 15, col( COLOR_BTNFACE ),   85, col( COLOR_WINDOW ) );
            m_rgColor[ OFC10COLOR_MENUBARSHORT          ] = col(835, col( COLOR_BTNFACE ),  165, col( COLOR_WINDOW ) );
            m_rgColor[ OFC10COLOR_MENUBARLONG           ] = col( 90, col( COLOR_BTNFACE ),   10, col( COLOR_BTNSHADOW ) );
            m_rgColor[ OFC10COLOR_MOUSEOVERBKGND        ] = col( 30, col( COLOR_HIGHLIGHT ), 70, col( COLOR_WINDOW ) );
            m_rgColor[ OFC10COLOR_MOUSEOVERBORDER       ] = col( COLOR_HIGHLIGHT );
            m_rgColor[ OFC10COLOR_MOUSEOVERTEXT         ] = col( COLOR_MENUTEXT );
            m_rgColor[ OFC10COLOR_MOUSEDOWNBKGND        ] = col( 50, col( COLOR_HIGHLIGHT ), 50, col( COLOR_WINDOW ) );
            m_rgColor[ OFC10COLOR_MOUSEDOWNBORDER       ] = col( COLOR_HIGHLIGHT );
            m_rgColor[ OFC10COLOR_MOUSEDOWNTEXT         ] = col( COLOR_HIGHLIGHTTEXT );
            m_rgColor[ OFC10COLOR_CTRLBKGD              ] = m_rgColor[ OFC10COLOR_BKGDTB              ];
            m_rgColor[ OFC10COLOR_CTRLTEXT              ] = col( COLOR_BTNTEXT );
            m_rgColor[ OFC10COLOR_CTRLTEXTDISABLED      ] = col( 90, col( COLOR_BTNSHADOW ), 10, col( COLOR_WINDOW ) );
            m_rgColor[ OFC10COLOR_CTRLBKGDSELECTED      ] = col( 10, col( COLOR_HIGHLIGHT ), 50,  m_rgColor[ OFC10COLOR_CTRLBKGD], 40, col( COLOR_WINDOW));
            m_rgColor[ OFC10COLOR_CTRLIMAGESHADOW       ] = col( 75, m_rgColor[ OFC10COLOR_MOUSEOVERBKGND ], 25, RGB( 0x00, 0x00, 0x00 ) );    // REVIEW: KOJIW: bkgnd s always OFC10COLOR_MOUSEOVERBKGND???
            m_rgColor[ OFC10COLOR_CTRLBORDERSELECTED    ] = col( COLOR_HIGHLIGHT );
            m_rgColor[ OFC10COLOR_BDROUTERMENU          ] = col( 20, col( COLOR_BTNTEXT ), 80, col( COLOR_BTNSHADOW ) );
            m_rgColor[ OFC10COLOR_BDRINNERMENU          ] = m_rgColor[ OFC10COLOR_BKGDMENU            ];
            m_rgColor[ OFC10COLOR_BDROUTERFLOATTB       ] = col( 15, col( COLOR_BTNTEXT ), 85, col( COLOR_BTNSHADOW ) );
            m_rgColor[ OFC10COLOR_BDRINNERFLOATTB       ] = m_rgColor[ OFC10COLOR_BKGDTB              ];
            m_rgColor[ OFC10COLOR_BDROUTERFLOATWP       ] = col( COLOR_BTNSHADOW );
            m_rgColor[ OFC10COLOR_BDRINNERFLOATWP       ] = m_rgColor[ OFC10COLOR_BKGDWP              ];
            m_rgColor[ OFC10COLOR_CAPTIONBKGDTB         ] = col( COLOR_BTNSHADOW );
            m_rgColor[ OFC10COLOR_CAPTIONTEXTTB         ] = col( COLOR_CAPTIONTEXT );
            m_rgColor[ OFC10COLOR_ACTIVECAPTIONBKGDWP   ] = m_rgColor[ OFC10COLOR_MOUSEOVERBKGND      ];
            m_rgColor[ OFC10COLOR_ACTIVECAPTIONTEXTWP   ] = m_rgColor[ OFC10COLOR_MOUSEOVERTEXT       ];
            m_rgColor[ OFC10COLOR_INACTIVECAPTIONBKGDWP ] = col( COLOR_BTNFACE );
            m_rgColor[ OFC10COLOR_INACTIVECAPTIONTEXTWP ] = col( COLOR_BTNTEXT );
            m_rgColor[ OFC10COLOR_SPLITTERLINE          ] = col( 70, col( COLOR_BTNSHADOW ), 30, col( COLOR_WINDOW ) );
            m_rgColor[ OFC10COLOR_DRAGHANDLE            ] = col( 75, col( COLOR_BTNSHADOW ), 25, col( COLOR_WINDOW ) );
            m_rgColor[ OFC10COLOR_MENUCTRLTEXT          ] = col( COLOR_WINDOWTEXT );

            CbvFixContrastProblems();
        }
    }

    virtual void DoneColor( void )
    {
    }

    virtual void InitBrush( void )
    {
        for (int i = 0; i < OFC10COLOR_MAX; i++) {
            m_rgBrush[i] = NULL;
        }
    }

    virtual void DoneBrush( void )
    {
        for (int i = 0; i < OFC10COLOR_MAX; i++) {
            if (m_rgBrush[i]) {
                DeleteObject( m_rgBrush[i] );
                m_rgBrush[i] = NULL;
            }
        }
    }

    __inline COLORREF col( int iColor )
    {
        return GetSysColor( iColor );
    }

    COLORREF col( int r1, COLORREF col1, int r2, COLORREF col2 )
    {
        int sum = r1 + r2;

        Assert( sum == 10 || sum == 100 || sum == 1000 );
        int r = (r1 * GetRValue(col1) + r2 * GetRValue(col2) + sum/2) / sum;
        int g = (r1 * GetGValue(col1) + r2 * GetGValue(col2) + sum/2) / sum;
        int b = (r1 * GetBValue(col1) + r2 * GetBValue(col2) + sum/2) / sum;
        return RGB( r, g, b );

    }

    COLORREF col( int r1, COLORREF col1, int r2, COLORREF col2 , int r3, COLORREF col3)
    {
        int sum = r1 + r2 + r3;

        Assert( sum == 10 || sum == 100 || sum == 1000 );
        int r = (r1 * GetRValue(col1) + r2 * GetRValue(col2) + r3 * GetRValue(col3) + sum/3) / sum;
        int g = (r1 * GetGValue(col1) + r2 * GetGValue(col2) + r3 * GetGValue(col3) + sum/3) / sum;
        int b = (r1 * GetBValue(col1) + r2 * GetBValue(col2) + r3 * GetBValue(col3) + sum/3) / sum;
        return RGB( r, g, b );

    }

    
   /*---------------------------------------------------------------------------
       CCbvScaleContrastForDarkness

       As colors become darker, their contrast descreases, even if their
       distance apart stays fixed.

       ie. in the grayscale, 0 and 50 are the same distance apart as 205 and 255,
       but monitors/eyes see less difference between 0 and 50, than 205 and 255.

       This function increases the dContrast value, based on a dDarkness.

       This operation assumes the parameters are in the weighted RGB color space
       (the color space that the CIC uses), ie. 220 is middle of the road.

   ----------------------------------------------------------------- DMORTON -*/
   CIC_NUM CCbvScaleContrastForDarkness(CIC_NUM dContrast, CIC_NUM dDarkness)
   {
       return (2 - (min(dDarkness, 220)) / 220) * dContrast;
   }

   /*---------------------------------------------------------------------------
       CCbvGetContrastSquared
    
        As a speed improvement, whenever you don't need the real contrast, but
        instead can make due with the contrast squared, call this function
        and avoid the expensive sqrt call thats in CCbvGetContrast.
    
    ----------------------------------------------------------------- DMORTON -*/
    CIC_NUM CCbvGetContrastSquared(COLORREF cr1, COLORREF cr2)
    {
        // Transform the delta vector into weighted RGB color space
        CIC_NUM dRedD = (CIC_NUM)(GetRValue(cr1) - GetRValue(cr2)) * MAX_RED / 255;
        CIC_NUM dGreenD = (CIC_NUM)(GetGValue(cr1) - GetGValue(cr2)) * MAX_GREEN / 255;
        CIC_NUM dBlueD = (CIC_NUM)(GetBValue(cr1) - GetBValue(cr2)) * MAX_BLUE / 255;
    
        // Calculate its magnitude squared
        return(dRedD * dRedD + dGreenD * dGreenD + dBlueD * dBlueD);
    }
    
    /*---------------------------------------------------------------------------
        CCbvGetContrast
    
        Determines the contrast between cr1 and cr2.
    
        As the incoming parameters are COLORREFs, they must be in the
        normal RGB space.
    
        However, the result is given in the more usefull weighted RGB space.
    
    ----------------------------------------------------------------- DMORTON -*/
    CIC_NUM CCbvGetContrast(COLORREF cr1, COLORREF cr2)
    {
        // Calculate its magnitude - watch out for negative values
        return((CIC_NUM)sqrt((double)CCbvGetContrastSquared(cr1, cr2)));
    }
    
    
    /*---------------------------------------------------------------------------
        FCbvEnoughContrast
    
        Determines if crLocked and crMoveable meet the minimum contrast requirement,
        which is specified by dMinContrast.
    
        fDarkness will invoke consideration of how dark colors have less contrast,
        if its TRUE.  crLocked will be used to determine how dark the colors are.
    
    ----------------------------------------------------------------- DMORTON -*/
    BOOL FCbvEnoughContrast(COLORREF crLocked, COLORREF crMoveable,
                            CIC_NUM dMinContrast, BOOL fDarkness)
    {
        if (fDarkness)
        {
            // TODO DMORTON - how expensive is this CCbvGetContrast call?
            // Isn't it doing a square root?
            dMinContrast = CCbvScaleContrastForDarkness(dMinContrast,
                            CCbvGetContrast(crLocked, RGB(0, 0, 0)));
        }
    
        // Its much faster to square dMinContrast, then it is to square root
        // the calculated contrast.
        return(CCbvGetContrastSquared(crLocked, crMoveable) >
                 dMinContrast * dMinContrast);
    }
    
    /*---------------------------------------------------------------------------
        CbvIncreaseContrast
    
        Attempts to seperate crMoveable, from crLocked, so that their resulting
        contrast is at least cMinContrast.
    
        Its stupid to call this function if the colors already have this minimum
        contrast, so that case is asserted.
    
    ----------------------------------------------------------------- DMORTON -*/
    void CbvIncreaseContrast(COLORREF crLocked, COLORREF *pcrMoveable,
                             CIC_NUM cMinContrast)
    {
        CIC_NUM cLockedI = CCbvGetContrast(crLocked, RGB(0, 0, 0));
        CIC_NUM cMoveableI = CCbvGetContrast(*pcrMoveable, RGB(0, 0, 0));
    
        // Scale up dMinContrast if cLockedI is close to black, since we have
        // a hard time seeing differences in dark shades
        CIC_NUM cContrast = CCbvScaleContrastForDarkness(cMinContrast, cLockedI);
    
        BOOL fTowardsWhite;
    
        if (cMoveableI > cLockedI) // we want to move towards white
        {
            if (cLockedI < 442 - cContrast) // TODO DMORTON: is this a valid way of checking available distance to white?
            {
                fTowardsWhite = TRUE; // There is room towards white
            }
            else
            {
                fTowardsWhite = FALSE; // There is no room towards white, try black
            }
        }
        else // we want to move towards black
        {
            if (cLockedI > cContrast)
            {
                fTowardsWhite = FALSE; // There is room towards black
            }
            else
            {
                fTowardsWhite = TRUE; // There is no room towards black, try white
            }
        }

        // Convert to weighted color space
        CIC_NUM cRedL = GetRValue(crLocked) * (CIC_NUM) MAX_RED / 255;
        CIC_NUM cGreenL = GetGValue(crLocked) * (CIC_NUM) MAX_GREEN / 255;
        CIC_NUM cBlueL = GetBValue(crLocked) * (CIC_NUM) MAX_BLUE / 255;
    
        CIC_NUM cRedM = GetRValue(*pcrMoveable) * (CIC_NUM) MAX_RED / 255;
        CIC_NUM cGreenM = GetGValue(*pcrMoveable) * (CIC_NUM) MAX_GREEN / 255;
        CIC_NUM cBlueM = GetBValue(*pcrMoveable) * (CIC_NUM) MAX_BLUE / 255;
    
        if (fTowardsWhite)
        {
            // Convert everything so white is the origin
            cRedM = MAX_RED - cRedM;
            cGreenM = MAX_GREEN - cGreenM;
            cBlueM = MAX_BLUE - cBlueM;
    
            cRedL = MAX_RED - cRedL;
            cGreenL = MAX_GREEN - cGreenL;
            cBlueL = MAX_BLUE - cBlueL;
        }
    
        // Calculate the magnitude of the moveable color
        CIC_NUM cMagMove = (CIC_NUM)sqrt(cRedM * cRedM + cGreenM * cGreenM + cBlueM * cBlueM);
    
        // we don't want some floating point snafu to cause us
        // to go negative, or be zero
        cMagMove = max(0.001f, cMagMove);
    
        // Dot product the locked color and the moveable color
        CIC_NUM cLockDotMove = cRedL * cRedM + cGreenL * cGreenM + cBlueL * cBlueM;
        // Take the projection of the locked color onto the moveable color
        CIC_NUM cLockProjected = (cLockDotMove) / cMagMove;
        CIC_NUM cScale = cLockProjected / cMagMove;
    
        CIC_NUM cRedTemp = cScale * cRedM - cRedL;
        CIC_NUM cGreenTemp = cScale * cGreenM - cGreenL;
        CIC_NUM cBlueTemp = cScale * cBlueM - cBlueL;
    
        // Calculate the last side of the triangle,
        // this is simply r^2 = a^2 + b^2, solving for b.
        CIC_NUM cN = (CIC_NUM)sqrt(cContrast * cContrast -
                       (cRedTemp * cRedTemp + cGreenTemp * cGreenTemp +
                            cBlueTemp * cBlueTemp));
    
        CIC_NUM cNewMagMove = cLockProjected - cN;
    
        // Scale the unit moveable vector
        cRedM = cRedM * cNewMagMove / cMagMove;
        cGreenM = cGreenM * cNewMagMove / cMagMove;
        cBlueM = cBlueM * cNewMagMove / cMagMove;
    
        if (fTowardsWhite)
        {
            // Convert everything back again
            cRedM = MAX_RED - cRedM;
            cGreenM = MAX_GREEN - cGreenM;
            cBlueM = MAX_BLUE - cBlueM;
        }
    
        cRedM = min(MAX_RED, max(0, cRedM));
        cGreenM = min(MAX_GREEN, max(0, cGreenM));
        cBlueM = min(MAX_BLUE, max(0, cBlueM));
    
        // Convert back to normal RGB color space
        int cR = (int)(cRedM * 255 / MAX_RED + 0.5);
        int cG = (int)(cGreenM * 255 / MAX_GREEN + 0.5);
        int cB = (int)(cBlueM * 255 / MAX_BLUE + 0.5);
    
        cR = max(0, min(255, cR));
        cG = max(0, min(255, cG));
        cB = max(0, min(255, cB));
    
        *pcrMoveable = RGB(cR, cG, cB);
    }
    
    /*---------------------------------------------------------------------------
        CbvDecreaseContrast
    
        Attempts to pull crMoveable towards crLocked, so that their resulting
        contrast is at most cMaxContrast.
    
        Its stupid to call this function if the colors already have this maximum
        contrast, so that case is asserted.
    
    ----------------------------------------------------------------- DMORTON -*/
    void CbvDecreaseContrast(COLORREF crLocked, COLORREF *pcrMoveable, CIC_NUM cMaxContrast)
    {
        CIC_NUM cLockedI = CCbvGetContrast(crLocked, RGB(0, 0, 0));
    
        // Scale up dMaxContrast if cLockedI is close to black, since we have
        // a hard time seeing differences in dark shades
        CIC_NUM dContrast = CCbvScaleContrastForDarkness(cMaxContrast, cLockedI);
    
        CIC_NUM cRedL = GetRValue(crLocked) * (CIC_NUM) MAX_RED / 255;
        CIC_NUM cGreenL = GetGValue(crLocked) * (CIC_NUM) MAX_GREEN / 255;
        CIC_NUM cBlueL = GetBValue(crLocked) * (CIC_NUM) MAX_BLUE / 255;
    
        CIC_NUM cRedM = GetRValue(*pcrMoveable) * (CIC_NUM) MAX_RED / 255;
        CIC_NUM cGreenM = GetGValue(*pcrMoveable) * (CIC_NUM) MAX_GREEN / 255;
        CIC_NUM cBlueM = GetBValue(*pcrMoveable) * (CIC_NUM) MAX_BLUE / 255;
    
        CIC_NUM cRedDelta = cRedL - cRedM;
        CIC_NUM cGreenDelta = cGreenL - cGreenM;
        CIC_NUM cBlueDelta = cBlueL - cBlueM;
    
        // Add to moveable a fraction of delta, to get it closer to locked.
        CIC_NUM dMagDelta = (CIC_NUM)sqrt(cRedDelta * cRedDelta + cGreenDelta * cGreenDelta
                                    + cBlueDelta * cBlueDelta);
        CIC_NUM dScale = (dMagDelta - dContrast) / dMagDelta;
    
        cRedM += cRedDelta * dScale;
        cGreenM += cGreenDelta * dScale;
        cBlueM += cBlueDelta * dScale;
    
        cRedM = min(MAX_RED, max(0, cRedM));
        cGreenM = min(MAX_GREEN, max(0, cGreenM));
        cBlueM = min(MAX_BLUE, max(0, cBlueM));
    
        // Transform back into normal RGB space...
        int cR = (int)(cRedM * 255 / MAX_RED + 0.5);
        int cG = (int)(cGreenM * 255 / MAX_GREEN + 0.5);
        int cB = (int)(cBlueM * 255 / MAX_BLUE + 0.5);
    
        cR = max(0, min(255, cR));
        cG = max(0, min(255, cG));
        cB = max(0, min(255, cB));
    
        *pcrMoveable = RGB(cR, cG, cB);
    
    }
    
    
    /*---------------------------------------------------------------------------
        CbvFixContrastProblems
    
        Goes through all crucial combinations of colors, ensuring that minimum
        and maximum contrasts are in place.
    
    ----------------------------------------------------------------- DMORTON -*/
    void CbvFixContrastProblems()
    {
#if 0
        if (FCbvEnoughContrast(m_rgColor[OFC10COLOR_MAINMENUBKGD],
                               m_rgColor[OFC10COLOR_BKGDTB], 35, TRUE))
        {
            CbvDecreaseContrast(m_rgColor[OFC10COLOR_MAINMENUBKGD],
                                &(m_rgColor[OFC10COLOR_BKGDTB]), 35);
        }
#else

        if (FCbvEnoughContrast(col(COLOR_BTNFACE),
                               m_rgColor[OFC10COLOR_BKGDTB], 35, TRUE))
        {
            CbvDecreaseContrast(col(COLOR_BTNFACE),
                                &(m_rgColor[OFC10COLOR_BKGDTB]), 35);
        }
#endif

        int i;
        for(i = 0; i < sizeof(vrgContrast) / sizeof(vrgContrast[0]); i++)
        {
            if (!FCbvEnoughContrast(m_rgColor[vrgContrast[i].colLocked],
                                    m_rgColor[vrgContrast[i].colMoveable],
                                    vrgContrast[i].cMinContrast,
                                    vrgContrast[i].fConsiderDarkness))
            {
                CbvIncreaseContrast(m_rgColor[vrgContrast[i].colLocked],
                                    &(m_rgColor[vrgContrast[i].colMoveable]),
                                    vrgContrast[i].cMinContrast);
            }
        }
    }
};


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  S C H E M E  D E F                                              */
/*                                                                             */
/*=============================================================================*/

static SYSCOLOR v_rgSysCol[ UIFCOLOR_MAX ] =
{
    SYSCOLOR_3DFACE,                /* UIFCOLOR_MENUBKGND            */
    SYSCOLOR_3DFACE,                /* UIFCOLOR_MENUBARSHORT         */
    SYSCOLOR_3DFACE,                /* UIFCOLOR_MENUBARLONG          */
    SYSCOLOR_HIGHLIGHT,             /* UIFCOLOR_MOUSEOVERBKGND       */
    SYSCOLOR_HIGHLIGHT,             /* UIFCOLOR_MOUSEOVERBORDER      */
    SYSCOLOR_HIGHLIGHTTEXT,         /* UIFCOLOR_MOUSEOVERTEXT        */
    SYSCOLOR_HIGHLIGHT,             /* UIFCOLOR_MOUSEDOWNBKGND       */
    SYSCOLOR_HIGHLIGHT,             /* UIFCOLOR_MOUSEDOWNBORDER      */
    SYSCOLOR_HIGHLIGHTTEXT,         /* UIFCOLOR_MOUSEDOWNTEXT        */
    SYSCOLOR_3DFACE,                /* UIFCOLOR_CTRLBKGND            */
    SYSCOLOR_BTNTEXT,               /* UIFCOLOR_CTRLTEXT             */
    SYSCOLOR_GRAYTEXT,              /* UIFCOLOR_CTRLTEXTDISABLED     */
    SYSCOLOR_3DSHAODW,              /* UIFCOLOR_CTRLIMAGESHADOW      */
    SYSCOLOR_HIGHLIGHT,             /* UIFCOLOR_CTRLBKGNDSELECTED    */
    SYSCOLOR_ACTIVEBORDER,          /* UIFCOLOR_BORDEROUTER          */
    SYSCOLOR_3DFACE,                /* UIFCOLOR_BORDERINNER          */
    SYSCOLOR_ACTIVECAPTION,         /* UIFCOLOR_ACTIVECAPTIONBKGND   */
    SYSCOLOR_CAPTIONTEXT,           /* UIFCOLOR_ACTIVECAPTIONTEXT    */
    SYSCOLOR_INACTIVECAPTION,       /* UIFCOLOR_INACTIVECAPTIONBKGND */
    SYSCOLOR_INACTIVECAPTIONTEXT,   /* UIFCOLOR_INACTIVECAPTIONTEXT  */
    SYSCOLOR_BTNSHADOW,             /* UIFCOLOR_SPLITTERLINE         */
    SYSCOLOR_BTNTEXT,               /* UIFCOLOR_DRAGHANDLE           */


    SYSCOLOR_3DFACE,                /* UIFCOLOR_WINDOW               */
};


//
// CUIFSchemeDef
//  = UI object default scheme =
//

class CUIFSchemeDef : public CUIFScheme
{
public:
    CUIFSchemeDef( UIFSCHEME scheme )
    {
        m_scheme = scheme;
    }

    virtual ~CUIFSchemeDef( void )
    {
    }

    //
    // CUIFScheme methods
    //

    /*   G E T  T Y P E   */
    /*------------------------------------------------------------------------------
    
        Get scheme type
    
    ------------------------------------------------------------------------------*/
    virtual UIFSCHEME GetType( void )
    {
        return m_scheme;
    }

    /*   G E T  C O L O R   */
    /*------------------------------------------------------------------------------
    
        Get scheme color
    
    ------------------------------------------------------------------------------*/
    virtual COLORREF GetColor( UIFCOLOR iCol )
    {
        return v_pColTableSys->GetColor( v_rgSysCol[ iCol ] );
    }

    /*   G E T  B R U S H   */
    /*------------------------------------------------------------------------------
    
        Get scheme brush
    
    ------------------------------------------------------------------------------*/
    virtual HBRUSH GetBrush( UIFCOLOR iCol )
    {
        return v_pColTableSys->GetBrush( v_rgSysCol[ iCol ] );
    }

    /*   C Y  M E N U  I T E M   */
    /*------------------------------------------------------------------------------
    
        Get menu item height
    
    ------------------------------------------------------------------------------*/
    virtual int CyMenuItem( int cyMenuText )
    {
        return cyMenuText + 2;
    }

    /*   C X  S I Z E  F R A M E   */
    /*------------------------------------------------------------------------------

        Get size frame width

    ------------------------------------------------------------------------------*/
    virtual int CxSizeFrame( void )
    {
        return GetSystemMetrics( SM_CXSIZEFRAME );
    }

    /*   C Y  S I Z E  F R A M E   */
    /*------------------------------------------------------------------------------

        Get size frame height

    ------------------------------------------------------------------------------*/
    virtual int CySizeFrame( void )
    {
        return GetSystemMetrics( SM_CYSIZEFRAME );
    }

    /*   C X  W N D  B O R D E R   */
    /*------------------------------------------------------------------------------

        Get window border width

    ------------------------------------------------------------------------------*/
    virtual int CxWndBorder( void )
    {
        return 1;
    }

    /*   C Y  W N D  B O R D E R   */
    /*------------------------------------------------------------------------------

        Get window border height

    ------------------------------------------------------------------------------*/
    virtual int CyWndBorder( void )
    {
        return 1;
    }

    /*   F I L L  R E C T   */
    /*------------------------------------------------------------------------------
    
        Fill rect by shceme color
    
    ------------------------------------------------------------------------------*/
    virtual void FillRect( HDC hDC, const RECT *prc, UIFCOLOR iCol )
    {
        ::FillRect( hDC, prc, GetBrush( iCol ) );
    }

    /*   F R A M E  R E C T   */
    /*------------------------------------------------------------------------------
    
        Frame rect by scheme color
    
    ------------------------------------------------------------------------------*/
    virtual void FrameRect( HDC hDC, const RECT *prc, UIFCOLOR iCol )
    {
        ::FrameRect( hDC, prc, GetBrush( iCol ) );
    }

    /*   D R A W  S E L E C T I O N  R E C T   */
    /*------------------------------------------------------------------------------
    
        Draw selection rect
    
    ------------------------------------------------------------------------------*/
    virtual void DrawSelectionRect( HDC hDC, const RECT *prc, BOOL fMouseDown )
    {
        Assert( prc != NULL );
        ::FillRect( hDC, prc, GetBrush( UIFCOLOR_MOUSEDOWNBKGND ) );
    }

    /*   G E T  C T R L  F A C E  O F F S E T   */
    /*------------------------------------------------------------------------------
    
        Get offcet of control face from status
    
    ------------------------------------------------------------------------------*/
    virtual void GetCtrlFaceOffset( DWORD dwFlag, DWORD dwState, SIZE *poffset )
    {
        int cxyOffset = 0;

        Assert( PtrToInt(poffset) );
        if ((dwState & UIFDCS_SELECTED) == UIFDCS_SELECTED) {
            cxyOffset = (dwFlag & UIFDCF_RAISEDONSELECT) ? -1 : 
                        (dwFlag & UIFDCF_SUNKENONSELECT) ? +1 : 0;
        }
        else if ((dwState & UIFDCS_MOUSEDOWN) == UIFDCS_MOUSEDOWN) {
            cxyOffset = (dwFlag & UIFDCF_RAISEDONMOUSEDOWN) ? -1 : 
                        (dwFlag & UIFDCF_SUNKENONMOUSEDOWN) ? +1 : 0;
        } 
        else if ((dwState & UIFDCS_MOUSEOVER) == UIFDCS_MOUSEOVER) {
            cxyOffset = (dwFlag & UIFDCF_RAISEDONMOUSEOVER) ? -1 : 
                        (dwFlag & UIFDCF_SUNKENONMOUSEOVER) ? +1 : 0;
        }
        else {
            cxyOffset = (dwFlag & UIFDCF_RAISEDONNORMAL) ? -1 : 
                        (dwFlag & UIFDCF_RAISEDONNORMAL) ? +1 : 0;
        }

        poffset->cx = cxyOffset;
        poffset->cy = cxyOffset;
    }

    /*   D R A W  C T R L  B K G D   */
    /*------------------------------------------------------------------------------
    
        Paint control background
    
    ------------------------------------------------------------------------------*/
    virtual void DrawCtrlBkgd( HDC hDC, const RECT *prc, DWORD dwFlag, DWORD dwState )
    {
        Assert( prc != NULL );
        ::FillRect( hDC, prc, GetBrush( UIFCOLOR_CTRLBKGND ) );

#ifndef UNDER_CE
        if (((dwState & UIFDCS_SELECTED) != 0) && ((dwState & UIFDCS_MOUSEDOWN) == 0)) {
            RECT rc = *prc;
            HBRUSH hBrush;
            COLORREF colTextOld;
            COLORREF colBackOld;
            hBrush = CreateDitherBrush();
            if (hBrush)
            {
                colTextOld = SetTextColor( hDC, GetSysColor(COLOR_3DFACE) );
                colBackOld = SetBkColor( hDC, GetSysColor(COLOR_3DHILIGHT) );

                InflateRect( &rc, -2, -2 );
                ::FillRect( hDC, &rc, hBrush );

                SetTextColor( hDC, colTextOld );
                SetBkColor( hDC, colBackOld );
                DeleteObject( hBrush );
            }
        }
#endif /* !UNDER_CE */
    }

    /*   D R A W  C T R L  E D G E   */
    /*------------------------------------------------------------------------------
    
        Paint control edge
    
    ------------------------------------------------------------------------------*/
    virtual void DrawCtrlEdge( HDC hDC, const RECT *prc, DWORD dwFlag, DWORD dwState )
    {
        UINT uiEdge = 0;

        if ((dwState & UIFDCS_SELECTED) == UIFDCS_SELECTED) {
            uiEdge = (dwFlag & UIFDCF_RAISEDONSELECT) ? BDR_RAISEDINNER : 
                     (dwFlag & UIFDCF_SUNKENONSELECT) ? BDR_SUNKENOUTER : 0;
        }
        else if ((dwState & UIFDCS_MOUSEDOWN) == UIFDCS_MOUSEDOWN) {
            uiEdge = (dwFlag & UIFDCF_RAISEDONMOUSEDOWN) ? BDR_RAISEDINNER : 
                     (dwFlag & UIFDCF_SUNKENONMOUSEDOWN) ? BDR_SUNKENOUTER : 0;
        } 
        else if ((dwState & UIFDCS_MOUSEOVER) == UIFDCS_MOUSEOVER) {
            uiEdge = (dwFlag & UIFDCF_RAISEDONMOUSEOVER) ? BDR_RAISEDINNER : 
                     (dwFlag & UIFDCF_SUNKENONMOUSEOVER) ? BDR_SUNKENOUTER : 0;
        }
        else {
            uiEdge = (dwFlag & UIFDCF_RAISEDONNORMAL) ? BDR_RAISEDINNER : 
                     (dwFlag & UIFDCF_RAISEDONNORMAL) ? BDR_SUNKENOUTER : 0;
        }

        if (uiEdge != 0) {
            RECT rcT = *prc;
            DrawEdge( hDC, &rcT, uiEdge, BF_RECT );
        }
    }

    /*   D R A W  C T R L  T E X T   */
    /*------------------------------------------------------------------------------
    
        Paint control text
    
    ------------------------------------------------------------------------------*/
    virtual void DrawCtrlText( HDC hDC, const RECT *prc, LPCWSTR pwch, int cwch, DWORD dwState , BOOL fVertical)
    {
        RECT     rc;
        COLORREF colTextOld = GetTextColor( hDC );
        int      iBkModeOld = SetBkMode( hDC, TRANSPARENT );

        Assert( prc != NULL );
        Assert( pwch != NULL );

        rc = *prc;
        if (cwch == -1) {
            cwch = StrLenW(pwch);
        }
        if (dwState & UIFDCS_DISABLED) {
            OffsetRect( &rc, +1, +1 );
    
            SetTextColor( hDC, GetSysColor(COLOR_3DHIGHLIGHT) );    // TODO: KojiW
            CUIExtTextOut( hDC,
                            fVertical ? rc.right : rc.left,
                            rc.top,
                            ETO_CLIPPED,
                            &rc,
                            pwch,
                            cwch,
                            NULL );
    
            OffsetRect( &rc, -1, -1 );
        }
    
        SetTextColor( hDC, GetSysColor(COLOR_BTNTEXT) );   // TODO: KojiW
        CUIExtTextOut( hDC,
                        fVertical ? rc.right : rc.left,
                        rc.top,
                        ETO_CLIPPED,
                        &rc,
                        pwch,
                        cwch,
                        NULL );

        SetTextColor( hDC, colTextOld );
        SetBkMode( hDC, iBkModeOld );
    }

    /*   D R A W  C T R L  I C O N   */
    /*------------------------------------------------------------------------------
    
        Paint control icon
    
    ------------------------------------------------------------------------------*/
    virtual void DrawCtrlIcon( HDC hDC, const RECT *prc, HICON hIcon, DWORD dwState , SIZE *psizeIcon)
    {
        Assert( prc != NULL );
        if (IsRTLLayout())
        {
            HBITMAP hbmp;
            HBITMAP hbmpMask;
            if (CUIGetIconBitmaps(hIcon, &hbmp, &hbmpMask, psizeIcon))
            {
                DrawCtrlBitmap( hDC, prc, hbmp, hbmpMask, dwState );
                DeleteObject(hbmp);
                DeleteObject(hbmpMask);
            }
        }
        else
        {
            CUIDrawState( hDC,
                NULL,
                NULL,
                (LPARAM)hIcon,
                0,
                prc->left,
                prc->top,
                0,
                0,
                DST_ICON | ((dwState & UIFDCS_DISABLED) ? (DSS_DISABLED | DSS_MONO) : 0) );
        }
    }

    /*   D R A W  C T R L  B I T M A P   */
    /*------------------------------------------------------------------------------
    
        Paint control bitmap
    
    ------------------------------------------------------------------------------*/
    virtual void DrawCtrlBitmap( HDC hDC, const RECT *prc, HBITMAP hBmp, HBITMAP hBmpMask, DWORD dwState )
    {
        Assert( prc != NULL );

        if (IsRTLLayout())
        {
            hBmp = CUIMirrorBitmap(hBmp, GetBrush(UIFCOLOR_CTRLBKGND));
            hBmpMask = CUIMirrorBitmap(hBmpMask, (HBRUSH)GetStockObject(BLACK_BRUSH));
        }

        if (!hBmpMask)
        {
            CUIDrawState( hDC,
                NULL,
                NULL,
                (LPARAM)hBmp,
                0,
                prc->left,
                prc->top,
                prc->right - prc->left,
                prc->bottom - prc->top,
                DST_BITMAP | ((dwState & UIFDCS_DISABLED) ? (DSS_DISABLED | DSS_MONO) : 0) );
        }
        else
        {
            HBITMAP hBmpTmp;
            HBRUSH hbr;
            BOOL fDeleteHBR = FALSE;

            if (dwState & UIFDCS_DISABLED) {
                hBmpTmp = CreateDisabledBitmap(prc, 
                                               hBmpMask, 
                                               GetBrush(UIFCOLOR_CTRLBKGND),
                                               GetBrush(UIFCOLOR_CTRLTEXTDISABLED ), TRUE);
            }
            else
            {

                if (((dwState & UIFDCS_SELECTED) != 0) && ((dwState & UIFDCS_MOUSEDOWN) == 0)) 
                {
                    hbr = CreateDitherBrush();
                    fDeleteHBR = TRUE;
                }
                // else if (dwState & UIFDCS_SELECTED)
                //     hbr = (HBRUSH)(COLOR_3DHIGHLIGHT + 1);
                else
                    hbr = (HBRUSH)(COLOR_3DFACE + 1);

                hBmpTmp = CreateMaskBmp(prc, hBmp, hBmpMask, hbr,
                                        GetSysColor(COLOR_3DFACE),
                                        GetSysColor(COLOR_3DHILIGHT));
#if 0
    CBitmapDC hdcTmp;
    CBitmapDC hdcSrc((HDC)hdcTmp);
    CBitmapDC hdcMask((HDC)hdcTmp);
    CBitmapDC hdcDst((HDC)hdcTmp);
    hdcSrc.SetBitmap(hBmp);
    hdcMask.SetBitmap(hBmpMask);
    hdcDst.SetBitmap(hBmpTmp);
    BitBlt(hdcTmp,  0, 30, 30, 30, hdcSrc, 0, 0, SRCCOPY);
    BitBlt(hdcTmp, 30, 30, 30, 30, hdcMask, 0, 0, SRCCOPY);
    BitBlt(hdcTmp, 60, 30, 30, 30, hdcDst, 0, 0, SRCCOPY);
    hdcSrc.GetBitmapAndKeep();
    hdcMask.GetBitmapAndKeep();
    hdcDst.GetBitmapAndKeep();
#endif
            }

            if (hBmpTmp)
            {
                CUIDrawState( hDC,
                    NULL,
                    NULL,
                    (LPARAM)hBmpTmp,
                    0,
                    prc->left,
                    prc->top,
                    prc->right - prc->left,
                    prc->bottom - prc->top,
                    DST_BITMAP);

                DeleteObject(hBmpTmp);
            }
            if (fDeleteHBR)
                DeleteObject(hbr );
        }

        if (IsRTLLayout())
        {
            DeleteObject(hBmp);
            DeleteObject(hBmpMask);
        }
    }

    /*   D R A W  M E N U  B I T M A P   */
    /*------------------------------------------------------------------------------
    
        Paint menu bitmap
    
    ------------------------------------------------------------------------------*/
    virtual void DrawMenuBitmap( HDC hDC, const RECT *prc, HBITMAP hBmp, HBITMAP hBmpMask, DWORD dwState )
    {
        DrawCtrlBitmap( hDC, prc, hBmp, hBmpMask, dwState );
    }

    /*   D R A W  M E N U  S E P A R A T O R
    /*------------------------------------------------------------------------------
    
        Paint menu separator
    
    ------------------------------------------------------------------------------*/
    virtual void DrawMenuSeparator( HDC hDC, const RECT *prc)
    {
        RECT rc;
        rc = *prc;
        rc.bottom = rc.top + (rc.bottom - rc.top) / 2;
        ::FillRect(hDC, &rc, (HBRUSH)(COLOR_3DSHADOW + 1));
        rc = *prc;
        rc.top = rc.top + (rc.bottom - rc.top) / 2;
        ::FillRect(hDC, &rc, (HBRUSH)(COLOR_3DHIGHLIGHT + 1));
    }

    /*   D R A W  F R A M E  C T R L  B K G D   */
    /*------------------------------------------------------------------------------
    
        Paint frame control background
    
    ------------------------------------------------------------------------------*/
    virtual void DrawFrameCtrlBkgd( HDC hDC, const RECT *prc, DWORD dwFlag, DWORD dwState )
    {
        DrawCtrlBkgd( hDC, prc, dwFlag, dwState );
    }

    /*   D R A W  F R A M E  C T R L  E D G E   */
    /*------------------------------------------------------------------------------
    
        Paint frame control edge
    
    ------------------------------------------------------------------------------*/
    virtual void DrawFrameCtrlEdge( HDC hDC, const RECT *prc, DWORD dwFlag, DWORD dwState )
    {
        DrawCtrlEdge( hDC, prc, dwFlag, dwState );
    }

    /*   D R A W  F R A M E  C T R L  I C O N   */
    /*------------------------------------------------------------------------------
    
        Paint frame control icon
    
    ------------------------------------------------------------------------------*/
    virtual void DrawFrameCtrlIcon( HDC hDC, const RECT *prc, HICON hIcon, DWORD dwState , SIZE *psizeIcon)
    {
        DrawCtrlIcon( hDC, prc, hIcon, dwState , psizeIcon);
    }

    /*   D R A W  F R A M E  C T R L  B I T M A P   */
    /*------------------------------------------------------------------------------
    
        Paint frame control bitmap
    
    ------------------------------------------------------------------------------*/
    virtual void DrawFrameCtrlBitmap( HDC hDC, const RECT *prc, HBITMAP hBmp, HBITMAP hBmpMask, DWORD dwState )
    {
        DrawCtrlBitmap( hDC, prc, hBmp, hBmpMask, dwState );
    }

    /*   D R A W  W N D  F R A M E   */
    /*------------------------------------------------------------------------------



    ------------------------------------------------------------------------------*/
    virtual void DrawWndFrame( HDC hDC, const RECT *prc, DWORD dwFlag, int cxFrame, int cyFrame )
    {
        RECT rc = *prc;

        switch (dwFlag) {
            default:
            case UIFDWF_THIN: {
                FrameRect( hDC, &rc, UIFCOLOR_BORDEROUTER );
                break;
            }

            case UIFDWF_THICK:
            case UIFDWF_ROUNDTHICK: {
                DrawEdge( hDC, &rc, EDGE_RAISED, BF_RECT );
                break;
            }
        }
    }

    /*   D R A W  D R A G  H A N D L E */
    /*------------------------------------------------------------------------------



    ------------------------------------------------------------------------------*/
    virtual void DrawDragHandle( HDC hDC, const RECT *prc, BOOL fVertical)
    {
        RECT rc;
        if (!fVertical)
        {
            ::SetRect(&rc, 
                      prc->left + 1, 
                      prc->top, 
                      prc->left + 4, 
                      prc->bottom);
        }
        else
        {
            ::SetRect(&rc, 
                      prc->left, 
                      prc->top + 1, 
                      prc->right, 
                      prc->top + 4);
        }

        DrawEdge(hDC, &rc, BDR_RAISEDINNER, BF_RECT);
    }

    /*   D R A W  S E P A R A T O R */
    /*------------------------------------------------------------------------------



    ------------------------------------------------------------------------------*/
    virtual void DrawSeparator( HDC hDC, const RECT *prc, BOOL fVertical)
    {
        CSolidPen hpenL;
        CSolidPen hpenS;
        HPEN hpenOld = NULL;
    
        if (!hpenL.Init(GetSysColor(COLOR_3DHILIGHT)))
            return;
    
        if (!hpenS.Init(GetSysColor(COLOR_3DSHADOW)))
            return;
    
        if (!fVertical)
        {
            hpenOld = (HPEN)SelectObject(hDC, (HPEN)hpenS);
            MoveToEx(hDC, prc->left + 1, prc->top, NULL);
            LineTo(hDC,   prc->left + 1, prc->bottom);
    
            SelectObject(hDC, (HPEN)hpenL);
            MoveToEx(hDC, prc->left + 2, prc->top, NULL);
            LineTo(hDC,   prc->left + 2, prc->bottom);
        }
        else
        {
            hpenOld = (HPEN)SelectObject(hDC, (HPEN)hpenS);
            MoveToEx(hDC, prc->left , prc->top + 1, NULL);
            LineTo(hDC,   prc->right, prc->top + 1);

            SelectObject(hDC, (HPEN)hpenL);
            MoveToEx(hDC, prc->left , prc->top + 2, NULL);
            LineTo(hDC,   prc->right, prc->top + 2);
    }
    
        SelectObject(hDC, hpenOld);
    }

protected:
    UIFSCHEME m_scheme;
};


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  S C H E M E  O F F 1 0  L O O K                                 */
/*                                                                             */
/*=============================================================================*/

static OFC10COLOR v_rgO10ColMenu[ UIFCOLOR_MAX ] = 
{
    OFC10COLOR_BKGDMENU,                /* UIFCOLOR_MENUBKGND            */
    OFC10COLOR_MENUBARSHORT,            /* UIFCOLOR_MENUBARSHORT         */
    OFC10COLOR_MENUBARLONG,             /* UIFCOLOR_MENUBARLONG          */
    OFC10COLOR_MOUSEOVERBKGND,          /* UIFCOLOR_MOUSEOVERBKGND       */
    OFC10COLOR_MOUSEOVERBORDER,         /* UIFCOLOR_MOUSEOVERBORDER      */
    OFC10COLOR_MOUSEOVERTEXT,           /* UIFCOLOR_MOUSEOVERTEXT        */
    OFC10COLOR_MOUSEDOWNBKGND,          /* UIFCOLOR_MOUSEDOWNBKGND       */
    OFC10COLOR_MOUSEDOWNBORDER,         /* UIFCOLOR_MOUSEDOWNBORDER      */
    OFC10COLOR_MOUSEDOWNTEXT,           /* UIFCOLOR_MOUSEDOWNTEXT        */
    OFC10COLOR_CTRLBKGD,                /* UIFCOLOR_CTRLBKGND            */
    OFC10COLOR_MENUCTRLTEXT,            /* UIFCOLOR_CTRLTEXT             */
    OFC10COLOR_CTRLTEXTDISABLED,        /* UIFCOLOR_CTRLTEXTDISABLED     */
    OFC10COLOR_CTRLIMAGESHADOW,         /* UIFCOLOR_CTRLIMAGESHADOW      */
    OFC10COLOR_MOUSEOVERBKGND,          /* UIFCOLOR_CTRLBKGNDSELECTED    */
    OFC10COLOR_BDROUTERMENU,            /* UIFCOLOR_BORDEROUTER          */
    OFC10COLOR_BDRINNERMENU,            /* UIFCOLOR_BORDERINNER          */
    OFC10COLOR_ACTIVECAPTIONBKGDWP,     /* UIFCOLOR_ACTIVECAPTIONBKGND   */  // TEMP assign
    OFC10COLOR_ACTIVECAPTIONTEXTWP,     /* UIFCOLOR_ACTIVECAPTIONTEXT    */  // TEMP assign
    OFC10COLOR_INACTIVECAPTIONBKGDWP,   /* UIFCOLOR_INACTIVECAPTIONBKGND */  // TEMP assign
    OFC10COLOR_INACTIVECAPTIONTEXTWP,   /* UIFCOLOR_INACTIVECAPTIONTEXT  */  // TEMP assign
    OFC10COLOR_SPLITTERLINE,            /* UIFCOLOR_SPLITTERLINE         */
    OFC10COLOR_DRAGHANDLE,              /* UIFCOLOR_DRAGHANDLE           */

    // virtual colors

    OFC10COLOR_BKGDMENU,                /* UIFCOLOR_WINDOW               */
};


static OFC10COLOR v_rgO10ColToolbar[ UIFCOLOR_MAX ] = 
{
    OFC10COLOR_BKGDMENU,                /* UIFCOLOR_MENUBKGND            */
    OFC10COLOR_MENUBARSHORT,            /* UIFCOLOR_MENUBARSHORT         */
    OFC10COLOR_MENUBARLONG,             /* UIFCOLOR_MENUBARLONG          */
    OFC10COLOR_MOUSEOVERBKGND,          /* UIFCOLOR_MOUSEOVERBKGND       */
    OFC10COLOR_MOUSEOVERBORDER,         /* UIFCOLOR_MOUSEOVERBORDER      */
    OFC10COLOR_MOUSEOVERTEXT,           /* UIFCOLOR_MOUSEOVERTEXT        */
    OFC10COLOR_MOUSEDOWNBKGND,          /* UIFCOLOR_MOUSEDOWNBKGND       */
    OFC10COLOR_MOUSEDOWNBORDER,         /* UIFCOLOR_MOUSEDOWNBORDER      */
    OFC10COLOR_MOUSEDOWNTEXT,           /* UIFCOLOR_MOUSEDOWNTEXT        */
    OFC10COLOR_CTRLBKGD,                /* UIFCOLOR_CTRLBKGND            */
    OFC10COLOR_CTRLTEXT,                /* UIFCOLOR_CTRLTEXT             */
    OFC10COLOR_CTRLTEXTDISABLED,        /* UIFCOLOR_CTRLTEXTDISABLED     */
    OFC10COLOR_CTRLIMAGESHADOW,         /* UIFCOLOR_CTRLIMAGESHADOW      */
    OFC10COLOR_CTRLBKGDSELECTED,        /* UIFCOLOR_CTRLBKGNDSELECTED    */
    OFC10COLOR_BDROUTERFLOATTB,         /* UIFCOLOR_BORDEROUTER          */
    OFC10COLOR_BDRINNERFLOATTB,         /* UIFCOLOR_BORDERINNER          */
    OFC10COLOR_CAPTIONBKGDTB,           /* UIFCOLOR_ACTIVECAPTIONBKGND   */
    OFC10COLOR_CAPTIONTEXTTB,           /* UIFCOLOR_ACTIVECAPTIONTEXT    */
    OFC10COLOR_CAPTIONBKGDTB,           /* UIFCOLOR_INACTIVECAPTIONBKGND */
    OFC10COLOR_CAPTIONTEXTTB,           /* UIFCOLOR_INACTIVECAPTIONTEXT  */
    OFC10COLOR_SPLITTERLINE,            /* UIFCOLOR_SPLITTERLINE         */
    OFC10COLOR_DRAGHANDLE,              /* UIFCOLOR_DRAGHANDLE           */


    // virtual colors

    OFC10COLOR_BKGDTB,                  /* UIFCOLOR_WINDOW               */
};


static OFC10COLOR v_rgO10ColWorkPane[ UIFCOLOR_MAX ] = 
{
    OFC10COLOR_BKGDMENU,                /* UIFCOLOR_MENUBKGND            */
    OFC10COLOR_MENUBARSHORT,            /* UIFCOLOR_MENUBARSHORT         */
    OFC10COLOR_MENUBARLONG,             /* UIFCOLOR_MENUBARLONG          */
    OFC10COLOR_MOUSEOVERBKGND,          /* UIFCOLOR_MOUSEOVERBKGND       */
    OFC10COLOR_MOUSEOVERBORDER,         /* UIFCOLOR_MOUSEOVERBORDER      */
    OFC10COLOR_MOUSEOVERTEXT,           /* UIFCOLOR_MOUSEOVERTEXT        */
    OFC10COLOR_MOUSEDOWNBKGND,          /* UIFCOLOR_MOUSEDOWNBKGND       */
    OFC10COLOR_MOUSEDOWNBORDER,         /* UIFCOLOR_MOUSEDOWNBORDER      */
    OFC10COLOR_MOUSEDOWNTEXT,           /* UIFCOLOR_MOUSEDOWNTEXT        */
    OFC10COLOR_CTRLBKGD,                /* UIFCOLOR_CTRLBKGND            */
    OFC10COLOR_CTRLTEXT,                /* UIFCOLOR_CTRLTEXT             */
    OFC10COLOR_CTRLTEXTDISABLED,        /* UIFCOLOR_CTRLTEXTDISABLED     */
    OFC10COLOR_CTRLIMAGESHADOW,         /* UIFCOLOR_CTRLIMAGESHADOW      */
    OFC10COLOR_CTRLBKGDSELECTED,        /* UIFCOLOR_CTRLBKGNDSELECTED    */
    OFC10COLOR_BDROUTERFLOATWP,         /* UIFCOLOR_BORDEROUTER          */
    OFC10COLOR_BDRINNERFLOATWP,         /* UIFCOLOR_BORDERINNER          */
    OFC10COLOR_ACTIVECAPTIONBKGDWP,     /* UIFCOLOR_ACTIVECAPTIONBKGND   */
    OFC10COLOR_ACTIVECAPTIONTEXTWP,     /* UIFCOLOR_ACTIVECAPTIONTEXT    */
    OFC10COLOR_INACTIVECAPTIONBKGDWP,   /* UIFCOLOR_INACTIVECAPTIONBKGND */
    OFC10COLOR_INACTIVECAPTIONTEXTWP,   /* UIFCOLOR_INACTIVECAPTIONTEXT  */
    OFC10COLOR_SPLITTERLINE,            /* UIFCOLOR_SPLITTERLINE         */
    OFC10COLOR_DRAGHANDLE,              /* UIFCOLOR_DRAGHANDLE           */

    // virtual colors

    OFC10COLOR_BKGDWP,                  /* UIFCOLOR_WINDOW              */
};


//
// CUIFSchemeOff10
//

class CUIFSchemeOff10 : public CUIFScheme
{
public:
    CUIFSchemeOff10( UIFSCHEME scheme )
    {
        m_scheme = scheme;

        // find color map table

        switch (m_scheme) {
            default:
            case UIFSCHEME_OFC10MENU: {
                m_pcoldef = v_rgO10ColMenu;
                break;
            }

            case UIFSCHEME_OFC10TOOLBAR: {
                m_pcoldef = v_rgO10ColToolbar;
                break;
            }

            case UIFSCHEME_OFC10WORKPANE: {
                m_pcoldef = v_rgO10ColWorkPane;
                break;
            }
        }
    }

    virtual ~CUIFSchemeOff10( void )
    {
    }

    //
    // CUIFScheme method
    //

    /*   G E T  T Y P E   */
    /*------------------------------------------------------------------------------
    
        Get scheme type
    
    ------------------------------------------------------------------------------*/
    virtual UIFSCHEME GetType( void )
    {
        return m_scheme;
    }

    /*   G E T  C O L O R   */
    /*------------------------------------------------------------------------------
    
        Get scheme color
    
    ------------------------------------------------------------------------------*/
    virtual COLORREF GetColor( UIFCOLOR iCol )
    {
        return v_pColTableOfc10->GetColor( m_pcoldef[ iCol ] );
    }

    /*   G E T  B R U S H   */
    /*------------------------------------------------------------------------------
    
        Get scheme brush
    
    ------------------------------------------------------------------------------*/
    virtual HBRUSH GetBrush( UIFCOLOR iCol )
    {
        return v_pColTableOfc10->GetBrush( m_pcoldef[ iCol ] );
    }

    /*   C Y  M E N U  I T E M   */
    /*------------------------------------------------------------------------------
    
        Get menu item height
    
    ------------------------------------------------------------------------------*/
    virtual int CyMenuItem( int cyMenuText )
    {
        return cyMenuText + 4;
    }

    /*   C X  S I Z E  F R A M E   */
    /*------------------------------------------------------------------------------

        Get size frame width

    ------------------------------------------------------------------------------*/
    virtual int CxSizeFrame( void )
    {
        return max( 3, GetSystemMetrics( SM_CXSIZEFRAME ) - 2 );
    }

    /*   C Y  S I Z E  F R A M E   */
    /*------------------------------------------------------------------------------

        Get size frame height

    ------------------------------------------------------------------------------*/
    virtual int CySizeFrame( void )
    {
        return max( 3, GetSystemMetrics( SM_CYSIZEFRAME ) - 2 );
    }

    /*   C X  W N D  B O R D E R   */
    /*------------------------------------------------------------------------------

        Get window border width

    ------------------------------------------------------------------------------*/
    virtual int CxWndBorder( void )
    {
        return 1;
    }

    /*   C Y  W N D  B O R D E R   */
    /*------------------------------------------------------------------------------

        Get window border height

    ------------------------------------------------------------------------------*/
    virtual int CyWndBorder( void )
    {
        return 1;
    }

    /*   F I L L  R E C T   */
    /*------------------------------------------------------------------------------
    
        Fill rect by scheme color
    
    ------------------------------------------------------------------------------*/
    virtual void FillRect( HDC hDC, const RECT *prc, UIFCOLOR iCol )
    {
        ::FillRect( hDC, prc, GetBrush( iCol ) );
    }

    /*   F R A M E  R E C T   */
    /*------------------------------------------------------------------------------
    
        Frame rect by scheme color
    
    ------------------------------------------------------------------------------*/
    virtual void FrameRect( HDC hDC, const RECT *prc, UIFCOLOR iCol )
    {
        ::FrameRect( hDC, prc, GetBrush( iCol ) );
    }

    /*   D R A W  S E L E C T I O N  R E C T   */
    /*------------------------------------------------------------------------------
    
        Draw selection rect
    
    ------------------------------------------------------------------------------*/
    virtual void DrawSelectionRect( HDC hDC, const RECT *prc, BOOL fMouseDown )
    {
        Assert( prc != NULL );

        if (fMouseDown) {
            ::FillRect( hDC, prc, GetBrush( UIFCOLOR_MOUSEDOWNBKGND ) );
            ::FrameRect( hDC, prc, GetBrush( UIFCOLOR_MOUSEDOWNBORDER ) );
        }
        else {
            ::FillRect( hDC, prc, GetBrush( UIFCOLOR_MOUSEOVERBKGND ) );
            ::FrameRect( hDC, prc, GetBrush( UIFCOLOR_MOUSEOVERBORDER ) );
        }
    }

    /*   G E T  C T R L  F A C E  O F F S E T   */
    /*------------------------------------------------------------------------------
    
        Get offcet of control face from status
    
    ------------------------------------------------------------------------------*/
    virtual void GetCtrlFaceOffset( DWORD dwFlag, DWORD dwState, SIZE *poffset )
    {
        Assert( poffset != NULL );
        poffset->cx = 0;
        poffset->cy = 0;
    }

    /*   D R A W  C T R L  B K G D   */
    /*------------------------------------------------------------------------------
    
        get background color
    
    ------------------------------------------------------------------------------*/
    virtual UIFCOLOR GetBkgdCol( DWORD dwState )
    {
        UIFCOLOR col = UIFCOLOR_MAX; /* invalid */

        if ((dwState & UIFDCS_DISABLED) == 0) { /* enabled */
            if ((dwState & UIFDCS_MOUSEOVERSELECTED) == UIFDCS_MOUSEOVERSELECTED) {
                col = UIFCOLOR_MOUSEDOWNBKGND;    /* frame: 100% */
            }
            else if ((dwState & UIFDCS_MOUSEDOWN) == UIFDCS_MOUSEDOWN) {
                col = UIFCOLOR_MOUSEDOWNBKGND;    /* frame: 100% */
            }
            else if ((dwState & UIFDCS_MOUSEOVER) == UIFDCS_MOUSEOVER) {
                col = UIFCOLOR_MOUSEOVERBKGND;    /* frame: 65% */
            }
            else if ((dwState & UIFDCS_SELECTED) == UIFDCS_SELECTED) {
                col = UIFCOLOR_CTRLBKGNDSELECTED;    /* frame: 65% */
            }
            else {
                col = UIFCOLOR_WINDOW;
            }
        }
        else { /* disabled */
            col = UIFCOLOR_WINDOW;
        }

        return col;
    }

    /*   D R A W  C T R L  B K G D   */
    /*------------------------------------------------------------------------------
    
        Paint control background
    
    ------------------------------------------------------------------------------*/
    virtual void DrawCtrlBkgd( HDC hDC, const RECT *prc, DWORD dwFlag, DWORD dwState )
    {
        Assert( prc != NULL );
        UIFCOLOR col = GetBkgdCol(dwState);

        if (col != UIFCOLOR_MAX) {
            FillRect( hDC, prc, col );
        }
    }

    /*   D R A W  C T R L  E D G E   */
    /*------------------------------------------------------------------------------
    
        Paint control edge
    
    ------------------------------------------------------------------------------*/
    virtual void DrawCtrlEdge( HDC hDC, const RECT *prc, DWORD dwFlag, DWORD dwState )
    {
        UIFCOLOR col = UIFCOLOR_MAX; /* invalid color */

        if ((dwState & UIFDCS_DISABLED) == 0) { /* enabled */
            if ((dwState & UIFDCS_MOUSEOVERSELECTED) == UIFDCS_MOUSEOVERSELECTED) {
                col = UIFCOLOR_MOUSEDOWNBORDER;    /* frame: 100% */
            }
            else if ((dwState & UIFDCS_MOUSEDOWN) == UIFDCS_MOUSEDOWN) {
                col = UIFCOLOR_MOUSEDOWNBORDER;    /* frame: 100% */
            }
            else if ((dwState & UIFDCS_MOUSEOVER) == UIFDCS_MOUSEOVER) {
                col = UIFCOLOR_MOUSEOVERBORDER;    /* frame: 65% */
            }
            else if ((dwState & UIFDCS_SELECTED) == UIFDCS_SELECTED) {
                col = UIFCOLOR_MOUSEOVERBORDER;    /* frame: 65% */
            }
        }
        else { /* disabled */
            if ((dwState & UIFDCS_MOUSEOVERSELECTED) == UIFDCS_MOUSEOVERSELECTED) {
                col = UIFCOLOR_MOUSEDOWNBORDER;    /* frame: 100% */      // REVIEW: KOJIW: correct?
            }
            else if ((dwState & UIFDCS_MOUSEDOWN) == UIFDCS_MOUSEDOWN) {
                col = UIFCOLOR_CTRLTEXTDISABLED;
            }
            else if ((dwState & UIFDCS_MOUSEOVER) == UIFDCS_MOUSEOVER) {
                col = UIFCOLOR_MOUSEDOWNBORDER;    /* frame: 100% */      // REVIEW: KOJIW: correct?
            }
            else if ((dwState & UIFDCS_SELECTED) == UIFDCS_SELECTED) {
                col = UIFCOLOR_CTRLTEXTDISABLED;   // ????
            }
        }

        if (col != UIFCOLOR_MAX) {
            FrameRect( hDC, prc, col );
        }
    }

    /*   D R A W  C T R L  T E X T   */
    /*------------------------------------------------------------------------------
    
        Paint control text
    
    ------------------------------------------------------------------------------*/
    virtual void DrawCtrlText( HDC hDC, const RECT *prc, LPCWSTR pwch, int cwch, DWORD dwState , BOOL fVertical)
    {
        COLORREF colTextOld = GetTextColor( hDC );
        int      iBkModeOld = SetBkMode( hDC, TRANSPARENT );

        Assert( prc != NULL );
        Assert( pwch != NULL );

        if (cwch == -1) {
            cwch = StrLenW(pwch);
        }

        if ((dwState & UIFDCS_MOUSEOVERSELECTED) == UIFDCS_MOUSEOVERSELECTED) {
            SetTextColor( hDC, GetColor(UIFCOLOR_MOUSEDOWNTEXT) );
        } else if (dwState & UIFDCS_DISABLED) {
            SetTextColor( hDC, GetColor(UIFCOLOR_CTRLTEXTDISABLED) );
        } else if (dwState & UIFDCS_MOUSEOVER) {
            SetTextColor( hDC, GetColor(UIFCOLOR_MOUSEOVERTEXT) );
        } else if (dwState & UIFDCS_MOUSEDOWN) {
            SetTextColor( hDC, GetColor(UIFCOLOR_MOUSEDOWNTEXT) );
        } else {
            SetTextColor( hDC, GetColor(UIFCOLOR_CTRLTEXT) );
        }
        CUIExtTextOut( hDC,
                        fVertical ? prc->right : prc->left,
                        prc->top,
                        ETO_CLIPPED,
                        prc,
                        pwch,
                        cwch,
                        NULL );

        SetTextColor( hDC, colTextOld );
        SetBkMode( hDC, iBkModeOld );
    }

    /*   D R A W  C T R L  I C O N   */
    /*------------------------------------------------------------------------------
    
        Paint control icon
    
    ------------------------------------------------------------------------------*/
    virtual void DrawCtrlIcon( HDC hDC, const RECT *prc, HICON hIcon, DWORD dwState , SIZE *psizeIcon)
    {
#if 1
        HBITMAP hbmp;
        HBITMAP hbmpMask;
        if (CUIGetIconBitmaps(hIcon, &hbmp, &hbmpMask, psizeIcon))
        {
            DrawCtrlBitmap( hDC, prc, hbmp, hbmpMask, dwState );
            DeleteObject(hbmp);
            DeleteObject(hbmpMask);
        }
#else
        Assert( prc != NULL );
        if (((dwState & UIFDCS_MOUSEOVER) == UIFDCS_MOUSEOVER) && 
            ((dwState & UIFDCS_SELECTED) == 0) &&
            ((dwState & UIFDCS_DISABLED) == 0)) {
            // draw shadow

            CUIDrawState( hDC,
                GetBrush( UIFCOLOR_CTRLIMAGESHADOW ),
                NULL,
                (LPARAM)hIcon,
                0,
                prc->left + 1,
                prc->top + 1,
                0,
                0,
                DST_ICON | DSS_MONO );

            CUIDrawState( hDC,
                NULL,
                NULL,
                (LPARAM)hIcon,
                0,
                prc->left - 1,
                prc->top - 1,
                0,
                0,
                DST_ICON );
        }
        else {
            if (dwState & UIFDCS_DISABLED)
            {
                HICON hIconSm = NULL;

                if (hIcon)
                   hIconSm = (HICON)CopyImage(hIcon, IMAGE_ICON, 16, 16, 0);

                if (hIconSm)
                {
                    CUIDrawState( hDC,
                        NULL,
                        NULL,
                        (LPARAM)hIconSm,
                        0,
                        prc->left,
                        prc->top,
                        prc->right - prc->left,
                        prc->bottom - prc->top,
                        DST_ICON | (DSS_DISABLED | DSS_MONO));
                }
                else
                {
                    CUIDrawState( hDC,
                        NULL,
                        NULL,
                        (LPARAM)hIcon,
                        0,
                        prc->left,
                        prc->top,
                        0,
                        0,
                        DST_ICON | (DSS_DISABLED | DSS_MONO));
                }

                if (hIconSm)
                    DestroyIcon(hIconSm);
            }
            else
            {
                CUIDrawState( hDC,
                    NULL,
                    NULL,
                    (LPARAM)hIcon,
                    0,
                    prc->left,
                    prc->top,
                    0,
                    0,
                    DST_ICON);
            }
        }
#endif
    }

    /*   D R A W  C T R L  B I T M A P   */
    /*------------------------------------------------------------------------------
    
        Paint control bitmap
    
    ------------------------------------------------------------------------------*/
    virtual void DrawCtrlBitmap( HDC hDC, const RECT *prc, HBITMAP hBmp, HBITMAP hBmpMask, DWORD dwState )
    {
        Assert( prc != NULL );
        
        if (IsRTLLayout())
        {
            hBmp = CUIMirrorBitmap(hBmp, GetBrush(GetBkgdCol(dwState)));
            hBmpMask = CUIMirrorBitmap(hBmpMask, (HBRUSH)GetStockObject(BLACK_BRUSH));
        }

        if (((dwState & UIFDCS_MOUSEOVER) == UIFDCS_MOUSEOVER) && 
                 ((dwState & UIFDCS_SELECTED) == 0) &&
                 ((dwState & UIFDCS_DISABLED) == 0)) {
            if (!hBmpMask)
            {
                // draw shadow

                CUIDrawState( hDC,
                    GetBrush( UIFCOLOR_CTRLIMAGESHADOW ),
                    NULL,
                    (LPARAM)hBmp,
                    0,
                    prc->left + 1,
                    prc->top + 1,
                    prc->right - prc->left,
                    prc->bottom - prc->top,
                    DST_BITMAP | DSS_MONO );

                CUIDrawState( hDC,
                    NULL,
                    NULL,
                    (LPARAM)hBmp,
                    0,
                    prc->left - 1,
                    prc->top - 1,
                    prc->right - prc->left,
                    prc->bottom - prc->top,
                    DST_BITMAP );

            }
            else
            {
                HBITMAP hBmpTmp;
                UIFCOLOR col = GetBkgdCol(dwState);
                RECT rcNew = *prc;

                //
                // adjust rect of shadow for RTL layout.
                //
                if (IsRTLLayout())
                {
                    rcNew.left++;
                    rcNew.top++;
                }

                hBmpTmp = CreateShadowMaskBmp(&rcNew, 
                                        hBmp,  
                                        hBmpMask, 
                                        (HBRUSH)GetBrush(col),
                                        GetBrush( UIFCOLOR_CTRLIMAGESHADOW));




                if (hBmpTmp)
                {
                    CUIDrawState( hDC,
                        NULL,
                        NULL,
                        (LPARAM)hBmpTmp,
                        0,
                        rcNew.left,
                        rcNew.top,
                        rcNew.right - rcNew.left,
                        rcNew.bottom - rcNew.top,
                        DST_BITMAP );


                    DeleteObject(hBmpTmp);
                }
            }
        }
        else {

            if (!hBmpMask)
            {
                CUIDrawState( hDC,
                    NULL,
                    NULL,
                    (LPARAM)hBmp,
                    0,
                    prc->left,
                    prc->top,
                    prc->right - prc->left,
                    prc->bottom - prc->top,
                    DST_BITMAP | ((dwState & UIFDCS_DISABLED) ? (DSS_DISABLED | DSS_MONO) : 0) );

            }
            else
            {
                HBITMAP hBmpTmp;
                UIFCOLOR col = GetBkgdCol(dwState);
                if (dwState & UIFDCS_DISABLED) 
                    hBmpTmp = CreateDisabledBitmap(prc, 
                                           hBmpMask, 
                                           GetBrush(col),
                                           GetBrush(UIFCOLOR_CTRLTEXTDISABLED),
                                           FALSE);
                else
                    hBmpTmp = CreateMaskBmp(prc, 
                                            hBmp,  
                                            hBmpMask, 
                                            (HBRUSH)GetBrush(col), 0, 0);
                CUIDrawState( hDC,
                    NULL,
                    NULL,
                    (LPARAM)hBmpTmp,
                    0,
                    prc->left,
                    prc->top,
                    prc->right - prc->left,
                    prc->bottom - prc->top,
                    DST_BITMAP);
                    // DST_BITMAP | ((dwState & UIFDCS_DISABLED) ? (DSS_DISABLED | DSS_MONO) : 0) );

                DeleteObject(hBmpTmp);
            }
        }

        if (IsRTLLayout())
        {
            DeleteObject(hBmp);
            DeleteObject(hBmpMask);
        }

    }

    /*   D R A W  M E N U  B I T M A P   */
    /*------------------------------------------------------------------------------
    
        Paint menu bitmap
    
    ------------------------------------------------------------------------------*/
    virtual void DrawMenuBitmap( HDC hDC, const RECT *prc, HBITMAP hBmp, HBITMAP hBmpMask, DWORD dwState )
    {
        Assert( prc != NULL );

        if (IsRTLLayout())
        {
            // hBmp = CUIMirrorBitmap(hBmp, GetBrush(UIFCOLOR_CTRLBKGND));
            UIFCOLOR col;

            if (dwState & UIFDCS_SELECTED)
                // col = UIFCOLOR_CTRLIMAGESHADOW;
                col = UIFCOLOR_MOUSEOVERBKGND;  
            else
                col = UIFCOLOR_CTRLBKGND;

            hBmp = CUIMirrorBitmap(hBmp, GetBrush(col));
            hBmpMask = CUIMirrorBitmap(hBmpMask, (HBRUSH)GetStockObject(BLACK_BRUSH));
        }

        if (((dwState & UIFDCS_MOUSEOVER) == UIFDCS_MOUSEOVER) && ((dwState & UIFDCS_SELECTED) == 0)) {
            if (!hBmpMask)
            {
                // draw shadow
    
                CUIDrawState( hDC,
                    GetBrush( UIFCOLOR_CTRLIMAGESHADOW ),
                    NULL,
                    (LPARAM)hBmp,
                    0,
                    prc->left + 1,
                    prc->top + 1,
                    prc->right - prc->left,
                    prc->bottom - prc->top,
                    DST_BITMAP | DSS_MONO );

                CUIDrawState( hDC,
                    NULL,
                    NULL,
                    (LPARAM)hBmp,
                    0,
                    prc->left - 1,
                    prc->top - 1,
                    prc->right - prc->left,
                    prc->bottom - prc->top,
                    DST_BITMAP );
            }
            else
            {
                HBITMAP hBmpTmp;
                UIFCOLOR col = GetBkgdCol(dwState);
                RECT rcNew = *prc;
                hBmpTmp = CreateShadowMaskBmp(&rcNew, 
                                        hBmp,  
                                        hBmpMask, 
                                        (HBRUSH)GetBrush(col),
                                        GetBrush( UIFCOLOR_CTRLIMAGESHADOW));




                if (hBmpTmp)
                {
                    CUIDrawState( hDC,
                        NULL,
                        NULL,
                        (LPARAM)hBmpTmp,
                        0,
                        rcNew.left,
                        rcNew.top,
                        rcNew.right - rcNew.left,
                        rcNew.bottom - rcNew.top,
                        DST_BITMAP );

                    DeleteObject(hBmpTmp);
                }
            }
        }
        else {
            if (!hBmpMask)
            {
                CUIDrawState( hDC,
                    NULL,
                    NULL,
                    (LPARAM)hBmp,
                    0,
                    prc->left,
                    prc->top,
                    prc->right - prc->left,
                    prc->bottom - prc->top,
                    DST_BITMAP );
            }
            else
            {
                HBITMAP hBmpTmp;
                UIFCOLOR col;

                if (dwState & UIFDCS_SELECTED)
                    // col = UIFCOLOR_CTRLIMAGESHADOW;
                    col = UIFCOLOR_MOUSEOVERBKGND;  
                else
                    col = UIFCOLOR_CTRLBKGND;

                hBmpTmp = CreateMaskBmp(prc, 
                                        hBmp,  
                                        hBmpMask, 
                                        (HBRUSH)GetBrush(col), 0, 0);
                CUIDrawState( hDC,
                    NULL,
                    NULL,
                    (LPARAM)hBmpTmp,
                    0,
                    prc->left,
                    prc->top,
                    prc->right - prc->left,
                    prc->bottom - prc->top,
                    DST_BITMAP );

                DeleteObject(hBmpTmp);
            }
        }

        if (IsRTLLayout())
        {
            DeleteObject(hBmp);
            DeleteObject(hBmpMask);
        }

    }

    /*   D R A W  M E N U  S E P A R A T O R
    /*------------------------------------------------------------------------------
    
        Paint menu separator
    
    ------------------------------------------------------------------------------*/
    virtual void DrawMenuSeparator( HDC hDC, const RECT *prc)
    {
        ::FillRect(hDC, prc, GetBrush(UIFCOLOR_CTRLBKGND));
    }

    /*   G E T  F R A M E  B K G D  C O L  */
    /*------------------------------------------------------------------------------
    
        get background color of frame control
    
    ------------------------------------------------------------------------------*/
    virtual UIFCOLOR GetFrameBkgdCol( DWORD dwState )
    {
        UIFCOLOR col = UIFCOLOR_MAX; /* invalid */

        if ((dwState & UIFDCS_DISABLED) == 0) { /* enabled */
            if ((dwState & UIFDCS_MOUSEOVERSELECTED) == UIFDCS_MOUSEOVERSELECTED) {
                col = UIFCOLOR_MOUSEDOWNBKGND;    /* frame: 100% */
            }
            else if ((dwState & UIFDCS_MOUSEDOWN) == UIFDCS_MOUSEDOWN) {
                col = UIFCOLOR_MOUSEDOWNBKGND;    /* frame: 100% */
            }
            else if ((dwState & UIFDCS_MOUSEOVER) == UIFDCS_MOUSEOVER) {
                col = UIFCOLOR_MOUSEOVERBKGND;    /* frame: 65% */
            }
            else if ((dwState & UIFDCS_SELECTED) == UIFDCS_SELECTED) {
                col = UIFCOLOR_MOUSEOVERBKGND;    /* frame: 65% */
            }
            else if ((dwState & UIFDCS_ACTIVE) == UIFDCS_ACTIVE) {
                col = UIFCOLOR_ACTIVECAPTIONBKGND;
            }
            else {
                col = UIFCOLOR_INACTIVECAPTIONBKGND;
            }
        }
        else { /* disabled */
            if ((dwState & UIFDCS_ACTIVE) == UIFDCS_ACTIVE) {
                col = UIFCOLOR_ACTIVECAPTIONBKGND;
            }
            else {
                col = UIFCOLOR_INACTIVECAPTIONBKGND;
            }
        }

        return col;
    }

    /*   D R A W  F R A M E  C T R L  B K G D   */
    /*------------------------------------------------------------------------------
    
        Paint frame control background
    
    ------------------------------------------------------------------------------*/
    virtual void DrawFrameCtrlBkgd( HDC hDC, const RECT *prc, DWORD dwFlag, DWORD dwState )
    {
        Assert( prc != NULL );
        UIFCOLOR col = GetFrameBkgdCol(dwState);

        if (col != UIFCOLOR_MAX)  {
            FillRect( hDC, prc, col );
        }
    }

    /*   D R A W  F R A M E  C T R L  E D G E   */
    /*------------------------------------------------------------------------------
    
        Paint frame control edge
    
    ------------------------------------------------------------------------------*/
    virtual void DrawFrameCtrlEdge( HDC hDC, const RECT *prc, DWORD dwFlag, DWORD dwState )
    {
        DrawCtrlEdge( hDC, prc, dwFlag, dwState );
    }

    /*   D R A W  F R A M E  C T R L  I C O N   */
    /*------------------------------------------------------------------------------
    
        Paint frame control icon
    
    ------------------------------------------------------------------------------*/
    virtual void DrawFrameCtrlIcon( HDC hDC, const RECT *prc, HICON hIcon, DWORD dwState , SIZE *psizeIcon)
    {
        HBITMAP hbmp;
        HBITMAP hbmpMask;
        if (CUIGetIconBitmaps(hIcon, &hbmp, &hbmpMask, psizeIcon))
        {
            DrawCtrlBitmap( hDC, prc, hbmp, hbmpMask, dwState );
            DeleteObject(hbmp);
            DeleteObject(hbmpMask);
        }
    }

    /*   D R A W  F R A M E  C T R L  B I T M A P   */
    /*------------------------------------------------------------------------------
    
        Paint frame control bitmap
    
    ------------------------------------------------------------------------------*/
    virtual void DrawFrameCtrlBitmap( HDC hDC, const RECT *prc, HBITMAP hBmp, HBITMAP hBmpMask, DWORD dwState )
    {
        if (!hBmpMask) {
            CUIDrawState( hDC,
                NULL,
                NULL,
                (LPARAM)hBmp,
                0,
                prc->left,
                prc->top,
                prc->right - prc->left,
                prc->bottom - prc->top,
                DST_BITMAP | ((dwState & UIFDCS_DISABLED) ? (DSS_DISABLED | DSS_MONO) : 0) );
        }
        else {
            HBITMAP hBmpTmp;
            UIFCOLOR col = GetFrameBkgdCol(dwState);

            if (dwState & UIFDCS_DISABLED) {
                hBmpTmp = CreateDisabledBitmap(prc, 
                                               hBmpMask, 
                                               (HBRUSH)GetBrush(col),
                                               GetBrush( UIFCOLOR_CTRLIMAGESHADOW ), FALSE);
            }
            else {
                HDC hDCMem;
                HDC hDCTmp;
                HDC hDCMono;
                HBITMAP hBmpMono;
                HBITMAP hBmpMemOld;
                HBITMAP hBmpTmpOld;
                HBITMAP hBmpMonoOld;
                LONG width  = prc->right - prc->left;
                LONG height = prc->bottom - prc->top;
                RECT rc;
                UIFCOLOR colText;

                SetRect( &rc, 0, 0, width, height );
                if ((dwState & UIFDCS_MOUSEOVERSELECTED) == UIFDCS_MOUSEOVERSELECTED) {
                    colText = UIFCOLOR_MOUSEDOWNTEXT;    /* frame: 100% */
                }
                else if ((dwState & UIFDCS_MOUSEDOWN) == UIFDCS_MOUSEDOWN) {
                    colText = UIFCOLOR_MOUSEDOWNTEXT;    /* frame: 100% */
                }
                else if ((dwState & UIFDCS_MOUSEOVER) == UIFDCS_MOUSEOVER) {
                    colText = UIFCOLOR_MOUSEOVERTEXT;    /* frame: 65% */
                }
                else if ((dwState & UIFDCS_SELECTED) == UIFDCS_SELECTED) {
                    colText = UIFCOLOR_MOUSEOVERTEXT;    /* frame: 65% */
                }
                else {
                    colText = UIFCOLOR_CTRLTEXT;
                }

                // create destination bitmap

                hDCTmp = CreateCompatibleDC( hDC );
                hBmpTmp = CreateCompatibleBitmap( hDC, width, height );
                hBmpTmpOld = (HBITMAP)SelectObject( hDCTmp, hBmpTmp );

                // create work DC
                
                hDCMem = CreateCompatibleDC( hDC );

                // paint background

                FillRect( hDCTmp, &rc, col );

                // step1. apply mask

                hBmpMemOld = (HBITMAP)SelectObject( hDCMem, hBmpMask );
                BitBlt( hDCTmp, 0, 0, width, height, hDCMem, 0, 0, SRCAND );

                // step2. fill color on mask

                HBRUSH hBrushOld = (HBRUSH)SelectObject( hDCTmp, GetBrush( colText ) );
                BitBlt( hDCTmp, 0, 0, width, height, hDCMem, 0, 0, 0x00BA0B09 /* DPSnao */ );
                SelectObject( hDCTmp, hBrushOld );

                // step3. create image mask

                SelectObject( hDCMem, hBmp );

                hDCMono = CreateCompatibleDC( hDC );
                hBmpMono = CreateBitmap( width, height, 1, 1, NULL );
                hBmpMonoOld = (HBITMAP)SelectObject( hDCMono, hBmpMono );

                SetBkColor( hDCMem, RGB( 0, 0, 0 ) );
                BitBlt( hDCMono, 0, 0, width, height, hDCMem, 0, 0, SRCCOPY );

                // step4. apply image mask

                SetBkColor( hDCTmp, RGB( 255, 255, 255 ) );
                SetTextColor( hDCTmp, RGB( 0, 0, 0 ) );
                BitBlt( hDCTmp, 0, 0, width, height, hDCMono, 0, 0, SRCAND );

                SelectObject( hDCMono, hBmpMonoOld );
                DeleteObject( hBmpMono );
                DeleteDC( hDCMono );

                // step5. apply image

                BitBlt( hDCTmp, 0, 0, width, height, hDCMem, 0, 0, SRCINVERT );

                // dispose work DC

                DeleteDC( hDCMem );

                // 

                SelectObject( hDCTmp, hBmpTmpOld );
                DeleteDC( hDCTmp );
            }

            CUIDrawState( hDC,
                NULL,
                NULL,
                (LPARAM)hBmpTmp,
                0,
                prc->left,
                prc->top,
                prc->right - prc->left,
                prc->bottom - prc->top,
                DST_BITMAP);

            DeleteObject(hBmpTmp);
        }
    }

    /*   D R A W  W N D  F R A M E   */
    /*------------------------------------------------------------------------------



    ------------------------------------------------------------------------------*/
    virtual void DrawWndFrame( HDC hDC, const RECT *prc, DWORD dwFlag, int cxFrame, int cyFrame )
    {
        RECT rc;
        int cxFrameOuter;
        int cyFrameOuter;
        int cxFrameInner;
        int cyFrameInner;

        switch (dwFlag) {
            default:
            case UIFDWF_THIN: {
                cxFrameOuter = cxFrame;
                cyFrameOuter = cyFrame;
                cxFrameInner = 0;
                cyFrameInner = 0;
                break;
            }

            case UIFDWF_THICK:
            case UIFDWF_ROUNDTHICK: {
                cxFrameOuter = cxFrame - 1;
                cyFrameOuter = cyFrame - 1;
                cxFrameInner = 1;
                cyFrameInner = 1;
                break;
            }
        }

        // left

        rc = *prc;
        rc.right  = rc.left + cxFrameOuter;
        FillRect( hDC, &rc, UIFCOLOR_BORDEROUTER );

        if (cxFrameInner != 0) {
            rc.left   = rc.left + cxFrameOuter;
            rc.right  = rc.left + cxFrameInner;
            rc.top    = rc.top    + cyFrameOuter;
            rc.bottom = rc.bottom - cyFrameOuter;
            FillRect( hDC, &rc, UIFCOLOR_BORDERINNER );
        }

        // right

        rc = *prc;
        rc.left = rc.right - cxFrameOuter;
        FillRect( hDC, &rc, UIFCOLOR_BORDEROUTER );

        if (cxFrameInner != 0) {
            rc.left   = rc.right - cxFrame;
            rc.right  = rc.left + cxFrameInner;
            rc.top    = rc.top    + cyFrameOuter;
            rc.bottom = rc.bottom - cyFrameOuter;
            FillRect( hDC, &rc, UIFCOLOR_BORDERINNER );
        }

        // top

        rc = *prc;
        rc.bottom = rc.top + cyFrameOuter;
        FillRect( hDC, &rc, UIFCOLOR_BORDEROUTER );

        if (cyFrameInner != 0) {
            rc.top    = rc.top + cyFrameOuter;
            rc.bottom = rc.top + cyFrameInner;
            rc.left   = rc.left  + cxFrameOuter;
            rc.right  = rc.right - cxFrameOuter;
            FillRect( hDC, &rc, UIFCOLOR_BORDERINNER );
        }

        // bottom

        rc = *prc;
        rc.top = rc.bottom - cyFrameOuter;
        FillRect( hDC, &rc, UIFCOLOR_BORDEROUTER );

        if (cyFrameInner != 0) {
            rc.top    = rc.bottom - cyFrame;
            rc.bottom = rc.top + cyFrameInner;
            rc.left   = rc.left  + cxFrameOuter;
            rc.right  = rc.right - cxFrameOuter;
            FillRect( hDC, &rc, UIFCOLOR_BORDERINNER );
        }

        // rounded corner

        if (dwFlag & UIFDWF_ROUNDTHICK) {
            rc = *prc;
            rc.left   = rc.left + cxFrameOuter;
            rc.top    = rc.top + cyFrameOuter;
            rc.right  = rc.left + 1;
            rc.bottom = rc.top + 1;
            FillRect( hDC, &rc, UIFCOLOR_BORDEROUTER );

            rc = *prc;
            rc.left   = rc.right - (cxFrameOuter + 1);
            rc.top    = rc.top + cyFrameOuter;
            rc.right  = rc.left + 1;
            rc.bottom = rc.top + 1;
            FillRect( hDC, &rc, UIFCOLOR_BORDEROUTER );
        }
    }

    /*   D R A W  D R A G  H A N D L E */
    /*------------------------------------------------------------------------------



    ------------------------------------------------------------------------------*/
    virtual void DrawDragHandle( HDC hDC, const RECT *prc, BOOL fVertical)
    {
        CSolidPen hpen;
        hpen.Init(GetColor(UIFCOLOR_DRAGHANDLE));

        HPEN hpenOld = (HPEN)SelectObject(hDC, hpen);

        if (!fVertical)
        {
            int x0, x1, y;
            y = prc->top + 2;
            x0 = prc->left + 2;
            x1 = prc->right;
            for (;y < prc->bottom - 1; y+=2)
            {
                MoveToEx(hDC, x0, y, NULL);
                LineTo(hDC, x1, y);
            }
        }
        else
        {
            int y0, y1, x;
            x = prc->left + 2;
            y0 = prc->top + 2;
            y1 = prc->bottom;
            for (;x < prc->right - 1; x+=2)
            {
                MoveToEx(hDC, x, y0, NULL);
                LineTo(hDC, x, y1);
            }
        }
        SelectObject(hDC, hpenOld);
    }

    /*   D R A W  S E P A R A T O R */
    /*------------------------------------------------------------------------------



    ------------------------------------------------------------------------------*/
    virtual void DrawSeparator( HDC hDC, const RECT *prc, BOOL fVertical)
    {
        CSolidPen hpenL;
        HPEN hpenOld = NULL;
    
        if (!hpenL.Init(GetColor(UIFCOLOR_CTRLIMAGESHADOW)))
            return;
    
        if (!fVertical)
        {
            hpenOld = (HPEN)SelectObject(hDC, (HPEN)hpenL);
            MoveToEx(hDC, prc->left + 1, prc->top + 1, NULL);
            LineTo(hDC,   prc->left + 1, prc->bottom - 1);
        }
        else
        {
            hpenOld = (HPEN)SelectObject(hDC, (HPEN)hpenL);
            MoveToEx(hDC, prc->left + 1, prc->top + 1, NULL);
            LineTo(hDC,   prc->right - 1, prc->top + 1);
        }
    
        SelectObject(hDC, hpenOld);
    }

protected:
    UIFSCHEME  m_scheme;
    OFC10COLOR *m_pcoldef;
};


/*=============================================================================*/
/*                                                                             */
/*   E X P O R T E D  F U N C T I O N S                                        */
/*                                                                             */
/*=============================================================================*/

/*   I N I T  U I F  S C H E M E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void InitUIFScheme( void )
{
    // create color tables

    v_pColTableSys = new CUIFColorTableSys();
    if (v_pColTableSys)
        v_pColTableSys->Initialize();

    v_pColTableOfc10 = new CUIFColorTableOff10();
    if (v_pColTableOfc10)
        v_pColTableOfc10->Initialize();
}


/*   D O N E  U I F  S C H E M E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void DoneUIFScheme( void )
{
    if (v_pColTableSys != NULL) {
        delete v_pColTableSys;
        v_pColTableSys = NULL;
    }

    if (v_pColTableOfc10 != NULL) {
        delete v_pColTableOfc10;
        v_pColTableOfc10 = NULL;
    }
}


/*   U P D A T E  U I F  S C H E M E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void UpdateUIFScheme( void )
{
    if (v_pColTableSys != NULL) {
        v_pColTableSys->Update();
    }

    if (v_pColTableOfc10 != NULL) {
        v_pColTableOfc10->Update();
    }
}


/*   C R E A T E  U I F  S C H E M E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFScheme *CreateUIFScheme( UIFSCHEME scheme )
{
    CUIFScheme *pScheme = NULL;

    switch (scheme) {
        default:
        case UIFSCHEME_DEFAULT: {
            pScheme = new CUIFSchemeDef( scheme );
            break;
        }

        case UIFSCHEME_OFC10MENU: {
            pScheme = new CUIFSchemeOff10( scheme );
            break;
        }

        case UIFSCHEME_OFC10TOOLBAR: {
            pScheme = new CUIFSchemeOff10( scheme );
            break;
        }

        case UIFSCHEME_OFC10WORKPANE: {
            pScheme = new CUIFSchemeOff10( scheme );
            break;
        }
    }

    Assert( pScheme != NULL );
    return pScheme;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuishadw.h ===
//
// cuishadw.h
//  = UI object library - define UIShadow class =
//

#ifndef CUISHADW_H
#define CUISHADW_H

#include "cuiobj.h"
#include "cuiwnd.h"

//
// CUIFShadow
//  = shadow window class =
//

class CUIFShadow : public CUIFWindow
{
public:
    CUIFShadow( HINSTANCE hInst, DWORD dwStyle, CUIFWindow *pWndOwner );
    virtual ~CUIFShadow( void );

    //
    // CUIFObject methods
    //
    virtual CUIFObject *Initialize( void );
    virtual DWORD GetWndStyleEx( void );
    virtual void OnCreate( HWND hWnd );
    virtual void OnPaint( HDC hDC );
    virtual void Show( BOOL fShow );
    virtual LRESULT OnSettingChange( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
    virtual LRESULT OnWindowPosChanging(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    //
    //
    //
    void OnOwnerWndMoved( BOOL fResized );
    void GetShift( SIZE *psize );

protected:
    CUIFWindow          *m_pWndOwner;
    COLORREF            m_color;
    int                 m_iGradWidth;
    int                 m_iAlpha;
    SIZE                m_sizeShift;
    BOOL                m_fGradient;

    void InitSettings( void );
    void AdjustWindowPos( void );
    void InitShadow( void );
};

#endif /* CUISHADW_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuischem.h ===
//
// cuischem.h
//

#ifndef CUISCHEM_H
#define CUISCHEM_H

#ifndef LAYOUT_RTL
#define LAYOUT_RTL                         0x00000001 // Right to left
#endif // LAYOUT_RTL

//
// UIFrame scheme
//

typedef enum _UIFSCHEME
{
    UIFSCHEME_DEFAULT,
    UIFSCHEME_OFC10MENU,
    UIFSCHEME_OFC10TOOLBAR,
    UIFSCHEME_OFC10WORKPANE,
} UIFSCHEME;


//
// UIFrame color
//

typedef enum _UIFCOLOR
{
    // base color

    UIFCOLOR_MENUBKGND,
    UIFCOLOR_MENUBARSHORT,
    UIFCOLOR_MENUBARLONG,
    UIFCOLOR_MOUSEOVERBKGND,
    UIFCOLOR_MOUSEOVERBORDER,
    UIFCOLOR_MOUSEOVERTEXT,
    UIFCOLOR_MOUSEDOWNBKGND,
    UIFCOLOR_MOUSEDOWNBORDER,
    UIFCOLOR_MOUSEDOWNTEXT,
    UIFCOLOR_CTRLBKGND,
    UIFCOLOR_CTRLTEXT,
    UIFCOLOR_CTRLTEXTDISABLED,
    UIFCOLOR_CTRLIMAGESHADOW,
    UIFCOLOR_CTRLBKGNDSELECTED,
    UIFCOLOR_BORDEROUTER,
    UIFCOLOR_BORDERINNER,
    UIFCOLOR_ACTIVECAPTIONBKGND,
    UIFCOLOR_ACTIVECAPTIONTEXT,
    UIFCOLOR_INACTIVECAPTIONBKGND,
    UIFCOLOR_INACTIVECAPTIONTEXT,
    UIFCOLOR_SPLITTERLINE,
    UIFCOLOR_DRAGHANDLE,

    // virtual color

    UIFCOLOR_WINDOW,

    UIFCOLOR_MAX,                   /* must be last */
} UIFCOLOR;


//
// DrawControl flags
//

#define UIFDCF_FLATONNORMAL                 0x00000000 /* used in default scheme */
#define UIFDCF_RAISEDONNORMAL               0x00000001 /* used in default scheme */
#define UIFDCF_SUNKENONNORMAL               0x00000002 /* used in default scheme */
#define UIFDCF_FLATONMOUSEOVER              0x00000000 /* used in default scheme */
#define UIFDCF_RAISEDONMOUSEOVER            0x00000004 /* used in default scheme */
#define UIFDCF_SUNKENONMOUSEOVER            0x00000008 /* used in default scheme */
#define UIFDCF_FLATONMOUSEDOWN              0x00000000 /* used in default scheme */
#define UIFDCF_RAISEDONMOUSEDOWN            0x00000010 /* used in default scheme */
#define UIFDCF_SUNKENONMOUSEDOWN            0x00000020 /* used in default scheme */
#define UIFDCF_FLATONSELECT                 0x00000000 /* used in default scheme */
#define UIFDCF_RAISEDONSELECT               0x00000040 /* used in default scheme */
#define UIFDCF_SUNKENONSELECT               0x00000080 /* used in default scheme */

#define UIFDCF_BUTTON                       (UIFDCF_FLATONNORMAL | UIFDCF_RAISEDONMOUSEOVER | UIFDCF_RAISEDONMOUSEDOWN | UIFDCF_RAISEDONSELECT)
#define UIFDCF_BUTTONSUNKEN                 (UIFDCF_RAISEDONNORMAL | UIFDCF_RAISEDONMOUSEOVER | UIFDCF_SUNKENONMOUSEDOWN | UIFDCF_SUNKENONSELECT)
#define UIFDCF_CAPTIONBUTTON                (UIFDCF_RAISEDONNORMAL | UIFDCF_RAISEDONMOUSEOVER | UIFDCF_SUNKENONMOUSEDOWN | UIFDCF_SUNKENONSELECT)


//
// DrawControl states
//

#define UIFDCS_NORMAL                       0x00000000
#define UIFDCS_MOUSEOVER                    0x00000001
#define UIFDCS_MOUSEDOWN                    0x00000002
#define UIFDCS_SELECTED                     0x00000010
#define UIFDCS_DISABLED                     0x00000020
#define UIFDCS_MOUSEOVERSELECTED            (UIFDCS_MOUSEOVER | UIFDCS_SELECTED)
#define UIFDCS_MOUSEDOWNSELECTED            (UIFDCS_MOUSEDOWN | UIFDCS_SELECTED)
#define UIFDCS_DISABLEDSELECTED             (UIFDCS_DISABLED  | UIFDCS_SELECTED)
#define UIFDCS_MOUSEOVERDISABLED            (UIFDCS_MOUSEOVER | UIFDCS_DISABLED)
#define UIFDCS_MOUSEOVERDISABLEDSELECTED    (UIFDCS_MOUSEOVER | UIFDCS_DISABLED | UIFDCS_SELECTED)
#define UIFDCS_ACTIVE                       0x00000040 /* used in DrawFrameCtrlXXX */
#define UIFDCS_INACTIVE                     0x00000000 /* used in DrawFrameCtrlXXX */


//
// DrawWndFrame flags
//

#define UIFDWF_THIN                         0x00000000
#define UIFDWF_THICK                        0x00000001
#define UIFDWF_ROUNDTHICK                   0x00000002


//
// CUIFScheme
//

class CUIFScheme
{
public:
    CUIFScheme() {
        m_dwLayout = 0;
    }

    //
    //
    //
    virtual UIFSCHEME GetType( void )                                                                           = 0;    /* PURE */

    // 
    // scheme color
    //
    virtual COLORREF GetColor( UIFCOLOR iCol )                                                                  = 0;    /* PURE */
    virtual HBRUSH GetBrush( UIFCOLOR iCol )                                                                    = 0;    /* PURE */

    //
    // metrics 
    //
    virtual int CyMenuItem( int cyMenuText )                                                                    = 0;    /* PURE */
    virtual int CxSizeFrame( void )                                                                             = 0;    /* PURE */
    virtual int CySizeFrame( void )                                                                             = 0;    /* PURE */
    virtual int CxWndBorder( void )                                                                             = 0;    /* PURE */
    virtual int CyWndBorder( void )                                                                             = 0;    /* PURE */

    //
    // drawing helper
    //
    virtual void FillRect( HDC hDC, const RECT *prc, UIFCOLOR iCol )                                            = 0;    /* PURE */
    virtual void FrameRect( HDC hDC, const RECT *prc, UIFCOLOR iCol )                                           = 0;    /* PURE */
    virtual void DrawSelectionRect( HDC hDC, const RECT *prc, BOOL fMouseDown )                                 = 0;    /* PURE */

    virtual void GetCtrlFaceOffset( DWORD dwFlag, DWORD dwState, SIZE *poffset )                                = 0;    /* PURE */
    virtual void DrawCtrlBkgd( HDC hDC, const RECT *prc, DWORD dwFlag, DWORD dwState )                          = 0;    /* PURE */
    virtual void DrawCtrlEdge( HDC hDC, const RECT *prc, DWORD dwFlag, DWORD dwState )                          = 0;    /* PURE */
    virtual void DrawCtrlText( HDC hDC, const RECT *prc, LPCWSTR pwch, int cwch, DWORD dwState, BOOL fVertical )                = 0;    /* PURE */
    virtual void DrawCtrlIcon( HDC hDC, const RECT *prc, HICON hIcon, DWORD dwState , SIZE *psizeIcon)          = 0;    /* PURE */
    virtual void DrawCtrlBitmap( HDC hDC, const RECT *prc, HBITMAP hBmp, HBITMAP hBmpMask, DWORD dwState )      = 0;    /* PURE */
    virtual void DrawMenuBitmap( HDC hDC, const RECT *prc, HBITMAP hBmp, HBITMAP hBmpMask, DWORD dwState )      = 0;    /* PURE */
    virtual void DrawMenuSeparator( HDC hDC, const RECT *prc)                                                   = 0;    /* PURE */
    virtual void DrawFrameCtrlBkgd( HDC hDC, const RECT *prc, DWORD dwFlag, DWORD dwState )                     = 0;    /* PURE */
    virtual void DrawFrameCtrlEdge( HDC hDC, const RECT *prc, DWORD dwFlag, DWORD dwState )                     = 0;    /* PURE */
    virtual void DrawFrameCtrlIcon( HDC hDC, const RECT *prc, HICON hIcon, DWORD dwState,  SIZE *psizeIcon)      = 0;    /* PURE */
    virtual void DrawFrameCtrlBitmap( HDC hDC, const RECT *prc, HBITMAP hBmp, HBITMAP hBmpMask, DWORD dwState ) = 0;    /* PURE */
    virtual void DrawWndFrame( HDC hDC, const RECT *prc, DWORD dwFlag, int cxFrame, int cyFrame )               = 0;    /* PURE */
    virtual void DrawDragHandle( HDC hDC, const RECT *prc, BOOL fVertical)                                      = 0;    /* PURE */
    virtual void DrawSeparator( HDC hDC, const RECT *prc, BOOL fVertical)                                       = 0;    /* PURE */

    void SetLayout(DWORD dwLayout) {
        m_dwLayout = dwLayout;
    }

    BOOL IsRTLLayout() {
        return (m_dwLayout & LAYOUT_RTL) ? TRUE : FALSE;
    }

protected:
    DWORD m_dwLayout;
};


//
// exported functions
//

extern void InitUIFScheme( void );
extern void DoneUIFScheme( void );
extern void UpdateUIFScheme( void );

extern CUIFScheme *CreateUIFScheme( UIFSCHEME scheme );

#endif /* CUISCHEM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuistr.cpp ===
//
// cuistr.cpp
//  = handling string functions in CUILIB =
//

#include "private.h"
#include "cuistr.h"


/*   C U I  S T R  C M P  W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIStrCmpW( const WCHAR* pwch1, const WCHAR* pwch2 )
{
    while (*pwch1 && *pwch2 && (*pwch1 == *pwch2)) {
        pwch1++;
        pwch2++;
    }

    return (*pwch1 - *pwch2);
}


/*   C U I  S T R  C P Y  W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
WCHAR* CUIStrCpyW( WCHAR *pwchDst, const WCHAR *pwchSrc )
{
    WCHAR *pwch = pwchDst;

    while (*pwch++ = *pwchSrc++);

    return pwchDst;
}


/*   C U I  S T R  L E N  W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIStrLenW( const WCHAR *pwch )
{
    const WCHAR *pwchFirst = pwch;

    while (*pwch++);

    return (int)(UINT_PTR)(pwch - pwchFirst - (UINT_PTR)1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuistr.h ===
//
// cuistr.h
//  = handling string functions in CUILIB =
//

#ifndef CUISTR_H
#define CUISTR_H

extern int CUIStrCmpW( const WCHAR *pwch1, const WCHAR *pwch2 );
extern WCHAR *CUIStrCpyW( WCHAR *pwchDst, const WCHAR *pwchSrc );
extern int CUIStrLenW( const WCHAR *pwch );


#define StrCmpW( pwch1, pwch2 )         CUIStrCmpW( (pwch1), (pwch2) )
#define StrCpyW( pwchDst, pwchSrc )     CUIStrCpyW( (pwchDst), (pwchSrc) )
#define StrLenW( pwch )                 CUIStrLenW( (pwch) )

#endif /* CUISTR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuishadw.cpp ===
//
// cuishadw.cpp
//

#include "private.h"
#include "cuishadw.h"
#include "cuisys.h"
#include "cuiutil.h"


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  S H A D O W                                                     */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  S H A D O W   */
/*------------------------------------------------------------------------------

    Constructor of CUIFShadow

------------------------------------------------------------------------------*/
CUIFShadow::CUIFShadow( HINSTANCE hInst, DWORD dwStyle, CUIFWindow *pWndOwner ) : CUIFWindow( hInst, dwStyle | UIWINDOW_TOOLWINDOW )
{
    m_pWndOwner    = pWndOwner;
    m_color        = RGB( 0, 0, 0 );
    m_iGradWidth   = 0;
    m_iAlpha       = 0;
    m_sizeShift.cx = 0;
    m_sizeShift.cy = 0;
    m_fGradient    = FALSE;
}


/*   ~  C  U I F  S H A D O W   */
/*------------------------------------------------------------------------------

    Destructor of CUIFShadow

------------------------------------------------------------------------------*/
CUIFShadow::~CUIFShadow( void )
{
    if (m_pWndOwner) {
        m_pWndOwner->ClearShadowWnd();
    }
}


/*   I N I T I A L I Z E   */
/*------------------------------------------------------------------------------

    Initialize UI window object
    (UIFObject method)

------------------------------------------------------------------------------*/
CUIFObject *CUIFShadow::Initialize( void )
{
    InitSettings();

    return CUIFWindow::Initialize();
}


/*   G E T  W N D  S T Y L E  E X   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
DWORD CUIFShadow::GetWndStyleEx( void )
{
    DWORD dwWndStyleEx = CUIFWindow::GetWndStyleEx();

    if (m_fGradient) {
        dwWndStyleEx |= WS_EX_LAYERED;
    }

    return dwWndStyleEx;
}


/*   O N  C R E A T E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFShadow::OnCreate( HWND hWnd )
{
    CUIFWindow::OnCreate( hWnd );
}


/*   P A I N T  O B J E C T   */
/*------------------------------------------------------------------------------

    Paint window object
    (UIFObject method)

------------------------------------------------------------------------------*/
void CUIFShadow::OnPaint( HDC hDC )
{
    HBRUSH hBrush;
    RECT   rc = GetRectRef();

    // 

    hBrush = CreateSolidBrush( m_color );
    FillRect( hDC, &rc, hBrush );
    DeleteObject( hBrush );
}


/*   O N  S E T T I N G  C H A N G E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CUIFShadow::OnSettingChange( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    InitSettings();

    if (m_fGradient) {
        DWORD dwWndStyleEx = GetWindowLong( GetWnd(), GWL_EXSTYLE );
        SetWindowLong( GetWnd(), GWL_EXSTYLE, (dwWndStyleEx | WS_EX_LAYERED) );
    }
    else {
        DWORD dwWndStyleEx = GetWindowLong( GetWnd(), GWL_EXSTYLE );
        SetWindowLong( GetWnd(), GWL_EXSTYLE, (dwWndStyleEx & ~WS_EX_LAYERED) );
    }

    AdjustWindowPos();
    InitShadow();

    return CUIFWindow::OnSettingChange( hWnd, uMsg, wParam, lParam );
}


/*   S H O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFShadow::Show( BOOL fShow )
{
    if (fShow) {
        if (IsWindow( m_hWnd ) && !IsWindowVisible( m_hWnd )) {
            AdjustWindowPos();
            InitShadow();
        }
    }

    if (IsWindow( m_hWnd )) {
        m_fVisible = fShow;
        ShowWindow( m_hWnd, fShow ? SW_SHOWNOACTIVATE : SW_HIDE );
    }
}


/*   O N  O W N E R  W N D  M O V E D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFShadow::OnOwnerWndMoved( BOOL fResized )
{
    if (IsWindow( m_hWnd ) && IsWindowVisible( m_hWnd )) {
        AdjustWindowPos();
        if (fResized) {
            InitShadow();
        }
    }
}


/*   G E T  S H I F T   */
/*-----------------------------------------------------------------------------



-----------------------------------------------------------------------------*/
void CUIFShadow::GetShift( SIZE *psize )
{
    *psize = m_sizeShift;
}


/*   O N  W I N D O W P O S C H A N G I N G
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CUIFShadow::OnWindowPosChanging(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)  
{ 
    WINDOWPOS *pwp = (WINDOWPOS *)lParam;

    pwp->hwndInsertAfter = m_pWndOwner->GetWnd();
    return DefWindowProc(hWnd, uMsg, wParam, lParam); 
}


/*   I N I T  S E T T I N G S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFShadow::InitSettings( void )
{
    m_fGradient = !UIFIsLowColor() && CUIIsUpdateLayeredWindowAvail();

    if (m_fGradient) {
        m_color        = RGB( 0, 0, 0 );
        m_iGradWidth   = 4;
        m_iAlpha       = 25;
        m_sizeShift.cx = 4;
        m_sizeShift.cy = 4;
    }
    else {
        m_color        = RGB( 128, 128, 128 );
        m_iGradWidth   = 0;
        m_iAlpha       = 0;
        m_sizeShift.cx = 2;
        m_sizeShift.cy = 2;
    }
}


/*   A D J U S T  W I N D O W  P O S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFShadow::AdjustWindowPos( void )
{
    HWND hWndOwner = m_pWndOwner->GetWnd();
    RECT rc;

    if (!IsWindow( GetWnd() )) {
        return;
    }

    GetWindowRect( hWndOwner, &rc );
    SetWindowPos( GetWnd(), 
                    hWndOwner, 
                    rc.left + m_sizeShift.cx, 
                    rc.top  + m_sizeShift.cy,
                    rc.right - rc.left,
                    rc.bottom - rc.top,
                    SWP_NOOWNERZORDER | SWP_NOACTIVATE );
}


/*   I N I T  S H A D O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFShadow::InitShadow( void )
{
    typedef struct _RGBAPLHA {
        BYTE rgbBlue;
        BYTE rgbGreen;
        BYTE rgbRed;
        BYTE rgbAlpha;
    } RGBALPHA;

    HDC         hdcScreen = NULL;
    HDC         hdcLayered = NULL;
    RECT        rcWindow;
    SIZE        size;
    BITMAPINFO  BitmapInfo;
    HBITMAP     hBitmapMem = NULL;
    HBITMAP     hBitmapOld = NULL;
    void        *pDIBits;
    int         i;
    int         j;
    int         iAlphaStep;
    POINT       ptSrc;
    POINT       ptDst;
    BLENDFUNCTION Blend;


    //

    if (!m_fGradient) {
        return;
    }

    // The extended window style, WS_EX_LAYERED, that has been set in CreateWindowEx 
    // will be cleared on Access (why?).  reset it again

    SetWindowLong( GetWnd(), GWL_EXSTYLE, (GetWindowLong( GetWnd(), GWL_EXSTYLE ) | WS_EX_LAYERED) );

    //

    Assert( CUIIsUpdateLayeredWindowAvail() );
    Assert( m_iGradWidth != 0 );
    iAlphaStep = ((255 * m_iAlpha / 100) / m_iGradWidth);

    //

    GetWindowRect( GetWnd(), &rcWindow );
    size.cx = rcWindow.right - rcWindow.left;
    size.cy = rcWindow.bottom - rcWindow.top;

    hdcScreen = GetDC( NULL );
    if (hdcScreen == NULL) {
        return;
    }

    hdcLayered = CreateCompatibleDC( hdcScreen );
    if (hdcLayered == NULL) {
        ReleaseDC( NULL, hdcScreen );
        return;
    }

    // create bitmap

    BitmapInfo.bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    BitmapInfo.bmiHeader.biWidth         = size.cx;
    BitmapInfo.bmiHeader.biHeight        = size.cy;
    BitmapInfo.bmiHeader.biPlanes        = 1;
    BitmapInfo.bmiHeader.biBitCount      = 32;
    BitmapInfo.bmiHeader.biCompression   = BI_RGB;
    BitmapInfo.bmiHeader.biSizeImage     = 0;
    BitmapInfo.bmiHeader.biXPelsPerMeter = 100;
    BitmapInfo.bmiHeader.biYPelsPerMeter = 100;
    BitmapInfo.bmiHeader.biClrUsed       = 0;
    BitmapInfo.bmiHeader.biClrImportant  = 0;

    hBitmapMem = CreateDIBSection( hdcScreen, &BitmapInfo, DIB_RGB_COLORS, &pDIBits, NULL, 0 );
    if (pDIBits == NULL) {
        ReleaseDC( NULL, hdcScreen );
        DeleteDC( hdcLayered );
        return;
    }

    MemSet( pDIBits, 0, ((((32 * size.cx) + 31) & ~31) / 8) * size.cy );

    // face 

    for (i = 0; i < size.cy; i++) {
        RGBALPHA *ppxl = (RGBALPHA *)pDIBits + i * size.cx;
        BYTE bAlpha = iAlphaStep * m_iGradWidth;

        for (j = 0; j < size.cx; j++) {
            ppxl->rgbAlpha = bAlpha;
            ppxl++;
        }
    }

    // edges

    for (i = 0; i < m_iGradWidth; i++) {
        RGBALPHA *ppxl;
        BYTE bAlpha = iAlphaStep * (i + 1);

        // top

        if (i <= (size.cy + 1)/2) {
            for (j = m_iGradWidth; j < size.cx - m_iGradWidth; j++) {
                ppxl = (RGBALPHA *)pDIBits + (size.cy - 1 - i) * size.cx + j;
                ppxl->rgbAlpha = bAlpha;
            }
        }

        // bottom

        if (i <= (size.cy + 1)/2) {
            for (j = m_iGradWidth; j < size.cx - m_iGradWidth; j++) {
                ppxl = (RGBALPHA *)pDIBits + i * size.cx + j;
                ppxl->rgbAlpha = bAlpha;
            }
        }

        // left

        if (i <= (size.cx + 1)/2) {
            for (j = m_iGradWidth; j < size.cy - m_iGradWidth; j++) {
                ppxl = (RGBALPHA *)pDIBits + j * size.cx + i;
                ppxl->rgbAlpha = bAlpha;
            }
        }

        // right

        if (i <= (size.cx + 1)/2) {
            for (j = m_iGradWidth; j < size.cy - m_iGradWidth; j++) {
                ppxl = (RGBALPHA *)pDIBits + j * size.cx + (size.cx - 1 - i);
                ppxl->rgbAlpha = bAlpha;
            }
        }
    }

    // corners

    for (i = 0; i < m_iGradWidth; i++) {
        RGBALPHA *ppxl;
        BYTE bAlpha;

        for (j = 0; j < m_iGradWidth; j++) {
            bAlpha = iAlphaStep * (i + 1) * (j + 1) / (m_iGradWidth + 1);

            // top-left

            if ((i <= (size.cy + 1)/2) && (j <= (size.cx + 1)/2)) {
                ppxl = (RGBALPHA *)pDIBits + (size.cy - 1 - i) * size.cx + j;
                ppxl->rgbAlpha = bAlpha;
            }

            // top-right

            if ((i <= (size.cy + 1)/2) && (j <= (size.cx + 1)/2)) {
                ppxl = (RGBALPHA *)pDIBits + (size.cy - 1 - i) * size.cx + (size.cx - 1 - j);
                ppxl->rgbAlpha = bAlpha;
            }

            // bottom-left

            if ((i <= (size.cy + 1)/2) && (j <= (size.cx + 1)/2)) {
                ppxl = (RGBALPHA *)pDIBits + i * size.cx + j;
                ppxl->rgbAlpha = bAlpha;
            }

            // bottom-right

            if ((i <= (size.cy + 1)/2) && (j <= (size.cx + 1)/2)) {
                ppxl = (RGBALPHA *)pDIBits + i * size.cx + (size.cx - 1 - j);
                ppxl->rgbAlpha = bAlpha;
            }
        }
    }

    //

    ptSrc.x = 0;
    ptSrc.y = 0;
    ptDst.x = rcWindow.left;
    ptDst.y = rcWindow.top;
    Blend.BlendOp             = AC_SRC_OVER;
    Blend.BlendFlags          = 0;
    Blend.SourceConstantAlpha = 255;
    Blend.AlphaFormat         = AC_SRC_ALPHA;

    hBitmapOld = (HBITMAP)SelectObject( hdcLayered, hBitmapMem );

    CUIUpdateLayeredWindow( GetWnd(), hdcScreen, NULL, &size, hdcLayered, &ptSrc, 0, &Blend, ULW_ALPHA );

    SelectObject( hdcLayered, hBitmapOld );

    // done

    ReleaseDC( NULL, hdcScreen );
    DeleteDC( hdcLayered );
    DeleteObject( hBitmapMem );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuisys.cpp ===
//
// cuischem.cpp
//  = UIF scheme implementation = 
//

#include "private.h"
#include "cuisys.h"


//
// gloval variables
//

static class CUIFSystemInfo *vpSysInfo = NULL;


//
// misc def
//

#define COLOR_WHITE RGB( 0xFF, 0xFF, 0xFF )
#define COLOR_BLACK RGB( 0x00, 0x00, 0x00 )


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  S Y S T E M  M E T R I C                                        */
/*                                                                             */
/*=============================================================================*/

//
// CUIFSystemInfo
//  = system info =
//

class CUIFSystemInfo
{
public:
    CUIFSystemInfo( void )
    {
        m_OSVerInfo.dwMajorVersion = 4;
        m_OSVerInfo.dwMinorVersion = 0;
        m_OSVerInfo.dwBuildNumber  = 0;
        m_OSVerInfo.dwPlatformId   = VER_PLATFORM_WIN32_WINDOWS;
        
        m_cBitsPixelScreen   = 8;
        m_fHighContrast      = FALSE;
        m_fHighContrastMenus = FALSE;
    }

    ~CUIFSystemInfo( void )
    {
    }

    void Initialize( void )
    {
        GetOSVersion();
        GetSystemMetrics();
    }

    void Update( void )
    {
        GetSystemMetrics();
    }

    __inline DWORD GetOSPlatformId( void )
    {
        return m_OSVerInfo.dwPlatformId;
    }

    __inline DWORD GetOSMajorVersion( void )
    {
        return m_OSVerInfo.dwMajorVersion;
    }

    __inline DWORD GetOSMinorVersion( void )
    {
        return m_OSVerInfo.dwMinorVersion;
    }
    
    __inline int GetBitsPixelScreen( void )
    {
        return m_cBitsPixelScreen;
    }

    __inline BOOL FHighContrast( void )
    {
        return m_fHighContrast;
    }

    __inline BOOL FHighContrastMenus( void )
    {
        return m_fHighContrastMenus;
    }

protected:
    OSVERSIONINFO m_OSVerInfo;
    int  m_cBitsPixelScreen;
    BOOL m_fHighContrast;
    BOOL m_fHighContrastMenus;

    void GetOSVersion( void )
    {
        m_OSVerInfo.dwOSVersionInfoSize = sizeof(m_OSVerInfo);
        GetVersionEx( &m_OSVerInfo );
    }

    void GetSystemMetrics( void )
    {
        HDC hDC = GetDC( NULL );
        COLORREF crBtnText;
        COLORREF crBtnFace;
        HIGHCONTRAST hicntr;
    
        // device caps
    
        m_cBitsPixelScreen = GetDeviceCaps( hDC, BITSPIXEL );
    
        // system paramater info
    
        MemSet( &hicntr, 0, sizeof(HIGHCONTRAST) );
        hicntr.cbSize = sizeof(HIGHCONTRAST);
        SystemParametersInfo( SPI_GETHIGHCONTRAST, sizeof(HIGHCONTRAST), &hicntr, 0 );
    
        m_fHighContrast = ((hicntr.dwFlags & HCF_HIGHCONTRASTON) != 0);
    
        // misc
    
        crBtnText = GetSysColor( COLOR_BTNTEXT );
        crBtnFace = GetSysColor( COLOR_BTNFACE );
    
        m_fHighContrastMenus = (m_fHighContrast ||
                                    ((crBtnText == COLOR_BLACK) && (crBtnFace == COLOR_WHITE)) ||
                                    ((crBtnText == COLOR_WHITE) && (crBtnFace == COLOR_BLACK)));
    
        // finished
    
        ReleaseDC( NULL, hDC );
    }
};


/*=============================================================================*/
/*                                                                             */
/*   E X P O R T E D  F U N C T I O N S                                        */
/*                                                                             */
/*=============================================================================*/

/*   I N I T  U I F  S Y S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void InitUIFSys( void )
{
    if (vpSysInfo = new CUIFSystemInfo())
        vpSysInfo->Initialize();
}


/*   D O N E  U I F  S Y S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void DoneUIFSys( void )
{
    if (vpSysInfo != NULL) {
        delete vpSysInfo;
        vpSysInfo = NULL;
    }
}


/*   U P D A T E  U I F  S Y S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void UpdateUIFSys( void )
{
    if (vpSysInfo != NULL) {
        vpSysInfo->Update();
    }
}


/*   U I F  I S  W I N D O W S  N  T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL UIFIsWindowsNT( void )
{
    if (vpSysInfo != NULL) {
        return (vpSysInfo->GetOSPlatformId() == VER_PLATFORM_WIN32_NT);
    }
    else {
        return FALSE;
    }
}


/*   U I F  I S  L O W  C O L O R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL UIFIsLowColor( void )
{
    if (vpSysInfo != NULL) {
        return (vpSysInfo->GetBitsPixelScreen() <= 8);
    }
    else {
        return TRUE;
    }
}


/*   U I F  I S  H I G H  C O N T R A S T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL UIFIsHighContrast( void )
{
    if (vpSysInfo != NULL) {
        return vpSysInfo->FHighContrastMenus();  // use FHighContrastMenus, not FHighContrast
    }
    else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuisys.h ===
//
// cuisys.h
//

#ifndef CUISYS_H
#define CUISYS_H

//
// exported functions
//

extern void InitUIFSys( void );
extern void DoneUIFSys( void );
extern void UpdateUIFSys( void );

extern BOOL UIFIsWindowsNT( void );
extern BOOL UIFIsLowColor( void );
extern BOOL UIFIsHighContrast( void );

#endif /* CUISYS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuitb.cpp ===
//
// cuitb.cpp
//

#include "private.h"
#include "cuitb.h"
#include "cuiwnd.h"
#include "cuischem.h"
#include "cmydc.h"

HBRUSH CreateDitherBrush( void );

#if 0
void DrawDownTri(HDC hDC, RECT *prc)
{
    static HBITMAP hbmpTri = NULL;
    HBITMAP hbmpOld;
    HDC hdcMem = CreateCompatibleDC(hDC);

    if (!hdcMem)
        return;

    if (!hbmpTri)
    {
        HPEN hpen;
        HPEN hpenOld;
        const static RECT rcBmp = {0, 0, 6, 3};

        hpen = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_BTNTEXT));
        hbmpTri = CreateCompatibleBitmap(hDC, 5, 3);
        hbmpOld = (HBITMAP)SelectObject(hdcMem, hbmpTri);

        FillRect( hdcMem, &rcBmp, (HBRUSH)(COLOR_3DFACE + 1) );
 
        hpenOld = (HPEN)SelectObject(hdcMem, hpen);

        MoveToEx(hdcMem, 0, 0, NULL);
        LineTo(hdcMem,   5, 0);
        MoveToEx(hdcMem, 1, 1, NULL);
        LineTo(hdcMem,   4, 1);
        MoveToEx(hdcMem, 2, 2, NULL);
        LineTo(hdcMem,   3, 2);
   
        SelectObject(hdcMem, hpenOld);

        DeleteObject(hpen);
    }
    else
        hbmpOld = (HBITMAP)SelectObject(hdcMem, hbmpTri);


    BitBlt(hDC, 
           prc->left + ((prc->right - prc->left) / 2) - 3,
           prc->top + ((prc->bottom - prc->top) / 2) - 1,
           5, 3,
           hdcMem,
           0, 0, SRCCOPY);

    SelectObject(hdcMem, hbmpOld);
    DeleteDC(hdcMem);
}
#endif

/*=============================================================================*/
/*                                                                             */
/*   C  U I  B U T T O N                                                       */
/*                                                                             */
/*=============================================================================*/

/*------------------------------------------------------------------------------

   ctor

------------------------------------------------------------------------------*/
CUIFToolbarButtonElement::CUIFToolbarButtonElement( CUIFToolbarButton *pParent, DWORD dwID, RECT *prc, DWORD dwStyle) : CUIFButton2( pParent, dwID, prc, dwStyle )
{
    _pTBButton = pParent;
}

/*------------------------------------------------------------------------------

   dtor

------------------------------------------------------------------------------*/
CUIFToolbarButtonElement::~CUIFToolbarButtonElement( void )
{
    Assert(!m_pUIWnd);
}

/*------------------------------------------------------------------------------

   OnLButtonUp

------------------------------------------------------------------------------*/
void CUIFToolbarButtonElement::OnLButtonUp( POINT pt ) 
{
    CUIFButton2::OnLButtonUp(pt);

    if (_pTBButton->IsMenuOnly())
       _pTBButton->OnShowMenu();
    else
       _pTBButton->OnLeftClick();

}

/*------------------------------------------------------------------------------

   OnRbuttonUp

------------------------------------------------------------------------------*/
void CUIFToolbarButtonElement::OnRButtonUp( POINT pt ) 
{
    if (!_pTBButton->IsMenuOnly())
       _pTBButton->OnRightClick();

    CUIFButton2::OnRButtonUp(pt);
}

/*------------------------------------------------------------------------------

   OnSetCursor

------------------------------------------------------------------------------*/
BOOL CUIFToolbarButtonElement::OnSetCursor( UINT uMsg, POINT pt )
{
    _pTBButton->OnSetCursor(uMsg, pt);
    return FALSE;
}

/*------------------------------------------------------------------------------

   OnSetCursor

------------------------------------------------------------------------------*/
LPCWSTR CUIFToolbarButtonElement::GetToolTip( void )
{
    if (_pTBButton)
       return _pTBButton->GetToolTip();

    return NULL;
}

/*=============================================================================*/
/*                                                                             */
/*   C  U I  B U T T O N                                                       */
/*                                                                             */
/*=============================================================================*/

/*------------------------------------------------------------------------------

   ctor

------------------------------------------------------------------------------*/
CUIFToolbarMenuButton::CUIFToolbarMenuButton( CUIFToolbarButton *pParent, DWORD dwID, RECT *prc, DWORD dwStyle) : CUIFButton2( pParent, dwID, prc, dwStyle )
{
    _pTBButton = pParent;
    HFONT hfont = CreateFont(8, 8, 0, 0, 400, FALSE, FALSE, FALSE, SYMBOL_CHARSET, 0, 0, 0, 0, "Marlett");

    SetFont(hfont);
    SetText(L"u");
}

/*------------------------------------------------------------------------------

   dtor

------------------------------------------------------------------------------*/
CUIFToolbarMenuButton::~CUIFToolbarMenuButton( void )
{
    HFONT hfontOld = GetFont();
    DeleteObject(hfontOld);
    SetFont((HFONT)NULL);
}

#if 0
/*------------------------------------------------------------------------------

   OnPaint

------------------------------------------------------------------------------*/
void CUIFToolbarMenuButton::OnPaint( HDC hDC )
{
    BOOL fDownFace;

    // erase face at first

    FillRect( hDC, &GetRectRef(), (HBRUSH)(COLOR_3DFACE + 1) );
#ifndef UNDER_CE
    if (m_fToggled && (m_dwStatus == UIBUTTON_NORMAL || m_dwStatus == UIBUTTON_DOWNOUT)) {
        RECT rc;
        HBRUSH hBrush = CreateDitherBrush();
        COLORREF colTextOld = SetTextColor( hDC, GetSysColor(COLOR_3DFACE) );
        COLORREF colBackOld = SetBkColor( hDC, GetSysColor(COLOR_3DHILIGHT) );

        rc = GetRectRef();
        InflateRect( &rc, -2, -2 );
        FillRect( hDC, &rc, hBrush );

        SetTextColor( hDC, colTextOld );
        SetBkColor( hDC, colBackOld );
        DeleteObject( hBrush );
    }
#endif /* !UNDER_CE */

    // draw face

    fDownFace = m_fToggled || (m_dwStatus == UIBUTTON_DOWN);


    RECT rcDnArrow;

    int nDownPad = fDownFace ? 1 : 0;
    rcDnArrow = GetRectRef();
    OffsetRect(&rcDnArrow, nDownPad, nDownPad);
    DrawDownTri(hDC, &rcDnArrow);


    // draw button edge
    if (m_fToggled) {
      DrawEdgeProc( hDC, &GetRectRef(), TRUE );
    } else {
        switch (m_dwStatus) {
            case UIBUTTON_DOWN: {
                DrawEdgeProc( hDC, &GetRectRef(), TRUE );
                break;
            }

            case UIBUTTON_HOVER:
            case UIBUTTON_DOWNOUT: {
                DrawEdgeProc( hDC, &GetRectRef(), FALSE );
                break;
            }
        }
    }
}
#endif

/*------------------------------------------------------------------------------

   OnPaint

------------------------------------------------------------------------------*/
void CUIFToolbarMenuButton::OnLButtonUp( POINT pt ) 
{
    CUIFButton2::OnLButtonUp(pt);
    _pTBButton->OnShowMenu();
}

/*------------------------------------------------------------------------------

   OnPaint

------------------------------------------------------------------------------*/
BOOL CUIFToolbarMenuButton::OnSetCursor( UINT uMsg, POINT pt )
{
    _pTBButton->OnSetCursor(uMsg, pt);
    return FALSE;
}

/*=============================================================================*/
/*                                                                             */
/*   C  U I  B U T T O N                                                       */
/*                                                                             */
/*=============================================================================*/

/*------------------------------------------------------------------------------

   ctor

------------------------------------------------------------------------------*/
CUIFToolbarButton::CUIFToolbarButton( CUIFObject *pParent, DWORD dwID, RECT *prc, DWORD dwStyle, DWORD dwSBtnStyle, DWORD dwSBtnShowType) : CUIFObject( pParent, dwID, prc, dwStyle )
{
    m_dwSBtnStyle = dwSBtnStyle;
    m_dwSBtnShowType = dwSBtnShowType;

}

BOOL CUIFToolbarButton::Init()
{
    RECT rc;
    RECT rcMenuBtn;

    rcMenuBtn = 
    rc = GetRectRef();

    if (IsMenuButton())
    {
        rc.right -= 12;
        rcMenuBtn.left = rc.right + 1;
    }

    _pBtn = new CUIFToolbarButtonElement(this,  GetID(),  &rc, 
                                UIBUTTON_FITIMAGE | 
                                UIBUTTON_VCENTER | 
                                UIBUTTON_CENTER | 
                                (IsToggle() ? UIBUTTON_TOGGLE : 0) |
                                (IsVertical() ? UIBUTTON_VERTICAL : 0));

    if (!_pBtn)
         return FALSE;

    _pBtn->Initialize();
    AddUIObj( _pBtn );

    if (!IsEnabled())
        _pBtn->Enable(FALSE);


    if (IsMenuButton())
    {
        _pMenuBtn = new CUIFToolbarMenuButton(this, 
                                              0, 
                                              &rcMenuBtn, 
                                              UIBUTTON_VCENTER | 
                                              UIBUTTON_CENTER |
                                              (IsVertical() ? UIBUTTON_VERTICAL : 0));
        if (!_pMenuBtn)
            return FALSE;

        _pMenuBtn->Initialize();
        AddUIObj( _pMenuBtn );

        if (!IsEnabled())
            _pMenuBtn->Enable(FALSE);


    }

    return TRUE;
}

/*------------------------------------------------------------------------------

   dtor

------------------------------------------------------------------------------*/
CUIFToolbarButton::~CUIFToolbarButton( void )
{
}

/*------------------------------------------------------------------------------

   SetShowType

------------------------------------------------------------------------------*/

void CUIFToolbarButton::SetShowType(DWORD dwSBtnShowType)
{
    m_dwSBtnShowType = dwSBtnShowType;
}


/*------------------------------------------------------------------------------

   SetRect

------------------------------------------------------------------------------*/

void CUIFToolbarButton::SetRect( const RECT *prc )
{

    RECT rc;
    RECT rcMenuBtn;

    CUIFObject::SetRect(prc);

    rcMenuBtn = 
    rc = GetRectRef();

    if (IsMenuButton())
    {
        rc.right -= 12;
        rcMenuBtn.left = rc.right + 1;
    }

    if (_pBtn)
    {
        _pBtn->SetRect(&rc);
    }

    if (_pMenuBtn)
    {
        _pMenuBtn->SetRect(&rcMenuBtn);
    }
   

}

void CUIFToolbarButton::Enable( BOOL fEnable )
{
    CUIFObject::Enable(fEnable);
    if (_pBtn)
        _pBtn->Enable(fEnable);

    if (_pMenuBtn)
        _pMenuBtn->Enable(fEnable);

}

void CUIFToolbarButton::SetIcon( HICON hIcon )
{
    Assert(PtrToInt(_pBtn));
    _pBtn->SetIcon(hIcon);
}

HICON CUIFToolbarButton::GetIcon( )
{
    Assert(PtrToInt(_pBtn));
    return _pBtn->GetIcon();
}

void CUIFToolbarButton::SetBitmap( HBITMAP hBmp )
{
    Assert(PtrToInt(_pBtn));
    _pBtn->SetBitmap(hBmp);
}

HBITMAP CUIFToolbarButton::GetBitmap( )
{
    Assert(PtrToInt(_pBtn));
    return _pBtn->GetBitmap();
}

void CUIFToolbarButton::SetBitmapMask( HBITMAP hBmp )
{
    Assert(PtrToInt(_pBtn));
    _pBtn->SetBitmapMask(hBmp);
}

HBITMAP CUIFToolbarButton::GetBitmapMask( )
{
    Assert(PtrToInt(_pBtn));
    return _pBtn->GetBitmapMask();
}

void CUIFToolbarButton::SetText( WCHAR *psz)
{
    Assert(PtrToInt(_pBtn));
    _pBtn->SetText(psz);
}

void CUIFToolbarButton::SetFont( HFONT hFont)
{
    Assert(PtrToInt(_pBtn));
    _pBtn->SetFont(hFont);
}

void CUIFToolbarButton::SetToolTip( LPCWSTR pwchToolTip )
{
    CUIFObject::SetToolTip(pwchToolTip);

    if (_pBtn)
        _pBtn->SetToolTip(pwchToolTip);

    if (_pMenuBtn)
        _pMenuBtn->SetToolTip(pwchToolTip);
}

LPCWSTR CUIFToolbarButton::GetToolTip( void ) 
{
    return CUIFObject::GetToolTip();
}

BOOL CUIFToolbarButton::IsMenuOnly() 
{
     return ((m_dwSBtnStyle & (UITBBUTTON_BUTTON | UITBBUTTON_MENU)) == UITBBUTTON_MENU);
}

BOOL CUIFToolbarButton::IsMenuButton() 
{
     return ((m_dwSBtnStyle & (UITBBUTTON_BUTTON | UITBBUTTON_MENU)) == (UITBBUTTON_BUTTON | UITBBUTTON_MENU));
}

BOOL CUIFToolbarButton::IsButtonOnly() 
{
     return ((m_dwSBtnStyle & (UITBBUTTON_BUTTON | UITBBUTTON_MENU)) == (UITBBUTTON_BUTTON));
}

BOOL CUIFToolbarButton::IsToggle() 
{
     return (m_dwSBtnStyle & UITBBUTTON_TOGGLE) ? TRUE : FALSE;
}

BOOL CUIFToolbarButton::IsVertical() 
{
     return (m_dwSBtnStyle & UITBBUTTON_VERTICAL) ? TRUE : FALSE;
}

void CUIFToolbarButton::DetachWndObj( void )
{
    if (_pBtn)
        _pBtn->DetachWndObj();

    if (_pMenuBtn)
        _pMenuBtn->DetachWndObj();

#ifdef DEBUG
    if (m_pUIWnd && m_pUIWnd->GetCaptureObject())
    {
       Assert(m_pUIWnd->GetCaptureObject() != _pBtn);
       Assert(m_pUIWnd->GetCaptureObject() != _pMenuBtn);
       Assert(m_pUIWnd->GetCaptureObject() != this);
    }
#endif

    CUIFObject::DetachWndObj();
}


//////////////////////////////////////////////////////////////////////////////
//
// CUIFSeparator
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// OnPaint
//
//----------------------------------------------------------------------------

BOOL CUIFSeparator::OnPaintTheme(HDC hDC)
{
    BOOL fRet = FALSE;
    int    iStateID;

    iStateID = TS_NORMAL;

    if (FAILED(EnsureThemeData( GetUIWnd()->GetWnd())))
        goto Exit;

    if (FAILED(DrawThemeBackground(hDC, iStateID, &GetRectRef(), 0 )))
        goto Exit;


    fRet = TRUE;
Exit:
    return fRet;
}

//+---------------------------------------------------------------------------
//
// OnPaintNoTheme
//
//----------------------------------------------------------------------------

void CUIFSeparator::OnPaintNoTheme(HDC hDC)
{
    CUIFWindow *pWnd = GetUIWnd();
    CUIFScheme *pUIFScheme = pWnd->GetUIFScheme();
    if (pUIFScheme) {
        pUIFScheme->DrawSeparator(hDC, &GetRectRef(), IsVertical());
        return;
    }

    CSolidPen hpenL;
    CSolidPen hpenS;
    HPEN hpenOld = NULL;

    if (!hpenL.Init(GetSysColor(COLOR_3DHILIGHT)))
        return;

    if (!hpenS.Init(GetSysColor(COLOR_3DSHADOW)))
        return;

    
    if (!IsVertical())
    {
        hpenOld = (HPEN)SelectObject(hDC, (HPEN)hpenS);
        MoveToEx(hDC, GetRectRef().left + 1, GetRectRef().top, NULL);
        LineTo(hDC,   GetRectRef().left + 1, GetRectRef().bottom);

        SelectObject(hDC, (HPEN)hpenL);
        MoveToEx(hDC, GetRectRef().left + 2, GetRectRef().top, NULL);
        LineTo(hDC,   GetRectRef().left + 2, GetRectRef().bottom);
    }
    else
    {
        hpenOld = (HPEN)SelectObject(hDC, (HPEN)hpenS);
        MoveToEx(hDC, GetRectRef().left , GetRectRef().top + 1, NULL);
        LineTo(hDC,   GetRectRef().right, GetRectRef().top + 1);

        SelectObject(hDC, (HPEN)hpenL);
        MoveToEx(hDC, GetRectRef().left , GetRectRef().top + 2, NULL);
        LineTo(hDC,   GetRectRef().right, GetRectRef().top + 2);
    }

    SelectObject(hDC, hpenOld);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuitb.h ===
//
// cuitb.h
//  UI object library - define UI objects
//
//      CUIFObject
//        +- CUIFBorder                 border object
//        +- CUIFStatic                 static object
//        +- CUIFButton                 button object
//        |    +- CUIFScrollButton      scrollbar button object (used in CUIFScroll)
//        +- CUIFScrollButton               scrollbar thumb object (used in CUIFScroll)
//        +- CUIFScroll                 scrollbar object
//        +- CUIFList                   listbox object
//        +- CUIFWindow                 window frame object (need to be at top of parent)
//


#ifndef CUITB_H
#define CUITB_H

#include "cuiobj.h"
#include "cuiwnd.h"


//-----------------------------------------------------------------------------
//
// CUIFToolbarButtonElement
//
//-----------------------------------------------------------------------------

class CUIFToolbarButton;
class CUIFToolbarButtonElement : public CUIFButton2
{
public:
    CUIFToolbarButtonElement( CUIFToolbarButton *pParent, DWORD dwID, RECT *prc, DWORD dwStyle);
    virtual ~CUIFToolbarButtonElement( void );

    // virtual void OnPaint(HDC hDC);
    virtual void OnLButtonUp( POINT pt );
    virtual void OnRButtonUp( POINT pt );
    virtual BOOL OnSetCursor( UINT uMsg, POINT pt );

    virtual LPCWSTR GetToolTip( void );
    
protected:
    CUIFToolbarButton *_pTBButton;
};

//-----------------------------------------------------------------------------
//
// CUIFToolbarMenuButton
//
//-----------------------------------------------------------------------------

class CUIFToolbarButton;
class CUIFToolbarMenuButton : public CUIFButton2
{
public:
    CUIFToolbarMenuButton( CUIFToolbarButton *pParent, DWORD dwID, RECT *prc, DWORD dwStyle);
    virtual ~CUIFToolbarMenuButton( void );

    // virtual void OnPaint(HDC hDC);
    virtual void OnLButtonUp( POINT pt );
    virtual BOOL OnSetCursor( UINT uMsg, POINT pt );

protected:
    CUIFToolbarButton *_pTBButton;
};

// 
// CUIFToolbarButton
//-----------------------------------------------------------------------------

// UIToolbarButton show type
#define UITBBUTTON_BUTTON        0x00010000
#define UITBBUTTON_MENU          0x00020000
#define UITBBUTTON_TOGGLE        0x00040000
#define UITBBUTTON_VERTICAL      0x00080000

// UIToolbarButton show type
#define UITBBUTTON_TEXT          0x0001

//
// CUIFToolbarButton
//

class CUIFToolbarButton : public CUIFObject
{
public:
    CUIFToolbarButton( CUIFObject *pParent, DWORD dwID, RECT *prc, DWORD dwStyle , DWORD dwSBtnStyle, DWORD dwSBtnShowType);
    virtual ~CUIFToolbarButton( void );

    BOOL Init();

    void SetShowType(DWORD dwSBtnShowType);

    virtual void SetRect( const RECT *prc );
    virtual void OnRightClick() {}
    virtual void OnLeftClick()  {}
    virtual void OnShowMenu()   {}

    virtual void Enable( BOOL fEnable );
    void SetIcon( HICON hIcon );
    HICON GetIcon( );
    void SetBitmap( HBITMAP hBmp );
    HBITMAP GetBitmap( );
    void SetBitmapMask( HBITMAP hBmp );
    HBITMAP GetBitmapMask( );
    void SetText( WCHAR *psz);
    void SetToolTip( LPCWSTR pwchToolTip );
    void SetFont(HFONT hfont);
    virtual LPCWSTR GetToolTip( void );
    BOOL IsMenuOnly();
    BOOL IsMenuButton();
    BOOL IsButtonOnly();
    BOOL IsToggle();
    BOOL IsVertical();
    void DetachWndObj( void );

    const WCHAR *GetText()
    {
        Assert(PtrToInt(_pBtn));
        return _pBtn->GetText();
    }

    virtual void SetActiveTheme(LPCWSTR pszClassList, int iPartID = 0, int iStateID = 0)
    { 
        if (_pBtn)
            _pBtn->SetActiveTheme(pszClassList, iPartID, iStateID);
        if (_pMenuBtn)
           _pMenuBtn->SetActiveTheme(pszClassList, iPartID, iStateID);
        CUIFObject::SetActiveTheme(pszClassList, iPartID, iStateID);
    }

    virtual void ClearWndObj()
    { 
        if (_pBtn)
            _pBtn->ClearWndObj();
        if (_pMenuBtn)
           _pMenuBtn->ClearWndObj();
        CUIFObject::ClearWndObj();
    }

    CUIFToolbarButtonElement *_pBtn;
    CUIFToolbarMenuButton *_pMenuBtn;
    DWORD m_dwSBtnStyle;
    DWORD m_dwSBtnShowType;
};



//
//
//-----------------------------------------------------------------------------

// UIFSeparator style

#define UITBSEPARATOR_VERTICAL  0x00000001

class CUIFSeparator : public CUIFObject
{
public:
    CUIFSeparator( CUIFObject *pParent, DWORD dwId, RECT *prc, DWORD dwStyle) : CUIFObject( pParent, dwId, prc, dwStyle )
    {
        if (IsVertical())
            SetActiveTheme(L"TOOLBAR", TP_SEPARATORVERT);
        else
            SetActiveTheme(L"TOOLBAR", TP_SEPARATOR);
    }
    virtual ~CUIFSeparator() 
    {
    }

protected:
    virtual BOOL OnPaintTheme( HDC hDC );
    virtual void OnPaintNoTheme( HDC hDC );

private:
    BOOL IsVertical() {return (GetStyle() & UITBSEPARATOR_VERTICAL) ? TRUE : FALSE;}
};

#endif /* CUITB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuitip.h ===
//
// cuitip.h
//  = UI object library - define UIToolTip class =
//

#ifndef CUITIP_H
#define CUITIP_H

#include "cuiobj.h"
#include "cuiwnd.h"

//
// CUIFToolTip
//  = UI tooltip window class =
//

class CUIFToolTip : public CUIFWindow
{
public:
    CUIFToolTip( HINSTANCE hInst, DWORD dwStyle, CUIFWindow *pWndOwner );
    virtual ~CUIFToolTip( void );

    //
    // CUIFObject methods
    //
    virtual CUIFObject *Initialize( void );
    virtual void OnPaint( HDC hDC );
    virtual void OnTimer( UINT uiTimerID );
    virtual void Enable( BOOL fEnable );

    //
    //
    //
    // LRESULT AddTool( CUIFObject *pUIObj );
    // LRESULT DelTool( CUIFObject *pUIObj );
    LRESULT GetDelayTime( DWORD dwDuration );
    LRESULT GetMargin( RECT *prc );
    LRESULT GetMaxTipWidth( void );
    LRESULT GetTipBkColor( void );
    LRESULT GetTipTextColor( void );
    LRESULT RelayEvent( MSG *pmsg );
    LRESULT Pop( void );
    LRESULT SetDelayTime( DWORD dwDuration, INT iTime );
    LRESULT SetMargin( RECT *prc );
    LRESULT SetMaxTipWidth( INT iWidth );
    LRESULT SetTipBkColor( COLORREF col );
    LRESULT SetTipTextColor( COLORREF col );
    CUIFObject *GetCurrentObj() {return m_pObjCur;}
    void ClearCurrentObj() {m_pObjCur = NULL;}

    BOOL IsBeingShown()  {return m_fBeingShown;}

protected:
    CUIFWindow *m_pWndOwner;
    CUIFObject *m_pObjCur;
    LPWSTR     m_pwchToolTip;
    BOOL       m_fBeingShown;
    BOOL       m_fIgnore;
    INT        m_iDelayAutoPop;
    INT        m_iDelayInitial;
    INT        m_iDelayReshow;
    RECT       m_rcMargin;
    INT        m_iMaxTipWidth;
    BOOL       m_fColBack;
    BOOL       m_fColText;
    COLORREF   m_colBack;
    COLORREF   m_colText;

    CUIFObject *FindObject( HWND hWnd, POINT pt );
    void ShowTip( void );
    void HideTip( void );
    void GetTipWindowSize( SIZE *psize );
    void GetTipWindowRect( RECT *prc, SIZE size, RECT *prcExclude);
};

#endif /* CUITIP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuitip.cpp ===
//
// cuiwnd.cpp
//

#include "private.h"
#include "cuitip.h"
#include "cuiobj.h"
#include "cuiutil.h"

// TIMER IDs

#define IDTIMER_TOOLTIP             0x3216


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  W I N D O W                                                     */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  W I N D O W   */
/*------------------------------------------------------------------------------

    Constructor of CUIFWindow

------------------------------------------------------------------------------*/
CUIFToolTip::CUIFToolTip( HINSTANCE hInst, DWORD dwStyle, CUIFWindow *pWndOwner ) : CUIFWindow( hInst, dwStyle )
{
    m_pWndOwner       = pWndOwner;
    m_pObjCur         = NULL;
    m_pwchToolTip     = NULL;
    m_fIgnore         = FALSE;
    m_iDelayAutoPop   = -1;
    m_iDelayInitial   = -1;
    m_iDelayReshow    = -1;
    m_rcMargin.left   = 2;
    m_rcMargin.top    = 2;
    m_rcMargin.right  = 2;
    m_rcMargin.bottom = 2;
    m_iMaxTipWidth    = -1;
    m_fColBack        = FALSE;
    m_fColText        = FALSE;
    m_colBack         = RGB( 0, 0, 0 );
    m_colText         = RGB( 0, 0, 0 );
}


/*   ~ C  U I F  W I N D O W   */
/*------------------------------------------------------------------------------

    Destructor of CUIFWindow

------------------------------------------------------------------------------*/
CUIFToolTip::~CUIFToolTip( void )
{
    if (m_pWndOwner)
        m_pWndOwner->ClearToolTipWnd();

    if (m_pwchToolTip != NULL) {
        delete m_pwchToolTip;
    }
}


/*   I N I T I A L I Z E   */
/*------------------------------------------------------------------------------

    Initialize UI window object
    (UIFObject method)

------------------------------------------------------------------------------*/
CUIFObject *CUIFToolTip::Initialize( void )
{
    return CUIFWindow::Initialize();
}


/*   P A I N T  O B J E C T   */
/*------------------------------------------------------------------------------

    Paint window object
    (UIFObject method)

------------------------------------------------------------------------------*/
void CUIFToolTip::OnPaint( HDC hDC )
{
    HFONT    hFontOld = (HFONT)SelectObject( hDC, GetFont() );
    int      iBkModeOld = SetBkMode( hDC, TRANSPARENT );
    COLORREF colTextOld;
    HBRUSH   hBrush;
    RECT     rc = GetRectRef();
    RECT     rcMargin;
    RECT     rcText;

    colTextOld = SetTextColor( hDC, (COLORREF) GetTipTextColor() );

    // 

    hBrush = CreateSolidBrush( (COLORREF) GetTipBkColor() );
    if (hBrush)
    {
        FillRect( hDC, &rc, hBrush );
        DeleteObject( hBrush );
    }

    //

    GetMargin( &rcMargin );
    rcText.left   = rc.left   + rcMargin.left;
    rcText.top    = rc.top    + rcMargin.top;
    rcText.right  = rc.right  - rcMargin.right;
    rcText.bottom = rc.bottom - rcMargin.bottom;

    if (0 < GetMaxTipWidth()) {
        CUIDrawText( hDC, m_pwchToolTip, -1, &rcText, DT_LEFT | DT_TOP | DT_WORDBREAK );
    }
    else {
        CUIDrawText( hDC, m_pwchToolTip, -1, &rcText, DT_LEFT | DT_TOP | DT_SINGLELINE );
    }

    // restore DC

    SetTextColor( hDC, colTextOld );
    SetBkMode( hDC, iBkModeOld );
    SelectObject( hDC, hFontOld );
}


/*   O N  T I M E R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFToolTip::OnTimer( UINT uiTimerID )
{
    if (uiTimerID == IDTIMER_TOOLTIP) {
        ShowTip();
    }
}


/*   E N A B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFToolTip::Enable( BOOL fEnable )
{
    if (!fEnable) {
        HideTip();
    }
    CUIFObject::Enable( fEnable );
}


/*   G E T  D E L A Y  T I M E   */
/*------------------------------------------------------------------------------

    Retrieves the initial, pop-up, and reshow durations currently set for a
    tooltip control.

------------------------------------------------------------------------------*/
LRESULT CUIFToolTip::GetDelayTime( DWORD dwDuration )
{
    switch (dwDuration) {
        case TTDT_AUTOPOP: {
            return ((m_iDelayAutoPop == -1) ? GetDoubleClickTime() * 10 : m_iDelayAutoPop);
        }
          
        case TTDT_INITIAL: {
            return ((m_iDelayInitial == -1) ? GetDoubleClickTime() : m_iDelayInitial);
        }
        
        case TTDT_RESHOW: {
            return ((m_iDelayReshow == -1) ? GetDoubleClickTime() / 5 : m_iDelayReshow);
        }
    }

    return 0;
}


/*   G E T  M A R G I N   */
/*------------------------------------------------------------------------------

    Retrieves the top, left, bottom, and right margins set for a tooltip window. 
    A margin is the distance, in pixels, between the tooltip window border and 
    the text contained within the tooltip window. 

------------------------------------------------------------------------------*/
LRESULT CUIFToolTip::GetMargin( RECT *prc )
{
    if (prc == NULL) {
        return 0;
    }

    *prc = m_rcMargin;
    return 0;
}


/*   G E T  M A X  T I P  W I D T H   */
/*------------------------------------------------------------------------------

    Retrieves the maximum width for a tooltip window. 

------------------------------------------------------------------------------*/
LRESULT CUIFToolTip::GetMaxTipWidth( void )
{
    return m_iMaxTipWidth;
}


/*   G E T  T I P  B K  C O L O R   */
/*------------------------------------------------------------------------------

    Retrieves the background color in a tooltip window. 

------------------------------------------------------------------------------*/
LRESULT CUIFToolTip::GetTipBkColor( void )
{ 
    if (m_fColBack) {
        return (LRESULT)m_colBack;
    }
    else {
        return (LRESULT)GetSysColor( COLOR_INFOBK );
    }
}


/*   G E T  T I P  T E X T  C O L O R   */
/*------------------------------------------------------------------------------

    Retrieves the text color in a tooltip window. 

------------------------------------------------------------------------------*/
LRESULT CUIFToolTip::GetTipTextColor( void )
{ 
    if (m_fColText) {
        return (LRESULT)m_colText;
    }
    else {
        return (LRESULT)GetSysColor( COLOR_INFOTEXT );
    }
}


/*   R E L A Y  E V E N T   */
/*------------------------------------------------------------------------------

    Passes a mouse message to a tooltip control for processing. 

------------------------------------------------------------------------------*/
LRESULT CUIFToolTip::RelayEvent( MSG *pmsg )
{
    if (pmsg == NULL) {
        return 0;
    }

    switch (pmsg->message) {
        case WM_MOUSEMOVE: {
            CUIFObject *pUIObj;
            POINT      pt;

            // ignore while disabled

            if (!IsEnabled()) {
                break;
            }

            // ignore mouse move while mouse down

            if ((GetKeyState(VK_LBUTTON) & 0x8000) || 
                (GetKeyState(VK_MBUTTON) & 0x8000) ||
                (GetKeyState(VK_RBUTTON) & 0x8000)) {
                break;
                }

            // get object from point

            POINTSTOPOINT( pt, MAKEPOINTS( pmsg->lParam ) );
            pUIObj = FindObject( pmsg->hwnd, pt );

            //

            if (pUIObj != NULL) {
                if (m_pObjCur != pUIObj) {
                    BOOL fWasVisible = IsVisible();

                    HideTip();
                    if (fWasVisible) {
                        ::SetTimer( GetWnd(), IDTIMER_TOOLTIP, (UINT)GetDelayTime( TTDT_RESHOW ), NULL );
                    }
                    else {
                        ::SetTimer( GetWnd(), IDTIMER_TOOLTIP, (UINT)GetDelayTime( TTDT_INITIAL ), NULL );
                    }
                }
            }
            else {
                HideTip();
            }

            m_pObjCur = pUIObj;
            break;
        }

        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_MBUTTONDOWN: {
            HideTip();
            break;
        }
  
        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
        case WM_MBUTTONUP: {
            break;
        }
    }

    return 0;
}


/*   P O P   */
/*------------------------------------------------------------------------------

    Removes a displayed tooltip window from view. 

------------------------------------------------------------------------------*/
LRESULT CUIFToolTip::Pop( void )
{
    HideTip();
    return 0;
}


/*   S E T  D E L A Y  T I M E   */
/*------------------------------------------------------------------------------

    Sets the initial, pop-up, and reshow durations for a tooltip control.

------------------------------------------------------------------------------*/
LRESULT CUIFToolTip::SetDelayTime( DWORD dwDuration, INT iTime )
{
    switch (dwDuration) {
        case TTDT_AUTOPOP: {
            m_iDelayAutoPop = iTime;
            break;
        }
          
        case TTDT_INITIAL: {
            m_iDelayInitial = iTime;
            break;
        }
        
        case TTDT_RESHOW: {
            m_iDelayReshow = iTime;
            break;
        }

        case TTDT_AUTOMATIC: {
            if (0 <= iTime) {
                m_iDelayAutoPop = iTime * 10;
                m_iDelayInitial = iTime;
                m_iDelayReshow  = iTime / 5;
            }
            else {
                m_iDelayAutoPop = -1;
                m_iDelayInitial = -1;
                m_iDelayReshow  = -1;
            }
            break;
        }
    }

    return 0;
}


/*   S E T  M A R G I N   */
/*------------------------------------------------------------------------------

    Sets the top, left, bottom, and right margins for a tooltip window. A margin 
    is the distance, in pixels, between the tooltip window border and the text 
    contained within the tooltip window. 

------------------------------------------------------------------------------*/
LRESULT CUIFToolTip::SetMargin( RECT *prc )
{
    if (prc == NULL) {
        return 0;
    }

    m_rcMargin = *prc;
    return 0;
}


/*   S E T  M A X  T I P  W I D T H   */
/*------------------------------------------------------------------------------

     Sets the maximum width for a tooltip window. 

------------------------------------------------------------------------------*/
LRESULT CUIFToolTip::SetMaxTipWidth( INT iWidth )
{
    m_iMaxTipWidth = iWidth;
    return 0;
}


/*   S E T  T I P  B K  C O L O R   */
/*------------------------------------------------------------------------------

    Sets the background color in a tooltip window. 

------------------------------------------------------------------------------*/
LRESULT CUIFToolTip::SetTipBkColor( COLORREF col )
{ 
    m_fColBack = TRUE;
    m_colBack = col;

    return 0;
}


/*   S E T  T I P  T E X T  C O L O R   */
/*------------------------------------------------------------------------------

    Sets the text color in a tooltip window. 

------------------------------------------------------------------------------*/
LRESULT CUIFToolTip::SetTipTextColor( COLORREF col )
{ 
    m_fColText = TRUE;
    m_colText = col;

    return 0;
}


/*   F I N D  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFObject *CUIFToolTip::FindObject( HWND hWnd, POINT pt )
{
    if (hWnd != m_pWndOwner->GetWnd()) {
        return NULL;
    }

    return m_pWndOwner->ObjectFromPoint( pt );
}


/*   S H O W  T I P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFToolTip::ShowTip( void )
{
    LPCWSTR pwchToolTip;
    SIZE    size;
    RECT    rc;
    RECT    rcObj;
    POINT   ptCursor;

    ::KillTimer( GetWnd(), IDTIMER_TOOLTIP );

    if (m_pObjCur == NULL) {
        return;
    }

    // if object has no tooltip, not open tooltip window

    pwchToolTip = m_pObjCur->GetToolTip();
    if (pwchToolTip == NULL) {
        return;
    }

    //
    // GetToolTip() might delete m_pObjCur. We need to check this again.
    //
    if (m_pObjCur == NULL) {
        return;
    }

    //
    // Start ToolTip notification.
    //
    if (m_pObjCur->OnShowToolTip())
        return;

    GetCursorPos( &ptCursor );
    ScreenToClient(m_pObjCur->GetUIWnd()->GetWnd(),&ptCursor);
    m_pObjCur->GetRect(&rcObj);
    if (!PtInRect(&rcObj, ptCursor)) {
        return;
    }

    // store tooltip text

    m_pwchToolTip = new WCHAR[ StrLenW(pwchToolTip) + 1 ];
    if (!m_pwchToolTip)
        return;

    StrCpyW( m_pwchToolTip, pwchToolTip );

    // calc window size

    GetTipWindowSize( &size );

    // calc window position

    ClientToScreen(m_pObjCur->GetUIWnd()->GetWnd(),(LPPOINT)&rcObj.left);
    ClientToScreen(m_pObjCur->GetUIWnd()->GetWnd(),(LPPOINT)&rcObj.right);
    GetTipWindowRect( &rc, size, &rcObj);

    // show window
    m_fBeingShown = TRUE;

    Move( rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top );
    Show( TRUE );
}


/*   H I D E  T I P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFToolTip::HideTip( void )
{
    ::KillTimer( GetWnd(), IDTIMER_TOOLTIP );

    m_fBeingShown = FALSE;

    //
    // Hide ToolTip notification.
    //
    if (m_pObjCur)
        m_pObjCur->OnHideToolTip();

    if (!IsVisible()) {
        return;
    }

    // dispose buffer

    if (m_pwchToolTip != NULL) {
        delete m_pwchToolTip;
        m_pwchToolTip = NULL;
    }

    // hide window

    Show( FALSE );
}


/*   G E T  T I P  W I N D O W  S I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFToolTip::GetTipWindowSize( SIZE *psize )
{
    HDC   hDC = GetDC( GetWnd() );
    HFONT hFontOld;
    RECT  rcMargin;
    RECT  rcText;
    RECT  rc;
    int   iTipWidth;
    int   iTipHeight;

    Assert( psize != NULL );

    if (m_pwchToolTip == NULL) {
        return;
    }

    hFontOld = (HFONT)SelectObject( hDC, GetFont() );

    // get text size

    iTipWidth = (int)GetMaxTipWidth();
    if (0 < iTipWidth) {
        rcText.left   = 0;
        rcText.top    = 0;
        rcText.right  = iTipWidth;
        rcText.bottom = 0;
        iTipHeight = CUIDrawText( hDC, m_pwchToolTip, -1, &rcText, DT_LEFT | DT_TOP | DT_CALCRECT | DT_WORDBREAK );

        rcText.bottom = rcText.top + iTipHeight;
    }
    else {
        rcText.left   = 0;
        rcText.top    = 0;
        rcText.right  = 0;
        rcText.bottom = 0;
        iTipHeight = CUIDrawText( hDC, m_pwchToolTip, -1, &rcText, DT_LEFT | DT_TOP | DT_CALCRECT | DT_SINGLELINE );

        rcText.bottom = rcText.top + iTipHeight;
    }

    // add margin size

    GetMargin( &rcMargin );

    rc.left   = rcText.left   - rcMargin.left;
    rc.top    = rcText.top    - rcMargin.top;
    rc.right  = rcText.right  + rcMargin.right;
    rc.bottom = rcText.bottom + rcMargin.bottom;

    // finally get window size

    ClientRectToWindowRect( &rc );
    psize->cx = (rc.right - rc.left);
    psize->cy = (rc.bottom - rc.top);

    SelectObject( hDC, hFontOld );
    ReleaseDC( GetWnd(), hDC );
}


/*   G E T  T I P  W I N D O W  R E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFToolTip::GetTipWindowRect( RECT *prc, SIZE size, RECT *prcExclude)
{
    POINT    ptCursor;
    POINT    ptHotSpot;
    SIZE     sizeCursor;
    HCURSOR  hCursor;
    ICONINFO IconInfo;
    BITMAP   bmp;
    RECT     rcScreen;

    Assert( prc != NULL );

    // get cursor pos

    GetCursorPos( &ptCursor );

    // get cursor size

    sizeCursor.cx = GetSystemMetrics( SM_CXCURSOR );
    sizeCursor.cy = GetSystemMetrics( SM_CYCURSOR );
    ptHotSpot.x = 0;
    ptHotSpot.y = 0;

    hCursor = GetCursor();
    if (hCursor != NULL && GetIconInfo( hCursor, &IconInfo )) {
        GetObject( IconInfo.hbmMask, sizeof(bmp), &bmp );
        if (!IconInfo.fIcon) {
            ptHotSpot.x = IconInfo.xHotspot;
            ptHotSpot.y = IconInfo.yHotspot;
            sizeCursor.cx = bmp.bmWidth;
            sizeCursor.cy = bmp.bmHeight;

            if (IconInfo.hbmColor == NULL) {
                sizeCursor.cy = sizeCursor.cy / 2;
            }
        }

        if (IconInfo.hbmColor != NULL) {
            DeleteObject( IconInfo.hbmColor );
        }
        DeleteObject( IconInfo.hbmMask );
    }

    // get screen rect

    rcScreen.left   = 0;
    rcScreen.top    = 0;
    rcScreen.right  = GetSystemMetrics( SM_CXSCREEN );
    rcScreen.bottom = GetSystemMetrics( SM_CYSCREEN );

    if (CUIIsMonitorAPIAvail()) {
        HMONITOR    hMonitor;
        MONITORINFO MonitorInfo;

        hMonitor = CUIMonitorFromPoint( ptCursor, MONITOR_DEFAULTTONEAREST );
        if (hMonitor != NULL) {
            MonitorInfo.cbSize = sizeof(MonitorInfo);
            if (CUIGetMonitorInfo( hMonitor, &MonitorInfo )) {
                rcScreen = MonitorInfo.rcMonitor;
            }
        }
    }

    // try to put it at bellow

    prc->left   = ptCursor.x;
    prc->top    = ptCursor.y - ptHotSpot.y + sizeCursor.cy;
    prc->right  = prc->left + size.cx;
    prc->bottom = prc->top  + size.cy;

    if (rcScreen.bottom < prc->bottom) {
        if (ptCursor.y < prcExclude->top)
            prc->top = ptCursor.y - size.cy;
        else
            prc->top = prcExclude->top - size.cy;
        prc->bottom = prc->top   + size.cy;
    }
    if (prc->top < rcScreen.top) {
        prc->top    = rcScreen.top;
        prc->bottom = prc->top + size.cy;
    }

    // check horizontal position

    if (rcScreen.right < prc->right) {
        prc->left  = rcScreen.right - size.cx;
        prc->right = prc->left + size.cx;
    }
    if (prc->left < rcScreen.left) {
        prc->left  = rcScreen.left;
        prc->right = prc->left + size.cx;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuitheme.h ===
//
// cuitheme.h
//

#ifndef CUITHEME_H
#define CUITHEME_H


#include "uxtheme.h"
#include "tmschema.h"

extern BOOL CUIIsThemeAPIAvail( void );
extern BOOL CUIIsThemeActive( void );
extern HTHEME CUIOpenThemeData( HWND hwnd, LPCWSTR pszClassList );
extern HRESULT CUICloseThemeData( HTHEME hTheme );
extern HRESULT CUISetWindowTheme(HWND hwnd, LPCWSTR pszSubAppName, LPCWSTR pszSubIdList);
extern HRESULT CUIDrawThemeBackground( HTHEME hTheme, HDC hDC, int iPartId, int iStateId, const RECT *pRect, DWORD dwBgFlags );
extern HRESULT CUIDrawThemeParentBackground( HWND hwnd, HDC hDC, const RECT *pRect);
extern HRESULT CUIDrawThemeText( HTHEME hTheme, HDC hDC, int iPartId, int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, DWORD dwTextFlags2, const RECT *pRect );
extern HRESULT CUIDrawThemeIcon( HTHEME hTheme, HDC hDC, int iPartId, int iStateId, const RECT *pRect, HIMAGELIST himl, int iImageIndex );
extern HRESULT CUIGetThemeBackgroundExtent( HTHEME hTheme, HDC hDC, int iPartId, int iStateId, const RECT *pContentRect, RECT *pExtentRect );
extern HRESULT CUIGetThemeBackgroundContentRect( HTHEME hTheme, HDC hDC, int iPartId, int iStateId, const RECT *pBoundingRect, RECT *pContentRect );
extern HRESULT CUIGetThemeTextExtent( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, const RECT *pBoundingRect, RECT *pExtentRect );
extern HRESULT CUIGetThemePartSize( HTHEME hTheme, HDC hDC, int iPartId, int iStateId, RECT *prc, enum THEMESIZE eSize, SIZE *pSize );
extern HRESULT CUIDrawThemeEdge(HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pDestRect, UINT uEdge, UINT uFlags, OPTIONAL OUT RECT *pContentRect);
extern HRESULT CUIGetThemeColor(HTHEME hTheme, int iPartId, int iStateId, int iPropId, COLORREF *pColor);
extern HRESULT CUIGetThemeMargins(HTHEME hTheme, HDC hdc, int iPartId, int iStateId, int iPropId, RECT *prc, MARGINS *pMargins);
extern HRESULT CUIGetThemeFont(HTHEME hTheme, HDC hdc, int iPartId, int iStateId, int iPropId, LOGFONTW *plf);
extern COLORREF CUIGetThemeSysColor(HTHEME hTheme, int iColorId);
extern int CUIGetThemeSysSize(HTHEME hTheme, int iSizeId);

class CUIFTheme
{
public:
    CUIFTheme()
    {
        m_pszThemeClassList = NULL;
        m_hTheme = NULL;
    }

    ~CUIFTheme() 
    {
        CloseThemeData();
    }

    BOOL IsThemeActive()
    {
        return CUIIsThemeActive();
    }

    HRESULT EnsureThemeData( HWND hwnd)
    {
        if (m_hTheme)
            return S_OK;

        return InternalOpenThemeData(hwnd);
    }

    HRESULT OpenThemeData( HWND hwnd)
    {
        Assert(!m_hTheme);
        return InternalOpenThemeData(hwnd);
    }

    HRESULT InternalOpenThemeData( HWND hwnd)
    {
        if (!hwnd)
            return E_FAIL;

        if (!m_pszThemeClassList)
            return E_FAIL;

        m_hTheme = CUIOpenThemeData(hwnd, m_pszThemeClassList);
        return m_hTheme ? S_OK : E_FAIL;
    }

    HRESULT CloseThemeData()
    {
        if (!m_hTheme)
            return S_OK;

        HRESULT hr = CUICloseThemeData( m_hTheme );
        m_hTheme = NULL;
        return hr;
    }

    HRESULT SetWindowTheme(HWND hwnd, LPCWSTR pszSubAppName, LPCWSTR pszSubIdList)
    {
         return CUISetWindowTheme(hwnd, pszSubAppName, pszSubIdList);
    }

    virtual HRESULT DrawThemeBackground(HDC hDC, int iStateId, const RECT *pRect, DWORD dwBgFlags )
    {
        Assert(!!m_hTheme);
        return CUIDrawThemeBackground(m_hTheme, 
                                      hDC, 
                                      m_iDefThemePartID, 
                                      iStateId, 
                                      pRect, 
                                      dwBgFlags );
    }

    virtual HRESULT DrawThemeParentBackground(HWND hwnd, HDC hDC, const RECT *pRect)
    {
        Assert(!!m_hTheme);
        return CUIDrawThemeParentBackground(hwnd, hDC,  pRect);
    }

    virtual HRESULT DrawThemeText(HDC hDC, int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, DWORD dwTextFlags2, const RECT *pRect )
    {
        Assert(!!m_hTheme);
        return CUIDrawThemeText(m_hTheme, 
                                hDC, 
                                m_iDefThemePartID, 
                                iStateId, 
                                pszText, 
                                iCharCount, 
                                dwTextFlags, 
                                dwTextFlags2, 
                                pRect );
    }

    virtual HRESULT DrawThemeIcon(HDC hDC, int iStateId, const RECT *pRect, HIMAGELIST himl, int iImageIndex )
    {
        Assert(!!m_hTheme);
        return CUIDrawThemeIcon(m_hTheme, 
                                hDC, 
                                m_iDefThemePartID, 
                                iStateId, 
                                pRect, 
                                himl, 
                                iImageIndex );
    }

    virtual HRESULT GetThemeBackgroundExtent(HDC hDC, int iStateId, const RECT *pContentRect, RECT *pExtentRect )
    {
        Assert(!!m_hTheme);
        return CUIGetThemeBackgroundExtent(m_hTheme, 
                                           hDC, 
                                           m_iDefThemePartID, 
                                           iStateId, 
                                           pContentRect, 
                                           pExtentRect );
    }

    virtual HRESULT GetThemeBackgroundContentRect(HDC hDC, int iStateId, const RECT *pBoundingRect, RECT *pContentRect )
    {
        Assert(!!m_hTheme);
        return CUIGetThemeBackgroundContentRect(m_hTheme, 
                                                hDC, 
                                                m_iDefThemePartID, 
                                                iStateId, 
                                                pBoundingRect, 
                                                pContentRect );
    }

    virtual HRESULT GetThemeTextExtent(HDC hdc, int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, const RECT *pBoundingRect, RECT *pExtentRect )
    {
        Assert(!!m_hTheme);
        return CUIGetThemeTextExtent(m_hTheme, 
                                     hdc, 
                                     m_iDefThemePartID, 
                                     iStateId, 
                                     pszText, 
                                     iCharCount, 
                                     dwTextFlags, 
                                     pBoundingRect, 
                                     pExtentRect );
    }

    virtual HRESULT GetThemePartSize(HDC hDC, int iStateId, RECT *prc, enum THEMESIZE eSize, SIZE *pSize )
    {
        Assert(!!m_hTheme);
        return CUIGetThemePartSize(m_hTheme, 
                                   hDC, 
                                   m_iDefThemePartID, 
                                   iStateId, 
                                   prc,
                                   eSize, 
                                   pSize );
    }

    virtual HRESULT DrawThemeEdge(HDC hdc, int iStateId, const RECT *pDestRect, UINT uEdge, UINT uFlags, RECT *pContentRect = NULL)
    {
        Assert(!!m_hTheme);
        return CUIDrawThemeEdge(m_hTheme, 
                                hdc, 
                                m_iDefThemePartID, 
                                iStateId, 
                                pDestRect, 
                                uEdge, 
                                uFlags, 
                                pContentRect);
    }

    virtual HRESULT GetThemeColor(int iStateId, int iPropId, COLORREF *pColor)
    {
        Assert(!!m_hTheme);
        return CUIGetThemeColor(m_hTheme, 
                                m_iDefThemePartID, 
                                iStateId, 
                                iPropId, 
                                pColor);
    }

    virtual HRESULT GetThemeMargins(HDC hdc, int iStateId, int iPropId, RECT *prc, MARGINS *pMargins)
    {
        Assert(!!m_hTheme);
        return CUIGetThemeMargins(m_hTheme, 
                                  hdc,
                                  m_iDefThemePartID, 
                                  iStateId, 
                                  iPropId, 
                                  prc, 
                                  pMargins);
    }

    virtual HRESULT GetThemeFont(HDC hdc, int iStateId, int iPropId, LOGFONTW *plf)
    {
        Assert(!!m_hTheme);
        return CUIGetThemeFont(m_hTheme, 
                                  hdc, 
                                  m_iDefThemePartID, 
                                  iStateId, 
                                  iPropId, 
                                  plf);
    }

    virtual COLORREF GetThemeSysColor(int iColorId)
    {
        Assert(!!m_hTheme);
        return CUIGetThemeSysColor(m_hTheme, iColorId);
    }

    virtual int GetThemeSysSize(int iSizeId)
    {
        Assert(!!m_hTheme);
        return CUIGetThemeSysSize(m_hTheme, iSizeId);
    }

    virtual void SetActiveTheme(LPCWSTR pszClassList, int iPartID = 0, int iStateID = 0)
    { 
        m_iDefThemePartID = iPartID;
        m_iDefThemeStateID = iStateID;
        m_pszThemeClassList = pszClassList;
    }

    int GetDefThemePartID() {return m_iDefThemePartID;}
    int GetDefThemeStateID() {return m_iDefThemeStateID;}
    void SetDefThemePartID(int iPartId) {m_iDefThemePartID = iPartId;}
private:
    LPCWSTR   m_pszThemeClassList;
    int       m_iDefThemePartID;
    int       m_iDefThemeStateID;
    HTHEME    m_hTheme;
};


#endif CUITHEME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuiutil.h ===
//
// cuituil.h
//  = UI object library - util functions =
//

#ifndef CUIUTIL_H
#define CUIUTIL_H

//
// user32 definition
//

#if (_WIN32_WINNT < 0x0500)
// Window style

#define WS_EX_LAYERED               0x00080000

// UpdateLayeredWindow()

#define LWA_COLORKEY                0x00000001
#define LWA_ALPHA                   0x00000002
#define ULW_COLORKEY                0x00000001
#define ULW_ALPHA                   0x00000002
#define ULW_OPAQUE                  0x00000004

#endif /* _WIN32_WINNT < 0x0500 */

#if (WINVER < 0x0500)
// AnimateWindow()

#define AW_HOR_POSITIVE             0x00000001
#define AW_HOR_NEGATIVE             0x00000002
#define AW_VER_POSITIVE             0x00000004
#define AW_VER_NEGATIVE             0x00000008
#define AW_CENTER                   0x00000010
#define AW_HIDE                     0x00010000
#define AW_ACTIVATE                 0x00020000
#define AW_SLIDE                    0x00040000
#define AW_BLEND                    0x00080000

// minitor functions

typedef struct tagMONITORINFO
{
    DWORD   cbSize;
    RECT    rcMonitor;
    RECT    rcWork;
    DWORD   dwFlags;
} MONITORINFO, *LPMONITORINFO;

DECLARE_HANDLE(HMONITOR);

#define MONITOR_DEFAULTTONULL       0x00000000
#define MONITOR_DEFAULTTOPRIMARY    0x00000001
#define MONITOR_DEFAULTTONEAREST    0x00000002
#define MONITORINFOF_PRIMARY        0x00000001

#endif /* WINVER < 0x0500 */


//
// user32 functions
//

extern BOOL CUIIsUpdateLayeredWindowAvail( void );
extern BOOL CUIUpdateLayeredWindow( HWND hWnd, HDC hdcDst, POINT *pptDst, SIZE *psize, HDC hdcSrc, POINT *pptSrc, COLORREF crKey, BLENDFUNCTION *pblend, DWORD dwFlags );

extern BOOL CUIIsMonitorAPIAvail( void );
extern BOOL CUIGetMonitorInfo( HMONITOR hMonitor, LPMONITORINFO lpmi );
extern HMONITOR CUIMonitorFromWindow( HWND hwnd, DWORD dwFlags );
extern HMONITOR CUIMonitorFromRect( LPRECT prc, DWORD dwFlags );
extern HMONITOR CUIMonitorFromPoint( POINT pt, DWORD dwFlags );
extern void CUIGetScreenRect(POINT pt, RECT *prc);
extern void CUIGetWorkAreaRect(POINT pt, RECT *prc);

extern BOOL CUIIsAnimateWindowAvail( void );
extern BOOL CUIAnimateWindow( HWND hwnd, DWORD dwTime, DWORD dwFlag );


//
// drawing functions
//
extern void InitUIFUtil();
extern void DoneUIFUtil();

extern int CUIDrawText( HDC hDC, LPCWSTR pwch, int cwch, RECT *prc, UINT uFormat );
extern BOOL CUIExtTextOut( HDC hDC, int x, int y, UINT fuOptions, const RECT *prc, LPCWSTR pwch, UINT cwch, const int *lpDs );
extern BOOL CUIGetTextExtentPoint32( HDC hDC, LPCWSTR pwch, int cwch, SIZE *psize );

extern HBITMAP CreateMaskBmp(const RECT *prc, HBITMAP hbmp, HBITMAP hbmpMask, HBRUSH hbrBk, COLORREF colText, COLORREF colBk);
extern HBITMAP CreateShadowMaskBmp(RECT *prc, HBITMAP hbmp, HBITMAP hbmpMask, HBRUSH hbrBk, HBRUSH hbrShadow);
extern HBITMAP CreateDisabledBitmap(const RECT *prc, HBITMAP hbmpMask, HBRUSH hbrBk, HBRUSH hbrShadow, BOOL fShadow);
extern HBRUSH CreateDitherBrush( void );
extern void DrawMaskBmpOnDC(HDC hdc, const RECT *prc, HBITMAP hbmp, HBITMAP hbmpMask);

extern BOOL CUIDrawState(HDC hdc, HBRUSH hbr, DRAWSTATEPROC lpOutputFunc, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT fuFlags);


extern BOOL CUIGetIconSize( HICON hIcon, SIZE *psize );
extern BOOL CUIGetBitmapSize( HBITMAP hBmp, SIZE *psize );
extern BOOL CUIGetIconBitmaps(HICON hIcon, HBITMAP *phbmp, HBITMAP *phbmpMask, SIZE *psize);

extern DWORD CUIProcessDefaultLayout();
extern DWORD CUISetLayout(HDC hdc, DWORD dw);
extern HBITMAP CUIMirrorBitmap(HBITMAP hbmOrig, HBRUSH hbrBk);

extern HMODULE CUIGetSystemModuleHandle(LPCTSTR lpModuleName);

#endif /* CUIUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\delay.h ===
//
// delay.h
//

#ifndef DELAY_H
#define DELAY_H

// comctrl32

HIMAGELIST  WINAPI CUIImageList_Create(int cx, int cy, UINT flags, int cInitial, int cGrow);
#define ImageList_Create CUIImageList_Create

BOOL        WINAPI CUIImageList_Destroy(HIMAGELIST himl);
#define ImageList_Destroy CUIImageList_Destroy

int         WINAPI CUIImageList_ReplaceIcon(HIMAGELIST himl, int i, HICON hicon);
#define ImageList_ReplaceIcon CUIImageList_ReplaceIcon

#endif // DELAY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for immx project.
//
//----------------------------------------------------------------------------

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#define _OLEAUT32_

#define OEMRESOURCE 1
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>


#include "cuidebug.h"
#include "cuistr.h"
#include "cuiutil.h"
#include "cuimem.h"
#include "chkobj.h"
#include "ccstock.h"


#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuiutil.cpp ===
//
// cuiutilcpp
//  = UI object library - util functions =
//

#include "private.h"
#include "cuiutil.h"
#include "cuiobj.h"
#include "cuiwnd.h"
#include "cuitip.h"
#include "cuisys.h"
#include "cmydc.h"

#ifndef NOFONTLINK
#include "fontlink.h"
#endif /* !NOFONTLINK */


//
//
//

typedef BOOL (WINAPI *PFNUPDATELAYEREDWINDOW)( HWND hwnd, HDC hdcDst, POINT *pptDst, SIZE *psize, HDC hdcSrc, POINT *pptSrc, COLORREF crKey, BLENDFUNCTION *pblend, DWORD dwFlags );
typedef HMONITOR (WINAPI *PFNMONITORFROMWINDOW)( HWND hwnd, DWORD dwFlags );
typedef HMONITOR (WINAPI *PFNMONITORFROMRECT)( LPRECT prc, DWORD dwFlags );
typedef HMONITOR (WINAPI *PFNMONITORFROMPOINT)( POINT pt, DWORD dwFlags );
typedef BOOL (WINAPI *PFNGETMONITORINFO)( HMONITOR hMonitor, LPMONITORINFO lpmi );
typedef BOOL (WINAPI *PFNANIMATEWINDOW)( HWND hwnd, DWORD dwTime, DWORD dwFlag );
typedef BOOL (WINAPI *PFNGETPROCESSDEFAULTLAYOUT)( DWORD *pdw);
typedef BOOL (WINAPI *PFNSETLAYOUT)( HDC hdc, DWORD dw);

static PFNUPDATELAYEREDWINDOW           vpfnUpdateLayeredWindow             = NULL;
static PFNMONITORFROMWINDOW             vpfnMonitorFromWindow               = NULL;
static PFNMONITORFROMRECT               vpfnMonitorFromRect                 = NULL;
static PFNMONITORFROMPOINT              vpfnMonitorFromPoint                = NULL;
static PFNGETMONITORINFO                vpfnGetMonitorInfo                  = NULL;
static PFNANIMATEWINDOW                 vpfnAnimateWindow                   = NULL;
static PFNGETPROCESSDEFAULTLAYOUT              vpfnGetProcessDefaultLayout         = NULL;
static PFNSETLAYOUT                     vpfnSetLayout                       = NULL;


/*   G E T  H  L I B  U S E R 3 2   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HINSTANCE GetHLibUser32( void )
{
    static HINSTANCE hLibUser32 = NULL;

    if (hLibUser32 == NULL) {
        hLibUser32 = CUIGetSystemModuleHandle( TEXT("user32.dll") );
    }
    
    return hLibUser32;
}

/*   G E T  H  L I B  G D U 3 2   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HINSTANCE GetHLibGdi32( void )
{
    static HINSTANCE hLibGdi32 = NULL;

    if (hLibGdi32 == NULL) {
        hLibGdi32 = CUIGetSystemModuleHandle( TEXT("gdi32.dll") );
    }
    
    return hLibGdi32;
}


/*   C U I  I S  U P D A T E  L A Y E R E D  W I N D O W  A V A I L   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CUIIsUpdateLayeredWindowAvail( void )
{
    static BOOL fInitialized = FALSE;

    if (!fInitialized) {
        HMODULE hmodUser32 = GetHLibUser32();
        if (hmodUser32)
            vpfnUpdateLayeredWindow = (PFNUPDATELAYEREDWINDOW)GetProcAddress( hmodUser32, TEXT("UpdateLayeredWindow") );
    }

    return (vpfnUpdateLayeredWindow != NULL);
}


/*   C U I  U P D A T E  L A Y E R E D  W I N D O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CUIUpdateLayeredWindow( HWND hwnd, HDC hdcDst, POINT *pptDst, SIZE *psize, HDC hdcSrc, POINT *pptSrc, COLORREF crKey, BLENDFUNCTION *pblend, DWORD dwFlags )
{
    if (!CUIIsUpdateLayeredWindowAvail()) {
        return FALSE;
    }

    return vpfnUpdateLayeredWindow( hwnd, hdcDst, pptDst, psize, hdcSrc, pptSrc, crKey, pblend, dwFlags );
}


/*   C U I  I S  M O N I T O R  A P I  A V A I L   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CUIIsMonitorAPIAvail( void )
{
    static BOOL fInitialized = FALSE;

    if (!fInitialized) {
        HMODULE hmodUser32 = GetHLibUser32();
        if (hmodUser32)
        {
            vpfnGetMonitorInfo = (PFNGETMONITORINFO)GetProcAddress( hmodUser32, TEXT("GetMonitorInfoA") );
            vpfnMonitorFromWindow = (PFNMONITORFROMWINDOW)GetProcAddress( hmodUser32, TEXT("MonitorFromWindow") );
            vpfnMonitorFromRect = (PFNMONITORFROMRECT)GetProcAddress( hmodUser32, TEXT("MonitorFromRect") );
            vpfnMonitorFromPoint = (PFNMONITORFROMPOINT)GetProcAddress( hmodUser32, TEXT("MonitorFromPoint") );
        }
    }

    return (vpfnGetMonitorInfo != NULL) 
            && (vpfnMonitorFromWindow != NULL) 
            && (vpfnMonitorFromRect != NULL) 
            && (vpfnMonitorFromPoint != NULL);
}


/*   C U I  G E T  M O N I T O R  I N F O   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CUIGetMonitorInfo( HMONITOR hMonitor, LPMONITORINFO lpmi )
{
    if (!CUIIsMonitorAPIAvail()) {
        return FALSE;
    }

    return vpfnGetMonitorInfo( hMonitor, lpmi );
}


/*   C U I  M O N I T O R  F R O M  W I N D O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HMONITOR CUIMonitorFromWindow( HWND hwnd, DWORD dwFlags )
{
    if (!CUIIsMonitorAPIAvail()) {
        return NULL;
    }

    return vpfnMonitorFromWindow( hwnd, dwFlags );
}


/*   C U I  M O N I T O R  F R O M  R E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HMONITOR CUIMonitorFromRect( LPRECT prc, DWORD dwFlags )
{
    if (!CUIIsMonitorAPIAvail()) {
        return NULL;
    }

    return vpfnMonitorFromRect( prc, dwFlags );
}


/*   C U I  M O N I T O R  F R O M  P O I N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HMONITOR CUIMonitorFromPoint( POINT pt, DWORD dwFlags )
{
    if (!CUIIsMonitorAPIAvail()) {
        return NULL;
    }

    return vpfnMonitorFromPoint( pt, dwFlags );
}

/*   C U I  GET SCREENRECT
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/

void CUIGetScreenRect(POINT pt, RECT *prc)
{
    prc->left   = 0;
    prc->top    = 0;
    prc->right  = GetSystemMetrics( SM_CXSCREEN );
    prc->bottom = GetSystemMetrics( SM_CYSCREEN );

    if (CUIIsMonitorAPIAvail()) {
        HMONITOR    hMonitor;
        MONITORINFO MonitorInfo;

        hMonitor = CUIMonitorFromPoint( pt, MONITOR_DEFAULTTONEAREST );
        if (hMonitor != NULL) {
            MonitorInfo.cbSize = sizeof(MonitorInfo);
            if (CUIGetMonitorInfo( hMonitor, &MonitorInfo )) {
                *prc = MonitorInfo.rcMonitor;
            }
        }
    }

    return;
}

/*   C U I  GET WORDARE
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/

void CUIGetWorkAreaRect(POINT pt, RECT *prc)
{
    SystemParametersInfo(SPI_GETWORKAREA,  0, prc, FALSE);

    if (CUIIsMonitorAPIAvail()) {
        HMONITOR    hMonitor;
        MONITORINFO MonitorInfo;

        hMonitor = CUIMonitorFromPoint( pt, MONITOR_DEFAULTTONEAREST );
        if (hMonitor != NULL) {
            MonitorInfo.cbSize = sizeof(MonitorInfo);
            if (CUIGetMonitorInfo( hMonitor, &MonitorInfo )) {
                *prc = MonitorInfo.rcWork;
            }
        }
    }

    return;
}

/*   C U I  I S  A N I M A T E  W I N D O W  A V A I L   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CUIIsAnimateWindowAvail( void )
{
    static BOOL fInitialized = FALSE;

    if (!fInitialized) {
        HMODULE hmodUser32 = GetHLibUser32();
        if (hmodUser32)
            vpfnAnimateWindow = (PFNANIMATEWINDOW)GetProcAddress( hmodUser32, TEXT("AnimateWindow") );
    }

    return (vpfnAnimateWindow != NULL);
}


/*   C U I  A N I M A T E  W I N D O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CUIAnimateWindow( HWND hwnd, DWORD dwTime, DWORD dwFlag )
{
    if (!CUIIsAnimateWindowAvail()) {
        return FALSE;
    }

    return vpfnAnimateWindow( hwnd, dwTime, dwFlag );
}


//
//
//

BOOL g_fInitUIFBitmapDCs = FALSE;
CBitmapDC *g_phdcSrc = NULL;
CBitmapDC *g_phdcMask = NULL;
CBitmapDC *g_phdcDst = NULL;
void InitUIFUtil()
{
    if (!g_phdcSrc)
        g_phdcSrc = new CBitmapDC(TRUE);

    if (!g_phdcMask)
        g_phdcMask = new CBitmapDC(TRUE);

    if (!g_phdcDst)
        g_phdcDst = new CBitmapDC(TRUE);

    if (g_phdcSrc && g_phdcMask && g_phdcDst)
        g_fInitUIFBitmapDCs = TRUE;
}

void DoneUIFUtil()
{
    if (g_phdcSrc)
        delete g_phdcSrc;
    g_phdcSrc = NULL;

    if (g_phdcMask)
        delete g_phdcMask;
    g_phdcMask = NULL;

    if (g_phdcDst)
        delete g_phdcDst;
    g_phdcDst = NULL;

    g_fInitUIFBitmapDCs = FALSE;
}


/*   C U I  D R A W  T E X T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIDrawText( HDC hDC, LPCWSTR pwch, int cwch, RECT *prc, UINT uFormat )
{
#ifndef NOFONTLINK
    return FLDrawTextW( hDC, pwch, cwch, prc, uFormat );
#else /* NOFONTLINK */
    char *pch;
    int  cch;
    int  iRet;

    if (UIFIsWindowsNT()) {
        return DrawTextW( hDC, pwch, cwch, prc, uFormat );
    }

    if (cwch == -1) {
        cwch = StrLenW(pwch);
    }

    pch = new CHAR[ cwch*2+1 ];
    if (pch == NULL) {
        return 0;
    }

    cch = WideCharToMultiByte( CP_ACP, 0, pwch, cwch, pch, cwch*2+1, NULL, NULL );
    *(pch + cch) = '\0';
    iRet = DrawTextA( hDC, pch, cch, prc, uFormat );
    delete pch;

    return iRet;
#endif /* NOFONTLINK */
}


/*   C U I  E X T  T E X T  O U T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CUIExtTextOut( HDC hDC, int x, int y, UINT fuOptions, const RECT *prc, LPCWSTR pwch, UINT cwch, const int *lpDs )
{
#ifndef NOFONTLINK
    return FLExtTextOutW( hDC, x, y, fuOptions, prc, pwch, cwch, lpDs );
#else /* NOFONTLINK */
    char *pch;
    int  cch;
    BOOL fRet;

    if (UIFIsWindowsNT()) {
        return ExtTextOutW( hDC, x, y, fuOptions, prc, pwch, cwch, lpDs );
    }

    if (cwch == -1) {
        cwch = StrLenW(pwch);
    }

    pch = new CHAR[ cwch*2+1 ];
    if (pch == NULL) {
        return 0;
    }

    cch = WideCharToMultiByte( CP_ACP, 0, pwch, cwch, pch, cwch*2+1, NULL, NULL );
    *(pch + cch) = '\0';
    fRet = ExtTextOutA( hDC, x, y, fuOptions, prc, pch, cch, lpDs );
    delete pch;

    return fRet;
#endif /* NOFONTLINK */
}


/*   C U I  G E T  T E X T  E X T E N T  P O I N T 3 2   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
extern BOOL CUIGetTextExtentPoint32( HDC hDC, LPCWSTR pwch, int cwch, SIZE *psize )
{
#ifndef NOFONTLINK
    return FLGetTextExtentPoint32( hDC, pwch, cwch, psize );
#else /* NOFONTLINK */
    char *pch;
    int  cch;
    BOOL fRet;

    if (UIFIsWindowsNT()) {
        return GetTextExtentPoint32W( hDC, pwch, cwch, psize );
    }

    if (cwch == -1) {
        cwch = StrLenW(pwch);
    }

    pch = new CHAR[ cwch*2+1 ];
    if (pch == NULL) {
        return 0;
    }

    cch = WideCharToMultiByte( CP_ACP, 0, pwch, cwch, pch, cwch*2+1, NULL, NULL );
    *(pch + cch) = '\0';
    fRet = GetTextExtentPoint32A( hDC, pch, cch, psize );
    delete pch;

    return fRet;
#endif /* NOFONTLINK */
}


/*   C R E A T E  D I T H E R  B R U S H   */
/*------------------------------------------------------------------------------

    Create brush of pattern
    Returns handle of brush object when suceed, otherwise FALSE.

------------------------------------------------------------------------------*/
HBRUSH CreateDitherBrush( void )
{
    WORD     rgwPattern[8] = { 0x0055, 0x00aa, 0x0055, 0x00aa, 0x0055, 0x00aa, 0x0055, 0x00aa };
    LOGBRUSH LogBrush;
    HBITMAP  hBitmap;
    HBRUSH   hBrush;

    hBitmap = CreateBitmap( 8, 8, 1, 1, rgwPattern );
    if (hBitmap == NULL) {
        return NULL;
    }

    LogBrush.lbHatch = (LONG_PTR)hBitmap;
    LogBrush.lbStyle = BS_PATTERN;
    hBrush = CreateBrushIndirect( &LogBrush );

    DeleteObject( hBitmap );

    return hBrush;
}

//+---------------------------------------------------------------------------
//
// ConvertBlackBKGBitmap
//
//----------------------------------------------------------------------------

HBITMAP ChangeBitmapColor(const RECT *prc, HBITMAP hbmp, COLORREF rgbOld, COLORREF rgbNew)
{
    if (!g_fInitUIFBitmapDCs)
        return NULL;

    int nWidth = prc->right - prc->left;
    int nHeight =  prc->bottom - prc->top;
    DWORD     DSPDxax  = 0x00E20746;
    CSolidBrush cbr(rgbNew);

    g_phdcDst->SetDIB(nWidth, nHeight);

    g_phdcSrc->SetBitmap(hbmp);
    g_phdcMask->SetBitmap(nWidth, nHeight, 1, 1);

    BitBlt(*g_phdcDst, 0, 0, nWidth, nHeight, *g_phdcSrc,  0, 0, SRCCOPY);

    SelectObject(*g_phdcDst, (HBRUSH)cbr);
    SetBkColor(*g_phdcDst, rgbOld);
    // BitBlt(*g_phdcMask, 0, 0, nWidth, nHeight, *g_phdcDst, 0, 0, DSPDxax);
    BitBlt(*g_phdcMask, 0, 0, nWidth, nHeight, *g_phdcDst, 0, 0, MERGECOPY);

    SetBkColor(*g_phdcDst, RGB(255,255,255));
    SetTextColor(*g_phdcDst, RGB(0,0,0));
    BitBlt(*g_phdcDst, 0, 0, nWidth, nHeight, *g_phdcMask, 0, 0, DSPDxax);

#if 0
BitBlt(*g_phdcTmp,  0, 0, nWidth, nHeight, *g_phdcSrc, 0, 0, SRCCOPY);
BitBlt(*g_phdcTmp, 30, 0, nWidth, nHeight, *g_phdcMask, 0, 0, SRCCOPY);
BitBlt(*g_phdcTmp, 60, 0, nWidth, nHeight, *g_phdcDst, 0, 0, SRCCOPY);
#endif

    g_phdcSrc->Uninit();
    g_phdcMask->Uninit();
    g_phdcDst->Uninit(TRUE);
    return g_phdcDst->GetBitmapAndKeep();
}

//+---------------------------------------------------------------------------
//
// ConvertBlackBKGBitmap
//
//----------------------------------------------------------------------------

HBITMAP ConvertBlackBKGBitmap(const RECT *prc, HBITMAP hbmp, HBITMAP hbmpMask, HBRUSH hBr)
{
    LOGBRUSH  lb;
    HBRUSH    hbrTemp;

    if (!g_fInitUIFBitmapDCs)
        return NULL;

    if (PtrToUlong(hBr) <= 50)
    {
       hbrTemp = GetSysColorBrush(PtrToUlong(hBr) - 1);
    }
    else
    {
       hbrTemp = hBr;
    }
    GetObject(hbrTemp, sizeof(lb), &lb);
    if ((lb.lbStyle != BS_SOLID) || (lb.lbColor != RGB(0,0,0)))
       return NULL;

    int nWidth = prc->right - prc->left;
    int nHeight =  prc->bottom - prc->top;
    HBITMAP hbmpChanged;

    // hbmpChanged = hbmp;
    hbmpChanged = ChangeBitmapColor(prc, hbmp, RGB(0,0,0), RGB(255,255,255));
    if (!hbmpChanged)
       return NULL;

    g_phdcDst->SetDIB(nWidth, nHeight);

    g_phdcSrc->SetBitmap(hbmpChanged);
    g_phdcMask->SetBitmap(hbmpMask);

    RECT rc;
    ::SetRect(&rc, 0, 0, nWidth, nHeight);
    FillRect( *g_phdcDst, &rc, (HBRUSH)GetStockObject(WHITE_BRUSH));
    BitBlt(*g_phdcDst, 0, 0, nWidth, nHeight, *g_phdcMask, 0, 0, SRCINVERT);
    BitBlt(*g_phdcDst, 0, 0, nWidth, nHeight, *g_phdcSrc,  0, 0, SRCAND);

#if 0
{
CBitmapDC hdcTmp;
BitBlt(hdcTmp,  0, 30, nWidth, nHeight, *g_phdcSrc, 0, 0, SRCCOPY);
BitBlt(hdcTmp, 30, 30, nWidth, nHeight, *g_phdcMask, 0, 0, SRCCOPY);
BitBlt(hdcTmp, 60, 30, nWidth, nHeight, *g_phdcDst, 0, 0, SRCCOPY);
}
#endif

    g_phdcSrc->Uninit();
    g_phdcMask->Uninit();
    g_phdcDst->Uninit(TRUE);

    DeleteObject(hbmpChanged);
    return g_phdcDst->GetBitmapAndKeep();
}

//+---------------------------------------------------------------------------
//
// CreateMaskBitmap
//
//----------------------------------------------------------------------------

HBITMAP CreateMaskBmp(const RECT *prc, HBITMAP hbmp, HBITMAP hbmpMask, HBRUSH hbrBk, COLORREF colText, COLORREF colBk)
{
    if (!g_fInitUIFBitmapDCs)
        return NULL;

    int nWidth = prc->right - prc->left;
    int nHeight =  prc->bottom - prc->top;

    HBITMAP hbmpBlk = ConvertBlackBKGBitmap(prc, hbmp, hbmpMask, hbrBk);
    if (hbmpBlk)
        return hbmpBlk;


    g_phdcDst->SetDIB(nWidth, nHeight);

    g_phdcSrc->SetBitmap(hbmp);
    g_phdcMask->SetBitmap(hbmpMask);

    RECT rc;
    ::SetRect(&rc, 0, 0, nWidth, nHeight);

    COLORREF colTextOld = SetTextColor( *g_phdcDst, colText);
    COLORREF colBackOld = SetBkColor( *g_phdcDst, colBk);
    FillRect( *g_phdcDst, &rc, hbrBk);
    SetTextColor( *g_phdcDst, colTextOld );
    SetBkColor( *g_phdcDst, colBackOld );

    BitBlt(*g_phdcDst, 0, 0, nWidth, nHeight, *g_phdcMask, 0, 0, SRCAND);
    BitBlt(*g_phdcDst, 0, 0, nWidth, nHeight, *g_phdcSrc,  0, 0, SRCINVERT);

    g_phdcSrc->Uninit();
    g_phdcMask->Uninit();
    g_phdcDst->Uninit(TRUE);
    return g_phdcDst->GetBitmapAndKeep();
}

//+---------------------------------------------------------------------------
//
// CreateShadowMaskBitmap
//
//----------------------------------------------------------------------------

HBITMAP CreateShadowMaskBmp(RECT *prc, HBITMAP hbmp, HBITMAP hbmpMask, HBRUSH hbrBk, HBRUSH hbrShadow)
{
    if (!g_fInitUIFBitmapDCs)
        return NULL;

    prc->left--;
    prc->top--;

    int nWidth = prc->right - prc->left;
    int nHeight =  prc->bottom - prc->top;
    CBitmapDC hdcDstShadow(TRUE);

    g_phdcDst->SetDIB(nWidth, nHeight);

    g_phdcSrc->SetBitmap(hbmp);
    g_phdcMask->SetBitmap(hbmpMask);

    hdcDstShadow.SetDIB(nWidth, nHeight);

    RECT rc;
    ::SetRect(&rc, 0, 0, nWidth, nHeight);
    FillRect( *g_phdcDst, &rc, hbrBk);

    FillRect(hdcDstShadow, &rc, hbrShadow);
    BitBlt(hdcDstShadow, 0, 0, nWidth, nHeight, *g_phdcMask, 0, 0, SRCPAINT);

    BitBlt(*g_phdcDst, 2, 2, nWidth, nHeight, hdcDstShadow, 0, 0, SRCAND);

    BitBlt(*g_phdcDst, 0, 0, nWidth, nHeight, *g_phdcMask, 0, 0, SRCAND);
    BitBlt(*g_phdcDst, 0, 0, nWidth, nHeight, *g_phdcSrc,  0, 0, SRCINVERT);

    g_phdcSrc->Uninit();
    g_phdcMask->Uninit();
    g_phdcDst->Uninit(TRUE);
    return g_phdcDst->GetBitmapAndKeep();
}

//+---------------------------------------------------------------------------
//
// CreateDisabledBitmap
//
//----------------------------------------------------------------------------

HBITMAP CreateDisabledBitmap(const RECT *prc, HBITMAP hbmpMask, HBRUSH hbrBk, HBRUSH hbrShadow, BOOL fShadow)
{
    if (!g_fInitUIFBitmapDCs)
        return NULL;

    int nWidth = prc->right - prc->left;
    int nHeight =  prc->bottom - prc->top;

    g_phdcDst->SetDIB(nWidth, nHeight);

    g_phdcMask->SetBitmap(hbmpMask);

    g_phdcSrc->SetDIB(nWidth, nHeight);

    RECT rc;
    ::SetRect(&rc, 0, 0, nWidth, nHeight);
    FillRect( *g_phdcDst, &rc, hbrBk);

    FillRect( *g_phdcSrc, &rc, (HBRUSH)GetStockObject(WHITE_BRUSH));
    BitBlt(*g_phdcSrc, 0, 0, nWidth, nHeight, *g_phdcMask, 0, 0, SRCINVERT);
    if (fShadow)
        BitBlt(*g_phdcDst, 1, 1, nWidth, nHeight, *g_phdcSrc, 0, 0, SRCPAINT);
    else
        BitBlt(*g_phdcDst, 0, 0, nWidth, nHeight, *g_phdcSrc, 0, 0, SRCPAINT);

#if 0
    BitBlt(*g_phdcTmp,  0, 30, 30, 30, *g_phdcMask, 0, 0, SRCCOPY);
    BitBlt(*g_phdcTmp, 30, 30, 30, 30, *g_phdcSrc, 0, 0, SRCCOPY);
    BitBlt(*g_phdcTmp, 60, 30, 30, 30, *g_phdcDst, 0, 0, SRCCOPY);
#endif

    FillRect( *g_phdcSrc, &rc, hbrShadow);
    BitBlt(*g_phdcSrc, 0, 0, nWidth, nHeight, *g_phdcMask, 0, 0, SRCPAINT);
    BitBlt(*g_phdcDst, 0, 0, nWidth, nHeight, *g_phdcSrc, 0, 0, SRCAND);

#if 0
    BitBlt(*g_phdcTmp,  0, 60, 30, 30, *g_phdcMask, 0, 0, SRCCOPY);
    BitBlt(*g_phdcTmp, 30, 60, 30, 30, *g_phdcSrc, 0, 0, SRCCOPY);
    BitBlt(*g_phdcTmp, 60, 60, 30, 30, *g_phdcDst, 0, 0, SRCCOPY);
#endif

    g_phdcSrc->Uninit();
    g_phdcMask->Uninit();
    g_phdcDst->Uninit(TRUE);
    return g_phdcDst->GetBitmapAndKeep();
}




//+---------------------------------------------------------------------------
//
// CUIDrawState
//
//----------------------------------------------------------------------------

BOOL CUIDrawState(HDC hdc, HBRUSH hbr, DRAWSTATEPROC lpOutputFunc, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT fuFlags)
{
    BOOL bRet;
    POINT ptOldOrg;
    BOOL fRetVal;

    // we have to do this viewport trick to get around the fact that 
    // DrawState has a GDI bug in NT4, such that it handles offsets improperly.
    // so we do the offset by hand.
    fRetVal = SetViewportOrgEx( hdc, 0, 0, &ptOldOrg );
    Assert( fRetVal );

    bRet = DrawState(hdc, 
                     hbr, 
                     lpOutputFunc, 
                     lData, 
                     wData, 
                     x + ptOldOrg.x, 
                     y + ptOldOrg.y, 
                     cx, 
                     cy, 
                     fuFlags);

    fRetVal = SetViewportOrgEx( hdc, ptOldOrg.x, ptOldOrg.y, NULL );
    Assert( fRetVal );

    return bRet;
}

//+---------------------------------------------------------------------------
//
// DrawMaskBitmapOnDC
//
//----------------------------------------------------------------------------

void DrawMaskBmpOnDC(HDC hdc, const RECT *prc, HBITMAP hbmp, HBITMAP hbmpMask)
{
    if (!g_fInitUIFBitmapDCs)
        return;

    int nWidth = prc->right - prc->left;
    int nHeight =  prc->bottom - prc->top;

    g_phdcDst->SetDIB(nWidth, nHeight);

    g_phdcSrc->SetBitmap(hbmp);
    g_phdcMask->SetBitmap(hbmpMask);

    RECT rc;
    ::SetRect(&rc, 0, 0, nWidth, nHeight);

    BitBlt(*g_phdcDst, 0, 0, nWidth, nHeight, hdc, prc->left, prc->top, SRCCOPY);
    BitBlt(*g_phdcDst, 0, 0, nWidth, nHeight, *g_phdcMask, 0, 0, SRCAND);
    BitBlt(*g_phdcDst, 0, 0, nWidth, nHeight, *g_phdcSrc,  0, 0, SRCINVERT);

    BitBlt(hdc, prc->left, prc->top, nWidth, nHeight, *g_phdcDst, 0, 0, SRCCOPY);

    g_phdcSrc->Uninit();
    g_phdcMask->Uninit();
    g_phdcDst->Uninit();
}


/*   C U I  G E T  I C O N  S I Z E   */
/*------------------------------------------------------------------------------

    get icon image size

------------------------------------------------------------------------------*/
BOOL CUIGetIconSize( HICON hIcon, SIZE *psize )
{
    ICONINFO IconInfo;
    BITMAP   bmp;
    
    Assert( hIcon != NULL );
    Assert( psize != NULL );

    if (!GetIconInfo( hIcon, &IconInfo )) {
        return FALSE;
    }

    GetObject( IconInfo.hbmColor, sizeof(bmp), &bmp );
    DeleteObject( IconInfo.hbmColor );
    DeleteObject( IconInfo.hbmMask );

    psize->cx = bmp.bmWidth;
    psize->cy = bmp.bmHeight;
    return TRUE;
}


/*   C U I  G E T  B I T M A P  S I Z E   */
/*------------------------------------------------------------------------------

    get bitmap image size

------------------------------------------------------------------------------*/
BOOL CUIGetBitmapSize( HBITMAP hBmp, SIZE *psize )
{
    BITMAP bmp;
    
    Assert( hBmp != NULL );
    Assert( psize != NULL );

    if (GetObject( hBmp, sizeof(bmp), &bmp ) == 0) {
        return FALSE;
    }

    psize->cx = bmp.bmWidth;
    psize->cy = bmp.bmHeight;

    return TRUE;
}


//+---------------------------------------------------------------------------
//
// CUIGetIconBitmaps
//
//----------------------------------------------------------------------------

BOOL CUIGetIconBitmaps(HICON hIcon, HBITMAP *phbmp, HBITMAP *phbmpMask, SIZE *psize)
{
    if (!g_fInitUIFBitmapDCs)
        return FALSE;

    SIZE size;

    if (psize)
        size = *psize;
    else if (!CUIGetIconSize( hIcon, &size))
        return FALSE;

    g_phdcSrc->SetDIB(size.cx, size.cy);
    g_phdcMask->SetBitmap(size.cx, size.cy, 1, 1);
    RECT rc = {0, 0, size.cx, size.cy};
    FillRect(*g_phdcSrc, &rc, (HBRUSH)GetStockObject(BLACK_BRUSH));
    DrawIconEx(*g_phdcSrc, 0, 0, hIcon, size.cx, size.cy, 0, NULL, DI_NORMAL);
    DrawIconEx(*g_phdcMask, 0, 0, hIcon, size.cx, size.cy, 0, NULL, DI_MASK);

    g_phdcSrc->Uninit(TRUE);
    g_phdcMask->Uninit(TRUE);

    *phbmp = g_phdcSrc->GetBitmapAndKeep();
    *phbmpMask = g_phdcMask->GetBitmapAndKeep();
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// CUIGetProcessDefaultLayout
//
//----------------------------------------------------------------------------

DWORD CUIProcessDefaultLayout()
{
    static BOOL fInitialized = FALSE;
    DWORD dw;

    if (!fInitialized) {
        HMODULE hmodUser32 = GetHLibUser32();
        if (hmodUser32)
            vpfnGetProcessDefaultLayout = (PFNGETPROCESSDEFAULTLAYOUT)GetProcAddress( hmodUser32, TEXT("GetProcessDefaultLayout") );
        fInitialized = TRUE;
    }

    if (!vpfnGetProcessDefaultLayout)
        return 0;

    if (!vpfnGetProcessDefaultLayout(&dw))
        return 0;

    return dw;
}

//+---------------------------------------------------------------------------
//
// CUISetLayout
//
//----------------------------------------------------------------------------

DWORD CUISetLayout(HDC hdc, DWORD dw)
{
    static BOOL fInitialized = FALSE;

    if (!fInitialized) {
        HMODULE hmodGdi32 = GetHLibGdi32();
        if (hmodGdi32)
            vpfnSetLayout = (PFNSETLAYOUT)GetProcAddress( hmodGdi32,  TEXT("SetLayout") );
        fInitialized = TRUE;
    }

    if (!vpfnSetLayout)
        return 0;

    return vpfnSetLayout(hdc, dw);
}

//+---------------------------------------------------------------------------
//
// CUISetLayout
//
//----------------------------------------------------------------------------

HBITMAP CUIMirrorBitmap(HBITMAP hbmOrg, HBRUSH hbrBk)
{
    if (!g_fInitUIFBitmapDCs)
        return NULL;

    BITMAP bm;

    if (!GetObject(hbmOrg, sizeof(BITMAP), &bm))
    {
        return NULL;
    }

    g_phdcSrc->SetBitmap(hbmOrg);
    g_phdcDst->SetDIB(bm.bmWidth, bm.bmHeight);
    g_phdcMask->SetDIB(bm.bmWidth, bm.bmHeight);

    RECT rc;
    ::SetRect(&rc, 0, 0, bm.bmWidth, bm.bmHeight);
    FillRect( *g_phdcDst, &rc, hbrBk);

    CUISetLayout(*g_phdcMask, LAYOUT_RTL);

    BitBlt(*g_phdcMask, 0, 0, bm.bmWidth, bm.bmHeight, *g_phdcSrc, 0, 0, SRCCOPY);

    CUISetLayout(*g_phdcMask, 0);

    //
    //  The offset by 1 is to solve the off-by-one problem.
    //
    BitBlt(*g_phdcDst, 0, 0, bm.bmWidth, bm.bmHeight, *g_phdcMask, 1, 0, SRCCOPY);

    g_phdcSrc->Uninit();
    g_phdcMask->Uninit();
    g_phdcDst->Uninit(TRUE);
    return g_phdcDst->GetBitmapAndKeep();
}

//+---------------------------------------------------------------------------
//
// CUICicSystemModulePath
//
//----------------------------------------------------------------------------

class CUICicSystemModulePath
{
public:
    CUICicSystemModulePath()
    {
        m_szPath[0] = TEXT('\0');
        m_uRet = 0;
    }

    UINT Init(LPCTSTR lpModuleName)
    {
        m_uRet = GetSystemDirectory(m_szPath, ARRAYSIZE(m_szPath));
        if (m_uRet)
        {
            if (m_szPath[m_uRet - 1] != TEXT('\\'))
            {
                m_szPath[m_uRet] = TEXT('\\');
                m_uRet++;
            }
            UINT uLength = lstrlen(lpModuleName);
            if (ARRAYSIZE(m_szPath) - m_uRet > uLength)
            {
                lstrcpyn(&m_szPath[m_uRet], lpModuleName, ARRAYSIZE(m_szPath) - m_uRet);
                m_uRet += uLength;
            }
            else
                m_uRet = 0;
        }
        return m_uRet;
    }

    LPTSTR GetPath()
    {
        return m_szPath;
    }

private:
    TCHAR m_szPath[MAX_PATH + 1];
    UINT m_uRet;
};

//+---------------------------------------------------------------------------
//
// CUIGetSystemModuleHandle
//
//----------------------------------------------------------------------------

HMODULE CUIGetSystemModuleHandle(LPCTSTR lpModuleName)
{
    CUICicSystemModulePath path;

    if (!path.Init(lpModuleName))
         return NULL;

    return GetModuleHandle(path.GetPath());
}

//+---------------------------------------------------------------------------
//
// CUILoadSystemModuleHandle
//
//----------------------------------------------------------------------------

HMODULE CUILoadSystemModuleHandle(LPCTSTR lpModuleName)
{
    CUICicSystemModulePath path;

    if (!path.Init(lpModuleName))
         return NULL;

    return LoadLibrary(path.GetPath());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuiwnd.h ===
//
// cuiwnd.h
//  = UI object library - define UIWindow class =
//

#ifndef CUIWND_H
#define CUIWND_H

#include "cuiobj.h"
#include "cuischem.h"


class CUIFToolTip;
class CUIFShadow;

//
//
//

#define WND_DEF_X  200
#define WND_DEF_Y  200
#define WND_HEIGHT 200
#define WND_WIDTH  200

//
// CUIFWindow style
//

#define UIWINDOW_CHILDWND                       0x00000001
#define UIWINDOW_TOPMOST                        0x00000002
#define UIWINDOW_TOOLWINDOW                     0x00000004
#define UIWINDOW_WSDLGFRAME                     0x00000008
#define UIWINDOW_WSBORDER                       0x00000010
#define UIWINDOW_HASTOOLTIP                     0x00000020
#define UIWINDOW_HASSHADOW                      0x00000040
#define UIWINDOW_HABITATINWORKAREA              0x00000080
#define UIWINDOW_HABITATINSCREEN                0x00000100
#define UIWINDOW_LAYOUTRTL                      0x00000200
#define UIWINDOW_NOMOUSEMSGFROMSETCURSOR        0x00000400

#define UIWINDOW_OFC10MENU                      0x10000000
#define UIWINDOW_OFC10TOOLBAR                   0x20000000
#define UIWINDOW_OFC10WORKPANE                  0x40000000

#define UIWINDOW_OFFICENEWLOOK                  0x70000000  /* mask bit */

#define UIWINDOW_WHISTLERLOOK                   0x80000000

//
// misc definition
//

#define WM_GETOBJECT                    0x003D


//
// CUIFWindow
//  = UI window class =
//

class CUIFWindow : public CUIFObject
{
public:
    CUIFWindow( HINSTANCE hInst, DWORD dwStyle );
    virtual ~CUIFWindow( void );

    //
    // CUIFObject methods
    //
    virtual CUIFObject *Initialize( void );
    virtual void PaintObject( HDC hDC, const RECT *prcUpdate );
    virtual void RemoveUIObj( CUIFObject *pUIObj );

    virtual void SetRect( const RECT *prc );

    //
    // window functions
    //
    virtual LPCTSTR GetClassName( void );
    virtual LPCTSTR GetWndTitle( void );
    virtual DWORD GetWndStyle( void );
    virtual DWORD GetWndStyleEx( void );
    virtual HWND CreateWnd( HWND hWndParent );

    virtual void Show( BOOL fShow );
    virtual void Move( int x, int y, int nWidth, int nHeight );
    virtual BOOL AnimateWnd( DWORD dwTime, DWORD dwFlags );

    //
    // child object fucntions
    //
    void SetCaptureObject( CUIFObject *pUIObj );
    void SetTimerObject( CUIFObject *pUIObj, UINT uElapse = 0 );
    virtual void OnObjectMoved( CUIFObject *pUIObj );
    virtual void OnMouseOutFromWindow( POINT pt ) {}

    //
    // message handling functions
    //
    virtual void OnCreate( HWND hwnd )                                                      {}
    virtual void OnDestroy( HWND hwnd )                                                     {}
    virtual void OnNCDestroy( HWND hwnd )                                                   {}
    virtual void OnSetFocus( HWND hwnd )                                                    {}
    virtual void OnKillFocus( HWND hwnd )                                                   {}
    virtual void OnNotify( HWND hwnd, int nId, NMHDR *pmnh )                                {}
    virtual void OnTimer( UINT uiTimerID )                                                  {}
    virtual void OnSysColorChange( void )                                                   {}
    virtual void OnEndSession(HWND hwnd, WPARAM wParam, LPARAM lParam)                      {}
    virtual void OnKeyDown(HWND hwnd, WPARAM wParam, LPARAM lParam)                         {}
    virtual void OnKeyUp(HWND hwnd, WPARAM wParam, LPARAM lParam)                           {}
    virtual void OnUser(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)                 {}
    virtual LRESULT OnActivate(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)          { return DefWindowProc(hWnd, uMsg, wParam, lParam); }
    virtual LRESULT OnWindowPosChanged(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)  { return DefWindowProc(hWnd, uMsg, wParam, lParam); }
    virtual LRESULT OnWindowPosChanging(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)  { return DefWindowProc(hWnd, uMsg, wParam, lParam); }
    virtual LRESULT OnNotifyFormat(HWND hwnd, HWND hwndFrom, LPARAM lParam)                 { return 0; }
    virtual LRESULT OnShowWindow( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )      { return DefWindowProc(hWnd, uMsg, wParam, lParam); }
    virtual LRESULT OnSettingChange( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )   { return DefWindowProc(hWnd, uMsg, wParam, lParam); } 
    virtual LRESULT OnDisplayChange( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )   { return DefWindowProc(hWnd, uMsg, wParam, lParam); } 
    virtual LRESULT OnGetObject( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )       { return DefWindowProc(hWnd, uMsg, wParam, lParam); }
    virtual LRESULT WindowProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
    virtual LRESULT OnEraseBkGnd( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )       { return DefWindowProc(hWnd, uMsg, wParam, lParam); }
    virtual void OnThemeChanged(HWND hwnd, WPARAM wParam, LPARAM lParam);

    //
    // member accesss functions
    //
    __inline HWND GetWnd( void ) 
    {
        return m_hWnd;
    }

    __inline HINSTANCE GetInstance( void )
    {
        return m_hInstance;
    }

    __inline CUIFObject *GetCaptureObject( void )
    {
        return m_pUIObjCapture;
    }

    __inline CUIFObject *GetTimerObject( void )
    {
        return m_pTimerUIObj; 
    }

    __inline CUIFToolTip *GetToolTipWnd( void )
    {
        return m_pWndToolTip;
    }

    __inline void ClearToolTipWnd()
    {
        m_pWndToolTip = NULL;
    }

    __inline CUIFShadow *GetShadowWnd( void )
    {
        return m_pWndShadow;
    }

    __inline void ClearShadowWnd()
    {
        m_pWndShadow = NULL;
    }

    __inline BOOL EnableShadow(BOOL fShadowOn)
    {
        BOOL bRet = m_fShadowEnabled;
        m_fShadowEnabled = fShadowOn;
        return bRet;
    }

    __inline BOOL IsShadowEnabled()
    {
        return m_fShadowEnabled;
    }

    //
    // misc functions
    //
    virtual void UpdateUI(const RECT *prc = NULL) 
    {
        if (IsWindow( m_hWnd )) {
            InvalidateRect( m_hWnd, prc, FALSE );
        }
    }

    __inline void UpdateWindow( void )
    { 
        if (IsWindow( m_hWnd )) {
            ::UpdateWindow( m_hWnd );
        }
    }

    virtual void SetCapture( BOOL fSet);

    void SetBehindModal(CUIFWindow *pModalUIWnd);
    virtual void ModalMouseNotify( UINT uMsg, POINT pt) {};

    __inline BOOL IsPointed(CUIFObject *pUIObj)
    {
        return (m_pUIObjPointed == pUIObj) ? TRUE : FALSE;
    }

    virtual void OnAnimationStart( void );
    virtual void OnAnimationEnd( void );
    
protected:
    int _xWnd;
    int _yWnd;
    int _nHeight;
    int _nWidth;

    HINSTANCE      m_hInstance;
    HWND           m_hWnd;
    CUIFObject     *m_pTimerUIObj;
    CUIFObject     *m_pUIObjCapture;
    CUIFObject     *m_pUIObjPointed;
    BOOL           m_fCheckingMouse;
    CUIFWindow     *m_pBehindModalUIWnd;
    CUIFToolTip    *m_pWndToolTip;
    CUIFShadow     *m_pWndShadow;
    BOOL           m_fShadowEnabled;

    void CreateScheme();

    virtual void HandleMouseMsg( UINT uMsg, POINT pt );
    void SetObjectPointed( CUIFObject *pUIobj, POINT pt );
    virtual void ClientRectToWindowRect( RECT *prc );
    virtual void GetWindowFrameSize( SIZE *psize );
    static BOOL InitMonitorFunc();
    BOOL GetWorkArea(RECT *prcIn, RECT *prcOut);
    void AdjustWindowPosition();

    // static functions

    static LRESULT CALLBACK WindowProcedure( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );

    static __inline void SetThis( HWND hWnd, CUIFWindow *pUIWindow )
    {
        SetWindowLongPtr( hWnd, GWLP_USERDATA, (LONG_PTR)pUIWindow );
    }

    static __inline CUIFWindow *GetThis( HWND hWnd )
    {
        CUIFWindow *pUIWindow = (CUIFWindow *)GetWindowLongPtr( hWnd, GWLP_USERDATA );
        return pUIWindow;
    }

};

#endif /* CUIWND_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\delay.cpp ===
//
// delay.cpp
//
// Delay load imported functions for perf.
//

#include "private.h"
#include "ciccs.h"
#include "cuitheme.h"

//////////////////////////////////////////////////////////////////////////////
//
// Manifest Support
//
//////////////////////////////////////////////////////////////////////////////
extern HINSTANCE g_hInst;
extern CCicCriticalSectionStatic g_cs;
#ifdef DEBUG
extern DWORD g_dwThreadDllMain;
#endif

typedef HANDLE (WINAPI *PFNCREATEACTCTXA)(PCACTCTXA pActCtx);
typedef VOID (WINAPI *PFNRELEASEACTCTX)( HANDLE hActCtx );
typedef BOOL (WINAPI *PFNACTIVATEACTCTX)( HANDLE hActCtx, ULONG_PTR *lpCookie );
typedef BOOL (WINAPI *PFNDEACTIVATEACTCTX)( DWORD dwFlags, ULONG_PTR ulCookie );

static PFNCREATEACTCTXA     s_pfnCreateActCtxA = NULL;
static PFNRELEASEACTCTX     s_pfnReleaseActCtx = NULL;
static PFNACTIVATEACTCTX    s_pfnActivateActCtx = NULL;
static PFNDEACTIVATEACTCTX  s_pfnDeactivateActCtx = NULL;
static BOOL s_InitActAPI = FALSE;

//+---------------------------------------------------------------------------
//
// InitActAPI
//
//+---------------------------------------------------------------------------

void InitActAPI()
{
    if (s_InitActAPI)
        return;

    HMODULE hModKernel32 = CUIGetSystemModuleHandle("kernel32.dll");

    if (!hModKernel32)
        return;

    s_pfnCreateActCtxA = (PFNCREATEACTCTXA)GetProcAddress(hModKernel32, "CreateActCtxA");
    s_pfnReleaseActCtx = (PFNRELEASEACTCTX)GetProcAddress(hModKernel32, "ReleaseActCtx");
    s_pfnActivateActCtx = (PFNACTIVATEACTCTX)GetProcAddress(hModKernel32, "ActivateActCtx");
    s_pfnDeactivateActCtx = (PFNDEACTIVATEACTCTX)GetProcAddress(hModKernel32, "DeactivateActCtx");
    s_InitActAPI = TRUE;
}

//+---------------------------------------------------------------------------
//
// CUICreateActCtx
//
//+---------------------------------------------------------------------------

HANDLE CUICreateActCtx(PCACTCTXA pActCtx)
{
    InitActAPI();
    if (!s_pfnCreateActCtxA)
        return NULL;

    return s_pfnCreateActCtxA(pActCtx);
}

//+---------------------------------------------------------------------------
//
// CUIReleaseActCtx
//
//+---------------------------------------------------------------------------

VOID CUIReleaseActCtx( HANDLE hActCtx )
{
    InitActAPI();
    if (!s_pfnReleaseActCtx)
        return;

    s_pfnReleaseActCtx(hActCtx);
}

//+---------------------------------------------------------------------------
//
// CUIActivateActCtx
//
//+---------------------------------------------------------------------------

BOOL CUIActivateActCtx( HANDLE hActCtx, ULONG_PTR *lpCookie )
{
    InitActAPI();
    if (!s_pfnActivateActCtx)
        return FALSE;

    return s_pfnActivateActCtx(hActCtx, lpCookie);
}

//+---------------------------------------------------------------------------
//
// CUIDeactivateActCtx
//
//+---------------------------------------------------------------------------

BOOL CUIDeactivateActCtx( DWORD dwFlags, ULONG_PTR ulCookie )
{
    InitActAPI();
    if (!s_pfnDeactivateActCtx)
        return FALSE;

    return s_pfnDeactivateActCtx(dwFlags, ulCookie);
}


//////////////////////////////////////////////////////////////////////////////
//
// DelayLoad 
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// CUIGetFn
//
//+---------------------------------------------------------------------------

FARPROC CUIGetFn(HINSTANCE *phInst, TCHAR *pchLib, TCHAR *pchFunc, int nManifestResource)
{
    Assert(g_dwThreadDllMain != GetCurrentThreadId());

    if (*phInst == 0)
    {
        TCHAR szPath[MAX_PATH];
        HANDLE hActCtx = INVALID_HANDLE_VALUE;
        ULONG_PTR ulCookie = 0;

        EnterCriticalSection(g_cs);

        _try {
            _try {
                if (nManifestResource > 0)
                {
                    GetModuleFileName(g_hInst, szPath, sizeof(szPath));
    
                    ACTCTX act = {0};
                    act.cbSize = sizeof(act);
                    act.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID;
                    act.lpResourceName = MAKEINTRESOURCE(nManifestResource);
                    act.lpSource = szPath;
                    hActCtx = CUICreateActCtx(&act);
                    if (hActCtx != INVALID_HANDLE_VALUE)
                        CUIActivateActCtx(hActCtx, &ulCookie);
                }
    
                *phInst = LoadLibrary(pchLib);
            }
            _except(1)
            {
                Assert(0);
            }

            if (ulCookie)
                CUIDeactivateActCtx(0, ulCookie);

            if (hActCtx != INVALID_HANDLE_VALUE)
                CUIReleaseActCtx(hActCtx);
        }
        _except(1)
        {
            Assert(0);
        }

        LeaveCriticalSection(g_cs);
    }

    if (*phInst == 0)
    {
        //
        // new dlls in whistler are not in downlevels.
        //
        // Assert(0);
        return NULL;
    }

    return GetProcAddress(*phInst, pchFunc);
}

#define DELAYLOAD(_hInst, _DllName, _ManifestResource, _CallConv, _FuncName, _Args1, _Args2, _RetType, _ErrVal)   \
_RetType _CallConv CUI ## _FuncName ## _Args1                                             \
{                                                                               \
    static FARPROC pfn = NULL;                                                  \
                                                                                \
    if (pfn == NULL || _hInst == NULL)                                          \
    {                                                                           \
        pfn = CUIGetFn(&_hInst, #_DllName, #_FuncName, _ManifestResource);      \
                                                                                \
        if (pfn == NULL)                                                        \
        {                                                                       \
            return (_RetType) _ErrVal;                                          \
        }                                                                       \
    }                                                                           \
                                                                                \
    return ((_RetType (_CallConv *)_Args1) (pfn)) _Args2;                       \
}

//
// comctl32.dll
//

HINSTANCE g_hComctl32 = 0;
#define DELAYLOADCOMCTL32(_FuncName, _Args1, _Args2, _RetType, _ErrVal)   \
    DELAYLOAD(g_hComctl32, comctl32.dll, 1, WINAPI, _FuncName, _Args1, _Args2, _RetType, _ErrVal)

DELAYLOADCOMCTL32(ImageList_Create, (int cx, int cy, UINT flags, int cInitial, int cGrow), (cx, cy, flags, cInitial, cGrow), HIMAGELIST, NULL)
DELAYLOADCOMCTL32(ImageList_Destroy, (HIMAGELIST himl), (himl), BOOL, FALSE)
DELAYLOADCOMCTL32(ImageList_ReplaceIcon, (HIMAGELIST himl, int i, HICON hIcon), (himl, i, hIcon), BOOL, FALSE)

//
// uxtheme.dll
//

HINSTANCE g_hUsTheme = 0;
#define DELAYLOADUSTHEME(_FuncName, _Args1, _Args2, _RetType, _ErrVal)   \
    DELAYLOAD(g_hUsTheme, uxtheme.dll, -1, WINAPI, _FuncName, _Args1, _Args2, _RetType, _ErrVal)

DELAYLOADUSTHEME(IsThemeActive, (void), (), BOOL, FALSE)

DELAYLOADUSTHEME(OpenThemeData,  (HWND hwnd, LPCWSTR pszClassList), (hwnd, pszClassList), HTHEME, NULL)

DELAYLOADUSTHEME(CloseThemeData, (HTHEME hTheme), (hTheme), HRESULT, E_FAIL)

DELAYLOADUSTHEME(SetWindowTheme, (HWND hwnd, LPCWSTR pszSubAppname, LPCWSTR pszSubIdList), (hwnd, pszSubAppname, pszSubIdList), HRESULT, E_FAIL)

DELAYLOADUSTHEME(DrawThemeBackground,  ( HTHEME hTheme, HDC hDC, int iPartId, int iStateId, const RECT *pRect, DWORD dwBgFlags ), ( hTheme, hDC, iPartId, iStateId, pRect, dwBgFlags ), HRESULT, E_FAIL)
DELAYLOADUSTHEME(DrawThemeParentBackground,  ( HWND hwnd, HDC hDC, const RECT *pRect ), ( hwnd, hDC, pRect), HRESULT, E_FAIL)

DELAYLOADUSTHEME(DrawThemeText,  ( HTHEME hTheme, HDC hDC, int iPartId, int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, DWORD dwTextFlags2, const RECT *pRect ), ( hTheme, hDC, iPartId, iStateId, pszText, iCharCount, dwTextFlags, dwTextFlags2, pRect ), HRESULT, E_FAIL)

DELAYLOADUSTHEME(DrawThemeIcon,  ( HTHEME hTheme, HDC hDC, int iPartId, int iStateId, const RECT *pRect, HIMAGELIST himl, int iImageIndex ), ( hTheme, hDC, iPartId, iStateId, pRect, himl, iImageIndex ), HRESULT, E_FAIL)

DELAYLOADUSTHEME(GetThemeBackgroundExtent,  ( HTHEME hTheme, HDC hDC, int iPartId, int iStateId, const RECT *pContentRect, RECT *pExtentRect ), ( hTheme, hDC, iPartId, iStateId, pContentRect, pExtentRect ), HRESULT, E_FAIL)

DELAYLOADUSTHEME(GetThemeBackgroundContentRect,  ( HTHEME hTheme, HDC hDC, int iPartId, int iStateId, const RECT *pBoundingRect, RECT *pContentRect ), ( hTheme, hDC, iPartId, iStateId, pBoundingRect, pContentRect ), HRESULT, E_FAIL)

DELAYLOADUSTHEME(GetThemeTextExtent,  ( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, const RECT *pBoundingRect, RECT *pExtentRect ), ( hTheme, hdc, iPartId, iStateId, pszText, iCharCount, dwTextFlags, pBoundingRect, pExtentRect ), HRESULT, E_FAIL)

DELAYLOADUSTHEME(GetThemePartSize,  ( HTHEME hTheme, HDC hDC, int iPartId, int iStateId, RECT *prc, enum THEMESIZE eSize, SIZE *pSize ), ( hTheme, hDC, iPartId, iStateId, prc, eSize, pSize ), HRESULT, E_FAIL)

DELAYLOADUSTHEME(DrawThemeEdge, (HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pDestRect, UINT uEdge, UINT uFlags, RECT *pContentRect), (hTheme, hdc, iPartId, iStateId, pDestRect, uEdge, uFlags, pContentRect), HRESULT , E_FAIL);

DELAYLOADUSTHEME(GetThemeColor, (HTHEME hTheme, int iPartId, int iStateId, int iPropId, COLORREF *pColor), (hTheme, iPartId, iStateId, iPropId, pColor), HRESULT , E_FAIL);

DELAYLOADUSTHEME(GetThemeMargins, (HTHEME hTheme, HDC hdc, int iPartId, int iStateId, int iPropId, RECT *prc, MARGINS *pMargins), (hTheme, hdc, iPartId, iStateId, iPropId, prc, pMargins), HRESULT , E_FAIL);

DELAYLOADUSTHEME(GetThemeFont, (HTHEME hTheme, HDC hdc, int iPartId, int iStateId, int iPropId, LOGFONTW *plf), (hTheme, hdc, iPartId, iStateId, iPropId, plf), HRESULT , E_FAIL);

DELAYLOADUSTHEME(GetThemeSysColor, (HTHEME hTheme, int iColorId), (hTheme, iColorId), COLORREF , 0);
DELAYLOADUSTHEME(GetThemeSysSize, (HTHEME hTheme, int iSizeId), (hTheme, iSizeId), int , 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\cuilib\cuiwnd.cpp ===
//
// cuiwnd.cpp
//

#include "private.h"
#include "cuiwnd.h"
#include "cuiobj.h"
#include "cuitip.h"
#include "cuishadw.h"
#include "cuischem.h"
#include "cuisys.h"
#include "cuiutil.h"


#define UIWINDOW_CLASSNAME          "CiceroUIWndFrame"
#define UIWINDOW_TITLE              "CiceroUIWndFrame"

// TIMER IDs

#define idTimer_UIObject            0x5461
#define idTimer_MonitorMouse        0x7982

//  if this is too small like 100ms, tooltip does not work correctly.
#define iElapse_MonitorMouse        1000


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  W I N D O W                                                     */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  W I N D O W   */
/*------------------------------------------------------------------------------

    Constructor of CUIFWindow

------------------------------------------------------------------------------*/
CUIFWindow::CUIFWindow( HINSTANCE hInst, DWORD dwStyle ) : CUIFObject( NULL /* no parent */, 0 /* no ID */, NULL /* no rectangle */, dwStyle )
{

    m_hInstance = hInst;
        _xWnd = WND_DEF_X;
        _yWnd = WND_DEF_Y;
        _nWidth = WND_WIDTH;
        _nHeight = WND_HEIGHT;
    m_hWnd           = NULL;
    m_pUIWnd         = this;
    m_pUIObjCapture  = NULL;
    m_pTimerUIObj    = NULL;
    m_pUIObjPointed  = NULL;
    m_fCheckingMouse = FALSE;
    m_pWndToolTip    = NULL;
    m_pWndShadow     = NULL;
    m_fShadowEnabled = TRUE;
    m_pBehindModalUIWnd = NULL;

    CreateScheme();
}


void CUIFWindow::CreateScheme()
{
    if (m_pUIFScheme)
       delete m_pUIFScheme;

    // create scheme

    UIFSCHEME scheme;
    scheme = UIFSCHEME_DEFAULT;
    if (FHasStyle( UIWINDOW_OFC10MENU )) {
        scheme = UIFSCHEME_OFC10MENU;
    } 
    else if (FHasStyle( UIWINDOW_OFC10TOOLBAR )) {
        scheme = UIFSCHEME_OFC10TOOLBAR;
    }
    else if (FHasStyle( UIWINDOW_OFC10WORKPANE )) {
        scheme = UIFSCHEME_OFC10WORKPANE;
    }
    
    m_pUIFScheme = CreateUIFScheme( scheme );
    Assert( m_pUIFScheme != NULL );

    SetScheme(m_pUIFScheme);
}


/*   ~ C  U I F  W I N D O W   */
/*------------------------------------------------------------------------------

    Destructor of CUIFWindow

------------------------------------------------------------------------------*/
CUIFWindow::~CUIFWindow( void )
{
    CUIFObject *pUIObj;

    Assert( !m_hWnd || !GetThis(m_hWnd) );

    // delete tooltip/shadow
    
    if (m_pWndToolTip != NULL) {
        delete m_pWndToolTip;
    }

    if (m_pWndShadow != NULL) {
        delete m_pWndShadow;
    }

    // delete all childlen

    while (pUIObj = m_ChildList.GetLast()) {
        m_ChildList.Remove( pUIObj );
        delete pUIObj;
    }

    // dispose scheme

    if (m_pUIFScheme)
        delete m_pUIFScheme;
}


/*   I N I T I A L I Z E   */
/*------------------------------------------------------------------------------

    Initialize UI window object
    (UIFObject method)

------------------------------------------------------------------------------*/
CUIFObject *CUIFWindow::Initialize( void )
{
    LPCTSTR pszClassName = GetClassName();
    WNDCLASSEX WndClass;
    
    // register window class

    MemSet( &WndClass, 0, sizeof(WndClass));
    WndClass.cbSize = sizeof( WndClass );

    if (!GetClassInfoEx( m_hInstance, pszClassName, &WndClass )) {
        MemSet( &WndClass, 0, sizeof(WndClass));

        WndClass.cbSize        = sizeof( WndClass );
        WndClass.style         = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
        WndClass.lpfnWndProc   = WindowProcedure;
        WndClass.cbClsExtra    = 0;
        WndClass.cbWndExtra    = 8;
        WndClass.hInstance     = m_hInstance;
        WndClass.hIcon         = NULL;
        WndClass.hCursor       = LoadCursor( NULL, IDC_ARROW );
        WndClass.hbrBackground = NULL;
        WndClass.lpszMenuName  = NULL;
        WndClass.lpszClassName = pszClassName;
        WndClass.hIconSm       = NULL;

        RegisterClassEx( &WndClass );
    }

    // update scheme

    UpdateUIFSys();
    UpdateUIFScheme();

    // create tooltip 

    if (FHasStyle( UIWINDOW_HASTOOLTIP )) {
        m_pWndToolTip = new CUIFToolTip( m_hInstance, UIWINDOW_TOPMOST | UIWINDOW_WSBORDER | (FHasStyle( UIWINDOW_LAYOUTRTL ) ? UIWINDOW_LAYOUTRTL : 0), this);
        if (m_pWndToolTip)
            m_pWndToolTip->Initialize();
    }

    // create shadow

    if (FHasStyle( UIWINDOW_HASSHADOW )) {
        m_pWndShadow = new CUIFShadow( m_hInstance, UIWINDOW_TOPMOST, this );
        if (m_pWndShadow)
            m_pWndShadow->Initialize();
    }

    return CUIFObject::Initialize();
}


/*   P A I N T  O B J E C T   */
/*------------------------------------------------------------------------------

    Paint window object
    (UIFObject method)

------------------------------------------------------------------------------*/
void CUIFWindow::PaintObject( HDC hDC, const RECT *prcUpdate )
{
    BOOL     fReleaseDC = FALSE;
    HDC      hDCMem;
    HBITMAP  hBmpMem;
    HBITMAP  hBmpOld;

    if (hDC == NULL) {
        hDC = GetDC( m_hWnd );
        fReleaseDC = TRUE;
    }

    if (prcUpdate == NULL) {
        prcUpdate = &GetRectRef();
    }

    // prepare memory dc

    hDCMem = CreateCompatibleDC( hDC );
    if (!hDCMem) {
        return;
    }

    hBmpMem = CreateCompatibleBitmap( hDC, 
                                      prcUpdate->right - prcUpdate->left, 
                                      prcUpdate->bottom - prcUpdate->top );
    
    if (hBmpMem) {
        hBmpOld = (HBITMAP)SelectObject( hDCMem, hBmpMem );

        // paint to memory dc

        BOOL fRetVal = SetViewportOrgEx( hDCMem, -prcUpdate->left, -prcUpdate->top, NULL );
        Assert( fRetVal );

        //
        // theme support
        //
        BOOL fDefault = TRUE;
        if (SUCCEEDED(EnsureThemeData(GetWnd())))
        {
            if (FHasStyle( UIWINDOW_CHILDWND ) &&
                SUCCEEDED(DrawThemeParentBackground(GetWnd(),
                                                    hDCMem, 
                                                    &GetRectRef())))
            {
                   fDefault = FALSE;
            }
            else if (SUCCEEDED(DrawThemeBackground(hDCMem, 
                                              GetDefThemeStateID(), 
                                              &GetRectRef(),
                                              0 )))
                   fDefault = FALSE;
        }

        if (fDefault)
        {
            if (m_pUIFScheme)
                m_pUIFScheme->FillRect( hDCMem, prcUpdate, UIFCOLOR_WINDOW );
        }

        //

        CUIFObject::PaintObject( hDCMem, prcUpdate );


        // transfer image to screen

        BitBlt( hDC, 
                prcUpdate->left, 
                prcUpdate->top, 
                prcUpdate->right - prcUpdate->left, 
                prcUpdate->bottom - prcUpdate->top, 
                hDCMem, 
                prcUpdate->left, 
                prcUpdate->top, 
                SRCCOPY );

        SelectObject( hDCMem, hBmpOld );
        DeleteObject( hBmpMem );
    }
    DeleteDC( hDCMem );
    
    if (fReleaseDC) {
        ReleaseDC( m_hWnd, hDC );
    }
}


/*   G E T  C L A S S  N A M E   */
/*------------------------------------------------------------------------------

    Get class name

------------------------------------------------------------------------------*/
LPCTSTR CUIFWindow::GetClassName( void )
{
    return TEXT( UIWINDOW_CLASSNAME );
}


/*   G E T  W I N D O W  T I T L E   */
/*------------------------------------------------------------------------------

    Get window title

------------------------------------------------------------------------------*/
LPCTSTR CUIFWindow::GetWndTitle( void )
{
    return TEXT( UIWINDOW_TITLE );
}


/*   G E T  W N D  S T Y L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
DWORD CUIFWindow::GetWndStyle( void )
{
    DWORD dwWndStyle = 0;

    // determine style

    if (FHasStyle( UIWINDOW_CHILDWND )) {
        dwWndStyle |= WS_CHILD | WS_CLIPSIBLINGS;
    }
    else {
        dwWndStyle |= WS_POPUP | WS_DISABLED;
    }

    if (FHasStyle( UIWINDOW_OFC10MENU )) {
        dwWndStyle |= WS_BORDER;
    }
    else if (FHasStyle( UIWINDOW_WSDLGFRAME )) {
        dwWndStyle |= WS_DLGFRAME;
    }
    else if (FHasStyle( UIWINDOW_OFC10TOOLBAR )) {
        dwWndStyle |= WS_BORDER;
    }
    else if (FHasStyle( UIWINDOW_WSBORDER )) {
        dwWndStyle |= WS_BORDER;
    }

    return dwWndStyle;
}


/*   G E T  W N D  S T Y L E  E X   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
DWORD CUIFWindow::GetWndStyleEx( void )
{
    DWORD dwWndStyleEx = 0;

    // determine ex style

    if (FHasStyle( UIWINDOW_TOPMOST )) {
        dwWndStyleEx |= WS_EX_TOPMOST;
    }

    if (FHasStyle( UIWINDOW_TOOLWINDOW )) {
        dwWndStyleEx |= WS_EX_TOOLWINDOW;
    }

    if (FHasStyle( UIWINDOW_LAYOUTRTL )) {
        dwWndStyleEx |= WS_EX_LAYOUTRTL;
    }

    return dwWndStyleEx;
}


/*   C R E A T E  W N D   */
/*------------------------------------------------------------------------------

    Create window

------------------------------------------------------------------------------*/
HWND CUIFWindow::CreateWnd( HWND hWndParent )
{
    HWND  hWnd;

    // create window
    
    hWnd = CreateWindowEx( GetWndStyleEx(),     /* ex style             */
                            GetClassName(),     /* class name           */
                            GetWndTitle(),      /* window title         */
                            GetWndStyle(),      /* window style         */
                            _xWnd,              /* initial position (x) */
                            _yWnd,              /* initial position (y) */
                            _nWidth,            /* initial width        */
                            _nHeight,           /* initial height       */
                            hWndParent,         /* parent winodw        */
                            NULL,               /* menu handle          */
                            m_hInstance,        /* instance             */
                            this );             /* lpParam              */

    // create tooltip window

    if (m_pWndToolTip != NULL) {
        m_pWndToolTip->CreateWnd( hWnd );
    }

    // create shadow window

    if (m_pWndShadow != NULL) {
        m_pWndShadow->CreateWnd( hWnd );
    }

    return hWnd;
}


/*   S H O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWindow::Show( BOOL fShow )
{
    if (IsWindow( m_hWnd )) {

        if (fShow && FHasStyle( UIWINDOW_TOPMOST ))
            SetWindowPos(m_hWnd, HWND_TOP, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);

        m_fVisible = fShow;
        ShowWindow( m_hWnd, fShow ? SW_SHOWNOACTIVATE : SW_HIDE );
    }
}


/*   M O V E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWindow::Move(int x, int y, int nWidth, int nHeight)
{
    _xWnd = x;
    _yWnd = y;

    if (nWidth >= 0)
        _nWidth = nWidth;

    if (nHeight >= 0)
        _nHeight = nHeight;

    if (IsWindow(m_hWnd)) {
        AdjustWindowPosition();
        MoveWindow(m_hWnd, _xWnd, _yWnd, _nWidth, _nHeight, TRUE);
    }
}


/*   A N I M A T E  W N D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CUIFWindow::AnimateWnd( DWORD dwTime, DWORD dwFlags )
{
    BOOL fRet = FALSE;
    
    if (!IsWindow( GetWnd() )) {
        return FALSE;
    }

    if (CUIIsAnimateWindowAvail()) {
        BOOL fVisibleOrg = m_fVisible;

        // HACK!
        // AnimateWindow never send WM_SHOWWINDOW message.
        // Need to set visible state before call AnimateWindow because
        // it need to be turned on in OnPaint() to handle WM_PRINTCLIENT 
        // message.  If animate window failed, restore it to original state.

        if ((dwFlags & AW_HIDE) == 0) {
            m_fVisible = TRUE;
        }
        else {
            m_fVisible = FALSE;
        }

        OnAnimationStart();

        // get system settings about animation
        
        fRet = CUIAnimateWindow( GetWnd(), dwTime, dwFlags );

        if (!fRet) {
            m_fVisible = fVisibleOrg;
        }

        OnAnimationEnd();
    }

    return fRet;
}


/*   R E M O V E  U I  O B J   */
/*------------------------------------------------------------------------------

    Remove child UI object

------------------------------------------------------------------------------*/
void CUIFWindow::RemoveUIObj( CUIFObject *pUIObj )
{
    if (pUIObj == m_pUIObjCapture) {
        // release capture before remove

        SetCaptureObject( NULL );
    } 
    if (pUIObj == m_pTimerUIObj) {
        // kill timer before remove

        SetTimerObject( NULL );
    } 
    if (pUIObj == m_pUIObjPointed) {
        // no object pointed...

        m_pUIObjPointed = NULL;
    }

    CUIFObject::RemoveUIObj( pUIObj );
}


/*   S E T  C A P T U R E  O B J E C T   */
/*------------------------------------------------------------------------------

    Set capture object
    Start/end capturing mouse

------------------------------------------------------------------------------*/
void CUIFWindow::SetCaptureObject( CUIFObject *pUIObj )
{
    if (pUIObj != NULL) {
        // start capture

        m_pUIObjCapture = pUIObj;
        SetCapture( TRUE );
    } else {
        // end capture

        m_pUIObjCapture = NULL;
        SetCapture( FALSE );
    }
}

/*   S E T  C A P T U R E  O B J E C T   */
/*------------------------------------------------------------------------------

    Set capture 
    Start/end capturing mouse

------------------------------------------------------------------------------*/
void CUIFWindow::SetCapture(BOOL fSet)
{
    if (fSet) {
        ::SetCapture( m_hWnd );
    } else {
        ::ReleaseCapture();
    }
}

/*   S E T  C A P T U R E  O B J E C T   */
/*------------------------------------------------------------------------------

    Set capture object
    Start/end capturing mouse

------------------------------------------------------------------------------*/
void CUIFWindow::SetBehindModal(CUIFWindow *pModalUIWnd)
{
    m_pBehindModalUIWnd = pModalUIWnd;
}


/*   S E T  T I M E R  O B J E C T   */
/*------------------------------------------------------------------------------

    Set timer object
    Make/kill timer

------------------------------------------------------------------------------*/
void CUIFWindow::SetTimerObject( CUIFObject *pUIObj, UINT uElapse )
{
    if (pUIObj != NULL) {
        // make timer

        Assert( uElapse != 0 );
        m_pTimerUIObj = pUIObj;
        SetTimer( m_hWnd, idTimer_UIObject, uElapse, NULL );
    } else {
        // kill timer

        Assert( uElapse == 0 );
        m_pTimerUIObj = NULL;
        KillTimer( m_hWnd, idTimer_UIObject );
    }
}


/*   H A N D L E  M O U S E  M S G   */
/*------------------------------------------------------------------------------

    Mouse message handler
    Pass mouse message to appropriate UI object (capturing/monitoring/under 
    the cursor)

------------------------------------------------------------------------------*/
void CUIFWindow::HandleMouseMsg( UINT uMsg, POINT pt )
{
    CUIFObject *pUIObj = ObjectFromPoint( pt );

    // check mouse in/out

    SetObjectPointed( pUIObj, pt );

    // find UI object to handle mouse message

    if (m_pUIObjCapture != NULL) {
        pUIObj = m_pUIObjCapture; 
    }

    // set cursor

    if (pUIObj == NULL || !pUIObj->OnSetCursor( uMsg, pt )) {
        SetCursor( LoadCursor( NULL, IDC_ARROW ) );
    }

    // handle mouse message

    if (pUIObj != NULL && pUIObj->IsEnabled()) {
        switch (uMsg) {
            case WM_MOUSEMOVE: {
                pUIObj->OnMouseMove( pt );
                break;
            }

            case WM_LBUTTONDOWN: {
                pUIObj->OnLButtonDown( pt );
                break;
            }

            case WM_MBUTTONDOWN: {
                pUIObj->OnMButtonDown( pt );
                break;
            }

            case WM_RBUTTONDOWN: {
                pUIObj->OnRButtonDown( pt );
                break;
            }

            case WM_LBUTTONUP: {
                pUIObj->OnLButtonUp( pt );
                break;
            }

            case WM_MBUTTONUP: {
                pUIObj->OnMButtonUp( pt );
                break;
            }
            case WM_RBUTTONUP: {
                pUIObj->OnRButtonUp( pt );
                break;
            }
        } /* of switch */
    }
}


/*   S E T  O B J E C T  P O I N T E D   */
/*------------------------------------------------------------------------------

    Set UI object pointed (the UI object under cursor)
    Notify MouseIn/Out to the object when changed

------------------------------------------------------------------------------*/
void CUIFWindow::SetObjectPointed( CUIFObject *pUIObj, POINT pt )
{
    if (pUIObj != m_pUIObjPointed) {
        // notify mouse out

        if (m_pUIObjCapture != NULL) {
            // notify only to capturing object

            if (m_pUIObjCapture == m_pUIObjPointed && m_pUIObjPointed->IsEnabled()) {
                m_pUIObjPointed->OnMouseOut( pt );
            }
        } else {
            if (m_pUIObjPointed != NULL && m_pUIObjPointed->IsEnabled()) {
                m_pUIObjPointed->OnMouseOut( pt );
            }
        }

        // set object pointed (object under the cursor)

        m_pUIObjPointed = pUIObj;

        // notify mouse in

        if (m_pUIObjCapture != NULL) {
            // notify only to capturing object

            if (m_pUIObjCapture == m_pUIObjPointed && m_pUIObjPointed->IsEnabled()) {
                m_pUIObjPointed->OnMouseIn( pt );
            }
        } else {
            if (m_pUIObjPointed != NULL && m_pUIObjPointed->IsEnabled()) {
                m_pUIObjPointed->OnMouseIn( pt );
            }
        }
    }
}


/*   O N  O B J E C T  M O V E D   */
/*------------------------------------------------------------------------------

    Called when the UI object has been moved
    Check mouse in/out for the object

------------------------------------------------------------------------------*/
void CUIFWindow::OnObjectMoved( CUIFObject *pUIObj )
{
    POINT pt;

    if (IsWindow( m_hWnd )) {
        // set object pointed to check mouse in/out

        GetCursorPos( &pt );
        ScreenToClient( m_hWnd, &pt );

        SetObjectPointed( ObjectFromPoint( pt ), pt );
    }
}


/*   S E T  R E C T   */
/*------------------------------------------------------------------------------

    Set rect of object
    (CUIFObject method)

------------------------------------------------------------------------------*/
void CUIFWindow::SetRect( const RECT * /*prc*/ )
{
    RECT rc = { 0, 0, 0, 0 };

    if (IsWindow( GetWnd() )) {
        GetClientRect( GetWnd(), &rc );
    }

    CUIFObject::SetRect( &rc );
}


/*   C L I E N T  R E C T  T O  W I N D O W  R E C T   */
/*------------------------------------------------------------------------------

    Get window rect from client rect

------------------------------------------------------------------------------*/
void CUIFWindow::ClientRectToWindowRect( RECT *prc )
{
    DWORD dwWndStyle;
    DWORD dwWndStyleEx;

    if (IsWindow( m_hWnd )) {
        dwWndStyle   = GetWindowLong( m_hWnd, GWL_STYLE );
        dwWndStyleEx = GetWindowLong( m_hWnd, GWL_EXSTYLE );
    }
    else {
        dwWndStyle   = GetWndStyle();
        dwWndStyleEx = GetWndStyleEx();
    }

    Assert( prc != NULL );
    AdjustWindowRectEx( prc, dwWndStyle, FALSE, dwWndStyleEx );
}


/*   G E T  W I N D O W  F R A M E  S I Z E   */
/*------------------------------------------------------------------------------

    Get window frame size

------------------------------------------------------------------------------*/
void CUIFWindow::GetWindowFrameSize( SIZE *psize )
{
    RECT rc = { 0, 0, 0, 0 };

    Assert( psize != NULL );

    ClientRectToWindowRect( &rc );
    psize->cx = (rc.right - rc.left) / 2;
    psize->cy = (rc.bottom - rc.top) / 2;
}


/*   O N  A N I M A T I O N  S T A R T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWindow::OnAnimationStart( void )
{

}


/*   O N  A N I M A T I O N  E N D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWindow::OnAnimationEnd( void )
{
    // show/hide shadow

    if (m_pWndShadow && m_fShadowEnabled) {
        m_pWndShadow->Show( m_fVisible );
    }
}


/*   O N  T H E M E C H A N G E D
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWindow::OnThemeChanged(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    ClearTheme();
}

/*   W I N D O W  P R O C   */
/*------------------------------------------------------------------------------

    Window procedure of the object
    This function is called from WindowProcedure which is actual callback 
    function to handle message.

------------------------------------------------------------------------------*/
LRESULT CUIFWindow::WindowProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch( uMsg ) {
        case WM_CREATE: {
            // store rects

            SetRect( NULL );

            OnCreate(hWnd);
            break;
        }

        case WM_SETFOCUS: {
            OnSetFocus(hWnd);
            break;
        }

        case WM_KILLFOCUS: {
            OnKillFocus(hWnd);
            break;
        }

        case WM_SIZE: {
            // store rects

            SetRect( NULL );
            break;
        }

        case WM_SETCURSOR: {
            POINT pt;

            // get current cursor pos

            GetCursorPos( &pt );
            ScreenToClient( m_hWnd, &pt );

            if (m_pBehindModalUIWnd)
            {
                m_pBehindModalUIWnd->ModalMouseNotify( HIWORD(lParam), pt );
                return TRUE;
            }

            // start checking mouse in/out

            if (!m_fCheckingMouse) {
                SetTimer( m_hWnd, idTimer_MonitorMouse, iElapse_MonitorMouse, NULL );
                m_fCheckingMouse = TRUE;
            }

            // tooltip

            if (m_pWndToolTip != NULL) {
                MSG msg;

                msg.hwnd    = GetWnd();
                msg.message = HIWORD(lParam);
                msg.wParam  = 0;
                msg.lParam  = MAKELPARAM( pt.x, pt.y );
                m_pWndToolTip->RelayEvent( &msg );
            }

            // handle mouse message

            if (!FHasStyle( UIWINDOW_NOMOUSEMSGFROMSETCURSOR ))
                HandleMouseMsg( HIWORD(lParam), pt );
            return TRUE;
        }

        case WM_MOUSEACTIVATE: {
            return MA_NOACTIVATE;
        }

        case WM_MOUSEMOVE:
        case WM_LBUTTONDOWN:
        case WM_MBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_LBUTTONUP:
        case WM_MBUTTONUP:
        case WM_RBUTTONUP: {
            POINT pt;
            POINTSTOPOINT( pt, MAKEPOINTS( lParam ) );

            if (m_pBehindModalUIWnd) {
                m_pBehindModalUIWnd->ModalMouseNotify( uMsg, pt );
                break;
            }

            // handle mouse message

            HandleMouseMsg( uMsg, pt );
            break;
        }

        case WM_NOTIFY: {
            OnNotify(hWnd, (int)wParam, (NMHDR *)lParam);
            break;
        }

        case WM_NOTIFYFORMAT: {
            return OnNotifyFormat(hWnd, (HWND)wParam, lParam);
            break;
        }

        case WM_KEYDOWN: {
            OnKeyDown(hWnd, wParam, lParam);
            return 0;
        }

        case WM_KEYUP: {
            OnKeyUp(hWnd, wParam, lParam);
            return 0;
        }

        case WM_PAINT: {
            HDC hDC;
            PAINTSTRUCT ps;

            hDC = BeginPaint( hWnd, &ps );
            PaintObject( hDC, &ps.rcPaint );
            EndPaint( hWnd, &ps );
            break;
        }

        case WM_PRINTCLIENT: {
            HDC hDC = (HDC)wParam;

            PaintObject( hDC, NULL );
            break;
        }

        case WM_DESTROY: {
            if (m_pWndToolTip) {
                if (IsWindow( m_pWndToolTip->GetWnd() )) {
                    DestroyWindow( m_pWndToolTip->GetWnd() );
                }
            }

            if (m_pWndShadow) {
                if (IsWindow( m_pWndShadow->GetWnd() )) {
                    DestroyWindow( m_pWndShadow->GetWnd() );
                }
            }

            OnDestroy(hWnd);
            break;
        }

        case WM_NCDESTROY: {
            OnNCDestroy(hWnd);
            break;
        }

        case WM_COMMAND: {
            break;
        }

        case WM_TIMER: {
            switch (wParam) {
                case idTimer_MonitorMouse: {
                    POINT pt;
                    POINT ptClient;
                    RECT  rc;
                    BOOL  fMouseOut;

                    // get current cursor pos

                    GetCursorPos( &pt );
                    ptClient = pt;
                    ScreenToClient( m_hWnd, &ptClient );

                    // check if mouse is outside of the window

                    GetWindowRect( m_hWnd, &rc );
                    fMouseOut = (!PtInRect( &rc, pt ) || WindowFromPoint( pt ) != m_hWnd);

                    // stop monitoring mouse when mouseout

                    if (fMouseOut) {
                        ::KillTimer( m_hWnd, idTimer_MonitorMouse );
                        m_fCheckingMouse = FALSE;

                        SetObjectPointed( NULL, ptClient );
                        OnMouseOutFromWindow( ptClient );
                    }

                    // notify mouse movement

                    if (!fMouseOut && m_pBehindModalUIWnd)
                    {
                        m_pBehindModalUIWnd->ModalMouseNotify( WM_MOUSEMOVE, ptClient );
                    }

                    // tooltip

                    if (m_pWndToolTip != NULL) {
                        MSG msg;

                        msg.hwnd    = GetWnd();
                        msg.message = WM_MOUSEMOVE;
                        msg.wParam  = 0;
                        msg.lParam  = MAKELPARAM( ptClient.x, ptClient.y );
                        m_pWndToolTip->RelayEvent( &msg );
                    }

                    // handle mouse movement

                    if (!fMouseOut) {
                        HandleMouseMsg( WM_MOUSEMOVE, ptClient );
                    }
                    break;
                }

                case idTimer_UIObject: {
                    if (m_pTimerUIObj != NULL)
                        m_pTimerUIObj->OnTimer();
                    break;
                }

                default: {
                    OnTimer((UINT)wParam );
                    break;
                }
            }
            break;
        }

        case WM_ACTIVATE: {
            return OnActivate(hWnd, uMsg, wParam, lParam);
            break;
        }

        case WM_WINDOWPOSCHANGED: {
            // move shadow

            if (m_pWndShadow) {
                WINDOWPOS *pWndPos = (WINDOWPOS*)lParam;

                m_pWndShadow->OnOwnerWndMoved( (pWndPos->flags & SWP_NOSIZE) == 0 );
            }
            return OnWindowPosChanged(hWnd, uMsg, wParam, lParam);
            break;
        }

        case WM_WINDOWPOSCHANGING: {
            // show/hide shadow

            if (m_pWndShadow) {
                WINDOWPOS *pWndPos = (WINDOWPOS*)lParam;

                if ((pWndPos->flags & SWP_HIDEWINDOW) != 0) {
                    m_pWndShadow->Show( FALSE );
                }

                // don't go behaind of shadow

                if (((pWndPos->flags & SWP_NOZORDER) == 0) && (pWndPos->hwndInsertAfter == m_pWndShadow->GetWnd())) {
                    pWndPos->flags |= SWP_NOZORDER;
                }

                m_pWndShadow->OnOwnerWndMoved( (pWndPos->flags & SWP_NOSIZE) == 0 );
            }

            return OnWindowPosChanging(hWnd, uMsg, wParam, lParam);
            break;
        }

        case WM_SYSCOLORCHANGE: {
            UpdateUIFScheme();
            OnSysColorChange();
            break;
        }

        case WM_SHOWWINDOW: {
            // show/hide shadow

            if (m_pWndShadow && m_fShadowEnabled) {
                m_pWndShadow->Show( (BOOL)wParam );
            }

            return OnShowWindow( hWnd, uMsg, wParam, lParam );
            break;
        }

        case WM_SETTINGCHANGE: {
            UpdateUIFSys();
            UpdateUIFScheme();

            return OnSettingChange( hWnd, uMsg, wParam, lParam );
            break;
        }

        case WM_DISPLAYCHANGE: {
            UpdateUIFSys();
            UpdateUIFScheme();
            return OnDisplayChange( hWnd, uMsg, wParam, lParam );
            break;
        }

        case WM_ERASEBKGND: {
            return OnEraseBkGnd(hWnd, uMsg, wParam, lParam);
        }

        case WM_ENDSESSION: {
            OnEndSession(hWnd, wParam, lParam);
            return 0;
        }

        case WM_THEMECHANGED: {
            OnThemeChanged(hWnd, wParam, lParam);
            return 0;
        }

        case WM_GETOBJECT: {
            return OnGetObject( hWnd, uMsg, wParam, lParam );
            break;
        }

        default: {
            if (uMsg >= WM_USER) {
                Assert( GetThis(hWnd) != NULL );
                GetThis(hWnd)->OnUser(hWnd, uMsg, wParam, lParam);
                break;
            }
            return DefWindowProc(hWnd, uMsg, wParam, lParam);
        }
    } /* of switch */

    return 0;
}


/*   W I N D O W  P R O C E D U R E   */
/*------------------------------------------------------------------------------

    Window procedure of the class

------------------------------------------------------------------------------*/
LRESULT CALLBACK CUIFWindow::WindowProcedure(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT   lResult = 0;
    CUIFWindow *pUIWindow = NULL;

    // preprcess

    switch (uMsg) {
#ifdef UNDER_CE
        case WM_CREATE: {
            CREATESTRUCT *pCreateStruct  = (CREATESTRUCT *)lParam;

            pUIWindow = (CUIFWindow *)pCreateStruct->lpCreateParams;

            SetThis( hWnd, pUIWindow );
            pUIWindow->m_hWnd = hWnd;
            break;
        }
#else /* !UNDER_CE */
        case WM_NCCREATE: {
            CREATESTRUCT *pCreateStruct  = (CREATESTRUCT *)lParam;

            pUIWindow = (CUIFWindow *)pCreateStruct->lpCreateParams;

            SetThis( hWnd, pUIWindow );
            pUIWindow->m_hWnd = hWnd;
            break;
        }

        case WM_GETMINMAXINFO: {
            pUIWindow = GetThis( hWnd );
            if (pUIWindow == NULL) {
                // we may be able to ignore this message since the default position
                // has been set in initializing WWindow object.

                return DefWindowProc( hWnd, uMsg, wParam, lParam );
            }
            break;
        }
#endif /* !UNDER_CE */

        default: {
            pUIWindow = GetThis( hWnd );
            break;
        }
    }

    // call window procedure

    Assert( pUIWindow != NULL );

    if (pUIWindow != NULL) {
        Assert(pUIWindow->FInitialized());

        switch (uMsg) {
#ifdef UNDER_CE
            case WM_DESTROY: {
#else /* !UNDER_CE */
            case WM_NCDESTROY: {
#endif /* !UNDER_CE */
                pUIWindow->m_hWnd = NULL;
                SetThis( hWnd, NULL );
                break;
            }
        }

        lResult = pUIWindow->WindowProc( hWnd, uMsg, wParam, lParam );
    }

    return lResult;
}

/*   Adjust Window Pos
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/

typedef HMONITOR (*MONITORFROMRECT)(LPRECT prc, DWORD dwFlags);
typedef BOOL (*GETMONITORINFO)(HMONITOR hMonitor, LPMONITORINFO lpmi);

static MONITORFROMRECT g_pfnMonitorFromRect = NULL;
static GETMONITORINFO g_pfnGetMonitorInfo = NULL;

/*   InitMoniterFunc
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/

BOOL CUIFWindow::InitMonitorFunc()
{
    HMODULE hModUser32;

    if (g_pfnMonitorFromRect && g_pfnGetMonitorInfo)
        return TRUE;

    hModUser32 = CUIGetSystemModuleHandle(TEXT("user32.dll"));
    if (hModUser32)
    {
         g_pfnMonitorFromRect = (MONITORFROMRECT)GetProcAddress(hModUser32, "MonitorFromRect");
         g_pfnGetMonitorInfo = (GETMONITORINFO)GetProcAddress(hModUser32, "GetMonitorInfoA");
    }

    if (g_pfnMonitorFromRect && g_pfnGetMonitorInfo)
        return TRUE;

    return FALSE;
}

/*   GetWorkArea
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/

BOOL CUIFWindow::GetWorkArea(RECT *prcIn, RECT *prcOut)
{
    BOOL bRet = FALSE;
    HMONITOR hMon;
    MONITORINFO mi;

    if (!FHasStyle( UIWINDOW_HABITATINWORKAREA | UIWINDOW_HABITATINSCREEN ))
        return FALSE;

    if (!InitMonitorFunc())
        goto TrySPI;

    hMon = g_pfnMonitorFromRect(prcIn, MONITOR_DEFAULTTONEAREST);
    if (!hMon)
        goto TrySPI;

    mi.cbSize = sizeof(mi);
    if (g_pfnGetMonitorInfo(hMon, &mi))
    {
        if (FHasStyle( UIWINDOW_HABITATINWORKAREA )) {
            *prcOut = mi.rcWork;
            return TRUE;
        }
        else if (FHasStyle( UIWINDOW_HABITATINSCREEN )) {
            *prcOut = mi.rcMonitor;
            return TRUE;
        }
        return FALSE;
    }

TrySPI:
    if (FHasStyle( UIWINDOW_HABITATINWORKAREA )) {
        return SystemParametersInfo(SPI_GETWORKAREA,  0, prcOut, FALSE);
    }
    else if (FHasStyle( UIWINDOW_HABITATINSCREEN )) {
        prcOut->top = 0;
        prcOut->left = 0;
        prcOut->right = GetSystemMetrics(SM_CXSCREEN);
        prcOut->bottom = GetSystemMetrics(SM_CYSCREEN);
        return TRUE;
    }
    return FALSE;
}

/*   Adjust Window Position
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/

void CUIFWindow::AdjustWindowPosition()
{
    RECT rc;
    RECT rcWnd;

    rcWnd.left = _xWnd;
    rcWnd.top = _yWnd;
    rcWnd.right = _xWnd + _nWidth;
    rcWnd.bottom = _yWnd + _nHeight;
    if (!GetWorkArea(&rcWnd, &rc))
        return;

    if (_xWnd < rc.left)
        _xWnd = rc.left;

    if (_yWnd < rc.top)
        _yWnd = rc.top;

    if (_xWnd + _nWidth >= rc.right)
        _xWnd = rc.right - _nWidth;

    if (_yWnd + _nHeight >= rc.bottom)
        _yWnd = rc.bottom - _nHeight;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\dummyhkl\dummyhkl.cpp ===
/**********************************************************************/
/*                                                                    */
/*      dummyhkl.C - Windows 95 dummyhkl                              */
/*                                                                    */
/*      Copyright (c) 1994-1995  Microsoft Corporation                */
/*                                                                    */
/**********************************************************************/

#include "private.h"
#include "dummyhkl.h"


HINSTANCE hInst;

#ifdef DUMMYHKL_0411
char szUIClassName[] = "hkl0411classname";
#elif DUMMYHKL_0412
char szUIClassName[] = "hkl0412classname";
#elif DUMMYHKL_0404
char szUIClassName[] = "hkl0404classname";
#elif DUMMYHKL_0804
char szUIClassName[] = "hkl0804classname";
#endif

/**********************************************************************/
/*    DLLEntry()                                                      */
/**********************************************************************/
BOOL WINAPI DLLEntry (
    HINSTANCE    hInstDLL,
    DWORD        dwFunction,
    LPVOID       lpNot)
{
    switch(dwFunction)
    {
        case DLL_PROCESS_ATTACH:
            hInst= hInstDLL;
            IMERegisterClass( hInst );
            break;

        case DLL_PROCESS_DETACH:
            UnregisterClass(szUIClassName,hInst);
            break;

        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\dummyhkl\imm.cpp ===
/**********************************************************************/
/*                                                                    */
/*      IMM.C - Windows 95 FAKEIME                                    */
/*                                                                    */
/*      Copyright (c) 1994-1995  Microsoft Corporation                */
/*                                                                    */
/**********************************************************************/
#include "private.h"
#include "dummyhkl.h"

/**********************************************************************/
/*      ImeInquire()                                                  */
/*                                                                    */
/**********************************************************************/
BOOL WINAPI ImeInquire(LPIMEINFO lpIMEInfo,LPSTR lpszClassName,LPCSTR lpszOption)
{
    // Init IMEINFO Structure.
    lpIMEInfo->dwPrivateDataSize = 0;
    lpIMEInfo->fdwProperty       = 0;
    lpIMEInfo->fdwConversionCaps = 0;
    lpIMEInfo->fdwSentenceCaps   = 0;
    lpIMEInfo->fdwUICaps         = 0;
    lpIMEInfo->fdwSCSCaps        = 0;
    lpIMEInfo->fdwSelectCaps     = 0;

    lstrcpy(lpszClassName,(LPSTR)szUIClassName);
    return TRUE;
}

/**********************************************************************/
/*      ImeConversionList()                                           */
/*                                                                    */
/**********************************************************************/
DWORD WINAPI ImeConversionList(HIMC hIMC,LPCTSTR lpSource,LPCANDIDATELIST lpCandList,DWORD dwBufLen,UINT uFlags)
{
    return 0;
}

/**********************************************************************/
/*      ImeDestroy()                                                  */
/*                                                                    */
/**********************************************************************/
BOOL WINAPI ImeDestroy(UINT uForce)
{
    return TRUE;
}

/**********************************************************************/
/*      ImeEscape()                                                   */
/*                                                                    */
/**********************************************************************/
LRESULT WINAPI ImeEscape(HIMC hIMC,UINT uSubFunc,LPVOID lpData)
{
    return FALSE;
}

/**********************************************************************/
/*      ImeSetActiveContext()                                         */
/*                                                                    */
/**********************************************************************/
BOOL WINAPI ImeSetActiveContext(HIMC hIMC,BOOL fFlag)
{
    return TRUE;
}

/**********************************************************************/
/*      ImeProcessKey()                                               */
/*                                                                    */
/**********************************************************************/
BOOL WINAPI ImeProcessKey(HIMC hIMC,UINT vKey,LPARAM lKeyData,CONST LPBYTE lpbKeyState)
{
    return FALSE;
}
/**********************************************************************/
/*      ImeToAsciiEx                                                  */
/*                                                                    */
/*    HIBYTE of uVirtKey is char code now.                            */
/**********************************************************************/
UINT WINAPI ImeToAsciiEx (UINT uVKey,UINT uScanCode,CONST LPBYTE lpbKeyState,LPDWORD lpdwTransKey,UINT fuState,HIMC hIMC)
{
    return 0;
}

/**********************************************************************/
/*      NotifyIME()                                                   */
/*                                                                    */
/**********************************************************************/
BOOL WINAPI NotifyIME(HIMC hIMC,DWORD dwAction,DWORD dwIndex,DWORD dwValue)
{
    return FALSE;
}

/**********************************************************************/
/*      ImeSelect()                                                   */
/*                                                                    */
/**********************************************************************/
BOOL WINAPI ImeSelect(HIMC hIMC, BOOL fSelect)
{
    return TRUE;
}


/**********************************************************************/
/*      ImeSetCompositionString()                                     */
/*                                                                    */
/**********************************************************************/
BOOL WINAPI ImeSetCompositionString(HIMC hIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwComp, LPVOID lpRead, DWORD dwRead)
{
    return FALSE;
}

/**********************************************************************/
/*                                                                    */
/*      ImeConfigure()                                                */
/*                                                                    */
/**********************************************************************/
BOOL WINAPI ImeConfigure(HKL hKL,HWND hWnd, DWORD dwMode, LPVOID lpData)
{
    return FALSE;
}

/**********************************************************************/
/*      ImeGetImeMenuItemInfo()                                       */
/*                                                                    */
/**********************************************************************/
DWORD WINAPI ImeGetImeMenuItems(HIMC hIMC, DWORD dwFlags, DWORD dwType, LPIMEMENUITEMINFO lpImeParentMenu, LPIMEMENUITEMINFO lpImeMenu, DWORD dwSize)
{
    return 0;
}

BOOL    WINAPI ImeRegisterWord(LPCSTR lpRead, DWORD dw, LPCSTR lpStr)
{
    return FALSE;
}
BOOL    WINAPI ImeUnregisterWord(LPCSTR lpRead, DWORD dw, LPCSTR lpStr)
{
    return FALSE;
}
UINT    WINAPI ImeGetRegisterWordStyle(UINT u, LPSTYLEBUF lp)
{
    return 0;
}

UINT    WINAPI ImeEnumRegisterWord(REGISTERWORDENUMPROC lpfn, LPCSTR lpRead, DWORD dw, LPCSTR lpStr, LPVOID lpData)
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\dummyhkl\dummyhkl.h ===
/**********************************************************************/
/*                                                                    */
/*      dummyhkl.H - Windows 95 dummyhkl                              */
/*                                                                    */
/*      Copyright (c) 1994-1995  Microsoft Corporation                */
/*                                                                    */
/**********************************************************************/

#include "immdev.h"


/* for GlobalAlloc */
#define GHIME (GHND | GMEM_SHARE)

/**********************************************************************/
/*                                                                    */
/*      Externs                                                       */
/*                                                                    */
/**********************************************************************/
extern HINSTANCE  hInst;
extern char szUIClassName[];

/**********************************************************************/
/*                                                                    */
/*      Functions                                                     */
/*                                                                    */
/**********************************************************************/
/*   dummyhkl.c     */
int PASCAL Init(void);
BOOL IMERegisterClass( HINSTANCE hInstance);
LRESULT CALLBACK DummyhKLWndProc(HWND,UINT,WPARAM,LPARAM);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\dummyhkl\ui.cpp ===
/**********************************************************************/
/*                                                                    */
/*      UI.C - Windows 95 DummyhKL                                     */
/*                                                                    */
/*      Copyright (c) 1994-1995  Microsoft Corporation                */
/*                                                                    */
/**********************************************************************/
#include "private.h"
#include "dummyhkl.h"

#define CS_DUMMYHKL (CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS | CS_IME)
/**********************************************************************/
/*                                                                    */
/* IMERegisterClass()                                                 */
/*                                                                    */
/* This function is called by IMMInquire.                             */
/*    Register the classes for the child windows.                     */
/*    Create global GDI objects.                                      */
/*                                                                    */
/**********************************************************************/
BOOL IMERegisterClass( HINSTANCE hInstance)
{
    WNDCLASSEX wc;

    //
    // register class of UI window.
    //
    wc.cbSize         = sizeof(WNDCLASSEX);
    wc.style          = CS_DUMMYHKL;
    wc.lpfnWndProc    = DummyhKLWndProc;
    wc.cbClsExtra     = 0;
    wc.cbWndExtra     = 8;
    wc.hInstance      = hInstance;
    wc.hCursor        = LoadCursor( NULL, IDC_ARROW );
    wc.hIcon          = NULL;
    wc.lpszMenuName   = (LPSTR)NULL;
    wc.lpszClassName  = (LPSTR)szUIClassName;
    wc.hbrBackground  = NULL;
    wc.hIconSm        = NULL;

    if( !RegisterClassEx( (LPWNDCLASSEX)&wc ) )
        return FALSE;


    return TRUE;
}

/**********************************************************************/
/*                                                                    */
/* DummyhKLWndProc()                                                   */
/*                                                                    */
/* IME UI window procedure                                            */
/*                                                                    */
/**********************************************************************/
LRESULT CALLBACK DummyhKLWndProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
    return DefWindowProc(hWnd,message,wParam,lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\aimmver.h ===
//
// aimmver.h
//
//
//
// OFFICE10_BUILD:
//
#ifndef  OFFICE10_BUILD
#include <winver.h>
#include <ntverp.h>
#else

// Change VER_PRODUCTBUILD and VER_PRODUCTBUILD_QFE as appropriate.

#define VER_MAJOR_PRODUCTVER		5
#define VER_MINOR_PRODUCTVER		1
#define VER_PRODUCTBUILD	/* Win9x */	2462
#define VER_PRODUCTBUILD_QFE	/* Win9x */	0


#define VER_PRODUCTVERSION		VER_MAJOR_PRODUCTVER,VER_MINOR_PRODUCTVER,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE
#define VER_PRODUCTVERSION_W		(0x0100)
#define VER_PRODUCTVERSION_DW		(0x01000000 | VER_PRODUCTBUILD)


// READ THIS

// Do not change VER_PRODUCTVERSION_STRING.
//
//       Again
//
// Do not change VER_PRODUCTVERSION_STRING.
//
//       One more time
//
// Do not change VER_PRODUCTVERSION_STRING.
//
// ntverp.h will do the right thing wrt the minor version #'s by stringizing
// the VER_PRODUCTBUILD and VER_PRODUCTBUILD_QFE values and concatenating them to
// the end of VER_PRODUCTVERSION_STRING.  VER_PRODUCTVERSION_STRING only needs
// is the major product version #'s. (currently, 5.00)

#define VER_PRODUCTBETA_STR		/* Win9x */  ""
#define VER_PRODUCTVERSION_STRING	"1.00"

#if 	(VER_PRODUCTBUILD < 10)
#define VER_BPAD "000"
#elif	(VER_PRODUCTBUILD < 100)
#define VER_BPAD "00"
#elif	(VER_PRODUCTBUILD < 1000)
#define VER_BPAD "0"
#else
#define VER_BPAD
#endif

#define VER_PRODUCTVERSION_STR2(x,y) VER_PRODUCTVERSION_STRING "." VER_BPAD #x "." #y
#define VER_PRODUCTVERSION_STR1(x,y) VER_PRODUCTVERSION_STR2(x, y)
#define VER_PRODUCTVERSION_STR       VER_PRODUCTVERSION_STR1(VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE)

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#if DBG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is prerelease */
#if BETA
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_NT_WINDOWS32
#define VER_FILEFLAGS               (VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation"
#define VER_PRODUCTNAME_STR         "Microsoft(R) Windows NT(R) Operating System"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft(R) is a registered trademark of Microsoft Corporation. Windows NT(R) is a registered trademark of Microsoft Corporation."

#endif // OFFICE10_BUILD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\catutil.h ===
//
// catutil.h
//

#ifndef CATUTIL_H
#define CATUTIL_H

#include "private.h"
#include "immxutil.h"

BOOL IsEqualTFGUIDATOM(LIBTHREAD *plt, TfGuidAtom guidatom, REFGUID rguid);
BOOL GetGUIDFromGUIDATOM(LIBTHREAD *plt, TfGuidAtom guidatom, GUID *pguid);
BOOL GetGUIDATOMFromGUID(LIBTHREAD *plt, REFGUID rguid, TfGuidAtom *pguidatom);
HRESULT LibEnumCategoriesInItem(LIBTHREAD *plt, REFGUID rguid, IEnumGUID **ppEnum);
HRESULT LibEnumItemsInCategory(LIBTHREAD *plt, REFGUID rcatid, IEnumGUID **ppEnum);

HRESULT RegisterGUIDDescription(REFCLSID rclsid, REFGUID rcatid, WCHAR *pszDesc);
HRESULT UnregisterGUIDDescription(REFCLSID rclsid, REFGUID rcatid);
HRESULT GetGUIDDescription(LIBTHREAD *plt, REFCLSID rclsid, BSTR *pbstr);
HRESULT RegisterGUIDDWORD(REFCLSID rclsid, REFGUID rcatid, DWORD dw);
HRESULT UnregisterGUIDDWORD(REFCLSID rclsid, REFGUID rcatid);
HRESULT GetGUIDDWORD(LIBTHREAD *plt, REFCLSID rclsid, DWORD*pdw);
HRESULT RegisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid);
HRESULT UnregisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid);



typedef struct tagREGISTERCAT {
    const GUID *pcatid;
    const GUID *pguid;
} REGISTERCAT;

HRESULT RegisterCategories(REFCLSID rclsid, const REGISTERCAT *pregcat);
HRESULT UnregisterCategories(REFCLSID rclsid, const REGISTERCAT *pregcat);
HRESULT GetKnownModeBias(LIBTHREAD *plt, TfGuidAtom guidatom, GUID *pcatid, const GUID **ppcatidList, ULONG ulCount);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\ats.h ===
//
// ats.h
//
// Generic ITfActiveLanguageProfileNotifySink object
//

#ifndef ATS_H
#define ATS_H

#include "private.h"

#define ALS_INVALID_COOKIE  ((DWORD)(-1))


typedef HRESULT (*ALSCALLBACK)(REFCLSID clsid, REFGUID guidProfile, BOOL fActivated, void *pv);

class CActiveLanguageProfileNotifySink : public ITfActiveLanguageProfileNotifySink
{
public:
    CActiveLanguageProfileNotifySink(ALSCALLBACK pfn, void *pv);

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfActiveLanguageProfileNotifySink
    //
    STDMETHODIMP OnActivated(REFCLSID clsid, REFGUID guidProfile, BOOL bActivated);

    HRESULT _Advise(ITfThreadMgr *ptim);
    HRESULT _Unadvise();

private:

    long _cRef;
    ITfThreadMgr *_ptim;
    DWORD _dwCookie;
    ALSCALLBACK _pfn;
    void *_pv;
};

#endif // ATS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\dummyhkl\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for gram project.
//
//----------------------------------------------------------------------------

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#define _OLEAUT32_

#define NOIME
#include <windows.h>
#include <ccstock.h>
#include <debug.h>
#include <ole2.h>
#include <ocidl.h>
#include <olectl.h>
#include "msctf.h"
#include "helpers.h"
#include "xstring.h"
#include "cgapi32.h"
#include "mem.h" // must be last

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\chkobj.h ===
//
// chkobj.h
//

#ifndef CHKOBJ_H
#define CHKOBJ_H

#ifdef DEBUG

// verify we don't free any unallocated gdi objs

__inline BOOL ChkDeleteObject(HGDIOBJ hObj)
{
    BOOL fDeleteObjectSucceeded = DeleteObject(hObj);

    Assert(fDeleteObjectSucceeded);

    return fDeleteObjectSucceeded;
}

#define DeleteObject(hObj)  ChkDeleteObject(hObj)

__inline BOOL ChkDeleteDC(HDC hdc)
{
    BOOL fDeleteDCSucceeded = DeleteDC(hdc);

    Assert(fDeleteDCSucceeded);

    return fDeleteDCSucceeded;
}

#define DeleteDC(hdc)  ChkDeleteDC(hdc)

#endif // DEBUG


#endif // CHKOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\ccstock.h ===
//
// CCSHELL stock definition and declaration header
//


#ifndef __CCSTOCK_H__
#define __CCSTOCK_H__

#ifndef RC_INVOKED

// NT and Win95 environments set warnings differently.  This makes
// our project consistent across environments.

#pragma warning(3:4101)   // Unreferenced local variable

//
// Sugar-coating
//

#define PUBLIC
#define PRIVATE
#define IN
#define OUT
#define BLOCK

#ifndef DECLARE_STANDARD_TYPES

/*
 * For a type "FOO", define the standard derived types PFOO, CFOO, and PCFOO.
 */

#define DECLARE_STANDARD_TYPES(type)      typedef type *P##type; \
                                          typedef const type C##type; \
                                          typedef const type *PC##type;

#endif

#ifndef DECLARE_STANDARD_TYPES_U

/*
 * For a type "FOO", define the standard derived UNALIGNED types PFOO, CFOO, and PCFOO.
 *  WINNT: RISC boxes care about ALIGNED, intel does not.
 */

#define DECLARE_STANDARD_TYPES_U(type)    typedef UNALIGNED type *P##type; \
                                          typedef UNALIGNED const type C##type; \
                                          typedef UNALIGNED const type *PC##type;

#endif

// For string constants that are always wide
#define __TEXTW(x)    L##x
#define TEXTW(x)      __TEXTW(x)

//
// Count of characters to count of bytes
//
#define CbFromCchW(cch)             ((cch)*sizeof(WCHAR))
#define CbFromCchA(cch)             ((cch)*sizeof(CHAR))
#ifdef UNICODE
#define CbFromCch                   CbFromCchW
#else  // UNICODE
#define CbFromCch                   CbFromCchA
#endif // UNICODE

//
// General flag macros
//
#define SetFlag(obj, f)             do {obj |= (f);} while (0)
#define ToggleFlag(obj, f)          do {obj ^= (f);} while (0)
#define ClearFlag(obj, f)           do {obj &= ~(f);} while (0)
#define IsFlagSet(obj, f)           (BOOL)(((obj) & (f)) == (f))
#define IsFlagClear(obj, f)         (BOOL)(((obj) & (f)) != (f))

//
// String macros
//
#define IsSzEqual(sz1, sz2)         (BOOL)(lstrcmpi(sz1, sz2) == 0)
#define IsSzEqualC(sz1, sz2)        (BOOL)(lstrcmp(sz1, sz2) == 0)

#define lstrnicmpA(sz1, sz2, cch)           StrCmpNIA(sz1, sz2, cch)
#define lstrnicmpW(sz1, sz2, cch)           StrCmpNIW(sz1, sz2, cch)
#define lstrncmpA(sz1, sz2, cch)            StrCmpNA(sz1, sz2, cch)
#define lstrncmpW(sz1, sz2, cch)            StrCmpNW(sz1, sz2, cch)

//
// lstrcatnA and lstrcatnW are #defined here to StrCatBuff which is implemented
// in shlwapi. We do this here (and not in shlwapi.h or shlwapip.h) in case the
// kernel guys ever decided to implement this.
//
#define lstrcatnA(sz1, sz2, cchBuffSize)    StrCatBuffA(sz1, sz2, cchBuffSize)
#define lstrcatnW(sz1, sz2, cchBuffSize)    StrCatBuffW(sz1, sz2, cchBuffSize)
#ifdef UNICODE
#define lstrcatn lstrcatnW
#else
#define lstrcatn lstrcatnA
#endif // UNICODE

#ifdef UNICODE
#define lstrnicmp       lstrnicmpW
#define lstrncmp        lstrncmpW
#else
#define lstrnicmp       lstrnicmpA
#define lstrncmp        lstrncmpA
#endif

#ifndef SIZEOF
#define SIZEOF(a)                   sizeof(a)
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif
#define SIZECHARS(sz)               (sizeof(sz)/sizeof(sz[0]))

#define InRange(id, idFirst, idLast)      ((UINT)((id)-(idFirst)) <= (UINT)((idLast)-(idFirst)))
#define IsInRange                   InRange

#define ZeroInit(pv, cb)            (memset((pv), 0, (cb)))

// ATOMICRELEASE
//
#ifndef ATOMICRELEASE
#ifdef __cplusplus
#define ATOMICRELEASET(p, type) { if(p) { type* punkT=p; p=NULL; punkT->Release();} }
#else
#define ATOMICRELEASET(p, type) { if(p) { type* punkT=p; p=NULL; punkT->lpVtbl->Release(punkT);} }
#endif

// doing this as a function instead of inline seems to be a size win.
//
#ifdef NOATOMICRELESEFUNC
#define ATOMICRELEASE(p) ATOMICRELEASET(p, IUnknown)
#else
#define ATOMICRELEASE(p) IUnknown_AtomicRelease((void **)&p)
#endif
#endif //ATOMICRELEASE

//
//  Helper macro for managing weak pointers to inner interfaces.
//  (It's the weak version of ATOMICRELEASE.)
//
//  The extra cast to (void **) is to keep C++ from doing strange
//  inheritance games when all I want to do is change the type.
//
#ifndef RELEASEINNERINTERFACE
#define RELEASEINNERINTERFACE(pOuter, p) \
        SHReleaseInnerInterface(pOuter, (IUnknown**)(void **)&(p))
#endif // RELEASEINNERINTERFACE

// For checking window charsets
#ifdef UNICODE
#define IsWindowTchar               IsWindowUnicode
#else  // !UNICODE
#define IsWindowTchar               !IsWindowUnicode
#endif // UNICODE

#ifdef DEBUG
// This macro is especially useful for cleaner looking code in
// declarations or for single lines.  For example, instead of:
//
//   {
//       DWORD dwRet;
//   #ifdef DEBUG
//       DWORD dwDebugOnlyVariable;
//   #endif
//
//       ....
//   }
//
// You can type:
//
//   {
//       DWORD dwRet;
//       DEBUG_CODE( DWORD dwDebugOnlyVariable; )
//
//       ....
//   }

#define DEBUG_CODE(x)               x
#else
#define DEBUG_CODE(x)

#endif  // DEBUG


//
// SAFECAST(obj, type)
//
// This macro is extremely useful for enforcing strong typechecking on other
// macros.  It generates no code.
//
// Simply insert this macro at the beginning of an expression list for
// each parameter that must be typechecked.  For example, for the
// definition of MYMAX(x, y), where x and y absolutely must be integers,
// use:
//
//   #define MYMAX(x, y)    (SAFECAST(x, int), SAFECAST(y, int), ((x) > (y) ? (x) : (y)))
//
//
#define SAFECAST(_obj, _type) (((_type)(_obj)==(_obj)?0:0), (_type)(_obj))


//
// Bitfields don't get along too well with bools,
// so here's an easy way to convert them:
//
#define BOOLIFY(expr)           (!!(expr))


// Issue (scotth): we should probably make this a 'bool', but be careful
// because the Alpha compiler might not recognize it yet.  Talk to AndyP.

// This isn't a BOOL because BOOL is signed and the compiler produces 
// sloppy code when testing for a single bit.

typedef DWORD   BITBOOL;


// STOCKLIB util functions

// IsOS(): returns TRUE/FALSE if the platform is the indicated OS.

#ifndef OS_WINDOWS
#define OS_WINDOWS      0           // windows vs. NT
#define OS_NT           1           // windows vs. NT
#define OS_WIN95        2           // Win95 or greater
#define OS_NT4          3           // NT4 or greater
#define OS_NT5          4           // NT5 or greater
#define OS_MEMPHIS      5           // Win98 or greater
#define OS_MEMPHIS_GOLD 6           // Win98 Gold
#endif

STDAPI_(BOOL) staticIsOS(DWORD dwOS);

#include <pshpack2.h>
typedef struct tagDLGTEMPLATEEX
{
    WORD    wDlgVer;
    WORD    wSignature;
    DWORD   dwHelpID;
    DWORD   dwExStyle;
    DWORD   dwStyle;
    WORD    cDlgItems;
    short   x;
    short   y;
    short   cx;
    short   cy;
}   DLGTEMPLATEEX, *LPDLGTEMPLATEEX;
#include <poppack.h>

//
// round macro that rounds a to the next multiple of b.
//
#ifndef ROUNDUP
#define ROUNDUP(a,b)    ((((a)+(b)-1)/(b))*(b))
#endif

#define ROUND_TO_CLUSTER ROUNDUP

//
// macro that sees if a give char is an number
//
#define ISDIGIT(c)  ((c) >= TEXT('0') && (c) <= TEXT('9'))

//
// inline that does PathIsDotOrDotDot
//
__inline BOOL PathIsDotOrDotDotW(LPCWSTR pszPath)
{
    return ((pszPath[0] == L'.') && 
            ((pszPath[1] == L'\0') || ((pszPath[1] == L'.') && (pszPath[2] == L'\0'))));
}

__inline BOOL PathIsDotOrDotDotA(LPCSTR pszPath)
{
    return ((pszPath[0] == '.') && 
            ((pszPath[1] == '\0') || ((pszPath[1] == '.') && (pszPath[2] == '\0'))));
}

#ifdef UNICODE
#define PathIsDotOrDotDot PathIsDotOrDotDotW
#else
#define PathIsDotOrDotDot PathIsDotOrDotDotA
#endif


//
//  WindowLong accessor macros and other Win64 niceness
//

__inline void * GetWindowPtr(HWND hWnd, int nIndex) {
    return (void *)GetWindowLongPtr(hWnd, nIndex);
}

__inline void * SetWindowPtr(HWND hWnd, int nIndex, void * p) {
    return (void *)SetWindowLongPtr(hWnd, nIndex, (LONG_PTR)p);
}

//***   GetWindowLong0 -- 'fast' GetWindowLong (and GetWindowLongPtr)
// DESCRIPTION
//  what's up w/ this?  it's all about perf.  GetWindowLong has 'A' and 'W'
//  versions.  however 99% of the time they do the same thing (the other
//  0.1% has to do w/ setting the WndProc and having to go thru a thunk).
//  but we still need wrappers for the general case.  but most of the time
//  we're just doing a GWL(0), e.g. on entry to a wndproc to get our private
//  data.  so by having a special version of that, we save going thru the
//  wrapper (which was costing us 1-3% of our profile).
// NOTES
//  note that we call the 'A' version since that's guaranteed to exist on
// all platforms.
__inline LONG GetWindowLong0(HWND hWnd) {
    return GetWindowLongA(hWnd, 0);
}
__inline LONG SetWindowLong0(HWND hWnd, LONG l) {
    return SetWindowLongA(hWnd, 0, l);
}
__inline void * GetWindowPtr0(HWND hWnd) {
    return (void *)GetWindowLongPtrA(hWnd, 0);
}
__inline void * SetWindowPtr0(HWND hWnd, void * p) {
    return (void *)SetWindowLongPtrA(hWnd, 0, (LONG_PTR)p);
}


#define IS_WM_CONTEXTMENU_KEYBOARD(lParam) ((DWORD)(lParam) == 0xFFFFFFFF)

//
//  CharUpperChar - Convert a single character to uppercase
//
__inline WCHAR CharUpperCharW(WCHAR c)
{
    return (WCHAR)(DWORD_PTR)CharUpperW((LPWSTR)(DWORD_PTR)(c));
}

__inline CHAR CharUpperCharA(CHAR c)
{
    return (CHAR)(DWORD_PTR)CharUpperA((LPSTR)(DWORD_PTR)(c));
}

#ifdef UNICODE
#define CharUpperChar       CharUpperCharW
#else
#define CharUpperChar       CharUpperCharA
#endif

//
//  ShrinkProcessWorkingSet - Use this to stay Sundown-happy.
//
#define ShrinkWorkingSet() \
        SetProcessWorkingSetSize(GetCurrentProcess(), (SIZE_T) -1, (SIZE_T) -1)

//
//  COM Initialization.
//
//  Usage:
//
//      HRESULT hrInit = SHCoInitialize();
//      ... do COM stuff ...
//      SHCoUninitialize(hrInit);
//
//  Notice:  Continue doing COM stuff even if SHCoInitialize fails.
//  It might fail if somebody else already CoInit'd with different
//  flags, but we don't want to barf under those conditions.
//

STDAPI SHCoInitialize(void);
#define SHCoUninitialize(hr) if (SUCCEEDED(hr)) CoUninitialize()


//
//  OLE Initialization.
//
//  Usage:
//
//      HRESULT hrInit = SHOleInitialize(pMalloc);
//      ... do COM stuff ...
//      SHOleUninitialize(hrInit);
//

#define SHOleInitialize(pMalloc) OleInitialize(pMalloc)

#define SHOleUninitialize(hr)   if (SUCCEEDED(hr))  OleUninitialize()

//
//  MACRO HACK - Since not all clients of ccstock.h include shlobj.h first,
//  we need to use the long form of LP[C]ITEMIDLIST.  Since nobody remembers
//  this little quirk, to avoid future build breaks, redefine the symbols
//  to their long forms.
//
#define LPCITEMIDLIST const UNALIGNED struct _ITEMIDLIST *
#define  LPITEMIDLIST       UNALIGNED struct _ITEMIDLIST *

//
//  Name Parsing generic across the shell
//  
//  Usage:
// 
//      HRESULT SHGetNameAndFlags()
//          wrapper to bind to the folder and do a GetDisplayName()
//
STDAPI SHGetNameAndFlagsA(LPCITEMIDLIST pidl, DWORD dwFlags, LPSTR pszName, UINT cchName, DWORD *pdwAttribs);
STDAPI SHGetNameAndFlagsW(LPCITEMIDLIST pidl, DWORD dwFlags, LPWSTR pszName, UINT cchName, DWORD *pdwAttribs);
STDAPI SHGetNameAndFlags2A(struct IShellFolder *psfRoot, LPCITEMIDLIST pidl, DWORD dwFlags, LPSTR pszName, UINT cchName, DWORD *pdwAttribs);
STDAPI SHGetNameAndFlags2W(struct IShellFolder *psfRoot, LPCITEMIDLIST pidl, DWORD dwFlags, LPWSTR pszName, UINT cchName, DWORD *pdwAttribs);

//
//  Special values for SHGetNameAndFlags2::psfRoot
//
#define NAF2_SHELLDESKTOP   ((IShellFolder *)0)    // relative to shell desktop
#define NAF2_CURRENTROOT    ((IShellFolder *)-1)   // relative to current root

STDAPI SHBindToObject(struct IShellFolder *psf, REFIID riid, LPCITEMIDLIST pidl, void **ppvOut);
#define SHGetAttributesOf(pidl, prgfInOut) SHGetNameAndFlags(pidl, 0, NULL, 0, prgfInOut)

STDAPI_(DWORD) GetUrlSchemeW(LPCWSTR pszUrl);
STDAPI_(DWORD) GetUrlSchemeA(LPCSTR pszUrl);

#ifdef UNICODE
#define SHGetNameAndFlags       SHGetNameAndFlagsW
#define SHGetNameAndFlags2      SHGetNameAndFlags2W
#define GetUrlScheme            GetUrlSchemeW
#else
#define SHGetNameAndFlags       SHGetNameAndFlagsA
#define SHGetNameAndFlags2      SHGetNameAndFlags2A
#define GetUrlScheme            GetUrlSchemeA
#endif

// SHBindToIDListParent(LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast)
//
// Given a pidl, you can get an interface pointer (as specified by riid) of the pidl's parent folder (in ppv)
// If ppidlLast is non-NULL, you can also get the pidl of the last item.
//
STDAPI SHBindToIDListParent(LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast);

//
// SHBindToFolderIDListParent
//
//  Same as SHBindToIDListParent, except you also specify which root to use.
//
STDAPI SHBindToFolderIDListParent(struct IShellFolder *psfRoot, LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast);

STDAPI_(void) SHRemoveURLTurd(LPTSTR pszUrl);

//  clones the parent of the pidl
STDAPI_(LPITEMIDLIST) ILCloneParent(LPCITEMIDLIST pidl);

//
//  END OF MACRO HACK
//
#undef LPITEMIDLIST
#undef LPCITEMIDLIST

//
// Mirroring-Support APIs (astracted in \shell\lib\stock5\rtlmir.cpp)
//
#ifdef __cplusplus
extern "C" {
#endif

extern BOOL g_bMirroredOS;

WORD  GetDefaultLang(BOOL bForceEnglish);
WORD  GetWindowLang (HWND hWndOwner);
BOOL  UseProperDlgTemplate(HINSTANCE hInst, HGLOBAL *phDlgTemplate, HRSRC *phResInfo, LPCSTR lpName, 
                           HWND hWndOwner, LPWORD lpwLangID, BOOL bForceEnglish);

#ifdef USE_MIRRORING

BOOL  IsBiDiLocalizedSystem( void );
BOOL  Mirror_IsEnabledOS( void );
LANGID Mirror_GetUserDefaultUILanguage( void );
BOOL  Mirror_IsWindowMirroredRTL( HWND hWnd );
DWORD Mirror_IsDCMirroredRTL( HDC hdc );
DWORD Mirror_MirrorDC( HDC hdc );
BOOL  Mirror_MirrorProcessRTL( void );
DWORD Mirror_GetLayout( HDC hdc );
DWORD Mirror_SetLayout( HDC hdc , DWORD dwLayout );
BOOL Mirror_GetProcessDefaultLayout( DWORD *pdwDefaultLayout );
BOOL Mirror_IsProcessRTL( void );
extern const DWORD dwNoMirrorBitmap;
extern const DWORD dwExStyleRTLMirrorWnd;
extern const DWORD dwExStyleNoInheritLayout;
extern const DWORD dwPreserveBitmap;
//
// 'g_bMirroredOS' is defined in each component which will use the
//  mirroring APIs. I decided to put it here, in order to make sure
//  each component has validated that the OS supports the mirroring
//  APIs before calling them.
//

#define IS_BIDI_LOCALIZED_SYSTEM()      IsBiDiLocalizedSystem()
#define IS_MIRRORING_ENABLED()          Mirror_IsEnabledOS()
#define IS_WINDOW_RTL_MIRRORED(hwnd)    (g_bMirroredOS && Mirror_IsWindowMirroredRTL(hwnd))
#define IS_DC_RTL_MIRRORED(hdc)         (g_bMirroredOS && Mirror_IsDCMirroredRTL(hdc))
#define GET_PROCESS_DEF_LAYOUT(pdwl)    (g_bMirroredOS && Mirror_GetProcessDefaultLayout(pdwl))
#define IS_PROCESS_RTL_MIRRORED()       (g_bMirroredOS && Mirror_IsProcessRTL())
#define SET_DC_RTL_MIRRORED(hdc)        Mirror_MirrorDC(hdc)
#define SET_DC_LAYOUT(hdc,dwl)          Mirror_SetLayout(hdc,dwl)
#define SET_PROCESS_RTL_LAYOUT()        Mirror_MirrorProcessRTL()
#define GET_DC_LAYOUT(hdc)              Mirror_GetLayout(hdc) 
#define DONTMIRRORBITMAP                dwNoMirrorBitmap
#define RTL_MIRRORED_WINDOW             dwExStyleRTLMirrorWnd
#define RTL_NOINHERITLAYOUT             dwExStyleNoInheritLayout
#define LAYOUT_PRESERVEBITMAP           dwPreserveBitmap

#else

#define IS_BIDI_LOCALIZED_SYSTEM()      FALSE
#define IS_MIRRORING_ENABLED()          FALSE
#define IS_WINDOW_RTL_MIRRORED(hwnd)    FALSE
#define IS_DC_RTL_MIRRORED(hdc)         FALSE
#define GET_PROCESS_DEF_LAYOUT(pdwl)    FALSE
#define IS_PROCESS_RTL_MIRRORED()       FALSE
#define SET_DC_RTL_MIRRORED(hdc)        
#define SET_DC_LAYOUT(hdc,dwl)
#define SET_PROCESS_DEFAULT_LAYOUT() 
#define GET_DC_LAYOUT(hdc)              0L

#define DONTMIRRORBITMAP                0L
#define RTL_MIRRORED_WINDOW             0L
#define LAYOUT_PRESERVEBITMAP           0L

#endif  // USE_MIRRROING

BOOL IsBiDiLocalizedWin95( BOOL bArabicOnly );


//
//====== Dynamic array functions  ================================================
//

//------------------------------------------------------------------------
// Dynamic key array
//
typedef struct _DKA * HDKA;     // hdka

HDKA   DKA_CreateA(HKEY hkey, LPCSTR pszSubKey, LPCSTR pszFirst, LPCSTR pszDefOrder, BOOL fDefault);
HDKA   DKA_CreateW(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszFirst, LPCWSTR pszDefOrder, BOOL fDefault);

int    DKA_GetItemCount(HDKA hdka);

LPCSTR  DKA_GetKeyA(HDKA hdka, int iItem);
LPCWSTR DKA_GetKeyW(HDKA hdka, int iItem);

LONG   DKA_QueryValueA(HDKA hdka, int iItem, LPSTR szValue, LONG  * pcb);
LONG   DKA_QueryValueW(HDKA hdka, int iItem, LPWSTR szValue, LONG  * pcb);

DWORD  DKA_QueryOtherValueA(HDKA pdka, int iItem, LPCSTR pszName, LPSTR pszValue, LONG * pcb);
DWORD  DKA_QueryOtherValueW(HDKA pdka, int iItem, LPCWSTR pszName, LPWSTR pszValue, LONG * pcb);

void   DKA_Destroy(HDKA hdka);

#ifdef UNICODE
#define DKA_Create          DKA_CreateW
#define DKA_GetKey          DKA_GetKeyW
#define DKA_QueryValue      DKA_QueryValueW
#define DKA_QueryOtherValue DKA_QueryOtherValueW
#else
#define DKA_Create          DKA_CreateA
#define DKA_GetKey          DKA_GetKeyA
#define DKA_QueryValue      DKA_QueryValueA
#define DKA_QueryOtherValue DKA_QueryOtherValueA
#endif

//------------------------------------------------------------------------
// Dynamic class array
//
typedef struct _DCA * HDCA;     // hdca

HDCA DCA_Create();
void DCA_Destroy(HDCA hdca);
int  DCA_GetItemCount(HDCA hdca);
BOOL DCA_AddItem(HDCA hdca, REFCLSID rclsid);
const CLSID * DCA_GetItem(HDCA hdca, int i);

void DCA_AddItemsFromKeyA(HDCA hdca, HKEY hkey, LPCSTR pszSubKey);
void DCA_AddItemsFromKeyW(HDCA hdca, HKEY hkey, LPCWSTR pszSubKey);

#ifdef UNICODE
#define DCA_AddItemsFromKey     DCA_AddItemsFromKeyW
#else
#define DCA_AddItemsFromKey     DCA_AddItemsFromKeyA
#endif 

STDAPI DCA_CreateInstance(HDCA hdca, int iItem, REFIID riid, void ** ppv);


#ifdef __cplusplus
};
#endif

#endif // RC_INVOKED

//------------------------------------------------------------------------
// Random helpful functions
//------------------------------------------------------------------------
//
STDAPI_(BOOL) _SHIsButtonObscured(HWND hwnd, PRECT prc, INT_PTR i);
STDAPI_(void) _SHPrettyMenu(HMENU hm);
STDAPI_(BOOL) _SHIsMenuSeparator(HMENU hm, int i);
STDAPI_(BOOL) _SHIsMenuSeparator2(HMENU hm, int i, BOOL *pbIsNamed);
STDAPI_(BYTE) SHBtnStateFromRestriction(DWORD dwRest, BYTE fsState);
STDAPI_(BOOL) SHIsDisplayable(LPCWSTR pwszName, BOOL fRunOnFE, BOOL fRunOnNT5);

STDAPI_(void) EnableOKButtonFromString(HWND hDlg, LPTSTR pszText);
STDAPI_(void) EnableOKButtonFromID(HWND hDlg, int id);

//------------------------------------------------------------------------

////////////////
//
//  Critical section stuff
//
//  Helper macros that give nice debug support
//
EXTERN_C CRITICAL_SECTION g_csDll;
#ifdef DEBUG
EXTERN_C UINT g_CriticalSectionCount;
EXTERN_C DWORD g_CriticalSectionOwner;
EXTERN_C void Dll_EnterCriticalSection(CRITICAL_SECTION*);
EXTERN_C void Dll_LeaveCriticalSection(CRITICAL_SECTION*);
#if defined(__cplusplus) && defined(AssertMsg)
class DEBUGCRITICAL {
protected:
    BOOL fClosed;
public:
    DEBUGCRITICAL() {fClosed = FALSE;};
    void Leave() {fClosed = TRUE;};
    ~DEBUGCRITICAL() 
    {
        AssertMsg(fClosed, TEXT("you left scope while holding the critical section"));
    }
};
#define ENTERCRITICAL DEBUGCRITICAL debug_crit; Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICAL debug_crit.Leave(); Dll_LeaveCriticalSection(&g_csDll)
#define ENTERCRITICALNOASSERT Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICALNOASSERT Dll_LeaveCriticalSection(&g_csDll)
#else // __cplusplus
#define ENTERCRITICAL Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICAL Dll_LeaveCriticalSection(&g_csDll)
#define ENTERCRITICALNOASSERT Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICALNOASSERT Dll_LeaveCriticalSection(&g_csDll)
#endif // __cplusplus
#define ASSERTCRITICAL ASSERT(g_CriticalSectionCount > 0 && GetCurrentThreadId() == g_CriticalSectionOwner)
#define ASSERTNONCRITICAL ASSERT(GetCurrentThreadId() != g_CriticalSectionOwner)
#else // DEBUG
#define ENTERCRITICAL EnterCriticalSection(&g_csDll)
#define LEAVECRITICAL LeaveCriticalSection(&g_csDll)
#define ENTERCRITICALNOASSERT EnterCriticalSection(&g_csDll)
#define LEAVECRITICALNOASSERT LeaveCriticalSection(&g_csDll)
#define ASSERTCRITICAL 
#define ASSERTNONCRITICAL
#endif // DEBUG

#endif // __CCSTOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\ciccs.h ===
//
// ciccs.h
//


#ifndef CICCS_H
#define CICCS_H



class CCicCriticalSectionStatic
{
public:
    BOOL Init()
    {
        m_fInit = FALSE;
        if (InitializeCriticalSectionAndSpinCount(&m_cs, 0))
        {
            m_fInit = TRUE;
        }

        return m_fInit;
    }

    void Delete()
    {
        if (m_fInit)
        {
            DeleteCriticalSection(&m_cs);
            m_fInit = FALSE;
        }
    }

    operator CRITICAL_SECTION*()
    {
        return &m_cs;
    }

private:
    CRITICAL_SECTION m_cs;
    BOOL m_fInit;
};

#endif CICCS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\cicutil.h ===
#ifndef CICUTIL_H
#define CICUTIL_H


BOOL IsSP1ResourceID(
    UINT uId);

HINSTANCE GetCicResInstance(
    HINSTANCE hInstOrg,
    UINT uId);

void FreeCicResInstance();

int CicLoadStringA(
    HINSTANCE hinstOrg,
    UINT uId,
    LPSTR lpBuffer,
    UINT cchMax);

int CicLoadString(
    HINSTANCE hinstOrg,
    UINT uId,
    LPTSTR lpBuffer,
    UINT cchMax);

int CicLoadStringWrapW(
    HINSTANCE hInstOrg,
    UINT uId,
    LPWSTR lpwBuff,
    UINT cchMax);


#endif // CICUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\cmydc.h ===
//
// cmydc.h
//


#ifndef CMYDC_H
#define CMYDC_H

class CSolidBrush
{
public:
    CSolidBrush(int r, int g, int b)
    {
        _hbr = CreateSolidBrush(RGB(r, g, b));
    }

    CSolidBrush(COLORREF rgb)
    {
        _hbr = CreateSolidBrush(rgb);
    }

    CSolidBrush()
    {
        _hbr = NULL;
    }

    BOOL Init(int r, int g, int b)
    {
        Assert(!_hbr);
        _hbr = CreateSolidBrush(RGB(r, g, b));
        return _hbr != NULL;
    }

    BOOL Init(COLORREF rgb)
    {
        Assert(!_hbr);
        _hbr = CreateSolidBrush(rgb);
        return _hbr != NULL;
    }

    ~CSolidBrush()
    {
        if (_hbr)
           DeleteObject(_hbr);
    }

    operator HBRUSH()
    {
        return _hbr;
    }

private:
    HBRUSH _hbr;
};

class CSolidPen
{
public:
    CSolidPen()
    {
        _hpen = NULL;
    }

    BOOL Init(int r, int g, int b)
    {
        Assert(!_hpen);
        _hpen = CreatePen(PS_SOLID, 0, RGB(r, g, b));
        return _hpen != NULL;
    }

    BOOL Init(COLORREF rgb)
    {
        Assert(!_hpen);
        _hpen = CreatePen(PS_SOLID, 0, rgb);
        return _hpen != NULL;
    }

    ~CSolidPen()
    {
        if (_hpen)
           DeleteObject(_hpen);
    }

    operator HPEN()
    {
        return _hpen;
    }

private:
    HPEN _hpen;
};

class CPatternBrush
{
public:
    CPatternBrush(HBITMAP hbmp)
    {
        _hbr = CreatePatternBrush(hbmp);
    }

    ~CPatternBrush()
    {
        if (_hbr)
            DeleteObject(_hbr);
    }

    operator HBRUSH()
    {
        return _hbr;
    }

private:
    HBRUSH _hbr;
};

class CBitmapDC
{
public:
    CBitmapDC(BOOL fCompat = FALSE)
    {
        _hbmp = NULL;
        _hbmpOld = NULL;
        _hbrOld = NULL;

        if (!fCompat)
            _hdc = CreateDC("DISPLAY", NULL, NULL, NULL);
        else
        {
            _hdc = CreateCompatibleDC(NULL);
        }

        Assert(HandleToULong(_hdc));
    }

    ~CBitmapDC()
    {
        Uninit();
        DeleteDC(_hdc);

    }

    void Uninit(BOOL fKeep = FALSE)
    {
        if (_hbmpOld)
        {
            SelectObject(_hdc, _hbmpOld);
            _hbmpOld = NULL;
        }

        if (_hbrOld)
        {
            SelectObject(_hdc, _hbrOld);
            _hbrOld = NULL;
        }

        if (!fKeep && _hbmp != NULL)
        {
            DeleteObject(_hbmp);
            _hbmp = NULL;
        }
    }

    BOOL SetCompatibleBitmap(int x, int y)
    {
        Assert(!_hbmp);
        Assert(!_hbmpOld);

        HDC hdc  = GetDC(NULL);
        _hbmp = CreateCompatibleBitmap(hdc, x, y);
        ReleaseDC(NULL, hdc);
        Assert(HandleToULong(_hbmp));
        _hbmpOld = (HBITMAP)SelectObject(_hdc, _hbmp);
        Assert(HandleToULong(_hbmpOld));
        return TRUE;
    }

    BOOL SetDIB(int cx, int cy, WORD iPlanes = 1, WORD iBitCount = 32)
    {
        BITMAPINFO bi = {0};
        bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
        bi.bmiHeader.biWidth = cx;
        bi.bmiHeader.biHeight = cy;
        bi.bmiHeader.biPlanes = iPlanes;
        bi.bmiHeader.biBitCount = iBitCount;
        bi.bmiHeader.biCompression = BI_RGB;

        _hbmp = CreateDIBSection(_hdc, &bi, DIB_RGB_COLORS, NULL, NULL, 0);
        Assert(HandleToULong(_hbmp));
        _hbmpOld = (HBITMAP)SelectObject(_hdc, _hbmp);
        Assert(HandleToULong(_hbmpOld));
        return TRUE;
    }


    BOOL SetBitmap(int x, int y, int cPlanes, int cBitPerPixel)
    {
        Assert(!_hbmp);
        Assert(!_hbmpOld);

        _hbmp = CreateBitmap(x, y, cPlanes, cBitPerPixel, NULL);
        Assert(HandleToULong(_hbmp));
        _hbmpOld = (HBITMAP)SelectObject(_hdc, _hbmp);
        Assert(HandleToULong(_hbmpOld));
        return TRUE;
    }

    BOOL SetBitmap(HBITMAP hbmp)
    {
        if (_hdc)
        {
           Assert(!_hbmpOld);

           _hbmpOld = (HBITMAP)SelectObject(_hdc, hbmp);
           Assert(HandleToULong(_hbmpOld));
        }
        return TRUE;
    }

    BOOL SetBitmapFromRes(HINSTANCE hInst, LPCSTR lp)
    {
        Assert(!_hbmp);
        Assert(!_hbmpOld);

        _hbmp = LoadBitmap(hInst, lp);
        Assert(HandleToULong(_hbmp));
        _hbmpOld = (HBITMAP)SelectObject(_hdc, _hbmp);
        Assert(HandleToULong(_hbmpOld));
        return TRUE;
    }

    BOOL SetBrush(HBRUSH hbr)
    {
        if (hbr)
        {
            _hbrOld = (HBRUSH)SelectObject(_hdc, hbr);
            Assert(HandleToULong(_hbrOld));
        }
        else
        {
            SelectObject(_hdc, _hbrOld);
            _hbrOld =  NULL;
        }
        return TRUE;
    }

    operator HDC()
    {
        return _hdc;
    }

    HBITMAP GetBitmapAndKeep()
    {
        HBITMAP hbmp = _hbmp;

        // don't delet _hbmp;
        _hbmp = NULL;
        return hbmp;
    }
    HBITMAP GetBitmap()
    {
        return _hbmp;
    }

private:
    HBITMAP _hbmp;
    HBITMAP _hbmpOld;
    HBRUSH _hbrOld;
    HDC _hdc;
};

__inline HBITMAP StretchBitmap(HBITMAP hbmp, int cx, int cy)
{
    BITMAP bmp;
    CBitmapDC hdcSrc(TRUE);
    CBitmapDC hdcDst(TRUE);

    GetObject( hbmp, sizeof(bmp), &bmp );

    hdcSrc.SetBitmap(hbmp);
    hdcDst.SetCompatibleBitmap(cx, cy);
    StretchBlt(hdcDst, 0, 0, cx, cy, 
               hdcSrc, 0, 0, bmp.bmWidth, bmp.bmHeight, SRCCOPY);

    return hdcDst.GetBitmapAndKeep();
}

_inline UINT GetPhysicalFontHeight(LOGFONT &lf)
{
    HDC hdc = GetDC(NULL);
    HFONT hfont;
    UINT nRet = 0;

    if((hfont = CreateFontIndirect(&lf)))
    {
        TEXTMETRIC tm;
        HFONT hfontOld;
        hfontOld = (HFONT)SelectObject( hdc, hfont);

        GetTextMetrics(hdc, &tm);
        nRet = tm.tmHeight + tm.tmExternalLeading;

        if (hfontOld)
            SelectObject(hdc, hfontOld);

        DeleteObject(hfont);
    }
    ReleaseDC(NULL, hdc);

    return nRet;
}

#endif // CMYDC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\cleanup.h ===
//
// cleanup.h
//

#ifndef CLEANUP_H
#define CLEANUP_H

struct ICleanupContextsClient : public IUnknown
{
    virtual HRESULT IsInterestedInContext(ITfContext *pic, BOOL *pfInterested) = 0;

    virtual HRESULT CleanupContext(TfEditCookie ecWrite, ITfContext *pic) = 0;
};

typedef void (*CLEANUP_COMPOSITIONS_CALLBACK)(TfEditCookie ecWrite, ITfRange *rangeComposition, void *pvPrivate);

BOOL CleanupAllCompositions(TfEditCookie ecWrite, ITfContext *pic, REFCLSID clsidOwner, CLEANUP_COMPOSITIONS_CALLBACK pfnCleanupCompositons, void *pvPrivate);

BOOL CleanupAllContexts(ITfThreadMgr *tim, TfClientId tid, ICleanupContextsClient *pClient);

#endif // CLEANUP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\cicspres.h ===
#ifndef CICSPRES_H
#define CICSPRES_H

#include "cicutil.h"

#ifdef CIC_XPSP1

#include "xpsp1res.h"


//
// INPUTDLL resource ID definition in XP SP1.
//
#undef DLG_INPUT_ADVANCED
#undef DLG_TOOLBAR_SETTING

#undef IDS_ADVANCED_CUAS_TEXT
#undef IDS_ADVANCED_CTFMON_TEXT

#undef IDC_TB_STATIC
#undef IDC_TB_SHOWLANGBAR
#undef IDC_TB_HIGHTRANS
#undef IDC_TB_EXTRAICON
#undef IDC_TB_TEXTLABELS
#undef IDC_TB_DISABLETEXTSERVICE

#undef IDC_ADVANCED_CUAS_ENABLE
#undef IDC_ADVANCED_CUAS_TEXT
#undef IDC_ADVANCED_CTFMON_DISABLE
#undef IDC_ADVANCED_CTFMON_TEXT
#undef IDC_GROUPBOX1
#undef IDC_GROUPBOX2

#define DLG_INPUT_ADVANCED                  DLG_INPUTDLL_INPUT_ADVANCED
#define DLG_TOOLBAR_SETTING                 DLG_INPUTDLL_TOOLBAR_SETTING

#define IDS_ADVANCED_CUAS_TEXT              IDS_INPUTDLL_ADVANCED_CUAS_TEXT
#define IDS_ADVANCED_CTFMON_TEXT            IDS_INPUTDLL_ADVANCED_CTFMON_TEXT

#define IDC_TB_STATIC                       IDC_INPUTDLL_TB_STATIC
#define IDC_TB_SHOWLANGBAR                  IDC_INPUTDLL_TB_SHOWLANGBAR
#define IDC_TB_HIGHTRANS                    IDC_INPUTDLL_TB_HIGHTRANS
#define IDC_TB_EXTRAICON                    IDC_INPUTDLL_TB_EXTRAICON
#define IDC_TB_TEXTLABELS                   IDC_INPUTDLL_TB_TEXTLABELS
#define IDC_TB_DISABLETEXTSERVICE

#define IDC_ADVANCED_CUAS_ENABLE            IDC_INPUTDLL_ADVANCED_CUAS_ENABLE
#define IDC_ADVANCED_CUAS_TEXT              IDC_INPUTDLL_ADVANCED_CUAS_TEXT
#define IDC_ADVANCED_CTFMON_DISABLE         IDC_INPUTDLL_ADVANCED_CTFMON_DISABLE
#define IDC_ADVANCED_CTFMON_TEXT            IDC_INPUTDLL_ADVANCED_CTFMON_TEXT
#define IDC_GROUPBOX1                       IDC_INPUTDLL_GROUPBOX1
#define IDC_GROUPBOX2                       IDC_INPUTDLL_GROUPBOX2


//
// Msctfime resource ID definition in XP SP1.
//
#undef IDS_ENTER_BTN_TEXT
#undef IDS_ENTER_BTN_TOOLTIP
#undef IDS_FUNCPRV_CONVERSION

#define IDS_ENTER_BTN_TEXT                  IDS_MSCTFIME_ENTER_BTN_TEXT
#define IDS_ENTER_BTN_TOOLTIP               IDS_MSCTFIME_ENTER_BTN_TOOLTIP
#define IDS_FUNCPRV_CONVERSION              IDS_MSCTFIME_FUNCPRV_CONVERSION


//
// SPTIP Resource ID definition in XP SP1.
//

#undef IDS_SHARDCMD_FILE
#undef IDS_GO_TO_SLEEP
#undef IDS_WAKE_UP
#undef IDS_PROPERTYPAGE_TITLE
#undef IDS_SPCMD_SELECT_ALL
#undef IDS_SPCMD_SELECT_THAT
#undef IDS_REPLAY
#undef IDS_DELETE
#undef IDS_REDO
#undef IDS_ADDTODICTIONARYPREFIX
#undef IDS_ADDTODICTIONARYPOSTFIX
#undef IDS_DELETESELECTION

#undef IDD_PROPERTY_PAGE
#undef IDD_PP_DIALOG_ADVANCE
#undef IDD_PP_DIALOG_BUTTON_SET

#undef IDC_PP_SHOW_BALLOON
#undef IDC_PP_LMA
#undef IDC_PP_HIGH_CONFIDENCE
#undef IDC_PP_SAVE_SPDATA
#undef IDC_PP_REMOVE_SPACE
#undef IDC_PP_DIS_DICT_TYPING
#undef IDC_PP_PLAYBACK
#undef IDC_PP_DICT_CANDUI_OPEN
#undef IDC_PP_DICTCMDS
#undef IDC_PP_ASSIGN_BUTTON
#undef IDC_PP_BUTTON_MB_SETTING
#undef IDC_PP_BUTTON_ADVANCE
#undef IDC_PP_BUTTON_LANGBAR
#undef IDC_PP_BUTTON_SPCPL
#undef IDC_PP_SELECTION_CMD
#undef IDC_PP_NAVIGATION_CMD
#undef IDC_PP_CASING_CMD
#undef IDC_PP_EDITING_CMD
#undef IDC_PP_KEYBOARD_CMD
#undef IDC_PP_DICTATION_CMB
#undef IDC_PP_COMMAND_CMB
#undef IDC_PP_LANGBAR_CMD
#undef IDC_GP_VOICE_COMMANDS
#undef IDC_GP_MODE_BUTTONS
#undef IDC_GP_ADVANCE_SET
#undef IDC_DESCRIPT_TEXT

#define IDS_SHARDCMD_FILE                   IDS_SPTIP_SHARDCMD_FILE
#define IDS_GO_TO_SLEEP                     IDS_SPTIP_GO_TO_SLEEP
#define IDS_WAKE_UP                         IDS_SPTIP_WAKE_UP
#define IDS_PROPERTYPAGE_TITLE              IDS_SPTIP_PROPERTYPAGE_TITLE
#define IDS_SPCMD_SELECT_ALL                IDS_SPTIP_SPCMD_SELECT_ALL
#define IDS_SPCMD_SELECT_THAT               IDS_SPTIP_SPCMD_SELECT_THAT
#define IDS_REPLAY                          IDS_SPTIP_REPLAY
#define IDS_DELETE                          IDS_SPTIP_DELETE
#define IDS_REDO                            IDS_SPTIP_REDO
#define IDS_ADDTODICTIONARYPREFIX           IDS_SPTIP_ADDTODICTIONARYPREFIX
#define IDS_ADDTODICTIONARYPOSTFIX          IDS_SPTIP_ADDTODICTIONARYPOSTFIX
#define IDS_DELETESELECTION                 IDS_SPTIP_DELETESELECTION

#define IDD_PROPERTY_PAGE                   IDD_SPTIP_PROPERTY_PAGE
#define IDD_PP_DIALOG_ADVANCE               IDD_SPTIP_PP_DIALOG_ADVANCE
#define IDD_PP_DIALOG_BUTTON_SET            IDD_SPTIP_PP_DIALOG_BUTTON_SET

#define IDC_PP_SHOW_BALLOON                 IDC_SPTIP_PP_SHOW_BALLOON
#define IDC_PP_LMA                          IDC_SPTIP_PP_LMA
#define IDC_PP_HIGH_CONFIDENCE              IDC_SPTIP_PP_HIGH_CONFIDENCE
#define IDC_PP_SAVE_SPDATA                  IDC_SPTIP_PP_SAVE_SPDATA
#define IDC_PP_REMOVE_SPACE                 IDC_SPTIP_PP_REMOVE_SPACE
#define IDC_PP_DIS_DICT_TYPING              IDC_SPTIP_PP_DIS_DICT_TYPING
#define IDC_PP_PLAYBACK                     IDC_SPTIP_PP_PLAYBACK
#define IDC_PP_DICT_CANDUI_OPEN             IDC_SPTIP_PP_DICT_CANDUI_OPEN
#define IDC_PP_DICTCMDS                     IDC_SPTIP_PP_DICTCMDS
#define IDC_PP_ASSIGN_BUTTON                IDC_SPTIP_PP_ASSIGN_BUTTON
#define IDC_PP_BUTTON_MB_SETTING            IDC_SPTIP_PP_BUTTON_MB_SETTING
#define IDC_PP_BUTTON_ADVANCE               IDC_SPTIP_PP_BUTTON_ADVANCE
#define IDC_PP_BUTTON_LANGBAR               IDC_SPTIP_PP_BUTTON_LANGBAR
#define IDC_PP_BUTTON_SPCPL                 IDC_SPTIP_PP_BUTTON_SPCPL
#define IDC_PP_SELECTION_CMD                IDC_SPTIP_PP_SELECTION_CMD
#define IDC_PP_NAVIGATION_CMD               IDC_SPTIP_PP_NAVIGATION_CMD
#define IDC_PP_CASING_CMD                   IDC_SPTIP_PP_CASING_CMD
#define IDC_PP_EDITING_CMD                  IDC_SPTIP_PP_EDITING_CMD
#define IDC_PP_KEYBOARD_CMD                 IDC_SPTIP_PP_KEYBOARD_CMD
#define IDC_PP_DICTATION_CMB                IDC_SPTIP_PP_DICTATION_CMB
#define IDC_PP_COMMAND_CMB                  IDC_SPTIP_PP_COMMAND_CMB
#define IDC_PP_LANGBAR_CMD                  IDC_SPTIP_PP_LANGBAR_CMD
#define IDC_GP_VOICE_COMMANDS               IDC_SPTIP_GP_VOICE_COMMANDS
#define IDC_GP_MODE_BUTTONS                 IDC_SPTIP_GP_MODE_BUTTONS
#define IDC_GP_ADVANCE_SET                  IDC_SPTIP_GP_ADVANCE_SET
#define IDC_DESCRIPT_TEXT                   IDC_SPTIP_DESCRIPT_TEXT


#endif // CIC_XPSP1
#endif // CICSPRES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\cicmutex.h ===
//
// cicmutex.h
//


#ifndef CICMUTEX_H
#define CICMUTEX_H


class CCicMutexHelper;

struct CCicMutex
{
public:
    BOOL Init(SECURITY_ATTRIBUTES *psa, TCHAR *psz)
    {
        _hMutex = CreateMutex(psa, FALSE, psz);
        Assert(_hMutex);
        return _hMutex ? TRUE : FALSE;
    }

    void Uninit()
    {
        if (_hMutex)
            CloseHandle(_hMutex);
        _hMutex = NULL;

        return;
    }


    BOOL Enter()
    {
        Assert(_hMutex);
        DWORD dwWaitResult = WaitForSingleObject(_hMutex, 5000);
        if (dwWaitResult == WAIT_OBJECT_0)
        {
            return TRUE;
        }
        else if (dwWaitResult == WAIT_ABANDONED)
        {
            TraceMsg(TF_EVENT, "CicMutex abandoned");
            return TRUE;
        }

        TraceMsg(TF_EVENT, "CicMutex Time Out");

        //
        // assert here to debug stop.
        //
        Assert(0);
        return FALSE;
    }

    void Leave()
    {
        Assert(_hMutex);
        ReleaseMutex(_hMutex);
    }

private:
    HANDLE  _hMutex;
};

class CCicMutexHelperStatic
{
public:
    void Init(CCicMutex *pcicmutex)
    {
        _pcicmutex = pcicmutex;
        SetIn(FALSE);
    }

    void Uninit()
    {
        Assert(!_fIn);
        _pcicmutex = NULL;
    }

    BOOL Enter()
    {
        BOOL bRet = _pcicmutex->Enter();
        SetIn(TRUE);
        return bRet;
    }

    void Leave()
    {
        SetIn(FALSE);
        _pcicmutex->Leave();
    }

    BOOL Invalid() 
    {
        return _pcicmutex ? TRUE : FALSE;
    }

protected:
    CCicMutex *_pcicmutex;
#ifdef DEBUG
    void SetIn(BOOL fIn) {_fIn = fIn;}
    BOOL _fIn;
#else
    void SetIn(BOOL fIn) {}
#endif
};

class CCicMutexHelper : public CCicMutexHelperStatic
{
public:
    CCicMutexHelper(CCicMutex *pcicmutex = NULL)
    {
#ifdef DEBUG
        _fIn = FALSE;
#endif
        _pcicmutex = NULL;
        if (pcicmutex)
            Init(pcicmutex);
    }

    ~CCicMutexHelper()
    {
        Assert(!_fIn);
    }
};

class CCicFileMappingStatic
{
public:
    void BaseInit()
    {
        _pv = NULL;
        _hfm = NULL;
    }

    void Finalize()
    {
        if (_fUseMutex)
        {
            Close();
  
            //
            // mutexhlp could be invalid if Uninit() was called.
            //
            if (_mutexhlp.Invalid())
                _mutexhlp.Leave();
        }
        else 
        {
            //
            // Close() must be called when client's own mutex is released,
            // if _fuseMutex is FALSE.
            //
            Assert(!_hfm);
        }
    }

    void Init(TCHAR *pszFile, CCicMutex *pmutex)
    {
        Assert(!_hfm);
        Assert(!_pv);
        if (pmutex)
            _mutexhlp.Init(pmutex);

        _pszFile = pszFile;
        _fCreated = FALSE;
        _fUseMutex = pmutex ? TRUE : FALSE;
    }

    void Uninit()
    {
        _mutexhlp.Uninit();
    }

    void *Open()
    {
        Assert(!_hfm);

        if (!_pszFile)
        {
            Assert(0);
            return NULL;
        }

        _hfm = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, _pszFile);

        if (_hfm == NULL)
            return NULL;

        return _Map();
    }

    void *Create(SECURITY_ATTRIBUTES *psa, ULONG cbSize, BOOL *pfAlreadyExists)
    {
        Assert(!_hfm);

        if (!_pszFile)
        {
            Assert(0);
            return NULL;
        }

        _hfm = CreateFileMapping(INVALID_HANDLE_VALUE, psa, PAGE_READWRITE,
                                 0, cbSize, _pszFile);

        if (pfAlreadyExists != NULL)
        {
            *pfAlreadyExists = (GetLastError() == ERROR_ALREADY_EXISTS);
        }

        if (_hfm == NULL)
            return NULL;

        _fCreated = TRUE;
        return _Map();
    }

    BOOL Flush(UINT cbSize)
    {
        if (!_pv)
            return FALSE;

        return FlushViewOfFile(_pv, cbSize);
    }

    void Close()
    {
        if (_pv)
            UnmapViewOfFile(_pv);

        if (_hfm)
            CloseHandle(_hfm);

        _pv = NULL;
        _hfm = NULL;
        _fCreated = FALSE;
    }

    void SetName(TCHAR *psz) {_pszFile = psz;}

    BOOL Enter()
    {
        if (_fUseMutex)
            if (!_mutexhlp.Enter())
                return FALSE;

        return TRUE;
    }

    void Leave()
    {
        if (_fUseMutex)
            _mutexhlp.Leave();
    }

    BOOL IsCreated() { return _fCreated; }

private:
    void *_Map()
    {
        Assert(!_pv);
        _pv = (void *)MapViewOfFile(_hfm, FILE_MAP_WRITE, 0, 0, 0);
        if (!_pv)
        {
            CloseHandle(_hfm);
            _hfm = NULL;
        }
        return _pv;
    }

protected:
    TCHAR *_pszFile;
    void *_pv;
private:
    HANDLE _hfm;
    BOOL _fCreated;
    BOOL _fUseMutex;
    CCicMutexHelperStatic _mutexhlp;
};

class CCicFileMapping : public CCicFileMappingStatic
{
public:
    CCicFileMapping(TCHAR *pszFile = NULL, CCicMutex *pmutex = NULL)
    {
        BaseInit();
        Init(pszFile, pmutex );
    }

    virtual ~CCicFileMapping()
    {
        Finalize();
    }
};

class CCicEvent
{
public:
    CCicEvent(TCHAR *psz = NULL)
    {
        _psz = psz;
        _hEvent = NULL;
    }

    ~CCicEvent()
    {
        Uninit();
    }

    BOOL Create(SECURITY_ATTRIBUTES *psa, TCHAR *psz = NULL)
    {
        if (psz)
        {
            Assert(!_psz);
            _psz = psz;
        }

        if (!_psz)
        {
            Assert(0);
            return FALSE;
        }

        Assert(!_hEvent);

        _hEvent = CreateEvent(psa, FALSE, FALSE, _psz);

#ifdef DEBUG
        TraceMsg(TF_EVENT, "%s CCicEvent::Create %x %s", _szModule, _hEvent, _psz);
#endif

        Assert(_hEvent);
        return _hEvent ? TRUE : FALSE;
    }

    BOOL Open(TCHAR *psz = NULL)
    {
        if (psz)
        {
            Assert(!_psz);
            _psz = psz;
        }
        Assert(!_hEvent);
        Assert(_psz);

        _hEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, _psz);
#ifdef DEBUG
        TraceMsg(TF_EVENT, "%s CCicEvent::Open %x %s", _szModule, _hEvent, _psz);
#endif
          
        // Assert(_hEvent);

#ifdef DEBUG
        if (!_hEvent)
        {
            DWORD dwError = GetLastError();
            TraceMsg(TF_EVENT, "OpenEvent error = %x %s\r\n", dwError, _psz);
        }
#endif

        return _hEvent ? TRUE : FALSE;
    }

    void Uninit()
    {
#ifdef DEBUG
        TraceMsg(TF_EVENT, "%s CCicEvent::Close %x %s", _szModule, _hEvent, _psz);
#endif
        if (_hEvent)
            CloseHandle(_hEvent);
        _hEvent = NULL;
        return;
    }

    BOOL Wait(DWORD dwMillisecouds)
    {
#ifdef DEBUG
        TraceMsg(TF_EVENT, "%s CCicEvent::Wait %x %s", _szModule, _hEvent, _psz);
#endif
        DWORD dwWaitResult = WaitForSingleObject(_hEvent, dwMillisecouds);
        if (dwWaitResult == WAIT_OBJECT_0)
        {
            return TRUE;
        }

#ifdef DEBUG
        TraceMsg(TF_EVENT, "%s CCicEvent Time Out", _szModule);
#endif

        //
        // assert here to debug stop.
        //
        // Assert(0);
        return FALSE;
    }

    DWORD EventCheck()
    {
        Assert(_hEvent);
        return WaitForSingleObject(_hEvent, 0);
    }

    DWORD MsgWait(DWORD dwWaitTime, DWORD dwWakeMask, DWORD dwFlags = 0)
    {
        Assert(_hEvent);
#ifdef DEBUG
        TraceMsg(TF_EVENT, "%s CCicEvent::MsgWait %x %s", _szModule, _hEvent, _psz);
#endif
        DWORD dwWaitResult;
        dwWaitResult =  MsgWaitForMultipleObjects(1,
                                                  &_hEvent,
                                                  FALSE,
                                                  dwWaitTime,
                                                  dwWakeMask);
#ifdef DEBUG
        if (dwWaitResult == WAIT_TIMEOUT)
        {
            TraceMsg(TF_EVENT, "%s CCicEvent Time Out::timeout val=%d", _szModule, dwWaitTime);
        }
#endif
        return dwWaitResult;
    }

    void Set()
    {
#ifdef DEBUG
        TraceMsg(TF_EVENT, "%s CCicEvent::Set %x %s", _szModule, _hEvent, _psz);
#endif
        SetEvent(_hEvent);
    }

    void Reset()
    {
#ifdef DEBUG
        TraceMsg(TF_EVENT, "%s CCicEvent::ReSet %x %s", _szModule, _hEvent, _psz);
#endif
        ResetEvent(_hEvent);
    }

    void SetName(TCHAR *psz) {_psz = psz;}


private:
    HANDLE _hEvent;

#ifdef DEBUG
    TCHAR  _szModule[MAX_PATH];
#endif

protected:
    TCHAR *_psz;
};

class CCicTimer
{
public:
    CCicTimer(DWORD dwMilliSeconds, BOOL fStart = TRUE)
    {
        _dwTimeOut = dwMilliSeconds / 10;
        _dwTimeToWait = (DWORD)(-1);
        _dwStartTime = (DWORD)(-1);
        if (fStart)
            Start();
    }

    void Start()
    {
        _dwStartTime = GetTickCount() / 10;
        _dwTimeToWait = _dwStartTime + _dwTimeOut;
    }

    BOOL IsTimerAtZero()
    {
        DWORD dwNow = GetTickCount() / 10;
        if (_dwTimeToWait < dwNow)
           return TRUE;
        
        return FALSE;
    }

    BOOL IsTimerPass(DWORD dwWaitSec)
    {
        DWORD dwNow = GetTickCount() / 10;
        dwWaitSec /= 10;
        if (dwNow - _dwStartTime > dwWaitSec)
           return TRUE;
        
        return FALSE;
    }

private:
    DWORD _dwTimeToWait;
    DWORD _dwStartTime;
    DWORD _dwTimeOut;
};

    

#endif // CICMUTEX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\computil.h ===
//
// computil.h
//


#ifndef COMPUTIL_H
#define COMPUTIL_H

#include "private.h"
#include "strary.h"
#include "immxutil.h"

HRESULT GetCompartment(IUnknown *punk, REFGUID rguidComp, ITfCompartment **ppComp, BOOL fGlobal);
HRESULT SetCompartmentDWORD(TfClientId tid, IUnknown *punk, REFGUID rguidComp, DWORD dw, BOOL fGlobal);
HRESULT GetCompartmentDWORD(IUnknown *punk, REFGUID rguidComp, DWORD *pdw, BOOL fGlobal);
HRESULT ToggleCompartmentDWORD(TfClientId tid, IUnknown *punk, REFGUID rguidComp, BOOL fGlobal);
HRESULT SetCompartmentGUIDATOM(TfClientId tid, IUnknown *punk, REFGUID rguidComp, TfClientId ga, BOOL fGlobal);
HRESULT GetCompartmentGUIDATOM(IUnknown *punk, REFGUID rguidComp, TfClientId *pga, BOOL fGlobal);
HRESULT SetCompartmentGUID(LIBTHREAD *plt, TfClientId tid, IUnknown *punk, REFGUID rguidComp, REFGUID rguid, BOOL fGlobal);
HRESULT GetCompartmentGUID(LIBTHREAD *plt, IUnknown *punk, REFGUID rguidComp, GUID *pguid, BOOL fGlobal);
HRESULT SetCompartmentUnknown(TfClientId tid, IUnknown *punk, REFGUID rguidComp, IUnknown *punkPriv);
HRESULT GetCompartmentUnknown(IUnknown *punk, REFGUID rguidComp, IUnknown **ppunkPriv);
HRESULT ClearCompartment(TfClientId tid, IUnknown *punk, REFGUID rguidComp, BOOL fGlobal);

typedef struct tag_CESMAP {
    ITfCompartment *pComp;
    DWORD dwCookie;
} CESMAP;

#define CES_INVALID_COOKIE  ((DWORD)(-1))

typedef HRESULT (*CESCALLBACK)(void *pv, REFGUID rguid);

class CCompartmentEventSink : public ITfCompartmentEventSink
{
public:
    CCompartmentEventSink(CESCALLBACK pfnCallback, void *pv);
    virtual ~CCompartmentEventSink() {};

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfCompartmentEventSink
    //
    STDMETHODIMP OnChange(REFGUID rguid);

    HRESULT _Advise(IUnknown *punk, REFGUID rguidComp, BOOL fGlobal);
    HRESULT _Unadvise();

protected:
    void SetCallbackPV(void* pv)
    {
        if (_pv == NULL)
            _pv = pv;
    };

private:
    CStructArray<CESMAP> _rgcesmap;

    long _cRef;
    CESCALLBACK _pfnCallback;
    void *_pv;
};

#endif //COMPUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\cresstr.h ===
//
// cresstr.h
//


#ifndef CRESSTR_H
#define CRESSTR_H

#include "osver.h"
#include "mui.h"
#include "cicutil.h"

//
// assume we have static g_hInst.
//
extern HINSTANCE g_hInst;

/////////////////////////////////////////////////////////////////////////////
// 
// CRStr
// 
/////////////////////////////////////////////////////////////////////////////

class CRStr
{
public:
    CRStr(int nResId)
    {
        _nResId = nResId;
    }

    operator WCHAR*()
    {
        LoadStringWrapW(g_hInst, _nResId, _sz, ARRAYSIZE(_sz));
        return _sz;
    }

    operator char*()
    {
        LoadStringA(g_hInst, _nResId, (char *)_sz, sizeof(_sz));
        return (char *)&_sz[0];
    }

private:
    int _nResId;
    WCHAR _sz[64];
};

class CRStr2
{
public:
    CRStr2(int nResId)
    {
        _nResId = nResId;
    }

    operator WCHAR*()
    {
        LoadStringWrapW(GetCicResInstance(g_hInst, _nResId), _nResId, _sz, ARRAYSIZE(_sz));
        return _sz;
    }

    operator char*()
    {
        LoadStringA(GetCicResInstance(g_hInst, _nResId), _nResId, (char *)_sz, sizeof(_sz));
        return (char *)&_sz[0];
    }

private:
    int _nResId;
    WCHAR _sz[256];
};

#endif // CRESSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\combase.h ===
//+---------------------------------------------------------------------------
//
//  File:       combase.h
//
//  Contents:   IUnknown and COM server declarations.
//
//  Using this file:
//
//  1. For each C++ class you want to expose as a COM object, derive from
//
//      CComObjectRootImmx - standard COM object
//      CComObjectRootImmx_NoDllAddRef - internal COM object
//      CComObjectRootImmx_InternalReference - internal/external object
//      CComObjectRoot_CreateInstance - standard COM object, exposed directly
//              from class factory.
//      CComObjectRoot_CreateInstanceSingleton - standard COM object, exposed
//              directly from class factory, one instance per thread.
//      CComObjectRoot_CreateInstanceSingleton_Verify - standard COM object,
//              exposed directly from class factory, one instance per thread.
//              Includes callback to fail create instance for custom reasons,
//              and a callback after the singleton is successfully created.
//
//  2. For each C++ class, declare the interfaces exposed by QueryInterface
//     using the BEGIN_COM_MAP_IMMX macro.  IUknown will be automatically mapped
//     to the first interface listed.  The IUnknown methods are implemented by
//     the BEGIN_COM_MAP_IMMX macro.
//
//  3. Use the BEGIN_COCLASSFACTORY_TABLE macro to declare the COM objects you
//     want to expose directly from the class factory.
//
//  4. Implement DllInit(), DllUninit(), DllRegisterServerCallback(),
//     DllUnregisterServerCallback(), and GetServerHINSTANCE.
//     Behavior commented next to the prototypes below.
//
//  Example:
//
//  // this class is exposed by the class factory
//  class MyCoCreateableObject : public ITfLangBarItemMgr,
//                               public CComObjectRoot_CreateInstance<MyCoCreateableObject>
//  {
//      MyCoCreateableObject();
//
//      BEGIN_COM_MAP_IMMX(MyCoCreateableObject)
//        COM_INTERFACE_ENTRY(ITfLangBarItemMgr)
//      END_COM_MAP_IMMX()
//  };
//
//  // this class is only exposed indirectly, through another interface
//  class MyObject : public ITfLangBarItemMgr,
//                   public CComObjectRootImmx
//  {
//      MyCoCreateableObject();
//
//      BEGIN_COM_MAP_IMMX(MyObject)
//        COM_INTERFACE_ENTRY(ITfLangBarItemMgr)
//      END_COM_MAP_IMMX()
//  };
//
//  // in .cpp file, declare the objects exposed through the class factory
//  // along with thier clsid and description.  Currently the apartment
//  // threading model is assumed.
//  BEGIN_COCLASSFACTORY_TABLE
//    DECLARE_COCLASSFACTORY_ENTRY(CLSID_TF_LangBarItemMgr, MyCoCreateableObject::CreateInstance, TEXT("TF_LangBarItemMgr"))
//  END_COCLASSFACTORY_TABLE
//
//  // finally implement DllInit(), DllUninit(), DllRegisterServerCallback(),
//  // DllUnregisterServerCallback(), and GetServerHINSTANCE.
//----------------------------------------------------------------------------

#ifndef UNKNOWN_H
#define UNKNOWN_H

#include "private.h"
#ifdef __cplusplus

//+---------------------------------------------------------------------------
//
//  extern prototypes that the server dll must implement
//
//----------------------------------------------------------------------------

// Called on every new external object reference.
BOOL DllInit(void);
// Called when an external reference goes away.
void DllUninit(void);

// Should return the server dll's HINSTANCE.
HINSTANCE GetServerHINSTANCE(void);
// Should return a mutex callable whenever the server ref count changes (i.e. not during DllMain).
CRITICAL_SECTION *GetServerCritSec(void);

//+---------------------------------------------------------------------------
//
//  COM server export implementations.
//
//----------------------------------------------------------------------------

HRESULT COMBase_DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppvObj);
HRESULT COMBase_DllCanUnloadNow(void);
HRESULT COMBase_DllRegisterServer(void);
HRESULT COMBase_DllUnregisterServer(void);

//+---------------------------------------------------------------------------
//
//  CComObjectRootImmx_NoDllAddRef
//
//  Use this base class if you don't want your COM object to AddRef the server.
//  Typically you DON'T want to do this.
//----------------------------------------------------------------------------

class CComObjectRootImmx_NoDllAddRef
{
public:
    CComObjectRootImmx_NoDllAddRef()
    {
        // Automatic AddRef().
        m_dwRef = 1L;

#ifdef DEBUG
        m_fTraceAddRef = FALSE;
#endif
    }

protected:

    virtual BOOL InternalReferenced()
    {
        return FALSE;
    }

    void DebugRefBreak()
    {
#ifdef DEBUG
        if (m_fTraceAddRef)
        {
            DebugBreak();
        }
#endif
    }

    long m_dwRef;
#ifdef DEBUG
    BOOL m_fTraceAddRef;
#endif
};

//+---------------------------------------------------------------------------
//
//  CComObjectRootImmx
//
//  Use this base class for standard COM objects.
//----------------------------------------------------------------------------

class CComObjectRootImmx : public CComObjectRootImmx_NoDllAddRef
{
public:
    CComObjectRootImmx()
    {
        void DllAddRef(void);
        DllAddRef();
    }

    ~CComObjectRootImmx()
    {
        void DllRelease(void);
        DllRelease();
    }
};

//+---------------------------------------------------------------------------
//
//  CComObjectRootImmx_InternalReference
//
//  Use this base class for COM objects that have an "internal reference".
//
//  With this base class, the server will only be AddRef'd if the object
//  ref count reaches 2.  The server will be Release'd when the object
//  ref count returns to 1.  This allows the object to be held internally
//  (and even released in DllMain) while still allowing outside references.
//----------------------------------------------------------------------------

class CComObjectRootImmx_InternalReference : public CComObjectRootImmx_NoDllAddRef
{
public:
    CComObjectRootImmx_InternalReference() {}

    BOOL InternalReferenced()
    { 
        return TRUE;
    }
};

typedef BOOL (*VERIFYFUNC)(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);
typedef void (*POSTCREATE)(REFIID riid, void *pvObj);

// helper function, don't call this directly
template<class DerivedClass>
static HRESULT Unk_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj, VERIFYFUNC pfnVerify, POSTCREATE pfnPostCreate)
{
    DerivedClass *pObject;
    HRESULT hr;

    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (pUnkOuter != NULL)
        return CLASS_E_NOAGGREGATION;

    if (pfnVerify != NULL && !pfnVerify(pUnkOuter, riid, ppvObj))
        return E_FAIL;

    pObject = new DerivedClass;

    if (pObject == NULL)
        return E_OUTOFMEMORY;

    hr = pObject->QueryInterface(riid, ppvObj);

    pObject->Release();

    if (hr == S_OK && pfnPostCreate != NULL)
    {
        pfnPostCreate(riid, ppvObj);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  CComObjectRoot_CreateInstance
//
//  Use this base class for standard COM objects that are exposed directly
//  from the class factory.
//----------------------------------------------------------------------------

template<class DerivedClass>
class CComObjectRoot_CreateInstance : public CComObjectRootImmx
{
public:
    CComObjectRoot_CreateInstance() {}

    static HRESULT CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
    {
        return Unk_CreateInstance<DerivedClass>(pUnkOuter, riid, ppvObj, NULL, NULL);
    }
};

//+---------------------------------------------------------------------------
//
//  CComObjectRoot_CreateInstance_Verify
//
//  Use this base class for standard COM objects that are exposed directly
//  from the class factory.
//----------------------------------------------------------------------------

template<class DerivedClass>
class CComObjectRoot_CreateInstance_Verify : public CComObjectRootImmx
{
public:
    CComObjectRoot_CreateInstance_Verify() {}

    static HRESULT CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
    {
        return Unk_CreateInstance<DerivedClass>(pUnkOuter, riid, ppvObj,
            DerivedClass::VerifyCreateInstance, DerivedClass::PostCreateInstance);
    }
};

// helper function, don't call this directly
template<class DerivedClass>
static HRESULT Unk_CreateInstanceSingleton(IUnknown *pUnkOuter, REFIID riid, void **ppvObj, VERIFYFUNC pfnVerify, POSTCREATE pfnPostCreate)
{
    DerivedClass *pObject;
    HRESULT hr;

    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (pUnkOuter != NULL)
        return CLASS_E_NOAGGREGATION;

    pObject = DerivedClass::_GetThis();

    if (pObject == NULL)
    {
        if (pfnVerify != NULL && !pfnVerify(pUnkOuter, riid, ppvObj))
        {
            hr = E_FAIL;
            goto Exit;
        }

        pObject = new DerivedClass;

        if (pObject == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        hr = pObject->QueryInterface(riid, ppvObj);

        pObject->Release();

        if (hr == S_OK)
        {
            Assert(DerivedClass::_GetThis() != NULL); // _GetThis() should be set in object ctor on success
            if (pfnPostCreate != NULL)
            {
                pfnPostCreate(riid, *ppvObj);
            }
        }
    }
    else
    {
        hr = pObject->QueryInterface(riid, ppvObj);
    }

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  CComObjectRoot_CreateSingletonInstance
//
//  Use this base class for standard COM objects that are exposed directly
//  from the class factory, and are singletons (one instance per thread).
//
//  Classes deriving from this base must implement a _GetThis() method which
//  returns the singleton object, if it already exists, or null.
//----------------------------------------------------------------------------

template<class DerivedClass>
class CComObjectRoot_CreateSingletonInstance : public CComObjectRootImmx
{
public:
    CComObjectRoot_CreateSingletonInstance() {}

    static HRESULT CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
    {
        return Unk_CreateInstanceSingleton<DerivedClass>(pUnkOuter, riid, ppvObj, NULL, NULL);
    }
};

//+---------------------------------------------------------------------------
//
//  CComObjectRoot_CreateSingletonInstance_Verify
//
//  Use this base class for standard COM objects that are exposed directly
//  from the class factory, and are singletons (one instance per thread).
//
//  Classes deriving from this base must implement a VerifyCreateInstance
//  method that is called before allocating a new singleton instance, if
//  necessary.  The Verify method can return FALSE to fail the class factory
//  CreateInstance call for any reason.
//
//  The derived class must also implement a PostCreateInstance method that will
//  be called after allocating a new singleton, if the createinstance is about
//  to return S_OK (QueryInterface succecceded).  This method is intended for
//  lazy load work.
//
//  typedef BOOL (*VERIFYFUNC)(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);
//  typedef void (*POSTCREATE)(REFIID riid, void *pvObj);
//
//  Classes deriving from this base must implement a _GetThis() method which
//  returns the singleton object, if it already exists, or null.
//----------------------------------------------------------------------------

template<class DerivedClass>
class CComObjectRoot_CreateSingletonInstance_Verify : public CComObjectRootImmx
{
public:
    CComObjectRoot_CreateSingletonInstance_Verify() {}

    static HRESULT CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
    {
        return Unk_CreateInstanceSingleton<DerivedClass>(pUnkOuter, riid, ppvObj,
                DerivedClass::VerifyCreateInstance, DerivedClass::PostCreateInstance);
    }
};

//+---------------------------------------------------------------------------
//
//  BEGIN_COM_MAP_IMMX
//
//----------------------------------------------------------------------------

#define BEGIN_COM_MAP_IMMX(class_type)                                  \
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObject)          \
    {                                                                   \
        BOOL fUseFirstIID = FALSE;                                      \
                                                                        \
        if (ppvObject == NULL)                                          \
            return E_INVALIDARG;                                        \
                                                                        \
        *ppvObject = NULL;                                              \
                                                                        \
        if (IsEqualIID(IID_IUnknown, riid))                             \
        {                                                               \
            /* use first IID for IUnknown */                            \
            fUseFirstIID = TRUE;                                        \
        }

//+---------------------------------------------------------------------------
//
//  COM_INTERFACE_ENTRY
//
//----------------------------------------------------------------------------

#define COM_INTERFACE_ENTRY(interface_type)                             \
        if (fUseFirstIID || IsEqualIID(IID_##interface_type, riid))     \
        {                                                               \
            *ppvObject = (interface_type *)this;                        \
        }                                                               \
        else

//+---------------------------------------------------------------------------
//
//  COM_INTERFACE_ENTRY_IID
//
//----------------------------------------------------------------------------

#define COM_INTERFACE_ENTRY_IID(interface_iid, interface_type)          \
        if (fUseFirstIID || IsEqualIID(interface_iid, riid))            \
        {                                                               \
            *ppvObject = (interface_type *)this;                        \
        }                                                               \
        else

//+---------------------------------------------------------------------------
//
//  COM_INTERFACE_ENTRY_FUNC
//
//----------------------------------------------------------------------------

#define COM_INTERFACE_ENTRY_FUNC(interface_iid, param, pfn)             \
        /* compiler will complain about unused vars, so reuse fUseFirstIID if we need it here */ \
        if (IsEqualIID(interface_iid, riid) &&                          \
            (fUseFirstIID = pfn(this, interface_iid, ppvObject, param)) != S_FALSE) \
        {                                                               \
            return (HRESULT)fUseFirstIID; /* pfn set ppvObject */       \
        }                                                               \
        else

//+---------------------------------------------------------------------------
//
//  END_COM_MAP_IMMX
//
//----------------------------------------------------------------------------

#define END_COM_MAP_IMMX()                                              \
        {}                                                              \
        if (*ppvObject)                                                 \
        {                                                               \
            AddRef();                                                   \
            return S_OK;                                                \
        }                                                               \
                                                                        \
        return E_NOINTERFACE;                                           \
    }                                                                   \
                                                                        \
    STDMETHODIMP_(ULONG) AddRef()                                       \
    {                                                                   \
        void DllAddRef(void);                                           \
        DebugRefBreak();                                                \
                                                                        \
        if (m_dwRef == 1 && InternalReferenced())                       \
        {                                                               \
            /* first external reference to this object */               \
            DllAddRef();                                                \
        }                                                               \
                                                                        \
        return ++m_dwRef;                                               \
    }                                                                   \
                                                                        \
    STDMETHODIMP_(ULONG) Release()                                      \
    {                                                                   \
        void DllRelease(void);                                          \
        long cr;                                                        \
                                                                        \
        DebugRefBreak();                                                \
                                                                        \
        cr = --m_dwRef;                                                 \
        Assert(cr >= 0);                                                \
                                                                        \
        if (cr == 1 && InternalReferenced())                            \
        {                                                               \
            /* last external reference just went away */                \
            DllRelease();                                               \
        }                                                               \
        else if (cr == 0)                                               \
        {                                                               \
            delete this;                                                \
        }                                                               \
                                                                        \
        return cr;                                                      \
    }

// here for backwards compat with old atl based code, unused
#define IMMX_OBJECT_IUNKNOWN_FOR_ATL()

// class factory entry
typedef HRESULT (STDAPICALLTYPE * PFNCREATEINSTANCE)(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);

typedef struct
{
    const CLSID *pclsid;
    PFNCREATEINSTANCE pfnCreateInstance;
    const TCHAR *pszDesc;
} OBJECT_ENTRY;

// instantiated by the BEGIN_COCLASSFACTORY_TABLE macro
extern const OBJECT_ENTRY c_rgCoClassFactoryTable[];

//+---------------------------------------------------------------------------
//
//  DllRefCount
//
//  Returns the number of outstanding object references held by clients of the
//  server.  This is useful for asserting all objects have been released at
//  process detach, and for delay loading/unitializing resources.
//----------------------------------------------------------------------------

inline LONG DllRefCount()
{
    extern LONG g_cRefDll;

    // our ref starts at -1
    return g_cRefDll+1;
}

class CClassFactory;

//+---------------------------------------------------------------------------
//
//  BEGIN_COCLASSFACTORY_TABLE
//
//----------------------------------------------------------------------------

#define BEGIN_COCLASSFACTORY_TABLE                                      \
    const OBJECT_ENTRY c_rgCoClassFactoryTable[] = {

//+---------------------------------------------------------------------------
//
//  DECLARE_COCLASSFACTORY_ENTRY
//
//  clsid - clsid of the object
//  cclass - C++ class of the object.  This macro expects to find
//    ClassName::CreateInstance, which the CComObject bases provide by default.
//  desc - description, default REG_SZ value under the CLSID registry entry.
//----------------------------------------------------------------------------

#define DECLARE_COCLASSFACTORY_ENTRY(clsid, cclass, desc)               \
    { &clsid, cclass##::CreateInstance, desc },

//+---------------------------------------------------------------------------
//
//  END_COCLASSFACTORY_TABLE
//
//----------------------------------------------------------------------------

#define END_COCLASSFACTORY_TABLE                                        \
    { NULL, NULL, NULL } };                                             \
    CClassFactory *g_ObjectInfo[ARRAYSIZE(c_rgCoClassFactoryTable)] = { NULL };

#endif // __cplusplus
#endif // UNKNOWN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\cregkey.h ===
// cregkey.h
//


#ifndef CREGKEY_H
#define CREGKEY_H

#include "osver.h"
#include "xstring.h"

/////////////////////////////////////////////////////////////////////////////
// 
// CMyRegKey
// 
/////////////////////////////////////////////////////////////////////////////

class CMyRegKey
{
public:
    CMyRegKey();
    ~CMyRegKey();

// Attributes
public:
    operator HKEY() const;
    HKEY m_hKey;

// Operations
public:
    LONG SetValue(DWORD dwValue, LPCTSTR lpszValueName);
    virtual LONG QueryValue(DWORD& dwValue, LPCTSTR lpszValueName);
    virtual LONG QueryValueCch(LPTSTR szValue, LPCTSTR lpszValueName, ULONG cchValue);
    LONG SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);

    LONG SetKeyValue(LPCTSTR lpszKeyName, 
                     LPCTSTR lpszValue, 
                     LPCTSTR lpszValueName = NULL);

    static LONG WINAPI SetValue(HKEY hKeyParent, 
                                LPCTSTR lpszKeyName,
                                LPCTSTR lpszValue, 
                                LPCTSTR lpszValueName = NULL);
    LONG Create(HKEY hKeyParent, 
                LPCTSTR lpszKeyName,
                LPTSTR lpszClass                = REG_NONE, 
                DWORD dwOptions                 = REG_OPTION_NON_VOLATILE,
                REGSAM samDesired               = KEY_ALL_ACCESS,
                LPSECURITY_ATTRIBUTES lpSecAttr = NULL,
                LPDWORD lpdwDisposition         = NULL);

    LONG Open(HKEY hKeyParent, 
              LPCTSTR lpszKeyName,
              REGSAM samDesired);

    LONG Close();
    HKEY Detach();
    void Attach(HKEY hKey);
    LONG DeleteSubKey(LPCTSTR lpszSubKey);
    LONG RecurseDeleteKey(LPCTSTR lpszKey);
    LONG DeleteValue(LPCTSTR lpszValue);
    LONG QueryBinaryValue(void *p, DWORD& dwCount, LPCTSTR lpszValueName);
    LONG SetBinaryValue(void *p, DWORD dwCount, LPCTSTR lpszValueName);
    LONG EnumKey(DWORD dwIndex, LPTSTR lpName, ULONG cchName);
    LONG EnumValue(DWORD dwIndex, LPTSTR lpName, ULONG cchName);

    DWORD GetNumSubKeys();

#ifndef UNICODE
// Operations for Unicode
public:
    LONG CreateW(HKEY hKeyParent, 
                 LPCWSTR lpszKeyName,
                 LPWSTR lpszClass                = REG_NONE, 
                 DWORD dwOptions                 = REG_OPTION_NON_VOLATILE,
                 REGSAM samDesired               = KEY_ALL_ACCESS,
                 LPSECURITY_ATTRIBUTES lpSecAttr = NULL,
                 LPDWORD lpdwDisposition         = NULL);
    LONG OpenW(HKEY hKeyParent, 
               LPCWSTR lpszKeyName,
               REGSAM samDesired);
    LONG SetValueW(const WCHAR *lpszValue, 
                   const WCHAR *lpszValueName = NULL,
                   ULONG cch = (ULONG)-1);
    virtual LONG QueryValueCchW(WCHAR *lpszValue, const WCHAR *lpszValueName, ULONG cchValue);
    LONG EnumValueW(DWORD dwIndex, WCHAR *lpName, ULONG cchName);
    LONG EnumKeyW(DWORD dwIndex, WCHAR *lpName, ULONG cchName);
    LONG DeleteValueW(const WCHAR *lpszValue, ULONG cch = (ULONG)-1);
#endif // UNICODE

};

inline CMyRegKey::CMyRegKey()
{
    m_hKey = NULL;
}

inline CMyRegKey::~CMyRegKey()
{
    Close();
}

inline CMyRegKey::operator HKEY() const
{
    return m_hKey;
}

inline HKEY CMyRegKey::Detach()
{
    HKEY hKey = m_hKey;
    m_hKey = NULL;
    return hKey;
}

inline void CMyRegKey::Attach(HKEY hKey)
{
    Assert(m_hKey == NULL);
    m_hKey = hKey;
}

inline LONG CMyRegKey::DeleteSubKey(LPCTSTR lpszSubKey)
{
    Assert(m_hKey != NULL);
    return RegDeleteKey(m_hKey, lpszSubKey);
}

inline LONG CMyRegKey::DeleteValue(LPCTSTR lpszValue)
{
    Assert(m_hKey != NULL);
    return RegDeleteValue(m_hKey, (LPTSTR)lpszValue);
}

inline LONG CMyRegKey::Close()
{
    LONG lRes = ERROR_SUCCESS;
    if (m_hKey != NULL)
    {
        lRes = RegCloseKey(m_hKey);
        m_hKey = NULL;
    }
    return lRes;
}

inline LONG CMyRegKey::Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
    LPTSTR lpszClass, DWORD dwOptions, REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecAttr, LPDWORD lpdwDisposition)
{
    Assert(hKeyParent != NULL);
    DWORD dw;
    HKEY hKey = NULL;
    LONG lRes = RegCreateKeyEx(hKeyParent, lpszKeyName, 0,
        lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw);
    if (lpdwDisposition != NULL)
        *lpdwDisposition = dw;
    if (lRes == ERROR_SUCCESS)
    {
        lRes = Close();
        m_hKey = hKey;
    }
    return lRes;
}

inline LONG CMyRegKey::Open(HKEY hKeyParent, LPCTSTR lpszKeyName, REGSAM samDesired)
{
    Assert(hKeyParent != NULL);
    HKEY hKey = NULL;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);
    if (lRes == ERROR_SUCCESS)
    {
        lRes = Close();
        Assert(lRes == ERROR_SUCCESS);
        m_hKey = hKey;
    }
    return lRes;
}

inline LONG CMyRegKey::QueryValue(DWORD& dwValue, LPCTSTR lpszValueName)
{
    DWORD dwType = NULL;
    DWORD dwCount = sizeof(DWORD);
    LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
        (LPBYTE)&dwValue, &dwCount);
    Assert((lRes!=ERROR_SUCCESS) || (dwType == REG_DWORD));
    Assert((lRes!=ERROR_SUCCESS) || (dwCount == sizeof(DWORD)));
    return lRes;
}

inline LONG CMyRegKey::QueryValueCch(LPTSTR szValue, LPCTSTR lpszValueName, ULONG cchValue)
{
    Assert(szValue != NULL);

    DWORD cb = cchValue*sizeof(TCHAR);
    DWORD dwType = NULL;

    LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
        (LPBYTE)szValue, &cb);

    Assert((lRes!=ERROR_SUCCESS) || (dwType == REG_SZ) ||
           (dwType == REG_MULTI_SZ) || (dwType == REG_EXPAND_SZ));

    // make sure we're null-terminated no matter what
    // RegQueryValueEx does not guarentee null-terminated strings
    if (cchValue > 0)
    {
        szValue[lRes == ERROR_SUCCESS ? cchValue-1 : 0] = '\0';
    }

    return lRes;
}

inline LONG WINAPI CMyRegKey::SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
    Assert(lpszValue != NULL);
    CMyRegKey key;
    LONG lRes = key.Create(hKeyParent, lpszKeyName);
    if (lRes == ERROR_SUCCESS)
        lRes = key.SetValue(lpszValue, lpszValueName);
    return lRes;
}

inline LONG CMyRegKey::SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
    Assert(lpszValue != NULL);
    CMyRegKey key;
    LONG lRes = key.Create(m_hKey, lpszKeyName);
    if (lRes == ERROR_SUCCESS)
        lRes = key.SetValue(lpszValue, lpszValueName);
    return lRes;
}

inline LONG CMyRegKey::SetValue(DWORD dwValue, LPCTSTR lpszValueName)
{
    Assert(m_hKey != NULL);
    return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_DWORD,
        (BYTE * const)&dwValue, sizeof(DWORD));
}

inline LONG CMyRegKey::SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
    Assert(lpszValue != NULL);
    Assert(m_hKey != NULL);
    return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_SZ,
        (BYTE * const)lpszValue, (lstrlen(lpszValue)+1)*sizeof(TCHAR));
}

inline LONG CMyRegKey::RecurseDeleteKey(LPCTSTR lpszKey)
{
    CMyRegKey key;
    LONG lRes = key.Open(m_hKey, lpszKey, KEY_READ | KEY_WRITE);
    if (lRes != ERROR_SUCCESS)
        return lRes;
    FILETIME time;
    TCHAR szBuffer[256];
    DWORD dwSize = ARRAYSIZE(szBuffer);
    while (RegEnumKeyEx(key.m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
        &time)==ERROR_SUCCESS)
    {
        szBuffer[ARRAYSIZE(szBuffer)-1] = '\0';
        lRes = key.RecurseDeleteKey(szBuffer);
        if (lRes != ERROR_SUCCESS)
            return lRes;
        dwSize = ARRAYSIZE(szBuffer);
    }
    key.Close();
    return DeleteSubKey(lpszKey);
}

inline LONG CMyRegKey::QueryBinaryValue(void *p, DWORD& dwCount, LPCTSTR lpszValueName)
{

    DWORD dwType = REG_BINARY;
    LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, 0,
                           &dwType, (BYTE *)p, &dwCount);

    Assert((lRes!=ERROR_SUCCESS) || (dwType == REG_BINARY));
    return lRes;
}

inline LONG CMyRegKey::SetBinaryValue(void *p, DWORD dwCount, LPCTSTR lpszValueName)
{
    Assert(m_hKey != NULL);
    return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_BINARY,
                         (BYTE * const)p, dwCount);
}

inline LONG CMyRegKey::EnumKey(DWORD dwIndex, LPTSTR lpName, ULONG cchName)
{
    LONG lResult;
    ULONG cchNameIn;

    cchNameIn = cchName;

    lResult = RegEnumKeyEx(m_hKey, dwIndex, lpName, &cchName, NULL, NULL,
                           NULL, NULL);

    // null-terminate
    if (cchNameIn > 0)
    {
        lpName[lResult == ERROR_SUCCESS ? cchNameIn-1 : 0] = '\0';
    }

    return lResult;
}

inline LONG CMyRegKey::EnumValue(DWORD dwIndex, LPTSTR lpName, ULONG cchName)
{
    LONG lResult;
    ULONG cchNameIn;

    cchNameIn = cchName;

    lResult = RegEnumValue(m_hKey, dwIndex, lpName, &cchName, NULL, NULL,
                           NULL, NULL);

    // null-terminate
    if (cchNameIn > 0)
    {
        lpName[lResult == ERROR_SUCCESS ? cchNameIn-1 : 0] = '\0';
    }

    return lResult;
}

#ifndef UNICODE
inline LONG CMyRegKey::CreateW(HKEY hKeyParent, LPCWSTR lpszKeyName,
    LPWSTR lpszClass, DWORD dwOptions, REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecAttr, LPDWORD lpdwDisposition)
{
    if (IsOnNT())
    {
        Assert(hKeyParent != NULL);
        DWORD dw;
        HKEY hKey = NULL;
        LONG lRes = RegCreateKeyExW(hKeyParent, lpszKeyName, 0,
            lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw);
        if (lpdwDisposition != NULL)
            *lpdwDisposition = dw;
        if (lRes == ERROR_SUCCESS)
        {
            lRes = Close();
            m_hKey = hKey;
        }
        return lRes;
    }

    return Create(hKeyParent, (LPCTSTR)WtoA(lpszKeyName),
                  lpszClass ? (LPTSTR)WtoA(lpszClass) : REG_NONE, 
                  dwOptions, samDesired,
                  lpSecAttr, lpdwDisposition);
}

inline LONG CMyRegKey::OpenW(HKEY hKeyParent, LPCWSTR lpszKeyName, REGSAM samDesired)
{
    if (IsOnNT())
    {
        Assert(hKeyParent != NULL);
        HKEY hKey = NULL;
        LONG lRes = RegOpenKeyExW(hKeyParent, lpszKeyName, 0, samDesired, &hKey);
        if (lRes == ERROR_SUCCESS)
        {
            lRes = Close();
            Assert(lRes == ERROR_SUCCESS);
            m_hKey = hKey;
        }
        return lRes;
    }
    return Open(hKeyParent, WtoA(lpszKeyName), samDesired);
}

inline LONG CMyRegKey::SetValueW(const WCHAR *lpszValue, const WCHAR *lpszValueName, ULONG cch)
{
    Assert(lpszValue != NULL);
    Assert(m_hKey != NULL);

    if (IsOnNT())
    {
        return RegSetValueExW(m_hKey, 
                              lpszValueName, 
                              NULL, 
                              REG_SZ,
                              (BYTE * const)lpszValue, 
                              (cch == -1) ? (wcslen(lpszValue)+1)*sizeof(WCHAR) : cch);
    }

    WtoA szValue(lpszValue, cch);
    WtoA szValueName(lpszValueName);

    return RegSetValueExA(m_hKey, 
                          (char *)szValueName, 
                          NULL, 
                          REG_SZ,
                          (BYTE * const)(char *)szValue, 
                          (lstrlenA(szValue)+1));

}

inline LONG CMyRegKey::QueryValueCchW(WCHAR *lpszValue, const WCHAR *lpszValueName, ULONG cchValue)
{
    Assert(lpszValue != NULL);

    DWORD dwType = NULL;
    DWORD cb;
    LONG lRes;

    Assert(IsOnNT()); // we don't support win9x anymore

    cb = cchValue*sizeof(WCHAR);
    lRes = RegQueryValueExW(m_hKey, 
                            (WCHAR *)lpszValueName, 
                            NULL, 
                            &dwType,
                            (BYTE *)lpszValue, 
                            &cb);

    Assert((lRes!=ERROR_SUCCESS) || (dwType == REG_SZ) ||
                (dwType == REG_MULTI_SZ) || (dwType == REG_EXPAND_SZ));

    // make sure we're null-terminated no matter what
    // RegQueryValueEx does not guarentee null-terminated strings
    if (cchValue > 0)
    {
        lpszValue[lRes == ERROR_SUCCESS ? cchValue-1 : 0] = '\0';
    }

    return lRes;
}

inline LONG CMyRegKey::DeleteValueW(const WCHAR *lpszValue, ULONG cch)
{
    Assert(m_hKey != NULL);

    if (IsOnNT())
        return RegDeleteValueW(m_hKey, (WCHAR *)lpszValue);

    return RegDeleteValueA(m_hKey, WtoA(lpszValue, cch));
}

inline DWORD CMyRegKey::GetNumSubKeys()
{
    DWORD dwNum = 0;

    if (RegQueryInfoKey(m_hKey, NULL, NULL, NULL,
                        &dwNum, NULL, NULL, NULL,
                        NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
    {
        dwNum = 0;
    }

    return dwNum;
}

inline LONG CMyRegKey::EnumValueW(DWORD dwIndex, WCHAR *lpName, ULONG cchName)
{
    LONG lResult;
    ULONG cchNameIn;

    Assert(IsOnNT()); // we don't support win9x anymore

    cchNameIn = cchName;

    lResult = RegEnumValueW(m_hKey, dwIndex, lpName, &cchName, NULL, NULL,
                            NULL, NULL);

    // null-terminate
    if (cchNameIn > 0)
    {
        lpName[lResult == ERROR_SUCCESS ? cchNameIn-1 : 0] = '\0';
    }

    return lResult;
}

inline LONG CMyRegKey::EnumKeyW(DWORD dwIndex, WCHAR *lpName, ULONG cchName)
{
    LONG lResult;
    ULONG cchNameIn;

    Assert(IsOnNT()); // we don't support win9x anymore

    cchNameIn = cchName;

    lResult = RegEnumKeyExW(m_hKey, dwIndex, lpName, &cchName, NULL, NULL,
                             NULL, NULL);

    // null-terminate
    if (cchNameIn > 0)
    {
        lpName[lResult == ERROR_SUCCESS ? cchNameIn-1 : 0] = '\0';
    }

    return lResult;
}
#endif // UNICODE


#endif // CREGKEY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\dap.h ===
//+---------------------------------------------------------------------------
//
//  File:       imx.h
//
//  Contents:   CIMX
//
//----------------------------------------------------------------------------

#ifndef DAP_H
#define DAP_H

#include "private.h"

class CDisplayAttributeInfo;

//+---------------------------------------------------------------------------
//
// CDisplayAttributeProvider
//
//----------------------------------------------------------------------------

class __declspec(novtable) CDisplayAttributeProvider : public ITfDisplayAttributeProvider
{
public:
    CDisplayAttributeProvider();
    virtual ~CDisplayAttributeProvider();

    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj) = 0;
    virtual STDMETHODIMP_(ULONG) AddRef(void)  = 0;
    virtual STDMETHODIMP_(ULONG) Release(void)  = 0;

    STDMETHODIMP EnumDisplayAttributeInfo(IEnumTfDisplayAttributeInfo **ppEnum);
    STDMETHODIMP GetDisplayAttributeInfo(REFGUID guid, ITfDisplayAttributeInfo **ppInfo);

    CDisplayAttributeInfo *_pList;

    static WCHAR szProviderName[80];

protected:
    void Add(GUID guid, WCHAR *pszDesc, TF_DISPLAYATTRIBUTE *pda);
};

//+---------------------------------------------------------------------------
//
// CDisplayAttributeInfo
//
//----------------------------------------------------------------------------

class CDisplayAttributeInfo : public ITfDisplayAttributeInfo
{
public:
    CDisplayAttributeInfo(GUID guid, WCHAR *pszDesc, TF_DISPLAYATTRIBUTE *pda);
    ~CDisplayAttributeInfo();

    //
    // IUnknown methods
    //
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP GetGUID(GUID *pguid);
    STDMETHODIMP GetDescription(BSTR *pbstr);

    STDMETHODIMP GetAttributeInfo(TF_DISPLAYATTRIBUTE *pda);
    STDMETHODIMP SetAttributeInfo(const TF_DISPLAYATTRIBUTE *pda);
    STDMETHODIMP Reset();

    CDisplayAttributeInfo *_pNext;

    HRESULT _SaveAttribute(const TCHAR *pszKey, WCHAR *pszDesc, const GUID *pguid, TF_DISPLAYATTRIBUTE *pda);
    HRESULT _OpenAttribute(const TCHAR *pszKey, WCHAR *pszDesc, const GUID *pguid, TF_DISPLAYATTRIBUTE *pda);
    HRESULT _DeleteAttribute(const TCHAR *pszKey, WCHAR *pszDesc, const GUID *pguid);

    GUID _guid;
    WCHAR _szDesc[MAX_PATH];
    TF_DISPLAYATTRIBUTE _da;
    TF_DISPLAYATTRIBUTE _daDefault;
    int _cRef;
};

//+---------------------------------------------------------------------------
//
// CEnumDisplayAttributeInfo
//
//----------------------------------------------------------------------------

class CEnumDisplayAttributeInfo : public IEnumTfDisplayAttributeInfo
{
public:
    CEnumDisplayAttributeInfo(CDisplayAttributeProvider *pProvider);
    ~CEnumDisplayAttributeInfo();

    // IUnknown methods
    //
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    //
    // IEnumTfDisplayAttributeInfo
    //
    STDMETHODIMP Clone(IEnumTfDisplayAttributeInfo **ppEnum);
    STDMETHODIMP Next(ULONG ulCount, ITfDisplayAttributeInfo **ppInfo, ULONG *pcFetched);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG ulCount);

private:
    CDisplayAttributeInfo *_pCur;
    int _cRef;
    CDisplayAttributeProvider *_pProvider;
};


#endif // DAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\dispattr.h ===
//
// dispattr.h
//

#ifndef DISPATTR_H
#define DISPATTR_H

#include "strary.h"
#include "ctffunc.h"

typedef struct tagDISPATTRPROP {
    GUID guid;
} DISPATTRPROP;

class CDispAttrPropCache
{
public:
    CDispAttrPropCache() {}

    void Add(REFGUID rguid)
    {
        if (!FindGuid(rguid))
        {
            int i = Count();
            if (_rgDispAttrProp.Insert(i, 1))
            {
                DISPATTRPROP *pProp = _rgDispAttrProp.GetPtr(i);
                pProp->guid = rguid;
            }
        }
        
    }

    void Remove(REFGUID rguid)
    {
        int nCnt = _rgDispAttrProp.Count();
        int i;
        for (i = 0; i < nCnt; i++)
        {
            DISPATTRPROP *pProp = _rgDispAttrProp.GetPtr(i);
            if (IsEqualGUID(pProp->guid, rguid))
            {
                _rgDispAttrProp.Remove(i, 1);
                return;
            }
        }
    }

    BOOL FindGuid(REFGUID rguid)
    {
        int nCnt = _rgDispAttrProp.Count();
        int i;
        for (i = 0; i < nCnt; i++)
        {
            DISPATTRPROP *pProp = _rgDispAttrProp.GetPtr(i);
            if (IsEqualGUID(pProp->guid, rguid))
            {
                return TRUE;
            }
        }
        return FALSE;
    }

    int Count()
    {
        return _rgDispAttrProp.Count();
    }

    GUID *GetPropTable()
    {
        return (GUID *)_rgDispAttrProp.GetPtr(0);
    }

    CStructArray<DISPATTRPROP> _rgDispAttrProp;
};


ITfDisplayAttributeMgr *GetDAMLib(LIBTHREAD *plt);
HRESULT InitDisplayAttrbuteLib(LIBTHREAD *plt);
HRESULT UninitDisplayAttrbuteLib(LIBTHREAD *plt);
HRESULT GetDisplayAttributeTrackPropertyRange(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfReadOnlyProperty **ppProp, IEnumTfRanges **ppEnum, ULONG *pulNumProp);
HRESULT GetDisplayAttributeData(LIBTHREAD *plt, TfEditCookie ec, ITfReadOnlyProperty *pProp, ITfRange *pRange, TF_DISPLAYATTRIBUTE *pda, TfClientId *pguid, ULONG  ulNumProp);

HRESULT GetReconversionFromDisplayAttribute(LIBTHREAD *plt, TfEditCookie ec, ITfThreadMgr *ptim, ITfContext *pic, ITfRange *pRange, ITfFnReconversion **ppReconv, ITfDisplayAttributeMgr *pDAM);

HRESULT GetAttributeColor(TF_DA_COLOR *pdac, COLORREF *pcr);
HRESULT SetAttributeColor(TF_DA_COLOR *pdac, COLORREF cr);
HRESULT SetAttributeSysColor(TF_DA_COLOR *pdac, int nIndex);
HRESULT ClearAttributeColor(TF_DA_COLOR *pdac);

#endif // DISPATTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\cstring.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    cstring.h

Abstract:

    This file defines the CString Class.
    and CMapStringToOb<VALUE, ARG_VALUE> template class.

Author:

Revision History:

Notes:

--*/

#ifndef _CSTRING_H_
#define _CSTRING_H_

#include "template.h"


/////////////////////////////////////////////////////////////////////////////
// Globals
extern TCHAR  afxChNil;
extern LPCTSTR _afxPchNil;


#define afxEmptyString ((CString&)*(CString*)&_afxPchNil)



/////////////////////////////////////////////////////////////////////////////
// CStringData

struct CStringData
{
    long  nRefs;    // reference count
    int   nDataLength;    // length of data (including terminator)
    int   nAllocLength;   // length of allocation
    // TCHAR data[nAllocLength]

    TCHAR* data()         // TCHAR* to managed data
    {
        return (TCHAR*)(this+1);
    }
};



/////////////////////////////////////////////////////////////////////////////
// CString

class CString
{
public:
// Constructors

    // constructs empty CString
    CString();
    // copy constructor
    CString(const CString& stringSrc);
    // from an ANSI string (converts to TCHAR)
    CString(LPCSTR lpsz);
    // subset of characters from an ANSI string (converts to TCHAR)
    CString(LPCSTR lpch, int nLength);
    // return pointer to const string
    operator LPCTSTR() const;

    // overloaded assignment

    // ref-counted copy from another CString
    const CString& operator=(const CString& stringSrc);
    // set string content to single character
    const CString& operator=(TCHAR ch);
    // copy string content from ANSI string (converts to TCHAR)
    const CString& operator=(LPCSTR lpsz);

// Attributes & Operations

    // string comparison

    // straight character comparison
    int Compare(LPCTSTR lpsz) const;
    // compare ignoring case
    int CompareNoCase(LPCTSTR lpsz) const;

    // simple sub-string extraction

    // return nCount characters starting at zero-based nFirst
    CString Mid(int nFirst, int nCount) const;
    // return all characters starting at zero-based nFirst
    CString Mid(int nFirst) const;

    // searching

    // find character starting at left, -1 if not found
    int Find(TCHAR ch) const;
    // find character starting at zero-based index and going right
    int Find(TCHAR ch, int nStart) const;

// Implementation
public:
    ~CString();

private:
    LPTSTR   m_pchData;        // pointer to ref counted string data

    // implementation helpers
    CStringData* GetData() const;
    void Init();
    void AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
    void AllocBuffer(int nLen);
    void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
    void AllocBeforeWrite(int nLen);
    void Release();
    static void PASCAL Release(CStringData* pData);
    static int PASCAL SafeStrlen(LPCTSTR lpsz);
    static void FreeData(CStringData* pData);
};

inline
CStringData*
CString::GetData(
    ) const
{
    ASSERT(m_pchData != NULL);
    return ((CStringData*)m_pchData)-1;
}

inline
void
CString::Init(
    )
{
    m_pchData = afxEmptyString.m_pchData;
}

// Compare helpers
bool operator==(const CString& s1, const CString& s2);
bool operator==(const CString& s1, LPCTSTR s2);
bool operator==(LPCTSTR s1, const CString& s2);


/////////////////////////////////////////////////////////////////////////////
// Special implementation for CStrings
// it is faster to bit-wise copy a CString than to call an offical
//   constructor - since an empty CString can be bit-wise copied

static
void
ConstructElement(
    CString* pNewData
    )
{
    memcpy(pNewData, &afxEmptyString, sizeof(CString));
}

static
void
DestructElement(
    CString* pOldData
    )
{
    pOldData->~CString();
}




/////////////////////////////////////////////////////////////////////////////
// CMapStringToOb<VALUE, ARG_VALUE>

template<class VALUE, class ARG_VALUE>
class CMapStringToOb
{
public:
    CMapStringToOb(int nBlockSize = 10);
    ~CMapStringToOb();

    INT_PTR GetCount() const;

    BOOL Lookup(LPCTSTR key, VALUE& rValue) const;

    VALUE& operator[](LPCTSTR key);

    void SetAt(LPCTSTR key, ARG_VALUE newValue);

    BOOL RemoveKey(LPCTSTR key);
    void RemoveAll();

    POSITION GetStartPosition() const;
    void GetNextAssoc(POSITION& rNextPosition, CString& rKey, VALUE& rValue) const;

    void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

protected:
    // Overridables: special non-virtual (see map implementation for details)
    // Routine used to user-provided hash keys
    UINT HashKey(LPCTSTR key) const;

private:
    // Association
    struct CAssoc {
        CAssoc* pNext;
        UINT nHashValue;    // needed for efficient iteration
        CString key;
        VALUE value;
    };

private:
    CAssoc* NewAssoc();
    void    FreeAssoc(CAssoc*);
    CAssoc* GetAssocAt(LPCTSTR, UINT&) const;

private:
    CAssoc**      m_pHashTable;
    UINT          m_nHashTableSize;
    INT_PTR       m_nCount;
    CAssoc*       m_pFreeList;
    struct CPlex* m_pBlocks;
    int           m_nBlockSize;

};



template<class VALUE, class ARG_VALUE>
INT_PTR
CMapStringToOb<VALUE, ARG_VALUE>::GetCount(
    ) const
{
    return m_nCount;
}

template<class VALUE, class ARG_VALUE>
void
CMapStringToOb<VALUE, ARG_VALUE>::SetAt(
    LPCTSTR key,
    ARG_VALUE newValue
    )
{
    (*this)[key] = newValue;
}


template<class VALUE, class ARG_VALUE>
CMapStringToOb<VALUE, ARG_VALUE>::CMapStringToOb(
    int nBlockSize
    )
{
    ASSERT(nBlockSize > 0);

    m_pHashTable     = NULL;
    m_nHashTableSize = 17;        // default size
    m_nCount         = 0;
    m_pFreeList      = NULL;
    m_pBlocks        = NULL;
    m_nBlockSize     = nBlockSize;
}


template<class VALUE, class ARG_VALUE>
UINT
CMapStringToOb<VALUE, ARG_VALUE>::HashKey(
    LPCTSTR key
    ) const
{
    UINT nHash = 0;
    while (*key)
        nHash = (nHash<<5) + nHash + *key++;
    return nHash;
}


template<class VALUE, class ARG_VALUE>
void
CMapStringToOb<VALUE, ARG_VALUE>::InitHashTable(
    UINT nHashSize,
    BOOL bAllocNow
    )
{
    ASSERT(m_nCount == 0);
    ASSERT(nHashSize > 0);

    if (m_pHashTable != NULL) {
        // free hash table
        delete[] m_pHashTable;
        m_pHashTable = NULL;
    }

    if (bAllocNow) {
        m_pHashTable = new CAssoc* [nHashSize];
        memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
    }

    m_nHashTableSize = nHashSize;
}


template<class VALUE, class ARG_VALUE>
void
CMapStringToOb<VALUE, ARG_VALUE>::RemoveAll(
    )
{
    if (m_pHashTable != NULL) {
        // destroy elements (values and keys)
        for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++) {
            CAssoc* pAssoc;
            for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext) {
                DestructElements<VALUE>(&pAssoc->value, 1);
                DestructElement(&pAssoc->key);    // free up string data
            }
        }
    }

    // free hash table
    delete[] m_pHashTable;
    m_pHashTable = NULL;

    m_nCount    = 0;
    m_pFreeList = NULL;

    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}


template<class VALUE, class ARG_VALUE>
CMapStringToOb<VALUE, ARG_VALUE>::~CMapStringToOb(
    )
{
    RemoveAll();

    ASSERT(m_nCount == 0);
}


template<class VALUE, class ARG_VALUE>
CMapStringToOb<VALUE, ARG_VALUE>::CAssoc*
CMapStringToOb<VALUE, ARG_VALUE>::NewAssoc(
    )
{
    if (m_pFreeList == NULL) {
        // add another block
        CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMapStringToOb::CAssoc));
        // chain them into free list;
        CMapStringToOb::CAssoc* pAssoc = (CMapStringToOb::CAssoc*) newBlock->data();
        // free in reverse order to make it easier to debug
        pAssoc += m_nBlockSize - 1;
        for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--) {
            pAssoc->pNext = m_pFreeList;
            m_pFreeList = pAssoc;
        }
    }
    ASSERT(m_pFreeList != NULL);    // we must have something

    CMapStringToOb::CAssoc* pAssoc = m_pFreeList;
    m_pFreeList = m_pFreeList->pNext;

    m_nCount++;
    ASSERT(m_nCount > 0);        // make sure we don't overflow

    memcpy(&pAssoc->key, &afxEmptyString, sizeof(CString));
    ConstructElements<VALUE>(&pAssoc->value, 1);        // special construct values

    return pAssoc;
}


template<class VALUE, class ARG_VALUE>
void
CMapStringToOb<VALUE, ARG_VALUE>::FreeAssoc(
    CMapStringToOb::CAssoc* pAssoc
    )
{
    DestructElements<VALUE>(&pAssoc->value, 1);
    DestructElement(&pAssoc->key);     // free up string data

    pAssoc->pNext = m_pFreeList;
    m_pFreeList = pAssoc;
    m_nCount--;
    ASSERT(m_nCount >= 0);        // make sure we don't underflow

    // if no more elements, cleanup completely
    if (m_nCount == 0)
        RemoveAll();
}


template<class VALUE, class ARG_VALUE>
CMapStringToOb<VALUE, ARG_VALUE>::CAssoc*
CMapStringToOb<VALUE, ARG_VALUE>::GetAssocAt(
    LPCTSTR key,
    UINT& nHash
    ) const
{
    nHash = HashKey(key) % m_nHashTableSize;

    if (m_pHashTable == NULL)
        return NULL;

    // see if it exists
    CAssoc* pAssoc;
    for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext) {
        if (pAssoc->key == key)
            return pAssoc;
    }

    return NULL;
}


template<class VALUE, class ARG_VALUE>
BOOL
CMapStringToOb<VALUE, ARG_VALUE>::Lookup(
    LPCTSTR key,
    VALUE& rValue
    ) const
{
    UINT nHash;
    CAssoc* pAssoc = GetAssocAt(key, nHash);
    if (pAssoc == NULL)
        return FALSE;        // not in map

    rValue = pAssoc->value;
    return TRUE;
}


template<class VALUE, class ARG_VALUE>
VALUE&
CMapStringToOb<VALUE, ARG_VALUE>::operator[](
    LPCTSTR key
    )
{
    UINT nHash;
    CAssoc* pAssoc;
    if ((pAssoc = GetAssocAt(key, nHash)) == NULL) {
        if (m_pHashTable == NULL)
            InitHashTable(m_nHashTableSize);

        // it doesn't exist, add a new Association
        pAssoc = NewAssoc();
        pAssoc->nHashValue = nHash;
        pAssoc->key = key;
        // 'pAssoc->value' is a constructed object, nothing more

        // put into hash table
        pAssoc->pNext = m_pHashTable[nHash];
        m_pHashTable[nHash] = pAssoc;
    }
    return pAssoc->value;    // return new reference
}


template<class VALUE, class ARG_VALUE>
BOOL
CMapStringToOb<VALUE, ARG_VALUE>::RemoveKey(
    LPCTSTR key
    )
{
    if (m_pHashTable == NULL)
        return FALSE;        // nothing in the table

    CAssoc** ppAssocPrev;
    ppAssocPrev = &m_pHashTable[HashKey(key) % m_nHashTableSize];

    CAssoc* pAssoc;
    for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext) {
        if (pAssoc->key == key)) {
            // remove it
            *ppAssocPrev = pAssoc->pNext;        // remove from list
            FreeAssoc(pAssoc);
            return TRUE;
        }
        ppAssocPrev = &pAssoc->pNext;
    }

    return FALSE;        // not found
}


template<class VALUE, class ARG_VALUE>
POSITION
CMapStringToOb<VALUE, ARG_VALUE>::GetStartPosition(
    ) const
{
    return (m_nCount == 0) ? NULL : BEFORE_START_POSITION;
}


template<class VALUE, class ARG_VALUE>
void
CMapStringToOb<VALUE, ARG_VALUE>::GetNextAssoc(
    POSITION& rNextPosition,
    CString& rKey,
    VALUE& rValue
    ) const
{
    ASSERT(m_pHashTable != NULL);    // never call on empty map

    CAssoc* pAssocRet = (CAssoc*)rNextPosition;
    ASSERT(pAssocRet != NULL);

    if (pAssocRet == (CAssoc*) BEFORE_START_POSITION) {
        // find the first association
        for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
            if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
                break;
            ASSERT(pAssocRet != NULL);    // must find something
    }

    // find next association
    CAssoc* pAssocNext;
    if ((pAssocNext = pAssocRet->pNext) == NULL) {
        // go to next bucket
        for (UINT nBucket = pAssocRet->nHashValue + 1; nBucket < m_nHashTableSize; nBucket++)
            if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
                break;
    }

    rNextPosition = (POSITION) pAssocNext;

    // fill in return data
    rKey = pAssocRet->key;
    rValue = pAssocRet->value;
}





#endif // _CSTRING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\dbgid.h ===
//
// dbgid.h
//
// debug macros
//

#ifndef DBGID_H
#define DBGID_H

#ifdef __cplusplus // "C" files can't handle "inline"

#include "ciccs.h"

extern CCicCriticalSectionStatic g_cs;

//extern "C" BOOL Dbg_MemSetNameID(void *pv, const TCHAR *pszName, DWORD dwID);

#ifdef DEBUG

#define DBG_ID_DECLARE                  \
    static DWORD _s_Dbg_dwID;           \
    static DWORD _s_Dbg_dwIDBreak;      \
    static BOOL  _s_Dbg_fBreak;         \
    DWORD _Dbg_dwID;

#define DBG_ID_INSTANCE(_class_)         \
    DWORD _class_::_s_Dbg_dwID = 0;      \
    DWORD _class_::_s_Dbg_dwIDBreak = 0; \
    BOOL  _class_::_s_Dbg_fBreak = FALSE;  

#define Dbg_MemSetThisNameID(pszName)            \
    EnterCriticalSection(g_cs);                  \
    _Dbg_dwID = ++_s_Dbg_dwID;                   \
    LeaveCriticalSection(g_cs);                  \
    Dbg_MemSetNameID(this, pszName, _Dbg_dwID);  \
    if (_s_Dbg_fBreak && (_Dbg_dwID == _s_Dbg_dwIDBreak)) DebugBreak();

#define Dbg_MemSetThisNameIDCounter(pszName, iCounter)   \
    EnterCriticalSection(g_cs);        \
    _Dbg_dwID = ++_s_Dbg_dwID;          \
    LeaveCriticalSection(g_cs);        \
    Dbg_MemSetNameIDCounter(this, pszName, _Dbg_dwID, iCounter); \
    if (_Dbg_dwID == _s_Dbg_dwIDBreak) DebugBreak();

#else

#define DBG_ID_DECLARE
#define DBG_ID_INSTANCE(_class_)
#define Dbg_MemSetNameIDCounter(pv, pszName, dwID, iCounter)
#define Dbg_MemSetThisNameIDCounter(pszName, iCounter)
#define Dbg_MemSetThisNameID(pszName)

#endif // DEBUG

#endif // __cplusplus // "C" files can't handle "inline"

#endif // DBGID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\debug.h ===
//====== Assertion/Debug output APIs =================================

#include <platform.h> // for __endexcept

#if defined(DECLARE_DEBUG) && defined(DEBUG)

//
// Declare module-specific debug strings
//
//   When including this header in your private header file, do not
//   define DECLARE_DEBUG.  But do define DECLARE_DEBUG in one of the
//   source files in your project, and then include this header file.
//
//   You may also define the following:
//
//      SZ_DEBUGINI     - the .ini file used to set debug flags
//      SZ_DEBUGSECTION - the section in the .ini file specific to
//                        the module component.
//      SZ_MODULE       - ansi version of the name of your module.
//
//

// (These are deliberately CHAR)
EXTERN_C const CHAR FAR c_szCcshellIniFile[] = SZ_DEBUGINI;
EXTERN_C const CHAR FAR c_szCcshellIniSecDebug[] = SZ_DEBUGSECTION;

#if 0
EXTERN_C const WCHAR FAR c_wszTrace[]      = L"trc " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR FAR c_wszErrorDbg[]   = L"err " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR FAR c_wszWarningDbg[] = L"wrn " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR FAR c_wszGeneralDbg[] = L"gen " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR FAR c_wszFuncDbg[]    = L"fnc " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR FAR c_wszMemLeakDbg[] = L"mem " TEXTW(SZ_MODULE) L"  ";
#else
EXTERN_C const WCHAR FAR c_wszTrace[]      = TEXTW(SZ_MODULE) L"-[Trc] ";
EXTERN_C const WCHAR FAR c_wszErrorDbg[]   = TEXTW(SZ_MODULE) L"-[Err] ";
EXTERN_C const WCHAR FAR c_wszWarningDbg[] = TEXTW(SZ_MODULE) L"-[Wrn] ";
EXTERN_C const WCHAR FAR c_wszGeneralDbg[] = TEXTW(SZ_MODULE) L"-[Gen] ";
EXTERN_C const WCHAR FAR c_wszFuncDbg[]    = TEXTW(SZ_MODULE) L"-[Fnc] ";
EXTERN_C const WCHAR FAR c_wszMemLeakDbg[] = TEXTW(SZ_MODULE) L"-[Mem] ";
#endif
EXTERN_C const WCHAR FAR c_wszAssertMsg[]    = TEXTW(SZ_MODULE) L"  Assert: ";
EXTERN_C const WCHAR FAR c_wszAssertFailed[] = TEXTW(SZ_MODULE) L"  Assert %ls, line %d: (%ls)\r\n";
EXTERN_C const WCHAR FAR c_wszRip[]     = TEXTW(SZ_MODULE) L"  RIP in %s at %s, line %d: (%s)\r\n";
EXTERN_C const WCHAR FAR c_wszRipNoFn[] = TEXTW(SZ_MODULE) L"  RIP at %s, line %d: (%s)\r\n";

// (These are deliberately CHAR)
#if 0
EXTERN_C const CHAR  FAR c_szTrace[]      = "trc " SZ_MODULE "  ";
EXTERN_C const CHAR  FAR c_szErrorDbg[]   = "err " SZ_MODULE "  ";
EXTERN_C const CHAR  FAR c_szWarningDbg[] = "wrn " SZ_MODULE "  ";
EXTERN_C const CHAR  FAR c_szGeneralDbg[] = "gen " SZ_MODULE "  ";
EXTERN_C const CHAR  FAR c_szFuncDbg[]    = "fnc " SZ_MODULE "  ";
EXTERN_C const CHAR  FAR c_szMemLeakDbg[] = "mem " SZ_MODULE "  ";
#else
EXTERN_C const CHAR  FAR c_szTrace[]      = SZ_MODULE "-[Trc] ";
EXTERN_C const CHAR  FAR c_szErrorDbg[]   = SZ_MODULE "-[Err] ";
EXTERN_C const CHAR  FAR c_szWarningDbg[] = SZ_MODULE "-[Wrn] ";
EXTERN_C const CHAR  FAR c_szGeneralDbg[] = SZ_MODULE "-[Gen] ";
EXTERN_C const CHAR  FAR c_szFuncDbg[]    = SZ_MODULE "-[Fnc] ";
EXTERN_C const CHAR  FAR c_szMemLeakDbg[] = SZ_MODULE "-[Mem] ";
#endif
EXTERN_C const CHAR  FAR c_szAssertMsg[]    = SZ_MODULE "  Assert: ";
EXTERN_C const CHAR  FAR c_szAssertFailed[] = SZ_MODULE "  Assert %s, line %d: (%s)\r\n";
EXTERN_C const CHAR  FAR c_szRip[] = SZ_MODULE     "  RIP in %s at %s, line %d: (%s)\r\n";
EXTERN_C const CHAR  FAR c_szRipNoFn[] = SZ_MODULE "  RIP at %s, line %d: (%s)\r\n";

#endif  // DECLARE_DEBUG && DEBUG

#if defined(DECLARE_DEBUG) && defined(PRODUCT_PROF)
EXTERN_C const CHAR FAR c_szCcshellIniFile[] = SZ_DEBUGINI;
EXTERN_C const CHAR FAR c_szCcshellIniSecDebug[] = SZ_DEBUGSECTION;
#endif



#ifdef __cplusplus
extern "C" {
#endif

#if !defined(DECLARE_DEBUG)

//
// Debug macros and validation code
//

// Undefine the macros that we define in case some other header
// might have tried defining these commonly-named macros.
#undef Assert
#undef AssertE
#undef AssertMsg
#undef AssertStrLen
#undef DebugMsg
#undef FullDebugMsg
#undef ASSERT
#undef EVAL
#undef ASSERTMSG            // catch people's typos
#undef DBEXEC

#ifdef _ATL_NO_DEBUG_CRT
#undef _ASSERTE             // we substitute this ATL macro
#endif

// Access these globals to determine which debug flags are set.
// These globals are modified by CcshellGetDebugFlags(), which
// reads an .ini file and sets the appropriate flags.
//
//   g_dwDumpFlags  - bits are application specific.  Typically 
//                    used for dumping structures.
//   g_dwBreakFlags - uses BF_* flags.  The remaining bits are
//                    application specific.  Used to determine
//                    when to break into the debugger.
//   g_dwTraceFlags - uses TF_* flags.  The remaining bits are
//                    application specific.  Used to display
//                    debug trace messages.
//   g_dwFuncTraceFlags - bits are application specific.  When
//                    TF_FUNC is set, CcshellFuncMsg uses this
//                    value to determine which function traces
//                    to display.
//   g_dwProtoype   - bits are application specific.  Use it for
//                    anything.
//   g_dwProfileCAP - bits are application specific. Used to
//                    control ICECAP profiling. 
//

extern DWORD g_dwDumpFlags;
extern DWORD g_dwBreakFlags;
extern DWORD g_dwTraceFlags;
#ifdef DEBUG
extern DWORD g_dwPrototype;
#else
#define g_dwPrototype   0
#endif
extern DWORD g_dwFuncTraceFlags;

#if defined(DEBUG) || defined(PRODUCT_PROF)
BOOL CcshellGetDebugFlags(void);
#else
#define CcshellGetDebugFlags()  0
#endif

// Break flags for g_dwBreakFlags
#define BF_ASSERT           0x00000001      // Break on assertions
#define BF_ONAPIENTER       0x00000002      // Break on entering an API
#define BF_ONERRORMSG       0x00000004      // Break on TF_ERROR
#define BF_ONWARNMSG        0x00000008      // Break on TF_WARNING
#define BF_THR              0x00000100      // Break when THR() receives a failure
#define BF_RIP              0x00000200      // Break on RIPs
#define BF_ASSERTPOPUP      0x00000400      // Break on RIPs

// Trace flags for g_dwTraceFlags
#define TF_ALWAYS           0xFFFFFFFF
#define TF_NEVER            0x00000000
#define TF_WARNING          0x00000001
#define TF_ERROR            0x00000002
#define TF_GENERAL          0x00000004      // Standard messages
#define TF_FUNC             0x00000008      // Trace function calls
#define TF_ATL              0x00000008      // Since TF_FUNC is so-little used, I'm overloading this bit
#define TF_EVENT            0x00000010
#define TF_MEMORY_LEAK      0x00000020
// (Upper 28 bits reserved for custom use per-module)

// Old, archaic debug flags.  
// Issue (scotth): the following flags will be phased out over time.
#ifdef DM_TRACE
#undef DM_TRACE
#undef DM_WARNING
#undef DM_ERROR
#endif
#define DM_TRACE            TF_GENERAL      // OBSOLETE Trace messages
#define DM_WARNING          TF_WARNING      // OBSOLETE Warning
#define DM_ERROR            TF_ERROR        // OBSOLETE Error


// Use this macro to declare message text that will be placed
// in the CODE segment (useful if DS is getting full)
//
// Ex: DEBUGTEXT(szMsg, "Invalid whatever: %d");
//
#define DEBUGTEXT(sz, msg)      /* ;Internal */ \
    static const TCHAR sz[] = msg


#ifndef NOSHELLDEBUG    // Others have own versions of these.

#ifdef DEBUG

#ifdef _X86_
// Use int 3 so we stop immediately in the source
#define DEBUG_BREAK        do { _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;} } while (0)
#else
#define DEBUG_BREAK        do { _try { DebugBreak(); } _except (EXCEPTION_EXECUTE_HANDLER) {;} __endexcept } while (0)
#endif

BOOL AttachDebugger(DWORD pid);

// Prototypes for debug functions

void CcshellStackEnter(void);
void CcshellStackLeave(void);

void CDECL CcshellFuncMsgW(DWORD mask, LPCSTR pszMsg, ...);
void CDECL CcshellFuncMsgA(DWORD mask, LPCSTR pszMsg, ...);

void CDECL _AssertMsgA(BOOL f, LPCSTR pszMsg, ...);
void CDECL _AssertMsgW(BOOL f, LPCWSTR pszMsg, ...);

void _AssertStrLenA(LPCSTR pszStr, int iLen);
void _AssertStrLenW(LPCWSTR pwzStr, int iLen);

#ifdef UNICODE
#define CcshellFuncMsg          CcshellFuncMsgW
#define CcshellAssertMsg        CcshellAssertMsgW
#define _AssertMsg              _AssertMsgW
#define _AssertStrLen           _AssertStrLenW
#else
#define CcshellFuncMsg          CcshellFuncMsgA
#define CcshellAssertMsg        CcshellAssertMsgA
#define _AssertMsg              _AssertMsgA
#define _AssertStrLen           _AssertStrLenA
#endif

#endif // DEBUG



// ASSERT(f)
//
//   Generates a "Assert file.c, line x (eval)" message if f is NOT true.
//
//   Use ASSERT() to check for logic invariance.  These are typically considered
//   fatal problems, and falls into the 'this should never ever happen' 
//   category.
//
//   Do *not* use ASSERT() to verify successful API calls if the APIs can 
//   legitimately fail due to low resources.  For example, LocalAlloc can 
//   legally fail, so you shouldn't assert that it will never fail.
//
//   The BF_ASSERT bit in g_dwBreakFlags governs whether the function 
//   performs a DebugBreak().
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew and break
//      Full debug builds:  spew and break
//
#ifdef DEBUG

BOOL CcshellAssertFailedA(LPCSTR szFile, int line, LPCSTR pszEval, BOOL bBreakInside, BOOL bAssertPopup);
BOOL CcshellAssertFailedW(LPCWSTR szFile, int line, LPCWSTR pwszEval, BOOL bBreakInside, BOOL bAssertPopup);
#ifdef UNICODE
#define CcshellAssertFailed     CcshellAssertFailedW
#else
#define CcshellAssertFailed     CcshellAssertFailedA
#endif

#define ASSERT(f)                                 \
    {                                             \
        DEBUGTEXT(szFile, TEXT(__FILE__));              \
        if (!(f) && CcshellAssertFailed(szFile, __LINE__, TEXT(#f), FALSE, TRUE)) \
            DEBUG_BREAK;       \
    }

#define ASSERTPRIVATE(f)                                 \
    {                                             \
        DEBUGTEXT(szFile, TEXT(__FILE__));              \
        if (!(f) && CcshellAssertFailed(szFile, __LINE__, TEXT(#f), FALSE, FALSE)) \
            DEBUG_BREAK;       \
    }

// The old Win95 code used to use "Assert()".  We discourage the use
// of this macro now because it is not msdev-friendly.
#ifdef DISALLOW_Assert
#define Assert(f)           Dont_use_Assert___Use_ASSERT
#define AssertPrivate(f)    Dont_use_AssertPrivate___Use_ASSERT
#else
#define Assert(f)           ASSERT(f)
#define AssertPrivate(f)    ASSERTPRIVATE(f)
#endif

#else  // DEBUG

#define ASSERT(f)
#define ASSERTPRIVATE(f)
#define Assert(f)
#define AssertPrivate(f)

#endif // DEBUG



// ASSERTMSG(f, szFmt, args...)
//
//   Behaves like ASSERT, except it prints the wsprintf-formatted message
//   instead of the file and line number.
//
//   The sz parameter is always ANSI; AssertMsg correctly converts it
//   to unicode if necessary.  This is so you don't have to wrap your
//   debug strings with TEXT().
//
//   The BF_ASSERT bit in g_dwBreakFlags governs whether the function 
//   performs a DebugBreak().
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew and break
//      Full debug builds:  spew and break
//
#ifdef DEBUG

void CDECL CcshellAssertMsgW(BOOL bAssert, LPCSTR pszMsg, ...);
void CDECL CcshellAssertMsgA(BOOL bAssert, LPCSTR pszMsg, ...);
#ifdef UNICODE
#define CcshellAssertMsg        CcshellAssertMsgW
#else
#define CcshellAssertMsg        CcshellAssertMsgA
#endif

#define ASSERTMSG           CcshellAssertMsg

#else  // DEBUG

#define ASSERTMSG       1 ? (void)0 : (void)

#endif // DEBUG



// EVAL(f)
//
//   Behaves like ASSERT().  Evaluates the expression (f).  The expression 
//   is always evaluated, even in retail builds.  But the macro only asserts 
//   in the debug build.  This macro may be used on logical expressions, eg:
//
//          if (EVAL(exp))
//              // do something
//
//   Do *not* use EVAL() to verify successful API calls if the APIs can 
//   legitimately fail due to low resources.  For example, LocalAlloc can 
//   legally fail, so you shouldn't assert that it will never fail.
//
//   The BF_ASSERT bit in g_dwBreakFlags governs whether the function 
//   performs a DebugBreak().
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew and break
//      Full debug builds:  spew and break
//
#ifdef DEBUG

#define EVAL(exp)   \
    ((exp) || (CcshellAssertFailed(TEXT(__FILE__), __LINE__, TEXT(#exp), TRUE, FALSE), 0))

#else  // DEBUG

#define EVAL(exp)       ((exp) != 0)

#endif // DEBUG



// RIP(f)
// 
//   Generates a "RIP at file.c, line x (eval)" message if f is NOT true.
//   
//   Use RIP() to perform parameter validation, especially when you
//   know the function or method may be called by a 3rd party app.
//   Typically, RIPs are used to indicate the caller passed in an invalid 
//   parameter, so the problem is really not in the code itself.
//
//   Do *not* use RIP() to verify successful API calls if the APIs can 
//   legitimately fail due to low resources.  For example, LocalAlloc can 
//   legally fail, so you shouldn't assert that it will never fail.
//
//   RIP performs a debugbreak only in the following processes:
//
//      explore.exe
//      iexplore.exe
//      rundll32.exe
//      welcome.exe
//
//   In any other process, this just spews the debug message, but doesn't stop.
//   
//   Setting the BF_RIP bit in g_dwBreakFlags will cause the macro to perform 
//   a DebugBreak() even in non-shell processes.
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew (other processes), spew and break (shell processes)
//      Full debug builds:  spew (other processes), spew and break (shell processes)
//
#ifdef DEBUG

BOOL CcshellRipA(LPCSTR pszFile, int line, LPCSTR pszEval, BOOL bBreakInside);
BOOL CcshellRipW(LPCWSTR pszFile, int line, LPCWSTR pwszEval, BOOL bBreakInside);
#ifdef UNICODE
#define CcshellRip      CcshellRipW
#else
#define CcshellRip      CcshellRipA
#endif

#define RIP(f)                                                                                              \
    {                                                                                                       \
        DEBUGTEXT(szFile, TEXT(__FILE__));                                                                  \
        if (!(f) && CcshellRip(szFile, __LINE__, TEXT(#f), FALSE))                                          \
        {                                                                                                   \
            DEBUG_BREAK;                                                                                    \
        }                                                                                                   \
    }                                                                                                       \

#define RIPMSG(f, msg)                                                                                      \
    {                                                                                                       \
        DEBUGTEXT(szFile, TEXT(__FILE__));                                                                  \
        if (!(f) && CcshellRip(szFile, __LINE__, TEXT(#msg), FALSE))                                        \
        {                                                                                                   \
            DEBUG_BREAK;                                                                                    \
        }                                                                                                   \
    }                                                                                                       \


#else  // DEBUG

#define RIP(f)
#define RIPMSG(f, msg)

#endif // DEBUG



// TraceMsg(dwMask, sz, args...) 
//
//   Generate wsprintf-formatted message using the specified trace dwMask.
//   dwMask may be one of the predefined bits:
//
//      TF_ERROR    - display "err <MODULE>  <string>"
//      TF_WARNING  - display "wn  <MODULE>  <string>"
//      TF_GENERAL  - display "t   <MODULE>  <string>"
//      TF_ALWAYS   - display "t   <MODULE>  <string>" regardless of g_dwTraceFlags.
//
//   or it may be a custom bit (any of the upper 28 bits).
//
//   The g_dwTraceFlags global governs whether the message is displayed (based
//   upon the dwMask parameter).
//
//   The sz parameter is always ANSI; TraceMsg correctly converts it
//   to unicode if necessary.  This is so you don't have to wrap your
//   debug strings with TEXT().
//
//   In addition to squirting the trace message, you may optionally cause
//   the trace message to stop if you need to trace down the source of
//   an error.  The BF_ONERRORMSG and BF_ONWARNMSG bits may be set in
//   g_dwBreakFlags to make TraceMsg stop when a TF_ERROR or TF_WARNING
//   message is displayed.  But typically these bits are disabled.
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       only TF_ALWAYS and TF_ERROR messages spew
//      Full debug builds:  spew
//
#ifdef DEBUG

void CDECL CcshellDebugMsgW(DWORD mask, LPCSTR pszMsg, ...);
void CDECL CcshellDebugMsgA(DWORD mask, LPCSTR pszMsg, ...);
void CDECL _DebugMsgA(DWORD flag, LPCSTR psz, ...);
void CDECL _DebugMsgW(DWORD flag, LPCWSTR psz, ...);
#ifdef UNICODE
#define CcshellDebugMsg         CcshellDebugMsgW
#define _DebugMsg               _DebugMsgW
#else
#define CcshellDebugMsg         CcshellDebugMsgA
#define _DebugMsg               _DebugMsgA
#endif

#define TraceMsgW           CcshellDebugMsgW
#define TraceMsgA           CcshellDebugMsgA
#define TraceMsg            CcshellDebugMsg

// Use TraceMsg instead of DebugMsg.  DebugMsg is obsolete.
#ifdef DISALLOW_DebugMsg
#define DebugMsg            Dont_use_DebugMsg___Use_TraceMsg
#else
#define DebugMsg            _DebugMsg
#endif

#else  // DEBUG

#define TraceMsgA       1 ? (void)0 : (void)
#define TraceMsgW       1 ? (void)0 : (void)
#define TraceMsg        1 ? (void)0 : (void)
#define DebugMsg        1 ? (void)0 : (void)

#endif // DEBUG



// THR(pfn)
// TBOOL(pfn)
// TINT(pfn)
// TPTR(pfn)
// TW32(pfn)
// 
//   These macros are useful to trace failed calls to functions that return
//   HRESULTs, BOOLs, ints, or pointers.  An example use of this is:
//
//   {
//       ...
//       hres = THR(CoCreateInstance(CLSID_Bar, NULL, CLSCTX_INPROC_SERVER, 
//                                   IID_IBar, (LPVOID*)&pbar));
//       if (SUCCEEDED(hres))
//       ...
//   }
//
//   If CoCreateInstance failed, you would see spew similar to:
//
//    err MODULE  THR: Failure of "CoCreateInstance(CLSID_Bar, NULL, CLSCTX_INPROC_SERVER, IID_IBar, (LPVOID*)&pbar)" at foo.cpp, line 100  (0x80004005)
//
//   THR keys off of the failure code of the hresult.
//   TBOOL considers FALSE to be a failure case.
//   TINT considers -1 to be a failure case.
//   TPTR considers NULL to be a failure case.
//   TW32 keys off the failure code of the Win32 error code.
//
//   Set the BF_THR bit in g_dwBreakFlags to stop when these macros see a failure.
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       nothing
//      Full debug builds:  spew on error
//
#ifdef DEBUG

EXTERN_C HRESULT TraceHR(HRESULT hrTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C BOOL    TraceBool(BOOL bTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C int     TraceInt(int iTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C LPVOID  TracePtr(LPVOID pvTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C DWORD   TraceWin32(DWORD dwTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);

#define THR(x)      (TraceHR((x), #x, __FILE__, __LINE__))
#define TBOOL(x)    (TraceBool((x), #x, __FILE__, __LINE__))
#define TINT(x)     (TraceInt((x), #x, __FILE__, __LINE__))
#define TPTR(x)     (TracePtr((x), #x, __FILE__, __LINE__))
#define TW32(x)     (TraceWin32((x), #x, __FILE__, __LINE__))

#else  // DEBUG

#define THR(x)          (x)
#define TBOOL(x)        (x)
#define TINT(x)         (x)
#define TPTR(x)         (x)
#define TW32(x)         (x)

#endif // DEBUG



// DBEXEC(flg, expr)
//
//   under DEBUG, does "if (flg) expr;" (w/ the usual safe syntax)
//   under !DEBUG, does nothing (and does not evaluate either of its args)
//
#ifdef DEBUG

#define DBEXEC(flg, expr)    ((flg) ? (expr) : 0)

#else  // DEBUG

#define DBEXEC(flg, expr)   /*NOTHING*/

#endif // DEBUG


// string and buffer whacking functions
//
#ifdef DEBUG

EXTERN_C void DEBUGWhackPathBufferA(LPSTR psz, UINT cch);
EXTERN_C void DEBUGWhackPathBufferW(LPWSTR psz, UINT cch);
EXTERN_C void DEBUGWhackPathStringA(LPSTR psz, UINT cch);
EXTERN_C void DEBUGWhackPathStringW(LPWSTR psz, UINT cch);

#ifdef UNICODE
#define DEBUGWhackPathBuffer DEBUGWhackPathBufferW
#define DEBUGWhackPathString DEBUGWhackPathStringW
#else
#define DEBUGWhackPathBuffer DEBUGWhackPathBufferA
#define DEBUGWhackPathString DEBUGWhackPathStringA
#endif

#else // DEBUG

#define DEBUGWhackPathBuffer(psz, cch)
#define DEBUGWhackPathString(psz, cch)

#endif // DEBUG


// Some trickery to map ATL debug macros to ours, so ATL code that stops
// or spews in our code will look like the rest of our squirties.

#ifdef DEBUG

#ifdef _ATL_NO_DEBUG_CRT
// ATL uses _ASSERTE.  Map it to ours.
#define _ASSERTE(f)         ASSERT(f)

// We map ATLTRACE macros to our functions
void _cdecl ShellAtlTraceA(LPCSTR lpszFormat, ...);
void _cdecl ShellAtlTraceW(LPCWSTR lpszFormat, ...);
#ifdef UNICODE
#define ShellAtlTrace   ShellAtlTraceW
#else
#define ShellAtlTrace   ShellAtlTraceA
#endif
#define ATLTRACE            ShellAtlTrace
#endif

#else  // DEBUG

#ifdef _ATL_NO_DEBUG_CRT
// ATL uses _ASSERTE.  Map it to ours.
#define _ASSERTE(f)

// We map ATLTRACE macros to our functions
#define ATLTRACE            1 ? (void)0 : (void)
#endif

#endif // DEBUG


// ------ Stay away from these macros below ----------
// Issue (scotth):  remove these by 8/15/98.  They should not be used anymore. 
#ifdef DEBUG

#define AssertE(f)          ASSERT(f)
#define AssertMsg           _AssertMsg
#define AssertStrLen        _AssertStrLen
#define AssertStrLenA       _AssertStrLenA
#define AssertStrLenW       _AssertStrLenW

#ifdef FULL_DEBUG
#define FullDebugMsg        _DebugMsg
#else
#define FullDebugMsg        1 ? (void)0 : (void)
#endif

#define ASSERT_MSGW         CcshellAssertMsgW
#define ASSERT_MSGA         CcshellAssertMsgA
#define ASSERT_MSG          CcshellAssertMsg
#else  // DEBUG

#define AssertE(f)      (f)
#define AssertMsg       1 ? (void)0 : (void)
#define AssertStrLen(lpStr, iLen)
#define FullDebugMsg    1 ? (void)0 : (void)
#define ASSERT_MSGA     1 ? (void)0 : (void)
#define ASSERT_MSGW     1 ? (void)0 : (void)
#define ASSERT_MSG      1 ? (void)0 : (void)

#endif // DEBUG
// ------ Stay away from these macros above ----------



// It's necessary to find when classes that were designed to be single threaded are used
// across threads so they can be fixed to be multithreaded.  These asserts will point
// out such cases.
#ifdef DEBUG
#define ASSERT_SINGLE_THREADED              AssertMsg(_dwThreadIDForSingleThreadedAssert == GetCurrentThreadId(), TEXT("MULTI-THREADED BUG: This class is being used by more than one thread, but it's not thread safe."))
#define INIT_SINGLE_THREADED_ASSERT         _dwThreadIDForSingleThreadedAssert = GetCurrentThreadId();
#define SINGLE_THREADED_MEMBER_VARIABLE     DWORD _dwThreadIDForSingleThreadedAssert;
#else // DEBUG
#define ASSERT_SINGLE_THREADED              NULL;
#define INIT_SINGLE_THREADED_ASSERT         NULL;
#define SINGLE_THREADED_MEMBER_VARIABLE     
#endif // DEBUG



#ifdef DEBUG

#define Dbg_SafeStrA(psz)   (SAFECAST(psz, LPCSTR), (psz) ? (psz) : "NULL string")
#define Dbg_SafeStrW(psz)   (SAFECAST(psz, LPCWSTR), (psz) ? (psz) : L"NULL string")
#ifdef UNICODE
#define Dbg_SafeStr         Dbg_SafeStrW
#else
#define Dbg_SafeStr         Dbg_SafeStrA
#endif

#define FUNC_MSG            CcshellFuncMsg


// Helpful macro for mapping manifest constants to strings.  Assumes
// return string is pcsz.  You can use this macro in this fashion:
//
// LPCSTR Dbg_GetFoo(FOO foo)
// {
//    LPCTSTR pcsz = TEXT("Unknown <foo>");
//    switch (foo)
//    {
//    STRING_CASE(FOOVALUE1);
//    STRING_CASE(FOOVALUE2);
//    ...
//    }
//    return pcsz;
// }
//
#define STRING_CASE(val)               case val: pcsz = TEXT(#val); break


// Debug function enter


// DBG_ENTER(flag, fn)  -- Generates a function entry debug spew for
//                          a function
//
#define DBG_ENTER(flagFTF, fn)                  \
        (FUNC_MSG(flagFTF, " > " #fn "()"), \
         CcshellStackEnter())

// DBG_ENTER_TYPE(flag, fn, dw, pfnStrFromType)  -- Generates a function entry debug
//                          spew for functions that accept <type>.
//
#define DBG_ENTER_TYPE(flagFTF, fn, dw, pfnStrFromType)                   \
        (FUNC_MSG(flagFTF, " < " #fn "(..., %s, ...)", (LPCTSTR)pfnStrFromType(dw)), \
         CcshellStackEnter())

// DBG_ENTER_SZ(flag, fn, sz)  -- Generates a function entry debug spew for
//                          a function that accepts a string as one of its
//                          parameters.
//
#define DBG_ENTER_SZ(flagFTF, fn, sz)                  \
        (FUNC_MSG(flagFTF, " > " #fn "(..., \"%s\",...)", Dbg_SafeStr(sz)), \
         CcshellStackEnter())


// Debug function exit


// DBG_EXIT(flag, fn)  -- Generates a function exit debug spew
//
#define DBG_EXIT(flagFTF, fn)                              \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "()"))

// DBG_EXIT_TYPE(flag, fn, dw, pfnStrFromType)  -- Generates a function exit debug
//                          spew for functions that return <type>.
//
#define DBG_EXIT_TYPE(flagFTF, fn, dw, pfnStrFromType)                   \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %s", (LPCTSTR)pfnStrFromType(dw)))

// DBG_EXIT_INT(flag, fn, us)  -- Generates a function exit debug spew for
//                          functions that return an INT.
//
#define DBG_EXIT_INT(flagFTF, fn, n)                       \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %d", (int)(n)))

// DBG_EXIT_BOOL(flag, fn, b)  -- Generates a function exit debug spew for
//                          functions that return a boolean.
//
#define DBG_EXIT_BOOL(flagFTF, fn, b)                      \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %s", (b) ? (LPTSTR)TEXT("TRUE") : (LPTSTR)TEXT("FALSE")))

// DBG_EXIT_UL(flag, fn, ul)  -- Generates a function exit debug spew for
//                          functions that return a ULONG.
//
#ifdef _WIN64
#define DBG_EXIT_UL(flagFTF, fn, ul)                   \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %#016I64x", (ULONG_PTR)(ul)))
#else
#define DBG_EXIT_UL(flagFTF, fn, ul)                   \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %#08lx", (ULONG)(ul)))
#endif // _WIN64

#define DBG_EXIT_DWORD      DBG_EXIT_UL

// DBG_EXIT_HRES(flag, fn, hres)  -- Generates a function exit debug spew for
//                          functions that return an HRESULT.
//
#define DBG_EXIT_HRES(flagFTF, fn, hres)     DBG_EXIT_TYPE(flagFTF, fn, hres, Dbg_GetHRESULTName)



#else   // DEBUG


#define Dbg_SafeStr     1 ? (void)0 : (void)

#define FUNC_MSG        1 ? (void)0 : (void)


#define DBG_ENTER(flagFTF, fn)
#define DBG_ENTER_TYPE(flagFTF, fn, dw, pfn)
#define DBG_ENTER_SZ(flagFTF, fn, sz)
#define DBG_EXIT(flagFTF, fn)
#define DBG_EXIT_INT(flagFTF, fn, n)
#define DBG_EXIT_BOOL(flagFTF, fn, b)
#define DBG_EXIT_UL(flagFTF, fn, ul)
#define DBG_EXIT_DWORD      DBG_EXIT_UL
#define DBG_EXIT_TYPE(flagFTF, fn, dw, pfn)
#define DBG_EXIT_HRES(flagFTF, fn, hres)

#endif  // DEBUG



// COMPILETIME_ASSERT(f)
//
//  Generates a build break at compile time if the constant expression
//  is not true.  Unlike the "#if" compile-time directive, the expression
//  in COMPILETIME_ASSERT() is allowed to use "sizeof".
//
//  Compiler magic!  If the expression "f" is FALSE, then you get the
//  compiler error "Duplicate case expression in switch statement".
//
#define COMPILETIME_ASSERT(f) switch (0) case 0: case f:


#endif  // NOSHELLDEBUG


// 
// Debug dump helper functions
//

#ifdef DEBUG

LPCTSTR Dbg_GetCFName(UINT ucf);
LPCTSTR Dbg_GetHRESULTName(HRESULT hr);
LPCTSTR Dbg_GetREFIIDName(REFIID riid);
LPCTSTR Dbg_GetVTName(VARTYPE vt);

#else

#define Dbg_GetCFName(ucf)          (void)0
#define Dbg_GetHRESULTName(hr)      (void)0
#define Dbg_GetREFIIDName(riid)     (void)0
#define Dbg_GetVTName(vt)           (void)0

#endif // DEBUG

// I'm a lazy typist...
#define Dbg_GetHRESULT              Dbg_GetHRESULTName

// Parameter validation macros
#include "validate.h"

#endif // DECLARE_DEBUG

#ifdef PRODUCT_PROF 
int __stdcall StartCAP(void);	// start profiling
int __stdcall StopCAP(void);    // stop profiling until StartCAP
int __stdcall SuspendCAP(void); // suspend profiling until ResumeCAP
int __stdcall ResumeCAP(void);  // resume profiling
int __stdcall StartCAPAll(void);    // process-wide start profiling
int __stdcall StopCAPAll(void);     // process-wide stop profiling
int __stdcall SuspendCAPAll(void);  // process-wide suspend profiling
int __stdcall ResumeCAPAll(void);   // process-wide resume profiling
void __stdcall MarkCAP(long lMark);  // write mark to MEA
extern DWORD g_dwProfileCAP;
#else
#define StartCAP()      0
#define StopCAP()       0
#define SuspendCAP()    0
#define ResumeCAP()     0
#define StartCAPAll()   0
#define StopCAPAll()    0
#define SuspendCAPAll() 0
#define ResumeCAPAll()  0
#define MarkCAP(n)      0

#define g_dwProfileCAP  0
#endif

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\helpers.h ===
//
// helpers.h
//

#ifndef HELPERS_H
#define HELPERS_H


#ifdef __cplusplus

//
// generic COM stuff
//

#define SafeRelease(punk)       \
{                               \
    if ((punk) != NULL)         \
    {                           \
        (punk)->Release();      \
    }                           \
}                   

#define SafeReleaseClear(punk)  \
{                               \
    if ((punk) != NULL)         \
    {                           \
        (punk)->Release();      \
        (punk) = NULL;          \
    }                           \
}                   

// COM identity compare
inline BOOL IdentityCompare(IUnknown *p1, IUnknown *p2)
{
    IUnknown *punk1 = NULL;
    IUnknown *punk2 = NULL;
    BOOL fRet = FALSE;

    if (p1->QueryInterface(IID_IUnknown, (void **)&punk1) != S_OK)
        goto Exit;

    if (p2->QueryInterface(IID_IUnknown, (void **)&punk2) != S_OK)
        goto Exit;

    fRet = (punk1 == punk2);

Exit:
    SafeRelease(punk1);
    SafeRelease(punk2);
    return fRet;
}

// inline VariantInit
inline void QuickVariantInit(VARIANT *pvar)
{
    pvar->vt = VT_EMPTY;
}

#endif // __cplusplus

// convert a boolean to S_OK or S_FALSE
#define HRBOOL(e) ( (e) ? S_OK : S_FALSE )

#endif // HELPERS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\fontlink.h ===
//
// fontlink.h
//

#ifndef FONTLINK_H
#define FONTLINK_H

#include "private.h"


//
//  CodePages
//
#define CP_OEM_437       437
#define CP_IBM852        852
#define CP_IBM866        866
#define CP_THAI          874
#define CP_JAPAN         932
#define CP_CHINA         936
#define CP_KOREA         949
#define CP_TAIWAN        950
#define CP_EASTEUROPE    1250
#define CP_RUSSIAN       1251
#define CP_WESTEUROPE    1252
#define CP_GREEK         1253
#define CP_TURKISH       1254
#define CP_HEBREW        1255
#define CP_ARABIC        1256
#define CP_BALTIC        1257
#define CP_VIETNAMESE    1258
#define CP_RUSSIANKOI8R  20866
#define CP_RUSSIANKOI8RU 21866
#define CP_ISOEASTEUROPE 28592
#define CP_ISOTURKISH    28593
#define CP_ISOBALTIC     28594
#define CP_ISORUSSIAN    28595
#define CP_ISOARABIC     28596
#define CP_ISOGREEK      28597
#define CP_JAPANNHK      50220
#define CP_JAPANESC      50221
#define CP_JAPANSIO      50222
#define CP_KOREAISO      50225
#define CP_JAPANEUC      51932
#define CP_CHINAHZ       52936
#define CP_MAC_ROMAN     10000
#define CP_MAC_JAPAN     10001
#define CP_MAC_GREEK     10006
#define CP_MAC_CYRILLIC  10007
#define CP_MAC_LATIN2    10029
#define CP_MAC_TURKISH   10081
#define CP_DEFAULT       CP_ACP
#define CP_GETDEFAULT    GetACP()
#define CP_JOHAB         1361
#define CP_SYMBOL        42
#define CP_UTF8          65001
#define CP_UTF7          65000
#define CP_UNICODELITTLE 1200
#define CP_UNICODEBIG    1201

#define OEM437_CHARSET   254

BOOL FLExtTextOutW(HDC hdc, int xp, int yp, UINT eto, CONST RECT *lprect, LPCWSTR lpwch, UINT cLen, CONST INT *lpdxp);
BOOL FLTextOutW(HDC hdc, int xp, int yp, LPCWSTR lpwch, int cLen);
BOOL FLGetTextExtentPoint32(HDC hdc, LPCWSTR lpwch, int cch, LPSIZE lpSize);
int FLDrawTextW(HDC hdc, LPCWSTR lpchText, int cchText, LPCRECT lprc, UINT format);

int LoadStringWrapW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int nBufferMax);

int FLDrawTextWVert(HDC hdc, LPCWSTR lpchText, int cchText, LPCRECT lprc, UINT format);
      
#endif // FONTLINK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\editcb.h ===
//
// editcb.h
//
// CEditSession
//

#ifndef EDITCB_H
#define EDITCB_H

#include "private.h"

class CEditSession;

typedef HRESULT (*ESCALLBACK)(TfEditCookie ec, CEditSession *);

class CEditSession : public ITfEditSession
{
public:
    CEditSession(ESCALLBACK pfnCallback);
    virtual ~CEditSession() {};

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfEditCallback
    //
    STDMETHODIMP DoEditSession(TfEditCookie ec);

    // data for use by owner
    struct
    {
        void *pv;
        UINT_PTR u;
        HWND hwnd;
        WPARAM wParam;
        LPARAM lParam;
        void *pv1;
        void *pv2;
        ITfContext *pic; // Issue: use pv1, pv2
        ITfRange *pRange; // Issue: use pv1, pv2
        BOOL fBool;
    } _state;

private:
    ESCALLBACK _pfnCallback;
    int _cRef;
};

#endif // EDIT_CB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\fnprbase.h ===
//
// funcprv.h
//

#ifndef FNPRBASE_H
#define FNPRBASE_H

#include "private.h"

class __declspec(novtable) CFunctionProviderBase : public ITfFunctionProvider
{
public:
    CFunctionProviderBase(TfClientId tid);
    virtual ~CFunctionProviderBase();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfFunctionProvider
    //
    STDMETHODIMP GetType(GUID *pguid);
    STDMETHODIMP GetDescription(BSTR *pbstrDesc);
    STDMETHODIMP GetFunction(REFGUID rguid, REFIID riid, IUnknown **ppunk);

    BOOL Init(REFGUID guidType, WCHAR *pszDesc);
    HRESULT _Advise(ITfThreadMgr *ptim);
    HRESULT _Unadvise(ITfThreadMgr *ptim);

private:
    TfClientId _tid;
    GUID _guidType;
    BSTR _bstrDesc;
    long _cRef;
};

#endif // FNPRBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\ico.h ===
//
// ico.h
//
// Generic ITfContextOwner object
//

#ifndef ICO_H
#define ICO_H

#include "private.h"

#define ICO_INVALID_COOKIE  ((DWORD)(-1))

#define ICO_POINT_TO_ACP    1
#define ICO_SCREENEXT       2
#define ICO_TEXTEXT         3
#define ICO_KEYDOWN         4
#define ICO_KEYUP           5
#define ICO_STATUS          6
#define ICO_WND             7
#define ICO_ATTR            8
#define ICO_ADVISEMOUSE     9
#define ICO_UNADVISEMOUSE   10
#define ICO_TESTKEYDOWN     11
#define ICO_TESTKEYUP       12

typedef struct
{
    union
    {
        // ICO_POINT_TO_ACP
        struct
        {
            const POINT *pt;
            DWORD dwFlags;
            LONG *pacp;
        } pta;
        // ICO_SCREENEXT
        struct
        {
            RECT *prc;
        } scr_ext;
        // ICO_TEXTEXT
        struct
        {
            LONG acpStart;
            LONG acpEnd;
            RECT *prc;
            BOOL *pfClipped;
        } text_ext;
        // ICO_KEYDOWN, ICO_KEYUP
        struct
        {
            WPARAM wParam;
            LPARAM lParam;
            ITfContext *pic;
            BOOL *pfEaten;
        } key;
        // ICO_STATUS
        struct
        {
            TF_STATUS *pdcs;
        } status;
        // ICO_HWND
        struct
        {
            HWND *phwnd;
        } hwnd;
        // ICO_ATTR
        struct
        {
            const GUID *pguid;
            VARIANT *pvar;
        } sys_attr;
        // ICO_ADVISEMOUSE
        struct
        {
            ITfRangeACP *rangeACP;
            ITfMouseSink *pSink;
            DWORD *pdwCookie;
        } advise_mouse;
        // ICO_UNADVISEMOUSE
        struct
        {
            DWORD dwCookie;
        } unadvise_mouse;
    };
} ICOARGS;

typedef HRESULT (*ICOCALLBACK)(UINT uCode, ICOARGS *pargs, void *pv);

class CInputContextOwner : public ITfContextOwner,
                           public ITfMouseTrackerACP
{
public:
    CInputContextOwner(ICOCALLBACK pfnCallback, void *pv);
    virtual ~CInputContextOwner() {};

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfContextOwner
    //
    STDMETHODIMP GetACPFromPoint(const POINT *pt, DWORD dwFlags, LONG *pacp);
    STDMETHODIMP GetScreenExt(RECT *prc);
    STDMETHODIMP GetTextExt(LONG acpStart, LONG acpEnd, RECT *prc, BOOL *pfClipped);
    STDMETHODIMP GetStatus(TF_STATUS *pdcs);
    STDMETHODIMP GetWnd(HWND *phwnd);
    STDMETHODIMP GetAttribute(REFGUID rguidAttribute, VARIANT *pvarValue);

    // ITfMouseTrackerACP
    STDMETHODIMP AdviseMouseSink(ITfRangeACP *range, ITfMouseSink *pSink, DWORD *pdwCookie);
    STDMETHODIMP UnadviseMouseSink(DWORD dwCookie);

    HRESULT _Advise(ITfContext *pic);
    HRESULT _Unadvise();

protected:
    void SetCallbackPV(void* pv)
    {
        if (_pv == NULL)
            _pv = pv;
    };

private:

    long _cRef;
    ITfContext *_pic;
    DWORD _dwCookie;
    ICOCALLBACK _pfnCallback;
    void *_pv;
};

class CInputContextKeyEventSink : public ITfContextKeyEventSink
{
public:
    CInputContextKeyEventSink(ICOCALLBACK pfnCallback, void *pv);

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfContextKeyEventSink
    //
    STDMETHODIMP OnKeyDown(WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnKeyUp(WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnTestKeyDown(WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnTestKeyUp(WPARAM wParam, LPARAM lParam, BOOL *pfEaten);

    HRESULT _Advise(ITfContext *pic);
    HRESULT _Unadvise();

private:

    long _cRef;
    ITfContext *_pic;
    DWORD _dwCookie;
    ICOCALLBACK _pfnCallback;
    void *_pv;
};

#endif // ICO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\iconlib.h ===
//
// iconlib.h
//

#ifndef ICONLIB_H
#define ICONLIB_H

BOOL GetIconSize( HICON hIcon, SIZE *psize );
BOOL GetIconBitmaps(HICON hIcon, HBITMAP *phbmp, HBITMAP *phbmpMask, SIZE *psize);
int GetMenuIconHeight(int *pnMenuFontHeghti);

#endif // ICONLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\icrtfree.h ===
//
// Code to help free modules from the bondage and tyranny of CRT libraries
//
// Include this header in a single component and #define CPP_FUNCTIONS
//


#if defined(__cplusplus) && defined(CPP_FUNCTIONS)

#include "mem.h"
#undef new

void *  __cdecl operator new(size_t nSize)
{
    return cicMemAllocClear((UINT)nSize);
}

void  __cdecl operator delete(void *pv)
{
    cicMemFree(pv);
}

void __cdecl operator delete[]( void * p )
{
    operator delete(p);
}

void * __cdecl operator new[]( size_t cb )
{
    return operator new(cb);
}

extern "C" int __cdecl _purecall(void) {return 0;}

#endif

#ifdef __cplusplus
extern "C" {
#endif

#if defined(DEFINE_FLOAT_STUFF)
// If you aren't using any floating-point CRT functions and you know
// you aren't performing any float conversions or arithmetic, yet the
// linker wants these symbols declared, then define DEFINE_FLOAT_STUFF.
//
// Warning: declaring these symbols in a component that needs floating
// point support from the CRT will produce undefined results.  (You will
// need fp support from the CRT if you simply perform fp arithmetic.)

int _fltused = 0;
void __cdecl _fpmath(void) { }
#endif

#ifdef __cplusplus
};
#endif

//
// This file should be included in a global component header
// to use the following
//

#ifndef __CRTFREE_H_
#define __CRTFREE_H_

#ifdef __cplusplus

#ifndef _M_PPC
#pragma intrinsic(memcpy)
#pragma intrinsic(memcmp)
#pragma intrinsic(memset)
#endif

#endif

#endif  // __CRTFREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\immlist.h ===
//
// imelist.h
//

#ifndef TFMLIST_H
#define TFMLIST_H

#include "ptrmap.h"

class CVoidPtrCicList;

class __declspec(novtable) CVoidPtrCicListItem
{
public:
    CVoidPtrCicListItem(void *pHandle) { _Init(pHandle); }
    CVoidPtrCicListItem *GetNext() {return _pNext;}

    void _Init(void *pHandle) { _pNext = NULL; _pHandle = pHandle; }

private:
friend CVoidPtrCicList;
    CVoidPtrCicListItem *_pNext;
    void *_pHandle;

};

class CVoidPtrCicList
{
public:
    CVoidPtrCicList();

    void Add(CVoidPtrCicListItem *pitem);
    CVoidPtrCicListItem *Find(void *pHandle);
    BOOL Remove(CVoidPtrCicListItem *pitem);
    CVoidPtrCicListItem *GetFirst() {return _pitemHdr;}

private:
    CVoidPtrCicListItem *_pitemHdr;
    CVoidPtrCicListItem *_pitemLast;
};


template<class T>
class __declspec(novtable) CPtrCicListItem : public CVoidPtrCicListItem
{
public:
    CPtrCicListItem(void *pHandle = NULL) : CVoidPtrCicListItem(pHandle) {}
    T *GetNext() {return  (T *)CVoidPtrCicListItem::GetNext();}
};


template<class T>
class __declspec(novtable) CUintPtrCicListItem : public CVoidPtrCicListItem
{
public:
    CUintPtrCicListItem(UINT_PTR up = 0) : CVoidPtrCicListItem((void *)up) {}
    T *GetNext() {return  (T *)CVoidPtrCicListItem::GetNext();}
};

template<class T>
class CPtrCicList : public CVoidPtrCicList
{
public:
    CPtrCicList() {}
    T *Find(void *pv) {return (T *)CVoidPtrCicList::Find(pv); }
    T *GetFirst() {return (T *)CVoidPtrCicList::GetFirst(); }
};

template<class T>
class CUintPtrCicList : public CVoidPtrCicList
{
public:
    CUintPtrCicList() {}
    T *Find(UINT_PTR up) {return (T *)CVoidPtrCicList::Find((void *)up); }
    T *GetFirst() {return (T *)CVoidPtrCicList::GetFirst(); }
};

template<class T>
class CPtrCicListItem2 : public CVoidPtrCicListItem
{
public:
    CPtrCicListItem2(T *pHandle = NULL) : CVoidPtrCicListItem(pHandle) {}
    CPtrCicListItem2 *GetNext() {return (CPtrCicListItem2 *)CVoidPtrCicListItem::GetNext();}
    T *GetThis() {return (T *)_pThis;}
    void SetThis(T *pv) {_pThis = pv;}
private:
    T *_pThis;
};

#endif // TFMLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\inatlib.h ===
//
// inatlib.h
//

#ifndef INATLIB_H
#define INATLIB_H


//-----------------------------------------------------------------------------
//
// MLNGINFO APIs
//
//-----------------------------------------------------------------------------

void WINAPI TF_InitMlngInfo();
int WINAPI TF_MlngInfoCount();
BOOL WINAPI TF_GetMlngHKL(int uId, HKL *phkl, WCHAR *psz, UINT cch);
UINT WINAPI TF_GetMlngIconIndex(int uId);
HICON WINAPI TF_InatExtractIcon(UINT uId);

#endif // INATLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\mes.h ===
//
// mes.h
//

#ifndef MES_H
#define MES_H

#include "private.h"

typedef HRESULT (*MOUSECALLBACK)(ULONG uEdge, ULONG uQuadrant, DWORD dwBtnStatus, BOOL *pfEaten, void *pv);

class CMouseSink : public ITfMouseSink
{
public:
    CMouseSink(MOUSECALLBACK pfnCallback, void *pv);

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfMouseSink
    //
    STDMETHODIMP OnMouseEvent(ULONG uEdge, ULONG uQuadrant, DWORD dwBtnStatus, BOOL *pfEaten);

    HRESULT _Advise(ITfRange *range, ITfContext *pic);
    HRESULT _Unadvise();

private:

    long _cRef;
    ITfContext *_pic;
    DWORD _dwCookie;
    MOUSECALLBACK _pfnCallback;
    void *_pv;
};

#endif // MES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\kes.h ===
//
// kes.h
//

#ifndef KES_H
#define KES_H

#include "private.h"

typedef HRESULT (*KESCALLBACK)(UINT uCode, ITfContext *pic, WPARAM wParam, LPARAM lParam, BOOL *pfEaten, void *pv);
typedef HRESULT (*KESPREKEYCALLBACK)(ITfContext *pic, REFGUID rguid, BOOL *pfEaten, void *pv);


#define KES_CODE_FOCUS          0x00000000
#define KES_CODE_KEYUP          0x00000001
#define KES_CODE_KEYDOWN        0x00000002
#define KES_CODE_TEST           0x80000000


typedef struct tag_KESPRESERVEDKEY {
    const GUID     *pguid;
    TF_PRESERVEDKEY tfpk;
    const WCHAR    *psz;
} KESPRESERVEDKEY;
    
class CKeyEventSink : public ITfKeyEventSink
{
public:
    CKeyEventSink(KESCALLBACK pfnCallback, void *pv);
    CKeyEventSink(KESCALLBACK pfnCallback, KESPREKEYCALLBACK pfnPrekeyCallback, void *pv);
    ~CKeyEventSink();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfWin32KeyEventSink
    //
    STDMETHODIMP OnSetFocus(BOOL fForeground);
    STDMETHODIMP OnTestKeyDown(ITfContext *pic, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnKeyDown(ITfContext *pic, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnTestKeyUp(ITfContext *pic, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnKeyUp(ITfContext *pic, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnPreservedKey(ITfContext *pic, REFGUID rguid, BOOL *pfEaten);

    HRESULT _Register(ITfThreadMgr *ptim, TfClientId tid, const KESPRESERVEDKEY *pprekey);
    HRESULT _Unregister(ITfThreadMgr *ptim, TfClientId tid, const KESPRESERVEDKEY *pprekey);

private:
    KESCALLBACK _pfnCallback;
    KESPREKEYCALLBACK _pfnPreKeyCallback;
    void *_pv;
    DWORD _dwCookiePreservedKey;
    int _cRef;
};

#endif // KES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\immxutil.h ===
//
// immxutil.h
//


#ifndef TFMXUTIL_H
#define TFMXUTIL_H

typedef struct tag_LIBTHREAD
{
    ITfCategoryMgr *_pcat;
    ITfDisplayAttributeMgr *_pDAM;
} LIBTHREAD;

BOOL TFInitLib(void);
void TFUninitLib(void);

//
// TFUninitThread should not be called in DllMain(THREAD_DETACH).
// Because this calls COM.
//
void TFUninitLib_Thread(LIBTHREAD *plt);

//
// call ntldr function for determin DLL_PROCESS_DETACH.
//
BOOL DllShutdownInProgress();

DWORD AsciiToNum( char *pszAscii);
BOOL AsciiToNumDec(char *pszAscii, DWORD *pdw);
DWORD WToNum( WCHAR *psz);
void NumToW(DWORD dw, WCHAR *psz);
void NumToA(DWORD dw, char *psz);
BOOL GetTopIC(ITfDocumentMgr *pdim, ITfContext **ppic);
int CompareGUIDs(REFGUID guid1, REFGUID guid2);
BOOL IsDisabledTextServices(void);
BOOL NoTipsInstalled(BOOL *pfOnlyTranslationRunning);
BOOL RunningOnWow64();
HKL GetSystemDefaultHKL();
BOOL IsDisabledCUAS();
void SetDisableCUAS(BOOL bDisableCUAS);
void RebootTheSystem();
BOOL IsAdminPrivilege();
BOOL IsInteractiveUserLogon();
BOOL FullPathExec( LPCSTR pszAppName, LPCSTR pszCmdLine, WORD wShowWindow, BOOL fWinDir);
BOOL RunCPLSetting(LPTSTR pCmdLine);

#define CR_ERROR        0xffffffff
#define CR_EQUAL        0x00000000
#define CR_RIGHTMEET    0x00000001
#define CR_RIGHT        0x00010001
#define CR_LEFTMEET     0x00000002
#define CR_LEFT         0x00010002
#define CR_PARTIAL      0x00000003
#define CR_INCLUSION    0x00000004

inline ITfContextView *GetActiveView(ITfDocumentMgr *dim)
{
    ITfContext *pic;
    ITfContextView *pView = NULL;

    if (dim->GetTop(&pic) == S_OK)
    {
        pic->GetActiveView(&pView);
        pic->Release();
    }

    return pView;
}

BOOL IsActiveView(ITfContext *pic, ITfContextView *pView);

HRESULT GetTextExtInActiveView(TfEditCookie ec, ITfRange *pRange, RECT *prc, BOOL *pfClipped);

int CompareRanges(TfEditCookie ec, ITfRange *pRangeSrc, ITfRange *pRangeCmp);

LONG AdjustAnchor(LONG ichAdjStart, LONG ichAdjEnd, LONG cchNew, LONG ichAnchor, BOOL fGravityRight);

#ifdef __cplusplus // "C" files can't handle "inline"

inline LONG CompareAnchors(IAnchor *pa1, IAnchor *pa2)
{
    LONG l;

    return FAILED(pa1->Compare(pa2, &l)) ? 0 : l;
}

inline BOOL IsEqualAnchor(IAnchor *pa1, IAnchor *pa2)
{
    BOOL fEqual;

    if (pa1->IsEqual(pa2, &fEqual) != S_OK)
    {
        Assert(0);
        // arbitrary: failure == not equal
        fEqual = FALSE;
    }

    return fEqual;
}

BOOL ShiftToOrClone(IAnchor **ppaDst, IAnchor *paSrc);

inline HRESULT GetService(IUnknown *punkProvider, REFIID refiid, IUnknown **ppunk)
{
    return punkProvider->QueryInterface(refiid, (void **)ppunk);
}

//
// GetSelectionSimple
//
// wrapper for GetSelection that throws out all style info, and ignores disjoint selections
//
inline HRESULT GetSelectionSimple(TfEditCookie ec, ITfContext *pic, ITfRange **ppSel)
{
    TF_SELECTION sel;
    ULONG cFetched;
    HRESULT hr;

    Assert(pic != NULL);
    Assert(ppSel != NULL);

    hr = pic->GetSelection(ec, TF_DEFAULT_SELECTION, 1, &sel, &cFetched);

    Assert(hr != S_OK || sel.range != NULL);

    *ppSel = NULL;
    if (hr == S_OK && cFetched > 0)
    {
        *ppSel = sel.range; // caller must Release
    }

    return hr;
}

//
// SetSelectionSimple
//
// Wrapper for SetSelection that takes only a single range and sets default style values.
//
inline HRESULT SetSelectionSimple(TfEditCookie ec, ITfContext *pic, ITfRange *range)
{
    TF_SELECTION sel;

    sel.range = range;
    sel.style.ase = TF_AE_NONE;
    sel.style.fInterimChar = FALSE;

    return pic->SetSelection(ec, 1, &sel);
}

inline BOOL GetCurrentPos(IStream *pStream, LARGE_INTEGER *pli)
{
    LARGE_INTEGER li;

    li.QuadPart = 0;

    return pStream->Seek(li, STREAM_SEEK_CUR, (ULARGE_INTEGER *)pli) == S_OK;
}

#endif // __cplusplus

HRESULT GetRangeForWholeDoc(TfEditCookie ec, ITfContext *pic, ITfRange **pprange);

#include "proputil.h"

#define LoadSmIcon(hinst, psz) (HICON)LoadImage(hinst, psz, IMAGE_ICON, 16,16, 0)

// NB: this is going away once we cleanup/separate the private/public libs
typedef HRESULT (STDAPICALLTYPE * PFNCOCREATE)(REFCLSID rclsid, LPUNKNOWN punkOuter, DWORD dwClsContext, REFIID riid, LPVOID *ppv);
BOOL TFInitLib_PrivateForCiceroOnly(PFNCOCREATE pfnCoCreate);


HMODULE GetSystemModuleHandle(LPCSTR lpModuleName);
HMODULE LoadSystemLibrary(LPCSTR lpModuleName);
HMODULE LoadSystemLibraryEx(LPCSTR lpModuleName, HANDLE hFile, DWORD dwFlags);
HMODULE GetSystemModuleHandleW(LPCWSTR lpModuleName);
HMODULE LoadSystemLibraryW(LPCWSTR lpModuleName);
HMODULE LoadSystemLibraryExW(LPCWSTR lpModuleName, HANDLE hFile, DWORD dwFlags);


#ifndef ARRAYSIZE
#define ARRAYSIZE(x)                (sizeof(x)/sizeof((x)[0]))
#endif

//+---------------------------------------------------------------------------
//
// CicSystemModulePath
//
//----------------------------------------------------------------------------

class CicSystemModulePath
{
public:
    CicSystemModulePath()
    {
        m_szPath[0] = '\0';
        m_uRet = 0;
    }

    UINT Init(LPCSTR lpModuleName, BOOL fWinDir = FALSE)
    {
        if (fWinDir)
            m_uRet = GetSystemWindowsDirectoryA(m_szPath, ARRAYSIZE(m_szPath));
        else
            m_uRet = GetSystemDirectoryA(m_szPath, ARRAYSIZE(m_szPath));

        if (m_uRet >= ARRAYSIZE(m_szPath))
        {
            m_uRet = 0;
            m_szPath[0] = '\0';
        }
        else if (m_uRet)
        {
            if (m_szPath[m_uRet - 1] != '\\')
            {
                m_szPath[m_uRet] = '\\';
                m_uRet++;
            }

            UINT uLength = lstrlenA(lpModuleName);
            if (ARRAYSIZE(m_szPath) - m_uRet > uLength)
            {
                lstrcpynA(&m_szPath[m_uRet], 
                         lpModuleName, 
                         ARRAYSIZE(m_szPath) - m_uRet);
                m_uRet += uLength;
            }
            else
            {
                m_uRet = 0;
                m_szPath[0] = '\0';
            }
        }
        return m_uRet;
    }

    LPSTR GetPath()
    {
        return m_szPath;
    }

    UINT GetLength()
    {
        return m_uRet;
    }

private:
    char m_szPath[MAX_PATH + 1];
    UINT m_uRet;
};

//+---------------------------------------------------------------------------
//
// CicSystemModulePathW
//
//----------------------------------------------------------------------------

class CicSystemModulePathW
{
public:
    CicSystemModulePathW()
    {
        m_szPath[0] = L'\0';
        m_uRet = 0;
    }

    UINT Init(LPCWSTR lpModuleName, BOOL fWinDir = FALSE)
    {
        if (fWinDir)
            m_uRet = GetSystemWindowsDirectoryW(m_szPath, ARRAYSIZE(m_szPath));
        else
            m_uRet = GetSystemDirectoryW(m_szPath, ARRAYSIZE(m_szPath));

        if (m_uRet >= ARRAYSIZE(m_szPath))
        {
            m_uRet = 0;
            m_szPath[0] = L'\0';
        }
        else if (m_uRet)
        {
            if (m_szPath[m_uRet - 1] != L'\\')
            {
                m_szPath[m_uRet] = L'\\';
                m_uRet++;
            }

            UINT uLength = lstrlenW(lpModuleName);
            if (ARRAYSIZE(m_szPath) - m_uRet > uLength)
            {
                wcsncpy(&m_szPath[m_uRet], 
                        lpModuleName, 
                        ARRAYSIZE(m_szPath) - m_uRet);
                m_uRet += uLength;
            }
            else
            {
                m_uRet = 0;
                m_szPath[0] = L'\0';
            }
        }
        return m_uRet;
    }

    LPWSTR GetPath()
    {
        return m_szPath;
    }

    UINT GetLength()
    {
        return m_uRet;
    }

private:
    WCHAR m_szPath[MAX_PATH + 1];
    UINT m_uRet;
};

#endif // TFMXUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\lbmenu.h ===
//
// lbmenu.h
//
// Generic ITfTextEventSink object
//

#ifndef LBMENU_H
#define LBMENU_H

#include "ctfutb.h"
#include "ptrary.h"

class CCicLibMenu;

//////////////////////////////////////////////////////////////////////////////
//
// CCicLibMenuItem
//
//////////////////////////////////////////////////////////////////////////////

class CCicLibMenuItem
{
public:
    CCicLibMenuItem() 
    {
        _uId = 0;
        _dwFlags = 0;
        _hbmp = NULL;
        _hbmpMask = NULL;
        _bstr = NULL;
        _pSubMenu = NULL;
    }
    
    ~CCicLibMenuItem();

    BOOL Init(UINT uId, DWORD dwFlags, HBITMAP hbmp, HBITMAP hbmpMask, const WCHAR *pch, ULONG cch, CCicLibMenu *pSubMenu);

    UINT GetId() {return _uId;}
    DWORD GetFlags() {return _dwFlags;}
    HBITMAP GetBitmap() {return _hbmp;}
    HBITMAP GetBitmapMask() {return _hbmpMask;}
    WCHAR *GetText() {return _bstr;}
    CCicLibMenu *GetSubMenu() {return _pSubMenu;}

    void ClearBitmaps()
    {
        _hbmp = NULL;
        _hbmpMask = NULL;
    }

private:
    static HBITMAP CreateBitmap(HBITMAP hbmp);

protected:
    UINT _uId;
    DWORD _dwFlags;
    HBITMAP _hbmp;
    HBITMAP _hbmpMask;
    BSTR _bstr;
    CCicLibMenu *_pSubMenu;
};


//////////////////////////////////////////////////////////////////////////////
//
// CCicLibMenu
//
//////////////////////////////////////////////////////////////////////////////

class CCicLibMenu :  public ITfMenu
{
public:
    CCicLibMenu();
    virtual ~CCicLibMenu();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfMenu
    //
    STDMETHODIMP AddMenuItem(UINT uId,
                             DWORD dwFlags,
                             HBITMAP hbmp,
                             HBITMAP hbmpMask,
                             const WCHAR *pch,
                             ULONG cch,
                             ITfMenu **ppMenu);

    virtual CCicLibMenu *CreateSubMenu()
    {
        return new CCicLibMenu;
    }

    virtual CCicLibMenuItem *CreateMenuItem()
    {
        return new CCicLibMenuItem;
    }

    UINT GetItemCount()
    {
        return _rgItem.Count();
    }

    CCicLibMenuItem *GetItem(UINT i)
    {
        return _rgItem.Get(i);
    }

protected:
    CPtrArray<CCicLibMenuItem> _rgItem;

    ULONG _cRef;
};

#endif LBMENU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\lpns.h ===
//
// lpns.h
//
// Generic ITfActiveInputProcessorNotifySink object
//

#ifndef LPAN_H
#define LPAN_H

#include "private.h"

#define LPNS_INVALID_COOKIE  ((DWORD)(-1))


typedef HRESULT (*LPNSCALLBACK)(BOOL fChanged, LANGID langid, BOOL *pfAccept, void *pv);

class CLanguageProfileNotifySink : public ITfLanguageProfileNotifySink
{
public:
    CLanguageProfileNotifySink(LPNSCALLBACK pfn, void *pv);

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfLanguageProfilesNotifySink
    //
    STDMETHODIMP OnLanguageChange(LANGID langid, BOOL *pfAccept);
    STDMETHODIMP OnLanguageChanged();

    HRESULT _Advise(ITfInputProcessorProfiles *pipp);
    HRESULT _Unadvise();

private:

    long _cRef;
    ITfInputProcessorProfiles *_pipp;
    DWORD _dwCookie;
    LPNSCALLBACK _pfn;
    void *_pv;
};

#endif // LPAN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\msime.h ===
/*----------------------------------------------------------------------------
    %%File: MSIME.H

    Copyright (c) 1995-1998  Microsoft Corporation
    Version 1.0

    Japanese specific definitions of IFECommon, IFELanguage, IFEDictionary,
    and Per IME Interfaces.
----------------------------------------------------------------------------*/

#ifndef __MSIME_H__
#define __MSIME_H__

#include <ole2.h>
#include <objbase.h>
#include <imm.h>

#pragma pack(1)         /* Assume byte packing throughout */

///////////////////////////
// HKEY_CLASSES_ROOT values
///////////////////////////

#define szImeJapan98        "MSIME.Japan.6"
#define szImeJapan          "MSIME.Japan"


////////////////
// CLSID and IID
////////////////

// Class ID for FE COM interfaces
// {019F7150-E6DB-11d0-83C3-00C04FDDB82E}
DEFINE_GUID(CLSID_MSIME_JAPANESE,
0x19f7150, 0xe6db, 0x11d0, 0x83, 0xc3, 0x0, 0xc0, 0x4f, 0xdd, 0xb8, 0x2e);

// Interface ID for IFECommon
// {019F7151-E6DB-11d0-83C3-00C04FDDB82E}
DEFINE_GUID(IID_IFECommon,
0x19f7151, 0xe6db, 0x11d0, 0x83, 0xc3, 0x0, 0xc0, 0x4f, 0xdd, 0xb8, 0x2e);

// Interface ID for IFELanguage
// {019F7152-E6DB-11d0-83C3-00C04FDDB82E}
DEFINE_GUID(IID_IFELanguage,
0x19f7152, 0xe6db, 0x11d0, 0x83, 0xc3, 0x0, 0xc0, 0x4f, 0xdd, 0xb8, 0x2e);

// Interface ID for IFELanguage2
// {21164102-C24A-11d1-851A-00C04FCC6B14}
DEFINE_GUID(IID_IFELanguage2,
0x21164102, 0xc24a, 0x11d1, 0x85, 0x1a, 0x0, 0xc0, 0x4f, 0xcc, 0x6b, 0x14);

// Interface ID for IFEDictionary
// {019F7153-E6DB-11d0-83C3-00C04FDDB82E}
DEFINE_GUID(IID_IFEDictionary,
0x19f7153, 0xe6db, 0x11d0, 0x83, 0xc3, 0x0, 0xc0, 0x4f, 0xdd, 0xb8, 0x2e);


////////////////////////////
// Definitions for IFECommon
////////////////////////////

#undef  INTERFACE
#define INTERFACE   IFEClassFactory

////////////////////////////////
// The IFEClassFactory Interface
////////////////////////////////

DECLARE_INTERFACE_(IFEClassFactory, IClassFactory)
{
    // IUnknown members
    STDMETHOD(QueryInterface)   (THIS_ REFIID refiid, VOID **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // IFEClassFactory members
    STDMETHOD(CreateInstance)   (THIS_ LPUNKNOWN, REFIID, void **) PURE;
    STDMETHOD(LockServer)       (THIS_ BOOL) PURE;
};


#undef  INTERFACE
#define INTERFACE   IFECommon

//////////////////////////
// The IFECommon Interface
//////////////////////////

#define IFEC_S_ALREADY_DEFAULT          MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x7400)

typedef struct _IMEDLG
{
    int         cbIMEDLG;               //size of this structure
    HWND        hwnd;                   //parent window handle
    LPWSTR      lpwstrWord;             //optional string
    int         nTabId;                 //specifies a tab in dialog
} IMEDLG;

DECLARE_INTERFACE_(IFECommon, IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface)   (THIS_ REFIID refiid, VOID **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // IFECommon members
    STDMETHOD(IsDefaultIME) (THIS_
                            CHAR *szName,               //(out) name of MS-IME
                            INT cszName                 //(in) size of szName
                            ) PURE;
    STDMETHOD(SetDefaultIME)    (THIS) PURE;
    STDMETHOD(InvokeWordRegDialog) (THIS_
                            IMEDLG *pimedlg             //(in) parameters
                            ) PURE;
    STDMETHOD(InvokeDictToolDialog) (THIS_
                            IMEDLG *pimedlg             //(in) parameters
                            ) PURE;
};


///////////////////////////
// The IFELanguage interface
///////////////////////////

// Word Descriptor
typedef struct tagWDD{
    WORD        wDispPos;   // Offset of Output string
    union {
        WORD    wReadPos;   // Offset of Reading string
        WORD    wCompPos;
    };

    WORD        cchDisp;    //number of ptchDisp
    union {
        WORD    cchRead;    //number of ptchRead
        WORD    cchComp;
    };

    DWORD       nReserve;   //reserved

    WORD        nPos;       //part of speech

                            // implementation-defined
    WORD        fPhrase : 1;//start of phrase
    WORD        fAutoCorrect: 1;//auto-corrected
    WORD        fNumericPrefix: 1;//kansu-shi expansion(JPN)
    WORD        fUserRegistered: 1;//from user dictionary
    WORD        fUnknown: 1;//unknown word (duplicated information with nPos.)
    WORD        fRecentUsed: 1; //used recently flag
    WORD        :10;        //

    VOID        *pReserved; //points directly to WORDITEM
} WDD;

#pragma warning(disable:4200) // zero-size array in structure
typedef struct tagMORRSLT {
    DWORD       dwSize;             // total size of this block.
    WCHAR       *pwchOutput;        // conversion result string.
    WORD        cchOutput;          // lengh of result string.
    union {
        WCHAR   *pwchRead;          // reading string
        WCHAR   *pwchComp;
    };
    union {
        WORD    cchRead;            // length of reading string.
        WORD    cchComp;
    };
    WORD        *pchInputPos;       // index array of reading to input character.
    WORD        *pchOutputIdxWDD;   // index array of output character to WDD
    union {
        WORD    *pchReadIdxWDD;     // index array of reading character to WDD
        WORD    *pchCompIdxWDD;
    };
    WORD        *paMonoRubyPos;     // array of position of monoruby
    WDD         *pWDD;              // pointer to array of WDD
    INT         cWDD;               // number of WDD
    VOID        *pPrivate;          // pointer of private data area
    WCHAR       BLKBuff[];          // area for stored above members.
                                    //  WCHAR   wchOutput[cchOutput];
                                    //  WCHAR   wchRead[cchRead];
                                    //  CHAR    chInputIdx[cwchInput];
                                    //  CHAR    chOutputIdx[cchOutput];
                                    //  CHAR    chReadIndx[cchRead];
                                    //  ????    Private
                                    //  WDD     WDDBlk[cWDD];
}MORRSLT;
#pragma warning(default:4200) // zero-size array in structure

// request for conversion (dwRequest)
#define FELANG_REQ_CONV         0x00010000
#define FELANG_REQ_RECONV       0x00020000
#define FELANG_REQ_REV          0x00030000


// Conversion mode (dwCMode)
#define FELANG_CMODE_MONORUBY       0x00000002  //mono-ruby
#define FELANG_CMODE_NOPRUNING      0x00000004  //no pruning
#define FELANG_CMODE_KATAKANAOUT    0x00000008  //katakana output
#define FELANG_CMODE_HIRAGANAOUT    0x00000000  //default output
#define FELANG_CMODE_HALFWIDTHOUT   0x00000010  //half-width output
#define FELANG_CMODE_FULLWIDTHOUT   0x00000020  //full-width output
#define FELANG_CMODE_BOPOMOFO       0x00000040  //
#define FELANG_CMODE_HANGUL         0x00000080  //
#define FELANG_CMODE_PINYIN         0x00000100  //
#define FELANG_CMODE_PRECONV        0x00000200  //do conversion as follows:
                                                // - roma-ji to kana
                                                // - autocorrect before conversion
                                                // - periods, comma, and brackets
#define FELANG_CMODE_RADICAL        0x00000400  //
#define FELANG_CMODE_UNKNOWNREADING 0x00000800  //
#define FELANG_CMODE_MERGECAND      0x00001000  // merge display with same candidate
#define FELANG_CMODE_ROMAN          0x00002000  //
#define FELANG_CMODE_BESTFIRST      0x00004000  // only make 1st best
#define FELANG_CMODE_USENOREVWORDS  0x00008000  // use invalid revword on REV/RECONV.

#define FELANG_CMODE_NONE           0x01000000  // IME_SMODE_NONE
#define FELANG_CMODE_PLAURALCLAUSE  0x02000000  // IME_SMODE_PLAURALCLAUSE
#define FELANG_CMODE_SINGLECONVERT  0x04000000  // IME_SMODE_SINGLECONVERT
#define FELANG_CMODE_AUTOMATIC      0x08000000  // IME_SMODE_AUTOMATIC
#define FELANG_CMODE_PHRASEPREDICT  0x10000000  // IME_SMODE_PHRASEPREDICT
#define FELANG_CMODE_CONVERSATION   0x20000000  // IME_SMODE_CONVERSATION
#define FELANG_CMODE_NAME           FELANG_CMODE_PHRASEPREDICT  // Name mode (MSKKIME)
#define FELANG_CMODE_NOINVISIBLECHAR 0x40000000 // remove invisible chars (e.g. tone mark)


// Error message
#define E_NOCAND            0x30    //not enough candidates
#define E_NOTENOUGH_BUFFER  0x31    //out of string buffer
#define E_NOTENOUGH_WDD     0x32    //out of WDD buffer
#define E_LARGEINPUT        0x33    //large input string


//Morphology Info
#define FELANG_CLMN_WBREAK      0x01
#define FELANG_CLMN_NOWBREAK    0x02
#define FELANG_CLMN_PBREAK      0x04
#define FELANG_CLMN_NOPBREAK    0x08
#define FELANG_CLMN_FIXR        0x10
#define FELANG_CLMN_FIXD        0x20    // fix display of word

#define FELANG_INVALD_PO        0xFFFF  // unmatched position for input string

#undef INTERFACE
#define INTERFACE       IFELanguage

//IFELanguage template
DECLARE_INTERFACE_(IFELanguage,IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID refiid, VOID **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // Ijconv members.  must be virtual functions
    STDMETHOD(Open)(THIS) PURE;
    STDMETHOD(Close)(THIS) PURE;

    STDMETHOD(GetJMorphResult)(THIS_
                        DWORD   dwRequest,          // [in]
                        DWORD   dwCMode,            // [in]
                        INT     cwchInput,          // [in]
                        WCHAR   *pwchInput,         // [in, size_is(cwchInput)]
                        DWORD   *pfCInfo,           // [in, size_is(cwchInput)]
                        MORRSLT **ppResult ) PURE;  // [out]

    STDMETHOD(GetConversionModeCaps)(THIS_ DWORD *pdwCaps) PURE;

    STDMETHOD(GetPhonetic)(THIS_
                        BSTR    string,             // [in]
                        LONG    start,              // [in]
                        LONG    length,             // [in]
                        BSTR *  phonetic ) PURE;    // [out, retval]

    STDMETHOD(GetConversion)(THIS_
                        BSTR    string,             // [in]
                        LONG    start,              // [in]
                        LONG    length,             // [in]
                        BSTR *  result ) PURE;      // [out, retval]
};


////////////////////////////////
// Definitions for IFEDictionary
////////////////////////////////

// Part Of Speach
#define IFED_POS_NONE                   0x00000000
#define IFED_POS_NOUN                   0x00000001
#define IFED_POS_VERB                   0x00000002
#define IFED_POS_ADJECTIVE              0x00000004
#define IFED_POS_ADJECTIVE_VERB         0x00000008
#define IFED_POS_ADVERB                 0x00000010
#define IFED_POS_ADNOUN                 0x00000020
#define IFED_POS_CONJUNCTION            0x00000040
#define IFED_POS_INTERJECTION           0x00000080
#define IFED_POS_INDEPENDENT            0x000000ff
#define IFED_POS_INFLECTIONALSUFFIX     0x00000100
#define IFED_POS_PREFIX                 0x00000200
#define IFED_POS_SUFFIX                 0x00000400
#define IFED_POS_AFFIX                  0x00000600
#define IFED_POS_TANKANJI               0x00000800
#define IFED_POS_IDIOMS                 0x00001000
#define IFED_POS_SYMBOLS                0x00002000
#define IFED_POS_PARTICLE               0x00004000
#define IFED_POS_AUXILIARY_VERB         0x00008000
#define IFED_POS_SUB_VERB               0x00010000
#define IFED_POS_DEPENDENT              0x0001c000
#define IFED_POS_ALL                    0x0001ffff

// GetWord Selection Type
#define IFED_SELECT_NONE                0x00000000
#define IFED_SELECT_READING             0x00000001
#define IFED_SELECT_DISPLAY             0x00000002
#define IFED_SELECT_POS                 0x00000004
#define IFED_SELECT_COMMENT             0x00000008
#define IFED_SELECT_ALL                 0x0000000f

// Registered Word Type
#define IFED_REG_NONE                   0x00000000
#define IFED_REG_USER                   0x00000001
#define IFED_REG_AUTO                   0x00000002
#define IFED_REG_GRAMMAR                0x00000004
#define IFED_REG_ALL                    0x00000007

// Dictionary Type
#define IFED_TYPE_NONE                  0x00000000
#define IFED_TYPE_GENERAL               0x00000001
#define IFED_TYPE_NAMEPLACE             0x00000002
#define IFED_TYPE_SPEECH                0x00000004
#define IFED_TYPE_REVERSE               0x00000008
#define IFED_TYPE_ENGLISH               0x00000010
#define IFED_TYPE_ALL                   0x0000001f

// HRESULTS for IFEDictionary interface

//no more entries in the dictionary
#define IFED_S_MORE_ENTRIES             MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x7200)
//dictionary is empty, no header information is returned
#define IFED_S_EMPTY_DICTIONARY         MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x7201)
//word already exists in dictionary
#define IFED_S_WORD_EXISTS              MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x7202)

//dictionary is not found
#define IFED_E_NOT_FOUND                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x7300)
//invalid dictionary format
#define IFED_E_INVALID_FORMAT           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x7301)
//failed to open file
#define IFED_E_OPEN_FAILED              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x7302)
//failed to write to file
#define IFED_E_WRITE_FAILED             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x7303)
//no entry found in dictionary
#define IFED_E_NO_ENTRY                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x7304)
//this routines doesn't support the current dictionary
#define IFED_E_REGISTER_FAILED          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x7305)
//not a user dictionary
#define IFED_E_NOT_USER_DIC             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x7306)
//not supported
#define IFED_E_NOT_SUPPORTED            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x7307)
//failed to insert user comment
#define IFED_E_USER_COMMENT             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x7308)

#define cbCommentMax            256

//Private Unicode Character
#define wchPrivate1             0xE000

// Where to place registring word
typedef enum
{
    IFED_REG_HEAD,
    IFED_REG_TAIL,
    IFED_REG_DEL,
} IMEREG;


// Type of IME dictionary
typedef enum
{
    IFED_UNKNOWN,
    IFED_MSIME2_BIN_SYSTEM,
    IFED_MSIME2_BIN_USER,
    IFED_MSIME2_TEXT_USER,
    IFED_MSIME95_BIN_SYSTEM,
    IFED_MSIME95_BIN_USER,
    IFED_MSIME95_TEXT_USER,
    IFED_MSIME97_BIN_SYSTEM,
    IFED_MSIME97_BIN_USER,
    IFED_MSIME97_TEXT_USER,
    IFED_MSIME_BIN_SYSTEM,
    IFED_MSIME_BIN_USER,
    IFED_MSIME_TEXT_USER,
    IFED_ACTIVE_DICT,
    IFED_ATOK9,
    IFED_ATOK10,
    IFED_NEC_AI_,
    IFED_WX_II,
    IFED_WX_III,
    IFED_VJE_20,
} IMEFMT;

// Type of User Comment
typedef enum
{
    IFED_UCT_NONE,
    IFED_UCT_STRING_SJIS,
    IFED_UCT_STRING_UNICODE,
    IFED_UCT_USER_DEFINED,
    IFED_UCT_MAX,
} IMEUCT;


#if _MSC_VER >= 1200
#pragma warning(push)
#pragma warning(disable:4201)
#endif

// WoRD found in a dictionary
typedef struct _IMEWRD
{
    WCHAR       *pwchReading;
    WCHAR       *pwchDisplay;
    union {
        ULONG ulPos;
        struct {
            WORD        nPos1;      //hinshi
            WORD        nPos2;      //extended hinshi
        } ;
    };
    ULONG       rgulAttrs[2];       //attributes
    INT         cbComment;          //size of user comment
    IMEUCT      uct;                //type of user comment
    VOID        *pvComment;         //user comment
} IMEWRD, *PIMEWRD;

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

// Shared Header dictionary File
typedef struct _IMESHF
{
    WORD        cbShf;              //size of this struct
    WORD        verDic;             //dictionary version
    CHAR        szTitle[48];        //dictionary title
    CHAR        szDescription[256]; //dictionary description
    CHAR        szCopyright[128];   //dictionary copyright info
} IMESHF;


#define POS_UNDEFINED      0
#define JPOS_UNDEFINED      POS_UNDEFINED
#define JPOS_MEISHI_FUTSU       100     //
#define JPOS_MEISHI_SAHEN       101     //
#define JPOS_MEISHI_ZAHEN       102     //
#define JPOS_MEISHI_KEIYOUDOUSHI        103     //`
#define JPOS_HUKUSIMEISHI       104     //I
#define JPOS_MEISA_KEIDOU       105     //`
#define JPOS_JINMEI     106     //l
#define JPOS_JINMEI_SEI     107     //
#define JPOS_JINMEI_MEI     108     //
#define JPOS_CHIMEI     109     //n
#define JPOS_CHIMEI_KUNI        110     //
#define JPOS_CHIMEI_KEN     111     //
#define JPOS_CHIMEI_GUN     112     //S
#define JPOS_CHIMEI_KU      113     //
#define JPOS_CHIMEI_SHI     114     //s
#define JPOS_CHIMEI_MACHI       115     //
#define JPOS_CHIMEI_MURA        116     //
#define JPOS_CHIMEI_EKI     117     //w
#define JPOS_SONOTA     118     //L
#define JPOS_SHAMEI     119     //
#define JPOS_SOSHIKI        120     //gD
#define JPOS_KENCHIKU       121     //z
#define JPOS_BUPPIN     122     //i
#define JPOS_DAIMEISHI      123     //
#define JPOS_DAIMEISHI_NINSHOU      124     //l
#define JPOS_DAIMEISHI_SHIJI        125     //w
#define JPOS_KAZU       126     //
#define JPOS_KAZU_SURYOU        127     //
#define JPOS_KAZU_SUSHI     128     //
#define JPOS_5DAN_AWA       200     //s
#define JPOS_5DAN_KA        201     //s
#define JPOS_5DAN_GA        202     //s
#define JPOS_5DAN_SA        203     //s
#define JPOS_5DAN_TA        204     //s
#define JPOS_5DAN_NA        205     //s
#define JPOS_5DAN_BA        206     //s
#define JPOS_5DAN_MA        207     //s
#define JPOS_5DAN_RA        208     //s
#define JPOS_5DAN_AWAUON        209     //s
#define JPOS_5DAN_KASOKUON      210     //s
#define JPOS_5DAN_RAHEN     211     //si
#define JPOS_4DAN_HA        212     //sli
#define JPOS_1DAN       213     //i
#define JPOS_TOKUSHU_KAHEN      214     //
#define JPOS_TOKUSHU_SAHENSURU      215     //
#define JPOS_TOKUSHU_SAHEN      216     //si
#define JPOS_TOKUSHU_ZAHEN      217     //si
#define JPOS_TOKUSHU_NAHEN      218     //si
#define JPOS_KURU_KI        219     //
#define JPOS_KURU_KITA      220     //
#define JPOS_KURU_KITARA        221     //
#define JPOS_KURU_KITARI        222     //
#define JPOS_KURU_KITAROU       223     //
#define JPOS_KURU_KITE      224     //
#define JPOS_KURU_KUREBA        225     //
#define JPOS_KURU_KO        226     //ij
#define JPOS_KURU_KOI       227     //
#define JPOS_KURU_KOYOU     228     //
#define JPOS_SURU_SA        229     //
#define JPOS_SURU_SI        230     //
#define JPOS_SURU_SITA      231     //
#define JPOS_SURU_SITARA        232     //
#define JPOS_SURU_SIATRI        233     //
#define JPOS_SURU_SITAROU       234     //
#define JPOS_SURU_SITE      235     //
#define JPOS_SURU_SIYOU     236     //
#define JPOS_SURU_SUREBA        237     //
#define JPOS_SURU_SE        238     //
#define JPOS_SURU_SEYO      239     //^
#define JPOS_KEIYOU     300     //`e
#define JPOS_KEIYOU_GARU        301     //`e
#define JPOS_KEIYOU_GE      302     //`e
#define JPOS_KEIYOU_ME      303     //`e
#define JPOS_KEIYOU_YUU     304     //`e
#define JPOS_KEIYOU_U       305     //`e
#define JPOS_KEIDOU     400     //`e
#define JPOS_KEIDOU_NO      401     //`e
#define JPOS_KEIDOU_TARU        402     //`e
#define JPOS_KEIDOU_GARU        403     //`e
#define JPOS_FUKUSHI        500     //
#define JPOS_FUKUSHI_SAHEN      501     //
#define JPOS_FUKUSHI_NI     502     //
#define JPOS_FUKUSHI_NANO       503     //
#define JPOS_FUKUSHI_DA     504     //
#define JPOS_FUKUSHI_TO     505     //
#define JPOS_FUKUSHI_TOSURU     506     //
#define JPOS_RENTAISHI      600     //A
#define JPOS_RENTAISHI_SHIJI        601     //wA
#define JPOS_SETSUZOKUSHI       650     //
#define JPOS_KANDOUSHI      670     //
#define JPOS_SETTOU     700     //
#define JPOS_SETTOU_KAKU        701     //P
#define JPOS_SETTOU_SAI     702     //Q
#define JPOS_SETTOU_FUKU        703     //R
#define JPOS_SETTOU_MI      704     //S
#define JPOS_SETTOU_DAISHOU     705     //T
#define JPOS_SETTOU_KOUTEI      706     //U
#define JPOS_SETTOU_CHOUTAN     707     //V
#define JPOS_SETTOU_SHINKYU     708     //W
#define JPOS_SETTOU_JINMEI      709     //l
#define JPOS_SETTOU_CHIMEI      710     //n
#define JPOS_SETTOU_SONOTA      711     //L
#define JPOS_SETTOU_JOSUSHI     712     //Ou
#define JPOS_SETTOU_TEINEI_O        713     //JP
#define JPOS_SETTOU_TEINEI_GO       714     //JQ
#define JPOS_SETTOU_TEINEI_ON       715     //JR
#define JPOS_SETSUBI        800     //
#define JPOS_SETSUBI_TEKI       801     //P
#define JPOS_SETSUBI_SEI        802     //Q
#define JPOS_SETSUBI_KA     803     //R
#define JPOS_SETSUBI_CHU        804     //S
#define JPOS_SETSUBI_FU     805     //T
#define JPOS_SETSUBI_RYU        806     //U
#define JPOS_SETSUBI_YOU        807     //V
#define JPOS_SETSUBI_KATA       808     //W
#define JPOS_SETSUBI_MEISHIRENDAKU      809     //A
#define JPOS_SETSUBI_JINMEI     810     //l
#define JPOS_SETSUBI_CHIMEI     811     //n
#define JPOS_SETSUBI_KUNI       812     //
#define JPOS_SETSUBI_KEN        813     //
#define JPOS_SETSUBI_GUN        814     //S
#define JPOS_SETSUBI_KU     815     //
#define JPOS_SETSUBI_SHI        816     //s
#define JPOS_SETSUBI_MACHI      817     //P
#define JPOS_SETSUBI_CHOU       818     //Q
#define JPOS_SETSUBI_MURA       819     //P
#define JPOS_SETSUBI_SON        820     //Q
#define JPOS_SETSUBI_EKI        821     //w
#define JPOS_SETSUBI_SONOTA     822     //L
#define JPOS_SETSUBI_SHAMEI     823     //
#define JPOS_SETSUBI_SOSHIKI        824     //gD
#define JPOS_SETSUBI_KENCHIKU       825     //z
#define JPOS_RENYOU_SETSUBI     826     //Ap
#define JPOS_SETSUBI_JOSUSHI        827     //u
#define JPOS_SETSUBI_JOSUSHIPLUS        828     //u{
#define JPOS_SETSUBI_JIKAN      829     //
#define JPOS_SETSUBI_JIKANPLUS      830     //{
#define JPOS_SETSUBI_TEINEI     831     //J
#define JPOS_SETSUBI_SAN        832     //JP
#define JPOS_SETSUBI_KUN        833     //JQ
#define JPOS_SETSUBI_SAMA       834     //JR
#define JPOS_SETSUBI_DONO       835     //JS
#define JPOS_SETSUBI_FUKUSU     836     //
#define JPOS_SETSUBI_TACHI      837     //P
#define JPOS_SETSUBI_RA     838     //Q
#define JPOS_TANKANJI       900     //P
#define JPOS_TANKANJI_KAO       901     //
#define JPOS_KANYOUKU       902     //p
#define JPOS_DOKURITSUGO        903     //
#define JPOS_FUTEIGO        904     //s
#define JPOS_KIGOU      905     //L
#define JPOS_EIJI       906     //p
#define JPOS_KUTEN      907     //_
#define JPOS_TOUTEN     908     //_
#define JPOS_KANJI      909     //s\
#define JPOS_OPENBRACE      910     //J
#define JPOS_CLOSEBRACE     911     //


//POS table data structure
typedef struct _POSTBL
{
    WORD        nPos;                   //pos number
    BYTE        *szName;                //name of pos
} POSTBL;


//////////////////////////////
// The IFEDictionary interface
//////////////////////////////

#undef  INTERFACE
#define INTERFACE   IFEDictionary

DECLARE_INTERFACE_(IFEDictionary, IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID refiid, VOID **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IFEDictionary members
    STDMETHOD(Open)         (THIS_
                            CHAR *pchDictPath,          //(in) dictionary path
                            IMESHF *pshf                //(out) dictionary header
                            ) PURE;
    STDMETHOD(Close)        (THIS) PURE;
    STDMETHOD(GetHeader)    (THIS_
                            CHAR *pchDictPath,          //(in) dictionary path
                            IMESHF *pshf,               //(out) dictionary header
                            IMEFMT *pjfmt,              //(out) dictionary format
                            ULONG *pulType              //(out) dictionary type
                            ) PURE;
    STDMETHOD(Reserve1)     (THIS) PURE;
    STDMETHOD(GetPosTable)  (THIS_
                            POSTBL **prgPosTbl,         //(out) pos table pointer
                            int *pcPosTbl               //(out) pos table count pointer
                            ) PURE;
    STDMETHOD(GetWords)     (THIS_
                            WCHAR *pwchFirst,           //(in) starting range of reading
                            WCHAR *pwchLast,            //(in) ending range of reading
                            WCHAR *pwchDisplay,         //(in) display
                            ULONG ulPos,                //(in) part of speech (IFED_POS_...)
                            ULONG ulSelect,             //(in) output selection
                            ULONG ulWordSrc,            //(in) user or auto registered word?
                            UCHAR *pchBuffer,           //(in/out) buffer for storing array of IMEWRD
                            ULONG cbBuffer,             //(in) size of buffer in bytes
                            ULONG *pcWrd                //(out) count of IMEWRD's returned
                            ) PURE;
    STDMETHOD(NextWords)    (THIS_
                            UCHAR *pchBuffer,           //(in/out) buffer for storing array of IMEWRD
                            ULONG cbBuffer,             //(in) size of buffer in bytes
                            ULONG *pcWrd                //(out) count of IMEWRD's returned
                            ) PURE;
    STDMETHOD(Create)       (THIS_
                            CHAR *pchDictPath,          //(in) path for the new dictionary
                            IMESHF *pshf                //(in) dictionary header
                            ) PURE;
    STDMETHOD(SetHeader)    (THIS_
                            IMESHF *pshf                //(in) dictionary header
                            ) PURE;
    STDMETHOD(ExistWord)    (THIS_
                            IMEWRD *pwrd                //(in) word to check
                            ) PURE;
    STDMETHOD(Reserve2)     (THIS) PURE;
    STDMETHOD(RegisterWord) (THIS_
                            IMEREG reg,                 //(in) type of operation to perform on IMEWRD
                            IMEWRD *pwrd                //(in) word to be registered or deleted
                            ) PURE;
};


///////////////////////////////////
// Definitions for PerIME Interface
///////////////////////////////////

/***********************************************************************
    IME Version IDs
 ***********************************************************************/
#define VERSION_ID_JAPANESE                 0x01000000
#define VERSION_ID_KOREAN                   0x02000000
#define VERSION_ID_CHINESE_TRADITIONAL      0x04000000
#define VERSION_ID_CHINESE_SIMPLIFIED       0x08000000

#define VERSION_ID_IMEJP98  (VERSION_ID_JAPANESE | 0x980)
#define VERSION_ID_IMEJP2000 (VERSION_ID_JAPANESE | 0x98a)

/***********************************************************************
    Msg:    WM_MSIME_SERVICE
    Desc:   service functions
    Dir:    Apps to IME
    wParam: reserved
    lParam: reserved
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_SERVICE     TEXT("MSIMEService")

//getting version number (wParam)
#define FID_MSIME_VERSION       0

/***********************************************************************
    Msg:    WM_MSIME_UIREADY
    Desc:   service functions
    Dir:    IME to Apps
    wParam: Version ID
    lParam: reserved
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_UIREADY     TEXT("MSIMEUIReady")



/***********************************************************************
    Msg:    WM_MSIME_MOUSE
    Desc:   mouse operation definition
    Dir:    Apps to IME
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_MOUSE       TEXT("MSIMEMouseOperation")

// Mouse Operation Version (return value of IMEMOUSE_VERSION)
#define VERSION_MOUSE_OPERATION     1

// Mouse operation result
#define IMEMOUSERET_NOTHANDLED      (-1)

//WParam definition for WM_IME_MOUSE.
#define IMEMOUSE_VERSION    0xff    // mouse supported?

#define IMEMOUSE_NONE       0x00    // no mouse button was pushed
#define IMEMOUSE_LDOWN      0x01
#define IMEMOUSE_RDOWN      0x02
#define IMEMOUSE_MDOWN      0x04
#define IMEMOUSE_WUP        0x10    // wheel up
#define IMEMOUSE_WDOWN      0x20    // wheel down


/***********************************************************************
    Msg:    WM_MSIME_RECONVERT
    Desc:   reconversion
    Dir:    IME to Apps
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_RECONVERT           TEXT("MSIMEReconvert")


/***********************************************************************
    Msg:    WM_MSIME_RECONVERTREQUEST
    Desc:   reconversion
    Dir:    Apps to IME
 ***********************************************************************/

// wParam of WM_MSIME_RECONVERTREQUEST
#define FID_RECONVERT_VERSION   0x10000000

// Private reconversion Version
#define VERSION_RECONVERSION        1

// Label for RegisterWindowMessage
#define RWM_RECONVERTREQUEST    TEXT("MSIMEReconvertRequest")


/***********************************************************************
    Msg:    WM_MSIME_DOCUMENTFEED
    Desc:   Document feeding
    Dir:    IME to Apps
    Usage:  SendMessage( hwndApp, WM_MSIME_DOCUMENTFEED, VERSION_DOCUMENTFEED,
                (RECONVERTSTRING*)pReconv );
    wParam: VERSION_DOCUMENTFEED
    lParam: Pointer of RECONVERTSTRING structure
    return: size of RECONVERTSTRING structure
 ***********************************************************************/

// wParam of WM_MSIME_DOCUMENTFEED (set current docfeed version)
#define VERSION_DOCUMENTFEED        1

// lParam is pointer of RECONVERTSTRING structure

// Label for RegisterWindowMessage
#define RWM_DOCUMENTFEED    TEXT("MSIMEDocumentFeed")

/***********************************************************************
    Msg:    WM_MSIME_QUERYPOSITION
    Desc:   composition UI
    Dir:    IME to Apps
    Usage:  SendMessage( hwndApp, WM_MSIME_QUERYPOSITION, VERSION_QUERYPOSITION, (IMEPOSITION*)pPs );
    wParam: reserved. must be 0.
    lParam: pointer of IMEPOSITION structure
    return: Non-zero = success. Zero = error.
 ***********************************************************************/

// wParam of WM_MSIME_QUERYPOSITION
#define VERSION_QUERYPOSITION       1

// Label for RegisterWindowMessage
#define RWM_QUERYPOSITION   TEXT("MSIMEQueryPosition")


/***********************************************************************
    Msg:    WM_MSIME_MODEBIAS
    Desc:   input mode bias
    Dir:    Apps to IME
    Usage:  SendMessage( hwndDefUI, WM_MSIME_MODEBIAS, MODEBIAS_xxxx, MODEBIASMODE_xxxx );
    wParam: operation of bias
    lParam: bias mode
    return: If wParam is MODEBIAS_GETVERSION,returns version number of interface.
            If wParam is MODEBIAS_SETVALUE : return non-zero value if succeeded. Returns 0 if fail.
            If wParam is MODEBIAS_GETVALUE : returns current bias mode.
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_MODEBIAS            TEXT("MSIMEModeBias")

// Current version
#define VERSION_MODEBIAS        1

// Set or Get (wParam)
#define MODEBIAS_GETVERSION     0
#define MODEBIAS_SETVALUE       1
#define MODEBIAS_GETVALUE       2

// Bias (lParam)
#define MODEBIASMODE_DEFAULT                0x00000000  // reset all of bias setting
#define MODEBIASMODE_FILENAME               0x00000001  // filename


/***********************************************************************
    Msg:    WM_MSIME_SHOWIMEPAD
    Desc:   show ImePad
    Usage: SendMessage( hwndDefUI, WM_MSIME_SHOWIMEPAD, wParam, lParam );
    wParam: Applet selection option
    lParam: Applet selection parameter
            (Category defined in imepad.h or a pointer to GUID for Applet)
    return: Non-zero = accepted. Zero = not accepted.
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_SHOWIMEPAD          TEXT("MSIMEShowImePad")

// Applet selection option
#define SHOWIMEPAD_DEFAULT                  0x00000000  // default applet
#define SHOWIMEPAD_CATEGORY                 0x00000001  // selection by applet category
#define SHOWIMEPAD_GUID                     0x00000002  // selection by applet GUID


/***********************************************************************
    Msg:    WM_MSIME_KEYMAP
    Desc:   key map sharing with apps
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_KEYMAP              TEXT("MSIMEKeyMap")
#define RWM_CHGKEYMAP           TEXT("MSIMEChangeKeyMap")
#define RWM_NTFYKEYMAP          TEXT("MSIMENotifyKeyMap")

#define FID_MSIME_KMS_VERSION       1
#define FID_MSIME_KMS_INIT          2
#define FID_MSIME_KMS_TERM          3
#define FID_MSIME_KMS_DEL_KEYLIST   4
#define FID_MSIME_KMS_NOTIFY        5
#define FID_MSIME_KMS_GETMAP        6
#define FID_MSIME_KMS_INVOKE        7
#define FID_MSIME_KMS_SETMAP        8

#define IMEKMS_NOCOMPOSITION        0
#define IMEKMS_COMPOSITION          1
#define IMEKMS_SELECTION            2
#define IMEKMS_IMEOFF               3
#define IMEKMS_2NDLEVEL             4   // Reserved
#define IMEKMS_INPTGL               5   // Reserved
#define IMEKMS_CANDIDATE            6   // Reserved

typedef struct tagIMEKMSINIT {
    INT         cbSize;
    HWND        hWnd;   // Window which receives notification from IME.
                        // If hWnd is NULL, no notification is posted
                        // to Input context.
} IMEKMSINIT;

typedef struct tagIMEKMSKEY {
    DWORD dwStatus;     //Shift-Control combination status.
                        //Any combination of constants below
                        //(defined in IMM.H)
                        // 0x0000 (default)
                        // MOD_CONTROL     0x0002
                        // MOD_SHIFT       0x0004
                        // Alt key and Win key is not processed by IME.

    DWORD dwCompStatus; //Composition string status
                        //One of the constants below
                        // IMEKMS_NOCOMPOSITION  No composition string
                        // IMEKMS_COMPOSITION    Some composition string
                        // IMEKMS_SELECTION      Selection exists in apps
                        // IMEKMS_IMEOFF         IME Off state


    DWORD dwVKEY;       // VKEY code defined in IMM.H
    union {
        DWORD dwControl;// IME Functionality ID
        DWORD dwNotUsed;
    };
    union {
        WCHAR pwszDscr[31];// The pointer to string of description of this functionalify
        WCHAR pwszNoUse[31];
    };
} IMEKMSKEY;

typedef struct tagIMEKMS {
    INT         cbSize;
    HIMC        hIMC;
    DWORD       cKeyList;
    IMEKMSKEY   *pKeyList;
} IMEKMS;

typedef struct tagIMEKMSNTFY {
    INT         cbSize;
    HIMC        hIMC;
    BOOL        fSelect;
} IMEKMSNTFY;

typedef struct tagIMEKMSKMP {
    INT         cbSize;         //[in] size of this structure
    HIMC        hIMC;           //[in] Input context
    LANGID      idLang;         //[in] Language ID
    WORD        wVKStart;       //[in] VKEY start
    WORD        wVKEnd;         //[in] VKEY end
    INT         cKeyList;       //[out] number of IMEKMSKEY
    IMEKMSKEY   *pKeyList;      //[out] retrieve buffer of IMEKMSKEY
                                //      Must be GlobalMemFree by clients
} IMEKMSKMP;

typedef struct tagIMEKMSINVK {
    INT         cbSize;
    HIMC        hIMC;
    DWORD       dwControl;
} IMEKMSINVK;


/***********************************************************************
    Msg:    WM_MSIME_RECONVERTOPTIONS
    Desc:   Set reconversion options
    Usage: SendMessage( hwndDefUI, WM_MSIME_RECONVERTOPTIONS, dwOpt, (LPARAM)(HIMC)hIMC );
    wParam: options
    lParam: Input context handle
    return: Non-zero = accepted. Zero = not accepted.
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_RECONVERTOPTIONS          TEXT("MSIMEReconvertOptions")

//WParam definition for WM_IME_RECONVERTOPTIONS.
#define RECONVOPT_NONE              0x00000000  // default
#define RECONVOPT_USECANCELNOTIFY   0x00000001  // cancel notify

// parameter of ImmGetCompositionString
#define GCSEX_CANCELRECONVERT       0x10000000

#pragma pack()


#ifdef __cplusplus
extern "C" {
#endif

// The following API replaces CoCreateInstance(), when CLSID is not used.
HRESULT WINAPI CreateIFECommonInstance(VOID **ppvObj);
typedef HRESULT (WINAPI *fpCreateIFECommonInstanceType)(VOID **ppvObj);

// The IFELanguage global export function
HRESULT WINAPI CreateIFELanguageInstance(REFCLSID clsid, VOID **ppvObj);
typedef HRESULT (WINAPI *fpCreateIFELanguageInstanceType)(REFCLSID clsid, VOID **ppvObj);

// The following API replaces CoCreateInstance(), when CLSID is not used.
HRESULT WINAPI CreateIFEDictionaryInstance(VOID **ppvObj);
typedef HRESULT (WINAPI *fpCreateIFEDictionaryInstanceType)(VOID **ppvObj);

#ifdef __cplusplus
} /* end of 'extern "C" {' */
#endif

#endif //__MSIME_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\mem.h ===
//
// mem.h
//

#ifndef MEM_H
#define MEM_H

#include "private.h"

#ifdef __cplusplus
extern "C" {
#endif

#ifndef DEBUG

void *cicMemAlloc(UINT uCount);
void *cicMemAllocClear(UINT uCount);
void cicMemFree(void *pv);
void *cicMemReAlloc(void *pv, UINT uCount);
UINT cicMemSize(void *pv);

// placeholders for the debug funcs
#define Dbg_MemInit(pszName, rgCounters)
#define Dbg_MemUninit()
#define Dbg_MemDumpStats()
#define Dbg_MemSetName(pv, pszName)
#define Dbg_MemGetName(pv, pch, ccBuffer)
#define Dbg_MemSetThisName(pszName)

#else // DEBUG

typedef struct _DBG_MEM_COUNTER
{
    const TCHAR *pszDesc;
    ULONG uCount;
} DBG_MEM_COUNTER;

typedef struct _DBG_MEMALLOC
{
    void *pvAlloc;          // the allocated memory
    UINT uCount;            // size of allocated mem
    TCHAR *pszName;         // debug string
    const TCHAR *pszFile;   // file in which alloc occurred
    int iLine;              // line num of alloc file
    DWORD dwThreadID;       // Thread ID
    DWORD dwID;             // unique id (by object type)
    struct _DBG_MEMALLOC *next;
} DBG_MEMALLOC;

typedef struct
{
    UINT uTotalAlloc;
    UINT uTotalFree;
    long uTotalMemAllocCalls;
    long uTotalMemAllocClearCalls;
    long uTotalMemReAllocCalls;
    long uTotalMemFreeCalls;
    DBG_MEMALLOC *pMemAllocList;
    TCHAR *pszName;
} DBG_MEMSTATS;

BOOL Dbg_MemInit(const TCHAR *pszName, DBG_MEM_COUNTER *rgCounters);
BOOL Dbg_MemUninit();
void Dbg_MemDumpStats();

void *Dbg_MemAlloc(UINT uCount, const TCHAR *pszFile, int iLine);
void *Dbg_MemAllocClear(UINT uCount, const TCHAR *pszFile, int iLine);
void Dbg_MemFree(void *pv);
void *Dbg_MemReAlloc(void *pv, UINT uCount, const TCHAR *pszFile, int iLine);
UINT Dbg_MemSize(void *pv);

BOOL Dbg_MemSetName(void *pv, const TCHAR *pszName);
BOOL Dbg_MemSetNameID(void *pv, const TCHAR *pszName, DWORD dwID);
BOOL Dbg_MemSetNameIDCounter(void *pv, const TCHAR *pszName, DWORD dwID, ULONG iCounter);
int Dbg_MemGetName(void *pv, TCHAR *pch, int ccBuffer);

#define cicMemAlloc(uCount)        Dbg_MemAlloc(uCount, TEXT(__FILE__), __LINE__)
#define cicMemAllocClear(uCount)   Dbg_MemAllocClear(uCount, TEXT(__FILE__), __LINE__)
#define cicMemFree(pv)             Dbg_MemFree(pv)
#define cicMemReAlloc(pv, uCount)  Dbg_MemReAlloc(pv, uCount, TEXT(__FILE__), __LINE__)
#define cicMemSize(pv)             Dbg_MemSize(pv)

// helpers
#define Dbg_MemSetThisName(pszName) Dbg_MemSetNameID(this, pszName, (DWORD)-1)

#endif // DEBUG

#ifdef __cplusplus
} // extern "C"
#endif

#ifdef __cplusplus
#ifdef DEBUG

inline void *  __cdecl operator new(size_t nSize, const TCHAR *pszFile, int iLine)
{
    return Dbg_MemAllocClear(nSize, pszFile, iLine);
}

#define new new(TEXT(__FILE__), __LINE__)

#endif // DEBUG
#endif // __cplusplus

#endif // MEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\msutbapi.h ===
//
// msutbapi.h
//
// Private msutb apis.
//

#ifndef MSUTBAPI_H
#define MSUTBAPI_H


#define UTB_GTI_WINLOGON 0x00000001
#define UTB_GTI_POPUP    0x80000000
extern "C" BOOL WINAPI GetPopupTipbar(HWND hwndParent, DWORD dwFlags);
extern "C" void WINAPI ClosePopupTipbar();

#endif // MSUTBAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\pkes.h ===
//
// pkes.h
//
// Generic ITfPreservedKeyNotifySink object
//

#ifndef PKES_H
#define PKES_H

#include "private.h"

#define PKES_INVALID_COOKIE  ((UINT_PTR)(-1))


typedef HRESULT (*PKESCALLBACK)(const TF_PRESERVEDKEY *pprekey, void *pv);

class CPreservedKeyNotifySink : public ITfPreservedKeyNotifySink
{
public:
    CPreservedKeyNotifySink(PKESCALLBACK pfnCallback, void *pv);

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfPreservedKeyNotifySink
    //
    STDMETHODIMP OnUpdated(const TF_PRESERVEDKEY *pprekey);

    HRESULT _Advise(ITfThreadMgr *ptim);
    HRESULT _Unadvise();

private:

    long _cRef;
    ITfThreadMgr *_ptim;
    DWORD _dwCookie;
    PKESCALLBACK _pfnCallback;
    void *_pv;
};

#endif // PKES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\regimx.h ===
//
// regimx.h
//

#ifndef REGIMX_H
#define REGIMX_H

typedef struct tag_REGTIPLANGPROFILE {
    //
    // langid
    //
    //   The langid value cane be one of followings.
    //
    //   1. complete lang id.
    //     the combination of SUBLANGID and MAINLANGID.
    //
    //   2. just main lang id.
    //     Just MAINLANGID and set SUBLANGID as 0.
    //     Then this profile is avaible for all langids that match with
    //     main langid.
    //
    //   3. -1
    //     This profile is avaible on any language.
    //
    LANGID langid;
    const GUID *pguidProfile;
    WCHAR szProfile[128];
    WCHAR szIconFile[32];
    ULONG uIconIndex;
    ULONG uDisplayDescResIndex;
} REGTIPLANGPROFILE;

BOOL RegisterTIP(HINSTANCE hInst, REFCLSID clsid, WCHAR *pwszDesc, const REGTIPLANGPROFILE *plp);
BOOL UnregisterTIP(REFCLSID rclsid);


#endif // REGIMX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\ptrary.h ===
//
// ptrary.h
//
// CPtrArray -- growable pointer array
//

#ifndef PTRARY_H
#define PTRARY_H

#include "private.h"

class CVoidPtrArray
{
public:
    CVoidPtrArray() 
    {
        _cElems = 0;
        _rgpv = NULL;
        _iSize = 0;
    }
    virtual ~CVoidPtrArray() { cicMemFree(_rgpv); }

    inline void Set(int iIndex, void *pv)
    {
        Assert(iIndex >= 0);
        Assert(iIndex < _cElems);

        _rgpv[iIndex] = pv;
    }

    inline void *Get(int iIndex) { return *GetPtr(iIndex); }

    inline void **GetPtr(int iIndex)
    {
        Assert(iIndex >= 0);
        Assert(iIndex <= _cElems); // there's code that uses the first invalid offset for loop termination

        return &_rgpv[iIndex];
    }

    BOOL Insert(int iIndex, int cElems);
    void Remove(int iIndex, int cElems);
    int Move(int iIndexNew, int iIndexOld);
    void **Append(int cElems)
    {
        return Insert(Count(), cElems) ? GetPtr(Count()-cElems) : NULL;
    }

    void SetCount(int cElems)
    {
        Assert(cElems >= 0);
        Assert(cElems <= _iSize);
        _cElems = cElems;
    }
    int Count() { return _cElems; }

    void Clear() { cicMemFree(_rgpv); _rgpv = NULL; _cElems = _iSize = 0; }

    void CompactSize(int iSizeNew)
    {
        void **ppv;

        Assert(iSizeNew <= _iSize);
        Assert(_cElems <= iSizeNew);

        if (iSizeNew == _iSize) // MemReAlloc will actually re-alloc!  Don't let it.
            return;

        if ((ppv = (void **)cicMemReAlloc(_rgpv, iSizeNew*sizeof(void *))) != NULL)
        {
            _rgpv = ppv;
            _iSize = iSizeNew;
        }
    }

    void CompactSize() { CompactSize(_cElems); }

private:
    void **_rgpv;   // the array
    int _cElems;    // num eles in the array
    int _iSize;     // actual size (in void *'s) of the array
};



//
// typesafe version
//
template<class T>
class CPtrArray : public CVoidPtrArray
{
public:
    CPtrArray() {}

    void Set(int iIndex, T *pT) { CVoidPtrArray::Set(iIndex, pT); }
    T *Get(int iIndex) { return (T *)CVoidPtrArray::Get(iIndex); }
    T **GetPtr(int iIndex) { return (T **)CVoidPtrArray::GetPtr(iIndex); }
    T **Append(int cElems) { return (T **)CVoidPtrArray::Append(cElems); }
};


#endif // PTRARY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\mui.h ===
#ifndef MUI_H
#define MUI_H

#ifdef __cplusplus
extern "C"
{
#endif

void MuiLoadResource(HINSTANCE hinstOrg, LPTSTR pszLocResDll);
void MuiLoadResourceW(HINSTANCE hinstOrg, LPWSTR pszLocResDll);
void MuiFreeResource(HINSTANCE hinstOrg);

void MuiFlushDlls(HINSTANCE hinstOrg);
void MuiClearResource();

HINSTANCE MuiGetHinstance();
HINSTANCE MuiLoadLibrary(LPCTSTR lpLibFileName, HMODULE hModule);

int MuiLoadString(HINSTANCE hinst, UINT id, LPSTR sz, INT cchMax);
int MuiLoadStringWrapW(HINSTANCE hinst, UINT id, LPWSTR sz, UINT cchMax);

#ifdef LoadString
#undef LoadString
#undef LoadStringA
#undef LoadStringW
#endif

#ifndef UNICODE
#define LoadString MuiLoadString
#else
#define LoadString MuiLoadStringWrapW
#endif
#define LoadStringA MuiLoadString
#define LoadStringW MuiLoadStringWrapW
#define LoadStringWrapW MuiLoadStringWrapW


INT_PTR MuiDialogBoxParam(
    HINSTANCE hInstance,
    LPCTSTR lpTemplateName,
    HWND hwndParent,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);

LANGID GetPlatformResourceLangID(void);

DWORD GetUIACP();


#ifdef __cplusplus
};
#endif // __cplusplus

#endif // MUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\nuibase.h ===
//
// nuibase.h
//
// Generic ITfTextEventSink object
//

#ifndef NUIBASE_H
#define NUIBASE_H

#include "ctfutb.h"
#include "iconlib.h"
inline HRESULT LangBarInsertMenu(ITfMenu *pMenu, UINT uId, WCHAR *psz, BOOL bChecked = FALSE, BOOL bRadioChecked = FALSE)
{
    DWORD dwFlags = 0;

    if (bChecked)
        dwFlags |= TF_LBMENUF_CHECKED;
    if (bRadioChecked)
        dwFlags |= TF_LBMENUF_RADIOCHECKED;

    return pMenu->AddMenuItem(uId, 
                              dwFlags,
                              NULL,
                              NULL,
                              psz,
                              wcslen(psz),
                              NULL);
}

inline HRESULT LangBarInsertGrayedMenu(ITfMenu *pMenu, WCHAR *psz)
{
    return pMenu->AddMenuItem((UINT)-1, 
                              TF_LBMENUF_GRAYED,
                              NULL,
                              NULL,
                              psz,
                              wcslen(psz),
                              NULL);
}

inline HRESULT LangBarInsertMenu(ITfMenu *pMenu, UINT uId, WCHAR *psz, HBITMAP hbmp, HBITMAP hbmpMask)
{
    return pMenu->AddMenuItem(uId, 
                              0,
                              hbmp,
                              hbmpMask,
                              psz,
                              wcslen(psz),
                              NULL);
}

inline HRESULT LangBarInsertMenu(ITfMenu *pMenu, UINT uId, WCHAR *psz, BOOL bChecked, HICON hIcon)
{
    HBITMAP hbmp = NULL;
    HBITMAP hbmpMask = NULL;
    if (hIcon)
    {
        HICON hSmIcon = (HICON)CopyImage(hIcon, 
                                         IMAGE_ICON, 
                                         16,
                                         16,
                                         LR_COPYFROMRESOURCE);
        SIZE size = {16, 16};

        if (!GetIconBitmaps(hSmIcon ? hSmIcon : hIcon, &hbmp, &hbmpMask, &size))
            return E_FAIL;

        if (hSmIcon)
            DestroyIcon(hSmIcon);

        if (hIcon)
            DestroyIcon(hIcon);
    }

    return pMenu->AddMenuItem(uId, 
                              bChecked ? TF_LBMENUF_CHECKED : 0,
                              hbmp,
                              hbmpMask,
                              psz,
                              wcslen(psz),
                              NULL);
}

inline HRESULT LangBarInsertGrayedMenu(ITfMenu *pMenu, WCHAR *psz, HICON hIcon)
{
    HBITMAP hbmp = NULL;
    HBITMAP hbmpMask = NULL;
    if (hIcon)
    {
        HICON hSmIcon = (HICON)CopyImage(hIcon, 
                                         IMAGE_ICON, 
                                         16,
                                         16,
                                         LR_COPYFROMRESOURCE);
        SIZE size = {16, 16};

        if (!GetIconBitmaps(hSmIcon ? hSmIcon : hIcon, &hbmp, &hbmpMask, &size))
            return E_FAIL;

        if (hSmIcon)
            DestroyIcon(hSmIcon);

        if (hIcon)
            DestroyIcon(hIcon);
    }

    return pMenu->AddMenuItem((UINT)-1, 
                              TF_LBMENUF_GRAYED,
                              hbmp,
                              hbmpMask,
                              psz,
                              wcslen(psz),
                              NULL);
}

inline HRESULT LangBarInsertSubMenu(ITfMenu *pMenu, WCHAR *psz, ITfMenu **ppSubMenu)
{
    return pMenu->AddMenuItem(UINT(-1), 
                              TF_LBMENUF_SUBMENU,
                              NULL,
                              NULL,
                              psz,
                              wcslen(psz),
                              ppSubMenu);
}

inline HRESULT LangBarInsertSeparator(ITfMenu *pMenu)
{
    return pMenu->AddMenuItem((UINT)(-1),
                              TF_LBMENUF_SEPARATOR,
                              NULL,
                              NULL,
                              NULL,
                              0,
                              NULL);
}

#define NUIBASE_TOOLTIP_MAX 256
#define NUIBASE_TEXT_MAX    256

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemBase
//
//////////////////////////////////////////////////////////////////////////////

class __declspec(novtable) CLBarItemBase
{
public:
    CLBarItemBase();
    virtual ~CLBarItemBase();

    void InitNuiInfo(REFCLSID clsid, REFGUID rguid, DWORD dwStyle, ULONG ulSort, WCHAR *pszDesc);
    virtual STDMETHODIMP GetInfo(TF_LANGBARITEMINFO *pInfo);
    virtual STDMETHODIMP GetStatus(DWORD *pdwStatus);
    virtual STDMETHODIMP Show(BOOL fShow);
    virtual STDMETHODIMP GetTooltipString(BSTR *pbstrToolTip);

    virtual STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie);
    virtual STDMETHODIMP UnadviseSink(DWORD dwCookie);

    DWORD GetStyle() {return _lbiInfo.dwStyle;}
    void SetStyle(DWORD dwStyle) {_lbiInfo.dwStyle = dwStyle;}

    GUID* GetGuidItem() {return &_lbiInfo.guidItem;}

    DWORD GetStatusInternal() {return _dwStatus;}
    void SetStatusInternal(DWORD dw) {_dwStatus = dw;}
    HRESULT ShowInternal(BOOL fShow, BOOL fNotify);

    void SetOrClearStatus(DWORD dw, BOOL fSet)
    {
        if (fSet)
            _dwStatus |= dw;
        else
            _dwStatus &= ~dw;
    }

    void SetToolTip(WCHAR *psz, UINT cch = (UINT)(-1))
    {
        if (cch == (UINT)(-1))
            StringCchCopyW(_szToolTip, ARRAYSIZE(_szToolTip), psz);
        else
        {
            UINT cchTemp = (UINT)min(ARRAYSIZE(_szToolTip) - 1, cch);
            memcpy(_szToolTip, psz, cchTemp * sizeof(WCHAR));
            _szToolTip[cchTemp] = L'\0';
        }
    }

    virtual HRESULT OnLButtonUp(const POINT pt, const RECT *prcArea);
    virtual HRESULT OnRButtonUp(const POINT pt, const RECT *prcArea);

    ITfLangBarItemSink *GetSink() {return _plbiSink;}

protected:
    DWORD _dwStatus;
    TF_LANGBARITEMINFO _lbiInfo;
    WCHAR _szToolTip[NUIBASE_TOOLTIP_MAX];
    long _cRef;
    ITfLangBarItemSink *_plbiSink;

private:
    DWORD _dwCookie;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemButtonBase
//
//////////////////////////////////////////////////////////////////////////////

class __declspec(novtable) CLBarItemButtonBase : public CLBarItemBase,
                                                 public ITfSource,
                                                 public ITfLangBarItemButton
{
public:
    CLBarItemButtonBase();
    virtual ~CLBarItemButtonBase();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfSource
    //
    STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);

    //
    // ITfLangBarItem
    //
    STDMETHODIMP GetInfo(TF_LANGBARITEMINFO *pInfo);
    STDMETHODIMP GetStatus(DWORD *pdwStatus);
    STDMETHODIMP Show(BOOL fShow);
    STDMETHODIMP GetTooltipString(BSTR *pbstrToolTip);

    //
    // ITfLangBarItemButton
    //
    STDMETHODIMP OnClick(TfLBIClick click, POINT pt, const RECT *prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    STDMETHODIMP GetIcon(HICON *phIcon);
    STDMETHODIMP GetText(BSTR *pbstrText);

    void SetIcon(HICON hIcon)   {_hIcon = hIcon;}
    HICON GetIcon()   {return _hIcon;}
    void SetText(WCHAR *psz)  
    {
        StringCchCopyW(_szText, ARRAYSIZE(_szText), psz);
    }

private:
    HICON _hIcon;
    WCHAR _szText[NUIBASE_TEXT_MAX];

};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemBitmapButtonBase
//
//////////////////////////////////////////////////////////////////////////////

class __declspec(novtable) CLBarItemBitmapButtonBase : public CLBarItemBase,
                                                       public ITfSource,
                                                       public ITfLangBarItemBitmapButton
{
public:
    CLBarItemBitmapButtonBase();
    virtual ~CLBarItemBitmapButtonBase();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfSource
    //
    STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);

    //
    // ITfLangBarItem
    //
    STDMETHODIMP GetInfo(TF_LANGBARITEMINFO *pInfo);
    STDMETHODIMP GetStatus(DWORD *pdwStatus);
    STDMETHODIMP Show(BOOL fShow);
    STDMETHODIMP GetTooltipString(BSTR *pbstrToolTip);

    //
    // ITfLangBarItemBitmapButton
    //
    STDMETHODIMP OnClick(TfLBIClick click, POINT pt, const RECT *prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    STDMETHODIMP GetPreferredSize(const SIZE *pszDefault, SIZE *psize);
    STDMETHODIMP DrawBitmap(LONG x, LONG y, DWORD dwFlags,  HBITMAP *phbmp, HBITMAP *phbmpMask) = 0;
    STDMETHODIMP GetText(BSTR *pbstrText);


    void SetText(WCHAR *psz)  
    {
        StringCchCopyW(_szText, ARRAYSIZE(_szText), psz);
    }

    void SetPreferedSize(SIZE *psize) {_sizePrefered = *psize;}
private:
    SIZE _sizePrefered;
    WCHAR _szText[NUIBASE_TEXT_MAX];

};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemBitmapBase
//
//////////////////////////////////////////////////////////////////////////////

class __declspec(novtable) CLBarItemBitmapBase : public CLBarItemBase,
                                                 public ITfSource,
                                                 public ITfLangBarItemBitmap
{
public:
    CLBarItemBitmapBase();
    virtual ~CLBarItemBitmapBase();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfSource
    //
    STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);

    //
    // ITfLangBarItem
    //
    STDMETHODIMP GetInfo(TF_LANGBARITEMINFO *pInfo);
    STDMETHODIMP GetStatus(DWORD *pdwStatus);
    STDMETHODIMP Show(BOOL fShow);
    STDMETHODIMP GetTooltipString(BSTR *pbstrToolTip);

    //
    // ITfLangBarItemBitmap
    //
    STDMETHODIMP OnClick(TfLBIClick click, POINT pt, const RECT *prcArea);
    STDMETHODIMP GetPreferredSize(const SIZE *pszDefault, SIZE *psize);
    STDMETHODIMP DrawBitmap(LONG x, LONG y, DWORD dwFlags, HBITMAP *phbmp, HBITMAP *phbmpMask) = 0;

    void SetPreferedSize(SIZE *psize) {_sizePrefered = *psize;}
private:
    SIZE _sizePrefered;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemBalloonBase
//
//////////////////////////////////////////////////////////////////////////////

class __declspec(novtable) CLBarItemBalloonBase : public CLBarItemBase,
                                                 public ITfSource,
                                                 public ITfLangBarItemBalloon
{
public:
    CLBarItemBalloonBase();
    virtual ~CLBarItemBalloonBase();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfSource
    //
    STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);

    //
    // ITfLangBarItem
    //
    STDMETHODIMP GetInfo(TF_LANGBARITEMINFO *pInfo);
    STDMETHODIMP GetStatus(DWORD *pdwStatus);
    STDMETHODIMP Show(BOOL fShow);
    STDMETHODIMP GetTooltipString(BSTR *pbstrToolTip);

    //
    // ITfLangBarItemBalloon
    //
    STDMETHODIMP OnClick(TfLBIClick click, POINT pt, const RECT *prcArea);
    STDMETHODIMP GetPreferredSize(const SIZE *pszDefault, SIZE *psize);
    STDMETHODIMP GetBalloonInfo(TF_LBBALLOONINFO *pInfo) = 0;

    void SetPreferedSize(SIZE *psize) {_sizePrefered = *psize;}
private:
    SIZE _sizePrefered;
};

#endif // NUIBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\osver.h ===
//
// osver.h
//

#include <windows.h>


#ifndef OSVER_H
#define OSVER_H

#define OSVER_ONNT     0x0001
#define OSVER_ONNT5    0x0002
#define OSVER_ON95     0x0004
#define OSVER_ON98     0x0008
#define OSVER_ONFE     0x0010
#define OSVER_ONIMM    0x0020
#define OSVER_ONDBCS   0x0040
#define OSVER_ONNT51   0x0080

#define DECLARE_OSVER()                 \
                DWORD g_dwOsVer; \
                UINT  g_uACP;

#ifdef __cplusplus
extern "C" {
#endif
extern DWORD g_dwOsVer;
extern UINT  g_uACP;
#ifdef __cplusplus
}
#endif

#define IsOnNT()       (g_dwOsVer & OSVER_ONNT)
#define IsOnNT5()      (g_dwOsVer & OSVER_ONNT5)
#define IsOn95()       (g_dwOsVer & OSVER_ON95)
#define IsOn98()       (g_dwOsVer & OSVER_ON98)
#define IsOn98orNT5()  (g_dwOsVer & (OSVER_ON98 | OSVER_ONNT5))
#define IsOnFE()       (g_dwOsVer & OSVER_ONFE)
#define IsOnImm()      (g_dwOsVer & OSVER_ONIMM)
#define IsOnDBCS()     (g_dwOsVer & OSVER_ONDBCS)
#define IsOnNT51()     (g_dwOsVer & OSVER_ONNT51)

#ifdef __cplusplus
inline void InitOSVer()
{
    OSVERSIONINFO osvi;
    g_uACP = GetACP();

    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx(&osvi);
    g_dwOsVer = 0;
    g_dwOsVer |= (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId) ? OSVER_ONNT : 0;
    g_dwOsVer |= (IsOnNT() && (osvi.dwMajorVersion >= 0x00000005)) ? OSVER_ONNT5 : 0;
    g_dwOsVer |= (IsOnNT5() && (osvi.dwMinorVersion >= 0x00000001)) ? OSVER_ONNT51 : 0;
    g_dwOsVer |= (!IsOnNT() && (osvi.dwMinorVersion >= 0x0000000A)) ? OSVER_ON98 : 0;
    g_dwOsVer |= (!IsOnNT() && !IsOn98()) ? OSVER_ON95 : 0;

    switch (g_uACP)
    {
        case 932:
        case 936:
        case 949:
        case 950:
            g_dwOsVer |= OSVER_ONFE;
            break;
    }

    if (IsOnNT5()) {
#if(_WIN32_WINNT >= 0x0500)
        /*
         * Only NT5 or later suppoert SM_IMMENABLED
         */
        if (GetSystemMetrics(SM_IMMENABLED)) {
            g_dwOsVer |= OSVER_ONIMM;
        }
#endif
    }
    if (GetSystemMetrics(SM_DBCSENABLED)) {
        if (!IsOnNT5()) 
            g_dwOsVer |= OSVER_ONIMM;
         g_dwOsVer |= OSVER_ONDBCS;
    }
}
#endif // __cplusplus


#endif // OSVER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\ptrmap.h ===
//
// ptrmap.h
//

#ifndef PTRMAP_H
#define PTRMAP_H

#ifdef __cplusplus

#include "private.h"

#define PM_HASHSIZE 31

template<class TKey, class TPtr>
class CPMEntry
{
public:
    TKey key;
    TPtr *ptr;
    CPMEntry<TKey, TPtr> *next;
};

template<class TKey, class TPtr>
class CPtrMap
{
public:
    CPtrMap() { memset(_HashTbl, 0, sizeof(_HashTbl)); }
    ~CPtrMap();

    BOOL _Set(TKey key, TPtr *ptr);
    TPtr *_Find(TKey key);
    TPtr *_Remove(TKey key);
    BOOL _Remove(TPtr *ptr);
    BOOL _FindKey(TPtr *ptr, TKey *pkeyOut);

private:
    UINT _HashFunc(TKey key) { return (UINT)((UINT_PTR)key % PM_HASHSIZE); }
    CPMEntry<TKey, TPtr> **_FindEntry(TKey key);

    CPMEntry<TKey, TPtr> *_HashTbl[PM_HASHSIZE];
};

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

template<class TKey, class TPtr>
CPtrMap<TKey, TPtr>::~CPtrMap()
{
    CPMEntry<TKey, TPtr> *pe;
    CPMEntry<TKey, TPtr> *peTmp;
    int i;

    // free anything left in the hashtbl
    for (i=0; i<ARRAYSIZE(_HashTbl); i++)
    {
        pe = _HashTbl[i];

        while (pe != NULL)
        {
            peTmp = pe->next;
            cicMemFree(pe);
            pe = peTmp;
        }
    }
}

//+---------------------------------------------------------------------------
//
// _Set
//
//----------------------------------------------------------------------------

template<class TKey, class TPtr>
BOOL CPtrMap<TKey, TPtr>::_Set(TKey key, TPtr *ptr)
{
    UINT uIndex;
    CPMEntry<TKey, TPtr> *pe;
    CPMEntry<TKey, TPtr> **ppe;
    BOOL fRet;

    fRet = TRUE;

    if (ppe = _FindEntry(key))
    {
        // already in hash tbl
        (*ppe)->ptr = ptr;
    }
    else if (pe = (CPMEntry<TKey, TPtr> *)cicMemAlloc(sizeof(CPMEntry<TKey, TPtr>)))
    {
        // new entry
        uIndex = _HashFunc(key);
        pe->key = key;
        pe->ptr = ptr;
        pe->next = _HashTbl[uIndex];
        _HashTbl[uIndex] = pe;
    }
    else
    {
        // out of memory
        fRet = FALSE;
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
// _Find
//
//----------------------------------------------------------------------------

template<class TKey, class TPtr>
TPtr *CPtrMap<TKey, TPtr>::_Find(TKey key)
{
    CPMEntry<TKey, TPtr> **ppe;

    if (ppe = _FindEntry(key))
    {
        return (*ppe)->ptr;
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//
// _Remove
//
//----------------------------------------------------------------------------

template<class TKey, class TPtr>
TPtr *CPtrMap<TKey, TPtr>::_Remove(TKey key)
{
    CPMEntry<TKey, TPtr> *pe;
    CPMEntry<TKey, TPtr> **ppe;
    TPtr *ptr;

    if (ppe = _FindEntry(key))
    {
        pe = *ppe;
        ptr = pe->ptr;
        *ppe = pe->next;
        cicMemFree(pe);
        return ptr;
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//
// _Remove
//
//----------------------------------------------------------------------------

template<class TKey, class TPtr>
BOOL CPtrMap<TKey, TPtr>::_Remove(TPtr *ptr)
{
    int i;
    CPMEntry<TKey, TPtr> *pe;
    CPMEntry<TKey, TPtr> **ppe;

    for (i = 0; i < PM_HASHSIZE; i++)
    {
        ppe = &_HashTbl[i];

        while (*ppe)
        {
            if ((*ppe)->ptr == ptr)
            {
                pe = *ppe;
                *ppe = pe->next;
                cicMemFree(pe);
            }
            else
            {
                ppe = &(*ppe)->next;
            }
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// _FindKey
//
//----------------------------------------------------------------------------

template<class TKey, class TPtr>
BOOL CPtrMap<TKey, TPtr>::_FindKey(TPtr *ptr, TKey *ptkeyOut)
{
    int i;
    CPMEntry<TKey, TPtr> **ppe;

    *ptkeyOut = NULL;

    for (i = 0; i < PM_HASHSIZE; i++)
    {
        ppe = &_HashTbl[i];

        while (*ppe)
        {
            if ((*ppe)->ptr == ptr)
            {
                *ptkeyOut = (*ppe)->key;
                return TRUE;
            }
            else
            {
                ppe = &(*ppe)->next;
            }
        }
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
// _FindEntry
//
//----------------------------------------------------------------------------

template<class TKey, class TPtr>
CPMEntry<TKey, TPtr> **CPtrMap<TKey, TPtr>::_FindEntry(TKey key)
{
    CPMEntry<TKey, TPtr> **ppe;

    ppe = &_HashTbl[_HashFunc(key)];

    while (*ppe)
    {
        if ((*ppe)->key == key)
        {
            return ppe;
        }
        ppe = &(*ppe)->next;
    }

    return NULL;
}


#endif // __cplusplus

#endif // PTRMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\proputil.h ===
//
// proputil.h
//


#ifndef PROPUTIL_H
#define PROPUTIL_H

#include "private.h"
#include "catutil.h"


HRESULT HrVariantToBlob(VARIANT *pv, void *value, ULONG *cbvalue, VARTYPE vt);
HRESULT HrBlobToVariant(const void *value, ULONG cbvalue, VARIANT *pv, VARTYPE vt);
HRESULT GetGUIDPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, TfGuidAtom *pguidatom);
HRESULT SetGUIDPropertyData(LIBTHREAD *plt, TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, REFGUID rguid);
HRESULT GetDWORDPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, DWORD *pdw);
HRESULT SetDWORDPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, DWORD dw);
HRESULT GetReadingStrPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, BSTR *pbtr);
HRESULT GetBSTRPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, BSTR *pbstr);
HRESULT SetBSTRPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, BSTR bstr);
HRESULT GetUnknownPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, IUnknown **ppunk);
HRESULT SetUnknownPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, IUnknown *punk);

#define GetLangIdPropertyData(ec, pProp, pPropRange, plangid)  {DWORD dw = 0; GetDWORDPropertyData(ec, pProp, pPropRange, &dw); *plangid = (WORD)dw;}
#define SetLangIdPropertyData(ec, pProp, pPropRange, langid) SetDWORDPropertyData(ec, pProp, pPropRange, (WORD)langid)
#define GetAttrPropertyData GetGUIDPropertyData
#define SetAttrPropertyData SetGUIDPropertyData

inline HRESULT HrVariantToGUID(VARIANT *pv, GUID *pguid)
{
    ULONG cb = sizeof(GUID);
    HRESULT hr =  HrVariantToBlob(pv, (void *)pguid, &cb, VT_I4);
    Assert(FAILED(hr) || (cb == sizeof(GUID) / 4));
    return hr;
}
inline HRESULT HrGUIDToVariant(REFGUID rguid, VARIANT *pv)
{
    return HrBlobToVariant((const void *)&rguid, sizeof(GUID) / 4, pv, VT_I4);
}

void SetIntAttribute(IXMLDOMElement *pElem, WCHAR *pszTag, int nData);
void SetCharAttribute(IXMLDOMElement *pElem, WCHAR *pszTag, WCHAR *pszData);
HRESULT GetIntAttribute(IXMLDOMElement *pElem, WCHAR *pszTag, int *pnRet);
HRESULT GetCharAttribute(IXMLDOMElement *pElem, WCHAR *pszTag, WCHAR *pszData, int nSize);

HRESULT SetTextAndProperty(LIBTHREAD *plt, TfEditCookie ec, ITfContext *pic, ITfRange *pRange, const WCHAR *pchText, LONG cchText, LANGID langid, const GUID *pattr);
HRESULT SetTextAndReading(LIBTHREAD *plt, TfEditCookie ec, ITfContext *pic, ITfRange *pRange, const WCHAR *pchText, LONG cchText, LANGID langid, const WCHAR *pszRead);

BOOL IsOwnerAndFocus(LIBTHREAD *plt, TfEditCookie ec, REFCLSID rclsid, ITfReadOnlyProperty *pProp, ITfRange *pRange);
HRESULT EnumTrackTextAndFocus(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfReadOnlyProperty **ppProp, IEnumTfRanges **ppEnumTrack);
BOOL IsGUIDProp(LIBTHREAD *plt, TfEditCookie ec, REFGUID rclsid, ITfProperty *pProp, ITfRange *pRange);
HRESULT AdjustRangeByTextOwner(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfRange **ppRange, REFGUID rguid);
HRESULT AdjustRangeByAttribute(LIBTHREAD *plt, TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfRange **ppRange, const GUID *rgRGuid, int cGuid);


#endif // PROPUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\regsvr.h ===
//
// imeutil.h
//

#ifndef REGSVR_H
#define REGSVR_H

#include <windows.h>
#include <advpub.h>

// Issue: calling convention

#define CLSID_STRLEN 38  // strlen("{xxxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxx}")
BOOL CLSIDToStringA(REFGUID refGUID, char *pchA);
BOOL StringAToCLSID(char *pchA, GUID *pGUID);

BOOL RegisterServer(REFCLSID clsid, LPCTSTR pszDesc, LPCTSTR pszPath, LPCTSTR pszModel, LPCTSTR pszSoftwareKey);
BOOL RegisterServerW(REFCLSID clsid, const WCHAR *pszDesc, const WCHAR *pszPath, const WCHAR *pszModel, const WCHAR  *pszSoftwareKey, const WCHAR *pszMenuTextPUI);

#endif // REGSVR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\sdo.h ===
//
// sdo.h
//
// Generic simple IDataObject object
//

#ifndef SDO_H
#define SDO_H

#include "private.h"

class CDataObject : public IDataObject
{
public:
    CDataObject();
    ~CDataObject();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IDataObject
    //
    STDMETHODIMP GetData(FORMATETC *pfe, STGMEDIUM *psm);
    STDMETHODIMP GetDataHere(FORMATETC *pfe, STGMEDIUM *psm);
    STDMETHODIMP QueryGetData(FORMATETC *pfe);
    STDMETHODIMP GetCanonicalFormatEtc(FORMATETC *pfeIn, FORMATETC *pfeOut);
    STDMETHODIMP SetData(FORMATETC *pfe, STGMEDIUM *psm, BOOL fRelease);
    STDMETHODIMP EnumFormatEtc(DWORD dwDir, IEnumFORMATETC **ppefe);
    STDMETHODIMP DAdvise(FORMATETC *pfe, DWORD advf, IAdviseSink *pas, DWORD *pdwCookie);
    STDMETHODIMP DUnadvise(DWORD dwCookie);
    STDMETHODIMP EnumDAdvise(IEnumSTATDATA **ppesd);

    HRESULT _SetData(const WCHAR *pch, ULONG cch);

private:
    FORMATETC _fe;
    STGMEDIUM _sm;
    BOOL _fReleaseSM;
    long _cRef;
};

#endif // SDO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\spgrmr.h ===
#ifndef SPGRMR_H
#define SPGRMR_H


//
// SPGRMR.DLL - speech tip icon resource ID
//
#define IDI_SPTIP_DELETEICON                                100

//
// SPGRMR.DLL - speech tip grammar resource ID
//                                                          200
#define ID_SPTIP_DICTATION_COMMAND_CFG                      201
#define ID_SPTIP_NUMMODE_COMMAND_CFG                        202
#define ID_SPTIP_SPELLING_TOPIC_CFG                         203
#define ID_SPTIP_SHAREDCMD_CFG                              204


#endif // SPGRMR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\strary.h ===
//
// strary.h
//
// CStructArray -- growable struct array
//

#ifndef STRARY_H
#define STRARY_H

#include "private.h"
#include "mem.h"

class CVoidStructArray
{
public:
    CVoidStructArray(int iElemSize)
    {         
        _iElemSize = iElemSize; // Issue: iElemSize should be const in template
        _pb = NULL;
        _cElems = 0;
        _iSize = 0;
    } 
    virtual ~CVoidStructArray() { cicMemFree(_pb); }

    inline void *GetPtr(int iIndex)
    {
        Assert(iIndex >= 0);
        Assert(iIndex <= _cElems); // there's code that uses the first invalid offset for loop termination

        return _pb + (iIndex * _iElemSize);
    }

    BOOL Insert(int iIndex, int cElems);
    void Remove(int iIndex, int cElems);
    void *Append(int cElems)
    {
        return Insert(Count(), cElems) ? GetPtr(Count()-cElems) : NULL;
    }

    int Count()
    { 
        return _cElems; 
    }

    void Clear()
    { 
        cicMemFree(_pb);
        _pb = NULL;
        _cElems = _iSize = 0;
    }

    void Reset(int iMaxSize)
    {
        BYTE *pb;

        _cElems = 0;        

        if (_iSize <= iMaxSize)
            return;
        Assert(_pb != NULL); // _iSize should be zero in this case

        if ((pb = (BYTE *)cicMemReAlloc(_pb, iMaxSize*_iElemSize))
            == NULL)
        {
            return;
        }

        _pb = pb;
        _iSize = iMaxSize;
    }

protected:
    BYTE *_pb;   // the array
    int _cElems;    // num eles in the array
    int _iElemSize;    // num eles in the array
    int _iSize;     // actual size (in void *'s) of the array
};



//
// typesafe version
//
template<class T>
class CStructArray : public CVoidStructArray
{
public:
    CStructArray():CVoidStructArray(sizeof(T)) {}

    T *GetPtr(int iIndex) { return (T *)CVoidStructArray::GetPtr(iIndex); }
    T *Append(int cElems) { return (T *)CVoidStructArray::Append(cElems); }
};

//
// GUID version
//
class CGUIDArray : private CVoidStructArray
{
public:
    CGUIDArray():CVoidStructArray(sizeof(GUID)) {}

    int Count() { return _cElems; }

    GUID *GetPtr(int iIndex) { return (GUID *)CVoidStructArray::GetPtr(iIndex); }
    GUID *Append(int cElems) { return (GUID *)CVoidStructArray::Append(cElems); }

    int InsertGuid(const GUID *pguid)
    {
        int nIndex;
        Find(pguid, &nIndex);
        nIndex++;

        Insert(nIndex, 1);
        *(((GUID *)_pb) + nIndex) = *pguid;
     
        return nIndex;
    }

    int RemoveGuid(const GUID *pguid)
    {
        int nIndex = Find(pguid, NULL);
        if (nIndex == -1)
            return -1;

        Remove(nIndex, 1);

        return nIndex;
    }

    int Find(const GUID *pguid, int *piOut) 
    {
        int iMatch = -1;
        int iMid = -1;
        int iMin = 0;
        int iMax = _cElems;
        LONG l;

        while(iMin < iMax)
        {
            iMid = (iMin + iMax) / 2;
            l = memcmp(pguid, ((GUID *)_pb) + iMid, sizeof(GUID));

            if (l < 0)
            {
                iMax = iMid;
            }
            else if (l > 0)
            {
                iMin = iMid + 1;
            }
            else 
            {
                iMatch = iMid;
                break;
            }
        }

        if (piOut)
        {
            if ((iMatch == -1) && (iMid >= 0))
            {
                if (memcmp(pguid, ((GUID *)_pb) + iMid, sizeof(GUID)) < 0)
                    iMid--;
            }
            *piOut = iMid;
        }
        return iMatch;
    }
};

//
// Ref-counted version.
//
// Note: this is limited, because there's no dtor for struct elements.
//
template<class T>
class CSharedStructArray : public CStructArray<T>
{
public:
    CSharedStructArray() : CStructArray<T>()
    {
        _cRef = 1;
    }

    void _AddRef()
    { 
        _cRef++;
    }

    void _Release()
    {   
        Assert(_cRef > 0);

        if (--_cRef == 0)
        {
            delete this;
        }
    }

private:
    LONG _cRef;
};

#endif // STRARY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\sink.h ===
//
// sink.h
//

#ifndef SINK_H
#define SINK_H

#include "private.h"
#include "strary.h"

#define GENERIC_ERROR_COOKIE    0xffffffff

typedef struct _GENERICSINK
{
    IUnknown *pSink;
    DWORD dwCookie;
    UINT_PTR uPrivate; // private state associated with the sink, for use of owner
} GENERICSINK;

inline UINT GenericCookieToGUIDIndex(DWORD dwCookie) { return (dwCookie & 0xff000000) >> 24; }

inline DWORD GenericChainToCookie(DWORD dwCookie, UINT cPreceedingCPs)
{
    Assert((dwCookie >> 24) + cPreceedingCPs < 128); // watch out for overflow

    return (dwCookie + (cPreceedingCPs << 24));
}
inline DWORD GenericUnchainToCookie(DWORD dwCookie, UINT cPreceedingCPs)
{
    Assert((int)(dwCookie - (cPreceedingCPs << 24)) >= 0); // underflow?

    return (dwCookie - (cPreceedingCPs << 24));
}


HRESULT GenericAdviseSink(REFIID riid, IUnknown *punk, const IID **rgiidConnectionPts, CStructArray<GENERICSINK> *rgSinkArrays, UINT cConnectionPts, DWORD *pdwCookie, GENERICSINK **ppSink = NULL);
HRESULT GenericUnadviseSink(CStructArray<GENERICSINK> *rgSinkArrays, UINT cConnectionPts, DWORD dwCookie, UINT_PTR *puPrivate = NULL);

HRESULT RequestCookie(CStructArray<DWORD> *rgCookies, DWORD *pdwCookie);
HRESULT ReleaseCookie(CStructArray<DWORD> *rgCookies, DWORD dwCookie);

#endif // SINK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\syslbar.h ===
//
// syslbar.h
//

#ifndef SYSLBAR_H
#define SYSLBAR_H

#include "ctfutb.h"

#define IDSLB_INITMENU        1
#define IDSLB_ONMENUSELECT    2
typedef HRESULT (*SYSLBARCALLBACK)(UINT uCode, void *pv, ITfMenu *pMenu, UINT wID);

//////////////////////////////////////////////////////////////////////////////
//
// CSystemLBarSink
//
//////////////////////////////////////////////////////////////////////////////

class CSystemLBarSink : public ITfSystemLangBarItemSink
{
public:
    CSystemLBarSink(SYSLBARCALLBACK pfn, void *pv);
    ~CSystemLBarSink();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfSource
    //
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);

    HRESULT _Advise(ITfThreadMgr *ptim, REFGUID rguid);
    HRESULT _Unadvise();


private:
    SYSLBARCALLBACK _pfn;
    ITfThreadMgr *_ptim;
    DWORD _dwCookie;
    void *_pv;
    GUID _guid;
    long _cRef;
};

#endif // SYSLBAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\slbarid.h ===
//
// slbarid.h
//

#ifndef SLBARID_H
#define SLBARID_H

//
// System lang bar items use these clsid to be located at proper place
// in the lang bar.
//

#define CICPADBTN_ORDER (-40)
#define HELPBTN_ORDER   (-30)
#define KANAINDIC_ORDER (-20)
#define WIN32IME_ORDER  (-10)

//
// Top sort order clsid
//
DEFINE_GUID(CLSID_SYSTEMLANGBARITEM, 0xbebacc94, 0x5cd3, 0x4662, 0xa1, 0xe0, 0xf3, 0x31, 0x99, 0x49, 0x36, 0x69);

//
// Last sort order clsid
//
DEFINE_GUID(CLSID_SYSTEMLANGBARITEM2, 0x5d997390, 0x8320, 0x400a, 0x88, 0xe5, 0x35, 0xb0, 0xc1, 0x20, 0xf9, 0x0b);

//
// Keyboard type sort order clsid
//
DEFINE_GUID(CLSID_SYSTEMLANGBARITEM_KEYBOARD, 0x77b34286, 0xed57, 0x45e2, 0x97, 0x66, 0xd8, 0xc5, 0xfe, 0x3d, 0xfb, 0x2c);

//
// Speech type sort order clsid
//
DEFINE_GUID(CLSID_SYSTEMLANGBARITEM_SPEECH,  0x7d1c98fb, 0xa873, 0x42b6, 0x88, 0x82, 0xb2, 0x97, 0x38, 0xb9, 0x30, 0xb2);

//
// HandWriting type sort order clsid
//
DEFINE_GUID(CLSID_SYSTEMLANGBARITEM_HANDWRITING, 0xa0810b6e, 0x1726, 0x4636, 0xb6, 0x51, 0xcd, 0xec, 0xd8, 0x22, 0xf0, 0x33);



/* 58c99d96-2f9b-42ce-91be-37ef1860f882 */
DEFINE_GUID(GUID_LBI_CTRL, 0x58c99d96, 0x2f9b, 0x42ce, 0x91, 0xbe, 0x37, 0xef, 0x18, 0x60, 0xf8, 0x82);

/* ed9d5450-ebe6-4255-8289-f8a31e687228 */
DEFINE_GUID(GUID_LBI_HELP, 0xed9d5450, 0xebe6, 0x4255, 0x82, 0x89, 0xf8, 0xa3, 0x1e, 0x68, 0x72, 0x28);

/* bb5bc72f-81df-4231-9668-c8dfd20fdb6f */
DEFINE_GUID(GUID_LBI_KANACAPS, 0xbb5bc72f, 0x81df, 0x4231, 0x96, 0x68, 0xc8, 0xdf, 0xd2, 0x0f, 0xdb, 0x6f);

/* 133901f4-2311-4bda-8c1e-57451a920d99 */
DEFINE_GUID(GUID_LBI_WIN32IME, 0x133901f4, 0x2311, 0x4bda, 0x8c, 0x1e, 0x57, 0x45, 0x1a, 0x92, 0x0d, 0x99);

/* 190f67a2-024f-40d9-aaba-439f5c808f67 */
DEFINE_GUID(GUID_LBI_RECONV, 0x190f67a2, 0x024f, 0x40d9, 0xaa, 0xba, 0x43, 0x9f, 0x5c, 0x80, 0x8f, 0x67);

#endif // SLBARID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\sapi.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0338 */
/* Compiler settings for sapi.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __sapi_h__
#define __sapi_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISpNotifySource_FWD_DEFINED__
#define __ISpNotifySource_FWD_DEFINED__
typedef interface ISpNotifySource ISpNotifySource;
#endif 	/* __ISpNotifySource_FWD_DEFINED__ */


#ifndef __ISpNotifySink_FWD_DEFINED__
#define __ISpNotifySink_FWD_DEFINED__
typedef interface ISpNotifySink ISpNotifySink;
#endif 	/* __ISpNotifySink_FWD_DEFINED__ */


#ifndef __ISpNotifyTranslator_FWD_DEFINED__
#define __ISpNotifyTranslator_FWD_DEFINED__
typedef interface ISpNotifyTranslator ISpNotifyTranslator;
#endif 	/* __ISpNotifyTranslator_FWD_DEFINED__ */


#ifndef __ISpDataKey_FWD_DEFINED__
#define __ISpDataKey_FWD_DEFINED__
typedef interface ISpDataKey ISpDataKey;
#endif 	/* __ISpDataKey_FWD_DEFINED__ */


#ifndef __ISpRegDataKey_FWD_DEFINED__
#define __ISpRegDataKey_FWD_DEFINED__
typedef interface ISpRegDataKey ISpRegDataKey;
#endif 	/* __ISpRegDataKey_FWD_DEFINED__ */


#ifndef __ISpObjectTokenCategory_FWD_DEFINED__
#define __ISpObjectTokenCategory_FWD_DEFINED__
typedef interface ISpObjectTokenCategory ISpObjectTokenCategory;
#endif 	/* __ISpObjectTokenCategory_FWD_DEFINED__ */


#ifndef __ISpObjectToken_FWD_DEFINED__
#define __ISpObjectToken_FWD_DEFINED__
typedef interface ISpObjectToken ISpObjectToken;
#endif 	/* __ISpObjectToken_FWD_DEFINED__ */


#ifndef __ISpObjectTokenInit_FWD_DEFINED__
#define __ISpObjectTokenInit_FWD_DEFINED__
typedef interface ISpObjectTokenInit ISpObjectTokenInit;
#endif 	/* __ISpObjectTokenInit_FWD_DEFINED__ */


#ifndef __IEnumSpObjectTokens_FWD_DEFINED__
#define __IEnumSpObjectTokens_FWD_DEFINED__
typedef interface IEnumSpObjectTokens IEnumSpObjectTokens;
#endif 	/* __IEnumSpObjectTokens_FWD_DEFINED__ */


#ifndef __ISpObjectWithToken_FWD_DEFINED__
#define __ISpObjectWithToken_FWD_DEFINED__
typedef interface ISpObjectWithToken ISpObjectWithToken;
#endif 	/* __ISpObjectWithToken_FWD_DEFINED__ */


#ifndef __ISpResourceManager_FWD_DEFINED__
#define __ISpResourceManager_FWD_DEFINED__
typedef interface ISpResourceManager ISpResourceManager;
#endif 	/* __ISpResourceManager_FWD_DEFINED__ */


#ifndef __ISpEventSource_FWD_DEFINED__
#define __ISpEventSource_FWD_DEFINED__
typedef interface ISpEventSource ISpEventSource;
#endif 	/* __ISpEventSource_FWD_DEFINED__ */


#ifndef __ISpEventSink_FWD_DEFINED__
#define __ISpEventSink_FWD_DEFINED__
typedef interface ISpEventSink ISpEventSink;
#endif 	/* __ISpEventSink_FWD_DEFINED__ */


#ifndef __ISpStreamFormat_FWD_DEFINED__
#define __ISpStreamFormat_FWD_DEFINED__
typedef interface ISpStreamFormat ISpStreamFormat;
#endif 	/* __ISpStreamFormat_FWD_DEFINED__ */


#ifndef __ISpStream_FWD_DEFINED__
#define __ISpStream_FWD_DEFINED__
typedef interface ISpStream ISpStream;
#endif 	/* __ISpStream_FWD_DEFINED__ */


#ifndef __ISpStreamFormatConverter_FWD_DEFINED__
#define __ISpStreamFormatConverter_FWD_DEFINED__
typedef interface ISpStreamFormatConverter ISpStreamFormatConverter;
#endif 	/* __ISpStreamFormatConverter_FWD_DEFINED__ */


#ifndef __ISpAudio_FWD_DEFINED__
#define __ISpAudio_FWD_DEFINED__
typedef interface ISpAudio ISpAudio;
#endif 	/* __ISpAudio_FWD_DEFINED__ */


#ifndef __ISpMMSysAudio_FWD_DEFINED__
#define __ISpMMSysAudio_FWD_DEFINED__
typedef interface ISpMMSysAudio ISpMMSysAudio;
#endif 	/* __ISpMMSysAudio_FWD_DEFINED__ */


#ifndef __ISpTranscript_FWD_DEFINED__
#define __ISpTranscript_FWD_DEFINED__
typedef interface ISpTranscript ISpTranscript;
#endif 	/* __ISpTranscript_FWD_DEFINED__ */


#ifndef __ISpLexicon_FWD_DEFINED__
#define __ISpLexicon_FWD_DEFINED__
typedef interface ISpLexicon ISpLexicon;
#endif 	/* __ISpLexicon_FWD_DEFINED__ */


#ifndef __ISpContainerLexicon_FWD_DEFINED__
#define __ISpContainerLexicon_FWD_DEFINED__
typedef interface ISpContainerLexicon ISpContainerLexicon;
#endif 	/* __ISpContainerLexicon_FWD_DEFINED__ */


#ifndef __ISpPhoneConverter_FWD_DEFINED__
#define __ISpPhoneConverter_FWD_DEFINED__
typedef interface ISpPhoneConverter ISpPhoneConverter;
#endif 	/* __ISpPhoneConverter_FWD_DEFINED__ */


#ifndef __ISpVoice_FWD_DEFINED__
#define __ISpVoice_FWD_DEFINED__
typedef interface ISpVoice ISpVoice;
#endif 	/* __ISpVoice_FWD_DEFINED__ */


#ifndef __ISpPhrase_FWD_DEFINED__
#define __ISpPhrase_FWD_DEFINED__
typedef interface ISpPhrase ISpPhrase;
#endif 	/* __ISpPhrase_FWD_DEFINED__ */


#ifndef __ISpPhraseAlt_FWD_DEFINED__
#define __ISpPhraseAlt_FWD_DEFINED__
typedef interface ISpPhraseAlt ISpPhraseAlt;
#endif 	/* __ISpPhraseAlt_FWD_DEFINED__ */


#ifndef __ISpRecoResult_FWD_DEFINED__
#define __ISpRecoResult_FWD_DEFINED__
typedef interface ISpRecoResult ISpRecoResult;
#endif 	/* __ISpRecoResult_FWD_DEFINED__ */


#ifndef __ISpGrammarBuilder_FWD_DEFINED__
#define __ISpGrammarBuilder_FWD_DEFINED__
typedef interface ISpGrammarBuilder ISpGrammarBuilder;
#endif 	/* __ISpGrammarBuilder_FWD_DEFINED__ */


#ifndef __ISpRecoGrammar_FWD_DEFINED__
#define __ISpRecoGrammar_FWD_DEFINED__
typedef interface ISpRecoGrammar ISpRecoGrammar;
#endif 	/* __ISpRecoGrammar_FWD_DEFINED__ */


#ifndef __ISpRecoContext_FWD_DEFINED__
#define __ISpRecoContext_FWD_DEFINED__
typedef interface ISpRecoContext ISpRecoContext;
#endif 	/* __ISpRecoContext_FWD_DEFINED__ */


#ifndef __ISpProperties_FWD_DEFINED__
#define __ISpProperties_FWD_DEFINED__
typedef interface ISpProperties ISpProperties;
#endif 	/* __ISpProperties_FWD_DEFINED__ */


#ifndef __ISpRecognizer_FWD_DEFINED__
#define __ISpRecognizer_FWD_DEFINED__
typedef interface ISpRecognizer ISpRecognizer;
#endif 	/* __ISpRecognizer_FWD_DEFINED__ */


#ifndef __SpNotifyTranslator_FWD_DEFINED__
#define __SpNotifyTranslator_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpNotifyTranslator SpNotifyTranslator;
#else
typedef struct SpNotifyTranslator SpNotifyTranslator;
#endif /* __cplusplus */

#endif 	/* __SpNotifyTranslator_FWD_DEFINED__ */


#ifndef __SpObjectTokenCategory_FWD_DEFINED__
#define __SpObjectTokenCategory_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpObjectTokenCategory SpObjectTokenCategory;
#else
typedef struct SpObjectTokenCategory SpObjectTokenCategory;
#endif /* __cplusplus */

#endif 	/* __SpObjectTokenCategory_FWD_DEFINED__ */


#ifndef __SpObjectToken_FWD_DEFINED__
#define __SpObjectToken_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpObjectToken SpObjectToken;
#else
typedef struct SpObjectToken SpObjectToken;
#endif /* __cplusplus */

#endif 	/* __SpObjectToken_FWD_DEFINED__ */


#ifndef __SpResourceManager_FWD_DEFINED__
#define __SpResourceManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpResourceManager SpResourceManager;
#else
typedef struct SpResourceManager SpResourceManager;
#endif /* __cplusplus */

#endif 	/* __SpResourceManager_FWD_DEFINED__ */


#ifndef __SpStreamFormatConverter_FWD_DEFINED__
#define __SpStreamFormatConverter_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpStreamFormatConverter SpStreamFormatConverter;
#else
typedef struct SpStreamFormatConverter SpStreamFormatConverter;
#endif /* __cplusplus */

#endif 	/* __SpStreamFormatConverter_FWD_DEFINED__ */


#ifndef __SpMMAudioEnum_FWD_DEFINED__
#define __SpMMAudioEnum_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpMMAudioEnum SpMMAudioEnum;
#else
typedef struct SpMMAudioEnum SpMMAudioEnum;
#endif /* __cplusplus */

#endif 	/* __SpMMAudioEnum_FWD_DEFINED__ */


#ifndef __SpMMAudioIn_FWD_DEFINED__
#define __SpMMAudioIn_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpMMAudioIn SpMMAudioIn;
#else
typedef struct SpMMAudioIn SpMMAudioIn;
#endif /* __cplusplus */

#endif 	/* __SpMMAudioIn_FWD_DEFINED__ */


#ifndef __SpMMAudioOut_FWD_DEFINED__
#define __SpMMAudioOut_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpMMAudioOut SpMMAudioOut;
#else
typedef struct SpMMAudioOut SpMMAudioOut;
#endif /* __cplusplus */

#endif 	/* __SpMMAudioOut_FWD_DEFINED__ */


#ifndef __SpRecPlayAudio_FWD_DEFINED__
#define __SpRecPlayAudio_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpRecPlayAudio SpRecPlayAudio;
#else
typedef struct SpRecPlayAudio SpRecPlayAudio;
#endif /* __cplusplus */

#endif 	/* __SpRecPlayAudio_FWD_DEFINED__ */


#ifndef __SpStream_FWD_DEFINED__
#define __SpStream_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpStream SpStream;
#else
typedef struct SpStream SpStream;
#endif /* __cplusplus */

#endif 	/* __SpStream_FWD_DEFINED__ */


#ifndef __SpVoice_FWD_DEFINED__
#define __SpVoice_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpVoice SpVoice;
#else
typedef struct SpVoice SpVoice;
#endif /* __cplusplus */

#endif 	/* __SpVoice_FWD_DEFINED__ */


#ifndef __SpSharedRecoContext_FWD_DEFINED__
#define __SpSharedRecoContext_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpSharedRecoContext SpSharedRecoContext;
#else
typedef struct SpSharedRecoContext SpSharedRecoContext;
#endif /* __cplusplus */

#endif 	/* __SpSharedRecoContext_FWD_DEFINED__ */


#ifndef __SpInprocRecognizer_FWD_DEFINED__
#define __SpInprocRecognizer_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpInprocRecognizer SpInprocRecognizer;
#else
typedef struct SpInprocRecognizer SpInprocRecognizer;
#endif /* __cplusplus */

#endif 	/* __SpInprocRecognizer_FWD_DEFINED__ */


#ifndef __SpSharedRecognizer_FWD_DEFINED__
#define __SpSharedRecognizer_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpSharedRecognizer SpSharedRecognizer;
#else
typedef struct SpSharedRecognizer SpSharedRecognizer;
#endif /* __cplusplus */

#endif 	/* __SpSharedRecognizer_FWD_DEFINED__ */


#ifndef __SpLexicon_FWD_DEFINED__
#define __SpLexicon_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpLexicon SpLexicon;
#else
typedef struct SpLexicon SpLexicon;
#endif /* __cplusplus */

#endif 	/* __SpLexicon_FWD_DEFINED__ */


#ifndef __SpUnCompressedLexicon_FWD_DEFINED__
#define __SpUnCompressedLexicon_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpUnCompressedLexicon SpUnCompressedLexicon;
#else
typedef struct SpUnCompressedLexicon SpUnCompressedLexicon;
#endif /* __cplusplus */

#endif 	/* __SpUnCompressedLexicon_FWD_DEFINED__ */


#ifndef __SpCompressedLexicon_FWD_DEFINED__
#define __SpCompressedLexicon_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpCompressedLexicon SpCompressedLexicon;
#else
typedef struct SpCompressedLexicon SpCompressedLexicon;
#endif /* __cplusplus */

#endif 	/* __SpCompressedLexicon_FWD_DEFINED__ */


#ifndef __SpPhoneConverter_FWD_DEFINED__
#define __SpPhoneConverter_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpPhoneConverter SpPhoneConverter;
#else
typedef struct SpPhoneConverter SpPhoneConverter;
#endif /* __cplusplus */

#endif 	/* __SpPhoneConverter_FWD_DEFINED__ */


#ifndef __SpNullPhoneConverter_FWD_DEFINED__
#define __SpNullPhoneConverter_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpNullPhoneConverter SpNullPhoneConverter;
#else
typedef struct SpNullPhoneConverter SpNullPhoneConverter;
#endif /* __cplusplus */

#endif 	/* __SpNullPhoneConverter_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_sapi_0000 */
/* [local] */ 

#ifndef MAXULONG_PTR
#error SAPI 5 requires a newer version of the Platform SDK than you have installed.
#endif // MAXULONG_PTR

#pragma warning(disable:4201) // Allow nameless structs/unions
#pragma comment(lib, "sapi.lib")
#if 0
typedef /* [restricted] */ struct WAVEFORMATEX
    {
    WORD wFormatTag;
    WORD nChannels;
    DWORD nSamplesPerSec;
    DWORD nAvgBytesPerSec;
    WORD nBlockAlign;
    WORD wBitsPerSample;
    WORD cbSize;
    } 	WAVEFORMATEX;

#else
#include <mmsystem.h>
#endif

























typedef 
enum SPDATAKEYLOCATION
    {	SPDKL_DefaultLocation	= 0,
	SPDKL_CurrentUser	= 1,
	SPDKL_LocalMachine	= 2,
	SPDKL_CurrentConfig	= 5
    } 	SPDATAKEYLOCATION;

#define SPDUI_EngineProperties   L"EngineProperties"
#define SPDUI_AddRemoveWord      L"AddRemoveWord"
#define SPDUI_UserTraining       L"UserTraining"
#define SPDUI_MicTraining        L"MicTraining"
#define SPDUI_RecoProfileProperties L"RecoProfileProperties"
#define SPDUI_AudioProperties    L"AudioProperties"
#define SPDUI_AudioVolume        L"AudioVolume"
EXTERN_C const GUID SID_SpTaskManager;
typedef 
enum SPSTREAMFORMAT
    {	SPSF_Default	= -1,
	SPSF_NoAssignedFormat	= 0,
	SPSF_Text	= SPSF_NoAssignedFormat + 1,
	SPSF_NonStandardFormat	= SPSF_Text + 1,
	SPSF_ExtendedAudioFormat	= SPSF_NonStandardFormat + 1,
	SPSF_8kHz8BitMono	= SPSF_ExtendedAudioFormat + 1,
	SPSF_8kHz8BitStereo	= SPSF_8kHz8BitMono + 1,
	SPSF_8kHz16BitMono	= SPSF_8kHz8BitStereo + 1,
	SPSF_8kHz16BitStereo	= SPSF_8kHz16BitMono + 1,
	SPSF_11kHz8BitMono	= SPSF_8kHz16BitStereo + 1,
	SPSF_11kHz8BitStereo	= SPSF_11kHz8BitMono + 1,
	SPSF_11kHz16BitMono	= SPSF_11kHz8BitStereo + 1,
	SPSF_11kHz16BitStereo	= SPSF_11kHz16BitMono + 1,
	SPSF_12kHz8BitMono	= SPSF_11kHz16BitStereo + 1,
	SPSF_12kHz8BitStereo	= SPSF_12kHz8BitMono + 1,
	SPSF_12kHz16BitMono	= SPSF_12kHz8BitStereo + 1,
	SPSF_12kHz16BitStereo	= SPSF_12kHz16BitMono + 1,
	SPSF_16kHz8BitMono	= SPSF_12kHz16BitStereo + 1,
	SPSF_16kHz8BitStereo	= SPSF_16kHz8BitMono + 1,
	SPSF_16kHz16BitMono	= SPSF_16kHz8BitStereo + 1,
	SPSF_16kHz16BitStereo	= SPSF_16kHz16BitMono + 1,
	SPSF_22kHz8BitMono	= SPSF_16kHz16BitStereo + 1,
	SPSF_22kHz8BitStereo	= SPSF_22kHz8BitMono + 1,
	SPSF_22kHz16BitMono	= SPSF_22kHz8BitStereo + 1,
	SPSF_22kHz16BitStereo	= SPSF_22kHz16BitMono + 1,
	SPSF_24kHz8BitMono	= SPSF_22kHz16BitStereo + 1,
	SPSF_24kHz8BitStereo	= SPSF_24kHz8BitMono + 1,
	SPSF_24kHz16BitMono	= SPSF_24kHz8BitStereo + 1,
	SPSF_24kHz16BitStereo	= SPSF_24kHz16BitMono + 1,
	SPSF_32kHz8BitMono	= SPSF_24kHz16BitStereo + 1,
	SPSF_32kHz8BitStereo	= SPSF_32kHz8BitMono + 1,
	SPSF_32kHz16BitMono	= SPSF_32kHz8BitStereo + 1,
	SPSF_32kHz16BitStereo	= SPSF_32kHz16BitMono + 1,
	SPSF_44kHz8BitMono	= SPSF_32kHz16BitStereo + 1,
	SPSF_44kHz8BitStereo	= SPSF_44kHz8BitMono + 1,
	SPSF_44kHz16BitMono	= SPSF_44kHz8BitStereo + 1,
	SPSF_44kHz16BitStereo	= SPSF_44kHz16BitMono + 1,
	SPSF_48kHz8BitMono	= SPSF_44kHz16BitStereo + 1,
	SPSF_48kHz8BitStereo	= SPSF_48kHz8BitMono + 1,
	SPSF_48kHz16BitMono	= SPSF_48kHz8BitStereo + 1,
	SPSF_48kHz16BitStereo	= SPSF_48kHz16BitMono + 1,
	SPSF_TrueSpeech_8kHz1BitMono	= SPSF_48kHz16BitStereo + 1,
	SPSF_CCITT_ALaw_8kHzMono	= SPSF_TrueSpeech_8kHz1BitMono + 1,
	SPSF_CCITT_ALaw_8kHzStereo	= SPSF_CCITT_ALaw_8kHzMono + 1,
	SPSF_CCITT_ALaw_11kHzMono	= SPSF_CCITT_ALaw_8kHzStereo + 1,
	SPSF_CCITT_ALaw_11kHzStereo	= SPSF_CCITT_ALaw_11kHzMono + 1,
	SPSF_CCITT_ALaw_22kHzMono	= SPSF_CCITT_ALaw_11kHzStereo + 1,
	SPSF_CCITT_ALaw_22kHzStereo	= SPSF_CCITT_ALaw_22kHzMono + 1,
	SPSF_CCITT_ALaw_44kHzMono	= SPSF_CCITT_ALaw_22kHzStereo + 1,
	SPSF_CCITT_ALaw_44kHzStereo	= SPSF_CCITT_ALaw_44kHzMono + 1,
	SPSF_CCITT_uLaw_8kHzMono	= SPSF_CCITT_ALaw_44kHzStereo + 1,
	SPSF_CCITT_uLaw_8kHzStereo	= SPSF_CCITT_uLaw_8kHzMono + 1,
	SPSF_CCITT_uLaw_11kHzMono	= SPSF_CCITT_uLaw_8kHzStereo + 1,
	SPSF_CCITT_uLaw_11kHzStereo	= SPSF_CCITT_uLaw_11kHzMono + 1,
	SPSF_CCITT_uLaw_22kHzMono	= SPSF_CCITT_uLaw_11kHzStereo + 1,
	SPSF_CCITT_uLaw_22kHzStereo	= SPSF_CCITT_uLaw_22kHzMono + 1,
	SPSF_CCITT_uLaw_44kHzMono	= SPSF_CCITT_uLaw_22kHzStereo + 1,
	SPSF_CCITT_uLaw_44kHzStereo	= SPSF_CCITT_uLaw_44kHzMono + 1,
	SPSF_ADPCM_8kHzMono	= SPSF_CCITT_uLaw_44kHzStereo + 1,
	SPSF_ADPCM_8kHzStereo	= SPSF_ADPCM_8kHzMono + 1,
	SPSF_ADPCM_11kHzMono	= SPSF_ADPCM_8kHzStereo + 1,
	SPSF_ADPCM_11kHzStereo	= SPSF_ADPCM_11kHzMono + 1,
	SPSF_ADPCM_22kHzMono	= SPSF_ADPCM_11kHzStereo + 1,
	SPSF_ADPCM_22kHzStereo	= SPSF_ADPCM_22kHzMono + 1,
	SPSF_ADPCM_44kHzMono	= SPSF_ADPCM_22kHzStereo + 1,
	SPSF_ADPCM_44kHzStereo	= SPSF_ADPCM_44kHzMono + 1,
	SPSF_GSM610_8kHzMono	= SPSF_ADPCM_44kHzStereo + 1,
	SPSF_GSM610_11kHzMono	= SPSF_GSM610_8kHzMono + 1,
	SPSF_GSM610_22kHzMono	= SPSF_GSM610_11kHzMono + 1,
	SPSF_GSM610_44kHzMono	= SPSF_GSM610_22kHzMono + 1,
	SPSF_NUM_FORMATS	= SPSF_GSM610_44kHzMono + 1
    } 	SPSTREAMFORMAT;

EXTERN_C const GUID SPDFID_Text;
EXTERN_C const GUID SPDFID_WaveFormatEx;
#define SPREG_USER_ROOT          L"HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Speech"
#define SPREG_LOCAL_MACHINE_ROOT L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech"
#define SPCAT_AUDIOOUT         L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\AudioOutput"
#define SPCAT_AUDIOIN          L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\AudioInput"
#define SPCAT_VOICES           L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\Voices"
#define SPCAT_RECOGNIZERS      L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\Recognizers"
#define SPCAT_APPLEXICONS      L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\AppLexicons"
#define SPCAT_PHONECONVERTERS  L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\PhoneConverters"
#define SPCAT_NLPS             L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\NatLangProcs"
#define SPCAT_RECOPROFILES     L"HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Speech\\RecoProfiles"
#define SPMMSYS_AUDIO_IN_TOKEN_ID        L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\AudioInput\\TokenEnums\\MMAudioIn\\"
#define SPMMSYS_AUDIO_OUT_TOKEN_ID       L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\AudioOutput\\TokenEnums\\MMAudioOut\\"
#define SPCURRENT_USER_LEXICON_TOKEN_ID  L"HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Speech\\CurrentUserLexicon"
#define SPTOKENVALUE_CLSID L"CLSID"
#define SPVOICECATEGORY_TTSRATE L"DefaultTTSRate"
#define SPPROP_RESOURCE_USAGE              L"ResourceUsage"
#define SPPROP_HIGH_CONFIDENCE_THRESHOLD   L"HighConfidenceThreshold"
#define SPPROP_NORMAL_CONFIDENCE_THRESHOLD L"NormalConfidenceThreshold"
#define SPPROP_LOW_CONFIDENCE_THRESHOLD    L"LowConfidenceThreshold"
#define SPPROP_RESPONSE_SPEED              L"ResponseSpeed"
#define SPPROP_COMPLEX_RESPONSE_SPEED      L"ComplexResponseSpeed"
#define SPPROP_ADAPTATION_ON               L"AdaptationOn"
#define SPTOPIC_SPELLING L"Spelling"
#define SPWILDCARD L"..."
#define SPDICTATION    L"*"
#define SPINFDICTATION L"*+"
#define	SP_LOW_CONFIDENCE	( -1 )

#define	SP_NORMAL_CONFIDENCE	( 0 )

#define	SP_HIGH_CONFIDENCE	( +1 )

#define	DEFAULT_WEIGHT	( 1 )

#define	SP_MAX_WORD_LENGTH	( 128 )

#define	SP_MAX_PRON_LENGTH	( 384 )

#if defined(__cplusplus)
interface ISpNotifyCallback
{
virtual HRESULT STDMETHODCALLTYPE NotifyCallback(
                                     WPARAM wParam,
                                     LPARAM lParam) = 0;
};
#else
typedef void *ISpNotifyCallback;

#endif
typedef void __stdcall __stdcall SPNOTIFYCALLBACK( 
    WPARAM wParam,
    LPARAM lParam);



extern RPC_IF_HANDLE __MIDL_itf_sapi_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sapi_0000_v0_0_s_ifspec;

#ifndef __ISpNotifySource_INTERFACE_DEFINED__
#define __ISpNotifySource_INTERFACE_DEFINED__

/* interface ISpNotifySource */
/* [restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISpNotifySource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5EFF4AEF-8487-11D2-961C-00C04F8EE628")
    ISpNotifySource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetNotifySink( 
            /* [in] */ ISpNotifySink *pNotifySink) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetNotifyWindowMessage( 
            /* [in] */ HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetNotifyCallbackFunction( 
            /* [in] */ SPNOTIFYCALLBACK *pfnCallback,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetNotifyCallbackInterface( 
            /* [in] */ ISpNotifyCallback *pSpCallback,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetNotifyWin32Event( void) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE WaitForNotifyEvent( 
            /* [in] */ DWORD dwMilliseconds) = 0;
        
        virtual /* [local] */ HANDLE STDMETHODCALLTYPE GetNotifyEventHandle( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpNotifySourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpNotifySource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpNotifySource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpNotifySource * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetNotifySink )( 
            ISpNotifySource * This,
            /* [in] */ ISpNotifySink *pNotifySink);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetNotifyWindowMessage )( 
            ISpNotifySource * This,
            /* [in] */ HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetNotifyCallbackFunction )( 
            ISpNotifySource * This,
            /* [in] */ SPNOTIFYCALLBACK *pfnCallback,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetNotifyCallbackInterface )( 
            ISpNotifySource * This,
            /* [in] */ ISpNotifyCallback *pSpCallback,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetNotifyWin32Event )( 
            ISpNotifySource * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *WaitForNotifyEvent )( 
            ISpNotifySource * This,
            /* [in] */ DWORD dwMilliseconds);
        
        /* [local] */ HANDLE ( STDMETHODCALLTYPE *GetNotifyEventHandle )( 
            ISpNotifySource * This);
        
        END_INTERFACE
    } ISpNotifySourceVtbl;

    interface ISpNotifySource
    {
        CONST_VTBL struct ISpNotifySourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpNotifySource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpNotifySource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpNotifySource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpNotifySource_SetNotifySink(This,pNotifySink)	\
    (This)->lpVtbl -> SetNotifySink(This,pNotifySink)

#define ISpNotifySource_SetNotifyWindowMessage(This,hWnd,Msg,wParam,lParam)	\
    (This)->lpVtbl -> SetNotifyWindowMessage(This,hWnd,Msg,wParam,lParam)

#define ISpNotifySource_SetNotifyCallbackFunction(This,pfnCallback,wParam,lParam)	\
    (This)->lpVtbl -> SetNotifyCallbackFunction(This,pfnCallback,wParam,lParam)

#define ISpNotifySource_SetNotifyCallbackInterface(This,pSpCallback,wParam,lParam)	\
    (This)->lpVtbl -> SetNotifyCallbackInterface(This,pSpCallback,wParam,lParam)

#define ISpNotifySource_SetNotifyWin32Event(This)	\
    (This)->lpVtbl -> SetNotifyWin32Event(This)

#define ISpNotifySource_WaitForNotifyEvent(This,dwMilliseconds)	\
    (This)->lpVtbl -> WaitForNotifyEvent(This,dwMilliseconds)

#define ISpNotifySource_GetNotifyEventHandle(This)	\
    (This)->lpVtbl -> GetNotifyEventHandle(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpNotifySource_SetNotifySink_Proxy( 
    ISpNotifySource * This,
    /* [in] */ ISpNotifySink *pNotifySink);


void __RPC_STUB ISpNotifySource_SetNotifySink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE ISpNotifySource_SetNotifyWindowMessage_Proxy( 
    ISpNotifySource * This,
    /* [in] */ HWND hWnd,
    /* [in] */ UINT Msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB ISpNotifySource_SetNotifyWindowMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE ISpNotifySource_SetNotifyCallbackFunction_Proxy( 
    ISpNotifySource * This,
    /* [in] */ SPNOTIFYCALLBACK *pfnCallback,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB ISpNotifySource_SetNotifyCallbackFunction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE ISpNotifySource_SetNotifyCallbackInterface_Proxy( 
    ISpNotifySource * This,
    /* [in] */ ISpNotifyCallback *pSpCallback,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB ISpNotifySource_SetNotifyCallbackInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE ISpNotifySource_SetNotifyWin32Event_Proxy( 
    ISpNotifySource * This);


void __RPC_STUB ISpNotifySource_SetNotifyWin32Event_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE ISpNotifySource_WaitForNotifyEvent_Proxy( 
    ISpNotifySource * This,
    /* [in] */ DWORD dwMilliseconds);


void __RPC_STUB ISpNotifySource_WaitForNotifyEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HANDLE STDMETHODCALLTYPE ISpNotifySource_GetNotifyEventHandle_Proxy( 
    ISpNotifySource * This);


void __RPC_STUB ISpNotifySource_GetNotifyEventHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpNotifySource_INTERFACE_DEFINED__ */


#ifndef __ISpNotifySink_INTERFACE_DEFINED__
#define __ISpNotifySink_INTERFACE_DEFINED__

/* interface ISpNotifySink */
/* [restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISpNotifySink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("259684DC-37C3-11D2-9603-00C04F8EE628")
    ISpNotifySink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Notify( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpNotifySinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpNotifySink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpNotifySink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpNotifySink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            ISpNotifySink * This);
        
        END_INTERFACE
    } ISpNotifySinkVtbl;

    interface ISpNotifySink
    {
        CONST_VTBL struct ISpNotifySinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpNotifySink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpNotifySink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpNotifySink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpNotifySink_Notify(This)	\
    (This)->lpVtbl -> Notify(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpNotifySink_Notify_Proxy( 
    ISpNotifySink * This);


void __RPC_STUB ISpNotifySink_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpNotifySink_INTERFACE_DEFINED__ */


#ifndef __ISpNotifyTranslator_INTERFACE_DEFINED__
#define __ISpNotifyTranslator_INTERFACE_DEFINED__

/* interface ISpNotifyTranslator */
/* [restricted][local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISpNotifyTranslator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ACA16614-5D3D-11D2-960E-00C04F8EE628")
    ISpNotifyTranslator : public ISpNotifySink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitWindowMessage( 
            /* [in] */ HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitCallback( 
            /* [in] */ SPNOTIFYCALLBACK *pfnCallback,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitSpNotifyCallback( 
            /* [in] */ ISpNotifyCallback *pSpCallback,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitWin32Event( 
            HANDLE hEvent,
            BOOL fCloseHandleOnRelease) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Wait( 
            /* [in] */ DWORD dwMilliseconds) = 0;
        
        virtual HANDLE STDMETHODCALLTYPE GetEventHandle( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpNotifyTranslatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpNotifyTranslator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpNotifyTranslator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpNotifyTranslator * This);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            ISpNotifyTranslator * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitWindowMessage )( 
            ISpNotifyTranslator * This,
            /* [in] */ HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *InitCallback )( 
            ISpNotifyTranslator * This,
            /* [in] */ SPNOTIFYCALLBACK *pfnCallback,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *InitSpNotifyCallback )( 
            ISpNotifyTranslator * This,
            /* [in] */ ISpNotifyCallback *pSpCallback,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *InitWin32Event )( 
            ISpNotifyTranslator * This,
            HANDLE hEvent,
            BOOL fCloseHandleOnRelease);
        
        HRESULT ( STDMETHODCALLTYPE *Wait )( 
            ISpNotifyTranslator * This,
            /* [in] */ DWORD dwMilliseconds);
        
        HANDLE ( STDMETHODCALLTYPE *GetEventHandle )( 
            ISpNotifyTranslator * This);
        
        END_INTERFACE
    } ISpNotifyTranslatorVtbl;

    interface ISpNotifyTranslator
    {
        CONST_VTBL struct ISpNotifyTranslatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpNotifyTranslator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpNotifyTranslator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpNotifyTranslator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpNotifyTranslator_Notify(This)	\
    (This)->lpVtbl -> Notify(This)


#define ISpNotifyTranslator_InitWindowMessage(This,hWnd,Msg,wParam,lParam)	\
    (This)->lpVtbl -> InitWindowMessage(This,hWnd,Msg,wParam,lParam)

#define ISpNotifyTranslator_InitCallback(This,pfnCallback,wParam,lParam)	\
    (This)->lpVtbl -> InitCallback(This,pfnCallback,wParam,lParam)

#define ISpNotifyTranslator_InitSpNotifyCallback(This,pSpCallback,wParam,lParam)	\
    (This)->lpVtbl -> InitSpNotifyCallback(This,pSpCallback,wParam,lParam)

#define ISpNotifyTranslator_InitWin32Event(This,hEvent,fCloseHandleOnRelease)	\
    (This)->lpVtbl -> InitWin32Event(This,hEvent,fCloseHandleOnRelease)

#define ISpNotifyTranslator_Wait(This,dwMilliseconds)	\
    (This)->lpVtbl -> Wait(This,dwMilliseconds)

#define ISpNotifyTranslator_GetEventHandle(This)	\
    (This)->lpVtbl -> GetEventHandle(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpNotifyTranslator_InitWindowMessage_Proxy( 
    ISpNotifyTranslator * This,
    /* [in] */ HWND hWnd,
    /* [in] */ UINT Msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB ISpNotifyTranslator_InitWindowMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpNotifyTranslator_InitCallback_Proxy( 
    ISpNotifyTranslator * This,
    /* [in] */ SPNOTIFYCALLBACK *pfnCallback,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB ISpNotifyTranslator_InitCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpNotifyTranslator_InitSpNotifyCallback_Proxy( 
    ISpNotifyTranslator * This,
    /* [in] */ ISpNotifyCallback *pSpCallback,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB ISpNotifyTranslator_InitSpNotifyCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpNotifyTranslator_InitWin32Event_Proxy( 
    ISpNotifyTranslator * This,
    HANDLE hEvent,
    BOOL fCloseHandleOnRelease);


void __RPC_STUB ISpNotifyTranslator_InitWin32Event_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpNotifyTranslator_Wait_Proxy( 
    ISpNotifyTranslator * This,
    /* [in] */ DWORD dwMilliseconds);


void __RPC_STUB ISpNotifyTranslator_Wait_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HANDLE STDMETHODCALLTYPE ISpNotifyTranslator_GetEventHandle_Proxy( 
    ISpNotifyTranslator * This);


void __RPC_STUB ISpNotifyTranslator_GetEventHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpNotifyTranslator_INTERFACE_DEFINED__ */


#ifndef __ISpDataKey_INTERFACE_DEFINED__
#define __ISpDataKey_INTERFACE_DEFINED__

/* interface ISpDataKey */
/* [restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISpDataKey;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("14056581-E16C-11D2-BB90-00C04F8EE6C0")
    ISpDataKey : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetData( 
            const WCHAR *pszValueName,
            ULONG cbData,
            const BYTE *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetData( 
            const WCHAR *pszValueName,
            ULONG *pcbData,
            BYTE *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStringValue( 
            const WCHAR *pszValueName,
            const WCHAR *pszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStringValue( 
            const WCHAR *pszValueName,
            WCHAR **ppszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDWORD( 
            const WCHAR *pszKeyName,
            DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDWORD( 
            const WCHAR *pszKeyName,
            DWORD *pdwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenKey( 
            const WCHAR *pszSubKeyName,
            ISpDataKey **ppSubKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateKey( 
            const WCHAR *pszSubKey,
            ISpDataKey **ppSubKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteKey( 
            const WCHAR *pszSubKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteValue( 
            const WCHAR *pszValueName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumKeys( 
            ULONG Index,
            WCHAR **ppszSubKeyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumValues( 
            ULONG Index,
            WCHAR **ppszValueName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpDataKeyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpDataKey * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpDataKey * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpDataKey * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetData )( 
            ISpDataKey * This,
            const WCHAR *pszValueName,
            ULONG cbData,
            const BYTE *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetData )( 
            ISpDataKey * This,
            const WCHAR *pszValueName,
            ULONG *pcbData,
            BYTE *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetStringValue )( 
            ISpDataKey * This,
            const WCHAR *pszValueName,
            const WCHAR *pszValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringValue )( 
            ISpDataKey * This,
            const WCHAR *pszValueName,
            WCHAR **ppszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetDWORD )( 
            ISpDataKey * This,
            const WCHAR *pszKeyName,
            DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetDWORD )( 
            ISpDataKey * This,
            const WCHAR *pszKeyName,
            DWORD *pdwValue);
        
        HRESULT ( STDMETHODCALLTYPE *OpenKey )( 
            ISpDataKey * This,
            const WCHAR *pszSubKeyName,
            ISpDataKey **ppSubKey);
        
        HRESULT ( STDMETHODCALLTYPE *CreateKey )( 
            ISpDataKey * This,
            const WCHAR *pszSubKey,
            ISpDataKey **ppSubKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteKey )( 
            ISpDataKey * This,
            const WCHAR *pszSubKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteValue )( 
            ISpDataKey * This,
            const WCHAR *pszValueName);
        
        HRESULT ( STDMETHODCALLTYPE *EnumKeys )( 
            ISpDataKey * This,
            ULONG Index,
            WCHAR **ppszSubKeyName);
        
        HRESULT ( STDMETHODCALLTYPE *EnumValues )( 
            ISpDataKey * This,
            ULONG Index,
            WCHAR **ppszValueName);
        
        END_INTERFACE
    } ISpDataKeyVtbl;

    interface ISpDataKey
    {
        CONST_VTBL struct ISpDataKeyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpDataKey_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpDataKey_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpDataKey_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpDataKey_SetData(This,pszValueName,cbData,pData)	\
    (This)->lpVtbl -> SetData(This,pszValueName,cbData,pData)

#define ISpDataKey_GetData(This,pszValueName,pcbData,pData)	\
    (This)->lpVtbl -> GetData(This,pszValueName,pcbData,pData)

#define ISpDataKey_SetStringValue(This,pszValueName,pszValue)	\
    (This)->lpVtbl -> SetStringValue(This,pszValueName,pszValue)

#define ISpDataKey_GetStringValue(This,pszValueName,ppszValue)	\
    (This)->lpVtbl -> GetStringValue(This,pszValueName,ppszValue)

#define ISpDataKey_SetDWORD(This,pszKeyName,dwValue)	\
    (This)->lpVtbl -> SetDWORD(This,pszKeyName,dwValue)

#define ISpDataKey_GetDWORD(This,pszKeyName,pdwValue)	\
    (This)->lpVtbl -> GetDWORD(This,pszKeyName,pdwValue)

#define ISpDataKey_OpenKey(This,pszSubKeyName,ppSubKey)	\
    (This)->lpVtbl -> OpenKey(This,pszSubKeyName,ppSubKey)

#define ISpDataKey_CreateKey(This,pszSubKey,ppSubKey)	\
    (This)->lpVtbl -> CreateKey(This,pszSubKey,ppSubKey)

#define ISpDataKey_DeleteKey(This,pszSubKey)	\
    (This)->lpVtbl -> DeleteKey(This,pszSubKey)

#define ISpDataKey_DeleteValue(This,pszValueName)	\
    (This)->lpVtbl -> DeleteValue(This,pszValueName)

#define ISpDataKey_EnumKeys(This,Index,ppszSubKeyName)	\
    (This)->lpVtbl -> EnumKeys(This,Index,ppszSubKeyName)

#define ISpDataKey_EnumValues(This,Index,ppszValueName)	\
    (This)->lpVtbl -> EnumValues(This,Index,ppszValueName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpDataKey_SetData_Proxy( 
    ISpDataKey * This,
    const WCHAR *pszValueName,
    ULONG cbData,
    const BYTE *pData);


void __RPC_STUB ISpDataKey_SetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpDataKey_GetData_Proxy( 
    ISpDataKey * This,
    const WCHAR *pszValueName,
    ULONG *pcbData,
    BYTE *pData);


void __RPC_STUB ISpDataKey_GetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpDataKey_SetStringValue_Proxy( 
    ISpDataKey * This,
    const WCHAR *pszValueName,
    const WCHAR *pszValue);


void __RPC_STUB ISpDataKey_SetStringValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpDataKey_GetStringValue_Proxy( 
    ISpDataKey * This,
    const WCHAR *pszValueName,
    WCHAR **ppszValue);


void __RPC_STUB ISpDataKey_GetStringValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpDataKey_SetDWORD_Proxy( 
    ISpDataKey * This,
    const WCHAR *pszKeyName,
    DWORD dwValue);


void __RPC_STUB ISpDataKey_SetDWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpDataKey_GetDWORD_Proxy( 
    ISpDataKey * This,
    const WCHAR *pszKeyName,
    DWORD *pdwValue);


void __RPC_STUB ISpDataKey_GetDWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpDataKey_OpenKey_Proxy( 
    ISpDataKey * This,
    const WCHAR *pszSubKeyName,
    ISpDataKey **ppSubKey);


void __RPC_STUB ISpDataKey_OpenKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpDataKey_CreateKey_Proxy( 
    ISpDataKey * This,
    const WCHAR *pszSubKey,
    ISpDataKey **ppSubKey);


void __RPC_STUB ISpDataKey_CreateKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpDataKey_DeleteKey_Proxy( 
    ISpDataKey * This,
    const WCHAR *pszSubKey);


void __RPC_STUB ISpDataKey_DeleteKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpDataKey_DeleteValue_Proxy( 
    ISpDataKey * This,
    const WCHAR *pszValueName);


void __RPC_STUB ISpDataKey_DeleteValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpDataKey_EnumKeys_Proxy( 
    ISpDataKey * This,
    ULONG Index,
    WCHAR **ppszSubKeyName);


void __RPC_STUB ISpDataKey_EnumKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpDataKey_EnumValues_Proxy( 
    ISpDataKey * This,
    ULONG Index,
    WCHAR **ppszValueName);


void __RPC_STUB ISpDataKey_EnumValues_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpDataKey_INTERFACE_DEFINED__ */


#ifndef __ISpRegDataKey_INTERFACE_DEFINED__
#define __ISpRegDataKey_INTERFACE_DEFINED__

/* interface ISpRegDataKey */
/* [restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISpRegDataKey;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("92A66E2B-C830-4149-83DF-6FC2BA1E7A5B")
    ISpRegDataKey : public ISpDataKey
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetKey( 
            /* [in] */ HKEY hkey,
            /* [in] */ BOOL fReadOnly) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpRegDataKeyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpRegDataKey * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpRegDataKey * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpRegDataKey * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetData )( 
            ISpRegDataKey * This,
            const WCHAR *pszValueName,
            ULONG cbData,
            const BYTE *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetData )( 
            ISpRegDataKey * This,
            const WCHAR *pszValueName,
            ULONG *pcbData,
            BYTE *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetStringValue )( 
            ISpRegDataKey * This,
            const WCHAR *pszValueName,
            const WCHAR *pszValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringValue )( 
            ISpRegDataKey * This,
            const WCHAR *pszValueName,
            WCHAR **ppszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetDWORD )( 
            ISpRegDataKey * This,
            const WCHAR *pszKeyName,
            DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetDWORD )( 
            ISpRegDataKey * This,
            const WCHAR *pszKeyName,
            DWORD *pdwValue);
        
        HRESULT ( STDMETHODCALLTYPE *OpenKey )( 
            ISpRegDataKey * This,
            const WCHAR *pszSubKeyName,
            ISpDataKey **ppSubKey);
        
        HRESULT ( STDMETHODCALLTYPE *CreateKey )( 
            ISpRegDataKey * This,
            const WCHAR *pszSubKey,
            ISpDataKey **ppSubKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteKey )( 
            ISpRegDataKey * This,
            const WCHAR *pszSubKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteValue )( 
            ISpRegDataKey * This,
            const WCHAR *pszValueName);
        
        HRESULT ( STDMETHODCALLTYPE *EnumKeys )( 
            ISpRegDataKey * This,
            ULONG Index,
            WCHAR **ppszSubKeyName);
        
        HRESULT ( STDMETHODCALLTYPE *EnumValues )( 
            ISpRegDataKey * This,
            ULONG Index,
            WCHAR **ppszValueName);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetKey )( 
            ISpRegDataKey * This,
            /* [in] */ HKEY hkey,
            /* [in] */ BOOL fReadOnly);
        
        END_INTERFACE
    } ISpRegDataKeyVtbl;

    interface ISpRegDataKey
    {
        CONST_VTBL struct ISpRegDataKeyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpRegDataKey_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpRegDataKey_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpRegDataKey_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpRegDataKey_SetData(This,pszValueName,cbData,pData)	\
    (This)->lpVtbl -> SetData(This,pszValueName,cbData,pData)

#define ISpRegDataKey_GetData(This,pszValueName,pcbData,pData)	\
    (This)->lpVtbl -> GetData(This,pszValueName,pcbData,pData)

#define ISpRegDataKey_SetStringValue(This,pszValueName,pszValue)	\
    (This)->lpVtbl -> SetStringValue(This,pszValueName,pszValue)

#define ISpRegDataKey_GetStringValue(This,pszValueName,ppszValue)	\
    (This)->lpVtbl -> GetStringValue(This,pszValueName,ppszValue)

#define ISpRegDataKey_SetDWORD(This,pszKeyName,dwValue)	\
    (This)->lpVtbl -> SetDWORD(This,pszKeyName,dwValue)

#define ISpRegDataKey_GetDWORD(This,pszKeyName,pdwValue)	\
    (This)->lpVtbl -> GetDWORD(This,pszKeyName,pdwValue)

#define ISpRegDataKey_OpenKey(This,pszSubKeyName,ppSubKey)	\
    (This)->lpVtbl -> OpenKey(This,pszSubKeyName,ppSubKey)

#define ISpRegDataKey_CreateKey(This,pszSubKey,ppSubKey)	\
    (This)->lpVtbl -> CreateKey(This,pszSubKey,ppSubKey)

#define ISpRegDataKey_DeleteKey(This,pszSubKey)	\
    (This)->lpVtbl -> DeleteKey(This,pszSubKey)

#define ISpRegDataKey_DeleteValue(This,pszValueName)	\
    (This)->lpVtbl -> DeleteValue(This,pszValueName)

#define ISpRegDataKey_EnumKeys(This,Index,ppszSubKeyName)	\
    (This)->lpVtbl -> EnumKeys(This,Index,ppszSubKeyName)

#define ISpRegDataKey_EnumValues(This,Index,ppszValueName)	\
    (This)->lpVtbl -> EnumValues(This,Index,ppszValueName)


#define ISpRegDataKey_SetKey(This,hkey,fReadOnly)	\
    (This)->lpVtbl -> SetKey(This,hkey,fReadOnly)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HRESULT STDMETHODCALLTYPE ISpRegDataKey_SetKey_Proxy( 
    ISpRegDataKey * This,
    /* [in] */ HKEY hkey,
    /* [in] */ BOOL fReadOnly);


void __RPC_STUB ISpRegDataKey_SetKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpRegDataKey_INTERFACE_DEFINED__ */


#ifndef __ISpObjectTokenCategory_INTERFACE_DEFINED__
#define __ISpObjectTokenCategory_INTERFACE_DEFINED__

/* interface ISpObjectTokenCategory */
/* [restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISpObjectTokenCategory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2D3D3845-39AF-4850-BBF9-40B49780011D")
    ISpObjectTokenCategory : public ISpDataKey
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetId( 
            /* [in] */ const WCHAR *pszCategoryId,
            BOOL fCreateIfNotExist) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetId( 
            /* [out] */ WCHAR **ppszCoMemCategoryId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataKey( 
            SPDATAKEYLOCATION spdkl,
            ISpDataKey **ppDataKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumTokens( 
            /* [string][in] */ const WCHAR *pzsReqAttribs,
            /* [string][in] */ const WCHAR *pszOptAttribs,
            /* [out] */ IEnumSpObjectTokens **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultTokenId( 
            /* [in] */ const WCHAR *pszTokenId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultTokenId( 
            /* [out] */ WCHAR **ppszCoMemTokenId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpObjectTokenCategoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpObjectTokenCategory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpObjectTokenCategory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpObjectTokenCategory * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetData )( 
            ISpObjectTokenCategory * This,
            const WCHAR *pszValueName,
            ULONG cbData,
            const BYTE *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetData )( 
            ISpObjectTokenCategory * This,
            const WCHAR *pszValueName,
            ULONG *pcbData,
            BYTE *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetStringValue )( 
            ISpObjectTokenCategory * This,
            const WCHAR *pszValueName,
            const WCHAR *pszValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringValue )( 
            ISpObjectTokenCategory * This,
            const WCHAR *pszValueName,
            WCHAR **ppszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetDWORD )( 
            ISpObjectTokenCategory * This,
            const WCHAR *pszKeyName,
            DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetDWORD )( 
            ISpObjectTokenCategory * This,
            const WCHAR *pszKeyName,
            DWORD *pdwValue);
        
        HRESULT ( STDMETHODCALLTYPE *OpenKey )( 
            ISpObjectTokenCategory * This,
            const WCHAR *pszSubKeyName,
            ISpDataKey **ppSubKey);
        
        HRESULT ( STDMETHODCALLTYPE *CreateKey )( 
            ISpObjectTokenCategory * This,
            const WCHAR *pszSubKey,
            ISpDataKey **ppSubKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteKey )( 
            ISpObjectTokenCategory * This,
            const WCHAR *pszSubKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteValue )( 
            ISpObjectTokenCategory * This,
            const WCHAR *pszValueName);
        
        HRESULT ( STDMETHODCALLTYPE *EnumKeys )( 
            ISpObjectTokenCategory * This,
            ULONG Index,
            WCHAR **ppszSubKeyName);
        
        HRESULT ( STDMETHODCALLTYPE *EnumValues )( 
            ISpObjectTokenCategory * This,
            ULONG Index,
            WCHAR **ppszValueName);
        
        HRESULT ( STDMETHODCALLTYPE *SetId )( 
            ISpObjectTokenCategory * This,
            /* [in] */ const WCHAR *pszCategoryId,
            BOOL fCreateIfNotExist);
        
        HRESULT ( STDMETHODCALLTYPE *GetId )( 
            ISpObjectTokenCategory * This,
            /* [out] */ WCHAR **ppszCoMemCategoryId);
        
        HRESULT ( STDMETHODCALLTYPE *GetDataKey )( 
            ISpObjectTokenCategory * This,
            SPDATAKEYLOCATION spdkl,
            ISpDataKey **ppDataKey);
        
        HRESULT ( STDMETHODCALLTYPE *EnumTokens )( 
            ISpObjectTokenCategory * This,
            /* [string][in] */ const WCHAR *pzsReqAttribs,
            /* [string][in] */ const WCHAR *pszOptAttribs,
            /* [out] */ IEnumSpObjectTokens **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultTokenId )( 
            ISpObjectTokenCategory * This,
            /* [in] */ const WCHAR *pszTokenId);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultTokenId )( 
            ISpObjectTokenCategory * This,
            /* [out] */ WCHAR **ppszCoMemTokenId);
        
        END_INTERFACE
    } ISpObjectTokenCategoryVtbl;

    interface ISpObjectTokenCategory
    {
        CONST_VTBL struct ISpObjectTokenCategoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpObjectTokenCategory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpObjectTokenCategory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpObjectTokenCategory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpObjectTokenCategory_SetData(This,pszValueName,cbData,pData)	\
    (This)->lpVtbl -> SetData(This,pszValueName,cbData,pData)

#define ISpObjectTokenCategory_GetData(This,pszValueName,pcbData,pData)	\
    (This)->lpVtbl -> GetData(This,pszValueName,pcbData,pData)

#define ISpObjectTokenCategory_SetStringValue(This,pszValueName,pszValue)	\
    (This)->lpVtbl -> SetStringValue(This,pszValueName,pszValue)

#define ISpObjectTokenCategory_GetStringValue(This,pszValueName,ppszValue)	\
    (This)->lpVtbl -> GetStringValue(This,pszValueName,ppszValue)

#define ISpObjectTokenCategory_SetDWORD(This,pszKeyName,dwValue)	\
    (This)->lpVtbl -> SetDWORD(This,pszKeyName,dwValue)

#define ISpObjectTokenCategory_GetDWORD(This,pszKeyName,pdwValue)	\
    (This)->lpVtbl -> GetDWORD(This,pszKeyName,pdwValue)

#define ISpObjectTokenCategory_OpenKey(This,pszSubKeyName,ppSubKey)	\
    (This)->lpVtbl -> OpenKey(This,pszSubKeyName,ppSubKey)

#define ISpObjectTokenCategory_CreateKey(This,pszSubKey,ppSubKey)	\
    (This)->lpVtbl -> CreateKey(This,pszSubKey,ppSubKey)

#define ISpObjectTokenCategory_DeleteKey(This,pszSubKey)	\
    (This)->lpVtbl -> DeleteKey(This,pszSubKey)

#define ISpObjectTokenCategory_DeleteValue(This,pszValueName)	\
    (This)->lpVtbl -> DeleteValue(This,pszValueName)

#define ISpObjectTokenCategory_EnumKeys(This,Index,ppszSubKeyName)	\
    (This)->lpVtbl -> EnumKeys(This,Index,ppszSubKeyName)

#define ISpObjectTokenCategory_EnumValues(This,Index,ppszValueName)	\
    (This)->lpVtbl -> EnumValues(This,Index,ppszValueName)


#define ISpObjectTokenCategory_SetId(This,pszCategoryId,fCreateIfNotExist)	\
    (This)->lpVtbl -> SetId(This,pszCategoryId,fCreateIfNotExist)

#define ISpObjectTokenCategory_GetId(This,ppszCoMemCategoryId)	\
    (This)->lpVtbl -> GetId(This,ppszCoMemCategoryId)

#define ISpObjectTokenCategory_GetDataKey(This,spdkl,ppDataKey)	\
    (This)->lpVtbl -> GetDataKey(This,spdkl,ppDataKey)

#define ISpObjectTokenCategory_EnumTokens(This,pzsReqAttribs,pszOptAttribs,ppEnum)	\
    (This)->lpVtbl -> EnumTokens(This,pzsReqAttribs,pszOptAttribs,ppEnum)

#define ISpObjectTokenCategory_SetDefaultTokenId(This,pszTokenId)	\
    (This)->lpVtbl -> SetDefaultTokenId(This,pszTokenId)

#define ISpObjectTokenCategory_GetDefaultTokenId(This,ppszCoMemTokenId)	\
    (This)->lpVtbl -> GetDefaultTokenId(This,ppszCoMemTokenId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpObjectTokenCategory_SetId_Proxy( 
    ISpObjectTokenCategory * This,
    /* [in] */ const WCHAR *pszCategoryId,
    BOOL fCreateIfNotExist);


void __RPC_STUB ISpObjectTokenCategory_SetId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpObjectTokenCategory_GetId_Proxy( 
    ISpObjectTokenCategory * This,
    /* [out] */ WCHAR **ppszCoMemCategoryId);


void __RPC_STUB ISpObjectTokenCategory_GetId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpObjectTokenCategory_GetDataKey_Proxy( 
    ISpObjectTokenCategory * This,
    SPDATAKEYLOCATION spdkl,
    ISpDataKey **ppDataKey);


void __RPC_STUB ISpObjectTokenCategory_GetDataKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpObjectTokenCategory_EnumTokens_Proxy( 
    ISpObjectTokenCategory * This,
    /* [string][in] */ const WCHAR *pzsReqAttribs,
    /* [string][in] */ const WCHAR *pszOptAttribs,
    /* [out] */ IEnumSpObjectTokens **ppEnum);


void __RPC_STUB ISpObjectTokenCategory_EnumTokens_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpObjectTokenCategory_SetDefaultTokenId_Proxy( 
    ISpObjectTokenCategory * This,
    /* [in] */ const WCHAR *pszTokenId);


void __RPC_STUB ISpObjectTokenCategory_SetDefaultTokenId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpObjectTokenCategory_GetDefaultTokenId_Proxy( 
    ISpObjectTokenCategory * This,
    /* [out] */ WCHAR **ppszCoMemTokenId);


void __RPC_STUB ISpObjectTokenCategory_GetDefaultTokenId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpObjectTokenCategory_INTERFACE_DEFINED__ */


#ifndef __ISpObjectToken_INTERFACE_DEFINED__
#define __ISpObjectToken_INTERFACE_DEFINED__

/* interface ISpObjectToken */
/* [restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISpObjectToken;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("14056589-E16C-11D2-BB90-00C04F8EE6C0")
    ISpObjectToken : public ISpDataKey
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetId( 
            const WCHAR *pszCategoryId,
            const WCHAR *pszTokenId,
            BOOL fCreateIfNotExist) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetId( 
            WCHAR **ppszCoMemTokenId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCategory( 
            ISpObjectTokenCategory **ppTokenCategory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstance( 
            /* [in] */ IUnknown *pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStorageFileName( 
            /* [in] */ REFCLSID clsidCaller,
            /* [in] */ const WCHAR *pszValueName,
            /* [in] */ const WCHAR *pszFileNameSpecifier,
            /* [in] */ ULONG nFolder,
            /* [out] */ WCHAR **ppszFilePath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStorageFileName( 
            /* [in] */ REFCLSID clsidCaller,
            /* [in] */ const WCHAR *pszKeyName,
            /* [in] */ BOOL fDeleteFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            const CLSID *pclsidCaller) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE IsUISupported( 
            /* [in] */ const WCHAR *pszTypeOfUI,
            /* [in] */ void *pvExtraData,
            /* [in] */ ULONG cbExtraData,
            /* [in] */ IUnknown *punkObject,
            /* [out] */ BOOL *pfSupported) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DisplayUI( 
            /* [in] */ HWND hwndParent,
            /* [in] */ const WCHAR *pszTitle,
            /* [in] */ const WCHAR *pszTypeOfUI,
            /* [in] */ void *pvExtraData,
            /* [in] */ ULONG cbExtraData,
            /* [in] */ IUnknown *punkObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MatchesAttributes( 
            /* [in] */ const WCHAR *pszAttributes,
            /* [out] */ BOOL *pfMatches) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpObjectTokenVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpObjectToken * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpObjectToken * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpObjectToken * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetData )( 
            ISpObjectToken * This,
            const WCHAR *pszValueName,
            ULONG cbData,
            const BYTE *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetData )( 
            ISpObjectToken * This,
            const WCHAR *pszValueName,
            ULONG *pcbData,
            BYTE *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetStringValue )( 
            ISpObjectToken * This,
            const WCHAR *pszValueName,
            const WCHAR *pszValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringValue )( 
            ISpObjectToken * This,
            const WCHAR *pszValueName,
            WCHAR **ppszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetDWORD )( 
            ISpObjectToken * This,
            const WCHAR *pszKeyName,
            DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetDWORD )( 
            ISpObjectToken * This,
            const WCHAR *pszKeyName,
            DWORD *pdwValue);
        
        HRESULT ( STDMETHODCALLTYPE *OpenKey )( 
            ISpObjectToken * This,
            const WCHAR *pszSubKeyName,
            ISpDataKey **ppSubKey);
        
        HRESULT ( STDMETHODCALLTYPE *CreateKey )( 
            ISpObjectToken * This,
            const WCHAR *pszSubKey,
            ISpDataKey **ppSubKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteKey )( 
            ISpObjectToken * This,
            const WCHAR *pszSubKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteValue )( 
            ISpObjectToken * This,
            const WCHAR *pszValueName);
        
        HRESULT ( STDMETHODCALLTYPE *EnumKeys )( 
            ISpObjectToken * This,
            ULONG Index,
            WCHAR **ppszSubKeyName);
        
        HRESULT ( STDMETHODCALLTYPE *EnumValues )( 
            ISpObjectToken * This,
            ULONG Index,
            WCHAR **ppszValueName);
        
        HRESULT ( STDMETHODCALLTYPE *SetId )( 
            ISpObjectToken * This,
            const WCHAR *pszCategoryId,
            const WCHAR *pszTokenId,
            BOOL fCreateIfNotExist);
        
        HRESULT ( STDMETHODCALLTYPE *GetId )( 
            ISpObjectToken * This,
            WCHAR **ppszCoMemTokenId);
        
        HRESULT ( STDMETHODCALLTYPE *GetCategory )( 
            ISpObjectToken * This,
            ISpObjectTokenCategory **ppTokenCategory);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInstance )( 
            ISpObjectToken * This,
            /* [in] */ IUnknown *pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetStorageFileName )( 
            ISpObjectToken * This,
            /* [in] */ REFCLSID clsidCaller,
            /* [in] */ const WCHAR *pszValueName,
            /* [in] */ const WCHAR *pszFileNameSpecifier,
            /* [in] */ ULONG nFolder,
            /* [out] */ WCHAR **ppszFilePath);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStorageFileName )( 
            ISpObjectToken * This,
            /* [in] */ REFCLSID clsidCaller,
            /* [in] */ const WCHAR *pszKeyName,
            /* [in] */ BOOL fDeleteFile);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            ISpObjectToken * This,
            const CLSID *pclsidCaller);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *IsUISupported )( 
            ISpObjectToken * This,
            /* [in] */ const WCHAR *pszTypeOfUI,
            /* [in] */ void *pvExtraData,
            /* [in] */ ULONG cbExtraData,
            /* [in] */ IUnknown *punkObject,
            /* [out] */ BOOL *pfSupported);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *DisplayUI )( 
            ISpObjectToken * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ const WCHAR *pszTitle,
            /* [in] */ const WCHAR *pszTypeOfUI,
            /* [in] */ void *pvExtraData,
            /* [in] */ ULONG cbExtraData,
            /* [in] */ IUnknown *punkObject);
        
        HRESULT ( STDMETHODCALLTYPE *MatchesAttributes )( 
            ISpObjectToken * This,
            /* [in] */ const WCHAR *pszAttributes,
            /* [out] */ BOOL *pfMatches);
        
        END_INTERFACE
    } ISpObjectTokenVtbl;

    interface ISpObjectToken
    {
        CONST_VTBL struct ISpObjectTokenVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpObjectToken_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpObjectToken_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpObjectToken_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpObjectToken_SetData(This,pszValueName,cbData,pData)	\
    (This)->lpVtbl -> SetData(This,pszValueName,cbData,pData)

#define ISpObjectToken_GetData(This,pszValueName,pcbData,pData)	\
    (This)->lpVtbl -> GetData(This,pszValueName,pcbData,pData)

#define ISpObjectToken_SetStringValue(This,pszValueName,pszValue)	\
    (This)->lpVtbl -> SetStringValue(This,pszValueName,pszValue)

#define ISpObjectToken_GetStringValue(This,pszValueName,ppszValue)	\
    (This)->lpVtbl -> GetStringValue(This,pszValueName,ppszValue)

#define ISpObjectToken_SetDWORD(This,pszKeyName,dwValue)	\
    (This)->lpVtbl -> SetDWORD(This,pszKeyName,dwValue)

#define ISpObjectToken_GetDWORD(This,pszKeyName,pdwValue)	\
    (This)->lpVtbl -> GetDWORD(This,pszKeyName,pdwValue)

#define ISpObjectToken_OpenKey(This,pszSubKeyName,ppSubKey)	\
    (This)->lpVtbl -> OpenKey(This,pszSubKeyName,ppSubKey)

#define ISpObjectToken_CreateKey(This,pszSubKey,ppSubKey)	\
    (This)->lpVtbl -> CreateKey(This,pszSubKey,ppSubKey)

#define ISpObjectToken_DeleteKey(This,pszSubKey)	\
    (This)->lpVtbl -> DeleteKey(This,pszSubKey)

#define ISpObjectToken_DeleteValue(This,pszValueName)	\
    (This)->lpVtbl -> DeleteValue(This,pszValueName)

#define ISpObjectToken_EnumKeys(This,Index,ppszSubKeyName)	\
    (This)->lpVtbl -> EnumKeys(This,Index,ppszSubKeyName)

#define ISpObjectToken_EnumValues(This,Index,ppszValueName)	\
    (This)->lpVtbl -> EnumValues(This,Index,ppszValueName)


#define ISpObjectToken_SetId(This,pszCategoryId,pszTokenId,fCreateIfNotExist)	\
    (This)->lpVtbl -> SetId(This,pszCategoryId,pszTokenId,fCreateIfNotExist)

#define ISpObjectToken_GetId(This,ppszCoMemTokenId)	\
    (This)->lpVtbl -> GetId(This,ppszCoMemTokenId)

#define ISpObjectToken_GetCategory(This,ppTokenCategory)	\
    (This)->lpVtbl -> GetCategory(This,ppTokenCategory)

#define ISpObjectToken_CreateInstance(This,pUnkOuter,dwClsContext,riid,ppvObject)	\
    (This)->lpVtbl -> CreateInstance(This,pUnkOuter,dwClsContext,riid,ppvObject)

#define ISpObjectToken_GetStorageFileName(This,clsidCaller,pszValueName,pszFileNameSpecifier,nFolder,ppszFilePath)	\
    (This)->lpVtbl -> GetStorageFileName(This,clsidCaller,pszValueName,pszFileNameSpecifier,nFolder,ppszFilePath)

#define ISpObjectToken_RemoveStorageFileName(This,clsidCaller,pszKeyName,fDeleteFile)	\
    (This)->lpVtbl -> RemoveStorageFileName(This,clsidCaller,pszKeyName,fDeleteFile)

#define ISpObjectToken_Remove(This,pclsidCaller)	\
    (This)->lpVtbl -> Remove(This,pclsidCaller)

#define ISpObjectToken_IsUISupported(This,pszTypeOfUI,pvExtraData,cbExtraData,punkObject,pfSupported)	\
    (This)->lpVtbl -> IsUISupported(This,pszTypeOfUI,pvExtraData,cbExtraData,punkObject,pfSupported)

#define ISpObjectToken_DisplayUI(This,hwndParent,pszTitle,pszTypeOfUI,pvExtraData,cbExtraData,punkObject)	\
    (This)->lpVtbl -> DisplayUI(This,hwndParent,pszTitle,pszTypeOfUI,pvExtraData,cbExtraData,punkObject)

#define ISpObjectToken_MatchesAttributes(This,pszAttributes,pfMatches)	\
    (This)->lpVtbl -> MatchesAttributes(This,pszAttributes,pfMatches)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpObjectToken_SetId_Proxy( 
    ISpObjectToken * This,
    const WCHAR *pszCategoryId,
    const WCHAR *pszTokenId,
    BOOL fCreateIfNotExist);


void __RPC_STUB ISpObjectToken_SetId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpObjectToken_GetId_Proxy( 
    ISpObjectToken * This,
    WCHAR **ppszCoMemTokenId);


void __RPC_STUB ISpObjectToken_GetId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpObjectToken_GetCategory_Proxy( 
    ISpObjectToken * This,
    ISpObjectTokenCategory **ppTokenCategory);


void __RPC_STUB ISpObjectToken_GetCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpObjectToken_CreateInstance_Proxy( 
    ISpObjectToken * This,
    /* [in] */ IUnknown *pUnkOuter,
    /* [in] */ DWORD dwClsContext,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppvObject);


void __RPC_STUB ISpObjectToken_CreateInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpObjectToken_GetStorageFileName_Proxy( 
    ISpObjectToken * This,
    /* [in] */ REFCLSID clsidCaller,
    /* [in] */ const WCHAR *pszValueName,
    /* [in] */ const WCHAR *pszFileNameSpecifier,
    /* [in] */ ULONG nFolder,
    /* [out] */ WCHAR **ppszFilePath);


void __RPC_STUB ISpObjectToken_GetStorageFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpObjectToken_RemoveStorageFileName_Proxy( 
    ISpObjectToken * This,
    /* [in] */ REFCLSID clsidCaller,
    /* [in] */ const WCHAR *pszKeyName,
    /* [in] */ BOOL fDeleteFile);


void __RPC_STUB ISpObjectToken_RemoveStorageFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpObjectToken_Remove_Proxy( 
    ISpObjectToken * This,
    const CLSID *pclsidCaller);


void __RPC_STUB ISpObjectToken_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE ISpObjectToken_IsUISupported_Proxy( 
    ISpObjectToken * This,
    /* [in] */ const WCHAR *pszTypeOfUI,
    /* [in] */ void *pvExtraData,
    /* [in] */ ULONG cbExtraData,
    /* [in] */ IUnknown *punkObject,
    /* [out] */ BOOL *pfSupported);


void __RPC_STUB ISpObjectToken_IsUISupported_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE ISpObjectToken_DisplayUI_Proxy( 
    ISpObjectToken * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ const WCHAR *pszTitle,
    /* [in] */ const WCHAR *pszTypeOfUI,
    /* [in] */ void *pvExtraData,
    /* [in] */ ULONG cbExtraData,
    /* [in] */ IUnknown *punkObject);


void __RPC_STUB ISpObjectToken_DisplayUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpObjectToken_MatchesAttributes_Proxy( 
    ISpObjectToken * This,
    /* [in] */ const WCHAR *pszAttributes,
    /* [out] */ BOOL *pfMatches);


void __RPC_STUB ISpObjectToken_MatchesAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpObjectToken_INTERFACE_DEFINED__ */


#ifndef __ISpObjectTokenInit_INTERFACE_DEFINED__
#define __ISpObjectTokenInit_INTERFACE_DEFINED__

/* interface ISpObjectTokenInit */
/* [restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISpObjectTokenInit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B8AAB0CF-346F-49D8-9499-C8B03F161D51")
    ISpObjectTokenInit : public ISpObjectToken
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitFromDataKey( 
            /* [in] */ const WCHAR *pszCategoryId,
            /* [in] */ const WCHAR *pszTokenId,
            /* [in] */ ISpDataKey *pDataKey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpObjectTokenInitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpObjectTokenInit * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpObjectTokenInit * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpObjectTokenInit * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetData )( 
            ISpObjectTokenInit * This,
            const WCHAR *pszValueName,
            ULONG cbData,
            const BYTE *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetData )( 
            ISpObjectTokenInit * This,
            const WCHAR *pszValueName,
            ULONG *pcbData,
            BYTE *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetStringValue )( 
            ISpObjectTokenInit * This,
            const WCHAR *pszValueName,
            const WCHAR *pszValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringValue )( 
            ISpObjectTokenInit * This,
            const WCHAR *pszValueName,
            WCHAR **ppszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetDWORD )( 
            ISpObjectTokenInit * This,
            const WCHAR *pszKeyName,
            DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetDWORD )( 
            ISpObjectTokenInit * This,
            const WCHAR *pszKeyName,
            DWORD *pdwValue);
        
        HRESULT ( STDMETHODCALLTYPE *OpenKey )( 
            ISpObjectTokenInit * This,
            const WCHAR *pszSubKeyName,
            ISpDataKey **ppSubKey);
        
        HRESULT ( STDMETHODCALLTYPE *CreateKey )( 
            ISpObjectTokenInit * This,
            const WCHAR *pszSubKey,
            ISpDataKey **ppSubKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteKey )( 
            ISpObjectTokenInit * This,
            const WCHAR *pszSubKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteValue )( 
            ISpObjectTokenInit * This,
            const WCHAR *pszValueName);
        
        HRESULT ( STDMETHODCALLTYPE *EnumKeys )( 
            ISpObjectTokenInit * This,
            ULONG Index,
            WCHAR **ppszSubKeyName);
        
        HRESULT ( STDMETHODCALLTYPE *EnumValues )( 
            ISpObjectTokenInit * This,
            ULONG Index,
            WCHAR **ppszValueName);
        
        HRESULT ( STDMETHODCALLTYPE *SetId )( 
            ISpObjectTokenInit * This,
            const WCHAR *pszCategoryId,
            const WCHAR *pszTokenId,
            BOOL fCreateIfNotExist);
        
        HRESULT ( STDMETHODCALLTYPE *GetId )( 
            ISpObjectTokenInit * This,
            WCHAR **ppszCoMemTokenId);
        
        HRESULT ( STDMETHODCALLTYPE *GetCategory )( 
            ISpObjectTokenInit * This,
            ISpObjectTokenCategory **ppTokenCategory);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInstance )( 
            ISpObjectTokenInit * This,
            /* [in] */ IUnknown *pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetStorageFileName )( 
            ISpObjectTokenInit * This,
            /* [in] */ REFCLSID clsidCaller,
            /* [in] */ const WCHAR *pszValueName,
            /* [in] */ const WCHAR *pszFileNameSpecifier,
            /* [in] */ ULONG nFolder,
            /* [out] */ WCHAR **ppszFilePath);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStorageFileName )( 
            ISpObjectTokenInit * This,
            /* [in] */ REFCLSID clsidCaller,
            /* [in] */ const WCHAR *pszKeyName,
            /* [in] */ BOOL fDeleteFile);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            ISpObjectTokenInit * This,
            const CLSID *pclsidCaller);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *IsUISupported )( 
            ISpObjectTokenInit * This,
            /* [in] */ const WCHAR *pszTypeOfUI,
            /* [in] */ void *pvExtraData,
            /* [in] */ ULONG cbExtraData,
            /* [in] */ IUnknown *punkObject,
            /* [out] */ BOOL *pfSupported);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *DisplayUI )( 
            ISpObjectTokenInit * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ const WCHAR *pszTitle,
            /* [in] */ const WCHAR *pszTypeOfUI,
            /* [in] */ void *pvExtraData,
            /* [in] */ ULONG cbExtraData,
            /* [in] */ IUnknown *punkObject);
        
        HRESULT ( STDMETHODCALLTYPE *MatchesAttributes )( 
            ISpObjectTokenInit * This,
            /* [in] */ const WCHAR *pszAttributes,
            /* [out] */ BOOL *pfMatches);
        
        HRESULT ( STDMETHODCALLTYPE *InitFromDataKey )( 
            ISpObjectTokenInit * This,
            /* [in] */ const WCHAR *pszCategoryId,
            /* [in] */ const WCHAR *pszTokenId,
            /* [in] */ ISpDataKey *pDataKey);
        
        END_INTERFACE
    } ISpObjectTokenInitVtbl;

    interface ISpObjectTokenInit
    {
        CONST_VTBL struct ISpObjectTokenInitVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpObjectTokenInit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpObjectTokenInit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpObjectTokenInit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpObjectTokenInit_SetData(This,pszValueName,cbData,pData)	\
    (This)->lpVtbl -> SetData(This,pszValueName,cbData,pData)

#define ISpObjectTokenInit_GetData(This,pszValueName,pcbData,pData)	\
    (This)->lpVtbl -> GetData(This,pszValueName,pcbData,pData)

#define ISpObjectTokenInit_SetStringValue(This,pszValueName,pszValue)	\
    (This)->lpVtbl -> SetStringValue(This,pszValueName,pszValue)

#define ISpObjectTokenInit_GetStringValue(This,pszValueName,ppszValue)	\
    (This)->lpVtbl -> GetStringValue(This,pszValueName,ppszValue)

#define ISpObjectTokenInit_SetDWORD(This,pszKeyName,dwValue)	\
    (This)->lpVtbl -> SetDWORD(This,pszKeyName,dwValue)

#define ISpObjectTokenInit_GetDWORD(This,pszKeyName,pdwValue)	\
    (This)->lpVtbl -> GetDWORD(This,pszKeyName,pdwValue)

#define ISpObjectTokenInit_OpenKey(This,pszSubKeyName,ppSubKey)	\
    (This)->lpVtbl -> OpenKey(This,pszSubKeyName,ppSubKey)

#define ISpObjectTokenInit_CreateKey(This,pszSubKey,ppSubKey)	\
    (This)->lpVtbl -> CreateKey(This,pszSubKey,ppSubKey)

#define ISpObjectTokenInit_DeleteKey(This,pszSubKey)	\
    (This)->lpVtbl -> DeleteKey(This,pszSubKey)

#define ISpObjectTokenInit_DeleteValue(This,pszValueName)	\
    (This)->lpVtbl -> DeleteValue(This,pszValueName)

#define ISpObjectTokenInit_EnumKeys(This,Index,ppszSubKeyName)	\
    (This)->lpVtbl -> EnumKeys(This,Index,ppszSubKeyName)

#define ISpObjectTokenInit_EnumValues(This,Index,ppszValueName)	\
    (This)->lpVtbl -> EnumValues(This,Index,ppszValueName)


#define ISpObjectTokenInit_SetId(This,pszCategoryId,pszTokenId,fCreateIfNotExist)	\
    (This)->lpVtbl -> SetId(This,pszCategoryId,pszTokenId,fCreateIfNotExist)

#define ISpObjectTokenInit_GetId(This,ppszCoMemTokenId)	\
    (This)->lpVtbl -> GetId(This,ppszCoMemTokenId)

#define ISpObjectTokenInit_GetCategory(This,ppTokenCategory)	\
    (This)->lpVtbl -> GetCategory(This,ppTokenCategory)

#define ISpObjectTokenInit_CreateInstance(This,pUnkOuter,dwClsContext,riid,ppvObject)	\
    (This)->lpVtbl -> CreateInstance(This,pUnkOuter,dwClsContext,riid,ppvObject)

#define ISpObjectTokenInit_GetStorageFileName(This,clsidCaller,pszValueName,pszFileNameSpecifier,nFolder,ppszFilePath)	\
    (This)->lpVtbl -> GetStorageFileName(This,clsidCaller,pszValueName,pszFileNameSpecifier,nFolder,ppszFilePath)

#define ISpObjectTokenInit_RemoveStorageFileName(This,clsidCaller,pszKeyName,fDeleteFile)	\
    (This)->lpVtbl -> RemoveStorageFileName(This,clsidCaller,pszKeyName,fDeleteFile)

#define ISpObjectTokenInit_Remove(This,pclsidCaller)	\
    (This)->lpVtbl -> Remove(This,pclsidCaller)

#define ISpObjectTokenInit_IsUISupported(This,pszTypeOfUI,pvExtraData,cbExtraData,punkObject,pfSupported)	\
    (This)->lpVtbl -> IsUISupported(This,pszTypeOfUI,pvExtraData,cbExtraData,punkObject,pfSupported)

#define ISpObjectTokenInit_DisplayUI(This,hwndParent,pszTitle,pszTypeOfUI,pvExtraData,cbExtraData,punkObject)	\
    (This)->lpVtbl -> DisplayUI(This,hwndParent,pszTitle,pszTypeOfUI,pvExtraData,cbExtraData,punkObject)

#define ISpObjectTokenInit_MatchesAttributes(This,pszAttributes,pfMatches)	\
    (This)->lpVtbl -> MatchesAttributes(This,pszAttributes,pfMatches)


#define ISpObjectTokenInit_InitFromDataKey(This,pszCategoryId,pszTokenId,pDataKey)	\
    (This)->lpVtbl -> InitFromDataKey(This,pszCategoryId,pszTokenId,pDataKey)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpObjectTokenInit_InitFromDataKey_Proxy( 
    ISpObjectTokenInit * This,
    /* [in] */ const WCHAR *pszCategoryId,
    /* [in] */ const WCHAR *pszTokenId,
    /* [in] */ ISpDataKey *pDataKey);


void __RPC_STUB ISpObjectTokenInit_InitFromDataKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpObjectTokenInit_INTERFACE_DEFINED__ */


#ifndef __IEnumSpObjectTokens_INTERFACE_DEFINED__
#define __IEnumSpObjectTokens_INTERFACE_DEFINED__

/* interface IEnumSpObjectTokens */
/* [restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumSpObjectTokens;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("06B64F9E-7FDA-11D2-B4F2-00C04F797396")
    IEnumSpObjectTokens : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ISpObjectToken **pelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumSpObjectTokens **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ ULONG Index,
            /* [out] */ ISpObjectToken **ppToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumSpObjectTokensVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumSpObjectTokens * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumSpObjectTokens * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumSpObjectTokens * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumSpObjectTokens * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ISpObjectToken **pelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumSpObjectTokens * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumSpObjectTokens * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumSpObjectTokens * This,
            /* [out] */ IEnumSpObjectTokens **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Item )( 
            IEnumSpObjectTokens * This,
            /* [in] */ ULONG Index,
            /* [out] */ ISpObjectToken **ppToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumSpObjectTokens * This,
            /* [out] */ ULONG *pCount);
        
        END_INTERFACE
    } IEnumSpObjectTokensVtbl;

    interface IEnumSpObjectTokens
    {
        CONST_VTBL struct IEnumSpObjectTokensVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumSpObjectTokens_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumSpObjectTokens_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumSpObjectTokens_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumSpObjectTokens_Next(This,celt,pelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,pelt,pceltFetched)

#define IEnumSpObjectTokens_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumSpObjectTokens_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumSpObjectTokens_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumSpObjectTokens_Item(This,Index,ppToken)	\
    (This)->lpVtbl -> Item(This,Index,ppToken)

#define IEnumSpObjectTokens_GetCount(This,pCount)	\
    (This)->lpVtbl -> GetCount(This,pCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumSpObjectTokens_Next_Proxy( 
    IEnumSpObjectTokens * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ISpObjectToken **pelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IEnumSpObjectTokens_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSpObjectTokens_Skip_Proxy( 
    IEnumSpObjectTokens * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumSpObjectTokens_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSpObjectTokens_Reset_Proxy( 
    IEnumSpObjectTokens * This);


void __RPC_STUB IEnumSpObjectTokens_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSpObjectTokens_Clone_Proxy( 
    IEnumSpObjectTokens * This,
    /* [out] */ IEnumSpObjectTokens **ppEnum);


void __RPC_STUB IEnumSpObjectTokens_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSpObjectTokens_Item_Proxy( 
    IEnumSpObjectTokens * This,
    /* [in] */ ULONG Index,
    /* [out] */ ISpObjectToken **ppToken);


void __RPC_STUB IEnumSpObjectTokens_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSpObjectTokens_GetCount_Proxy( 
    IEnumSpObjectTokens * This,
    /* [out] */ ULONG *pCount);


void __RPC_STUB IEnumSpObjectTokens_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumSpObjectTokens_INTERFACE_DEFINED__ */


#ifndef __ISpObjectWithToken_INTERFACE_DEFINED__
#define __ISpObjectWithToken_INTERFACE_DEFINED__

/* interface ISpObjectWithToken */
/* [restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISpObjectWithToken;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5B559F40-E952-11D2-BB91-00C04F8EE6C0")
    ISpObjectWithToken : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetObjectToken( 
            ISpObjectToken *pToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectToken( 
            ISpObjectToken **ppToken) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpObjectWithTokenVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpObjectWithToken * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpObjectWithToken * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpObjectWithToken * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetObjectToken )( 
            ISpObjectWithToken * This,
            ISpObjectToken *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectToken )( 
            ISpObjectWithToken * This,
            ISpObjectToken **ppToken);
        
        END_INTERFACE
    } ISpObjectWithTokenVtbl;

    interface ISpObjectWithToken
    {
        CONST_VTBL struct ISpObjectWithTokenVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpObjectWithToken_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpObjectWithToken_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpObjectWithToken_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpObjectWithToken_SetObjectToken(This,pToken)	\
    (This)->lpVtbl -> SetObjectToken(This,pToken)

#define ISpObjectWithToken_GetObjectToken(This,ppToken)	\
    (This)->lpVtbl -> GetObjectToken(This,ppToken)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpObjectWithToken_SetObjectToken_Proxy( 
    ISpObjectWithToken * This,
    ISpObjectToken *pToken);


void __RPC_STUB ISpObjectWithToken_SetObjectToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpObjectWithToken_GetObjectToken_Proxy( 
    ISpObjectWithToken * This,
    ISpObjectToken **ppToken);


void __RPC_STUB ISpObjectWithToken_GetObjectToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpObjectWithToken_INTERFACE_DEFINED__ */


#ifndef __ISpResourceManager_INTERFACE_DEFINED__
#define __ISpResourceManager_INTERFACE_DEFINED__

/* interface ISpResourceManager */
/* [restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISpResourceManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("93384E18-5014-43D5-ADBB-A78E055926BD")
    ISpResourceManager : public IServiceProvider
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetObject( 
            /* [in] */ REFGUID guidServiceId,
            /* [in] */ IUnknown *pUnkObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ REFGUID guidServiceId,
            /* [in] */ REFCLSID ObjectCLSID,
            /* [in] */ REFIID ObjectIID,
            /* [in] */ BOOL fReleaseWhenLastExternalRefReleased,
            /* [iid_is][out] */ void **ppObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpResourceManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpResourceManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpResourceManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpResourceManager * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *QueryService )( 
            ISpResourceManager * This,
            /* [in] */ REFGUID guidService,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE *SetObject )( 
            ISpResourceManager * This,
            /* [in] */ REFGUID guidServiceId,
            /* [in] */ IUnknown *pUnkObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            ISpResourceManager * This,
            /* [in] */ REFGUID guidServiceId,
            /* [in] */ REFCLSID ObjectCLSID,
            /* [in] */ REFIID ObjectIID,
            /* [in] */ BOOL fReleaseWhenLastExternalRefReleased,
            /* [iid_is][out] */ void **ppObject);
        
        END_INTERFACE
    } ISpResourceManagerVtbl;

    interface ISpResourceManager
    {
        CONST_VTBL struct ISpResourceManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpResourceManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpResourceManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpResourceManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpResourceManager_QueryService(This,guidService,riid,ppvObject)	\
    (This)->lpVtbl -> QueryService(This,guidService,riid,ppvObject)


#define ISpResourceManager_SetObject(This,guidServiceId,pUnkObject)	\
    (This)->lpVtbl -> SetObject(This,guidServiceId,pUnkObject)

#define ISpResourceManager_GetObject(This,guidServiceId,ObjectCLSID,ObjectIID,fReleaseWhenLastExternalRefReleased,ppObject)	\
    (This)->lpVtbl -> GetObject(This,guidServiceId,ObjectCLSID,ObjectIID,fReleaseWhenLastExternalRefReleased,ppObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpResourceManager_SetObject_Proxy( 
    ISpResourceManager * This,
    /* [in] */ REFGUID guidServiceId,
    /* [in] */ IUnknown *pUnkObject);


void __RPC_STUB ISpResourceManager_SetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpResourceManager_GetObject_Proxy( 
    ISpResourceManager * This,
    /* [in] */ REFGUID guidServiceId,
    /* [in] */ REFCLSID ObjectCLSID,
    /* [in] */ REFIID ObjectIID,
    /* [in] */ BOOL fReleaseWhenLastExternalRefReleased,
    /* [iid_is][out] */ void **ppObject);


void __RPC_STUB ISpResourceManager_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpResourceManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sapi_0256 */
/* [local] */ 

typedef 
enum SPEVENTLPARAMTYPE
    {	SPET_LPARAM_IS_UNDEFINED	= 0,
	SPET_LPARAM_IS_TOKEN	= SPET_LPARAM_IS_UNDEFINED + 1,
	SPET_LPARAM_IS_OBJECT	= SPET_LPARAM_IS_TOKEN + 1,
	SPET_LPARAM_IS_POINTER	= SPET_LPARAM_IS_OBJECT + 1,
	SPET_LPARAM_IS_STRING	= SPET_LPARAM_IS_POINTER + 1
    } 	SPEVENTLPARAMTYPE;

typedef 
enum SPEVENTENUM
    {	SPEI_UNDEFINED	= 0,
	SPEI_START_INPUT_STREAM	= 1,
	SPEI_END_INPUT_STREAM	= 2,
	SPEI_VOICE_CHANGE	= 3,
	SPEI_TTS_BOOKMARK	= 4,
	SPEI_WORD_BOUNDARY	= 5,
	SPEI_PHONEME	= 6,
	SPEI_SENTENCE_BOUNDARY	= 7,
	SPEI_VISEME	= 8,
	SPEI_TTS_AUDIO_LEVEL	= 9,
	SPEI_TTS_PRIVATE	= 15,
	SPEI_MIN_TTS	= 1,
	SPEI_MAX_TTS	= 15,
	SPEI_END_SR_STREAM	= 34,
	SPEI_SOUND_START	= 35,
	SPEI_SOUND_END	= 36,
	SPEI_PHRASE_START	= 37,
	SPEI_RECOGNITION	= 38,
	SPEI_HYPOTHESIS	= 39,
	SPEI_SR_BOOKMARK	= 40,
	SPEI_PROPERTY_NUM_CHANGE	= 41,
	SPEI_PROPERTY_STRING_CHANGE	= 42,
	SPEI_FALSE_RECOGNITION	= 43,
	SPEI_INTERFERENCE	= 44,
	SPEI_REQUEST_UI	= 45,
	SPEI_RECO_STATE_CHANGE	= 46,
	SPEI_ADAPTATION	= 47,
	SPEI_START_SR_STREAM	= 48,
	SPEI_RECO_OTHER_CONTEXT	= 49,
	SPEI_SR_AUDIO_LEVEL	= 50,
	SPEI_SR_PRIVATE	= 52,
	SPEI_MIN_SR	= 34,
	SPEI_MAX_SR	= 52,
	SPEI_RESERVED1	= 30,
	SPEI_RESERVED2	= 33,
	SPEI_RESERVED3	= 63
    } 	SPEVENTENUM;

#define SPFEI_FLAGCHECK ( (1ui64 << SPEI_RESERVED1) | (1ui64 << SPEI_RESERVED2) )
#define SPFEI_ALL_TTS_EVENTS (0x000000000000FFFEui64 | SPFEI_FLAGCHECK)
#define SPFEI_ALL_SR_EVENTS  (0x001FFFFC00000000ui64 | SPFEI_FLAGCHECK)
#define SPFEI_ALL_EVENTS      0xEFFFFFFFFFFFFFFFui64
#define SPFEI(SPEI_ord) ((1ui64 << SPEI_ord) | SPFEI_FLAGCHECK)
#if 0
typedef /* [restricted] */ struct SPEVENT
    {
    WORD eEventId;
    WORD elParamType;
    ULONG ulStreamNum;
    ULONGLONG ullAudioStreamOffset;
    WPARAM wParam;
    LPARAM lParam;
    } 	SPEVENT;

typedef /* [restricted] */ struct SPSERIALIZEDEVENT
    {
    WORD eEventId;
    WORD elParamType;
    ULONG ulStreamNum;
    ULONGLONG ullAudioStreamOffset;
    ULONG SerializedwParam;
    LONG SerializedlParam;
    } 	SPSERIALIZEDEVENT;

typedef /* [restricted] */ struct SPSERIALIZEDEVENT64
    {
    WORD eEventId;
    WORD elParamType;
    ULONG ulStreamNum;
    ULONGLONG ullAudioStreamOffset;
    ULONGLONG SerializedwParam;
    LONGLONG SerializedlParam;
    } 	SPSERIALIZEDEVENT64;

#else
typedef struct SPEVENT
{
    SPEVENTENUM        eEventId : 16;
    SPEVENTLPARAMTYPE  elParamType : 16;
    ULONG       ulStreamNum;
    ULONGLONG   ullAudioStreamOffset;
    WPARAM      wParam;
    LPARAM      lParam;
} SPEVENT;
typedef struct SPSERIALIZEDEVENT
{
    SPEVENTENUM        eEventId : 16;
    SPEVENTLPARAMTYPE  elParamType : 16;
    ULONG       ulStreamNum;
    ULONGLONG   ullAudioStreamOffset;
    ULONG       SerializedwParam;
    LONG        SerializedlParam;
} SPSERIALIZEDEVENT;
typedef struct SPSERIALIZEDEVENT64
{
    SPEVENTENUM        eEventId : 16;
    SPEVENTLPARAMTYPE  elParamType : 16;
    ULONG       ulStreamNum;
    ULONGLONG   ullAudioStreamOffset;
    ULONGLONG   SerializedwParam;
    LONGLONG    SerializedlParam;
} SPSERIALIZEDEVENT64;
#endif
typedef 
enum SPINTERFERENCE
    {	SPINTERFERENCE_NONE	= 0,
	SPINTERFERENCE_NOISE	= SPINTERFERENCE_NONE + 1,
	SPINTERFERENCE_NOSIGNAL	= SPINTERFERENCE_NOISE + 1,
	SPINTERFERENCE_TOOLOUD	= SPINTERFERENCE_NOSIGNAL + 1,
	SPINTERFERENCE_TOOQUIET	= SPINTERFERENCE_TOOLOUD + 1,
	SPINTERFERENCE_TOOFAST	= SPINTERFERENCE_TOOQUIET + 1,
	SPINTERFERENCE_TOOSLOW	= SPINTERFERENCE_TOOFAST + 1
    } 	SPINTERFERENCE;

typedef 
enum SPENDSRSTREAMFLAGS
    {	SPESF_NONE	= 0,
	SPESF_STREAM_RELEASED	= 1 << 0
    } 	SPENDSRSTREAMFLAGS;

typedef 
enum SPVFEATURE
    {	SPVFEATURE_STRESSED	= 1L << 0,
	SPVFEATURE_EMPHASIS	= 1L << 1
    } 	SPVFEATURE;

typedef 
enum SPVISEMES
    {	SP_VISEME_0	= 0,
	SP_VISEME_1	= SP_VISEME_0 + 1,
	SP_VISEME_2	= SP_VISEME_1 + 1,
	SP_VISEME_3	= SP_VISEME_2 + 1,
	SP_VISEME_4	= SP_VISEME_3 + 1,
	SP_VISEME_5	= SP_VISEME_4 + 1,
	SP_VISEME_6	= SP_VISEME_5 + 1,
	SP_VISEME_7	= SP_VISEME_6 + 1,
	SP_VISEME_8	= SP_VISEME_7 + 1,
	SP_VISEME_9	= SP_VISEME_8 + 1,
	SP_VISEME_10	= SP_VISEME_9 + 1,
	SP_VISEME_11	= SP_VISEME_10 + 1,
	SP_VISEME_12	= SP_VISEME_11 + 1,
	SP_VISEME_13	= SP_VISEME_12 + 1,
	SP_VISEME_14	= SP_VISEME_13 + 1,
	SP_VISEME_15	= SP_VISEME_14 + 1,
	SP_VISEME_16	= SP_VISEME_15 + 1,
	SP_VISEME_17	= SP_VISEME_16 + 1,
	SP_VISEME_18	= SP_VISEME_17 + 1,
	SP_VISEME_19	= SP_VISEME_18 + 1,
	SP_VISEME_20	= SP_VISEME_19 + 1,
	SP_VISEME_21	= SP_VISEME_20 + 1
    } 	SPVISEMES;

typedef /* [restricted] */ struct SPEVENTSOURCEINFO
    {
    ULONGLONG ullEventInterest;
    ULONGLONG ullQueuedInterest;
    ULONG ulCount;
    } 	SPEVENTSOURCEINFO;



extern RPC_IF_HANDLE __MIDL_itf_sapi_0256_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sapi_0256_v0_0_s_ifspec;

#ifndef __ISpEventSource_INTERFACE_DEFINED__
#define __ISpEventSource_INTERFACE_DEFINED__

/* interface ISpEventSource */
/* [restricted][local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISpEventSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BE7A9CCE-5F9E-11D2-960F-00C04F8EE628")
    ISpEventSource : public ISpNotifySource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetInterest( 
            /* [in] */ ULONGLONG ullEventInterest,
            /* [in] */ ULONGLONG ullQueuedInterest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEvents( 
            /* [in] */ ULONG ulCount,
            /* [size_is][out] */ SPEVENT *pEventArray,
            /* [out] */ ULONG *pulFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [out] */ SPEVENTSOURCEINFO *pInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpEventSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpEventSource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpEventSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpEventSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetNotifySink )( 
            ISpEventSource * This,
            /* [in] */ ISpNotifySink *pNotifySink);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetNotifyWindowMessage )( 
            ISpEventSource * This,
            /* [in] */ HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetNotifyCallbackFunction )( 
            ISpEventSource * This,
            /* [in] */ SPNOTIFYCALLBACK *pfnCallback,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetNotifyCallbackInterface )( 
            ISpEventSource * This,
            /* [in] */ ISpNotifyCallback *pSpCallback,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetNotifyWin32Event )( 
            ISpEventSource * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *WaitForNotifyEvent )( 
            ISpEventSource * This,
            /* [in] */ DWORD dwMilliseconds);
        
        /* [local] */ HANDLE ( STDMETHODCALLTYPE *GetNotifyEventHandle )( 
            ISpEventSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetInterest )( 
            ISpEventSource * This,
            /* [in] */ ULONGLONG ullEventInterest,
            /* [in] */ ULONGLONG ullQueuedInterest);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvents )( 
            ISpEventSource * This,
            /* [in] */ ULONG ulCount,
            /* [size_is][out] */ SPEVENT *pEventArray,
            /* [out] */ ULONG *pulFetched);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            ISpEventSource * This,
            /* [out] */ SPEVENTSOURCEINFO *pInfo);
        
        END_INTERFACE
    } ISpEventSourceVtbl;

    interface ISpEventSource
    {
        CONST_VTBL struct ISpEventSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpEventSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpEventSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpEventSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpEventSource_SetNotifySink(This,pNotifySink)	\
    (This)->lpVtbl -> SetNotifySink(This,pNotifySink)

#define ISpEventSource_SetNotifyWindowMessage(This,hWnd,Msg,wParam,lParam)	\
    (This)->lpVtbl -> SetNotifyWindowMessage(This,hWnd,Msg,wParam,lParam)

#define ISpEventSource_SetNotifyCallbackFunction(This,pfnCallback,wParam,lParam)	\
    (This)->lpVtbl -> SetNotifyCallbackFunction(This,pfnCallback,wParam,lParam)

#define ISpEventSource_SetNotifyCallbackInterface(This,pSpCallback,wParam,lParam)	\
    (This)->lpVtbl -> SetNotifyCallbackInterface(This,pSpCallback,wParam,lParam)

#define ISpEventSource_SetNotifyWin32Event(This)	\
    (This)->lpVtbl -> SetNotifyWin32Event(This)

#define ISpEventSource_WaitForNotifyEvent(This,dwMilliseconds)	\
    (This)->lpVtbl -> WaitForNotifyEvent(This,dwMilliseconds)

#define ISpEventSource_GetNotifyEventHandle(This)	\
    (This)->lpVtbl -> GetNotifyEventHandle(This)


#define ISpEventSource_SetInterest(This,ullEventInterest,ullQueuedInterest)	\
    (This)->lpVtbl -> SetInterest(This,ullEventInterest,ullQueuedInterest)

#define ISpEventSource_GetEvents(This,ulCount,pEventArray,pulFetched)	\
    (This)->lpVtbl -> GetEvents(This,ulCount,pEventArray,pulFetched)

#define ISpEventSource_GetInfo(This,pInfo)	\
    (This)->lpVtbl -> GetInfo(This,pInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpEventSource_SetInterest_Proxy( 
    ISpEventSource * This,
    /* [in] */ ULONGLONG ullEventInterest,
    /* [in] */ ULONGLONG ullQueuedInterest);


void __RPC_STUB ISpEventSource_SetInterest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpEventSource_GetEvents_Proxy( 
    ISpEventSource * This,
    /* [in] */ ULONG ulCount,
    /* [size_is][out] */ SPEVENT *pEventArray,
    /* [out] */ ULONG *pulFetched);


void __RPC_STUB ISpEventSource_GetEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpEventSource_GetInfo_Proxy( 
    ISpEventSource * This,
    /* [out] */ SPEVENTSOURCEINFO *pInfo);


void __RPC_STUB ISpEventSource_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpEventSource_INTERFACE_DEFINED__ */


#ifndef __ISpEventSink_INTERFACE_DEFINED__
#define __ISpEventSink_INTERFACE_DEFINED__

/* interface ISpEventSink */
/* [restricted][local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISpEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BE7A9CC9-5F9E-11D2-960F-00C04F8EE628")
    ISpEventSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddEvents( 
            /* [in] */ const SPEVENT *pEventArray,
            /* [in] */ ULONG ulCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEventInterest( 
            /* [out] */ ULONGLONG *pullEventInterest) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpEventSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpEventSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpEventSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddEvents )( 
            ISpEventSink * This,
            /* [in] */ const SPEVENT *pEventArray,
            /* [in] */ ULONG ulCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetEventInterest )( 
            ISpEventSink * This,
            /* [out] */ ULONGLONG *pullEventInterest);
        
        END_INTERFACE
    } ISpEventSinkVtbl;

    interface ISpEventSink
    {
        CONST_VTBL struct ISpEventSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpEventSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpEventSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpEventSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpEventSink_AddEvents(This,pEventArray,ulCount)	\
    (This)->lpVtbl -> AddEvents(This,pEventArray,ulCount)

#define ISpEventSink_GetEventInterest(This,pullEventInterest)	\
    (This)->lpVtbl -> GetEventInterest(This,pullEventInterest)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpEventSink_AddEvents_Proxy( 
    ISpEventSink * This,
    /* [in] */ const SPEVENT *pEventArray,
    /* [in] */ ULONG ulCount);


void __RPC_STUB ISpEventSink_AddEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpEventSink_GetEventInterest_Proxy( 
    ISpEventSink * This,
    /* [out] */ ULONGLONG *pullEventInterest);


void __RPC_STUB ISpEventSink_GetEventInterest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpEventSink_INTERFACE_DEFINED__ */


#ifndef __ISpStreamFormat_INTERFACE_DEFINED__
#define __ISpStreamFormat_INTERFACE_DEFINED__

/* interface ISpStreamFormat */
/* [restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISpStreamFormat;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BED530BE-2606-4F4D-A1C0-54C5CDA5566F")
    ISpStreamFormat : public IStream
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFormat( 
            GUID *pguidFormatId,
            WAVEFORMATEX **ppCoMemWaveFormatEx) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpStreamFormatVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpStreamFormat * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpStreamFormat * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpStreamFormat * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Read )( 
            ISpStreamFormat * This,
            /* [length_is][size_is][out] */ void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbRead);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Write )( 
            ISpStreamFormat * This,
            /* [size_is][in] */ const void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbWritten);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Seek )( 
            ISpStreamFormat * This,
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER *plibNewPosition);
        
        HRESULT ( STDMETHODCALLTYPE *SetSize )( 
            ISpStreamFormat * This,
            /* [in] */ ULARGE_INTEGER libNewSize);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CopyTo )( 
            ISpStreamFormat * This,
            /* [unique][in] */ IStream *pstm,
            /* [in] */ ULARGE_INTEGER cb,
            /* [out] */ ULARGE_INTEGER *pcbRead,
            /* [out] */ ULARGE_INTEGER *pcbWritten);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            ISpStreamFormat * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Revert )( 
            ISpStreamFormat * This);
        
        HRESULT ( STDMETHODCALLTYPE *LockRegion )( 
            ISpStreamFormat * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockRegion )( 
            ISpStreamFormat * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *Stat )( 
            ISpStreamFormat * This,
            /* [out] */ STATSTG *pstatstg,
            /* [in] */ DWORD grfStatFlag);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ISpStreamFormat * This,
            /* [out] */ IStream **ppstm);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormat )( 
            ISpStreamFormat * This,
            GUID *pguidFormatId,
            WAVEFORMATEX **ppCoMemWaveFormatEx);
        
        END_INTERFACE
    } ISpStreamFormatVtbl;

    interface ISpStreamFormat
    {
        CONST_VTBL struct ISpStreamFormatVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpStreamFormat_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpStreamFormat_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpStreamFormat_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpStreamFormat_Read(This,pv,cb,pcbRead)	\
    (This)->lpVtbl -> Read(This,pv,cb,pcbRead)

#define ISpStreamFormat_Write(This,pv,cb,pcbWritten)	\
    (This)->lpVtbl -> Write(This,pv,cb,pcbWritten)


#define ISpStreamFormat_Seek(This,dlibMove,dwOrigin,plibNewPosition)	\
    (This)->lpVtbl -> Seek(This,dlibMove,dwOrigin,plibNewPosition)

#define ISpStreamFormat_SetSize(This,libNewSize)	\
    (This)->lpVtbl -> SetSize(This,libNewSize)

#define ISpStreamFormat_CopyTo(This,pstm,cb,pcbRead,pcbWritten)	\
    (This)->lpVtbl -> CopyTo(This,pstm,cb,pcbRead,pcbWritten)

#define ISpStreamFormat_Commit(This,grfCommitFlags)	\
    (This)->lpVtbl -> Commit(This,grfCommitFlags)

#define ISpStreamFormat_Revert(This)	\
    (This)->lpVtbl -> Revert(This)

#define ISpStreamFormat_LockRegion(This,libOffset,cb,dwLockType)	\
    (This)->lpVtbl -> LockRegion(This,libOffset,cb,dwLockType)

#define ISpStreamFormat_UnlockRegion(This,libOffset,cb,dwLockType)	\
    (This)->lpVtbl -> UnlockRegion(This,libOffset,cb,dwLockType)

#define ISpStreamFormat_Stat(This,pstatstg,grfStatFlag)	\
    (This)->lpVtbl -> Stat(This,pstatstg,grfStatFlag)

#define ISpStreamFormat_Clone(This,ppstm)	\
    (This)->lpVtbl -> Clone(This,ppstm)


#define ISpStreamFormat_GetFormat(This,pguidFormatId,ppCoMemWaveFormatEx)	\
    (This)->lpVtbl -> GetFormat(This,pguidFormatId,ppCoMemWaveFormatEx)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpStreamFormat_GetFormat_Proxy( 
    ISpStreamFormat * This,
    GUID *pguidFormatId,
    WAVEFORMATEX **ppCoMemWaveFormatEx);


void __RPC_STUB ISpStreamFormat_GetFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpStreamFormat_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sapi_0259 */
/* [local] */ 

typedef 
enum SPFILEMODE
    {	SPFM_OPEN_READONLY	= 0,
	SPFM_OPEN_READWRITE	= SPFM_OPEN_READONLY + 1,
	SPFM_CREATE	= SPFM_OPEN_READWRITE + 1,
	SPFM_CREATE_ALWAYS	= SPFM_CREATE + 1,
	SPFM_NUM_MODES	= SPFM_CREATE_ALWAYS + 1
    } 	SPFILEMODE;



extern RPC_IF_HANDLE __MIDL_itf_sapi_0259_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sapi_0259_v0_0_s_ifspec;

#ifndef __ISpStream_INTERFACE_DEFINED__
#define __ISpStream_INTERFACE_DEFINED__

/* interface ISpStream */
/* [restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISpStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12E3CCA9-7518-44C5-A5E7-BA5A79CB929E")
    ISpStream : public ISpStreamFormat
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetBaseStream( 
            IStream *pStream,
            REFGUID rguidFormat,
            const WAVEFORMATEX *pWaveFormatEx) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBaseStream( 
            IStream **ppStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindToFile( 
            const WCHAR *pszFileName,
            SPFILEMODE eMode,
            const GUID *pFormatId,
            const WAVEFORMATEX *pWaveFormatEx,
            ULONGLONG ullEventInterest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpStream * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpStream * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Read )( 
            ISpStream * This,
            /* [length_is][size_is][out] */ void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbRead);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Write )( 
            ISpStream * This,
            /* [size_is][in] */ const void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbWritten);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Seek )( 
            ISpStream * This,
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER *plibNewPosition);
        
        HRESULT ( STDMETHODCALLTYPE *SetSize )( 
            ISpStream * This,
            /* [in] */ ULARGE_INTEGER libNewSize);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CopyTo )( 
            ISpStream * This,
            /* [unique][in] */ IStream *pstm,
            /* [in] */ ULARGE_INTEGER cb,
            /* [out] */ ULARGE_INTEGER *pcbRead,
            /* [out] */ ULARGE_INTEGER *pcbWritten);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            ISpStream * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Revert )( 
            ISpStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *LockRegion )( 
            ISpStream * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockRegion )( 
            ISpStream * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *Stat )( 
            ISpStream * This,
            /* [out] */ STATSTG *pstatstg,
            /* [in] */ DWORD grfStatFlag);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ISpStream * This,
            /* [out] */ IStream **ppstm);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormat )( 
            ISpStream * This,
            GUID *pguidFormatId,
            WAVEFORMATEX **ppCoMemWaveFormatEx);
        
        HRESULT ( STDMETHODCALLTYPE *SetBaseStream )( 
            ISpStream * This,
            IStream *pStream,
            REFGUID rguidFormat,
            const WAVEFORMATEX *pWaveFormatEx);
        
        HRESULT ( STDMETHODCALLTYPE *GetBaseStream )( 
            ISpStream * This,
            IStream **ppStream);
        
        HRESULT ( STDMETHODCALLTYPE *BindToFile )( 
            ISpStream * This,
            const WCHAR *pszFileName,
            SPFILEMODE eMode,
            const GUID *pFormatId,
            const WAVEFORMATEX *pWaveFormatEx,
            ULONGLONG ullEventInterest);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            ISpStream * This);
        
        END_INTERFACE
    } ISpStreamVtbl;

    interface ISpStream
    {
        CONST_VTBL struct ISpStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpStream_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpStream_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpStream_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpStream_Read(This,pv,cb,pcbRead)	\
    (This)->lpVtbl -> Read(This,pv,cb,pcbRead)

#define ISpStream_Write(This,pv,cb,pcbWritten)	\
    (This)->lpVtbl -> Write(This,pv,cb,pcbWritten)


#define ISpStream_Seek(This,dlibMove,dwOrigin,plibNewPosition)	\
    (This)->lpVtbl -> Seek(This,dlibMove,dwOrigin,plibNewPosition)

#define ISpStream_SetSize(This,libNewSize)	\
    (This)->lpVtbl -> SetSize(This,libNewSize)

#define ISpStream_CopyTo(This,pstm,cb,pcbRead,pcbWritten)	\
    (This)->lpVtbl -> CopyTo(This,pstm,cb,pcbRead,pcbWritten)

#define ISpStream_Commit(This,grfCommitFlags)	\
    (This)->lpVtbl -> Commit(This,grfCommitFlags)

#define ISpStream_Revert(This)	\
    (This)->lpVtbl -> Revert(This)

#define ISpStream_LockRegion(This,libOffset,cb,dwLockType)	\
    (This)->lpVtbl -> LockRegion(This,libOffset,cb,dwLockType)

#define ISpStream_UnlockRegion(This,libOffset,cb,dwLockType)	\
    (This)->lpVtbl -> UnlockRegion(This,libOffset,cb,dwLockType)

#define ISpStream_Stat(This,pstatstg,grfStatFlag)	\
    (This)->lpVtbl -> Stat(This,pstatstg,grfStatFlag)

#define ISpStream_Clone(This,ppstm)	\
    (This)->lpVtbl -> Clone(This,ppstm)


#define ISpStream_GetFormat(This,pguidFormatId,ppCoMemWaveFormatEx)	\
    (This)->lpVtbl -> GetFormat(This,pguidFormatId,ppCoMemWaveFormatEx)


#define ISpStream_SetBaseStream(This,pStream,rguidFormat,pWaveFormatEx)	\
    (This)->lpVtbl -> SetBaseStream(This,pStream,rguidFormat,pWaveFormatEx)

#define ISpStream_GetBaseStream(This,ppStream)	\
    (This)->lpVtbl -> GetBaseStream(This,ppStream)

#define ISpStream_BindToFile(This,pszFileName,eMode,pFormatId,pWaveFormatEx,ullEventInterest)	\
    (This)->lpVtbl -> BindToFile(This,pszFileName,eMode,pFormatId,pWaveFormatEx,ullEventInterest)

#define ISpStream_Close(This)	\
    (This)->lpVtbl -> Close(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpStream_SetBaseStream_Proxy( 
    ISpStream * This,
    IStream *pStream,
    REFGUID rguidFormat,
    const WAVEFORMATEX *pWaveFormatEx);


void __RPC_STUB ISpStream_SetBaseStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpStream_GetBaseStream_Proxy( 
    ISpStream * This,
    IStream **ppStream);


void __RPC_STUB ISpStream_GetBaseStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpStream_BindToFile_Proxy( 
    ISpStream * This,
    const WCHAR *pszFileName,
    SPFILEMODE eMode,
    const GUID *pFormatId,
    const WAVEFORMATEX *pWaveFormatEx,
    ULONGLONG ullEventInterest);


void __RPC_STUB ISpStream_BindToFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpStream_Close_Proxy( 
    ISpStream * This);


void __RPC_STUB ISpStream_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpStream_INTERFACE_DEFINED__ */


#ifndef __ISpStreamFormatConverter_INTERFACE_DEFINED__
#define __ISpStreamFormatConverter_INTERFACE_DEFINED__

/* interface ISpStreamFormatConverter */
/* [restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISpStreamFormatConverter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("678A932C-EA71-4446-9B41-78FDA6280A29")
    ISpStreamFormatConverter : public ISpStreamFormat
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetBaseStream( 
            /* [in] */ ISpStreamFormat *pStream,
            /* [in] */ BOOL fSetFormatToBaseStreamFormat,
            /* [in] */ BOOL fWriteToBaseStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBaseStream( 
            /* [out] */ ISpStreamFormat **ppStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFormat( 
            /* [in] */ REFGUID rguidFormatIdOfConvertedStream,
            /* [in] */ const WAVEFORMATEX *pWaveFormatExOfConvertedStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetSeekPosition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ScaleConvertedToBaseOffset( 
            /* [in] */ ULONGLONG ullOffsetConvertedStream,
            /* [out] */ ULONGLONG *pullOffsetBaseStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ScaleBaseToConvertedOffset( 
            /* [in] */ ULONGLONG ullOffsetBaseStream,
            /* [out] */ ULONGLONG *pullOffsetConvertedStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpStreamFormatConverterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpStreamFormatConverter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpStreamFormatConverter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpStreamFormatConverter * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Read )( 
            ISpStreamFormatConverter * This,
            /* [length_is][size_is][out] */ void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbRead);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Write )( 
            ISpStreamFormatConverter * This,
            /* [size_is][in] */ const void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbWritten);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Seek )( 
            ISpStreamFormatConverter * This,
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER *plibNewPosition);
        
        HRESULT ( STDMETHODCALLTYPE *SetSize )( 
            ISpStreamFormatConverter * This,
            /* [in] */ ULARGE_INTEGER libNewSize);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CopyTo )( 
            ISpStreamFormatConverter * This,
            /* [unique][in] */ IStream *pstm,
            /* [in] */ ULARGE_INTEGER cb,
            /* [out] */ ULARGE_INTEGER *pcbRead,
            /* [out] */ ULARGE_INTEGER *pcbWritten);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            ISpStreamFormatConverter * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Revert )( 
            ISpStreamFormatConverter * This);
        
        HRESULT ( STDMETHODCALLTYPE *LockRegion )( 
            ISpStreamFormatConverter * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockRegion )( 
            ISpStreamFormatConverter * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *Stat )( 
            ISpStreamFormatConverter * This,
            /* [out] */ STATSTG *pstatstg,
            /* [in] */ DWORD grfStatFlag);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ISpStreamFormatConverter * This,
            /* [out] */ IStream **ppstm);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormat )( 
            ISpStreamFormatConverter * This,
            GUID *pguidFormatId,
            WAVEFORMATEX **ppCoMemWaveFormatEx);
        
        HRESULT ( STDMETHODCALLTYPE *SetBaseStream )( 
            ISpStreamFormatConverter * This,
            /* [in] */ ISpStreamFormat *pStream,
            /* [in] */ BOOL fSetFormatToBaseStreamFormat,
            /* [in] */ BOOL fWriteToBaseStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetBaseStream )( 
            ISpStreamFormatConverter * This,
            /* [out] */ ISpStreamFormat **ppStream);
        
        HRESULT ( STDMETHODCALLTYPE *SetFormat )( 
            ISpStreamFormatConverter * This,
            /* [in] */ REFGUID rguidFormatIdOfConvertedStream,
            /* [in] */ const WAVEFORMATEX *pWaveFormatExOfConvertedStream);
        
        HRESULT ( STDMETHODCALLTYPE *ResetSeekPosition )( 
            ISpStreamFormatConverter * This);
        
        HRESULT ( STDMETHODCALLTYPE *ScaleConvertedToBaseOffset )( 
            ISpStreamFormatConverter * This,
            /* [in] */ ULONGLONG ullOffsetConvertedStream,
            /* [out] */ ULONGLONG *pullOffsetBaseStream);
        
        HRESULT ( STDMETHODCALLTYPE *ScaleBaseToConvertedOffset )( 
            ISpStreamFormatConverter * This,
            /* [in] */ ULONGLONG ullOffsetBaseStream,
            /* [out] */ ULONGLONG *pullOffsetConvertedStream);
        
        END_INTERFACE
    } ISpStreamFormatConverterVtbl;

    interface ISpStreamFormatConverter
    {
        CONST_VTBL struct ISpStreamFormatConverterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpStreamFormatConverter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpStreamFormatConverter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpStreamFormatConverter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpStreamFormatConverter_Read(This,pv,cb,pcbRead)	\
    (This)->lpVtbl -> Read(This,pv,cb,pcbRead)

#define ISpStreamFormatConverter_Write(This,pv,cb,pcbWritten)	\
    (This)->lpVtbl -> Write(This,pv,cb,pcbWritten)


#define ISpStreamFormatConverter_Seek(This,dlibMove,dwOrigin,plibNewPosition)	\
    (This)->lpVtbl -> Seek(This,dlibMove,dwOrigin,plibNewPosition)

#define ISpStreamFormatConverter_SetSize(This,libNewSize)	\
    (This)->lpVtbl -> SetSize(This,libNewSize)

#define ISpStreamFormatConverter_CopyTo(This,pstm,cb,pcbRead,pcbWritten)	\
    (This)->lpVtbl -> CopyTo(This,pstm,cb,pcbRead,pcbWritten)

#define ISpStreamFormatConverter_Commit(This,grfCommitFlags)	\
    (This)->lpVtbl -> Commit(This,grfCommitFlags)

#define ISpStreamFormatConverter_Revert(This)	\
    (This)->lpVtbl -> Revert(This)

#define ISpStreamFormatConverter_LockRegion(This,libOffset,cb,dwLockType)	\
    (This)->lpVtbl -> LockRegion(This,libOffset,cb,dwLockType)

#define ISpStreamFormatConverter_UnlockRegion(This,libOffset,cb,dwLockType)	\
    (This)->lpVtbl -> UnlockRegion(This,libOffset,cb,dwLockType)

#define ISpStreamFormatConverter_Stat(This,pstatstg,grfStatFlag)	\
    (This)->lpVtbl -> Stat(This,pstatstg,grfStatFlag)

#define ISpStreamFormatConverter_Clone(This,ppstm)	\
    (This)->lpVtbl -> Clone(This,ppstm)


#define ISpStreamFormatConverter_GetFormat(This,pguidFormatId,ppCoMemWaveFormatEx)	\
    (This)->lpVtbl -> GetFormat(This,pguidFormatId,ppCoMemWaveFormatEx)


#define ISpStreamFormatConverter_SetBaseStream(This,pStream,fSetFormatToBaseStreamFormat,fWriteToBaseStream)	\
    (This)->lpVtbl -> SetBaseStream(This,pStream,fSetFormatToBaseStreamFormat,fWriteToBaseStream)

#define ISpStreamFormatConverter_GetBaseStream(This,ppStream)	\
    (This)->lpVtbl -> GetBaseStream(This,ppStream)

#define ISpStreamFormatConverter_SetFormat(This,rguidFormatIdOfConvertedStream,pWaveFormatExOfConvertedStream)	\
    (This)->lpVtbl -> SetFormat(This,rguidFormatIdOfConvertedStream,pWaveFormatExOfConvertedStream)

#define ISpStreamFormatConverter_ResetSeekPosition(This)	\
    (This)->lpVtbl -> ResetSeekPosition(This)

#define ISpStreamFormatConverter_ScaleConvertedToBaseOffset(This,ullOffsetConvertedStream,pullOffsetBaseStream)	\
    (This)->lpVtbl -> ScaleConvertedToBaseOffset(This,ullOffsetConvertedStream,pullOffsetBaseStream)

#define ISpStreamFormatConverter_ScaleBaseToConvertedOffset(This,ullOffsetBaseStream,pullOffsetConvertedStream)	\
    (This)->lpVtbl -> ScaleBaseToConvertedOffset(This,ullOffsetBaseStream,pullOffsetConvertedStream)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpStreamFormatConverter_SetBaseStream_Proxy( 
    ISpStreamFormatConverter * This,
    /* [in] */ ISpStreamFormat *pStream,
    /* [in] */ BOOL fSetFormatToBaseStreamFormat,
    /* [in] */ BOOL fWriteToBaseStream);


void __RPC_STUB ISpStreamFormatConverter_SetBaseStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpStreamFormatConverter_GetBaseStream_Proxy( 
    ISpStreamFormatConverter * This,
    /* [out] */ ISpStreamFormat **ppStream);


void __RPC_STUB ISpStreamFormatConverter_GetBaseStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpStreamFormatConverter_SetFormat_Proxy( 
    ISpStreamFormatConverter * This,
    /* [in] */ REFGUID rguidFormatIdOfConvertedStream,
    /* [in] */ const WAVEFORMATEX *pWaveFormatExOfConvertedStream);


void __RPC_STUB ISpStreamFormatConverter_SetFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpStreamFormatConverter_ResetSeekPosition_Proxy( 
    ISpStreamFormatConverter * This);


void __RPC_STUB ISpStreamFormatConverter_ResetSeekPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpStreamFormatConverter_ScaleConvertedToBaseOffset_Proxy( 
    ISpStreamFormatConverter * This,
    /* [in] */ ULONGLONG ullOffsetConvertedStream,
    /* [out] */ ULONGLONG *pullOffsetBaseStream);


void __RPC_STUB ISpStreamFormatConverter_ScaleConvertedToBaseOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpStreamFormatConverter_ScaleBaseToConvertedOffset_Proxy( 
    ISpStreamFormatConverter * This,
    /* [in] */ ULONGLONG ullOffsetBaseStream,
    /* [out] */ ULONGLONG *pullOffsetConvertedStream);


void __RPC_STUB ISpStreamFormatConverter_ScaleBaseToConvertedOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpStreamFormatConverter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sapi_0261 */
/* [local] */ 

typedef 
enum _SPAUDIOSTATE
    {	SPAS_CLOSED	= 0,
	SPAS_STOP	= SPAS_CLOSED + 1,
	SPAS_PAUSE	= SPAS_STOP + 1,
	SPAS_RUN	= SPAS_PAUSE + 1
    } 	SPAUDIOSTATE;

typedef /* [restricted] */ struct SPAUDIOSTATUS
    {
    long cbFreeBuffSpace;
    ULONG cbNonBlockingIO;
    SPAUDIOSTATE State;
    ULONGLONG CurSeekPos;
    ULONGLONG CurDevicePos;
    DWORD dwReserved1;
    DWORD dwReserved2;
    } 	SPAUDIOSTATUS;

typedef /* [restricted] */ struct SPAUDIOBUFFERINFO
    {
    ULONG ulMsMinNotification;
    ULONG ulMsBufferSize;
    ULONG ulMsEventBias;
    } 	SPAUDIOBUFFERINFO;



extern RPC_IF_HANDLE __MIDL_itf_sapi_0261_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sapi_0261_v0_0_s_ifspec;

#ifndef __ISpAudio_INTERFACE_DEFINED__
#define __ISpAudio_INTERFACE_DEFINED__

/* interface ISpAudio */
/* [restricted][local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISpAudio;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C05C768F-FAE8-4EC2-8E07-338321C12452")
    ISpAudio : public ISpStreamFormat
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetState( 
            /* [in] */ SPAUDIOSTATE NewState,
            /* [in] */ ULONGLONG ullReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFormat( 
            /* [in] */ REFGUID rguidFmtId,
            /* [in] */ const WAVEFORMATEX *pWaveFormatEx) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ SPAUDIOSTATUS *pStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBufferInfo( 
            /* [in] */ const SPAUDIOBUFFERINFO *pBuffInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferInfo( 
            /* [out] */ SPAUDIOBUFFERINFO *pBuffInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultFormat( 
            /* [out] */ GUID *pFormatId,
            /* [out] */ WAVEFORMATEX **ppCoMemWaveFormatEx) = 0;
        
        virtual HANDLE STDMETHODCALLTYPE EventHandle( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVolumeLevel( 
            /* [out] */ ULONG *pLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVolumeLevel( 
            /* [in] */ ULONG Level) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferNotifySize( 
            /* [out] */ ULONG *pcbSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBufferNotifySize( 
            /* [in] */ ULONG cbSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpAudioVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpAudio * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpAudio * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpAudio * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Read )( 
            ISpAudio * This,
            /* [length_is][size_is][out] */ void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbRead);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Write )( 
            ISpAudio * This,
            /* [size_is][in] */ const void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbWritten);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Seek )( 
            ISpAudio * This,
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER *plibNewPosition);
        
        HRESULT ( STDMETHODCALLTYPE *SetSize )( 
            ISpAudio * This,
            /* [in] */ ULARGE_INTEGER libNewSize);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CopyTo )( 
            ISpAudio * This,
            /* [unique][in] */ IStream *pstm,
            /* [in] */ ULARGE_INTEGER cb,
            /* [out] */ ULARGE_INTEGER *pcbRead,
            /* [out] */ ULARGE_INTEGER *pcbWritten);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            ISpAudio * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Revert )( 
            ISpAudio * This);
        
        HRESULT ( STDMETHODCALLTYPE *LockRegion )( 
            ISpAudio * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockRegion )( 
            ISpAudio * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *Stat )( 
            ISpAudio * This,
            /* [out] */ STATSTG *pstatstg,
            /* [in] */ DWORD grfStatFlag);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ISpAudio * This,
            /* [out] */ IStream **ppstm);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormat )( 
            ISpAudio * This,
            GUID *pguidFormatId,
            WAVEFORMATEX **ppCoMemWaveFormatEx);
        
        HRESULT ( STDMETHODCALLTYPE *SetState )( 
            ISpAudio * This,
            /* [in] */ SPAUDIOSTATE NewState,
            /* [in] */ ULONGLONG ullReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SetFormat )( 
            ISpAudio * This,
            /* [in] */ REFGUID rguidFmtId,
            /* [in] */ const WAVEFORMATEX *pWaveFormatEx);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            ISpAudio * This,
            /* [out] */ SPAUDIOSTATUS *pStatus);
        
        HRESULT ( STDMETHODCALLTYPE *SetBufferInfo )( 
            ISpAudio * This,
            /* [in] */ const SPAUDIOBUFFERINFO *pBuffInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferInfo )( 
            ISpAudio * This,
            /* [out] */ SPAUDIOBUFFERINFO *pBuffInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultFormat )( 
            ISpAudio * This,
            /* [out] */ GUID *pFormatId,
            /* [out] */ WAVEFORMATEX **ppCoMemWaveFormatEx);
        
        HANDLE ( STDMETHODCALLTYPE *EventHandle )( 
            ISpAudio * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVolumeLevel )( 
            ISpAudio * This,
            /* [out] */ ULONG *pLevel);
        
        HRESULT ( STDMETHODCALLTYPE *SetVolumeLevel )( 
            ISpAudio * This,
            /* [in] */ ULONG Level);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferNotifySize )( 
            ISpAudio * This,
            /* [out] */ ULONG *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetBufferNotifySize )( 
            ISpAudio * This,
            /* [in] */ ULONG cbSize);
        
        END_INTERFACE
    } ISpAudioVtbl;

    interface ISpAudio
    {
        CONST_VTBL struct ISpAudioVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpAudio_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpAudio_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpAudio_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpAudio_Read(This,pv,cb,pcbRead)	\
    (This)->lpVtbl -> Read(This,pv,cb,pcbRead)

#define ISpAudio_Write(This,pv,cb,pcbWritten)	\
    (This)->lpVtbl -> Write(This,pv,cb,pcbWritten)


#define ISpAudio_Seek(This,dlibMove,dwOrigin,plibNewPosition)	\
    (This)->lpVtbl -> Seek(This,dlibMove,dwOrigin,plibNewPosition)

#define ISpAudio_SetSize(This,libNewSize)	\
    (This)->lpVtbl -> SetSize(This,libNewSize)

#define ISpAudio_CopyTo(This,pstm,cb,pcbRead,pcbWritten)	\
    (This)->lpVtbl -> CopyTo(This,pstm,cb,pcbRead,pcbWritten)

#define ISpAudio_Commit(This,grfCommitFlags)	\
    (This)->lpVtbl -> Commit(This,grfCommitFlags)

#define ISpAudio_Revert(This)	\
    (This)->lpVtbl -> Revert(This)

#define ISpAudio_LockRegion(This,libOffset,cb,dwLockType)	\
    (This)->lpVtbl -> LockRegion(This,libOffset,cb,dwLockType)

#define ISpAudio_UnlockRegion(This,libOffset,cb,dwLockType)	\
    (This)->lpVtbl -> UnlockRegion(This,libOffset,cb,dwLockType)

#define ISpAudio_Stat(This,pstatstg,grfStatFlag)	\
    (This)->lpVtbl -> Stat(This,pstatstg,grfStatFlag)

#define ISpAudio_Clone(This,ppstm)	\
    (This)->lpVtbl -> Clone(This,ppstm)


#define ISpAudio_GetFormat(This,pguidFormatId,ppCoMemWaveFormatEx)	\
    (This)->lpVtbl -> GetFormat(This,pguidFormatId,ppCoMemWaveFormatEx)


#define ISpAudio_SetState(This,NewState,ullReserved)	\
    (This)->lpVtbl -> SetState(This,NewState,ullReserved)

#define ISpAudio_SetFormat(This,rguidFmtId,pWaveFormatEx)	\
    (This)->lpVtbl -> SetFormat(This,rguidFmtId,pWaveFormatEx)

#define ISpAudio_GetStatus(This,pStatus)	\
    (This)->lpVtbl -> GetStatus(This,pStatus)

#define ISpAudio_SetBufferInfo(This,pBuffInfo)	\
    (This)->lpVtbl -> SetBufferInfo(This,pBuffInfo)

#define ISpAudio_GetBufferInfo(This,pBuffInfo)	\
    (This)->lpVtbl -> GetBufferInfo(This,pBuffInfo)

#define ISpAudio_GetDefaultFormat(This,pFormatId,ppCoMemWaveFormatEx)	\
    (This)->lpVtbl -> GetDefaultFormat(This,pFormatId,ppCoMemWaveFormatEx)

#define ISpAudio_EventHandle(This)	\
    (This)->lpVtbl -> EventHandle(This)

#define ISpAudio_GetVolumeLevel(This,pLevel)	\
    (This)->lpVtbl -> GetVolumeLevel(This,pLevel)

#define ISpAudio_SetVolumeLevel(This,Level)	\
    (This)->lpVtbl -> SetVolumeLevel(This,Level)

#define ISpAudio_GetBufferNotifySize(This,pcbSize)	\
    (This)->lpVtbl -> GetBufferNotifySize(This,pcbSize)

#define ISpAudio_SetBufferNotifySize(This,cbSize)	\
    (This)->lpVtbl -> SetBufferNotifySize(This,cbSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpAudio_SetState_Proxy( 
    ISpAudio * This,
    /* [in] */ SPAUDIOSTATE NewState,
    /* [in] */ ULONGLONG ullReserved);


void __RPC_STUB ISpAudio_SetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpAudio_SetFormat_Proxy( 
    ISpAudio * This,
    /* [in] */ REFGUID rguidFmtId,
    /* [in] */ const WAVEFORMATEX *pWaveFormatEx);


void __RPC_STUB ISpAudio_SetFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpAudio_GetStatus_Proxy( 
    ISpAudio * This,
    /* [out] */ SPAUDIOSTATUS *pStatus);


void __RPC_STUB ISpAudio_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpAudio_SetBufferInfo_Proxy( 
    ISpAudio * This,
    /* [in] */ const SPAUDIOBUFFERINFO *pBuffInfo);


void __RPC_STUB ISpAudio_SetBufferInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpAudio_GetBufferInfo_Proxy( 
    ISpAudio * This,
    /* [out] */ SPAUDIOBUFFERINFO *pBuffInfo);


void __RPC_STUB ISpAudio_GetBufferInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpAudio_GetDefaultFormat_Proxy( 
    ISpAudio * This,
    /* [out] */ GUID *pFormatId,
    /* [out] */ WAVEFORMATEX **ppCoMemWaveFormatEx);


void __RPC_STUB ISpAudio_GetDefaultFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HANDLE STDMETHODCALLTYPE ISpAudio_EventHandle_Proxy( 
    ISpAudio * This);


void __RPC_STUB ISpAudio_EventHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpAudio_GetVolumeLevel_Proxy( 
    ISpAudio * This,
    /* [out] */ ULONG *pLevel);


void __RPC_STUB ISpAudio_GetVolumeLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpAudio_SetVolumeLevel_Proxy( 
    ISpAudio * This,
    /* [in] */ ULONG Level);


void __RPC_STUB ISpAudio_SetVolumeLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpAudio_GetBufferNotifySize_Proxy( 
    ISpAudio * This,
    /* [out] */ ULONG *pcbSize);


void __RPC_STUB ISpAudio_GetBufferNotifySize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpAudio_SetBufferNotifySize_Proxy( 
    ISpAudio * This,
    /* [in] */ ULONG cbSize);


void __RPC_STUB ISpAudio_SetBufferNotifySize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpAudio_INTERFACE_DEFINED__ */


#ifndef __ISpMMSysAudio_INTERFACE_DEFINED__
#define __ISpMMSysAudio_INTERFACE_DEFINED__

/* interface ISpMMSysAudio */
/* [restricted][local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISpMMSysAudio;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("15806F6E-1D70-4B48-98E6-3B1A007509AB")
    ISpMMSysAudio : public ISpAudio
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDeviceId( 
            /* [out] */ UINT *puDeviceId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDeviceId( 
            /* [in] */ UINT uDeviceId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMMHandle( 
            void **pHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLineId( 
            /* [out] */ UINT *puLineId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLineId( 
            /* [in] */ UINT uLineId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpMMSysAudioVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpMMSysAudio * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpMMSysAudio * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpMMSysAudio * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Read )( 
            ISpMMSysAudio * This,
            /* [length_is][size_is][out] */ void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbRead);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Write )( 
            ISpMMSysAudio * This,
            /* [size_is][in] */ const void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbWritten);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Seek )( 
            ISpMMSysAudio * This,
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER *plibNewPosition);
        
        HRESULT ( STDMETHODCALLTYPE *SetSize )( 
            ISpMMSysAudio * This,
            /* [in] */ ULARGE_INTEGER libNewSize);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CopyTo )( 
            ISpMMSysAudio * This,
            /* [unique][in] */ IStream *pstm,
            /* [in] */ ULARGE_INTEGER cb,
            /* [out] */ ULARGE_INTEGER *pcbRead,
            /* [out] */ ULARGE_INTEGER *pcbWritten);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            ISpMMSysAudio * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Revert )( 
            ISpMMSysAudio * This);
        
        HRESULT ( STDMETHODCALLTYPE *LockRegion )( 
            ISpMMSysAudio * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockRegion )( 
            ISpMMSysAudio * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *Stat )( 
            ISpMMSysAudio * This,
            /* [out] */ STATSTG *pstatstg,
            /* [in] */ DWORD grfStatFlag);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ISpMMSysAudio * This,
            /* [out] */ IStream **ppstm);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormat )( 
            ISpMMSysAudio * This,
            GUID *pguidFormatId,
            WAVEFORMATEX **ppCoMemWaveFormatEx);
        
        HRESULT ( STDMETHODCALLTYPE *SetState )( 
            ISpMMSysAudio * This,
            /* [in] */ SPAUDIOSTATE NewState,
            /* [in] */ ULONGLONG ullReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SetFormat )( 
            ISpMMSysAudio * This,
            /* [in] */ REFGUID rguidFmtId,
            /* [in] */ const WAVEFORMATEX *pWaveFormatEx);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            ISpMMSysAudio * This,
            /* [out] */ SPAUDIOSTATUS *pStatus);
        
        HRESULT ( STDMETHODCALLTYPE *SetBufferInfo )( 
            ISpMMSysAudio * This,
            /* [in] */ const SPAUDIOBUFFERINFO *pBuffInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferInfo )( 
            ISpMMSysAudio * This,
            /* [out] */ SPAUDIOBUFFERINFO *pBuffInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultFormat )( 
            ISpMMSysAudio * This,
            /* [out] */ GUID *pFormatId,
            /* [out] */ WAVEFORMATEX **ppCoMemWaveFormatEx);
        
        HANDLE ( STDMETHODCALLTYPE *EventHandle )( 
            ISpMMSysAudio * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVolumeLevel )( 
            ISpMMSysAudio * This,
            /* [out] */ ULONG *pLevel);
        
        HRESULT ( STDMETHODCALLTYPE *SetVolumeLevel )( 
            ISpMMSysAudio * This,
            /* [in] */ ULONG Level);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferNotifySize )( 
            ISpMMSysAudio * This,
            /* [out] */ ULONG *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetBufferNotifySize )( 
            ISpMMSysAudio * This,
            /* [in] */ ULONG cbSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceId )( 
            ISpMMSysAudio * This,
            /* [out] */ UINT *puDeviceId);
        
        HRESULT ( STDMETHODCALLTYPE *SetDeviceId )( 
            ISpMMSysAudio * This,
            /* [in] */ UINT uDeviceId);
        
        HRESULT ( STDMETHODCALLTYPE *GetMMHandle )( 
            ISpMMSysAudio * This,
            void **pHandle);
        
        HRESULT ( STDMETHODCALLTYPE *GetLineId )( 
            ISpMMSysAudio * This,
            /* [out] */ UINT *puLineId);
        
        HRESULT ( STDMETHODCALLTYPE *SetLineId )( 
            ISpMMSysAudio * This,
            /* [in] */ UINT uLineId);
        
        END_INTERFACE
    } ISpMMSysAudioVtbl;

    interface ISpMMSysAudio
    {
        CONST_VTBL struct ISpMMSysAudioVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpMMSysAudio_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpMMSysAudio_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpMMSysAudio_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpMMSysAudio_Read(This,pv,cb,pcbRead)	\
    (This)->lpVtbl -> Read(This,pv,cb,pcbRead)

#define ISpMMSysAudio_Write(This,pv,cb,pcbWritten)	\
    (This)->lpVtbl -> Write(This,pv,cb,pcbWritten)


#define ISpMMSysAudio_Seek(This,dlibMove,dwOrigin,plibNewPosition)	\
    (This)->lpVtbl -> Seek(This,dlibMove,dwOrigin,plibNewPosition)

#define ISpMMSysAudio_SetSize(This,libNewSize)	\
    (This)->lpVtbl -> SetSize(This,libNewSize)

#define ISpMMSysAudio_CopyTo(This,pstm,cb,pcbRead,pcbWritten)	\
    (This)->lpVtbl -> CopyTo(This,pstm,cb,pcbRead,pcbWritten)

#define ISpMMSysAudio_Commit(This,grfCommitFlags)	\
    (This)->lpVtbl -> Commit(This,grfCommitFlags)

#define ISpMMSysAudio_Revert(This)	\
    (This)->lpVtbl -> Revert(This)

#define ISpMMSysAudio_LockRegion(This,libOffset,cb,dwLockType)	\
    (This)->lpVtbl -> LockRegion(This,libOffset,cb,dwLockType)

#define ISpMMSysAudio_UnlockRegion(This,libOffset,cb,dwLockType)	\
    (This)->lpVtbl -> UnlockRegion(This,libOffset,cb,dwLockType)

#define ISpMMSysAudio_Stat(This,pstatstg,grfStatFlag)	\
    (This)->lpVtbl -> Stat(This,pstatstg,grfStatFlag)

#define ISpMMSysAudio_Clone(This,ppstm)	\
    (This)->lpVtbl -> Clone(This,ppstm)


#define ISpMMSysAudio_GetFormat(This,pguidFormatId,ppCoMemWaveFormatEx)	\
    (This)->lpVtbl -> GetFormat(This,pguidFormatId,ppCoMemWaveFormatEx)


#define ISpMMSysAudio_SetState(This,NewState,ullReserved)	\
    (This)->lpVtbl -> SetState(This,NewState,ullReserved)

#define ISpMMSysAudio_SetFormat(This,rguidFmtId,pWaveFormatEx)	\
    (This)->lpVtbl -> SetFormat(This,rguidFmtId,pWaveFormatEx)

#define ISpMMSysAudio_GetStatus(This,pStatus)	\
    (This)->lpVtbl -> GetStatus(This,pStatus)

#define ISpMMSysAudio_SetBufferInfo(This,pBuffInfo)	\
    (This)->lpVtbl -> SetBufferInfo(This,pBuffInfo)

#define ISpMMSysAudio_GetBufferInfo(This,pBuffInfo)	\
    (This)->lpVtbl -> GetBufferInfo(This,pBuffInfo)

#define ISpMMSysAudio_GetDefaultFormat(This,pFormatId,ppCoMemWaveFormatEx)	\
    (This)->lpVtbl -> GetDefaultFormat(This,pFormatId,ppCoMemWaveFormatEx)

#define ISpMMSysAudio_EventHandle(This)	\
    (This)->lpVtbl -> EventHandle(This)

#define ISpMMSysAudio_GetVolumeLevel(This,pLevel)	\
    (This)->lpVtbl -> GetVolumeLevel(This,pLevel)

#define ISpMMSysAudio_SetVolumeLevel(This,Level)	\
    (This)->lpVtbl -> SetVolumeLevel(This,Level)

#define ISpMMSysAudio_GetBufferNotifySize(This,pcbSize)	\
    (This)->lpVtbl -> GetBufferNotifySize(This,pcbSize)

#define ISpMMSysAudio_SetBufferNotifySize(This,cbSize)	\
    (This)->lpVtbl -> SetBufferNotifySize(This,cbSize)


#define ISpMMSysAudio_GetDeviceId(This,puDeviceId)	\
    (This)->lpVtbl -> GetDeviceId(This,puDeviceId)

#define ISpMMSysAudio_SetDeviceId(This,uDeviceId)	\
    (This)->lpVtbl -> SetDeviceId(This,uDeviceId)

#define ISpMMSysAudio_GetMMHandle(This,pHandle)	\
    (This)->lpVtbl -> GetMMHandle(This,pHandle)

#define ISpMMSysAudio_GetLineId(This,puLineId)	\
    (This)->lpVtbl -> GetLineId(This,puLineId)

#define ISpMMSysAudio_SetLineId(This,uLineId)	\
    (This)->lpVtbl -> SetLineId(This,uLineId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpMMSysAudio_GetDeviceId_Proxy( 
    ISpMMSysAudio * This,
    /* [out] */ UINT *puDeviceId);


void __RPC_STUB ISpMMSysAudio_GetDeviceId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpMMSysAudio_SetDeviceId_Proxy( 
    ISpMMSysAudio * This,
    /* [in] */ UINT uDeviceId);


void __RPC_STUB ISpMMSysAudio_SetDeviceId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpMMSysAudio_GetMMHandle_Proxy( 
    ISpMMSysAudio * This,
    void **pHandle);


void __RPC_STUB ISpMMSysAudio_GetMMHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpMMSysAudio_GetLineId_Proxy( 
    ISpMMSysAudio * This,
    /* [out] */ UINT *puLineId);


void __RPC_STUB ISpMMSysAudio_GetLineId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpMMSysAudio_SetLineId_Proxy( 
    ISpMMSysAudio * This,
    /* [in] */ UINT uLineId);


void __RPC_STUB ISpMMSysAudio_SetLineId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpMMSysAudio_INTERFACE_DEFINED__ */


#ifndef __ISpTranscript_INTERFACE_DEFINED__
#define __ISpTranscript_INTERFACE_DEFINED__

/* interface ISpTranscript */
/* [restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISpTranscript;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10F63BCE-201A-11D3-AC70-00C04F8EE6C0")
    ISpTranscript : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTranscript( 
            /* [string][out] */ WCHAR **ppszTranscript) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppendTranscript( 
            /* [string][in] */ const WCHAR *pszTranscript) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpTranscriptVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpTranscript * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpTranscript * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpTranscript * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTranscript )( 
            ISpTranscript * This,
            /* [string][out] */ WCHAR **ppszTranscript);
        
        HRESULT ( STDMETHODCALLTYPE *AppendTranscript )( 
            ISpTranscript * This,
            /* [string][in] */ const WCHAR *pszTranscript);
        
        END_INTERFACE
    } ISpTranscriptVtbl;

    interface ISpTranscript
    {
        CONST_VTBL struct ISpTranscriptVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpTranscript_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpTranscript_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpTranscript_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpTranscript_GetTranscript(This,ppszTranscript)	\
    (This)->lpVtbl -> GetTranscript(This,ppszTranscript)

#define ISpTranscript_AppendTranscript(This,pszTranscript)	\
    (This)->lpVtbl -> AppendTranscript(This,pszTranscript)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpTranscript_GetTranscript_Proxy( 
    ISpTranscript * This,
    /* [string][out] */ WCHAR **ppszTranscript);


void __RPC_STUB ISpTranscript_GetTranscript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpTranscript_AppendTranscript_Proxy( 
    ISpTranscript * This,
    /* [string][in] */ const WCHAR *pszTranscript);


void __RPC_STUB ISpTranscript_AppendTranscript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpTranscript_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sapi_0264 */
/* [local] */ 

typedef 
enum SPDISPLYATTRIBUTES
    {	SPAF_ONE_TRAILING_SPACE	= 0x2,
	SPAF_TWO_TRAILING_SPACES	= 0x4,
	SPAF_CONSUME_LEADING_SPACES	= 0x8,
	SPAF_ALL	= 0xf
    } 	SPDISPLAYATTRIBUTES;

typedef unsigned short SPPHONEID;

typedef /* [restricted] */ struct SPPHRASEELEMENT
    {
    ULONG ulAudioTimeOffset;
    ULONG ulAudioSizeTime;
    ULONG ulAudioStreamOffset;
    ULONG ulAudioSizeBytes;
    ULONG ulRetainedStreamOffset;
    ULONG ulRetainedSizeBytes;
    const WCHAR *pszDisplayText;
    const WCHAR *pszLexicalForm;
    const SPPHONEID *pszPronunciation;
    BYTE bDisplayAttributes;
    signed char RequiredConfidence;
    signed char ActualConfidence;
    BYTE Reserved;
    float SREngineConfidence;
    } 	SPPHRASEELEMENT;

typedef /* [restricted] */ struct SPPHRASERULE SPPHRASERULE;

struct SPPHRASERULE
    {
    const WCHAR *pszName;
    ULONG ulId;
    ULONG ulFirstElement;
    ULONG ulCountOfElements;
    const SPPHRASERULE *pNextSibling;
    const SPPHRASERULE *pFirstChild;
    float SREngineConfidence;
    signed char Confidence;
    } ;
typedef /* [restricted] */ struct SPPHRASEPROPERTY SPPHRASEPROPERTY;

struct SPPHRASEPROPERTY
    {
    const WCHAR *pszName;
    ULONG ulId;
    const WCHAR *pszValue;
    VARIANT vValue;
    ULONG ulFirstElement;
    ULONG ulCountOfElements;
    const SPPHRASEPROPERTY *pNextSibling;
    const SPPHRASEPROPERTY *pFirstChild;
    float SREngineConfidence;
    signed char Confidence;
    } ;
typedef /* [restricted] */ struct SPPHRASEREPLACEMENT
    {
    BYTE bDisplayAttributes;
    const WCHAR *pszReplacementText;
    ULONG ulFirstElement;
    ULONG ulCountOfElements;
    } 	SPPHRASEREPLACEMENT;

typedef /* [restricted] */ struct SPPHRASE
    {
    ULONG cbSize;
    WORD LangID;
    WORD wReserved;
    ULONGLONG ullGrammarID;
    ULONGLONG ftStartTime;
    ULONGLONG ullAudioStreamPosition;
    ULONG ulAudioSizeBytes;
    ULONG ulRetainedSizeBytes;
    ULONG ulAudioSizeTime;
    SPPHRASERULE Rule;
    const SPPHRASEPROPERTY *pProperties;
    const SPPHRASEELEMENT *pElements;
    ULONG cReplacements;
    const SPPHRASEREPLACEMENT *pReplacements;
    GUID SREngineID;
    ULONG ulSREnginePrivateDataSize;
    const BYTE *pSREnginePrivateData;
    } 	SPPHRASE;

typedef /* [restricted] */ struct SPSERIALIZEDPHRASE
    {
    ULONG ulSerializedSize;
    } 	SPSERIALIZEDPHRASE;

typedef 
enum SPVALUETYPE
    {	SPDF_PROPERTY	= 0x1,
	SPDF_REPLACEMENT	= 0x2,
	SPDF_RULE	= 0x4,
	SPDF_DISPLAYTEXT	= 0x8,
	SPDF_LEXICALFORM	= 0x10,
	SPDF_PRONUNCIATION	= 0x20,
	SPDF_AUDIO	= 0x40,
	SPDF_ALTERNATES	= 0x80,
	SPDF_ALL	= 0xff
    } 	SPVALUETYPE;

typedef struct SPBINARYGRAMMAR
    {
    ULONG ulTotalSerializedSize;
    } 	SPBINARYGRAMMAR;

typedef 
enum SPPHRASERNG
    {	SPPR_ALL_ELEMENTS	= -1
    } 	SPPHRASERNG;

#define SP_GETWHOLEPHRASE SPPR_ALL_ELEMENTS
#define SPRR_ALL_ELEMENTS SPPR_ALL_ELEMENTS
#if 0
typedef void *SPSTATEHANDLE;

#else
DECLARE_HANDLE(SPSTATEHANDLE);
#endif
typedef 
enum SPRECOEVENTFLAGS
    {	SPREF_AutoPause	= 1 << 0,
	SPREF_Emulated	= 1 << 1
    } 	SPRECOECOEVENTFLAGS;

typedef 
enum SPPARTOFSPEECH
    {	SPPS_NotOverriden	= -1,
	SPPS_Unknown	= 0,
	SPPS_Noun	= 0x1000,
	SPPS_Verb	= 0x2000,
	SPPS_Modifier	= 0x3000,
	SPPS_Function	= 0x4000,
	SPPS_Interjection	= 0x5000
    } 	SPPARTOFSPEECH;

typedef 
enum SPLEXICONTYPE
    {	eLEXTYPE_USER	= 1L << 0,
	eLEXTYPE_APP	= 1L << 1,
	eLEXTYPE_RESERVED1	= 1L << 2,
	eLEXTYPE_RESERVED2	= 1L << 3,
	eLEXTYPE_RESERVED3	= 1L << 4,
	eLEXTYPE_RESERVED4	= 1L << 5,
	eLEXTYPE_RESERVED5	= 1L << 6,
	eLEXTYPE_RESERVED6	= 1L << 7,
	eLEXTYPE_RESERVED7	= 1L << 8,
	eLEXTYPE_RESERVED8	= 1L << 9,
	eLEXTYPE_RESERVED9	= 1L << 10,
	eLEXTYPE_RESERVED10	= 1L << 11,
	eLEXTYPE_PRIVATE1	= 1L << 12,
	eLEXTYPE_PRIVATE2	= 1L << 13,
	eLEXTYPE_PRIVATE3	= 1L << 14,
	eLEXTYPE_PRIVATE4	= 1L << 15,
	eLEXTYPE_PRIVATE5	= 1L << 16,
	eLEXTYPE_PRIVATE6	= 1L << 17,
	eLEXTYPE_PRIVATE7	= 1L << 18,
	eLEXTYPE_PRIVATE8	= 1L << 19,
	eLEXTYPE_PRIVATE9	= 1L << 20,
	eLEXTYPE_PRIVATE10	= 1L << 21,
	eLEXTYPE_PRIVATE11	= 1L << 22,
	eLEXTYPE_PRIVATE12	= 1L << 23,
	eLEXTYPE_PRIVATE13	= 1L << 24,
	eLEXTYPE_PRIVATE14	= 1L << 25,
	eLEXTYPE_PRIVATE15	= 1L << 26,
	eLEXTYPE_PRIVATE16	= 1L << 27,
	eLEXTYPE_PRIVATE17	= 1L << 28,
	eLEXTYPE_PRIVATE18	= 1L << 29,
	eLEXTYPE_PRIVATE19	= 1L << 30,
	eLEXTYPE_PRIVATE20	= 1L << 31
    } 	SPLEXICONTYPE;

typedef 
enum SPWORDTYPE
    {	eWORDTYPE_ADDED	= 1L << 0,
	eWORDTYPE_DELETED	= 1L << 1
    } 	SPWORDTYPE;

typedef /* [restricted] */ struct SPWORDPRONUNCIATION
    {
    struct SPWORDPRONUNCIATION *pNextWordPronunciation;
    SPLEXICONTYPE eLexiconType;
    WORD LangID;
    WORD wReserved;
    SPPARTOFSPEECH ePartOfSpeech;
    SPPHONEID szPronunciation[ 1 ];
    } 	SPWORDPRONUNCIATION;

typedef /* [restricted] */ struct SPWORDPRONUNCIATIONLIST
    {
    ULONG ulSize;
    BYTE *pvBuffer;
    SPWORDPRONUNCIATION *pFirstWordPronunciation;
    } 	SPWORDPRONUNCIATIONLIST;

typedef /* [restricted] */ struct SPWORD
    {
    struct SPWORD *pNextWord;
    WORD LangID;
    WORD wReserved;
    SPWORDTYPE eWordType;
    WCHAR *pszWord;
    SPWORDPRONUNCIATION *pFirstWordPronunciation;
    } 	SPWORD;

typedef /* [restricted] */ struct SPWORDLIST
    {
    ULONG ulSize;
    BYTE *pvBuffer;
    SPWORD *pFirstWord;
    } 	SPWORDLIST;



extern RPC_IF_HANDLE __MIDL_itf_sapi_0264_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sapi_0264_v0_0_s_ifspec;

#ifndef __ISpLexicon_INTERFACE_DEFINED__
#define __ISpLexicon_INTERFACE_DEFINED__

/* interface ISpLexicon */
/* [restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISpLexicon;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DA41A7C2-5383-4DB2-916B-6C1719E3DB58")
    ISpLexicon : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPronunciations( 
            /* [in] */ const WCHAR *pszWord,
            /* [in] */ WORD LangID,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ SPWORDPRONUNCIATIONLIST *pWordPronunciationList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddPronunciation( 
            /* [in] */ const WCHAR *pszWord,
            /* [in] */ WORD LangID,
            /* [in] */ SPPARTOFSPEECH ePartOfSpeech,
            /* [in] */ const SPPHONEID *pszPronunciation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemovePronunciation( 
            /* [in] */ const WCHAR *pszWord,
            /* [in] */ WORD LangID,
            /* [in] */ SPPARTOFSPEECH ePartOfSpeech,
            /* [in] */ const SPPHONEID *pszPronunciation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGeneration( 
            DWORD *pdwGeneration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGenerationChange( 
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ DWORD *pdwGeneration,
            /* [out][in] */ SPWORDLIST *pWordList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWords( 
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ DWORD *pdwGeneration,
            /* [out][in] */ DWORD *pdwCookie,
            /* [out][in] */ SPWORDLIST *pWordList) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpLexiconVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpLexicon * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpLexicon * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpLexicon * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPronunciations )( 
            ISpLexicon * This,
            /* [in] */ const WCHAR *pszWord,
            /* [in] */ WORD LangID,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ SPWORDPRONUNCIATIONLIST *pWordPronunciationList);
        
        HRESULT ( STDMETHODCALLTYPE *AddPronunciation )( 
            ISpLexicon * This,
            /* [in] */ const WCHAR *pszWord,
            /* [in] */ WORD LangID,
            /* [in] */ SPPARTOFSPEECH ePartOfSpeech,
            /* [in] */ const SPPHONEID *pszPronunciation);
        
        HRESULT ( STDMETHODCALLTYPE *RemovePronunciation )( 
            ISpLexicon * This,
            /* [in] */ const WCHAR *pszWord,
            /* [in] */ WORD LangID,
            /* [in] */ SPPARTOFSPEECH ePartOfSpeech,
            /* [in] */ const SPPHONEID *pszPronunciation);
        
        HRESULT ( STDMETHODCALLTYPE *GetGeneration )( 
            ISpLexicon * This,
            DWORD *pdwGeneration);
        
        HRESULT ( STDMETHODCALLTYPE *GetGenerationChange )( 
            ISpLexicon * This,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ DWORD *pdwGeneration,
            /* [out][in] */ SPWORDLIST *pWordList);
        
        HRESULT ( STDMETHODCALLTYPE *GetWords )( 
            ISpLexicon * This,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ DWORD *pdwGeneration,
            /* [out][in] */ DWORD *pdwCookie,
            /* [out][in] */ SPWORDLIST *pWordList);
        
        END_INTERFACE
    } ISpLexiconVtbl;

    interface ISpLexicon
    {
        CONST_VTBL struct ISpLexiconVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpLexicon_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpLexicon_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpLexicon_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpLexicon_GetPronunciations(This,pszWord,LangID,dwFlags,pWordPronunciationList)	\
    (This)->lpVtbl -> GetPronunciations(This,pszWord,LangID,dwFlags,pWordPronunciationList)

#define ISpLexicon_AddPronunciation(This,pszWord,LangID,ePartOfSpeech,pszPronunciation)	\
    (This)->lpVtbl -> AddPronunciation(This,pszWord,LangID,ePartOfSpeech,pszPronunciation)

#define ISpLexicon_RemovePronunciation(This,pszWord,LangID,ePartOfSpeech,pszPronunciation)	\
    (This)->lpVtbl -> RemovePronunciation(This,pszWord,LangID,ePartOfSpeech,pszPronunciation)

#define ISpLexicon_GetGeneration(This,pdwGeneration)	\
    (This)->lpVtbl -> GetGeneration(This,pdwGeneration)

#define ISpLexicon_GetGenerationChange(This,dwFlags,pdwGeneration,pWordList)	\
    (This)->lpVtbl -> GetGenerationChange(This,dwFlags,pdwGeneration,pWordList)

#define ISpLexicon_GetWords(This,dwFlags,pdwGeneration,pdwCookie,pWordList)	\
    (This)->lpVtbl -> GetWords(This,dwFlags,pdwGeneration,pdwCookie,pWordList)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpLexicon_GetPronunciations_Proxy( 
    ISpLexicon * This,
    /* [in] */ const WCHAR *pszWord,
    /* [in] */ WORD LangID,
    /* [in] */ DWORD dwFlags,
    /* [out][in] */ SPWORDPRONUNCIATIONLIST *pWordPronunciationList);


void __RPC_STUB ISpLexicon_GetPronunciations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpLexicon_AddPronunciation_Proxy( 
    ISpLexicon * This,
    /* [in] */ const WCHAR *pszWord,
    /* [in] */ WORD LangID,
    /* [in] */ SPPARTOFSPEECH ePartOfSpeech,
    /* [in] */ const SPPHONEID *pszPronunciation);


void __RPC_STUB ISpLexicon_AddPronunciation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpLexicon_RemovePronunciation_Proxy( 
    ISpLexicon * This,
    /* [in] */ const WCHAR *pszWord,
    /* [in] */ WORD LangID,
    /* [in] */ SPPARTOFSPEECH ePartOfSpeech,
    /* [in] */ const SPPHONEID *pszPronunciation);


void __RPC_STUB ISpLexicon_RemovePronunciation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpLexicon_GetGeneration_Proxy( 
    ISpLexicon * This,
    DWORD *pdwGeneration);


void __RPC_STUB ISpLexicon_GetGeneration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpLexicon_GetGenerationChange_Proxy( 
    ISpLexicon * This,
    /* [in] */ DWORD dwFlags,
    /* [out][in] */ DWORD *pdwGeneration,
    /* [out][in] */ SPWORDLIST *pWordList);


void __RPC_STUB ISpLexicon_GetGenerationChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpLexicon_GetWords_Proxy( 
    ISpLexicon * This,
    /* [in] */ DWORD dwFlags,
    /* [out][in] */ DWORD *pdwGeneration,
    /* [out][in] */ DWORD *pdwCookie,
    /* [out][in] */ SPWORDLIST *pWordList);


void __RPC_STUB ISpLexicon_GetWords_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpLexicon_INTERFACE_DEFINED__ */


#ifndef __ISpContainerLexicon_INTERFACE_DEFINED__
#define __ISpContainerLexicon_INTERFACE_DEFINED__

/* interface ISpContainerLexicon */
/* [restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISpContainerLexicon;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8565572F-C094-41CC-B56E-10BD9C3FF044")
    ISpContainerLexicon : public ISpLexicon
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddLexicon( 
            /* [in] */ ISpLexicon *pAddLexicon,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpContainerLexiconVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpContainerLexicon * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpContainerLexicon * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpContainerLexicon * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPronunciations )( 
            ISpContainerLexicon * This,
            /* [in] */ const WCHAR *pszWord,
            /* [in] */ WORD LangID,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ SPWORDPRONUNCIATIONLIST *pWordPronunciationList);
        
        HRESULT ( STDMETHODCALLTYPE *AddPronunciation )( 
            ISpContainerLexicon * This,
            /* [in] */ const WCHAR *pszWord,
            /* [in] */ WORD LangID,
            /* [in] */ SPPARTOFSPEECH ePartOfSpeech,
            /* [in] */ const SPPHONEID *pszPronunciation);
        
        HRESULT ( STDMETHODCALLTYPE *RemovePronunciation )( 
            ISpContainerLexicon * This,
            /* [in] */ const WCHAR *pszWord,
            /* [in] */ WORD LangID,
            /* [in] */ SPPARTOFSPEECH ePartOfSpeech,
            /* [in] */ const SPPHONEID *pszPronunciation);
        
        HRESULT ( STDMETHODCALLTYPE *GetGeneration )( 
            ISpContainerLexicon * This,
            DWORD *pdwGeneration);
        
        HRESULT ( STDMETHODCALLTYPE *GetGenerationChange )( 
            ISpContainerLexicon * This,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ DWORD *pdwGeneration,
            /* [out][in] */ SPWORDLIST *pWordList);
        
        HRESULT ( STDMETHODCALLTYPE *GetWords )( 
            ISpContainerLexicon * This,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ DWORD *pdwGeneration,
            /* [out][in] */ DWORD *pdwCookie,
            /* [out][in] */ SPWORDLIST *pWordList);
        
        HRESULT ( STDMETHODCALLTYPE *AddLexicon )( 
            ISpContainerLexicon * This,
            /* [in] */ ISpLexicon *pAddLexicon,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } ISpContainerLexiconVtbl;

    interface ISpContainerLexicon
    {
        CONST_VTBL struct ISpContainerLexiconVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpContainerLexicon_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpContainerLexicon_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpContainerLexicon_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpContainerLexicon_GetPronunciations(This,pszWord,LangID,dwFlags,pWordPronunciationList)	\
    (This)->lpVtbl -> GetPronunciations(This,pszWord,LangID,dwFlags,pWordPronunciationList)

#define ISpContainerLexicon_AddPronunciation(This,pszWord,LangID,ePartOfSpeech,pszPronunciation)	\
    (This)->lpVtbl -> AddPronunciation(This,pszWord,LangID,ePartOfSpeech,pszPronunciation)

#define ISpContainerLexicon_RemovePronunciation(This,pszWord,LangID,ePartOfSpeech,pszPronunciation)	\
    (This)->lpVtbl -> RemovePronunciation(This,pszWord,LangID,ePartOfSpeech,pszPronunciation)

#define ISpContainerLexicon_GetGeneration(This,pdwGeneration)	\
    (This)->lpVtbl -> GetGeneration(This,pdwGeneration)

#define ISpContainerLexicon_GetGenerationChange(This,dwFlags,pdwGeneration,pWordList)	\
    (This)->lpVtbl -> GetGenerationChange(This,dwFlags,pdwGeneration,pWordList)

#define ISpContainerLexicon_GetWords(This,dwFlags,pdwGeneration,pdwCookie,pWordList)	\
    (This)->lpVtbl -> GetWords(This,dwFlags,pdwGeneration,pdwCookie,pWordList)


#define ISpContainerLexicon_AddLexicon(This,pAddLexicon,dwFlags)	\
    (This)->lpVtbl -> AddLexicon(This,pAddLexicon,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpContainerLexicon_AddLexicon_Proxy( 
    ISpContainerLexicon * This,
    /* [in] */ ISpLexicon *pAddLexicon,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ISpContainerLexicon_AddLexicon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpContainerLexicon_INTERFACE_DEFINED__ */


#ifndef __ISpPhoneConverter_INTERFACE_DEFINED__
#define __ISpPhoneConverter_INTERFACE_DEFINED__

/* interface ISpPhoneConverter */
/* [restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISpPhoneConverter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8445C581-0CAC-4A38-ABFE-9B2CE2826455")
    ISpPhoneConverter : public ISpObjectWithToken
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PhoneToId( 
            /* [in] */ const WCHAR *pszPhone,
            /* [out] */ SPPHONEID *pId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IdToPhone( 
            /* [in] */ const SPPHONEID *pId,
            /* [out] */ WCHAR *pszPhone) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpPhoneConverterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpPhoneConverter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpPhoneConverter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpPhoneConverter * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetObjectToken )( 
            ISpPhoneConverter * This,
            ISpObjectToken *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectToken )( 
            ISpPhoneConverter * This,
            ISpObjectToken **ppToken);
        
        HRESULT ( STDMETHODCALLTYPE *PhoneToId )( 
            ISpPhoneConverter * This,
            /* [in] */ const WCHAR *pszPhone,
            /* [out] */ SPPHONEID *pId);
        
        HRESULT ( STDMETHODCALLTYPE *IdToPhone )( 
            ISpPhoneConverter * This,
            /* [in] */ const SPPHONEID *pId,
            /* [out] */ WCHAR *pszPhone);
        
        END_INTERFACE
    } ISpPhoneConverterVtbl;

    interface ISpPhoneConverter
    {
        CONST_VTBL struct ISpPhoneConverterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpPhoneConverter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpPhoneConverter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpPhoneConverter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpPhoneConverter_SetObjectToken(This,pToken)	\
    (This)->lpVtbl -> SetObjectToken(This,pToken)

#define ISpPhoneConverter_GetObjectToken(This,ppToken)	\
    (This)->lpVtbl -> GetObjectToken(This,ppToken)


#define ISpPhoneConverter_PhoneToId(This,pszPhone,pId)	\
    (This)->lpVtbl -> PhoneToId(This,pszPhone,pId)

#define ISpPhoneConverter_IdToPhone(This,pId,pszPhone)	\
    (This)->lpVtbl -> IdToPhone(This,pId,pszPhone)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpPhoneConverter_PhoneToId_Proxy( 
    ISpPhoneConverter * This,
    /* [in] */ const WCHAR *pszPhone,
    /* [out] */ SPPHONEID *pId);


void __RPC_STUB ISpPhoneConverter_PhoneToId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpPhoneConverter_IdToPhone_Proxy( 
    ISpPhoneConverter * This,
    /* [in] */ const SPPHONEID *pId,
    /* [out] */ WCHAR *pszPhone);


void __RPC_STUB ISpPhoneConverter_IdToPhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpPhoneConverter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sapi_0267 */
/* [local] */ 

typedef /* [restricted] */ struct SPVPITCH
    {
    long MiddleAdj;
    long RangeAdj;
    } 	SPVPITCH;

typedef 
enum SPVACTIONS
    {	SPVA_Speak	= 0,
	SPVA_Silence	= SPVA_Speak + 1,
	SPVA_Pronounce	= SPVA_Silence + 1,
	SPVA_Bookmark	= SPVA_Pronounce + 1,
	SPVA_SpellOut	= SPVA_Bookmark + 1,
	SPVA_Section	= SPVA_SpellOut + 1,
	SPVA_ParseUnknownTag	= SPVA_Section + 1
    } 	SPVACTIONS;

typedef /* [restricted] */ struct SPVCONTEXT
    {
    LPCWSTR pCategory;
    LPCWSTR pBefore;
    LPCWSTR pAfter;
    } 	SPVCONTEXT;

typedef /* [restricted] */ struct SPVSTATE
    {
    SPVACTIONS eAction;
    WORD LangID;
    WORD wReserved;
    long EmphAdj;
    long RateAdj;
    ULONG Volume;
    SPVPITCH PitchAdj;
    ULONG SilenceMSecs;
    SPPHONEID *pPhoneIds;
    SPPARTOFSPEECH ePartOfSpeech;
    SPVCONTEXT Context;
    } 	SPVSTATE;

typedef /* [restricted] */ struct SPVSENTITEM
    {
    const SPVSTATE *pXmlState;
    LPCWSTR pItem;
    ULONG ulItemLen;
    ULONG ulItemSrcOffset;
    ULONG ulItemSrcLen;
    } 	SPVSENTITEM;

typedef 
enum SPRUNSTATE
    {	SPRS_DONE	= 1L << 0,
	SPRS_IS_SPEAKING	= 1L << 1
    } 	SPRUNSTATE;

typedef 
enum SPVLIMITS
    {	SPMIN_VOLUME	= 0,
	SPMAX_VOLUME	= 100,
	SPMIN_RATE	= -10,
	SPMAX_RATE	= 10
    } 	SPVLIMITS;

typedef 
enum SPVPRIORITY
    {	SPVPRI_NORMAL	= 0,
	SPVPRI_ALERT	= 1L << 0,
	SPVPRI_OVER	= 1L << 1
    } 	SPVPRIORITY;

typedef /* [restricted] */ struct SPVOICESTATUS
    {
    ULONG ulCurrentStream;
    ULONG ulLastStreamQueued;
    HRESULT hrLastResult;
    DWORD dwRunningState;
    ULONG ulInputWordPos;
    ULONG ulInputWordLen;
    ULONG ulInputSentPos;
    ULONG ulInputSentLen;
    LONG lBookmarkId;
    SPPHONEID PhonemeId;
    SPVISEMES VisemeId;
    DWORD dwReserved1;
    DWORD dwReserved2;
    } 	SPVOICESTATUS;

typedef 
enum SPEAKFLAGS
    {	SPF_DEFAULT	= 0,
	SPF_ASYNC	= 1L << 0,
	SPF_PURGEBEFORESPEAK	= 1L << 1,
	SPF_IS_FILENAME	= 1L << 2,
	SPF_IS_XML	= 1L << 3,
	SPF_IS_NOT_XML	= 1L << 4,
	SPF_PERSIST_XML	= 1L << 5,
	SPF_NLP_SPEAK_PUNC	= 1L << 6,
	SPF_NLP_MASK	= SPF_NLP_SPEAK_PUNC,
	SPF_VOICE_MASK	= SPF_ASYNC | SPF_PURGEBEFORESPEAK | SPF_IS_FILENAME | SPF_IS_XML | SPF_IS_NOT_XML | SPF_NLP_MASK | SPF_PERSIST_XML,
	SPF_UNUSED_FLAGS	= ~SPF_VOICE_MASK
    } 	SPEAKFLAGS;



extern RPC_IF_HANDLE __MIDL_itf_sapi_0267_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sapi_0267_v0_0_s_ifspec;

#ifndef __ISpVoice_INTERFACE_DEFINED__
#define __ISpVoice_INTERFACE_DEFINED__

/* interface ISpVoice */
/* [restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISpVoice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6C44DF74-72B9-4992-A1EC-EF996E0422D4")
    ISpVoice : public ISpEventSource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetOutput( 
            /* [in] */ IUnknown *pUnkOutput,
            /* [in] */ BOOL fAllowFormatChanges) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputObjectToken( 
            /* [out] */ ISpObjectToken **ppObjectToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputStream( 
            /* [out] */ ISpStreamFormat **ppStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVoice( 
            /* [in] */ ISpObjectToken *pToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVoice( 
            /* [out] */ ISpObjectToken **ppToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Speak( 
            /* [string][in] */ const WCHAR *pwcs,
            /* [in] */ DWORD dwFlags,
            /* [out] */ ULONG *pulStreamNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SpeakStream( 
            /* [in] */ IStream *pStream,
            /* [in] */ DWORD dwFlags,
            /* [out] */ ULONG *pulStreamNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ SPVOICESTATUS *pStatus,
            /* [string][out] */ WCHAR **ppszLastBookmark) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [string][in] */ WCHAR *pItemType,
            /* [in] */ long lNumItems,
            /* [out] */ ULONG *pulNumSkipped) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPriority( 
            /* [in] */ SPVPRIORITY ePriority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPriority( 
            /* [out] */ SPVPRIORITY *pePriority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAlertBoundary( 
            /* [in] */ SPEVENTENUM eBoundary) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAlertBoundary( 
            /* [out] */ SPEVENTENUM *peBoundary) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRate( 
            /* [in] */ long RateAdjust) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRate( 
            /* [out] */ long *pRateAdjust) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVolume( 
            /* [in] */ USHORT usVolume) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVolume( 
            /* [out] */ USHORT *pusVolume) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WaitUntilDone( 
            /* [in] */ ULONG msTimeout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSyncSpeakTimeout( 
            /* [in] */ ULONG msTimeout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSyncSpeakTimeout( 
            /* [out] */ ULONG *pmsTimeout) = 0;
        
        virtual /* [local] */ HANDLE STDMETHODCALLTYPE SpeakCompleteEvent( void) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE IsUISupported( 
            /* [in] */ const WCHAR *pszTypeOfUI,
            /* [in] */ void *pvExtraData,
            /* [in] */ ULONG cbExtraData,
            /* [out] */ BOOL *pfSupported) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DisplayUI( 
            /* [in] */ HWND hwndParent,
            /* [in] */ const WCHAR *pszTitle,
            /* [in] */ const WCHAR *pszTypeOfUI,
            /* [in] */ void *pvExtraData,
            /* [in] */ ULONG cbExtraData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpVoiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpVoice * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpVoice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpVoice * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetNotifySink )( 
            ISpVoice * This,
            /* [in] */ ISpNotifySink *pNotifySink);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetNotifyWindowMessage )( 
            ISpVoice * This,
            /* [in] */ HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetNotifyCallbackFunction )( 
            ISpVoice * This,
            /* [in] */ SPNOTIFYCALLBACK *pfnCallback,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetNotifyCallbackInterface )( 
            ISpVoice * This,
            /* [in] */ ISpNotifyCallback *pSpCallback,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetNotifyWin32Event )( 
            ISpVoice * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *WaitForNotifyEvent )( 
            ISpVoice * This,
            /* [in] */ DWORD dwMilliseconds);
        
        /* [local] */ HANDLE ( STDMETHODCALLTYPE *GetNotifyEventHandle )( 
            ISpVoice * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetInterest )( 
            ISpVoice * This,
            /* [in] */ ULONGLONG ullEventInterest,
            /* [in] */ ULONGLONG ullQueuedInterest);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvents )( 
            ISpVoice * This,
            /* [in] */ ULONG ulCount,
            /* [size_is][out] */ SPEVENT *pEventArray,
            /* [out] */ ULONG *pulFetched);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            ISpVoice * This,
            /* [out] */ SPEVENTSOURCEINFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutput )( 
            ISpVoice * This,
            /* [in] */ IUnknown *pUnkOutput,
            /* [in] */ BOOL fAllowFormatChanges);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputObjectToken )( 
            ISpVoice * This,
            /* [out] */ ISpObjectToken **ppObjectToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputStream )( 
            ISpVoice * This,
            /* [out] */ ISpStreamFormat **ppStream);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            ISpVoice * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            ISpVoice * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetVoice )( 
            ISpVoice * This,
            /* [in] */ ISpObjectToken *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetVoice )( 
            ISpVoice * This,
            /* [out] */ ISpObjectToken **ppToken);
        
        HRESULT ( STDMETHODCALLTYPE *Speak )( 
            ISpVoice * This,
            /* [string][in] */ const WCHAR *pwcs,
            /* [in] */ DWORD dwFlags,
            /* [out] */ ULONG *pulStreamNumber);
        
        HRESULT ( STDMETHODCALLTYPE *SpeakStream )( 
            ISpVoice * This,
            /* [in] */ IStream *pStream,
            /* [in] */ DWORD dwFlags,
            /* [out] */ ULONG *pulStreamNumber);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            ISpVoice * This,
            /* [out] */ SPVOICESTATUS *pStatus,
            /* [string][out] */ WCHAR **ppszLastBookmark);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ISpVoice * This,
            /* [string][in] */ WCHAR *pItemType,
            /* [in] */ long lNumItems,
            /* [out] */ ULONG *pulNumSkipped);
        
        HRESULT ( STDMETHODCALLTYPE *SetPriority )( 
            ISpVoice * This,
            /* [in] */ SPVPRIORITY ePriority);
        
        HRESULT ( STDMETHODCALLTYPE *GetPriority )( 
            ISpVoice * This,
            /* [out] */ SPVPRIORITY *pePriority);
        
        HRESULT ( STDMETHODCALLTYPE *SetAlertBoundary )( 
            ISpVoice * This,
            /* [in] */ SPEVENTENUM eBoundary);
        
        HRESULT ( STDMETHODCALLTYPE *GetAlertBoundary )( 
            ISpVoice * This,
            /* [out] */ SPEVENTENUM *peBoundary);
        
        HRESULT ( STDMETHODCALLTYPE *SetRate )( 
            ISpVoice * This,
            /* [in] */ long RateAdjust);
        
        HRESULT ( STDMETHODCALLTYPE *GetRate )( 
            ISpVoice * This,
            /* [out] */ long *pRateAdjust);
        
        HRESULT ( STDMETHODCALLTYPE *SetVolume )( 
            ISpVoice * This,
            /* [in] */ USHORT usVolume);
        
        HRESULT ( STDMETHODCALLTYPE *GetVolume )( 
            ISpVoice * This,
            /* [out] */ USHORT *pusVolume);
        
        HRESULT ( STDMETHODCALLTYPE *WaitUntilDone )( 
            ISpVoice * This,
            /* [in] */ ULONG msTimeout);
        
        HRESULT ( STDMETHODCALLTYPE *SetSyncSpeakTimeout )( 
            ISpVoice * This,
            /* [in] */ ULONG msTimeout);
        
        HRESULT ( STDMETHODCALLTYPE *GetSyncSpeakTimeout )( 
            ISpVoice * This,
            /* [out] */ ULONG *pmsTimeout);
        
        /* [local] */ HANDLE ( STDMETHODCALLTYPE *SpeakCompleteEvent )( 
            ISpVoice * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *IsUISupported )( 
            ISpVoice * This,
            /* [in] */ const WCHAR *pszTypeOfUI,
            /* [in] */ void *pvExtraData,
            /* [in] */ ULONG cbExtraData,
            /* [out] */ BOOL *pfSupported);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *DisplayUI )( 
            ISpVoice * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ const WCHAR *pszTitle,
            /* [in] */ const WCHAR *pszTypeOfUI,
            /* [in] */ void *pvExtraData,
            /* [in] */ ULONG cbExtraData);
        
        END_INTERFACE
    } ISpVoiceVtbl;

    interface ISpVoice
    {
        CONST_VTBL struct ISpVoiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpVoice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpVoice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpVoice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpVoice_SetNotifySink(This,pNotifySink)	\
    (This)->lpVtbl -> SetNotifySink(This,pNotifySink)

#define ISpVoice_SetNotifyWindowMessage(This,hWnd,Msg,wParam,lParam)	\
    (This)->lpVtbl -> SetNotifyWindowMessage(This,hWnd,Msg,wParam,lParam)

#define ISpVoice_SetNotifyCallbackFunction(This,pfnCallback,wParam,lParam)	\
    (This)->lpVtbl -> SetNotifyCallbackFunction(This,pfnCallback,wParam,lParam)

#define ISpVoice_SetNotifyCallbackInterface(This,pSpCallback,wParam,lParam)	\
    (This)->lpVtbl -> SetNotifyCallbackInterface(This,pSpCallback,wParam,lParam)

#define ISpVoice_SetNotifyWin32Event(This)	\
    (This)->lpVtbl -> SetNotifyWin32Event(This)

#define ISpVoice_WaitForNotifyEvent(This,dwMilliseconds)	\
    (This)->lpVtbl -> WaitForNotifyEvent(This,dwMilliseconds)

#define ISpVoice_GetNotifyEventHandle(This)	\
    (This)->lpVtbl -> GetNotifyEventHandle(This)


#define ISpVoice_SetInterest(This,ullEventInterest,ullQueuedInterest)	\
    (This)->lpVtbl -> SetInterest(This,ullEventInterest,ullQueuedInterest)

#define ISpVoice_GetEvents(This,ulCount,pEventArray,pulFetched)	\
    (This)->lpVtbl -> GetEvents(This,ulCount,pEventArray,pulFetched)

#define ISpVoice_GetInfo(This,pInfo)	\
    (This)->lpVtbl -> GetInfo(This,pInfo)


#define ISpVoice_SetOutput(This,pUnkOutput,fAllowFormatChanges)	\
    (This)->lpVtbl -> SetOutput(This,pUnkOutput,fAllowFormatChanges)

#define ISpVoice_GetOutputObjectToken(This,ppObjectToken)	\
    (This)->lpVtbl -> GetOutputObjectToken(This,ppObjectToken)

#define ISpVoice_GetOutputStream(This,ppStream)	\
    (This)->lpVtbl -> GetOutputStream(This,ppStream)

#define ISpVoice_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define ISpVoice_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#define ISpVoice_SetVoice(This,pToken)	\
    (This)->lpVtbl -> SetVoice(This,pToken)

#define ISpVoice_GetVoice(This,ppToken)	\
    (This)->lpVtbl -> GetVoice(This,ppToken)

#define ISpVoice_Speak(This,pwcs,dwFlags,pulStreamNumber)	\
    (This)->lpVtbl -> Speak(This,pwcs,dwFlags,pulStreamNumber)

#define ISpVoice_SpeakStream(This,pStream,dwFlags,pulStreamNumber)	\
    (This)->lpVtbl -> SpeakStream(This,pStream,dwFlags,pulStreamNumber)

#define ISpVoice_GetStatus(This,pStatus,ppszLastBookmark)	\
    (This)->lpVtbl -> GetStatus(This,pStatus,ppszLastBookmark)

#define ISpVoice_Skip(This,pItemType,lNumItems,pulNumSkipped)	\
    (This)->lpVtbl -> Skip(This,pItemType,lNumItems,pulNumSkipped)

#define ISpVoice_SetPriority(This,ePriority)	\
    (This)->lpVtbl -> SetPriority(This,ePriority)

#define ISpVoice_GetPriority(This,pePriority)	\
    (This)->lpVtbl -> GetPriority(This,pePriority)

#define ISpVoice_SetAlertBoundary(This,eBoundary)	\
    (This)->lpVtbl -> SetAlertBoundary(This,eBoundary)

#define ISpVoice_GetAlertBoundary(This,peBoundary)	\
    (This)->lpVtbl -> GetAlertBoundary(This,peBoundary)

#define ISpVoice_SetRate(This,RateAdjust)	\
    (This)->lpVtbl -> SetRate(This,RateAdjust)

#define ISpVoice_GetRate(This,pRateAdjust)	\
    (This)->lpVtbl -> GetRate(This,pRateAdjust)

#define ISpVoice_SetVolume(This,usVolume)	\
    (This)->lpVtbl -> SetVolume(This,usVolume)

#define ISpVoice_GetVolume(This,pusVolume)	\
    (This)->lpVtbl -> GetVolume(This,pusVolume)

#define ISpVoice_WaitUntilDone(This,msTimeout)	\
    (This)->lpVtbl -> WaitUntilDone(This,msTimeout)

#define ISpVoice_SetSyncSpeakTimeout(This,msTimeout)	\
    (This)->lpVtbl -> SetSyncSpeakTimeout(This,msTimeout)

#define ISpVoice_GetSyncSpeakTimeout(This,pmsTimeout)	\
    (This)->lpVtbl -> GetSyncSpeakTimeout(This,pmsTimeout)

#define ISpVoice_SpeakCompleteEvent(This)	\
    (This)->lpVtbl -> SpeakCompleteEvent(This)

#define ISpVoice_IsUISupported(This,pszTypeOfUI,pvExtraData,cbExtraData,pfSupported)	\
    (This)->lpVtbl -> IsUISupported(This,pszTypeOfUI,pvExtraData,cbExtraData,pfSupported)

#define ISpVoice_DisplayUI(This,hwndParent,pszTitle,pszTypeOfUI,pvExtraData,cbExtraData)	\
    (This)->lpVtbl -> DisplayUI(This,hwndParent,pszTitle,pszTypeOfUI,pvExtraData,cbExtraData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpVoice_SetOutput_Proxy( 
    ISpVoice * This,
    /* [in] */ IUnknown *pUnkOutput,
    /* [in] */ BOOL fAllowFormatChanges);


void __RPC_STUB ISpVoice_SetOutput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpVoice_GetOutputObjectToken_Proxy( 
    ISpVoice * This,
    /* [out] */ ISpObjectToken **ppObjectToken);


void __RPC_STUB ISpVoice_GetOutputObjectToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpVoice_GetOutputStream_Proxy( 
    ISpVoice * This,
    /* [out] */ ISpStreamFormat **ppStream);


void __RPC_STUB ISpVoice_GetOutputStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpVoice_Pause_Proxy( 
    ISpVoice * This);


void __RPC_STUB ISpVoice_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpVoice_Resume_Proxy( 
    ISpVoice * This);


void __RPC_STUB ISpVoice_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpVoice_SetVoice_Proxy( 
    ISpVoice * This,
    /* [in] */ ISpObjectToken *pToken);


void __RPC_STUB ISpVoice_SetVoice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpVoice_GetVoice_Proxy( 
    ISpVoice * This,
    /* [out] */ ISpObjectToken **ppToken);


void __RPC_STUB ISpVoice_GetVoice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpVoice_Speak_Proxy( 
    ISpVoice * This,
    /* [string][in] */ const WCHAR *pwcs,
    /* [in] */ DWORD dwFlags,
    /* [out] */ ULONG *pulStreamNumber);


void __RPC_STUB ISpVoice_Speak_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpVoice_SpeakStream_Proxy( 
    ISpVoice * This,
    /* [in] */ IStream *pStream,
    /* [in] */ DWORD dwFlags,
    /* [out] */ ULONG *pulStreamNumber);


void __RPC_STUB ISpVoice_SpeakStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpVoice_GetStatus_Proxy( 
    ISpVoice * This,
    /* [out] */ SPVOICESTATUS *pStatus,
    /* [string][out] */ WCHAR **ppszLastBookmark);


void __RPC_STUB ISpVoice_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpVoice_Skip_Proxy( 
    ISpVoice * This,
    /* [string][in] */ WCHAR *pItemType,
    /* [in] */ long lNumItems,
    /* [out] */ ULONG *pulNumSkipped);


void __RPC_STUB ISpVoice_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpVoice_SetPriority_Proxy( 
    ISpVoice * This,
    /* [in] */ SPVPRIORITY ePriority);


void __RPC_STUB ISpVoice_SetPriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpVoice_GetPriority_Proxy( 
    ISpVoice * This,
    /* [out] */ SPVPRIORITY *pePriority);


void __RPC_STUB ISpVoice_GetPriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpVoice_SetAlertBoundary_Proxy( 
    ISpVoice * This,
    /* [in] */ SPEVENTENUM eBoundary);


void __RPC_STUB ISpVoice_SetAlertBoundary_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpVoice_GetAlertBoundary_Proxy( 
    ISpVoice * This,
    /* [out] */ SPEVENTENUM *peBoundary);


void __RPC_STUB ISpVoice_GetAlertBoundary_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpVoice_SetRate_Proxy( 
    ISpVoice * This,
    /* [in] */ long RateAdjust);


void __RPC_STUB ISpVoice_SetRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpVoice_GetRate_Proxy( 
    ISpVoice * This,
    /* [out] */ long *pRateAdjust);


void __RPC_STUB ISpVoice_GetRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpVoice_SetVolume_Proxy( 
    ISpVoice * This,
    /* [in] */ USHORT usVolume);


void __RPC_STUB ISpVoice_SetVolume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpVoice_GetVolume_Proxy( 
    ISpVoice * This,
    /* [out] */ USHORT *pusVolume);


void __RPC_STUB ISpVoice_GetVolume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpVoice_WaitUntilDone_Proxy( 
    ISpVoice * This,
    /* [in] */ ULONG msTimeout);


void __RPC_STUB ISpVoice_WaitUntilDone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpVoice_SetSyncSpeakTimeout_Proxy( 
    ISpVoice * This,
    /* [in] */ ULONG msTimeout);


void __RPC_STUB ISpVoice_SetSyncSpeakTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpVoice_GetSyncSpeakTimeout_Proxy( 
    ISpVoice * This,
    /* [out] */ ULONG *pmsTimeout);


void __RPC_STUB ISpVoice_GetSyncSpeakTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HANDLE STDMETHODCALLTYPE ISpVoice_SpeakCompleteEvent_Proxy( 
    ISpVoice * This);


void __RPC_STUB ISpVoice_SpeakCompleteEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE ISpVoice_IsUISupported_Proxy( 
    ISpVoice * This,
    /* [in] */ const WCHAR *pszTypeOfUI,
    /* [in] */ void *pvExtraData,
    /* [in] */ ULONG cbExtraData,
    /* [out] */ BOOL *pfSupported);


void __RPC_STUB ISpVoice_IsUISupported_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE ISpVoice_DisplayUI_Proxy( 
    ISpVoice * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ const WCHAR *pszTitle,
    /* [in] */ const WCHAR *pszTypeOfUI,
    /* [in] */ void *pvExtraData,
    /* [in] */ ULONG cbExtraData);


void __RPC_STUB ISpVoice_DisplayUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpVoice_INTERFACE_DEFINED__ */


#ifndef __ISpPhrase_INTERFACE_DEFINED__
#define __ISpPhrase_INTERFACE_DEFINED__

/* interface ISpPhrase */
/* [restricted][unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_ISpPhrase;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1A5C0354-B621-4b5a-8791-D306ED379E53")
    ISpPhrase : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPhrase( 
            /* [out] */ SPPHRASE **ppCoMemPhrase) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSerializedPhrase( 
            /* [out] */ SPSERIALIZEDPHRASE **ppCoMemPhrase) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [in] */ ULONG ulStart,
            /* [in] */ ULONG ulCount,
            /* [in] */ BOOL fUseTextReplacements,
            /* [out] */ WCHAR **ppszCoMemText,
            /* [out] */ BYTE *pbDisplayAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Discard( 
            /* [in] */ DWORD dwValueTypes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpPhraseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpPhrase * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpPhrase * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpPhrase * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPhrase )( 
            ISpPhrase * This,
            /* [out] */ SPPHRASE **ppCoMemPhrase);
        
        HRESULT ( STDMETHODCALLTYPE *GetSerializedPhrase )( 
            ISpPhrase * This,
            /* [out] */ SPSERIALIZEDPHRASE **ppCoMemPhrase);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            ISpPhrase * This,
            /* [in] */ ULONG ulStart,
            /* [in] */ ULONG ulCount,
            /* [in] */ BOOL fUseTextReplacements,
            /* [out] */ WCHAR **ppszCoMemText,
            /* [out] */ BYTE *pbDisplayAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *Discard )( 
            ISpPhrase * This,
            /* [in] */ DWORD dwValueTypes);
        
        END_INTERFACE
    } ISpPhraseVtbl;

    interface ISpPhrase
    {
        CONST_VTBL struct ISpPhraseVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpPhrase_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpPhrase_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpPhrase_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpPhrase_GetPhrase(This,ppCoMemPhrase)	\
    (This)->lpVtbl -> GetPhrase(This,ppCoMemPhrase)

#define ISpPhrase_GetSerializedPhrase(This,ppCoMemPhrase)	\
    (This)->lpVtbl -> GetSerializedPhrase(This,ppCoMemPhrase)

#define ISpPhrase_GetText(This,ulStart,ulCount,fUseTextReplacements,ppszCoMemText,pbDisplayAttributes)	\
    (This)->lpVtbl -> GetText(This,ulStart,ulCount,fUseTextReplacements,ppszCoMemText,pbDisplayAttributes)

#define ISpPhrase_Discard(This,dwValueTypes)	\
    (This)->lpVtbl -> Discard(This,dwValueTypes)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpPhrase_GetPhrase_Proxy( 
    ISpPhrase * This,
    /* [out] */ SPPHRASE **ppCoMemPhrase);


void __RPC_STUB ISpPhrase_GetPhrase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpPhrase_GetSerializedPhrase_Proxy( 
    ISpPhrase * This,
    /* [out] */ SPSERIALIZEDPHRASE **ppCoMemPhrase);


void __RPC_STUB ISpPhrase_GetSerializedPhrase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpPhrase_GetText_Proxy( 
    ISpPhrase * This,
    /* [in] */ ULONG ulStart,
    /* [in] */ ULONG ulCount,
    /* [in] */ BOOL fUseTextReplacements,
    /* [out] */ WCHAR **ppszCoMemText,
    /* [out] */ BYTE *pbDisplayAttributes);


void __RPC_STUB ISpPhrase_GetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpPhrase_Discard_Proxy( 
    ISpPhrase * This,
    /* [in] */ DWORD dwValueTypes);


void __RPC_STUB ISpPhrase_Discard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpPhrase_INTERFACE_DEFINED__ */


#ifndef __ISpPhraseAlt_INTERFACE_DEFINED__
#define __ISpPhraseAlt_INTERFACE_DEFINED__

/* interface ISpPhraseAlt */
/* [restricted][unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_ISpPhraseAlt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8FCEBC98-4E49-4067-9C6C-D86A0E092E3D")
    ISpPhraseAlt : public ISpPhrase
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAltInfo( 
            ISpPhrase **ppParent,
            ULONG *pulStartElementInParent,
            ULONG *pcElementsInParent,
            ULONG *pcElementsInAlt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpPhraseAltVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpPhraseAlt * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpPhraseAlt * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpPhraseAlt * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPhrase )( 
            ISpPhraseAlt * This,
            /* [out] */ SPPHRASE **ppCoMemPhrase);
        
        HRESULT ( STDMETHODCALLTYPE *GetSerializedPhrase )( 
            ISpPhraseAlt * This,
            /* [out] */ SPSERIALIZEDPHRASE **ppCoMemPhrase);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            ISpPhraseAlt * This,
            /* [in] */ ULONG ulStart,
            /* [in] */ ULONG ulCount,
            /* [in] */ BOOL fUseTextReplacements,
            /* [out] */ WCHAR **ppszCoMemText,
            /* [out] */ BYTE *pbDisplayAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *Discard )( 
            ISpPhraseAlt * This,
            /* [in] */ DWORD dwValueTypes);
        
        HRESULT ( STDMETHODCALLTYPE *GetAltInfo )( 
            ISpPhraseAlt * This,
            ISpPhrase **ppParent,
            ULONG *pulStartElementInParent,
            ULONG *pcElementsInParent,
            ULONG *pcElementsInAlt);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            ISpPhraseAlt * This);
        
        END_INTERFACE
    } ISpPhraseAltVtbl;

    interface ISpPhraseAlt
    {
        CONST_VTBL struct ISpPhraseAltVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpPhraseAlt_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpPhraseAlt_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpPhraseAlt_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpPhraseAlt_GetPhrase(This,ppCoMemPhrase)	\
    (This)->lpVtbl -> GetPhrase(This,ppCoMemPhrase)

#define ISpPhraseAlt_GetSerializedPhrase(This,ppCoMemPhrase)	\
    (This)->lpVtbl -> GetSerializedPhrase(This,ppCoMemPhrase)

#define ISpPhraseAlt_GetText(This,ulStart,ulCount,fUseTextReplacements,ppszCoMemText,pbDisplayAttributes)	\
    (This)->lpVtbl -> GetText(This,ulStart,ulCount,fUseTextReplacements,ppszCoMemText,pbDisplayAttributes)

#define ISpPhraseAlt_Discard(This,dwValueTypes)	\
    (This)->lpVtbl -> Discard(This,dwValueTypes)


#define ISpPhraseAlt_GetAltInfo(This,ppParent,pulStartElementInParent,pcElementsInParent,pcElementsInAlt)	\
    (This)->lpVtbl -> GetAltInfo(This,ppParent,pulStartElementInParent,pcElementsInParent,pcElementsInAlt)

#define ISpPhraseAlt_Commit(This)	\
    (This)->lpVtbl -> Commit(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpPhraseAlt_GetAltInfo_Proxy( 
    ISpPhraseAlt * This,
    ISpPhrase **ppParent,
    ULONG *pulStartElementInParent,
    ULONG *pcElementsInParent,
    ULONG *pcElementsInAlt);


void __RPC_STUB ISpPhraseAlt_GetAltInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpPhraseAlt_Commit_Proxy( 
    ISpPhraseAlt * This);


void __RPC_STUB ISpPhraseAlt_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpPhraseAlt_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sapi_0270 */
/* [local] */ 

typedef /* [restricted] */ struct SPRECORESULTTIMES
    {
    FILETIME ftStreamTime;
    ULONGLONG ullLength;
    DWORD dwTickCount;
    ULONGLONG ullStart;
    } 	SPRECORESULTTIMES;

typedef struct SPSERIALIZEDRESULT
    {
    ULONG ulSerializedSize;
    } 	SPSERIALIZEDRESULT;



extern RPC_IF_HANDLE __MIDL_itf_sapi_0270_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sapi_0270_v0_0_s_ifspec;

#ifndef __ISpRecoResult_INTERFACE_DEFINED__
#define __ISpRecoResult_INTERFACE_DEFINED__

/* interface ISpRecoResult */
/* [restricted][local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISpRecoResult;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("20B053BE-E235-43cd-9A2A-8D17A48B7842")
    ISpRecoResult : public ISpPhrase
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetResultTimes( 
            /* [out] */ SPRECORESULTTIMES *pTimes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAlternates( 
            /* [in] */ ULONG ulStartElement,
            /* [in] */ ULONG cElements,
            /* [in] */ ULONG ulRequestCount,
            /* [out] */ ISpPhraseAlt **ppPhrases,
            /* [out] */ ULONG *pcPhrasesReturned) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAudio( 
            /* [in] */ ULONG ulStartElement,
            /* [in] */ ULONG cElements,
            /* [out] */ ISpStreamFormat **ppStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SpeakAudio( 
            /* [in] */ ULONG ulStartElement,
            /* [in] */ ULONG cElements,
            /* [in] */ DWORD dwFlags,
            /* [out] */ ULONG *pulStreamNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Serialize( 
            /* [out] */ SPSERIALIZEDRESULT **ppCoMemSerializedResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ScaleAudio( 
            /* [in] */ const GUID *pAudioFormatId,
            /* [in] */ const WAVEFORMATEX *pWaveFormatEx) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecoContext( 
            /* [out] */ ISpRecoContext **ppRecoContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpRecoResultVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpRecoResult * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpRecoResult * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpRecoResult * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPhrase )( 
            ISpRecoResult * This,
            /* [out] */ SPPHRASE **ppCoMemPhrase);
        
        HRESULT ( STDMETHODCALLTYPE *GetSerializedPhrase )( 
            ISpRecoResult * This,
            /* [out] */ SPSERIALIZEDPHRASE **ppCoMemPhrase);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            ISpRecoResult * This,
            /* [in] */ ULONG ulStart,
            /* [in] */ ULONG ulCount,
            /* [in] */ BOOL fUseTextReplacements,
            /* [out] */ WCHAR **ppszCoMemText,
            /* [out] */ BYTE *pbDisplayAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *Discard )( 
            ISpRecoResult * This,
            /* [in] */ DWORD dwValueTypes);
        
        HRESULT ( STDMETHODCALLTYPE *GetResultTimes )( 
            ISpRecoResult * This,
            /* [out] */ SPRECORESULTTIMES *pTimes);
        
        HRESULT ( STDMETHODCALLTYPE *GetAlternates )( 
            ISpRecoResult * This,
            /* [in] */ ULONG ulStartElement,
            /* [in] */ ULONG cElements,
            /* [in] */ ULONG ulRequestCount,
            /* [out] */ ISpPhraseAlt **ppPhrases,
            /* [out] */ ULONG *pcPhrasesReturned);
        
        HRESULT ( STDMETHODCALLTYPE *GetAudio )( 
            ISpRecoResult * This,
            /* [in] */ ULONG ulStartElement,
            /* [in] */ ULONG cElements,
            /* [out] */ ISpStreamFormat **ppStream);
        
        HRESULT ( STDMETHODCALLTYPE *SpeakAudio )( 
            ISpRecoResult * This,
            /* [in] */ ULONG ulStartElement,
            /* [in] */ ULONG cElements,
            /* [in] */ DWORD dwFlags,
            /* [out] */ ULONG *pulStreamNumber);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            ISpRecoResult * This,
            /* [out] */ SPSERIALIZEDRESULT **ppCoMemSerializedResult);
        
        HRESULT ( STDMETHODCALLTYPE *ScaleAudio )( 
            ISpRecoResult * This,
            /* [in] */ const GUID *pAudioFormatId,
            /* [in] */ const WAVEFORMATEX *pWaveFormatEx);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecoContext )( 
            ISpRecoResult * This,
            /* [out] */ ISpRecoContext **ppRecoContext);
        
        END_INTERFACE
    } ISpRecoResultVtbl;

    interface ISpRecoResult
    {
        CONST_VTBL struct ISpRecoResultVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpRecoResult_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpRecoResult_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpRecoResult_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpRecoResult_GetPhrase(This,ppCoMemPhrase)	\
    (This)->lpVtbl -> GetPhrase(This,ppCoMemPhrase)

#define ISpRecoResult_GetSerializedPhrase(This,ppCoMemPhrase)	\
    (This)->lpVtbl -> GetSerializedPhrase(This,ppCoMemPhrase)

#define ISpRecoResult_GetText(This,ulStart,ulCount,fUseTextReplacements,ppszCoMemText,pbDisplayAttributes)	\
    (This)->lpVtbl -> GetText(This,ulStart,ulCount,fUseTextReplacements,ppszCoMemText,pbDisplayAttributes)

#define ISpRecoResult_Discard(This,dwValueTypes)	\
    (This)->lpVtbl -> Discard(This,dwValueTypes)


#define ISpRecoResult_GetResultTimes(This,pTimes)	\
    (This)->lpVtbl -> GetResultTimes(This,pTimes)

#define ISpRecoResult_GetAlternates(This,ulStartElement,cElements,ulRequestCount,ppPhrases,pcPhrasesReturned)	\
    (This)->lpVtbl -> GetAlternates(This,ulStartElement,cElements,ulRequestCount,ppPhrases,pcPhrasesReturned)

#define ISpRecoResult_GetAudio(This,ulStartElement,cElements,ppStream)	\
    (This)->lpVtbl -> GetAudio(This,ulStartElement,cElements,ppStream)

#define ISpRecoResult_SpeakAudio(This,ulStartElement,cElements,dwFlags,pulStreamNumber)	\
    (This)->lpVtbl -> SpeakAudio(This,ulStartElement,cElements,dwFlags,pulStreamNumber)

#define ISpRecoResult_Serialize(This,ppCoMemSerializedResult)	\
    (This)->lpVtbl -> Serialize(This,ppCoMemSerializedResult)

#define ISpRecoResult_ScaleAudio(This,pAudioFormatId,pWaveFormatEx)	\
    (This)->lpVtbl -> ScaleAudio(This,pAudioFormatId,pWaveFormatEx)

#define ISpRecoResult_GetRecoContext(This,ppRecoContext)	\
    (This)->lpVtbl -> GetRecoContext(This,ppRecoContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpRecoResult_GetResultTimes_Proxy( 
    ISpRecoResult * This,
    /* [out] */ SPRECORESULTTIMES *pTimes);


void __RPC_STUB ISpRecoResult_GetResultTimes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoResult_GetAlternates_Proxy( 
    ISpRecoResult * This,
    /* [in] */ ULONG ulStartElement,
    /* [in] */ ULONG cElements,
    /* [in] */ ULONG ulRequestCount,
    /* [out] */ ISpPhraseAlt **ppPhrases,
    /* [out] */ ULONG *pcPhrasesReturned);


void __RPC_STUB ISpRecoResult_GetAlternates_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoResult_GetAudio_Proxy( 
    ISpRecoResult * This,
    /* [in] */ ULONG ulStartElement,
    /* [in] */ ULONG cElements,
    /* [out] */ ISpStreamFormat **ppStream);


void __RPC_STUB ISpRecoResult_GetAudio_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoResult_SpeakAudio_Proxy( 
    ISpRecoResult * This,
    /* [in] */ ULONG ulStartElement,
    /* [in] */ ULONG cElements,
    /* [in] */ DWORD dwFlags,
    /* [out] */ ULONG *pulStreamNumber);


void __RPC_STUB ISpRecoResult_SpeakAudio_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoResult_Serialize_Proxy( 
    ISpRecoResult * This,
    /* [out] */ SPSERIALIZEDRESULT **ppCoMemSerializedResult);


void __RPC_STUB ISpRecoResult_Serialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoResult_ScaleAudio_Proxy( 
    ISpRecoResult * This,
    /* [in] */ const GUID *pAudioFormatId,
    /* [in] */ const WAVEFORMATEX *pWaveFormatEx);


void __RPC_STUB ISpRecoResult_ScaleAudio_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoResult_GetRecoContext_Proxy( 
    ISpRecoResult * This,
    /* [out] */ ISpRecoContext **ppRecoContext);


void __RPC_STUB ISpRecoResult_GetRecoContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpRecoResult_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sapi_0271 */
/* [local] */ 

typedef struct tagSPTEXTSELECTIONINFO
    {
    ULONG ulStartActiveOffset;
    ULONG cchActiveChars;
    ULONG ulStartSelection;
    ULONG cchSelection;
    } 	SPTEXTSELECTIONINFO;

typedef 
enum SPGRAMMARSTATE
    {	SPGS_DISABLED	= 0,
	SPGS_ENABLED	= 1,
	SPGS_EXCLUSIVE	= 3
    } 	SPGRAMMARSTATE;

typedef 
enum SPCONTEXTSTATE
    {	SPCS_DISABLED	= 0,
	SPCS_ENABLED	= 1
    } 	SPCONTEXTSTATE;

typedef 
enum SPRULESTATE
    {	SPRS_INACTIVE	= 0,
	SPRS_ACTIVE	= 1,
	SPRS_ACTIVE_WITH_AUTO_PAUSE	= 3
    } 	SPRULESTATE;

#define	SP_STREAMPOS_ASAP	( 0 )

#define	SP_STREAMPOS_REALTIME	( -1 )

#define SPRULETRANS_TEXTBUFFER (SPSTATEHANDLE)(-1)
#define SPRULETRANS_WILDCARD   (SPSTATEHANDLE)(-2)
#define SPRULETRANS_DICTATION  (SPSTATEHANDLE)(-3)
typedef 
enum SPGRAMMARWORDTYPE
    {	SPWT_DISPLAY	= 0,
	SPWT_LEXICAL	= SPWT_DISPLAY + 1,
	SPWT_PRONUNCIATION	= SPWT_LEXICAL + 1
    } 	SPGRAMMARWORDTYPE;

typedef struct tagSPPROPERTYINFO
    {
    const WCHAR *pszName;
    ULONG ulId;
    const WCHAR *pszValue;
    VARIANT vValue;
    } 	SPPROPERTYINFO;

typedef 
enum SPCFGRULEATTRIBUTES
    {	SPRAF_TopLevel	= 1 << 0,
	SPRAF_Active	= 1 << 1,
	SPRAF_Export	= 1 << 2,
	SPRAF_Import	= 1 << 3,
	SPRAF_Interpreter	= 1 << 4,
	SPRAF_Dynamic	= 1 << 5,
	SPRAF_AutoPause	= 1 << 16
    } 	SPCFGRULEATTRIBUTES;



extern RPC_IF_HANDLE __MIDL_itf_sapi_0271_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sapi_0271_v0_0_s_ifspec;

#ifndef __ISpGrammarBuilder_INTERFACE_DEFINED__
#define __ISpGrammarBuilder_INTERFACE_DEFINED__

/* interface ISpGrammarBuilder */
/* [local][restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISpGrammarBuilder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8137828F-591A-4A42-BE58-49EA7EBAAC68")
    ISpGrammarBuilder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ResetGrammar( 
            /* [in] */ WORD NewLanguage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRule( 
            /* [in] */ const WCHAR *pszRuleName,
            /* [in] */ DWORD dwRuleId,
            /* [in] */ DWORD dwAttributes,
            /* [in] */ BOOL fCreateIfNotExist,
            /* [out] */ SPSTATEHANDLE *phInitialState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearRule( 
            SPSTATEHANDLE hState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNewState( 
            SPSTATEHANDLE hState,
            SPSTATEHANDLE *phState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddWordTransition( 
            SPSTATEHANDLE hFromState,
            SPSTATEHANDLE hToState,
            const WCHAR *psz,
            const WCHAR *pszSeperators,
            SPGRAMMARWORDTYPE eWordType,
            float Weight,
            const SPPROPERTYINFO *pPropInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRuleTransition( 
            SPSTATEHANDLE hFromState,
            SPSTATEHANDLE hToState,
            SPSTATEHANDLE hRule,
            float Weight,
            const SPPROPERTYINFO *pPropInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddResource( 
            /* [in] */ SPSTATEHANDLE hRuleState,
            /* [in] */ const WCHAR *pszResourceName,
            /* [in] */ const WCHAR *pszResourceValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpGrammarBuilderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpGrammarBuilder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpGrammarBuilder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpGrammarBuilder * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResetGrammar )( 
            ISpGrammarBuilder * This,
            /* [in] */ WORD NewLanguage);
        
        HRESULT ( STDMETHODCALLTYPE *GetRule )( 
            ISpGrammarBuilder * This,
            /* [in] */ const WCHAR *pszRuleName,
            /* [in] */ DWORD dwRuleId,
            /* [in] */ DWORD dwAttributes,
            /* [in] */ BOOL fCreateIfNotExist,
            /* [out] */ SPSTATEHANDLE *phInitialState);
        
        HRESULT ( STDMETHODCALLTYPE *ClearRule )( 
            ISpGrammarBuilder * This,
            SPSTATEHANDLE hState);
        
        HRESULT ( STDMETHODCALLTYPE *CreateNewState )( 
            ISpGrammarBuilder * This,
            SPSTATEHANDLE hState,
            SPSTATEHANDLE *phState);
        
        HRESULT ( STDMETHODCALLTYPE *AddWordTransition )( 
            ISpGrammarBuilder * This,
            SPSTATEHANDLE hFromState,
            SPSTATEHANDLE hToState,
            const WCHAR *psz,
            const WCHAR *pszSeperators,
            SPGRAMMARWORDTYPE eWordType,
            float Weight,
            const SPPROPERTYINFO *pPropInfo);
        
        HRESULT ( STDMETHODCALLTYPE *AddRuleTransition )( 
            ISpGrammarBuilder * This,
            SPSTATEHANDLE hFromState,
            SPSTATEHANDLE hToState,
            SPSTATEHANDLE hRule,
            float Weight,
            const SPPROPERTYINFO *pPropInfo);
        
        HRESULT ( STDMETHODCALLTYPE *AddResource )( 
            ISpGrammarBuilder * This,
            /* [in] */ SPSTATEHANDLE hRuleState,
            /* [in] */ const WCHAR *pszResourceName,
            /* [in] */ const WCHAR *pszResourceValue);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            ISpGrammarBuilder * This,
            DWORD dwReserved);
        
        END_INTERFACE
    } ISpGrammarBuilderVtbl;

    interface ISpGrammarBuilder
    {
        CONST_VTBL struct ISpGrammarBuilderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpGrammarBuilder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpGrammarBuilder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpGrammarBuilder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpGrammarBuilder_ResetGrammar(This,NewLanguage)	\
    (This)->lpVtbl -> ResetGrammar(This,NewLanguage)

#define ISpGrammarBuilder_GetRule(This,pszRuleName,dwRuleId,dwAttributes,fCreateIfNotExist,phInitialState)	\
    (This)->lpVtbl -> GetRule(This,pszRuleName,dwRuleId,dwAttributes,fCreateIfNotExist,phInitialState)

#define ISpGrammarBuilder_ClearRule(This,hState)	\
    (This)->lpVtbl -> ClearRule(This,hState)

#define ISpGrammarBuilder_CreateNewState(This,hState,phState)	\
    (This)->lpVtbl -> CreateNewState(This,hState,phState)

#define ISpGrammarBuilder_AddWordTransition(This,hFromState,hToState,psz,pszSeperators,eWordType,Weight,pPropInfo)	\
    (This)->lpVtbl -> AddWordTransition(This,hFromState,hToState,psz,pszSeperators,eWordType,Weight,pPropInfo)

#define ISpGrammarBuilder_AddRuleTransition(This,hFromState,hToState,hRule,Weight,pPropInfo)	\
    (This)->lpVtbl -> AddRuleTransition(This,hFromState,hToState,hRule,Weight,pPropInfo)

#define ISpGrammarBuilder_AddResource(This,hRuleState,pszResourceName,pszResourceValue)	\
    (This)->lpVtbl -> AddResource(This,hRuleState,pszResourceName,pszResourceValue)

#define ISpGrammarBuilder_Commit(This,dwReserved)	\
    (This)->lpVtbl -> Commit(This,dwReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpGrammarBuilder_ResetGrammar_Proxy( 
    ISpGrammarBuilder * This,
    /* [in] */ WORD NewLanguage);


void __RPC_STUB ISpGrammarBuilder_ResetGrammar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpGrammarBuilder_GetRule_Proxy( 
    ISpGrammarBuilder * This,
    /* [in] */ const WCHAR *pszRuleName,
    /* [in] */ DWORD dwRuleId,
    /* [in] */ DWORD dwAttributes,
    /* [in] */ BOOL fCreateIfNotExist,
    /* [out] */ SPSTATEHANDLE *phInitialState);


void __RPC_STUB ISpGrammarBuilder_GetRule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpGrammarBuilder_ClearRule_Proxy( 
    ISpGrammarBuilder * This,
    SPSTATEHANDLE hState);


void __RPC_STUB ISpGrammarBuilder_ClearRule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpGrammarBuilder_CreateNewState_Proxy( 
    ISpGrammarBuilder * This,
    SPSTATEHANDLE hState,
    SPSTATEHANDLE *phState);


void __RPC_STUB ISpGrammarBuilder_CreateNewState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpGrammarBuilder_AddWordTransition_Proxy( 
    ISpGrammarBuilder * This,
    SPSTATEHANDLE hFromState,
    SPSTATEHANDLE hToState,
    const WCHAR *psz,
    const WCHAR *pszSeperators,
    SPGRAMMARWORDTYPE eWordType,
    float Weight,
    const SPPROPERTYINFO *pPropInfo);


void __RPC_STUB ISpGrammarBuilder_AddWordTransition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpGrammarBuilder_AddRuleTransition_Proxy( 
    ISpGrammarBuilder * This,
    SPSTATEHANDLE hFromState,
    SPSTATEHANDLE hToState,
    SPSTATEHANDLE hRule,
    float Weight,
    const SPPROPERTYINFO *pPropInfo);


void __RPC_STUB ISpGrammarBuilder_AddRuleTransition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpGrammarBuilder_AddResource_Proxy( 
    ISpGrammarBuilder * This,
    /* [in] */ SPSTATEHANDLE hRuleState,
    /* [in] */ const WCHAR *pszResourceName,
    /* [in] */ const WCHAR *pszResourceValue);


void __RPC_STUB ISpGrammarBuilder_AddResource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpGrammarBuilder_Commit_Proxy( 
    ISpGrammarBuilder * This,
    DWORD dwReserved);


void __RPC_STUB ISpGrammarBuilder_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpGrammarBuilder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sapi_0272 */
/* [local] */ 

typedef 
enum SPLOADOPTIONS
    {	SPLO_STATIC	= 0,
	SPLO_DYNAMIC	= 1
    } 	SPLOADOPTIONS;



extern RPC_IF_HANDLE __MIDL_itf_sapi_0272_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sapi_0272_v0_0_s_ifspec;

#ifndef __ISpRecoGrammar_INTERFACE_DEFINED__
#define __ISpRecoGrammar_INTERFACE_DEFINED__

/* interface ISpRecoGrammar */
/* [local][restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISpRecoGrammar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2177DB29-7F45-47D0-8554-067E91C80502")
    ISpRecoGrammar : public ISpGrammarBuilder
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetGrammarId( 
            /* [out] */ ULONGLONG *pullGrammarId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecoContext( 
            /* [out] */ ISpRecoContext **ppRecoCtxt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadCmdFromFile( 
            /* [string][in] */ const WCHAR *pszFileName,
            /* [in] */ SPLOADOPTIONS Options) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadCmdFromObject( 
            /* [in] */ REFCLSID rcid,
            /* [string][in] */ const WCHAR *pszGrammarName,
            /* [in] */ SPLOADOPTIONS Options) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadCmdFromResource( 
            /* [in] */ HMODULE hModule,
            /* [string][in] */ const WCHAR *pszResourceName,
            /* [string][in] */ const WCHAR *pszResourceType,
            /* [in] */ WORD wLanguage,
            /* [in] */ SPLOADOPTIONS Options) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadCmdFromMemory( 
            /* [in] */ const SPBINARYGRAMMAR *pGrammar,
            /* [in] */ SPLOADOPTIONS Options) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadCmdFromProprietaryGrammar( 
            /* [in] */ REFGUID rguidParam,
            /* [string][in] */ const WCHAR *pszStringParam,
            /* [in] */ const void *pvDataPrarm,
            /* [in] */ ULONG cbDataSize,
            /* [in] */ SPLOADOPTIONS Options) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRuleState( 
            /* [string][in] */ const WCHAR *pszName,
            void *pReserved,
            /* [in] */ SPRULESTATE NewState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRuleIdState( 
            /* [in] */ ULONG ulRuleId,
            /* [in] */ SPRULESTATE NewState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadDictation( 
            /* [string][in] */ const WCHAR *pszTopicName,
            /* [in] */ SPLOADOPTIONS Options) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnloadDictation( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDictationState( 
            /* [in] */ SPRULESTATE NewState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWordSequenceData( 
            /* [in] */ const WCHAR *pText,
            /* [in] */ ULONG cchText,
            /* [in] */ const SPTEXTSELECTIONINFO *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTextSelection( 
            /* [in] */ const SPTEXTSELECTIONINFO *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsPronounceable( 
            /* [string][in] */ const WCHAR *pszWord,
            /* [out] */ BOOL *pfPronounciable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGrammarState( 
            /* [in] */ SPGRAMMARSTATE eGrammarState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveCmd( 
            /* [in] */ IStream *pStream,
            /* [optional][out] */ WCHAR **ppszCoMemErrorText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGrammarState( 
            /* [out] */ SPGRAMMARSTATE *peGrammarState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpRecoGrammarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpRecoGrammar * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpRecoGrammar * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpRecoGrammar * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResetGrammar )( 
            ISpRecoGrammar * This,
            /* [in] */ WORD NewLanguage);
        
        HRESULT ( STDMETHODCALLTYPE *GetRule )( 
            ISpRecoGrammar * This,
            /* [in] */ const WCHAR *pszRuleName,
            /* [in] */ DWORD dwRuleId,
            /* [in] */ DWORD dwAttributes,
            /* [in] */ BOOL fCreateIfNotExist,
            /* [out] */ SPSTATEHANDLE *phInitialState);
        
        HRESULT ( STDMETHODCALLTYPE *ClearRule )( 
            ISpRecoGrammar * This,
            SPSTATEHANDLE hState);
        
        HRESULT ( STDMETHODCALLTYPE *CreateNewState )( 
            ISpRecoGrammar * This,
            SPSTATEHANDLE hState,
            SPSTATEHANDLE *phState);
        
        HRESULT ( STDMETHODCALLTYPE *AddWordTransition )( 
            ISpRecoGrammar * This,
            SPSTATEHANDLE hFromState,
            SPSTATEHANDLE hToState,
            const WCHAR *psz,
            const WCHAR *pszSeperators,
            SPGRAMMARWORDTYPE eWordType,
            float Weight,
            const SPPROPERTYINFO *pPropInfo);
        
        HRESULT ( STDMETHODCALLTYPE *AddRuleTransition )( 
            ISpRecoGrammar * This,
            SPSTATEHANDLE hFromState,
            SPSTATEHANDLE hToState,
            SPSTATEHANDLE hRule,
            float Weight,
            const SPPROPERTYINFO *pPropInfo);
        
        HRESULT ( STDMETHODCALLTYPE *AddResource )( 
            ISpRecoGrammar * This,
            /* [in] */ SPSTATEHANDLE hRuleState,
            /* [in] */ const WCHAR *pszResourceName,
            /* [in] */ const WCHAR *pszResourceValue);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            ISpRecoGrammar * This,
            DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetGrammarId )( 
            ISpRecoGrammar * This,
            /* [out] */ ULONGLONG *pullGrammarId);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecoContext )( 
            ISpRecoGrammar * This,
            /* [out] */ ISpRecoContext **ppRecoCtxt);
        
        HRESULT ( STDMETHODCALLTYPE *LoadCmdFromFile )( 
            ISpRecoGrammar * This,
            /* [string][in] */ const WCHAR *pszFileName,
            /* [in] */ SPLOADOPTIONS Options);
        
        HRESULT ( STDMETHODCALLTYPE *LoadCmdFromObject )( 
            ISpRecoGrammar * This,
            /* [in] */ REFCLSID rcid,
            /* [string][in] */ const WCHAR *pszGrammarName,
            /* [in] */ SPLOADOPTIONS Options);
        
        HRESULT ( STDMETHODCALLTYPE *LoadCmdFromResource )( 
            ISpRecoGrammar * This,
            /* [in] */ HMODULE hModule,
            /* [string][in] */ const WCHAR *pszResourceName,
            /* [string][in] */ const WCHAR *pszResourceType,
            /* [in] */ WORD wLanguage,
            /* [in] */ SPLOADOPTIONS Options);
        
        HRESULT ( STDMETHODCALLTYPE *LoadCmdFromMemory )( 
            ISpRecoGrammar * This,
            /* [in] */ const SPBINARYGRAMMAR *pGrammar,
            /* [in] */ SPLOADOPTIONS Options);
        
        HRESULT ( STDMETHODCALLTYPE *LoadCmdFromProprietaryGrammar )( 
            ISpRecoGrammar * This,
            /* [in] */ REFGUID rguidParam,
            /* [string][in] */ const WCHAR *pszStringParam,
            /* [in] */ const void *pvDataPrarm,
            /* [in] */ ULONG cbDataSize,
            /* [in] */ SPLOADOPTIONS Options);
        
        HRESULT ( STDMETHODCALLTYPE *SetRuleState )( 
            ISpRecoGrammar * This,
            /* [string][in] */ const WCHAR *pszName,
            void *pReserved,
            /* [in] */ SPRULESTATE NewState);
        
        HRESULT ( STDMETHODCALLTYPE *SetRuleIdState )( 
            ISpRecoGrammar * This,
            /* [in] */ ULONG ulRuleId,
            /* [in] */ SPRULESTATE NewState);
        
        HRESULT ( STDMETHODCALLTYPE *LoadDictation )( 
            ISpRecoGrammar * This,
            /* [string][in] */ const WCHAR *pszTopicName,
            /* [in] */ SPLOADOPTIONS Options);
        
        HRESULT ( STDMETHODCALLTYPE *UnloadDictation )( 
            ISpRecoGrammar * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDictationState )( 
            ISpRecoGrammar * This,
            /* [in] */ SPRULESTATE NewState);
        
        HRESULT ( STDMETHODCALLTYPE *SetWordSequenceData )( 
            ISpRecoGrammar * This,
            /* [in] */ const WCHAR *pText,
            /* [in] */ ULONG cchText,
            /* [in] */ const SPTEXTSELECTIONINFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetTextSelection )( 
            ISpRecoGrammar * This,
            /* [in] */ const SPTEXTSELECTIONINFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *IsPronounceable )( 
            ISpRecoGrammar * This,
            /* [string][in] */ const WCHAR *pszWord,
            /* [out] */ BOOL *pfPronounciable);
        
        HRESULT ( STDMETHODCALLTYPE *SetGrammarState )( 
            ISpRecoGrammar * This,
            /* [in] */ SPGRAMMARSTATE eGrammarState);
        
        HRESULT ( STDMETHODCALLTYPE *SaveCmd )( 
            ISpRecoGrammar * This,
            /* [in] */ IStream *pStream,
            /* [optional][out] */ WCHAR **ppszCoMemErrorText);
        
        HRESULT ( STDMETHODCALLTYPE *GetGrammarState )( 
            ISpRecoGrammar * This,
            /* [out] */ SPGRAMMARSTATE *peGrammarState);
        
        END_INTERFACE
    } ISpRecoGrammarVtbl;

    interface ISpRecoGrammar
    {
        CONST_VTBL struct ISpRecoGrammarVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpRecoGrammar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpRecoGrammar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpRecoGrammar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpRecoGrammar_ResetGrammar(This,NewLanguage)	\
    (This)->lpVtbl -> ResetGrammar(This,NewLanguage)

#define ISpRecoGrammar_GetRule(This,pszRuleName,dwRuleId,dwAttributes,fCreateIfNotExist,phInitialState)	\
    (This)->lpVtbl -> GetRule(This,pszRuleName,dwRuleId,dwAttributes,fCreateIfNotExist,phInitialState)

#define ISpRecoGrammar_ClearRule(This,hState)	\
    (This)->lpVtbl -> ClearRule(This,hState)

#define ISpRecoGrammar_CreateNewState(This,hState,phState)	\
    (This)->lpVtbl -> CreateNewState(This,hState,phState)

#define ISpRecoGrammar_AddWordTransition(This,hFromState,hToState,psz,pszSeperators,eWordType,Weight,pPropInfo)	\
    (This)->lpVtbl -> AddWordTransition(This,hFromState,hToState,psz,pszSeperators,eWordType,Weight,pPropInfo)

#define ISpRecoGrammar_AddRuleTransition(This,hFromState,hToState,hRule,Weight,pPropInfo)	\
    (This)->lpVtbl -> AddRuleTransition(This,hFromState,hToState,hRule,Weight,pPropInfo)

#define ISpRecoGrammar_AddResource(This,hRuleState,pszResourceName,pszResourceValue)	\
    (This)->lpVtbl -> AddResource(This,hRuleState,pszResourceName,pszResourceValue)

#define ISpRecoGrammar_Commit(This,dwReserved)	\
    (This)->lpVtbl -> Commit(This,dwReserved)


#define ISpRecoGrammar_GetGrammarId(This,pullGrammarId)	\
    (This)->lpVtbl -> GetGrammarId(This,pullGrammarId)

#define ISpRecoGrammar_GetRecoContext(This,ppRecoCtxt)	\
    (This)->lpVtbl -> GetRecoContext(This,ppRecoCtxt)

#define ISpRecoGrammar_LoadCmdFromFile(This,pszFileName,Options)	\
    (This)->lpVtbl -> LoadCmdFromFile(This,pszFileName,Options)

#define ISpRecoGrammar_LoadCmdFromObject(This,rcid,pszGrammarName,Options)	\
    (This)->lpVtbl -> LoadCmdFromObject(This,rcid,pszGrammarName,Options)

#define ISpRecoGrammar_LoadCmdFromResource(This,hModule,pszResourceName,pszResourceType,wLanguage,Options)	\
    (This)->lpVtbl -> LoadCmdFromResource(This,hModule,pszResourceName,pszResourceType,wLanguage,Options)

#define ISpRecoGrammar_LoadCmdFromMemory(This,pGrammar,Options)	\
    (This)->lpVtbl -> LoadCmdFromMemory(This,pGrammar,Options)

#define ISpRecoGrammar_LoadCmdFromProprietaryGrammar(This,rguidParam,pszStringParam,pvDataPrarm,cbDataSize,Options)	\
    (This)->lpVtbl -> LoadCmdFromProprietaryGrammar(This,rguidParam,pszStringParam,pvDataPrarm,cbDataSize,Options)

#define ISpRecoGrammar_SetRuleState(This,pszName,pReserved,NewState)	\
    (This)->lpVtbl -> SetRuleState(This,pszName,pReserved,NewState)

#define ISpRecoGrammar_SetRuleIdState(This,ulRuleId,NewState)	\
    (This)->lpVtbl -> SetRuleIdState(This,ulRuleId,NewState)

#define ISpRecoGrammar_LoadDictation(This,pszTopicName,Options)	\
    (This)->lpVtbl -> LoadDictation(This,pszTopicName,Options)

#define ISpRecoGrammar_UnloadDictation(This)	\
    (This)->lpVtbl -> UnloadDictation(This)

#define ISpRecoGrammar_SetDictationState(This,NewState)	\
    (This)->lpVtbl -> SetDictationState(This,NewState)

#define ISpRecoGrammar_SetWordSequenceData(This,pText,cchText,pInfo)	\
    (This)->lpVtbl -> SetWordSequenceData(This,pText,cchText,pInfo)

#define ISpRecoGrammar_SetTextSelection(This,pInfo)	\
    (This)->lpVtbl -> SetTextSelection(This,pInfo)

#define ISpRecoGrammar_IsPronounceable(This,pszWord,pfPronounciable)	\
    (This)->lpVtbl -> IsPronounceable(This,pszWord,pfPronounciable)

#define ISpRecoGrammar_SetGrammarState(This,eGrammarState)	\
    (This)->lpVtbl -> SetGrammarState(This,eGrammarState)

#define ISpRecoGrammar_SaveCmd(This,pStream,ppszCoMemErrorText)	\
    (This)->lpVtbl -> SaveCmd(This,pStream,ppszCoMemErrorText)

#define ISpRecoGrammar_GetGrammarState(This,peGrammarState)	\
    (This)->lpVtbl -> GetGrammarState(This,peGrammarState)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpRecoGrammar_GetGrammarId_Proxy( 
    ISpRecoGrammar * This,
    /* [out] */ ULONGLONG *pullGrammarId);


void __RPC_STUB ISpRecoGrammar_GetGrammarId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoGrammar_GetRecoContext_Proxy( 
    ISpRecoGrammar * This,
    /* [out] */ ISpRecoContext **ppRecoCtxt);


void __RPC_STUB ISpRecoGrammar_GetRecoContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoGrammar_LoadCmdFromFile_Proxy( 
    ISpRecoGrammar * This,
    /* [string][in] */ const WCHAR *pszFileName,
    /* [in] */ SPLOADOPTIONS Options);


void __RPC_STUB ISpRecoGrammar_LoadCmdFromFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoGrammar_LoadCmdFromObject_Proxy( 
    ISpRecoGrammar * This,
    /* [in] */ REFCLSID rcid,
    /* [string][in] */ const WCHAR *pszGrammarName,
    /* [in] */ SPLOADOPTIONS Options);


void __RPC_STUB ISpRecoGrammar_LoadCmdFromObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoGrammar_LoadCmdFromResource_Proxy( 
    ISpRecoGrammar * This,
    /* [in] */ HMODULE hModule,
    /* [string][in] */ const WCHAR *pszResourceName,
    /* [string][in] */ const WCHAR *pszResourceType,
    /* [in] */ WORD wLanguage,
    /* [in] */ SPLOADOPTIONS Options);


void __RPC_STUB ISpRecoGrammar_LoadCmdFromResource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoGrammar_LoadCmdFromMemory_Proxy( 
    ISpRecoGrammar * This,
    /* [in] */ const SPBINARYGRAMMAR *pGrammar,
    /* [in] */ SPLOADOPTIONS Options);


void __RPC_STUB ISpRecoGrammar_LoadCmdFromMemory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoGrammar_LoadCmdFromProprietaryGrammar_Proxy( 
    ISpRecoGrammar * This,
    /* [in] */ REFGUID rguidParam,
    /* [string][in] */ const WCHAR *pszStringParam,
    /* [in] */ const void *pvDataPrarm,
    /* [in] */ ULONG cbDataSize,
    /* [in] */ SPLOADOPTIONS Options);


void __RPC_STUB ISpRecoGrammar_LoadCmdFromProprietaryGrammar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoGrammar_SetRuleState_Proxy( 
    ISpRecoGrammar * This,
    /* [string][in] */ const WCHAR *pszName,
    void *pReserved,
    /* [in] */ SPRULESTATE NewState);


void __RPC_STUB ISpRecoGrammar_SetRuleState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoGrammar_SetRuleIdState_Proxy( 
    ISpRecoGrammar * This,
    /* [in] */ ULONG ulRuleId,
    /* [in] */ SPRULESTATE NewState);


void __RPC_STUB ISpRecoGrammar_SetRuleIdState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoGrammar_LoadDictation_Proxy( 
    ISpRecoGrammar * This,
    /* [string][in] */ const WCHAR *pszTopicName,
    /* [in] */ SPLOADOPTIONS Options);


void __RPC_STUB ISpRecoGrammar_LoadDictation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoGrammar_UnloadDictation_Proxy( 
    ISpRecoGrammar * This);


void __RPC_STUB ISpRecoGrammar_UnloadDictation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoGrammar_SetDictationState_Proxy( 
    ISpRecoGrammar * This,
    /* [in] */ SPRULESTATE NewState);


void __RPC_STUB ISpRecoGrammar_SetDictationState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoGrammar_SetWordSequenceData_Proxy( 
    ISpRecoGrammar * This,
    /* [in] */ const WCHAR *pText,
    /* [in] */ ULONG cchText,
    /* [in] */ const SPTEXTSELECTIONINFO *pInfo);


void __RPC_STUB ISpRecoGrammar_SetWordSequenceData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoGrammar_SetTextSelection_Proxy( 
    ISpRecoGrammar * This,
    /* [in] */ const SPTEXTSELECTIONINFO *pInfo);


void __RPC_STUB ISpRecoGrammar_SetTextSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoGrammar_IsPronounceable_Proxy( 
    ISpRecoGrammar * This,
    /* [string][in] */ const WCHAR *pszWord,
    /* [out] */ BOOL *pfPronounciable);


void __RPC_STUB ISpRecoGrammar_IsPronounceable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoGrammar_SetGrammarState_Proxy( 
    ISpRecoGrammar * This,
    /* [in] */ SPGRAMMARSTATE eGrammarState);


void __RPC_STUB ISpRecoGrammar_SetGrammarState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoGrammar_SaveCmd_Proxy( 
    ISpRecoGrammar * This,
    /* [in] */ IStream *pStream,
    /* [optional][out] */ WCHAR **ppszCoMemErrorText);


void __RPC_STUB ISpRecoGrammar_SaveCmd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoGrammar_GetGrammarState_Proxy( 
    ISpRecoGrammar * This,
    /* [out] */ SPGRAMMARSTATE *peGrammarState);


void __RPC_STUB ISpRecoGrammar_GetGrammarState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpRecoGrammar_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sapi_0273 */
/* [local] */ 

typedef /* [restricted] */ struct SPRECOCONTEXTSTATUS
    {
    SPINTERFERENCE eInterference;
    WCHAR szRequestTypeOfUI[ 255 ];
    DWORD dwReserved1;
    DWORD dwReserved2;
    } 	SPRECOCONTEXTSTATUS;

typedef 
enum SPBOOKMARKOPTIONS
    {	SPBO_NONE	= 0,
	SPBO_PAUSE	= 1
    } 	SPBOOKMARKOPTIONS;

typedef 
enum SPAUDIOOPTIONS
    {	SPAO_NONE	= 0,
	SPAO_RETAIN_AUDIO	= 1 << 0
    } 	SPAUDIOOPTIONS;



extern RPC_IF_HANDLE __MIDL_itf_sapi_0273_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sapi_0273_v0_0_s_ifspec;

#ifndef __ISpRecoContext_INTERFACE_DEFINED__
#define __ISpRecoContext_INTERFACE_DEFINED__

/* interface ISpRecoContext */
/* [restricted][local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISpRecoContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F740A62F-7C15-489E-8234-940A33D9272D")
    ISpRecoContext : public ISpEventSource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRecognizer( 
            /* [out] */ ISpRecognizer **ppRecognizer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateGrammar( 
            /* [in] */ ULONGLONG ullGrammarId,
            /* [out] */ ISpRecoGrammar **ppGrammar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ SPRECOCONTEXTSTATUS *pStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxAlternates( 
            /* [in] */ ULONG *pcAlternates) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxAlternates( 
            /* [in] */ ULONG cAlternates) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAudioOptions( 
            /* [in] */ SPAUDIOOPTIONS Options,
            /* [in] */ const GUID *pAudioFormatId,
            /* [in] */ const WAVEFORMATEX *pWaveFormatEx) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAudioOptions( 
            /* [in] */ SPAUDIOOPTIONS *pOptions,
            /* [out] */ GUID *pAudioFormatId,
            /* [out] */ WAVEFORMATEX **ppCoMemWFEX) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeserializeResult( 
            /* [in] */ const SPSERIALIZEDRESULT *pSerializedResult,
            /* [out] */ ISpRecoResult **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Bookmark( 
            /* [in] */ SPBOOKMARKOPTIONS Options,
            /* [in] */ ULONGLONG ullStreamPosition,
            /* [in] */ LPARAM lparamEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAdaptationData( 
            /* [string][in] */ const WCHAR *pAdaptationData,
            /* [in] */ const ULONG cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( 
            DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( 
            DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVoice( 
            /* [in] */ ISpVoice *pVoice,
            /* [in] */ BOOL fAllowFormatChanges) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVoice( 
            /* [out] */ ISpVoice **ppVoice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVoicePurgeEvent( 
            /* [in] */ ULONGLONG ullEventInterest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVoicePurgeEvent( 
            /* [out] */ ULONGLONG *pullEventInterest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContextState( 
            /* [in] */ SPCONTEXTSTATE eContextState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContextState( 
            /* [in] */ SPCONTEXTSTATE *peContextState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpRecoContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpRecoContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpRecoContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpRecoContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetNotifySink )( 
            ISpRecoContext * This,
            /* [in] */ ISpNotifySink *pNotifySink);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetNotifyWindowMessage )( 
            ISpRecoContext * This,
            /* [in] */ HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetNotifyCallbackFunction )( 
            ISpRecoContext * This,
            /* [in] */ SPNOTIFYCALLBACK *pfnCallback,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetNotifyCallbackInterface )( 
            ISpRecoContext * This,
            /* [in] */ ISpNotifyCallback *pSpCallback,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetNotifyWin32Event )( 
            ISpRecoContext * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *WaitForNotifyEvent )( 
            ISpRecoContext * This,
            /* [in] */ DWORD dwMilliseconds);
        
        /* [local] */ HANDLE ( STDMETHODCALLTYPE *GetNotifyEventHandle )( 
            ISpRecoContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetInterest )( 
            ISpRecoContext * This,
            /* [in] */ ULONGLONG ullEventInterest,
            /* [in] */ ULONGLONG ullQueuedInterest);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvents )( 
            ISpRecoContext * This,
            /* [in] */ ULONG ulCount,
            /* [size_is][out] */ SPEVENT *pEventArray,
            /* [out] */ ULONG *pulFetched);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            ISpRecoContext * This,
            /* [out] */ SPEVENTSOURCEINFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecognizer )( 
            ISpRecoContext * This,
            /* [out] */ ISpRecognizer **ppRecognizer);
        
        HRESULT ( STDMETHODCALLTYPE *CreateGrammar )( 
            ISpRecoContext * This,
            /* [in] */ ULONGLONG ullGrammarId,
            /* [out] */ ISpRecoGrammar **ppGrammar);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            ISpRecoContext * This,
            /* [out] */ SPRECOCONTEXTSTATUS *pStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxAlternates )( 
            ISpRecoContext * This,
            /* [in] */ ULONG *pcAlternates);
        
        HRESULT ( STDMETHODCALLTYPE *SetMaxAlternates )( 
            ISpRecoContext * This,
            /* [in] */ ULONG cAlternates);
        
        HRESULT ( STDMETHODCALLTYPE *SetAudioOptions )( 
            ISpRecoContext * This,
            /* [in] */ SPAUDIOOPTIONS Options,
            /* [in] */ const GUID *pAudioFormatId,
            /* [in] */ const WAVEFORMATEX *pWaveFormatEx);
        
        HRESULT ( STDMETHODCALLTYPE *GetAudioOptions )( 
            ISpRecoContext * This,
            /* [in] */ SPAUDIOOPTIONS *pOptions,
            /* [out] */ GUID *pAudioFormatId,
            /* [out] */ WAVEFORMATEX **ppCoMemWFEX);
        
        HRESULT ( STDMETHODCALLTYPE *DeserializeResult )( 
            ISpRecoContext * This,
            /* [in] */ const SPSERIALIZEDRESULT *pSerializedResult,
            /* [out] */ ISpRecoResult **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *Bookmark )( 
            ISpRecoContext * This,
            /* [in] */ SPBOOKMARKOPTIONS Options,
            /* [in] */ ULONGLONG ullStreamPosition,
            /* [in] */ LPARAM lparamEvent);
        
        HRESULT ( STDMETHODCALLTYPE *SetAdaptationData )( 
            ISpRecoContext * This,
            /* [string][in] */ const WCHAR *pAdaptationData,
            /* [in] */ const ULONG cch);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            ISpRecoContext * This,
            DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            ISpRecoContext * This,
            DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SetVoice )( 
            ISpRecoContext * This,
            /* [in] */ ISpVoice *pVoice,
            /* [in] */ BOOL fAllowFormatChanges);
        
        HRESULT ( STDMETHODCALLTYPE *GetVoice )( 
            ISpRecoContext * This,
            /* [out] */ ISpVoice **ppVoice);
        
        HRESULT ( STDMETHODCALLTYPE *SetVoicePurgeEvent )( 
            ISpRecoContext * This,
            /* [in] */ ULONGLONG ullEventInterest);
        
        HRESULT ( STDMETHODCALLTYPE *GetVoicePurgeEvent )( 
            ISpRecoContext * This,
            /* [out] */ ULONGLONG *pullEventInterest);
        
        HRESULT ( STDMETHODCALLTYPE *SetContextState )( 
            ISpRecoContext * This,
            /* [in] */ SPCONTEXTSTATE eContextState);
        
        HRESULT ( STDMETHODCALLTYPE *GetContextState )( 
            ISpRecoContext * This,
            /* [in] */ SPCONTEXTSTATE *peContextState);
        
        END_INTERFACE
    } ISpRecoContextVtbl;

    interface ISpRecoContext
    {
        CONST_VTBL struct ISpRecoContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpRecoContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpRecoContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpRecoContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpRecoContext_SetNotifySink(This,pNotifySink)	\
    (This)->lpVtbl -> SetNotifySink(This,pNotifySink)

#define ISpRecoContext_SetNotifyWindowMessage(This,hWnd,Msg,wParam,lParam)	\
    (This)->lpVtbl -> SetNotifyWindowMessage(This,hWnd,Msg,wParam,lParam)

#define ISpRecoContext_SetNotifyCallbackFunction(This,pfnCallback,wParam,lParam)	\
    (This)->lpVtbl -> SetNotifyCallbackFunction(This,pfnCallback,wParam,lParam)

#define ISpRecoContext_SetNotifyCallbackInterface(This,pSpCallback,wParam,lParam)	\
    (This)->lpVtbl -> SetNotifyCallbackInterface(This,pSpCallback,wParam,lParam)

#define ISpRecoContext_SetNotifyWin32Event(This)	\
    (This)->lpVtbl -> SetNotifyWin32Event(This)

#define ISpRecoContext_WaitForNotifyEvent(This,dwMilliseconds)	\
    (This)->lpVtbl -> WaitForNotifyEvent(This,dwMilliseconds)

#define ISpRecoContext_GetNotifyEventHandle(This)	\
    (This)->lpVtbl -> GetNotifyEventHandle(This)


#define ISpRecoContext_SetInterest(This,ullEventInterest,ullQueuedInterest)	\
    (This)->lpVtbl -> SetInterest(This,ullEventInterest,ullQueuedInterest)

#define ISpRecoContext_GetEvents(This,ulCount,pEventArray,pulFetched)	\
    (This)->lpVtbl -> GetEvents(This,ulCount,pEventArray,pulFetched)

#define ISpRecoContext_GetInfo(This,pInfo)	\
    (This)->lpVtbl -> GetInfo(This,pInfo)


#define ISpRecoContext_GetRecognizer(This,ppRecognizer)	\
    (This)->lpVtbl -> GetRecognizer(This,ppRecognizer)

#define ISpRecoContext_CreateGrammar(This,ullGrammarId,ppGrammar)	\
    (This)->lpVtbl -> CreateGrammar(This,ullGrammarId,ppGrammar)

#define ISpRecoContext_GetStatus(This,pStatus)	\
    (This)->lpVtbl -> GetStatus(This,pStatus)

#define ISpRecoContext_GetMaxAlternates(This,pcAlternates)	\
    (This)->lpVtbl -> GetMaxAlternates(This,pcAlternates)

#define ISpRecoContext_SetMaxAlternates(This,cAlternates)	\
    (This)->lpVtbl -> SetMaxAlternates(This,cAlternates)

#define ISpRecoContext_SetAudioOptions(This,Options,pAudioFormatId,pWaveFormatEx)	\
    (This)->lpVtbl -> SetAudioOptions(This,Options,pAudioFormatId,pWaveFormatEx)

#define ISpRecoContext_GetAudioOptions(This,pOptions,pAudioFormatId,ppCoMemWFEX)	\
    (This)->lpVtbl -> GetAudioOptions(This,pOptions,pAudioFormatId,ppCoMemWFEX)

#define ISpRecoContext_DeserializeResult(This,pSerializedResult,ppResult)	\
    (This)->lpVtbl -> DeserializeResult(This,pSerializedResult,ppResult)

#define ISpRecoContext_Bookmark(This,Options,ullStreamPosition,lparamEvent)	\
    (This)->lpVtbl -> Bookmark(This,Options,ullStreamPosition,lparamEvent)

#define ISpRecoContext_SetAdaptationData(This,pAdaptationData,cch)	\
    (This)->lpVtbl -> SetAdaptationData(This,pAdaptationData,cch)

#define ISpRecoContext_Pause(This,dwReserved)	\
    (This)->lpVtbl -> Pause(This,dwReserved)

#define ISpRecoContext_Resume(This,dwReserved)	\
    (This)->lpVtbl -> Resume(This,dwReserved)

#define ISpRecoContext_SetVoice(This,pVoice,fAllowFormatChanges)	\
    (This)->lpVtbl -> SetVoice(This,pVoice,fAllowFormatChanges)

#define ISpRecoContext_GetVoice(This,ppVoice)	\
    (This)->lpVtbl -> GetVoice(This,ppVoice)

#define ISpRecoContext_SetVoicePurgeEvent(This,ullEventInterest)	\
    (This)->lpVtbl -> SetVoicePurgeEvent(This,ullEventInterest)

#define ISpRecoContext_GetVoicePurgeEvent(This,pullEventInterest)	\
    (This)->lpVtbl -> GetVoicePurgeEvent(This,pullEventInterest)

#define ISpRecoContext_SetContextState(This,eContextState)	\
    (This)->lpVtbl -> SetContextState(This,eContextState)

#define ISpRecoContext_GetContextState(This,peContextState)	\
    (This)->lpVtbl -> GetContextState(This,peContextState)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpRecoContext_GetRecognizer_Proxy( 
    ISpRecoContext * This,
    /* [out] */ ISpRecognizer **ppRecognizer);


void __RPC_STUB ISpRecoContext_GetRecognizer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoContext_CreateGrammar_Proxy( 
    ISpRecoContext * This,
    /* [in] */ ULONGLONG ullGrammarId,
    /* [out] */ ISpRecoGrammar **ppGrammar);


void __RPC_STUB ISpRecoContext_CreateGrammar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoContext_GetStatus_Proxy( 
    ISpRecoContext * This,
    /* [out] */ SPRECOCONTEXTSTATUS *pStatus);


void __RPC_STUB ISpRecoContext_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoContext_GetMaxAlternates_Proxy( 
    ISpRecoContext * This,
    /* [in] */ ULONG *pcAlternates);


void __RPC_STUB ISpRecoContext_GetMaxAlternates_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoContext_SetMaxAlternates_Proxy( 
    ISpRecoContext * This,
    /* [in] */ ULONG cAlternates);


void __RPC_STUB ISpRecoContext_SetMaxAlternates_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoContext_SetAudioOptions_Proxy( 
    ISpRecoContext * This,
    /* [in] */ SPAUDIOOPTIONS Options,
    /* [in] */ const GUID *pAudioFormatId,
    /* [in] */ const WAVEFORMATEX *pWaveFormatEx);


void __RPC_STUB ISpRecoContext_SetAudioOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoContext_GetAudioOptions_Proxy( 
    ISpRecoContext * This,
    /* [in] */ SPAUDIOOPTIONS *pOptions,
    /* [out] */ GUID *pAudioFormatId,
    /* [out] */ WAVEFORMATEX **ppCoMemWFEX);


void __RPC_STUB ISpRecoContext_GetAudioOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoContext_DeserializeResult_Proxy( 
    ISpRecoContext * This,
    /* [in] */ const SPSERIALIZEDRESULT *pSerializedResult,
    /* [out] */ ISpRecoResult **ppResult);


void __RPC_STUB ISpRecoContext_DeserializeResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoContext_Bookmark_Proxy( 
    ISpRecoContext * This,
    /* [in] */ SPBOOKMARKOPTIONS Options,
    /* [in] */ ULONGLONG ullStreamPosition,
    /* [in] */ LPARAM lparamEvent);


void __RPC_STUB ISpRecoContext_Bookmark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoContext_SetAdaptationData_Proxy( 
    ISpRecoContext * This,
    /* [string][in] */ const WCHAR *pAdaptationData,
    /* [in] */ const ULONG cch);


void __RPC_STUB ISpRecoContext_SetAdaptationData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoContext_Pause_Proxy( 
    ISpRecoContext * This,
    DWORD dwReserved);


void __RPC_STUB ISpRecoContext_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoContext_Resume_Proxy( 
    ISpRecoContext * This,
    DWORD dwReserved);


void __RPC_STUB ISpRecoContext_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoContext_SetVoice_Proxy( 
    ISpRecoContext * This,
    /* [in] */ ISpVoice *pVoice,
    /* [in] */ BOOL fAllowFormatChanges);


void __RPC_STUB ISpRecoContext_SetVoice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoContext_GetVoice_Proxy( 
    ISpRecoContext * This,
    /* [out] */ ISpVoice **ppVoice);


void __RPC_STUB ISpRecoContext_GetVoice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoContext_SetVoicePurgeEvent_Proxy( 
    ISpRecoContext * This,
    /* [in] */ ULONGLONG ullEventInterest);


void __RPC_STUB ISpRecoContext_SetVoicePurgeEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoContext_GetVoicePurgeEvent_Proxy( 
    ISpRecoContext * This,
    /* [out] */ ULONGLONG *pullEventInterest);


void __RPC_STUB ISpRecoContext_GetVoicePurgeEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoContext_SetContextState_Proxy( 
    ISpRecoContext * This,
    /* [in] */ SPCONTEXTSTATE eContextState);


void __RPC_STUB ISpRecoContext_SetContextState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecoContext_GetContextState_Proxy( 
    ISpRecoContext * This,
    /* [in] */ SPCONTEXTSTATE *peContextState);


void __RPC_STUB ISpRecoContext_GetContextState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpRecoContext_INTERFACE_DEFINED__ */


#ifndef __ISpProperties_INTERFACE_DEFINED__
#define __ISpProperties_INTERFACE_DEFINED__

/* interface ISpProperties */
/* [restricted][local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISpProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5B4FB971-B115-4DE1-AD97-E482E3BF6EE4")
    ISpProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPropertyNum( 
            /* [in] */ const WCHAR *pName,
            /* [in] */ LONG lValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyNum( 
            /* [in] */ const WCHAR *pName,
            /* [out] */ LONG *plValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPropertyString( 
            /* [in] */ const WCHAR *pName,
            /* [in] */ const WCHAR *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyString( 
            /* [in] */ const WCHAR *pName,
            /* [out] */ WCHAR **ppCoMemValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpProperties * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPropertyNum )( 
            ISpProperties * This,
            /* [in] */ const WCHAR *pName,
            /* [in] */ LONG lValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyNum )( 
            ISpProperties * This,
            /* [in] */ const WCHAR *pName,
            /* [out] */ LONG *plValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetPropertyString )( 
            ISpProperties * This,
            /* [in] */ const WCHAR *pName,
            /* [in] */ const WCHAR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyString )( 
            ISpProperties * This,
            /* [in] */ const WCHAR *pName,
            /* [out] */ WCHAR **ppCoMemValue);
        
        END_INTERFACE
    } ISpPropertiesVtbl;

    interface ISpProperties
    {
        CONST_VTBL struct ISpPropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpProperties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpProperties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpProperties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpProperties_SetPropertyNum(This,pName,lValue)	\
    (This)->lpVtbl -> SetPropertyNum(This,pName,lValue)

#define ISpProperties_GetPropertyNum(This,pName,plValue)	\
    (This)->lpVtbl -> GetPropertyNum(This,pName,plValue)

#define ISpProperties_SetPropertyString(This,pName,pValue)	\
    (This)->lpVtbl -> SetPropertyString(This,pName,pValue)

#define ISpProperties_GetPropertyString(This,pName,ppCoMemValue)	\
    (This)->lpVtbl -> GetPropertyString(This,pName,ppCoMemValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpProperties_SetPropertyNum_Proxy( 
    ISpProperties * This,
    /* [in] */ const WCHAR *pName,
    /* [in] */ LONG lValue);


void __RPC_STUB ISpProperties_SetPropertyNum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpProperties_GetPropertyNum_Proxy( 
    ISpProperties * This,
    /* [in] */ const WCHAR *pName,
    /* [out] */ LONG *plValue);


void __RPC_STUB ISpProperties_GetPropertyNum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpProperties_SetPropertyString_Proxy( 
    ISpProperties * This,
    /* [in] */ const WCHAR *pName,
    /* [in] */ const WCHAR *pValue);


void __RPC_STUB ISpProperties_SetPropertyString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpProperties_GetPropertyString_Proxy( 
    ISpProperties * This,
    /* [in] */ const WCHAR *pName,
    /* [out] */ WCHAR **ppCoMemValue);


void __RPC_STUB ISpProperties_GetPropertyString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpProperties_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sapi_0275 */
/* [local] */ 

#define	SP_MAX_LANGIDS	( 20 )

typedef /* [restricted] */ struct SPRECOGNIZERSTATUS
    {
    SPAUDIOSTATUS AudioStatus;
    ULONGLONG ullRecognitionStreamPos;
    ULONG ulStreamNumber;
    ULONG ulNumActive;
    CLSID clsidEngine;
    ULONG cLangIDs;
    WORD aLangID[ 20 ];
    DWORD dwReserved1;
    DWORD dwReserved2;
    } 	SPRECOGNIZERSTATUS;

typedef 
enum SPWAVEFORMATTYPE
    {	SPWF_INPUT	= 0,
	SPWF_SRENGINE	= SPWF_INPUT + 1
    } 	SPSTREAMFORMATTYPE;

typedef 
enum SPRECOSTATE
    {	SPRST_INACTIVE	= 0,
	SPRST_ACTIVE	= SPRST_INACTIVE + 1,
	SPRST_ACTIVE_ALWAYS	= SPRST_ACTIVE + 1,
	SPRST_INACTIVE_WITH_PURGE	= SPRST_ACTIVE_ALWAYS + 1,
	SPRST_NUM_STATES	= SPRST_INACTIVE_WITH_PURGE + 1
    } 	SPRECOSTATE;



extern RPC_IF_HANDLE __MIDL_itf_sapi_0275_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sapi_0275_v0_0_s_ifspec;

#ifndef __ISpRecognizer_INTERFACE_DEFINED__
#define __ISpRecognizer_INTERFACE_DEFINED__

/* interface ISpRecognizer */
/* [restricted][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISpRecognizer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C2B5F241-DAA0-4507-9E16-5A1EAA2B7A5C")
    ISpRecognizer : public ISpProperties
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetRecognizer( 
            /* [in] */ ISpObjectToken *pRecognizer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecognizer( 
            /* [out] */ ISpObjectToken **ppRecognizer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInput( 
            /* [in] */ IUnknown *pUnkInput,
            /* [in] */ BOOL fAllowFormatChanges) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputObjectToken( 
            /* [out] */ ISpObjectToken **ppToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputStream( 
            /* [out] */ ISpStreamFormat **ppStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRecoContext( 
            /* [out] */ ISpRecoContext **ppNewCtxt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecoProfile( 
            /* [out] */ ISpObjectToken **ppToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRecoProfile( 
            /* [in] */ ISpObjectToken *pToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSharedInstance( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecoState( 
            /* [out] */ SPRECOSTATE *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRecoState( 
            /* [in] */ SPRECOSTATE NewState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ SPRECOGNIZERSTATUS *pStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFormat( 
            /* [in] */ SPSTREAMFORMATTYPE WaveFormatType,
            /* [out] */ GUID *pFormatId,
            /* [out] */ WAVEFORMATEX **ppCoMemWFEX) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE IsUISupported( 
            /* [in] */ const WCHAR *pszTypeOfUI,
            /* [in] */ void *pvExtraData,
            /* [in] */ ULONG cbExtraData,
            /* [out] */ BOOL *pfSupported) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DisplayUI( 
            /* [in] */ HWND hwndParent,
            /* [in] */ const WCHAR *pszTitle,
            /* [in] */ const WCHAR *pszTypeOfUI,
            /* [in] */ void *pvExtraData,
            /* [in] */ ULONG cbExtraData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EmulateRecognition( 
            /* [in] */ ISpPhrase *pPhrase) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpRecognizerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISpRecognizer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISpRecognizer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISpRecognizer * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPropertyNum )( 
            ISpRecognizer * This,
            /* [in] */ const WCHAR *pName,
            /* [in] */ LONG lValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyNum )( 
            ISpRecognizer * This,
            /* [in] */ const WCHAR *pName,
            /* [out] */ LONG *plValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetPropertyString )( 
            ISpRecognizer * This,
            /* [in] */ const WCHAR *pName,
            /* [in] */ const WCHAR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyString )( 
            ISpRecognizer * This,
            /* [in] */ const WCHAR *pName,
            /* [out] */ WCHAR **ppCoMemValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetRecognizer )( 
            ISpRecognizer * This,
            /* [in] */ ISpObjectToken *pRecognizer);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecognizer )( 
            ISpRecognizer * This,
            /* [out] */ ISpObjectToken **ppRecognizer);
        
        HRESULT ( STDMETHODCALLTYPE *SetInput )( 
            ISpRecognizer * This,
            /* [in] */ IUnknown *pUnkInput,
            /* [in] */ BOOL fAllowFormatChanges);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputObjectToken )( 
            ISpRecognizer * This,
            /* [out] */ ISpObjectToken **ppToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputStream )( 
            ISpRecognizer * This,
            /* [out] */ ISpStreamFormat **ppStream);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRecoContext )( 
            ISpRecognizer * This,
            /* [out] */ ISpRecoContext **ppNewCtxt);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecoProfile )( 
            ISpRecognizer * This,
            /* [out] */ ISpObjectToken **ppToken);
        
        HRESULT ( STDMETHODCALLTYPE *SetRecoProfile )( 
            ISpRecognizer * This,
            /* [in] */ ISpObjectToken *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *IsSharedInstance )( 
            ISpRecognizer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecoState )( 
            ISpRecognizer * This,
            /* [out] */ SPRECOSTATE *pState);
        
        HRESULT ( STDMETHODCALLTYPE *SetRecoState )( 
            ISpRecognizer * This,
            /* [in] */ SPRECOSTATE NewState);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            ISpRecognizer * This,
            /* [out] */ SPRECOGNIZERSTATUS *pStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormat )( 
            ISpRecognizer * This,
            /* [in] */ SPSTREAMFORMATTYPE WaveFormatType,
            /* [out] */ GUID *pFormatId,
            /* [out] */ WAVEFORMATEX **ppCoMemWFEX);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *IsUISupported )( 
            ISpRecognizer * This,
            /* [in] */ const WCHAR *pszTypeOfUI,
            /* [in] */ void *pvExtraData,
            /* [in] */ ULONG cbExtraData,
            /* [out] */ BOOL *pfSupported);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *DisplayUI )( 
            ISpRecognizer * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ const WCHAR *pszTitle,
            /* [in] */ const WCHAR *pszTypeOfUI,
            /* [in] */ void *pvExtraData,
            /* [in] */ ULONG cbExtraData);
        
        HRESULT ( STDMETHODCALLTYPE *EmulateRecognition )( 
            ISpRecognizer * This,
            /* [in] */ ISpPhrase *pPhrase);
        
        END_INTERFACE
    } ISpRecognizerVtbl;

    interface ISpRecognizer
    {
        CONST_VTBL struct ISpRecognizerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpRecognizer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpRecognizer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpRecognizer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpRecognizer_SetPropertyNum(This,pName,lValue)	\
    (This)->lpVtbl -> SetPropertyNum(This,pName,lValue)

#define ISpRecognizer_GetPropertyNum(This,pName,plValue)	\
    (This)->lpVtbl -> GetPropertyNum(This,pName,plValue)

#define ISpRecognizer_SetPropertyString(This,pName,pValue)	\
    (This)->lpVtbl -> SetPropertyString(This,pName,pValue)

#define ISpRecognizer_GetPropertyString(This,pName,ppCoMemValue)	\
    (This)->lpVtbl -> GetPropertyString(This,pName,ppCoMemValue)


#define ISpRecognizer_SetRecognizer(This,pRecognizer)	\
    (This)->lpVtbl -> SetRecognizer(This,pRecognizer)

#define ISpRecognizer_GetRecognizer(This,ppRecognizer)	\
    (This)->lpVtbl -> GetRecognizer(This,ppRecognizer)

#define ISpRecognizer_SetInput(This,pUnkInput,fAllowFormatChanges)	\
    (This)->lpVtbl -> SetInput(This,pUnkInput,fAllowFormatChanges)

#define ISpRecognizer_GetInputObjectToken(This,ppToken)	\
    (This)->lpVtbl -> GetInputObjectToken(This,ppToken)

#define ISpRecognizer_GetInputStream(This,ppStream)	\
    (This)->lpVtbl -> GetInputStream(This,ppStream)

#define ISpRecognizer_CreateRecoContext(This,ppNewCtxt)	\
    (This)->lpVtbl -> CreateRecoContext(This,ppNewCtxt)

#define ISpRecognizer_GetRecoProfile(This,ppToken)	\
    (This)->lpVtbl -> GetRecoProfile(This,ppToken)

#define ISpRecognizer_SetRecoProfile(This,pToken)	\
    (This)->lpVtbl -> SetRecoProfile(This,pToken)

#define ISpRecognizer_IsSharedInstance(This)	\
    (This)->lpVtbl -> IsSharedInstance(This)

#define ISpRecognizer_GetRecoState(This,pState)	\
    (This)->lpVtbl -> GetRecoState(This,pState)

#define ISpRecognizer_SetRecoState(This,NewState)	\
    (This)->lpVtbl -> SetRecoState(This,NewState)

#define ISpRecognizer_GetStatus(This,pStatus)	\
    (This)->lpVtbl -> GetStatus(This,pStatus)

#define ISpRecognizer_GetFormat(This,WaveFormatType,pFormatId,ppCoMemWFEX)	\
    (This)->lpVtbl -> GetFormat(This,WaveFormatType,pFormatId,ppCoMemWFEX)

#define ISpRecognizer_IsUISupported(This,pszTypeOfUI,pvExtraData,cbExtraData,pfSupported)	\
    (This)->lpVtbl -> IsUISupported(This,pszTypeOfUI,pvExtraData,cbExtraData,pfSupported)

#define ISpRecognizer_DisplayUI(This,hwndParent,pszTitle,pszTypeOfUI,pvExtraData,cbExtraData)	\
    (This)->lpVtbl -> DisplayUI(This,hwndParent,pszTitle,pszTypeOfUI,pvExtraData,cbExtraData)

#define ISpRecognizer_EmulateRecognition(This,pPhrase)	\
    (This)->lpVtbl -> EmulateRecognition(This,pPhrase)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpRecognizer_SetRecognizer_Proxy( 
    ISpRecognizer * This,
    /* [in] */ ISpObjectToken *pRecognizer);


void __RPC_STUB ISpRecognizer_SetRecognizer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecognizer_GetRecognizer_Proxy( 
    ISpRecognizer * This,
    /* [out] */ ISpObjectToken **ppRecognizer);


void __RPC_STUB ISpRecognizer_GetRecognizer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecognizer_SetInput_Proxy( 
    ISpRecognizer * This,
    /* [in] */ IUnknown *pUnkInput,
    /* [in] */ BOOL fAllowFormatChanges);


void __RPC_STUB ISpRecognizer_SetInput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecognizer_GetInputObjectToken_Proxy( 
    ISpRecognizer * This,
    /* [out] */ ISpObjectToken **ppToken);


void __RPC_STUB ISpRecognizer_GetInputObjectToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecognizer_GetInputStream_Proxy( 
    ISpRecognizer * This,
    /* [out] */ ISpStreamFormat **ppStream);


void __RPC_STUB ISpRecognizer_GetInputStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecognizer_CreateRecoContext_Proxy( 
    ISpRecognizer * This,
    /* [out] */ ISpRecoContext **ppNewCtxt);


void __RPC_STUB ISpRecognizer_CreateRecoContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecognizer_GetRecoProfile_Proxy( 
    ISpRecognizer * This,
    /* [out] */ ISpObjectToken **ppToken);


void __RPC_STUB ISpRecognizer_GetRecoProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecognizer_SetRecoProfile_Proxy( 
    ISpRecognizer * This,
    /* [in] */ ISpObjectToken *pToken);


void __RPC_STUB ISpRecognizer_SetRecoProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecognizer_IsSharedInstance_Proxy( 
    ISpRecognizer * This);


void __RPC_STUB ISpRecognizer_IsSharedInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecognizer_GetRecoState_Proxy( 
    ISpRecognizer * This,
    /* [out] */ SPRECOSTATE *pState);


void __RPC_STUB ISpRecognizer_GetRecoState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecognizer_SetRecoState_Proxy( 
    ISpRecognizer * This,
    /* [in] */ SPRECOSTATE NewState);


void __RPC_STUB ISpRecognizer_SetRecoState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecognizer_GetStatus_Proxy( 
    ISpRecognizer * This,
    /* [out] */ SPRECOGNIZERSTATUS *pStatus);


void __RPC_STUB ISpRecognizer_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecognizer_GetFormat_Proxy( 
    ISpRecognizer * This,
    /* [in] */ SPSTREAMFORMATTYPE WaveFormatType,
    /* [out] */ GUID *pFormatId,
    /* [out] */ WAVEFORMATEX **ppCoMemWFEX);


void __RPC_STUB ISpRecognizer_GetFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE ISpRecognizer_IsUISupported_Proxy( 
    ISpRecognizer * This,
    /* [in] */ const WCHAR *pszTypeOfUI,
    /* [in] */ void *pvExtraData,
    /* [in] */ ULONG cbExtraData,
    /* [out] */ BOOL *pfSupported);


void __RPC_STUB ISpRecognizer_IsUISupported_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE ISpRecognizer_DisplayUI_Proxy( 
    ISpRecognizer * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ const WCHAR *pszTitle,
    /* [in] */ const WCHAR *pszTypeOfUI,
    /* [in] */ void *pvExtraData,
    /* [in] */ ULONG cbExtraData);


void __RPC_STUB ISpRecognizer_DisplayUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecognizer_EmulateRecognition_Proxy( 
    ISpRecognizer * This,
    /* [in] */ ISpPhrase *pPhrase);


void __RPC_STUB ISpRecognizer_EmulateRecognition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpRecognizer_INTERFACE_DEFINED__ */



#ifndef __SpeechLib_LIBRARY_DEFINED__
#define __SpeechLib_LIBRARY_DEFINED__

/* library SpeechLib */
/* [version][uuid][helpstring] */ 


EXTERN_C const IID LIBID_SpeechLib;

EXTERN_C const CLSID CLSID_SpNotifyTranslator;

#ifdef __cplusplus

class DECLSPEC_UUID("E2AE5372-5D40-11D2-960E-00C04F8EE628")
SpNotifyTranslator;
#endif

EXTERN_C const CLSID CLSID_SpObjectTokenCategory;

#ifdef __cplusplus

class DECLSPEC_UUID("A910187F-0C7A-45AC-92CC-59EDAFB77B53")
SpObjectTokenCategory;
#endif

EXTERN_C const CLSID CLSID_SpObjectToken;

#ifdef __cplusplus

class DECLSPEC_UUID("EF411752-3736-4CB4-9C8C-8EF4CCB58EFE")
SpObjectToken;
#endif

EXTERN_C const CLSID CLSID_SpResourceManager;

#ifdef __cplusplus

class DECLSPEC_UUID("96749373-3391-11D2-9EE3-00C04F797396")
SpResourceManager;
#endif

EXTERN_C const CLSID CLSID_SpStreamFormatConverter;

#ifdef __cplusplus

class DECLSPEC_UUID("7013943A-E2EC-11D2-A086-00C04F8EF9B5")
SpStreamFormatConverter;
#endif

EXTERN_C const CLSID CLSID_SpMMAudioEnum;

#ifdef __cplusplus

class DECLSPEC_UUID("AB1890A0-E91F-11D2-BB91-00C04F8EE6C0")
SpMMAudioEnum;
#endif

EXTERN_C const CLSID CLSID_SpMMAudioIn;

#ifdef __cplusplus

class DECLSPEC_UUID("CF3D2E50-53F2-11D2-960C-00C04F8EE628")
SpMMAudioIn;
#endif

EXTERN_C const CLSID CLSID_SpMMAudioOut;

#ifdef __cplusplus

class DECLSPEC_UUID("A8C680EB-3D32-11D2-9EE7-00C04F797396")
SpMMAudioOut;
#endif

EXTERN_C const CLSID CLSID_SpRecPlayAudio;

#ifdef __cplusplus

class DECLSPEC_UUID("FEE225FC-7AFD-45E9-95D0-5A318079D911")
SpRecPlayAudio;
#endif

EXTERN_C const CLSID CLSID_SpStream;

#ifdef __cplusplus

class DECLSPEC_UUID("715D9C59-4442-11D2-9605-00C04F8EE628")
SpStream;
#endif

EXTERN_C const CLSID CLSID_SpVoice;

#ifdef __cplusplus

class DECLSPEC_UUID("96749377-3391-11D2-9EE3-00C04F797396")
SpVoice;
#endif

EXTERN_C const CLSID CLSID_SpSharedRecoContext;

#ifdef __cplusplus

class DECLSPEC_UUID("47206204-5ECA-11D2-960F-00C04F8EE628")
SpSharedRecoContext;
#endif

EXTERN_C const CLSID CLSID_SpInprocRecognizer;

#ifdef __cplusplus

class DECLSPEC_UUID("41B89B6B-9399-11D2-9623-00C04F8EE628")
SpInprocRecognizer;
#endif

EXTERN_C const CLSID CLSID_SpSharedRecognizer;

#ifdef __cplusplus

class DECLSPEC_UUID("3BEE4890-4FE9-4A37-8C1E-5E7E12791C1F")
SpSharedRecognizer;
#endif

EXTERN_C const CLSID CLSID_SpLexicon;

#ifdef __cplusplus

class DECLSPEC_UUID("0655E396-25D0-11D3-9C26-00C04F8EF87C")
SpLexicon;
#endif

EXTERN_C const CLSID CLSID_SpUnCompressedLexicon;

#ifdef __cplusplus

class DECLSPEC_UUID("C9E37C15-DF92-4727-85D6-72E5EEB6995A")
SpUnCompressedLexicon;
#endif

EXTERN_C const CLSID CLSID_SpCompressedLexicon;

#ifdef __cplusplus

class DECLSPEC_UUID("90903716-2F42-11D3-9C26-00C04F8EF87C")
SpCompressedLexicon;
#endif

EXTERN_C const CLSID CLSID_SpPhoneConverter;

#ifdef __cplusplus

class DECLSPEC_UUID("9185F743-1143-4C28-86B5-BFF14F20E5C8")
SpPhoneConverter;
#endif

EXTERN_C const CLSID CLSID_SpNullPhoneConverter;

#ifdef __cplusplus

class DECLSPEC_UUID("455F24E9-7396-4A16-9715-7C0FDBE3EFE3")
SpNullPhoneConverter;
#endif
#endif /* __SpeechLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\tlapi.h ===
//
// tlapi.h
//

#ifndef TLAPI_H
#define TLAPI_H

BOOL TF_GetThreadFlags(DWORD dwThreadId, DWORD *pdwFlags, DWORD *pdwProcessId, DWORD *pdwTickTime);

#define TLF_TIMACTIVE                             0x00000001
#define TLF_16BITTASK                             0x00000002
#define TLF_16BITTASKCHECKED                      0x00000004
#define TLF_NTCONSOLE                             0x00000008
#define TLF_LBIMGR                                0x00000010
#define TLF_INSFW                                 0x00000020
#define TLF_TFPRIV_UPDATE_REG_IMX_IN_QUEUE        0x00000040
#define TLF_TFPRIV_SYSCOLORCHANGED_IN_QUEUE       0x00000080
#define TLF_TFPRIV_UPDATE_REG_KBDTOGGLE_IN_QUEUE  0x00000100
#define TLF_NOWAITFORINPUTIDLEONWIN9X             0x00000200
#define TLF_GCOMPACTIVE                           0x00000400
#define TLF_CTFMONPROCESS                         0x00000800

BOOL TF_IsInMarshaling(DWORD dwThreadId);

#endif // TLAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\timsink.h ===
//
// timsink.h
//

#ifndef TIMSINK_H
#define TIMSINK_H

#include "private.h"

typedef HRESULT (*DIMCALLBACK)(UINT uCode, ITfDocumentMgr *dim, ITfDocumentMgr *dimPrev, void *pv);
typedef HRESULT (*ICCALLBACK)(UINT uCode, ITfContext *pic, void *pv);

#define TIM_CODE_INITDIM       0
#define TIM_CODE_UNINITDIM     1
#define TIM_CODE_SETFOCUS      2
#define TIM_CODE_INITIC        3
#define TIM_CODE_UNINITIC      4

class CThreadMgrEventSink : public ITfThreadMgrEventSink
{
public:
    CThreadMgrEventSink(DIMCALLBACK pfnDIMCallback, ICCALLBACK pfnICCallback, void *pv);
    ~CThreadMgrEventSink();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfThreadMgrEventSink
    //
    STDMETHODIMP OnInitDocumentMgr(ITfDocumentMgr *dim);
    STDMETHODIMP OnUninitDocumentMgr(ITfDocumentMgr *dim);
    STDMETHODIMP OnSetFocus(ITfDocumentMgr *dimFocus, ITfDocumentMgr *dimPrevFocus);
    STDMETHODIMP OnPushContext(ITfContext *pic);
    STDMETHODIMP OnPopContext(ITfContext *pic);

    HRESULT _Advise(ITfThreadMgr *tim);
    HRESULT _Unadvise();
    HRESULT _InitDIMs(BOOL fInit);

protected:
    void SetCallbackPV(void* pv)
    {
        if (_pv == NULL)
            _pv = pv;
    };

private:
    ITfThreadMgr *_tim;
    DWORD _dwCookie;
    DIMCALLBACK _pfnDIMCallback;
    ICCALLBACK _pfnICCallback;
    TfClientId _tid;
    void *_pv;
    int _cRef;
};

#endif // TIMSINK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\tes.h ===
//
// tes.h
//
// Generic ITfTextEventSink object
//

#ifndef TES_H
#define TES_H

#include "private.h"

#define TES_INVALID_COOKIE  ((DWORD)(-1))

#define ICF_TEXTDELTA           1
#define ICF_LAYOUTDELTA         2
#define ICF_LAYOUTDELTA_CREATE  3
#define ICF_LAYOUTDELTA_DESTROY 4

typedef struct
{
    TfEditCookie ecReadOnly;
    ITfEditRecord *pEditRecord;
    ITfContext *pic;
} TESENDEDIT;

typedef HRESULT (*TESCALLBACK)(UINT uCode, void *pv, void *pvData);

class CTextEventSink : public ITfTextEditSink,
                       public ITfTextLayoutSink
{
public:
    CTextEventSink(TESCALLBACK pfnCallback, void *pv);
    virtual ~CTextEventSink() {};

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfTextEventSink
    //
    STDMETHODIMP OnEndEdit(ITfContext *pic, TfEditCookie ecReadOnly, ITfEditRecord *pEditRecord);

    STDMETHODIMP OnLayoutChange(ITfContext *pic, TfLayoutCode lcode, ITfContextView *pView);

    HRESULT _Advise(ITfContext *pic, DWORD dwFlags);
    HRESULT _Unadvise();

protected:
    void SetCallbackPV(void* pv)
    {
        if (_pv == NULL)
            _pv = pv;
    };

private:

    long _cRef;
    ITfContext *_pic;
    DWORD _dwEditCookie;
    DWORD _dwLayoutCookie;
    DWORD _dwFlags;
    TESCALLBACK _pfnCallback;
    void *_pv;
};

#endif // TES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\template.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    template.h

Abstract:

    This file defines the Template Class.

Author:

Revision History:

Notes:

--*/

#ifndef _TEMPLATE_H_
#define _TEMPLATE_H_

/////////////////////////////////////////////////////////////////////////////
// Basic types

// abstract iteration position
struct __POSITION { };
typedef __POSITION* POSITION;

const POSITION BEFORE_START_POSITION = (POSITION)-1;


/////////////////////////////////////////////////////////////////////////////
// global helpers (can be overridden)

#undef new
inline void *  __cdecl operator new(size_t, void *_P)
{
    return (_P);
}

template<class TYPE>
void
ConstructElements(
    TYPE* pElements,
    INT_PTR nCount
    )
{
    ASSERT(nCount);

    // first do bit-wise zero initialization
    memset((void*)pElements, 0, (size_t)nCount * sizeof(TYPE));

    // then call the constructor(s)
    for (; nCount--; pElements++)
        ::new((void*)pElements) TYPE;
}

#undef new
// retore mem.h trick
#ifdef DEBUG
#define new new(TEXT(__FILE__), __LINE__)
#endif // DEBUG

template<class TYPE>
void
DestructElements(
    TYPE* pElements,
    INT_PTR nCount
    )
{
    ASSERT(nCount);

    // call the destructor(s)
    for (; nCount--; pElements++)
        pElements->~TYPE();
}


template<class TYPE, class ARG_TYPE>
BOOL
CompareElements(
    const TYPE* pElement1,
    const ARG_TYPE* pElement2
    )
{
    return *pElement1 == *pElement2;
}


template<class ARG_KEY>
UINT
HashKey(
    ARG_KEY key
    )
{
    // default identity hash - works for most primitive values
    return ((UINT)(ULONG_PTR)key) >> 4;
}


struct CPlex        // warning variable length structure
{
    CPlex* pNext;

    // BYTE data[maxNum*elementSize];

    void* data() { return this+1; }

    static CPlex* PASCAL Create(CPlex*& head, UINT nMax, UINT cbElement);
                    // like 'calloc' but no zero fill
                    // may throw memory exceptions

    void FreeDataChain();        // free this one and links
};



/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CMap
{
public:
    CMap(int nBlockSize = default_block_size);
    ~CMap();

    INT_PTR GetCount() const;

    BOOL Lookup(ARG_KEY key, VALUE& rValue) const;

    VALUE& operator[](ARG_KEY key);

    void SetAt(ARG_KEY key, ARG_VALUE newValue);

    BOOL RemoveKey(ARG_KEY key);
    void RemoveAll();

    POSITION GetStartPosition() const;
    void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const;

    void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

private:
    // Association
    struct CAssoc {
        CAssoc* pNext;
        UINT nHashValue;    // needed for efficient iteration
        KEY key;
        VALUE value;
    };

    static const int default_block_size = 10;

private:
    CAssoc* NewAssoc();
    void    FreeAssoc(CAssoc*);
    CAssoc* GetAssocAt(ARG_KEY, UINT&) const;

private:
    CAssoc**      m_pHashTable;
    UINT          m_nHashTableSize;
    INT_PTR       m_nCount;
    CAssoc*       m_pFreeList;
    struct CPlex* m_pBlocks;
    int           m_nBlockSize;

};



template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
INT_PTR
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount(
    ) const
{
    return m_nCount;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(
    ARG_KEY key,
    ARG_VALUE newValue
    )
{
    (*this)[key] = newValue;
}


template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CMap(
    int nBlockSize
    )
{
    ASSERT(nBlockSize > 0);

    if (nBlockSize <= 0)
        nBlockSize = default_block_size;

    m_pHashTable     = NULL;
    m_nHashTableSize = 17;        // default size
    m_nCount         = 0;
    m_pFreeList      = NULL;
    m_pBlocks        = NULL;
    m_nBlockSize     = nBlockSize;
}


template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
    UINT nHashSize,
    BOOL bAllocNow
    )
{
    ASSERT(m_nCount == 0);
    ASSERT(nHashSize > 0);

    if (m_pHashTable != NULL) {
        // free hash table
        delete[] m_pHashTable;
        m_pHashTable = NULL;
    }

    if (bAllocNow) {
        m_pHashTable = new CAssoc* [nHashSize];
        if (! m_pHashTable)
            return;
        memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
    }

    m_nHashTableSize = nHashSize;
}


template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll(
    )
{
    if (m_pHashTable != NULL) {
        // destroy elements (values and keys)
        for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++) {
            CAssoc* pAssoc;
            for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext) {
                DestructElements<VALUE>(&pAssoc->value, 1);
                DestructElements<KEY>(&pAssoc->key, 1);
            }
        }
    }

    // free hash table
    delete[] m_pHashTable;
    m_pHashTable = NULL;

    m_nCount    = 0;
    m_pFreeList = NULL;

    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}


template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CMap(
    )
{
    RemoveAll();

    ASSERT(m_nCount == 0);
}


template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc(
    )
{
    if (m_pFreeList == NULL) {
        // add another block
        CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));
        // chain them into free list;
        CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
        // free in reverse order to make it easier to debug
        pAssoc += m_nBlockSize - 1;
        for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--) {
            pAssoc->pNext = m_pFreeList;
            m_pFreeList = pAssoc;
        }
    }
    ASSERT(m_pFreeList != NULL);    // we must have something

    CMap::CAssoc* pAssoc = m_pFreeList;
    m_pFreeList = m_pFreeList->pNext;

    m_nCount++;
    ASSERT(m_nCount > 0);        // make sure we don't overflow

    ConstructElements<KEY>(&pAssoc->key, 1);
    ConstructElements<VALUE>(&pAssoc->value, 1);        // special construct values

    return pAssoc;
}


template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(
    CMap::CAssoc* pAssoc
    )
{
    DestructElements<VALUE>(&pAssoc->value, 1);
    DestructElements<KEY>(&pAssoc->key, 1);

    pAssoc->pNext = m_pFreeList;
    m_pFreeList = pAssoc;
    m_nCount--;
    ASSERT(m_nCount >= 0);        // make sure we don't underflow

    // if no more elements, cleanup completely
    if (m_nCount == 0)
        RemoveAll();
}


template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(
    ARG_KEY key,
    UINT& nHash
    ) const
{
    nHash = HashKey<ARG_KEY>(key) % m_nHashTableSize;

    if (m_pHashTable == NULL)
        return NULL;

    // see if it exists
    CAssoc* pAssoc;
    for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext) {
        if (CompareElements(&pAssoc->key, &key))
            return pAssoc;
    }

    return NULL;
}


template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(
    ARG_KEY key,
    VALUE& rValue
    ) const
{
    UINT nHash;
    CAssoc* pAssoc = GetAssocAt(key, nHash);
    if (pAssoc == NULL)
        return FALSE;        // not in map

    rValue = pAssoc->value;
    return TRUE;
}


template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE&
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](
    ARG_KEY key
    )
{
    UINT nHash;
    CAssoc* pAssoc;
    if ((pAssoc = GetAssocAt(key, nHash)) == NULL) {
        if (m_pHashTable == NULL)
            InitHashTable(m_nHashTableSize);

        // it doesn't exist, add a new Association
        pAssoc = NewAssoc();
        pAssoc->nHashValue = nHash;
        pAssoc->key = key;
        // 'pAssoc->value' is a constructed object, nothing more

        // put into hash table
        pAssoc->pNext = m_pHashTable[nHash];
        m_pHashTable[nHash] = pAssoc;
    }
    return pAssoc->value;    // return new reference
}


template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveKey(
    ARG_KEY key
    )
{
    if (m_pHashTable == NULL)
        return FALSE;        // nothing in the table

    CAssoc** ppAssocPrev;
    ppAssocPrev = &m_pHashTable[HashKey<ARG_KEY>(key) % m_nHashTableSize];

    CAssoc* pAssoc;
    for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext) {
        if (CompareElements(&pAssoc->key, &key)) {
            // remove it
            *ppAssocPrev = pAssoc->pNext;        // remove from list
            FreeAssoc(pAssoc);
            return TRUE;
        }
        ppAssocPrev = &pAssoc->pNext;
    }

    return FALSE;        // not found
}


template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
POSITION
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition(
    ) const
{
    return (m_nCount == 0) ? NULL : BEFORE_START_POSITION;
}


template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetNextAssoc(
    POSITION& rNextPosition,
    KEY& rKey,
    VALUE& rValue
    ) const
{
    ASSERT(m_pHashTable != NULL);    // never call on empty map

    CAssoc* pAssocRet = (CAssoc*)rNextPosition;
    ASSERT(pAssocRet != NULL);

    if (pAssocRet == (CAssoc*) BEFORE_START_POSITION) {
        // find the first association
        for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
            if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
                break;
            ASSERT(pAssocRet != NULL);    // must find something
    }

    // find next association
    CAssoc* pAssocNext;
    if ((pAssocNext = pAssocRet->pNext) == NULL) {
        // go to next bucket
        for (UINT nBucket = pAssocRet->nHashValue + 1; nBucket < m_nHashTableSize; nBucket++)
            if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
                break;
    }

    rNextPosition = (POSITION) pAssocNext;

    // fill in return data
    rKey = pAssocRet->key;
    rValue = pAssocRet->value;
}




/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CArray
{
public:
    CArray();
    ~CArray();

    INT_PTR GetSize() const;
    BOOL SetSize(INT_PTR nNewSize, INT_PTR nGrowBy = -1);

    void RemoveAll();

    TYPE GetAt(INT_PTR nIndex) const;
    void SetAt(INT_PTR nIndex, ARG_TYPE newElement);

    const TYPE* GetData() const;
    TYPE* GetData();

    void SetAtGrow(INT_PTR nIndex, ARG_TYPE newElement);
    INT_PTR Add(ARG_TYPE newElement);

    void RemoveAt(int nIndex, int nCount = 1);

private:
    TYPE*   m_pData;        // the actual array of data
    INT_PTR m_nSize;        // # of elements (upperBound - 1)
    INT_PTR m_nMaxSize;     // max allocated
    INT_PTR m_nGrowBy;      // grow amount
};

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::CArray(
    )
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::~CArray(
    )
{
    if (m_pData != NULL) {
        DestructElements<TYPE>(m_pData, m_nSize);
        delete[] (BYTE*)m_pData;
    }
}

template<class TYPE, class ARG_TYPE>
INT_PTR
CArray<TYPE, ARG_TYPE>::GetSize(
    ) const
{
    return m_nSize;
}

template<class TYPE, class ARG_TYPE>
BOOL
CArray<TYPE, ARG_TYPE>::SetSize(
    INT_PTR nNewSize,
    INT_PTR nGrowBy
    )
{
    if (nNewSize < 0)
        return FALSE;

    if ((nGrowBy == 0) || (nGrowBy < -1))
        return FALSE;

    if (nGrowBy != -1)
        m_nGrowBy = nGrowBy;    // set new size

    if (nNewSize == 0) {
        // shrink to nothing
        if (m_pData != NULL) {
            DestructElements<TYPE>(m_pData, m_nSize);
            delete[] (BYTE*)m_pData;
            m_pData = NULL;
        }
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL) {
        // create one with exact size
        m_pData = (TYPE*) new BYTE[(size_t)nNewSize * sizeof(TYPE)];
        if (! m_pData)
            return FALSE;
        ConstructElements<TYPE>(m_pData, nNewSize);
        m_nSize = m_nMaxSize = nNewSize;
    }
    else if (nNewSize <= m_nMaxSize) {
        // it fits
        if (nNewSize > m_nSize) {
            // initialize the new elements
            ConstructElements<TYPE>(&m_pData[m_nSize], nNewSize-m_nSize);
        }
        else if (m_nSize > nNewSize) {
            // destroy the old elements
            DestructElements<TYPE>(&m_pData[nNewSize], m_nSize-nNewSize);
        }
        m_nSize = nNewSize;
    }
    else {
        // otherwise, grow array
        INT_PTR nTempGrowBy = m_nGrowBy;
        if (nTempGrowBy == 0) {
            // heuristically determine growth when nTempGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nTempGrowBy = m_nSize / 8;
            nTempGrowBy = (nTempGrowBy < 4) ? 4 : ((nTempGrowBy > 1024) ? 1024 : nTempGrowBy);
        }
        INT_PTR nNewMax;
        if (nNewSize < m_nMaxSize + nTempGrowBy)
            nNewMax = m_nMaxSize + nTempGrowBy;    // granularity
        else
            nNewMax = nNewSize;                // no slush

        ASSERT(nNewMax >= m_nMaxSize);         // no wrap around

        TYPE* pNewData = (TYPE*) new BYTE[(size_t)nNewMax * sizeof(TYPE)];
        if (! pNewData)
            return FALSE;

        // copy new data from old
        memcpy(pNewData, m_pData, (size_t)m_nSize * sizeof(TYPE));

        // construct remaining elements
        ASSERT(nNewSize > m_nSize);
        ConstructElements<TYPE>(&pNewData[m_nSize], nNewSize-m_nSize);

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }

    return TRUE;
}


template<class TYPE, class ARG_TYPE>
void
CArray<TYPE, ARG_TYPE>::RemoveAll(
    )
{
    SetSize(0);
}

template<class TYPE, class ARG_TYPE>
TYPE
CArray<TYPE, ARG_TYPE>::GetAt(
    INT_PTR nIndex
    ) const
{
    ASSERT(nIndex >= 0 && nIndex < m_nSize);
    return m_pData[nIndex];
}

template<class TYPE, class ARG_TYPE>
void
CArray<TYPE, ARG_TYPE>::SetAt(
    INT_PTR nIndex,
    ARG_TYPE newElement
    )
{
    ASSERT(nIndex >= 0 && nIndex < m_nSize);
    m_pData[nIndex] = newElement;
}

template<class TYPE, class ARG_TYPE>
const TYPE*
CArray<TYPE, ARG_TYPE>::GetData(
    ) const
{
    return (const TYPE*)m_pData;
}

template<class TYPE, class ARG_TYPE>
TYPE*
CArray<TYPE, ARG_TYPE>::GetData(
    )
{
    return (TYPE*)m_pData;
}

template<class TYPE, class ARG_TYPE>
void
CArray<TYPE, ARG_TYPE>::SetAtGrow(
    INT_PTR nIndex,
    ARG_TYPE newElement
    )
{
    ASSERT(nIndex >= 0);

    if (nIndex >= m_nSize)
        if (! SetSize(nIndex+1))
            return;

    m_pData[nIndex] = newElement;
}

template<class TYPE, class ARG_TYPE>
INT_PTR
CArray<TYPE, ARG_TYPE>::Add(
    ARG_TYPE newElement
    )
{
    INT_PTR nIndex = m_nSize;
    SetAtGrow(nIndex, newElement);
    return nIndex;
}

template<class TYPE, class ARG_TYPE>
void
CArray<TYPE, ARG_TYPE>::RemoveAt(
    int nIndex,
    int nCount
    )
{
    // just remove a range
    INT_PTR nMoveCount = m_nSize - (nIndex + nCount);
    DestructElements<TYPE>(&m_pData[nIndex], nCount);
    if (nMoveCount)
        memmove(&m_pData[nIndex], &m_pData[nIndex + nCount],
                nMoveCount * sizeof(TYPE));
    m_nSize -= nCount;
}



/////////////////////////////////////////////////////////////////////////////
// CFirstInFirstOut<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CFirstInFirstOut
{
public:
    CFirstInFirstOut();
    ~CFirstInFirstOut();

    INT_PTR GetSize() const;
    BOOL GetData(TYPE& data);
    VOID SetData(TYPE& data);

    void GrowBuffer(INT_PTR nGrowBy = 3);

private:
    TYPE*   m_pData;        // the actual ring buffer of data
    INT_PTR m_nMaxSize;     // max allocated

    INT_PTR m_In;           // Index of First In of ring buffer
    INT_PTR m_Out;          // Index of First Out of ring buffer
};

template<class TYPE, class ARG_TYPE>
CFirstInFirstOut<TYPE, ARG_TYPE>::CFirstInFirstOut(
    )
{
    m_pData = NULL;
    m_In = m_Out = 0;
    m_nMaxSize = 0;
}

template<class TYPE, class ARG_TYPE>
CFirstInFirstOut<TYPE, ARG_TYPE>::~CFirstInFirstOut(
    )
{
    if (m_pData != NULL) {
        DestructElements<TYPE>(m_pData, m_nMaxSize);
        delete[] (BYTE*)m_pData;
    }
}

template<class TYPE, class ARG_TYPE>
INT_PTR
CFirstInFirstOut<TYPE, ARG_TYPE>::GetSize(
    ) const
{
    if (m_Out == m_In) {
        return 0;            // no more data
    }
    else if (m_In > m_Out) {
        return (m_In - m_Out);
    }
    else {
        return (m_nMaxSize - m_Out) + m_In;
    }
}

template<class TYPE, class ARG_TYPE>
BOOL
CFirstInFirstOut<TYPE, ARG_TYPE>::GetData(
    TYPE& data
    )
{
    if (m_Out == m_In) {
        return FALSE;        // no more data
    }

    data = m_pData[m_Out++];

    if (m_Out == m_nMaxSize)
        m_Out = 0;

    return TRUE;
}

template<class TYPE, class ARG_TYPE>
VOID
CFirstInFirstOut<TYPE, ARG_TYPE>::SetData(
    TYPE& data
    )
{
    if (m_nMaxSize == 0 || GetSize() >= m_nMaxSize - 1)
        GrowBuffer();

    m_pData[m_In++] = data;

    if (m_In == m_nMaxSize)
        m_In = 0;
}

template<class TYPE, class ARG_TYPE>
void
CFirstInFirstOut<TYPE, ARG_TYPE>::GrowBuffer(
    INT_PTR nGrowBy
    )
{
    ASSERT(nGrowBy >= 0);

    if (m_pData == NULL) {
        // create one with exact size
        m_pData = (TYPE*) new BYTE[(size_t)nGrowBy * sizeof(TYPE)];
        if (! m_pData)
            return;
        ConstructElements<TYPE>(m_pData, nGrowBy);
        m_nMaxSize = nGrowBy;
    }
    else {
        // otherwise, grow ring buffer
        INT_PTR nNewMax = m_nMaxSize + nGrowBy;
        TYPE* pNewData = (TYPE*) new BYTE[(size_t)nNewMax * sizeof(TYPE)];
        if (! pNewData)
            return;

        // copy new data from old
        memcpy(pNewData, m_pData, (size_t)m_nMaxSize * sizeof(TYPE));

        // construct remaining elements
        ASSERT(nNewMax > m_nMaxSize);
        ConstructElements<TYPE>(&pNewData[m_nMaxSize], nGrowBy);

        if (m_Out > m_In) {
            // move data to new momory, if out data is remain into the tail of buffer.
            memcpy(&pNewData[m_Out+nGrowBy], &m_pData[m_Out], (size_t)(m_nMaxSize-m_Out) * sizeof(TYPE));
            m_Out += nGrowBy;
        }

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = nNewMax;
    }
}





/////////////////////////////////////////////////////////////////////////////
// _Interface<T>

//
// Auto-interface classes
//

template <class T>
class _Interface {
public:
    _Interface(T* p = NULL)
        : m_p(p)
    {
    }
    virtual ~_Interface() = 0
    {
    }

    bool Valid() { return m_p != NULL; }
    bool Invalid() { return !Valid(); }

    operator void**() { return (void**)&m_p; }

    operator T*() { return m_p; }
    operator T**() { return &m_p; }
    T* operator->() { return m_p; }

    void Attach(T* ip)
    {
        ASSERT(ip);
        m_p = ip;
    }

protected:
    T* m_p;

private:
    // Do not allow to make a copy
    _Interface(_Interface<T>&);
    void operator=(_Interface<T>&);
};

/////////////////////////////////////////////////////////////////////////////
// Interface_RefCnt<T>

template <class T>
class Interface_RefCnt : public _Interface<T> {
public:
    Interface_RefCnt(T* p = NULL) : _Interface<T>(p)
    {
        if (m_p) {
            m_p->AddRef();
        }
    }

    virtual ~Interface_RefCnt()
    {
        if (m_p) {
            m_p->Release();
        }
    }

private:
    // Do not allow to make a copy
    Interface_RefCnt(Interface_RefCnt<T>&);
    void operator=(Interface_RefCnt<T>&);
};

/////////////////////////////////////////////////////////////////////////////
// Interface_Attach<T>

//
// The specialized class for auto-release
//
template <class T>
class Interface_Attach : public Interface_RefCnt<T> {
public:
    // Only the way to create an object of this type is
    // from the similar object.
    Interface_Attach(T* p) : Interface_RefCnt<T>(p) {}
    Interface_Attach(const Interface_Attach<T>& src) : Interface_RefCnt<T>(src.m_p) {}

    virtual ~Interface_Attach() {}

    // Since this class is extremely naive, get the pointer to
    // COM interface through the explicit member function.
    T* GetPtr() { return m_p; }

public:
    // Do not allow to retrive a pointer
    operator T*();

private:
    // Do not allow to make a copy
      // Interface_Attach(Interface_Attach<T>&);
    void operator=(Interface_Attach<T>&);
};

/////////////////////////////////////////////////////////////////////////////
// Interface<T>

//
// The specialized class for auto-release without AddRef.
//
template <class T>
class Interface : public Interface_RefCnt<T> {
public:
    Interface() {};

    virtual ~Interface() {}

    operator T*() { return m_p; }

private:
    // Do not allow to make a copy
    Interface(Interface<T>&);
    void operator=(Interface<T>&);
};

/////////////////////////////////////////////////////////////////////////////
// Interface_Creator<T>

//
// This class should be used only by the creator of the series of
// the objects.
// The specialized class for auto-release without AddRef.
//
template <class T>
class Interface_Creator : public Interface_RefCnt<T> {
public:
    Interface_Creator() {};

    Interface_Creator(T* p)
    {
        Attach(p);
    }

    virtual ~Interface_Creator() {}

    bool Valid()
    {
        if (! Interface_RefCnt<T>::Valid())
            return false;
        else
            return m_p ? m_p->Valid()   : false;
    }

    bool Invalid()
    {
        if (Interface_RefCnt<T>::Invalid())
            return true;
        else
            return m_p ? m_p->Invalid() : true;
    }

private:
    // Do not allow to make a copy
    Interface_Creator(Interface_Creator<T>&);
    void operator=(Interface_Creator<T>&);
};




/////////////////////////////////////////////////////////////////////////////
// Interface_TFSELECTION<>

//
// Specialized interface class for TFSELECTION
// who has a COM pointer in it
//
class Interface_TFSELECTION : public _Interface<TF_SELECTION> {
public:
    Interface_TFSELECTION()
    {
        Attach(&m_sel);
        m_p->range = NULL;
    }
    ~Interface_TFSELECTION()
    {
        if (m_p && m_p->range) {
            m_p->range->Release();
        }
    }

    operator TF_SELECTION*() { return m_p; }

    void Release()
    {
        ASSERT(m_p && m_p->range);
        m_p->range->Release();
        m_p = NULL;
    }

    TF_SELECTION m_sel;

private:
    // Do not allow to make a copy
    Interface_TFSELECTION(Interface_TFSELECTION&);
    void operator=(Interface_TFSELECTION&);
};




/////////////////////////////////////////////////////////////////////////////
// CEnumrateInterface<ENUM, CALLBACK>

typedef enum {
    ENUM_FIND = 0,
    ENUM_CONTINUE,    // DoEnumrate never return ENUM_CONTINUE
    ENUM_NOMOREDATA
} ENUM_RET;

template<class IF_ENUM, class IF_CALLBACK, class IF_ARG>
class CEnumrateInterface
{
public:
    CEnumrateInterface(
        Interface<IF_ENUM>& Enum,
        ENUM_RET (*pCallback)(IF_CALLBACK* pObj, IF_ARG* Arg),
        IF_ARG* Arg = NULL
    ) : m_Enum(Enum), m_pfnCallback(pCallback), m_Arg(Arg) {};

    ENUM_RET DoEnumrate(void);

private:
    Interface<IF_ENUM>& m_Enum;
    ENUM_RET          (*m_pfnCallback)(IF_CALLBACK* pObj, IF_ARG* Arg);
    IF_ARG*             m_Arg;
};

template<class IF_ENUM, class IF_CALLBACK, class IF_ARG>
ENUM_RET
CEnumrateInterface<IF_ENUM, IF_CALLBACK, IF_ARG>::DoEnumrate(
    void
    )
{
    HRESULT hr;
    IF_CALLBACK* pObj;

    while ((hr = m_Enum->Next(1, &pObj, NULL)) == S_OK) {
        ENUM_RET ret = (*m_pfnCallback)(pObj, m_Arg);
        pObj->Release();
        if (ret == ENUM_FIND)
            return ret;
    }
    return ENUM_NOMOREDATA;
}



template<class IF_ENUM, class VAL_CALLBACK, class VAL_ARG>
class CEnumrateValue
{
public:
    CEnumrateValue(
        Interface<IF_ENUM>& Enum,
        ENUM_RET (*pCallback)(VAL_CALLBACK Obj, VAL_ARG* Arg),
        VAL_ARG* Arg = NULL
    ) : m_Enum(Enum), m_pfnCallback(pCallback), m_Arg(Arg) {};

    ENUM_RET DoEnumrate(void);

private:
    Interface<IF_ENUM>& m_Enum;
    ENUM_RET          (*m_pfnCallback)(VAL_CALLBACK Obj, VAL_ARG* Arg);
    VAL_ARG*            m_Arg;
};

template<class IF_ENUM, class VAL_CALLBACK, class VAL_ARG>
ENUM_RET
CEnumrateValue<IF_ENUM, VAL_CALLBACK, VAL_ARG>::DoEnumrate(
    void
    )
{
    HRESULT hr;
    VAL_CALLBACK Obj;

    while ((hr = m_Enum->Next(1, &Obj, NULL)) == S_OK) {
        ENUM_RET ret = (*m_pfnCallback)(Obj, m_Arg);
        if (ret == ENUM_FIND)
            return ret;
    }
    return ENUM_NOMOREDATA;
}



/////////////////////////////////////////////////////////////////////////////
//  Alignment template for IA64 and x86

//
// On the assumption that Win32 (user32/gdi32) handle is 32bit length even IA64 platform.
//
template <class TYPE>
class CAlignWinHandle
{
public:
    operator TYPE() { return (TYPE)ULongToPtr(dw); }
    TYPE operator -> () { return (TYPE)ULongToPtr(dw); }
    void operator = (TYPE a)
    {
        dw = (ULONG)(ULONG_PTR)(a);
    }

protected:
    DWORD dw;        // Alignment is always 32bit.
};


//
// Exception HKL. User32 uses "IntToPtr".
//
class CAlignWinHKL : public CAlignWinHandle<HKL>
{
public:
    operator HKL() { return (HKL)IntToPtr(dw); }
    HKL operator -> () { return (HKL)IntToPtr(dw); }
    void operator = (HKL a)
    {
        dw = (ULONG)(ULONG_PTR)(a);
    }
};




template <class TYPE>
union CAlignPointer
{
public:
    operator TYPE() { return h; }
    TYPE operator -> () { return h; }
    void operator = (TYPE a)
    {
#ifndef _WIN64
        u = 0;        // NULL out high dword.
#endif
        h = a;
    }

protected:
    TYPE    h;

private:
    __int64 u;        // Alignment is always __int64.
};



template <class TYPE>
struct CNativeOrWow64_WinHandle
{
public:
    TYPE GetHandle(BOOL _bOnWow64) { return ! _bOnWow64 ? _h : _h_wow6432; }
    TYPE SetHandle(BOOL _bOnWow64, TYPE a)
    {
        if ( ! _bOnWow64)
            _h = a;
        else
            _h_wow6432 = a;
        return a;
    }

private:
    // Native system HHOOK
    CAlignWinHandle<TYPE>    _h;

    // WOW6432 system HHOOK
    CAlignWinHandle<TYPE>    _h_wow6432;
};



template <class TYPE>
struct CNativeOrWow64_Pointer
{
public:
    TYPE GetPunk(BOOL _bOnWow64) { return ! _bOnWow64 ? _pv : _pv_wow6432; }
    TYPE SetPunk(BOOL _bOnWow64, TYPE a)
    {
        if ( ! _bOnWow64)
            _pv = a;
        else
            _pv_wow6432 = a;
        return a;
    }

private:
    // Native system ITfLangBarEventSink
    CAlignPointer<TYPE>    _pv;

    // WOW6432 system ITfLangBarEventSink
    CAlignPointer<TYPE>    _pv_wow6432;
};


#endif // _TEMPLATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\tfpriv.h ===
//
// tfpriv.h
//
// Private msctf thread messages.
//

#ifndef TFPRIV_H
#define TFPRIV_H


#define TFPRIV_ONSETTHREADFOCUS          0
#define TFPRIV_ONKILLTHREADFOCUS         1
#define TFPRIV_MARSHALINTERFACE          2
#define TFPRIV_UNMARSHALINTERFACEERROR   3
#define TFPRIV_UPDATEDISPATTR            4
#define TFPRIV_LANGCHANGE                5
#define TFPRIV_KEYTIPCHANGE              6
#define TFPRIV_GLOBALCOMPARTMENTSYNC     7
#define TFPRIV_SETMODALLBAR              8
#define TFPRIV_RELEASEMODALLBAR          9
#define TFPRIV_RPCSENDRECEIVE            10
#define TFPRIV_UPDATE_REG_KBDTOGGLE      11
#define TFPRIV_UPDATE_REG_IMX            12
#define TFPRIV_SHELLLANGUAGECHANGE       13
#define TFPRIV_REGISTEREDNEWLANGBAR      14
#define TFPRIV_SYSCOLORCHANGED           15
#define TFPRIV_LOCKREQ                   16
#define TFPRIV_ONSETWINDOWFOCUS          17
#define TFPRIV_POSTINPUTCHANGEREQUEST    18
#define TFPRIV_LANGBARCLOSED             19
#define TFPRIV_ACTIVATELANG              20
#define TFPRIV_ENABLE_MSAA               21
#define TFPRIV_DISABLE_MSAA              22

#endif // TFPRIV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\tsattrs.h ===
/*
 *
 *  Copyright (C) Microsoft Corporation, 1999-2000
 *
 *  File: tsattrs.h
 *
 *  List of ITextStore standard attributes.
 *
 */
#ifndef _TSATTRS_H_
#define _TSATTRS_H_




DEFINE_GUID(TSATTRID_OTHERS,                            0xb3c32af9,0x57d0,0x46a9,0xbc,0xa8,0xda,0xc2,0x38,0xa1,0x30,0x57);

DEFINE_GUID(TSATTRID_Font,                              0x573ea825,0x749b,0x4f8a,0x9c,0xfd,0x21,0xc3,0x60,0x5c,0xa8,0x28);
DEFINE_GUID(TSATTRID_Font_FaceName,                     0xb536aeb6,0x053b,0x4eb8,0xb6,0x5a,0x50,0xda,0x1e,0x81,0xe7,0x2e);
DEFINE_GUID(TSATTRID_Font_SizePts,                      0xc8493302,0xa5e9,0x456d,0xaf,0x04,0x80,0x05,0xe4,0x13,0x0f,0x03);
DEFINE_GUID(TSATTRID_Font_Style,                        0x68b2a77f,0x6b0e,0x4f28,0x81,0x77,0x57,0x1c,0x2f,0x3a,0x42,0xb1);
DEFINE_GUID(TSATTRID_Font_Style_Bold,                   0x48813a43,0x8a20,0x4940,0x8e,0x58,0x97,0x82,0x3f,0x7b,0x26,0x8a);
DEFINE_GUID(TSATTRID_Font_Style_Italic,                 0x8740682a,0xa765,0x48e1,0xac,0xfc,0xd2,0x22,0x22,0xb2,0xf8,0x10);
DEFINE_GUID(TSATTRID_Font_Style_SmallCaps,              0xfacb6bc6,0x9100,0x4cc6,0xb9,0x69,0x11,0xee,0xa4,0x5a,0x86,0xb4);
DEFINE_GUID(TSATTRID_Font_Style_Capitalize,				0x7d85a3ba, 0xb4fd, 0x43b3, 0xbe, 0xfc, 0x6b, 0x98, 0x5c, 0x84, 0x31, 0x41);
DEFINE_GUID(TSATTRID_Font_Style_Uppercase,				0x33a300e8, 0xe340, 0x4937, 0xb6, 0x97, 0x8f, 0x23, 0x40, 0x45, 0xcd, 0x9a);
DEFINE_GUID(TSATTRID_Font_Style_Lowercase,				0x76d8ccb5, 0xca7b, 0x4498, 0x8e, 0xe9, 0xd5, 0xc4, 0xf6, 0xf7, 0x4c, 0x60);
DEFINE_GUID(TSATTRID_Font_Style_Animation,				0xdcf73d22, 0xe029, 0x47b7, 0xbb, 0x36, 0xf2, 0x63, 0xa3, 0xd0, 0x04, 0xcc);
DEFINE_GUID(TSATTRID_Font_Style_Animation_LasVegasLights,0xf40423d5, 0xf87, 0x4f8f, 0xba, 0xda, 0xe6, 0xd6, 0xc, 0x25, 0xe1, 0x52);
DEFINE_GUID(TSATTRID_Font_Style_Animation_BlinkingBackground,0x86e5b104, 0x0104, 0x4b10, 0xb5, 0x85, 0x00, 0xf2, 0x52, 0x75, 0x22, 0xb5);
DEFINE_GUID(TSATTRID_Font_Style_Animation_SparkleText,	0x533aad20, 0x962c, 0x4e9f, 0x8c, 0x09, 0xb4, 0x2e, 0xa4, 0x74, 0x97, 0x11);
DEFINE_GUID(TSATTRID_Font_Style_Animation_MarchingBlackAnts, 0x7644e067, 0xf186, 0x4902, 0xbf, 0xc6, 0xec, 0x81, 0x5a, 0xa2, 0x0e, 0x9d);
DEFINE_GUID(TSATTRID_Font_Style_Animation_MarchingRedAnts, 0x78368dad, 0x50fb, 0x4c6f, 0x84, 0x0b, 0xd4, 0x86, 0xbb, 0x6c, 0xf7, 0x81);
DEFINE_GUID(TSATTRID_Font_Style_Animation_Shimmer,		0x2ce31b58, 0x5293, 0x4c36, 0x88, 0x09, 0xbf, 0x8b, 0xb5, 0x1a, 0x27, 0xb3);
DEFINE_GUID(TSATTRID_Font_Style_Animation_WipeDown,		0x5872e874, 0x367b, 0x4803, 0xb1, 0x60, 0xc9, 0x0f, 0xf6, 0x25, 0x69, 0xd0);
DEFINE_GUID(TSATTRID_Font_Style_Animation_WipeRight,	0xb855cbe3, 0x3d2c, 0x4600, 0xb1, 0xe9, 0xe1, 0xc9, 0xce, 0x02, 0xf8, 0x42);
DEFINE_GUID(TSATTRID_Font_Style_Emboss,					0xbd8ed742, 0x349e, 0x4e37, 0x82, 0xfb, 0x43, 0x79, 0x79, 0xcb, 0x53, 0xa7);
DEFINE_GUID(TSATTRID_Font_Style_Engrave,				0x9c3371de, 0x8332, 0x4897, 0xbe, 0x5d, 0x89, 0x23, 0x32, 0x23, 0x17, 0x9a);
DEFINE_GUID(TSATTRID_Font_Style_Hidden,					0xb1e28770, 0x881c, 0x475f, 0x86, 0x3f, 0x88, 0x7a, 0x64, 0x7b, 0x10, 0x90);
DEFINE_GUID(TSATTRID_Font_Style_Kerning,				0xcc26e1b4, 0x2f9a, 0x47c8, 0x8b, 0xff, 0xbf, 0x1e, 0xb7, 0xcc, 0xe0, 0xdd);
DEFINE_GUID(TSATTRID_Font_Style_Outlined,				0x10e6db31, 0xdb0d, 0x4ac6, 0xa7, 0xf5, 0x9c, 0x9c, 0xff, 0x6f, 0x2a, 0xb4);
DEFINE_GUID(TSATTRID_Font_Style_Position,				0x15cd26ab, 0xf2fb, 0x4062, 0xb5, 0xa6, 0x9a, 0x49, 0xe1, 0xa5, 0xcc, 0x0b);
DEFINE_GUID(TSATTRID_Font_Style_Protected,				0x1c557cb2, 0x14cf, 0x4554, 0xa5, 0x74, 0xec, 0xb2, 0xf7, 0xe7, 0xef, 0xd4);
DEFINE_GUID(TSATTRID_Font_Style_Shadow,					0x5f686d2f, 0xc6cd, 0x4c56, 0x8a, 0x1a, 0x99, 0x4a, 0x4b, 0x97, 0x66, 0xbe);
DEFINE_GUID(TSATTRID_Font_Style_Spacing,				0x98c1200d, 0x8f06, 0x409a, 0x8e, 0x49, 0x6a, 0x55, 0x4b, 0xf7, 0xc1, 0x53);
DEFINE_GUID(TSATTRID_Font_Style_Weight,					0x12f3189c, 0x8bb0, 0x461b, 0xb1, 0xfa, 0xea, 0xf9, 0x07, 0x04, 0x7f, 0xe0);
DEFINE_GUID(TSATTRID_Font_Style_Height,					0x7e937477, 0x12e6, 0x458b, 0x92, 0x6a, 0x1f, 0xa4, 0x4e, 0xe8, 0xf3, 0x91);
DEFINE_GUID(TSATTRID_Font_Style_Underline,              0xc3c9c9f3,0x7902,0x444b,0x9a,0x7b,0x48,0xe7,0x0f,0x4b,0x50,0xf7);
DEFINE_GUID(TSATTRID_Font_Style_Underline_Single,       0x1b6720e5,0x0f73,0x4951,0xa6,0xb3,0x6f,0x19,0xe4,0x3c,0x94,0x61);
DEFINE_GUID(TSATTRID_Font_Style_Underline_Double,       0x74d24aa6, 0x1db3, 0x4c69, 0xa1, 0x76, 0x31, 0x12, 0x0e, 0x75, 0x86, 0xd5);
DEFINE_GUID(TSATTRID_Font_Style_Strikethrough,          0x0c562193,0x2d08,0x4668,0x96,0x01,0xce,0xd4,0x13,0x09,0xd7,0xaf);
DEFINE_GUID(TSATTRID_Font_Style_Strikethrough_Single,   0x75d736b6,0x3c8f,0x4b97,0xab,0x78,0x18,0x77,0xcb,0x99,0x0d,0x31);
DEFINE_GUID(TSATTRID_Font_Style_Strikethrough_Double,   0x62489b31, 0xa3e7, 0x4f94, 0xac, 0x43, 0xeb, 0xaf, 0x8f, 0xcc, 0x7a, 0x9f);
DEFINE_GUID(TSATTRID_Font_Style_Overline,               0xe3989f4a,0x992b,0x4301,0x8c,0xe1,0xa5,0xb7,0xc6,0xd1,0xf3,0xc8);
DEFINE_GUID(TSATTRID_Font_Style_Overline_Single,        0x8440d94c,0x51ce,0x47b2,0x8d,0x4c,0x15,0x75,0x1e,0x5f,0x72,0x1b);
DEFINE_GUID(TSATTRID_Font_Style_Overline_Double,        0xdc46063a, 0xe115, 0x46e3, 0xbc, 0xd8, 0xca, 0x67, 0x72, 0xaa, 0x95, 0xb4);
DEFINE_GUID(TSATTRID_Font_Style_Blink,         		    0xbfb2c036, 0x7acf, 0x4532, 0xb7, 0x20, 0xb4, 0x16, 0xdd, 0x77, 0x65, 0xa8);
DEFINE_GUID(TSATTRID_Font_Style_Subscript,              0x5774fb84,0x389b,0x43bc,0xa7,0x4b,0x15,0x68,0x34,0x7c,0xf0,0xf4);
DEFINE_GUID(TSATTRID_Font_Style_Superscript,            0x2ea4993c,0x563c,0x49aa,0x93,0x72,0x0b,0xef,0x09,0xa9,0x25,0x5b);
DEFINE_GUID(TSATTRID_Font_Style_Color,                  0x857a7a37,0xb8af,0x4e9a,0x81,0xb4,0xac,0xf7,0x00,0xc8,0x41,0x1b);
DEFINE_GUID(TSATTRID_Font_Style_BackgroundColor,		0xb50eaa4e, 0x3091, 0x4468, 0x81, 0xdb, 0xd7, 0x9e, 0xa1, 0x90, 0xc7, 0xc7);

DEFINE_GUID(TSATTRID_Text,              				0x7edb8e68, 0x81f9, 0x449d, 0xa1, 0x5a, 0x87, 0xa8, 0x38, 0x8f, 0xaa, 0xc0);
DEFINE_GUID(TSATTRID_Text_VerticalWriting,              0x6bba8195,0x046f,0x4ea9,0xb3,0x11,0x97,0xfd,0x66,0xc4,0x27,0x4b);
DEFINE_GUID(TSATTRID_Text_RightToLeft,                  0xca666e71,0x1b08,0x453d,0xbf,0xdd,0x28,0xe0,0x8c,0x8a,0xaf,0x7a);
DEFINE_GUID(TSATTRID_Text_Orientation,                  0x6bab707f,0x8785,0x4c39,0x8b,0x52,0x96,0xf8,0x78,0x30,0x3f,0xfb);
DEFINE_GUID(TSATTRID_Text_Language,                     0xd8c04ef1,0x5753,0x4c25,0x88,0x87,0x85,0x44,0x3f,0xe5,0xf8,0x19);
DEFINE_GUID(TSATTRID_Text_ReadOnly,                     0x85836617,0xde32,0x4afd,0xa5,0x0f,0xa2,0xdb,0x11,0x0e,0x6e,0x4d);
DEFINE_GUID(TSATTRID_Text_EmbeddedObject,               0x7edb8e68, 0x81f9, 0x449d, 0xa1, 0x5a, 0x87, 0xa8, 0x38, 0x8f, 0xaa, 0xc0);
DEFINE_GUID(TSATTRID_Text_Alignment,               		0x139941e6, 0x1767, 0x456d, 0x93, 0x8e, 0x35, 0xba, 0x56, 0x8b, 0x5c, 0xd4);
DEFINE_GUID(TSATTRID_Text_Alignment_Left,          		0x16ae95d3, 0x6361, 0x43a2, 0x84, 0x95, 0xd0, 0x0f, 0x39, 0x7f, 0x16, 0x93);
DEFINE_GUID(TSATTRID_Text_Alignment_Right,        		0xb36f0f98, 0x1b9e, 0x4360, 0x86, 0x16, 0x03, 0xfb, 0x08, 0xa7, 0x84, 0x56);
DEFINE_GUID(TSATTRID_Text_Alignment_Center,        		0xa4a95c16, 0x53bf, 0x4d55, 0x8b, 0x87, 0x4b, 0xdd, 0x8d, 0x42, 0x75, 0xfc);
DEFINE_GUID(TSATTRID_Text_Alignment_Justify,       		0xed350740, 0xa0f7, 0x42d3, 0x8e, 0xa8, 0xf8, 0x1b, 0x64, 0x88, 0xfa, 0xf0);
DEFINE_GUID(TSATTRID_Text_Link,               			0x47cd9051, 0x3722, 0x4cd8, 0xb7, 0xc8, 0x4e, 0x17, 0xca, 0x17, 0x59, 0xf5);
DEFINE_GUID(TSATTRID_Text_Hyphenation,               	0xdadf4525, 0x618e, 0x49eb, 0xb1, 0xa8, 0x3b, 0x68, 0xbd, 0x76, 0x48, 0xe3);
DEFINE_GUID(TSATTRID_Text_Para,		               		0x5edc5822, 0x99dc, 0x4dd6, 0xae, 0xc3, 0xb6, 0x2b, 0xaa, 0x5b, 0x2e, 0x7c);
DEFINE_GUID(TSATTRID_Text_Para_FirstLineIndent,         0x07c97a13, 0x7472, 0x4dd8, 0x90, 0xa9, 0x91, 0xe3, 0xd7, 0xe4, 0xf2, 0x9c);
DEFINE_GUID(TSATTRID_Text_Para_LeftIndent,              0xfb2848e9, 0x7471, 0x41c9, 0xb6, 0xb3, 0x8a, 0x14, 0x50, 0xe0, 0x18, 0x97);
DEFINE_GUID(TSATTRID_Text_Para_RightIndent,             0x2c7f26f9, 0xa5e2, 0x48da, 0xb9, 0x8a, 0x52, 0x0c, 0xb1, 0x65, 0x13, 0xbf);
DEFINE_GUID(TSATTRID_Text_Para_SpaceAfter,              0x7b0a3f55, 0x22dc, 0x425f, 0xa4, 0x11, 0x93, 0xda, 0x1d, 0x8f, 0x9b, 0xaa);
DEFINE_GUID(TSATTRID_Text_Para_SpaceBefore,             0x8df98589, 0x194a, 0x4601, 0xb2, 0x51, 0x98, 0x65, 0xa3, 0xe9, 0x06, 0xdd);
DEFINE_GUID(TSATTRID_Text_Para_LineSpacing,             0x699b380d, 0x7f8c, 0x46d6, 0xa7, 0x3b, 0xdf, 0xe3, 0xd1, 0x53, 0x8d, 0xf3);
DEFINE_GUID(TSATTRID_Text_Para_LineSpacing_Single,   	0xed350740, 0xa0f7, 0x42d3, 0x8e, 0xa8, 0xf8, 0x1b, 0x64, 0x88, 0xfa, 0xf0);
DEFINE_GUID(TSATTRID_Text_Para_LineSpacing_OnePtFive,	0x0428a021, 0x0397, 0x4b57, 0x9a, 0x17, 0x07, 0x95, 0x99, 0x4c, 0xd3, 0xc5);
DEFINE_GUID(TSATTRID_Text_Para_LineSpacing_Double,  	0x82fb1805, 0xa6c4, 0x4231, 0xac, 0x12, 0x62, 0x60, 0xaf, 0x2a, 0xba, 0x28);
DEFINE_GUID(TSATTRID_Text_Para_LineSpacing_AtLeast, 	0xadfedf31, 0x2d44, 0x4434, 0xa5, 0xff, 0x7f, 0x4c, 0x49, 0x90, 0xa9, 0x05);
DEFINE_GUID(TSATTRID_Text_Para_LineSpacing_Exactly, 	0x3d45ad40, 0x23de, 0x48d7, 0xa6, 0xb3, 0x76, 0x54, 0x20, 0xc6, 0x20, 0xcc);
DEFINE_GUID(TSATTRID_Text_Para_LineSpacing_Multiple, 	0x910f1e3c, 0xd6d0, 0x4f65, 0x8a, 0x3c, 0x42, 0xb4, 0xb3, 0x18, 0x68, 0xc5);

DEFINE_GUID(TSATTRID_List,                              0x436d673b, 0x26f1, 0x4aee, 0x9e, 0x65, 0x8f, 0x83, 0xa4, 0xed, 0x48, 0x84);
DEFINE_GUID(TSATTRID_List_LevelIndel,            		0x7f7cc899, 0x311f, 0x487b, 0xad, 0x5d, 0xe2, 0xa4, 0x59, 0xe1, 0x2d, 0x42);
DEFINE_GUID(TSATTRID_List_Type,             			0xae3e665e, 0x4bce, 0x49e3, 0xa0, 0xfe, 0x2d, 0xb4, 0x7d, 0x3a, 0x17, 0xae);
DEFINE_GUID(TSATTRID_List_Type_Bullet,        			0xbccd77c5, 0x4c4d, 0x4ce2, 0xb1, 0x02, 0x55, 0x9f, 0x3b, 0x2b, 0xfc, 0xea);
DEFINE_GUID(TSATTRID_List_Type_Arabic,        			0x1338c5d6, 0x98a3, 0x4fa3, 0x9b, 0xd1, 0x7a, 0x60, 0xee, 0xf8, 0xe9, 0xe0);
DEFINE_GUID(TSATTRID_List_Type_LowerLetter,    			0x96372285, 0xf3cf, 0x491e, 0xa9, 0x25, 0x38, 0x32, 0x34, 0x7f, 0xd2, 0x37);
DEFINE_GUID(TSATTRID_List_Type_UpperLetter,             0x7987b7cd, 0xce52, 0x428b, 0x9b, 0x95, 0xa3, 0x57, 0xf6, 0xf1, 0x0c, 0x45);
DEFINE_GUID(TSATTRID_List_Type_LowerRoman,             	0x90466262, 0x3980, 0x4b8e, 0x93, 0x68, 0x91, 0x8b, 0xd1, 0x21, 0x8a, 0x41);
DEFINE_GUID(TSATTRID_List_Type_UpperRoman,          	0x0f6ab552, 0x4a80, 0x467f, 0xb2, 0xf1, 0x12, 0x7e, 0x2a, 0xa3, 0xba, 0x9e);

DEFINE_GUID(TSATTRID_App,                               0xa80f77df,0x4237,0x40e5,0x84,0x9c,0xb5,0xfa,0x51,0xc1,0x3a,0xc7);
DEFINE_GUID(TSATTRID_App_IncorrectSpelling,             0xf42de43c,0xef12,0x430d,0x94,0x4c,0x9a,0x08,0x97,0x0a,0x25,0xd2);
DEFINE_GUID(TSATTRID_App_IncorrectGrammar,              0xbd54e398,0xad03,0x4b74,0xb6,0xb3,0x5e,0xdb,0x19,0x99,0x63,0x88);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\validate.h ===
#ifndef _validate_h_
#define _validate_h_

#ifdef __cplusplus
extern "C" {
#endif

/* parameter validation macros */

/*
 * call as:
 *
 * bOK = IS_VALID_READ_PTR(pfoo, CFOO);
 *
 * bOK = IS_VALID_HANDLE(hfoo, FOO);
 */

#ifdef DEBUG

#define IS_VALID_READ_PTR(ptr, type) \
   (IsBadReadPtr((ptr), sizeof(type)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs read pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_PTR(ptr, type) \
   (IsBadWritePtr((PVOID)(ptr), sizeof(type)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs write pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTRA(ptr, cch) \
   ((IsBadReadPtr((ptr), sizeof(char)) || IsBadStringPtrA((ptr), (UINT_PTR)(cch))) ? \
    (TraceMsgA(TF_ERROR, "invalid LPSTR pointer - %#08lx", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTRW(ptr, cch) \
   ((IsBadReadPtr((ptr), sizeof(WCHAR)) || IsBadStringPtrW((ptr), (UINT_PTR)(cch))) ? \
    (TraceMsgA(TF_ERROR, "invalid LPWSTR pointer - %#08lx", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_CODE_PTR(ptr, type) \
   (IsBadCodePtr((FARPROC)(ptr)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs code pointer - %#08lx", (LPCSTR)#type, (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_READ_BUFFER(ptr, type, len) \
   (IsBadReadPtr((ptr), sizeof(type)*(len)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs read buffer pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_BUFFER(ptr, type, len) \
   (IsBadWritePtr((ptr), sizeof(type)*(len)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs write buffer pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? \
    (TraceMsgA(TF_ERROR, "invalid flags set - %#08lx", ((dwFlags) & (~(dwAllFlags)))), FALSE) : \
    TRUE)

#define IS_VALID_PIDL(ptr) \
   ( !IsValidPIDL(ptr) ? \
    (TraceMsgA(TF_ERROR, "invalid PIDL pointer - %#08lx", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_SIZE(cb, cbExpected) \
   ((cb) != (cbExpected) ? \
    (TraceMsgA(TF_ERROR, "invalid size - is %#08lx, expected %#08lx", (cb), (cbExpected)), FALSE) : \
    TRUE)


#else

#define IS_VALID_READ_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#define IS_VALID_WRITE_PTR(ptr, type) \
   (! IsBadWritePtr((PVOID)(ptr), sizeof(type)))

#define IS_VALID_STRING_PTRA(ptr, cch) \
   (! IsBadStringPtrA((ptr), (UINT_PTR)(cch)))

#define IS_VALID_STRING_PTRW(ptr, cch) \
   (! IsBadStringPtrW((ptr), (UINT_PTR)(cch)))

#define IS_VALID_CODE_PTR(ptr, type) \
   (! IsBadCodePtr((FARPROC)(ptr)))

#define IS_VALID_READ_BUFFER(ptr, type, len) \
   (! IsBadReadPtr((ptr), sizeof(type)*(len)))

#define IS_VALID_WRITE_BUFFER(ptr, type, len) \
   (! IsBadWritePtr((ptr), sizeof(type)*(len)))

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? FALSE : TRUE)

#define IS_VALID_PIDL(ptr) \
   (IsValidPIDL(ptr))

#define IS_VALID_SIZE(cb, cbExpected) \
   ((cb) == (cbExpected))

#endif

#ifdef UNICODE
#define IS_VALID_STRING_PTR     IS_VALID_STRING_PTRW
#else
#define IS_VALID_STRING_PTR     IS_VALID_STRING_PTRA
#endif


/* handle validation macros */

#ifdef DEBUG

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd) ? \
    TRUE : \
    (TraceMsgA(TF_ERROR, "invalid H" #type " - %#08lx", (hnd)), FALSE))

#else

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd))

#endif

/* structure validation macros */

// Define VSTF if you want to validate the fields in structures.  This
// requires a handler function (of the form IsValid*()) that knows how
// to validate the specific structure type.

#ifdef VSTF

#ifdef DEBUG

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr) ? \
    TRUE : \
    (TraceMsgA(TF_ERROR, "invalid %hs pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (IsValidP##type(ptr, x) ? \
    TRUE : \
    (TraceMsgA(TF_ERROR, "invalid %hs pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE))

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (IsValidP##type(ptr, x))

#endif

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#endif  // VSTF

/* OLE interface validation macro */

#define IS_VALID_INTERFACE_PTR(ptr, iface) \
   IS_VALID_STRUCT_PTR(ptr, ##iface)


#if !defined(NO_SHELL_VALIDATION)

BOOL IsValidPathA(LPCSTR pcszPath);
BOOL IsValidPathW(LPCWSTR pcszPath);

BOOL IsValidPathResultA(HRESULT hr, LPCSTR pcszPath, UINT cchPathBufLen);
BOOL IsValidPathResultW(HRESULT hr, LPCWSTR pcszPath, UINT cchPathBufLen);

BOOL IsValidExtensionA(LPCSTR pcszExt);
BOOL IsValidExtensionW(LPCWSTR pcszExt);

BOOL IsValidIconIndexA(HRESULT hr, LPCSTR pcszIconFile, UINT cchIconFileBufLen, int niIcon);
BOOL IsValidIconIndexW(HRESULT hr, LPCWSTR pcszIconFile, UINT cchIconFileBufLen, int niIcon);

BOOL IsFullPathA(LPCSTR pcszPath);
BOOL IsFullPathW(LPCWSTR pcszPath);

BOOL IsStringContainedA(LPCSTR pcszBigger, LPCSTR pcszSuffix);
BOOL IsStringContainedW(LPCWSTR pcszBigger, LPCWSTR pcszSuffix);

#ifdef UNICODE
#define IsValidPath         IsValidPathW
#define IsValidPathResult   IsValidPathResultW
#define IsValidExtension    IsValidExtensionW
#define IsValidIconIndex    IsValidIconIndexW
#define IsFullPath          IsFullPathW
#define IsStringContained   IsStringContainedW
#else
#define IsValidPath         IsValidPathA
#define IsValidPathResult   IsValidPathResultA
#define IsValidExtension    IsValidExtensionA
#define IsValidIconIndex    IsValidIconIndexA
#define IsFullPath          IsFullPathA
#define IsStringContained   IsStringContainedA
#endif

BOOL IsValidHANDLE(HANDLE hnd);         // Compares with NULL and INVALID_HANDLE_VALUE
BOOL IsValidHANDLE2(HANDLE hnd);        // Compares with INVALID_HANDLE_VALUE

#define IsValidHEVENT       IsValidHANDLE
#define IsValidHGLOBAL      IsValidHANDLE
#define IsValidHFILE        IsValidHANDLE
#define IsValidHINSTANCE    IsValidHANDLE
#define IsValidHICON        IsValidHANDLE
#define IsValidHKEY         IsValidHANDLE
#define IsValidHMODULE      IsValidHANDLE
#define IsValidHPROCESS     IsValidHANDLE

BOOL
IsValidHWND(
    HWND hwnd);

BOOL
IsValidHMENU(
    HMENU hmenu);

BOOL
IsValidShowCmd(
    int nShow);

// The next few functions must declare the structure types explicitly
// so we don't need to worry about whether <shlobj.h> and/or <comctrlp.h>
// was included before or after us.

BOOL
IsValidPIDL(
    const UNALIGNED struct _ITEMIDLIST *pidl);

BOOL
IsValidHDPA(
    struct _DPA *hdpa);

BOOL
IsValidHDSA(
    struct _DSA *hdsa);

#endif // NO_SHELL_VALIDATION

#ifdef __cplusplus
};
#endif

#endif // _validate_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\varutil.h ===
//
// varutil.h
//


#ifndef VARUTIL_H
#define VARUTIL_H

#include "varcomp.h"

HRESULT CicVarCmp(VARIANT *pvar1, VARIANT *pvar2);

#endif // VARUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\varstor.h ===
//
// varstor.h
//

#ifndef VARSTOR_H
#define VARSTOR_H

#ifdef __cplusplus

#include "private.h"

#define VS_HASHSIZE 31

template<class TKey, class T>
class CVSEntry
{
public:
    TKey key;
    T t;
    CVSEntry<TKey, T> *next;
};

template<class TKey, class T>
class CVarStor
{
public:
    CVarStor() { memset(_HashTbl, 0, sizeof(_HashTbl)); }
    ~CVarStor();

    T *_Create(TKey key);
    T *_Find(TKey key);
    BOOL _Remove(TKey key);

private:
    UINT _HashFunc(TKey key) { return (DWORD)key % PM_HASHSIZE; }
    CVSEntry<TKey, T> **_FindEntry(TKey key);

    CVSEntry<TKey, T> *_HashTbl[PM_HASHSIZE];
};

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

template<class TKey, class T>
CVarStor<TKey, T>::~CVarStor()
{
    CVSEntry<TKey, T> *pe;
    CVSEntry<TKey, T> *peTmp;
    int i;

    // free anything left in the hashtbl
    for (i=0; i<ARRAYSIZE(_HashTbl); i++)
    {
        pe = _HashTbl[i];

        while (pe != NULL)
        {
            peTmp = pe->next;
            delete pe;
            pe = peTmp;
        }
    }
}

//+---------------------------------------------------------------------------
//
// _Set
//
//----------------------------------------------------------------------------

template<class TKey, class T>
T *CVarStor<TKey, T>::_Create(TKey key)
{
    UINT uIndex;
    CVSEntry<TKey, T> *pe;
    BOOL fRet;

    fRet = TRUE;

    Assert(_FindEntry(key) == NULL);

    if ((pe = new CVSEntry<TKey, T>) == NULL)
        return NULL;

    // new entry
    uIndex = _HashFunc(key);
    pe->key = key;
    pe->next = _HashTbl[uIndex];
    _HashTbl[uIndex] = pe;

    return &pe->t;
}

//+---------------------------------------------------------------------------
//
// _Find
//
//----------------------------------------------------------------------------

template<class TKey, class T>
T *CVarStor<TKey, T>::_Find(TKey key)
{
    CVSEntry<TKey, T> **ppe;

    if (ppe = _FindEntry(key))
    {
        return &(*ppe)->t;
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//
// _Remove
//
//----------------------------------------------------------------------------

template<class TKey, class T>
BOOL CVarStor<TKey, T>::_Remove(TKey key)
{
    CVSEntry<TKey, T> *pe;
    CVSEntry<TKey, T> **ppe;

    if (ppe = _FindEntry(key))
    {
        pe = *ppe;
        *ppe = pe->next;
        delete pe;
        return TRUE;
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
// _FindEntry
//
//----------------------------------------------------------------------------

template<class TKey, class T>
CVSEntry<TKey, T> **CVarStor<TKey, T>::_FindEntry(TKey key)
{
    CVSEntry<TKey, T> **ppe;

    ppe = &_HashTbl[_HashFunc(key)];

    while (*ppe)
    {
        if ((*ppe)->key == key)
        {
            return ppe;
        }
        ppe = &(*ppe)->next;
    }

    return NULL;
}


#endif // __cplusplus

#endif // VARSTOR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\xstring.h ===
//
// xstring.h
//
// Unicode/ansi conversion.
//

#ifndef XSTRING_H
#define XSTRING_H

char *UnicodeToAnsi(UINT uCodePage, const WCHAR *pchW, UINT uLenW, char *pchAIn, UINT uSizeA);
WCHAR *AnsiToUnicode(UINT uCodePage, const char *pchA, UINT uLenA, WCHAR *pchWIn, UINT uSizeW);
void BufferAllocFree(void *pBuffer, void *pAllocMem);

#ifdef __cplusplus
class WtoA {
public:
    WtoA(const WCHAR* str)
    {
        int cch = WideCharToMultiByte(CP_ACP, 0, str, -1, NULL, 0, NULL, NULL);
        _pch = new char[cch + 1];
        if (_pch)
            WideCharToMultiByte(CP_ACP, 0, str, -1, _pch, cch, NULL, NULL);
    }

    WtoA(const WCHAR* str, ULONG cch)
    {
        int cchA = WideCharToMultiByte(CP_ACP, 0, str, cch, NULL, 0, NULL, NULL);
        _pch = new char[cchA + 1];
        if (_pch)
            WideCharToMultiByte(CP_ACP, 0, str, cch, _pch, cchA, NULL, NULL);
    }
    ~WtoA()
    {
        delete _pch;
    }

    operator char*()
    {
        if (_pch)
            return _pch;

        Assert(0);
        return "\0";
    }

protected:
    char* _pch;
};

class AtoW {
public:
    AtoW(const char* str)
    {
        int cch = MultiByteToWideChar(CP_ACP, 0, str, -1, NULL, 0);
        _pch = new WCHAR[cch + 1];
        if (_pch)
            MultiByteToWideChar(CP_ACP, 0, str, -1, _pch, cch);
    }

    AtoW(const char* str, ULONG cch)
    {
        int cchW = MultiByteToWideChar(CP_ACP, 0, str, cch, NULL, 0);
        _pch = new WCHAR[cchW + 1];
        if (_pch)
            MultiByteToWideChar(CP_ACP, 0, str, cch, _pch, cchW);
    }

    ~AtoW()
    {
        delete _pch;
    }

    operator WCHAR*()
    {
        if (_pch)
            return _pch;

        Assert(0);
        return L"\0";
    }

protected:
    WCHAR* _pch;
};

class WCHtoWSZ {
public:
    WCHtoWSZ (const WCHAR *pch, ULONG cch)
    {
        Assert(pch || !cch);

        if (cch == (ULONG)(-1))
            cch = wcslen(pch);

        _pch = new WCHAR[cch + 1];
        if (_pch)
        {
            if (pch && cch)
                memcpy(_pch, pch, cch * sizeof(WCHAR));

            _pch[cch] = L'\0';
        }
    }

    ~WCHtoWSZ ()
    {
        delete _pch;
    }

    operator WCHAR*()
    {
        if (_pch)
            return _pch;

        Assert(0);
        return L"\0";
    }
protected:
    WCHAR* _pch;
};
#endif // __cplusplus

#endif // XSTRING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inputdll\external.h ===
//
//  Include Files.
//

#ifndef EXTERNAL_H
#define EXTERNAL_H

typedef struct layoutlist_s
{
    DWORD dwLocale;                 // input locale id
    DWORD dwLayout;                 // layout id
    DWORD dwSubst;                  // substitution key value
    BOOL bLoaded;                   // if the layout is already loaded
    BOOL bIME;                      // if the layout is an IME
} LAYOUTLIST, *LPLAYOUTLIST;

BOOL InstallInputLayout(
    LCID lcid,
    DWORD dwLayout,
    BOOL bDefLayout,
    HKL hklDefault,
    BOOL bDefUser,
    BOOL bSysLocale);

BOOL UnInstallInputLayout(
    LCID lcid,
    DWORD dwLayout,
    BOOL bDefUser);

void LoadCtfmon(
    BOOL bLoad,
    LCID SysLocale,
    BOOL bDefUser);

#endif // EXTERNAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inputdll\cicutil.c ===
#include "input.h"
#include "util.h"

#define SP1_BEGIN_RC_ID         10000
#define SP1_END_RC_ID           20000

HINSTANCE g_hInstXPSP1Res = NULL;


////////////////////////////////////////////////////////////////////////////
//
// IsXPSP1ResourceID
//
////////////////////////////////////////////////////////////////////////////

BOOL IsXPSP1ResourceID(UINT uID)
{
    BOOL bRet = FALSE;

    if (uID >= SP1_BEGIN_RC_ID && uID <= SP1_END_RC_ID)
    {
        bRet = TRUE;
    }

    return bRet;
}

////////////////////////////////////////////////////////////////////////////
//
//  GetCicResInstance()
//
////////////////////////////////////////////////////////////////////////////

HINSTANCE GetCicResInstance(HINSTANCE hInstOrg, UINT uID)
{
#ifdef CIC_XPSP1
    if (IsXPSP1ResourceID(uID))
    {
        if (!g_hInstXPSP1Res)
        {
            g_hInstXPSP1Res = LoadSystemLibraryEx(TEXT("xpsp1res.dll"),
                                                NULL,
                                                LOAD_LIBRARY_AS_DATAFILE);
        }

        return g_hInstXPSP1Res;
    }
    else
    {
        return hInstOrg;
    }
#else
    return hInstOrg;
#endif // CIC_XPSP1
}

////////////////////////////////////////////////////////////////////////////
//
//  FreeCicResInstance()
//
////////////////////////////////////////////////////////////////////////////
void FreeCicResInstance()
{
#ifdef CIC_XPSP1
    if (g_hInstXPSP1Res)
        FreeLibrary(g_hInstXPSP1Res);
#endif // CIC_XPSP1
}

////////////////////////////////////////////////////////////////////////////
//
// CicLoadString
//
////////////////////////////////////////////////////////////////////////////

int CicLoadString(HINSTANCE hInstOrg, UINT uID, LPTSTR lpBuffer, UINT uBuffSize)
{
    HINSTANCE hResInst = GetCicResInstance(hInstOrg, uID);

    return LoadString(hResInst, uID, lpBuffer, uBuffSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inc\varcomp.h ===
//
// varcomp.h
//

#pragma once

#define PRLT    ( 0 )
#define PRLE    ( 1 )
#define PRGT    ( 2 )
#define PRGE    ( 3 )
#define PREQ    ( 4 )
#define PRNE    ( 5 )
#define PRRE    ( 6 )
#define PRAllBits   ( 7 )
#define PRSomeBits  ( 8 )
#define PRAll   ( 0x100 )
#define PRAny   ( 0x200 )


typedef BOOL (* FRel)(PROPVARIANT const &, PROPVARIANT const &);
typedef BOOL (* FPRel)(BYTE const *, BYTE const *);
typedef int (* FCmp)(PROPVARIANT const &, PROPVARIANT const &);
typedef int (* FPCmp)(BYTE const *, BYTE const *);

class CComparators
{
public:

    static FCmp   GetComparator( VARENUM vt );
    static FRel   GetRelop( VARENUM vt, ULONG rel );
    static FPCmp  GetPointerComparator( PROPVARIANT const & v1,
                                        PROPVARIANT const & v2 );
    static FPRel  GetPointerRelop( PROPVARIANT const & v1,
                                   PROPVARIANT const & v2,
                                   ULONG rel );

private:

    //
    // There is one SComparators structure for each base variant type.
    // They are accessed off aVariantComarators by VT_xxx.  Within
    // the SComparators structure relops are accessed by PRxxx.
    //

    struct SComparators
    {
        FCmp comparator;
        FPCmp pointercomparator;
        FRel relops[9];
        FPRel pointerrelops[9];
    };

    static ULONG const  _iStart;
    static SComparators const _aVariantComparators[];
    static ULONG const  _cVariantComparators;

    static ULONG const  _iStart2;
    static SComparators const _aVariantComparators2[];
    static ULONG const  _cVariantComparators2;

    static FRel const   _aVectorComparators[];
    static ULONG const  _cVectorComparators;
    static FRel const   _aVectorComparatorsAll[];
    static ULONG const  _cVectorComparatorsAll;
    static FRel const   _aVectorComparatorsAny[];
    static ULONG const  _cVectorComparatorsAny;
};

extern CComparators VariantCompare;

inline BOOL isVector(VARTYPE vt)
{
    return 0 != ( vt & VT_VECTOR );
}

inline BOOL isVector(PROPVARIANT const & v)
{
    return isVector( v.vt );
}

inline BOOL isArray(VARTYPE vt)
{
    return 0 != ( vt & VT_ARRAY );
}

inline BOOL isArray(PROPVARIANT const & v)
{
    return isArray( v.vt );
}

inline BOOL isVectorOrArray(VARTYPE vt)
{
    return 0 != ( vt & (VT_ARRAY|VT_VECTOR) );
}

inline BOOL isVectorOrArray(PROPVARIANT const & v)
{
    return isVectorOrArray( v.vt );
}

inline BOOL isVectorRelop(ULONG relop)
{
    return relop & (PRAny | PRAll);
}

inline BOOL isRelopAny(ULONG relop)
{
    return relop & PRAny;
}

inline BOOL isRelopAll(ULONG relop)
{
    return relop & PRAll;
}

inline VARENUM getBaseType(PROPVARIANT const &v)
{
    return (VARENUM) (VT_TYPEMASK & v.vt);
}

inline ULONG getBaseRelop(ULONG relop)
{
    return relop & ~(PRAny | PRAll);
}

BOOL VT_VARIANT_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 );
BOOL VT_VARIANT_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 );
BOOL VT_VARIANT_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 );
BOOL VT_VARIANT_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 );
BOOL VT_VARIANT_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 );
BOOL VT_VARIANT_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inputdll\advanced.c ===
//
//  Include Files.
//

#include "input.h"
#include "util.h"
#include "inputdlg.h"
#include "external.h"
#include "inputhlp.h"


//
// Define global variables.
//
HWND g_hwndAdvanced = NULL;
static BOOL g_bAdmin = FALSE;

//
// Define external variable and rotines.
//
extern g_bAdvChanged;
extern UINT g_iInputs;
extern UINT g_iOrgInputs;


//
//  Context Help Ids.
//

static int aAdvancedHelpIds[] =
{
    IDC_GROUPBOX1,                  IDH_COMM_GROUPBOX,
    IDC_ADVANCED_CUAS_ENABLE,       IDH_ADVANCED_CUAS,
    IDC_ADVANCED_CUAS_TEXT,         IDH_ADVANCED_CUAS,
    IDC_GROUPBOX2,                  IDH_COMM_GROUPBOX,
    IDC_ADVANCED_CTFMON_DISABLE,    IDH_ADVANCED_CTFMON,
    IDC_ADVANCED_CTFMON_TEXT,       IDH_ADVANCED_CTFMON,
    0, 0
};


////////////////////////////////////////////////////////////////////////////
//
//  AdvancedDlgInit
//
////////////////////////////////////////////////////////////////////////////

void AdvancedDlgInit(HWND hwnd)
{
    HKEY hkeyTemp;

    //
    //  Get the setting of enable/disalbe Text Services input
    //
    if (IsDisableCtfmon())
    {
        EnableWindow(GetDlgItem(hwnd, IDC_ADVANCED_CUAS_ENABLE), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_ADVANCED_CUAS_TEXT), FALSE);

        CheckDlgButton(hwnd, IDC_ADVANCED_CTFMON_DISABLE, TRUE);
    }
    else
    {
        CheckDlgButton(hwnd, IDC_ADVANCED_CTFMON_DISABLE, FALSE);

        //
        // Show the turned off advanced text service if ctfmon.exe process isn't
        // running with the multiple keyboard without adding any new layouts.
        //
        if (!IsSetupMode() &&
            IsEnabledTipOrMultiLayouts() &&
            g_iInputs == g_iOrgInputs &&
            FindWindow(c_szCTFMonClass, NULL) == NULL)
        {
            //
            // ctfmon.exe process doesn't running with TIP or multi keyboard
            // layouts. So change the status as the disabled ctfmon.
            //
            CheckDlgButton(hwnd, IDC_ADVANCED_CTFMON_DISABLE, TRUE);

            EnableWindow(GetDlgItem(hwnd, IDC_ADVANCED_CUAS_ENABLE), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_ADVANCED_CUAS_TEXT), FALSE);

            // Try to keep the disabled status when Apply button is clicked.
            g_bAdvChanged = TRUE;
        }
    }

    //
    // Get Cicero Unaware Application Support setting info from the registry.
    //
    if (IsDisableCUAS())
    {
        // Turn off CUAS
        CheckDlgButton(hwnd, IDC_ADVANCED_CUAS_ENABLE, FALSE);
    }
    else
    {
        // Turn on CUAS
        CheckDlgButton(hwnd, IDC_ADVANCED_CUAS_ENABLE, TRUE);
    }

    //
    //  Check the Administrative privileges by the token group SID.
    //
    if (IsAdminPrivilegeUser())
    {
        g_bAdmin = TRUE;
    }
    else
    {
        // Disable Cicero Unaware Application Support checkbox for local user
        EnableWindow(GetDlgItem(hwnd, IDC_ADVANCED_CUAS_ENABLE), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_ADVANCED_CUAS_TEXT), FALSE);
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  InputAdvancedDlgProc
//
//  This is the dialog proc for the Input Advanced property sheet.
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK InputAdvancedDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (message)
    {
        case ( WM_HELP ) :
        {
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    c_szHelpFile,
                    HELP_WM_HELP,
                    (DWORD_PTR)(LPTSTR)aAdvancedHelpIds);
            break;
        }
        case ( WM_CONTEXTMENU ) :                       // right mouse click
        {
            WinHelp((HWND)wParam,
                    c_szHelpFile,
                    HELP_CONTEXTMENU,
                    (DWORD_PTR)(LPTSTR)aAdvancedHelpIds);
            break;
        }

        case (WM_INITDIALOG) :
        {
            HWND hwndCUASText;
            HWND hwndCtfmonText;
            TCHAR szCUASText[MAX_PATH * 2];
            TCHAR szCtfmonText[MAX_PATH * 2];

            //
            // Save Advanced tab window handle
            //
            g_hwndAdvanced = hDlg;

            //
            // Set Cicero Unawared Application Support text string.
            //
            hwndCUASText = GetDlgItem(hDlg, IDC_ADVANCED_CUAS_TEXT);

            CicLoadString(hInstance, IDS_ADVANCED_CUAS_TEXT, szCUASText, MAX_PATH * 2);

            SetWindowText(hwndCUASText, szCUASText);

            //
            // Set disable all advanced text services text string.
            //
            hwndCtfmonText = GetDlgItem(hDlg, IDC_ADVANCED_CTFMON_TEXT);

            CicLoadString(hInstance, IDS_ADVANCED_CTFMON_TEXT, szCtfmonText, MAX_PATH * 2);

            SetWindowText(hwndCtfmonText, szCtfmonText);

            //
            // Initialize CUAS and CTFMON turn off status.
            //
            AdvancedDlgInit(hDlg);

            break;
        }

        case (WM_NOTIFY) :
        {
            switch (((NMHDR *)lParam)->code)
            {
                case (PSN_QUERYCANCEL) :
                case (PSN_RESET) :
                case (PSN_KILLACTIVE) :
                    break;

                case (PSN_APPLY) :
                {
                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }

        case (WM_COMMAND) :
        {
            switch (LOWORD(wParam))
            {
                case (IDC_ADVANCED_CTFMON_DISABLE) :
                {
                    if (IsDlgButtonChecked(hDlg, IDC_ADVANCED_CTFMON_DISABLE))
                    {
                        EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED_CUAS_ENABLE), FALSE);
                        EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED_CUAS_TEXT), FALSE);
                    }
                    else
                    {
                        if (g_bAdmin)
                        {
                            EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED_CUAS_ENABLE), TRUE);
                            EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED_CUAS_TEXT), TRUE);
                        }
                    }

                    // fall thru...
                }

                case (IDC_ADVANCED_CUAS_ENABLE) :
                {
                    //
                    // Set the advanced tab change status to apply it.
                    //
                    g_bAdvChanged = TRUE;

                    PropSheet_Changed(GetParent(hDlg), hDlg);
                    break;
                }

                case (IDOK) :
                {
                    // fall thru...
                }
                case (IDCANCEL) :
                {
                    EndDialog(hDlg, TRUE);
                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }

        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inputdll\input.c ===
//
//  Include Files.
//

#include "input.h"
#include <cpl.h>
#include <commctrl.h>

#include "util.h"

//
//  Constant Declarations.
//

#define MAX_PAGES 3          // limit on the number of pages


//
//  Global Variables.
//

HANDLE g_hMutex = NULL;
TCHAR szMutexName[] = TEXT("TextInput_InputLocaleMutex");

HANDLE g_hEvent = NULL;
TCHAR szEventName[] = TEXT("TextInput_InputLocaleEvent");

HINSTANCE hInstance;
HINSTANCE hInstOrig;
HINSTANCE hInstRes;


//
//  Function Prototypes.
//

void
DoProperties(
    HWND hwnd,
    LPCTSTR pCmdLine);


////////////////////////////////////////////////////////////////////////////
//
//  LibMain
//
//  This routine is called from LibInit to perform any initialization that
//  is required.
//
////////////////////////////////////////////////////////////////////////////

BOOL APIENTRY LibMain(
    HANDLE hDll,
    DWORD dwReason,
    LPVOID lpReserved)
{
    switch (dwReason)
    {
        case ( DLL_PROCESS_ATTACH ) :
        {
            hInstance = hDll;
            hInstOrig = hInstance;

            //
            //  Create the mutex used for the Input Locale property page.
            //
            g_hMutex = CreateMutex(NULL, FALSE, szMutexName);
            g_hEvent = CreateEvent(NULL, TRUE, TRUE, szEventName);

            DisableThreadLibraryCalls(hDll);

            InitCommonControls();

            break;
        }
        case ( DLL_PROCESS_DETACH ) :
        {
            if (g_hMutex)
            {
                CloseHandle(g_hMutex);
            }
            if (g_hEvent)
            {
                CloseHandle(g_hEvent);
            }

            // Free XP SP1 resource instance if we loaded
            FreeCicResInstance();

            break;
        }

        case ( DLL_THREAD_DETACH ) :
        {
            break;
        }

        case ( DLL_THREAD_ATTACH ) :
        default :
        {
            break;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateGlobals
//
////////////////////////////////////////////////////////////////////////////

BOOL CreateGlobals()
{
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
//  DestroyGlobals
//
////////////////////////////////////////////////////////////////////////////

void DestroyGlobals()
{
}


////////////////////////////////////////////////////////////////////////////
//
//  CPlApplet
//
////////////////////////////////////////////////////////////////////////////

LONG CALLBACK CPlApplet(
    HWND hwnd,
    UINT Msg,
    LPARAM lParam1,
    LPARAM lParam2)
{
    switch (Msg)
    {
        case ( CPL_INIT ) :
        {
            //
            //  First message to CPlApplet(), sent once only.
            //  Perform all control panel applet initialization and return
            //  true for further processing.
            //
            return (CreateGlobals());
        }
        case ( CPL_GETCOUNT ) :
        {
            //
            //  Second message to CPlApplet(), sent once only.
            //  Return the number of control applets to be displayed in the
            //  control panel window.  For this applet, return 1.
            //
            return (1);
        }
        case ( CPL_INQUIRE ) :
        {
            //
            //  Third message to CPlApplet().
            //  It is sent as many times as the number of applets returned by
            //  CPL_GETCOUNT message.  Each applet must register by filling
            //  in the CPLINFO structure referenced by lParam2 with the
            //  applet's icon, name, and information string.  Since there is
            //  only one applet, simply set the information for this
            //  singular case.
            //
            LPCPLINFO lpCPlInfo = (LPCPLINFO)lParam2;

            lpCPlInfo->idIcon = CPL_DYNAMIC_RES;
            lpCPlInfo->idName = CPL_DYNAMIC_RES;
            lpCPlInfo->idInfo = CPL_DYNAMIC_RES;
            lpCPlInfo->lData  = 0;

            break;
        }
        case ( CPL_NEWINQUIRE ) :
        {
            //
            //  Third message to CPlApplet().
            //  It is sent as many times as the number of applets returned by
            //  CPL_GETCOUNT message.  Each applet must register by filling
            //  in the NEWCPLINFO structure referenced by lParam2 with the
            //  applet's icon, name, and information string.  Since there is
            //  only one applet, simply set the information for this
            //  singular case.
            //
            LPNEWCPLINFO lpNewCPlInfo = (LPNEWCPLINFO)lParam2;

            lpNewCPlInfo->dwSize = sizeof(NEWCPLINFO);
            lpNewCPlInfo->dwFlags = 0;
            lpNewCPlInfo->dwHelpContext = 0UL;
            lpNewCPlInfo->lData = 0;
            lpNewCPlInfo->hIcon = LoadIcon( hInstOrig,
                                            (LPCTSTR)MAKEINTRESOURCE(IDI_ICON) );
            LoadString(hInstance, IDS_NAME, lpNewCPlInfo->szName, 32);
            LoadString(hInstance, IDS_INFO, lpNewCPlInfo->szInfo, 64);
            lpNewCPlInfo->szHelpFile[0] = CHAR_NULL;

            break;
        }
        case ( CPL_SELECT ) :
        {
            //
            //  Applet has been selected, do nothing.
            //
            break;
        }
        case ( CPL_DBLCLK ) :
        {
            //
            //  Applet icon double clicked -- invoke property sheet with
            //  the first property sheet page on top.
            //
            DoProperties(hwnd, (LPCTSTR)NULL);
            break;
        }
        case ( CPL_STARTWPARMS ) :
        {
            //
            //  Same as CPL_DBLCLK, but lParam2 is a long pointer to
            //  a string of extra directions that are to be supplied to
            //  the property sheet that is to be initiated.
            //
            DoProperties(hwnd, (LPCTSTR)lParam2);
            break;
        }
        case ( CPL_STOP ) :
        {
            //
            //  Sent once for each applet prior to the CPL_EXIT msg.
            //  Perform applet specific cleanup.
            //
            break;
        }
        case ( CPL_EXIT ) :
        {
            //
            //  Last message, sent once only, before MMCPL.EXE calls
            //  FreeLibrary() on this DLL.  Do non-applet specific cleanup.
            //
            DestroyGlobals();
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  AddPage
//
////////////////////////////////////////////////////////////////////////////

void AddPage(
    LPPROPSHEETHEADER ppsh,
    UINT id,
    DLGPROC pfn,
    LPARAM lParam)
{
    if (ppsh->nPages < MAX_PAGES)
    {
        PROPSHEETPAGE psp;

        psp.dwSize = sizeof(psp);
        psp.dwFlags = PSP_DEFAULT;
        psp.hInstance = GetCicResInstance(hInstance, id);
        psp.pszTemplate = MAKEINTRESOURCE(id);
        psp.pfnDlgProc = pfn;
        psp.lParam = lParam;

        ppsh->phpage[ppsh->nPages] = CreatePropertySheetPage(&psp);
        if (ppsh->phpage[ppsh->nPages])
        {
            ppsh->nPages++;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  DoProperties
//
////////////////////////////////////////////////////////////////////////////

void DoProperties(
    HWND hwnd,
    LPCTSTR pCmdLine)
{
    HPROPSHEETPAGE rPages[MAX_PAGES];
    PROPSHEETHEADER psh;
    LPARAM lParam = 0;
    BOOL bQuit = FALSE;

    while (pCmdLine && *pCmdLine)
    {
        if (*pCmdLine == TEXT('/'))
        {
            switch (*++pCmdLine)
            {
                case ( TEXT('u') ) :
                case ( TEXT('U') ) :
                {
                    CheckInternatModule();

                    bQuit = TRUE;
                    break;
                }

                case ( TEXT('m') ) :
                case ( TEXT('M') ) :
                {
                    MigrateCtfmonFromWin9x(pCmdLine+2);
                    
                    bQuit = TRUE;
                    break;
                }

                default :
                {
                    break;
                }
            }
        }
        else if (*pCmdLine == TEXT(' '))
        {
            pCmdLine++;
        }
        else
        {
            break;
        }
    }

    if (bQuit)
        return;

    //
    //  See if there is a command line switch from Setup.
    //
    psh.nStartPage = 0;

    //
    //  Set up the property sheet information.
    //
    psh.dwSize = sizeof(psh);
    psh.dwFlags = 0;
    psh.hwndParent = hwnd;
    psh.hInstance = hInstance;
    psh.pszCaption = MAKEINTRESOURCE(IDS_NAME);
    psh.nPages = 0;
    psh.phpage = rPages;

    //
    //  Add the appropriate property pages.
    //
    AddPage(&psh, DLG_INPUT_LOCALES, InputLocaleDlgProc, lParam);
    AddPage(&psh, DLG_INPUT_ADVANCED, InputAdvancedDlgProc, lParam);

    //
    //  Make the property sheet.
    //
    PropertySheet(&psh);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inputdll\external.c ===
//
//  Include Files.
//

#include "input.h"
#include <regstr.h>
#include <shlapip.h>
#include "external.h"
#include "inputdlg.h"
#include "util.h"

#include "msctf.h"

// TM_LANGUAGEBAND is defined in "shell\inc\trayp.h"
#define TM_LANGUAGEBAND     WM_USER+0x105



typedef BOOL (WINAPI *PFNINVALIDASMCACHE)();


static const char c_szTF_InvalidAssemblyListCahgeIdExist[] = "TF_InvalidAssemblyListCacheIfExist";
void InvalidAssemblyListCacheIfExist()
{
    HINSTANCE hModCtf = LoadSystemLibrary(TEXT("msctf.dll"));
    PFNINVALIDASMCACHE pfn;
    if (!hModCtf)
        return;

    pfn = (PFNINVALIDASMCACHE)GetProcAddress(hModCtf, 
                                             c_szTF_InvalidAssemblyListCahgeIdExist);
    if (pfn)
        pfn();

    FreeLibrary(hModCtf);
}


////////////////////////////////////////////////////////////////////////////
//
//  LoadCtfmon
//
////////////////////////////////////////////////////////////////////////////

void LoadCtfmon(
    BOOL bLoad,
    LCID SysLocale,
    BOOL bDefUser)
{
    HWND hwndCTFMon;
    HKEY hkeyCtfmon;

    BOOL bMinLangBar = TRUE;

    //
    //  Get default system locale
    //
    if (!SysLocale)
        SysLocale = GetSystemDefaultLCID();

    if ((SysLocale == 0x0404) || (SysLocale == 0x0411) ||
        (SysLocale == 0x0412) || (SysLocale == 0x0804))
    {
        //
        //  Show language bar in case of FE system as a default
        //
        bMinLangBar = FALSE;
    }

    //
    //  Find language tool bar module(CTFMON.EXE)
    //
    hwndCTFMon = FindWindow(c_szCTFMonClass, NULL);

    if (!bDefUser)
    {
        if (RegCreateKey( HKEY_CURRENT_USER,
                          REGSTR_PATH_RUN,
                          &hkeyCtfmon ) != ERROR_SUCCESS)
        {
            hkeyCtfmon = NULL;
        }
    }
    else
    {
        if (RegCreateKey( HKEY_USERS,
                          c_szRunPath_DefUser,
                          &hkeyCtfmon ) != ERROR_SUCCESS)
        {
            hkeyCtfmon = NULL;
        }
    }

    //
    //  Update language band menu item to Taskbar
    //
    SetLanguageBandMenu(bLoad);

    if (bLoad)
    {
        BOOL bOSNT51 = IsOSPlatform(OS_NT51);

        if (IsSetupMode() || bDefUser)
        {
            DWORD dwShowStatus;

            if (!GetLangBarOption(&dwShowStatus, bDefUser))
            {
                if (bMinLangBar)
                {
                    if (bOSNT51)
                        SetLangBarOption(REG_LANGBAR_DESKBAND, bDefUser);
                    else
                        SetLangBarOption(REG_LANGBAR_MINIMIZED, bDefUser);
                }
                else
                {
                        SetLangBarOption(REG_LANGBAR_SHOWNORMAL, bDefUser);
                }
            }
        }

        if (!IsSetupMode() && IsInteractiveUserLogon() && !bDefUser)
        {
            HRESULT hr;
            DWORD dwTBFlag = 0;
            ITfLangBarMgr *pLangBar = NULL;

            //
            // Minimize language bar as a default setting.
            //
            hr = CoCreateInstance(&CLSID_TF_LangBarMgr,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  &IID_ITfLangBarMgr,
                                  (LPVOID *) &pLangBar);

            if (SUCCEEDED(hr))
            {
                pLangBar->lpVtbl->GetShowFloatingStatus(pLangBar, &dwTBFlag);

                //
                // Bug#519662 - Tablet PC set Language Bar UI as hidden status with
                // running ctfmon.exe module. So we want to show Language Bar UI again
                // if the current show status is hidden.
                //
                if (!IsWindow(hwndCTFMon) || (dwTBFlag & TF_SFT_HIDDEN))
                {
                    if (bMinLangBar)
                    {
                        if (bOSNT51)
                            pLangBar->lpVtbl->ShowFloating(pLangBar, TF_SFT_DESKBAND);
                        else
                            pLangBar->lpVtbl->ShowFloating(pLangBar, TF_SFT_MINIMIZED);
                    }
                    else
                    {
                       pLangBar->lpVtbl->ShowFloating(pLangBar, TF_SFT_SHOWNORMAL);
                    }
                }
                else if (dwTBFlag & TF_SFT_DESKBAND)
                {
                    pLangBar->lpVtbl->ShowFloating(pLangBar, dwTBFlag);
                }
            }

            if (pLangBar)
                pLangBar->lpVtbl->Release(pLangBar);


            //
            // Invalid Assembly Cahce before starting ctfmon.exe
            //
            InvalidAssemblyListCacheIfExist();

            //
            //  Run ctfmon.exe process
            //
            RunCtfmonProcess();

        }

        if (hkeyCtfmon)
        {
            TCHAR szCTFMonPath[MAX_PATH];

            GetCtfmonPath((LPTSTR) szCTFMonPath, ARRAYSIZE(szCTFMonPath));

            RegSetValueEx(hkeyCtfmon,
                          c_szCTFMon,
                          0,
                          REG_SZ,
                          (LPBYTE)szCTFMonPath,
                          (lstrlen(szCTFMonPath) + 1) * sizeof(TCHAR));

            //
            //  Clean up the registry for internat.
            //
            RegDeleteValue(hkeyCtfmon, c_szInternat);
        }
    }
    else
    {
        if (!bDefUser)
        {
            HRESULT hr;
            DWORD dwTBFlag = 0;
            ITfLangBarMgr *pLangBar = NULL;

            //
            // Minimize language bar as a default setting.
            //
            hr = CoCreateInstance(&CLSID_TF_LangBarMgr,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  &IID_ITfLangBarMgr,
                                  (LPVOID *) &pLangBar);

            if (SUCCEEDED(hr))
            {
                pLangBar->lpVtbl->GetShowFloatingStatus(pLangBar, &dwTBFlag);

                if (dwTBFlag & TF_SFT_DESKBAND)
                {
#if 0
                    HWND hwndTray = NULL;

                    //
                    //  Notify to shell to remove the language band from taskbar.
                    //
                    hwndTray = FindWindow(TEXT(WNDCLASS_TRAYNOTIFY), NULL);

                    if (hwndTray)
                    {
                        DWORD_PTR dwResult;
                        LRESULT lResult = (LRESULT)0;

                        lResult = SendMessageTimeout(hwndTray,
                                                     TM_LANGUAGEBAND,
                                                     0,
                                                     0,     // Remove band
                                                     SMTO_ABORTIFHUNG | SMTO_BLOCK,
                                                     5000,
                                                     &dwResult);
                    }
#else
                    pLangBar->lpVtbl->ShowFloating(pLangBar, TF_SFT_SHOWNORMAL);

                    //
                    //  Change back DeskBand setting into the registry
                    //
                    SetLangBarOption(REG_LANGBAR_DESKBAND, bDefUser);
#endif
                }
            }

            if (pLangBar)
                pLangBar->lpVtbl->Release(pLangBar);

            if (hwndCTFMon && IsWindow(hwndCTFMon))
            {
                //
                //  It's on, turn off the language tool bar.
                //
                PostMessage(hwndCTFMon, WM_CLOSE, 0L, 0L);
            }
        }

        if (hkeyCtfmon)
            RegDeleteValue(hkeyCtfmon, c_szCTFMon);
    }

    if (hkeyCtfmon)
    {
        RegCloseKey(hkeyCtfmon);
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  UpdateDefaultHotkey
//
////////////////////////////////////////////////////////////////////////////

void UpdateDefaultHotkey(
    LCID SysLocale,
    BOOL bThai,
    BOOL bDefaultUserCase)
{
    HKEY hKey;
    TCHAR szData[MAX_PATH];
    DWORD cbData;
    BOOL bHotKey = FALSE;
    BOOL bChinese = FALSE;
    BOOL bMe = FALSE;
    DWORD dwPrimLangID;

    dwPrimLangID = PRIMARYLANGID(LANGIDFROMLCID(SysLocale));

    if (PRIMARYLANGID(dwPrimLangID) == LANG_CHINESE)
    {
        bChinese = TRUE;
    }
    else if (dwPrimLangID == LANG_ARABIC || dwPrimLangID == LANG_HEBREW)
    {
        bMe = TRUE;
    }

    //
    //  Try to open the registry key
    //
    if (!bDefaultUserCase)
    {
        if (RegOpenKey( HKEY_CURRENT_USER,
                        c_szKbdToggleKey,
                        &hKey ) == ERROR_SUCCESS)
        {
            bHotKey = TRUE;
        }
    }
    else
    {
        if (RegOpenKey( HKEY_USERS,
                        c_szKbdToggleKey_DefUser,
                        &hKey ) == ERROR_SUCCESS)
        {
            bHotKey = TRUE;
        }
    }

    //
    //  If there is no hotkey switch, set it to Ctrl+Shift.  Otherwise, the
    //  user cannot switch to an IME without setting the value first.
    //
    szData[0] = TEXT('\0');
    if (bHotKey)
    {
        cbData = sizeof(szData);
        RegQueryValueEx( hKey,
                         TEXT("Hotkey"),
                         NULL,
                         NULL,
                         (LPBYTE)szData,
                         &cbData );

        switch (szData[0])
        {
            case TEXT('1'):
            {
                //
                //  Currently ALT/SHIFT or CTRL/SHIFT.  Do not change.
                //
                break;
            }
            case TEXT('2'):
            {
                //
                //  Change to 1 if Chinese.
                //
                if (bChinese)
                {
                    szData[0] = TEXT('1');
                    szData[1] = TEXT('\0');
                    RegSetValueEx( hKey,
                                   TEXT("Hotkey"),
                                   0,
                                   REG_SZ,
                                   (LPBYTE)szData,
                                   (DWORD)(lstrlen(szData) + 1) * sizeof(TCHAR) );
                }
                break;
            }
            case TEXT('3'):
            {
                //
                //  Default hotkey for FE locale switch.
                //
                szData[0] = bThai ? TEXT('4') : TEXT('1');
                szData[1] = TEXT('\0');
                RegSetValueEx( hKey,
                               TEXT("Hotkey"),
                               0,
                               REG_SZ,
                               (LPBYTE)szData,
                               (DWORD)(lstrlen(szData) + 1) * sizeof(TCHAR) );
                break;
            }
            case TEXT('4'):
            {
                //
                //  Currently Grave.  Change to 1 if not Thai.
                //
                if (!bThai)
                {
                    szData[0] = TEXT('1');
                    szData[1] = TEXT('\0');

                    RegSetValueEx( hKey,
                                   TEXT("Hotkey"),
                                   0,
                                   REG_SZ,
                                   (LPBYTE)szData,
                                   (DWORD)(lstrlen(szData) + 1) * sizeof(TCHAR) );
                }
                break;
            }
        }

        RegFlushKey(hKey);

        //
        //  Get updated hotkey value and copy the value to language hotkey
        //
        szData[0] = TEXT('\0');
        cbData = sizeof(szData);
        RegQueryValueEx( hKey,
                         TEXT("Hotkey"),
                         NULL,
                         NULL,
                         (LPBYTE)szData,
                         &cbData );

        if (szData[0])
        {
            RegSetValueEx( hKey,
                           TEXT("Language Hotkey"),
                           0,
                           REG_SZ,
                           (LPBYTE)szData,
                           (DWORD)(lstrlen(szData) + 1) * sizeof(TCHAR) );

            //
            //  Set Layout Hotkey
            //
            switch (szData[0])
            {
                case TEXT('1'):
                case TEXT('4'):
                {
                    szData[0] = bMe ? TEXT('3') : TEXT('2');
                    szData[1] = TEXT('\0');
                    break;
                }
                case TEXT('2'):
                {
                    szData[0] = TEXT('1');
                    szData[1] = TEXT('\0');
                    break;
                }
                case TEXT('3'):
                {
                    szData[0] = TEXT('3');
                    szData[1] = TEXT('\0');
                    break;
                }
            }
            RegSetValueEx( hKey,
                           TEXT("Layout Hotkey"),
                           0,
                           REG_SZ,
                           (LPBYTE)szData,
                           (DWORD)(lstrlen(szData) + 1) * sizeof(TCHAR) );

        }

        RegCloseKey(hKey);
    }
    else
    {
        BOOL bKeyCreated = FALSE;

        //
        //  Create the registry key
        //
        if (!bDefaultUserCase)
        {
            if (RegCreateKey( HKEY_CURRENT_USER,
                              c_szKbdToggleKey,
                              &hKey ) == ERROR_SUCCESS)
            {
                bKeyCreated = TRUE;
            }
        }
        else
        {
            if (RegCreateKey( HKEY_USERS,
                              c_szKbdToggleKey_DefUser,
                              &hKey ) == ERROR_SUCCESS)
            {
                bKeyCreated = TRUE;
            }
        }

        //
        //  We don't have a Toggle key yet.  Create one and set the
        //  correct value.
        //
        if (bKeyCreated)
        {
            szData[0] = bThai ? TEXT('4') : TEXT('1');
            szData[1] = 0;
            RegSetValueEx( hKey,
                           TEXT("Hotkey"),
                           0,
                           REG_SZ,
                           (LPBYTE)szData,
                           (DWORD)(lstrlen(szData) + 1) * sizeof(TCHAR) );

            RegSetValueEx( hKey,
                           TEXT("Language Hotkey"),
                           0,
                           REG_SZ,
                           (LPBYTE)szData,
                           (DWORD)(lstrlen(szData) + 1) * sizeof(TCHAR) );

            szData[0] = bMe ? TEXT('3') : TEXT('2');
            szData[1] = 0;
            RegSetValueEx( hKey,
                           TEXT("Layout Hotkey"),
                           0,
                           REG_SZ,
                           (LPBYTE)szData,
                           (DWORD)(lstrlen(szData) + 1) * sizeof(TCHAR) );

            RegFlushKey(hKey);
            RegCloseKey(hKey);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//   ClearHotkey
//
////////////////////////////////////////////////////////////////////////////

void ClearHotKey(
    BOOL bDefaultUserCase)
{
    HKEY hKey;
    DWORD cbData;
    TCHAR szData[MAX_PATH];
    BOOL bKeyCreated = FALSE;

    //
    //  Create the registry key
    //
    if (!bDefaultUserCase)
    {
        if (RegCreateKey( HKEY_CURRENT_USER,
                          c_szKbdToggleKey,
                          &hKey ) == ERROR_SUCCESS)
        {
            bKeyCreated = TRUE;
        }
    }
    else
    {
        if (RegCreateKey( HKEY_USERS,
                          c_szKbdToggleKey_DefUser,
                          &hKey ) == ERROR_SUCCESS)
        {
            bKeyCreated = TRUE;
        }
    }

    if (bKeyCreated)
    {
        szData[0] = TEXT('3');
        szData[1] = 0;

        RegSetValueEx( hKey,
                       TEXT("Hotkey"),
                       0,
                       REG_SZ,
                       (LPBYTE)szData,
                       (DWORD)(lstrlen(szData) + 1) * sizeof(TCHAR) );

        RegSetValueEx( hKey,
                       TEXT("Language Hotkey"),
                       0,
                       REG_SZ,
                       (LPBYTE)szData,
                       (DWORD)(lstrlen(szData) + 1) * sizeof(TCHAR) );

        RegSetValueEx( hKey,
                       TEXT("Layout Hotkey"),
                       0,
                       REG_SZ,
                       (LPBYTE)szData,
                       (DWORD)(lstrlen(szData) + 1) * sizeof(TCHAR) );

        RegFlushKey(hKey);
        RegCloseKey(hKey);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//   ActivateDefaultKeyboardLayout
//
//   Sets the default input layout on the system, and broadcast to all
//   running apps about this change.
//
////////////////////////////////////////////////////////////////////////////

BOOL ActivateDefaultKeyboardLayout(
    DWORD dwLocale,
    DWORD dwLayout,
    HKL hkl)
{
    BOOL bRet = FALSE;
    if (hkl)
    {
        if (SystemParametersInfo( SPI_SETDEFAULTINPUTLANG,
                                  0,
                                  (LPVOID)((LPDWORD) &hkl),
                                  0 ))
        {
            DWORD dwRecipients = BSM_APPLICATIONS | BSM_ALLDESKTOPS;
            BroadcastSystemMessage( BSF_POSTMESSAGE,
                                    &dwRecipients,
                                    WM_INPUTLANGCHANGEREQUEST,
                                    1,
                                    (LPARAM) hkl );
            bRet = TRUE;
        }
    }

    return bRet;
}


////////////////////////////////////////////////////////////////////////////
//
//  SetSystemDefautLayout
//
////////////////////////////////////////////////////////////////////////////

BOOL SetSystemDefautLayout(
    LCID Locale,
    DWORD dwLayout,
    HKL hklDefault,
    BOOL bDefaultUserCase )
{
    LONG rc;
    int iPreloadInx;
    BOOL bRet = FALSE;
    HKEY hKeyPreload,hKeySubst;
    TCHAR szSubValue[MAX_PATH];
    TCHAR szSubData[MAX_PATH];
    TCHAR szPreload[MAX_PATH];
    TCHAR szPreloadInx[MAX_PATH];
    DWORD dwLocale, dwIndex, cchSubValue, cbData;

    dwLocale = Locale;

    if (dwLayout == 0)
    {
        return (FALSE);
    }

    //
    //  Open the HKCU\Keyboard Layout\Preload key.
    //
    if (!bDefaultUserCase)
    {
        if (RegOpenKeyEx(HKEY_CURRENT_USER,
                         c_szKbdPreloadKey,
                         0,
                         KEY_ALL_ACCESS,
                         &hKeyPreload) != ERROR_SUCCESS)
        {
            return (FALSE);
        }
    }
    else
    {
        if (RegOpenKeyEx(HKEY_USERS,
                         c_szKbdPreloadKey_DefUser,
                         0,
                         KEY_ALL_ACCESS,
                         &hKeyPreload) != ERROR_SUCCESS)
        {
            return (FALSE);
        }
    }

    //
    //  Open the HKCU\Keyboard Layout\Substitutes key.
    //
    if (!bDefaultUserCase)
    {
        if (RegOpenKeyEx(HKEY_CURRENT_USER,
                         c_szKbdSubstKey,
                         0,
                         KEY_ALL_ACCESS,
                         &hKeySubst) != ERROR_SUCCESS)
        {
            RegCloseKey(hKeyPreload);
            return (FALSE);
        }
    }
    else
    {
        if (RegOpenKeyEx(HKEY_USERS,
                         c_szKbdSubstKey_DefUser,
                         0,
                         KEY_ALL_ACCESS,
                         &hKeySubst) != ERROR_SUCCESS)
        {
            RegCloseKey(hKeyPreload);
            return (FALSE);
        }
    }

    //
    //  Enumerate the values in the Preload key.
    //
    dwIndex = 0;
    cchSubValue = sizeof(szSubValue) / sizeof(TCHAR);
    cbData = sizeof(szSubData);
    rc = RegEnumValue( hKeySubst,
                       dwIndex,
                       szSubValue,
                       &cchSubValue,
                       NULL,
                       NULL,
                       (LPBYTE)szSubData,
                       &cbData );

    while (rc == ERROR_SUCCESS)
    {
        DWORD dwSubLayout;

        dwSubLayout = TransNum(szSubData);

        if (dwLayout == dwSubLayout)
        {
            dwLayout = TransNum(szSubValue);
            break;
        }

        //
        //  Get the next enum value.
        //
        dwIndex++;
        cchSubValue = sizeof(szSubValue) / sizeof(TCHAR);
        cbData = sizeof(szSubData);
        rc = RegEnumValue( hKeySubst,
                           dwIndex,
                           szSubValue,
                           &cchSubValue,
                           NULL,
                           NULL,
                           (LPBYTE)szSubData,
                           &cbData );

    }

    //
    //  Set default layout into preload section
    //
    iPreloadInx = 1;
    while(1)
    {
        DWORD dwCurLayout;
        DWORD dwFirstLayout;

        //
        //  See if there is a substitute value.
        //
        StringCchPrintf(szPreloadInx, ARRAYSIZE(szPreloadInx), TEXT("%d"), iPreloadInx);

        cbData = sizeof(szPreload);
        if (RegQueryValueEx(hKeyPreload,
                             szPreloadInx,
                             NULL,
                             NULL,
                             (LPBYTE)szPreload,
                             &cbData ) == ERROR_SUCCESS)
        {
            dwCurLayout = TransNum(szPreload);
        }
        else
        {
            break;
        }

        if (!dwCurLayout)
            break;

        if (iPreloadInx == 1)
            dwFirstLayout = dwCurLayout;

        if (dwCurLayout == dwLayout)
        {
            bRet = TRUE;
            if (iPreloadInx != 1)
            {
                //
                //  Set new default keyboard layout
                //
                StringCchPrintf(szPreloadInx, ARRAYSIZE(szPreloadInx), TEXT("%d"), 1);
                StringCchPrintf(szPreload, ARRAYSIZE(szPreload), TEXT("%08x"), dwCurLayout);
                RegSetValueEx( hKeyPreload,
                               szPreloadInx,
                               0,
                               REG_SZ,
                               (LPBYTE)szPreload,
                               (DWORD)(lstrlen(szPreload) + 1) * sizeof(TCHAR) );

                //
                //  Set old default keyboard layout
                //
                StringCchPrintf(szPreloadInx, ARRAYSIZE(szPreloadInx), TEXT("%d"), iPreloadInx);
                StringCchPrintf(szPreload, ARRAYSIZE(szPreload), TEXT("%08x"), dwFirstLayout);
                RegSetValueEx( hKeyPreload,
                               szPreloadInx,
                               0,
                               REG_SZ,
                               (LPBYTE)szPreload,
                               (DWORD)(lstrlen(szPreload) + 1) * sizeof(TCHAR) );

            }

            //
            //  Activate new default keyboard layout
            //
            ActivateDefaultKeyboardLayout(dwLocale, dwLayout, hklDefault);
            break;
        }

        iPreloadInx++;
    }

    //
    //  Refresh Preload section and close key.
    //
    RegFlushKey(hKeyPreload);
    RegCloseKey(hKeyPreload);
    RegCloseKey(hKeySubst);

    //
    //  Return success.
    //
    return (bRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetFETipStatus
//
////////////////////////////////////////////////////////////////////////////

BOOL SetFETipStatus(
    DWORD dwLayout,
    BOOL bEnable)
{
    HRESULT hr;
    BOOL bReturn = FALSE;
    BOOL bFound = FALSE;
    IEnumTfLanguageProfiles *pEnum;
    ITfInputProcessorProfiles *pProfiles = NULL;

    //
    // load Assembly list
    //
    hr = CoCreateInstance(&CLSID_TF_InputProcessorProfiles,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          &IID_ITfInputProcessorProfiles,
                          (LPVOID *) &pProfiles);

    if (FAILED(hr))
        return bReturn;

    //
    //  Enum all available languages
    //
    if (SUCCEEDED(pProfiles->lpVtbl->EnumLanguageProfiles(pProfiles, 0, &pEnum)))
    {
        TF_LANGUAGEPROFILE tflp;

        while (pEnum->lpVtbl->Next(pEnum, 1, &tflp, NULL) == S_OK)
        {
            HKL hklSub;

            if (!IsEqualGUID(&tflp.catid, &GUID_TFCAT_TIP_KEYBOARD))
            {
                continue;
            }

            hklSub = GetSubstituteHKL(&tflp.clsid,
                                      tflp.langid,
                                      &tflp.guidProfile);

            if (hklSub == IntToPtr(dwLayout))
            {
                hr = pProfiles->lpVtbl->EnableLanguageProfile(
                                              pProfiles,
                                              &tflp.clsid,
                                              tflp.langid,
                                              &tflp.guidProfile,
                                              bEnable);
                if (FAILED(hr))
                    goto Exit;

                bFound = TRUE;
            }

        }

        if (bFound)
            bReturn = TRUE;

Exit:
        pEnum->lpVtbl->Release(pEnum);
    }

    if (pProfiles)
        pProfiles->lpVtbl->Release(pProfiles);

    return bReturn;

}


////////////////////////////////////////////////////////////////////////////
//
//  InstallInputLayout
//
////////////////////////////////////////////////////////////////////////////

BOOL InstallInputLayout(
    LCID lcid,
    DWORD dwLayout,
    BOOL bDefLayout,
    HKL hklDefault,
    BOOL bDefUser,
    BOOL bSysLocale)
{
    LONG rc;
    LCID SysLocale;
    HKEY hKeySubst;
    HKEY hKeyPreload;
    BOOL bRet = FALSE;
    BOOL bThai = FALSE;
    BOOL bHasIME = FALSE;
    DWORD dwPreloadNum = 0;
    TCHAR szValue[MAX_PATH];
    TCHAR szData[MAX_PATH];
    TCHAR szData2[MAX_PATH];
    LPLAYOUTLIST pLayoutList = NULL;
    DWORD dwIndex, cchValue, cbData, cbData2;
    DWORD dwValue, dwData, dwData2, dwCtr, dwCtr2;
    DWORD dwNum = 1;                                             // Only support 1 layout installing
    HKL hklNew = 0;


    //
    //  Create the array to store the list of input locales.
    //
    pLayoutList = (LPLAYOUTLIST)LocalAlloc(LPTR, sizeof(LAYOUTLIST) * dwNum + 1);

    if (pLayoutList == NULL)
    {
        goto Exit;
    }

    //
    //  Currently support only one install layout list
    //
    pLayoutList[0].dwLocale = lcid;
    pLayoutList[0].dwLayout = dwLayout;

    if ((HIWORD(pLayoutList[0].dwLayout) & 0xf000) == 0xe000)
    {
        pLayoutList[0].bIME = TRUE;
    }

    //
    //  Open the HKCU\Keyboard Layout\Preload key.
    //
    if (!bDefUser)
    {
        if (RegOpenKeyEx( HKEY_CURRENT_USER,
                          c_szKbdPreloadKey,
                          0,
                          KEY_ALL_ACCESS,
                          &hKeyPreload ) != ERROR_SUCCESS)
        {
            goto Exit;
        }
    }
    else
    {
        if (RegOpenKeyEx( HKEY_USERS,
                          c_szKbdPreloadKey_DefUser,
                          0,
                          KEY_ALL_ACCESS,
                          &hKeyPreload ) != ERROR_SUCCESS)
        {
            goto Exit;
        }
    }

    //
    //  Open the HKCU\Keyboard Layout\Substitutes key.
    //
    if (!bDefUser)
    {
        if (RegOpenKeyEx( HKEY_CURRENT_USER,
                          c_szKbdSubstKey,
                          0,
                          KEY_ALL_ACCESS,
                          &hKeySubst ) != ERROR_SUCCESS)
        {
            RegCloseKey(hKeyPreload);
            goto Exit;
        }
    }
    else
    {
        if (RegOpenKeyEx( HKEY_USERS,
                          c_szKbdSubstKey_DefUser,
                          0,
                          KEY_ALL_ACCESS,
                          &hKeySubst ) != ERROR_SUCCESS)
        {
            RegCloseKey(hKeyPreload);
            goto Exit;
        }
    }

    //
    //  Enumerate the values in the Preload key.
    //
    dwIndex = 0;
    cchValue = sizeof(szValue) / sizeof(TCHAR);
    cbData = sizeof(szData);
    rc = RegEnumValue( hKeyPreload,
                       dwIndex,
                       szValue,
                       &cchValue,
                       NULL,
                       NULL,
                       (LPBYTE)szData,
                       &cbData );

    while (rc == ERROR_SUCCESS)
    {
        //
        //  Save the preload number if it's higher than the highest one
        //  found so far.
        //
        dwValue = TransNum(szValue);
        if (dwValue > dwPreloadNum)
        {
            dwPreloadNum = dwValue;
        }

        //
        //  Save the preload data - input locale.
        //
        dwValue = TransNum(szData);

        if (PRIMARYLANGID(LOWORD(dwValue)) == LANG_THAI)
        {
            bThai = TRUE;
        }

        //
        //  See if there is a substitute value.
        //
        dwData = 0;
        cbData2 = sizeof(szData2);
        if (RegQueryValueEx( hKeySubst,
                             szData,
                             NULL,
                             NULL,
                             (LPBYTE)szData2,
                             &cbData2 ) == ERROR_SUCCESS)
        {
            dwData = TransNum(szData2);
        }

        //
        //  Go through each of the requested input locales and make sure
        //  they don't already exist.
        //
        for (dwCtr = 0; dwCtr < dwNum; dwCtr++)
        {
            if (LOWORD(pLayoutList[dwCtr].dwLocale) == LOWORD(dwValue))
            {
                if (dwData)
                {
                    if (pLayoutList[dwCtr].dwLayout == dwData)
                    {
                        pLayoutList[dwCtr].bLoaded = TRUE;
                    }
                }
                else if (pLayoutList[dwCtr].dwLayout == dwValue)
                {
                    pLayoutList[dwCtr].bLoaded = TRUE;
                }

                //
                //  Save the highest 0xd000 value for this input locale.
                //
                if (pLayoutList[dwCtr].bIME == FALSE)
                {
                    dwData2 = (DWORD)(HIWORD(dwValue));
                    if (((dwData2 & 0xf000) != 0xe000) &&
                        (pLayoutList[dwCtr].dwSubst <= dwData2))
                    {
                        if (dwData2 == 0)
                        {
                            pLayoutList[dwCtr].dwSubst = 0xd000;
                        }
                        else if ((dwData2 & 0xf000) == 0xd000)
                        {
                            pLayoutList[dwCtr].dwSubst = dwData2 + 1;
                        }
                    }
                }
            }
        }

        //
        //  Get the next enum value.
        //
        dwIndex++;
        cchValue = sizeof(szValue) / sizeof(TCHAR);
        szValue[0] = TEXT('\0');
        cbData = sizeof(szData);
        szData[0] = TEXT('\0');
        rc = RegEnumValue( hKeyPreload,
                           dwIndex,
                           szValue,
                           &cchValue,
                           NULL,
                           NULL,
                           (LPBYTE)szData,
                           &cbData );
    }

    //
    //  Increase the maximum preload value by one so that it represents the
    //  next available value to use.
    //
    dwPreloadNum++;

    //
    //  Go through the list of layouts and add them.
    //
    for (dwCtr = 0; dwCtr < dwNum; dwCtr++)
    {
        if ((pLayoutList[dwCtr].bLoaded == FALSE) &&
            (IsValidLocale(pLayoutList[dwCtr].dwLocale, LCID_INSTALLED)) &&
            (IsValidLayout(pLayoutList[dwCtr].dwLayout)))
        {
            //
            //  Save the preload number as a string so that it can be
            //  written into the registry.
            //
            StringCchPrintf(szValue, ARRAYSIZE(szValue), TEXT("%d"), dwPreloadNum);

            if (PRIMARYLANGID(LOWORD(pLayoutList[dwCtr].dwLocale)) == LANG_THAI)
            {
                bThai = TRUE;
            }

            //
            //  Save the locale id as a string so that it can be written
            //  into the registry.
            //
            if (pLayoutList[dwCtr].bIME == TRUE)
            {
                StringCchPrintf(szData, ARRAYSIZE(szData), TEXT("%08x"), pLayoutList[dwCtr].dwLayout);
                bHasIME = TRUE;
            }
            else
            {
                //
                //  Get the 0xd000 value, if necessary.
                //
                if (dwCtr != 0)
                {
                    dwCtr2 = dwCtr;
                    do
                    {
                        dwCtr2--;
                        if ((pLayoutList[dwCtr2].bLoaded == FALSE) &&
                            (pLayoutList[dwCtr].dwLocale ==
                             pLayoutList[dwCtr2].dwLocale) &&
                            (pLayoutList[dwCtr2].bIME == FALSE))
                        {
                            dwData2 = pLayoutList[dwCtr2].dwSubst;
                            if (dwData2 == 0)
                            {
                                pLayoutList[dwCtr].dwSubst = 0xd000;
                            }
                            else
                            {
                                pLayoutList[dwCtr].dwSubst = dwData2 + 1;
                            }
                            break;
                        }
                    } while (dwCtr2 != 0);
                }

                //
                //  Save the locale id as a string.
                //
                dwData2 = pLayoutList[dwCtr].dwLocale;
                dwData2 |= (DWORD)(pLayoutList[dwCtr].dwSubst << 16);
                StringCchPrintf(szData, ARRAYSIZE(szData), TEXT("%08x"), dwData2);
            }

            //
            //  Set the value in the Preload section of the registry.
            //
            RegSetValueEx( hKeyPreload,
                           szValue,
                           0,
                           REG_SZ,
                           (LPBYTE)szData,
                           (DWORD)(lstrlen(szData) + 1) * sizeof(TCHAR) );

            //
            //  Increment the preload value.
            //
            dwPreloadNum++;

            //
            //  See if we need to add a substitute for this input locale.
            //
            if (((pLayoutList[dwCtr].dwLocale != pLayoutList[dwCtr].dwLayout) ||
                 (pLayoutList[dwCtr].dwSubst != 0)) &&
                (pLayoutList[dwCtr].bIME == FALSE))
            {
                StringCchPrintf(szData2, ARRAYSIZE(szData2), TEXT("%08x"), pLayoutList[dwCtr].dwLayout);
                RegSetValueEx( hKeySubst,
                               szData,
                               0,
                               REG_SZ,
                               (LPBYTE)szData2,
                               (DWORD)(lstrlen(szData) + 1) * sizeof(TCHAR) );
            }

            //
            //  Make sure all of the changes are written to disk.
            //
            RegFlushKey(hKeySubst);
            RegFlushKey(hKeyPreload);

            //
            //  Load the keyboard layout.
            //  If it fails, there isn't much we can do at this point.
            //
            hklNew = LoadKeyboardLayout(szData, KLF_SUBSTITUTE_OK | KLF_NOTELLSHELL);
        }
    }

    //
    //  Add FE TIPs if the current requested keyboard layout is the substitute
    //  keyboard layout of TIP.
    //
    if (((HIWORD(dwLayout) & 0xf000) == 0xe000) &&
        (PRIMARYLANGID(LOWORD(dwLayout)) != LANG_CHINESE))
    {
        BOOL bEnable = TRUE;

        SetFETipStatus(dwLayout, bEnable);
    }

    //
    //  Get default system locale
    //
    if (bSysLocale)
        SysLocale = lcid;
    else
        SysLocale = GetSystemDefaultLCID();


    //
    //  If there is an IME and there is no hotkey switch, set it to
    //  Ctrl+Shift.  Otherwise, the user cannot switch to an IME without
    //  setting the value first.
    //
    if (bHasIME || (dwPreloadNum > 2))
    {
        UpdateDefaultHotkey(
            SysLocale,
            (PRIMARYLANGID(LANGIDFROMLCID(SysLocale)) == LANG_THAI)
             && bThai,
            bDefUser);
    }

    //
    //  Update the taskbar indicator.
    //
    if (!IsDisableCtfmon() && dwPreloadNum > 2)
    {
        LoadCtfmon(TRUE, SysLocale, bDefUser);
    }

    //
    //  Close the registry keys.
    //
    RegCloseKey(hKeyPreload);
    RegCloseKey(hKeySubst);

    bRet = TRUE;

    //
    //  Update preload section with new default keyboard layout
    //
    if (bDefLayout)
    {
        TCHAR szDefLayout[MAX_PATH];

        StringCchPrintf(szDefLayout, ARRAYSIZE(szDefLayout), TEXT("%08x"), dwLayout);
        hklNew = LoadKeyboardLayout(szDefLayout, KLF_SUBSTITUTE_OK |
                                                 KLF_REPLACELANG |
                                                 KLF_NOTELLSHELL);

        if (hklNew)
            bRet = SetSystemDefautLayout(lcid, dwLayout, hklNew, bDefUser);
    }

Exit:
    if (pLayoutList)
        LocalFree(pLayoutList);

    return bRet;
}

////////////////////////////////////////////////////////////////////////////
//
//  UnInstallInputLayout
//
////////////////////////////////////////////////////////////////////////////

BOOL UnInstallInputLayout(
    LCID lcid,
    DWORD dwLayout,
    BOOL bDefUser)
{
    LCID SysLocale;
    HKEY hKeySubst;
    HKEY hKeyPreload;
    BOOL bHasSubst;
    DWORD cbData;
    DWORD dwCurLayout;
    UINT uMatch = 0;
    UINT uPreloadNum;
    UINT uPreloadInx = 1;
    BOOL bRet = FALSE;
    BOOL fReset = FALSE;
    BOOL bRemoveAllLang = FALSE;
    TCHAR szSubst[MAX_PATH];
    TCHAR szPreload[MAX_PATH];
    TCHAR szPreloadInx[MAX_PATH];


    //
    //  Remove all language layouts from system
    //
    if (lcid && dwLayout == 0)
    {
        bRemoveAllLang = TRUE;
        dwLayout = PRIMARYLANGID(LANGIDFROMLCID(lcid));
    }

    //
    //  Open the HKCU\Keyboard Layout\Preload key.
    //
    if (!bDefUser)
    {
        if (RegOpenKeyEx( HKEY_CURRENT_USER,
                          c_szKbdPreloadKey,
                          0,
                          KEY_ALL_ACCESS,
                          &hKeyPreload ) != ERROR_SUCCESS)
        {
            goto Exit;
        }
    }
    else
    {
        if (RegOpenKeyEx( HKEY_USERS,
                          c_szKbdPreloadKey_DefUser,
                          0,
                          KEY_ALL_ACCESS,
                          &hKeyPreload ) != ERROR_SUCCESS)
        {
            goto Exit;
        }
    }

    //
    //  Open the HKCU\Keyboard Layout\Substitutes key.
    //
    if (!bDefUser)
    {
        if (RegOpenKeyEx( HKEY_CURRENT_USER,
                          c_szKbdSubstKey,
                          0,
                          KEY_ALL_ACCESS,
                          &hKeySubst ) != ERROR_SUCCESS)
        {
            RegCloseKey(hKeyPreload);
            goto Exit;
        }
    }
    else
    {
        if (RegOpenKeyEx( HKEY_USERS,
                          c_szKbdSubstKey_DefUser,
                          0,
                          KEY_ALL_ACCESS,
                          &hKeySubst ) != ERROR_SUCCESS)
        {
            RegCloseKey(hKeyPreload);
            goto Exit;
        }
    }

    uPreloadInx = 1;

    //
    //  See if there is a substitute value.
    //
    StringCchPrintf(szPreloadInx, ARRAYSIZE(szPreloadInx), TEXT("%d"), uPreloadInx);

    cbData = sizeof(szPreload);
    while (RegQueryValueEx(hKeyPreload,
                         szPreloadInx,
                         NULL,
                         NULL,
                         (LPBYTE)szPreload,
                         &cbData ) == ERROR_SUCCESS)
    {
        dwCurLayout = TransNum(szPreload);

        //
        //  See if there is a substitute value.
        //
        bHasSubst = FALSE;
        cbData = sizeof(szSubst);
        if (RegQueryValueEx(hKeySubst,
                            szPreload,
                            NULL,
                            NULL,
                            (LPBYTE)szSubst,
                            &cbData) == ERROR_SUCCESS)
        {
            dwCurLayout = TransNum(szSubst);
            bHasSubst = TRUE;
        }

        if ((dwCurLayout == dwLayout) ||
            (bRemoveAllLang &&
             (PRIMARYLANGID(LANGIDFROMLCID(dwCurLayout)) == dwLayout)))
        {
            uPreloadInx++;
            StringCchPrintf(szPreloadInx, ARRAYSIZE(szPreloadInx), TEXT("%d"), uPreloadInx);

            uMatch++;
            fReset = TRUE;

            if (bHasSubst)
            {
                RegDeleteValue(hKeySubst, szPreload);
            }

            continue;
        }

        if (fReset && uMatch)
        {
            if (uPreloadInx <= uMatch)
            {
                goto Exit;
            }

            //
            //  Reordering the preload keyboard layouts
            //
            StringCchPrintf(szPreloadInx, ARRAYSIZE(szPreloadInx), TEXT("%d"), uPreloadInx - uMatch);
            StringCchPrintf(szPreload, ARRAYSIZE(szPreload), TEXT("%08x"), dwCurLayout);

            RegSetValueEx(hKeyPreload,
                          szPreloadInx,
                          0,
                          REG_SZ,
                          (LPBYTE)szPreload,
                          (DWORD)(lstrlen(szPreload) + 1) * sizeof(TCHAR));

        }

        uPreloadInx++;
        StringCchPrintf(szPreloadInx, ARRAYSIZE(szPreloadInx), TEXT("%d"), uPreloadInx);

    }

    uPreloadNum = uPreloadInx - uMatch;

    while (fReset && uMatch && uPreloadInx)
    {
        if (uPreloadInx <= uMatch || (uPreloadInx - uMatch) <= 1)
            goto Exit;

        //
        //  Uninstall the specified keyboard layout
        //
        StringCchPrintf(szPreloadInx, ARRAYSIZE(szPreloadInx), TEXT("%d"), uPreloadInx - uMatch);

        RegDeleteValue(hKeyPreload, szPreloadInx);

        uMatch--;
    }

    //
    //  Close the registry keys.
    //
    RegCloseKey(hKeyPreload);
    RegCloseKey(hKeySubst);

#if 0
    if (hklUnload)
    {
        //
        //  Get the active keyboard layout list from the system.
        //
        if (!SystemParametersInfo(SPI_GETDEFAULTINPUTLANG,
                                  0,
                                  &hklDefault,
                                  0 ))
        {
            hklDefault = GetKeyboardLayout(0);
        }

        if (hklUnload == hklDefault)
        {
            if (!SystemParametersInfo( SPI_SETDEFAULTINPUTLANG,
                                       0,
                                       (LPVOID)((LPDWORD)&hklNewDefault),
                                       0 ))
            {
                goto Exit;
            }
            else
            {
                DWORD dwRecipients = BSM_APPLICATIONS | BSM_ALLDESKTOPS;
                BroadcastSystemMessage( BSF_POSTMESSAGE,
                                        &dwRecipients,
                                        WM_INPUTLANGCHANGEREQUEST,
                                        1,
                                        (LPARAM)hklNewDefault );
            }
        }

        UnloadKeyboardLayout(hklUnload);
    }
#endif

    //
    //  Add FE TIPs if the current requested keyboard layout is the substitute
    //  keyboard layout of TIP.
    //
    if (((HIWORD(dwLayout) & 0xf000) == 0xe000) &&
        (PRIMARYLANGID(LOWORD(dwLayout)) != LANG_CHINESE))
    {
        BOOL bEnable = FALSE;

        SetFETipStatus(dwLayout, bEnable);
    }

    //
    //  Get default system locale
    //
    SysLocale = GetSystemDefaultLCID();

    //
    //  Update the taskbar indicator.
    //
    if (uPreloadNum <= 2)
    {
        LoadCtfmon(FALSE, SysLocale, bDefUser);
        ClearHotKey(bDefUser);
    }


    bRet = TRUE;

Exit:
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inputdll\inputdlg.c ===
//
//  Include Files.
//

#include "input.h"
#include <shlobj.h>
#include <regstr.h>
#include <setupapi.h>
#include <immp.h>
#include <winuserp.h>
#include <winbasep.h>
#include <oleauto.h>

#include "inputdlg.h"
#include "msctf.h"
#include "msctfp.h"
#include "ctffunc.h"
#include "util.h"
#include "inputhlp.h"

#include "external.h"

#define IMAGEID_KEYBOARD        0
#define IMAGEID_SPEECH          1
#define IMAGEID_PEN             2
#define IMAGEID_TIPITEMS        3
#define IMAGEID_EXTERNAL        4
#define IMAGEID_SMARTTAG        5

#define TV_ITEM_TYPE_LANG       0x0001
#define TV_ITEM_TYPE_GROUP      0x0002
#define TV_ITEM_TYPE_KBD        0x0010
#define TV_ITEM_TYPE_SPEECH     0x0020
#define TV_ITEM_TYPE_PEN        0x0040
#define TV_ITEM_TYPE_TIP        0x0100
#define TV_ITEM_TYPE_EXTERNAL   0x0200
#define TV_ITEM_TYPE_SMARTTAG   0x0400

#define INPUT_TYPE_KBD          TV_ITEM_TYPE_KBD
#define INPUT_TYPE_PEN          TV_ITEM_TYPE_PEN
#define INPUT_TYPE_SPEECH       TV_ITEM_TYPE_SPEECH
#define INPUT_TYPE_TIP          TV_ITEM_TYPE_TIP
#define INPUT_TYPE_EXTERNAL     TV_ITEM_TYPE_EXTERNAL
#define INPUT_TYPE_SMARTTAG     TV_ITEM_TYPE_SMARTTAG

#define MAX_DUPLICATED_HKL      64

//
//  Context Help Ids.
//

static int aInputHelpIds[] =
{
    IDC_GROUPBOX1,            IDH_COMM_GROUPBOX,
    IDC_LOCALE_DEFAULT_TEXT,  IDH_INPUT_DEFAULT_LOCALE,
    IDC_LOCALE_DEFAULT,       IDH_INPUT_DEFAULT_LOCALE,
    IDC_GROUPBOX2,            IDH_COMM_GROUPBOX,
    IDC_INPUT_LIST_TEXT,      IDH_INPUT_LIST,
    IDC_INPUT_LIST,           IDH_INPUT_LIST,
    IDC_KBDL_ADD,             IDH_INPUT_ADD,
    IDC_KBDL_DELETE,          IDH_INPUT_DELETE,
    IDC_KBDL_EDIT,            IDH_INPUT_EDIT,
    IDC_GROUPBOX3,            IDH_COMM_GROUPBOX,
    IDC_TB_SETTING,           IDH_INPUT_TOOLBAR_SETTINGS,
    IDC_HOTKEY_SETTING,       IDH_INPUT_KEY_SETTINGS,
    0, 0
};

static int aToolbarSettingsHelpIds[] =
{
    IDC_GROUPBOX1,              IDH_COMM_GROUPBOX,
    IDC_TB_SHOWLANGBAR,         IDH_INPUT_SHOWLANGBAR,
    IDC_TB_HIGHTRANS,           IDH_INPUT_HIGH_TRANS,
    IDC_TB_EXTRAICON,           IDH_INPUT_EXTRAICON,
    IDC_TB_TEXTLABELS,          IDH_INPUT_TEXT_LABELS,
    0, 0
};

static int aLocaleKeysSettingsHelpIds[] =
{
    IDC_KBDL_CAPSLOCK_FRAME,    IDH_COMM_GROUPBOX,
    IDC_KBDL_CAPSLOCK,          IDH_INPUT_SETTINGS_CAPSLOCK,
    IDC_KBDL_SHIFTLOCK,         IDH_INPUT_SETTINGS_CAPSLOCK,
    IDC_KBDL_HOTKEY_FRAME,      IDH_COMM_GROUPBOX,
    IDC_KBDL_HOTKEY,            IDH_INPUT_SETTINGS_HOTKEY,
    IDC_KBDL_HOTKEY_SEQUENCE,   IDH_INPUT_SETTINGS_HOTKEY,
    IDC_KBDL_HOTKEY_LIST,       IDH_INPUT_SETTINGS_HOTKEY_LIST,
    IDC_KBDL_CHANGE_HOTKEY,     IDH_INPUT_SETTINGS_HOTKEY,
    0, 0
};

static int aLocaleAddHelpIds[] =
{
    IDC_KBDLA_LOCALE_TEXT,     IDH_INPUT_ADD_LOCALE,
    IDC_KBDLA_LOCALE,          IDH_INPUT_ADD_LOCALE,
    IDC_KBDLA_LAYOUT_TEXT,     IDH_INPUT_ADD_LAYOUT,
    IDC_KBDLA_LAYOUT,          IDH_INPUT_ADD_LAYOUT,
    IDC_PEN_TEXT,              IDH_INPUT_ADD_PEN,
    IDC_PEN_TIP,               IDH_INPUT_ADD_PEN,
    IDC_SPEECH_TEXT,           IDH_INPUT_ADD_SPEECH,
    IDC_SPEECH_TIP,            IDH_INPUT_ADD_SPEECH,
    0, 0
};

static int aLocaleHotkeyHelpIds[] =
{
    IDC_GROUPBOX1,             IDH_COMM_GROUPBOX,
    IDC_KBDLH_LANGHOTKEY,      IDH_INPUT_LANG_HOTKEY_CHANGE,
    IDC_KBDLH_SHIFT,           IDH_INPUT_LANG_HOTKEY_CHANGE,
    IDC_KBDLH_PLUS,            IDH_INPUT_LANG_HOTKEY_CHANGE,
    IDC_KBDLH_CTRL,            IDH_INPUT_LANG_HOTKEY_CHANGE,
    IDC_KBDLH_L_ALT,           IDH_INPUT_LANG_HOTKEY_CHANGE,
    IDC_KBDLH_LAYOUTHOTKEY,    IDH_INPUT_LANG_HOTKEY_CHANGE,
    IDC_KBDLH_SHIFT2,          IDH_INPUT_LANG_HOTKEY_CHANGE,
    IDC_KBDLH_PLUS2,           IDH_INPUT_LANG_HOTKEY_CHANGE,
    IDC_KBDLH_CTRL2,           IDH_INPUT_LANG_HOTKEY_CHANGE,
    IDC_KBDLH_L_ALT2,          IDH_INPUT_LANG_HOTKEY_CHANGE,
    IDC_KBDLH_GRAVE,           IDH_INPUT_LANG_HOTKEY_CHANGE,
    0, 0
};

static int aLayoutHotkeyHelpIds[] =
{
    IDC_KBDLH_LAYOUT_TEXT,     IDH_INPUT_LAYOUT_HOTKEY_CHANGE,
    IDC_KBDLH_LANGHOTKEY,      IDH_INPUT_LAYOUT_HOTKEY_CHANGE,
    IDC_KBDLH_SHIFT,           IDH_INPUT_LAYOUT_HOTKEY_CHANGE,
    IDC_KBDLH_CTRL,            IDH_INPUT_LAYOUT_HOTKEY_CHANGE,
    IDC_KBDLH_L_ALT,           IDH_INPUT_LAYOUT_HOTKEY_CHANGE,
    IDC_KBDLH_KEY_COMBO,       IDH_INPUT_LAYOUT_HOTKEY_CHANGE,
    0, 0
};


//
//  Global Variables.
//

HWND g_hDlg;
HWND g_hwndTV;

HTREEITEM g_hTVRoot;
HIMAGELIST g_hImageList;

UINT g_cTVItemSize = 0;

BOOL g_OSNT4 = FALSE;
BOOL g_OSNT5 = FALSE;
BOOL g_OSWIN95 = FALSE;

BOOL g_bAdvChanged = FALSE;

static BOOL g_bGetSwitchLangHotKey = TRUE;
static BOOL g_bCoInit = FALSE;

static DWORD g_dwPrimLangID = 0;
static UINT g_iThaiLayout = 0;
static BOOL g_bPenOrSapiTip = FALSE;
static BOOL g_bExtraTip = FALSE;

UINT g_iInputs = 0;
UINT g_iOrgInputs = 0;

WNDPROC g_lpfnTVWndProc = NULL;

TCHAR szPropHwnd[] = TEXT("PROP_HWND");
TCHAR szPropIdx[]  = TEXT("PROP_IDX");

TCHAR szDefault[DESC_MAX];
TCHAR szInputTypeKbd[DESC_MAX];
TCHAR szInputTypePen[DESC_MAX];
TCHAR szInputTypeSpeech[DESC_MAX];
TCHAR szInputTypeExternal[DESC_MAX];

HINSTANCE g_hShlwapi = NULL;

FARPROC pfnSHLoadRegUIString = NULL;

//
//  External Routines.
//

extern HWND g_hwndAdvanced;

extern void Region_RebootTheSystem();

extern BOOL Region_OpenIntlInfFile(HINF *phInf);

extern BOOL Region_CloseInfFile(HINF *phInf);

extern BOOL Region_ReadDefaultLayoutFromInf(
    LPTSTR pszLocale,
    LPDWORD pdwLocale,
    LPDWORD pdwLayout,
    LPDWORD pdwLocale2,
    LPDWORD pdwLayout2,
    HINF hIntlInf);

// For (_WIN32_WINNT >= 0x0500 from winuser.h
#define KLF_SHIFTLOCK       0x00010000
#define KLF_RESET           0x40000000
#define SM_IMMENABLED           82


////////////////////////////////////////////////////////////////////////////
//
// MarkSptipRemoved
//
// TRUE - mark the reg value as "removed", FALSE - delete the reg value
//
////////////////////////////////////////////////////////////////////////////

BOOL MarkSptipRemoved(BOOL bRemoved)
{
    //
    // SPTIP's private regentries for the use of detecting
    // whether user has removed profile
    //
    const TCHAR c_szProfileRemoved[] = TEXT("ProfileRemoved");
    const TCHAR c_szSapilayrKey[] = TEXT("SOFTWARE\\Microsoft\\CTF\\Sapilayr\\");
    HKEY hkey;
    long lRet = ERROR_SUCCESS;
    DWORD dw = bRemoved ? 1 : 0;

    if (ERROR_SUCCESS ==
        RegCreateKey(HKEY_CURRENT_USER, c_szSapilayrKey, &hkey))
    {
        lRet = RegSetValueEx(hkey, c_szProfileRemoved, 0,
                      REG_DWORD, (LPBYTE)&dw, sizeof(DWORD));

        RegCloseKey(hkey);
    }

    return lRet;
}

////////////////////////////////////////////////////////////////////////////
//
//  CompareStringTIP
//
////////////////////////////////////////////////////////////////////////////
int CompareStringTIP(LPTSTR lpStr1, LPTSTR lpStr2)
{
    if (g_bCHSystem)
    {
        TCHAR szTemp[MAX_PATH];
        UINT uSize1 = lstrlen(lpStr1);
        UINT uSize2 = lstrlen(lpStr2);
        UINT uSizeDef = lstrlen(szDefault);

        if (uSize1 == uSize2)
            return lstrcmp(lpStr1, lpStr2);

        if (uSize1 > uSizeDef)
        {
            if (lstrcmp(lpStr1 + uSize1 - uSizeDef, szDefault) == 0)
            {
                StringCchCopy(szTemp, ARRAYSIZE(szTemp), lpStr1);
                *(szTemp + uSize1 - uSizeDef) = TEXT('\0');

                return lstrcmp(szTemp, lpStr2);
            }
        }

        if (uSize2 > uSizeDef)
        {
            if (lstrcmp(lpStr2 + uSize2 - uSizeDef, szDefault) == 0)
            {
                StringCchCopy(szTemp, ARRAYSIZE(szTemp), lpStr2);
                *(szTemp + uSize2 - uSizeDef) = TEXT('\0');

                return lstrcmp(szTemp, lpStr1);
            }
        }
    }

    return lstrcmp(lpStr1, lpStr2);
}

////////////////////////////////////////////////////////////////////////////
//
//  Locale_ErrorMsg
//
//  Sound a beep and put up the given error message.
//
////////////////////////////////////////////////////////////////////////////

void Locale_ErrorMsg(
    HWND hwnd,
    UINT iErr,
    LPTSTR lpValue)
{
    TCHAR sz[DESC_MAX];
    TCHAR szString[DESC_MAX];

    //
    //  Sound a beep.
    //
    MessageBeep(MB_OK);

    //
    //  Put up the appropriate error message box.
    //
    if (LoadString(hInstance, iErr, sz, ARRAYSIZE(sz)))
    {
        //
        //  If the caller wants to display a message with a caller supplied
        //  value string, do it.
        //
        if (lpValue)
        {
            StringCchPrintf(szString, ARRAYSIZE(szString), sz, lpValue);
            MessageBox(hwnd, szString, NULL, MB_OK_OOPS);
        }
        else
        {
            MessageBox(hwnd, sz, NULL, MB_OK_OOPS);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  IsFELangID
//
////////////////////////////////////////////////////////////////////////////

BOOL IsFELangID(DWORD dwLangID)
{
    if ((dwLangID == 0x0404) || (dwLangID == 0x0411) ||
        (dwLangID == 0x0412) || (dwLangID == 0x0804))
    {
        return TRUE;
    }

    return FALSE;
}

////////////////////////////////////////////////////////////////////////////
//
//   IsUnregisteredFEDummyHKL
//
////////////////////////////////////////////////////////////////////////////

BOOL IsUnregisteredFEDummyHKL(HKL hkl)
{
    HKEY hKey;
    BOOL bRet = FALSE;
    TCHAR szFEDummyHKL[10];

    switch (LANGIDFROMLCID(hkl))
    {
        case 0x411: break;
        case 0x412: break;
        case 0x404: break;
        case 0x804: break;
        default:
           goto Exit;
    }

    if (HIWORD((DWORD)(UINT_PTR)hkl) != LOWORD((DWORD)(UINT_PTR)hkl))
    {
        goto Exit;
    }

    StringCchPrintf(szFEDummyHKL, ARRAYSIZE(szFEDummyHKL), TEXT("%08x"), LOWORD((DWORD)(UINT_PTR)hkl));

    //
    //  Now read all of preload hkl from the registry.
    //
    if (RegOpenKey(HKEY_CURRENT_USER, c_szKbdPreloadKey, &hKey) == ERROR_SUCCESS)
    {
        DWORD dwIndex;
        DWORD cchValue, cbData;
        LONG dwRetVal;
        TCHAR szValue[MAX_PATH];           // language id (number)
        TCHAR szData[MAX_PATH];            // language name

        dwIndex = 0;
        cchValue = sizeof(szValue) / sizeof(TCHAR);
        cbData = sizeof(szData);
        dwRetVal = RegEnumValue( hKey,
                                 dwIndex,
                                 szValue,
                                 &cchValue,
                                 NULL,
                                 NULL,
                                 (LPBYTE)szData,
                                 &cbData );

        if (dwRetVal != ERROR_SUCCESS)
        {
            RegCloseKey(hKey);
            return (FALSE);
        }


        //
        //  There is FE dummy hkl. we will skip this hkl if it is not loaded
        //  from Preload registry section.
        //
        bRet = TRUE;

        do
        {
            if (!lstrcmp(szFEDummyHKL, szData))
            {
                HKEY hSubKey;
                BOOL bSubHKL = FALSE;

                //
                //  Check substitute hkl.
                //
                if (RegOpenKey(HKEY_CURRENT_USER,
                               c_szKbdSubstKey,
                               &hSubKey) == ERROR_SUCCESS)
                {
                    if (RegQueryValueEx(hSubKey, szData,
                                        NULL, NULL,
                                        NULL, NULL)
                                              == ERROR_SUCCESS)
                    {
                        bSubHKL = TRUE;
                    }
                    RegCloseKey(hSubKey);

                    if (bSubHKL)
                        goto Next;
                }

                //
                //  Found dummy hkl from preload section, so we need to display
                //  this dummy hkl
                //
                bRet = FALSE;
                break;
            }

Next:
            dwIndex++;
            cchValue = sizeof(szValue) / sizeof(TCHAR);
            szValue[0] = TEXT('\0');
            cbData = sizeof(szData);
            szData[0] = TEXT('\0');
            dwRetVal = RegEnumValue( hKey,
                                     dwIndex,
                                     szValue,
                                     &cchValue,
                                     NULL,
                                     NULL,
                                     (LPBYTE)szData,
                                     &cbData );

        } while (dwRetVal == ERROR_SUCCESS);

        RegCloseKey(hKey);
    }

Exit:
    return bRet;
}


#ifdef _WIN64
//
//  Issue optimization for IA64 retail version case - related bug#361062
//
#pragma optimize("", off)
#endif // _WIN64

////////////////////////////////////////////////////////////////////////////
//
//  GetSubstituteHKL
//
////////////////////////////////////////////////////////////////////////////

HKL GetSubstituteHKL(REFCLSID rclsid, LANGID langid, REFGUID guidProfile)
{
    HKEY hkey;
    DWORD cb;
    HKL hkl = NULL;
    TCHAR szSubKeyPath[MAX_PATH];
    TCHAR szSubHKL[MAX_PATH];

    StringCchCopy(szSubKeyPath, ARRAYSIZE(szSubKeyPath), c_szCTFTipPath);

    StringFromGUID2(rclsid, (LPOLESTR) szSubKeyPath + lstrlen(szSubKeyPath), 100);

    StringCchCat(szSubKeyPath, ARRAYSIZE(szSubKeyPath), TEXT("\\"));
    StringCchCat(szSubKeyPath, ARRAYSIZE(szSubKeyPath), c_szLangProfileKey);
    StringCchCat(szSubKeyPath, ARRAYSIZE(szSubKeyPath), TEXT("\\"));
    StringCchPrintf(szSubKeyPath + lstrlen(szSubKeyPath),
                    ARRAYSIZE(szSubKeyPath) - lstrlen(szSubKeyPath),
                    TEXT("0x%08x"),
                    langid);
    StringCchCat(szSubKeyPath, ARRAYSIZE(szSubKeyPath), TEXT("\\"));

    StringFromGUID2(guidProfile, (LPOLESTR) szSubKeyPath + lstrlen(szSubKeyPath), 50);

    if (RegOpenKey(HKEY_LOCAL_MACHINE, szSubKeyPath, &hkey) == ERROR_SUCCESS)
    {
        cb = sizeof(szSubHKL);
        RegQueryValueEx(hkey, c_szSubstituteLayout, NULL, NULL, (LPBYTE)szSubHKL, &cb);
        RegCloseKey(hkey);

        if ((szSubHKL[0] == '0') && ((szSubHKL[1] == 'X') || (szSubHKL[1] == 'x')))
        {
            hkl = (HKL) IntToPtr(TransNum(szSubHKL+2));

            if (LOWORD(hkl) != langid)
                hkl = 0;
        }
    }
    return hkl;
}

#ifdef _WIN64
#pragma optimize("", on)
#endif // _WIN64

////////////////////////////////////////////////////////////////////////////
//
//  IsTipSubstituteHKL
//
////////////////////////////////////////////////////////////////////////////

BOOL IsTipSubstituteHKL(HKL hkl)
{
    UINT ctr;

    //
    //  Search substitute HKL of Tips.
    //
    for (ctr = 0; ctr < g_iTipsBuff; ctr++)
    {
        if (hkl == g_lpTips[ctr].hklSub)
        {
            return TRUE;
        }
    }
    return FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  IsEnabledTipOrMultiLayouts()
//
////////////////////////////////////////////////////////////////////////////

BOOL IsEnabledTipOrMultiLayouts()
{
    BOOL bRet = TRUE;

    if (g_iInputs < 2 && !g_iEnabledTips)
    {
        // No Tip and one layout, so diable turn off ctfmon UI.
        bRet = FALSE;
    }

    return bRet;
}


////////////////////////////////////////////////////////////////////////////
//
//  AddKbdLayoutOnKbdTip
//
////////////////////////////////////////////////////////////////////////////

void AddKbdLayoutOnKbdTip(HKL hkl, UINT iLayout)
{
    UINT ctr;

    //
    //  Search substitute HKL of Tips.
    //
    for (ctr = 0; ctr < g_iTipsBuff; ctr++)
    {

        if (hkl == g_lpTips[ctr].hklSub)
        {
            if (iLayout)
                g_lpTips[ctr].iLayout = iLayout;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  IsAvailableTip
//
////////////////////////////////////////////////////////////////////////////
BOOL IsTipAvailableForAdd(DWORD dwLangID)
{
    UINT ctr;

    //
    //  Search substitute HKL of Tips.
    //
    for (ctr = 0; ctr < g_iTipsBuff; ctr++)
    {
        if ((dwLangID == g_lpTips[ctr].dwLangID) &&
            !(g_lpTips[ctr].bEnabled))
        {
            if (g_lpTips[ctr].uInputType & INPUT_TYPE_SPEECH)
            {
                if (!(g_lpTips[ctr].fEngineAvailable))
                    continue;
            }

            return TRUE;
        }
    }

    return FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateImageIcons
//
////////////////////////////////////////////////////////////////////////////

void CreateImageIcons()
{
    HBITMAP hBmp;
    UINT flags = ILC_COLOR | ILC_MASK;
    HIMAGELIST hIml, hImlTmp;
    HICON hIcon = NULL;

    //
    //  Create the image list
    //
    g_hImageList = ImageList_Create( GetSystemMetrics(SM_CXSMICON),
                                     GetSystemMetrics(SM_CYSMICON),
                                     ILC_COLOR32 | ILC_MASK,
                                     0,
                                     0 );

    //
    //  Load the group icons of input type.
    //
    hIcon = LoadImage(hInstOrig,
                      MAKEINTRESOURCE(IDI_KEYBOARD),
                      IMAGE_ICON,
                      0,
                      0,
                      LR_DEFAULTCOLOR);

    ImageList_AddIcon(g_hImageList, hIcon);

    hIcon = LoadImage(hInstOrig,
                      MAKEINTRESOURCE(IDI_SPEECH),
                      IMAGE_ICON,
                      0,
                      0,
                      LR_DEFAULTCOLOR);

    ImageList_AddIcon(g_hImageList, hIcon);

    hIcon = LoadImage(hInstOrig,
                      MAKEINTRESOURCE(IDI_PEN),
                      IMAGE_ICON,
                      0,
                      0,
                      LR_DEFAULTCOLOR);

    ImageList_AddIcon(g_hImageList, hIcon);

    hIcon = LoadImage(GetCicResInstance(hInstOrig, IDI_TIPITEM),
                      MAKEINTRESOURCE(IDI_TIPITEM),
                      IMAGE_ICON,
                      0,
                      0,
                      LR_DEFAULTCOLOR);

    ImageList_AddIcon(g_hImageList, hIcon);

    hIcon = LoadImage(GetCicResInstance(hInstOrig, IDI_ICON),
                      MAKEINTRESOURCE(IDI_ICON),
                      IMAGE_ICON,
                      0,
                      0,
                      LR_DEFAULTCOLOR);

    ImageList_AddIcon(g_hImageList, hIcon);

    hIcon = LoadImage(GetCicResInstance(hInstOrig, IDI_SMARTTAG),
                      MAKEINTRESOURCE(IDI_SMARTTAG),
                      IMAGE_ICON,
                      0,
                      0,
                      LR_DEFAULTCOLOR);

    ImageList_AddIcon(g_hImageList, hIcon);

    // Associate the image list with the tree.
    hImlTmp = TreeView_SetImageList(g_hwndTV, g_hImageList, TVSIL_NORMAL);
    if (hImlTmp)
        ImageList_Destroy(hImlTmp);
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateLangIcon
//
////////////////////////////////////////////////////////////////////////////

HICON CreateLangIcon( HWND hwnd, UINT langID )
{
    HBITMAP  hbmColour;
    HBITMAP  hbmMono;
    HBITMAP  hbmOld;
    HICON    hicon = NULL;
    ICONINFO ii;
    RECT     rc;
    DWORD    rgbText;
    DWORD    rgbBk = 0;
    UINT     i;
    HDC      hdc;
    HDC      hdcScreen;
    //HBRUSH   hbr;
    LOGFONT  lf;
    HFONT    hfont;
    HFONT hfontOld;
    TCHAR szData[20];

    //
    //  Get the indicator by using the first 2 characters of the
    //  abbreviated language name.
    //
    if (GetLocaleInfo(MAKELCID(langID, SORT_DEFAULT),
                       LOCALE_SABBREVLANGNAME | LOCALE_NOUSEROVERRIDE,
                       szData,
                       ARRAYSIZE(szData)))

    {
        //
        //  Make Uppercase
        //
        if (g_OSWIN95)
        {
            szData[0] -= 0x20;
            szData[1] -= 0x20;
        }
        //
        //  Only use the first two characters.
        //
        szData[2] = TEXT('\0');
    }
    else
    {
        //
        //  Id wasn't found.  Use question marks.
        //
        szData[0] = TEXT('?');
        szData[1] = TEXT('?');
        szData[2] = TEXT('\0');
    }

    if(SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, 0))
    {
        if( (hfont = CreateFontIndirect(&lf)) )
        {
            UINT cxSmIcon = GetSystemMetrics( SM_CXSMICON );
            UINT cySmIcon = GetSystemMetrics( SM_CYSMICON );

            hdcScreen = GetDC(NULL);
            hdc       = CreateCompatibleDC(hdcScreen);
            hbmColour = CreateCompatibleBitmap(hdcScreen, cxSmIcon, cySmIcon);
            ReleaseDC( NULL, hdcScreen);
            if (hbmColour && hdc)
            {
                hbmMono = CreateBitmap(cxSmIcon, cySmIcon, 1, 1, NULL);
                if (hbmMono)
                {
                    hbmOld    = SelectObject( hdc, hbmColour);
                    rc.left   = 0;
                    rc.top    = 0;
                    rc.right  = cxSmIcon;
                    rc.bottom = cySmIcon;
        
                    rgbBk = SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
                    rgbText = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));

                    ExtTextOut(hdc,
                               rc.left,
                               rc.top,
                               ETO_OPAQUE,
                               &rc,
                               TEXT(""),
                               0,
                               NULL);


                    SelectObject( hdc, GetStockObject(DEFAULT_GUI_FONT));
                    hfontOld = SelectObject( hdc, hfont);
                    DrawText(hdc,
                             szData,
                             2,
                             &rc,
                             DT_CENTER | DT_VCENTER | DT_SINGLELINE);

                   if (g_bShowRtL)
                       MirrorBitmapInDC(hdc, hbmColour);

                    SelectObject( hdc, hbmMono);
                    PatBlt(hdc, 0, 0, cxSmIcon, cySmIcon, BLACKNESS);

                    ii.fIcon    = TRUE;
                    ii.xHotspot = 0;
                    ii.yHotspot = 0;
                    ii.hbmColor = hbmColour;
                    ii.hbmMask  = hbmMono;
                    hicon       = CreateIconIndirect(&ii);

                    SelectObject(hdc, hbmOld);
                    DeleteObject(hbmMono);
                    SelectObject(hdc, hfontOld);
                }
                DeleteObject(hbmColour);
                DeleteDC(hdc);
            }
            DeleteObject(hfont);
        }
    }

    return hicon;
}


////////////////////////////////////////////////////////////////////////////
//
// GetLanguageName
//
////////////////////////////////////////////////////////////////////////////

BOOL GetLanguageName(
    LCID lcid,
    LPTSTR lpLangName,
    UINT cchLangName)
{
    BOOL bRet = TRUE;

    if (g_OSWIN95)
    {
        if (!GetLocaleInfo(lcid,
                           LOCALE_SLANGUAGE,
                           lpLangName,
                           cchLangName))
        {
            LoadString(hInstance, IDS_LOCALE_UNKNOWN, lpLangName, cchLangName);
            bRet = FALSE;
        }
    }
    else
    {
        WCHAR wszLangName[MAX_PATH];

        if (!GetLocaleInfoW(lcid,
                           LOCALE_SLANGUAGE,
                           wszLangName,
                           ARRAYSIZE(wszLangName)))
        {
            LoadString(hInstance, IDS_LOCALE_UNKNOWN, lpLangName, cchLangName);
            bRet = FALSE;
        }
        else
        {
            StringCchCopy(lpLangName, cchLangName, wszLangName);
        }
    }

    return bRet;
}


////////////////////////////////////////////////////////////////////////////
//
// CreateTVItemNode
//
////////////////////////////////////////////////////////////////////////////

LPTVITEMNODE CreateTVItemNode(DWORD dwLangID)
{
    LPTVITEMNODE pTVItemNode;
    HANDLE hItemNode;

    //
    //  Create the new node.
    //
    if (!(pTVItemNode = (LPTVITEMNODE) LocalAlloc(LPTR, sizeof(TVITEMNODE))))
    {
        return (NULL);
    }

    g_cTVItemSize++;

    //
    //  Fill in the new node with the appropriate info.
    //
    pTVItemNode->dwLangID = dwLangID;
    pTVItemNode->bDefLang = FALSE;
    pTVItemNode->iIdxTips = -1;
    pTVItemNode->atmDefTipName = 0;
    pTVItemNode->atmTVItemName = 0;
    pTVItemNode->lParam = 0;

    //
    //  Return the pointer to the new node.
    //
    return (pTVItemNode);
}


////////////////////////////////////////////////////////////////////////////
//
//  RemoveTVItemNode
//
////////////////////////////////////////////////////////////////////////////

void RemoveTVItemNode(
    LPTVITEMNODE pTVItemNode)
{
    if (pTVItemNode)
    {
        if (pTVItemNode->uInputType & INPUT_TYPE_KBD)
        {
            int idxSel = -1;
            TCHAR szItemName[MAX_PATH * 2];
            HWND hwndDefList = GetDlgItem(g_hDlg, IDC_LOCALE_DEFAULT);

            GetLanguageName(MAKELCID(pTVItemNode->dwLangID, SORT_DEFAULT),
                            szItemName,
                            ARRAYSIZE(szItemName));

            StringCchCat(szItemName, ARRAYSIZE(szItemName), TEXT(" - "));

            GetAtomName(pTVItemNode->atmTVItemName,
                        szItemName + lstrlen(szItemName), MAX_PATH);

            idxSel = ComboBox_FindString(hwndDefList, 0, szItemName);

            if (idxSel != CB_ERR)
            {
                ComboBox_DeleteString(hwndDefList, idxSel);
            }
        }

        if (pTVItemNode->atmTVItemName)
            DeleteAtom(pTVItemNode->atmTVItemName);

        if (pTVItemNode->atmDefTipName)
            DeleteAtom(pTVItemNode->atmDefTipName);

        LocalFree(pTVItemNode);
        g_cTVItemSize--;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_AddToLinkedList
//
//  Adds an Input Locale to the main g_lpLang array.
//
////////////////////////////////////////////////////////////////////////////

LPLANGNODE Locale_AddToLinkedList(
    UINT idx,
    HKL hkl)
{
    LPINPUTLANG pInpLang = &g_lpLang[idx];
    LPLANGNODE pLangNode;
    LPLANGNODE pTemp;
    HANDLE hLangNode;

    //
    //  Create the new node.
    //
    if (!(hLangNode = LocalAlloc(LHND, sizeof(LANGNODE))))
    {
        return (NULL);
    }
    pLangNode = LocalLock(hLangNode);

    //
    //  Fill in the new node with the appropriate info.
    //
    pLangNode->wStatus = 0;
    pLangNode->iLayout = (UINT)(-1);
    pLangNode->hkl = hkl;
    pLangNode->hklUnload = hkl;
    pLangNode->iLang = idx;
    pLangNode->hLangNode = hLangNode;
    pLangNode->pNext = NULL;
    pLangNode->nIconIME = -1;

    //
    //  If an hkl is given, see if it's an IME.  If so, mark the status bit.
    //
    if ((hkl) && ((HIWORD(hkl) & 0xf000) == 0xe000))
    {
        pLangNode->wStatus |= LANG_IME;
    }

    //
    //  Put the new node in the list.
    //
    pTemp = pInpLang->pNext;
    if (pTemp == NULL)
    {
        pInpLang->pNext = pLangNode;
    }
    else
    {
        while (pTemp->pNext != NULL)
        {
            pTemp = pTemp->pNext;
        }
        pTemp->pNext = pLangNode;
    }

    //
    //  Increment the count.
    //
    pInpLang->iNumCount++;

    //
    //  Return the pointer to the new node.
    //
    return (pLangNode);
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_RemoveFromLinkedList
//
//  Removes a link from the linked list.
//
////////////////////////////////////////////////////////////////////////////

void Locale_RemoveFromLinkedList(
    LPLANGNODE pLangNode)
{
    LPINPUTLANG pInpLang;
    LPLANGNODE pPrev;
    LPLANGNODE pCur;
    HANDLE hCur;

    pInpLang = &g_lpLang[pLangNode->iLang];

    //
    //  Find the node in the list.
    //
    pPrev = NULL;
    pCur = pInpLang->pNext;

    while (pCur && (pCur != pLangNode))
    {
        pPrev = pCur;
        pCur = pCur->pNext;
    }

    if (pPrev == NULL)
    {
        if (pCur == pLangNode)
        {
            pInpLang->pNext = pCur->pNext;
        }
        else
        {
            pInpLang->pNext = NULL;
        }
    }
    else if (pCur)
    {
        pPrev->pNext = pCur->pNext;
    }

    //
    //  Remove the node from the list.
    //
    if (pCur)
    {
        hCur = pCur->hLangNode;
        LocalUnlock(hCur);
        LocalFree(hCur);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_GetImeHotKeyInfo
//
//  Initializes array for CHS/CHT specific IME related hotkey items.
//
////////////////////////////////////////////////////////////////////////////

int Locale_GetImeHotKeyInfo(
    HWND         hwnd,
    LPHOTKEYINFO *aImeHotKey)
{

    HWND       hwndTV = g_hwndTV;
    LPLANGNODE pLangNode;
    LANGID     LangID;
    int        ctr;
    BOOL       fCHS, fCHT;

    TV_ITEM tvItem;
    HTREEITEM hItem;
    HTREEITEM hLangItem;
    HTREEITEM hGroupItem;

    fCHS = fCHT = FALSE;
    ctr = 0;

    //
    //  Check if the CHS or CHT layouts are loaded.
    //
    tvItem.mask        = TVIF_HANDLE | TVIF_PARAM;

    for (hLangItem = TreeView_GetChild(hwndTV, g_hTVRoot) ;
        hLangItem != NULL ;
        hLangItem = TreeView_GetNextSibling(hwndTV, hLangItem))
    {
        for (hGroupItem = TreeView_GetChild(hwndTV, hLangItem);
             hGroupItem != NULL;
             hGroupItem = TreeView_GetNextSibling(hwndTV, hGroupItem))
        {
            for (hItem = TreeView_GetChild(hwndTV, hGroupItem);
                 hItem != NULL;
                 hItem = TreeView_GetNextSibling(hwndTV, hItem))
            {

                LPTVITEMNODE pTVItemNode;

                tvItem.hItem = hItem;
                if (TreeView_GetItem(hwndTV, &tvItem) && tvItem.lParam)
                {
                    pTVItemNode = (LPTVITEMNODE) tvItem.lParam;
                    pLangNode = (LPLANGNODE)pTVItemNode->lParam;

                    if (pLangNode == NULL)
                        continue;
                }
                else
                   continue;

                LangID = LOWORD(g_lpLayout[pLangNode->iLayout].dwID);

                if ( PRIMARYLANGID(LangID) == LANG_CHINESE )
                {
                   if ( SUBLANGID(LangID) == SUBLANG_CHINESE_SIMPLIFIED)
                      fCHS = TRUE;
                   else if ( SUBLANGID(LangID) == SUBLANG_CHINESE_TRADITIONAL )
                           fCHT = TRUE;
                }

                if (fCHS && fCHT)
                    break;
           }
        }
    }

    if ( (fCHS == TRUE)  && (fCHT == TRUE) )
    {
        // Both CHS and CHT IMEs are Loaded

        *aImeHotKey = g_aImeHotKeyCHxBoth;
        return(sizeof(g_aImeHotKeyCHxBoth) / sizeof(HOTKEYINFO) );
    }
    else
    {
        if ( fCHS == TRUE )
        {
          // only CHS IMEs are loaded

            *aImeHotKey = g_aImeHotKey0804;
            return (sizeof(g_aImeHotKey0804) / sizeof(HOTKEYINFO));
        }

        if ( fCHT == TRUE )
        {

          // Only CHT IMEs are loaded.

            *aImeHotKey = g_aImeHotKey0404;
            return (sizeof(g_aImeHotKey0404) / sizeof(HOTKEYINFO));
        }

    }

    // all other cases, No Chinese IME is loaded.

    *aImeHotKey=NULL;
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_EnumChildWndProc
//
//  disable all controls.
////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK Locale_EnumChildWndProc(HWND hwnd, LPARAM lParam)
{

    EnableWindow(hwnd, FALSE);
    ShowWindow(hwnd, SW_HIDE);

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//
//  Locale_EnablePane
//
//  The controls in "iControl" are the controls that get disabled if the
//  pane can't come up.
//
////////////////////////////////////////////////////////////////////////////

void Locale_EnablePane(
    HWND hwnd,
    BOOL bEnable,
    UINT DisableId)
{

    if (!bEnable)
    {
        if (DisableId == IDC_KBDL_DISABLED_2)
        {
            //
            //  Disable all controls.
            //
            EnumChildWindows(hwnd, (WNDENUMPROC)Locale_EnumChildWndProc, 0);

            ShowWindow(GetDlgItem(hwnd, IDC_KBDL_DISABLED_2), SW_SHOW);
            EnableWindow(GetDlgItem(hwnd, IDC_KBDL_DISABLED_2), TRUE);
        }
        else
        {
            if (!g_iEnabledTips)
            {
                //
                //  Disable all controls.
                //
                EnumChildWindows(hwnd, (WNDENUMPROC)Locale_EnumChildWndProc, 0);

                ShowWindow(GetDlgItem(hwnd, IDC_KBDL_DISABLED), SW_SHOW);
                EnableWindow(GetDlgItem(hwnd, IDC_KBDL_DISABLED), TRUE);
            }
            else
            {
                //
                //  Disable Add, Property, Hotkey and default language setting controls.
                //
                EnableWindow(GetDlgItem(hwnd, IDC_LOCALE_DEFAULT), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_KBDL_ADD), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_KBDL_EDIT), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_HOTKEY_SETTING), FALSE);
            }
        }
    }

    return;
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_KillPaneDialog
//
//  Processing for a WM_DESTROY message.
//
////////////////////////////////////////////////////////////////////////////

void Locale_KillPaneDialog(
    HWND hwnd)
{
    UINT ctr, iCount;
    HANDLE hCur;
    LPLANGNODE pCur;
    LPHOTKEYINFO aImeHotKey;

    TV_ITEM tvItem;
    HTREEITEM hLangItem;
    HTREEITEM hGroupItem;
    HTREEITEM hItem;
    LPTVITEMNODE pTVItemNode;

    HWND hwndTV = GetDlgItem(g_hDlg, IDC_INPUT_LIST);

    if (g_bCoInit)
        CoUninitialize();

    //
    //  Delete all hot key atoms and free up the hotkey arrays.
    //
    if (g_SwitchLangHotKey.atmHotKeyName)
    {
        DeleteAtom(g_SwitchLangHotKey.atmHotKeyName);
    }

    iCount = Locale_GetImeHotKeyInfo(hwnd, &aImeHotKey);
    for (ctr = 0; ctr < iCount; ctr++)
    {
        if (aImeHotKey[ctr].atmHotKeyName)
        {
            DeleteAtom(aImeHotKey[ctr].atmHotKeyName);
        }
    }

    for (ctr = 0; ctr < DSWITCH_HOTKEY_SIZE; ctr++)
    {
        if (g_aDirectSwitchHotKey[ctr].atmHotKeyName)
        {
            DeleteAtom(g_aDirectSwitchHotKey[ctr].atmHotKeyName);
        }
    }

    //
    //  Delete all TreeView node.
    //
    tvItem.mask        = TVIF_HANDLE | TVIF_PARAM;

    for (hLangItem = TreeView_GetChild(hwndTV, g_hTVRoot) ;
        hLangItem != NULL ;
        hLangItem = TreeView_GetNextSibling(hwndTV, hLangItem)
        )
    {
        for (hGroupItem = TreeView_GetChild(hwndTV, hLangItem);
             hGroupItem != NULL;
             hGroupItem = TreeView_GetNextSibling(hwndTV, hGroupItem))
        {
            for (hItem = TreeView_GetChild(hwndTV, hGroupItem);
                 hItem != NULL;
                 hItem = TreeView_GetNextSibling(hwndTV, hItem))
            {

                tvItem.hItem = hItem;
                if (TreeView_GetItem(hwndTV, &tvItem))
                {
                    pTVItemNode = (LPTVITEMNODE) tvItem.lParam;
                    RemoveTVItemNode(pTVItemNode);
                }
            }

            tvItem.hItem = hGroupItem;
            if (TreeView_GetItem(hwndTV, &tvItem))
            {
                pTVItemNode = (LPTVITEMNODE) tvItem.lParam;
                if (TreeView_GetItem(hwndTV, &tvItem))
                {
                    RemoveTVItemNode(pTVItemNode);
                    continue;
                }
            }

        }
        tvItem.hItem = hLangItem;
        if (TreeView_GetItem(hwndTV, &tvItem))
        {
            pTVItemNode = (LPTVITEMNODE) tvItem.lParam;
            RemoveTVItemNode(pTVItemNode);
        }
    }

#ifdef DEBUG
    if (g_cTVItemSize)
    {
        MessageBox(NULL, TEXT("Error is occurred during terminate window"), NULL, MB_OK);
    }
#endif

    //
    //  Delete all Language Name atoms and free the g_lpLang array.
    //
    for (ctr = 0; ctr < g_iLangBuff; ctr++)
    {
        if (g_lpLang[ctr].atmLanguageName)
        {
            DeleteAtom(g_lpLang[ctr].atmLanguageName);
        }

        pCur = g_lpLang[ctr].pNext;
        g_lpLang[ctr].pNext = NULL;
        while (pCur)
        {
            hCur = pCur->hLangNode;
            pCur = pCur->pNext;
            LocalUnlock(hCur);
            LocalFree(hCur);
        }
    }

    if (g_hImageList != NULL)
    {
        TreeView_SetImageList(hwndTV, NULL, TVSIL_NORMAL);
        ImageList_Destroy(g_hImageList);
    }
    LocalUnlock(g_hLang);
    LocalFree(g_hLang);

    //
    //  Delete all layout text and layout file atoms and free the
    //  g_lpLayout array.
    //
    for (ctr = 0; ctr < g_iLayoutBuff; ctr++)
    {
        if (g_lpLayout[ctr].atmLayoutText)
        {
            DeleteAtom(g_lpLayout[ctr].atmLayoutText);
        }
        if (g_lpLayout[ctr].atmLayoutFile)
        {
            DeleteAtom(g_lpLayout[ctr].atmLayoutFile);
        }
        if (g_lpLayout[ctr].atmIMEFile)
        {
            DeleteAtom(g_lpLayout[ctr].atmIMEFile);
        }
    }

    LocalUnlock(g_hLayout);
    LocalFree(g_hLayout);

    //
    //  Make sure the mutex is released.
    //
    if (g_hMutex)
    {
        ReleaseMutex(g_hMutex);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  SelectDefaultKbdLayoutAsBold
//
////////////////////////////////////////////////////////////////////////////

void SelectDefaultKbdLayoutAsBold(
    HWND hwndTV,
    HTREEITEM hTVItem)
{
    TV_ITEM tvItem;
    TCHAR szItemName[MAX_PATH];
    TCHAR szLayoutName[MAX_PATH];

    TreeView_SelectItem(hwndTV, hTVItem);

    tvItem.mask = TVIF_TEXT | TVIF_PARAM | TVIF_STATE;
    tvItem.hItem = hTVItem;
    tvItem.state = 0;
    tvItem.stateMask = TVIS_BOLD;
    tvItem.pszText = szItemName;
    tvItem.cchTextMax  = sizeof(szItemName) / sizeof(TCHAR);

    if (TreeView_GetItem(hwndTV, &tvItem))
    {
        LPTVITEMNODE pTVItemNode;

        pTVItemNode = (LPTVITEMNODE) tvItem.lParam;

        if (!pTVItemNode)
            return;

        if (g_bCHSystem)
        {
            GetAtomName(pTVItemNode->atmTVItemName, szLayoutName, ARRAYSIZE(szLayoutName));
            StringCchCat(szLayoutName, ARRAYSIZE(szLayoutName), szDefault);
            tvItem.pszText = szLayoutName;
        }

        tvItem.state |= TVIS_BOLD;

        SendMessage(hwndTV, TVM_SETITEM, 0, (LPARAM) &tvItem);
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  FindTVLangItem
//
////////////////////////////////////////////////////////////////////////////

HTREEITEM
FindTVLangItem(DWORD dwLangID, LPTSTR lpLangText)
{
    HWND hwndTV = GetDlgItem(g_hDlg, IDC_INPUT_LIST);

    TV_ITEM tvItem;
    HTREEITEM hLangItem;
    LPTVITEMNODE pTVLangNode;

    TCHAR szLangName[MAX_PATH];

    tvItem.mask = TVIF_TEXT | TVIF_HANDLE | TVIF_PARAM;
    tvItem.pszText     = szLangName;
    tvItem.cchTextMax  = sizeof(szLangName) / sizeof(TCHAR);

    for (hLangItem = TreeView_GetChild(hwndTV, g_hTVRoot) ;
        hLangItem != NULL ;
        hLangItem = TreeView_GetNextSibling(hwndTV, hLangItem)
        )
    {
        tvItem.hItem = hLangItem;
        if (TreeView_GetItem(hwndTV, &tvItem))
        {
            int iSize = lstrlen(lpLangText);

            pTVLangNode = (LPTVITEMNODE) tvItem.lParam;

            if (!pTVLangNode)
            {
                continue;
            }

            *(szLangName + min(iSize, tvItem.cchTextMax)) = TEXT('\0');

            if (!CompareStringTIP(szLangName, lpLangText) ||
                (dwLangID && (pTVLangNode->dwLangID == dwLangID)))
            {
                return hLangItem;
            }
        }
    }

    return NULL;
}


////////////////////////////////////////////////////////////////////////////
//
//  AddTreeViewItems
//
////////////////////////////////////////////////////////////////////////////

HTREEITEM AddTreeViewItems(
    UINT uItemType,
    LPTSTR lpLangText,
    LPTSTR lpGroupText,
    LPTSTR lpTipText,
    LPTVITEMNODE *ppTVItemNode)
{
    HTREEITEM hTVItem;
    HTREEITEM hTVItem2;
    HTREEITEM hItem;
    HTREEITEM hLangItem = NULL;
    HTREEITEM hGroupItem;
    TV_ITEM tvItem;
    TV_INSERTSTRUCT tvIns;

    HWND hwndTV = GetDlgItem(g_hDlg, IDC_INPUT_LIST);
    HWND hwndDefList = GetDlgItem(g_hDlg, IDC_LOCALE_DEFAULT);

    TCHAR szDefItem[MAX_PATH];
    TCHAR szLangName[ MAX_PATH ];
    LPTVITEMNODE pTVLangNode;
    LPTVITEMNODE pTVItemNode;
    BOOL bFoundLang = FALSE;
    BOOL bFindGroup = FALSE;

    LPLANGNODE pLangNode;

    pTVItemNode = *ppTVItemNode;

    if (!pTVItemNode)
        return NULL;


    // We only want to add an lang item if it is not already there.
    //
    
    tvItem.mask        = TVIF_HANDLE | TVIF_TEXT | TVIF_PARAM;
    tvItem.state       = 0;
    tvItem.stateMask   = 0;
    tvItem.pszText     = szLangName;
    tvItem.cchTextMax  = sizeof(szLangName) / sizeof(TCHAR);
    
    for (hItem = TreeView_GetChild(hwndTV, g_hTVRoot) ;
        hItem != NULL ;
        hItem = TreeView_GetNextSibling(hwndTV, hItem)
        )
    {
        tvItem.hItem = hItem;
        if (TreeView_GetItem(hwndTV, &tvItem))
        {
            pTVLangNode = (LPTVITEMNODE) tvItem.lParam;

            if (!pTVLangNode)
            {
                continue;
            }

            if (pTVLangNode->dwLangID == pTVItemNode->dwLangID)
            {
                // We found a match!
                //
                hLangItem = hItem;
                bFoundLang = TRUE;

                if (!pTVLangNode->atmDefTipName && pTVItemNode->atmDefTipName)
                {
                    TCHAR szDefTip[DESC_MAX];

                    GetAtomName(pTVItemNode->atmDefTipName, szDefTip, ARRAYSIZE(szDefTip));
                    pTVLangNode->atmDefTipName = AddAtom(szDefTip);
                }

                if (!(pTVLangNode->hklSub) && pTVItemNode->hklSub)
                    pTVLangNode->hklSub = pTVItemNode->hklSub;
            }
        }
    }


    if (bFoundLang && (uItemType & TV_ITEM_TYPE_LANG))
    {
        RemoveTVItemNode(pTVItemNode);
        *ppTVItemNode = NULL;
        return hItem;
    }


    tvItem.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM | TVIF_STATE;

    tvItem.lParam = (LPARAM) pTVItemNode;

    if (uItemType & TV_ITEM_TYPE_LANG)
    {
        HICON hIcon = NULL;
        int iImage;

        hIcon = CreateLangIcon(hwndTV, LOWORD(pTVItemNode->dwLangID));
        if (hIcon)
        {
            iImage = ImageList_AddIcon(g_hImageList, hIcon);
            tvItem.iImage = iImage;
            tvItem.iSelectedImage = iImage;
        }

        pTVItemNode->atmTVItemName = AddAtom(lpLangText);
        pTVItemNode->uInputType |= TV_ITEM_TYPE_LANG;

        tvItem.pszText = lpLangText;
        tvItem.cchTextMax  = sizeof(szLangName) / sizeof(TCHAR);

        tvIns.item = tvItem;
        tvIns.hInsertAfter = TVI_SORT;
        tvIns.hParent = g_hTVRoot;

        hTVItem = (HTREEITEM) SendMessage(hwndTV, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT) &tvIns);

        return hTVItem;
    }

    if (hLangItem == NULL)
        return NULL;

    // Find the group node of input type
    for (hGroupItem = TreeView_GetChild(hwndTV, hLangItem) ;
        hGroupItem != NULL ;
        hGroupItem = TreeView_GetNextSibling(hwndTV, hGroupItem)
        )
    {
        tvItem.hItem = hGroupItem;
        if (TreeView_GetItem(hwndTV, &tvItem))
        {
            if (!lstrcmp(tvItem.pszText, lpGroupText))
            {
                bFindGroup = TRUE;
                break;
            }
        }
    }


    tvItem.lParam = (LPARAM) pTVItemNode;
    pTVItemNode->uInputType |= uItemType;
    g_iInputs++;

    if (!bFindGroup)
    {
        LPTVITEMNODE pTVGroupNode;

        if (pTVItemNode->bNoAddCat)
        {
            pTVGroupNode = pTVItemNode;
        }
        else
        {
            if (!(pTVGroupNode = CreateTVItemNode(pTVItemNode->dwLangID)))
                return NULL;

            pTVGroupNode->dwLangID = pTVItemNode->dwLangID;
            pTVGroupNode->uInputType = pTVItemNode->uInputType | TV_ITEM_TYPE_GROUP;
            pTVGroupNode->atmTVItemName = AddAtom(lpTipText);
            tvItem.lParam = (LPARAM) pTVGroupNode;
        }

        tvItem.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM | TVIF_STATE;

        tvItem.state = 0;

        if (pTVItemNode->uInputType & TV_ITEM_TYPE_KBD)
        {
            tvItem.iImage = IMAGEID_KEYBOARD;
            tvItem.iSelectedImage = IMAGEID_KEYBOARD;
        }
        else if (pTVItemNode->uInputType & TV_ITEM_TYPE_PEN)
        {
            tvItem.iImage = IMAGEID_PEN;
            tvItem.iSelectedImage = IMAGEID_PEN;
        }
        else if (pTVItemNode->uInputType & TV_ITEM_TYPE_SPEECH)
        {
            tvItem.iImage = IMAGEID_SPEECH;
            tvItem.iSelectedImage = IMAGEID_SPEECH;
        }
        else if (pTVItemNode->uInputType & TV_ITEM_TYPE_SMARTTAG)
        {
            tvItem.iImage = IMAGEID_SMARTTAG;
            tvItem.iSelectedImage = IMAGEID_SMARTTAG;
        }
        else
        {
            tvItem.iImage = IMAGEID_EXTERNAL;
            tvItem.iSelectedImage = IMAGEID_EXTERNAL;
        }

        if (pTVItemNode->bNoAddCat)
            tvItem.pszText = lpTipText;
        else
            tvItem.pszText = lpGroupText;
        tvItem.cchTextMax = MAX_PATH;

        tvIns.item = tvItem;

        tvIns.hInsertAfter = TVI_SORT;
        tvIns.hParent = hLangItem;


        hGroupItem = (HTREEITEM) SendMessage(hwndTV, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT) &tvIns);

        hTVItem = TreeView_GetParent(hwndTV, hGroupItem);
        TreeView_Expand(hwndTV, hTVItem, TVE_EXPAND);

    }
 
    if (pTVItemNode->bNoAddCat)
        return hGroupItem;

    //
    //  Check layout name whether it is already added on the treeview.
    //
    for (hItem = TreeView_GetChild(hwndTV, hGroupItem);
         hItem != NULL;
         hItem = TreeView_GetNextSibling(hwndTV, hItem))
    {
        tvItem.hItem = hItem;
        if (TreeView_GetItem(hwndTV, &tvItem))
        {
            if (!CompareStringTIP(tvItem.pszText, lpTipText))
            {
                if (pTVItemNode->lParam)
                    Locale_RemoveFromLinkedList((LPLANGNODE)pTVItemNode->lParam);
                RemoveTVItemNode(pTVItemNode);
                return NULL;
            }
        }
    }


    pTVItemNode->atmTVItemName = AddAtom(lpTipText);

    tvItem.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM | TVIF_STATE;

    tvItem.state = 0;
    tvItem.stateMask = TVIS_BOLD;

    tvItem.iImage = IMAGEID_TIPITEMS;
    tvItem.iSelectedImage = IMAGEID_TIPITEMS;
    tvItem.lParam = (LPARAM) pTVItemNode;

    tvItem.pszText = lpTipText;
    tvItem.cchTextMax = MAX_PATH;

    tvIns.item = tvItem;

    tvIns.hInsertAfter = TVI_SORT;
    tvIns.hParent = hGroupItem;


    hTVItem = (HTREEITEM) SendMessage(hwndTV, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT) &tvIns);

    pLangNode = (LPLANGNODE)pTVItemNode->lParam;

    //
    //  Adding the available default setting languages
    //
    if ((pTVItemNode->uInputType == TV_ITEM_TYPE_KBD) ||
        (pTVItemNode->uInputType & (TV_ITEM_TYPE_KBD|TV_ITEM_TYPE_TIP) && pTVItemNode->hklSub))
    {
        StringCchCopy(szDefItem, ARRAYSIZE(szDefItem), lpLangText);
        StringCchCat(szDefItem, ARRAYSIZE(szDefItem), TEXT(" - "));
        StringCchCat(szDefItem, ARRAYSIZE(szDefItem), lpTipText);

        if (ComboBox_FindStringExact(hwndDefList, 0, szDefItem) == CB_ERR)
            ComboBox_AddString(hwndDefList, szDefItem);
    }

#if 0
    if (pTVItemNode->hklSub)
    {
        TV_ITEM tvItem2;

        tvItem2.mask = TVIF_HANDLE | TVIF_PARAM;

        if (tvItem2.hItem = FindTVLangItem(pTVItemNode->dwLangID, NULL))
        {
            if (TreeView_GetItem(hwndTV, &tvItem2) && tvItem2.lParam)
            {
                pTVItemNode = (LPTVITEMNODE) tvItem2.lParam;
                pLangNode = (LPLANGNODE)pTVItemNode->lParam;
            }
        }
    }
#endif

    if (pLangNode && (pLangNode->wStatus & LANG_DEFAULT))
    {
        //
        //  Select the default layout item as bold
        //
        SelectDefaultKbdLayoutAsBold(hwndTV, hTVItem);

        TreeView_Expand(hwndTV, hTVItem, TVE_EXPAND);

        tvItem.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM | TVIF_STATE;
        tvItem.hItem = hLangItem;
        tvItem.pszText     = szLangName;
        tvItem.cchTextMax  = sizeof(szLangName) / sizeof(TCHAR);

        if (TreeView_GetItem(hwndTV, &tvItem))
        {
            LPTVITEMNODE pTVLangItemNode;
            int idxSel = -1;

            StringCchCopy(szDefItem, ARRAYSIZE(szDefItem), lpLangText);
            StringCchCat(szDefItem, ARRAYSIZE(szDefItem), TEXT(" - "));
            StringCchCat(szDefItem, ARRAYSIZE(szDefItem), lpTipText);

            //
            //  Set the default locale selection.
            //
            //
            if ((idxSel = ComboBox_FindStringExact(hwndDefList, 0, szDefItem)) == CB_ERR)
            {
                //  Simply set the current selection to be the first entry
                //  in the list.
                //
                ComboBox_SetCurSel(hwndDefList, 0);
            }
            else
                ComboBox_SetCurSel(hwndDefList, idxSel);

            if (pTVLangItemNode = (LPTVITEMNODE) tvItem.lParam)
            {
                pTVLangItemNode->bDefLang = TRUE;
                pTVLangItemNode->atmDefTipName = AddAtom(lpTipText);
                tvItem.state |= TVIS_BOLD;
            }

            StringCchCopy(tvItem.pszText, tvItem.cchTextMax, lpLangText);

            //
            //  No more adding default description
            //
            //StringCchCat(tvItem.pszText, ARRAYSIZE(tvItem.cchTextMax), szDefault);

            SendMessage(hwndTV, TVM_SETITEM, 0, (LPARAM) &tvItem);

            TreeView_SelectSetFirstVisible(hwndTV, hLangItem);
        }
    }

    if (hTVItem2 = TreeView_GetParent(hwndTV, hTVItem))
        TreeView_Expand(hwndTV, hTVItem2, TVE_EXPAND);

    return hTVItem;

}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateDefaultTVLangItem
//
////////////////////////////////////////////////////////////////////////////

BOOL UpdateDefaultTVLangItem(
    DWORD dwLangID,
    LPTSTR lpDefTip,
    BOOL bDefLang,
    BOOL bSubhkl)
{
    HTREEITEM hItem;
    TV_ITEM tvItem;

    HWND hwndTV = GetDlgItem(g_hDlg, IDC_INPUT_LIST);

    TCHAR szLangName[ MAX_PATH ];
    LPTVITEMNODE pTVLangItemNode;


    tvItem.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM | TVIF_STATE;
    tvItem.pszText     = szLangName;
    tvItem.cchTextMax  = sizeof(szLangName) / sizeof(TCHAR);
    
    for (hItem = TreeView_GetChild(hwndTV, g_hTVRoot) ;
        hItem != NULL ;
        hItem = TreeView_GetNextSibling(hwndTV, hItem)
        )
    {
        tvItem.hItem = hItem;
        if (TreeView_GetItem(hwndTV, &tvItem))
        {
            pTVLangItemNode = (LPTVITEMNODE) tvItem.lParam;

            if (!pTVLangItemNode)
            {
                continue;
            }

            if (pTVLangItemNode->dwLangID == dwLangID)
            {
                // We found a match!
                //
                GetAtomName(pTVLangItemNode->atmTVItemName, szLangName, ARRAYSIZE(szLangName));

                if (pTVLangItemNode->atmDefTipName)
                    DeleteAtom(pTVLangItemNode->atmDefTipName);
                pTVLangItemNode->atmDefTipName = AddAtom(lpDefTip);

                if (bSubhkl &&
                    (pTVLangItemNode->lParam && pTVLangItemNode->hklSub))

                {
                     LPLANGNODE pLangNode = NULL;

                     if (pLangNode = (LPLANGNODE)pTVLangItemNode->lParam)
                     {
                         if (bDefLang)
                             pLangNode->wStatus |= (LANG_DEFAULT | LANG_DEF_CHANGE);
                         else if (pLangNode->wStatus & LANG_DEFAULT)
                             pLangNode->wStatus &= ~(LANG_DEFAULT | LANG_DEF_CHANGE);
                     }
                }

                tvItem.stateMask |= TVIS_BOLD;

                if (bDefLang)
                {
                    TreeView_SelectSetFirstVisible(hwndTV, hItem);

                    pTVLangItemNode->bDefLang = TRUE;
                    //
                    //  No more adding default description
                    //
                    //StringCchCat(szLangName, ARRAYSIZE(szLangName), szDefault);
                    tvItem.state |= TVIS_BOLD;
                }
                else
                {
                    pTVLangItemNode->bDefLang = FALSE;
                    tvItem.state &= ~TVIS_BOLD;
                }

                tvItem.pszText = szLangName;

                SendMessage(hwndTV, TVM_SETITEM, 0, (LPARAM) &tvItem);

                return TRUE;

            }
        }
    }

    return FALSE;

}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateLangKBDItemNode
//
////////////////////////////////////////////////////////////////////////////

BOOL UpdateLangKBDItemNode(
    HTREEITEM hLangItem,
    LPTSTR lpDefTip,
    BOOL bDefault)
{
    HWND hwndTV = GetDlgItem(g_hDlg, IDC_INPUT_LIST);

    BOOL fRet = FALSE;
    TV_ITEM tvItem;
    HTREEITEM hGroupItem;
    HTREEITEM hItem;

    LPTVITEMNODE pTVItemNode;
    LPLANGNODE pLangNode;


    TCHAR szItemName[ MAX_PATH ];
    TCHAR szLayoutName[ MAX_PATH ];

    tvItem.mask = TVIF_TEXT | TVIF_PARAM | TVIF_HANDLE | TVIF_STATE;
    tvItem.pszText     = szItemName;
    tvItem.cchTextMax  = sizeof(szItemName) / sizeof(TCHAR);
    

     for (hGroupItem = TreeView_GetChild(hwndTV, hLangItem);
          hGroupItem != NULL;
          hGroupItem = TreeView_GetNextSibling(hwndTV, hGroupItem))
     {
         for (hItem = TreeView_GetChild(hwndTV, hGroupItem);
              hItem != NULL;
              hItem = TreeView_GetNextSibling(hwndTV, hItem))
         {
             tvItem.hItem = hItem;
             if (TreeView_GetItem(hwndTV, &tvItem))
             {

                 if (!CompareStringTIP(tvItem.pszText, lpDefTip) &&
                     (pTVItemNode = (LPTVITEMNODE) tvItem.lParam))
                 {
                     GetAtomName(pTVItemNode->atmTVItemName, szLayoutName, ARRAYSIZE(szLayoutName));

                     tvItem.stateMask |= TVIS_BOLD;

                     if (bDefault)
                     {
                         pTVItemNode->bDefLang = TRUE;
                         tvItem.state |= TVIS_BOLD;

                         if (g_bCHSystem)
                             StringCchCat(szLayoutName, ARRAYSIZE(szLayoutName), szDefault);
                     }
                     else
                     {
                         pTVItemNode->bDefLang = FALSE;
                         tvItem.state &= ~TVIS_BOLD;
                     }

                     pLangNode = (LPLANGNODE)pTVItemNode->lParam;

                     if (pLangNode != NULL)
                     {
                         if (bDefault)
                             pLangNode->wStatus |= (LANG_DEFAULT | LANG_DEF_CHANGE);
                         else if (pLangNode->wStatus & LANG_DEFAULT)
                             pLangNode->wStatus &= ~(LANG_DEFAULT | LANG_DEF_CHANGE);
                     }

                     tvItem.pszText = szLayoutName;
                     SendMessage(hwndTV, TVM_SETITEM, 0, (LPARAM) &tvItem);

                     fRet = TRUE;
                     return fRet;
                 }
             }
         }
     }
     return fRet;
}



////////////////////////////////////////////////////////////////////////////
//
//  FindDefaultTipItem
//
////////////////////////////////////////////////////////////////////////////

HTREEITEM FindDefaultTipItem(
    DWORD dwLangID,
    LPTSTR lpDefTip)
{
    HWND hwndTV = GetDlgItem(g_hDlg, IDC_INPUT_LIST);

    TV_ITEM tvItem;
    HTREEITEM hLangItem;
    HTREEITEM hGroupItem;
    HTREEITEM hItem;
    LPTVITEMNODE pTVLangItemNode;

    TCHAR szLangName[MAX_PATH];


    tvItem.mask = TVIF_TEXT | TVIF_HANDLE | TVIF_PARAM;
    tvItem.pszText     = szLangName;
    tvItem.cchTextMax  = sizeof(szLangName) / sizeof(TCHAR);


    for (hLangItem = TreeView_GetChild(hwndTV, g_hTVRoot) ;
        hLangItem != NULL ;
        hLangItem = TreeView_GetNextSibling(hwndTV, hLangItem)
        )
    {
        for (hGroupItem = TreeView_GetChild(hwndTV, hLangItem);
             hGroupItem != NULL;
             hGroupItem = TreeView_GetNextSibling(hwndTV, hGroupItem))
        {
            for (hItem = TreeView_GetChild(hwndTV, hGroupItem);
                 hItem != NULL;
                 hItem = TreeView_GetNextSibling(hwndTV, hItem))
            {
                tvItem.hItem = hItem;
                if (TreeView_GetItem(hwndTV, &tvItem))
                {

                    pTVLangItemNode = (LPTVITEMNODE) tvItem.lParam;

                    if (!pTVLangItemNode)
                        continue;

                    if ((pTVLangItemNode->uInputType & INPUT_TYPE_KBD) &&
                        (pTVLangItemNode->dwLangID == dwLangID))
                    {
                        if (!CompareStringTIP(tvItem.pszText, lpDefTip) || lpDefTip == NULL)
                            return hItem;
                    }

                }
            }
        }
    }

    return NULL;
}



////////////////////////////////////////////////////////////////////////////
//
//  SetNextDefaultLayout
//
////////////////////////////////////////////////////////////////////////////

void SetNextDefaultLayout(
    DWORD dwLangID,
    BOOL bDefLang,
    LPTSTR lpNextTip,
    UINT cchNextTip)
{
    TV_ITEM tvItem;
    HTREEITEM hItem;
    LPLANGNODE pLangNode = NULL;
    LPTVITEMNODE pTVDefItemNode = NULL;

    hItem = FindDefaultTipItem(dwLangID, NULL);

    tvItem.hItem = hItem;
    tvItem.mask = TVIF_HANDLE | TVIF_PARAM;

    if (TreeView_GetItem(g_hwndTV, &tvItem) && tvItem.lParam)
    {
        pTVDefItemNode = (LPTVITEMNODE) tvItem.lParam;

        pLangNode = (LPLANGNODE)pTVDefItemNode->lParam;

        GetAtomName(pTVDefItemNode->atmTVItemName, lpNextTip, cchNextTip);

        if (bDefLang)
        {
            //
            //  Select the default layout item as bold
            //
            SelectDefaultKbdLayoutAsBold(g_hwndTV, hItem);
        }

        if (pLangNode && bDefLang)
            pLangNode->wStatus |= (LANG_DEFAULT | LANG_DEF_CHANGE);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  EnsureDefaultKbdLayout
//
////////////////////////////////////////////////////////////////////////////

void EnsureDefaultKbdLayout(UINT *nLocales)
{
    HWND hwndTV = GetDlgItem(g_hDlg, IDC_INPUT_LIST);

    TV_ITEM tvItem;
    HTREEITEM hLangItem;
    HTREEITEM hGroupItem;
    HTREEITEM hItem;
    LPTVITEMNODE pTVItemNode;
    LPLANGNODE pLangNode = NULL;
    BOOL bDefLayout = FALSE;

    tvItem.mask = TVIF_HANDLE | TVIF_PARAM;

    for (hLangItem = TreeView_GetChild(hwndTV, g_hTVRoot) ;
        hLangItem != NULL ;
        hLangItem = TreeView_GetNextSibling(hwndTV, hLangItem))
    {
        for (hGroupItem = TreeView_GetChild(hwndTV, hLangItem);
             hGroupItem != NULL;
             hGroupItem = TreeView_GetNextSibling(hwndTV, hGroupItem))
        {
            for (hItem = TreeView_GetChild(hwndTV, hGroupItem);
                 hItem != NULL;
                 hItem = TreeView_GetNextSibling(hwndTV, hItem))
            {
                (*nLocales)++;

                tvItem.hItem = hItem;
                if (TreeView_GetItem(hwndTV, &tvItem))
                {

                    pTVItemNode = (LPTVITEMNODE) tvItem.lParam;

                    if (!pTVItemNode)
                        continue;

                    pLangNode = (LPLANGNODE)pTVItemNode->lParam;

                    if (pLangNode == NULL &&
                        (pTVItemNode->uInputType & INPUT_TYPE_KBD) &&
                        pTVItemNode->hklSub)
                    {
                        if (tvItem.hItem = FindTVLangItem(pTVItemNode->dwLangID, NULL))
                        {
                            if (TreeView_GetItem(hwndTV, &tvItem) && tvItem.lParam)
                            {
                                pTVItemNode = (LPTVITEMNODE) tvItem.lParam;
                                pLangNode = (LPLANGNODE)pTVItemNode->lParam;
                            }
                        }
                    }

                    if (pLangNode == NULL)
                        continue;

                    if (!(pLangNode->wStatus & LANG_UNLOAD) &&
                        (pLangNode->wStatus & LANG_DEFAULT))
                    {
                        bDefLayout = TRUE;
                    }
                }
            }
        }
    }

    if (!bDefLayout)
    {
        LPTVITEMNODE pTVLangItemNode;

        for (hLangItem = TreeView_GetChild(hwndTV, g_hTVRoot) ;
            hLangItem != NULL ;
            hLangItem = TreeView_GetNextSibling(hwndTV, hLangItem))
        {
            tvItem.hItem = hLangItem;
            if (TreeView_GetItem(hwndTV, &tvItem))
            {

                pTVLangItemNode = (LPTVITEMNODE) tvItem.lParam;

                if (!pTVLangItemNode)
                    continue;

                if (pTVLangItemNode->bDefLang)
                {
                    for (hGroupItem = TreeView_GetChild(hwndTV, hLangItem);
                         hGroupItem != NULL;
                         hGroupItem = TreeView_GetNextSibling(hwndTV, hGroupItem))
                    {
                        for (hItem = TreeView_GetChild(hwndTV, hGroupItem);
                             hItem != NULL;
                             hItem = TreeView_GetNextSibling(hwndTV, hItem))
                        {
                            tvItem.hItem = hItem;
                            if (TreeView_GetItem(hwndTV, &tvItem))
                            {

                                pTVItemNode = (LPTVITEMNODE) tvItem.lParam;

                                if (!pTVItemNode)
                                    continue;

                                pLangNode = (LPLANGNODE)pTVItemNode->lParam;

                                if (pLangNode == NULL &&
                                    (pTVItemNode->uInputType & INPUT_TYPE_KBD) &&
                                    pTVItemNode->hklSub)
                                {
                                    if (tvItem.hItem = FindTVLangItem(pTVItemNode->dwLangID, NULL))
                                    {
                                        if (TreeView_GetItem(hwndTV, &tvItem) && tvItem.lParam)
                                        {
                                            pTVItemNode = (LPTVITEMNODE) tvItem.lParam;
                                            pLangNode = (LPLANGNODE)pTVItemNode->lParam;
                                        }
                                    }
                                }

                                if (pLangNode == NULL)
                                    continue;

                                if (!(pLangNode->wStatus & LANG_UNLOAD))
                                {
                                    pLangNode->wStatus |= LANG_DEFAULT;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    return;
}


////////////////////////////////////////////////////////////////////////////
//
//  FindTVItem
//
////////////////////////////////////////////////////////////////////////////

HTREEITEM FindTVItem(DWORD dwLangID, LPTSTR lpTipText)
{
    HWND hwndTV = GetDlgItem(g_hDlg, IDC_INPUT_LIST);

    TV_ITEM tvItem;
    HTREEITEM hItem;
    HTREEITEM hLangItem = NULL;
    HTREEITEM hGroupItem = NULL;
    LPTVITEMNODE pTVLangNode;
    TCHAR szLangName[ MAX_PATH ];


    tvItem.mask = TVIF_TEXT | TVIF_HANDLE | TVIF_PARAM;
    tvItem.pszText     = szLangName;
    tvItem.cchTextMax  = sizeof(szLangName) / sizeof(TCHAR);

    
    for (hItem = TreeView_GetChild(hwndTV, g_hTVRoot) ;
        hItem != NULL ;
        hItem = TreeView_GetNextSibling(hwndTV, hItem)
        )
    {
        tvItem.hItem = hItem;
        if (TreeView_GetItem(hwndTV, &tvItem))
        {
            pTVLangNode = (LPTVITEMNODE) tvItem.lParam;

            if (!pTVLangNode)
            {
                continue;
            }

            if (pTVLangNode->dwLangID == dwLangID)
            {
                hLangItem = hItem;
            }
        }
    }


    if (hLangItem && lpTipText)
    {
        for (hGroupItem = TreeView_GetChild(hwndTV, hLangItem);
             hGroupItem != NULL;
             hGroupItem = TreeView_GetNextSibling(hwndTV, hGroupItem))
        {
            for (hItem = TreeView_GetChild(hwndTV, hGroupItem);
                 hItem != NULL;
                 hItem = TreeView_GetNextSibling(hwndTV, hItem))
            {
                tvItem.hItem = hItem;
                if (TreeView_GetItem(hwndTV, &tvItem))
                {

                    if (!CompareStringTIP(tvItem.pszText, lpTipText))
                    {
                        return hItem;
                    }
                }
            }
        }

    }

    return NULL;
}


////////////////////////////////////////////////////////////////////////////
//
//   CheckButtons
//
////////////////////////////////////////////////////////////////////////////

void CheckButtons(
    HWND hwnd)
{
    TV_ITEM tvItem;
    UINT uInputType;
    HTREEITEM hTVItem;
    LPTVITEMNODE pTVItemNode;
    LPLANGNODE pLangNode = NULL;

    hTVItem = TreeView_GetSelection(g_hwndTV);

    if (!hTVItem)
        return;

    tvItem.hItem = hTVItem;
    tvItem.mask = TVIF_HANDLE | TVIF_PARAM;
    
    if (TreeView_GetItem(g_hwndTV, &tvItem) && tvItem.lParam)
    {
        if (!(pTVItemNode = (LPTVITEMNODE) tvItem.lParam))
            return;

        pLangNode = (LPLANGNODE)pTVItemNode->lParam;
        uInputType = pTVItemNode->uInputType;

        if ((uInputType & INPUT_TYPE_KBD) &&
            (g_iInputs >= 2))
        {
            EnableWindow(GetDlgItem(hwnd, IDC_KBDL_SET_DEFAULT), TRUE);
        }
        else
        {
            BOOL bKbdGroup = FALSE;

            if (uInputType & TV_ITEM_TYPE_LANG)
            {
                HTREEITEM hGroupItem;

                for (hGroupItem = TreeView_GetChild(g_hwndTV, hTVItem);
                     hGroupItem != NULL;
                     hGroupItem = TreeView_GetNextSibling(g_hwndTV, hGroupItem))
                {
                    tvItem.hItem = hGroupItem;
                    if (TreeView_GetItem(g_hwndTV, &tvItem))
                    {
                        LPTVITEMNODE pTVItemNode2;

                        if (!(pTVItemNode2 = (LPTVITEMNODE) tvItem.lParam))
                            return;

                        if (pTVItemNode2->uInputType & INPUT_TYPE_KBD)
                        {
                            bKbdGroup = TRUE;
                            break;
                        }
                    }
                }
            }

            if (bKbdGroup && (g_iInputs >= 2))
                EnableWindow(GetDlgItem(hwnd, IDC_KBDL_SET_DEFAULT), TRUE);
            else
                EnableWindow(GetDlgItem(hwnd, IDC_KBDL_SET_DEFAULT), FALSE);
        }

        if ((!g_bSetupCase) &&
            ((pLangNode &&
              (pLangNode->wStatus & LANG_IME) &&
              (pLangNode->wStatus & LANG_ORIGACTIVE) &&
              (uInputType == INPUT_TYPE_KBD) &&
              (GetSystemMetrics(SM_IMMENABLED))) ||
             ((uInputType & INPUT_TYPE_TIP) && !(uInputType & TV_ITEM_TYPE_GROUP))))
        {
            EnableWindow(GetDlgItem(hwnd, IDC_KBDL_EDIT), TRUE);
        }
        else
        {
            EnableWindow(GetDlgItem(hwnd, IDC_KBDL_EDIT), FALSE);
        }

        if (g_iInputs == 1)
        {
            EnableWindow(GetDlgItem(hwnd, IDC_KBDL_DELETE), FALSE);
            return;
        }
        else
        {
            EnableWindow(GetDlgItem(hwnd, IDC_KBDL_DELETE), TRUE);
        }

        if (uInputType & TV_ITEM_TYPE_LANG)
        {
            if (!TreeView_GetNextSibling(g_hwndTV, hTVItem) &&
                 !TreeView_GetPrevSibling(g_hwndTV, hTVItem))
            {
                EnableWindow(GetDlgItem(hwnd, IDC_KBDL_DELETE), FALSE);
            }

            return;
        }
        else if (uInputType & TV_ITEM_TYPE_GROUP)
        {
            if (uInputType & TV_ITEM_TYPE_KBD)
            {
                if (!TreeView_GetNextSibling(g_hwndTV, hTVItem) &&
                     !TreeView_GetPrevSibling(g_hwndTV, hTVItem))
                {
                    hTVItem = TreeView_GetParent(g_hwndTV, hTVItem);

                    if (!TreeView_GetNextSibling(g_hwndTV, hTVItem) &&
                         !TreeView_GetPrevSibling(g_hwndTV, hTVItem))
                    {
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDL_DELETE), FALSE);
                    }
                }
                else
                {
                    EnableWindow(GetDlgItem(hwnd, IDC_KBDL_DELETE), FALSE);
                }
            }

            return;
        }
        else if (uInputType & TV_ITEM_TYPE_KBD)
        {
            if (!TreeView_GetNextSibling(g_hwndTV, hTVItem) &&
                 !TreeView_GetPrevSibling(g_hwndTV, hTVItem))
            {
                hTVItem = TreeView_GetParent(g_hwndTV, hTVItem);

                if (!TreeView_GetNextSibling(g_hwndTV, hTVItem) &&
                     !TreeView_GetPrevSibling(g_hwndTV, hTVItem))
                {
                    hTVItem = TreeView_GetParent(g_hwndTV, hTVItem);

                    if (!TreeView_GetNextSibling(g_hwndTV, hTVItem) &&
                         !TreeView_GetPrevSibling(g_hwndTV, hTVItem))
                    {
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDL_DELETE), FALSE);
                    }
                }
                else
                {
                    EnableWindow(GetDlgItem(hwnd, IDC_KBDL_DELETE), FALSE);
                }
            }

            return;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumCiceroTips
//
////////////////////////////////////////////////////////////////////////////

BOOL EnumCiceroTips()
{

    ULONG ul;
    ULONG ulCnt;
    HRESULT hr;
    LPTIPS pTips;
    LANGID *plangid;
    UINT uInputType;
    BOOL bReturn = TRUE;
    BOOL bEnabledTip = FALSE;
    TCHAR szTipName[MAX_PATH];
    TCHAR szTipTypeName[MAX_PATH];
    IEnumTfLanguageProfiles *pEnum;
    ITfInputProcessorProfiles *pProfiles = NULL;
    ITfFnLangProfileUtil *pLangUtil = NULL;
    ITfCategoryMgr *pCategory = NULL;

    //
    //  initialize COM
    //
    if (CoInitialize(NULL) == S_OK)
        g_bCoInit = TRUE;
    else
        g_bCoInit = FALSE;

    //
    //  Check-up SAPI TIP registration.
    //
    hr = CoCreateInstance(&CLSID_SapiLayr,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          &IID_ITfFnLangProfileUtil,
                          (LPVOID *) &pLangUtil);
    if (SUCCEEDED(hr))
    {
        pLangUtil->lpVtbl->RegisterActiveProfiles(pLangUtil);
    }

    //
    // load Assembly list
    //
    hr = CoCreateInstance(&CLSID_TF_InputProcessorProfiles,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          &IID_ITfInputProcessorProfiles,
                          (LPVOID *) &pProfiles);

    if (FAILED(hr))
        return FALSE;

    //
    //  Create the new node.
    //
    if (!(g_hTips = (LPTIPS) LocalAlloc(LHND, ALLOCBLOCK * sizeof(TIPS))))
    {
        return FALSE;
    }

    g_nTipsBuffSize = ALLOCBLOCK;
    g_iTipsBuff = 0;
    g_lpTips = LocalLock(g_hTips);


    //
    //  Enum all available languages
    //
    if (SUCCEEDED(pProfiles->lpVtbl->EnumLanguageProfiles(pProfiles, 0, &pEnum)))
    {
        TF_LANGUAGEPROFILE tflp;
        CLSID clsid;
        GUID guidProfile;

        while (pEnum->lpVtbl->Next(pEnum, 1, &tflp, NULL) == S_OK)
        {
            BSTR bstr = NULL;
            BSTR bstr2 = NULL;
            LANGID langid = tflp.langid;
            BOOL bNoCategory = FALSE;

            hr = pProfiles->lpVtbl->GetLanguageProfileDescription(
                                                  pProfiles,
                                                  &tflp.clsid,
                                                  tflp.langid,
                                                  &tflp.guidProfile,
                                                  &bstr);

            if (FAILED(hr))
                continue;

            StringCchCopy(szTipName, ARRAYSIZE(szTipName), bstr);

            if (IsEqualGUID(&tflp.catid, &GUID_TFCAT_TIP_KEYBOARD))
            {
                StringCchCopy(szTipTypeName, ARRAYSIZE(szTipTypeName), szInputTypeKbd);
                uInputType = INPUT_TYPE_KBD;
            }
            else if (IsEqualGUID(&tflp.catid, &GUID_TFCAT_TIP_HANDWRITING))
            {
                StringCchCopy(szTipTypeName, ARRAYSIZE(szTipTypeName), szInputTypePen);
                uInputType = INPUT_TYPE_PEN;
            }
            else if (IsEqualGUID(&tflp.catid, &GUID_TFCAT_TIP_SPEECH))
            {
                StringCchCopy(szTipTypeName, ARRAYSIZE(szTipTypeName), szInputTypeSpeech);
                uInputType = INPUT_TYPE_SPEECH;
                bNoCategory = TRUE;
            }
            else
            {
                g_bExtraTip = TRUE;
                uInputType = INPUT_TYPE_EXTERNAL;

                if (pCategory == NULL)
                {
                    hr = CoCreateInstance(&CLSID_TF_CategoryMgr,
                                          NULL,
                                          CLSCTX_INPROC_SERVER,
                                          &IID_ITfCategoryMgr,
                                          (LPVOID *) &pCategory);

                    if (FAILED(hr))
                        return FALSE;
                }

                if (pCategory->lpVtbl->GetGUIDDescription(pCategory,
                                              &tflp.catid,
                                              &bstr2) == S_OK)
                {
                    StringCchCopy(szTipTypeName, ARRAYSIZE(szTipTypeName), bstr2);
                }
                else
                {
                    StringCchCopy(szTipTypeName, ARRAYSIZE(szTipTypeName), szInputTypeExternal);
                }

                if (IsEqualGUID(&tflp.catid, &GUID_TFCAT_TIP_SMARTTAG))
                {
                    bNoCategory = TRUE;
                    uInputType |= INPUT_TYPE_SMARTTAG;
                }
            }

            uInputType |= INPUT_TYPE_TIP;

            if (g_iTipsBuff + 1 == g_nTipsBuffSize)
            {
                HANDLE hTemp;

                LocalUnlock(g_hTips);
                g_nTipsBuffSize += ALLOCBLOCK;
                hTemp = LocalReAlloc(g_hTips,
                                     g_nTipsBuffSize * sizeof(TIPS),
                                     LHND);
                if (hTemp == NULL)
                    return FALSE;
                g_hTips = hTemp;
                g_lpTips = LocalLock(g_hTips);
            }

            g_lpTips[g_iTipsBuff].dwLangID = (DWORD) langid;
            g_lpTips[g_iTipsBuff].uInputType = uInputType;
            g_lpTips[g_iTipsBuff].atmTipText = AddAtom(szTipName);
            g_lpTips[g_iTipsBuff].clsid  = tflp.clsid;
            g_lpTips[g_iTipsBuff].guidProfile = tflp.guidProfile;
            g_lpTips[g_iTipsBuff].bNoAddCat = bNoCategory;

            if (pProfiles->lpVtbl->GetDefaultLanguageProfile(pProfiles,
                                                             langid,
                                                             &tflp.catid,
                                                             &clsid,
                                                             &guidProfile) == S_OK)
            {
                if (IsEqualGUID(&tflp.guidProfile, &guidProfile))
                    g_lpTips[g_iTipsBuff].bDefault = TRUE;
            }

            if (uInputType & INPUT_TYPE_KBD)
            {
                g_lpTips[g_iTipsBuff].hklSub = GetSubstituteHKL(&tflp.clsid,
                                                                tflp.langid,
                                                                &tflp.guidProfile);
            }

            pProfiles->lpVtbl->IsEnabledLanguageProfile(pProfiles,
                                                        &tflp.clsid,
                                                        tflp.langid,
                                                        &tflp.guidProfile,
                                                        &bEnabledTip);

            // we need a special care for speech here, because:
            //
            // - speech TIP uses -1 profile with disabled status
            //
            // - when a user start a session, either this control
            // panel or first Cicero app, it'll fire off setting up
            // per user profiles based on SR engines currently 
            // installed and available on the machine
            //
            // - speech TIP also fires off the logic when any SR
            // engines are added or removed
            //
            // to make this senario work, we have to check with 
            // speech TIP's ITfFnProfileUtil interface each time
            // we invoke "Add Input Language" dialog box.
            //
            if (pLangUtil && (uInputType & INPUT_TYPE_SPEECH))
                
            {
                BOOL fSpeechAvailable = FALSE;
                pLangUtil->lpVtbl->IsProfileAvailableForLang( pLangUtil,
                                                              langid, 
                                                              &fSpeechAvailable
                                                            );
                g_lpTips[g_iTipsBuff].fEngineAvailable = fSpeechAvailable;
            }

            //
            //  Enable pen and speech category adding options if user has the
            //  installed pen or speech items.
            //
            if ((!g_bPenOrSapiTip) &&
                ((uInputType & INPUT_TYPE_PEN) || g_lpTips[g_iTipsBuff].fEngineAvailable))
                g_bPenOrSapiTip = TRUE;

            if (bEnabledTip && langid)
            {
                TCHAR szLangName[MAX_PATH];
                LPTVITEMNODE pTVItemNode;
                LPTVITEMNODE pTVLangItemNode;

                GetLanguageName(MAKELCID(langid, SORT_DEFAULT),
                                szLangName,
                                ARRAYSIZE(szLangName));

                if (!(pTVLangItemNode = CreateTVItemNode(langid)))
                {
                    bReturn = FALSE;
                    break;
                }

                if (pTVLangItemNode->hklSub)
                    pTVLangItemNode->atmDefTipName = AddAtom(szTipName);

                AddTreeViewItems(TV_ITEM_TYPE_LANG,
                                 szLangName,
                                 NULL,
                                 NULL,
                                 &pTVLangItemNode);

                if (!(pTVItemNode = CreateTVItemNode(langid)))
                {
                    bReturn = FALSE;
                    break;
                }

                pTVItemNode->uInputType = uInputType;
                pTVItemNode->iIdxTips = g_iTipsBuff;
                pTVItemNode->clsid  = tflp.clsid;
                pTVItemNode->guidProfile = tflp.guidProfile;
                pTVItemNode->hklSub = g_lpTips[g_iTipsBuff].hklSub;
                pTVItemNode->bNoAddCat = g_lpTips[g_iTipsBuff].bNoAddCat;

                //
                //  Make sure the loading TIP substitute hkl
                //
                if (pTVItemNode->hklSub)
                {
                    TCHAR szSubhkl[10];
                    HKL hklNew;

                    StringCchPrintf(szSubhkl, ARRAYSIZE(szSubhkl), TEXT("%08x"), (DWORD)(UINT_PTR)pTVItemNode->hklSub);
                    hklNew = LoadKeyboardLayout(szSubhkl,
                                                 KLF_SUBSTITUTE_OK |
                                                  KLF_REPLACELANG |
                                                  KLF_NOTELLSHELL);
                    if (hklNew != pTVItemNode->hklSub)
                    {
                        pTVItemNode->hklSub = 0;
                        g_lpTips[g_iTipsBuff].hklSub = 0;
                    }
                }

                AddTreeViewItems(uInputType,
                                 szLangName,
                                 szTipTypeName,
                                 szTipName,
                                 &pTVItemNode);

                g_lpTips[g_iTipsBuff].bEnabled = TRUE;
                g_iEnabledTips++;

                if (uInputType & INPUT_TYPE_KBD)
                    g_iEnabledKbdTips++;
            }

            g_iTipsBuff++;

            if (bstr)
               SysFreeString(bstr);

            if (bstr2)
               SysFreeString(bstr2);
        }
        pEnum->lpVtbl->Release(pEnum);
    }

    if (pCategory)
        pCategory->lpVtbl->Release(pCategory);

    if (pLangUtil)
        pLangUtil->lpVtbl->Release(pLangUtil);

    if (pProfiles)
        pProfiles->lpVtbl->Release(pProfiles);

    return bReturn;
}


////////////////////////////////////////////////////////////////////////////
//
//  SaveLanguageProfileStatus
//
////////////////////////////////////////////////////////////////////////////

LRESULT SaveLanguageProfileStatus(
    BOOL bSave,
    int iIdxTip,
    HKL hklSub)
{
    HRESULT hr;
    UINT idx;
    int iIdxDef = -1;
    int iIdxDefTip = -1;
    ITfInputProcessorProfiles *pProfiles = NULL;

    //
    // load Assembly list
    //
    hr = CoCreateInstance(&CLSID_TF_InputProcessorProfiles,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          &IID_ITfInputProcessorProfiles,
                          (LPVOID *) &pProfiles);

    if (FAILED(hr))
        return S_FALSE;

    if (bSave)
    {
        ITfFnLangProfileUtil *pLangUtil = NULL;

        for (idx = 0; idx < g_iTipsBuff; idx++)
        {

            hr = pProfiles->lpVtbl->EnableLanguageProfile(
                                          pProfiles,
                                          &(g_lpTips[idx].clsid),
                                          (LANGID)g_lpTips[idx].dwLangID,
                                          &(g_lpTips[idx].guidProfile),
                                          g_lpTips[idx].bEnabled);
            if (FAILED(hr))
                goto Exit;
        }

        hr = CoCreateInstance(&CLSID_SapiLayr,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              &IID_ITfFnLangProfileUtil,
                              (LPVOID *) &pLangUtil);
        if (S_OK == hr)
        {
            pLangUtil->lpVtbl->RegisterActiveProfiles(pLangUtil);
            pLangUtil->lpVtbl->Release(pLangUtil);
        }
    }

    if (hklSub && iIdxTip != -1 && iIdxTip < (int)g_iTipsBuff)
    {
        BOOL bFound = FALSE;
        TCHAR szItem[MAX_PATH];
        TCHAR szDefLayout[MAX_PATH];
        HWND hwndDefList = GetDlgItem(g_hDlg, IDC_LOCALE_DEFAULT);

        //
        //  Get the current selection in the input locale list.
        //
        if ((iIdxDef = ComboBox_GetCurSel(hwndDefList)) != CB_ERR)
        {
            WCHAR *pwchar;

            SendMessage(hwndDefList, CB_GETLBTEXT, iIdxDef, (LPARAM)szItem);

            pwchar = wcschr(szItem, L'-');

            if (szItem < (pwchar - 1))
                *(pwchar - 1) = TEXT('\0');

            StringCchCopy(szDefLayout, ARRAYSIZE(szDefLayout), pwchar + 2);
        }

        GetAtomName(g_lpTips[iIdxTip].atmTipText, szItem, ARRAYSIZE(szItem));

        if (lstrcmp(szItem, szDefLayout) == 0)
        {
            iIdxDefTip = iIdxTip;
            bFound = TRUE;
        }
        else
        {
            for (idx = 0; idx < g_iTipsBuff; idx++)
            {
                 if (hklSub == g_lpTips[idx].hklSub)
                 {
                     GetAtomName(g_lpTips[idx].atmTipText,
                                 szItem,
                                 ARRAYSIZE(szItem));

                     if (lstrcmp(szItem, szDefLayout) == 0)
                     {
                         iIdxDefTip = idx;
                         bFound = TRUE;
                         break;
                     }

                 }
            }
        }

        if (bFound && iIdxDefTip != -1)
        {
            pProfiles->lpVtbl->SetDefaultLanguageProfile(
                                         pProfiles,
                                         (LANGID)g_lpTips[iIdxDefTip].dwLangID,
                                         &(g_lpTips[iIdxDefTip].clsid),
                                         &(g_lpTips[iIdxDefTip].guidProfile));
        }
    }

Exit:
    if (pProfiles)
        pProfiles->lpVtbl->Release(pProfiles);

    return hr;
}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateToolBarSetting
//
////////////////////////////////////////////////////////////////////////////

void UpdateToolBarSetting()
{
    HRESULT hr;

    ITfLangBarMgr *pLangBar = NULL;

    //
    // load LangBar manager
    //
    hr = CoCreateInstance(&CLSID_TF_LangBarMgr,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          &IID_ITfLangBarMgr,
                          (LPVOID *) &pLangBar);

    if (SUCCEEDED(hr))
        pLangBar->lpVtbl->ShowFloating(pLangBar, g_dwToolBar);

    if (pLangBar)
        pLangBar->lpVtbl->Release(pLangBar);
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_ApplyError
//
//  Put up the given error message with the language name in it.
//
//  NOTE: This error is NOT fatal - as we could be half way through the
//        list before an error occurs.  The registry will already have
//        some information and we should let them have what comes next
//        as well.
//
////////////////////////////////////////////////////////////////////////////

int Locale_ApplyError(
    HWND hwnd,
    LPLANGNODE pLangNode,
    UINT iErr,
    UINT iStyle)
{
    UINT idxLang, idxLayout;
    TCHAR sz[MAX_PATH];
    TCHAR szTemp[MAX_PATH];
    TCHAR szLangName[MAX_PATH * 2];
    LPTSTR pszLang;

    //
    //  Load in the string for the given string id.
    //
    LoadString(hInstance, iErr, sz, ARRAYSIZE(sz));

    //
    //  Get the language name to fill into the above string.
    //
    if (pLangNode)
    {
        idxLang = pLangNode->iLang;
        idxLayout = pLangNode->iLayout;
        GetAtomName(g_lpLang[idxLang].atmLanguageName, szLangName, ARRAYSIZE(szLangName));
        if (g_lpLang[idxLang].dwID != g_lpLayout[idxLayout].dwID)
        {
            pszLang = szLangName + lstrlen(szLangName);
            pszLang[0] = TEXT(' ');
            pszLang[1] = TEXT('-');
            pszLang[2] = TEXT(' ');
            GetAtomName(g_lpLayout[idxLayout].atmLayoutText,
                        pszLang + 3,
                        ARRAYSIZE(szLangName) - (lstrlen(szLangName) + 3));
        }
    }
    else
    {
        LoadString(hInstance, IDS_UNKNOWN, szLangName, ARRAYSIZE(szLangName));
    }

    //
    //  Put up the error message box.
    //
    StringCchPrintf(szTemp, ARRAYSIZE(szTemp), sz, szLangName);
    return (MessageBox(hwnd, szTemp, NULL, iStyle));
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_FetchIndicator
//
//  Saves the two letter indicator symbol for the given language in the
//  g_lpLang array.
//
////////////////////////////////////////////////////////////////////////////

void Locale_FetchIndicator(
    LPLANGNODE pLangNode)
{
    TCHAR szData[MAX_PATH];
    LPINPUTLANG pInpLang = &g_lpLang[pLangNode->iLang];

    //
    //  Get the indicator by using the first 2 characters of the
    //  abbreviated language name.
    //
    if (GetLocaleInfo(LOWORD(pInpLang->dwID),
                      LOCALE_SABBREVLANGNAME | LOCALE_NOUSEROVERRIDE,
                      szData,
                      ARRAYSIZE(szData)))
    {
        //
        //  Save the first two characters.
        //
        pInpLang->szSymbol[0] = szData[0];
        pInpLang->szSymbol[1] = szData[1];
        pInpLang->szSymbol[2] = TEXT('\0');
    }
    else
    {
        //
        //  Id wasn't found.  Return question marks.
        //
        pInpLang->szSymbol[0] = TEXT('?');
        pInpLang->szSymbol[1] = TEXT('?');
        pInpLang->szSymbol[2] = TEXT('\0');
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_SetSecondaryControls
//
//  Sets the secondary controls to either be enabled or disabled.
//  When there is only 1 active TIP, then this function will be called to
//  disable these controls.
//
////////////////////////////////////////////////////////////////////////////

void Locale_SetSecondaryControls(
    HWND hwndMain)
{
    if (g_iInputs >= 2)
    {
        EnableWindow(GetDlgItem(hwndMain, IDC_HOTKEY_SETTING), TRUE);
    }
    else
    {
        EnableWindow(GetDlgItem(hwndMain, IDC_HOTKEY_SETTING), FALSE);
    }

    CheckButtons(hwndMain);
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_CommandSetDefault
//
//  Sets the new default when the Set as Default button is pressed.
//
////////////////////////////////////////////////////////////////////////////

void Locale_CommandSetDefault(
    HWND hwnd)
{
    int iIdxDef;
    int idxList;
    LPLANGNODE pLangNode = NULL;
    HWND hwndTV = GetDlgItem(hwnd, IDC_INPUT_LIST);
    HWND hwndDefList = GetDlgItem(hwnd, IDC_LOCALE_DEFAULT);
    TCHAR sz[DESC_MAX];

    HTREEITEM hTVCurLangItem = NULL;
    HTREEITEM hTVCurItem = NULL;
    TV_ITEM tvItem;
    TV_ITEM tvItem2;

    HTREEITEM hItem;
    HTREEITEM hLangItem;
    HTREEITEM hGroupItem;

    LPTVITEMNODE pCurItemNode;
    LPTVITEMNODE pPrevDefItemNode;

    TCHAR szLangText[DESC_MAX];
    TCHAR szLayoutName[DESC_MAX];
    TCHAR szDefItem[MAX_PATH];
    LPINPUTLANG pInpLang;
    WCHAR *pwchar;

    TCHAR szDefTip[DESC_MAX];

    //
    //  Get the current selection in the input locale list.
    //
    iIdxDef =  (int) SendMessage(hwndDefList, CB_GETCURSEL, 0, 0);

    if (iIdxDef == CB_ERR)
    {
        //iIdxDef = 0;
        DWORD dwLangID;

        for (hLangItem = TreeView_GetChild(hwndTV, g_hTVRoot) ;
            hLangItem != NULL ;
            hLangItem = TreeView_GetNextSibling(hwndTV, hLangItem)
            )
        {
            tvItem.hItem = hLangItem;

            if (TreeView_GetItem(hwndTV, &tvItem) &&
                (pCurItemNode = (LPTVITEMNODE) tvItem.lParam))
            {
                 if (pCurItemNode->bDefLang)
                 {
                     dwLangID = pCurItemNode->dwLangID;
                     GetAtomName(pCurItemNode->atmTVItemName,
                                 szLangText,
                                 ARRAYSIZE(szLangText));
                     break;
                 }
            }
        }
    }
    else
    {
        SendMessage(hwndDefList, CB_GETLBTEXT, iIdxDef, (LPARAM)szDefItem);

        pwchar = wcschr(szDefItem, L'-');

        if (szDefItem < (pwchar - 1))
            *(pwchar - 1) = TEXT('\0');

        StringCchCopy(szLangText, ARRAYSIZE(szLangText), szDefItem);
        StringCchCopy(szLayoutName, ARRAYSIZE(szLayoutName), pwchar + 2);
    }

    hTVCurLangItem = FindTVLangItem(0, szLangText);

    if (hTVCurLangItem == NULL)
    {
        // 
        //  There is no default keyboard layout on the system, so try to set
        //  the default keyboard layout with the first available item.
        //
        if (SendMessage(hwndDefList, CB_GETLBTEXT, 0, (LPARAM)szDefItem) != CB_ERR)
        {
            pwchar = wcschr(szDefItem, L'-');

            if (szDefItem < (pwchar - 1))
                *(pwchar - 1) = TEXT('\0');

            StringCchCopy(szLangText, ARRAYSIZE(szLangText), szDefItem);
            StringCchCopy(szLayoutName, ARRAYSIZE(szLayoutName), pwchar + 2);
            ComboBox_SetCurSel(hwndDefList, 0);
        }
    }
    else
    {
        tvItem.mask = TVIF_HANDLE | TVIF_PARAM;
        tvItem.hItem = hTVCurLangItem;
    }

    if (TreeView_GetItem(hwndTV, &tvItem) && tvItem.lParam)
    {
        //
        //  Get the pointer to the lang node from the list box
        //  item data.
        //
        pCurItemNode = (LPTVITEMNODE) tvItem.lParam;

        if (hTVCurItem = FindTVItem(pCurItemNode->dwLangID, szLayoutName))
        {
            tvItem.hItem = hTVCurItem;

            if (TreeView_GetItem(hwndTV, &tvItem) && tvItem.lParam)
            {
                TreeView_SelectItem(hwndTV, hTVCurItem);
                pCurItemNode = (LPTVITEMNODE) tvItem.lParam;
            }
        }
    }
    else
    {
        //
        //  Make sure we're not removing the only entry in the list.
        //
        MessageBeep(MB_ICONEXCLAMATION);
        return;
    }

    //
    //  Find the previous default Tip.
    //

    for (hLangItem = TreeView_GetChild(hwndTV, g_hTVRoot) ;
        hLangItem != NULL ;
        hLangItem = TreeView_GetNextSibling(hwndTV, hLangItem)
        )
    {
        tvItem.hItem = hLangItem;

        if (TreeView_GetItem(hwndTV, &tvItem) &&
            (pPrevDefItemNode = (LPTVITEMNODE) tvItem.lParam))
        {
             if (pPrevDefItemNode->bDefLang)
             {
                 GetAtomName(pPrevDefItemNode->atmDefTipName, szDefTip, ARRAYSIZE(szDefTip));
                 UpdateDefaultTVLangItem(pPrevDefItemNode->dwLangID, szDefTip, FALSE, TRUE);
                 UpdateLangKBDItemNode(hLangItem, szDefTip, FALSE);
                 break;
             }
        }
    }

    pCurItemNode->bDefLang = TRUE;

    if (pCurItemNode->atmDefTipName)
        GetAtomName(pCurItemNode->atmDefTipName, szDefTip, ARRAYSIZE(szDefTip));
    else
        GetAtomName(pCurItemNode->atmTVItemName, szDefTip, ARRAYSIZE(szDefTip));

    UpdateDefaultTVLangItem(pCurItemNode->dwLangID,
                            szDefTip,
                            TRUE,
                            pCurItemNode->hklSub ? TRUE : FALSE);

    if (!UpdateLangKBDItemNode(hTVCurLangItem, szDefTip, TRUE))
    {
        SetNextDefaultLayout(pCurItemNode->dwLangID,
                             pCurItemNode->bDefLang,
                             szDefTip,
                             ARRAYSIZE(szDefTip));
    }

    if (pCurItemNode->uInputType & TV_ITEM_TYPE_LANG)
    {
        hItem = FindDefaultTipItem(pCurItemNode->dwLangID, szDefTip);
        tvItem.hItem = hItem;

        if (TreeView_GetItem(hwndTV, &tvItem) && tvItem.lParam)
            pCurItemNode = (LPTVITEMNODE) tvItem.lParam;

        //
        //  Select the default layout item as bold
        //
        SelectDefaultKbdLayoutAsBold(hwndTV, hItem);

        pLangNode = (LPLANGNODE)pCurItemNode->lParam;
        if (pLangNode)
            pLangNode->wStatus |= (LANG_DEFAULT | LANG_DEF_CHANGE);
    }

    //
    //  Enable the Apply button.
    //
    g_dwChanges |= CHANGE_DEFAULT;
    PropSheet_Changed(GetParent(hwnd), hwnd);
}

void Locale_CommandSetDefaultLayout(
    HWND hwnd)
{
    TV_ITEM tvItem;
    HTREEITEM hTVItem;
    HTREEITEM hLangItem;
    HTREEITEM hTVCurItem;
    TCHAR szDefTip[DESC_MAX];
    TCHAR szLangText[DESC_MAX];
    LPLANGNODE pLangNode = NULL;
    LPTVITEMNODE pCurItemNode;
    LPTVITEMNODE pPrevDefItemNode;
    HWND hwndTV = GetDlgItem(hwnd, IDC_INPUT_LIST);

    //
    //  Get the current selection layout in the input layout lists.
    //
    hTVCurItem = TreeView_GetSelection(hwndTV);

    if (!hTVCurItem)
        return;

    tvItem.mask = TVIF_HANDLE | TVIF_PARAM;
    tvItem.hItem = hTVCurItem;

    if (TreeView_GetItem(hwndTV, &tvItem) && tvItem.lParam)
    {
        //
        //  Get the pointer to the lang node from the list box
        //  item data.
        //
        pCurItemNode = (LPTVITEMNODE) tvItem.lParam;
    }
    else
    {
        //
        //  Make sure we're not removing the only entry in the list.
        //
        MessageBeep(MB_ICONEXCLAMATION);
        return;
    }

    //
    //  Find the previous default Tip.
    //

    for (hLangItem = TreeView_GetChild(hwndTV, g_hTVRoot) ;
        hLangItem != NULL ;
        hLangItem = TreeView_GetNextSibling(hwndTV, hLangItem)
        )
    {
        tvItem.hItem = hLangItem;

        if (TreeView_GetItem(hwndTV, &tvItem) &&
            (pPrevDefItemNode = (LPTVITEMNODE) tvItem.lParam))
        {
             if (pPrevDefItemNode->bDefLang)
             {
                 if (pPrevDefItemNode->atmDefTipName)
                     GetAtomName(pPrevDefItemNode->atmDefTipName, szDefTip, ARRAYSIZE(szDefTip));
                 else
                     GetAtomName(pPrevDefItemNode->atmTVItemName, szDefTip, ARRAYSIZE(szDefTip));
                 UpdateDefaultTVLangItem(pPrevDefItemNode->dwLangID, szDefTip, FALSE, TRUE);
                 UpdateLangKBDItemNode(hLangItem, szDefTip, FALSE);
                 break;
             }
        }
    }

    if (pCurItemNode->atmDefTipName)
        GetAtomName(pCurItemNode->atmDefTipName, szDefTip, ARRAYSIZE(szDefTip));
    else
        GetAtomName(pCurItemNode->atmTVItemName, szDefTip, ARRAYSIZE(szDefTip));

    UpdateDefaultTVLangItem(pCurItemNode->dwLangID,
                            szDefTip,
                            TRUE,
                            pCurItemNode->hklSub ? TRUE : FALSE);

    pCurItemNode->bDefLang = TRUE;

    pLangNode = (LPLANGNODE)pCurItemNode->lParam;

    if (pLangNode)
        pLangNode->wStatus |= (LANG_DEFAULT | LANG_DEF_CHANGE);

    if (hTVItem = FindTVLangItem(pCurItemNode->dwLangID, NULL))
    {
        int idxSel = -1;
        TCHAR szDefItem[MAX_PATH];
        HWND hwndDefList = GetDlgItem(g_hDlg, IDC_LOCALE_DEFAULT);

        tvItem.mask = TVIF_HANDLE | TVIF_PARAM;
        tvItem.hItem = hTVItem;

        if (TreeView_GetItem(g_hwndTV, &tvItem) && tvItem.lParam)
        {
            LPTVITEMNODE pTVItemNode;

            pTVItemNode = (LPTVITEMNODE) tvItem.lParam;
            GetAtomName(pTVItemNode->atmTVItemName, szLangText, ARRAYSIZE(szLangText));
        }

        StringCchCopy(szDefItem, ARRAYSIZE(szDefItem), szLangText);
        StringCchCat(szDefItem, ARRAYSIZE(szDefItem), TEXT(" - "));
        StringCchCat(szDefItem, ARRAYSIZE(szDefItem), szDefTip);

        //
        //  Set the default locale selection.
        //
        if ((idxSel = ComboBox_FindStringExact(hwndDefList, 0, szDefItem)) != CB_ERR)
            ComboBox_SetCurSel(hwndDefList, idxSel);
    }

    SelectDefaultKbdLayoutAsBold(hwndTV, FindDefaultTipItem(pCurItemNode->dwLangID, szDefTip));

    //
    //  Enable the Apply button.
    //
    g_dwChanges |= CHANGE_DEFAULT;
    PropSheet_Changed(GetParent(hwnd), hwnd);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetLanguageHotkeyFromRegistry()
//
////////////////////////////////////////////////////////////////////////////

BOOL GetLanguageHotkeyFromRegistry(
    LPTSTR lpLangKey,
    UINT cchLangKey,
    LPTSTR lpLayoutKey,
    UINT cchLayoutKey)
{
    DWORD cb;
    HKEY hkey;

    lpLangKey[0] = 0;
    StringCchCopy(lpLayoutKey, cchLayoutKey, TEXT("3"));

    if (RegOpenKey(HKEY_CURRENT_USER, c_szKbdToggleKey, &hkey) == ERROR_SUCCESS)
    {
        cb = sizeof(lpLangKey);

        RegQueryValueEx(hkey, g_OSWIN95? NULL : c_szToggleHotKey, NULL, NULL, (LPBYTE)lpLangKey, &cb);

        if (g_iEnabledKbdTips)
        {
            StringCchCopy(lpLangKey, cchLangKey, TEXT("1"));
            RegQueryValueEx(hkey, c_szToggleLang, NULL, NULL, (LPBYTE)lpLangKey, &cb);
        }

        if (RegQueryValueEx(hkey, c_szToggleLayout, NULL, NULL, (LPBYTE)lpLayoutKey, &cb) != ERROR_SUCCESS)
        {
            if (lstrcmp(lpLangKey, TEXT("1")) == 0)
            {
                lpLayoutKey[0] = TEXT('2');
                lpLayoutKey[1] = TEXT('\0');
            }
            if (lstrcmp(lpLangKey, TEXT("2")) == 0)
            {
                lpLayoutKey[0] = TEXT('1');
                lpLayoutKey[1] = TEXT('\0');
            }
            else
            {
                lpLayoutKey[0] = TEXT('3');
                lpLayoutKey[1] = TEXT('\0');
            }

            if (GetSystemMetrics(SM_MIDEASTENABLED))
            {
                lpLayoutKey[0] = TEXT('3');
                lpLayoutKey[1] = TEXT('\0');
            }
        }

        if (lstrcmp(lpLangKey, lpLayoutKey) == 0)
            StringCchCopy(lpLayoutKey, cchLayoutKey, TEXT("3"));

        RegCloseKey(hkey);

        return TRUE;
    }
    else
        return FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_SetDefaultHotKey
//
//  Set the default hotkey for a locale switch.
//
////////////////////////////////////////////////////////////////////////////

void Locale_SetDefaultHotKey(
    HWND hwnd,
    BOOL bAdd)
{
    LPHOTKEYINFO pHotKeyNode;
    BOOL bReset = FALSE;

    //
    //  Initialize lang hotkey value to switch between lnaguages.
    //
    if (g_bGetSwitchLangHotKey)
    {
        TCHAR szItem[DESC_MAX];
        TCHAR sz[10];
        TCHAR sz2[10];

        g_SwitchLangHotKey.dwHotKeyID = HOTKEY_SWITCH_LANG;
        g_SwitchLangHotKey.fdwEnable = MOD_CONTROL | MOD_ALT | MOD_SHIFT;

        LoadString( hInstance,
                    IDS_KBD_SWITCH_LOCALE,
                    szItem,
                    sizeof(szItem) / sizeof(TCHAR) );

        g_SwitchLangHotKey.atmHotKeyName = AddAtom(szItem);

        if (!GetLanguageHotkeyFromRegistry(sz, ARRAYSIZE(sz), sz2, ARRAYSIZE(sz2)))
        {
            g_SwitchLangHotKey.uModifiers = 0;
            g_SwitchLangHotKey.uLayoutHotKey = 0;
            g_SwitchLangHotKey.uVKey = 0;
        }
        else
        {
            //
            //  Set the modifiers.
            //
            if (sz[1] == 0)
            {
                switch (sz[0])
                {
                    case ( TEXT('1') ) :
                    {
                        g_SwitchLangHotKey.uModifiers = MOD_ALT | MOD_SHIFT;
                        break;
                    }
                    case ( TEXT('2') ) :
                    {
                        g_SwitchLangHotKey.uModifiers = MOD_CONTROL | MOD_SHIFT;
                        break;
                    }
                    case ( TEXT('3') ) :
                    {
                        g_SwitchLangHotKey.uModifiers = 0;
                        break;
                    }
                    case ( TEXT('4') ) :
                    {
                        g_SwitchLangHotKey.uModifiers = 0;
                        g_SwitchLangHotKey.uVKey = CHAR_GRAVE;
                        break;
                    }
                }
            }
            //
            //  Get the layout hotkey from the registry
            //
            if (sz2[1] == 0)
            {
                switch (sz2[0])
                {
                    case ( TEXT('1') ) :
                    {
                        g_SwitchLangHotKey.uLayoutHotKey = MOD_ALT | MOD_SHIFT;
                        break;
                    }
                    case ( TEXT('2') ) :
                    {
                        g_SwitchLangHotKey.uLayoutHotKey = MOD_CONTROL | MOD_SHIFT;
                        break;
                    }
                    case ( TEXT('3') ) :
                    {
                        g_SwitchLangHotKey.uLayoutHotKey = 0;
                        break;
                    }
                    case ( TEXT('4') ) :
                    {
                        g_SwitchLangHotKey.uLayoutHotKey = 0;
                        g_SwitchLangHotKey.uVKey = CHAR_GRAVE;
                        break;
                    }
                }
            }
        }
        g_bGetSwitchLangHotKey = FALSE;
    }

    //
    //  Get language switch hotkey
    //
    pHotKeyNode = (LPHOTKEYINFO) &g_SwitchLangHotKey;

    //
    //  Check the current hotkey setting
    //
    if ((bAdd && g_iInputs >= 2) &&
        (g_SwitchLangHotKey.uModifiers == 0 &&
         g_SwitchLangHotKey.uLayoutHotKey == 0 &&
         g_SwitchLangHotKey.uVKey == 0))
    {
        bReset = TRUE;
    }

    if (bAdd && (g_iInputs == 2 || bReset))
    {
        if (g_dwPrimLangID == LANG_THAI && g_iThaiLayout)
        {
            pHotKeyNode->uVKey = CHAR_GRAVE;
            pHotKeyNode->uModifiers &= ~(MOD_CONTROL | MOD_ALT | MOD_SHIFT);
        }
        else
            pHotKeyNode->uModifiers = MOD_ALT | MOD_SHIFT;

        if (g_bMESystem)
        {
            pHotKeyNode->uVKey = CHAR_GRAVE;
            pHotKeyNode->uLayoutHotKey &= ~(MOD_CONTROL | MOD_ALT | MOD_SHIFT);
        }
        else if (pHotKeyNode->uModifiers & MOD_CONTROL)
            pHotKeyNode->uLayoutHotKey = MOD_ALT;
        else
            pHotKeyNode->uLayoutHotKey = MOD_CONTROL;

        g_dwChanges |= CHANGE_LANGSWITCH;
    }

    if (!bAdd)
    {
        if (g_iInputs == 1)
        {
            //
            //  Remove the locale hotkey, since it's no longer required.
            //
            pHotKeyNode->uVKey = 0;
            pHotKeyNode->uModifiers &= ~(MOD_CONTROL | MOD_ALT | MOD_SHIFT);
            pHotKeyNode->uLayoutHotKey &= ~(MOD_CONTROL | MOD_ALT | MOD_SHIFT);

            g_dwChanges |= CHANGE_LANGSWITCH;
        }
        else if ((g_dwPrimLangID == LANG_THAI && !g_iThaiLayout) &&
                 (pHotKeyNode->uVKey == CHAR_GRAVE))
        {
            //
            //  Reset the locale switch hotkey from Grave accent to
            //  Left-Alt + Shift.
            //
            pHotKeyNode->uVKey = 0;
            if (pHotKeyNode->uLayoutHotKey & MOD_ALT)
                pHotKeyNode->uModifiers = MOD_CONTROL | MOD_SHIFT;
            else
                pHotKeyNode->uModifiers = MOD_ALT | MOD_SHIFT;

            g_dwChanges |= CHANGE_LANGSWITCH;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_SetLanguageHotkey
//
//  Set the language switch hotkey on the registry.
//
////////////////////////////////////////////////////////////////////////////

void Locale_SetLanguageHotkey()
{
    UINT idx, idx2;
    HKEY hkeyToggle;
    TCHAR szTemp[10], szTemp2[10];
    LPHOTKEYINFO pHotKeyNode;

    //
    //  Get language switch hotkey
    //
    pHotKeyNode = (LPHOTKEYINFO) &g_SwitchLangHotKey;

    idx = 3;
    idx2 = 3;

    if (pHotKeyNode->uModifiers & MOD_ALT)
    {
        idx = 1;
    }
    else if (pHotKeyNode->uModifiers & MOD_CONTROL)
    {
        idx = 2;
    }
    else if (g_iThaiLayout && pHotKeyNode->uVKey == CHAR_GRAVE)
    {
        idx = 4;
    }

    if (pHotKeyNode->uLayoutHotKey & MOD_ALT)
    {
        idx2 = 1;
    }
    else if (pHotKeyNode->uLayoutHotKey & MOD_CONTROL)
    {
        idx2 = 2;
    }
    else if (g_bMESystem && pHotKeyNode->uVKey == CHAR_GRAVE)
    {
        idx2 = 4;
    }

    //
    //  Get the toggle hotkey as a string so that it can be written
    //  into the registry (as data).
    //
    StringCchPrintf(szTemp, ARRAYSIZE(szTemp), TEXT("%d"), idx);
    StringCchPrintf(szTemp2, ARRAYSIZE(szTemp2), TEXT("%d"), idx2);

    //
    //  Set the new entry in the registry.  It is of the form:
    //
    //  HKCU\Keyboard Layout
    //      Toggle:    Hotkey = <hotkey number>
    //
    if (RegCreateKey(HKEY_CURRENT_USER,
                     c_szKbdToggleKey,
                     &hkeyToggle ) == ERROR_SUCCESS)
    {
        RegSetValueEx(hkeyToggle,
                      g_OSWIN95? NULL : c_szToggleHotKey,
                      0,
                      REG_SZ,
                      (LPBYTE)szTemp,
                      (DWORD)(lstrlen(szTemp) + 1) * sizeof(TCHAR) );

        RegSetValueEx(hkeyToggle,
                      c_szToggleLang,
                      0,
                      REG_SZ,
                      (LPBYTE)szTemp,
                      (DWORD)(lstrlen(szTemp) + 1) * sizeof(TCHAR) );

        RegSetValueEx(hkeyToggle,
                      c_szToggleLayout,
                      0,
                      REG_SZ,
                      (LPBYTE)szTemp2,
                      (DWORD)(lstrlen(szTemp2) + 1) * sizeof(TCHAR) );

        RegCloseKey(hkeyToggle);
    }

    //
    //  Since we updated the registry, we should reread this next time.
    //
    g_bGetSwitchLangHotKey = TRUE;

    //
    //  Call SystemParametersInfo to enable the toggle.
    //
    SystemParametersInfo(SPI_SETLANGTOGGLE, 0, NULL, 0);
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_FileExists
//
//  Determines if the file exists and is accessible.
//
////////////////////////////////////////////////////////////////////////////

BOOL Locale_FileExists(
    LPTSTR pFileName)
{
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;
    BOOL bRet;
    UINT OldMode;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFile(pFileName, &FindData);
    if (FindHandle == INVALID_HANDLE_VALUE)
    {
        bRet = FALSE;
    }
    else
    {
        FindClose(FindHandle);
        bRet = TRUE;
    }

    SetErrorMode(OldMode);

    return (bRet);
}

////////////////////////////////////////////////////////////////////////////
//
//  Locale_GetHotkeys
//
//  Gets the hotkey keyboard switch value from the registry and then
//  sets the appropriate radio button in the dialog.
//
////////////////////////////////////////////////////////////////////////////

void Locale_GetHotkeys(
    HWND hwnd,
    BOOL *bHasIme)
{
    TCHAR sz[10];
    TCHAR sz2[10];
    int ctr1, iLangCount, iCount;
    UINT iIndex;
    TCHAR szLanguage[DESC_MAX];
    TCHAR szLayout[DESC_MAX];
    TCHAR szItem[DESC_MAX];
    TCHAR szAction[DESC_MAX];
    LPLANGNODE pLangNode;
    HWND hwndTV = g_hwndTV;
    HWND hwndHotkey = GetDlgItem(hwnd, IDC_KBDL_HOTKEY_LIST);
    LPHOTKEYINFO aImeHotKey;

    TV_ITEM tvItem;
    HTREEITEM hItem;
    HTREEITEM hLangItem;
    HTREEITEM hGroupItem;

    //
    //  Clear out the hot keys list box.
    //
    ListBox_ResetContent(hwndHotkey);

    //
    //  Get the hotkey value to switch between locales from the registry.
    //
    if (g_bGetSwitchLangHotKey)
    {
        g_SwitchLangHotKey.dwHotKeyID = HOTKEY_SWITCH_LANG;
        g_SwitchLangHotKey.fdwEnable = MOD_CONTROL | MOD_ALT | MOD_SHIFT;

        LoadString( hInstance,
                    IDS_KBD_SWITCH_LOCALE,
                    szItem,
                    sizeof(szItem) / sizeof(TCHAR) );

        g_SwitchLangHotKey.atmHotKeyName = AddAtom(szItem);

        if (!GetLanguageHotkeyFromRegistry(sz, ARRAYSIZE(sz), sz2, ARRAYSIZE(sz2)))
        {
            g_SwitchLangHotKey.uModifiers = 0;
            g_SwitchLangHotKey.uLayoutHotKey = 0;
            g_SwitchLangHotKey.uVKey = 0;
        }
        else
        {
            //
            //  Set the modifiers.
            //
            if (sz[1] == 0)
            {
                switch (sz[0])
                {
                    case ( TEXT('1') ) :
                    {
                        g_SwitchLangHotKey.uModifiers = MOD_ALT | MOD_SHIFT;
                        break;
                    }
                    case ( TEXT('2') ) :
                    {
                        g_SwitchLangHotKey.uModifiers = MOD_CONTROL | MOD_SHIFT;
                        break;
                    }
                    case ( TEXT('3') ) :
                    {
                        g_SwitchLangHotKey.uModifiers = 0;
                        break;
                    }
                    case ( TEXT('4') ) :
                    {
                        g_SwitchLangHotKey.uModifiers = 0;
                        g_SwitchLangHotKey.uVKey = CHAR_GRAVE;
                        break;
                    }
                }
            }
            //
            //  Get the layout hotkey from the registry
            //
            if (sz2[1] == 0)
            {
                switch (sz2[0])
                {
                    case ( TEXT('1') ) :
                    {
                        g_SwitchLangHotKey.uLayoutHotKey = MOD_ALT | MOD_SHIFT;
                        break;
                    }
                    case ( TEXT('2') ) :
                    {
                        g_SwitchLangHotKey.uLayoutHotKey = MOD_CONTROL | MOD_SHIFT;
                        break;
                    }
                    case ( TEXT('3') ) :
                    {
                        g_SwitchLangHotKey.uLayoutHotKey = 0;
                        break;
                    }
                    case ( TEXT('4') ) :
                    {
                        g_SwitchLangHotKey.uLayoutHotKey = 0;
                        g_SwitchLangHotKey.uVKey = CHAR_GRAVE;
                        break;
                    }
                }
            }
            g_bGetSwitchLangHotKey = FALSE;
        }
    }

    iIndex = ListBox_InsertString(hwndHotkey, -1, szItem);
    ListBox_SetItemData(hwndHotkey, iIndex, (LONG_PTR)&g_SwitchLangHotKey);

    //
    //  Determine the hotkey value for direct locale switch.
    //
    //  Query all available direct switch hotkey IDs and put the
    //  corresponding hkl, key, and modifiers information into the array.
    //
    for (ctr1 = 0; ctr1 < DSWITCH_HOTKEY_SIZE; ctr1++)
    {
        BOOL fRet;

        g_aDirectSwitchHotKey[ctr1].dwHotKeyID = IME_HOTKEY_DSWITCH_FIRST + ctr1;
        g_aDirectSwitchHotKey[ctr1].fdwEnable = MOD_VIRTKEY | MOD_CONTROL |
                                                MOD_ALT | MOD_SHIFT |
                                                MOD_LEFT | MOD_RIGHT;
        g_aDirectSwitchHotKey[ctr1].idxLayout = -1;

        fRet = ImmGetHotKey( g_aDirectSwitchHotKey[ctr1].dwHotKeyID,
                             &g_aDirectSwitchHotKey[ctr1].uModifiers,
                             &g_aDirectSwitchHotKey[ctr1].uVKey,
                             &g_aDirectSwitchHotKey[ctr1].hkl );
        if (!fRet)
        {
            g_aDirectSwitchHotKey[ctr1].uModifiers = 0;

            if ((g_aDirectSwitchHotKey[ctr1].fdwEnable & (MOD_LEFT | MOD_RIGHT)) ==
                (MOD_LEFT | MOD_RIGHT))
            {
                g_aDirectSwitchHotKey[ctr1].uModifiers |= MOD_LEFT | MOD_RIGHT;
            }
            g_aDirectSwitchHotKey[ctr1].uVKey = 0;
            g_aDirectSwitchHotKey[ctr1].hkl = (HKL)NULL;
        }
    }

    LoadString( hInstance,
                IDS_KBD_SWITCH_TO,
                szAction,
                sizeof(szAction) / sizeof(TCHAR) );

    //
    //  Try to find either a matching hkl or empty spot in the array
    //  for each of the hkls in the locale list.
    //
    for (hLangItem = TreeView_GetChild(hwndTV, g_hTVRoot) ;
        hLangItem != NULL ;
        hLangItem = TreeView_GetNextSibling(hwndTV, hLangItem)
        )
    {
        for (hGroupItem = TreeView_GetChild(hwndTV, hLangItem);
             hGroupItem != NULL;
             hGroupItem = TreeView_GetNextSibling(hwndTV, hGroupItem))
        {

            for (hItem = TreeView_GetChild(hwndTV, hGroupItem);
                 hItem != NULL;
                 hItem = TreeView_GetNextSibling(hwndTV, hItem))
            {
                int ctr2;
                int iEmpty = -1;
                int iMatch = -1;
                LPTVITEMNODE pTVItemNode;

                tvItem.hItem = hItem;
                tvItem.mask = TVIF_HANDLE | TVIF_PARAM;
                if (TreeView_GetItem(hwndTV, &tvItem) && tvItem.lParam)
                {
                    pTVItemNode = (LPTVITEMNODE) tvItem.lParam;
                    pLangNode = (LPLANGNODE)pTVItemNode->lParam;
                }
                else
                    break;

                if (pLangNode == NULL &&
                    (pTVItemNode->uInputType & INPUT_TYPE_KBD) &&
                    pTVItemNode->hklSub)
                {
                    if (tvItem.hItem = FindTVLangItem(pTVItemNode->dwLangID, NULL))
                    {
                        if (TreeView_GetItem(hwndTV, &tvItem) && tvItem.lParam)
                        {
                            pTVItemNode = (LPTVITEMNODE) tvItem.lParam;
                            pLangNode = (LPLANGNODE)pTVItemNode->lParam;
                        }
                    }
                }

                if (pLangNode == NULL)
                    continue;

                for (ctr2 = 0; ctr2 < DSWITCH_HOTKEY_SIZE; ctr2++)
                {
                    if (!g_aDirectSwitchHotKey[ctr2].hkl)
                    {
                        if ((iEmpty == -1) &&
                            (g_aDirectSwitchHotKey[ctr2].idxLayout == -1))
                        {
                            //
                            //  Remember the first empty spot.
                            //
                            iEmpty = ctr2;
                        }
                    }
                    else if (g_aDirectSwitchHotKey[ctr2].hkl == pLangNode->hkl)
                    {
                        //
                        //  We found a match.  Remember it.
                        //
                        iMatch = ctr2;
                        break;
                    }
                }

                if (iMatch == -1)
                {
                    if (iEmpty == -1)
                    {
                        //
                        //  We don't have any spots left.
                        //
                        continue;
                    }
                    else
                    {
                        //
                        //  New item.
                        //
                        iMatch = iEmpty;
                        if (pLangNode->hkl)
                        {
                            g_aDirectSwitchHotKey[iMatch].hkl = pLangNode->hkl;
                        }
                        else
                        {
                            //
                            //  This must be a newly added layout.  We don't have
                            //  the hkl yet.  Remember the index position of this
                            //  layout - we can get the real hkl when the user
                            //  chooses to apply.
                            //
                            g_aDirectSwitchHotKey[iMatch].idxLayout = ctr1;
                        }
                    }
                }

                if (pLangNode->wStatus & LANG_IME)
                {
                    *bHasIme = TRUE;
                }

                if (pLangNode->wStatus & LANG_HOTKEY)
                {
                    g_aDirectSwitchHotKey[iMatch].uModifiers = pLangNode->uModifiers;
                    g_aDirectSwitchHotKey[iMatch].uVKey = pLangNode->uVKey;
                }

                GetAtomName(g_lpLang[pLangNode->iLang].atmLanguageName,
                            szLanguage,
                            ARRAYSIZE(szLanguage));

                GetAtomName(g_lpLayout[pLangNode->iLayout].atmLayoutText,
                            szLayout,
                            ARRAYSIZE(szLayout));

                StringCchCat(szLanguage, ARRAYSIZE(szLanguage), TEXT(" - "));
                StringCchCat(szLanguage, ARRAYSIZE(szLanguage), szLayout);

                StringCchPrintf(szItem, ARRAYSIZE(szItem), szAction, szLanguage);

                if (ListBox_FindStringExact(hwndHotkey, 0, szItem) != CB_ERR)
                    continue;

                g_aDirectSwitchHotKey[iMatch].atmHotKeyName = AddAtom(szItem);
                iIndex = ListBox_InsertString(hwndHotkey, -1, szItem);

                ListBox_SetItemData(hwndHotkey, iIndex, &g_aDirectSwitchHotKey[iMatch]);
            }
        }
    }

    //
    //  Determine IME specific hotkeys for CHS and CHT locales.
    //
    iCount = *bHasIme ? Locale_GetImeHotKeyInfo(hwnd,&aImeHotKey) : 0;

    for (ctr1 = 0; ctr1 < iCount; ctr1++)
    {
        BOOL bRet;

        LoadString( hInstance,
                    aImeHotKey[ctr1].idHotKeyName,
                    szItem,
                    sizeof(szItem) / sizeof(TCHAR) );

        aImeHotKey[ctr1].atmHotKeyName = AddAtom(szItem);

        iIndex = ListBox_InsertString(hwndHotkey, -1,szItem);

        ListBox_SetItemData(hwndHotkey, iIndex, &aImeHotKey[ctr1]);

        //
        //  Get the hot key value.
        //
        bRet = ImmGetHotKey( aImeHotKey[ctr1].dwHotKeyID,
                             &aImeHotKey[ctr1].uModifiers,
                             &aImeHotKey[ctr1].uVKey,
                             NULL );
        if (!bRet)
        {
            aImeHotKey[ctr1].uModifiers = 0;
            if ((aImeHotKey[ctr1].fdwEnable & (MOD_LEFT | MOD_RIGHT)) ==
                (MOD_LEFT | MOD_RIGHT))
            {
                aImeHotKey[ctr1].uModifiers |= MOD_LEFT | MOD_RIGHT;
            }
            aImeHotKey[ctr1].uVKey = 0;
            aImeHotKey[ctr1].hkl = (HKL)NULL;
        }
    }
    ListBox_SetCurSel(hwndHotkey, 0);
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_SetImmHotkey
//
////////////////////////////////////////////////////////////////////////////

void Locale_SetImmHotkey(
    HWND hwnd,
    LPLANGNODE pLangNode,
    UINT nLangs,
    HKL * pLangs,
    BOOL *bDirectSwitch)
{
    int ctr1;
    HKL hkl;
    BOOL bRet;
    UINT uVKey;
    UINT uModifiers;
    int iEmpty = -1;
    int iMatch = -1;
    LPHOTKEYINFO pHotKeyNode;


    if (pLangNode == NULL)
        return;

    for (ctr1 = 0; ctr1 < DSWITCH_HOTKEY_SIZE; ctr1++)
    {
        if (!g_aDirectSwitchHotKey[ctr1].hkl)
        {
            if ((iEmpty == -1) &&
                (g_aDirectSwitchHotKey[ctr1].idxLayout == -1))
            {
                //
                //  Remember the first empty spot.
                //
                iEmpty = ctr1;
            }
        }
        else if (g_aDirectSwitchHotKey[ctr1].hkl == pLangNode->hkl)
        {
            //
            //  We found a match.  Remember it.
            //
            iMatch = ctr1;
            break;
        }
    }

    if (iMatch == -1)
    {
        if (iEmpty == -1)
        {
            //
            //  We don't have any spots left.
            //
            return;
        }
        else
        {
            //
            //  New item.
            //
            iMatch = iEmpty;
            if (pLangNode->hkl)
            {
                g_aDirectSwitchHotKey[iMatch].hkl = pLangNode->hkl;
            }
            else
            {
                //
                //  This must be a newly added layout.  We don't have
                //  the hkl yet.  Remember the index position of this
                //  layout - we can get the real hkl when the user
                //  chooses to apply.
                //
                g_aDirectSwitchHotKey[iMatch].idxLayout = ctr1;
            }
        }
    }

    if (iMatch == -1)
        return;

    //
    //  Get Hotkey information for current layout.
    //
    pHotKeyNode = (LPHOTKEYINFO) &g_aDirectSwitchHotKey[iMatch];

    bRet = ImmGetHotKey(pHotKeyNode->dwHotKeyID, &uModifiers, &uVKey, &hkl);

    if (!bRet &&
        (!pHotKeyNode->uVKey) &&
        ((pHotKeyNode->uModifiers & (MOD_ALT | MOD_CONTROL | MOD_SHIFT))
         != (MOD_ALT | MOD_CONTROL | MOD_SHIFT)))
    {
        //
        //  No such hotkey exists.  User does not specify key and modifier
        //  information either. We can skip this one.
        //
        return;
    }

    if ((pHotKeyNode->uModifiers == uModifiers) &&
        (pHotKeyNode->uVKey == uVKey))
    {
        //
        //  No change.
        //
        if (IS_DIRECT_SWITCH_HOTKEY(pHotKeyNode->dwHotKeyID))
        {
            *bDirectSwitch = TRUE;
        }
        return;
    }

    if (pHotKeyNode->idxLayout != -1)
    {
        //
        //  We had this layout index remembered because at that time
        //  we did not have a real hkl to work with.  Now it is
        //  time to get the real hkl.
        //
        pHotKeyNode->hkl = pLangNode->hkl;
    }

    if (!bRet && IS_DIRECT_SWITCH_HOTKEY(pHotKeyNode->dwHotKeyID))
    {
        //
        //  New direct switch hotkey ID.  We need to see if the same
        //  hkl is set at another ID.  If so, set the other ID instead
        //  of the one requested.
        //
        DWORD dwHotKeyID;

        //
        //  Loop through all direct switch hotkeys.
        //
        for (dwHotKeyID = IME_HOTKEY_DSWITCH_FIRST;
             (dwHotKeyID <= IME_HOTKEY_DSWITCH_LAST);
             dwHotKeyID++)
        {
            if (dwHotKeyID == pHotKeyNode->dwHotKeyID)
            {
                //
                //  Skip itself.
                //
                continue;
            }

            bRet = ImmGetHotKey(dwHotKeyID, &uModifiers, &uVKey, &hkl);
            if (!bRet)
            {
                //
                //  Did not find the hotkey id. Skip.
                //
                continue;
            }

            if (hkl == pHotKeyNode->hkl)
            {
                //
                //  We found the same hkl already with hotkey
                //  settings at another ID.  Set hotkey
                //  ID equal to the one with the same hkl. So later
                //  we will modify hotkey for the correct hkl.
                //
                pHotKeyNode->dwHotKeyID = dwHotKeyID;
                break;
            }
        }
    }

    //
    //  Set the hotkey value.
    //
    bRet = ImmSetHotKey( pHotKeyNode->dwHotKeyID,
                         pHotKeyNode->uModifiers,
                         pHotKeyNode->uVKey,
                         pHotKeyNode->hkl );

    if (bRet)
    {
        //
        //  Hotkey set successfully. See if user used any direct
        //  switch hot key. We may have to load imm later.
        //
        if (IS_DIRECT_SWITCH_HOTKEY(pHotKeyNode->dwHotKeyID))
        {
            if (pHotKeyNode->uVKey != 0)
            {
                *bDirectSwitch = TRUE;
            }
        }
        else
        {
            //
            //  Must be IME related hotkey.  We need to sync up the
            //  imes so that the new hotkey is effective to all
            //  of them.
            //
            UINT ctr2;

            for (ctr2 = 0; ctr2 < nLangs; ctr2++)
            {
                if (!ImmIsIME(pLangs[ctr2]))
                {
                    continue;
                }

                ImmEscape( pLangs[ctr2],
                           NULL,
                           IME_ESC_SYNC_HOTKEY,
                           &pHotKeyNode->dwHotKeyID );
            }
        }
    }
    else
    {
        //
        //  Failed to set hotkey.  Maybe a duplicate.  Warn user.
        //
        TCHAR szString[DESC_MAX];

        GetAtomName( pHotKeyNode->atmHotKeyName,
                     szString,
                     sizeof(szString) / sizeof(TCHAR) );
        Locale_ErrorMsg(hwnd, IDS_KBD_SET_HOTKEY_ERR, szString);
    }

}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_SetImmCHxHotkey
//
////////////////////////////////////////////////////////////////////////////

void Locale_SetImmCHxHotkey(
    HWND hwnd,
    UINT nLangs,
    HKL * pLangs)
{
    HKL hkl;
    UINT ctr1;
    UINT uVKey;
    UINT iCount;
    UINT uModifiers;
    LPHOTKEYINFO aImeHotKey;
    LPHOTKEYINFO pHotKeyNode;

    //
    //  Determine IME specific hotkeys for CHS and CHT locales.
    //
    iCount = Locale_GetImeHotKeyInfo(hwnd, &aImeHotKey);

    for (ctr1 = 0; ctr1 < iCount; ctr1++)
    {
        UINT iIndex;
        BOOL bRet;

        //
        //  Get Hotkey information for current layout.
        //
        pHotKeyNode = (LPHOTKEYINFO) &aImeHotKey[ctr1];

        bRet = ImmGetHotKey(pHotKeyNode->dwHotKeyID, &uModifiers, &uVKey, &hkl);

        if (!bRet &&
            (!pHotKeyNode->uVKey) &&
            ((pHotKeyNode->uModifiers & (MOD_ALT | MOD_CONTROL | MOD_SHIFT))
             != (MOD_ALT | MOD_CONTROL | MOD_SHIFT)))
        {
            //
            //  No such hotkey exists.  User does not specify key and modifier
            //  information either. We can skip this one.
            //
            continue;
        }

        if ((pHotKeyNode->uModifiers == uModifiers) &&
            (pHotKeyNode->uVKey == uVKey))
        {
            //
            //  No change.
            //
            continue;
        }

        //
        //  Set the hotkey value.
        //
        bRet = ImmSetHotKey( pHotKeyNode->dwHotKeyID,
                             pHotKeyNode->uModifiers,
                             pHotKeyNode->uVKey,
                             pHotKeyNode->hkl );

        if (bRet)
        {
            //
            //  Must be IME related hotkey.  We need to sync up the
            //  imes so that the new hotkey is effective to all
            //  of them.
            //
            UINT ctr2;

            for (ctr2 = 0; ctr2 < nLangs; ctr2++)
            {
                if (!ImmIsIME(pLangs[ctr2]))
                {
                    continue;
                }

                ImmEscape( pLangs[ctr2],
                           NULL,
                           IME_ESC_SYNC_HOTKEY,
                           &pHotKeyNode->dwHotKeyID );
            }
        }
        else
        {
            //
            //  Failed to set hotkey.  Maybe a duplicate.  Warn user.
            //
            TCHAR szString[DESC_MAX];

            GetAtomName( pHotKeyNode->atmHotKeyName,
                         szString,
                         sizeof(szString) / sizeof(TCHAR) );
            Locale_ErrorMsg(hwnd, IDS_KBD_SET_HOTKEY_ERR, szString);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_GetAttributes
//
//  Gets the global layout attributes (eg: CapsLock/ShiftLock value) from
//  the registry and then sets the appropriate radio button in the dialog.
//
////////////////////////////////////////////////////////////////////////////

void Locale_GetAttributes(
    HWND hwnd)
{
    DWORD cb;
    HKEY hkey;

    //
    //  Initialize the global.
    //
    g_dwAttributes = 0;           // KLF_SHIFTLOCK = 0x00010000

    //
    //  Get the Atributes value from the registry.
    //
    if (RegOpenKey(HKEY_CURRENT_USER, c_szKbdLayouts, &hkey) == ERROR_SUCCESS)
    {
        cb = sizeof(DWORD);
        RegQueryValueEx( hkey,
                         c_szAttributes,
                         NULL,
                         NULL,
                         (LPBYTE)&g_dwAttributes,
                         &cb );
        RegCloseKey(hkey);
    }

    //
    //  Set the radio buttons appropriately.
    //
    CheckDlgButton( hwnd,
                    IDC_KBDL_SHIFTLOCK,
                    (g_dwAttributes & KLF_SHIFTLOCK)
                      ? BST_CHECKED
                      : BST_UNCHECKED );
    CheckDlgButton( hwnd,
                    IDC_KBDL_CAPSLOCK,
                    (g_dwAttributes & KLF_SHIFTLOCK)
                      ? BST_UNCHECKED
                      : BST_CHECKED);
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_LoadLayouts
//
//  Loads the layouts from the registry.
//
////////////////////////////////////////////////////////////////////////////

BOOL Locale_LoadLayouts(
    HWND hwnd)
{
    HKEY hKey;
    HKEY hkey1;
    DWORD cb;
    DWORD dwIndex;
    LONG dwRetVal;
    DWORD dwValue;
    DWORD dwType;
    TCHAR szValue[MAX_PATH];           // language id (number)
    TCHAR szData[MAX_PATH];            // language name
    TCHAR szSystemDir[MAX_PATH * 2];
    UINT SysDirLen;
    DWORD dwLayoutID;
    BOOL bLoadedLayout;

    //
    //  Load shlwapi module to get the localized layout name
    //
    g_hShlwapi = LoadSystemLibrary(TEXT("shlwapi.dll"));

    if (g_hShlwapi)
    {
        //
        //  Get address SHLoadRegUIStringW
        //
        pfnSHLoadRegUIString = GetProcAddress(g_hShlwapi, (LPVOID)439);
    }

    //
    //  Now read all of the layouts from the registry.
    //
    if (RegOpenKey(HKEY_LOCAL_MACHINE, c_szLayoutPath, &hKey) != ERROR_SUCCESS)
    {
        Locale_EnablePane(hwnd, FALSE, IDC_KBDL_DISABLED);
        return (FALSE);
    }

    dwIndex = 0;
    dwRetVal = RegEnumKey( hKey,
                           dwIndex,
                           szValue,
                           sizeof(szValue) / sizeof(TCHAR) );

    if (dwRetVal != ERROR_SUCCESS)
    {
        Locale_EnablePane(hwnd, FALSE, IDC_KBDL_DISABLED);
        RegCloseKey(hKey);
        return (FALSE);
    }

    g_hLayout = LocalAlloc(LHND, ALLOCBLOCK * sizeof(LAYOUT));
    g_nLayoutBuffSize = ALLOCBLOCK;
    g_iLayoutBuff = 0;
    g_iLayoutIME = 0;                    // number of IME layouts.
    g_lpLayout = LocalLock(g_hLayout);

    if (!g_hLayout)
    {
        Locale_EnablePane(hwnd, FALSE, IDC_KBDL_DISABLED);
        RegCloseKey(hKey);
        return (FALSE);
    }

    //
    //  Save the system directory string.
    //
    szSystemDir[0] = 0;
    if (SysDirLen = GetSystemDirectory(szSystemDir, MAX_PATH))
    {
        if (SysDirLen > MAX_PATH)
        {
            SysDirLen = 0;
            szSystemDir[0] = 0;
        }
        else if (szSystemDir[SysDirLen - 1] != TEXT('\\'))
        {
            szSystemDir[SysDirLen] = TEXT('\\');
            szSystemDir[SysDirLen + 1] = 0;
            SysDirLen++;
        }
    }

    do
    {
        //
        //  New layout - get the layout id, the layout file name, and
        //  the layout description string.
        //
        if (g_iLayoutBuff + 1 == g_nLayoutBuffSize)
        {
            HANDLE hTemp;

            LocalUnlock(g_hLayout);

            g_nLayoutBuffSize += ALLOCBLOCK;
            hTemp = LocalReAlloc( g_hLayout,
                                  g_nLayoutBuffSize * sizeof(LAYOUT),
                                  LHND );
            if (hTemp == NULL)
            {
                break;
            }

            g_hLayout = hTemp;
            g_lpLayout = LocalLock(g_hLayout);
        }

        //
        //  Get the layout id
        //
        dwLayoutID = TransNum(szValue);

        //
        //  Save the layout id.
        //
        g_lpLayout[g_iLayoutBuff].dwID = dwLayoutID;

        StringCchCopy(szData, ARRAYSIZE(szData), c_szLayoutPath);
        StringCchCat(szData, ARRAYSIZE(szData), TEXT("\\"));
        StringCchCat(szData, ARRAYSIZE(szData), szValue);

        if (RegOpenKey(HKEY_LOCAL_MACHINE, szData, &hkey1) == ERROR_SUCCESS)
        {
            //
            //  Get the name of the layout file.
            //
            szValue[0] = TEXT('\0');
            cb = sizeof(szValue);
            if ((RegQueryValueEx( hkey1,
                                  c_szLayoutFile,
                                  NULL,
                                  NULL,
                                  (LPBYTE)szValue,
                                  &cb ) == ERROR_SUCCESS) &&
                (cb > sizeof(TCHAR)))
            {
                g_lpLayout[g_iLayoutBuff].atmLayoutFile = AddAtom(szValue);

                //
                //  See if the layout file exists already.
                //
                StringCchCopy(szSystemDir + SysDirLen,
                              ARRAYSIZE(szSystemDir) - SysDirLen,
                              szValue);
                g_lpLayout[g_iLayoutBuff].bInstalled = (Locale_FileExists(szSystemDir));

                //
                //  Get the name of the layout.
                //
                szValue[0] = TEXT('\0');
                cb = sizeof(szValue);
                g_lpLayout[g_iLayoutBuff].iSpecialID = 0;
                bLoadedLayout = FALSE;

                if (pfnSHLoadRegUIString &&
                    pfnSHLoadRegUIString(hkey1,
                                         c_szDisplayLayoutText,
                                         szValue,
                                         ARRAYSIZE(szValue)) == S_OK)
                {
                    g_lpLayout[g_iLayoutBuff].atmLayoutText = AddAtom(szValue);
                    bLoadedLayout = TRUE;
                }
                else
                {
                    //
                    //  Get the name of the layout.
                    //
                    szValue[0] = TEXT('\0');
                    cb = sizeof(szValue);
                    if (RegQueryValueEx( hkey1,
                                         c_szLayoutText,
                                         NULL,
                                         NULL,
                                         (LPBYTE)szValue,
                                         &cb ) == ERROR_SUCCESS)
                    {
                        g_lpLayout[g_iLayoutBuff].atmLayoutText = AddAtom(szValue);
                        bLoadedLayout = TRUE;
                    }
                }

                if (bLoadedLayout)
                {

                    //
                    //  See if it's an IME or a special id.
                    //
                    szValue[0] = TEXT('\0');
                    cb = sizeof(szValue);
                    if ((HIWORD(g_lpLayout[g_iLayoutBuff].dwID) & 0xf000) == 0xe000)
                    {
                        //
                        //  Get the name of the IME file.
                        //
                        if (RegQueryValueEx( hkey1,
                                             c_szIMEFile,
                                             NULL,
                                             NULL,
                                             (LPBYTE)szValue,
                                             &cb ) == ERROR_SUCCESS)
                        {
                            g_lpLayout[g_iLayoutBuff].atmIMEFile = AddAtom(szValue);
                            szValue[0] = TEXT('\0');
                            cb = sizeof(szValue);
                            g_iLayoutBuff++;
                            g_iLayoutIME++;   // increment number of IME layouts.
                        }
                    }
                    else
                    {
                        //
                        //  See if this is a special id.
                        //
                        if (RegQueryValueEx( hkey1,
                                             c_szLayoutID,
                                             NULL,
                                             NULL,
                                             (LPBYTE)szValue,
                                             &cb ) == ERROR_SUCCESS)
                        {
                            //
                            //  This may not exist.
                            //
                            g_lpLayout[g_iLayoutBuff].iSpecialID =
                                (UINT)TransNum(szValue);
                        }
                        g_iLayoutBuff++;
                    }
                }
            }

            RegCloseKey(hkey1);
        }

        dwIndex++;
        szValue[0] = TEXT('\0');
        dwRetVal = RegEnumKey( hKey,
                               dwIndex,
                               szValue,
                               sizeof(szValue) / sizeof(TCHAR) );

    } while (dwRetVal == ERROR_SUCCESS);

    cb = sizeof(DWORD);
    g_dwAttributes = 0;
    if (RegQueryValueEx( hKey,
                         c_szAttributes,
                         NULL,
                         NULL,
                         (LPBYTE)&g_dwAttributes,
                         &cb ) != ERROR_SUCCESS)
    {
        g_dwAttributes &= 0x00FF0000;
    }

    RegCloseKey(hKey);

    if (g_hShlwapi)
    {
        FreeLibrary(g_hShlwapi);
        g_hShlwapi = NULL;
        pfnSHLoadRegUIString = NULL;
    }
    return (g_iLayoutBuff);
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_LoadLocales
//
//  Loads the locales from the registry.
//
////////////////////////////////////////////////////////////////////////////

BOOL Locale_LoadLocales(
    HWND hwnd)
{
    HKEY hKey;
    DWORD cchValue, cbData;
    DWORD dwIndex;
    DWORD dwLocale, dwLayout;
    DWORD dwLocale2, dwLayout2;
    LONG dwRetVal;
    UINT ctr1, ctr2 = 0;
    TCHAR szValue[MAX_PATH];           // language id (number)
    TCHAR szData[MAX_PATH];            // language name
    HINF hIntlInf;
    BOOL bRet;

    if (!(g_hLang = LocalAlloc(LHND, ALLOCBLOCK * sizeof(INPUTLANG))))
    {
        Locale_EnablePane(hwnd, FALSE, IDC_KBDL_DISABLED);
        return (FALSE);
    }

    g_nLangBuffSize = ALLOCBLOCK;
    g_iLangBuff = 0;
    g_lpLang = LocalLock(g_hLang);

    //
    //  Now read all of the locales from the registry.
    //
    if (RegOpenKey(HKEY_LOCAL_MACHINE, c_szLocaleInfo, &hKey) != ERROR_SUCCESS)
    {
        Locale_EnablePane(hwnd, FALSE, IDC_KBDL_DISABLED);
        return (FALSE);
    }

    dwIndex = 0;
    cchValue = sizeof(szValue) / sizeof(TCHAR);
    cbData = sizeof(szData);
    dwRetVal = RegEnumValue( hKey,
                             dwIndex,
                             szValue,
                             &cchValue,
                             NULL,
                             NULL,
                             (LPBYTE)szData,
                             &cbData );


    if (dwRetVal != ERROR_SUCCESS)
    {
        Locale_EnablePane(hwnd, FALSE, IDC_KBDL_DISABLED);
        RegCloseKey(hKey);
        return (FALSE);
    }

    //
    //  Open the INF file.
    //
    bRet = Region_OpenIntlInfFile(&hIntlInf);

    do
    {
        //
        //  Check for cchValue > 1 - an empty string will be enumerated,
        //  and will come back with cchValue == 1 for the null terminator.
        //  Also, check for cbData > 2 - an empty string will be 2, since
        //  this is the count of bytes.
        //
        if ((cchValue > 1) && (cchValue < HKL_LEN) && (cbData > 2))
        {
            //
            //  New language - get the language name and the language id.
            //
            if ((g_iLangBuff + 1) == g_nLangBuffSize)
            {
                HANDLE hTemp;

                LocalUnlock(g_hLang);

                g_nLangBuffSize += ALLOCBLOCK;
                hTemp = LocalReAlloc( g_hLang,
                                      g_nLangBuffSize * sizeof(INPUTLANG),
                                      LHND );
                if (hTemp == NULL)
                {
                    break;
                }

                g_hLang = hTemp;
                g_lpLang = LocalLock(g_hLang);
            }

            g_lpLang[g_iLangBuff].dwID = TransNum(szValue);
            g_lpLang[g_iLangBuff].iUseCount = 0;
            g_lpLang[g_iLangBuff].iNumCount = 0;
            g_lpLang[g_iLangBuff].pNext = NULL;

            //
            //  Get the default keyboard layout for the language.
            //
            if (bRet && Region_ReadDefaultLayoutFromInf( szValue,
                                                         &dwLocale,
                                                         &dwLayout,
                                                         &dwLocale2,
                                                         &dwLayout2,
                                                         hIntlInf ) == TRUE)
            {
                //
                // The default layout is either the first layout in the inf file line
                // or it's the first layout in the line that has the same language
                // is the locale.
                g_lpLang[g_iLangBuff].dwDefaultLayout = dwLayout2?dwLayout2:dwLayout;
            }

            //
            //  Get the full localized name of the language.
            //
            if (GetLanguageName(LOWORD(g_lpLang[g_iLangBuff].dwID), szData, ARRAYSIZE(szData)))
            {
                g_lpLang[g_iLangBuff].atmLanguageName = AddAtom(szData);
                g_iLangBuff++;
            }
        }

        dwIndex++;
        cchValue = sizeof(szValue) / sizeof(TCHAR);
        szValue[0] = TEXT('\0');
        cbData = sizeof(szData);
        szData[0] = TEXT('\0');
        dwRetVal = RegEnumValue( hKey,
                                 dwIndex,
                                 szValue,
                                 &cchValue,
                                 NULL,
                                 NULL,
                                 (LPBYTE)szData,
                                 &cbData );

    } while (dwRetVal == ERROR_SUCCESS);

    //
    //  If we succeeded in opening the INF file, close it.
    //
    if (bRet)
    {
        Region_CloseInfFile(&hIntlInf);
    }

    RegCloseKey(hKey);
    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////
//
//  Locale_LoadLocalesNT4
//
//  Loads the locales from the registry.
//
////////////////////////////////////////////////////////////////////////////

BOOL Locale_LoadLocalesNT4(
    HWND hwnd)
{
    HKEY hKey;
    DWORD cch;
    DWORD dwIndex;
    LONG dwRetVal;
    UINT i, j = 0;

    TCHAR szValue[MAX_PATH];           // language id (number)
    TCHAR szData[MAX_PATH];            // language name

    if (!(g_hLang = LocalAlloc(LHND, ALLOCBLOCK * sizeof(INPUTLANG))))
    {
        Locale_EnablePane(hwnd, FALSE, IDC_KBDL_DISABLED);
        return (FALSE);
    }

    g_nLangBuffSize = ALLOCBLOCK;
    g_iLangBuff = 0;
    g_lpLang = LocalLock(g_hLang);

    //
    //  Now read all of the locales from the registry.
    //
    if (RegOpenKey(HKEY_LOCAL_MACHINE, c_szLocaleInfoNT4, &hKey) != ERROR_SUCCESS)
    {
        Locale_EnablePane(hwnd, FALSE, IDC_KBDL_DISABLED);
        return (FALSE);
    }

    dwIndex = 0;
    cch = sizeof(szValue) / sizeof(TCHAR);
    dwRetVal = RegEnumValue( hKey,
                             dwIndex,
                             szValue,
                             &cch,
                             NULL,
                             NULL,
                             NULL,
                             NULL );

    if (dwRetVal != ERROR_SUCCESS)
    {
        Locale_EnablePane(hwnd, FALSE, IDC_KBDL_DISABLED);
        RegCloseKey(hKey);
        return (FALSE);
    }

    do
    {
        if ((cch > 1) && (cch < HKL_LEN))
        {
            //
            //  Check for cch > 1: an empty string will be enumerated,
            //  and will come back with cch == 1 for the null terminator.
            //
            //  New language - get the language name, the language
            //  description, and the language id.
            //
            if ((g_iLangBuff + 1) == g_nLangBuffSize)
            {
                HANDLE hTemp;

                LocalUnlock(g_hLang);

                g_nLangBuffSize += ALLOCBLOCK;
                hTemp = LocalReAlloc( g_hLang,
                                      g_nLangBuffSize * sizeof(INPUTLANG),
                                      LHND );
                if (hTemp == NULL)
                {
                    break;
                }

                g_hLang = hTemp;
                g_lpLang = LocalLock(g_hLang);
            }

            g_lpLang[g_iLangBuff].dwID = TransNum(szValue);
            g_lpLang[g_iLangBuff].iUseCount = 0;
            g_lpLang[g_iLangBuff].iNumCount = 0;
            g_lpLang[g_iLangBuff].pNext = NULL;

            //
            //  Get the full localized name of the language.
            //
            if (GetLanguageName(LOWORD(g_lpLang[g_iLangBuff].dwID), szData, ARRAYSIZE(szData)))
            {
                g_lpLang[g_iLangBuff].atmLanguageName = AddAtom(szData);

                g_iLangBuff++;
            }
        }

        dwIndex++;
        cch = sizeof(szValue) / sizeof(TCHAR);
        szValue[0] = TEXT('\0');
        dwRetVal = RegEnumValue( hKey,
                                 dwIndex,
                                 szValue,
                                 &cch,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL );

    } while (dwRetVal == ERROR_SUCCESS);

    RegCloseKey(hKey);
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_GetActiveLocales
//
//  Gets the active locales.
//
////////////////////////////////////////////////////////////////////////////

BOOL Locale_GetActiveLocales(
    HWND hwnd)
{
    HKL *pLangs;
    UINT nLangs, ctr1, ctr2, ctr3, id;
    HWND hwndList = GetDlgItem(hwnd, IDC_INPUT_LIST);
    HKL hklSystem = 0;
    int idxListBox;
    BOOL bReturn = FALSE;
    BOOL bTipSubhkl = FALSE;
    DWORD langLay;
    HANDLE hLangNode;
    LPLANGNODE pLangNode;
    HICON hIcon = NULL;

    TCHAR szLangText[DESC_MAX];
    TCHAR szLayoutName[DESC_MAX];
    LPINPUTLANG pInpLang;
    HTREEITEM hTVItem;
    TV_ITEM tvItem;


    //
    //  Initialize US layout option.
    //
    g_iUsLayout = -1;

    //
    //  Get the active keyboard layout list from the system.
    //
    if (!SystemParametersInfo( SPI_GETDEFAULTINPUTLANG,
                               0,
                               &hklSystem,
                               0 ))
    {
        hklSystem = GetKeyboardLayout(0);
    }

    nLangs = GetKeyboardLayoutList(0, NULL);
    if (nLangs == 0)
    {
        Locale_EnablePane(hwnd, FALSE, IDC_KBDL_DISABLED);
        return bReturn;
    }
    pLangs = (HKL *)LocalAlloc(LPTR, sizeof(DWORD_PTR) * nLangs);

    if (pLangs == NULL)
    {
        Locale_EnablePane(hwnd, FALSE, IDC_KBDL_DISABLED);
        return bReturn;
    }

    GetKeyboardLayoutList(nLangs, (HKL *)pLangs);

    //
    //  Find the position of the US layout to use as a default.
    //
    for (ctr1 = 0; ctr1 < g_iLayoutBuff; ctr1++)
    {
        if (g_lpLayout[ctr1].dwID == US_LOCALE)
        {
            g_iUsLayout = ctr1;
            break;
        }
    }
    if (ctr1 == g_iLayoutBuff)
    {
        Locale_EnablePane(hwnd, FALSE, IDC_KBDL_DISABLED);
        goto Error;
    }

    //
    //  Get the active keyboard information and put it in the internal
    //  language structure.
    //
    for (ctr2 = 0; ctr2 < nLangs; ctr2++)
    {
        //
        //  Filter out TIP substitute HKL from TreeView.
        //
        bTipSubhkl = IsTipSubstituteHKL(pLangs[ctr2]);

        if (hklSystem != pLangs[ctr2] &&
            IsUnregisteredFEDummyHKL(pLangs[ctr2]))
        {
            continue;
        }

        for (ctr1 = 0; ctr1 < g_iLangBuff; ctr1++)
        {
            //
            //  See if there's a match.
            //
            if (LOWORD(pLangs[ctr2]) == LOWORD(g_lpLang[ctr1].dwID))
            {
                LPTVITEMNODE pTVItemNode;

                //
                //  Found a match.
                //  Create a node for this language.
                //
                pLangNode = Locale_AddToLinkedList(ctr1, pLangs[ctr2]);
                if (!pLangNode)
                {
                    Locale_EnablePane(hwnd, FALSE, IDC_KBDL_DISABLED);
                    goto Error;
                }

                //
                //  Get language name to add it to treeview
                //
                pInpLang = &g_lpLang[pLangNode->iLang];
                GetAtomName(pInpLang->atmLanguageName, szLangText, ARRAYSIZE(szLangText));

                if ((HIWORD(pLangs[ctr2]) & 0xf000) == 0xe000)
                {
                    pLangNode->wStatus |= LANG_IME;
                }
                pLangNode->wStatus |= (LANG_ORIGACTIVE | LANG_ACTIVE);
                pLangNode->hkl = pLangs[ctr2];
                pLangNode->hklUnload = pLangs[ctr2];
                Locale_FetchIndicator(pLangNode);

                //
                //  Match the language to the layout.
                //
                pLangNode->iLayout = 0;
                langLay = (DWORD)HIWORD(pLangs[ctr2]);

                if ((HIWORD(pLangs[ctr2]) == 0xffff) ||
                    (HIWORD(pLangs[ctr2]) == 0xfffe))
                {
                    //
                    //  Mark default or previous error as US - this
                    //  means that the layout will be that of the basic
                    //  keyboard driver (the US one).
                    //
                    pLangNode->wStatus |= LANG_CHANGED;
                    pLangNode->iLayout = g_iUsLayout;
                    langLay = 0;
                }
                else if ((HIWORD(pLangs[ctr2]) & 0xf000) == 0xf000)
                {
                    //
                    //  Layout is special, need to search for the ID
                    //  number.
                    //
                    id = HIWORD(pLangs[ctr2]) & 0x0fff;
                    for (ctr3 = 0; ctr3 < g_iLayoutBuff; ctr3++)
                    {
                        if (id == g_lpLayout[ctr3].iSpecialID)
                        {
                            pLangNode->iLayout = ctr3;
                            langLay = 0;
                            break;
                        }
                    }
                    if (langLay)
                    {
                        //
                        //  Didn't find the id, so reset to basic for
                        //  the language.
                        //
                        langLay = (DWORD)LOWORD(pLangs[ctr2]);
                    }
                }

                if (langLay)
                {
                    //
                    //  Search for the id.
                    //
                    for (ctr3 = 0; ctr3 < g_iLayoutBuff; ctr3++)
                    {
                        if (((LOWORD(langLay) & 0xf000) == 0xe000) &&
                            (g_lpLayout[ctr3].dwID) == (DWORD)((DWORD_PTR)(pLangs[ctr2])))
                        {
                            pLangNode->iLayout = ctr3;
                            break;
                        }
                        else
                        {
                            if (langLay == (DWORD)LOWORD(g_lpLayout[ctr3].dwID))
                            {
                                pLangNode->iLayout = ctr3;
                                break;
                            }
                        }
                    }

                    if (ctr3 == g_iLayoutBuff)
                    {
                        //
                        //  Something went wrong or didn't load from
                        //  the registry correctly.
                        //
                        MessageBeep(MB_ICONEXCLAMATION);
                        pLangNode->wStatus |= LANG_CHANGED;
                        pLangNode->iLayout = g_iUsLayout;
                    }
                }

                //
                //  If this is the current language, then it's the default
                //  one.
                //
                if ((DWORD)((DWORD_PTR)pLangNode->hkl) == (DWORD)((DWORD_PTR)hklSystem))
                {
                    TCHAR sz[DESC_MAX];

                    pInpLang = &g_lpLang[ctr1];

                    //
                    //  Found the default.  Set the Default input locale
                    //  text in the property sheet.
                    //
                    if (pLangNode->wStatus & LANG_IME)
                    {
                        GetAtomName(g_lpLayout[pLangNode->iLayout].atmLayoutText,
                                    sz,
                                    ARRAYSIZE(sz));
                    }
                    else
                    {
                        GetAtomName(pInpLang->atmLanguageName, sz, ARRAYSIZE(sz));
                    }
                    pLangNode->wStatus |= LANG_DEFAULT;
                }

                // Get layout name and add it to treeview
                GetAtomName(g_lpLayout[pLangNode->iLayout].atmLayoutText,
                            szLayoutName,
                            ARRAYSIZE(szLayoutName));

                if (bTipSubhkl)
                {
                    AddKbdLayoutOnKbdTip((HKL) ((DWORD_PTR)(pLangs[ctr2])), pLangNode->iLayout);
                }

                if (bTipSubhkl &&
                    (hTVItem = FindTVLangItem(pInpLang->dwID, NULL)))
                {
                    TV_ITEM tvTipItem;
                    HTREEITEM hGroupItem;
                    HTREEITEM hTipItem;
                    LPTVITEMNODE pTVTipItemNode;

                    tvItem.mask = TVIF_HANDLE | TVIF_PARAM;
                    tvItem.hItem = hTVItem;
                    
                    //GetAtomName(pTVItemNode->atmDefTipName, szLayoutName, ARRAYSIZE(szLayoutName));

                    tvTipItem.mask = TVIF_HANDLE | TVIF_PARAM;
                    tvTipItem.hItem = hTVItem;

                    //
                    //  Adding the default keyboard layout info into each TIPs.
                    //
                    for (hGroupItem = TreeView_GetChild(g_hwndTV, hTVItem);
                         hGroupItem != NULL;
                         hGroupItem = TreeView_GetNextSibling(g_hwndTV, hGroupItem))
                    {
                        for (hTipItem = TreeView_GetChild(g_hwndTV, hGroupItem);
                             hTipItem != NULL;
                             hTipItem = TreeView_GetNextSibling(g_hwndTV, hTipItem))
                        {
                            tvTipItem.hItem = hTipItem;
                            if (TreeView_GetItem(g_hwndTV, &tvTipItem) && tvTipItem.lParam)
                            {
                                pTVTipItemNode = (LPTVITEMNODE) tvTipItem.lParam;

                                if (pTVTipItemNode->hklSub == pLangNode->hkl)
                                {
                                    pTVTipItemNode->lParam = (LPARAM) pLangNode;
                                }
                            }
                        }

                    }

                    if (pLangNode->wStatus & LANG_DEFAULT)
                    {
                        UINT ctr;
                        TCHAR szDefItem[MAX_PATH];

                        //
                        //  Set the default locale selection.
                        //
                        HWND hwndDefList = GetDlgItem(g_hDlg, IDC_LOCALE_DEFAULT);
                        int idxSel = -1;


                        //
                        //  Search substitute HKL of Tips.
                        //
                        for (ctr = 0; ctr < g_iTipsBuff; ctr++)
                        {
                            if (pLangs[ctr2] == g_lpTips[ctr].hklSub &&
                                g_lpTips[ctr].bDefault)
                            {
                                GetAtomName(g_lpTips[ctr].atmTipText,
                                            szLayoutName,
                                            ARRAYSIZE(szLayoutName));
                                break;
                            }
                        }

                        StringCchCopy(szDefItem, ARRAYSIZE(szDefItem), szLangText);
                        StringCchCat(szDefItem, ARRAYSIZE(szDefItem), TEXT(" - "));
                        StringCchCat(szDefItem, ARRAYSIZE(szDefItem), szLayoutName);

                        if ((idxSel = ComboBox_FindStringExact(hwndDefList, 0, szDefItem)) != CB_ERR)
                            ComboBox_SetCurSel(hwndDefList, idxSel);

                        Locale_CommandSetDefault(hwnd);
                    }
                }
                else
                {
                    //
                    //
                    //
                    if (!(pTVItemNode = CreateTVItemNode(pInpLang->dwID)))
                        goto Error;

                    pTVItemNode->lParam = (LPARAM)pLangNode;

                    if (!pTVItemNode->atmDefTipName)
                        pTVItemNode->atmDefTipName = AddAtom(szLayoutName);

                    //
                    //  Add language node into treeview
                    //
                    AddTreeViewItems(TV_ITEM_TYPE_LANG,
                                     szLangText, NULL, NULL, &pTVItemNode);

                    if (!(pTVItemNode = CreateTVItemNode(pInpLang->dwID)))
                        goto Error;

                    pTVItemNode->lParam = (LPARAM)pLangNode;

                    //
                    //  Add keyboard layout item into treeview
                    //
                    hTVItem = AddTreeViewItems(TV_ITEM_TYPE_KBD,
                                               szLangText,
                                               szInputTypeKbd,
                                               szLayoutName,
                                               &pTVItemNode);
                }

                //
                //  Check Thai layout.
                //
                if (g_dwPrimLangID == LANG_THAI && hTVItem)
                {
                    if (PRIMARYLANGID(LOWORD(g_lpLayout[pLangNode->iLayout].dwID)) == LANG_THAI)
                        g_iThaiLayout++;
                }

                //
                //  Break out of inner loop - we've found it.
                //
                break;

            }
        }
    }

    bReturn = TRUE;

Error:
    if (pLangs)
        LocalFree((HANDLE)pLangs);
    return (bReturn);
}

////////////////////////////////////////////////////////////////////////////
//
//  GetInstalledInput
//
////////////////////////////////////////////////////////////////////////////

BOOL GetInstalledInput(HWND hwnd)
{
    DWORD dwLayout = 0;
    LANGID langID;

    //
    //  Reset the installed input
    //
    g_iInputs = 0;


    //
    //  Need to check language id for Thai, Chinese and Arabic.
    //
    g_dwPrimLangID = PRIMARYLANGID(LANGIDFROMLCID(GetSystemDefaultLCID()));

    if (g_dwPrimLangID == LANG_ARABIC || g_dwPrimLangID == LANG_HEBREW)
    {
        g_bMESystem = TRUE;
    }
#if 0
    else if (g_dwPrimLangID == LANG_CHINESE)
    {
        g_bCHSystem = TRUE;
    }
#endif

    langID = GetUserDefaultUILanguage();
    if (PRIMARYLANGID(langID) == LANG_ARABIC || PRIMARYLANGID(langID) == LANG_HEBREW)
    {
        g_bShowRtL = TRUE;
    }

    //
    //  Enum new tips(speech, pen and keyboard).
    //  If there are new tips in the system, read tip category enabling status
    //  and add them into tree view control.
    //
    EnumCiceroTips();

    //
    //  Read all availabe keyboard layouts from system
    //
    if (g_OSNT4)
    {
        if (!Locale_LoadLocalesNT4(hwnd))
            return FALSE;
    }
    else
    {
        if (!Locale_LoadLocales(hwnd))
            return FALSE;
    }

    if ((!Locale_LoadLayouts(hwnd)) ||
        (!Locale_GetActiveLocales(hwnd)))
        return FALSE;

    //
    //  Only 1 TIP, so disable the secondary controls.
    //
    Locale_SetSecondaryControls(hwnd);

    //
    //  Save the originial input layouts
    //
    g_iOrgInputs = g_iInputs;

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
//  InitPropSheet
//
//  Processing for a WM_INITDIALOG message for the Input Locales
//  property sheet.
//
////////////////////////////////////////////////////////////////////////////

void InitPropSheet(
    HWND hwnd,
    LPPROPSHEETPAGE psp)
{
    HKEY hKey;
    HANDLE hlib;
    HWND hwndList;
    LPLANGNODE pLangNode;
    LANGID LangID;
    UINT iNumLangs, ctr;
    TCHAR szItem[DESC_MAX];
    BOOL bImeSetting = FALSE;

    //
    //  See if there are any other instances of this property page.
    //  If so, disable this page.
    //
    if (g_hMutex && (WaitForSingleObject(g_hMutex, 0) != WAIT_OBJECT_0))
    {
        // Need to disable controls ...
        Locale_EnablePane(hwnd, FALSE, IDC_KBDL_DISABLED_2);
        return;
    }

    //
    //  See if we're in setup mode.
    //
    if (IsSetupMode())
    {
        //
        //  Set the setup special case flag.
        //
        g_bSetupCase = TRUE;
    }

    //
    //  Make sure the event is clear.
    //
    if (g_hEvent)
    {
        SetEvent(g_hEvent);
    }

    g_OSNT4 = IsOSPlatform(OS_NT4);
    g_OSNT5 = IsOSPlatform(OS_NT5);
#ifndef _WIN64
    g_OSWIN95 = IsOSPlatform(OS_WIN95);
#endif // _WIN64

    //
    //  Check the Administrative privileges by the token group SID.
    //
    if (IsAdminPrivilegeUser())
    {
        g_bAdmin_Privileges = TRUE;
    }
    else
    {
        //
        //  The user does not have admin privileges.
        //
        g_bAdmin_Privileges = FALSE;
    }

    //
    //  Load the strings
    //
    LoadString(hInstance, IDS_LOCALE_DEFAULT, szDefault, ARRAYSIZE(szDefault));
    LoadString(hInstance, IDS_INPUT_KEYBOARD, szInputTypeKbd, ARRAYSIZE(szInputTypeKbd));
    LoadString(hInstance, IDS_INPUT_PEN, szInputTypePen, ARRAYSIZE(szInputTypePen));
    LoadString(hInstance, IDS_INPUT_SPEECH, szInputTypeSpeech, ARRAYSIZE(szInputTypeSpeech));
    LoadString(hInstance, IDS_INPUT_EXTERNAL, szInputTypeExternal, ARRAYSIZE(szInputTypeExternal));
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_CommandAdd
//
//  Invokes the Add dialog.
//
//  Returns 1 if a dialog box was invoked and the dialog returned IDOK.
//  Otherwise, it returns 0.
//
////////////////////////////////////////////////////////////////////////////

int Locale_CommandAdd(
    HWND hwnd)
{
    HWND hwndList;
    HWND hwndTV;
    int idxList;
    UINT nList;
    int rc = 0;
    INITINFO InitInfo;
    LPCTSTR lpTemplateName;
    HINSTANCE hInstRes;

    HTREEITEM hTVItem;

    hwndTV = GetDlgItem(hwnd, IDC_INPUT_LIST);
    hTVItem = TreeView_GetSelection(hwndTV);

    if (!hTVItem)
        return 0;

    InitInfo.hwndMain = hwnd;
    InitInfo.pLangNode = NULL;

    if (g_bExtraTip)
    {
        hInstRes = GetCicResInstance(hInstance, DLG_KEYBOARD_LOCALE_ADD_EXTRA);
        lpTemplateName = MAKEINTRESOURCE(DLG_KEYBOARD_LOCALE_ADD_EXTRA);
    }
    else if (g_bPenOrSapiTip)
    {
        hInstRes = GetCicResInstance(hInstance, DLG_KEYBOARD_LOCALE_ADD);
        lpTemplateName = MAKEINTRESOURCE(DLG_KEYBOARD_LOCALE_ADD);
    }
    else
    {
        hInstRes = GetCicResInstance(hInstance, DLG_KEYBOARD_LOCALE_SIMPLE_ADD);
        lpTemplateName = MAKEINTRESOURCE(DLG_KEYBOARD_LOCALE_SIMPLE_ADD);
    }

    //
    //  Bring up the appropriate dialog box. And check return value for added
    //  items.
    //
    if ((rc = (int)DialogBoxParam(hInstRes,
                                  lpTemplateName,
                                  hwnd,
                                  KbdLocaleAddDlg,
                                  (LPARAM)(&InitInfo) )) == IDOK)
    {
        //
        //  Turn on ApplyNow button.
        //
        PropSheet_Changed(GetParent(hwnd), hwnd);
    }
    else
    {
        //
        //  Failure, so need to return 0.
        //
        TreeView_SelectItem(hwndTV, hTVItem);
        rc = 0;
    }

    return (rc);
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_CommandEdit
//
//  Invokes the Properties dialog.
//
//  Returns 1 if a dialog box was invoked and the dialog returned IDOK.
//  Otherwise, it returns 0.
//
////////////////////////////////////////////////////////////////////////////

void Locale_CommandEdit(
    HWND hwnd,
    LPLANGNODE pLangNode)
{
    HWND hwndList;
    HWND hwndTV;
    int idxList;
    UINT nList;
    int rc = 0;
    INITINFO InitInfo;

    HTREEITEM hTVItem;
    TV_ITEM tvItem;
    LPTVITEMNODE pTVItemNode;

    hTVItem = TreeView_GetSelection(g_hwndTV);

    if (!hTVItem)
        return;

    tvItem.mask = TVIF_HANDLE | TVIF_PARAM;
    tvItem.hItem = hTVItem;

    if (TreeView_GetItem(g_hwndTV, &tvItem) && tvItem.lParam)
    {
        pTVItemNode = (LPTVITEMNODE) tvItem.lParam;

        if (pTVItemNode->uInputType & INPUT_TYPE_TIP)
        {
            HRESULT hr;

            ITfFnConfigure *pConfig = NULL;

            //
            //  Load LangBar manager to bring the property window
            //
            hr = CoCreateInstance(&pTVItemNode->clsid,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  &IID_ITfFnConfigure,
                                  (LPVOID *) &pConfig);

            //
            //  Call property dialog from TIP.
            //
            if (SUCCEEDED(hr))
                pConfig->lpVtbl->Show(pConfig, 
                                      hwnd,
                                      (LANGID)pTVItemNode->dwLangID,
                                      &pTVItemNode->guidProfile);

            if (pConfig)
                pConfig->lpVtbl->Release(pConfig);

        }
        else
        {
            if ((pLangNode = (LPLANGNODE)pTVItemNode->lParam) && (pLangNode->wStatus & LANG_IME))
                ImmConfigureIME(pLangNode->hkl, hwnd, IME_CONFIG_GENERAL, NULL);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  RemoveTVSubItems
//
////////////////////////////////////////////////////////////////////////////

BOOL RemoveTVSubItems(
    HWND hwnd,
    HTREEITEM hTVItem,
    LPTVITEMNODE pTVItemNode)
{
    TV_ITEM tvItem;
    BOOL bRemoveAll = TRUE;
    HTREEITEM hGroupItem, hItem;
    HWND hwndTV = GetDlgItem(g_hDlg, IDC_INPUT_LIST);

    //
    //  Delete all TreeView node.
    //
    tvItem.mask        = TVIF_HANDLE | TVIF_PARAM;

    if (pTVItemNode->uInputType & TV_ITEM_TYPE_LANG)
    {
        hGroupItem = TreeView_GetChild(hwndTV, hTVItem);
    }
    else
    {
        hGroupItem = hTVItem;
        bRemoveAll = FALSE;
    }

    while (hGroupItem != NULL)
    {
        BOOL bNextGroup = FALSE;
        LPTVITEMNODE pTVTempNode = NULL;
        HTREEITEM hDeletedItem = NULL;

        for (hItem = TreeView_GetChild(hwndTV, hGroupItem);
             hItem != NULL;
             hItem = TreeView_GetNextSibling(hwndTV, hItem))
        {
            if (hDeletedItem)
            {
                TreeView_DeleteItem(hwndTV, hDeletedItem);
                hDeletedItem = NULL;
            }
            tvItem.hItem = hItem;
            if (TreeView_GetItem(hwndTV, &tvItem) && tvItem.lParam)
            {
                LPLANGNODE pLangNode = NULL;

                if (pTVTempNode = (LPTVITEMNODE) tvItem.lParam)
                    pLangNode = (LPLANGNODE)pTVTempNode->lParam;
                else
                    continue;

                if (pTVTempNode->uInputType & INPUT_TYPE_TIP)
                {
                    g_lpTips[pTVTempNode->iIdxTips].bEnabled = FALSE;
                    g_iEnabledTips--;

                    if (pTVTempNode->uInputType & INPUT_TYPE_KBD)
                        g_iEnabledKbdTips--;

                    g_dwChanges |= CHANGE_TIPCHANGE;

                    if ((pTVTempNode->uInputType & INPUT_TYPE_KBD) && pTVTempNode->hklSub)
                    {
                        UINT ctr;
                        UINT uNumSubhkl = 0;

                        for (ctr = 0; ctr < g_iTipsBuff; ctr++)
                        {
                            if (pTVTempNode->hklSub == g_lpTips[ctr].hklSub &&
                                g_lpTips[ctr].bEnabled)
                            {
                                uNumSubhkl++;
                            }
                        }

                        if (!uNumSubhkl)
                        {
                            pLangNode = (LPLANGNODE)pTVTempNode->lParam;
                        }
                        else
                        {
                            //
                            //  Someone still use this substitute HKL.
                            //
                            pLangNode = NULL;
                        }
                    }
                }

                if ((pTVTempNode->uInputType & TV_ITEM_TYPE_KBD) && pLangNode)
                {
                    if (!(pTVTempNode->uInputType & INPUT_TYPE_TIP))
                        pLangNode = (LPLANGNODE)pTVTempNode->lParam;

                    if (!pLangNode)
                        return FALSE;

                    //
                    //  Check Thai layout.
                    //
                    if (g_dwPrimLangID == LANG_THAI)
                    {
                        if (PRIMARYLANGID(LOWORD(g_lpLayout[pLangNode->iLayout].dwID)) == LANG_THAI)
                            g_iThaiLayout--;
                    }

                    pLangNode->wStatus &= ~(LANG_ACTIVE|LANG_DEFAULT);
                    pLangNode->wStatus |= LANG_CHANGED;

                    g_lpLang[pLangNode->iLang].iNumCount--;

                    if (!(pLangNode->wStatus & LANG_ORIGACTIVE))
                    {
                        Locale_RemoveFromLinkedList(pLangNode);
                    }
                }

                RemoveTVItemNode(pTVTempNode);
                hDeletedItem = hItem;
                g_iInputs--;
            }
        }

        tvItem.hItem = hGroupItem;

        if (TreeView_GetItem(hwndTV, &tvItem) && tvItem.lParam)
        {
            pTVTempNode = (LPTVITEMNODE)tvItem.lParam;

            if (!pTVTempNode)
                continue;

            if (pTVTempNode->uInputType & INPUT_TYPE_SPEECH ||
                pTVTempNode->uInputType & INPUT_TYPE_SMARTTAG)
            {
              
                g_lpTips[pTVTempNode->iIdxTips].bEnabled = FALSE;
                g_iEnabledTips--;
                g_dwChanges |= CHANGE_TIPCHANGE;

                if (pTVTempNode->uInputType & INPUT_TYPE_SPEECH)
                    MarkSptipRemoved(TRUE);
            }

            if (pTVTempNode->uInputType & ~TV_ITEM_TYPE_LANG)
            {
                hGroupItem = TreeView_GetNextSibling(hwndTV, hGroupItem);
                bNextGroup = TRUE;
                TreeView_DeleteItem(hwndTV, tvItem.hItem );
            }

            RemoveTVItemNode(pTVTempNode);

            if (pTVTempNode == pTVItemNode)
                pTVItemNode = NULL;
        }

        if (!bNextGroup)
            hGroupItem = TreeView_GetNextSibling(hwndTV, hGroupItem);

        if (!bRemoveAll)
            hGroupItem = NULL;
    }

    if (pTVItemNode && (pTVItemNode->uInputType & TV_ITEM_TYPE_LANG))
    {
        int idxSel = -1;
        TCHAR szItemName[DESC_MAX];
        HWND hwndDefList = GetDlgItem(hwnd, IDC_LOCALE_DEFAULT);

        GetAtomName(pTVItemNode->atmTVItemName, szItemName, ARRAYSIZE(szItemName));

        idxSel = ComboBox_FindString(hwndDefList, 0, szItemName);

        for (; idxSel != CB_ERR; )
        {
            ComboBox_DeleteString(hwndDefList, idxSel);
            idxSel = ComboBox_FindString(hwndDefList, 0, szItemName);
        }

        if (pTVItemNode->bDefLang)
        {
           ComboBox_SetCurSel(hwndDefList, 0);
           Locale_CommandSetDefault(hwnd);
        }

        RemoveTVItemNode(pTVItemNode);
        TreeView_DeleteItem(hwndTV, hTVItem );
    }

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
//  GetNewRemoveItem
//
//  Removes the currently selected input locale from the list.
//
////////////////////////////////////////////////////////////////////////////
HTREEITEM GetNewRemoveItem(
    HWND hwnd,
    HTREEITEM hTVItem,
    BOOL *bDelSameSubhkl,
    LPTSTR lpDelItems,
    UINT cchDelItems)
{
    TV_ITEM tvItem;
    LPTVITEMNODE pTVItemNode;
    HTREEITEM hTVNewItem = hTVItem;
    HTREEITEM hTVLangItem = NULL;
    HWND hwndTV = GetDlgItem(hwnd, IDC_INPUT_LIST);

    tvItem.mask = TVIF_HANDLE | TVIF_PARAM;
    tvItem.hItem = hTVItem;

    if (TreeView_GetItem(hwndTV, &tvItem))
    {
        //
        //  Get the pointer to the lang node from the list box
        //  item data.
        //
        pTVItemNode = (LPTVITEMNODE) tvItem.lParam;

        if (!pTVItemNode)
            goto Error;

        if (pTVItemNode->uInputType & TV_ITEM_TYPE_LANG)
            return hTVItem;

        if (pTVItemNode->uInputType & TV_ITEM_TYPE_GROUP)
        {
             if (!TreeView_GetNextSibling(hwndTV, hTVItem) &&
                 !TreeView_GetPrevSibling(hwndTV, hTVItem))
             {
                 if ((hTVLangItem = TreeView_GetParent(hwndTV, hTVItem)) &&
                     (TreeView_GetNextSibling(hwndTV, hTVLangItem) ||
                      TreeView_GetPrevSibling(hwndTV, hTVLangItem)))
                 {
                     hTVNewItem = TreeView_GetParent(hwndTV, hTVItem);
                 }
             }
        }
        else
        {
             if (!TreeView_GetNextSibling(hwndTV, hTVItem) &&
                 !TreeView_GetPrevSibling(hwndTV, hTVItem))
             {
                 if (hTVNewItem = TreeView_GetParent(hwndTV, hTVItem))
                 {
                     if (!TreeView_GetNextSibling(hwndTV, hTVNewItem) &&
                         !TreeView_GetPrevSibling(hwndTV, hTVNewItem))

                     {
                         if ((hTVLangItem = TreeView_GetParent(hwndTV, hTVNewItem)) &&
                             (TreeView_GetNextSibling(hwndTV, hTVLangItem) ||
                              TreeView_GetPrevSibling(hwndTV, hTVLangItem)))
                         {
                             hTVNewItem = TreeView_GetParent(hwndTV, hTVNewItem);
                         }
                     }
                 }
             }
             else
             {
                 if(pTVItemNode->hklSub)
                 {
                     HTREEITEM hItem;
                     HTREEITEM hTVKbdGrpItem;
                     LPTVITEMNODE pTVTempItem;
                     UINT uSubhklItems = 0;
                     BOOL bFoundOther = FALSE;

                     if (hTVKbdGrpItem = TreeView_GetParent(hwndTV, hTVItem))
                     {
                         for (hItem = TreeView_GetChild(hwndTV, hTVKbdGrpItem);
                              hItem != NULL;
                              hItem = TreeView_GetNextSibling(hwndTV, hItem))
                         {
                              tvItem.hItem = hItem;

                              if (TreeView_GetItem(hwndTV, &tvItem) && tvItem.lParam)
                              {
                                  pTVTempItem = (LPTVITEMNODE) tvItem.lParam;
                              }
                              else
                              {
                                  goto Error;
                              }

                              if (pTVItemNode->hklSub != pTVTempItem->hklSub)
                              {
                                  bFoundOther = TRUE;
                              }
                              else
                              {
                                  TCHAR szItemName[MAX_PATH];

                                  GetAtomName(pTVTempItem->atmTVItemName,
                                              szItemName,
                                              ARRAYSIZE(szItemName));

                                  if (lstrlen(lpDelItems) < MAX_PATH / 2)
                                  {
                                      StringCchCat(lpDelItems, cchDelItems, TEXT("\r\n\t"));
                                      StringCchCat(lpDelItems, cchDelItems, szItemName);
                                  }
                                  else
                                  {
                                      StringCchCat(lpDelItems, cchDelItems, TEXT("..."));
                                  }

                                  uSubhklItems++;
                              }
                         }

                         if (uSubhklItems >= 2)
                             *bDelSameSubhkl = TRUE;

                         if (!bFoundOther)
                         {
                             if (!TreeView_GetNextSibling(hwndTV, hTVKbdGrpItem) &&
                                 !TreeView_GetPrevSibling(hwndTV, hTVKbdGrpItem))
                             {
                                 if ((hTVLangItem = TreeView_GetParent(hwndTV, hTVKbdGrpItem)) &&
                                     (TreeView_GetNextSibling(hwndTV, hTVLangItem) ||
                                      TreeView_GetPrevSibling(hwndTV, hTVLangItem)))
                                 {
                                     hTVNewItem = TreeView_GetParent(hwndTV, hTVKbdGrpItem);
                                 }
                             }
                         }
                    }
                }
            }
        }
   }

Error:
   return hTVNewItem;
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_CommandDelete
//
//  Removes the currently selected input locale from the list.
//
////////////////////////////////////////////////////////////////////////////

void Locale_CommandDelete(
    HWND hwnd)
{
    TV_ITEM tvItem;
    HTREEITEM hTVItem;
    LPTVITEMNODE pTVItemNode;
    TCHAR szDelItems[MAX_PATH];
    LPLANGNODE pLangNode = NULL;
    BOOL bDelSameSubhkl = FALSE;
    BOOL bRemovedDefLayout = FALSE;
    DWORD dwNextLangId;
    HWND hwndTV = GetDlgItem(hwnd, IDC_INPUT_LIST);


    //
    //  Get the current selection in the input locale list.
    //
    hTVItem = TreeView_GetSelection(hwndTV);

    if (!hTVItem)
        return;

    szDelItems[0] = TEXT('\0');

    hTVItem = GetNewRemoveItem(hwnd, hTVItem, &bDelSameSubhkl, szDelItems, ARRAYSIZE(szDelItems));

    if (bDelSameSubhkl)
    {
        TCHAR szTitle[MAX_PATH];
        TCHAR szMsg[MAX_PATH];
        TCHAR szMsg2[MAX_PATH*2];

        CicLoadString(hInstance, IDS_DELETE_CONFIRMTITLE, szTitle, ARRAYSIZE(szTitle));
        CicLoadString(hInstance, IDS_DELETE_TIP, szMsg, ARRAYSIZE(szMsg));
        StringCchPrintf(szMsg2, ARRAYSIZE(szMsg2), szMsg, szDelItems);

        if (MessageBox(hwnd, szMsg2, szTitle, MB_YESNO|MB_ICONQUESTION ) == IDNO)
        {
            return;
        }
    }

    tvItem.mask = TVIF_HANDLE | TVIF_PARAM;
    tvItem.hItem = hTVItem;

    if (TreeView_GetItem(hwndTV, &tvItem))
    {
        //
        //  Get the pointer to the lang node from the list box
        //  item data.
        //
        pTVItemNode = (LPTVITEMNODE) tvItem.lParam;

        if (!pTVItemNode)
	    return;

        if ((pTVItemNode->uInputType & TV_ITEM_TYPE_LANG) ||
            (pTVItemNode->uInputType & TV_ITEM_TYPE_GROUP))
        {
            if (RemoveTVSubItems(hwnd, hTVItem, pTVItemNode))
                goto ItemChanged;

            return;
        }

        if (pTVItemNode->uInputType & INPUT_TYPE_KBD)
        {
            pLangNode = (LPLANGNODE)pTVItemNode->lParam;
        }
    }
    else
    {
        //
        //  Make sure we're not removing the only entry in the list.
        //
        MessageBeep(MB_ICONEXCLAMATION);
        return;
    }


    if (pTVItemNode->uInputType & INPUT_TYPE_TIP)
    {
        g_lpTips[pTVItemNode->iIdxTips].bEnabled = FALSE;
        g_iEnabledTips--;

        if (pTVItemNode->uInputType & INPUT_TYPE_KBD)
            g_iEnabledKbdTips--;

        if (pTVItemNode->uInputType & INPUT_TYPE_SPEECH)
        {
            // mark SPTIP's hack entry
            MarkSptipRemoved(TRUE);
        }

        g_dwChanges |= CHANGE_TIPCHANGE;

        if ((pTVItemNode->uInputType & INPUT_TYPE_KBD) && pTVItemNode->hklSub)
        {
            UINT ctr;

            for (ctr = 0; ctr < g_iTipsBuff; ctr++)
            {
                if (pTVItemNode->hklSub == g_lpTips[ctr].hklSub &&
                    g_lpTips[ctr].bEnabled)
                {
                    HTREEITEM hDelItem;
                    TCHAR szTipText[MAX_PATH];

                    g_iEnabledTips--;
                    g_iEnabledKbdTips--;
                    g_lpTips[ctr].bEnabled = FALSE;

                    GetAtomName(g_lpTips[ctr].atmTipText,
                                szTipText,
                                ARRAYSIZE(szTipText));

                    //
                    //  Find the installed same keyboard TIP layout to delete it
                    //  together.
                    //
                    if (hDelItem = FindTVItem(g_lpTips[ctr].dwLangID,
                                              szTipText))
                    {
                        tvItem.hItem = hDelItem;

                        if (TreeView_GetItem(g_hwndTV, &tvItem) && tvItem.lParam)
                        {
                            RemoveTVItemNode((LPTVITEMNODE)tvItem.lParam);
                            TreeView_DeleteItem(g_hwndTV, tvItem.hItem );
                        }

                        g_iInputs--;
                    }
                }
            }

        }
    }

    if (pTVItemNode->uInputType & INPUT_TYPE_KBD && pLangNode)
    {
        //
        //  Check Thai layout.
        //
        if (g_dwPrimLangID == LANG_THAI)
        {
            if (PRIMARYLANGID(LOWORD(g_lpLayout[pLangNode->iLayout].dwID)) == LANG_THAI)
                g_iThaiLayout--;
        }

        if (pLangNode->wStatus & LANG_DEFAULT)
        {
            bRemovedDefLayout = TRUE;
            dwNextLangId = pTVItemNode->dwLangID;
        }

        //
        //  Set the input locale to be not active and show that its state
        //  has changed.  Also, delete the string from the input locale list
        //  in the property sheet.
        //
        //  Decrement the number of nodes for this input locale.
        //
        pLangNode->wStatus &= ~(LANG_ACTIVE|LANG_DEFAULT);
        pLangNode->wStatus |= LANG_CHANGED;

        g_lpLang[pLangNode->iLang].iNumCount--;

        //
        //  If it wasn't originally active, then remove it from the list.
        //  There's nothing more to do with this node.
        //
        if (!(pLangNode->wStatus & LANG_ORIGACTIVE))
        {
            Locale_RemoveFromLinkedList(pLangNode);
        }
    }

    g_iInputs--;
    RemoveTVItemNode(pTVItemNode);
    TreeView_DeleteItem(hwndTV, hTVItem);

    //
    //  Set the next available default layout
    //
    if (bRemovedDefLayout)
    {
        int idxSel = -1;
        TCHAR szNextDefTip[MAX_PATH];
        TCHAR szDefLayout[MAX_PATH * 2];
        LPTVITEMNODE pTVLangItemNode = NULL;
        HWND hwndDefList = GetDlgItem(hwnd, IDC_LOCALE_DEFAULT);

        SetNextDefaultLayout(dwNextLangId,
                             TRUE,
                             szNextDefTip,
                             ARRAYSIZE(szNextDefTip));

        if (tvItem.hItem = FindTVLangItem(dwNextLangId, NULL))
        {
            tvItem.mask = TVIF_HANDLE | TVIF_PARAM;

            if (TreeView_GetItem(g_hwndTV, &tvItem) && tvItem.lParam)
            {
                pTVLangItemNode = (LPTVITEMNODE) tvItem.lParam;

                if (pTVLangItemNode->atmDefTipName)
                    DeleteAtom(pTVLangItemNode->atmDefTipName);
                pTVLangItemNode->atmDefTipName = AddAtom(szNextDefTip);

                GetAtomName(pTVLangItemNode->atmTVItemName,
                            szDefLayout,
                            MAX_PATH);

                StringCchCat(szDefLayout, ARRAYSIZE(szDefLayout), TEXT(" - "));
                StringCchCat(szDefLayout, ARRAYSIZE(szDefLayout), szNextDefTip);
            }
        }

        idxSel = ComboBox_FindString(hwndDefList, 0, szDefLayout);

        if (idxSel == CB_ERR)
            idxSel = 0;

        ComboBox_SetCurSel(hwndDefList, idxSel);
    }

    //
    //  Find keyboard group dangling node that doesn't has child keyboard
    //  layout item.
    //
    hTVItem = TreeView_GetSelection(hwndTV);

    if (!hTVItem)
        return;

    tvItem.hItem = hTVItem;
    tvItem.mask = TVIF_HANDLE | TVIF_PARAM;
    
    if (TreeView_GetItem(g_hwndTV, &tvItem) && tvItem.lParam)
    {
        if ((pTVItemNode = (LPTVITEMNODE) tvItem.lParam))
        {
            if ((pTVItemNode->uInputType & INPUT_TYPE_KBD) &&
                (pTVItemNode->uInputType & TV_ITEM_TYPE_GROUP))
            {
                if (TreeView_GetChild(hwndTV, hTVItem) == NULL)
                {
                    //
                    //  Delete keyboard group dangling node
                    //
                    RemoveTVItemNode(pTVItemNode);
                    TreeView_DeleteItem(hwndTV, hTVItem);
                }
            }
        }
    }

ItemChanged:
    //
    // Only 1 active tip, so disable the secondary controls.
    //
    Locale_SetSecondaryControls(hwnd);

    //
    //  Update the default locale switch hotkey.
    //
    Locale_SetDefaultHotKey(hwnd, FALSE);

    //
    // Move the focus to the Add button if the Remove button
    // is now disabled (so that we don't lose input focus)
    //
    if (!IsWindowEnabled(GetDlgItem(hwnd, IDC_KBDL_DELETE)))
    {
        SetFocus(GetDlgItem(hwnd, IDC_KBDL_ADD));
    }

    //
    //  Enable the Apply button.
    //
    PropSheet_Changed(GetParent(hwnd), hwnd);
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_CommandHotKeySetting
//
//  Invokes the Change HotKey dialog.
//
//  Returns 1 if a dialog box was invoked and the dialog returned IDOK.
//  Otherwise, it returns 0.
//
////////////////////////////////////////////////////////////////////////////

BOOL Locale_CommandHotKeySetting(
    HWND hwnd)
{
    int rc = 0;
    INITINFO InitInfo;

    InitInfo.hwndMain = hwnd;

    if (g_OSNT5)
    {
        rc = (int)DialogBoxParam(GetCicResInstance(hInstance, DLG_KEYBOARD_LOCALE_HOTKEY),
                                 MAKEINTRESOURCE(DLG_KEYBOARD_LOCALE_HOTKEY),
                                 hwnd,
                                 KbdLocaleHotKeyDlg,
                                 (LPARAM)(&InitInfo));
    }
    else
    {
        rc = (int)DialogBoxParam(GetCicResInstance(hInstance, DLG_KEYBOARD_HOTKEY_INPUT_LOCALE),
                                 MAKEINTRESOURCE(DLG_KEYBOARD_HOTKEY_INPUT_LOCALE),
                                 hwnd,
                                 KbdLocaleSimpleHotkey,
                                 (LPARAM)&InitInfo);
    }

    return rc;
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_CommandToolBarSetting
//
//  Invokes the ToolBar setting dialog.
//
//  Returns 1 if a dialog box was invoked and the dialog returned IDOK.
//  Otherwise, it returns 0.
//
////////////////////////////////////////////////////////////////////////////

BOOL Locale_CommandToolBarSetting(
    HWND hwnd)
{
    int rc = 0;

    if ((rc = (int)DialogBoxParam(GetCicResInstance(hInstance, DLG_TOOLBAR_SETTING),
                                  MAKEINTRESOURCE(DLG_TOOLBAR_SETTING),
                                  hwnd,
                                  ToolBarSettingDlg,
                                  (LPARAM)NULL)) == IDOK)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }

}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_AddLanguage
//
//  Adds the new input locale to the list in the property page.
//
////////////////////////////////////////////////////////////////////////////

BOOL Locale_AddLanguage(
    HWND hwndMain,
    LPLANGNODE pLangNode,
    int iKbdTip,
    int iPen,
    int iSpeech,
    int iExternal,
    int idxLang)
{
    HWND hwndLang;
    UINT iCount, ctr;
    BOOL bSameHKLTip = FALSE;

    TCHAR szLangText[DESC_MAX];
    TCHAR szLayoutName[DESC_MAX];
    LPINPUTLANG pInpLang;
    LPTVITEMNODE pTVItemNode = NULL;
    HTREEITEM hTVItem;

    if (pLangNode && iKbdTip == -1)
    {
        //
        //  See if the user has Admin privileges.  If not, then don't allow
        //  them to install any NEW layouts.
        //
        if ((!g_bAdmin_Privileges) &&
            (!g_lpLayout[pLangNode->iLayout].bInstalled))
        {
            //
            //  The layout is not currently installed, so don't allow it
            //  to be added.
            //
            Locale_ErrorMsg(hwndMain, IDS_KBD_LAYOUT_FAILED, NULL);
            return (FALSE);
        }

        //
        //  Set the language to active.
        //  Also, set the status to changed so that the layout will be added.
        //
        pLangNode->wStatus |= (LANG_CHANGED | LANG_ACTIVE);

        //
        //  Get language name and add it to treeview
        //
        pInpLang = &g_lpLang[pLangNode->iLang];
        GetAtomName(pInpLang->atmLanguageName, szLangText, ARRAYSIZE(szLangText));

        if (!(pTVItemNode = CreateTVItemNode(pInpLang->dwID)))
            return FALSE;

        pTVItemNode->lParam = (LPARAM)pLangNode;
        AddTreeViewItems(TV_ITEM_TYPE_LANG,
                         szLangText, NULL, NULL, &pTVItemNode);


        //
        //  Get keyboard layout name and add it to treeview
        //
        GetAtomName(g_lpLayout[pLangNode->iLayout].atmLayoutText,
                    szLayoutName,
                    ARRAYSIZE(szLayoutName));

        //
        //  Adding the default layout name for each language
        //
        if (pTVItemNode && !pTVItemNode->atmDefTipName)
            pTVItemNode->atmDefTipName = AddAtom(szLayoutName);

        if (!(pTVItemNode = CreateTVItemNode(pInpLang->dwID)))
            return FALSE;

        pTVItemNode->lParam = (LPARAM)pLangNode;
        hTVItem = AddTreeViewItems(TV_ITEM_TYPE_KBD,
                           szLangText, szInputTypeKbd, szLayoutName, &pTVItemNode);

        if (hTVItem)
            TreeView_SelectItem(g_hwndTV, hTVItem);

        //
        //  Check Thai layout.
        //
        if (g_dwPrimLangID == LANG_THAI && hTVItem)
        {
            if (PRIMARYLANGID(LOWORD(g_lpLayout[pLangNode->iLayout].dwID)) == LANG_THAI)
                g_iThaiLayout++;
        }

        g_dwChanges |= CHANGE_NEWKBDLAYOUT;
    }

    //
    //  Get kbd tip name and add it to treeview
    //
    if ((iKbdTip != CB_ERR) && !(g_lpTips[iKbdTip].bEnabled))
    {

        TV_ITEM tvItem;
        HTREEITEM hTVLangItem;

        if (g_lpTips[iKbdTip].hklSub)
        {
            //
            // Looking for the same substitute HKL
            //
            for (ctr = 0; ctr < g_iTipsBuff; ctr++)
            {
                 if (ctr == iKbdTip)
                     continue;

                 if (g_lpTips[ctr].hklSub == g_lpTips[iKbdTip].hklSub)
                 {
                     bSameHKLTip = TRUE;
                     break;
                 }
            }
        }

        //
        //  Get TIP name description
        //
        GetAtomName(g_lpTips[iKbdTip].atmTipText, szLayoutName, ARRAYSIZE(szLayoutName));

        hTVLangItem = FindTVLangItem(g_lpTips[iKbdTip].dwLangID, NULL);

        if (hTVLangItem)
        {
            tvItem.mask = TVIF_HANDLE | TVIF_PARAM;
            tvItem.hItem = hTVLangItem;

            if (TreeView_GetItem(g_hwndTV, &tvItem) && tvItem.lParam)
            {
                pTVItemNode = (LPTVITEMNODE) tvItem.lParam;
            }
        }
        else
        {
            //
            //  Get language name and add it to treeview
            //
            if (!(pTVItemNode = CreateTVItemNode(g_lpTips[iKbdTip].dwLangID)))
                return FALSE;

            GetLanguageName(MAKELCID(g_lpTips[iKbdTip].dwLangID, SORT_DEFAULT),
                            szLangText,
                            ARRAYSIZE(szLangText));

            AddTreeViewItems(TV_ITEM_TYPE_LANG,
                             szLangText, NULL, NULL, &pTVItemNode);
        }

        if (pTVItemNode && g_lpTips[iKbdTip].hklSub)
        {
            //
            //  Set the index of keyboard Tip.
            //
            pTVItemNode->iIdxTips = iKbdTip;

            if (!pTVItemNode->atmDefTipName)
                pTVItemNode->atmDefTipName = AddAtom(szLayoutName);

        }

        //
        //  Create TIP layout
        //
        if (!(pTVItemNode = CreateTVItemNode(g_lpTips[iKbdTip].dwLangID)))
            return FALSE;

        if (pTVItemNode && g_lpTips[iKbdTip].hklSub)
        {
            //
            //  Insert a new language node.
            //
            pLangNode = Locale_AddToLinkedList(idxLang, 0);

            if (pLangNode)
            {
                pLangNode->iLayout = (UINT) g_lpTips[iKbdTip].iLayout;
                pLangNode->wStatus |= (LANG_CHANGED | LANG_ACTIVE);
                pTVItemNode->lParam = (LPARAM)pLangNode;
            }
        }

        pTVItemNode->iIdxTips = iKbdTip;
        pTVItemNode->clsid  = g_lpTips[iKbdTip].clsid;
        pTVItemNode->guidProfile = g_lpTips[iKbdTip].guidProfile;
        pTVItemNode->uInputType = INPUT_TYPE_TIP | INPUT_TYPE_KBD;
        pTVItemNode->hklSub = g_lpTips[iKbdTip].hklSub;

        //
        //  Get language name from LangID.
        //
        GetLanguageName(MAKELCID(g_lpTips[iKbdTip].dwLangID, SORT_DEFAULT),
                        szLangText,
                        ARRAYSIZE(szLangText));

        hTVItem = AddTreeViewItems(TV_ITEM_TYPE_KBD,
                           szLangText, szInputTypeKbd, szLayoutName, &pTVItemNode);
        if (hTVItem)
        {
            TreeView_SelectItem(g_hwndTV, hTVItem);
            g_lpTips[iKbdTip].bEnabled = TRUE;
            g_iEnabledTips++;
            g_iEnabledKbdTips++;
            g_dwChanges |= CHANGE_TIPCHANGE;
        }

        if (bSameHKLTip)
        {
            for (ctr = 0; ctr < g_iTipsBuff; ctr++)
            {
                 if (!(g_lpTips[ctr].bEnabled) &&
                     g_lpTips[ctr].hklSub == g_lpTips[iKbdTip].hklSub)
                 {
                    //
                    //  Create TIP layout
                    //
                    if (!(pTVItemNode = CreateTVItemNode(g_lpTips[ctr].dwLangID)))
                        return FALSE;

                    pTVItemNode->iIdxTips = ctr;
                    pTVItemNode->clsid  = g_lpTips[ctr].clsid;
                    pTVItemNode->guidProfile = g_lpTips[ctr].guidProfile;
                    pTVItemNode->uInputType = INPUT_TYPE_TIP | INPUT_TYPE_KBD;
                    pTVItemNode->hklSub = g_lpTips[ctr].hklSub;

                    if (pLangNode)
                        pTVItemNode->lParam = (LPARAM)pLangNode;

                    //
                    //  Get language name from LangID and layout name.
                    //
                    GetLanguageName(MAKELCID(g_lpTips[ctr].dwLangID, SORT_DEFAULT),
                                    szLangText,
                                    ARRAYSIZE(szLangText));
                    GetAtomName(g_lpTips[ctr].atmTipText, szLayoutName, ARRAYSIZE(szLayoutName));

                    hTVItem = AddTreeViewItems(TV_ITEM_TYPE_KBD,
                                       szLangText, szInputTypeKbd, szLayoutName, &pTVItemNode);
                    if (hTVItem)
                    {
                        TreeView_SelectItem(g_hwndTV, hTVItem);
                        g_lpTips[ctr].bEnabled = TRUE;
                        g_iEnabledTips++;
                        g_iEnabledKbdTips++;
                        g_dwChanges |= CHANGE_TIPCHANGE;
                    }
                 }
            }
        }
    }

    //
    //  Get pen tip name and add it to treeview
    //
    if ((iPen != CB_ERR) && !(g_lpTips[iPen].bEnabled))
    {
        GetAtomName(g_lpTips[iPen].atmTipText,
                    szLayoutName,
                    ARRAYSIZE(szLayoutName));

        if (!(pTVItemNode = CreateTVItemNode(g_lpTips[iPen].dwLangID)))
            return FALSE;

        pTVItemNode->iIdxTips = iPen;
        pTVItemNode->clsid  = g_lpTips[iPen].clsid;
        pTVItemNode->guidProfile = g_lpTips[iPen].guidProfile;
        pTVItemNode->uInputType = INPUT_TYPE_TIP | INPUT_TYPE_PEN;

        //
        //  Get language name from LangID.
        //
        GetLanguageName(MAKELCID(g_lpTips[iPen].dwLangID, SORT_DEFAULT),
                        szLangText,
                        ARRAYSIZE(szLangText));

        hTVItem = AddTreeViewItems(TV_ITEM_TYPE_PEN,
                           szLangText, szInputTypePen, szLayoutName, &pTVItemNode);
        if (hTVItem)
        {
            g_lpTips[iPen].bEnabled = TRUE;
            g_iEnabledTips++;
            g_dwChanges |= CHANGE_TIPCHANGE;
        }
    }

    //
    //  Get speech tip name and add it to treeview
    //
    if ((iSpeech != CB_ERR) && !(g_lpTips[iSpeech].bEnabled))
    {
        GetAtomName(g_lpTips[iSpeech].atmTipText,
                    szLayoutName,
                    ARRAYSIZE(szLayoutName));

        if (!(pTVItemNode = CreateTVItemNode(g_lpTips[iSpeech].dwLangID)))
            return FALSE;

        pTVItemNode->iIdxTips = iSpeech;
        pTVItemNode->clsid  = g_lpTips[iSpeech].clsid;
        pTVItemNode->guidProfile = g_lpTips[iSpeech].guidProfile;
        pTVItemNode->bNoAddCat = g_lpTips[iSpeech].bNoAddCat;
        pTVItemNode->uInputType = INPUT_TYPE_TIP | INPUT_TYPE_SPEECH;

        //
        //  Get language name from LangID.
        //
        GetLanguageName(MAKELCID(g_lpTips[iSpeech].dwLangID, SORT_DEFAULT),
                        szLangText,
                        ARRAYSIZE(szLangText));

        hTVItem = AddTreeViewItems(TV_ITEM_TYPE_SPEECH,
                           szLangText, szInputTypeSpeech, szLayoutName, &pTVItemNode);

        if (hTVItem)
        {
            g_lpTips[iSpeech].bEnabled = TRUE;
            g_iEnabledTips++;
            g_dwChanges |= CHANGE_TIPCHANGE;
            MarkSptipRemoved(FALSE);
        }
    }

    //
    //  Get external tip name and add it to treeview
    //
    if ((iExternal != CB_ERR) && !(g_lpTips[iExternal].bEnabled))
    {
        BSTR bstr = NULL;
        TCHAR szTipTypeName[MAX_PATH];
        ITfCategoryMgr *pCategory = NULL;

        GetAtomName(g_lpTips[iExternal].atmTipText,
                    szLayoutName,
                    ARRAYSIZE(szLayoutName));

        if (!(pTVItemNode = CreateTVItemNode(g_lpTips[iExternal].dwLangID)))
            return FALSE;

        pTVItemNode->iIdxTips = iExternal;
        pTVItemNode->clsid  = g_lpTips[iExternal].clsid;
        pTVItemNode->guidProfile = g_lpTips[iExternal].guidProfile;
        pTVItemNode->bNoAddCat = g_lpTips[iExternal].bNoAddCat;
        pTVItemNode->uInputType = INPUT_TYPE_TIP | INPUT_TYPE_EXTERNAL;

        if (g_lpTips[iExternal].uInputType & INPUT_TYPE_SMARTTAG)
        {
            pTVItemNode->uInputType |= INPUT_TYPE_SMARTTAG;
        }

        //
        //  Get language name from LangID.
        //
        GetLanguageName(MAKELCID(g_lpTips[iExternal].dwLangID, SORT_DEFAULT),
                        szLangText,
                        ARRAYSIZE(szLangText));

        if (CoCreateInstance(&CLSID_TF_CategoryMgr,
                             NULL,
                             CLSCTX_INPROC_SERVER,
                             &IID_ITfCategoryMgr,
                             (LPVOID *) &pCategory) != S_OK)
            return FALSE;

        if (pCategory->lpVtbl->GetGUIDDescription(pCategory,
                                      &g_lpTips[iExternal].clsid,
                                      &bstr) == S_OK)
        {
            StringCchCopy(szTipTypeName, ARRAYSIZE(szTipTypeName), bstr);
        }
        else
        {
            StringCchCopy(szTipTypeName, ARRAYSIZE(szTipTypeName), szInputTypeExternal);
        }

        if (bstr)
           SysFreeString(bstr);

        if (pCategory)
            pCategory->lpVtbl->Release(pCategory);

        hTVItem = AddTreeViewItems(TV_ITEM_TYPE_EXTERNAL,
                           szLangText, szInputTypeExternal, szLayoutName, &pTVItemNode);

        if (hTVItem)
        {
            g_lpTips[iExternal].bEnabled = TRUE;
            g_iEnabledTips++;
            g_dwChanges |= CHANGE_TIPCHANGE;
        }
    }

    //
    //  See the secondary controls according to input layout.
    //
    Locale_SetSecondaryControls(hwndMain);

    //
    //  Add the default language switch hotkey.
    //
    Locale_SetDefaultHotKey(hwndMain, TRUE);

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_SetupKeyboardLayouts
//
//  Calls setup to get all of the new keyboard layout files.
//
////////////////////////////////////////////////////////////////////////////

BOOL Locale_SetupKeyboardLayoutsNT4(
    HWND hwnd)
{
    HINF hKbdInf;
    HSPFILEQ FileQueue;
    PVOID QueueContext;
    UINT i;
    LPLANGNODE pLangNode;
    int count;
    BOOL bInitInf = FALSE;
    TCHAR szSection[MAX_PATH];
    BOOL bRet = TRUE;

    HWND hwndTV = GetDlgItem(hwnd, IDC_INPUT_LIST);
    TV_ITEM tvItem;
    HTREEITEM hItem;
    HTREEITEM hLangItem;
    HTREEITEM hGroupItem;

    tvItem.mask        = TVIF_HANDLE | TVIF_PARAM;

    for (hLangItem = TreeView_GetChild(hwndTV, g_hTVRoot) ;
        hLangItem != NULL ;
        hLangItem = TreeView_GetNextSibling(hwndTV, hLangItem)
        )
    {
        for (hGroupItem = TreeView_GetChild(hwndTV, hLangItem);
             hGroupItem != NULL;
             hGroupItem = TreeView_GetNextSibling(hwndTV, hGroupItem))
        {
            for (hItem = TreeView_GetChild(hwndTV, hGroupItem);
                 hItem != NULL;
                 hItem = TreeView_GetNextSibling(hwndTV, hItem))
            {

                LPTVITEMNODE pTVItemNode;

                tvItem.hItem = hItem;
                if (TreeView_GetItem(hwndTV, &tvItem) && tvItem.lParam)
                {
                    pTVItemNode = (LPTVITEMNODE) tvItem.lParam;
                    pLangNode = (LPLANGNODE)pTVItemNode->lParam;
                    if (pLangNode == NULL)
                        continue;
                }
                else
                   continue;


                if ((pLangNode->wStatus & LANG_CHANGED) &&
                    (pLangNode->wStatus & LANG_ACTIVE))
                {
                    if (!bInitInf)
                    {
                        //
                        //  Open the Inf file.
                        //
                        hKbdInf = SetupOpenInfFile(c_szKbdInf, NULL, INF_STYLE_WIN4, NULL);
                        if (hKbdInf == INVALID_HANDLE_VALUE)
                        {
                            return (FALSE);
                        }

                        if (!SetupOpenAppendInfFile(NULL, hKbdInf, NULL))
                        {
                            SetupCloseInfFile(hKbdInf);
                            return (FALSE);
                        }

                        //
                        //  Create a setup file queue and initialize default setup
                        //  copy queue callback context.
                        //
                        FileQueue = SetupOpenFileQueue();
                        if ((!FileQueue) || (FileQueue == INVALID_HANDLE_VALUE))
                        {
                            SetupCloseInfFile(hKbdInf);
                            return (FALSE);
                        }

                        QueueContext = SetupInitDefaultQueueCallback(hwnd);
                        if (!QueueContext)
                        {
                            SetupCloseFileQueue(FileQueue);
                            SetupCloseInfFile(hKbdInf);
                            return (FALSE);
                        }

                        bInitInf = TRUE;
                    }

                    //
                    //  Get the layout name.
                    //
                    StringCchPrintf(szSection,
                                    ARRAYSIZE(szSection),
                                    TEXT("%s%8.8lx"),
                                    c_szPrefixCopy,
                                    g_lpLayout[pLangNode->iLayout].dwID );

                    //
                    //  Enqueue the keyboard layout files so that they may be
                    //  copied.  This only handles the CopyFiles entries in the
                    //  inf file.
                    //
                    if (!SetupInstallFilesFromInfSection( hKbdInf,
                                                          NULL,
                                                          FileQueue,
                                                          szSection,
                                                          NULL,
                                                          SP_COPY_NEWER ))
                    {
                        //
                        //  Setup failed to find the keyboard.  Make it inactive
                        //  and remove it from the list.
                        //
                        //  This shouldn't happen - the inf file is messed up.
                        //
                        Locale_ErrorMsg(hwnd, IDS_KBD_SETUP_FAILED, NULL);

                        pLangNode->wStatus &= ~(LANG_CHANGED | LANG_ACTIVE);

                        if (pTVItemNode)
                        {
                           RemoveTVItemNode(pTVItemNode);
                        }
                        TreeView_DeleteItem(hwndTV, tvItem.hItem );

                        if ((g_lpLang[pLangNode->iLang].iNumCount) > 1)
                        {
                            (g_lpLang[pLangNode->iLang].iNumCount)--;
                            Locale_RemoveFromLinkedList(pLangNode);
                        }
                    }
                }
            }
        }
    }

    if (bInitInf)
    {
        DWORD d;

        //
        //  See if we need to install any files.
        //
        //  d = 0: User wants new files or some files were missing;
        //         Must commit queue.
        //
        //  d = 1: User wants to use existing files and queue is empty;
        //         Can skip committing queue.
        //
        //  d = 2: User wants to use existing files, but del/ren queues
        //         not empty.  Must commit queue.  The copy queue will
        //         have been emptied, so only del/ren functions will be
        //         performed.
        //
        if ((SetupScanFileQueue( FileQueue,
                                 SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_INFORM_USER,
                                 hwnd,
                                 NULL,
                                 NULL,
                                 &d )) && (d != 1))
        {
            //
            //  Copy the files in the queue.
            //
            if (!SetupCommitFileQueue( hwnd,
                                       FileQueue,
                                       SetupDefaultQueueCallback,
                                       QueueContext ))
            {
                //
                //  This can happen if the user hits Cancel from within
                //  the setup dialog.
                //
                Locale_ErrorMsg(hwnd, IDS_KBD_SETUP_FAILED, NULL);
                bRet = FALSE;
                goto Locale_SetupError;
            }
        }

Locale_SetupError:
        //
        //  Terminate the Queue.
        //
        SetupTermDefaultQueueCallback(QueueContext);

        //
        //  Close the file queue.
        //
        SetupCloseFileQueue(FileQueue);

        //
        //  Close the Inf file.
        //
        SetupCloseInfFile(hKbdInf);
    }

    //
    //  Return success.
    //
    return (bRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_ApplyInputs
//
//  1. make sure we have all the layout files required.
//  2. write the information into the registry
//  3. call Load/UnloadKeyboardLayout where relevant
//
//  Note that this will trash the previous preload and substitutes sections,
//  based on what is actually loaded.  Thus if something was wrong before in
//  the registry, it will be corrected now.
//
////////////////////////////////////////////////////////////////////////////

BOOL Locale_ApplyInputs(
    HWND hwnd)
{
    BOOL bSetDef = FALSE;
    UINT iVal, idx, ctr, ctr2, nHotKeys;
    UINT nLocales = 0;
    UINT iPreload = 0;
    LPLANGNODE pLangNode, pTemp;
    LPINPUTLANG pInpLang;
    DWORD dwID;
    TCHAR sz[DESC_MAX];            // temp - build the name of the reg entry
    TCHAR szPreload10[10];
    TCHAR szTemp[MAX_PATH];
    HKEY hkeyLayouts;
    HKEY hkeySubst;
    HKEY hkeyPreload;
    HKEY hKeyImm;
    HKEY hkeyTip;
    HWND hwndTV = GetDlgItem(hwnd, IDC_INPUT_LIST);
    HKL hklDefault = 0;
    HKL hklLoad, hklUnload;
    HKL hklSub[MAX_DUPLICATED_HKL];
    HCURSOR hcurSave;
    HKEY hkeyScanCode;
    DWORD cb;
    TCHAR szShiftL[8];
    TCHAR szShiftR[8];
    BOOL bHasIme = FALSE;
    BOOL bReplaced = FALSE;
    BOOL bCheckedSubhkl;
    BOOL bDisableCtfmon = FALSE;
    BOOL bRebootForCUAS = FALSE;
    BOOL bAlreadyLoadCtfmon = FALSE;

    TV_ITEM tvItem;
    HTREEITEM hItem;
    HTREEITEM hLangItem;
    HTREEITEM hGroupItem;


    //
    //  See if the pane is disabled.  If so, then there is nothing to
    //  Apply.
    //
    if (!IsWindowEnabled(hwndTV))
    {
        return (TRUE);
    }

    //
    //  Put up the hour glass.
    //
    hcurSave = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    //  Make sure there are actually changes since the last save when
    //  OK is selected.  If the user hits OK without anything to Apply,
    //  then we should do nothing.
    //
    if (g_dwChanges == 0 && !g_bAdvChanged)
    {
        pLangNode = NULL;
        for (idx = 0; idx < g_iLangBuff; idx++)
        {
            pLangNode = g_lpLang[idx].pNext;
            while (pLangNode != NULL)
            {
                if (pLangNode->wStatus & (LANG_CHANGED | LANG_DEF_CHANGE))
                {
                    break;
                }
                pLangNode = pLangNode->pNext;
            }
            if (pLangNode != NULL)
            {
                break;
            }
        }
        if ((idx == g_iLangBuff) && (pLangNode == NULL))
        {
            SetCursor(hcurSave);
            PropSheet_UnChanged(GetParent(hwnd), hwnd);
            return (TRUE);
        }
    }


    if (g_OSNT4)
    {
        //
        //  Queue up the new layouts and copy the appropriate files to
        //  disk using the setup apis.  Only do this if the user has
        //  Admin privileges.
        //
        if (g_bAdmin_Privileges &&
            !Locale_SetupKeyboardLayoutsNT4(hwnd))
        {
            SetCursor(hcurSave);
            return (FALSE);
        }
    }

    //
    //  Clean up the registry.
    //

    //
    //  For FE languages, there is a keyboard which has a different
    //  scan code for shift keys - eg. NEC PC9801.
    //  We have to keep information about scan codes for shift keys in
    //  the registry under the 'toggle' sub key as named values.
    //
    szShiftL[0] = TEXT('\0');
    szShiftR[0] = TEXT('\0');
    if (RegOpenKey( HKEY_CURRENT_USER,
                    c_szScanCodeKey,
                    &hkeyScanCode ) == ERROR_SUCCESS)
    {
        cb = sizeof(szShiftL);
        RegQueryValueEx( hkeyScanCode,
                         c_szValueShiftLeft,
                         NULL,
                         NULL,
                         (LPBYTE)szShiftL,
                         &cb );

        cb = sizeof(szShiftR);
        RegQueryValueEx( hkeyScanCode,
                         c_szValueShiftRight,
                         NULL,
                         NULL,
                         (LPBYTE)szShiftR,
                         &cb );

        RegCloseKey(hkeyScanCode);
    }

    //
    //  Delete the HKCU\Keyboard Layout key and all subkeys.
    //
    if (RegOpenKeyEx( HKEY_CURRENT_USER,
                      c_szKbdLayouts,
                      0,
                      KEY_ALL_ACCESS,
                      &hkeyLayouts ) == ERROR_SUCCESS)
    {
        //
        //  Delete the HKCU\Keyboard Layout\Preload, Substitutes, and Toggle
        //  keys in the registry so that the Keyboard Layout section can be
        //  rebuilt.
        //
        RegDeleteKey(hkeyLayouts, c_szPreloadKey);
        RegDeleteKey(hkeyLayouts, c_szSubstKey);

        RegCloseKey(hkeyLayouts);
    }

    //
    //  Create the HKCU\Keyboard Layout key.
    //
    if (RegCreateKey( HKEY_CURRENT_USER,
                      c_szKbdLayouts,
                      &hkeyLayouts ) == ERROR_SUCCESS)
    {
        //
        //  Create the HKCU\Keyboard Layout\Substitutes key.
        //
        if (RegCreateKey( hkeyLayouts,
                          c_szSubstKey,
                          &hkeySubst ) == ERROR_SUCCESS)
        {
            //
            //  Create the HKCU\Keyboard Layout\Preload key.
            //
            if (RegCreateKey( hkeyLayouts,
                              c_szPreloadKey,
                              &hkeyPreload ) == ERROR_SUCCESS)
            {
                //
                //  Initialize the iPreload variable to 1 to show
                //  that the key has been created.
                //
                iPreload = 1;
            }
            else
            {
                RegCloseKey(hkeySubst);
            }
        }
        RegCloseKey(hkeyLayouts);
    }
    if (!iPreload)
    {
        //
        //  Registry keys could not be created.  Now what?
        //
        MessageBeep(MB_OK);
        SetCursor(hcurSave);
        return (FALSE);
    }

    //
    //  Set all usage counts to zero in the language array.
    //
    for (idx = 0; idx < g_iLangBuff; idx++)
    {
        g_lpLang[idx].iUseCount = 0;
    }

    //
    //  Search through the list to see if any keyboard layouts need to be
    //  unloaded from the system.
    //
    for (idx = 0; idx < g_iLangBuff; idx++)
    {
        pLangNode = g_lpLang[idx].pNext;
        while (pLangNode != NULL)
        {
            if ( (pLangNode->wStatus & LANG_ORIGACTIVE) &&
                 !(pLangNode->wStatus & LANG_ACTIVE) )
            {
                //
                //  Before unloading the hkl, look for the corresponding
                //  hotkey and remove it.
                //
                DWORD dwHotKeyID = 0;

                for (ctr = 0; ctr < DSWITCH_HOTKEY_SIZE; ctr++)
                {
                    if (g_aDirectSwitchHotKey[ctr].hkl == pLangNode->hkl)
                    {
                        //
                        //  Found an hkl match.  Remember the hotkey ID so
                        //  we can delete the hotkey entry later if the
                        //  unload of the hkl succeeds.
                        //
                        dwHotKeyID = g_aDirectSwitchHotKey[ctr].dwHotKeyID;
                        break;
                    }
                }

                //
                //  Started off with this active, deleting it now.
                //  Failure is not fatal.
                //
                if (!UnloadKeyboardLayout(pLangNode->hkl))
                {
                    LPLANGNODE pLangNodeNext = NULL;

                    pLangNode->wStatus |= LANG_UNLOAD;
                    pLangNodeNext = pLangNode->pNext;

                    //
                    //  Don't need to check TIP case and TIP case also display
                    //  message and add the substitute hkl into the tree view.
                    //
                    //if (!IsTipSubstituteHKL((HKL) ((DWORD_PTR)(pLangNode->hkl))))
                    {
                        Locale_ApplyError( hwnd,
                                           pLangNode,
                                           IDS_KBD_UNLOAD_KBD_FAILED,
                                           MB_OK_OOPS );

                        //
                        //  Failed to unload layout, put it back in the list,
                        //  and turn ON the indicator whether it needs it or not.
                        //
                        if (Locale_AddLanguage(hwnd, pLangNode, -1, -1, -1, -1, 0))
                        {
                            Locale_SetSecondaryControls(hwnd);
                        }
                    }

                    pLangNode = pLangNodeNext;
                }
                else
                {
                    //
                    //  Succeeded, no longer in USER's list.
                    //
                    //  Reset flag, this could be from ApplyInput and we'll
                    //  fail on the OK if we leave it marked as original
                    //  active.
                    //
                    pLangNode->wStatus &= ~(LANG_ORIGACTIVE | LANG_CHANGED);

                    //
                    //  Remove the hotkey entry for this hkl.
                    //
                    if (dwHotKeyID)
                    {
                        ImmSetHotKey(dwHotKeyID, 0, 0, (HKL)NULL);
                    }

                    //
                    //  Remove the link in the language array.
                    //
                    //  NOTE: pLangNode could be null here.
                    //
                    pTemp = pLangNode->pNext;
                    Locale_RemoveFromLinkedList(pLangNode);
                    pLangNode = pTemp;
                }
            }
            else
            {
                pLangNode = pLangNode->pNext;
            }
        }
    }

    //
    //  The order in the registry is based on the order in which they
    //  appear in the list box.
    //
    //  The only exception to this is that the default will be number 1.
    //
    //  If no default is found, the last one in the list will be used as
    //  the default.
    //
    iVal = 2;
    ctr = 0;

    //
    //  Check the default keyboard layout not to lose the default HKL.
    //
    EnsureDefaultKbdLayout(&nLocales);

    tvItem.mask        = TVIF_HANDLE | TVIF_PARAM;

    for (hLangItem = TreeView_GetChild(hwndTV, g_hTVRoot) ;
        hLangItem != NULL ;
        hLangItem = TreeView_GetNextSibling(hwndTV, hLangItem))
    {
        bCheckedSubhkl = FALSE;
        //
        //  Clear the duplicated HKL buffer index
        //
        ctr2 = 0;

        for (hGroupItem = TreeView_GetChild(hwndTV, hLangItem);
             hGroupItem != NULL;
             hGroupItem = TreeView_GetNextSibling(hwndTV, hGroupItem))
        {
            for (hItem = TreeView_GetChild(hwndTV, hGroupItem);
                 hItem != NULL;
                 hItem = TreeView_GetNextSibling(hwndTV, hItem))
            {

                LPTVITEMNODE pTVItemNode;

                pLangNode = NULL;

                tvItem.hItem = hItem;
                if (TreeView_GetItem(hwndTV, &tvItem) && tvItem.lParam)
                {
                    pTVItemNode = (LPTVITEMNODE) tvItem.lParam;
                    pLangNode = (LPLANGNODE)pTVItemNode->lParam;
                }

                if (!pLangNode && !bCheckedSubhkl &&
                    (pTVItemNode->uInputType & INPUT_TYPE_KBD) &&
                    pTVItemNode->hklSub)
                {
                    bCheckedSubhkl = TRUE;

                    if (tvItem.hItem = FindTVLangItem(pTVItemNode->dwLangID, NULL))
                    {
                        if (TreeView_GetItem(hwndTV, &tvItem) && tvItem.lParam)
                        {
                            LPTVITEMNODE pTVLangItemNode;

                            pTVLangItemNode = (LPTVITEMNODE) tvItem.lParam;
                            pLangNode = (LPLANGNODE)pTVLangItemNode->lParam;
                        }
                    }
                }

                if (!pLangNode)
                    continue;

                if (pTVItemNode->hklSub)
                {
                    UINT uHklIdx;
                    BOOL bFoundSameHkl = FALSE;

                    for (uHklIdx = 0; uHklIdx < ctr2; uHklIdx++)
                    {
                         if (pTVItemNode->hklSub == hklSub[uHklIdx])
                         {
                             bFoundSameHkl = TRUE;
                             break;
                         }
                    }

                    //
                    // This substitute HKL is already registered. Skip this HKL.
                    //
                    if (bFoundSameHkl)
                        continue;

                    hklSub[ctr2] = pTVItemNode->hklSub;
                    ctr2++;
                }

                if (pLangNode->wStatus & LANG_UNLOAD)
                {
                    pLangNode->wStatus &= ~LANG_UNLOAD;
                    pLangNode->wStatus &= ~(LANG_CHANGED | LANG_DEF_CHANGE);
                    nLocales--;
                    continue;
                }

                pInpLang = &(g_lpLang[pLangNode->iLang]);

                //
                //  Clear the "set hot key" field, since we will be writing to the
                //  registry.
                //
                pLangNode->wStatus &= ~LANG_HOTKEY;

                //
                //  See if it's the default input locale.
                //
                if (!bSetDef && (pLangNode->wStatus & LANG_DEFAULT))
                {
                    //
                    //  Default input locale, so the preload value should be
                    //  set to 1.
                    //
                    iPreload = 1;
                    bSetDef = TRUE;

                    if (pTVItemNode->hklSub)
                    {
                        TCHAR szDefTip[MAX_PATH];

                        if (g_lpTips &&
                            g_lpTips[pTVItemNode->iIdxTips].hklSub == pTVItemNode->hklSub)
                        {
                            BOOL bSave = FALSE;

                            SaveLanguageProfileStatus(bSave,
                                                      pTVItemNode->iIdxTips,
                                                      pTVItemNode->hklSub);
                        }
                    }
                }
                else if (ctr == (nLocales - 1))
                {
                    //
                    //  We're on the last one.  Make sure there was a default.
                    //
                    iPreload = (iVal <= nLocales) ? iVal : 1;
                }
                else
                {
                    //
                    //  Set the preload value to the next value.
                    //
                    iPreload = iVal;
                    iVal++;
                }

                ctr++;

                //
                //  Store the preload value as a string so that it can be written
                //  into the registry (as a value name).
                //
                StringCchPrintf(sz, ARRAYSIZE(sz), TEXT("%d"), iPreload);

                //
                //  Store the locale id as a string so that it can be written
                //  into the registry (as a value).
                //
                if ((HIWORD(g_lpLayout[pLangNode->iLayout].dwID) & 0xf000) == 0xe000)
                {
                    pLangNode->wStatus |= LANG_IME;
                    StringCchPrintf(szPreload10,
                                    ARRAYSIZE(szPreload10),
                                    TEXT("%8.8lx"),
                                    g_lpLayout[pLangNode->iLayout].dwID );
                    bHasIme = TRUE;
                }
                else
                {
                    pLangNode->wStatus &= ~LANG_IME;
                    dwID = pInpLang->dwID;
                    idx = pInpLang->iUseCount;
                    if ((idx == 0) || (idx > 0xfff))
                    {
                        idx = 0;
                    }
                    else
                    {
                        dwID |= ((DWORD)(0xd000 | ((WORD)(idx - 1))) << 16);
                    }
                    StringCchPrintf(szPreload10, ARRAYSIZE(szPreload10), TEXT("%08.8x"), dwID);
                    (pInpLang->iUseCount)++;
                }

                //
                //  Set the new entry in the registry.  It is of the form:
                //
                //  HKCU\Keyboard Layout
                //      Preload:    1 = <locale id>
                //                  2 = <locale id>
                //                      etc...
                //
                RegSetValueEx( hkeyPreload,
                               sz,
                               0,
                               REG_SZ,
                               (LPBYTE)szPreload10,
                               (DWORD)(lstrlen(szPreload10) + 1) * sizeof(TCHAR) );

                //
                //  See if we need to add a substitute for this input locale.
                //
                if (((pInpLang->dwID != g_lpLayout[pLangNode->iLayout].dwID) || idx) &&
                    (!(pLangNode->wStatus & LANG_IME)))
                {
                    //
                    //  Get the layout id as a string so that it can be written
                    //  into the registry (as a value).
                    //
                    StringCchPrintf(szTemp,
                                    ARRAYSIZE(szTemp),
                                    TEXT("%8.8lx"),
                                    g_lpLayout[pLangNode->iLayout].dwID );

                    //
                    //  Set the new entry in the registry.  It is of the form:
                    //
                    //  HKCU\Keyboard Layout
                    //      Substitutes:    <locale id> = <layout id>
                    //                      <locale id> = <layout id>
                    //                          etc...
                    //
                    RegSetValueEx( hkeySubst,
                                   szPreload10,
                                   0,
                                   REG_SZ,
                                   (LPBYTE)szTemp,
                                   (DWORD)(lstrlen(szTemp) + 1) * sizeof(TCHAR) );
                }

                //
                //  Make sure all of the changes are written to disk.
                //
                RegFlushKey(hkeySubst);
                RegFlushKey(hkeyPreload);
                RegFlushKey(HKEY_CURRENT_USER);

                //
                //  See if the keyboard layout needs to be loaded.
                //
                if (pLangNode->wStatus & (LANG_CHANGED | LANG_DEF_CHANGE))
                {
                    //
                    //  Load the keyboard layout into the system.
                    //
                    if (pLangNode->hklUnload)
                    {
                        hklLoad = LoadKeyboardLayoutEx( pLangNode->hklUnload,
                                                        szPreload10,
                                                        KLF_SUBSTITUTE_OK |
                                                         KLF_NOTELLSHELL |
                                                         g_dwAttributes );
                        if (hklLoad != pLangNode->hklUnload)
                        {
                            bReplaced = TRUE;
                        }
                    }
                    else
                    {
                            hklLoad = LoadKeyboardLayout( szPreload10,
                                                           KLF_SUBSTITUTE_OK |
                                                            KLF_NOTELLSHELL |
                                                            g_dwAttributes );
                    }

                    if (hklLoad)
                    {
                        pLangNode->wStatus &= ~(LANG_CHANGED | LANG_DEF_CHANGE);
                        pLangNode->wStatus |= (LANG_ACTIVE | LANG_ORIGACTIVE);

                        if (pLangNode->wStatus & LANG_DEFAULT)
                        {
                            hklDefault = hklLoad;
                        }

                        pLangNode->hkl = hklLoad;
                        pLangNode->hklUnload = hklLoad;
                    }
                    else
                    {
                        Locale_ApplyError( hwnd,
                                           pLangNode,
                                           IDS_KBD_LOAD_KBD_FAILED,
                                           MB_OK_OOPS );
                    }
                }
            }
        }
    }

    //
    //  Close the handles to the registry keys.
    //
    RegCloseKey(hkeySubst);
    RegCloseKey(hkeyPreload);
    
    //
    //  If TIP setting is changed, save the enable/disable status into
    //  registry TIP section.
    //
    if ((g_dwChanges & CHANGE_TIPCHANGE) && g_iTipsBuff)
    {
        int iIdxDefTip = -1;
        BOOL bSave = TRUE;

        SaveLanguageProfileStatus(bSave, iIdxDefTip, NULL);

        g_dwChanges &= ~CHANGE_TIPCHANGE;
    }

    //
    //  Make sure the default is set properly.  The layout id for the
    //  current default input locale may have been changed.
    //
    //  NOTE: This should be done before the Unloads occur in case one
    //        of the layouts to unload is the old default layout.
    //
    if (hklDefault != 0)
    {
        if (!SystemParametersInfo( SPI_SETDEFAULTINPUTLANG,
                                   0,
                                   (LPVOID)((LPDWORD)&hklDefault),
                                   0 ))
        {
            //
            //  Failure is not fatal.  The old default language will
            //  still work.
            //
            Locale_ErrorMsg(hwnd, IDS_KBD_NO_DEF_LANG2, NULL);
        }
        else
        {
            //
            //  Try to make everything switch to the new default input locale:
            //  if we are in setup  OR
            //  if it is the only one (but not if we just replaced the layout
            //    within the Input Locale without changing the input locale)
            //
            if (g_bSetupCase || ((nLocales == 1) && !bReplaced))
            {
                DWORD dwRecipients = BSM_APPLICATIONS | BSM_ALLDESKTOPS;
                BroadcastSystemMessage( BSF_POSTMESSAGE,
                                        &dwRecipients,
                                        WM_INPUTLANGCHANGEREQUEST,
                                        1,  // IS compatible with system font
                                        (LPARAM)hklDefault );
            }
        }
    }

    //
    // Apply the advanced tab changes.
    //
    if (g_hwndAdvanced != NULL && g_bAdvChanged)
    {
        DWORD dwDisableCtfmon;
        BOOL bPrevDisableCUAS;
        BOOL bDisabledCUAS;

        //
        // Get the previous CUAS status from the registry.
        //
        bPrevDisableCUAS = IsDisableCUAS();

        //
        // Save enable/disable CUAS info into the regitry.
        //
        if (IsDlgButtonChecked(g_hwndAdvanced, IDC_ADVANCED_CUAS_ENABLE))
        {
            //
            //  Enalbe Cicero Unaware Application Support.
            //
            SetDisableCUAS(FALSE);
        }
        else
        {
            //
            //  Disable Cicero Unaware Application Support.
            //
            SetDisableCUAS(TRUE);
        }

        bDisabledCUAS = IsDisableCUAS();

        if (!g_bSetupCase)
        {
            TCHAR szTitle[MAX_PATH];
            TCHAR szMsg[MAX_PATH];
            BOOL bPrevCtfmon;

            if (bPrevDisableCUAS != bDisabledCUAS)
            {
                //
                // CUAS option is changed, so need to require the system reboot.
                //
                bRebootForCUAS = TRUE;
            }

            //
            //  Find language tool bar module(CTFMON.EXE)
            //
            if (FindWindow(c_szCTFMonClass, NULL) == NULL)
                bPrevCtfmon = FALSE;
            else
                bPrevCtfmon = TRUE;

            if (!bPrevCtfmon &&
                !bRebootForCUAS &&
                !IsDlgButtonChecked(g_hwndAdvanced, IDC_ADVANCED_CTFMON_DISABLE))
            {
                // Turn on CTFMON.EXE
                CicLoadString(hInstance, IDS_TITLE_STRING, szTitle, ARRAYSIZE(szTitle));
                CicLoadString(hInstance, IDS_ENABLE_CICERO, szMsg, ARRAYSIZE(szMsg));

                //
                //  Notice - Need to restart apps that are already running.
                //
                MessageBox(hwnd, szMsg, szTitle, MB_OK);
            }
        }

        //
        // Save enable/disable CTFMON info into the regitry.
        //
        if (IsDlgButtonChecked(g_hwndAdvanced, IDC_ADVANCED_CTFMON_DISABLE))
        {
            //
            //  Set the ctfmon disable flag
            //
            dwDisableCtfmon = 1;
            SetDisalbeCtfmon(dwDisableCtfmon);
        }
        else
        {
            //
            //  Set the ctfmon enable flag
            //
            dwDisableCtfmon = 0;
            SetDisalbeCtfmon(dwDisableCtfmon);

            //
            //  Run ctfmon.exe immediately
            //
            if (!g_bSetupCase &&
                IsEnabledTipOrMultiLayouts() &&
                IsInteractiveUserLogon())
            {
                RunCtfmonProcess();
                bAlreadyLoadCtfmon = TRUE;
            }
        }

    }

    //
    //  Load the language tool bar if there is any enabled tip, otherwise
    //  disable tool bar
    //
    bDisableCtfmon = IsDisableCtfmon();

    if (!bDisableCtfmon && g_iInputs >= 2)
    {
        //
        //  Load language bar or language icon(ctfmon.exe)
        //
        if (!bAlreadyLoadCtfmon && (g_iInputs != g_iOrgInputs))
            LoadCtfmon(TRUE, 0, FALSE);

        if(!g_bSetupCase)
           EnableWindow(GetDlgItem(hwnd, IDC_TB_SETTING), TRUE);
    }
    else
    {
        if (bDisableCtfmon || !bHasIme)
        {
            LoadCtfmon(FALSE, 0, FALSE);

            //
            //  Disable language bar setting option button
            //
            EnableWindow(GetDlgItem(hwnd, IDC_TB_SETTING), FALSE);
        }
    }

    //
    //  Reset ctfmon change status.
    //
    g_bAdvChanged = FALSE;

    if (g_dwChanges & CHANGE_LANGSWITCH)
    {
        Locale_SetLanguageHotkey();
    }

    //
    //  Set the scan code entries in the registry.
    //
    if (RegCreateKey( HKEY_CURRENT_USER,
                      c_szScanCodeKey,
                      &hkeyScanCode ) == ERROR_SUCCESS)
    {
        if (szShiftL[0])
        {
            RegSetValueEx( hkeyScanCode,
                           c_szValueShiftLeft,
                           0,
                           REG_SZ,
                           (LPBYTE)szShiftL,
                           (DWORD)(lstrlen(szShiftL) + 1) * sizeof(TCHAR) );
        }

        if (szShiftR[0])
        {
            RegSetValueEx( hkeyScanCode,
                           c_szValueShiftRight,
                           0,
                           REG_SZ,
                           (LPBYTE)szShiftR,
                           (DWORD)(lstrlen(szShiftR) + 1) * sizeof(TCHAR) );
        }
        RegCloseKey(hkeyScanCode);
    }

    //
    //  Call SystemParametersInfo to enable the toggle.
    //
    SystemParametersInfo(SPI_SETLANGTOGGLE, 0, NULL, 0);

    //
    //  Turn off the hour glass.
    //
    SetCursor(hcurSave);

    if ((g_dwChanges & CHANGE_DIRECTSWITCH) || bHasIme || bRebootForCUAS)
    {
        g_dwChanges &= ~CHANGE_DIRECTSWITCH;

        if (RegOpenKey( HKEY_LOCAL_MACHINE,
                        c_szLoadImmPath,
                        &hKeyImm ) == ERROR_SUCCESS)
        {
            DWORD dwValue = 1;

            if ((g_dwChanges & CHANGE_DIRECTSWITCH) || bHasIme)
            {
                RegSetValueEx( hKeyImm,
                               TEXT("LoadIMM"),
                               0,
                               REG_DWORD,
                               (LPBYTE)&dwValue,
                               sizeof(DWORD) );
            }

            RegCloseKey(hKeyImm);

            if (g_bAdmin_Privileges &&
                ((!g_bSetupCase &&
                  !GetSystemMetrics(SM_IMMENABLED) &&
                  !GetSystemMetrics(SM_DBCSENABLED)) ||
                 bRebootForCUAS))
            {
                //
                //  Imm was not loaded.  Ask user to reboot and let
                //  it be loaded.
                //
                TCHAR szReboot[DESC_MAX];
                TCHAR szTitle[DESC_MAX];

                CicLoadString(hInstance, IDS_REBOOT_STRING, szReboot, ARRAYSIZE(szReboot));
                CicLoadString(hInstance, IDS_TITLE_STRING, szTitle, ARRAYSIZE(szTitle));
                if (MessageBox( hwnd,
                                szReboot,
                                szTitle,
                                MB_YESNO | MB_ICONQUESTION ) == IDYES)
                {
                    Region_RebootTheSystem();
                }
            }
        }
    }

    //
    //  Update the originial input layouts
    //
    g_iOrgInputs = g_iInputs;

    //
    //  Return success.
    //
    g_dwChanges = 0;
    PropSheet_UnChanged(GetParent(hwnd), hwnd);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  TVSubCVlassProc
//
//  Ignore TreeView item expand or contractibility
//
////////////////////////////////////////////////////////////////////////////

LRESULT WINAPI TVSubClassProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (message)
    {
        case (WM_LBUTTONDBLCLK):
        {
            return TRUE;
        }
        case (WM_KEYDOWN):
        {
            if (wParam == VK_LEFT || wParam == VK_RIGHT)
                return TRUE;
        }
        default:
        {
            return CallWindowProc(g_lpfnTVWndProc, hwnd, message, wParam, lParam);
        }
    }

    return CallWindowProc(g_lpfnTVWndProc, hwnd, message, wParam, lParam);
}


////////////////////////////////////////////////////////////////////////////
//
//  InputLocaleDlgProc
//
//  This is the dialog proc for the Input Locales property sheet.
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK InputLocaleDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hwndTV = GetDlgItem(hDlg, IDC_INPUT_LIST);

    switch (message)
    {
        case ( WM_DESTROY ) :
        {
            Locale_KillPaneDialog(hDlg);

            if (g_lpfnTVWndProc)
                SetWindowLongPtr(hwndTV, GWLP_WNDPROC, (LONG_PTR)g_lpfnTVWndProc);

            break;
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     c_szHelpFile,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aInputHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     c_szHelpFile,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aInputHelpIds );
            break;
        }
        case ( WM_INITDIALOG ) :
        {
            HWND hwndDefList = GetDlgItem(hDlg, IDC_LOCALE_DEFAULT);

            g_hDlg = hDlg;
            g_hwndTV = hwndTV;

            InitPropSheet(hDlg, (LPPROPSHEETPAGE)lParam);

            //
            //  Create image icons for Language tree view control
            //
            CreateImageIcons();

            //
            //  Reset the contents of the default locale combo box.
            //
            ComboBox_ResetContent(hwndDefList);

            g_hTVRoot = TreeView_GetRoot(hwndTV);

            //
            //  Get all installed input information
            //
            GetInstalledInput(hDlg);

            //
            //  Set subclass for treeview control to ignore treeview item expand
            //  or contractibility by mouse or keyboard.
            //
            g_lpfnTVWndProc = (WNDPROC) SetWindowLongPtr(hwndTV, GWLP_WNDPROC, (LONG_PTR) TVSubClassProc);

            Locale_CommandSetDefault(hDlg);

            //
            //  No longer supporting set default button.
            //
            //if (!g_bSetupCase && !g_bCHSystem)
            {
                HWND hwndDefBtn;

                hwndDefBtn = GetDlgItem(hDlg, IDC_KBDL_SET_DEFAULT);
                EnableWindow(hwndDefBtn, FALSE);
                ShowWindow(hwndDefBtn, SW_HIDE);
            }

            if (FindWindow(c_szCTFMonClass, NULL) == NULL || g_bSetupCase)
            {
                //
                //  Disable language bar setting option during the setup mode,
                //  or turned off ctfmon.
                //
                EnableWindow(GetDlgItem(hDlg, IDC_TB_SETTING), FALSE);
            }
            else
            {
                EnableWindow(GetDlgItem(hDlg, IDC_TB_SETTING), TRUE);
            }

            break;
        }

        case ( WM_NOTIFY ) :
        {
            switch (((NMHDR *)lParam)->code)
            {
                case TVN_SELCHANGED:
                {
                    CheckButtons(hDlg);
                    break;
                }
                case ( PSN_QUERYCANCEL ) :
                case ( PSN_KILLACTIVE ) :
                case ( PSN_RESET ) :
                    break;

                case ( PSN_APPLY ) :
                {
                    Locale_ApplyInputs(hDlg);
                    CheckButtons(hDlg);
                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }

        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                case ( IDC_KBDL_SET_DEFAULT ) :
                {
                    Locale_CommandSetDefaultLayout(hDlg);
                    break;
                }
                case ( IDC_KBDL_ADD ) :
                {
                    Locale_CommandAdd(hDlg);
                    break;
                }
                case ( IDC_KBDL_EDIT ) :
                {
                    Locale_CommandEdit(hDlg, NULL);
                    break;
                }
                case ( IDC_KBDL_DELETE ) :
                {
                    Locale_CommandDelete(hDlg);
                    break;
                }
                case ( IDC_LOCALE_DEFAULT ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                         Locale_CommandSetDefault(hDlg);
                    }
                    break;
                }
                case ( IDC_HOTKEY_SETTING ) :
                {
                    if (g_dwChanges & CHANGE_NEWKBDLAYOUT)
                    {
                        TCHAR szApplyMsg[MAX_PATH];
                        TCHAR szTitle[MAX_PATH];

                        CicLoadString(hInstance, IDS_KBD_APPLY_WARN, szApplyMsg, ARRAYSIZE(szApplyMsg));
                        CicLoadString(hInstance, IDS_TITLE_STRING, szTitle, ARRAYSIZE(szTitle));

                        if (MessageBox(hDlg,
                                       szApplyMsg,
                                       szTitle,
                                       MB_YESNO | MB_ICONQUESTION) == IDYES)
                        {
                            Locale_ApplyInputs(hDlg);
                        }
                        g_dwChanges &= ~CHANGE_NEWKBDLAYOUT;
                    }

                    Locale_CommandHotKeySetting(hDlg);
                    break;
                }
                case ( IDC_TB_SETTING ) :
                {
                    Locale_CommandToolBarSetting(hDlg);
                    break;
                }

                case ( IDOK ) :
                {
                    if (!Locale_ApplyInputs(hDlg))
                    {
                        break;
                    }

                    // fall thru...
                }
                case ( IDCANCEL ) :
                {
                    EndDialog(hDlg, TRUE);
                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }

        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_GetLayoutList
//
//  Fills in the given listbox with the appropriate list of layouts.
//
////////////////////////////////////////////////////////////////////////////

void Locale_GetLayoutList(
    HWND hwndLayout,
    UINT idxLang,
    UINT idxLayout,
    BOOL *pfNoDefLayout)
{
    UINT ctr;
    UINT idx;
    int idxSel = -1;
    int idxSame = -1;
    int idxOther = -1;
    int idxBase = -1;
    int idxUSA = -1;              // last resort default
    TCHAR sz[DESC_MAX];
    LPLANGNODE pTemp;
    DWORD LangID = g_lpLang[idxLang].dwID;
    DWORD BaseLangID = (LOWORD(LangID) & 0xff) | 0x400;

    //
    //  Reset the contents of the combo box.
    //
    ComboBox_ResetContent(hwndLayout);

    //
    //  Search through all of the layouts.
    //
    for (ctr = 0; ctr < g_iLayoutBuff; ctr++)
    {
        //
        //  Filter out IME layout if it is not under native locale.
        //
        if (((HIWORD(g_lpLayout[ctr].dwID) & 0xf000) == 0xe000) &&
            (LOWORD(g_lpLayout[ctr].dwID) != LOWORD(LangID)))
        {
            continue;
        }

        //
        //  Make sure this layout isn't already used for this input locale.
        //  If it is, then don't display it in the properties dialog.
        //
        if (ctr != idxLayout)
        {
            pTemp = g_lpLang[idxLang].pNext;
            while (pTemp)
            {
                if (pTemp->wStatus & LANG_ACTIVE)
                {
                    if (ctr == pTemp->iLayout)
                    {
                        break;
                    }
                }
                pTemp = pTemp->pNext;
            }
            if (pTemp && (ctr == pTemp->iLayout))
            {
                continue;
            }
        }

        //
        //  Get the layout text.  If it doesn't already exist in the
        //  combo box, then add it to the list of possible layouts.
        //
        GetAtomName(g_lpLayout[ctr].atmLayoutText, sz, ARRAYSIZE(sz));
        if ((idx = ComboBox_FindStringExact(hwndLayout, 0, sz)) == CB_ERR)
        {
            //
            //  Filter out TIP substitute HKL.
            //
            if (IsTipSubstituteHKL(IntToPtr(g_lpLayout[ctr].dwID)))
            {
                AddKbdLayoutOnKbdTip(IntToPtr(g_lpLayout[ctr].dwID), ctr);
                continue;
            }

            //
            //  Add the layout string and set the item data to be the
            //  index into the g_lpLayout array.
            //
            idx = ComboBox_AddString(hwndLayout, sz);
            ComboBox_SetItemData(hwndLayout, idx, MAKELONG(ctr, 0));

            //
            //  See if it's the US layout.  If so, save the index.
            //
            if (g_lpLayout[ctr].dwID == US_LOCALE)
            {
                idxUSA = ctr;
            }
        }

        if (idxLayout == -1)
        {
            //
            //  If the caller does not specify a layout, it must be the
            //  Add dialog.  First we want the default layout.  If the
            //  default layout is not an option (eg. it's already used),
            //  then we want any layout that has the same id as the locale
            //  to be the default.
            //
            if (idxSel == -1)
            {
                if (g_lpLayout[ctr].dwID == g_lpLang[idxLang].dwDefaultLayout)
                {
                    idxSel = ctr;
                }
                else if (idxSame == -1)
                {
                    if ((LOWORD(g_lpLayout[ctr].dwID) == LOWORD(LangID)) &&
                        (HIWORD(g_lpLayout[ctr].dwID) == 0))
                    {
                        idxSame = ctr;
                    }
                    else if (idxOther == -1)
                    {
                        if (LOWORD(g_lpLayout[ctr].dwID) == LOWORD(LangID))
                        {
                            idxOther = ctr;
                        }
                        else if ((idxBase == -1) &&
                                 (LOWORD(g_lpLayout[ctr].dwID) == LOWORD(BaseLangID)))
                        {
                            idxBase = ctr;
                        }
                    }
                }
            }
        }
        else if (ctr == idxLayout)
        {
            //
            //  For the properties dialog, we want the one ALREADY associated.
            //
            idxSel = ctr;
        }
    }

    //
    //  If it's the Add dialog, do some extra checking for the layout to use.
    //
    if (idxLayout == -1)
    {
        if (idxSel == -1)
        {
            idxSel = (idxSame != -1)
                         ? idxSame
                         : ((idxOther != -1) ? idxOther : idxBase);
        }
    }

    //
    //  If a default layout was not found, then set it to the US layout.
    //
    if (idxSel == -1)
    {
        idxSel = idxUSA;
        *pfNoDefLayout = TRUE;
    }

    //
    //  Set the current selection.
    //
    if (idxSel == -1)
    {
        //
        //  Simply set the current selection to be the first entry
        //  in the list.
        //
        ComboBox_SetCurSel(hwndLayout, 0);
    }
    else
    {
        //
        //  The combo box is sorted, but we need to know where
        //  g_lpLayout[idxSel] was stored.  So, get the atom again, and
        //  search the list.
        //
        GetAtomName(g_lpLayout[idxSel].atmLayoutText, sz, ARRAYSIZE(sz));
        idx = ComboBox_FindStringExact(hwndLayout, 0, sz);
        ComboBox_SetCurSel(hwndLayout, idx);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_GetTipList
//
////////////////////////////////////////////////////////////////////////////

void Locale_GetTipList(
    HWND hwnd,
    UINT uInxLang,
    BOOL bNoDefKbd)
{
    UINT ctr;
    int idxDefKbd = -1;
    BOOL bPenOn = FALSE;
    BOOL bSpeechOn = FALSE;
    BOOL bExternalOn = FALSE;
    TCHAR szTipName[DESC_MAX];
    TCHAR szNone[DESC_MAX];
    UINT uIdx;


    DWORD dwLangID = g_lpLang[uInxLang].dwID;
    HWND hwndKbd = GetDlgItem(hwnd, IDC_KBDLA_LAYOUT);
    HWND hwndPen = GetDlgItem(hwnd, IDC_PEN_TIP);
    HWND hwndPenText = GetDlgItem(hwnd, IDC_PEN_TEXT);
    HWND hwndSpeech = GetDlgItem(hwnd, IDC_SPEECH_TIP);
    HWND hwndSpeechText = GetDlgItem(hwnd, IDC_SPEECH_TEXT);
    HWND hwndExternal = GetDlgItem(hwnd, IDC_EXTERNAL_TIP);
    HWND hwndExternalText = GetDlgItem(hwnd, IDC_EXTERNAL_TEXT);

    //
    //  Reset the contents of the combo box.
    //
    ComboBox_ResetContent(hwndPen);
    ComboBox_ResetContent(hwndSpeech);
    ComboBox_ResetContent(hwndExternal);

    if (g_iTipsBuff == 0)
    {
        EnableWindow(hwndPen, FALSE);
        EnableWindow(hwndPenText, FALSE);
        EnableWindow(hwndSpeech, FALSE);
        EnableWindow(hwndSpeechText, FALSE);
        EnableWindow(hwndExternal, FALSE);
        EnableWindow(hwndExternalText, FALSE);

        return;
    }

    for (ctr = 0; ctr < g_iTipsBuff; ctr++)
    {
        if ((dwLangID == g_lpTips[ctr].dwLangID) &&
            (g_lpTips[ctr].uInputType != INPUT_TYPE_KBD))
        {
            //
            //  Get the Tips text.
            //
            GetAtomName(g_lpTips[ctr].atmTipText, szTipName, ARRAYSIZE(szTipName));

            if ((g_lpTips[ctr].uInputType & INPUT_TYPE_PEN) &&
                !(g_lpTips[ctr].bEnabled))
            {
                uIdx = ComboBox_AddString(hwndPen, szTipName);
                ComboBox_SetItemData(hwndPen, uIdx, MAKELONG(ctr, 0));
                bPenOn = TRUE;
            }
            else if ((g_lpTips[ctr].uInputType & INPUT_TYPE_SPEECH) &&
                     !(g_lpTips[ctr].bEnabled)                      &&
                      g_lpTips[ctr].fEngineAvailable)
            {
                uIdx = ComboBox_AddString(hwndSpeech, szTipName);
                ComboBox_SetItemData(hwndSpeech, uIdx, MAKELONG(ctr, 0));
                bSpeechOn = TRUE;
            }
            else if ((g_lpTips[ctr].uInputType & INPUT_TYPE_KBD) &&
                     !(g_lpTips[ctr].bEnabled))
            {
                uIdx = ComboBox_AddString(hwndKbd, szTipName);
                ComboBox_SetItemData(hwndKbd, uIdx, MAKELONG(ctr, 1));
                idxDefKbd = uIdx;
            }
            else if((g_lpTips[ctr].uInputType & INPUT_TYPE_EXTERNAL) &&
                    !(g_lpTips[ctr].bEnabled))
            {
                uIdx = ComboBox_AddString(hwndExternal, szTipName);
                ComboBox_SetItemData(hwndExternal, uIdx, MAKELONG(ctr, 0));
                bExternalOn = TRUE;
            }
        }
    }

    if (idxDefKbd != -1)
    {
        ComboBox_SetCurSel(hwndKbd, idxDefKbd);
    }

    EnableWindow(hwndPen, IsDlgButtonChecked(hwnd, IDC_PEN_TEXT));
    EnableWindow(hwndPenText, bPenOn);
    ComboBox_SetCurSel(hwndPen, 0);

    EnableWindow(hwndSpeech, IsDlgButtonChecked(hwnd, IDC_SPEECH_TEXT));
    EnableWindow(hwndSpeechText, bSpeechOn);
    ComboBox_SetCurSel(hwndSpeech, 0);

    EnableWindow(hwndExternal, IsDlgButtonChecked(hwnd, IDC_EXTERNAL_TEXT));
    EnableWindow(hwndExternalText, bExternalOn);
    ComboBox_SetCurSel(hwndExternal, 0);
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_AddDlgInit
//
//  Processing for a WM_INITDIALOG message for the Add dialog box.
//
////////////////////////////////////////////////////////////////////////////

BOOL Locale_AddDlgInit(
    HWND hwnd,
    LPARAM lParam)
{
    UINT ctr1;
    UINT idx;
    TCHAR sz[DESC_MAX];
    LPLANGNODE pLangNode;
    int  nLocales, idxList, IMELayoutExist = 0;
    UINT ctr2, ListCount, DefaultIdx = 0;
    LRESULT LCSelectData = (LONG)-1;
    BOOL bNoDefLayout = FALSE;
    DWORD dwCurLang = 0;
    TV_ITEM tvItem;
    HTREEITEM hTVItem;
    HWND hwndLang = GetDlgItem(hwnd, IDC_KBDLA_LOCALE);

    //
    //  Get the currently chosen input locale in the parent dialog's
    //  treeview list box.
    //
    hTVItem = TreeView_GetSelection(g_hwndTV);

    if (!hTVItem)
        return FALSE;

    tvItem.mask = TVIF_HANDLE | TVIF_PARAM;
    tvItem.hItem = hTVItem;

    if (TreeView_GetItem(g_hwndTV, &tvItem))
    {
        if ((LPTVITEMNODE) tvItem.lParam)
        {
            dwCurLang = ((LPTVITEMNODE) tvItem.lParam)->dwLangID;
        }
    }

    //
    //  Go through all of the input locales.  Display all of them,
    //  since we can have multiple layouts per locale.
    //
    //  Do NOT go down the links in this case.  We don't want to display
    //  the language choice multiple times.
    //
    for (ctr1 = 0; ctr1 < g_iLangBuff; ctr1++)
    {
        //
        //  If the language does not contain an IME layout, then
        //  compare with layout counts without IME.
        //
        for (ctr2 = 0; ctr2 < g_iLayoutBuff; ctr2++)
        {
            if ((LOWORD(g_lpLayout[ctr2].dwID) == LOWORD(g_lpLang[ctr1].dwID)) &&
                ((HIWORD(g_lpLayout[ctr2].dwID) & 0xf000) == 0xe000))
            {
                IMELayoutExist = 1;
                break;
            }
        }
        if ((!IMELayoutExist) &&
            (g_lpLang[ctr1].iNumCount == (g_iLayoutBuff - g_iLayoutIME)) &&
            (g_iTipsBuff == 0))
        {
            //
            //  No more layouts to be added for this language.
            //
            continue;
        }

        //
        //  Make sure there are layouts to be added for this
        //  input locale.
        //
        if ((g_lpLang[ctr1].iNumCount != g_iLayoutBuff) ||
            (g_iTipsBuff != 0 && IsTipAvailableForAdd(g_lpLang[ctr1].dwID)))
        {
            //
            //  Get the language name, add the string to the
            //  combo box, and set the index into the g_lpLang
            //  array as the item data.
            //
            GetAtomName(g_lpLang[ctr1].atmLanguageName, sz, ARRAYSIZE(sz));
            idx = ComboBox_AddString(hwndLang, sz);
            ComboBox_SetItemData(hwndLang, idx, MAKELONG(ctr1, 0));

            //
            //  Save system default locale.
            //
            if (LCSelectData == -1)
            {
                if (g_lpLang[ctr1].dwID == GetSystemDefaultLCID())
                {
                    LCSelectData = MAKELONG(ctr1, 0);
                }
            }

            //
            //  Save chosen input locale.
            //
            if (dwCurLang && (g_lpLang[ctr1].dwID == dwCurLang))
            {
                LCSelectData = MAKELONG(ctr1, 0);
                dwCurLang = 0;
            }
        }
    }

    //
    //  Set the current selection to the currently chosen input locale
    //  or the default system locale entry.
    //
    if (LCSelectData != -1)
    {
        ListCount = ComboBox_GetCount(hwndLang);
        for (ctr1 = 0; ctr1 < ListCount; ctr1++)
        {
            if (LCSelectData == ComboBox_GetItemData(hwndLang, ctr1))
            {
                DefaultIdx = ctr1;
                break;
            }
        }
    }
    ComboBox_SetCurSel(hwndLang, DefaultIdx);
    idx = (UINT)ComboBox_GetItemData(hwndLang, DefaultIdx);

    SetProp(hwnd, szPropHwnd, (HANDLE)((LPINITINFO)lParam)->hwndMain);
    SetProp(hwnd, szPropIdx, (HANDLE)UIntToPtr(idx));

    //
    //  Check available language.
    //
    if (idx == -1)
    {
        //
        //  No languages
        //
        Locale_ErrorMsg(hwnd, IDS_KBD_NO_MORE_TO_ADD, NULL);

        return FALSE;
    }

    //
    //  Display the keyboard layout.
    //
    Locale_GetLayoutList(GetDlgItem(hwnd, IDC_KBDLA_LAYOUT), idx, -1, &bNoDefLayout);

    Locale_GetTipList(hwnd, idx, bNoDefLayout);

    //
    //  Checking for keyboard layout. If user already has this language,
    //  we want to give a choice to enable/disable keyboard layout. Otherwise,
    //  just enable the adding keyboard layouts.
    //
    if (g_bPenOrSapiTip || g_bExtraTip)
    {
        if (FindTVLangItem(g_lpLang[idx].dwID, NULL))
        {
            CheckDlgButton(hwnd, IDC_KBDLA_LAYOUT_TEXT, BST_UNCHECKED);
            EnableWindow(GetDlgItem(hwnd, IDC_KBDLA_LAYOUT_TEXT), TRUE);
            EnableWindow(GetDlgItem(hwnd, IDC_KBDLA_LAYOUT), FALSE);

        }
        else
        {
            CheckDlgButton(hwnd, IDC_KBDLA_LAYOUT_TEXT, BST_CHECKED);
            EnableWindow(GetDlgItem(hwnd, IDC_KBDLA_LAYOUT_TEXT), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_KBDLA_LAYOUT), TRUE);
        }
    }

    //
    //  Disable the keyboard layout if there is no available layout.
    //
    if (!ComboBox_GetCount(GetDlgItem(hwnd, IDC_KBDLA_LAYOUT)))
    {
        EnableWindow(GetDlgItem(hwnd, IDC_KBDLA_LAYOUT_TEXT), FALSE);
    }

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_AddCommandOK
//
//  Gets the currently selected input locale from the combo box and marks
//  it as active in the g_lpLang list.  It then gets the requested layout
//  and sets that in the list.  It then adds the new input locale string
//  to the input locale list in the property sheet.
//
////////////////////////////////////////////////////////////////////////////

int Locale_AddCommandOK(
    HWND hwnd)
{
    LPLANGNODE pLangNode = NULL;
    HWND hwndLang = GetDlgItem(hwnd, IDC_KBDLA_LOCALE);
    HWND hwndLayout = GetDlgItem(hwnd, IDC_KBDLA_LAYOUT);
    HWND hwndPen = GetDlgItem(hwnd, IDC_PEN_TIP);
    HWND hwndSpeech = GetDlgItem(hwnd, IDC_SPEECH_TIP);
    HWND hwndExternal = GetDlgItem(hwnd, IDC_EXTERNAL_TIP);
    int idxLang = ComboBox_GetCurSel(hwndLang);
    int idxLayout = ComboBox_GetCurSel(hwndLayout);
    int idxPen = ComboBox_GetCurSel(hwndPen);
    int idxSpeech = ComboBox_GetCurSel(hwndSpeech);
    int idxExternal = ComboBox_GetCurSel(hwndExternal);
    int iPen = -1;
    int iSpeech = -1;
    int iExternal = -1;
    int iKbdLayout = -1;
    WORD wDefault = 0;

    //
    //  Get the offset for the language to add.
    //
        idxLang = (int)ComboBox_GetItemData(hwndLang, idxLang);

    //
    //  Get the offset for the chosen keyboard layout.
    //
    if (IsDlgButtonChecked(hwnd, IDC_KBDLA_LAYOUT_TEXT) ||
        !(g_bPenOrSapiTip || g_bExtraTip))
        iKbdLayout = (int)ComboBox_GetItemData(hwndLayout, idxLayout);

    //
    //  Get the offset for the chosen Tips.
    //
    if (hwndPen && hwndSpeech)
    {
        if (IsDlgButtonChecked(hwnd, IDC_PEN_TEXT))
            iPen = (int) ComboBox_GetItemData(hwndPen, idxPen);
        if (IsDlgButtonChecked(hwnd, IDC_SPEECH_TEXT))
            iSpeech = (int) ComboBox_GetItemData(hwndSpeech, idxSpeech);
    }

    if (hwndExternal)
    {
        if (IsDlgButtonChecked(hwnd, IDC_EXTERNAL_TEXT))
            iExternal = (int) ComboBox_GetItemData(hwndExternal, idxExternal);
    }


    //
    //  Selected no keyboard layout
    //
    if (iKbdLayout == CB_ERR)
        goto AddLang;

    if (HIWORD(iKbdLayout))
    {
        iKbdLayout = LOWORD(iKbdLayout);
    }
    else
    {
        //
        //  Need to check win9x system, since win9x doesn't support multiple
        //  keyboard layout on the same language. But FE system can have multiple
        //  IME layouts
        //
        if ((g_OSWIN95 && !IsFELangID(g_lpLang[idxLang].dwID)) &&
            (g_lpLang[idxLang].iNumCount))
        {
            TCHAR szTemp[DESC_MAX];
            TCHAR szMsg[DESC_MAX];
            TCHAR szNewLayout[DESC_MAX];

            CicLoadString(hInstance, IDS_KBD_LAYOUTEDIT, szMsg, ARRAYSIZE(szMsg));
            GetAtomName(g_lpLayout[iKbdLayout].atmLayoutText, szNewLayout, ARRAYSIZE(szNewLayout));
            StringCchPrintf(szTemp, ARRAYSIZE(szTemp), szMsg, szNewLayout);

            //
            //  Ask user whether new selected keyboard layout will be replaced
            //  or not.
            //
            if (MessageBox(hwnd, szTemp, NULL, MB_YESNO | MB_ICONQUESTION) == IDYES)
            {
                HTREEITEM hItem;
                LPLANGNODE pOldLangNode = g_lpLang[idxLang].pNext;

                GetAtomName(g_lpLayout[pOldLangNode->iLayout].atmLayoutText, szTemp, ARRAYSIZE(szTemp));

                //
                //  Find installed keyboard layout to delete it.
                //
                if (hItem = FindTVItem(g_lpLang[idxLang].dwID, szTemp))
                {
                    TV_ITEM tvItem;

                    tvItem.mask = TVIF_HANDLE | TVIF_PARAM;
                    tvItem.hItem = hItem;

                    pOldLangNode->wStatus &= ~LANG_ACTIVE;
                    pOldLangNode->wStatus |= LANG_CHANGED;

                    if (pOldLangNode->wStatus & LANG_DEFAULT)
                        wDefault = LANG_DEFAULT;

                    g_lpLang[pOldLangNode->iLang].iNumCount--;

                    Locale_RemoveFromLinkedList(pOldLangNode);

                    if (TreeView_GetItem(g_hwndTV, &tvItem) && tvItem.lParam)
                    {
                        RemoveTVItemNode((LPTVITEMNODE)tvItem.lParam);
                        TreeView_DeleteItem(g_hwndTV, tvItem.hItem );
                    }

                    g_iInputs--;
                }

            }
            else
            {
                //
                //  Cancel - leave installed keyboard layout without changing.
                //  Check if there are other tips to be installed.
                //
                iKbdLayout = -1;
                goto AddLang;
            }
        }


        //
        //  Insert a new language node.
        //
        pLangNode = Locale_AddToLinkedList(idxLang, 0);
        if (!pLangNode)
        {
            return (0);
        }

        //
        //  Get the offset for the chosen keyboard layout.
        //
        pLangNode->iLayout = (UINT) iKbdLayout;

        //
        //  Set ikbdLayout as the default to distinguish keyboard tip from layouts.
        //
        iKbdLayout = -1;

        //
        //  Set the default hkl after replacing the default hkl with new one.
        //
        if (g_OSWIN95)
            pLangNode->wStatus |= wDefault;

        //
        //  See if the layout is an IME and mark the status bits accordingly.
        //
        if ((HIWORD(g_lpLayout[pLangNode->iLayout].dwID) & 0xf000) == 0xe000)
        {
            pLangNode->wStatus |= LANG_IME;
        }
        else
        {
            pLangNode->wStatus &= ~LANG_IME;
        }
    }

AddLang:
    //
    //  Add the new language.
    //
    if (!Locale_AddLanguage(GetProp(hwnd, szPropHwnd), pLangNode, iKbdLayout, iPen, iSpeech, iExternal, idxLang))
    {
        //
        //  Unable to add the language.  Need to return the user back
        //  to the Add dialog.
        //
        if (pLangNode)
            Locale_RemoveFromLinkedList(pLangNode);

        return (0);
    }

    //
    //  Return success.
    //
    return (1);
}


////////////////////////////////////////////////////////////////////////////
//
//  KbdLocaleAddDlg
//
//  This is the dialog proc for the Add button of the Input Locales
//  property sheet.
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK KbdLocaleAddDlg(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            if (!Locale_AddDlgInit(hwnd, lParam))
            {
                EndDialog(hwnd, 0);
            }

            break;
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     c_szHelpFile,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aLocaleAddHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     c_szHelpFile,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aLocaleAddHelpIds );
            break;
        }
        case ( WM_DESTROY ) :
        {
            RemoveProp(hwnd, szPropHwnd);
            RemoveProp(hwnd, szPropIdx);
            break;
        }
        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                case ( IDOK ) :
                {
                    if (!Locale_AddCommandOK(hwnd))
                    {
                        //
                        //  This means the properties dialog was cancelled.
                        //  The Add dialog should remain active.
                        //
                        break;
                    }

                    // fall thru...
                }
                case ( IDCANCEL ) :
                {
                    EndDialog(hwnd, (wParam == IDOK) ? 1 : 0);
                    break;
                }
                case ( IDC_KBDLA_LOCALE ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        HWND hwndLocale = (HWND)lParam;
                        HWND hwndLayout = GetDlgItem(hwnd, IDC_KBDLA_LAYOUT);
                        BOOL bNoDefLayout = FALSE;
                        int idx;

                        //
                        //  Update the keyboard layout lists.
                        //
                        if ((idx = ComboBox_GetCurSel(hwndLocale)) != CB_ERR)
                        {
                            idx = (int)ComboBox_GetItemData(hwndLocale, idx);
                            Locale_GetLayoutList(hwndLayout, idx, -1, &bNoDefLayout);

                            Locale_GetTipList(hwnd, idx, bNoDefLayout);
                        }

                        //
                        //  Check the keyboard layout visibility
                        //
                        if (g_bPenOrSapiTip || g_bExtraTip)
                        {

                            if (FindTVLangItem(g_lpLang[idx].dwID, NULL))
                            {
                                CheckDlgButton(hwnd, IDC_KBDLA_LAYOUT_TEXT, BST_UNCHECKED);
                                EnableWindow(GetDlgItem(hwnd, IDC_KBDLA_LAYOUT_TEXT), TRUE);
                                EnableWindow(GetDlgItem(hwnd, IDC_KBDLA_LAYOUT), FALSE);
                            }
                            else
                            {
                                //
                                //  There isn't this language in the user configuration, so
                                //  force to add a keyboard layout for this language.
                                //
                                CheckDlgButton(hwnd, IDC_KBDLA_LAYOUT_TEXT, BST_CHECKED);
                                EnableWindow(GetDlgItem(hwnd, IDC_KBDLA_LAYOUT_TEXT), FALSE);
                                EnableWindow(GetDlgItem(hwnd, IDC_KBDLA_LAYOUT), TRUE);
                            }
                        }

                        //
                        //  Disable the keyboard layout if there is no available layout.
                        //
                        if (!ComboBox_GetCount(GetDlgItem(hwnd, IDC_KBDLA_LAYOUT)))
                        {
                            EnableWindow(GetDlgItem(hwnd, IDC_KBDLA_LAYOUT_TEXT), FALSE);
                        }
                    }
                    break;
                }
                case (IDC_KBDLA_LAYOUT_TEXT) :
                {
                      EnableWindow(GetDlgItem(hwnd, IDC_KBDLA_LAYOUT), IsDlgButtonChecked(hwnd, IDC_KBDLA_LAYOUT_TEXT));
                      break;
                }
                case (IDC_PEN_TEXT) :
                {
                      EnableWindow(GetDlgItem(hwnd, IDC_PEN_TIP), IsDlgButtonChecked(hwnd, IDC_PEN_TEXT));
                      break;
                }
                case (IDC_SPEECH_TEXT) :
                {
                      EnableWindow(GetDlgItem(hwnd, IDC_SPEECH_TIP), IsDlgButtonChecked(hwnd, IDC_SPEECH_TEXT));
                      break;
                }
                case (IDC_EXTERNAL_TEXT) :
                {
                      EnableWindow(GetDlgItem(hwnd, IDC_EXTERNAL_TIP), IsDlgButtonChecked(hwnd, IDC_EXTERNAL_TEXT));
                      break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////
//
//  GetToolBarSetting
//
////////////////////////////////////////////////////////////////////////////

void GetToolBarSetting(
    HWND hwnd)
{
    HRESULT hr;
    DWORD dwTBFlag = 0;
    ITfLangBarMgr *pLangBar = NULL;

    if (!g_OSNT5)
    {
        EnableWindow(GetDlgItem(hwnd, IDC_TB_HIGHTRANS), FALSE);
    }

    //
    // load LangBar manager
    //
    hr = CoCreateInstance(&CLSID_TF_LangBarMgr,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          &IID_ITfLangBarMgr,
                          (LPVOID *) &pLangBar);

    if (SUCCEEDED(hr))
        pLangBar->lpVtbl->GetShowFloatingStatus(pLangBar, &dwTBFlag);

    //
    //  Set the language bar show/close.
    //
    CheckDlgButton(hwnd, IDC_TB_SHOWLANGBAR, !(dwTBFlag & TF_SFT_HIDDEN));

    if (!(dwTBFlag & TF_SFT_SHOWNORMAL))
    {
        //  Disable langbar setting options
        //EnableWindow(GetDlgItem(hwnd, IDC_TB_EXTRAICON), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_TB_HIGHTRANS), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_TB_TEXTLABELS), FALSE);
    }

    //
    //  Set language bar extra icons in case of minimized.
    //
    CheckDlgButton(hwnd, IDC_TB_EXTRAICON, dwTBFlag & TF_SFT_EXTRAICONSONMINIMIZED);

    //
    //  Set the default toolbar transparency option.
    //
    CheckDlgButton(hwnd, IDC_TB_HIGHTRANS, !(dwTBFlag & TF_SFT_NOTRANSPARENCY));

    //
    //  Set the default toolbar show text option.
    //
    CheckDlgButton(hwnd, IDC_TB_TEXTLABELS, dwTBFlag & TF_SFT_LABELS);

    if (pLangBar)
        pLangBar->lpVtbl->Release(pLangBar);
}

////////////////////////////////////////////////////////////////////////////
//
//  ToolBarSettingInit
//
////////////////////////////////////////////////////////////////////////////

void ToolBarSettingInit(
    HWND hwnd)
{
    HWND hwndCTFMon = NULL;

    //
    //  Find language tool bar module(CTFMON.EXE)
    //
    hwndCTFMon = FindWindow(c_szCTFMonClass, NULL);

    if (hwndCTFMon)
    {
        EnableWindow(GetDlgItem(hwnd, IDC_TB_SHOWLANGBAR), TRUE);
        EnableWindow(GetDlgItem(hwnd, IDC_TB_EXTRAICON), TRUE);

        GetToolBarSetting(hwnd);
    }
    else
    {
        EnableWindow(GetDlgItem(hwnd, IDC_TB_SHOWLANGBAR), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_TB_EXTRAICON), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_TB_HIGHTRANS), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_TB_TEXTLABELS), FALSE);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ToolBarSettingOK
//
////////////////////////////////////////////////////////////////////////////

void ToolBarSettingOK(
    HWND hwnd)
{
    DWORD dwDisableCtfmon;
    HRESULT hr;
    DWORD dwTBFlag = 0;
    ITfLangBarMgr *pLangBar = NULL;

    g_dwToolBar = 0;

    //
    //  Load LangBar manager and get the current status.
    //
    hr = CoCreateInstance(&CLSID_TF_LangBarMgr,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          &IID_ITfLangBarMgr,
                          (LPVOID *) &pLangBar);

    if (SUCCEEDED(hr))
        pLangBar->lpVtbl->GetShowFloatingStatus(pLangBar, &dwTBFlag);

    if (pLangBar)
        pLangBar->lpVtbl->Release(pLangBar);

    if (IsDlgButtonChecked(hwnd, IDC_TB_SHOWLANGBAR))
    {
        if (dwTBFlag & TF_SFT_HIDDEN)
        {
            g_dwToolBar |= TF_SFT_SHOWNORMAL;
        }
        else
        {
            if (dwTBFlag & TF_SFT_SHOWNORMAL)
                g_dwToolBar |= TF_SFT_SHOWNORMAL;
            else if (dwTBFlag & TF_SFT_DOCK)
                g_dwToolBar |= TF_SFT_DOCK;
            else if (dwTBFlag & TF_SFT_MINIMIZED)
                g_dwToolBar |= TF_SFT_MINIMIZED;
            else if (dwTBFlag & TF_SFT_DESKBAND)
                g_dwToolBar |= TF_SFT_DESKBAND;
        }
    }
    else
    {
        g_dwToolBar |= TF_SFT_HIDDEN;
    }

    //
    //  Get the extra icons
    //
    if (IsDlgButtonChecked(hwnd, IDC_TB_EXTRAICON))
        g_dwToolBar |= TF_SFT_EXTRAICONSONMINIMIZED;
    else
        g_dwToolBar |= TF_SFT_NOEXTRAICONSONMINIMIZED;

    //
    //  Get the transparency setting
    //
    if (IsDlgButtonChecked(hwnd, IDC_TB_HIGHTRANS))
        g_dwToolBar |= TF_SFT_LOWTRANSPARENCY;
    else
        g_dwToolBar |= TF_SFT_NOTRANSPARENCY;

    //
    //  Get the label setting
    //
    if (IsDlgButtonChecked(hwnd, IDC_TB_TEXTLABELS))
        g_dwToolBar |= TF_SFT_LABELS;
    else
        g_dwToolBar |= TF_SFT_NOLABELS;

    //
    //  Update toolbar setting on the Apply button.
    //
    UpdateToolBarSetting();
}


////////////////////////////////////////////////////////////////////////////
//
//  ToolBarSettingDlg
//
//  This is the dialog proc for the ToolBar Setting Dlg.
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK ToolBarSettingDlg(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            ToolBarSettingInit(hwnd);

            break;
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     c_szHelpFile,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aToolbarSettingsHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     c_szHelpFile,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aToolbarSettingsHelpIds );
            break;
        }
        case ( WM_DESTROY ) :
        {
            break;
        }
        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                case ( IDOK ) :
                {
                    ToolBarSettingOK(hwnd);
                    // fall thru...
                }
                case ( IDCANCEL ) :
                {
                    EndDialog(hwnd, (wParam == IDOK) ? 1 : 0);
                    break;
                }
                case ( IDC_TB_SHOWLANGBAR ) :
                {
                    BOOL bShowLangBar;

                    bShowLangBar = IsDlgButtonChecked(hwnd, IDC_TB_SHOWLANGBAR);

                    EnableWindow(GetDlgItem(hwnd, IDC_TB_EXTRAICON), bShowLangBar);
                    EnableWindow(GetDlgItem(hwnd, IDC_TB_HIGHTRANS), bShowLangBar);
                    EnableWindow(GetDlgItem(hwnd, IDC_TB_TEXTLABELS), bShowLangBar);

                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_TranslateHotKey
//
//  Translates hotkey modifiers and values into key names.
//
////////////////////////////////////////////////////////////////////////////

void Locale_TranslateHotKey(
    LPTSTR lpString,
    UINT cchString,
    UINT uVKey,
    UINT uModifiers)
{
    UINT ctr;
    TCHAR szBuffer[DESC_MAX];
    BOOL bMod = FALSE;

    lpString[0] = 0;

    if (uModifiers & MOD_CONTROL)
    {
        CicLoadString(hInstance, IDS_KBD_MOD_CONTROL, szBuffer, ARRAYSIZE(szBuffer));
        StringCchCat(lpString, cchString, szBuffer);
        bMod = TRUE;
    }

    if (uModifiers & MOD_ALT)
    {
        CicLoadString(hInstance, IDS_KBD_MOD_LEFT_ALT, szBuffer, ARRAYSIZE(szBuffer));
        StringCchCat(lpString, cchString, szBuffer);
        bMod = TRUE;
    }

    if (uModifiers & MOD_SHIFT)
    {
        CicLoadString(hInstance, IDS_KBD_MOD_SHIFT, szBuffer, ARRAYSIZE(szBuffer));

        StringCchCat(lpString, cchString, szBuffer);
        bMod = TRUE;
    }

    if (uVKey == 0)
    {
        if (!bMod)
        {
            GetAtomName( g_aVirtKeyDesc[0].atVirtKeyName,
                         szBuffer,
                         sizeof(szBuffer) / sizeof(TCHAR) );
            StringCchCat(lpString, cchString, szBuffer);
            return;
        }
        else
        {
            //
            //  Only modifiers, remove the "+" at the end.
            //
            lpString[lstrlen(lpString) - 1] = 0;
            return;
        }
    }

    for (ctr = 0; (ctr < sizeof(g_aVirtKeyDesc) / sizeof(VIRTKEYDESC)); ctr++)
    {
        if (g_aVirtKeyDesc[ctr].uVirtKeyValue == uVKey)
        {
            GetAtomName( g_aVirtKeyDesc[ctr].atVirtKeyName,
                         szBuffer,
                         sizeof(szBuffer) / sizeof(TCHAR) );
            StringCchCat(lpString, cchString, szBuffer);
            return;
        }
    }

    GetAtomName( g_aVirtKeyDesc[0].atVirtKeyName,
                 szBuffer,
                 sizeof(szBuffer) / sizeof(TCHAR) );
    StringCchCat(lpString, cchString, szBuffer);
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_HotKeyDrawItem
//
//  Draws the hotkey list box.
//
////////////////////////////////////////////////////////////////////////////

void Locale_HotKeyDrawItem(
    HWND hWnd,
    LPDRAWITEMSTRUCT lpDis)
{
    LPHOTKEYINFO pHotKeyNode;
    COLORREF crBk, crTxt;
    UINT uStrLen, uAlign;
    TCHAR szString[DESC_MAX];
    TCHAR szHotKey[DESC_MAX];
    SIZE Size;
    UINT iMaxChars;
    int iMaxWidth;

    if (!ListBox_GetCount(lpDis->hwndItem))
    {
        return;
    }

    pHotKeyNode = (LPHOTKEYINFO)lpDis->itemData;

    crBk = SetBkColor( lpDis->hDC,
                       (lpDis->itemState & ODS_SELECTED)
                         ? GetSysColor(COLOR_HIGHLIGHT)
                         : GetSysColor(COLOR_WINDOW) );

    crTxt = SetTextColor( lpDis->hDC,
                          (lpDis->itemState & ODS_SELECTED)
                            ? GetSysColor(COLOR_HIGHLIGHTTEXT)
                            : GetSysColor(COLOR_WINDOWTEXT) );

    if (g_bMESystem && (pHotKeyNode->dwHotKeyID == HOTKEY_SWITCH_LANG))
        Locale_TranslateHotKey( szHotKey,
                                ARRAYSIZE(szHotKey),
                                0,
                                pHotKeyNode->uModifiers );
    else
        Locale_TranslateHotKey( szHotKey,
                                ARRAYSIZE(szHotKey),
                                pHotKeyNode->uVKey,
                                pHotKeyNode->uModifiers );

    GetTextExtentExPoint( lpDis->hDC,
                          szHotKey,
                          lstrlen(szHotKey),
                          0,
                          NULL,
                          NULL ,
                          &Size );

    iMaxWidth = lpDis->rcItem.right - lpDis->rcItem.left - Size.cx - LIST_MARGIN * 8;

    uStrLen = GetAtomName( pHotKeyNode->atmHotKeyName,
                           szString,
                           sizeof(szString) / sizeof(TCHAR) );

    GetTextExtentExPoint( lpDis->hDC,
                          szString,
                          uStrLen,
                          iMaxWidth,
                          &iMaxChars,
                          NULL ,
                          &Size );

    if (uStrLen > iMaxChars)
    {
        szString[iMaxChars-3] = TEXT('.');
        szString[iMaxChars-2] = TEXT('.');
        szString[iMaxChars-1] = TEXT('.');
        szString[iMaxChars]   = 0;
    }

    ExtTextOut( lpDis->hDC,
                lpDis->rcItem.left + LIST_MARGIN,
                lpDis->rcItem.top + (g_cyListItem - g_cyText) / 2,
                ETO_OPAQUE,
                &lpDis->rcItem,
                szString,
                iMaxChars,
                NULL );

    uAlign = GetTextAlign(lpDis->hDC);

    SetTextAlign(lpDis->hDC, TA_RIGHT);

    ExtTextOut( lpDis->hDC,
                lpDis->rcItem.right - LIST_MARGIN,
                lpDis->rcItem.top + (g_cyListItem - g_cyText) / 2,
                0,
                NULL,
                szHotKey,
                lstrlen(szHotKey),
                NULL );

    SetTextAlign(lpDis->hDC, uAlign);

    SetBkColor(lpDis->hDC, crBk);

    SetTextColor(lpDis->hDC, crTxt);

    if (lpDis->itemState & ODS_FOCUS)
    {
        DrawFocusRect(lpDis->hDC, &lpDis->rcItem);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_DrawItem
//
//  Processing for a WM_DRAWITEM message.
//
////////////////////////////////////////////////////////////////////////////

BOOL Locale_DrawItem(
    HWND hwnd,
    LPDRAWITEMSTRUCT lpdi)
{
    switch (lpdi->CtlID)
    {
        case ( IDC_KBDL_HOTKEY_LIST ) :
        {
            Locale_HotKeyDrawItem(hwnd, lpdi);
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_MeasureItem
//
//  Processing for a WM_MEASUREITEM message.
//
////////////////////////////////////////////////////////////////////////////

void Locale_MeasureItem(
    HWND hwnd,
    LPMEASUREITEMSTRUCT lpmi)
{
    HFONT hfont;
    HDC hdc;
    TEXTMETRIC tm;

    switch (lpmi->CtlID)
    {
        case ( IDC_KBDL_HOTKEY_LIST ) :
        {
            hfont = (HFONT) SendMessage(hwnd, WM_GETFONT, 0, 0);
            hdc = GetDC(NULL);
            hfont = SelectObject(hdc, hfont);

            GetTextMetrics(hdc, &tm);
            SelectObject(hdc, hfont);
            ReleaseDC(NULL, hdc);

            g_cyText = tm.tmHeight;
            lpmi->itemHeight = g_cyListItem =
                MAX(g_cyText, GetSystemMetrics(SM_CYSMICON)) + 2 * LIST_MARGIN;

            break;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_CommandChangeHotKey
//
//  Brings up change hotkey dialog box.
//
////////////////////////////////////////////////////////////////////////////

void Locale_CommandChangeHotKey(
    HWND hwnd)
{
    HWND hwndHotkey = GetDlgItem(hwnd, IDC_KBDL_HOTKEY_LIST);
    LPHOTKEYINFO pHotKeyNode;
    int iIndex;
    INITINFO InitInfo;

    iIndex = ListBox_GetCurSel(hwndHotkey);
    pHotKeyNode = (LPHOTKEYINFO)ListBox_GetItemData(hwndHotkey, iIndex);

    InitInfo.hwndMain = hwnd;
    InitInfo.pHotKeyNode = pHotKeyNode;

    if (pHotKeyNode->dwHotKeyID == HOTKEY_SWITCH_LANG)
    {
        if (g_iThaiLayout)
            DialogBoxParam(GetCicResInstance(hInstance, DLG_KEYBOARD_HOTKEY_INPUT_LOCALE_THAI),
                           MAKEINTRESOURCE(DLG_KEYBOARD_HOTKEY_INPUT_LOCALE_THAI),
                           hwnd,
                           (DLGPROC)KbdLocaleChangeThaiInputLocaleHotkey,
                           (LPARAM)&InitInfo);
        else if (g_bMESystem)
            DialogBoxParam(GetCicResInstance(hInstance, DLG_KEYBOARD_HOTKEY_INPUT_LOCALE_ME),
                           MAKEINTRESOURCE(DLG_KEYBOARD_HOTKEY_INPUT_LOCALE_ME),
                           hwnd,
                           (DLGPROC)KbdLocaleChangeMEInputLocaleHotkey,
                           (LPARAM)&InitInfo);
        else
            DialogBoxParam(GetCicResInstance(hInstance, DLG_KEYBOARD_HOTKEY_INPUT_LOCALE),
                           MAKEINTRESOURCE(DLG_KEYBOARD_HOTKEY_INPUT_LOCALE),
                           hwnd,
                           (DLGPROC)KbdLocaleChangeInputLocaleHotkey,
                           (LPARAM)&InitInfo);
    }
    else
        DialogBoxParam(GetCicResInstance(hInstance, DLG_KEYBOARD_HOTKEY_KEYBOARD_LAYOUT),
                       MAKEINTRESOURCE(DLG_KEYBOARD_HOTKEY_KEYBOARD_LAYOUT),
                       hwnd,
                       KbdLocaleChangeKeyboardLayoutHotkey,
                       (LPARAM)&InitInfo);
}


////////////////////////////////////////////////////////////////////////////
//
//  KbdLocaleHotKeyDlg
//
//  This is the dialog proc for the Input Locales HotKey Setting Dlg.
//
////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK KbdLocaleHotKeyDlg(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    static BOOL bHasIme;

    switch (uMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            UINT ctr;
            TCHAR szItem[DESC_MAX];

            //
            //  Get hotkey information.
            //
            bHasIme = FALSE;
            Locale_GetHotkeys(hwnd, &bHasIme);

            if (!ListBox_GetCount(GetDlgItem(hwnd, IDC_KBDL_HOTKEY_LIST)))
            {
                EnableWindow(GetDlgItem(hwnd, IDC_KBDL_CHANGE_HOTKEY), FALSE);
            }

            //
            //  Get Attributes information (CapsLock/ShiftLock etc.)
            //
            Locale_GetAttributes(hwnd);

            //
            //  Load virtual key description.
            //
            for (ctr = 0; (ctr < sizeof(g_aVirtKeyDesc) / sizeof(VIRTKEYDESC)); ctr++)
            {
                CicLoadString(hInstance,
                              g_aVirtKeyDesc[ctr].idVirtKeyName,
                              szItem,
                              sizeof(szItem) / sizeof(TCHAR) );
                g_aVirtKeyDesc[ctr].atVirtKeyName = AddAtom(szItem);
            }

            break;
        }
        case ( WM_DESTROY ) :
        {
            break;
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     c_szHelpFile,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aLocaleKeysSettingsHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     c_szHelpFile,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aLocaleKeysSettingsHelpIds );
            break;
        }
        case ( WM_MEASUREITEM ) :
        {
            Locale_MeasureItem(hwnd, (LPMEASUREITEMSTRUCT)lParam);
            break;
        }
        case ( WM_DRAWITEM ) :
        {
            return (Locale_DrawItem(hwnd, (LPDRAWITEMSTRUCT)lParam));
        }


        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                case ( IDC_KBDL_CAPSLOCK ) :
                case ( IDC_KBDL_SHIFTLOCK ) :
                {
                    break;
                }
                case ( IDC_KBDL_HOTKEY_LIST ):
                {
                    if (HIWORD(wParam) == LBN_DBLCLK)
                    {
                        //
                        //  User double clicked on a hotkey.  Invoke the
                        //  change hotkey dialog.
                        //
                        Locale_CommandChangeHotKey(hwnd);
                    }
                    break;
                }
                case ( IDC_KBDL_CHANGE_HOTKEY ) :
                {
                    Locale_CommandChangeHotKey(hwnd);
                    break;
                }
                case ( IDOK ) :
                {
                    DWORD dwAttributes = 0;
                    HKEY hkeyLayouts;

                    if (IsDlgButtonChecked(hwnd, IDC_KBDL_SHIFTLOCK))
                        dwAttributes |= KLF_SHIFTLOCK;
                    else
                        dwAttributes &= ~KLF_SHIFTLOCK;

                    if (dwAttributes != g_dwAttributes)
                    {
                        DWORD cb;
                        HKEY hkey;

                        if (RegOpenKey(HKEY_CURRENT_USER, c_szKbdLayouts, &hkey) == ERROR_SUCCESS)
                        {
                            cb = sizeof(DWORD);

                            RegSetValueEx(hkey,
                                          c_szAttributes,
                                          0,
                                          REG_DWORD,
                                          (LPBYTE)&dwAttributes,
                                          sizeof(DWORD) );

                            RegCloseKey(hkey);
                        }

                        ActivateKeyboardLayout(GetKeyboardLayout(0), KLF_RESET | dwAttributes);
                    }

                    if (g_dwChanges & CHANGE_SWITCH)
                    {
                        UINT nLangs;
                        HKL *pLangs = NULL;
                        BOOL bDirectSwitch = FALSE;
                        TV_ITEM tvItem;
                        HTREEITEM hItem;
                        HTREEITEM hLangItem;
                        HTREEITEM hGroupItem;
                        LPLANGNODE pLangNode;
                        HWND hwndTV = g_hwndTV;


                        Locale_SetLanguageHotkey();

                        //
                        //  Set Imm hotkeys.
                        //
                        //  Get the list of the currently active keyboard layouts from
                        //  the system.  We will possibly need to sync up all IMEs with new
                        //  hotkeys.
                        //
                        nLangs = GetKeyboardLayoutList(0, NULL);
                        if (nLangs != 0)
                        {
                            pLangs = (HKL *)LocalAlloc(LPTR, sizeof(DWORD_PTR) * nLangs);
                            if (!pLangs)
                                return (FALSE);

                            GetKeyboardLayoutList(nLangs, (HKL *)pLangs);
                        }

                        tvItem.mask = TVIF_HANDLE | TVIF_PARAM;

                        //
                        //  Try to find either a matching hkl or empty spot in the array
                        //  for each of the hkls in the locale list.
                        //
                        for (hLangItem = TreeView_GetChild(hwndTV, g_hTVRoot) ;
                            hLangItem != NULL ;
                            hLangItem = TreeView_GetNextSibling(hwndTV, hLangItem)
                            )
                        {
                            for (hGroupItem = TreeView_GetChild(hwndTV, hLangItem);
                                 hGroupItem != NULL;
                                 hGroupItem = TreeView_GetNextSibling(hwndTV, hGroupItem))
                            {

                                for (hItem = TreeView_GetChild(hwndTV, hGroupItem);
                                     hItem != NULL;
                                     hItem = TreeView_GetNextSibling(hwndTV, hItem))
                                {
                                    LPTVITEMNODE pTVItemNode;

                                    tvItem.hItem = hItem;
                                    if (TreeView_GetItem(hwndTV, &tvItem) && tvItem.lParam)
                                    {
                                        pTVItemNode = (LPTVITEMNODE) tvItem.lParam;
                                        pLangNode = (LPLANGNODE)pTVItemNode->lParam;
                                    }
                                    else
                                        break;

                                    if (pLangNode == NULL &&
                                        (pTVItemNode->uInputType & INPUT_TYPE_KBD) &&
                                        pTVItemNode->hklSub)
                                    {
                                        if (tvItem.hItem = FindTVLangItem(pTVItemNode->dwLangID, NULL))
                                        {
                                            if (TreeView_GetItem(hwndTV, &tvItem) && tvItem.lParam)
                                            {
                                                pTVItemNode = (LPTVITEMNODE) tvItem.lParam;
                                                pLangNode = (LPLANGNODE)pTVItemNode->lParam;
                                            }
                                        }
                                    }
                                    if (pLangNode == NULL)
                                        continue;
                                    //
                                    //  Set Imm hotkeys.
                                    //
                                    Locale_SetImmHotkey(hwnd, pLangNode, nLangs, pLangs, &bDirectSwitch);
                                }
                            }
                        }

                        if (bDirectSwitch)
                            g_dwChanges |= CHANGE_DIRECTSWITCH;

                        if (bHasIme)
                        {
                            Locale_SetImmCHxHotkey(hwnd, nLangs, pLangs);
                        }

                        //
                        //  Free any allocated memory.
                        //
                        if (pLangs != NULL)
                        {
                            LocalFree((HANDLE)pLangs);
                        }

                        g_dwChanges &= ~CHANGE_SWITCH;
                    }

                    EndDialog(hwnd, 1);
                    break;
                }
                case ( IDCANCEL ) :
                {
                    EndDialog(hwnd, 0);
                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_VirtKeyList
//
//  Initializes the virtual key combo box and sets the current selection.
//
////////////////////////////////////////////////////////////////////////////

void Locale_VirtKeyList(
    HWND hwnd,
    UINT uVKey,
    BOOL bDirectSwitch)
{
    int  ctr, iStart, iEnd, iIndex;
    UINT  iSel = 0;
    TCHAR szString[DESC_MAX];
    HWND  hwndKey = GetDlgItem(hwnd, IDC_KBDLH_KEY_COMBO);

    //
    //  Look for hot keys for direct switch.
    //
    for (ctr = sizeof(g_aVirtKeyDesc) / sizeof(VIRTKEYDESC) - 1;
         ctr >= 0;
         ctr--)
    {
        if (g_aVirtKeyDesc[ctr].idVirtKeyName == IDS_VK_NONE1)
        {
            //
            //  Found it.  Remove "(None)" from hwndKey list box.
            //
            ctr++;
            break;
        }
    }

    if (ctr < 0) return;

    iStart = bDirectSwitch ? ctr : 0;
    iEnd = bDirectSwitch ? sizeof(g_aVirtKeyDesc) / sizeof(VIRTKEYDESC) : ctr;

    ComboBox_ResetContent(hwndKey);

    for (ctr = iStart; ctr < iEnd; ctr++)
    {
        GetAtomName( g_aVirtKeyDesc[ctr].atVirtKeyName,
                     szString,
                     sizeof(szString) / sizeof(TCHAR) );

        iIndex = ComboBox_InsertString(hwndKey, -1, szString);
        ComboBox_SetItemData(hwndKey, iIndex, g_aVirtKeyDesc[ctr].uVirtKeyValue);
        if (g_aVirtKeyDesc[ctr].uVirtKeyValue == uVKey)
        {
            iSel = iIndex;
        }
    }
    ComboBox_SetCurSel(hwndKey, iSel);
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_ChangeHotKeyDlgInit
//
//  Initializes the change hotkey dialog box.
//
////////////////////////////////////////////////////////////////////////////

void Locale_ChangeHotKeyDlgInit(
    HWND hwnd,
    LPARAM lParam)
{
    TCHAR szHotKeyName[DESC_MAX];
    LPHOTKEYINFO pHotKeyNode = ((LPINITINFO)lParam)->pHotKeyNode;
    BOOL bCtrl = TRUE;
    BOOL bAlt = TRUE;
    BOOL bGrave = TRUE;

    GetAtomName(pHotKeyNode->atmHotKeyName, szHotKeyName, ARRAYSIZE(szHotKeyName));
    SetDlgItemText(hwnd, IDC_KBDLH_LAYOUT_TEXT, szHotKeyName);

    //
    //  Set the language switch hotkey
    //
    if (pHotKeyNode->uModifiers & MOD_CONTROL)
    {
        CheckDlgButton(hwnd, IDC_KBDLH_CTRL, TRUE);
        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT, FALSE);
        bCtrl = FALSE;
    }

    if (pHotKeyNode->uModifiers & MOD_ALT)
    {
        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT, TRUE);
        CheckDlgButton(hwnd, IDC_KBDLH_CTRL, FALSE);
        bAlt = FALSE;
    }

    if (GetDlgItem(hwnd, IDC_KBDLH_GRAVE) && (pHotKeyNode->uVKey == CHAR_GRAVE))
    {
        CheckDlgButton(hwnd, IDC_KBDLH_GRAVE, TRUE);
        bGrave = FALSE;
    }

    if (bCtrl && bAlt && bGrave)
    {
        CheckDlgButton(hwnd, IDC_KBDLH_LANGHOTKEY, FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_CTRL), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_L_ALT), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_GRAVE), FALSE);
        ComboBox_SetCurSel(GetDlgItem(hwnd, IDC_KBDLH_KEY_COMBO), 0);
        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_KEY_COMBO), FALSE);
    }
    else
    {
        CheckDlgButton(hwnd, IDC_KBDLH_LANGHOTKEY, TRUE);
    }

    //
    //  Set the layout switch hotkey
    //
    CheckDlgButton(hwnd, IDC_KBDLH_LAYOUTHOTKEY, TRUE);
    if (pHotKeyNode->uLayoutHotKey & MOD_CONTROL)
    {
        CheckDlgButton(hwnd, IDC_KBDLH_CTRL2, TRUE);
        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT2, FALSE);
    }
    else if (pHotKeyNode->uLayoutHotKey & MOD_ALT)
    {
        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT2, TRUE);
        CheckDlgButton(hwnd, IDC_KBDLH_CTRL2, FALSE);
    }
    else if (g_bMESystem && pHotKeyNode->uVKey == CHAR_GRAVE)
    {
        CheckDlgButton(hwnd, IDC_KBDLH_GRAVE, TRUE);
    }
    else
    {
        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_CTRL2), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_L_ALT2), FALSE);
        CheckDlgButton(hwnd, IDC_KBDLH_LAYOUTHOTKEY, FALSE);

        if (g_bMESystem)
            EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_GRAVE), FALSE);
    }

    //
    //  There is no ctfmon.exe process during the setup, so disable layout
    //  hotkey settings.
    //
    if (g_bSetupCase)
    {
        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_LAYOUTHOTKEY), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_CTRL2), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_L_ALT2), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_SHIFT2), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_PLUS2), FALSE);

        if (g_bMESystem)
            EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_GRAVE), FALSE);

#if 0
        ShowWindow(GetDlgItem(hwnd, IDC_KBDLH_LAYOUTHOTKEY), SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, IDC_KBDLH_CTRL2), SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, IDC_KBDLH_L_ALT2), SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, IDC_KBDLH_SHIFT2), SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, IDC_KBDLH_PLUS2), SW_HIDE);

        if (g_bMESystem)
            ShowWindow(GetDlgItem(hwnd, IDC_KBDLH_GRAVE), SW_HIDE);
#endif

    }

    if (IS_DIRECT_SWITCH_HOTKEY(pHotKeyNode->dwHotKeyID))
    {
        Locale_VirtKeyList(hwnd, pHotKeyNode->uVKey, TRUE);
    }
    else
    {
        Locale_VirtKeyList(hwnd, pHotKeyNode->uVKey, FALSE);
    }

    SetProp(hwnd, szPropHwnd, (HANDLE)((LPINITINFO)lParam)->hwndMain);
    SetProp(hwnd, szPropIdx, (HANDLE)pHotKeyNode);
}


////////////////////////////////////////////////////////////////////////////
//
//  Locale_ChangeHotKeyCommandOK
//
//  Records hotkey changes made in change hotkey dialog box.
//  Warns if duplicate hotkeys are selected.
//
////////////////////////////////////////////////////////////////////////////

BOOL Locale_ChangeHotKeyCommandOK(
    HWND hwnd)
{
    LPHOTKEYINFO pHotKeyNode, pHotKeyTemp;
    UINT iIndex;
    HWND hwndHotkey, hwndMain, hwndKey;
    UINT uOldVKey, uOldModifiers, uOldLayoutHotKey;
    int ctr;
    int iNumMods = 0;
    int DialogType;

    pHotKeyNode = GetProp(hwnd, szPropIdx);
    hwndMain = GetProp(hwnd, szPropHwnd);
    hwndHotkey = GetDlgItem(hwndMain, IDC_KBDL_HOTKEY_LIST);
    hwndKey = GetDlgItem(hwnd, IDC_KBDLH_KEY_COMBO);

    uOldVKey = pHotKeyNode->uVKey;
    uOldModifiers = pHotKeyNode->uModifiers;
    uOldLayoutHotKey = pHotKeyNode->uLayoutHotKey;

    if (pHotKeyNode->dwHotKeyID == HOTKEY_SWITCH_LANG)
    {
        DialogType = DIALOG_SWITCH_INPUT_LOCALES;
    }
    else if (GetDlgItem(hwnd, IDC_KBDLH_KEY_COMBO) &&
             (GetWindowLong( GetDlgItem(hwnd, IDC_KBDLH_KEY_COMBO),
                             GWL_STYLE) & BS_RADIOBUTTON))
    {
        DialogType = DIALOG_SWITCH_KEYBOARD_LAYOUT;
    }
    else
    {
        DialogType = DIALOG_SWITCH_IME;
    }

    pHotKeyNode->uModifiers &= ~(MOD_CONTROL | MOD_ALT | MOD_SHIFT);
    pHotKeyNode->uVKey = 0;
    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LANGHOTKEY))
    {
        if (IsDlgButtonChecked(hwnd, IDC_KBDLH_CTRL))
        {
            pHotKeyNode->uModifiers |= MOD_CONTROL;
            iNumMods++;
        }

        if (IsDlgButtonChecked(hwnd, IDC_KBDLH_L_ALT))
        {
            pHotKeyNode->uModifiers |= MOD_ALT;
            iNumMods++;
        }

        if (IsDlgButtonChecked(hwnd, IDC_KBDLH_GRAVE))
        {
            //
            //  Assign Grave key.
            //
            pHotKeyNode->uVKey = CHAR_GRAVE;
        }
        else
        {
            //
            //  Shift key is mandatory.
            //
            pHotKeyNode->uModifiers |= MOD_SHIFT;
            iNumMods++;

            if ((iIndex = ComboBox_GetCurSel(hwndKey)) == CB_ERR)
            {
                pHotKeyNode->uVKey = 0;
            }
            else
            {
                pHotKeyNode->uVKey = (UINT)ComboBox_GetItemData(hwndKey, iIndex);
            }
        }
    }

    //
    //  Set the layout switch hotkey
    //
    pHotKeyNode->uLayoutHotKey = 0;
    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LAYOUTHOTKEY))
    {
        if (IsDlgButtonChecked(hwnd, IDC_KBDLH_CTRL2))
        {
            pHotKeyNode->uLayoutHotKey |= MOD_CONTROL;
        }
        else if (IsDlgButtonChecked(hwnd, IDC_KBDLH_L_ALT2))
        {
            pHotKeyNode->uLayoutHotKey |= MOD_ALT;
        }
        else if (IsDlgButtonChecked(hwnd, IDC_KBDLH_GRAVE))
        {
            pHotKeyNode->uVKey = CHAR_GRAVE;
        }
    }

    //
    //  Key sequence with only one modifier and without a key,
    //  or without any modifier is invalid.
    //
    if (((pHotKeyNode->uVKey != 0) && (iNumMods == 0) &&
         (DialogType != DIALOG_SWITCH_INPUT_LOCALES)) ||
        ((pHotKeyNode->uVKey == 0) && (iNumMods != 0) &&
         (DialogType != DIALOG_SWITCH_INPUT_LOCALES)))
    {
        TCHAR szName[DESC_MAX];

        Locale_TranslateHotKey( szName,
                                ARRAYSIZE(szName),
                                pHotKeyNode->uVKey,
                                pHotKeyNode->uModifiers );

        Locale_ErrorMsg(hwnd, IDS_KBD_INVALID_HOTKEY, szName);

        pHotKeyNode->uModifiers = uOldModifiers;
        pHotKeyNode->uVKey = uOldVKey;
        return (FALSE);
    }

    //
    //  Do not allow duplicate hot keys.
    //
    for (ctr = 0; ctr < ListBox_GetCount(hwndHotkey); ctr++)
    {
        pHotKeyTemp = (LPHOTKEYINFO)ListBox_GetItemData(hwndHotkey, ctr);
        if ((pHotKeyTemp != pHotKeyNode) &&
            ((pHotKeyNode->uModifiers & (MOD_CONTROL | MOD_ALT | MOD_SHIFT)) ==
             (pHotKeyTemp->uModifiers & (MOD_CONTROL | MOD_ALT | MOD_SHIFT))) &&
            (pHotKeyNode->uVKey == pHotKeyTemp->uVKey) &&
            (iNumMods || pHotKeyNode->uVKey != 0))
        {
            TCHAR szName[DESC_MAX];

            Locale_TranslateHotKey( szName,
                                    ARRAYSIZE(szName),
                                    pHotKeyNode->uVKey,
                                    pHotKeyNode->uModifiers );
            Locale_ErrorMsg(hwnd, IDS_KBD_CONFLICT_HOTKEY, szName);

            pHotKeyNode->uModifiers = uOldModifiers;
            pHotKeyNode->uVKey = uOldVKey;
            return (FALSE);
        }
    }

    InvalidateRect(hwndHotkey, NULL, FALSE);

    if ((uOldVKey != pHotKeyNode->uVKey) ||
        (uOldModifiers != pHotKeyNode->uModifiers) ||
        (uOldLayoutHotKey != pHotKeyNode->uLayoutHotKey))
    {
        g_dwChanges |= CHANGE_SWITCH;
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  KbdLocaleSimpleHotkey
//
//  Dlgproc for hotkey on NT4 and Win9x platform
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK KbdLocaleSimpleHotkey(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            TCHAR szHotKey[10];
            TCHAR szLayoutHotKey[10];

            GetLanguageHotkeyFromRegistry(szHotKey, ARRAYSIZE(szHotKey),
                                          szLayoutHotKey, ARRAYSIZE(szLayoutHotKey));

            //
            //  Set the modifiers.
            //
            if (szHotKey[1] == 0)
            {
                CheckDlgButton(hwnd, IDC_KBDLH_LANGHOTKEY, TRUE);

                switch (szHotKey[0])
                {
                    case ( TEXT('1') ) :
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT, TRUE);
                        break;
                    }
                    case ( TEXT('2') ) :
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_CTRL, TRUE);
                        break;
                    }
                    default:
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_LANGHOTKEY, FALSE);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_CTRL), FALSE);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_L_ALT), FALSE);
                    }
                }
            }
            else
            {
                EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_CTRL), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_L_ALT), FALSE);
            }

            if (szLayoutHotKey[1] == 0)
            {
                CheckDlgButton(hwnd, IDC_KBDLH_LAYOUTHOTKEY, TRUE);

                switch (szLayoutHotKey[0])
                {
                    case ( TEXT('1') ) :
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT2, TRUE);
                        break;
                    }
                    case ( TEXT('2') ) :
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_CTRL2, TRUE);
                        break;
                    }
                    default:
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_LAYOUTHOTKEY, FALSE);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_CTRL2), FALSE);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_L_ALT2), FALSE);
                    }
                }
            }
            else
            {
                 EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_CTRL2), FALSE);
                 EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_L_ALT2), FALSE);
            }
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     c_szHelpFile,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aLocaleHotkeyHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     c_szHelpFile,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aLocaleHotkeyHelpIds );
            break;
        }
        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                case ( IDOK ) :
                {
                    DWORD dwLangHotKey;
                    DWORD dwLayoutHotKey;
                    HKEY hkeyToggle;
                    TCHAR szTemp[10];
                    TCHAR szTemp2[10];

                    //
                    //  Language switch hotkey
                    //
                    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LANGHOTKEY))
                    {
                        if (IsDlgButtonChecked(hwnd, IDC_KBDLH_L_ALT))
                        {
                            dwLangHotKey = 1;
                        }
                        else
                        {
                            dwLangHotKey = 2;
                        }
                    }
                    else
                    {
                        dwLangHotKey = 3;
                    }

                    //
                    //  Layout swtich hotkey
                    //
                    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LAYOUTHOTKEY))
                    {
                        if (IsDlgButtonChecked(hwnd, IDC_KBDLH_L_ALT2))
                        {
                            dwLayoutHotKey = 1;
                        }
                        else
                        {
                            dwLayoutHotKey = 2;
                        }
                    }
                    else
                    {
                        dwLayoutHotKey = 3;
                    }

                    //
                    //  Get the toggle hotkey as a string so that it can be written
                    //  into the registry (as data).
                    //
                    StringCchPrintf(szTemp, ARRAYSIZE(szTemp), TEXT("%d"), dwLangHotKey);
                    StringCchPrintf(szTemp2, ARRAYSIZE(szTemp2), TEXT("%d"), dwLayoutHotKey);

                    //
                    //  Create the HKCU\Keyboard Layout\Toggle key.
                    //
                    if (RegCreateKey(HKEY_CURRENT_USER,
                                     c_szKbdToggleKey,
                                     &hkeyToggle ) == ERROR_SUCCESS)
                    {

                        RegSetValueEx(hkeyToggle,
                                      g_OSNT4? c_szToggleHotKey : NULL,
                                      0,
                                      REG_SZ,
                                      (LPBYTE)szTemp,
                                      (DWORD)(lstrlen(szTemp) + 1) * sizeof(TCHAR) );

                        RegSetValueEx(hkeyToggle,
                                      c_szToggleLang,
                                      0,
                                      REG_SZ,
                                      (LPBYTE)szTemp,
                                      (DWORD)(lstrlen(szTemp) + 1) * sizeof(TCHAR) );

                        RegSetValueEx(hkeyToggle,
                                      c_szToggleLayout,
                                      0,
                                      REG_SZ,
                                      (LPBYTE)szTemp2,
                                      (DWORD)(lstrlen(szTemp2) + 1) * sizeof(TCHAR) );

                        RegCloseKey(hkeyToggle);
                    }

                    EndDialog(hwnd, 1);

                    break;
                }
                case ( IDCANCEL ) :
                {
                    EndDialog(hwnd, 0);
                    break;
                }
                case ( IDC_KBDLH_LANGHOTKEY ) :
                {
                    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LANGHOTKEY))
                    {
                        if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LAYOUTHOTKEY))
                        {
                            if (IsDlgButtonChecked(hwnd, IDC_KBDLH_L_ALT2))
                            {
                                CheckDlgButton(hwnd, IDC_KBDLH_CTRL, BST_CHECKED);
                                CheckDlgButton(hwnd, IDC_KBDLH_L_ALT, BST_UNCHECKED);
                            }
                            else
                            {
                                CheckDlgButton(hwnd, IDC_KBDLH_CTRL, BST_UNCHECKED);
                                CheckDlgButton(hwnd, IDC_KBDLH_L_ALT, BST_CHECKED);
                            }
                        }
                        else
                        {
                            CheckDlgButton(hwnd, IDC_KBDLH_L_ALT, BST_CHECKED);
                            CheckDlgButton(hwnd, IDC_KBDLH_CTRL, BST_UNCHECKED);
                        }

                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_CTRL), TRUE);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_L_ALT), TRUE);
                    }
                    else
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_CTRL, BST_UNCHECKED);
                        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT, BST_UNCHECKED);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_CTRL), FALSE);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_L_ALT), FALSE);
                    }
                    break;
                }
                case ( IDC_KBDLH_LAYOUTHOTKEY ) :
                {
                    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LAYOUTHOTKEY))
                    {
                        if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LANGHOTKEY))
                        {
                            if (IsDlgButtonChecked(hwnd, IDC_KBDLH_L_ALT))
                            {
                                CheckDlgButton(hwnd, IDC_KBDLH_CTRL2, BST_CHECKED);
                                CheckDlgButton(hwnd, IDC_KBDLH_L_ALT2, BST_UNCHECKED);
                            }
                            else
                            {
                                CheckDlgButton(hwnd, IDC_KBDLH_CTRL2, BST_UNCHECKED);
                                CheckDlgButton(hwnd, IDC_KBDLH_L_ALT2, BST_CHECKED);
                            }
                        }
                        else
                        {
                            CheckDlgButton(hwnd, IDC_KBDLH_CTRL2, BST_CHECKED);
                            CheckDlgButton(hwnd, IDC_KBDLH_L_ALT2, BST_UNCHECKED);
                        }

                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_CTRL2), TRUE);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_L_ALT2), TRUE);
                    }
                    else
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_CTRL2, BST_UNCHECKED);
                        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT2, BST_UNCHECKED);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_CTRL2), FALSE);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_L_ALT2), FALSE);
                    }
                    break;
                }
                case ( IDC_KBDLH_CTRL ) :
                {
                    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LAYOUTHOTKEY))
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_CTRL2, BST_UNCHECKED);
                        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT2, BST_CHECKED);
                    }
                    break;
                }
                case ( IDC_KBDLH_L_ALT ) :
                {
                    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LAYOUTHOTKEY))
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_CTRL2, BST_CHECKED);
                        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT2, BST_UNCHECKED);
                    }
                    break;
                }
                case ( IDC_KBDLH_CTRL2 ) :
                {
                    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LANGHOTKEY))
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_CTRL, BST_UNCHECKED);
                        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT, BST_CHECKED);
                    }
                    break;
                }
                case ( IDC_KBDLH_L_ALT2 ) :
                {
                    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LANGHOTKEY))
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_CTRL, BST_CHECKED);
                        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT, BST_UNCHECKED);
                    }
                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  KbdLocaleChangeInputLocaleHotkey
//
//  Dlgproc for changing input locale hotkey dialog box.
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK KbdLocaleChangeInputLocaleHotkey(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            Locale_ChangeHotKeyDlgInit(hwnd, lParam);
            break;
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     c_szHelpFile,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aLocaleHotkeyHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     c_szHelpFile,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aLocaleHotkeyHelpIds );
            break;
        }
        case ( WM_DESTROY ) :
        {
            RemoveProp(hwnd, szPropHwnd);
            RemoveProp(hwnd, szPropIdx);
            break;
        }
        case ( WM_COMMAND ) :
        {
            LPHOTKEYINFO pHotKeyNode = GetProp(hwnd, szPropIdx);

            switch (LOWORD(wParam))
            {
                case ( IDOK ) :
                {
                    if (Locale_ChangeHotKeyCommandOK(hwnd))
                    {
                        EndDialog(hwnd, 1);
                    }
                    break;
                }
                case ( IDCANCEL ) :
                {
                    EndDialog(hwnd, 0);
                    break;
                }
                case ( IDC_KBDLH_LANGHOTKEY ) :
                {
                    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LANGHOTKEY))
                    {
                        if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LAYOUTHOTKEY))
                        {
                            if (IsDlgButtonChecked(hwnd, IDC_KBDLH_L_ALT2))
                            {
                                CheckDlgButton(hwnd, IDC_KBDLH_CTRL, BST_CHECKED);
                                CheckDlgButton(hwnd, IDC_KBDLH_L_ALT, BST_UNCHECKED);
                            }
                            else
                            {
                                CheckDlgButton(hwnd, IDC_KBDLH_CTRL, BST_UNCHECKED);
                                CheckDlgButton(hwnd, IDC_KBDLH_L_ALT, BST_CHECKED);
                            }
                        }
                        else
                        {
                            CheckDlgButton(hwnd, IDC_KBDLH_L_ALT, BST_CHECKED);
                            CheckDlgButton(hwnd, IDC_KBDLH_CTRL, BST_UNCHECKED);
                        }

                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_CTRL), TRUE);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_L_ALT), TRUE);
                    }
                    else
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_CTRL, BST_UNCHECKED);
                        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT, BST_UNCHECKED);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_CTRL), FALSE);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_L_ALT), FALSE);
                    }
                    break;
                }
                case ( IDC_KBDLH_LAYOUTHOTKEY ) :
                {
                    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LAYOUTHOTKEY))
                    {
                        if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LANGHOTKEY))
                        {
                            if (IsDlgButtonChecked(hwnd, IDC_KBDLH_CTRL))
                            {
                                CheckDlgButton(hwnd, IDC_KBDLH_CTRL2, BST_UNCHECKED);
                                CheckDlgButton(hwnd, IDC_KBDLH_L_ALT2, BST_CHECKED);
                            }
                            else
                            {
                                CheckDlgButton(hwnd, IDC_KBDLH_CTRL2, BST_CHECKED);
                                CheckDlgButton(hwnd, IDC_KBDLH_L_ALT2, BST_UNCHECKED);
                            }
                        }
                        else
                        {
                            CheckDlgButton(hwnd, IDC_KBDLH_CTRL2, BST_CHECKED);
                            CheckDlgButton(hwnd, IDC_KBDLH_L_ALT2, BST_UNCHECKED);
                        }

                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_CTRL2), TRUE);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_L_ALT2), TRUE);
                    }
                    else
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_CTRL2, BST_UNCHECKED);
                        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT2, BST_UNCHECKED);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_CTRL2), FALSE);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_L_ALT2), FALSE);
                    }
                    break;
                }
                case ( IDC_KBDLH_CTRL ) :
                {
                    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LAYOUTHOTKEY))
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_CTRL2, BST_UNCHECKED);
                        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT2, BST_CHECKED);
                    }
                    break;
                }
                case ( IDC_KBDLH_L_ALT ) :
                {
                    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LAYOUTHOTKEY))
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_CTRL2, BST_CHECKED);
                        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT2, BST_UNCHECKED);
                    }
                    break;
                }
                case ( IDC_KBDLH_CTRL2 ) :
                {
                    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LANGHOTKEY))
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_CTRL, BST_UNCHECKED);
                        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT, BST_CHECKED);
                    }
                    break;
                }
                case ( IDC_KBDLH_L_ALT2 ) :
                {
                    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LANGHOTKEY))
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_CTRL, BST_CHECKED);
                        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT, BST_UNCHECKED);
                    }
                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  KbdLocaleChangeThaiInputLocaleHotkey
//
//  Dlgproc for changing Thai input locale hotkey dialog box.
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK KbdLocaleChangeThaiInputLocaleHotkey(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            Locale_ChangeHotKeyDlgInit(hwnd, lParam);
            break;
        }
        case ( WM_DESTROY ) :
        {
            RemoveProp(hwnd, szPropHwnd);
            RemoveProp(hwnd, szPropIdx);
            break;
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     c_szHelpFile,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aLocaleHotkeyHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :
        {
            WinHelp( (HWND)wParam,
                     c_szHelpFile,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aLocaleHotkeyHelpIds );
            break;
        }
        case ( WM_DRAWITEM ) :
        {
            if (wParam == IDC_KBDLH_VLINE)
            {
                LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT)lParam;
                RECT rect;
                HPEN hPenHilite, hPenShadow, hPenOriginal;

                GetClientRect(lpdis->hwndItem, &rect);
                hPenHilite = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNHIGHLIGHT));
                hPenShadow = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNSHADOW));

                hPenOriginal = SelectObject(lpdis->hDC, hPenShadow);
                MoveToEx(lpdis->hDC, rect.right / 2, 0, NULL);
                LineTo(lpdis->hDC, rect.right / 2, rect.bottom);                    
                                   
                SelectObject(lpdis->hDC, hPenHilite);                
                MoveToEx(lpdis->hDC, rect.right / 2 + 1, 0, NULL);
                LineTo(lpdis->hDC, rect.right / 2 + 1, rect.bottom);
                
                SelectObject(lpdis->hDC, hPenOriginal);

                if (hPenShadow)
                {
                    DeleteObject(hPenShadow);
                }
                if (hPenHilite)
                {
                    DeleteObject(hPenHilite);
                }
                return (TRUE);
            }
            return (FALSE);
            break;
        }
        case ( WM_COMMAND ) :
        {
            LPHOTKEYINFO pHotKeyNode = GetProp(hwnd, szPropIdx);

            switch (LOWORD(wParam))
            {
                case ( IDOK ) :
                {
                    if (Locale_ChangeHotKeyCommandOK(hwnd))
                    {
                        EndDialog(hwnd, 1);
                    }
                    break;
                }
                case ( IDCANCEL ) :
                {
                    EndDialog(hwnd, 0);
                    break;
                }
                case ( IDC_KBDLH_LANGHOTKEY ) :
                {
                    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LANGHOTKEY))
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_GRAVE, BST_CHECKED);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_CTRL), TRUE);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_L_ALT), TRUE);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_GRAVE), TRUE);
                    }
                    else
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_CTRL, BST_UNCHECKED);
                        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT, BST_UNCHECKED);
                        CheckDlgButton(hwnd, IDC_KBDLH_GRAVE, BST_UNCHECKED);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_CTRL), FALSE);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_L_ALT), FALSE);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_GRAVE), FALSE);
                    }
                    break;
                }
                case ( IDC_KBDLH_LAYOUTHOTKEY ) :
                {
                    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LAYOUTHOTKEY))
                    {
                        if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LANGHOTKEY))
                        {
                            if (IsDlgButtonChecked(hwnd, IDC_KBDLH_CTRL))
                            {
                                CheckDlgButton(hwnd, IDC_KBDLH_CTRL2, BST_UNCHECKED);
                                CheckDlgButton(hwnd, IDC_KBDLH_L_ALT2, BST_CHECKED);
                            }
                            else
                            {
                                CheckDlgButton(hwnd, IDC_KBDLH_CTRL2, BST_CHECKED);
                                CheckDlgButton(hwnd, IDC_KBDLH_L_ALT2, BST_UNCHECKED);
                            }
                        }
                        else
                        {
                            CheckDlgButton(hwnd, IDC_KBDLH_CTRL2, BST_CHECKED);
                            CheckDlgButton(hwnd, IDC_KBDLH_L_ALT2, BST_UNCHECKED);
                        }

                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_CTRL2), TRUE);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_L_ALT2), TRUE);
                    }
                    else
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_CTRL2, BST_UNCHECKED);
                        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT2, BST_UNCHECKED);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_CTRL2), FALSE);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_L_ALT2), FALSE);
                    }
                    break;
                }
                case ( IDC_KBDLH_CTRL ) :
                {
                    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LAYOUTHOTKEY))
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_CTRL2, BST_UNCHECKED);
                        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT2, BST_CHECKED);
                    }
                    break;
                }
                case ( IDC_KBDLH_L_ALT ) :
                {
                    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LAYOUTHOTKEY))
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_CTRL2, BST_CHECKED);
                        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT2, BST_UNCHECKED);
                    }
                    break;
                }
                case ( IDC_KBDLH_CTRL2 ) :
                {
                    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LANGHOTKEY) &&
                        !IsDlgButtonChecked(hwnd, IDC_KBDLH_GRAVE))
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_CTRL, BST_UNCHECKED);
                        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT, BST_CHECKED);
                    }
                    break;
                }
                case ( IDC_KBDLH_L_ALT2 ) :
                {
                    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LANGHOTKEY) &&
                        !IsDlgButtonChecked(hwnd, IDC_KBDLH_GRAVE))
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_CTRL, BST_CHECKED);
                        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT, BST_UNCHECKED);
                    }
                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  KbdLocaleChangeMEInputLocaleHotkey
//
//  Dlgproc for changing Thai input locale hotkey dialog box.
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK KbdLocaleChangeMEInputLocaleHotkey(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            Locale_ChangeHotKeyDlgInit(hwnd, lParam);
            break;
        }
        case ( WM_DESTROY ) :
        {
            RemoveProp(hwnd, szPropHwnd);
            RemoveProp(hwnd, szPropIdx);
            break;
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     c_szHelpFile,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aLocaleHotkeyHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :
        {
            WinHelp( (HWND)wParam,
                     c_szHelpFile,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aLocaleHotkeyHelpIds );
            break;
        }
        case ( WM_DRAWITEM ) :
        {
            if (wParam == IDC_KBDLH_VLINE)
            {
                LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT)lParam;
                RECT rect;
                HPEN hPenHilite, hPenShadow, hPenOriginal;

                GetClientRect(lpdis->hwndItem, &rect);
                hPenHilite = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNHIGHLIGHT));
                hPenShadow = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNSHADOW));

                hPenOriginal = SelectObject(lpdis->hDC, hPenShadow);
                MoveToEx(lpdis->hDC, rect.right / 2, 0, NULL);
                LineTo(lpdis->hDC, rect.right / 2, rect.bottom);                    
                                   
                SelectObject(lpdis->hDC, hPenHilite);                
                MoveToEx(lpdis->hDC, rect.right / 2 + 1, 0, NULL);
                LineTo(lpdis->hDC, rect.right / 2 + 1, rect.bottom);
                
                SelectObject(lpdis->hDC, hPenOriginal);

                if (hPenShadow)
                {
                    DeleteObject(hPenShadow);
                }
                if (hPenHilite)
                {
                    DeleteObject(hPenHilite);
                }
                return (TRUE);
            }
            return (FALSE);
            break;
        }
        case ( WM_COMMAND ) :
        {
            LPHOTKEYINFO pHotKeyNode = GetProp(hwnd, szPropIdx);

            switch (LOWORD(wParam))
            {
                case ( IDOK ) :
                {
                    if (Locale_ChangeHotKeyCommandOK(hwnd))
                    {
                        EndDialog(hwnd, 1);
                    }
                    break;
                }
                case ( IDCANCEL ) :
                {
                    EndDialog(hwnd, 0);
                    break;
                }
                case ( IDC_KBDLH_LANGHOTKEY ) :
                {
                    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LANGHOTKEY))
                    {
                        if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LAYOUTHOTKEY))
                        {
                            if (IsDlgButtonChecked(hwnd, IDC_KBDLH_L_ALT2))
                            {
                                CheckDlgButton(hwnd, IDC_KBDLH_CTRL, BST_CHECKED);
                                CheckDlgButton(hwnd, IDC_KBDLH_L_ALT, BST_UNCHECKED);
                            }
                            else
                            {
                                CheckDlgButton(hwnd, IDC_KBDLH_CTRL, BST_UNCHECKED);
                                CheckDlgButton(hwnd, IDC_KBDLH_L_ALT, BST_CHECKED);
                            }
                        }
                        else
                        {
                            CheckDlgButton(hwnd, IDC_KBDLH_L_ALT, BST_CHECKED);
                            CheckDlgButton(hwnd, IDC_KBDLH_CTRL, BST_UNCHECKED);
                        }

                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_CTRL), TRUE);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_L_ALT), TRUE);
                    }
                    else
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_CTRL, BST_UNCHECKED);
                        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT, BST_UNCHECKED);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_CTRL), FALSE);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_L_ALT), FALSE);
                    }
                    break;
                }
                case ( IDC_KBDLH_LAYOUTHOTKEY ) :
                {
                    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LAYOUTHOTKEY))
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_GRAVE, BST_CHECKED);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_CTRL2), TRUE);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_L_ALT2), TRUE);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_GRAVE), TRUE);
                    }
                    else
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_CTRL2, BST_UNCHECKED);
                        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT2, BST_UNCHECKED);
                        CheckDlgButton(hwnd, IDC_KBDLH_GRAVE, BST_UNCHECKED);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_CTRL2), FALSE);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_L_ALT2), FALSE);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_GRAVE), FALSE);
                    }
                    break;
                }
                case ( IDC_KBDLH_CTRL ) :
                {
                    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LAYOUTHOTKEY) &&
                        !IsDlgButtonChecked(hwnd, IDC_KBDLH_GRAVE))
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_CTRL2, BST_UNCHECKED);
                        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT2, BST_CHECKED);
                    }
                    break;
                }
                case ( IDC_KBDLH_L_ALT ) :
                {
                    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LAYOUTHOTKEY) &&
                        !IsDlgButtonChecked(hwnd, IDC_KBDLH_GRAVE))
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_CTRL2, BST_CHECKED);
                        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT2, BST_UNCHECKED);
                    }
                    break;
                }
                case ( IDC_KBDLH_CTRL2 ) :
                {
                    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LANGHOTKEY))
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_CTRL, BST_UNCHECKED);
                        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT, BST_CHECKED);
                    }
                    break;
                }
                case ( IDC_KBDLH_L_ALT2 ) :
                {
                    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LANGHOTKEY))
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_CTRL, BST_CHECKED);
                        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT, BST_UNCHECKED);
                    }
                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  KbdLocaleChangeKeyboardLayoutHotkey
//
//  Dlgproc for changing direct switch keyboard layout hotkey dialog box.
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK KbdLocaleChangeKeyboardLayoutHotkey(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            Locale_ChangeHotKeyDlgInit(hwnd, lParam);
            break;
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     c_szHelpFile,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aLayoutHotkeyHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     c_szHelpFile,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aLayoutHotkeyHelpIds );
            break;
        }
        case ( WM_DESTROY ) :
        {
            RemoveProp(hwnd, szPropHwnd);
            RemoveProp(hwnd, szPropIdx);
            break;
        }
        case ( WM_COMMAND ) :
        {
            HWND hwndKey = GetDlgItem(hwnd, IDC_KBDLH_KEY_COMBO);
            LPHOTKEYINFO pHotKeyNode = GetProp(hwnd, szPropIdx);

            switch (LOWORD(wParam))
            {
                case ( IDOK ) :
                {
                    if (Locale_ChangeHotKeyCommandOK(hwnd))
                    {
                        EndDialog(hwnd, 1);
                    }
                    break;
                }
                case ( IDCANCEL ) :
                {
                    EndDialog(hwnd, 0);
                    break;
                }
                case ( IDC_KBDLH_LANGHOTKEY ) :
                {
                    if (IsDlgButtonChecked(hwnd, IDC_KBDLH_LANGHOTKEY))
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_CTRL, BST_UNCHECKED);
                        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT, BST_CHECKED);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_CTRL), TRUE);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_L_ALT), TRUE);
                        ComboBox_SetCurSel(hwndKey, 0);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_KEY_COMBO), TRUE);
                    }
                    else
                    {
                        CheckDlgButton(hwnd, IDC_KBDLH_CTRL, BST_UNCHECKED);
                        CheckDlgButton(hwnd, IDC_KBDLH_L_ALT, BST_UNCHECKED);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_CTRL), FALSE);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_L_ALT), FALSE);
                        ComboBox_SetCurSel(hwndKey, 0);
                        EnableWindow(GetDlgItem(hwnd, IDC_KBDLH_KEY_COMBO), FALSE);
                    }
                    break;
                }
                case ( IDC_KBDLH_CTRL ) :
                {
                    break;
                }
                case ( IDC_KBDLH_L_ALT ) :
                {
                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
/////////////////////////////////  END  ////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inputdll\inputdlg.h ===
//
//  Include Files.
//

#ifndef INPUTDLG_H
#define INPUTDLG_H


#ifndef ARRAYSIZE
#define ARRAYSIZE(a)        (sizeof(a)/sizeof((a)[0]))
#endif


//
//  Constant Declarations.
//

#define US_LOCALE            MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US)

#define IS_DIRECT_SWITCH_HOTKEY(p)                                   \
                             (((p) >= IME_HOTKEY_DSWITCH_FIRST) &&   \
                              ((p) <= IME_HOTKEY_DSWITCH_LAST))


#define DESC_MAX             MAX_PATH    // max size of a description
#define ALLOCBLOCK           3           // # items added to block for alloc/realloc
#define HKL_LEN              9           // max # chars in hkl id + null

#define LIST_MARGIN          2           // for making the list box look good

#define MB_OK_OOPS           (MB_OK    | MB_ICONEXCLAMATION)    // msg box flags


//
//  wStatus bit pile.
//
#define LANG_ACTIVE          0x0001      // language is active
#define LANG_ORIGACTIVE      0x0002      // language was active to start with
#define LANG_CHANGED         0x0004      // user changed status of language
#define ICON_LOADED          0x0010      // icon read in from file
#define LANG_DEFAULT         0x0020      // current language
#define LANG_DEF_CHANGE      0x0040      // language default has changed
#define LANG_IME             0x0080      // IME
#define LANG_HOTKEY          0x0100      // a hotkey has been defined
#define LANG_UNLOAD          0x0200      // unload language
#define LANG_UPDATE          0x8000      // language needs to be updated

#define HOTKEY_SWITCH_LANG   0x0000      // id to switch between locales

#define MAX(i, j)            (((i) > (j)) ? (i) : (j))

#define LANG_OAC             (LANG_ORIGACTIVE | LANG_ACTIVE | LANG_CHANGED)

//
//  Bits for g_dwChanges.
//
#define CHANGE_SWITCH        0x0001
#define CHANGE_DEFAULT       0x0002
#define CHANGE_CAPSLOCK      0x0004
#define CHANGE_NEWKBDLAYOUT  0x0008
#define CHANGE_TIPCHANGE     0x0010
#define CHANGE_LANGSWITCH    0x0020
#define CHANGE_DIRECTSWITCH  0x0040


//
//  For the indicator on the tray.
//
#define IDM_NEWSHELL         249
#define IDM_EXIT             259


#define MOD_VIRTKEY          0x0080

//
// These are according to the US English kbd layout
//
#define VK_OEM_SEMICLN       0xba        //  ;    :
#define VK_OEM_EQUAL         0xbb        //  =    +
#define VK_OEM_SLASH         0xbf        //  /    ?
#define VK_OEM_LBRACKET      0xdb        //  [    {
#define VK_OEM_BSLASH        0xdc        //  \    |
#define VK_OEM_RBRACKET      0xdd        //  ]    }
#define VK_OEM_QUOTE         0xde        //  '    "


//
//  For the hot key switching.
//
#define DIALOG_SWITCH_INPUT_LOCALES     0
#define DIALOG_SWITCH_KEYBOARD_LAYOUT   1
#define DIALOG_SWITCH_IME               2

//
//  Show Language bar
//
#define REG_LANGBAR_SHOWNORMAL      (DWORD)0
#define REG_LANGBAR_DOCK            (DWORD)1
#define REG_LANGBAR_MINIMIZED       (DWORD)2
#define REG_LANGBAR_HIDDEN          (DWORD)3
#define REG_LANGBAR_DESKBAND        (DWORD)4


//
//  Typedef Declarations.
//

typedef struct
{
    DWORD dwLangID;                 // language id
    BOOL bDefLang;                  // default language
    BOOL bNoAddCat;                 // don't add category
    UINT uInputType;                // default input type
    LPARAM lParam;                  // item data
    int iIdxTips;                   // index of Tips
    CLSID clsid;                    // tip clsid
    GUID guidProfile;               // tip profile guid
    HKL hklSub;                     // tip substitute hkl
    ATOM atmDefTipName;             // default input name
    ATOM atmTVItemName;             // tree view item name
} TVITEMNODE, *LPTVITEMNODE;


typedef struct langnode_s
{
    WORD wStatus;                   // status flags
    UINT iLayout;                   // offset into layout array
    HKL hkl;                        // hkl
    HKL hklUnload;                  // hkl of currently loaded layout
    UINT iLang;                     // offset into lang array
    HANDLE hLangNode;               // handle to free for this structure
    int nIconIME;                   // IME icon
    struct langnode_s *pNext;       // ptr to next langnode
    UINT uModifiers;                // hide Hotkey stuff here
    UINT uVKey;                     //   so we can rebuild the hotkey record
} LANGNODE, *LPLANGNODE;


typedef struct
{
    DWORD dwID;                     // language id
    ATOM atmLanguageName;           // language name - localized
    TCHAR szSymbol[3];              // 2 letter indicator symbol (+ null)
    UINT iUseCount;                 // usage count for this language
    UINT iNumCount;                 // number of links attached
    DWORD dwDefaultLayout;          // default layout id
    LPLANGNODE pNext;               // ptr to lang node structure
} INPUTLANG, *LPINPUTLANG;


typedef struct
{
    DWORD dwID;                     // numeric id
    BOOL bInstalled;                // if layout is installed
    UINT iSpecialID;                // special id (0xf001 for dvorak etc)
    ATOM atmLayoutFile;             // layout file name
    ATOM atmLayoutText;             // layout text name
    ATOM atmIMEFile;                // IME file name
} LAYOUT, *LPLAYOUT;

typedef struct
{
    DWORD dwLangID;                 // language id
    BOOL bEnabled;                  // enable status
    BOOL bDefault;                  // default profile
    BOOL fEngineAvailable;          // engine status
    BOOL bNoAddCat;                 // don't add category
    UINT uInputType;                // input type
    CLSID clsid;                    // tip clsid
    GUID guidProfile;               // tip profile guid
    HKL hklSub;                     // tip substitute hkl
    UINT iLayout;                   // offset into keyboard layout array
    ATOM atmTipText;                // layout text name
} TIPS, *LPTIPS;

typedef struct
{
    DWORD dwHotKeyID;
    UINT  idHotKeyName;
    DWORD fdwEnable;
    UINT  uModifiers;
    UINT  uVKey;
    HKL   hkl;
    ATOM  atmHotKeyName;
    UINT  idxLayout;
    UINT  uLayoutHotKey;
} HOTKEYINFO, *LPHOTKEYINFO;

typedef struct
{
    HWND hwndMain;
    LPLANGNODE pLangNode;
    LPHOTKEYINFO pHotKeyNode;
} INITINFO, *LPINITINFO;

typedef struct
{
    UINT uVirtKeyValue;
    UINT idVirtKeyName;
    ATOM atVirtKeyName;
} VIRTKEYDESC;



//
//  Global Variables.
//

static VIRTKEYDESC g_aVirtKeyDesc[] =
{
    {0,               IDS_VK_NONE,          0},
    {VK_SPACE,        IDS_VK_SPACE,         0},
    {VK_PRIOR,        IDS_VK_PRIOR,         0},
    {VK_NEXT,         IDS_VK_NEXT,          0},
    {VK_END,          IDS_VK_END,           0},
    {VK_HOME,         IDS_VK_HOME,          0},
    {VK_F1,           IDS_VK_F1,            0},
    {VK_F2,           IDS_VK_F2,            0},
    {VK_F3,           IDS_VK_F3,            0},
    {VK_F4,           IDS_VK_F4,            0},
    {VK_F5,           IDS_VK_F5,            0},
    {VK_F6,           IDS_VK_F6,            0},
    {VK_F7,           IDS_VK_F7,            0},
    {VK_F8,           IDS_VK_F8,            0},
    {VK_F9,           IDS_VK_F9,            0},
    {VK_F10,          IDS_VK_F10,           0},
    {VK_F11,          IDS_VK_F11,           0},
    {VK_F12,          IDS_VK_F12,           0},
    {VK_OEM_SEMICLN,  IDS_VK_OEM_SEMICLN,   0},
    {VK_OEM_EQUAL,    IDS_VK_OEM_EQUAL,     0},
    {VK_OEM_COMMA,    IDS_VK_OEM_COMMA,     0},
    {VK_OEM_MINUS,    IDS_VK_OEM_MINUS,     0},
    {VK_OEM_PERIOD,   IDS_VK_OEM_PERIOD,    0},
    {VK_OEM_SLASH,    IDS_VK_OEM_SLASH,     0},
    {VK_OEM_3,        IDS_VK_OEM_3,         0},
    {VK_OEM_LBRACKET, IDS_VK_OEM_LBRACKET,  0},
    {VK_OEM_BSLASH,   IDS_VK_OEM_BSLASH,    0},
    {VK_OEM_RBRACKET, IDS_VK_OEM_RBRACKET,  0},
    {VK_OEM_QUOTE,    IDS_VK_OEM_QUOTE,     0},
    {'A',             IDS_VK_A + 0,         0},
    {'B',             IDS_VK_A + 1,         0},
    {'C',             IDS_VK_A + 2,         0},
    {'D',             IDS_VK_A + 3,         0},
    {'E',             IDS_VK_A + 4,         0},
    {'F',             IDS_VK_A + 5,         0},
    {'G',             IDS_VK_A + 6,         0},
    {'H',             IDS_VK_A + 7,         0},
    {'I',             IDS_VK_A + 8,         0},
    {'J',             IDS_VK_A + 9,         0},
    {'K',             IDS_VK_A + 10,        0},
    {'L',             IDS_VK_A + 11,        0},
    {'M',             IDS_VK_A + 12,        0},
    {'N',             IDS_VK_A + 13,        0},
    {'O',             IDS_VK_A + 14,        0},
    {'P',             IDS_VK_A + 15,        0},
    {'Q',             IDS_VK_A + 16,        0},
    {'R',             IDS_VK_A + 17,        0},
    {'S',             IDS_VK_A + 18,        0},
    {'T',             IDS_VK_A + 19,        0},
    {'U',             IDS_VK_A + 20,        0},
    {'V',             IDS_VK_A + 21,        0},
    {'W',             IDS_VK_A + 22,        0},
    {'X',             IDS_VK_A + 23,        0},
    {'Y',             IDS_VK_A + 24,        0},
    {'Z',             IDS_VK_A + 25,        0},
    {0,               IDS_VK_NONE1,         0},
    {'0',             IDS_VK_0 + 0,         0},
    {'1',             IDS_VK_0 + 1,         0},
    {'2',             IDS_VK_0 + 2,         0},
    {'3',             IDS_VK_0 + 3,         0},
    {'4',             IDS_VK_0 + 4,         0},
    {'5',             IDS_VK_0 + 5,         0},
    {'6',             IDS_VK_0 + 6,         0},
    {'7',             IDS_VK_0 + 7,         0},
    {'8',             IDS_VK_0 + 8,         0},
    {'9',             IDS_VK_0 + 9,         0},
    {'~',             IDS_VK_0 + 10,        0},
    {'`',             IDS_VK_0 + 11,        0},
};



static BOOL g_bAdmin_Privileges = FALSE;
static BOOL g_bSetupCase = FALSE;

static BOOL g_bCHSystem = FALSE;
static BOOL g_bMESystem = FALSE;
static BOOL g_bShowRtL = FALSE;

static UINT g_iEnabledTips = 0;
static UINT g_iEnabledKbdTips = 0;
static DWORD g_dwToolBar = 0;
static DWORD g_dwChanges = 0;

static LPINPUTLANG g_lpLang = NULL;
static UINT g_iLangBuff;
static HANDLE g_hLang;
static UINT g_nLangBuffSize;

static LPLAYOUT g_lpLayout = NULL;
static UINT g_iLayoutBuff;
static HANDLE g_hLayout;
static UINT g_nLayoutBuffSize;
static UINT g_iLayoutIME;         // Number of IME keyboard layouts.
static int g_iUsLayout;
static DWORD g_dwAttributes;

static int g_cyText;
static int g_cyListItem;

static LPTIPS g_lpTips = NULL;
static UINT g_iTipsBuff;
static UINT g_nTipsBuffSize;
static HANDLE g_hTips;

static TCHAR c_szLocaleInfo[]    = TEXT("SYSTEM\\CurrentControlSet\\Control\\Nls\\Locale");
static TCHAR c_szLocaleInfoNT4[] = TEXT("SYSTEM\\CurrentControlSet\\Control\\Nls\\Language");
static TCHAR c_szLayoutPath[]    = TEXT("SYSTEM\\CurrentControlSet\\Control\\Keyboard Layouts");
static TCHAR c_szLayoutFile[]    = TEXT("layout file");
static TCHAR c_szLayoutText[]    = TEXT("layout text");
static TCHAR c_szLayoutID[]      = TEXT("layout id");
static TCHAR c_szInstalled[]     = TEXT("installed");
static TCHAR c_szIMEFile[]       = TEXT("IME File");
static TCHAR c_szDisplayLayoutText[] = TEXT("Layout Display Name");

static TCHAR c_szKbdLayouts[]    = TEXT("Keyboard Layout");
static TCHAR c_szPreloadKey[]    = TEXT("Preload");
static TCHAR c_szSubstKey[]      = TEXT("Substitutes");
static TCHAR c_szToggleKey[]     = TEXT("Toggle");
static TCHAR c_szToggleHotKey[]  = TEXT("Hotkey");
static TCHAR c_szToggleLang[]    = TEXT("Language Hotkey");
static TCHAR c_szToggleLayout[]  = TEXT("Layout Hotkey");
static TCHAR c_szAttributes[]    = TEXT("Attributes");
static TCHAR c_szKbdPreloadKey[] = TEXT("Keyboard Layout\\Preload");
static TCHAR c_szKbdSubstKey[]   = TEXT("Keyboard Layout\\Substitutes");
static TCHAR c_szKbdToggleKey[]  = TEXT("Keyboard Layout\\Toggle");
static TCHAR c_szInternat[]      = TEXT("internat.exe");
static char  c_szInternatA[]     = "internat.exe";

static TCHAR c_szTipInfo[]       = TEXT("SOFTWARE\\Microsoft\\CTF");
static TCHAR c_szCTFMon[]        = TEXT("CTFMON.EXE");
static char  c_szCTFMonA[]       = "ctfmon.exe";

static TCHAR c_szScanCodeKey[]     = TEXT("Keyboard Layout\\IMEtoggle\\scancode");
static TCHAR c_szValueShiftLeft[]  = TEXT("Shift Left");
static TCHAR c_szValueShiftRight[] = TEXT("Shift Right");

static TCHAR c_szIndicator[]     = TEXT("Indicator");
static TCHAR c_szCTFMonClass[]   = TEXT("CicLoaderWndClass");

static TCHAR c_szLoadImmPath[]   = TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IMM");

static TCHAR c_szPrefixCopy[]    = TEXT("KEYBOARD_");
static TCHAR c_szKbdInf[]        = TEXT("kbd.inf");
static TCHAR c_szKbdInf9x[]      = TEXT("multilng.inf");
static TCHAR c_szKbdIMEInf9x[]   = TEXT("ime.inf");
static TCHAR c_szIMECopy[]       = TEXT("IME_");

static TCHAR c_szTipCategoryEnable[] = TEXT("Enable");
static TCHAR c_szCTFTipPath[]        = TEXT("SOFTWARE\\Microsoft\\CTF\\TIP\\");
static TCHAR c_szLangProfileKey[]    = TEXT("LanguageProfile");
static TCHAR c_szSubstituteLayout[]  = TEXT("SubstituteLayout");

static TCHAR c_szKbdPreloadKey_DefUser[] = TEXT(".DEFAULT\\Keyboard Layout\\Preload");
static TCHAR c_szKbdSubstKey_DefUser[]   = TEXT(".DEFAULT\\Keyboard Layout\\Substitutes");
static TCHAR c_szKbdToggleKey_DefUser[]  = TEXT(".DEFAULT\\Keyboard Layout\\Toggle");
static TCHAR c_szRunPath_DefUser[]       = TEXT(".DEFAULT\\Software\\Microsoft\\Windows\\CurrentVersion\\Run");

static TCHAR c_szHelpFile[]    = TEXT("input.hlp");


static HOTKEYINFO g_aDirectSwitchHotKey[IME_HOTKEY_DSWITCH_LAST - IME_HOTKEY_DSWITCH_FIRST + 1];
#define DSWITCH_HOTKEY_SIZE sizeof(g_aDirectSwitchHotKey) / sizeof(HOTKEYINFO)

static HOTKEYINFO g_SwitchLangHotKey;

static HOTKEYINFO g_aImeHotKey0404[] =
{
    {IME_ITHOTKEY_RESEND_RESULTSTR,     IDS_RESEND_RESULTSTR_CHT,
        MOD_VIRTKEY|MOD_CONTROL|MOD_ALT|MOD_SHIFT,
        0, 0, (HKL)NULL, 0, -1},
    {IME_ITHOTKEY_PREVIOUS_COMPOSITION, IDS_PREVIOUS_COMPOS_CHT,
        MOD_VIRTKEY|MOD_CONTROL|MOD_ALT|MOD_SHIFT,
        0, 0, (HKL)NULL, 0, -1},
    {IME_ITHOTKEY_UISTYLE_TOGGLE,       IDS_UISTYLE_TOGGLE_CHT,
        MOD_VIRTKEY|MOD_CONTROL|MOD_ALT|MOD_SHIFT,
        0, 0, (HKL)NULL, 0, -1},
    {IME_THOTKEY_IME_NONIME_TOGGLE,     IDS_IME_NONIME_TOGGLE_CHT,
        MOD_LEFT,
        0, 0, (HKL)NULL, 0, -1},
    {IME_THOTKEY_SHAPE_TOGGLE,          IDS_SHAPE_TOGGLE_CHT,
        MOD_LEFT,
        0, 0, (HKL)NULL, 0, -1},
    {IME_THOTKEY_SYMBOL_TOGGLE,         IDS_SYMBOL_TOGGLE_CHT,
        MOD_VIRTKEY|MOD_CONTROL|MOD_ALT|MOD_SHIFT,
        0, 0, (HKL)NULL, 0, -1},
};

static HOTKEYINFO g_aImeHotKey0804[] =
{

    {IME_CHOTKEY_IME_NONIME_TOGGLE,     IDS_IME_NONIME_TOGGLE_CHS,
        MOD_LEFT,
        0, 0, (HKL)NULL, 0, -1},
    {IME_CHOTKEY_SHAPE_TOGGLE,          IDS_SHAPE_TOGGLE_CHS,
        MOD_LEFT,
        0, 0, (HKL)NULL, 0, -1},
    {IME_CHOTKEY_SYMBOL_TOGGLE,         IDS_SYMBOL_TOGGLE_CHS,
        MOD_VIRTKEY|MOD_CONTROL|MOD_ALT|MOD_SHIFT,
        0, 0, (HKL)NULL, 0, -1},

};


static HOTKEYINFO g_aImeHotKeyCHxBoth[]=
{

// CHS HOTKEYs,

    {IME_CHOTKEY_IME_NONIME_TOGGLE,     IDS_IME_NONIME_TOGGLE_CHS,
        MOD_LEFT,
        0, 0, (HKL)NULL, 0, -1},
    {IME_CHOTKEY_SHAPE_TOGGLE,          IDS_SHAPE_TOGGLE_CHS,
        MOD_LEFT,
        0, 0, (HKL)NULL, 0, -1},
    {IME_CHOTKEY_SYMBOL_TOGGLE,         IDS_SYMBOL_TOGGLE_CHS,
        MOD_VIRTKEY|MOD_CONTROL|MOD_ALT|MOD_SHIFT,
        0, 0, (HKL)NULL, 0, -1},

// CHT HOTKEYs,

    {IME_ITHOTKEY_RESEND_RESULTSTR,     IDS_RESEND_RESULTSTR_CHT,
        MOD_VIRTKEY|MOD_CONTROL|MOD_ALT|MOD_SHIFT,
        0, 0, (HKL)NULL, 0, -1},
    {IME_ITHOTKEY_PREVIOUS_COMPOSITION, IDS_PREVIOUS_COMPOS_CHT,
        MOD_VIRTKEY|MOD_CONTROL|MOD_ALT|MOD_SHIFT,
        0, 0, (HKL)NULL, 0, -1},
    {IME_ITHOTKEY_UISTYLE_TOGGLE,       IDS_UISTYLE_TOGGLE_CHT,
        MOD_VIRTKEY|MOD_CONTROL|MOD_ALT|MOD_SHIFT,
        0, 0, (HKL)NULL, 0, -1},
    {IME_THOTKEY_IME_NONIME_TOGGLE,     IDS_IME_NONIME_TOGGLE_CHT,
        MOD_LEFT,
        0, 0, (HKL)NULL, 0, -1},
    {IME_THOTKEY_SHAPE_TOGGLE,          IDS_SHAPE_TOGGLE_CHT,
        MOD_LEFT,
        0, 0, (HKL)NULL, 0, -1},
    {IME_THOTKEY_SYMBOL_TOGGLE,         IDS_SYMBOL_TOGGLE_CHT,
        MOD_VIRTKEY|MOD_CONTROL|MOD_ALT|MOD_SHIFT,
        0, 0, (HKL)NULL, 0, -1},
};




//
//  Function Prototypes.
//

INT_PTR CALLBACK
KbdLocaleAddDlg(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
KbdLocaleEditDlg(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
KbdLocaleChangeInputLocaleHotkey(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
KbdLocaleChangeThaiInputLocaleHotkey(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
KbdLocaleChangeMEInputLocaleHotkey(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
KbdLocaleChangeKeyboardLayoutHotkey(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
KbdLocaleHotKeyDlg(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
KbdLocaleSimpleHotkey(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
ToolBarSettingDlg(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);



BOOL Locale_LoadLocales(HWND hwnd);

BOOL IsEnabledTipOrMultiLayouts();

HKL GetSubstituteHKL(
   REFCLSID rclsid,
   LANGID langid,
   REFGUID guidProfile);

#endif // INPUTDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inputdll\input.h ===
//
//  Include Files.
//

#ifndef INPUT_H
#define INPUT_H

#include <windows.h>
#include <windowsx.h>
#include <windows.h>
#include <winuser.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#include <prsht.h>
#include <prshtp.h>
#include <shellapi.h>
#include <winnls.h>

#include "resource.h"
#include "cicspres.h"
#include "cicutil.h"


#ifndef OS_WINDOWS
#define OS_WINDOWS          0           // windows vs. NT
#define OS_NT               1           // windows vs. NT
#define OS_WIN95            2           // Win95 or greater
#define OS_NT4              3           // NT4 or greater
#define OS_NT5              4           // NT5 or greater
#define OS_MEMPHIS          5           // Win98 or greater
#define OS_MEMPHIS_GOLD     6           // Win98 Gold
#define OS_NT51             7           // NT51
#endif


//
//  Character constants.
//
#define CHAR_NULL            TEXT('\0')
#define CHAR_COLON           TEXT(':')

#define CHAR_GRAVE           TEXT('`')


//
//  Global Variables.
//  Data that is shared betweeen the property sheets.
//

extern HANDLE g_hMutex;             // mutex handle

extern HANDLE g_hEvent;             // event handle

extern HINSTANCE hInstance;         // library instance
extern HINSTANCE hInstOrig;         // original library instance


//
//  Function Prototypes.
//

//
//  Callback functions for each of the propety sheet pages.
//
INT_PTR CALLBACK InputLocaleDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK InputAdvancedDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

#endif // INPUT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inputdll\regdlg.c ===
//
//  Include Files.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "input.h"
#include "winnlsp.h"
#include <windowsx.h>
#include <regstr.h>
#include <tchar.h>
#include <stdlib.h>
#include <setupapi.h>
#include <syssetup.h>
#include <winuserp.h>
#include <userenv.h>
#include "inputdlg.h"

#include "util.h"


//
//  Global Variables.
//

static TCHAR szIntlInf[]          = TEXT("intl.inf");


//
//  Function Prototypes.
//

VOID
Region_RebootTheSystem();

BOOL
Region_OpenIntlInfFile(HINF *phInf);

BOOL
Region_CloseInfFile(HINF *phInf);

BOOL
Region_ReadDefaultLayoutFromInf(
    LPTSTR pszLocale,
    LPDWORD pdwLocale,
    LPDWORD pdwLayout,
    LPDWORD pdwLocale2,
    LPDWORD pdwLayout2,
    HINF hIntlInf);





////////////////////////////////////////////////////////////////////////////
//
//  Region_RebootTheSystem
//
//  This routine enables all privileges in the token, calls ExitWindowsEx
//  to reboot the system, and then resets all of the privileges to their
//  old state.
//
////////////////////////////////////////////////////////////////////////////

VOID Region_RebootTheSystem()
{
    HANDLE Token = NULL;
    ULONG ReturnLength, Index;
    PTOKEN_PRIVILEGES NewState = NULL;
    PTOKEN_PRIVILEGES OldState = NULL;
    BOOL Result;

    //  Only allow admin privilege user for system reboot.
    if (!IsAdminPrivilegeUser())
        return;

    Result = OpenProcessToken( GetCurrentProcess(),
                               TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                               &Token );
    if (Result)
    {
        ReturnLength = 4096;
        NewState = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR, ReturnLength);
        OldState = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR, ReturnLength);
        Result = (BOOL)((NewState != NULL) && (OldState != NULL));
        if (Result)
        {
            Result = GetTokenInformation( Token,            // TokenHandle
                                          TokenPrivileges,  // TokenInformationClass
                                          NewState,         // TokenInformation
                                          ReturnLength,     // TokenInformationLength
                                          &ReturnLength );  // ReturnLength
            if (Result)
            {
                //
                //  Set the state settings so that all privileges are
                //  enabled...
                //
                if (NewState->PrivilegeCount > 0)
                {
                    for (Index = 0; Index < NewState->PrivilegeCount; Index++)
                    {
                        NewState->Privileges[Index].Attributes = SE_PRIVILEGE_ENABLED;
                    }
                }

                Result = AdjustTokenPrivileges( Token,           // TokenHandle
                                                FALSE,           // DisableAllPrivileges
                                                NewState,        // NewState
                                                ReturnLength,    // BufferLength
                                                OldState,        // PreviousState
                                                &ReturnLength ); // ReturnLength
                if (Result)
                {
                    ExitWindowsEx(EWX_REBOOT, 0);


                    AdjustTokenPrivileges( Token,
                                           FALSE,
                                           OldState,
                                           0,
                                           NULL,
                                           NULL );
                }
            }
        }
    }

    if (NewState != NULL)
    {
        LocalFree(NewState);
    }
    if (OldState != NULL)
    {
        LocalFree(OldState);
    }
    if (Token != NULL)
    {
        CloseHandle(Token);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_OpenInfFile
//
////////////////////////////////////////////////////////////////////////////

BOOL Region_OpenIntlInfFile(HINF *phInf)
{
    HINF hIntlInf;

    //
    //  Open the intl.inf file.
    //
    hIntlInf = SetupOpenInfFile(szIntlInf, NULL, INF_STYLE_WIN4, NULL);
    if (hIntlInf == INVALID_HANDLE_VALUE)
    {
        return (FALSE);
    }
    if (!SetupOpenAppendInfFile(NULL, hIntlInf, NULL))
    {
        SetupCloseInfFile(hIntlInf);
        return (FALSE);
    }

    *phInf = hIntlInf;

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  RegionCloseInfFile
//
////////////////////////////////////////////////////////////////////////////

BOOL Region_CloseInfFile(HINF *phInf)
{
    SetupCloseInfFile(*phInf);
    *phInf = INVALID_HANDLE_VALUE;

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_ReadDefaultLayoutFromInf
//
////////////////////////////////////////////////////////////////////////////

BOOL Region_ReadDefaultLayoutFromInf(
    LPTSTR pszLocale,
    LPDWORD pdwLocale,
    LPDWORD pdwLayout,
    LPDWORD pdwLocale2,
    LPDWORD pdwLayout2,
    HINF hIntlInf)
{
    INFCONTEXT Context;
    TCHAR szPair[MAX_PATH * 2];
    LPTSTR pPos;
    DWORD dwLangIn = LANGIDFROMLCID(TransNum(pszLocale));
    int iField;

    //
    //  Get the first (default) LANGID:HKL pair for the given locale.
    //    Example String: "0409:00000409"
    //
    szPair[0] = 0;
    if (SetupFindFirstLine( hIntlInf,
                            TEXT("Locales"),
                            pszLocale,
                            &Context ))
    {
        SetupGetStringField(&Context, 5, szPair, MAX_PATH, NULL);
    }

    //
    //  Make sure we have a string.
    //
    if (szPair[0] == 0)
    {
        return (FALSE);
    }

    //
    //  Find the colon in the string and then set the position
    //  pointer to the next character.
    //
    pPos = szPair;
    while (*pPos)
    {
        if ((*pPos == CHAR_COLON) && (pPos != szPair))
        {
            *pPos = 0;
            pPos++;
            break;
        }
        pPos++;
    }

    if (pdwLayout2)
        *pdwLayout2 = 0;
    if (pdwLocale2)
        *pdwLocale2 = 0;

    //
    //  If there is a layout, then return the input locale and the layout.
    //
    if ((*pPos) &&
        (*pdwLocale = TransNum(szPair)) &&
        (*pdwLayout = TransNum(pPos)))
    {
        if ((!pdwLocale2) ||
            (!pdwLayout2) ||
            (dwLangIn == LANGIDFROMLCID(*pdwLocale)))
        {
            return (TRUE);
        }

        //
        //  If we get here, the language has a default layout that has a
        //  different locale than the language (e.g. Thai).  We want the
        //  default locale to be English (so that logon can occur with a US
        //  keyboard), but the first Thai keyboard layout should be installed
        //  when the Thai locale is chosen.  This is why we have two locales
        //  and layouts passed back to the caller.
        //
        iField = 6;
        while (SetupGetStringField(&Context, iField, szPair, MAX_PATH, NULL))
        {
            DWORD dwLoc, dwLay;

            //
            //  Make sure we have a string.
            //
            if (szPair[0] == 0)
            {
                iField++;
                continue;
            }

            //
            //  Find the colon in the string and then set the position
            //  pointer to the next character.
            //
            pPos = szPair;

            while (*pPos)
            {
                if ((*pPos == CHAR_COLON) && (pPos != szPair))
                {
                    *pPos = 0;
                    pPos++;
                    break;
                }
                pPos++;
            }

            if (*pPos == 0)
            {
                iField++;
                continue;
            }

            dwLoc = TransNum(szPair);
            dwLay = TransNum(pPos);
            if ((dwLoc == 0) || (dwLay == 0))
            {
                iField++;
                continue;
            }
            if (LANGIDFROMLCID(dwLoc) == dwLangIn)
            {
                *pdwLayout2 = dwLay;
                *pdwLocale2 = dwLoc;
                return (TRUE);
            }
            iField++;
        }

        //
        //  If we get here, then no matching locale could be found.
        //  This should not happen, but do the right thing and
        //  only pass back the default layout if it does.
        //
        return (TRUE);
    }

    //
    //  Return failure.
    //
    return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inputdll\inputhlp.h ===
//
//  Include Files.
//

#ifndef INPUTHLP_H
#define INPUTHLP_H

//
//  From help.h.
//
#define IDH_COMM_GROUPBOX              28548


//
//  Values must be in the range 3300 - 3499.
//

// Text Input Methods tab
#define IDH_INPUT_DEFAULT_LOCALE                              3400
#define IDH_INPUT_LIST                                        3401
#define IDH_INPUT_ADD                                         3402
#define IDH_INPUT_DELETE                                      3403
#define IDH_INPUT_EDIT                                        3404
#define IDH_INPUT_TOOLBAR_SETTINGS                            3405
#define IDH_INPUT_KEY_SETTINGS                                3406

// Toolbar Settings - Text Input Methods
#define IDH_INPUT_DISABLE_TEXTSERVICE                         3410
#define IDH_INPUT_SHOWLANGBAR                                 3411
#define IDH_INPUT_EXTRAICON                                   3412
#define IDH_INPUT_SHRINK                                      3413
#define IDH_INPUT_CLOSE                                       3414
#define IDH_INPUT_OPAQUE                                      3415
#define IDH_INPUT_LOW_TRANS                                   3416
#define IDH_INPUT_HIGH_TRANS                                  3417
#define IDH_INPUT_TEXT_LABELS                                 3418
#define IDH_INPUT_N_TEXT_LABELS                               3419

// Advanced Key Settings - Text Input Methods
#define IDH_INPUT_SETTINGS_CAPSLOCK                           3421
#define IDH_INPUT_SETTINGS_HOTKEY                             3422
#define IDH_INPUT_SETTINGS_HOTKEY_LIST                        3423

// Add Input Locale - Text Input Methods
#define IDH_INPUT_ADD_LOCALE                                  3431
#define IDH_INPUT_ADD_LAYOUT                                  3432
#define IDH_INPUT_ADD_PEN                                     3433
#define IDH_INPUT_ADD_SPEECH                                  3435

// Input Local Properties - Text Input Methods
#define IDH_INPUT_PROP_LOCALE                                 3441
#define IDH_INPUT_PROP_KEYLAY                                 3442

// Change Key Sequence - Text Input Methods
#define IDH_INPUT_LANG_HOTKEY_CHANGE                          3451
#define IDH_INPUT_LAYOUT_HOTKEY_CHANGE                        3452


//
// Advanced settings page
//
#define IDH_ADVANCED_CUAS                                     3500
#define IDH_ADVANCED_CTFMON                                   3501


#endif // INPUTHLP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inputdll\util.c ===
//
//  Include Files.
//

#include "input.h"
#include <regstr.h>
#include "util.h"
#include "external.h"
#include "msctf.h"
#include "inputdlg.h"


#define CLSID_STRLEN                38

const TCHAR c_szSetupKey[]           = TEXT("System\\Setup");
const TCHAR c_szSetupInProgress[]    = TEXT("SystemSetupInProgress");
const TCHAR c_szLangBarSetting[]     = TEXT("SOFTWARE\\Microsoft\\CTF\\LangBar");
const TCHAR c_szShowStatus[]         = TEXT("ShowStatus");
const TCHAR c_szCtf[]                = TEXT("SOFTWARE\\Microsoft\\CTF");
const TCHAR c_szCtfShared[]          = TEXT("SOFTWARE\\Microsoft\\CTF\\SystemShared");
const TCHAR c_szDisableTim[]         = TEXT("Disable Thread Input Manager");
const TCHAR c_szLangBarSetting_DefUser[] = TEXT(".DEFAULT\\SOFTWARE\\Microsoft\\CTF\\LangBar");
const TCHAR c_szLangGroup[]          = TEXT("System\\CurrentControlSet\\Control\\Nls\\Language Groups");
const TCHAR c_szLangJPN[]            = TEXT("7");

const TCHAR c_szLanguageProfile[]    = TEXT("\\LanguageProfile");

//
//  Cicero Unaware Application Support const strings.
//
const TCHAR c_szIMM[]                = TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IMM");
const TCHAR c_szLoadIMM[]            = TEXT("LoadIMM");
const TCHAR c_szIMMFile[]            = TEXT("IME File");
const TCHAR c_szIMMFileName[]        = TEXT("msctfime.ime");
const TCHAR c_szCUAS[]               = TEXT("CUAS");



////////////////////////////////////////////////////////////////////////////
//
//  CLSIDToStringA
//
//  Converts a CLSID to an mbcs string.
//
////////////////////////////////////////////////////////////////////////////


static const BYTE GuidMap[] = {3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
    8, 9, '-', 10, 11, 12, 13, 14, 15};

static const char szDigits[] = "0123456789ABCDEF";


BOOL CLSIDToStringA(REFGUID refGUID, char *pchA)
{
    int i;
    char *p = pchA;

    const BYTE * pBytes = (const BYTE *) refGUID;

    *p++ = '{';
    for (i = 0; i < sizeof(GuidMap); i++)
    {
        if (GuidMap[i] == '-')
        {
            *p++ = '-';
        }
        else
        {
            *p++ = szDigits[ (pBytes[GuidMap[i]] & 0xF0) >> 4 ];
            *p++ = szDigits[ (pBytes[GuidMap[i]] & 0x0F) ];
        }
    }

    *p++ = '}';
    *p   = '\0';

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//
//  TransNum
//
//  Converts a number string to a dword value (in hex).
//
////////////////////////////////////////////////////////////////////////////

DWORD TransNum(
    LPTSTR lpsz)
{
    DWORD dw = 0L;
    TCHAR c;

    while (*lpsz)
    {
        c = *lpsz++;

        if (c >= TEXT('A') && c <= TEXT('F'))
        {
            c -= TEXT('A') - 0xa;
        }
        else if (c >= TEXT('0') && c <= TEXT('9'))
        {
            c -= TEXT('0');
        }
        else if (c >= TEXT('a') && c <= TEXT('f'))
        {
            c -= TEXT('a') - 0xa;
        }
        else
        {
            break;
        }
        dw *= 0x10;
        dw += c;
    }
    return (dw);
}


BOOL IsOSPlatform(DWORD dwOS)
{
    BOOL bRet;
    static OSVERSIONINFOA s_osvi;
    static BOOL s_bVersionCached = FALSE;

    if (!s_bVersionCached)
    {
        s_bVersionCached = TRUE;

        s_osvi.dwOSVersionInfoSize = sizeof(s_osvi);
        GetVersionExA(&s_osvi);
    }

    switch (dwOS)
    {
    case OS_WINDOWS:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId);
        break;

    case OS_NT:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId);
        break;

    case OS_WIN95:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 4);
        break;

    case OS_NT4:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                (s_osvi.dwMajorVersion >= 4 && s_osvi.dwMajorVersion < 5));
        break;

    case OS_NT5:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 5);
        break;

    case OS_NT51:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 5 && s_osvi.dwMinorVersion >= 0x00000001);
        break;

    default:
        bRet = FALSE;
        break;
    }

    return bRet;

}

////////////////////////////////////////////////////////////////////////////
//
//  MirrorBitmapInDC
//
////////////////////////////////////////////////////////////////////////////

void MirrorBitmapInDC(
    HDC hdc,
    HBITMAP hbmOrig)
{
    HDC hdcMem;
    HBITMAP hbm;
    BITMAP bm;

    if (!GetObject(hbmOrig, sizeof(BITMAP), &bm))
    {
        return;
    }

    hdcMem = CreateCompatibleDC(hdc);
    if (!hdcMem)
    {
        return;
    }

    hbm = CreateCompatibleBitmap(hdc, bm.bmWidth, bm.bmHeight);
    if (!hbm)
    {
        DeleteDC(hdcMem);
        return;
    }

    //
    //  Flip the bitmap.
    //
    SelectObject(hdcMem, hbm);

    SetLayout(hdcMem, LAYOUT_RTL);

    BitBlt(hdcMem, 0, 0, bm.bmWidth, bm.bmHeight, hdc, 0, 0, SRCCOPY);

    SetLayout(hdcMem, 0);


    //
    //  The offset by 1 is to solve the off-by-one problem.
    //
    BitBlt(hdc, 0, 0, bm.bmWidth, bm.bmHeight, hdcMem, 1, 0, SRCCOPY);

    DeleteDC(hdcMem);
    DeleteObject(hbm);
}

////////////////////////////////////////////////////////////////////////////
//
//  IsSetupMode
//
//  Look into the registry if we are currently in setup mode.
//
////////////////////////////////////////////////////////////////////////////

BOOL IsSetupMode()
{
    HKEY hKey;
    DWORD cb;
    DWORD fSystemSetupInProgress;

    //
    //  Open the registry key used by setup
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    c_szSetupKey,
                    0,
                    KEY_READ,
                    &hKey) != ERROR_SUCCESS)
    {
        return (FALSE);
    }

    //
    //  Query for the value indicating that we are in setup.
    //
    cb = sizeof(fSystemSetupInProgress);
    if (RegQueryValueEx(hKey,
                        c_szSetupInProgress,
                        NULL,
                        NULL,
                        (LPBYTE)&fSystemSetupInProgress,
                        &cb) != ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
        return (FALSE);
    }

    //
    //  Clean up
    //
    RegCloseKey(hKey);

    //
    //  Check the value
    //
    if (fSystemSetupInProgress)
    {
        return (TRUE);
    }

    return FALSE;
}

////////////////////////////////////////////////////////////////////////////
//
//  IsAdminPrivilegeUser
//
////////////////////////////////////////////////////////////////////////////

BOOL IsAdminPrivilegeUser()
{
    BOOL bAdmin = FALSE;
    BOOL bResult = FALSE;
    BOOL fSIDCreated = FALSE;
    HANDLE hToken = NULL;
    PSID AdminSid;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    fSIDCreated = AllocateAndInitializeSid(&NtAuthority,
                                           2,
                                           SECURITY_BUILTIN_DOMAIN_RID,
                                           DOMAIN_ALIAS_RID_ADMINS,
                                           0, 0, 0, 0, 0, 0,
                                           &AdminSid);

    if (!fSIDCreated)
        return FALSE;

    bResult = OpenProcessToken(GetCurrentProcess(),
                               TOKEN_QUERY,
                               &hToken );

    if (bResult)
    {
        DWORD dwSize = 0;
        TOKEN_GROUPS *pTokenGrpInfo;

        GetTokenInformation(hToken,
                            TokenGroups,
                            NULL,
                            dwSize,
                            &dwSize);

        if (dwSize)
            pTokenGrpInfo = (PTOKEN_GROUPS) LocalAlloc(LPTR, dwSize);
        else
            pTokenGrpInfo = NULL;

        if (pTokenGrpInfo && GetTokenInformation(hToken,
                                                 TokenGroups,
                                                 pTokenGrpInfo,
                                                 dwSize,
                                                 &dwSize))
        {
            UINT i;

            for (i = 0; i < pTokenGrpInfo->GroupCount; i++)
            {
                if (EqualSid(pTokenGrpInfo->Groups[i].Sid, AdminSid) &&
                    (pTokenGrpInfo->Groups[i].Attributes & SE_GROUP_ENABLED))
                {
                    bAdmin = TRUE;
                    break;
                }
            }
        }

        if (pTokenGrpInfo)
            LocalFree(pTokenGrpInfo);
    }

    if (hToken)
        CloseHandle(hToken);

    if (AdminSid)
        FreeSid(AdminSid);

    return bAdmin;
}

////////////////////////////////////////////////////////////////////////////
//
//  IsInteractiveUserLogon
//
////////////////////////////////////////////////////////////////////////////

BOOL IsInteractiveUserLogon()
{
    PSID InteractiveSid;
    BOOL bCheckSucceeded;
    BOOL bAmInteractive = FALSE;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    if (!AllocateAndInitializeSid(&NtAuthority,
                                  1,
                                  SECURITY_INTERACTIVE_RID,
                                  0, 0, 0, 0, 0, 0, 0,
                                  &InteractiveSid))
    {
        return FALSE;
    }

    //
    // This checking is for logged on user or not. So we can blcok running
    // ctfmon.exe process from non-authorized user.
    //
    bCheckSucceeded = CheckTokenMembership(NULL,
                                           InteractiveSid,
                                           &bAmInteractive);

    if (InteractiveSid)
        FreeSid(InteractiveSid);

    return (bCheckSucceeded && bAmInteractive);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsValidLayout
//
////////////////////////////////////////////////////////////////////////////

BOOL IsValidLayout(
    DWORD dwLayout)
{
    HKEY hKey1, hKey2;
    TCHAR szLayout[MAX_PATH];

    //
    //  Get the layout id as a string.
    //
    StringCchPrintf(szLayout, ARRAYSIZE(szLayout), TEXT("%08x"), dwLayout);

    //
    //  Open the Keyboard Layouts key.
    //
    if (RegOpenKey(HKEY_LOCAL_MACHINE, c_szLayoutPath, &hKey1) != ERROR_SUCCESS)
    {
        return (FALSE);
    }

    //
    //  Try to open the layout id key under the Keyboard Layouts key.
    //
    if (RegOpenKey(hKey1, szLayout, &hKey2) != ERROR_SUCCESS)
    {
        RegCloseKey(hKey1);
        return (FALSE);
    }

    //
    //  Close the keys.
    //
    RegCloseKey(hKey1);
    RegCloseKey(hKey2);

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetLangBarOption
//
////////////////////////////////////////////////////////////////////////////

void SetLangBarOption(
   DWORD dwShowStatus,
   BOOL bDefUser)
{
    DWORD cb;
    HKEY hkeyLangBar;

    if (bDefUser)
    {
        if (RegCreateKey(HKEY_USERS,
                         c_szLangBarSetting_DefUser,
                         &hkeyLangBar) != ERROR_SUCCESS)
        {
            hkeyLangBar = NULL;
        }
    }
    else
    {
        if (RegCreateKey(HKEY_CURRENT_USER,
                         c_szLangBarSetting,
                         &hkeyLangBar) != ERROR_SUCCESS)
        {
            hkeyLangBar = NULL;
        }
    }

    if (hkeyLangBar)
    {
        cb = sizeof(DWORD);

        RegSetValueEx(hkeyLangBar,
                      c_szShowStatus,
                      0,
                      REG_DWORD,
                      (LPBYTE)&dwShowStatus,
                      sizeof(DWORD) );

        RegCloseKey(hkeyLangBar);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetLangBarOption
//
////////////////////////////////////////////////////////////////////////////

BOOL GetLangBarOption(
   DWORD *dwShowStatus,
   BOOL bDefUser)
{
    DWORD cb;
    HKEY hkeyLangBar;
    BOOL bRet = FALSE;

    if (bDefUser)
    {
        if (RegCreateKey(HKEY_USERS,
                         c_szLangBarSetting_DefUser,
                         &hkeyLangBar) != ERROR_SUCCESS)
        {
            hkeyLangBar = NULL;
        }
    }
    else
    {
        if (RegCreateKey(HKEY_CURRENT_USER,
                         c_szLangBarSetting,
                         &hkeyLangBar) != ERROR_SUCCESS)
        {
            hkeyLangBar = NULL;
        }
    }

    if (hkeyLangBar)
    {
        cb = sizeof(DWORD);

        if (RegQueryValueEx(hkeyLangBar,
                      c_szShowStatus,
                      NULL,
                      NULL,
                      (LPBYTE)&dwShowStatus,
                      &cb) == ERROR_SUCCESS)
        {
            bRet = TRUE;
        }

        RegCloseKey(hkeyLangBar);
    }

    return bRet;
}


////////////////////////////////////////////////////////////////////////////
//
//  CheckInternatModule
//
////////////////////////////////////////////////////////////////////////////

void CheckInternatModule()
{
    DWORD cb;
    HKEY hkeyRun;
    TCHAR szInternatName[MAX_PATH];

    if (RegOpenKey(HKEY_CURRENT_USER,
                     REGSTR_PATH_RUN,
                     &hkeyRun) == ERROR_SUCCESS)
    {
       cb = sizeof(szInternatName);

        if (RegQueryValueEx(hkeyRun,
                            c_szInternat,
                            NULL,
                            NULL,
                            (LPBYTE)szInternatName,
                            &cb) == ERROR_SUCCESS)
        {
            LCID SysLocale;
            BOOL bMinLangBar = TRUE;
            TCHAR szCTFMonPath[MAX_PATH];

            SysLocale = GetSystemDefaultLCID();

            if ((SysLocale == 0x0404) || (SysLocale == 0x0411) ||
                (SysLocale == 0x0412) || (SysLocale == 0x0804))
            {
                //
                //  Show language bar in case of FE system as a default
                //
                bMinLangBar = FALSE;
            }

            if (bMinLangBar)
            {
                if (IsOSPlatform(OS_NT51))
                {
                    SetLangBarOption(REG_LANGBAR_DESKBAND, FALSE);

                    //
                    //  Update language band menu item to Taskbar
                    //
                    SetLanguageBandMenu(TRUE);
                }
                else
                {
                    SetLangBarOption(REG_LANGBAR_MINIMIZED, FALSE);
                }
            }

            //
            //  Get Ctfmon full path string
            //
            if (GetCtfmonPath((LPTSTR) szCTFMonPath, ARRAYSIZE(szCTFMonPath)))
            {
                //
                //  Set "ctfmon.exe" instead of "internat.exe" module.
                //
                RegSetValueEx(hkeyRun,
                              c_szCTFMon,
                              0,
                              REG_SZ,
                              (LPBYTE)szCTFMonPath,
                              (lstrlen(szCTFMonPath) + 1) * sizeof(TCHAR));
            }
        }

        RegCloseKey(hkeyRun);
    }
}


#define MAX_REGKEY      10

DWORD
OpenUserKeyForWin9xUpgrade(
    LPCTSTR pszUserKey,
    HKEY *phKey
    )
{
    DWORD dwResult = ERROR_INVALID_PARAMETER;

    if (NULL != pszUserKey && NULL != phKey)
    {
        typedef struct {
            LPTSTR pszRoot;
            HKEY hKeyRoot;

        } REGISTRY_ROOTS, *PREGISTRY_ROOTS;

        static REGISTRY_ROOTS rgRoots[] = {
            { TEXT("HKLM"),                 HKEY_LOCAL_MACHINE   },
            { TEXT("HKEY_LOCAL_MACHINE"),   HKEY_LOCAL_MACHINE   },
            { TEXT("HKCC"),                 HKEY_CURRENT_CONFIG  },
            { TEXT("HKEY_CURRENT_CONFIG"),  HKEY_CURRENT_CONFIG  },
            { TEXT("HKU"),                  HKEY_USERS           },
            { TEXT("HKEY_USERS"),           HKEY_USERS           },
            { TEXT("HKCU"),                 HKEY_CURRENT_USER    },
            { TEXT("HKEY_CURRENT_USER"),    HKEY_CURRENT_USER    },
            { TEXT("HKCR"),                 HKEY_CLASSES_ROOT    },
            { TEXT("HKEY_CLASSES_ROOT"),    HKEY_CLASSES_ROOT    }
          };

        TCHAR szUserKey[MAX_PATH];      // For a local copy.
        LPTSTR pszSubKey = szUserKey;

        //
        // Make a local copy that we can modify.
        //
        StringCchCopy(szUserKey, ARRAYSIZE(szUserKey), pszUserKey);

        *phKey = NULL;
        //
        // Find the backslash.
        //
        while(*pszSubKey && TEXT('\\') != *pszSubKey)
            pszSubKey++;

        if (TEXT('\\') == *pszSubKey)
        {
            HKEY hkeyRoot = NULL;
            int i;
            //
            // Replace backslash with nul to separate the root key and
            // sub key strings in our local copy of the original argument 
            // string.
            //
            *pszSubKey++ = TEXT('\0');
            //
            // Now find the true root key in rgRoots[].
            //
            for (i = 0; i < MAX_REGKEY; i++)
            {
                if (0 == lstrcmpi(rgRoots[i].pszRoot, szUserKey))
                {
                    hkeyRoot = rgRoots[i].hKeyRoot;
                    break;
                }
            }
            if (NULL != hkeyRoot)
            {
                //
                // Open the key.
                //
                dwResult = RegOpenKeyEx(hkeyRoot,
                                        pszSubKey,
                                        0,
                                        KEY_ALL_ACCESS,
                                        phKey);
            }
        }
    }
    return dwResult;
}

////////////////////////////////////////////////////////////////////////////
//
//  MigrateCtfmonFromWin9x
//
////////////////////////////////////////////////////////////////////////////

DWORD MigrateCtfmonFromWin9x(LPCTSTR pszUserKey)
{
    DWORD cb;
    LCID SysLocale;
    HKEY hkeyRun = NULL;
    HKEY hkeyUser = NULL;
    HKEY hkeyPreload = NULL;
    BOOL bAddCtfmon = FALSE;
    TCHAR szInternatName[MAX_PATH];
    DWORD dwResult = ERROR_INVALID_PARAMETER;

    if (lstrlen(pszUserKey) >= MAX_PATH)
        return 0;

    SysLocale = GetSystemDefaultLCID();

    if ((SysLocale == 0x0404) || (SysLocale == 0x0411) ||
        (SysLocale == 0x0412) || (SysLocale == 0x0804))
    {
        return 0;
    }

    dwResult = OpenUserKeyForWin9xUpgrade(pszUserKey, &hkeyUser);

    if (ERROR_SUCCESS != dwResult || hkeyUser == NULL)
    {
        return dwResult;
    }

    //
    //  Now read all of preload hkl from the registry.
    //
    if (RegOpenKeyEx(hkeyUser,
                     c_szKbdPreloadKey,
                     0,
                     KEY_ALL_ACCESS,
                     &hkeyPreload) == ERROR_SUCCESS)
    {
        DWORD dwIndex;
        DWORD cchValue, cbData;
        TCHAR szValue[MAX_PATH];           // language id (number)
        TCHAR szData[MAX_PATH];            // language name

        dwIndex = 0;
        cchValue = sizeof(szValue) / sizeof(TCHAR);
        cbData = sizeof(szData);

        dwResult = RegEnumValue(hkeyPreload,
                                dwIndex,
                                szValue,
                                &cchValue,
                                NULL,
                                NULL,
                                (LPBYTE)szData,
                                &cbData );

        if (dwResult != ERROR_SUCCESS)
        {
            goto Exit;
        }

        do
        {
            dwIndex++;

            if (dwIndex >= 2)
            {
                bAddCtfmon = TRUE;
                break;
            }
            cchValue = sizeof(szValue) / sizeof(TCHAR);
            szValue[0] = TEXT('\0');
            cbData = sizeof(szData);
            szData[0] = TEXT('\0');

            dwResult = RegEnumValue(hkeyPreload,
                                    dwIndex,
                                    szValue,
                                    &cchValue,
                                    NULL,
                                    NULL,
                                    (LPBYTE)szData,
                                    &cbData );

        } while (dwResult == ERROR_SUCCESS);
    }

    if (!bAddCtfmon)
    {
        goto Exit;
    }

    if (RegOpenKeyEx(hkeyUser,
                     REGSTR_PATH_RUN,
                     0,
                     KEY_ALL_ACCESS,
                     &hkeyRun) == ERROR_SUCCESS)
    {
        HKEY hkeyLangBar;
        TCHAR szCTFMonPath[MAX_PATH];

        if (RegCreateKey(hkeyUser,
                         c_szLangBarSetting,
                         &hkeyLangBar) == ERROR_SUCCESS)
        {
            DWORD dwShowStatus = REG_LANGBAR_DESKBAND;
            cb = sizeof(DWORD);

            RegSetValueEx(hkeyLangBar,
                          c_szShowStatus,
                          0,
                          REG_DWORD,
                          (LPBYTE)&dwShowStatus,
                          sizeof(DWORD) );

            RegCloseKey(hkeyLangBar);
        }

        //
        //  Get Ctfmon full path string
        //
        if (GetCtfmonPath((LPTSTR) szCTFMonPath, ARRAYSIZE(szCTFMonPath)))
        {
            //
            //  Set "ctfmon.exe" instead of "internat.exe" module.
            //
            dwResult = RegSetValueEx(hkeyRun,
                                     c_szCTFMon,
                                     0,
                                     REG_SZ,
                                     (LPBYTE)szCTFMonPath,
                                     (lstrlen(szCTFMonPath) + 1) * sizeof(TCHAR));
        }

        //
        //  Clean up the registry for internat.
        //
        RegDeleteValue(hkeyRun, c_szInternat);
    }

Exit:
    if (hkeyPreload)
        RegCloseKey(hkeyPreload);

    if (hkeyRun)
        RegCloseKey(hkeyRun);

    if (hkeyUser)
        RegCloseKey(hkeyUser);

    return dwResult;
}


////////////////////////////////////////////////////////////////////////////
//
//   IsDisableCtfmon
//
////////////////////////////////////////////////////////////////////////////

BOOL IsDisableCtfmon()
{
    DWORD cb;
    HKEY hkeyLangBar;
    BOOL bRet = FALSE;
    DWORD dwDisableCtfmon = 0;


    if (RegOpenKey(HKEY_CURRENT_USER, c_szCtf, &hkeyLangBar) == ERROR_SUCCESS)
    {
        cb = sizeof(DWORD);

        RegQueryValueEx(hkeyLangBar,
                        c_szDisableTim,
                        NULL,
                        NULL,
                        (LPBYTE)&dwDisableCtfmon,
                        &cb);

        if (dwDisableCtfmon)
            bRet = TRUE;

        RegCloseKey(hkeyLangBar);
    }

    return bRet;
}


////////////////////////////////////////////////////////////////////////////
//
//  SetDisableCtfmon
//
////////////////////////////////////////////////////////////////////////////

void SetDisalbeCtfmon(
    DWORD dwDisableCtfmon)
{
    DWORD cb;
    HKEY hkeyLangBar;

    if (RegCreateKey(HKEY_CURRENT_USER, c_szCtf, &hkeyLangBar) == ERROR_SUCCESS)
    {
        cb = sizeof(DWORD);

        RegSetValueEx(hkeyLangBar,
                      c_szDisableTim,
                      0,
                      REG_DWORD,
                      (LPBYTE)&dwDisableCtfmon,
                      cb);

        RegCloseKey(hkeyLangBar);
    }
}

////////////////////////////////////////////////////////////////////////////
//
//   IsDisableCUAS
//
////////////////////////////////////////////////////////////////////////////

BOOL IsDisableCUAS()
{
    DWORD cb;
    HKEY hkeyCTF;
    BOOL bRet = TRUE;
    DWORD dwEnableCUAS = 0;

    if (RegOpenKey(HKEY_LOCAL_MACHINE, c_szCtfShared, &hkeyCTF) == ERROR_SUCCESS)
    {
        cb = sizeof(DWORD);

        RegQueryValueEx(hkeyCTF,
                        c_szCUAS,
                        NULL,
                        NULL,
                        (LPBYTE)&dwEnableCUAS,
                        &cb);

        if (dwEnableCUAS)
            bRet = FALSE;

        RegCloseKey(hkeyCTF);
    }

    return bRet;
}


////////////////////////////////////////////////////////////////////////////
//
//  SetDisableCUAS
//
////////////////////////////////////////////////////////////////////////////

void SetDisableCUAS(
    BOOL bDisableCUAS)
{
    HKEY hkeyIMM;
    HKEY hkeyCTF;
    DWORD cb = sizeof(DWORD);
    DWORD dwIMM32, dwCUAS;

    if (bDisableCUAS)
        dwIMM32 = dwCUAS = 0;
    else
        dwIMM32 = dwCUAS = 1;

    if (RegCreateKey(HKEY_LOCAL_MACHINE, c_szIMM, &hkeyIMM) != ERROR_SUCCESS)
    {
        hkeyIMM = NULL;
    }

    if (RegCreateKey(HKEY_LOCAL_MACHINE, c_szCtfShared, &hkeyCTF) != ERROR_SUCCESS)
    {
        hkeyCTF = NULL;
    }

    if (!bDisableCUAS)
    {
        //
        //  Turn on LoadIMM and CUAS flags
        //

        if (hkeyIMM)
        {
            RegSetValueEx(hkeyIMM,
                          c_szIMMFile,
                          0,
                          REG_SZ,
                          (LPBYTE)c_szIMMFileName,
                          (lstrlen(c_szIMMFileName) + 1) * sizeof(TCHAR));
        }
    }
    else
    {
        //
        //  Turn off LoadIMM and CUAS flags
        //

        BOOL bEALang = IsInstalledEALangPack();

        if (bEALang)
        {
            dwIMM32 = 1;
        }
    }

    if (hkeyIMM)
    {
        RegSetValueEx(hkeyIMM,
                      c_szLoadIMM,
                      0,
                      REG_DWORD,
                      (LPBYTE)&dwIMM32,
                      cb);
    }

    if (hkeyCTF)
    {
        RegSetValueEx(hkeyCTF,
                      c_szCUAS,
                      0,
                      REG_DWORD,
                      (LPBYTE)&dwCUAS,
                      cb);
    }

    if (hkeyIMM)
        RegCloseKey(hkeyIMM);

    if (hkeyCTF)
        RegCloseKey(hkeyCTF);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetDisableCtfmon
//
////////////////////////////////////////////////////////////////////////////

BOOL SetLanguageBandMenu(
    BOOL bLoad)
{
    BOOL bRet = FALSE;
    HINSTANCE hMsutb = NULL;
    FARPROC pfnSetRegisterLangBand = NULL;

    //
    //  Load MSUTB.DLL to register deskband menu item to TaskBar.
    //
    hMsutb = LoadSystemLibrary(TEXT("msutb.dll"));
    if (hMsutb)
    {
        //
        //  Get SetRegisterLangBand()
        //
        pfnSetRegisterLangBand = GetProcAddress(hMsutb,
                                                (LPVOID)8);
    }
    else
    {
        goto Exit;
    }

    //
    //  Call DllRegisterServer/DllUnregisterServer()
    //
    if (pfnSetRegisterLangBand)
    {
        pfnSetRegisterLangBand(bLoad);
        bRet = TRUE;
    }

    if (hMsutb)
    {
        FreeLibrary(hMsutb);
    }

Exit:
    return bRet;
}


////////////////////////////////////////////////////////////////////////////
//
//  RunCtfmonProcess
//
////////////////////////////////////////////////////////////////////////////

BOOL RunCtfmonProcess()
{
    TCHAR szCtfmonPath[MAX_PATH + 1];

    if (GetCtfmonPath(szCtfmonPath, ARRAYSIZE(szCtfmonPath)))
    {
        PROCESS_INFORMATION pi;
        STARTUPINFO si = {0};

        si.cb = sizeof(STARTUPINFO);
        si.dwFlags = STARTF_USESHOWWINDOW;
        si.wShowWindow = (WORD) SW_SHOWMINNOACTIVE;

        if (CreateProcess(szCtfmonPath,
                             c_szCTFMon,
                             NULL,
                             NULL,
                             FALSE,
                             NORMAL_PRIORITY_CLASS,
                             NULL,
                             NULL,
                             &si,
                             &pi))
        {
            WaitForInputIdle(pi.hProcess, 2000) ;
            return TRUE;
        }
        
    }

    return FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCtfmonPath
//
////////////////////////////////////////////////////////////////////////////

UINT GetCtfmonPath(
    LPTSTR lpCtfmonPath,
    UINT uBuffLen)
{
    UINT uSize = 0;

    if (!lpCtfmonPath)
        return uSize;

    *lpCtfmonPath = TEXT('\0');

    //
    // Confirmed lpCtfmonPath has MAX_PATH buffer size.
    //
    if (uSize = GetSystemDirectory(lpCtfmonPath, uBuffLen))
    {
        if (*(lpCtfmonPath + uSize - 1) != TEXT('\\'))
        {
            *(lpCtfmonPath + uSize) = TEXT('\\');
            uSize++;
        }

        if (uBuffLen - uSize > (UINT) lstrlen(c_szCTFMon))
        {
            lstrcpyn(lpCtfmonPath + uSize, c_szCTFMon, uBuffLen - uSize);
            uSize += lstrlen(c_szCTFMon);
        }
        else
        {
            *(lpCtfmonPath) = TEXT('\0');
            uSize = 0;
        }
    }

    return uSize;
}

////////////////////////////////////////////////////////////////////////////
//
//  IsInstalledEALangPack
//
////////////////////////////////////////////////////////////////////////////

BOOL IsInstalledEALangPack()
{
    BOOL bRet = FALSE;
    HKEY hkeyLangGroup;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     c_szLangGroup,
                     0,
                     KEY_READ,
                     &hkeyLangGroup) == ERROR_SUCCESS)
    {
        DWORD cb;
        TCHAR szLangInstall[10];

        cb = sizeof(szLangInstall);

        //
        //  The checking of Japan Language is enough to know EA language pack
        //  installation.
        //
        if (RegQueryValueEx(hkeyLangGroup,
                            c_szLangJPN,
                            NULL,
                            NULL,
                            (LPBYTE)szLangInstall,
                            &cb) == ERROR_SUCCESS)
        {
            if (szLangInstall[0] != 0)
                return TRUE;
        }

        RegCloseKey(hkeyLangGroup);
    }

    return bRet;
}


////////////////////////////////////////////////////////////////////////////
//
//  IsTIPClsidEnabled
//
////////////////////////////////////////////////////////////////////////////

BOOL IsTIPClsidEnabled(
    HKEY hkeyTop,
    LPTSTR lpTipClsid,
    BOOL *bExistEnable)
{
    BOOL bRet = FALSE;
    HKEY hkeyTipLang;
    HKEY hkeyTipLangid;
    HKEY hkeyTipGuid;
    UINT uIndex;
    UINT uIndex2;
    DWORD cb;
    DWORD cchLangid;
    DWORD cchGuid;
    DWORD dwEnableTIP = 0;
    LPTSTR pszGuid;
    LPTSTR pszLangid;
    TCHAR szTIPLangid[15];
    TCHAR szTIPGuid[128];
    TCHAR szTIPClsidLang[MAX_PATH];
    FILETIME lwt;
    UINT uLangidLen;
    UINT uGuidLen;

    if (lstrlen(lpTipClsid) != CLSID_STRLEN)
        return bRet;

    StringCchCopy(szTIPClsidLang, ARRAYSIZE(szTIPClsidLang), c_szCTFTipPath);
    StringCchCat(szTIPClsidLang, ARRAYSIZE(szTIPClsidLang), lpTipClsid);
    StringCchCat(szTIPClsidLang, ARRAYSIZE(szTIPClsidLang), c_szLanguageProfile);

    pszLangid = szTIPClsidLang + lstrlen(szTIPClsidLang);
    uLangidLen = ARRAYSIZE(szTIPClsidLang) - lstrlen(szTIPClsidLang);

    if (RegOpenKeyEx(hkeyTop,
                     szTIPClsidLang, 0,
                     KEY_READ, &hkeyTipLang) != ERROR_SUCCESS)
    {
        goto Exit;
    }

    for (uIndex = 0; bRet == FALSE; uIndex++)
    {
        cchLangid = sizeof(szTIPLangid) / sizeof(TCHAR);

        if (RegEnumKeyEx(hkeyTipLang, uIndex,
                         szTIPLangid, &cchLangid,
                         NULL, NULL, NULL, &lwt) != ERROR_SUCCESS)
        {
            break;
        }

        if (cchLangid != 10)
        {
            // string langid subkeys should be like 0x00000409
            continue;
        }

        if (uLangidLen > (cchLangid + 1))
        {
            StringCchCopy(pszLangid, uLangidLen, TEXT("\\"));
            StringCchCat(pszLangid, uLangidLen, szTIPLangid);
        }

        if (RegOpenKeyEx(hkeyTop,
                         szTIPClsidLang, 0,
                         KEY_READ, &hkeyTipLangid) != ERROR_SUCCESS)
        {
            continue;
        }

        pszGuid = szTIPClsidLang + lstrlen(szTIPClsidLang);
        uGuidLen = ARRAYSIZE(szTIPClsidLang) - lstrlen(szTIPClsidLang);

        for (uIndex2 = 0; bRet == FALSE; uIndex2++)
        {
            cchGuid = sizeof(szTIPGuid) / sizeof(TCHAR);

            if (RegEnumKeyEx(hkeyTipLangid, uIndex2,
                             szTIPGuid, &cchGuid,
                             NULL, NULL, NULL, &lwt) != ERROR_SUCCESS)
            {
                break;
            }

            if (cchGuid != CLSID_STRLEN)
            {
                continue;
            }

            if (uGuidLen > (cchGuid + 1))
            {
                StringCchCopy(pszGuid, uGuidLen, TEXT("\\"));
                StringCchCat(szTIPClsidLang, ARRAYSIZE(szTIPClsidLang), szTIPGuid);
            }

            if (RegOpenKeyEx(hkeyTop,
                             szTIPClsidLang, 0,
                             KEY_READ, &hkeyTipGuid) == ERROR_SUCCESS)
            {
                cb = sizeof(DWORD);

                if (RegQueryValueEx(hkeyTipGuid,
                                    TEXT("Enable"),
                                    NULL,
                                    NULL,
                                    (LPBYTE)&dwEnableTIP,
                                    &cb) == ERROR_SUCCESS)
                {

                    RegCloseKey(hkeyTipGuid);

                    *bExistEnable = TRUE;

                    if (dwEnableTIP)
                    {
                        bRet = TRUE;
                    }
                }
                else if (hkeyTop == HKEY_LOCAL_MACHINE)
                {
                    // Default is the enabled status on HKLM
                    *bExistEnable = TRUE;

                    bRet = TRUE;
                }
                else
                {
                    *bExistEnable = FALSE;
                }
            }
        }

        RegCloseKey(hkeyTipLangid);
    }

    RegCloseKey(hkeyTipLang);

Exit:

    return bRet;
}

////////////////////////////////////////////////////////////////////////////
//
//  IsTipInstalled
//
////////////////////////////////////////////////////////////////////////////

BOOL IsTipInstalled()
{
    const CLSID CLSID_SapiLayr = {0xdcbd6fa8, 0x032f, 0x11d3, {0xb5, 0xb1, 0x00, 0xc0, 0x4f, 0xc3, 0x24, 0xa1}};
    const CLSID CLSID_SoftkbdIMX = {0xf89e9e58, 0xbd2f, 0x4008, {0x9a, 0xc2, 0x0f, 0x81, 0x6c, 0x09, 0xf4, 0xee}};

    static const TCHAR c_szSpeechRecognizersKey[] = TEXT("Software\\Microsoft\\Speech\\Recognizers\\Tokens");
    static const TCHAR c_szCategory[] = TEXT("\\Category\\Category");

    BOOL bRet = FALSE;
    BOOL bExistEnable;
    HKEY hkeyTip;
    HKEY hkeyTipSub;
    UINT uIndex;
    DWORD dwSubKeys;
    DWORD cchClsid;
    CLSID clsidTip;
    TCHAR szTipClsid[128];
    TCHAR szTipClsidPath[MAX_PATH];
    FILETIME lwt;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     TEXT("Software\\Microsoft\\CTF\\TIP"),
                     0, KEY_READ, &hkeyTip) != ERROR_SUCCESS)
    {
        goto Exit;
    }

    // enum through all the TIP subkeys
    for (uIndex = 0; TRUE; uIndex++)
    {
        bExistEnable = FALSE;

        cchClsid = sizeof(szTipClsid) / sizeof(TCHAR);

        if (RegEnumKeyEx(hkeyTip, uIndex,
                         szTipClsid, &cchClsid,
                         NULL, NULL, NULL, &lwt) != ERROR_SUCCESS)
        {
            break;
        }

        if (cchClsid != CLSID_STRLEN)
        {
            // string clsid subkeys should be like {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
            continue;
        }

        StringCchCopy(szTipClsidPath, ARRAYSIZE(szTipClsidPath), szTipClsid);

        // we want subkey\Language Profiles key
        StringCchCat(szTipClsidPath, ARRAYSIZE(szTipClsidPath), c_szLanguageProfile);

        // is this subkey a tip?
        if (RegOpenKeyEx(hkeyTip,
                         szTipClsidPath, 0,
                         KEY_READ, &hkeyTipSub) == ERROR_SUCCESS)
        {
            RegCloseKey(hkeyTipSub);

            // it's a tip, get the clsid
            if (CLSIDFromString((LPOLESTR )szTipClsid, &clsidTip) != NOERROR)
                continue;

            // special case certain known tips
            if (IsEqualGUID(&clsidTip, &CLSID_SapiLayr))
            {
                //
                // This is SAPI TIP and need to handle it specially, since sptip has
                // a default option as the enabled status.
                //
                if (!IsTIPClsidEnabled(HKEY_CURRENT_USER, szTipClsid, &bExistEnable))
                {
                    //
                    // If SPTIP has enable registry setting on HKCU with the disabled
                    // speech tip, we assume user intentionally disable it.
                    //
                    if (bExistEnable)
                        continue;
                }

                // this is the sapi tip, which is always installed
                // but it will not activate if sapi is not installed
                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 c_szSpeechRecognizersKey, 0,
                                 KEY_READ, &hkeyTipSub) != ERROR_SUCCESS)
                {
                    continue; // this tip doesn't count
                }

                // need 1 or more subkeys for sapi to be truely installed...whistler has a Tokens with nothing underneath
                if (RegQueryInfoKey(hkeyTipSub,
                                    NULL, NULL, NULL, &dwSubKeys, NULL,
                                    NULL, NULL, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
                {
                    dwSubKeys = 0; // assume no sub keys on failure
                }

                RegCloseKey(hkeyTipSub);

                if (dwSubKeys != 0)
                {
                    bRet = TRUE;
                    break;
                }
            }
            else if (IsEqualGUID(&clsidTip, &CLSID_SoftkbdIMX))
            {
                // don't count the softkbd, it is disabled until another tip
                // enables it
                continue;
            }
            else if(IsTIPClsidEnabled(HKEY_CURRENT_USER, szTipClsid, &bExistEnable))
            {
                bRet = TRUE;
                break;
            }
            else if (!bExistEnable)
            {
                if(IsTIPClsidEnabled(HKEY_LOCAL_MACHINE, szTipClsid, &bExistEnable))
                {
                   bRet = TRUE;
                   break;
                }
            }
        }
    }

    RegCloseKey(hkeyTip);


Exit:

    return bRet;
}

////////////////////////////////////////////////////////////////////////////
//
//  ResetImm32AndCtfImeFlag
//
////////////////////////////////////////////////////////////////////////////

void ResetImm32AndCtfIme()
{
    BOOL bTipInstalled;

    bTipInstalled = IsTipInstalled();

    if (bTipInstalled)
    {
        //
        // TIP is detected now, so automatically recover LoadImm
        // and CUAS to "On" status
        //
        SetDisableCUAS(FALSE);
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  LoadSystemLibrary
//
////////////////////////////////////////////////////////////////////////////

HMODULE LoadSystemLibrary(
    LPCTSTR lpModuleName)
{
    UINT uRet = 0;
    HINSTANCE hModule = NULL;
    TCHAR szModulePath[MAX_PATH + 1];

    szModulePath[0] = TEXT('\0');

    uRet = GetSystemDirectory(szModulePath, ARRAYSIZE(szModulePath));

    if (uRet >= ARRAYSIZE(szModulePath))
    {
        // we don't have a room to copy module name.
        uRet = 0;
    }
    else if (uRet)
    {
        if (szModulePath[uRet - 1] != TEXT('\\'))
        {
            szModulePath[uRet] = TEXT('\\');
            uRet++;
        }

        if (ARRAYSIZE(szModulePath) - uRet > (UINT) lstrlen(lpModuleName))
        {
            lstrcpyn(&szModulePath[uRet],
                     lpModuleName,
                     ARRAYSIZE(szModulePath) - uRet);
        }
        else
        {
            uRet = 0;
        }
    }

    if (uRet)
    {
        hModule = LoadLibrary(szModulePath);
    }

    return hModule;
}

////////////////////////////////////////////////////////////////////////////
//
//  LoadSystemLibraryEx
//
////////////////////////////////////////////////////////////////////////////

HMODULE LoadSystemLibraryEx(
    LPCTSTR lpModuleName,
    HANDLE hFile,
    DWORD dwFlags)
{
    UINT uRet = 0;
    HINSTANCE hModule = NULL;
    TCHAR szModulePath[MAX_PATH + 1];

    szModulePath[0] = TEXT('\0');

    uRet = GetSystemDirectory(szModulePath, ARRAYSIZE(szModulePath));

    if (uRet >= ARRAYSIZE(szModulePath))
    {
        // we don't have a room to copy module name.
        uRet = 0;
    }
    else if (uRet)
    {
        if (szModulePath[uRet - 1] != TEXT('\\'))
        {
            szModulePath[uRet] = TEXT('\\');
            uRet++;
        }

        if (ARRAYSIZE(szModulePath) - uRet > (UINT) lstrlen(lpModuleName))
        {
            lstrcpyn(&szModulePath[uRet],
                     lpModuleName,
                     ARRAYSIZE(szModulePath) - uRet);
        }
        else
        {
            uRet = 0;
        }
    }

    if (uRet)
    {
        hModule = LoadLibraryEx(szModulePath, hFile,dwFlags);
    }

    return hModule;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inputdll\resource.h ===
//
//  resource.h
//

#ifndef RESOURCE_H
#define RESOURCE_H


//
//  Icons.
//

#define IDI_ICON                       200
#define IDI_DEFAULT_CHECK              201
#define IDI_KEYBOARD                   202
#define IDI_SPEECH                     203
#define IDI_PEN                        204
#define IDI_TIPITEM                    205
#define IDI_EXTERNAL                   206
#define IDI_SMARTTAG                   207


//
//  Text String Constants.
//

#define IDS_NAME                       1
#define IDS_INFO                       2

#define IDS_REBOOT_STRING              10
#define IDS_TITLE_STRING               11

#define IDS_KBD_NO_DEF_LANG            50
#define IDS_KBD_NO_DEF_LANG2           51
#define IDS_KBD_SETUP_FAILED           52
#define IDS_KBD_LOAD_KBD_FAILED        53
#define IDS_KBD_UNLOAD_KBD_FAILED      54
#define IDS_KBD_NEED_LAYOUT            55
#define IDS_KBD_LOAD_LINE_BAD          56
#define IDS_KBD_NO_MORE_TO_ADD         57
#define IDS_KBD_LAYOUT_FAILED          58
#define IDS_KBD_SWITCH_LOCALE          59
#define IDS_KBD_SWITCH_TO              61
#define IDS_KBD_MOD_CONTROL            62
#define IDS_KBD_MOD_LEFT_ALT           63
#define IDS_KBD_MOD_SHIFT              64
#define IDS_KBD_CONFLICT_HOTKEY        65
#define IDS_KBD_INVALID_HOTKEY         66
#define IDS_KBD_LAYOUTEDIT             67
#define IDS_KBD_APPLY_WARN             68

#define IDS_LOCALE_LIST_ROOTNAME       80
#define IDS_LOCALE_DEFAULT             81
#define IDS_LOCALE_UNKNOWN             82
#define IDS_LOCALE_NOLAYOUT            83

#define IDS_DELETE_CONFIRMTITLE        100
#define IDS_DELETE_LANGNODE            101
#define IDS_NODELETE_CATEGORYITEM      102
#define IDS_ENABLE_CICERO              103
#define IDS_DISABLE_CICERO             104
#define IDS_DELETE_TIP                 105


#define IDS_ADVANCED_CUAS_TEXT         120
#define IDS_ADVANCED_CTFMON_TEXT       121

#define IDS_UNKNOWN                    200



//
//  Dialogs.
//

#define DLG_INPUT_LOCALES                        500

#define DLG_KEYBOARD_LOCALE_ADD                  501
#define DLG_KEYBOARD_LOCALE_EDIT                 502
#define DLG_KEYBOARD_HOTKEY_INPUT_LOCALE         503
#define DLG_KEYBOARD_HOTKEY_INPUT_LOCALE_THAI    504
#define DLG_KEYBOARD_HOTKEY_KEYBOARD_LAYOUT      505
#define DLG_KEYBOARD_HOTKEY_IME                  506
#define DLG_KEYBOARD_LOCALE_SIMPLE_ADD           507
#define DLG_KEYBOARD_HOTKEY_INPUT_LOCALE_ME      508
#define DLG_KEYBOARD_LOCALE_ADD_EXTRA            509

#define DLG_KEYBOARD_LOCALE_HOTKEY               510
#define DLG_TOOLBAR_SETTING                      511


#define DLG_INPUT_ADVANCED			 600

//
//  Misc. Controls.
//

#define IDC_STATIC                       -1


//
//  Input Locale Property Page Controls.
//

#define IDC_GROUPBOX1                  1100
#define IDC_LOCALE_DEFAULT             1101
#define IDC_LOCALE_DEFAULT_TEXT        1102
#define IDC_GROUPBOX2                  1103
#define IDC_INPUT_LIST                 1104
#define IDC_INPUT_LIST_TEXT            1105
#define IDC_GROUPBOX3                  1106

#define IDC_KBDL_INPUT_FRAME           1200
#define IDC_KBDL_LOCALE                1201
#define IDC_KBDL_LAYOUT_TEXT           1202
#define IDC_KBDL_ADD                   1204
#define IDC_KBDL_EDIT                  1205
#define IDC_KBDL_DELETE                1206
#define IDC_KBDL_DISABLED              1207
#define IDC_KBDL_DISABLED_2            1208
#define IDC_KBDL_CAPSLOCK_FRAME        1209
#define IDC_KBDL_CAPSLOCK              1210
#define IDC_KBDL_SHIFTLOCK             1211
#define IDC_KBDL_SET_DEFAULT           1213
#define IDC_KBDL_SHORTCUT_FRAME        1214
#define IDC_KBDL_ALT_SHIFT             1215
#define IDC_KBDL_CTRL_SHIFT            1216
#define IDC_KBDL_NO_SHIFT              1217
#define IDC_KBDL_INDICATOR             1218
#define IDC_KBDLA_LOCALE               1219
#define IDC_KBDLA_LOCALE_TEXT          1220
#define IDC_KBDLA_LAYOUT               1221
#define IDC_KBDLA_LAYOUT_TEXT          1222
#define IDC_KBDLE_LOCALE               1223
#define IDC_KBDLE_LOCALE_TEXT          1224
#define IDC_KBDLE_LAYOUT               1225
#define IDC_KBDLE_LAYOUT_TEXT          1226
#define IDC_KBDL_ONSCRNKBD             1227
#define IDC_KBDL_UP                    1228
#define IDC_KBDL_DOWN                  1229

#define IDC_KBDL_IME_SETTINGS          1230
#define IDC_KBDL_HOTKEY_LIST           1231
#define IDC_KBDL_HOTKEY_SEQUENCE       1232
#define IDC_KBDL_HOTKEY                1233
#define IDC_KBDL_HOTKEY_FRAME          1234
#define IDC_KBDL_CHANGE_HOTKEY         1235
#define IDC_KBDLH_KEY_COMBO            1236
#define IDC_KBDLH_CTRL                 1237
#define IDC_KBDLH_L_ALT                1238
#define IDC_KBDLH_SHIFT                1239
#define IDC_KBDLH_LAYOUT_TEXT          1240
#define IDC_KBDLH_ENABLE               1241
#define IDC_KBDLH_GRAVE                1242
#define IDC_KBDLH_VLINE                1243
#define IDC_KBDLH_PLUS                 1244
#define IDC_KBDLH_CTRL2                1245
#define IDC_KBDLH_L_ALT2               1246
#define IDC_KBDLH_SHIFT2               1247
#define IDC_KBDLH_PLUS2                1248
#define IDC_KBDLH_LANGHOTKEY           1249
#define IDC_KBDLH_LAYOUTHOTKEY         1250

#define IDC_PEN_TIP                    1300
#define IDC_PEN_TEXT                   1301

#define IDC_SPEECH_TIP                 1400
#define IDC_SPEECH_TEXT                1401
#define IDC_EXTERNAL_TIP               1450
#define IDC_EXTERNAL_TEXT              1451

#define IDC_ADVANCED_CUAS_ENABLE       1460
#define IDC_ADVANCED_CUAS_TEXT         1461
#define IDC_ADVANCED_CTFMON_DISABLE    1462
#define IDC_ADVANCED_CTFMON_TEXT       1463


#define IDS_INPUT_KEYBOARD             1500
#define IDS_INPUT_PEN                  1501
#define IDS_INPUT_SPEECH               1502
#define IDS_INPUT_EXTERNAL             1503



//
//  Input Locale Property Page HotKey Controls.
//
#define IDC_HOTKEY_SETTING             1600
#define IDC_TB_SETTING                 1601
#define IDC_TB_BEHAVIOR_FRAME          1602
#define IDC_TB_SHOWLANGBAR             1603
#define IDC_TB_EXTRAICON               1604
#define IDC_TB_SHRINK                  1605
#define IDC_TB_CLOSE                   1606
#define IDC_TB_TRANSPARENCY_FRAME      1607
#define IDC_TB_OPAQUE                  1608
#define IDC_TB_LOWTRANS                1609
#define IDC_TB_HIGHTRANS               1610
#define IDC_TB_LABELS_FRAME            1611
#define IDC_TB_TEXTLABELS              1612
#define IDC_TB_NOTEXTLABELS            1613
#define IDC_TB_DISABLETEXTSERVICE      1614



//
//  Hotkey Strings.
//

#define IDS_VK_NONE                    2200
#define IDS_VK_SPACE                   2201
#define IDS_VK_PRIOR                   2202
#define IDS_VK_NEXT                    2203
#define IDS_VK_END                     2204
#define IDS_VK_HOME                    2205
#define IDS_VK_F1                      2206
#define IDS_VK_F2                      2207
#define IDS_VK_F3                      2208
#define IDS_VK_F4                      2209
#define IDS_VK_F5                      2210
#define IDS_VK_F6                      2211
#define IDS_VK_F7                      2212
#define IDS_VK_F8                      2213
#define IDS_VK_F9                      2214
#define IDS_VK_F10                     2215
#define IDS_VK_F11                     2216
#define IDS_VK_F12                     2217
#define IDS_VK_OEM_SEMICLN             2218
#define IDS_VK_OEM_EQUAL               2219
#define IDS_VK_OEM_COMMA               2220
#define IDS_VK_OEM_MINUS               2221
#define IDS_VK_OEM_PERIOD              2222
#define IDS_VK_OEM_SLASH               2223
#define IDS_VK_OEM_3                   2224
#define IDS_VK_OEM_LBRACKET            2225
#define IDS_VK_OEM_BSLASH              2226
#define IDS_VK_OEM_RBRACKET            2227
#define IDS_VK_OEM_QUOTE               2228
#define IDS_VK_A                       2229
#define IDS_VK_NONE1                   (IDS_VK_A + 26)
#define IDS_VK_0                       (IDS_VK_A + 27)


//
// the below HOTKEYS are only for CHT IMEs
//
#define IDS_RESEND_RESULTSTR_CHT       2300
#define IDS_PREVIOUS_COMPOS_CHT        2302
#define IDS_UISTYLE_TOGGLE_CHT         2304
#define IDS_IME_NONIME_TOGGLE_CHT      2306
#define IDS_SHAPE_TOGGLE_CHT           2308
#define IDS_SYMBOL_TOGGLE_CHT          2310

//
// the below HOTKEYS are only for CHS IMEs
//
#define IDS_IME_NONIME_TOGGLE_CHS      2312
#define IDS_SHAPE_TOGGLE_CHS           2314
#define IDS_SYMBOL_TOGGLE_CHS          2316

#define IDS_KBD_SET_HOTKEY_ERR         2320

//
// NOTENOTE: Please reserve 5000 ~ 5999 range
// for the following IDs.
//
// the below are the strings for layout display names.
// They will have an offset of 5000 related to
// the names.  E.g. The values for KLT_1 will be
// 5001. The value for KLT_100 will be 5100.
//
// The strings and the names (KLT_1) are copied
// from intl.inx and intl.txt.  And these values
// should be kept in sync.
//
#define KLT_0                          5000 // US Keyboard.
#define KLT_1                          5001
#define KLT_2                          5002
#define KLT_3                          5003
#define KLT_4                          5004
#define KLT_5                          5005
#define KLT_6                          5006
#define KLT_7                          5007
#define KLT_8                          5008
#define KLT_9                          5009
#define KLT_10                          5010
#define KLT_11                          5011
#define KLT_12                          5012
#define KLT_13                          5013
#define KLT_14                          5014
#define KLT_15                          5015
#define KLT_16                          5016
#define KLT_17                          5017
#define KLT_18                          5018
#define KLT_19                          5019
#define KLT_20                          5020
#define KLT_21                          5021
#define KLT_22                          5022
#define KLT_23                          5023
#define KLT_24                          5024
#define KLT_25                          5025
#define KLT_26                          5026
#define KLT_27                          5027
#define KLT_28                          5028
#define KLT_29                          5029
#define KLT_30                          5030
#define KLT_31                          5031
#define KLT_32                          5032
#define KLT_33                          5033
#define KLT_34                          5034
#define KLT_35                          5035
#define KLT_36                          5036
#define KLT_37                          5037
#define KLT_38                          5038
#define KLT_39                          5039
#define KLT_40                          5040
#define KLT_41                          5041
#define KLT_42                          5042
#define KLT_43                          5043
#define KLT_44                          5044
#define KLT_45                          5045
#define KLT_46                          5046
#define KLT_47                          5047
#define KLT_48                          5048
#define KLT_49                          5049
#define KLT_50                          5050
#define KLT_51                          5051
#define KLT_52                          5052
#define KLT_53                          5053
#define KLT_54                          5054
#define KLT_55                          5055
#define KLT_56                          5056
#define KLT_57                          5057
#define KLT_58                          5058
#define KLT_59                          5059
#define KLT_60                          5060
#define KLT_61                          5061
#define KLT_62                          5062
#define KLT_63                          5063
#define KLT_64                          5064
#define KLT_65                          5065
#define KLT_66                          5066
#define KLT_67                          5067
#define KLT_68                          5068
#define KLT_69                          5069
#define KLT_70                          5070
#define KLT_71                          5071
#define KLT_72                          5072
#define KLT_73                          5073
#define KLT_74                          5074
#define KLT_75                          5075
#define KLT_76                          5076
#define KLT_77                          5077
#define KLT_78                          5078
#define KLT_79                          5079
#define KLT_80                          5080
#define KLT_81                          5081
#define KLT_82                          5082
#define KLT_83                          5083
#define KLT_84                          5084
#define KLT_85                          5085
#define KLT_86                          5086
#define KLT_87                          5087
#define KLT_88                          5088
#define KLT_89                          5089
#define KLT_90                          5090
#define KLT_91                          5091
#define KLT_92                          5092
#define KLT_93                          5093
#define KLT_94                          5094
#define KLT_95                          5095
#define KLT_96                          5096
#define KLT_97                          5097
#define KLT_98                          5098
#define KLT_99                          5099
#define KLT_100                          5100
#define KLT_101                          5101
#define KLT_102                          5102
#define KLT_103                          5103
#define KLT_104                          5104
#define KLT_105                          5105
#define KLT_106                          5106
#define KLT_107                          5107
#define KLT_108                          5108
#define KLT_109                          5109
#define KLT_110                          5110
#define KLT_111                          5111
#define KLT_112                          5112
#define KLT_113                          5113
#define KLT_114                          5114
#define KLT_115                          5115
#define KLT_116                          5116
#define KLT_117                          5117
#define KLT_118                          5118
#define KLT_119                          5119
#define KLT_120                          5120
#define KLT_121                          5121
#define KLT_122                          5122
#define KLT_123                          5123
#define KLT_124                          5124
#define KLT_125                          5125
#define KLT_126                          5126
#define KLT_127                          5127
#define KLT_128                          5128
#define KLT_129                          5129
#define KLT_130                          5130
#define KLT_131                          5131
#define KLT_132                          5132
#define KLT_133                          5133
#define KLT_134                          5134

#endif // RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\inputdll\util.h ===
//
//  Include Files.
//

#ifndef UTIL_H
#define UTIL_H

BOOL CLSIDToStringA(
    REFGUID refGUID,
    char *pchA);

DWORD TransNum(
    LPTSTR lpsz);

BOOL IsOSPlatform(
    DWORD dwOS);

void MirrorBitmapInDC(
    HDC hdc,
    HBITMAP hbmOrig);

BOOL IsSetupMode();
BOOL IsAdminPrivilegeUser();
BOOL IsInteractiveUserLogon();

BOOL IsValidLayout(
    DWORD dwLayout);

void SetLangBarOption(
   DWORD dwShowStatus,
   BOOL bDefUser);

BOOL GetLangBarOption(
   DWORD *dwShowStatus,
   BOOL bDefUser);

void CheckInternatModule();
DWORD MigrateCtfmonFromWin9x(LPCTSTR pszUserKey);
void ResetImm32AndCtfImeFlag();


BOOL IsDisableCtfmon();

void SetDisalbeCtfmon(
   DWORD dwDisableCtfmon);

BOOL IsDisableCTFIME();
BOOL IsDisableCUAS();

void SetDisableCUAS(
    BOOL bDisableCUAS);

BOOL SetLanguageBandMenu(
    BOOL bLoad);

BOOL RunCtfmonProcess();

UINT GetCtfmonPath(
    LPTSTR szCtfmonPath,
    UINT uBuffLen);

BOOL IsInstalledEALangPack();
BOOL IsTipInstalled();

HMODULE LoadSystemLibrary(
    LPCTSTR lpModuleName);

HMODULE LoadSystemLibraryEx(
    LPCTSTR lpModuleName,
    HANDLE hFile,
    DWORD dwFlags);

#endif // UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\ats.cpp ===
//
// ats.cpp
//

#include "private.h"
#include "ats.h"
#include "helpers.h"

//////////////////////////////////////////////////////////////////////////////
//
// CActiveLanguageProfileNotifySink
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CActiveLanguageProfileNotifySink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfActiveLanguageProfileNotifySink))
    {
        *ppvObj = SAFECAST(this, CActiveLanguageProfileNotifySink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CActiveLanguageProfileNotifySink::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CActiveLanguageProfileNotifySink::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CActiveLanguageProfileNotifySink::CActiveLanguageProfileNotifySink(ALSCALLBACK pfn, void *pv)
{
    Dbg_MemSetThisName(TEXT("CActiveLanguageProfileNotifySink"));

    _cRef = 1;
    _dwCookie = ALS_INVALID_COOKIE;
 
    _pfn = pfn;
    _pv = pv;
}

//+---------------------------------------------------------------------------
//
// OnUpdated
//
//----------------------------------------------------------------------------

STDAPI CActiveLanguageProfileNotifySink::OnActivated(REFCLSID clsid, REFGUID guidProfile, BOOL bActivated)
{
    return _pfn ? _pfn(clsid, guidProfile, bActivated, _pv) : S_OK;
}

//+---------------------------------------------------------------------------
//
// CActiveLanguageProfileNotifySink::Advise
//
//----------------------------------------------------------------------------

HRESULT CActiveLanguageProfileNotifySink::_Advise(ITfThreadMgr *ptim)
{
    HRESULT hr;
    ITfSource *source = NULL;

    _ptim = NULL;
    hr = E_FAIL;

    if (FAILED(ptim->QueryInterface(IID_ITfSource, (void **)&source)))
        goto Exit;

    if (FAILED(source->AdviseSink(IID_ITfActiveLanguageProfileNotifySink, this, &_dwCookie)))
        goto Exit;

    _ptim = ptim;
    _ptim->AddRef();

    hr = S_OK;

Exit:
    SafeRelease(source);
    return hr;
}

//+---------------------------------------------------------------------------
//
// CActiveLanguageProfileNotifySink::Unadvise
//
//----------------------------------------------------------------------------

HRESULT CActiveLanguageProfileNotifySink::_Unadvise()
{
    HRESULT hr;
    ITfSource *source = NULL;

    hr = E_FAIL;

    if (_ptim == NULL)
        goto Exit;

    if (FAILED(_ptim->QueryInterface(IID_ITfSource, (void **)&source)))
        goto Exit;

    if (FAILED(source->UnadviseSink(_dwCookie)))
        goto Exit;

    hr = S_OK;

Exit:
    SafeRelease(source);
    SafeReleaseClear(_ptim);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\cicutil.cpp ===
#include "private.h"
#include "immxutil.h"
#include "cicutil.h"
#include "mui.h"


#define SP1_BEGIN_RC_ID                 10000
#define SP1_END_RC_ID                   20000


HINSTANCE g_hInstXPSP1Res = NULL;


////////////////////////////////////////////////////////////////////////////
//
// IsXPSP1ResourceID
//
////////////////////////////////////////////////////////////////////////////

BOOL IsXPSP1ResourceID(UINT uId)
{
    BOOL bRet = FALSE;

    if (uId >= SP1_BEGIN_RC_ID && uId <= SP1_END_RC_ID)
    {
        bRet = TRUE;
    }

    return bRet;
}

////////////////////////////////////////////////////////////////////////////
//
//  GetCicResInstance()
//
////////////////////////////////////////////////////////////////////////////

HINSTANCE GetCicResInstance(HINSTANCE hInstOrg, UINT uId)
{
#ifdef CIC_XPSP1
    if (IsXPSP1ResourceID(uId))
    {
        if (!g_hInstXPSP1Res)
        {
            g_hInstXPSP1Res = LoadSystemLibraryEx(TEXT("xpsp1res.dll"),
                                                NULL,
                                                LOAD_LIBRARY_AS_DATAFILE);
        }

        return g_hInstXPSP1Res;
    }
    else
    {
        return hInstOrg;
    }
#else
    return hInstOrg;
#endif
}

////////////////////////////////////////////////////////////////////////////
//
//  FreeCicResInstance()
//
////////////////////////////////////////////////////////////////////////////
void FreeCicResInstance()
{
#ifdef CIC_XPSP1
    if (g_hInstXPSP1Res)
        FreeLibrary(g_hInstXPSP1Res);
#endif // CIC_XPSP1
}


////////////////////////////////////////////////////////////////////////////
//
// CicLoadStringA
//
////////////////////////////////////////////////////////////////////////////

int CicLoadStringA(HINSTANCE hInstOrg, UINT uId, LPSTR lpBuffer, UINT cchMax)
{
    HINSTANCE hResInst = GetCicResInstance(hInstOrg, uId);

    return LoadStringA(hResInst, uId, lpBuffer, cchMax);
}


////////////////////////////////////////////////////////////////////////////
//
// CicLoadStringWrapW
//
////////////////////////////////////////////////////////////////////////////

int CicLoadStringWrapW(HINSTANCE hInstOrg, UINT uId, LPWSTR lpwBuffer, UINT cchMax)
{
    HINSTANCE hResInst = GetCicResInstance(hInstOrg, uId);

    return LoadStringWrapW(hResInst, uId, lpwBuffer, cchMax);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\combase.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       combase.cpp
//
//  Contents:   COM server functionality.
//
//----------------------------------------------------------------------------

#include "private.h"
#include "combase.h"
#include "regsvr.h"

extern CClassFactory *g_ObjectInfo[];

LONG g_cRefDll = -1; // -1 /w no refs, for win95 InterlockedIncrement/Decrement compat

void FreeGlobalObjects(void);

//+---------------------------------------------------------------------------
//
//  DllAddRef
//
//----------------------------------------------------------------------------

void DllAddRef(void)
{
    if (InterlockedIncrement(&g_cRefDll) == 0) // g_cRefDll == -1 with zero refs
    {
        DllInit();
    }
}

//+---------------------------------------------------------------------------
//
//  DllRelease
//
//----------------------------------------------------------------------------

void DllRelease(void)
{
    if (InterlockedDecrement(&g_cRefDll) < 0) // g_cRefDll == -1 with zero refs
    {
        EnterCriticalSection(GetServerCritSec());

        // need to check ref again after grabbing mutex
        if (g_ObjectInfo[0] != NULL)
        {
            FreeGlobalObjects();
        }
        Assert(g_cRefDll == -1);

        LeaveCriticalSection(GetServerCritSec());

        DllUninit();
    }
}

//+---------------------------------------------------------------------------
//
//  CClassFactory declaration with IClassFactory Interface
//
//----------------------------------------------------------------------------

class CClassFactory : public IClassFactory
{
public:
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IClassFactory methods
    STDMETHODIMP CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);
    STDMETHODIMP LockServer(BOOL fLock);

    // Constructor
    CClassFactory(const CLSID *pclsid, HRESULT (*pfnCreateInstance)(IUnknown *pUnkOuter, REFIID riid, void **ppvObj))
        : _pclsid(pclsid)
    {
        _pfnCreateInstance = pfnCreateInstance;
    }

public:
    const CLSID *_pclsid;
    HRESULT (*_pfnCreateInstance)(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);
};

//+---------------------------------------------------------------------------
//
//  CClassFactory::QueryInterface
//
//----------------------------------------------------------------------------

STDAPI CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = this;
        DllAddRef();
        return NOERROR;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//
//  CClassFactory::AddRef
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CClassFactory::AddRef()
{
    DllAddRef();
    return g_cRefDll+1; // -1 w/ no refs
}

//+---------------------------------------------------------------------------
//
//  CClassFactory::Release
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CClassFactory::Release()
{
    DllRelease();
    return g_cRefDll+1; // -1 w/ no refs
}

//+---------------------------------------------------------------------------
//
//  CClassFactory::CreateInstance
//
//----------------------------------------------------------------------------

STDAPI CClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    return _pfnCreateInstance(pUnkOuter, riid, ppvObj);
}

//+---------------------------------------------------------------------------
//
//  CClassFactory::LockServer
//
//----------------------------------------------------------------------------

STDAPI CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
    {
        DllAddRef();
    }
    else
    {
        DllRelease();
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  BuildGlobalObjects
//
//----------------------------------------------------------------------------

void BuildGlobalObjects(void)
{
    const OBJECT_ENTRY *pEntry;
    int i;
    // Build CClassFactory Objects

    i = 0;
    for (pEntry = &c_rgCoClassFactoryTable[0]; pEntry->pfnCreateInstance != NULL; pEntry++)
    {
        g_ObjectInfo[i++] = new CClassFactory(pEntry->pclsid, pEntry->pfnCreateInstance);
    }
    // You can add more object info here.
    // Don't forget to increase number of item for g_ObjectInfo[],
}

//+---------------------------------------------------------------------------
//
//  FreeGlobalObjects
//
//----------------------------------------------------------------------------

void FreeGlobalObjects(void)
{
    const OBJECT_ENTRY *pEntry;

    pEntry = &c_rgCoClassFactoryTable[0];

    // Free CClassFactory Objects
    // we know the size of g_ObjectInfo must match c_rgCoClassFactoryTable, which is null terminated
    for (int i = 0; pEntry->pfnCreateInstance != NULL; i++, pEntry++)
    {
        if (NULL != g_ObjectInfo[i])
        {
            delete g_ObjectInfo[i];
            g_ObjectInfo[i] = NULL;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  DllGetClassObject
//
//----------------------------------------------------------------------------

HRESULT COMBase_DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppvObj)
{
    const OBJECT_ENTRY *pEntry;

    if (ppvObj == NULL)
        return E_INVALIDARG;

    if (g_ObjectInfo[0] == NULL)
    {
        EnterCriticalSection(GetServerCritSec());

            // need to check ref again after grabbing mutex
            if (g_ObjectInfo[0] == NULL)
            {
                BuildGlobalObjects();
            }

        LeaveCriticalSection(GetServerCritSec());
    }

    if (IsEqualIID(riid, IID_IClassFactory) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        // we know the size of g_ObjectInfo must match c_rgCoClassFactoryTable, which is null terminated
        pEntry = &c_rgCoClassFactoryTable[0];
        for (int i = 0; pEntry->pfnCreateInstance != NULL; i++, pEntry++)
        {
            if (NULL != g_ObjectInfo[i] &&
                IsEqualGUID(rclsid, *g_ObjectInfo[i]->_pclsid))
            {
                *ppvObj = (void *)g_ObjectInfo[i];
                DllAddRef();    // class factory holds DLL ref count
                return NOERROR;
            }
        }
    }

    *ppvObj = NULL;

    return CLASS_E_CLASSNOTAVAILABLE;
}

//+---------------------------------------------------------------------------
//
//  DllCanUnloadNow
//
//----------------------------------------------------------------------------

HRESULT COMBase_DllCanUnloadNow(void)
{
    if (g_cRefDll >= 0) // -1 with no refs
        return S_FALSE;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  DllRegisterServer
//
//----------------------------------------------------------------------------

HRESULT COMBase_DllRegisterServer(void)
{
    const OBJECT_ENTRY *pEntry;
    TCHAR achPath[MAX_PATH+1];
    HRESULT hr = E_FAIL;
    
    if (GetModuleFileName(GetServerHINSTANCE(), achPath, ARRAYSIZE(achPath)) == 0)
        goto Exit;
    achPath[ARRAYSIZE(achPath)-1] = 0;

    for (pEntry = &c_rgCoClassFactoryTable[0]; pEntry->pfnCreateInstance != NULL; pEntry++)
    {
        if (!RegisterServer(*pEntry->pclsid, pEntry->pszDesc, achPath, TEXT("Apartment"), NULL))
            goto Exit;
    }

    hr = S_OK;

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  DllUnregisterServer
//
//----------------------------------------------------------------------------

HRESULT COMBase_DllUnregisterServer(void)
{
    const OBJECT_ENTRY *pEntry;
    HRESULT hr = E_FAIL;
    
    for (pEntry = &c_rgCoClassFactoryTable[0]; pEntry->pfnCreateInstance != NULL; pEntry++)
    {
        if (FAILED(hr = RegisterServer(*pEntry->pclsid, NULL, NULL, NULL, NULL) ? S_OK : E_FAIL))
            goto Exit;
    }

    hr = S_OK;

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\computil.cpp ===
//
// computil.cpp
//

#include "private.h"
#include "computil.h"
#include "catutil.h"
#include "helpers.h"

ITfCategoryMgr *GetUIMCat();

//+---------------------------------------------------------------------------
//
//  GetCompartment
//
//----------------------------------------------------------------------------

HRESULT GetCompartment(IUnknown *punk, REFGUID rguidComp, ITfCompartment **ppComp, BOOL fGlobal)
{
    HRESULT hr = E_FAIL;
    ITfCompartmentMgr *pCompMgr = NULL;
    ITfThreadMgr *ptim = NULL;

    Assert(ppComp);
    *ppComp = NULL;

    if (fGlobal)
    {
        if (FAILED(hr = punk->QueryInterface(IID_ITfThreadMgr,
                                                (void **)&ptim)))
             goto Exit;

        if (FAILED(hr = ptim->GetGlobalCompartment(&pCompMgr)))
             goto Exit;
        
    }
    else
    {
        if (FAILED(hr = punk->QueryInterface(IID_ITfCompartmentMgr,
                                                (void **)&pCompMgr)))
             goto Exit;
    }

    if (SUCCEEDED(hr) && pCompMgr)
    {
        hr = pCompMgr->GetCompartment(rguidComp, ppComp);
        pCompMgr->Release();
    }
    else
        hr = E_FAIL;

Exit:
    if (ptim)
       ptim->Release();

    return hr;
}


//+---------------------------------------------------------------------------
//
//  SetCompartmentDWORD
//
//----------------------------------------------------------------------------

HRESULT SetCompartmentDWORD(TfClientId tid, IUnknown *punk, REFGUID rguidComp, DWORD dw, BOOL fGlobal)
{
    HRESULT hr;
    ITfCompartment *pComp;
    VARIANT var;

    if (SUCCEEDED(hr = GetCompartment(punk, rguidComp, &pComp, fGlobal)))
    {
        var.vt = VT_I4;
        var.lVal = dw;
        hr = pComp->SetValue(tid, &var);
        pComp->Release();
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  GetCompartmentDWORD
//
//----------------------------------------------------------------------------

HRESULT GetCompartmentDWORD(IUnknown *punk, REFGUID rguidComp, DWORD *pdw, BOOL fGlobal)
{
    HRESULT hr;
    ITfCompartment *pComp;
    VARIANT var;

    *pdw = 0;
    if (SUCCEEDED(hr = GetCompartment(punk, rguidComp, &pComp, fGlobal)))
    {
        if ((hr = pComp->GetValue(&var)) == S_OK)
        {
            Assert(var.vt == VT_I4);
            *pdw = var.lVal;
        }
        pComp->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  ToggleCompartmentDWORD
//
//  Toggle DWORD value between 0 and 1.
//
//----------------------------------------------------------------------------

HRESULT ToggleCompartmentDWORD(TfClientId tid, IUnknown *punk, REFGUID rguidComp, BOOL fGlobal)
{
    HRESULT hr;
    ITfCompartment *pComp;
    VARIANT var;

    if (SUCCEEDED(hr = GetCompartment(punk, rguidComp, &pComp, fGlobal)))
    {
        if ((hr = pComp->GetValue(&var)) == S_OK)
        {
            Assert(var.vt == VT_I4);
            var.lVal = !var.lVal;
            hr = pComp->SetValue(tid, &var);
        }
        else
        {
            var.vt = VT_I4;
            var.lVal = 0x01;
            hr = pComp->SetValue(tid, &var);
        }
        pComp->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  SetCompartmentGUIDATOM
//
//----------------------------------------------------------------------------

HRESULT SetCompartmentGUIDATOM(TfClientId tid, IUnknown *punk, REFGUID rguidComp, TfGuidAtom guidatom, BOOL fGlobal)
{
    HRESULT hr;
    ITfCompartment *pComp;
    VARIANT var;

    if (SUCCEEDED(hr = GetCompartment(punk, rguidComp, &pComp, fGlobal)))
    {
        var.vt = VT_I4;
        var.lVal = guidatom;
        hr = pComp->SetValue(tid, &var);
        pComp->Release();
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  GetCompartmentGUIDATOM
//
//----------------------------------------------------------------------------

HRESULT GetCompartmentGUIDATOM(IUnknown *punk, REFGUID rguidComp, TfGuidAtom *pga, BOOL fGlobal)
{
    HRESULT hr;
    ITfCompartment *pComp;
    VARIANT var;

    *pga = 0;
    if (SUCCEEDED(hr = GetCompartment(punk, rguidComp, &pComp, fGlobal)))
    {
        if ((hr = pComp->GetValue(&var)) == S_OK)
        {
            Assert(var.vt == VT_I4);
            *pga = (TfGuidAtom)var.lVal;;
        }
        pComp->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  SetCompartmentGUID
//
//----------------------------------------------------------------------------

HRESULT SetCompartmentGUID(LIBTHREAD *plt, TfClientId tid, IUnknown *punk, REFGUID rguidComp, REFGUID rguid, BOOL fGlobal)
{
    TfGuidAtom ga;

    if (!GetGUIDATOMFromGUID(plt, rguid, &ga))
        return E_FAIL;

    if (FAILED(SetCompartmentGUIDATOM(tid, punk, rguidComp, ga, fGlobal)))
        return E_FAIL;
    
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  GetCompartmentGUID
//
//----------------------------------------------------------------------------

HRESULT GetCompartmentGUID(LIBTHREAD *plt, IUnknown *punk, REFGUID rguidComp, GUID *pguid, BOOL fGlobal)
{
    TfGuidAtom ga;
    if (FAILED(GetCompartmentGUIDATOM(punk, rguidComp, &ga, fGlobal)))
        return E_FAIL;
    
    if (GetGUIDFromGUIDATOM(plt, ga, pguid))
        return S_OK;

    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  GetCompartmentUnknown
//
//----------------------------------------------------------------------------

HRESULT GetCompartmentUnknown(IUnknown *punk, REFGUID rguidComp, IUnknown **ppunk)
{
    HRESULT hr;
    ITfCompartment *pComp;
    VARIANT var;

    *ppunk = NULL;
    if (SUCCEEDED(hr = GetCompartment(punk, rguidComp, &pComp, FALSE)))
    {
        if ((hr = pComp->GetValue(&var)) == S_OK)
        {
            Assert(var.vt == VT_UNKNOWN);
            *ppunk = var.punkVal;
        }
        pComp->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  SetCompartmentUnknown
//
//----------------------------------------------------------------------------

HRESULT SetCompartmentUnknown(TfClientId tid, IUnknown *punk, REFGUID rguidComp, IUnknown *punkPriv)
{
    HRESULT hr;
    ITfCompartment *pComp;
    VARIANT var;

    if (SUCCEEDED(hr = GetCompartment(punk, rguidComp, &pComp, FALSE)))
    {
        var.vt = VT_UNKNOWN;
        var.punkVal = punkPriv;
        hr = pComp->SetValue(tid, &var);
        pComp->Release();
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  ClearCompartment
//
//----------------------------------------------------------------------------

HRESULT ClearCompartment(TfClientId tid, IUnknown *punk, REFGUID rguidComp, BOOL fGlobal)
{
    HRESULT hr = E_FAIL;
    ITfCompartmentMgr *pCompMgr = NULL;
    ITfThreadMgr *ptim = NULL;

    if (fGlobal)
    {
        if (FAILED(hr = punk->QueryInterface(IID_ITfThreadMgr,
                                                (void **)&ptim)))
             goto Exit;

        if (FAILED(hr = ptim->GetGlobalCompartment(&pCompMgr)))
             goto Exit;
        
    }
    else
    {
        if (FAILED(hr = punk->QueryInterface(IID_ITfCompartmentMgr,
                                                (void **)&pCompMgr)))
             goto Exit;
    }

    if (SUCCEEDED(hr) && pCompMgr)
    {
        hr = pCompMgr->ClearCompartment(tid, rguidComp);
        pCompMgr->Release();
    }
    else
        hr = E_FAIL;

Exit:
    if (ptim)
       ptim->Release();

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CCompartmentEventSink
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CCompartmentEventSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfCompartmentEventSink))
    {
        *ppvObj = SAFECAST(this, ITfCompartmentEventSink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CCompartmentEventSink::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CCompartmentEventSink::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CCompartmentEventSink::CCompartmentEventSink(CESCALLBACK pfnCallback, void *pv)
{
    Dbg_MemSetThisName(TEXT("CCompartmentEventSink"));

    _cRef = 1;

    _pfnCallback = pfnCallback;
    _pv = pv;
}

//+---------------------------------------------------------------------------
//
// OnChange
//
//----------------------------------------------------------------------------

STDAPI CCompartmentEventSink::OnChange(REFGUID rguid)
{
    return _pfnCallback(_pv, rguid);
}

//+---------------------------------------------------------------------------
//
// CCompartmentEventSink::Advise
//
//----------------------------------------------------------------------------

HRESULT CCompartmentEventSink::_Advise(IUnknown *punk, REFGUID rguidComp, BOOL fGlobal)
{
    HRESULT hr;
    ITfSource *pSource = NULL;
    CESMAP *pcesmap;
    pcesmap = _rgcesmap.Append(1);
    if (!pcesmap)
        return E_OUTOFMEMORY;

    hr = E_FAIL;

    if (FAILED(hr = GetCompartment(punk, rguidComp, &pcesmap->pComp, fGlobal)))
        goto Exit;

    if (FAILED(hr = pcesmap->pComp->QueryInterface(IID_ITfSource, (void **)&pSource)))
        goto Exit;

    if (FAILED(hr = pSource->AdviseSink(IID_ITfCompartmentEventSink, (ITfCompartmentEventSink *)this, &pcesmap->dwCookie)))
        goto Exit;

    hr = S_OK;

Exit:
    if (FAILED(hr))
    {
        int nCnt;
        SafeReleaseClear(pcesmap->pComp);
        nCnt = _rgcesmap.Count();
        _rgcesmap.Remove(nCnt - 1, 1);
    }

    SafeRelease(pSource);
    return hr;
}

//+---------------------------------------------------------------------------
//
// CCompartmentEventSink::Unadvise
//
//----------------------------------------------------------------------------

HRESULT CCompartmentEventSink::_Unadvise()
{
    HRESULT hr;
    int nCnt;
    CESMAP *pcesmap;

    hr = E_FAIL;


    nCnt = _rgcesmap.Count();
    pcesmap = _rgcesmap.GetPtr(0);

    while (nCnt)
    {
        ITfSource *pSource = NULL;
        if (FAILED(pcesmap->pComp->QueryInterface(IID_ITfSource, (void **)&pSource)))
            goto Next;

        if (FAILED(pSource->UnadviseSink(pcesmap->dwCookie)))
            goto Next;

Next:
        SafeReleaseClear(pcesmap->pComp);
        SafeRelease(pSource);
        nCnt--;
        pcesmap++;
    }

    hr = S_OK;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\catutil.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       catutil.cpp
//
//
//----------------------------------------------------------------------------

#include "private.h"
#include "globals.h"
#include "catutil.h"

//+---------------------------------------------------------------------------
//
//  GetUIMCat
//
//----------------------------------------------------------------------------
ITfCategoryMgr *GetUIMCat(LIBTHREAD *plt) 
{
    if (!plt)
       return NULL;

    if (plt->_pcat)
       return plt->_pcat;
   
    if (SUCCEEDED(g_pfnCoCreate(CLSID_TF_CategoryMgr,
                                   NULL, 
                                   CLSCTX_INPROC_SERVER, 
                                   IID_ITfCategoryMgr, 
                                   (void**)&plt->_pcat)))
       return plt->_pcat;

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  IsEqualTFGUIDATOM
//
//----------------------------------------------------------------------------
BOOL IsEqualTFGUIDATOM(LIBTHREAD *plt, TfGuidAtom guidatom, REFGUID rguid)
{
    BOOL fEqual = FALSE;
    ITfCategoryMgr *pcat = GetUIMCat(plt);

    if (pcat != NULL)
    {
        pcat->IsEqualTfGuidAtom(guidatom, rguid, &fEqual);
    }

    return fEqual;
}

//+---------------------------------------------------------------------------
//
//  GetGUIDFromGUIDATOM
//
//----------------------------------------------------------------------------
BOOL GetGUIDFromGUIDATOM(LIBTHREAD *plt, TfGuidAtom guidatom, GUID *pguid)
{
    ITfCategoryMgr *pcat = GetUIMCat(plt);

    if (pcat == NULL)
        return FALSE;

    return (pcat->GetGUID(guidatom, pguid) == S_OK);
}

//+---------------------------------------------------------------------------
//
//  GetGUIDATOMFromGUID
//
//----------------------------------------------------------------------------
BOOL GetGUIDATOMFromGUID(LIBTHREAD *plt, REFGUID rguid, TfGuidAtom *pguidatom)
{
    ITfCategoryMgr *pcat = GetUIMCat(plt);

    if (pcat == NULL)
        return FALSE;

    return (pcat->RegisterGUID(rguid, pguidatom) == S_OK);
}

//+---------------------------------------------------------------------------
//
//  LibEnumCategoriesInItem
//
//----------------------------------------------------------------------------

HRESULT LibEnumCategoriesInItem(LIBTHREAD *plt, REFGUID rguid, IEnumGUID **ppEnum)
{
    ITfCategoryMgr *pcat = GetUIMCat(plt);

    if (pcat == NULL)
        return E_FAIL;

    return pcat->EnumCategoriesInItem(rguid, ppEnum);
}

//+---------------------------------------------------------------------------
//
//  LibEnumCategoriesInItem 
//
//----------------------------------------------------------------------------

HRESULT LibEnumItemsInCategory(LIBTHREAD *plt, REFGUID rcatid, IEnumGUID **ppEnum)
{
    ITfCategoryMgr *pcat = GetUIMCat(plt);

    if (pcat == NULL)
        return E_FAIL;

    return pcat->EnumItemsInCategory(rcatid, ppEnum);
}


//+---------------------------------------------------------------------------
//
// RegisterGUIDDescription
//
//----------------------------------------------------------------------------

HRESULT RegisterGUIDDescription(REFCLSID rclsid, REFGUID rcatid, WCHAR *pszDesc)
{
    ITfCategoryMgr *pcat;
    HRESULT hr;

    if (SUCCEEDED(hr = g_pfnCoCreate(CLSID_TF_CategoryMgr,
                                   NULL, 
                                   CLSCTX_INPROC_SERVER, 
                                   IID_ITfCategoryMgr, 
                                   (void**)&pcat)))
    {
        hr = pcat->RegisterGUIDDescription(rclsid, rcatid, pszDesc, wcslen(pszDesc));
        pcat->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// UnregisterGUIDDescription
//
//----------------------------------------------------------------------------

HRESULT UnregisterGUIDDescription(REFCLSID rclsid, REFGUID rcatid)
{
    ITfCategoryMgr *pcat;
    HRESULT hr;

    if (SUCCEEDED(hr = g_pfnCoCreate(CLSID_TF_CategoryMgr,
                                   NULL, 
                                   CLSCTX_INPROC_SERVER, 
                                   IID_ITfCategoryMgr, 
                                   (void**)&pcat)))
    {
        hr = pcat->UnregisterGUIDDescription(rclsid, rcatid);
        pcat->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetGUIDDescription
//
//----------------------------------------------------------------------------

HRESULT GetGUIDDescription(LIBTHREAD *plt, REFCLSID rclsid, BSTR *pbstr)
{
    ITfCategoryMgr *pcat = GetUIMCat(plt);
    HRESULT hr = E_FAIL;

    Assert(pcat);

    if (pcat)
        hr = pcat->GetGUIDDescription(rclsid, pbstr);

    return hr;
}

//+---------------------------------------------------------------------------
//
// RegisterGUIDDWORD
//
//----------------------------------------------------------------------------

HRESULT RegisterGUIDDWORD(REFCLSID rclsid, REFGUID rcatid, DWORD dw)
{
    ITfCategoryMgr *pcat;
    HRESULT hr;

    if (SUCCEEDED(hr = g_pfnCoCreate(CLSID_TF_CategoryMgr,
                                   NULL, 
                                   CLSCTX_INPROC_SERVER, 
                                   IID_ITfCategoryMgr, 
                                   (void**)&pcat)))
    {
        hr = pcat->RegisterGUIDDWORD(rclsid, rcatid, dw);
        pcat->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// UnregisterGUIDDWORD
//
//----------------------------------------------------------------------------

HRESULT UnregisterGUIDDWORD(REFCLSID rclsid, REFGUID rcatid)
{
    ITfCategoryMgr *pcat;
    HRESULT hr;

    if (SUCCEEDED(hr = g_pfnCoCreate(CLSID_TF_CategoryMgr,
                                   NULL, 
                                   CLSCTX_INPROC_SERVER, 
                                   IID_ITfCategoryMgr, 
                                   (void**)&pcat)))
    {
        hr = pcat->UnregisterGUIDDWORD(rclsid, rcatid);
        pcat->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetGUIDDWORD
//
//----------------------------------------------------------------------------

HRESULT GetGUIDDWORD(LIBTHREAD *plt, REFCLSID rclsid, DWORD *pdw)
{
    ITfCategoryMgr *pcat = GetUIMCat(plt);
    HRESULT hr = E_FAIL;

    Assert(pcat);

    if (pcat)
        hr = pcat->GetGUIDDWORD(rclsid, pdw);

    return hr;
}

//+---------------------------------------------------------------------------
//
// RegisterCategory
//
//----------------------------------------------------------------------------

HRESULT RegisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid)
{
    ITfCategoryMgr *pcat;
    HRESULT hr;

    if (SUCCEEDED(hr = g_pfnCoCreate(CLSID_TF_CategoryMgr,
                                   NULL, 
                                   CLSCTX_INPROC_SERVER, 
                                   IID_ITfCategoryMgr, 
                                   (void**)&pcat)))
    {
        hr = pcat->RegisterCategory(rclsid, rcatid, rguid);
        pcat->Release();
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
// UnregisterCategory
//
//----------------------------------------------------------------------------

HRESULT UnregisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid)
{
    ITfCategoryMgr *pcat;
    HRESULT hr;

    if (SUCCEEDED(hr = g_pfnCoCreate(CLSID_TF_CategoryMgr,
                                   NULL, 
                                   CLSCTX_INPROC_SERVER, 
                                   IID_ITfCategoryMgr, 
                                   (void**)&pcat)))
    {
        hr = pcat->UnregisterCategory(rclsid, rcatid, rguid);
        pcat->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// UnregisterCategory
//
//----------------------------------------------------------------------------

HRESULT RegisterCategories(REFCLSID rclsid, const REGISTERCAT *pregcat)
{
    while (pregcat->pcatid)
    {
        if (FAILED(RegisterCategory(rclsid, *pregcat->pcatid, *pregcat->pguid)))
            return E_FAIL;
        pregcat++;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UnregisterCategory
//
//----------------------------------------------------------------------------

HRESULT UnregisterCategories(REFCLSID rclsid, const REGISTERCAT *pregcat)
{
    while (pregcat->pcatid)
    {
        if (FAILED(UnregisterCategory(rclsid, *pregcat->pcatid, *pregcat->pguid)))
            return E_FAIL;
        pregcat++;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  GetKnownModeBias
//
//----------------------------------------------------------------------------

HRESULT GetKnownModeBias(LIBTHREAD *plt, TfGuidAtom guidatom, GUID *pcatid, const GUID **ppcatidList, ULONG ulCount)
{
    *pcatid = GUID_MODEBIAS_NONE;

    GUID guid;
    ITfCategoryMgr *pcat = GetUIMCat(plt);

    if (!pcat)
        return E_FAIL;

    if (FAILED(pcat->GetGUID(guidatom, &guid)))
        return E_FAIL;

    return pcat->FindClosestCategory(guid, pcatid, ppcatidList, ulCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\cleanup.cpp ===
//
// cleanup.cpp
//

#include "private.h"
#include "cleanup.h"

class CCleanupContextsEditSession : public ITfEditSession
{
public:
    CCleanupContextsEditSession(ITfContext *pic, ICleanupContextsClient *pClient);
    ~CCleanupContextsEditSession();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfEditCallback
    //
    STDMETHODIMP DoEditSession(TfEditCookie ec);

private:
    ITfContext *_pic;
    ICleanupContextsClient *_pClient;

    LONG _cRef;
};

//+---------------------------------------------------------------------------
//
// CleanupAllCompositions
//
//----------------------------------------------------------------------------

BOOL CleanupAllCompositions(TfEditCookie ecWrite, ITfContext *pic,
                            REFCLSID clsidOwner,
                            CLEANUP_COMPOSITIONS_CALLBACK pfnCleanupCompositons,
                            void *pvPrivate)
{
    IEnumITfCompositionView *pEnum;
    ITfCompositionView *pCompositionView;
    ITfContextComposition *picc;
    ITfComposition *pComposition;
    ITfRange *range;
    CLSID clsid;
    HRESULT hr;
    BOOL fRet;

    // find all the compositions with our _tid, in _pic
    if (pic->QueryInterface(IID_ITfContextComposition, (void **)&picc) != S_OK)
        return FALSE;

    fRet = FALSE;

    if (picc->EnumCompositions(&pEnum) != S_OK)
        goto Exit;

    while (pEnum->Next(1, &pCompositionView, NULL) == S_OK)
    {
        pCompositionView->GetOwnerClsid(&clsid);

        // make sure we ignore other TIPs' compositions!
        if (!IsEqualCLSID(clsid, clsidOwner))
            goto NextComposition;

        if (pCompositionView->QueryInterface(IID_ITfComposition, (void **)&pComposition) != S_OK)
            goto NextComposition;

        hr = pComposition->GetRange(&range);

        // notify cicero, app
        pComposition->EndComposition(ecWrite);

        if (hr == S_OK)
        {
            // notify tip
            pfnCleanupCompositons(ecWrite, range, pvPrivate);
            range->Release();
        }

        pComposition->Release();

NextComposition:
        pCompositionView->Release();
    }

    pEnum->Release();

    fRet = TRUE;

Exit:
    picc->Release();

    return fRet;
}

//+---------------------------------------------------------------------------
//
// CleanupAllContexts
//
//----------------------------------------------------------------------------

BOOL CleanupAllContexts(ITfThreadMgr *tim, TfClientId tid, ICleanupContextsClient *pClient)
{
    IEnumTfDocumentMgrs *pEnumDm;
    ITfDocumentMgr *pDm;
    IEnumTfContexts *pEnumCtxt;
    ITfContext *pic;
    CCleanupContextsEditSession *pes;
    BOOL fInterested;
    HRESULT hr;

    if (tim->EnumDocumentMgrs(&pEnumDm) != S_OK)
        return FALSE;

    while (pEnumDm->Next(1, &pDm, NULL) == S_OK)
    {
        if (pDm->EnumContexts(&pEnumCtxt) != S_OK)
            goto NextDm;

        while (pEnumCtxt->Next(1, &pic, NULL) == S_OK)
        {
            if (pClient->IsInterestedInContext(pic, &fInterested) != S_OK || !fInterested)
                goto NextIC;

            if ((pes = new CCleanupContextsEditSession(pic, pClient)) == NULL)
                goto NextIC;

            pic->RequestEditSession(tid, pes, TF_ES_READWRITE, &hr);
            Assert(SUCCEEDED(hr));
            pes->Release();

NextIC:
            pic->Release();
        }

        pEnumCtxt->Release();

NextDm:
        pDm->Release();
    }

    pEnumDm->Release();

    return TRUE;
}



//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CCleanupContextsEditSession::CCleanupContextsEditSession(ITfContext *pic, ICleanupContextsClient *pClient)
{
    _pic = pic;
    _pic->AddRef();

    _pClient = pClient;
    _pClient->AddRef();

    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CCleanupContextsEditSession::~CCleanupContextsEditSession()
{
    _pic->Release();
    _pClient->Release();
}

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CCleanupContextsEditSession::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfEditSession))
    {
        *ppvObj = SAFECAST(this, CCleanupContextsEditSession *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CCleanupContextsEditSession::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CCleanupContextsEditSession::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// DoEditSession
//
//----------------------------------------------------------------------------

STDAPI CCleanupContextsEditSession::DoEditSession(TfEditCookie ec)
{
    _pClient->CleanupContext(ec, _pic);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\dap.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       dap.cpp
//
//  Contents:   CDisplayAttributeProvider
//
//----------------------------------------------------------------------------

#include "private.h"
#include "dap.h"
#include "regsvr.h" // for CLSID_STRLEN 

void DllAddRef(void);
void DllRelease(void);

const TCHAR c_szKey[] = TEXT("SOFTWARE\\Microsoft\\");
WCHAR CDisplayAttributeProvider::szProviderName[80] = L"DisplayAttribute";


//+---------------------------------------------------------------------------
//
// CDisplayAttributeProvider
//
//----------------------------------------------------------------------------

CDisplayAttributeProvider::CDisplayAttributeProvider()
{
    _pList = NULL;
}

CDisplayAttributeProvider::~CDisplayAttributeProvider()
{
    CDisplayAttributeInfo *pInfo = _pList;

    while (pInfo)
    {
        CDisplayAttributeInfo *pNext = pInfo->_pNext;
        pInfo->Release();
        pInfo = pNext;
    }
}


//+---------------------------------------------------------------------------
//
// EnumDisplayAttributeInfo
//
//----------------------------------------------------------------------------

STDMETHODIMP CDisplayAttributeProvider::EnumDisplayAttributeInfo(IEnumTfDisplayAttributeInfo **ppEnum)
{
    HRESULT hr = S_OK;

    if (!(*ppEnum = new CEnumDisplayAttributeInfo(this)))
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

//----------------------------------------------------------------------------
//
// GetDisplayAttributeInfo
//
//----------------------------------------------------------------------------

STDMETHODIMP CDisplayAttributeProvider::GetDisplayAttributeInfo(REFGUID guid, ITfDisplayAttributeInfo **ppInfo)
{
    HRESULT hr = E_FAIL;
    CDisplayAttributeInfo *pInfo = _pList;

    while (pInfo)
    {
        if (IsEqualGUID(pInfo->_guid, guid))
        {
            if (SUCCEEDED(hr = pInfo->QueryInterface(IID_ITfDisplayAttributeInfo, (void **)ppInfo)))
            {
                return hr;
            }
        }
        pInfo = pInfo->_pNext;
    }
    return hr;
}

//----------------------------------------------------------------------------
//
// Add
//
//----------------------------------------------------------------------------

void CDisplayAttributeProvider::Add(GUID guid, WCHAR *pszDesc, TF_DISPLAYATTRIBUTE *pda)
{
    CDisplayAttributeInfo *pInfo;

    pInfo = new CDisplayAttributeInfo(guid, pszDesc, pda);
    if (pInfo)
    {
        pInfo->_pNext = _pList;
        _pList = pInfo;
    }
}

//+---------------------------------------------------------------------------
//
// CDisplayAttributeInfo
//
//----------------------------------------------------------------------------

CDisplayAttributeInfo::CDisplayAttributeInfo(GUID guid, WCHAR *pszDesc, TF_DISPLAYATTRIBUTE *pda)
{
    DllAddRef();

    _guid = guid;
    StringCchCopyW(_szDesc, ARRAYSIZE(_szDesc), pszDesc);

    if (FAILED(_OpenAttribute(c_szKey, 
                              CDisplayAttributeProvider::szProviderName, 
                              &guid, &_da)))
        _da = *pda;

    _daDefault = *pda;
    _pNext = NULL;

    _cRef = 1;
}

CDisplayAttributeInfo::~CDisplayAttributeInfo()
{
    DllRelease();
}

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CDisplayAttributeInfo::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_POINTER;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfDisplayAttributeInfo))
    {
        *ppvObj = SAFECAST(this, ITfDisplayAttributeInfo *);
    }

    if (*ppvObj == NULL)
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

STDAPI_(ULONG) CDisplayAttributeInfo::AddRef()
{
    _cRef++;
    return _cRef;
}

STDAPI_(ULONG) CDisplayAttributeInfo::Release()
{
    _cRef--;
    if (0 < _cRef)
        return _cRef;

    delete this;
    return 0;    
}

//+---------------------------------------------------------------------------
//
// GetGUID
//
//----------------------------------------------------------------------------

HRESULT CDisplayAttributeInfo::GetGUID(GUID *pguid)
{
    *pguid = _guid;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetDescription
//
//----------------------------------------------------------------------------

HRESULT CDisplayAttributeInfo::GetDescription(BSTR *pbstr)
{
    *pbstr = SysAllocString(_szDesc);

    if (*pbstr)
        return S_OK;
    else
        return E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// GetAttributeInfo
//
//----------------------------------------------------------------------------

HRESULT CDisplayAttributeInfo::GetAttributeInfo(TF_DISPLAYATTRIBUTE *pda)
{
    *pda = _da;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SetAttributeInfo
//
//----------------------------------------------------------------------------

HRESULT CDisplayAttributeInfo::SetAttributeInfo(const TF_DISPLAYATTRIBUTE *pda)
{
    _da = *pda;
    _SaveAttribute(c_szKey, CDisplayAttributeProvider::szProviderName, 
                   &_guid, &_da);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Reset()
//
//----------------------------------------------------------------------------

HRESULT CDisplayAttributeInfo::Reset()
{
    _da = _daDefault;
    _DeleteAttribute(c_szKey, CDisplayAttributeProvider::szProviderName, &_guid);
    return S_OK;
}

//----------------------------------------------------------------------------
//
// SaveAttribute
//
//----------------------------------------------------------------------------

HRESULT CDisplayAttributeInfo::_SaveAttribute(const TCHAR *pszKey, WCHAR *pszDesc, const GUID *pguid, TF_DISPLAYATTRIBUTE *pda)

{
    DWORD dw;
    HKEY hKeyDAM;
    HKEY hKeyItem;
    TCHAR achGuid[CLSID_STRLEN+1];

    if (RegCreateKeyEx(HKEY_CURRENT_USER, pszKey, 0, NULL, 
                       REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS, 
                       NULL, 
                       &hKeyDAM, 
                       &dw) != ERROR_SUCCESS)
    {
        return E_FAIL;
    }

    CLSIDToStringA(*pguid, achGuid);
    int cchDescA = wcslen(pszDesc)  * sizeof(WCHAR) + 1;
    char *pszDescA = new char[cchDescA];
    if (pszDescA)
    {
        cchDescA = WideCharToMultiByte(CP_ACP, 0, 
                                       pszDesc, wcslen(pszDesc), 
                                       pszDescA, cchDescA, 
                                       NULL, NULL);
        *(pszDescA + cchDescA) = L'\0';

        if (RegCreateKeyEx(hKeyDAM, pszDescA, 0, NULL, 
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS, 
                           NULL, 
                           &hKeyItem, 
                           &dw) == ERROR_SUCCESS)
        {

            RegSetValueEx(hKeyItem, achGuid, 0, REG_BINARY, 
                              (CONST BYTE *)pda, sizeof(TF_DISPLAYATTRIBUTE));

            RegCloseKey(hKeyItem);
        }

        delete pszDescA;
    }
    RegCloseKey(hKeyDAM);


    return S_OK;
}

//----------------------------------------------------------------------------
//
// OpenAttribute
//
//----------------------------------------------------------------------------

HRESULT CDisplayAttributeInfo::_OpenAttribute(const TCHAR *pszKey, WCHAR *pszDesc, const GUID *pguid, TF_DISPLAYATTRIBUTE *pda)

{
    DWORD dw;
    HKEY hKeyDAM;
    HKEY hKeyItem;
    TCHAR achGuid[CLSID_STRLEN+1];
    LONG lret = ERROR_SUCCESS;

    if (RegCreateKeyEx(HKEY_CURRENT_USER, pszKey, 0, NULL, 
                       REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS, 
                       NULL, 
                       &hKeyDAM, 
                       &dw) != ERROR_SUCCESS)
    {
        return E_FAIL;
    }

    CLSIDToStringA(*pguid, achGuid);
    int cchDescA = wcslen(pszDesc)  * sizeof(WCHAR) + 1;
    char *pszDescA = new char[cchDescA];
    if (pszDescA)
    {
        cchDescA = WideCharToMultiByte(CP_ACP, 0, 
                                       pszDesc, wcslen(pszDesc), 
                                       pszDescA, cchDescA, 
                                       NULL, NULL);
        *(pszDescA + cchDescA) = L'\0';

        if (RegCreateKeyEx(hKeyDAM, pszDescA, 0, NULL, 
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS, 
                           NULL, 
                           &hKeyItem, 
                           &dw) == ERROR_SUCCESS)
        {

            DWORD dwType = REG_BINARY;
            DWORD dwSize = sizeof(TF_DISPLAYATTRIBUTE);
            lret = RegQueryValueEx(hKeyItem, achGuid, 0, &dwType, 
                            (BYTE *)pda, &dwSize);

            RegCloseKey(hKeyItem);
        }

        delete pszDescA;
    }
    RegCloseKey(hKeyDAM);

    return (lret == ERROR_SUCCESS) ? S_OK : E_FAIL;
}

//----------------------------------------------------------------------------
//
// DeleteAttribute
//
//----------------------------------------------------------------------------

HRESULT CDisplayAttributeInfo::_DeleteAttribute(const TCHAR *pszKey, WCHAR *pszDesc, const GUID *pguid)

{
    DWORD dw;
    HKEY hKeyDAM;
    HKEY hKeyItem;
    TCHAR achGuid[CLSID_STRLEN+1];

    if (RegCreateKeyEx(HKEY_CURRENT_USER, pszKey, 0, NULL, 
                       REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS, 
                       NULL, 
                       &hKeyDAM, 
                       &dw) != ERROR_SUCCESS)
    {
        return E_FAIL;
    }

    CLSIDToStringA(*pguid, achGuid);
    int cchDescA = wcslen(pszDesc)  * sizeof(WCHAR) + 1;
    char *pszDescA = new char[cchDescA];
    if (pszDescA)
    {
        cchDescA = WideCharToMultiByte(CP_ACP, 0, 
                                       pszDesc, wcslen(pszDesc), 
                                       pszDescA, cchDescA, 
                                       NULL, NULL);
        *(pszDescA + cchDescA) = L'\0';

        if (RegCreateKeyEx(hKeyDAM, pszDescA, 0, NULL, 
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS, 
                           NULL, 
                           &hKeyItem, 
                           &dw) == ERROR_SUCCESS)
        {
            RegDeleteValue(hKeyItem, achGuid);
            RegCloseKey(hKeyItem);
        }

        delete pszDescA;
    }
    RegCloseKey(hKeyDAM);

    return S_OK;
}


//+---------------------------------------------------------------------------
//
// CEnumDisplayAttributeInfo
//
//----------------------------------------------------------------------------

CEnumDisplayAttributeInfo::CEnumDisplayAttributeInfo(CDisplayAttributeProvider *pProvider)
{
    DllAddRef();

    _pProvider = pProvider;
    _pProvider->AddRef();
    _pCur = _pProvider->_pList;

    _cRef = 1;
}

CEnumDisplayAttributeInfo::~CEnumDisplayAttributeInfo()
{
    _pProvider->Release();
    DllRelease();
}

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CEnumDisplayAttributeInfo::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_POINTER;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IEnumTfDisplayAttributeInfo))
    {
        *ppvObj = SAFECAST(this, IEnumTfDisplayAttributeInfo *);
    }

    if (*ppvObj == NULL)
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

STDAPI_(ULONG) CEnumDisplayAttributeInfo::AddRef()
{
    _cRef++;
    return _cRef;
}

STDAPI_(ULONG) CEnumDisplayAttributeInfo::Release()
{
    _cRef--;
    if (0 < _cRef)
        return _cRef;

    delete this;
    return 0;    
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

HRESULT CEnumDisplayAttributeInfo::Clone(IEnumTfDisplayAttributeInfo **ppEnum)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// Next
//
//----------------------------------------------------------------------------

HRESULT CEnumDisplayAttributeInfo::Next(ULONG ulCount, ITfDisplayAttributeInfo **ppInfo, ULONG *pcFetched)
{
    ULONG cFetched = 0;

    while (cFetched < ulCount)
    {
        if (!_pCur)
            break;

        if (FAILED(_pCur->QueryInterface(IID_ITfDisplayAttributeInfo, (void **)ppInfo)))
            break;

        _pCur= _pCur->_pNext;
        ppInfo++;
        cFetched++;
    }

    if (pcFetched)
        *pcFetched = cFetched;

    return (cFetched == ulCount) ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
// Reset
//
//----------------------------------------------------------------------------

HRESULT CEnumDisplayAttributeInfo::Reset()
{
    _pCur = _pProvider->_pList;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Skip
//
//----------------------------------------------------------------------------

HRESULT CEnumDisplayAttributeInfo::Skip(ULONG ulCount)
{
    while (ulCount)
    {
        if (!_pCur)
            break;

        _pCur = _pCur->_pNext;
        ulCount--;
    }

    return ulCount ? S_FALSE : S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\globals.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       globals.cpp
//
//  Contents:   Global variables.
//
//----------------------------------------------------------------------------

#include "private.h"
#include "globals.h"

HINSTANCE g_hMlang = 0;
HRESULT (*g_pfnGetGlobalFontLinkObject)(IMLangFontLink **) = NULL;
BOOL g_bComplexPlatform = FALSE;
UINT g_uiACP = CP_ACP;

PFNCOCREATE g_pfnCoCreate = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\cstring.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    cstring.cpp

Abstract:

    This file implements the CString class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include <tchar.h>
#include "cstring.h"


/////////////////////////////////////////////////////////////////////////////
// static class data

// afxChNil is left for backward compatibility
TCHAR afxChNil = TEXT('\0');

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)

int _afxInitData[] = { -1, 0, 0, 0 };
CStringData* _afxDataNil = (CStringData*)&_afxInitData;

LPCTSTR _afxPchNil = (LPCTSTR)(((BYTE*)&_afxInitData)+sizeof(CStringData));


/////////////////////////////////////////////////////////////////////////////
// CString

CString::CString(
    )
{
    Init();
}

CString::CString(
    const CString& stringSrc
    )
{
    ASSERT(stringSrc.GetData()->nRefs != 0);

    if (stringSrc.GetData()->nRefs >= 0) {
        ASSERT(stringSrc.GetData() != _afxDataNil);
        m_pchData = stringSrc.m_pchData;
        InterlockedIncrement(&GetData()->nRefs);
    }
    else {
        Init();
        *this = stringSrc.m_pchData;
    }
}

CString::CString(
    LPCSTR lpsz
    )
{
    Init();
    *this = lpsz;
}

CString::CString(
    LPCSTR lpsz,
    int nLength
    )
{
    Init();
    if (nLength != 0) {
        AllocBuffer(nLength);
        memcpy(m_pchData, lpsz, nLength*sizeof(TCHAR));
    }
}

CString::~CString(
    )
{
    // free any attached data

    if (GetData() != _afxDataNil) {
        if (InterlockedDecrement(&GetData()->nRefs) <= 0)
            FreeData(GetData());
    }
}

void
CString::AllocCopy(
    CString& dest,
    int nCopyLen,
    int nCopyIndex,
    int nExtraLen
    ) const
{
    // will clone the data attached to this string
    // allocating 'nExtraLen' characters
    // Places results in uninitialized string 'dest'
    // Will copy the part or all of original data to start of new string

    int nNewLen = nCopyLen + nExtraLen;
    if (nNewLen == 0) {
        dest.Init();
    }
    else {
        dest.AllocBuffer(nNewLen);
        memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(TCHAR));
    }
}

void
CString::AllocBuffer(
    int nLen
    )
{
    // always allocate one extra character for '\0' termination
    // assumes [optimistically] that data length will equal allocation length

    ASSERT(nLen >= 0);
    ASSERT(nLen <= INT_MAX-1);    // max size (enough room for 1 extra)

    if (nLen == 0)
        Init();
    else {
        CStringData* pData;

        pData = (CStringData*) new BYTE[ sizeof(CStringData) + (nLen+1)*sizeof(TCHAR) ];

        if (pData)
        {
            pData->nAllocLength = nLen;

            pData->nRefs = 1;
            pData->data()[nLen] = TEXT('\0');
            pData->nDataLength = nLen;
            m_pchData = pData->data();
        }
    }
}

void
CString::FreeData(
    CStringData* pData
    )
{
    delete [] (BYTE*)pData;
}

void
CString::Release(
    )
{
    if (GetData() != _afxDataNil) {
        ASSERT(GetData()->nRefs != 0);
        if (InterlockedDecrement(&GetData()->nRefs) <= 0)
            FreeData(GetData());
        Init();
    }
}

void PASCAL
CString::Release(
    CStringData* pData
    )
{
    if (pData != _afxDataNil) {
        ASSERT(pData->nRefs != 0);
        if (InterlockedDecrement(&pData->nRefs) <= 0)
            FreeData(pData);
    }
}

void
CString::AllocBeforeWrite(
    int nLen
    )
{
    if (GetData()->nRefs > 1 ||
        nLen > GetData()->nAllocLength) {
        Release();
        AllocBuffer(nLen);
    }
    ASSERT(GetData()->nRefs <= 1);
}

int
CString::Compare(
    LPCTSTR lpsz
    ) const
{
    return _tcscmp(m_pchData, lpsz);     // MBSC/Unicode aware
}

int
CString::CompareNoCase(
    LPCTSTR lpsz
    ) const
{
    return _tcsicmp(m_pchData, lpsz);    // MBCS/Unicode aware
}

CString
CString::Mid(
    int nFirst
    ) const
{
    return Mid(nFirst, GetData()->nDataLength - nFirst);
}

CString
CString::Mid(
    int nFirst,
    int nCount
    ) const
{
    // out-of-bounds requests return sensible things
    if (nFirst < 0)
        nFirst = 0;
    if (nCount < 0)
        nCount = 0;

    if (nFirst + nCount > GetData()->nDataLength)
        nCount = GetData()->nDataLength - nFirst;
    if (nFirst > GetData()->nDataLength)
        nCount = 0;

    ASSERT(nFirst >= 0);
    ASSERT(nFirst + nCount <= GetData()->nDataLength);

    // optimize case of returning entire string
    if (nFirst == 0 && nFirst + nCount == GetData()->nDataLength)
        return *this;

    CString dest;
    AllocCopy(dest, nCount, nFirst, 0);
    return dest;
}

int
CString::Find(
    TCHAR ch
    ) const
{
    return Find(ch, 0);
}

int
CString::Find(
    TCHAR ch,
    int nStart
    ) const
{
    int nLength = GetData()->nDataLength;
    if (nStart >= nLength)
        return -1;

    // find first single character
    LPTSTR lpsz = _tcschr(m_pchData + nStart, (_TUCHAR)ch);

    // return -1 if not found and index otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

/////////////////////////////////////////////////////////////////////////////
// Assignment opeators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void
CString::AssignCopy(
    int nSrcLen,
    LPCTSTR lpszSrcData
    )
{
    AllocBeforeWrite(nSrcLen);
    memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
    GetData()->nDataLength = nSrcLen;
    m_pchData[nSrcLen] = TEXT('\0');
}

const CString&
CString::operator=(
    const CString& stringSrc
    )
{
    if (m_pchData != stringSrc.m_pchData) {
        if ((GetData()->nRefs < 0 && GetData() != _afxDataNil) ||
            stringSrc.GetData()->nRefs < 0) {
            // actual copy necessary since one of the strings is locked
            AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
        }
        else {
            // can just copy reference around
            Release();
            ASSERT(stringSrc.GetData() != _afxDataNil);
            m_pchData = stringSrc.m_pchData;
            InterlockedIncrement(&GetData()->nRefs);
        }
    }
    return *this;
}

const CString&
CString::operator=(
    char ch
    )
{
    AssignCopy(1, &ch);
    return *this;
}

const CString&
CString::operator=(
    LPCTSTR lpsz
    )
{
    ASSERT(lpsz != NULL);
    AssignCopy(SafeStrlen(lpsz), lpsz);
    return *this;
}

CString::operator LPCTSTR(
    ) const
{
    return m_pchData;
}

int PASCAL
CString::SafeStrlen(
    LPCTSTR lpsz
    )
{
    return (lpsz == NULL) ? 0 : lstrlen(lpsz);
}



// Compare helpers
bool
operator==(
    const CString& s1,
    const CString& s2
    )
{
    return s1.Compare(s2) == 0;
}

bool
operator==(
    const CString& s1,
    LPCTSTR s2
    )
{
    return s1.Compare(s2) == 0;
}

bool
operator==(
    LPCTSTR s1,
    CString& s2
    )
{
    return s2.Compare(s1) == 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\fontlink.cpp ===
//
// fontlink.cpp
//

#include "private.h"
#include "fontlink.h"
#include "xstring.h"
#include "osver.h"
#include "globals.h"
#include "flshare.h"
#include "ciccs.h"

extern CCicCriticalSectionStatic g_cs;

// Just like IMLangFontLink::MapFont, except has a hack for vertical fonts
HRESULT MapFont(IMLangFontLink *pMLFontLink, HDC hdc, DWORD dwCodePages, HFONT hSrcFont, HFONT* phDestFont, BOOL *pfWrappedFont)
{
    HRESULT hr;
    LOGFONT lfSrc;
    LOGFONT lfMap;
    HFONT hfontVert;
    TCHAR achVertFaceName[LF_FACESIZE];

    *pfWrappedFont = FALSE;

    hr = pMLFontLink->MapFont(hdc, dwCodePages, hSrcFont, phDestFont);

    if (hr != S_OK)
        return hr;

    // check, was this a vertical font?
    if (!GetObject(hSrcFont, sizeof(lfSrc), &lfSrc))
        return S_OK; // the MapFont call stil succeeded

    if (lfSrc.lfFaceName[0] != '@')
        return S_OK; // not a vertical font

    // is the mapped font vertical?
    if (!GetObject(*phDestFont, sizeof(lfMap), &lfMap))
        return S_OK; // the MapFont call stil succeeded

    if (lfMap.lfFaceName[0] == '@')
        return S_OK; // everything's ok

    // if we get here, src font is vertical but mlang has returned a
    // non-vertical font.  Try to create a vertical one.

    // create a new '@' version
    memmove(&lfMap.lfFaceName[1], &lfMap.lfFaceName[0], LF_FACESIZE-sizeof(TCHAR));
    lfMap.lfFaceName[0] = '@';
    lfMap.lfFaceName[LF_FACESIZE-1] = 0;
    // save it for later
    memcpy(achVertFaceName, lfMap.lfFaceName, LF_FACESIZE*sizeof(TCHAR));

    // Issue: perf: one idea here would be to cache the lru font
    hfontVert = CreateFontIndirect(&lfMap);

    if (hfontVert == 0)
        return S_OK;

    // did it work?
    if (!GetObject(hfontVert, sizeof(lfMap), &lfMap))
        goto ExitDelete;

    if (lstrcmp(achVertFaceName, lfMap.lfFaceName) != 0)
        goto ExitDelete; // no vertical version available

    // got it, swap out the fonts
    pMLFontLink->ReleaseFont(*phDestFont);
    *phDestFont = hfontVert;
    *pfWrappedFont = TRUE;

    return S_OK;

ExitDelete:
    DeleteObject(hfontVert);
    return S_OK;
}

// IMLangFontLink::ReleaseFont wrapper, matched with MapFont
HRESULT ReleaseFont(IMLangFontLink *pMLFontLink, HFONT hfontMap, BOOL fWrappedFont)
{
    if (!fWrappedFont)
        return pMLFontLink->ReleaseFont(hfontMap);

    // Issue: cache!
    DeleteObject(hfontMap);
    return S_OK;
}

#define CH_PREFIX L'&'

BOOL LoadMLFontLink(IMLangFontLink **ppMLFontLink)
{
    EnterCriticalSection(g_cs);

    *ppMLFontLink = NULL;
    if (NULL == g_pfnGetGlobalFontLinkObject)
    {
        if (g_hMlang == 0)
        {
            g_hMlang = LoadSystemLibrary(TEXT("MLANG.DLL"));
        }

        if (g_hMlang)
        {
            g_pfnGetGlobalFontLinkObject = (HRESULT (*)(IMLangFontLink **))GetProcAddress(g_hMlang, "GetGlobalFontLinkObject");
        }
    }
    Assert(g_hMlang);

    if (g_pfnGetGlobalFontLinkObject)
    {
        g_pfnGetGlobalFontLinkObject(ppMLFontLink);
    }

    g_bComplexPlatform = GetSystemModuleHandle(TEXT("LPK.DLL")) ? TRUE : FALSE;

    LeaveCriticalSection(g_cs);

    return (*ppMLFontLink)? TRUE: FALSE;
}

BOOL _OtherExtTextOutW(HDC hdc, int xp, int yp, UINT eto, CONST RECT *lprect,
                       LPCWSTR lpwch, UINT cLen, CONST INT *lpdxp)
{
    if (!(eto & ETO_GLYPH_INDEX) && cLen < 256 && lpwch[0] <= 127)
    {
        char lpchA[256];
        UINT ich;
        BOOL fAscii = TRUE;

        for (ich = 0; ich < cLen; ich++)
        {
            WCHAR wch = lpwch[ich];

            if (wch <= 127)
                lpchA[ich] = (char) wch;
            else
            {
                fAscii = FALSE;
                break;
            }
        }
        if (fAscii)
            return ExtTextOutA(hdc, xp, yp, eto, lprect, lpchA, cLen, lpdxp);
    }

    return (ExtTextOutW(hdc, xp, yp, eto, lprect, lpwch, cLen, lpdxp));
}

BOOL _ExtTextOutWFontLink(HDC hdc, int xp, int yp, UINT eto, CONST RECT *lprect,
                          LPCWSTR lpwch, UINT cLen, CONST INT *lpdxp)
{
    HFONT hfont = NULL;
    HFONT hfontSav = NULL;
    HFONT hfontMap = NULL;
    BOOL fRet = FALSE;
    UINT ta;
    int fDoTa = FALSE;
    int fQueryTa = TRUE;
    POINT pt;
    int cchDone;
    DWORD dwACP, dwFontCodePages, dwCodePages;
    long cchCodePages;
    IMLangFontLink *pMLFontLink = NULL;
    BOOL fWrappedFont;

    if (cLen == 0)
        return FALSE;

    if (!LoadMLFontLink(&pMLFontLink))
        return FALSE;

    hfont = (HFONT)GetCurrentObject(hdc, OBJ_FONT);
    pMLFontLink->GetFontCodePages(hdc, hfont, &dwFontCodePages);
    pMLFontLink->CodePageToCodePages(g_uiACP, &dwACP); // Give priority to CP_ACP

    // See if whole string can be handled by current font
    pMLFontLink->GetStrCodePages(lpwch, cLen, dwACP, &dwCodePages, &cchCodePages);

    // current font supports whole string ?
    if ((dwFontCodePages & dwCodePages) && cLen == (UINT)cchCodePages)
    {
        pMLFontLink->Release();
        return FALSE;
    }
    for (cchDone = 0; (UINT)cchDone < cLen; cchDone += cchCodePages)
    {
        pMLFontLink->GetStrCodePages(lpwch + cchDone, cLen - cchDone, dwACP, &dwCodePages, &cchCodePages);

        if (!(dwFontCodePages & dwCodePages))
        {
            MapFont(pMLFontLink, hdc, dwCodePages, hfont, &hfontMap, &fWrappedFont);   // Issue: Baseline?
            hfontSav = (HFONT)SelectObject(hdc, hfontMap);
        }

        // cchCodePages shouldn't be 0
        ASSERT(cchCodePages);

        if (cchCodePages > 0)
        {
            // If rendering in multiple parts, need to use TA_UPDATECP
            if ((UINT)cchCodePages != cLen && fQueryTa)
            {
                ta = GetTextAlign(hdc);
                if ((ta & TA_UPDATECP) == 0) // Don't do the move if x, y aren't being used
                {
                    MoveToEx(hdc, xp, yp, &pt);
                    fDoTa = TRUE;
                }
                fQueryTa = FALSE;
            }

            if (fDoTa)
                SetTextAlign(hdc, ta | TA_UPDATECP);

            fRet = _OtherExtTextOutW(hdc, xp, yp, eto, lprect, lpwch + cchDone, cchCodePages,
                        lpdxp ? lpdxp + cchDone : NULL);
            eto = eto & ~ETO_OPAQUE; // Don't do mupltiple OPAQUEs!!!
            if (fDoTa)
                SetTextAlign(hdc, ta);
            if (!fRet)
                break;
        }

        if (NULL != hfontSav)
        {
            SelectObject(hdc, hfontSav);
            ReleaseFont(pMLFontLink, hfontMap, fWrappedFont);
            hfontSav = NULL;
        }
    }
    if (fDoTa) // Don't do the move if x, y aren't being used
        MoveToEx(hdc, pt.x, pt.y, NULL);

    pMLFontLink->Release();
    return fRet;
}


BOOL FLExtTextOutW(HDC hdc, int xp, int yp, UINT eto, CONST RECT *lprect, LPCWSTR lpwch, UINT cLen, CONST INT *lpdxp)
{
    BOOL fRet      = FALSE;

    if (cLen == 0)
    {
        char chT;
        return ExtTextOutA(hdc, xp, yp, eto, lprect, &chT, cLen, lpdxp);
    }

    // Optimize for all < 128 case
    if (!(eto & ETO_GLYPH_INDEX) && cLen < 256 && lpwch[0] <= 127)
    {
        char lpchA[256];
        UINT ich;
        BOOL fAscii = TRUE;

        for (ich = 0; ich < cLen; ich++)
        {
            WCHAR wch = lpwch[ich];

            if (wch <= 127)
                lpchA[ich] = (char) wch;
            else
            {
                fAscii = FALSE;
                break;
            }
        }
        if (fAscii)
            return ExtTextOutA(hdc, xp, yp, eto, lprect, lpchA, cLen, lpdxp);
    }

    // Font linking support for UI rendering
    fRet = _ExtTextOutWFontLink(hdc, xp, yp, eto, lprect, lpwch, cLen, lpdxp);

    if (!fRet)
        fRet = _OtherExtTextOutW(hdc, xp, yp, eto, lprect, lpwch, cLen, lpdxp);

    return fRet;
}

BOOL FLTextOutW(HDC hdc, int xp, int yp, LPCWSTR lpwch, int cLen)
{
    return FLExtTextOutW(hdc, xp, yp, 0, NULL, lpwch, cLen, NULL);
}    

// this is a workaround for a win95 bug: gdi will fault if lpwch is NULL, even
// when cch == 0
inline BOOL SafeGetTextExtentPoint32W(HDC hdc, LPCWSTR lpwch, int cch, LPSIZE lpSize)
{
    if (cch == 0)
    {
        memset(lpSize, 0, sizeof(*lpSize));
        return TRUE;
    }

    return GetTextExtentPoint32W(hdc, lpwch, cch, lpSize);
}

//
//  _GetTextExtentPointWFontLink
//
//  This is a filter for GetTextExtentPointW() that does font linking.
//
//  The input string is scanned and fonts are switched if not all chars are
//  supported by the current font in the HDC.
//
BOOL _GetTextExtentPointWFontLink(HDC hdc, LPCWSTR lpwch, int cch, LPSIZE lpSize)
{
    HFONT hfont = NULL;
    HFONT hfontSav = NULL;
    HFONT hfontMap = NULL;
    BOOL fRet = FALSE;
    int cchDone;
    long cchCodePages;
    DWORD dwACP, dwFontCodePages, dwCodePages;
    SIZE size;
    IMLangFontLink *pMLFontLink = NULL;
    BOOL fWrappedFont;

    ASSERT(cch != 0);

    if (!LoadMLFontLink(&pMLFontLink))
        return FALSE;

    hfont = (HFONT)GetCurrentObject(hdc, OBJ_FONT);
    pMLFontLink->GetFontCodePages(hdc, hfont, &dwFontCodePages);
    pMLFontLink->CodePageToCodePages(g_uiACP, &dwACP); // Give priority to CP_ACP

    // See if whole string can be handled by current font
    pMLFontLink->GetStrCodePages(lpwch, cch, dwACP, &dwCodePages, &cchCodePages);

    // current font supports whole string ?
    if ((dwFontCodePages & dwCodePages) && cch == cchCodePages)
    {
        pMLFontLink->Release();
        return FALSE;
    }
    // Get Hight of DC font
    if (!(fRet = GetTextExtentPointA(hdc, " ", 1, lpSize)))
    {
        pMLFontLink->Release();
        return FALSE;
    }
    lpSize->cx = 0;

    for (cchDone = 0; cchDone < cch; cchDone += cchCodePages)
    {
        pMLFontLink->GetStrCodePages(lpwch + cchDone, cch - cchDone, dwACP, &dwCodePages, &cchCodePages);

        if (!(dwFontCodePages & dwCodePages))
        {
            MapFont(pMLFontLink, hdc, dwCodePages, hfont, &hfontMap, &fWrappedFont);
            hfontSav = (HFONT)SelectObject(hdc, hfontMap);
        }

        // cchCodePages shouldn't be 0
        ASSERT(cchCodePages);

        if (cchCodePages > 0)
        {
            fRet = SafeGetTextExtentPoint32W(hdc, lpwch + cchDone, cchCodePages, &size);
            lpSize->cx += size.cx;
        }

        if (NULL != hfontSav)
        {
            SelectObject(hdc, hfontSav);
            ReleaseFont(pMLFontLink, hfontMap, fWrappedFont);
            hfontSav = NULL;
        }
    }
    pMLFontLink->Release();
    return fRet;
}


BOOL FLGetTextExtentPoint32(HDC hdc, LPCWSTR lpwch, int cch, LPSIZE lpSize)
{
    BOOL fRet      = FALSE;

    if (cch)
    {
        // Optimize for all < 128 case
        if (cch < 256 && lpwch[0] <= 127)
        {
            char lpchA[256];
            int ich;
            BOOL fAscii = TRUE;

            for (ich = 0; ich < cch; ich++)
            {
                WCHAR wch = lpwch[ich];

                if (wch <= 127)
                    lpchA[ich] = (char) wch;
                else
                {
                    fAscii = FALSE;
                    break;
                }
            }
            if (fAscii)
                return GetTextExtentPointA(hdc, lpchA, cch, lpSize);
        }
        fRet = _GetTextExtentPointWFontLink(hdc, lpwch, cch, lpSize);
    }
    if (!fRet)
        fRet = SafeGetTextExtentPoint32W(hdc, lpwch, cch, lpSize);

    return fRet;
}

//
//  Issue: Review for removing below big table and UsrFromWch() ...
//
__inline BOOL FChsDbcs(UINT chs)
{
    return (chs == SHIFTJIS_CHARSET ||
            chs == HANGEUL_CHARSET ||
            chs == CHINESEBIG5_CHARSET ||
            chs == GB2312_CHARSET);
}

__inline int FChsBiDi(int chs)
{
    return (chs == ARABIC_CHARSET ||
            chs == HEBREW_CHARSET);
}

__inline BOOL FCpgChinese(UINT cpg)
{
    if (cpg == CP_ACP)
        cpg = GetACP();
    return (cpg == CP_TAIWAN || cpg == CP_CHINA);
}

__inline BOOL FCpgTaiwan(UINT cpg)
{
    if (cpg == CP_ACP)
        cpg = GetACP();
    return (cpg == CP_TAIWAN);
}

__inline BOOL FCpgPRC(UINT cpg)
{
    if (cpg == CP_ACP)
        cpg = GetACP();
    return (cpg == CP_CHINA);
}
    
__inline BOOL FCpgFarEast(UINT cpg)
{
    if (cpg == CP_ACP)
        cpg = GetACP();
    return (cpg == CP_JAPAN || cpg == CP_TAIWAN || cpg == CP_CHINA ||
            cpg == CP_KOREA || cpg == CP_MAC_JAPAN);
}

__inline BOOL FCpgDbcs(UINT cpg)
{
    return (cpg == CP_JAPAN ||
            cpg == CP_KOREA ||
            cpg == CP_TAIWAN ||
            cpg == CP_CHINA);
}

__inline int FCpgBiDi(int cpg)
{
    return (cpg == CP_ARABIC ||
            cpg == CP_HEBREW);
}

HFONT GetBiDiFont(HDC hdc)
{
    HFONT   hfont    = NULL;
    HFONT   hfontTmp;
    LOGFONT lf;

    hfontTmp = (HFONT)GetCurrentObject(hdc, OBJ_FONT);
    GetObject(hfontTmp, sizeof(lf), &lf);
    // Issue: Should I loop on the string to check if it contains BiDi chars?
    if ( !FChsBiDi(lf.lfCharSet))
    {
        lf.lfCharSet = DEFAULT_CHARSET;
        hfont        = CreateFontIndirect(&lf);
    }
    return hfont;
}

static const WCHAR szEllipsis[CCHELLIPSIS+1] = L"...";


/***************************************************************************\
*  There are word breaking characters which are compatible with
* Japanese Windows 3.1 and FarEast Windows 95.
*
*  SJ - Country Japan , Charset SHIFTJIS, Codepage  932.
*  GB - Country PRC   , Charset GB2312  , Codepage  936.
*  B5 -         Taiwan, Charset BIG5    , Codepage  950.
*  WS - Country Korea , Charset WANGSUNG, Codepage  949.
*  JB - Country Korea , Charset JOHAB   , Codepage 1361. *** LATER ***
*
* [START BREAK CHARACTERS]
*
*   These character should not be the last charatcer of the line.
*
*  Unicode   Japan      PRC     Taiwan     Korea
*  -------+---------+---------+---------+---------+
*
* + ASCII
*
*   U+0024 (SJ+0024)                     (WS+0024) Dollar sign
*   U+0028 (SJ+0028)                     (WS+0028) Opening parenthesis
*   U+003C (SJ+003C)                               Less-than sign
*   U+005C (SJ+005C)                               Backslash
*   U+005B (SJ+005B) (GB+005B)           (WS+005B) Opening square bracket
*   U+007B (SJ+007B) (GB+007B)           (WS+007B) Opening curly bracket
*
* + General punctuation
*
*   U+2018                               (WS+A1AE) Single Turned Comma Quotation Mark
*   U+201C                               (WS+A1B0) Double Comma Quotation Mark
*
* + CJK symbols and punctuation
*
*   U+3008                               (WS+A1B4) Opening Angle Bracket
*   U+300A (SJ+8173)                     (WS+A1B6) Opening Double Angle Bracket
*   U+300C (SJ+8175)                     (WS+A1B8) Opening Corner Bracket
*   U+300E (SJ+8177)                     (WS+A1BA) Opening White Corner Bracket
*   U+3010 (SJ+9179)                     (WS+A1BC) Opening Black Lenticular Bracket
*   U+3014 (SJ+816B)                     (WS+A1B2) Opening Tortoise Shell Bracket
*
* + Fullwidth ASCII variants
*
*   U+FF04                               (WS+A3A4) Fullwidth Dollar Sign
*   U+FF08 (SJ+8169)                     (WS+A3A8) Fullwidth opening parenthesis
*   U+FF1C (SJ+8183)                               Fullwidth less-than sign
*   U+FF3B (SJ+816D)                     (WS+A3DB) Fullwidth opening square bracket
*   U+FF5B (SJ+816F)                     (WS+A3FB) Fullwidth opening curly bracket
*
* + Halfwidth Katakana variants
*
*   U+FF62 (SJ+00A2)                               Halfwidth Opening Corner Bracket
*
* + Fullwidth symbol variants
*
*   U+FFE1                               (WS+A1CC) Fullwidth Pound Sign
*   U+FFE6                               (WS+A3DC) Fullwidth Won Sign
*
* [END BREAK CHARACTERS]
*
*   These character should not be the top charatcer of the line.
*
*  Unicode   Japan      PRC     Taiwan     Korea
*  -------+---------+---------+---------+---------+
*
* + ASCII
*
*   U+0021 (SJ+0021) (GB+0021) (B5+0021) (WS+0021) Exclamation mark
*   U+0025                               (WS+0025) Percent Sign
*   U+0029 (SJ+0029)                     (WS+0029) Closing parenthesis
*   U+002C (SJ+002C) (GB+002C) (B5+002C) (WS+002C) Comma
*   U+002E (SJ+002E) (GB+002E) (B5+002E) (WS+002E) Priod
*   U+003A                               (WS+003A) Colon
*   U+003B                               (WS+003B) Semicolon
*   U+003E (SJ+003E)                               Greater-than sign
*   U+003F (SJ+003F) (GB+003F) (B5+003F) (WS+003F) Question mark
*   U+005D (SJ+005D) (GB+005D) (B5+005D) (WS+005D) Closing square bracket
*   U+007D (SJ+007D) (GB+007D) (B5+007D) (WS+007D) Closing curly bracket
*
* + Latin1
*
*   U+00A8           (GB+A1A7)                     Spacing diaeresis
*   U+00B0                               (WS+A1C6) Degree Sign
*   U+00B7                     (B5+A150)           Middle Dot
*
* + Modifier letters
*
*   U+02C7           (GB+A1A6)                     Modifier latter hacek
*   U+02C9           (GB+A1A5)                     Modifier letter macron
*
* + General punctuation
*
*   U+2013                     (B5+A156)           En Dash
*   U+2014                     (b5+A158)           Em Dash
*   U+2015           (GB+A1AA)                     Quotation dash
*   U+2016           (GB+A1AC)                     Double vertical bar
*   U+2018           (GB+A1AE)                     Single turned comma quotation mark
*   U+2019           (GB+A1AF) (B5+A1A6) (WS+A1AF) Single comma quotation mark
*   U+201D           (GB+A1B1) (B5+A1A8) (WS+A1B1) Double comma quotation mark
*   U+2022           (GB+A1A4)                     Bullet
*   U+2025                     (B5+A14C)           Two Dot Leader
*   U+2026           (GB+A1AD) (B5+A14B)           Horizontal ellipsis
*   U+2027                     (B5+A145)           Hyphenation Point
*   U+2032                     (B5+A1AC) (WS+A1C7) Prime
*   U+2033                               (WS+A1C8) Double Prime
*
* + Letterlike symbols
*
*   U+2103                               (WS+A1C9) Degrees Centigrade
*
* + Mathemetical opetartors
*
*   U+2236           (GB+A1C3)                     Ratio
*
* + Form and Chart components
*
*   U+2574                     (B5+A15A)           Forms Light Left
*
* + CJK symbols and punctuation
*
*   U+3001 (SJ+8141) (GB+A1A2) (B5+A142)           Ideographic comma
*   U+3002 (SJ+8142) (GB+A1A3) (B5+A143)           Ideographic period
*   U+3003           (GB+A1A8)                     Ditto mark
*   U+3005           (GB+A1A9)                     Ideographic iteration
*   U+3009           (GB+A1B5) (B5+A172) (WS+A1B5) Closing angle bracket
*   U+300B (SJ+8174) (GB+A1B7) (B5+A16E) (WS+A1B7) Closing double angle bracket
*   U+300D (SJ+8176) (GB+A1B9) (B5+A176) (WS+A1B9) Closing corner bracket
*   U+300F (SJ+8178) (GB+A1BB) (B5+A17A) (WS+A1BB) Closing white corner bracket
*   U+3011 (SJ+817A) (GB+A1BF) (B5+A16A) (WS+A1BD) Closing black lenticular bracket
*   U+3015 (SJ+816C) (GB+A1B3) (B5+A166) (WS+A1B3) Closing tortoise shell bracket
*   U+3017           (GB+A1BD)                     Closing white lenticular bracket
*   U+301E                     (B5+A1AA)           Double Prime Quotation Mark
*
* + Hiragana
*
*   U+309B (SJ+814A)                               Katakana-Hiragana voiced sound mark
*   U+309C (SJ+814B)                               Katakana-Hiragana semi-voiced sound mark
*
* + CNS 11643 compatibility
*
*   U+FE30                     (B5+A14A)           Glyph for Vertical 2 Dot Leader
*   U+FE31                     (B5+A157)           Glyph For Vertical Em Dash
*   U+FE33                     (B5+A159)           Glyph for Vertical Spacing Underscore
*   U+FE34                     (B5+A15B)           Glyph for Vertical Spacing Wavy Underscore
*   U+FE36                     (B5+A160)           Glyph For Vertical Closing Parenthesis
*   U+FE38                     (B5+A164)           Glyph For Vertical Closing Curly Bracket
*   U+FE3A                     (B5+A168)           Glyph For Vertical Closing Tortoise Shell Bracket
*   U+FE3C                     (B5+A16C)           Glyph For Vertical Closing Black Lenticular Bracket
*   U+FE3E                     (B5+A16E)           Closing Double Angle Bracket
*   U+FE40                     (B5+A174)           Glyph For Vertical Closing Angle Bracket
*   U+FE42                     (B5+A178)           Glyph For Vertical Closing Corner Bracket
*   U+FE44                     (B5+A17C)           Glyph For Vertical Closing White Corner Bracket
*   U+FE4F                     (B5+A15C)           Spacing Wavy Underscore
*
* + Small variants
*
*   U+FE50                     (B5+A14D)           Small Comma
*   U+FE51                     (B5+A14E)           Small Ideographic Comma
*   U+FE52                     (B5+A14F)           Small Period
*   U+FE54                     (B5+A151)           Small Semicolon
*   U+FE55                     (B5+A152)           Small Colon
*   U+FE56                     (B5+A153)           Small Question Mark
*   U+FE57                     (B5+A154)           Small Exclamation Mark
*   U+FE5A                     (B5+A17E)           Small Closing Parenthesis
*   U+FE5C                     (B5+A1A2)           Small Closing Curly Bracket
*   U+FE5E                     (B5+A1A4)           Small Closing Tortoise Shell Bracket
*
* + Fullwidth ASCII variants
*
*   U+FF01 (SJ+8149) (GB+A3A1) (B5+A149) (WS+A3A1) Fullwidth exclamation mark
*   U+FF02           (GB+A3A2)                     Fullwidth Quotation mark
*   U+FF05                               (WS+A3A5) Fullwidth Percent Sign
*   U+FF07           (GB+A3A7)                     Fullwidth Apostrophe
*   U+FF09 (SJ+816A) (GB+A3A9) (B5+A15E) (WS+A3A9) Fullwidth Closing parenthesis
*   U+FF0C (SJ+8143) (GB+A3AC) (B5+A141) (WS+A3AC) Fullwidth comma
*   U+FF0D           (GB+A3AD)                     Fullwidth Hyphen-minus
*   U+FF0E (SJ+8144)           (B5+A144) (WS+A3AE) Fullwidth period
*   U+FF1A           (GB+A3BA) (B4+A147) (WS+A3BA) Fullwidth colon
*   U+FF1B           (GB+A3BB) (B5+A146) (WS+A3BB) Fullwidth semicolon
*   U+FF1E (SJ+8184)                               Fullwidth Greater-than sign
*   U+FF1F (SJ+8148) (GB+A3BF) (B5+A148) (WS+A3BF) Fullwidth question mark
*   U+FF3D (SJ+816E) (GB+A3DD)           (WS+A3DD) Fullwidth Closing square bracket
*   U+FF5C                     (B5+A155)           Fullwidth Vertical Bar
*   U+FF5D (SJ+8170)           (B5+A162) (WS+A3FD) Fullwidth Closing curly bracket
*   U+FF5E           (GB+A1AB)                     Fullwidth Spacing tilde
*
* + Halfwidth Katakana variants
*
*   U+FF61 (SJ+00A1)                               Halfwidth Ideographic period
*   U+FF63 (SJ+00A3)                               Halfwidth Closing corner bracket
*   U+FF64 (SJ+00A4)                               Halfwidth Ideographic comma
*   U+FF9E (SJ+00DE)                               Halfwidth Katakana voiced sound mark
*   U+FF9F (SJ+00DF)                               Halfwidth Katakana semi-voiced sound mark
*
* + Fullwidth symbol variants
*
*   U+FFE0                               (WS+A1CB) Fullwidth Cent Sign
*
\***************************************************************************/

#if 0   // not currently used --- FYI only
/***************************************************************************\
* Start Break table
*  These character should not be the last charatcer of the line.
\***************************************************************************/

CONST BYTE aASCII_StartBreak[] = {
/* 00       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 2X */                1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
/* 3X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
/* 4X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 5X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0,
/* 6X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 7X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
};

CONST BYTE aCJKSymbol_StartBreak[] = {
/* 30       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 0X */                            1, 0, 1, 0, 1, 0, 1, 0,
/* 1X */    1, 0, 0, 0, 1
};

CONST BYTE aFullWidthHalfWidthVariants_StartBreak[] = {
/* FF       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 0X */                1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
/* 1X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
/* 2X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 3X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
/* 4X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 5X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
/* 6X */    0, 0, 1
};
#endif

/***************************************************************************\
* End Break table.
*  These character should not be the top charatcer of the line.
\***************************************************************************/

CONST BYTE aASCII_Latin1_EndBreak[] = {
/* 00       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 2X */       1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0,
/* 3X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1,
/* 4X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 5X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
/* 6X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 7X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
/* 8X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 9X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* AX */    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
/* BX */    1, 0, 0, 0, 0, 0, 0, 1
};

CONST BYTE aGeneralPunctuation_EndBreak[] = {
/* 20       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 1X */             1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0,
/* 2X */    0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
/* 3X */    0, 0, 1, 1
};

CONST BYTE aCJKSymbol_EndBreak[] = {
/* 30       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 0X */       1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1,
/* 1X */    0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1
};

CONST BYTE aCNS11643_SmallVariants_EndBreak[] = {
/* FE       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 3X */    1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
/* 4X */    1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
/* 5X */    1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1
};

CONST BYTE aFullWidthHalfWidthVariants_EndBreak[] = {
/* FF       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 0X */       1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0,
/* 1X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1,
/* 2X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 3X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
/* 4X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 5X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0,
/* 6X */    0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 7X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 8X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 9X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1
};

/***************************************************************************\
*  UserIsFELineBreak() - Detects East Asian word breaking characters.       *
*                                                                           *
* History:                                                                  *
* 10-Mar-1996 HideyukN  Created.                                            *
\***************************************************************************/

#if 0   // not currently used --- FYI only
BOOL UserIsFELineBreakStart(WCHAR wch)
{
    switch (wch>>8)
    {
        case 0x00:
            // Check if word breaking chars in ASCII.
            if ((wch >= 0x0024) && (wch <= 0x007B))
                return ((BOOL)(aASCII_StartBreak[wch - 0x0024]));
            else
                return FALSE;

        case 0x20:
            // Check if work breaking chars in "General punctuation"
            if ((wch == 0x2018) || (wch == 0x201C))
                return TRUE;
            else
                return FALSE;

        case 0x30:
            // Check if word breaking chars in "CJK symbols and punctuation"
            // and Hiragana.
            if ((wch >= 0x3008) && (wch <= 0x3014))
                return ((BOOL)(aCJKSymbol_StartBreak[wch - 0x3008]));
            else
                return FALSE;

        case 0xFF:
            // Check if word breaking chars in "Fullwidth ASCII variants",
            // "Halfwidth Katakana variants" or "Fullwidth Symbol variants".
            if ((wch >= 0xFF04) && (wch <= 0xFF62))
                return ((BOOL)(aFullWidthHalfWidthVariants_StartBreak[wch - 0xFF04]));
            else if ((wch == 0xFFE1) || (wch == 0xFFE6))
                return TRUE;
            else
                return FALSE;

        default:
            return FALSE;
    }
}
#endif

BOOL UserIsFELineBreakEnd(WCHAR wch)
{
    switch (wch>>8)
    {
        case 0x00:
            // Check if word breaking chars in ASCII or Latin1.
            if ((wch >= 0x0021) && (wch <= 0x00B7))
                return ((BOOL)(aASCII_Latin1_EndBreak[wch - 0x0021]));
            else
                return FALSE;

        case 0x02:
            // Check if work breaking chars in "Modifier letters"
            if ((wch == 0x02C7) || (wch == 0x02C9))
                return TRUE;
            else
                return FALSE;

        case 0x20:
            // Check if work breaking chars in "General punctuation"
            if ((wch >= 0x2013) && (wch <= 0x2033))
                return ((BOOL)(aGeneralPunctuation_EndBreak[wch - 0x2013]));
            else
                return FALSE;

        case 0x21:
            // Check if work breaking chars in "Letterlike symbols"
            if (wch == 0x2103)
                return TRUE;
            else
                return FALSE;

        case 0x22:
            // Check if work breaking chars in "Mathemetical opetartors"
            if (wch == 0x2236)
                return TRUE;
            else
                return FALSE;

        case 0x25:
            // Check if work breaking chars in "Form and Chart components"
            if (wch == 0x2574)
                return TRUE;
            else
                return FALSE;

        case 0x30:
            // Check if word breaking chars in "CJK symbols and punctuation"
            // and Hiragana.
            if ((wch >= 0x3001) && (wch <= 0x301E))
                return ((BOOL)(aCJKSymbol_EndBreak[wch - 0x3001]));
            else if ((wch == 0x309B) || (wch == 0x309C))
                return TRUE;
            else
                return FALSE;

        case 0xFE:
            // Check if word breaking chars in "CNS 11643 compatibility"
            // or "Small variants".
            if ((wch >= 0xFE30) && (wch <= 0xFE5E))
                return ((BOOL)(aCNS11643_SmallVariants_EndBreak[wch - 0xFE30]));
            else
                return FALSE;

        case 0xFF:
            // Check if word breaking chars in "Fullwidth ASCII variants",
            // "Halfwidth Katakana variants" or "Fullwidth symbol variants".
            if ((wch >= 0xFF01) && (wch <= 0xFF9F))
                return ((BOOL)(aFullWidthHalfWidthVariants_EndBreak[wch - 0xFF01]));
            else if (wch >= 0xFFE0)
                return TRUE;
            else
                return FALSE;

        default:
            return FALSE;
    }
}

#define UserIsFELineBreak(wChar)    UserIsFELineBreakEnd(wChar)

typedef struct _FULLWIDTH_UNICODE {
    WCHAR Start;
    WCHAR End;
} FULLWIDTH_UNICODE, *PFULLWIDTH_UNICODE;

#define NUM_FULLWIDTH_UNICODES    4

CONST FULLWIDTH_UNICODE FullWidthUnicodes[] =
{
   { 0x4E00, 0x9FFF }, // CJK_UNIFIED_IDOGRAPHS
   { 0x3040, 0x309F }, // HIRAGANA
   { 0x30A0, 0x30FF }, // KATAKANA
   { 0xAC00, 0xD7A3 }  // HANGUL
};

BOOL UserIsFullWidth(WCHAR wChar)
{
    int index;

    // Early out for ASCII.
    if (wChar < 0x0080)
    {
        // if the character < 0x0080, it should be a halfwidth character.
        return FALSE;
    }
    // Scan FullWdith definition table... most of FullWidth character is
    // defined here... this is more faster than call NLS API.
    for (index = 0; index < NUM_FULLWIDTH_UNICODES; index++)
    {
        if ((wChar >= FullWidthUnicodes[index].Start) && (wChar <= FullWidthUnicodes[index].End))
            return TRUE;
    }

    // Issue: We need one more case here to match NT5 implementation - beomoh
    // if this Unicode character is mapped to Double-Byte character,
    // this is also FullWidth character..

    return FALSE;
}

LPCWSTR GetNextWordbreak(LPCWSTR lpch,
                         LPCWSTR lpchEnd,
                         DWORD  dwFormat,
                         LPDRAWTEXTDATA lpDrawInfo)
{
    /* ichNonWhite is used to make sure we always make progress. */
    int ichNonWhite = 1;
    int ichComplexBreak = 0;        // Breaking opportunity for complex scripts
#if ((DT_WORDBREAK & ~0xff) != 0)
#error cannot use BOOLEAN for DT_WORDBREAK, or you should use "!!" before assigning it
#endif
    BOOLEAN fBreakSpace = (BOOLEAN)(dwFormat & DT_WORDBREAK);
    // If DT_WORDBREAK and DT_NOFULLWIDTHCHARBREAK are both set, we must
    // stop assuming FullWidth characters as word as we're doing in
    // NT4 and Win95. Instead, CR/LF and/or white space will only be
    // a line-break characters.
    BOOLEAN fDbcsCharBreak = (fBreakSpace && !(dwFormat & DT_NOFULLWIDTHCHARBREAK));

    // We must terminate this loop before lpch == lpchEnd, otherwise, we may gp fault during *lpch.
    while (lpch < lpchEnd)
    {
        switch (*lpch)
        {
            case CR:
            case LF:
                return lpch;

            case '\t':
            case ' ':
                if (fBreakSpace)
                    return (lpch + ichNonWhite);

            // FALL THRU //

            default:
                // Since most Japanese writing don't use space character
                // to separate each word, we define each Kanji character
                // as a word.
                if (fDbcsCharBreak && UserIsFullWidth(*lpch))
                {
                    if (!ichNonWhite)
                        return lpch;

                    // if the next character is the last character of this string,
                    // We return the character, even this is a "KINSOKU" charcter...
                    if ((lpch+1) != lpchEnd)
                    {
                        // Check next character of FullWidth character.
                        // if the next character is "KINSOKU" character, the character
                        // should be handled as a part of previous FullWidth character.
                        // Never handle is as A character, and should not be a Word also.
                        if (UserIsFELineBreak(*(lpch+1)))
                        {
                            // Then if the character is "KINSOKU" character, we return
                            // the next of this character,...
                            return (lpch + 1 + 1);
                        }
                    }
                    // Otherwise, we just return the chracter that is next of FullWidth
                    // Character. Because we treat A FullWidth chacter as A Word.
                    return (lpch + 1);
                }
                lpch++;
                ichNonWhite = 0;
        }
    }
    return lpch;
}

// This routine returns the count of accelerator mnemonics and the
// character location (starting at 0) of the character to underline.
// A single CH_PREFIX character will be striped and the following character
// underlined, all double CH_PREFIX character sequences will be replaced by
// a single CH_PREFIX (this is done by PSMTextOut). This routine is used
// to determine the actual character length of the string that will be
// printed, and the location the underline should be placed. Only
// cch characters from the input string will be processed. If the lpstrCopy
// parameter is non-NULL, this routine will make a printable copy of the
// string with all single prefix characters removed and all double prefix
// characters collapsed to a single character. If copying, a maximum
// character count must be specified which will limit the number of
// characters copied.
//
// The location of the single CH_PREFIX is returned in the low order
// word, and the count of CH_PREFIX characters that will be striped
// from the string during printing is in the hi order word. If the
// high order word is 0, the low order word is meaningless. If there
// were no single prefix characters (i.e. nothing to underline), the
// low order word will be -1 (to distinguish from location 0).
//
// These routines assume that there is only one single CH_PREFIX character
// in the string.
//
// WARNING! this rountine returns information in BYTE count not CHAR count
// (so it can easily be passed onto GreExtTextOutW which takes byte
// counts as well)
LONG GetPrefixCount(
    LPCWSTR lpstr,
    int cch,
    LPWSTR lpstrCopy,
    int charcopycount)
{
    int chprintpos = 0;         // Num of chars that will be printed
    int chcount = 0;            // Num of prefix chars that will be removed
    int chprefixloc = -1;       // Pos (in printed chars) of the prefix
    WCHAR ch;

    // If not copying, use a large bogus count...
    if (lpstrCopy == NULL)
        charcopycount = 32767;

    while ((cch-- > 0) && *lpstr && charcopycount-- != 0)
    {
        // Is this guy a prefix character ?
        if ((ch = *lpstr++) == CH_PREFIX)
        {
            // Yup - increment the count of characters removed during print.
            chcount++;

            // Is the next also a prefix char?
            if (*lpstr != CH_PREFIX)
            {
                // Nope - this is a real one, mark its location.
                chprefixloc = chprintpos;
            }
            else
            {
                // yup - simply copy it if copying.
                if (lpstrCopy != NULL)
                    *(lpstrCopy++) = CH_PREFIX;
                cch--;
                lpstr++;
                chprintpos++;
            }
        }
        else if (ch == CH_ENGLISHPREFIX)    // Still needs to be parsed
        {
            // Yup - increment the count of characters removed during print.
            chcount++;

            // Next character is a real one, mark its location.
            chprefixloc = chprintpos;
        }
        else if (ch == CH_KANJIPREFIX)    // Still needs to be parsed
        {
            // We only support Alpha Numeric(CH_ENGLISHPREFIX).
            // no support for Kana(CH_KANJIPREFIX).

            // Yup - increment the count of characters removed during print.
            chcount++;

            if(cch)
            {
                // don't copy the character
                chcount++;
                lpstr++;
                cch--;
            }
        }
        else
        {
            // Nope - just inc count of char.  that will be printed
            chprintpos++;
            if (lpstrCopy != NULL)
                *(lpstrCopy++) = ch;
        }
    }

    if (lpstrCopy != NULL)
        *lpstrCopy = 0;

    // Return the character counts
    return MAKELONG(chprefixloc, chcount);
}

// Returns total width of prefix character. Japanese Windows has
// three shortcut prefixes, '&',\036 and \037.  They may have
// different width.
int KKGetPrefixWidth(HDC hdc, LPCWSTR lpStr, int cch)
{
    SIZE size;
    SIZE iPrefix1 = {-1L,-1L};
    SIZE iPrefix2 = {-1L,-1L};
    SIZE iPrefix3 = {-1L,-1L};
    int  iTotal   = 0;

    while (cch-- > 0 && *lpStr)
    {
        switch(*lpStr)
        {
            case CH_PREFIX:
                if (lpStr[1] != CH_PREFIX)
                {
                    if (iPrefix1.cx == -1)
                        FLGetTextExtentPoint32(hdc, lpStr, 1, &iPrefix1);
                    iTotal += iPrefix1.cx;
                }
                else
                {
                    lpStr++;
                    cch--;
                }
                break;

            case CH_ENGLISHPREFIX:
                if (iPrefix2.cx == -1)
                     FLGetTextExtentPoint32(hdc, lpStr, 1, &iPrefix2);
                iTotal += iPrefix2.cx;
                break;

            case CH_KANJIPREFIX:
                if (iPrefix3.cx == -1)
                     FLGetTextExtentPoint32(hdc, lpStr, 1, &iPrefix3);
                iTotal += iPrefix3.cx;

                // In NT, always alpha numeric mode, Then we have to sum
                // KANA accel key prefix non visible char width.
                // so always add the extent for next char.
                FLGetTextExtentPoint32(hdc, lpStr, 1, &size);
                iTotal += size.cx;
                break;
            default:
                // No need to taking care of Double byte since 2nd byte of
                // DBC is grater than 0x2f but all shortcut keys are less
                // than 0x30.
                break;
        }
        lpStr++;
    }
    return iTotal;
}

// Outputs the text and puts and _ below the character with an &
// before it. Note that this routine isn't used for menus since menus
// have their own special one so that it is specialized and faster...
void PSMTextOut(
    HDC hdc,
    int xLeft,
    int yTop,
    LPWSTR lpsz,
    int cch,
    DWORD dwFlags)
{
    int cx;
    LONG textsize, result;
    WCHAR achWorkBuffer[255];
    WCHAR *pchOut = achWorkBuffer;
    TEXTMETRIC textMetric;
    SIZE size;
    RECT rc;
    COLORREF color;

    if (dwFlags & DT_NOPREFIX)
    {
        FLTextOutW(hdc, xLeft, yTop, lpsz, cch);
        return;
    }

    if (cch > sizeof(achWorkBuffer)/sizeof(WCHAR))
    {
        pchOut = (WCHAR*)LocalAlloc(LPTR, (cch+1) * sizeof(WCHAR));
        if (pchOut == NULL)
            return;
    }

    result = GetPrefixCount(lpsz, cch, pchOut, cch);

    // DT_PREFIXONLY is a new 5.0 option used when switching from keyboard cues off to on.
    if (!(dwFlags & DT_PREFIXONLY))
        FLTextOutW(hdc, xLeft, yTop, pchOut, cch - HIWORD(result));

    // Any true prefix characters to underline?
    if (LOWORD(result) == 0xFFFF || dwFlags & DT_HIDEPREFIX)
    {
        if (pchOut != achWorkBuffer)
            LocalFree(pchOut);
        return;
    }

    if (!GetTextMetrics(hdc, &textMetric))
    {
        textMetric.tmOverhang = 0;
        textMetric.tmAscent = 0;
    }

    // For proportional fonts, find starting point of underline.
    if (LOWORD(result) != 0)
    {
        // How far in does underline start (if not at 0th byte.).
        FLGetTextExtentPoint32(hdc, pchOut, LOWORD(result), &size);
        xLeft += size.cx;

        // Adjust starting point of underline if not at first char and there is
        // an overhang.  (Italics or bold fonts.)
        xLeft = xLeft - textMetric.tmOverhang;
    }

    // Adjust for proportional font when setting the length of the underline and
    // height of text.
    FLGetTextExtentPoint32(hdc, pchOut + LOWORD(result), 1, &size);
    textsize = size.cx;

    // Find the width of the underline character.  Just subtract out the overhang
    // divided by two so that we look better with italic fonts.  This is not
    // going to effect embolded fonts since their overhang is 1.
    cx = LOWORD(textsize) - textMetric.tmOverhang / 2;

    // Get height of text so that underline is at bottom.
    yTop += textMetric.tmAscent + 1;

    // Draw the underline using the foreground color.
    SetRect(&rc, xLeft, yTop, xLeft+cx, yTop+1);
    color = SetBkColor(hdc, GetTextColor(hdc));
    FLExtTextOutW(hdc, xLeft, yTop, ETO_OPAQUE, &rc, L"", 0, NULL);
    SetBkColor(hdc, color);

    if (pchOut != achWorkBuffer)
        LocalFree(pchOut);
}

int DT_GetExtentMinusPrefixes(HDC hdc, LPCWSTR lpchStr, int cchCount, UINT wFormat, int iOverhang)
{
    int iPrefixCount;
    int cxPrefixes = 0;
    WCHAR PrefixChar = CH_PREFIX;
    SIZE size;

    if (!(wFormat & DT_NOPREFIX) &&
        (iPrefixCount = HIWORD(GetPrefixCount(lpchStr, cchCount, NULL, 0))))
    {
        // Kanji Windows has three shortcut prefixes...
        if (IsOnDBCS())
        {
            // 16bit apps compatibility
            cxPrefixes = KKGetPrefixWidth(hdc, lpchStr, cchCount) - (iPrefixCount * iOverhang);
        }
        else
        {
            cxPrefixes = FLGetTextExtentPoint32(hdc, &PrefixChar, 1, &size);
            cxPrefixes = size.cx - iOverhang;
            cxPrefixes *=  iPrefixCount;
        }
    }
    FLGetTextExtentPoint32(hdc, lpchStr, cchCount, &size);
    return (size.cx - cxPrefixes);
}

// This will draw the given string in the given location without worrying
// about the left/right justification. Gets the extent and returns it.
// If fDraw is TRUE and if NOT DT_CALCRECT, this draws the text.
// NOTE: This returns the extent minus Overhang.
int DT_DrawStr(HDC hdc, int  xLeft, int yTop, LPCWSTR lpchStr,
               int cchCount, BOOL fDraw, UINT wFormat,
               LPDRAWTEXTDATA lpDrawInfo)
{
    LPCWSTR lpch;
    int     iLen;
    int     cxExtent;
    int     xOldLeft = xLeft;   // Save the xLeft given to compute the extent later
    int     xTabLength = lpDrawInfo->cxTabLength;
    int     iTabOrigin = lpDrawInfo->rcFormat.left;

    // Check if the tabs need to be expanded
    if (wFormat & DT_EXPANDTABS)
    {
        while (cchCount)
        {
            // Look for a tab
            for (iLen = 0, lpch = lpchStr; iLen < cchCount; iLen++)
                if(*lpch++ == L'\t')
                    break;

            // Draw text, if any, upto the tab
            if (iLen)
            {
                // Draw the substring taking care of the prefixes.
                if (fDraw && !(wFormat & DT_CALCRECT))  // Only if we need to draw text
                    PSMTextOut(hdc, xLeft, yTop, (LPWSTR)lpchStr, iLen, wFormat);
                // Get the extent of this sub string and add it to xLeft.
                xLeft += DT_GetExtentMinusPrefixes(hdc, lpchStr, iLen, wFormat, lpDrawInfo->cxOverhang) - lpDrawInfo->cxOverhang;
            }

            //if a TAB was found earlier, calculate the start of next sub-string.
            if (iLen < cchCount)
            {
                iLen++;  // Skip the tab
                if (xTabLength) // Tab length could be zero
                    xLeft = (((xLeft - iTabOrigin)/xTabLength) + 1)*xTabLength + iTabOrigin;
            }

            // Calculate the details of the string that remains to be drawn.
            cchCount -= iLen;
            lpchStr = lpch;
        }
        cxExtent = xLeft - xOldLeft;
    }
    else
    {
        // If required, draw the text
        if (fDraw && !(wFormat & DT_CALCRECT))
            PSMTextOut(hdc, xLeft, yTop, (LPWSTR)lpchStr, cchCount, wFormat);
        // Compute the extent of the text.
        cxExtent = DT_GetExtentMinusPrefixes(hdc, lpchStr, cchCount, wFormat, lpDrawInfo->cxOverhang) - lpDrawInfo->cxOverhang;
    }
    return cxExtent;
}

// This function draws one complete line with proper justification
void DT_DrawJustifiedLine(HDC hdc, int yTop, LPCWSTR lpchLineSt, int cchCount, UINT wFormat, LPDRAWTEXTDATA lpDrawInfo)
{
    LPRECT  lprc;
    int     cxExtent;
    int     xLeft;

    lprc = &(lpDrawInfo->rcFormat);
    xLeft = lprc->left;

    // Handle the special justifications (right or centered) properly.
    if (wFormat & (DT_CENTER | DT_RIGHT))
    {
        cxExtent = DT_DrawStr(hdc, xLeft, yTop, lpchLineSt, cchCount, FALSE, wFormat, lpDrawInfo)
                 + lpDrawInfo->cxOverhang;
        if(wFormat & DT_CENTER)
            xLeft = lprc->left + (((lprc->right - lprc->left) - cxExtent) >> 1);
        else
            xLeft = lprc->right - cxExtent;
    }
    else
        xLeft = lprc->left;

    // Draw the whole line.
    cxExtent = DT_DrawStr(hdc, xLeft, yTop, lpchLineSt, cchCount, TRUE, wFormat, lpDrawInfo)
             + lpDrawInfo->cxOverhang;
    if (cxExtent > lpDrawInfo->cxMaxExtent)
        lpDrawInfo->cxMaxExtent = cxExtent;
}

// This is called at the begining of DrawText(); This initializes the
// DRAWTEXTDATA structure passed to this function with all the required info.
BOOL DT_InitDrawTextInfo(
    HDC                 hdc,
    LPRECT              lprc,
    UINT                wFormat,
    LPDRAWTEXTDATA      lpDrawInfo,
    LPDRAWTEXTPARAMS    lpDTparams)
{
    SIZE        sizeViewPortExt = {0, 0}, sizeWindowExt = {0, 0};
    TEXTMETRIC  tm;
    LPRECT      lprcDest;
    int         iTabLength = 8;   // Default Tab length is 8 characters.
    int         iLeftMargin;
    int         iRightMargin;

    if (lpDTparams)
    {
        // Only if DT_TABSTOP flag is mentioned, we must use the iTabLength field.
        if (wFormat & DT_TABSTOP)
            iTabLength = lpDTparams->iTabLength;
        iLeftMargin = lpDTparams->iLeftMargin;
        iRightMargin = lpDTparams->iRightMargin;
    }
    else
        iLeftMargin = iRightMargin = 0;

    // Get the View port and Window extents for the given DC
    // If this call fails, hdc must be invalid
    if (!GetViewportExtEx(hdc, &sizeViewPortExt))
        return FALSE;
    GetWindowExtEx(hdc, &sizeWindowExt);

    // For the current mapping mode,  find out the sign of x from left to right.
    lpDrawInfo->iXSign = (((sizeViewPortExt.cx ^ sizeWindowExt.cx) & 0x80000000) ? -1 : 1);

    // For the current mapping mode,  find out the sign of y from top to bottom.
    lpDrawInfo->iYSign = (((sizeViewPortExt.cy ^ sizeWindowExt.cy) & 0x80000000) ? -1 : 1);

    // Calculate the dimensions of the current font in this DC.
    GetTextMetrics(hdc, &tm);

    // cyLineHeight is in pixels (This will be signed).
    lpDrawInfo->cyLineHeight = (tm.tmHeight +
        ((wFormat & DT_EXTERNALLEADING) ? tm.tmExternalLeading : 0)) * lpDrawInfo->iYSign;

    // cxTabLength is the tab length in pixels (This will not be signed)
    lpDrawInfo->cxTabLength = tm.tmAveCharWidth * iTabLength;

    // Set the cxOverhang
    lpDrawInfo->cxOverhang = tm.tmOverhang;

    // Set up the format rectangle based on the margins.
    lprcDest = &(lpDrawInfo->rcFormat);
    *lprcDest = *lprc;

    // We need to do the following only if the margins are given
    if (iLeftMargin | iRightMargin)
    {
        lprcDest->left += iLeftMargin * lpDrawInfo->iXSign;
        lprcDest->right -= (lpDrawInfo->cxRightMargin = iRightMargin * lpDrawInfo->iXSign);
    }
    else
        lpDrawInfo->cxRightMargin = 0;  // Initialize to zero.

    // cxMaxWidth is unsigned.
    lpDrawInfo->cxMaxWidth = (lprcDest->right - lprcDest->left) * lpDrawInfo->iXSign;
    lpDrawInfo->cxMaxExtent = 0;  // Initialize this to zero.

    return TRUE;
}

// In the case of WORDWRAP, we need to treat the white spaces at the
// begining/end of each line specially. This function does that.
// lpStNext = points to the begining of next line.
// lpiCount = points to the count of characters in the current line.
LPCWSTR  DT_AdjustWhiteSpaces(LPCWSTR lpStNext, LPINT lpiCount, UINT wFormat)
{
    switch (wFormat & DT_HFMTMASK)
    {
        case DT_LEFT:
            // Prevent a white space at the begining of a left justfied text.
            // Is there a white space at the begining of next line......
            if ((*lpStNext == L' ') || (*lpStNext == L'\t'))
            {
                // ...then, exclude it from next line.
                lpStNext++;
            }
            break;

        case DT_RIGHT:
            // Prevent a white space at the end of a RIGHT justified text.
            // Is there a white space at the end of current line,.......
            if ((*(lpStNext-1) == L' ') || (*(lpStNext - 1) == L'\t'))
            {
                // .....then, Skip the white space from the current line.
                (*lpiCount)--;
            }
            break;

        case DT_CENTER:
            // Exclude white spaces from the begining and end of CENTERed lines.
            // If there is a white space at the end of current line.......
            if ((*(lpStNext-1) == L' ') || (*(lpStNext - 1) == L'\t'))
                (*lpiCount)--;    //...., don't count it for justification.
            // If there is a white space at the begining of next line.......
            if ((*lpStNext == L' ') || (*lpStNext == L'\t'))
                lpStNext++;       //...., exclude it from next line.
            break;
    }
    return lpStNext;
}

// A word needs to be broken across lines and this finds out where to break it.
LPCWSTR  DT_BreakAWord(HDC hdc, LPCWSTR lpchText, int iLength, int iWidth, UINT wFormat, int iOverhang)
{
  int  iLow = 0, iHigh = iLength;
  int  iNew;

  while ((iHigh - iLow) > 1)
  {
      iNew = iLow + (iHigh - iLow)/2;
      if(DT_GetExtentMinusPrefixes(hdc, lpchText, iNew, wFormat, iOverhang) > iWidth)
          iHigh = iNew;
      else
          iLow = iNew;
  }
  // If the width is too low, we must print atleast one char per line.
  // Else, we will be in an infinite loop.
  if(!iLow && iLength)
      iLow = 1;
  return (lpchText+iLow);
}

// This finds out the location where we can break a line.
// Returns LPCSTR to the begining of next line.
// Also returns via lpiLineLength, the length of the current line.
// NOTE: (lpstNextLineStart - lpstCurrentLineStart) is not equal to the
// line length; This is because, we exclude some white spaces at the begining
// and/or end of lines; Also, CR/LF is excluded from the line length.
LPWSTR DT_GetLineBreak(
    HDC             hdc,
    LPCWSTR         lpchLineStart,
    int             cchCount,
    DWORD           dwFormat,
    LPINT           lpiLineLength,
    LPDRAWTEXTDATA  lpDrawInfo)
{
    LPCWSTR lpchText, lpchEnd, lpch, lpchLineEnd;
    int   cxStart, cxExtent, cxNewExtent;
    BOOL  fAdjustWhiteSpaces = FALSE;
    WCHAR ch;

    cxStart = lpDrawInfo->rcFormat.left;
    cxExtent = cxNewExtent = 0;
    lpchText = lpchLineStart;
    lpchEnd = lpchLineStart + cchCount;
    lpch = lpchEnd;
    lpchLineEnd = lpchEnd;

    while(lpchText < lpchEnd)
    {
        lpchLineEnd = lpch = GetNextWordbreak(lpchText, lpchEnd, dwFormat, lpDrawInfo);
        // DT_DrawStr does not return the overhang; Otherwise we will end up
        // adding one overhang for every word in the string.

        // For simulated Bold fonts, the summation of extents of individual
        // words in a line is greater than the extent of the whole line. So,
        // always calculate extent from the LineStart.
        // BUGTAG: #6054 -- Win95B -- SANKAR -- 3/9/95 --
        cxNewExtent = DT_DrawStr(hdc, cxStart, 0, lpchLineStart, (int)(((PBYTE)lpch - (PBYTE)lpchLineStart)/sizeof(WCHAR)),
                                 FALSE, dwFormat, lpDrawInfo);

        if ((dwFormat & DT_WORDBREAK) && ((cxNewExtent + lpDrawInfo->cxOverhang) > lpDrawInfo->cxMaxWidth))
        {
            // Are there more than one word in this line?
            if (lpchText != lpchLineStart)
            {
                lpchLineEnd = lpch = lpchText;
                fAdjustWhiteSpaces = TRUE;
            }
            else
            {
                //One word is longer than the maximum width permissible.
                //See if we are allowed to break that single word.
                if((dwFormat & DT_EDITCONTROL) && !(dwFormat & DT_WORD_ELLIPSIS))
                {
                    lpchLineEnd = lpch = DT_BreakAWord(hdc, lpchText, (int)(((PBYTE)lpch - (PBYTE)lpchText)/sizeof(WCHAR)),
                          lpDrawInfo->cxMaxWidth - cxExtent, dwFormat, lpDrawInfo->cxOverhang); //Break that word
                    //Note: Since we broke in the middle of a word, no need to
                    // adjust for white spaces.
                }
                else
                {
                    fAdjustWhiteSpaces = TRUE;
                    // Check if we need to end this line with ellipsis
                    if(dwFormat & DT_WORD_ELLIPSIS)
                    {
                        // Don't do this if already at the end of the string.
                        if (lpch < lpchEnd)
                        {
                            // If there are CR/LF at the end, skip them.
                            if ((ch = *lpch) == CR || ch == LF)
                            {
                                if ((++lpch < lpchEnd) && (*lpch == (WCHAR)(ch ^ (LF ^ CR))))
                                    lpch++;
                                fAdjustWhiteSpaces = FALSE;
                            }
                        }
                    }
                }
            }
            // Well! We found a place to break the line. Let us break from this loop;
            break;
        }
        else
        {
            // Don't do this if already at the end of the string.
            if (lpch < lpchEnd)
            {
                if ((ch = *lpch) == CR || ch == LF)
                {
                    if ((++lpch < lpchEnd) && (*lpch == (WCHAR)(ch ^ (LF ^ CR))))
                        lpch++;
                    fAdjustWhiteSpaces = FALSE;
                    break;
                }
            }
        }
        // Point at the beginning of the next word.
        lpchText = lpch;
        cxExtent = cxNewExtent;
    }
    // Calculate the length of current line.
    *lpiLineLength = (INT)((PBYTE)lpchLineEnd - (PBYTE)lpchLineStart)/sizeof(WCHAR);

    // Adjust the line length and lpch to take care of spaces.
    if(fAdjustWhiteSpaces && (lpch < lpchEnd))
        lpch = DT_AdjustWhiteSpaces(lpch, lpiLineLength, dwFormat);

    // return the begining of next line;
    return (LPWSTR)lpch;
}

// This function checks whether the given string fits within the given
// width or we need to add end-ellipse. If it required end-ellipses, it
// returns TRUE and it returns the number of characters that are saved
// in the given string via lpCount.
BOOL  NeedsEndEllipsis(
    HDC             hdc,
    LPCWSTR         lpchText,
    LPINT           lpCount,
    LPDRAWTEXTDATA  lpDTdata,
    UINT            wFormat)
{
    int   cchText;
    int   ichMin, ichMax, ichMid;
    int   cxMaxWidth;
    int   iOverhang;
    int   cxExtent;
    SIZE size;
    cchText = *lpCount;  // Get the current count.

    if (cchText == 0)
        return FALSE;

    cxMaxWidth  = lpDTdata->cxMaxWidth;
    iOverhang   = lpDTdata->cxOverhang;

    cxExtent = DT_GetExtentMinusPrefixes(hdc, lpchText, cchText, wFormat, iOverhang);

    if (cxExtent <= cxMaxWidth)
        return FALSE;
    // Reserve room for the "..." ellipses;
    // (Assumption: The ellipses don't have any prefixes!)
    FLGetTextExtentPoint32(hdc, szEllipsis, CCHELLIPSIS, &size);
    cxMaxWidth -= size.cx - iOverhang;

    // If no room for ellipses, always show first character.
    //
    ichMax = 1;
    if (cxMaxWidth > 0)
    {
        // Binary search to find characters that will fit.
        ichMin = 0;
        ichMax = cchText;
        while (ichMin < ichMax)
        {
            // Be sure to round up, to make sure we make progress in
            // the loop if ichMax == ichMin + 1.
            ichMid = (ichMin + ichMax + 1) / 2;

            cxExtent = DT_GetExtentMinusPrefixes(hdc, lpchText, ichMid, wFormat, iOverhang);

            if (cxExtent < cxMaxWidth)
                ichMin = ichMid;
            else
            {
                if (cxExtent > cxMaxWidth)
                    ichMax = ichMid - 1;
                else
                {
                    // Exact match up up to ichMid: just exit.
                    ichMax = ichMid;
                    break;
                }
            }
        }
        // Make sure we always show at least the first character...
        if (ichMax < 1)
            ichMax = 1;
    }
    *lpCount = ichMax;
    return TRUE;
}

// Returns a pointer to the last component of a path string.
//
// in:
//      path name, either fully qualified or not
//
// returns:
//      pointer into the path where the path is.  if none is found
//      returns a poiter to the start of the path
//
//  c:\foo\bar  -> bar
//  c:\foo      -> foo
//  c:\foo\     -> c:\foo\      (REVIEW: is this case busted?)
//  c:\         -> c:\          (REVIEW: this case is strange)
//  c:          -> c:
//  foo         -> foo
LPWSTR PathFindFileName(LPCWSTR pPath, int cchText)
{
    LPCWSTR pT;

    for (pT = pPath; cchText > 0 && *pPath; pPath++, cchText--)
    {
        if ((pPath[0] == L'\\' || pPath[0] == L':') && pPath[1])
            pT = pPath + 1;
    }
    return (LPWSTR)pT;
}

// This adds a path ellipse to the given path name.
// Returns TRUE if the resultant string's extent is less the the
// cxMaxWidth. FALSE, if otherwise.
int AddPathEllipsis(
    HDC    hdc,
    LPWSTR lpszPath,
    int    cchText,
    UINT   wFormat,
    int    cxMaxWidth,
    int    iOverhang)
{
    int    iLen;
    UINT   dxFixed, dxEllipsis;
    LPWSTR lpEnd;          /* end of the unfixed string */
    LPWSTR lpFixed;        /* start of text that we always display */
    BOOL   bEllipsisIn;
    int    iLenFixed;
    SIZE   size;

    lpFixed = PathFindFileName(lpszPath, cchText);
    if (lpFixed != lpszPath)
        lpFixed--;  // point at the slash
    else
        return cchText;

    lpEnd = lpFixed;
    bEllipsisIn = FALSE;
    iLenFixed = cchText - (int)(lpFixed - lpszPath);
    dxFixed = DT_GetExtentMinusPrefixes(hdc, lpFixed, iLenFixed, wFormat, iOverhang);

    // It is assumed that the "..." string does not have any prefixes ('&').
    FLGetTextExtentPoint32(hdc, szEllipsis, CCHELLIPSIS, &size);
    dxEllipsis = size.cx - iOverhang;

    while (TRUE)
    {
        iLen = dxFixed + DT_GetExtentMinusPrefixes(hdc, lpszPath, (int)((PBYTE)lpEnd - (PBYTE)lpszPath)/sizeof(WCHAR),
                                                   wFormat, iOverhang) - iOverhang;

        if (bEllipsisIn)
            iLen += dxEllipsis;

        if (iLen <= cxMaxWidth)
            break;

        bEllipsisIn = TRUE;

        if (lpEnd <= lpszPath)
        {
            // Things didn't fit.
            lpEnd = lpszPath;
            break;
        }
        // Step back a character.
        lpEnd--;
    }

    if (bEllipsisIn && (lpEnd + CCHELLIPSIS < lpFixed))
    {
        // NOTE: the strings could over lap here. So, we use LCopyStruct.
        MoveMemory((lpEnd + CCHELLIPSIS), lpFixed, iLenFixed * sizeof(WCHAR));
        CopyMemory(lpEnd, szEllipsis, CCHELLIPSIS * sizeof(WCHAR));

        cchText = (int)(lpEnd - lpszPath) + CCHELLIPSIS + iLenFixed;

        // now we can NULL terminate the string
        *(lpszPath + cchText) = L'\0';
    }
    return cchText;
}

// This function returns the number of characters actually drawn.
int AddEllipsisAndDrawLine(
    HDC            hdc,
    int            yLine,
    LPCWSTR        lpchText,
    int            cchText,
    DWORD          dwDTformat,
    LPDRAWTEXTDATA lpDrawInfo)
{
    LPWSTR pEllipsis = NULL;
    WCHAR  szTempBuff[MAXBUFFSIZE];
    LPWSTR lpDest;
    BOOL   fAlreadyCopied = FALSE;

    // Check if this is a filename with a path AND
    // Check if the width is too narrow to hold all the text.
    if ((dwDTformat & DT_PATH_ELLIPSIS) &&
        ((DT_GetExtentMinusPrefixes(hdc, lpchText, cchText, dwDTformat, lpDrawInfo->cxOverhang)) > lpDrawInfo->cxMaxWidth))
    {
        // We need to add Path-Ellipsis. See if we can do it in-place.
        if (!(dwDTformat & DT_MODIFYSTRING)) {
            // NOTE: When you add Path-Ellipsis, the string could grow by
            // CCHELLIPSIS bytes.
            if((cchText + CCHELLIPSIS + 1) <= MAXBUFFSIZE)
                lpDest = szTempBuff;
            else
            {
                // Alloc the buffer from local heap.
                if(!(pEllipsis = (LPWSTR)LocalAlloc(LPTR, (cchText+CCHELLIPSIS+1)*sizeof(WCHAR))))
                    return 0;
                lpDest = (LPWSTR)pEllipsis;
            }
            // Source String may not be NULL terminated. So, copy just
            // the given number of characters.
            CopyMemory(lpDest, lpchText, cchText*sizeof(WCHAR));
            lpchText = lpDest;        // lpchText points to the copied buff.
            fAlreadyCopied = TRUE;    // Local copy has been made.
        }
        // Add the path ellipsis now!
        cchText = AddPathEllipsis(hdc, (LPWSTR)lpchText, cchText, dwDTformat, lpDrawInfo->cxMaxWidth, lpDrawInfo->cxOverhang);
    }

    // Check if end-ellipsis are to be added.
    if ((dwDTformat & (DT_END_ELLIPSIS | DT_WORD_ELLIPSIS)) &&
        NeedsEndEllipsis(hdc, lpchText, &cchText, lpDrawInfo, dwDTformat))
    {
        // We need to add end-ellipsis; See if we can do it in-place.
        if (!(dwDTformat & DT_MODIFYSTRING) && !fAlreadyCopied)
        {
            // See if the string is small enough for the buff on stack.
            if ((cchText+CCHELLIPSIS+1) <= MAXBUFFSIZE)
                lpDest = szTempBuff;  // If so, use it.
            else {
                // Alloc the buffer from local heap.
                if (!(pEllipsis = (LPWSTR)LocalAlloc(LPTR, (cchText+CCHELLIPSIS+1)*sizeof(WCHAR))))
                    return 0;
                lpDest = pEllipsis;
            }
            // Make a copy of the string in the local buff.
            CopyMemory(lpDest, lpchText, cchText*sizeof(WCHAR));
            lpchText = lpDest;
        }
        // Add an end-ellipsis at the proper place.
        CopyMemory((LPWSTR)(lpchText+cchText), szEllipsis, (CCHELLIPSIS+1)*sizeof(WCHAR));
        cchText += CCHELLIPSIS;
    }

    // Draw the line that we just formed.
    DT_DrawJustifiedLine(hdc, yLine, lpchText, cchText, dwDTformat, lpDrawInfo);

    // Free the block allocated for End-Ellipsis.
    if (pEllipsis)
        LocalFree(pEllipsis);

    return cchText;
}

BOOL IsComplexScriptPresent(LPWSTR lpchText, int cchText)
{
    if (g_bComplexPlatform) {
        for (int i = 0; i < cchText; i++) {
            if (InRange(lpchText[i], 0x0590, 0x0FFF)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

int  FLDrawTextExPrivW(
   HDC               hdc,
   LPWSTR            lpchText,
   int               cchText,
   LPRECT           lprc,
   UINT              dwDTformat,
   LPDRAWTEXTPARAMS  lpDTparams)
{
    DRAWTEXTDATA DrawInfo;
    WORD         wFormat = LOWORD(dwDTformat);
    LPWSTR       lpchTextBegin;
    LPWSTR       lpchEnd;
    LPWSTR       lpchNextLineSt;
    int          iLineLength;
    int          iySign;
    int          yLine;
    int          yLastLineHeight;
    HRGN         hrgnClip;
    int          iLineCount;
    RECT         rc;
    BOOL         fLastLine;
    WCHAR        ch;
    UINT         oldAlign;

    // On NT5, we use system API behavior including fontlink
    if (IsOnNT5())
        return DrawTextExW(hdc, lpchText, cchText, lprc, dwDTformat, lpDTparams);

    if ((cchText == 0) && lpchText && (*lpchText))
    {
        // infoview.exe passes lpchText that points to '\0'
        // Lotus Notes doesn't like getting a zero return here
        return 1;
    }

    if (cchText == -1)
        cchText = lstrlenW(lpchText);
    else if (lpchText[cchText - 1] == L'\0')
        cchText--;      // accommodate counting of NULLS for ME

    // We got the string length, then check if it a complex string or not.
    // If yes then call the system DrawTextEx API to do the job it knows how to
    // handle the complex scripts.
    if (IsComplexScriptPresent(lpchText, cchText))
    {
        if (IsOnNT())
        {
            //Call the system DrawtextExW
            return DrawTextExW(hdc, lpchText, cchText, lprc, dwDTformat, lpDTparams);
        }
        HFONT hfont    = NULL;
        HFONT hfontSav = NULL;
        int iRet;

        if (hfont = GetBiDiFont(hdc))
            hfontSav = (HFONT)SelectObject(hdc, hfont);

        WtoA szText(lpchText, cchText);
        iRet = DrawTextExA(hdc, szText, lstrlen(szText), lprc, dwDTformat, lpDTparams);

        if (hfont)
        {
            SelectObject(hdc, hfontSav);
            DeleteObject(hfont);
        }
        return iRet;
    }

    if ((lpDTparams) && (lpDTparams->cbSize != sizeof(DRAWTEXTPARAMS)))
    {
        ASSERT(0 && "DrawTextExWorker: cbSize is invalid");
        return 0;
    }


    // If DT_MODIFYSTRING is specified, then check for read-write pointer.
    if ((dwDTformat & DT_MODIFYSTRING) &&
        (dwDTformat & (DT_END_ELLIPSIS | DT_PATH_ELLIPSIS)))
    {
        if(IsBadWritePtr(lpchText, cchText))
        {
            ASSERT(0 && "DrawTextExWorker: For DT_MODIFYSTRING, lpchText must be read-write");
            return 0;
        }
    }

    // Initialize the DrawInfo structure.
    if (!DT_InitDrawTextInfo(hdc, lprc, dwDTformat, (LPDRAWTEXTDATA)&DrawInfo, lpDTparams))
        return 0;

    // If the rect is too narrow or the margins are too wide.....Just forget it!
    //
    // If wordbreak is specified, the MaxWidth must be a reasonable value.
    // This check is sufficient because this will allow CALCRECT and NOCLIP
    // cases.  --SANKAR.
    //
    // This also fixed all of our known problems with AppStudio.
    if (DrawInfo.cxMaxWidth <= 0)
    {
        if (wFormat & DT_WORDBREAK)
        {
            ASSERT(0 && "DrawTextExW: FAILURE DrawInfo.cxMaxWidth <= 0");
            return 1;
        }
    }

    // if we're not doing the drawing, initialise the lpk-dll
    if (dwDTformat & DT_RTLREADING)
        oldAlign = SetTextAlign(hdc, TA_RTLREADING | GetTextAlign(hdc));

    // If we need to clip, let us do that.
    if (!(wFormat & DT_NOCLIP))
    {
        // Save clipping region so we can restore it later.
        hrgnClip = CreateRectRgn(0,0,0,0);
        if (hrgnClip != NULL)
        {
            if (GetClipRgn(hdc, hrgnClip) != 1)
            {
                DeleteObject(hrgnClip);
                hrgnClip = (HRGN)-1;
            }
            rc = *lprc;
            IntersectClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);
        }
    }
    else
        hrgnClip = NULL;

    lpchTextBegin = lpchText;
    lpchEnd = lpchText + cchText;

ProcessDrawText:

    iLineCount = 0;  // Reset number of lines to 1.
    yLine = lprc->top;

    if (wFormat & DT_SINGLELINE)
    {
        iLineCount = 1;  // It is a single line.

        // Process single line DrawText.
        switch (wFormat & DT_VFMTMASK)
        {
            case DT_BOTTOM:
                yLine = lprc->bottom - DrawInfo.cyLineHeight;
                break;

            case DT_VCENTER:
                yLine = lprc->top + ((lprc->bottom - lprc->top - DrawInfo.cyLineHeight) / 2);
                break;
        }

        cchText = AddEllipsisAndDrawLine(hdc, yLine, lpchText, cchText, dwDTformat, &DrawInfo);
        yLine += DrawInfo.cyLineHeight;
        lpchText += cchText;
    }
    else
    {
        // Multiline
        // If the height of the rectangle is not an integral multiple of the
        // average char height, then it is possible that the last line drawn
        // is only partially visible. However, if DT_EDITCONTROL style is
        // specified, then we must make sure that the last line is not drawn if
        // it is going to be partially visible. This will help imitate the
        // appearance of an edit control.
        if (wFormat & DT_EDITCONTROL)
            yLastLineHeight = DrawInfo.cyLineHeight;
        else
            yLastLineHeight = 0;

        iySign = DrawInfo.iYSign;
        fLastLine = FALSE;
        // Process multiline DrawText.
        while ((lpchText < lpchEnd) && (!fLastLine))
        {
            // Check if the line we are about to draw is the last line that needs
            // to be drawn.
            // Let us check if the display goes out of the clip rect and if so
            // let us stop here, as an optimisation;
            if (!(wFormat & DT_CALCRECT) && // We don't need to calc rect?
                !(wFormat & DT_NOCLIP) &&   // Must we clip the display ?
                                            // Are we outside the rect?
                ((yLine + DrawInfo.cyLineHeight + yLastLineHeight)*iySign > (lprc->bottom*iySign)))
            {
                fLastLine = TRUE;    // Let us quit this loop
            }

            // We do the Ellipsis processing only for the last line.
            if (fLastLine && (dwDTformat & (DT_END_ELLIPSIS | DT_PATH_ELLIPSIS)))
                lpchText += AddEllipsisAndDrawLine(hdc, yLine, lpchText, cchText, dwDTformat, &DrawInfo);
            else
            {
                lpchNextLineSt = (LPWSTR)DT_GetLineBreak(hdc, lpchText, cchText, dwDTformat, &iLineLength, &DrawInfo);

                // Check if we need to put ellipsis at the end of this line.
                // Also check if this is the last line.
                if ((dwDTformat & DT_WORD_ELLIPSIS) ||
                    ((lpchNextLineSt >= lpchEnd) && (dwDTformat & (DT_END_ELLIPSIS | DT_PATH_ELLIPSIS))))
                    AddEllipsisAndDrawLine(hdc, yLine, lpchText, iLineLength, dwDTformat, &DrawInfo);
                else
                    DT_DrawJustifiedLine(hdc, yLine, lpchText, iLineLength, dwDTformat, &DrawInfo);
                cchText -= (int)((PBYTE)lpchNextLineSt - (PBYTE)lpchText) / sizeof(WCHAR);
                lpchText = lpchNextLineSt;
            }
            iLineCount++; // We draw one more line.
            yLine += DrawInfo.cyLineHeight;
        }

        // For Win3.1 and NT compatibility, if the last char is a CR or a LF
        // then the height returned includes one more line.
        if (!(dwDTformat & DT_EDITCONTROL) &&
            (lpchEnd > lpchTextBegin) &&   // If zero length it will fault.
            (((ch = (*(lpchEnd-1))) == CR) || (ch == LF)))
            yLine += DrawInfo.cyLineHeight;
    }

    // If DT_CALCRECT, modify width and height of rectangle to include
    // all of the text drawn.
    if (wFormat & DT_CALCRECT)
    {
        DrawInfo.rcFormat.right = DrawInfo.rcFormat.left + DrawInfo.cxMaxExtent * DrawInfo.iXSign;
        lprc->right = DrawInfo.rcFormat.right + DrawInfo.cxRightMargin;

        // If the Width is more than what was provided, we have to redo all
        // the calculations, because, the number of lines can be less now.
        // (We need to do this only if we have more than one line).
        if((iLineCount > 1) && (DrawInfo.cxMaxExtent > DrawInfo.cxMaxWidth))
        {
            DrawInfo.cxMaxWidth = DrawInfo.cxMaxExtent;
            lpchText = lpchTextBegin;
            cchText = (int)((PBYTE)lpchEnd - (PBYTE)lpchTextBegin) / sizeof(WCHAR);
            goto  ProcessDrawText;  // Start all over again!
        }
        lprc->bottom = yLine;
    }

    if (hrgnClip != NULL)
    {
        if (hrgnClip == (HRGN)-1)
            ExtSelectClipRgn(hdc, NULL, RGN_COPY);
        else
        {
            ExtSelectClipRgn(hdc, hrgnClip, RGN_COPY);
            DeleteObject(hrgnClip);
        }
    }

    if (dwDTformat & DT_RTLREADING)
        SetTextAlign(hdc, oldAlign);

    // Copy the number of characters actually drawn
    if(lpDTparams != NULL)
        lpDTparams->uiLengthDrawn = (UINT)((PBYTE)lpchText - (PBYTE)lpchTextBegin) / sizeof(WCHAR);

    if (yLine == lprc->top)
        return 1;

    return (yLine - lprc->top);
}

int FLDrawTextW(HDC hdc, LPCWSTR lpchText, int cchText, LPCRECT lprc, UINT format)
{
    DRAWTEXTPARAMS DTparams;
    LPDRAWTEXTPARAMS lpDTparams = NULL;

    if (cchText < -1)
        return(0);

    if (format & DT_TABSTOP)
    {
        DTparams.cbSize      = sizeof(DRAWTEXTPARAMS);
        DTparams.iLeftMargin = DTparams.iRightMargin = 0;
        DTparams.iTabLength  = (format & 0xff00) >> 8;
        lpDTparams           = &DTparams;
        format              &= 0xffff00ff;
    }
    return FLDrawTextExPrivW(hdc, (LPWSTR)lpchText, cchText, (LPRECT)lprc, format, lpDTparams);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\editcb.cpp ===
//
// editcb.cpp
//
// CEditSession
//

#include "private.h"
#include "editcb.h"

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CEditSession::CEditSession(ESCALLBACK pfnCallback)
{
    _pfnCallback = pfnCallback;
    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CEditSession::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfEditSession))
    {
        *ppvObj = SAFECAST(this, CEditSession *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CEditSession::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CEditSession::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// DoEditSession
//
//----------------------------------------------------------------------------

STDAPI CEditSession::DoEditSession(TfEditCookie ec)
{
    return _pfnCallback(ec, this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\flshare.h ===
//
// flshare.h
//


typedef  struct   {
    RECT     rcFormat;          // Format rectangle.
    int      cxTabLength;       // Tab length in pixels.
    int      iXSign;
    int      iYSign;
    int      cyLineHeight;      // Height of a line based on DT_EXTERNALLEADING
    int      cxMaxWidth;        // Width of the format rectangle.
    int      cxMaxExtent;       // Width of the longest line drawn.
    int      cxRightMargin;     // Right margin in pixels (with proper sign) on DT_NOPREFIX flag.
    int      cxOverhang;        // Character overhang.
} DRAWTEXTDATA, *LPDRAWTEXTDATA;

typedef  struct   {
    RECT     rcFormat;          // Format rectangle.
    int      cyTabLength;       // Tab length in pixels.
    int      iXSign;
    int      iYSign;
    int      cxLineHeight;      // Height of a line based on DT_EXTERNALLEADING
    int      cyMaxWidth;        // Width of the format rectangle.
    int      cyMaxExtent;       // Width of the longest line drawn.
    int      cyBottomMargin;     // Right margin in pixels (with proper sign) on DT_NOPREFIX flag.
    int      cyOverhang;        // Character overhang.
} DRAWTEXTDATAVERT, *LPDRAWTEXTDATAVERT;

#define CR          13
#define LF          10
#define DT_HFMTMASK 0x03
#define DT_VFMTMASK 0x0C

// FE support both Kanji and English mnemonic characters,
// toggled from control panel.  Both mnemonics are embedded in menu
// resource templates.  The following prefixes guide their parsing.
#define CH_ENGLISHPREFIX 0x1E
#define CH_KANJIPREFIX   0x1F

#define CH_PREFIX L'&'

#define CCHELLIPSIS 3
extern const WCHAR szEllipsis[];


// Max length of a full path is around 260. But, most of the time, it will
// be less than 128. So, we alloc only this much on stack. If the string is
// longer, we alloc from local heap (which is slower).
//
// BOGUS: For international versions, we need to give some more margin here.
//
#define MAXBUFFSIZE     128

HFONT GetBiDiFont(HDC hdc);
BOOL UserIsFELineBreakEnd(WCHAR wch);
BOOL UserIsFullWidth(WCHAR wChar);
LPCWSTR GetNextWordbreak(LPCWSTR lpch, LPCWSTR lpchEnd, DWORD  dwFormat, LPDRAWTEXTDATA lpDrawInfo);

LPCWSTR  DT_AdjustWhiteSpaces(LPCWSTR lpStNext, LPINT lpiCount, UINT wFormat);
LONG GetPrefixCount( LPCWSTR lpstr, int cch, LPWSTR lpstrCopy, int charcopycount);
int KKGetPrefixWidth(HDC hdc, LPCWSTR lpStr, int cch);
LPWSTR PathFindFileName(LPCWSTR pPath, int cchText);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\dispattr.cpp ===
#include "private.h"
#include "globals.h"
#include "dispattr.h"
#include "proputil.h"
#include "catutil.h"
#include "ctffunc.h"
#include "helpers.h"
#include "ciccs.h"

extern CCicCriticalSectionStatic g_cs;
CDispAttrPropCache *g_pPropCache = NULL;

//+---------------------------------------------------------------------------
//
//  GetDAMLib
//
//----------------------------------------------------------------------------

ITfDisplayAttributeMgr *GetDAMLib(LIBTHREAD *plt) 
{
   return plt->_pDAM;
}

//+---------------------------------------------------------------------------
//
//  InitDisplayAttributeLib
//
//----------------------------------------------------------------------------

HRESULT InitDisplayAttrbuteLib(LIBTHREAD *plt)
{
    IEnumGUID *pEnumProp = NULL;

    if ( plt == NULL )
        return E_FAIL;

    if (plt->_pDAM)
        plt->_pDAM->Release();

    plt->_pDAM = NULL;

    if (FAILED(g_pfnCoCreate(CLSID_TF_DisplayAttributeMgr,
                                   NULL, 
                                   CLSCTX_INPROC_SERVER, 
                                   IID_ITfDisplayAttributeMgr, 
                                   (void**)&plt->_pDAM)))
    {
        return E_FAIL;
    }

    LibEnumItemsInCategory(plt, GUID_TFCAT_DISPLAYATTRIBUTEPROPERTY, &pEnumProp);

    HRESULT hr;

    EnterCriticalSection(g_cs);
    //
    // make a database for Display Attribute Properties.
    //
    if (pEnumProp && !g_pPropCache)
    {
         GUID guidProp;
         g_pPropCache = new CDispAttrPropCache;

         if (!g_pPropCache)
         {
              hr = E_OUTOFMEMORY;
              goto Exit;
         }

         //
         // add System Display Attribute first.
         // so no other Display Attribute property overwrite it.
         //
         g_pPropCache->Add(GUID_PROP_ATTRIBUTE);
         while(pEnumProp->Next(1, &guidProp, NULL) == S_OK)
         {
             if (!IsEqualGUID(guidProp, GUID_PROP_ATTRIBUTE))
                 g_pPropCache->Add(guidProp);
         }
    }

    hr = S_OK;

Exit:
    LeaveCriticalSection(g_cs);

    SafeRelease(pEnumProp);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  UninitDisplayAttributeLib
//
//----------------------------------------------------------------------------

HRESULT UninitDisplayAttrbuteLib(LIBTHREAD *plt)
{
    Assert(plt);
    if ( plt == NULL )
        return E_FAIL;

    if (plt->_pDAM)
        plt->_pDAM->Release();

    plt->_pDAM = NULL;

    // if (plt->_fDAMCoInit)
    //     CoUninitialize();
    // 
    // plt->_fDAMCoInit = FALSE;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  GetDisplayAttributeTrackPropertyRange
//
//----------------------------------------------------------------------------

HRESULT GetDisplayAttributeTrackPropertyRange(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfReadOnlyProperty **ppProp, IEnumTfRanges **ppEnum, ULONG *pulNumProp)

{
    ITfReadOnlyProperty *pProp = NULL;
    HRESULT hr = E_FAIL;
    GUID  *pguidProp = NULL;
    const GUID **ppguidProp;
    ULONG ulNumProp = 0;
    ULONG i;

    EnterCriticalSection(g_cs);

    if (!g_pPropCache)
        goto Exit;
 
    pguidProp = g_pPropCache->GetPropTable();
    if (!pguidProp)
        goto Exit;

    ulNumProp = g_pPropCache->Count();
    if (!ulNumProp)
        goto Exit;

    // TrackProperties wants an array of GUID *'s
    if ((ppguidProp = (const GUID **)cicMemAlloc(sizeof(GUID *)*ulNumProp)) == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    for (i=0; i<ulNumProp; i++)
    {
        ppguidProp[i] = pguidProp++;
    }
    
    if (SUCCEEDED(hr = pic->TrackProperties(ppguidProp, 
                                            ulNumProp,
                                            0,
                                            NULL,
                                            &pProp)))
    {
        hr = pProp->EnumRanges(ec, ppEnum, pRange);
        if (SUCCEEDED(hr))
        {
            *ppProp = pProp;
            pProp->AddRef();
        }
        pProp->Release();
    }

    cicMemFree(ppguidProp);

    if (SUCCEEDED(hr))
        *pulNumProp = ulNumProp;
    
Exit:
    LeaveCriticalSection(g_cs);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  GetDisplayAttributeData
//
//----------------------------------------------------------------------------

HRESULT GetDisplayAttributeData(LIBTHREAD *plt, TfEditCookie ec, ITfReadOnlyProperty *pProp, ITfRange *pRange, TF_DISPLAYATTRIBUTE *pda, TfGuidAtom *pguid, ULONG  ulNumProp)
{
    VARIANT var;
    IEnumTfPropertyValue *pEnumPropertyVal;
    TF_PROPERTYVAL tfPropVal;
    GUID guid;
    TfGuidAtom gaVal;
    ITfDisplayAttributeInfo *pDAI;

    HRESULT hr = E_FAIL;

    if (SUCCEEDED(pProp->GetValue(ec, pRange, &var)))
    {
        Assert(var.vt == VT_UNKNOWN);

        if (SUCCEEDED(var.punkVal->QueryInterface(IID_IEnumTfPropertyValue, 
                                                  (void **)&pEnumPropertyVal)))
        {
            while (pEnumPropertyVal->Next(1, &tfPropVal, NULL) == S_OK)
            {
                if (tfPropVal.varValue.vt == VT_EMPTY)
                    continue; // prop has no value over this span

                Assert(tfPropVal.varValue.vt == VT_I4); // expecting GUIDATOMs

                gaVal = (TfGuidAtom)tfPropVal.varValue.lVal;

                GetGUIDFromGUIDATOM(plt, gaVal, &guid);

                if ((plt != NULL) && SUCCEEDED(plt->_pDAM->GetDisplayAttributeInfo(guid, &pDAI, NULL)))
                {
                    //
                    // Issue: for simple apps.
                    // 
                    // Small apps can not show multi underline. So
                    // this helper function returns only one 
                    // DISPLAYATTRIBUTE structure.
                    //
                    if (pda)
                    {
                        pDAI->GetAttributeInfo(pda);
                    }

                    if (pguid)
                    {
                        *pguid = gaVal;
                    }

                    pDAI->Release();
                    hr = S_OK;
                    break;
                    }
            }
            pEnumPropertyVal->Release();
        }
        VariantClear(&var);
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  GetAttributeColor
//
//----------------------------------------------------------------------------

HRESULT GetAttributeColor(TF_DA_COLOR *pdac, COLORREF *pcr)
{
    switch (pdac->type)
    {
        case TF_CT_NONE:
            return S_FALSE;

        case TF_CT_SYSCOLOR:
            *pcr = GetSysColor(pdac->nIndex);
            break;

        case TF_CT_COLORREF:
            *pcr = pdac->cr;
            break;
    }
    return S_OK;
    
}

//+---------------------------------------------------------------------------
//
//  SetAttributeColor
//
//----------------------------------------------------------------------------

HRESULT SetAttributeColor(TF_DA_COLOR *pdac, COLORREF cr)
{
    pdac->type = TF_CT_COLORREF;
    pdac->cr = cr;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  SetAttributeSysColor
//
//----------------------------------------------------------------------------

HRESULT SetAttributeSysColor(TF_DA_COLOR *pdac, int nIndex)
{
    pdac->type = TF_CT_SYSCOLOR;
    pdac->nIndex = nIndex;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  ClearAttributeColor
//
//----------------------------------------------------------------------------

HRESULT ClearAttributeColor(TF_DA_COLOR *pdac)
{
    pdac->type = TF_CT_NONE;
    pdac->nIndex = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  GetReconversionFromDisplayAttribute
//
//----------------------------------------------------------------------------

HRESULT GetReconversionFromDisplayAttribute(LIBTHREAD *plt, TfEditCookie ec, ITfThreadMgr *ptim, ITfContext *pic, ITfRange *pRange, ITfFnReconversion **ppReconv, ITfDisplayAttributeMgr *pDAM)
{
    IEnumTfRanges *epr = NULL;
    ITfReadOnlyProperty *pProp;
    ITfRange *proprange;
    ULONG ulNumProp;
    HRESULT hr = E_FAIL;

    //
    // get an enumorator
    //
    if (FAILED(GetDisplayAttributeTrackPropertyRange(ec, pic, pRange, &pProp, &epr, &ulNumProp)))
        goto Exit;


    //
    // Get display attribute of the first proprange.
    //
    if (epr->Next(1, &proprange, NULL) == S_OK)
    {
        ITfRange *rangeTmp = NULL;
        TfGuidAtom guidatom;
        if (SUCCEEDED(GetDisplayAttributeData(plt, ec, pProp, proprange, NULL, &guidatom, ulNumProp)))
        {
            CLSID clsid;
            GUID guid;
            if (GetGUIDFromGUIDATOM(plt, guidatom, &guid) &&
                SUCCEEDED(pDAM->GetDisplayAttributeInfo(guid, NULL, &clsid)))
            {
                ITfFunctionProvider *pFuncPrv;
                if (SUCCEEDED(ptim->GetFunctionProvider(clsid, &pFuncPrv)))
                {
                    hr = pFuncPrv->GetFunction(GUID_NULL, IID_ITfFnReconversion, (IUnknown **)ppReconv);
                    pFuncPrv->Release();
                }
            }
        }
        proprange->Release();
    }
    epr->Release();

    pProp->Release();

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\fontlnkv.cpp ===
//
// fontlnkv.cpp
//
//
// Vertical version DrawTextW()
//

#include "private.h"
#include "flshare.h"
#include "fontlink.h"
#include "xstring.h"
#include "osver.h"
#include "globals.h"

typedef struct tagDRAWTEXTPARAMSVERT
{
    UINT    cbSize;
    int     iTabLength;
    int     iTopMargin;
    int     iBottomMargin;
    UINT    uiLengthDrawn;
} DRAWTEXTPARAMSVERT, FAR *LPDRAWTEXTPARAMSVERT;

// Outputs the text and puts and _ below the character with an &
// before it. Note that this routine isn't used for menus since menus
// have their own special one so that it is specialized and faster...
void PSMTextOutVert(
    HDC hdc,
    int xRight,
    int yTop,
    LPWSTR lpsz,
    int cch,
    DWORD dwFlags)
{
    int cy;
    LONG textsize, result;
    WCHAR achWorkBuffer[255];
    WCHAR *pchOut = achWorkBuffer;
    TEXTMETRIC textMetric;
    SIZE size;
    RECT rc;
    COLORREF color;

    if (dwFlags & DT_NOPREFIX)
    {
        FLTextOutW(hdc, xRight, yTop, lpsz, cch);
        return;
    }

    if (cch > sizeof(achWorkBuffer)/sizeof(WCHAR))
    {
        pchOut = (WCHAR*)LocalAlloc(LPTR, (cch+1) * sizeof(WCHAR));
        if (pchOut == NULL)
            return;
    }

    result = GetPrefixCount(lpsz, cch, pchOut, cch);

    // DT_PREFIXONLY is a new 5.0 option used when switching from keyboard cues off to on.
    if (!(dwFlags & DT_PREFIXONLY))
        FLTextOutW(hdc, xRight, yTop, pchOut, cch - HIWORD(result));

    // Any true prefix characters to underline?
    if (LOWORD(result) == 0xFFFF || dwFlags & DT_HIDEPREFIX)
    {
        if (pchOut != achWorkBuffer)
            LocalFree(pchOut);
        return;
    }

    if (!GetTextMetrics(hdc, &textMetric))
    {
        textMetric.tmOverhang = 0;
        textMetric.tmAscent = 0;
    }

    // For proportional fonts, find starting point of underline.
    if (LOWORD(result) != 0)
    {
        // How far in does underline start (if not at 0th byte.).
        FLGetTextExtentPoint32(hdc, pchOut, LOWORD(result), &size);
        xRight += size.cy;

        // Adjust starting point of underline if not at first char and there is
        // an overhang.  (Italics or bold fonts.)
        yTop = yTop - textMetric.tmOverhang;
    }

    // Adjust for proportional font when setting the length of the underline and
    // height of text.
    FLGetTextExtentPoint32(hdc, pchOut + LOWORD(result), 1, &size);
    textsize = size.cx;

    // Find the width of the underline character.  Just subtract out the overhang
    // divided by two so that we look better with italic fonts.  This is not
    // going to effect embolded fonts since their overhang is 1.
    cy = LOWORD(textsize) - textMetric.tmOverhang / 2;

    // Get height of text so that underline is at bottom.
    xRight -= textMetric.tmAscent + 1;

    // Draw the underline using the foreground color.
    SetRect(&rc, xRight, yTop, xRight+1, yTop+cy);
    color = SetBkColor(hdc, GetTextColor(hdc));
    FLExtTextOutW(hdc, xRight, yTop, ETO_OPAQUE, &rc, L"", 0, NULL);
    SetBkColor(hdc, color);

    if (pchOut != achWorkBuffer)
        LocalFree(pchOut);
}

int DT_GetExtentMinusPrefixesVert(HDC hdc, LPCWSTR lpchStr, int cchCount, UINT wFormat, int iOverhang)
{
    int iPrefixCount;
    int cxPrefixes = 0;
    WCHAR PrefixChar = CH_PREFIX;
    SIZE size;

    if (!(wFormat & DT_NOPREFIX) &&
        (iPrefixCount = HIWORD(GetPrefixCount(lpchStr, cchCount, NULL, 0))))
    {
        // Kanji Windows has three shortcut prefixes...
        if (IsOnDBCS())
        {
            // 16bit apps compatibility
            cxPrefixes = KKGetPrefixWidth(hdc, lpchStr, cchCount) - (iPrefixCount * iOverhang);
        }
        else
        {
            cxPrefixes = FLGetTextExtentPoint32(hdc, &PrefixChar, 1, &size);
            cxPrefixes = size.cx - iOverhang;
            cxPrefixes *=  iPrefixCount;
        }
    }
    FLGetTextExtentPoint32(hdc, lpchStr, cchCount, &size);
    return (size.cx - cxPrefixes);
}

// This will draw the given string in the given location without worrying
// about the left/right justification. Gets the extent and returns it.
// If fDraw is TRUE and if NOT DT_CALCRECT, this draws the text.
// NOTE: This returns the extent minus Overhang.
int DT_DrawStrVert(HDC hdc, int  xRight, int yTop, LPCWSTR lpchStr,
               int cchCount, BOOL fDraw, UINT wFormat,
               LPDRAWTEXTDATAVERT lpDrawInfo)
{
    LPCWSTR lpch;
    int     iLen;
    int     cyExtent;
    int     yOldLeft = yTop;   // Save the xRight given to compute the extent later
    int     yTabLength = lpDrawInfo->cyTabLength;
    int     iTabOrigin = lpDrawInfo->rcFormat.left;

    // Check if the tabs need to be expanded
    if (wFormat & DT_EXPANDTABS)
    {
        while (cchCount)
        {
            // Look for a tab
            for (iLen = 0, lpch = lpchStr; iLen < cchCount; iLen++)
                if(*lpch++ == L'\t')
                    break;

            // Draw text, if any, upto the tab
            if (iLen)
            {
                // Draw the substring taking care of the prefixes.
                if (fDraw && !(wFormat & DT_CALCRECT))  // Only if we need to draw text
                    PSMTextOutVert(hdc, xRight, yTop, (LPWSTR)lpchStr, iLen, wFormat);
                // Get the extent of this sub string and add it to xRight.
                yTop += DT_GetExtentMinusPrefixesVert(hdc, lpchStr, iLen, wFormat, lpDrawInfo->cyOverhang) - lpDrawInfo->cyOverhang;
            }

            //if a TAB was found earlier, calculate the start of next sub-string.
            if (iLen < cchCount)
            {
                iLen++;  // Skip the tab
                if (yTabLength) // Tab length could be zero
                    yTop = (((yTop - iTabOrigin)/yTabLength) + 1)*yTabLength + iTabOrigin;
            }

            // Calculate the details of the string that remains to be drawn.
            cchCount -= iLen;
            lpchStr = lpch;
        }
        cyExtent = yTop - yOldLeft;
    }
    else
    {
        // If required, draw the text
        if (fDraw && !(wFormat & DT_CALCRECT))
            PSMTextOutVert(hdc, xRight, yTop, (LPWSTR)lpchStr, cchCount, wFormat);
        // Compute the extent of the text.
        cyExtent = DT_GetExtentMinusPrefixesVert(hdc, lpchStr, cchCount, wFormat, lpDrawInfo->cyOverhang) - lpDrawInfo->cyOverhang;
    }
    return cyExtent;
}

// This function draws one complete line with proper justification
void DT_DrawJustifiedLineVert(HDC hdc, int xRight, LPCWSTR lpchLineSt, int cchCount, UINT wFormat, LPDRAWTEXTDATAVERT lpDrawInfo)
{
    LPRECT  lprc;
    int     cyExtent;
    int     yTop;

    lprc = &(lpDrawInfo->rcFormat);
    yTop = lprc->top;

    // Handle the special justifications (right or centered) properly.
    if (wFormat & (DT_CENTER | DT_RIGHT))
    {
        cyExtent = DT_DrawStrVert(hdc, xRight, yTop, lpchLineSt, cchCount, FALSE, wFormat, lpDrawInfo)
                 + lpDrawInfo->cyOverhang;
        if(wFormat & DT_CENTER)
            yTop = lprc->top + (((lprc->bottom - lprc->top) - cyExtent) >> 1);
        else
            yTop = lprc->bottom - cyExtent;
    }
    else
        yTop = lprc->top;

    // Draw the whole line.
    cyExtent = DT_DrawStrVert(hdc, xRight, yTop, lpchLineSt, cchCount, TRUE, wFormat, lpDrawInfo)
             + lpDrawInfo->cyOverhang;
    if (cyExtent > lpDrawInfo->cyMaxExtent)
        lpDrawInfo->cyMaxExtent = cyExtent;
}

// This is called at the begining of DrawText(); This initializes the
// DRAWTEXTDATAVERT structure passed to this function with all the required info.
BOOL DT_InitDrawTextInfoVert(
    HDC                 hdc,
    LPRECT              lprc,
    UINT                wFormat,
    LPDRAWTEXTDATAVERT  lpDrawInfo,
    LPDRAWTEXTPARAMSVERT lpDTparams)
{
    SIZE        sizeViewPortExt = {0, 0}, sizeWindowExt = {0, 0};
    TEXTMETRIC  tm;
    LPRECT      lprcDest;
    int         iTabLength = 8;   // Default Tab length is 8 characters.
    int         iTopMargin;
    int         iBottomMargin;

    if (lpDTparams)
    {
        // Only if DT_TABSTOP flag is mentioned, we must use the iTabLength field.
        if (wFormat & DT_TABSTOP)
            iTabLength = lpDTparams->iTabLength;
        iTopMargin = lpDTparams->iTopMargin;
        iBottomMargin = lpDTparams->iBottomMargin;
    }
    else
        iTopMargin = iBottomMargin = 0;

    // Get the View port and Window extents for the given DC
    // If this call fails, hdc must be invalid
    if (!GetViewportExtEx(hdc, &sizeViewPortExt))
        return FALSE;
    GetWindowExtEx(hdc, &sizeWindowExt);

    // For the current mapping mode,  find out the sign of x from left to right.
    lpDrawInfo->iXSign = (((sizeViewPortExt.cx ^ sizeWindowExt.cx) & 0x80000000) ? -1 : 1);

    // For the current mapping mode,  find out the sign of y from top to bottom.
    lpDrawInfo->iYSign = (((sizeViewPortExt.cy ^ sizeWindowExt.cy) & 0x80000000) ? -1 : 1);

    // Calculate the dimensions of the current font in this DC.
    GetTextMetrics(hdc, &tm);

    // cxLineHeight is in pixels (This will be signed).
    lpDrawInfo->cxLineHeight = (tm.tmHeight +
        ((wFormat & DT_EXTERNALLEADING) ? tm.tmExternalLeading : 0)) * lpDrawInfo->iXSign;

    // cyTabLength is the tab length in pixels (This will not be signed)
    lpDrawInfo->cyTabLength = tm.tmAveCharWidth * iTabLength;

    // Set the cyOverhang
    lpDrawInfo->cyOverhang = tm.tmOverhang;

    // Set up the format rectangle based on the margins.
    lprcDest = &(lpDrawInfo->rcFormat);
    *lprcDest = *lprc;

    // We need to do the following only if the margins are given
    if (iTopMargin | iBottomMargin)
    {
        lprcDest->top += iTopMargin * lpDrawInfo->iYSign;
        lprcDest->bottom -= (lpDrawInfo->cyBottomMargin = iBottomMargin * lpDrawInfo->iYSign);
    }
    else
        lpDrawInfo->cyBottomMargin = 0;  // Initialize to zero.

    // cyMaxWidth is unsigned.
    lpDrawInfo->cyMaxWidth = (lprcDest->bottom - lprcDest->top) * lpDrawInfo->iYSign;
    lpDrawInfo->cyMaxExtent = 0;  // Initialize this to zero.

    return TRUE;
}

// A word needs to be broken across lines and this finds out where to break it.
LPCWSTR  DT_BreakAWordVert(HDC hdc, LPCWSTR lpchText, int iLength, int iWidth, UINT wFormat, int iOverhang)
{
  int  iLow = 0, iHigh = iLength;
  int  iNew;

  while ((iHigh - iLow) > 1)
  {
      iNew = iLow + (iHigh - iLow)/2;
      if(DT_GetExtentMinusPrefixesVert(hdc, lpchText, iNew, wFormat, iOverhang) > iWidth)
          iHigh = iNew;
      else
          iLow = iNew;
  }
  // If the width is too low, we must print atleast one char per line.
  // Else, we will be in an infinite loop.
  if(!iLow && iLength)
      iLow = 1;
  return (lpchText+iLow);
}

// This finds out the location where we can break a line.
// Returns LPCSTR to the begining of next line.
// Also returns via lpiLineLength, the length of the current line.
// NOTE: (lpstNextLineStart - lpstCurrentLineStart) is not equal to the
// line length; This is because, we exclude some white spaces at the begining
// and/or end of lines; Also, CR/LF is excluded from the line length.
LPWSTR DT_GetLineBreakVert(
    HDC             hdc,
    LPCWSTR         lpchLineStart,
    int             cchCount,
    DWORD           dwFormat,
    LPINT           lpiLineLength,
    LPDRAWTEXTDATAVERT  lpDrawInfo)
{
    LPCWSTR lpchText, lpchEnd, lpch, lpchLineEnd;
    int   cxStart, cyExtent, cyNewExtent;
    BOOL  fAdjustWhiteSpaces = FALSE;
    WCHAR ch;

    cxStart = lpDrawInfo->rcFormat.left;
    cyExtent = cyNewExtent = 0;
    lpchText = lpchLineStart;
    lpchEnd = lpchLineStart + cchCount;
    lpch = lpchEnd;
    lpchLineEnd = lpchEnd;

    while(lpchText < lpchEnd)
    {
        lpchLineEnd = lpch = GetNextWordbreak(lpchText, lpchEnd, dwFormat, NULL);
        // DT_DrawStrVert does not return the overhang; Otherwise we will end up
        // adding one overhang for every word in the string.

        // For simulated Bold fonts, the summation of extents of individual
        // words in a line is greater than the extent of the whole line. So,
        // always calculate extent from the LineStart.
        // BUGTAG: #6054 -- Win95B -- SANKAR -- 3/9/95 --
        cyNewExtent = DT_DrawStrVert(hdc, cxStart, 0, lpchLineStart, (int)(((PBYTE)lpch - (PBYTE)lpchLineStart)/sizeof(WCHAR)),
                                 FALSE, dwFormat, lpDrawInfo);

        if ((dwFormat & DT_WORDBREAK) && ((cyNewExtent + lpDrawInfo->cyOverhang) > lpDrawInfo->cyMaxWidth))
        {
            // Are there more than one word in this line?
            if (lpchText != lpchLineStart)
            {
                lpchLineEnd = lpch = lpchText;
                fAdjustWhiteSpaces = TRUE;
            }
            else
            {
                //One word is longer than the maximum width permissible.
                //See if we are allowed to break that single word.
                if((dwFormat & DT_EDITCONTROL) && !(dwFormat & DT_WORD_ELLIPSIS))
                {
                    lpchLineEnd = lpch = DT_BreakAWordVert(hdc, lpchText, (int)(((PBYTE)lpch - (PBYTE)lpchText)/sizeof(WCHAR)),
                          lpDrawInfo->cyMaxWidth - cyExtent, dwFormat, lpDrawInfo->cyOverhang); //Break that word
                    //Note: Since we broke in the middle of a word, no need to
                    // adjust for white spaces.
                }
                else
                {
                    fAdjustWhiteSpaces = TRUE;
                    // Check if we need to end this line with ellipsis
                    if(dwFormat & DT_WORD_ELLIPSIS)
                    {
                        // Don't do this if already at the end of the string.
                        if (lpch < lpchEnd)
                        {
                            // If there are CR/LF at the end, skip them.
                            if ((ch = *lpch) == CR || ch == LF)
                            {
                                if ((++lpch < lpchEnd) && (*lpch == (WCHAR)(ch ^ (LF ^ CR))))
                                    lpch++;
                                fAdjustWhiteSpaces = FALSE;
                            }
                        }
                    }
                }
            }
            // Well! We found a place to break the line. Let us break from this loop;
            break;
        }
        else
        {
            // Don't do this if already at the end of the string.
            if (lpch < lpchEnd)
            {
                if ((ch = *lpch) == CR || ch == LF)
                {
                    if ((++lpch < lpchEnd) && (*lpch == (WCHAR)(ch ^ (LF ^ CR))))
                        lpch++;
                    fAdjustWhiteSpaces = FALSE;
                    break;
                }
            }
        }
        // Point at the beginning of the next word.
        lpchText = lpch;
        cyExtent = cyNewExtent;
    }
    // Calculate the length of current line.
    *lpiLineLength = (INT)((PBYTE)lpchLineEnd - (PBYTE)lpchLineStart)/sizeof(WCHAR);

    // Adjust the line length and lpch to take care of spaces.
    if(fAdjustWhiteSpaces && (lpch < lpchEnd))
        lpch = DT_AdjustWhiteSpaces(lpch, lpiLineLength, dwFormat);

    // return the begining of next line;
    return (LPWSTR)lpch;
}

// This function checks whether the given string fits within the given
// width or we need to add end-ellipse. If it required end-ellipses, it
// returns TRUE and it returns the number of characters that are saved
// in the given string via lpCount.
BOOL  NeedsEndEllipsisVert(
    HDC             hdc,
    LPCWSTR         lpchText,
    LPINT           lpCount,
    LPDRAWTEXTDATAVERT  lpDTdata,
    UINT            wFormat)
{
    int   cchText;
    int   ichMin, ichMax, ichMid;
    int   cyMaxWidth;
    int   iOverhang;
    int   cyExtent;
    SIZE size;
    cchText = *lpCount;  // Get the current count.

    if (cchText == 0)
        return FALSE;

    cyMaxWidth  = lpDTdata->cyMaxWidth;
    iOverhang   = lpDTdata->cyOverhang;

    cyExtent = DT_GetExtentMinusPrefixesVert(hdc, lpchText, cchText, wFormat, iOverhang);

    if (cyExtent <= cyMaxWidth)
        return FALSE;
    // Reserve room for the "..." ellipses;
    // (Assumption: The ellipses don't have any prefixes!)
    FLGetTextExtentPoint32(hdc, szEllipsis, CCHELLIPSIS, &size);
    cyMaxWidth -= size.cx - iOverhang;

    // If no room for ellipses, always show first character.
    //
    ichMax = 1;
    if (cyMaxWidth > 0)
    {
        // Binary search to find characters that will fit.
        ichMin = 0;
        ichMax = cchText;
        while (ichMin < ichMax)
        {
            // Be sure to round up, to make sure we make progress in
            // the loop if ichMax == ichMin + 1.
            ichMid = (ichMin + ichMax + 1) / 2;

            cyExtent = DT_GetExtentMinusPrefixesVert(hdc, lpchText, ichMid, wFormat, iOverhang);

            if (cyExtent < cyMaxWidth)
                ichMin = ichMid;
            else
            {
                if (cyExtent > cyMaxWidth)
                    ichMax = ichMid - 1;
                else
                {
                    // Exact match up up to ichMid: just exit.
                    ichMax = ichMid;
                    break;
                }
            }
        }
        // Make sure we always show at least the first character...
        if (ichMax < 1)
            ichMax = 1;
    }
    *lpCount = ichMax;
    return TRUE;
}

// This adds a path ellipse to the given path name.
// Returns TRUE if the resultant string's extent is less the the
// cyMaxWidth. FALSE, if otherwise.
int AddPathEllipsisVert(
    HDC    hdc,
    LPWSTR lpszPath,
    int    cchText,
    UINT   wFormat,
    int    cyMaxWidth,
    int    iOverhang)
{
    int    iLen;
    UINT   dxFixed, dxEllipsis;
    LPWSTR lpEnd;          /* end of the unfixed string */
    LPWSTR lpFixed;        /* start of text that we always display */
    BOOL   bEllipsisIn;
    int    iLenFixed;
    SIZE   size;

    lpFixed = PathFindFileName(lpszPath, cchText);
    if (lpFixed != lpszPath)
        lpFixed--;  // point at the slash
    else
        return cchText;

    lpEnd = lpFixed;
    bEllipsisIn = FALSE;
    iLenFixed = cchText - (int)(lpFixed - lpszPath);
    dxFixed = DT_GetExtentMinusPrefixesVert(hdc, lpFixed, iLenFixed, wFormat, iOverhang);

    // It is assumed that the "..." string does not have any prefixes ('&').
    FLGetTextExtentPoint32(hdc, szEllipsis, CCHELLIPSIS, &size);
    dxEllipsis = size.cx - iOverhang;

    while (TRUE)
    {
        iLen = dxFixed + DT_GetExtentMinusPrefixesVert(hdc, lpszPath, (int)((PBYTE)lpEnd - (PBYTE)lpszPath)/sizeof(WCHAR),
                                                   wFormat, iOverhang) - iOverhang;

        if (bEllipsisIn)
            iLen += dxEllipsis;

        if (iLen <= cyMaxWidth)
            break;

        bEllipsisIn = TRUE;

        if (lpEnd <= lpszPath)
        {
            // Things didn't fit.
            lpEnd = lpszPath;
            break;
        }
        // Step back a character.
        lpEnd--;
    }

    if (bEllipsisIn && (lpEnd + CCHELLIPSIS < lpFixed))
    {
        // NOTE: the strings could over lap here. So, we use LCopyStruct.
        MoveMemory((lpEnd + CCHELLIPSIS), lpFixed, iLenFixed * sizeof(WCHAR));
        CopyMemory(lpEnd, szEllipsis, CCHELLIPSIS * sizeof(WCHAR));

        cchText = (int)(lpEnd - lpszPath) + CCHELLIPSIS + iLenFixed;

        // now we can NULL terminate the string
        *(lpszPath + cchText) = L'\0';
    }
    return cchText;
}

// This function returns the number of characters actually drawn.
int AddEllipsisAndDrawLineVert(
    HDC            hdc,
    int            xLine,
    LPCWSTR        lpchText,
    int            cchText,
    DWORD          dwDTformat,
    LPDRAWTEXTDATAVERT lpDrawInfo)
{
    LPWSTR pEllipsis = NULL;
    WCHAR  szTempBuff[MAXBUFFSIZE];
    LPWSTR lpDest;
    BOOL   fAlreadyCopied = FALSE;

    // Check if this is a filename with a path AND
    // Check if the width is too narrow to hold all the text.
    if ((dwDTformat & DT_PATH_ELLIPSIS) &&
        ((DT_GetExtentMinusPrefixesVert(hdc, lpchText, cchText, dwDTformat, lpDrawInfo->cyOverhang)) > lpDrawInfo->cyMaxWidth))
    {
        // We need to add Path-Ellipsis. See if we can do it in-place.
        if (!(dwDTformat & DT_MODIFYSTRING)) {
            // NOTE: When you add Path-Ellipsis, the string could grow by
            // CCHELLIPSIS bytes.
            if((cchText + CCHELLIPSIS + 1) <= MAXBUFFSIZE)
                lpDest = szTempBuff;
            else
            {
                // Alloc the buffer from local heap.
                if(!(pEllipsis = (LPWSTR)LocalAlloc(LPTR, (cchText+CCHELLIPSIS+1)*sizeof(WCHAR))))
                    return 0;
                lpDest = (LPWSTR)pEllipsis;
            }
            // Source String may not be NULL terminated. So, copy just
            // the given number of characters.
            CopyMemory(lpDest, lpchText, cchText*sizeof(WCHAR));
            lpchText = lpDest;        // lpchText points to the copied buff.
            fAlreadyCopied = TRUE;    // Local copy has been made.
        }
        // Add the path ellipsis now!
        cchText = AddPathEllipsisVert(hdc, (LPWSTR)lpchText, cchText, dwDTformat, lpDrawInfo->cyMaxWidth, lpDrawInfo->cyOverhang);
    }

    // Check if end-ellipsis are to be added.
    if ((dwDTformat & (DT_END_ELLIPSIS | DT_WORD_ELLIPSIS)) &&
        NeedsEndEllipsisVert(hdc, lpchText, &cchText, lpDrawInfo, dwDTformat))
    {
        // We need to add end-ellipsis; See if we can do it in-place.
        if (!(dwDTformat & DT_MODIFYSTRING) && !fAlreadyCopied)
        {
            // See if the string is small enough for the buff on stack.
            if ((cchText+CCHELLIPSIS+1) <= MAXBUFFSIZE)
                lpDest = szTempBuff;  // If so, use it.
            else {
                // Alloc the buffer from local heap.
                if (!(pEllipsis = (LPWSTR)LocalAlloc(LPTR, (cchText+CCHELLIPSIS+1)*sizeof(WCHAR))))
                    return 0;
                lpDest = pEllipsis;
            }
            // Make a copy of the string in the local buff.
            CopyMemory(lpDest, lpchText, cchText*sizeof(WCHAR));
            lpchText = lpDest;
        }
        // Add an end-ellipsis at the proper place.
        CopyMemory((LPWSTR)(lpchText+cchText), szEllipsis, (CCHELLIPSIS+1)*sizeof(WCHAR));
        cchText += CCHELLIPSIS;
    }

    // Draw the line that we just formed.
    DT_DrawJustifiedLineVert(hdc, xLine, lpchText, cchText, dwDTformat, lpDrawInfo);

    // Free the block allocated for End-Ellipsis.
    if (pEllipsis)
        LocalFree(pEllipsis);

    return cchText;
}

BOOL IsComplexScriptPresent(LPWSTR lpchText, int cchText);

int  FLDrawTextExPrivWVert(
   HDC               hdc,
   LPWSTR            lpchText,
   int               cchText,
   LPRECT            lprc,
   UINT              dwDTformat,
   LPDRAWTEXTPARAMSVERT  lpDTparams)
{
    DRAWTEXTDATAVERT DrawInfo;
    WORD         wFormat = LOWORD(dwDTformat);
    LPWSTR       lpchTextBegin;
    LPWSTR       lpchEnd;
    LPWSTR       lpchNextLineSt;
    int          iLineLength;
    int          ixSign;
    int          xLine;
    int          xLastLineHeight;
    HRGN         hrgnClip;
    int          iLineCount;
    RECT         rc;
    BOOL         fLastLine;
    WCHAR        ch;
    UINT         oldAlign;

    if ((cchText == 0) && lpchText && (*lpchText))
    {
        // infoview.exe passes lpchText that points to '\0'
        // Lotus Notes doesn't like getting a zero return here
        return 1;
    }

    if (cchText == -1)
        cchText = lstrlenW(lpchText);
    else if (lpchText[cchText - 1] == L'\0')
        cchText--;      // accommodate counting of NULLS for ME


    if ((lpDTparams) && (lpDTparams->cbSize != sizeof(DRAWTEXTPARAMS)))
    {
        ASSERT(0 && "DrawTextExWorker: cbSize is invalid");
        return 0;
    }


    // If DT_MODIFYSTRING is specified, then check for read-write pointer.
    if ((dwDTformat & DT_MODIFYSTRING) &&
        (dwDTformat & (DT_END_ELLIPSIS | DT_PATH_ELLIPSIS)))
    {
        if(IsBadWritePtr(lpchText, cchText))
        {
            ASSERT(0 && "DrawTextExWorker: For DT_MODIFYSTRING, lpchText must be read-write");
            return 0;
        }
    }

    // Initialize the DrawInfo structure.
    if (!DT_InitDrawTextInfoVert(hdc, lprc, dwDTformat, (LPDRAWTEXTDATAVERT)&DrawInfo, lpDTparams))
        return 0;

    // If the rect is too narrow or the margins are too wide.....Just forget it!
    //
    // If wordbreak is specified, the MaxWidth must be a reasonable value.
    // This check is sufficient because this will allow CALCRECT and NOCLIP
    // cases.  --SANKAR.
    //
    // This also fixed all of our known problems with AppStudio.
    if (DrawInfo.cyMaxWidth <= 0)
    {
        if (wFormat & DT_WORDBREAK)
        {
            ASSERT(0 && "DrawTextExW: FAILURE DrawInfo.cyMaxWidth <= 0");
            return 1;
        }
    }

    // if we're not doing the drawing, initialise the lpk-dll
    if (dwDTformat & DT_RTLREADING)
        oldAlign = SetTextAlign(hdc, TA_RTLREADING | GetTextAlign(hdc));

    // If we need to clip, let us do that.
    if (!(wFormat & DT_NOCLIP))
    {
        // Save clipping region so we can restore it later.
        hrgnClip = CreateRectRgn(0,0,0,0);
        if (hrgnClip != NULL)
        {
            if (GetClipRgn(hdc, hrgnClip) != 1)
            {
                DeleteObject(hrgnClip);
                hrgnClip = (HRGN)-1;
            }
            rc = *lprc;
            IntersectClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);
        }
    }
    else
        hrgnClip = NULL;

    lpchTextBegin = lpchText;
    lpchEnd = lpchText + cchText;

ProcessDrawText:

    iLineCount = 0;  // Reset number of lines to 1.
    xLine = lprc->right;

    if (wFormat & DT_SINGLELINE)
    {
        iLineCount = 1;  // It is a single line.

        // Process single line DrawText.
        switch (wFormat & DT_VFMTMASK)
        {
            case DT_BOTTOM:
                xLine = lprc->left + DrawInfo.cxLineHeight;
                break;

            case DT_VCENTER:
                xLine = lprc->right - ((lprc->right - lprc->left - DrawInfo.cxLineHeight) / 2);
                break;
        }

        cchText = AddEllipsisAndDrawLineVert(hdc, xLine, lpchText, cchText, dwDTformat, &DrawInfo);
        xLine += DrawInfo.cxLineHeight;
        lpchText += cchText;
    }
    else
    {
        // Multiline
        // If the height of the rectangle is not an integral multiple of the
        // average char height, then it is possible that the last line drawn
        // is only partially visible. However, if DT_EDITCONTROL style is
        // specified, then we must make sure that the last line is not drawn if
        // it is going to be partially visible. This will help imitate the
        // appearance of an edit control.
        if (wFormat & DT_EDITCONTROL)
            xLastLineHeight = DrawInfo.cxLineHeight;
        else
            xLastLineHeight = 0;

        ixSign = DrawInfo.iXSign;
        fLastLine = FALSE;
        // Process multiline DrawText.
        while ((lpchText < lpchEnd) && (!fLastLine))
        {
            // Check if the line we are about to draw is the last line that needs
            // to be drawn.
            // Let us check if the display goes out of the clip rect and if so
            // let us stop here, as an optimisation;
            if (!(wFormat & DT_CALCRECT) && // We don't need to calc rect?
                !(wFormat & DT_NOCLIP) &&   // Must we clip the display ?
                                            // Are we outside the rect?
                ((xLine + DrawInfo.cxLineHeight + xLastLineHeight)*ixSign > (lprc->right*ixSign)))
            {
                fLastLine = TRUE;    // Let us quit this loop
            }

            // We do the Ellipsis processing only for the last line.
            if (fLastLine && (dwDTformat & (DT_END_ELLIPSIS | DT_PATH_ELLIPSIS)))
                lpchText += AddEllipsisAndDrawLineVert(hdc, xLine, lpchText, cchText, dwDTformat, &DrawInfo);
            else
            {
                lpchNextLineSt = (LPWSTR)DT_GetLineBreakVert(hdc, lpchText, cchText, dwDTformat, &iLineLength, &DrawInfo);

                // Check if we need to put ellipsis at the end of this line.
                // Also check if this is the last line.
                if ((dwDTformat & DT_WORD_ELLIPSIS) ||
                    ((lpchNextLineSt >= lpchEnd) && (dwDTformat & (DT_END_ELLIPSIS | DT_PATH_ELLIPSIS))))
                    AddEllipsisAndDrawLineVert(hdc, xLine, lpchText, iLineLength, dwDTformat, &DrawInfo);
                else
                    DT_DrawJustifiedLineVert(hdc, xLine, lpchText, iLineLength, dwDTformat, &DrawInfo);
                cchText -= (int)((PBYTE)lpchNextLineSt - (PBYTE)lpchText) / sizeof(WCHAR);
                lpchText = lpchNextLineSt;
            }
            iLineCount++; // We draw one more line.
            xLine += DrawInfo.cxLineHeight;
        }

        // For Win3.1 and NT compatibility, if the last char is a CR or a LF
        // then the height returned includes one more line.
        if (!(dwDTformat & DT_EDITCONTROL) &&
            (lpchEnd > lpchTextBegin) &&   // If zero length it will fault.
            (((ch = (*(lpchEnd-1))) == CR) || (ch == LF)))
            xLine += DrawInfo.cxLineHeight;
    }

    // If DT_CALCRECT, modify width and height of rectangle to include
    // all of the text drawn.
    if (wFormat & DT_CALCRECT)
    {
        DrawInfo.rcFormat.bottom = DrawInfo.rcFormat.top + DrawInfo.cyMaxExtent * DrawInfo.iYSign;
        lprc->bottom = DrawInfo.rcFormat.bottom + DrawInfo.cyBottomMargin;

        // If the Width is more than what was provided, we have to redo all
        // the calculations, because, the number of lines can be less now.
        // (We need to do this only if we have more than one line).
        if((iLineCount > 1) && (DrawInfo.cyMaxExtent > DrawInfo.cyMaxWidth))
        {
            DrawInfo.cyMaxWidth = DrawInfo.cyMaxExtent;
            lpchText = lpchTextBegin;
            cchText = (int)((PBYTE)lpchEnd - (PBYTE)lpchTextBegin) / sizeof(WCHAR);
            goto  ProcessDrawText;  // Start all over again!
        }
        lprc->left = xLine;
    }

    if (hrgnClip != NULL)
    {
        if (hrgnClip == (HRGN)-1)
            ExtSelectClipRgn(hdc, NULL, RGN_COPY);
        else
        {
            ExtSelectClipRgn(hdc, hrgnClip, RGN_COPY);
            DeleteObject(hrgnClip);
        }
    }

    if (dwDTformat & DT_RTLREADING)
        SetTextAlign(hdc, oldAlign);

    // Copy the number of characters actually drawn
    if(lpDTparams != NULL)
        lpDTparams->uiLengthDrawn = (UINT)((PBYTE)lpchText - (PBYTE)lpchTextBegin) / sizeof(WCHAR);

    if (xLine == lprc->right)
        return 1;

    return (xLine + lprc->right);
}

int FLDrawTextWVert(HDC hdc, LPCWSTR lpchText, int cchText, LPCRECT lprc, UINT format)
{
    DRAWTEXTPARAMSVERT DTparams;
    LPDRAWTEXTPARAMSVERT lpDTparams = NULL;

    if (cchText < -1)
        return(0);

    if (format & DT_TABSTOP)
    {
        DTparams.cbSize      = sizeof(DRAWTEXTPARAMSVERT);
        DTparams.iTopMargin = DTparams.iBottomMargin = 0;
        DTparams.iTabLength  = (format & 0xff00) >> 8;
        lpDTparams           = &DTparams;
        format              &= 0xffff00ff;
    }
    return FLDrawTextExPrivWVert(hdc, (LPWSTR)lpchText, cchText, (LPRECT)lprc, format, lpDTparams);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\fnprbase.cpp ===
//
// funcprv.cpp
//

#include "private.h"
#include "helpers.h"
#include "immxutil.h"
#include "fnprbase.h"


//////////////////////////////////////////////////////////////////////////////
//
// CFunctionProviderBase
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CFunctionProviderBase::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfFunctionProvider))
    {
        *ppvObj = SAFECAST(this, CFunctionProviderBase *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CFunctionProviderBase::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDAPI_(ULONG) CFunctionProviderBase::Release()
{
    long cr;

    cr = InterlockedDecrement(&_cRef);
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFunctionProviderBase::CFunctionProviderBase(TfClientId tid)
{
    _tid = tid;
    _cRef = 1;
    _bstrDesc = NULL;
    _guidType = GUID_NULL;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFunctionProviderBase::~CFunctionProviderBase()
{
    if (! DllShutdownInProgress())
    {
        SysFreeString(_bstrDesc);
    }
}

//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

BOOL CFunctionProviderBase::Init(REFGUID guidType, WCHAR *pszDesc)
{
    _bstrDesc = SysAllocString(pszDesc);
    _guidType = guidType;

    if (_bstrDesc)
        return TRUE;
    else
        return FALSE;
}


//+---------------------------------------------------------------------------
//
// CFunctionProviderBase::Advise
//
//----------------------------------------------------------------------------

HRESULT CFunctionProviderBase::_Advise(ITfThreadMgr *ptim)
{
    HRESULT hr;
    ITfSourceSingle *source = NULL;

    hr = E_FAIL;

    if (FAILED(ptim->QueryInterface(IID_ITfSourceSingle, (void **)&source)))
        goto Exit;

    if (FAILED(source->AdviseSingleSink(_tid, IID_ITfFunctionProvider, this)))
        goto Exit;

    hr = S_OK;

Exit:
    SafeRelease(source);
    return hr;
}

//+---------------------------------------------------------------------------
//
// CFunctionProviderBase::Unadvise
//
//----------------------------------------------------------------------------

HRESULT CFunctionProviderBase::_Unadvise(ITfThreadMgr *ptim)
{
    HRESULT hr;
    ITfSourceSingle *source = NULL;

    hr = E_FAIL;

    if (FAILED(ptim->QueryInterface(IID_ITfSourceSingle, (void **)&source)))
        goto Exit;

    if (FAILED(source->UnadviseSingleSink(_tid, IID_ITfFunctionProvider)))
        goto Exit;

    hr = S_OK;

Exit:
    SafeRelease(source);
    return hr;
}

//+---------------------------------------------------------------------------
//
// GetType
//
//----------------------------------------------------------------------------

STDAPI CFunctionProviderBase::GetType(GUID *pguid)
{
    *pguid = _guidType;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetDescription
//
//----------------------------------------------------------------------------

STDAPI CFunctionProviderBase::GetDescription(BSTR *pbstrDesc)
{
    *pbstrDesc = SysAllocString(_bstrDesc);

    if (*pbstrDesc)
        return S_OK;
    else
        return E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// GetFunction
//
//----------------------------------------------------------------------------

STDAPI CFunctionProviderBase::GetFunction(REFGUID rguid, REFIID riid, IUnknown **ppunk)
{
    *ppunk = NULL;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\globals.h ===
//+---------------------------------------------------------------------------
//
//  File:       globals.h
//
//  Contents:   Global variable declarations.
//
//----------------------------------------------------------------------------

#ifndef GLOBALS_H
#define GLOBALS_H

#include "private.h"
#include "immxutil.h"


extern HINSTANCE g_hMlang;
extern HRESULT (*g_pfnGetGlobalFontLinkObject)(IMLangFontLink **);
extern BOOL g_bComplexPlatform;
extern UINT g_uiACP;

class CDispAttrPropCache;
extern CDispAttrPropCache *g_pPropCache;

extern PFNCOCREATE g_pfnCoCreate;

#endif // GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\iconlib.cpp ===
//
// iconlib.cpp
//

#include "private.h"
#include "cmydc.h"
#include "iconlib.h"

/*   G E T  I C O N  S I Z E   */
/*------------------------------------------------------------------------------

    get icon size

------------------------------------------------------------------------------*/
BOOL GetIconSize( HICON hIcon, SIZE *psize )
{
    ICONINFO IconInfo;
    BITMAP   bmp;
    
    Assert( hIcon != NULL );

    if (!GetIconInfo( hIcon, &IconInfo ))
        return FALSE;

    GetObject( IconInfo.hbmColor, sizeof(bmp), &bmp );
    DeleteObject( IconInfo.hbmColor );
    DeleteObject( IconInfo.hbmMask );

    psize->cx = bmp.bmWidth;
    psize->cy = bmp.bmHeight;
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// GetIconBitmaps
//
//----------------------------------------------------------------------------

BOOL GetIconBitmaps(HICON hIcon, HBITMAP *phbmp, HBITMAP *phbmpMask, SIZE *psize)
{
    CBitmapDC hdcSrc(TRUE);
    CBitmapDC hdcMask(TRUE);
    SIZE size;

    if (psize)
        size = *psize;
    else if (!GetIconSize( hIcon, &size))
        return FALSE;

    hdcSrc.SetCompatibleBitmap(size.cx, size.cy);
    // hdcMask.SetCompatibleBitmap(size.cx, size.cy);
    hdcMask.SetBitmap(size.cx, size.cy, 1, 1);
    RECT rc = {0, 0, size.cx, size.cy};
    FillRect(hdcSrc, &rc, (HBRUSH)GetStockObject(BLACK_BRUSH));
    DrawIconEx(hdcSrc, 0, 0, hIcon, size.cx, size.cy, 0, NULL, DI_NORMAL);
    DrawIconEx(hdcMask, 0, 0, hIcon, size.cx, size.cy, 0, NULL, DI_MASK);
    *phbmp = hdcSrc.GetBitmapAndKeep();
    *phbmpMask = hdcMask.GetBitmapAndKeep();
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// GetIconDIBitmaps
//
//----------------------------------------------------------------------------

BOOL GetIconDIBitmaps(HICON hIcon, HBITMAP *phbmp, HBITMAP *phbmpMask, SIZE *psize)
{
    CBitmapDC hdcSrc(TRUE);
    CBitmapDC hdcMask(TRUE);
    SIZE size;

    if (psize)
        size = *psize;
    else if (!GetIconSize( hIcon, &size))
        return FALSE;

    hdcSrc.SetDIB(size.cx, size.cy);
    // hdcMask.SetCompatibleBitmap(size.cx, size.cy);
    hdcMask.SetBitmap(size.cx, size.cy, 1, 1);
    RECT rc = {0, 0, size.cx, size.cy};
    FillRect(hdcSrc, &rc, (HBRUSH)GetStockObject(BLACK_BRUSH));
    DrawIconEx(hdcSrc, 0, 0, hIcon, size.cx, size.cy, 0, NULL, DI_NORMAL);
    DrawIconEx(hdcMask, 0, 0, hIcon, size.cx, size.cy, 0, NULL, DI_MASK);
    *phbmp = hdcSrc.GetBitmapAndKeep();
    *phbmpMask = hdcMask.GetBitmapAndKeep();
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// GetMenuIconHeight
//
//----------------------------------------------------------------------------

int GetMenuIconHeight(int *pnMenuFontHeghti)
{
    int nMenuFontHeight;
    int cxSmIcon = GetSystemMetrics( SM_CXSMICON );
    NONCLIENTMETRICS ncm;

    int cyMenu = GetSystemMetrics(SM_CYMENU);

    ncm.cbSize = sizeof(ncm);
    SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, FALSE);

    nMenuFontHeight = (ncm.lfMenuFont.lfHeight > 0) ?
            ncm.lfMenuFont.lfHeight :
            -ncm.lfMenuFont.lfHeight;

    if (pnMenuFontHeghti)
        *pnMenuFontHeghti = nMenuFontHeight;

    //
    // CUIMENU.CPP uses 8 as TextMargin of dropdown menu.
    //

    if ((nMenuFontHeight + 8 >= cxSmIcon) && (nMenuFontHeight <= cxSmIcon))
        return cxSmIcon;

    return nMenuFontHeight + 4;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\immlist.cpp ===
//
// imelist.cpp
//

#include "private.h"
#include "immlist.h"

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CVoidPtrCicList::CVoidPtrCicList()
{
    _pitemHdr = NULL;
    _pitemLast = NULL;

}

//+---------------------------------------------------------------------------
//
// Add
//
//----------------------------------------------------------------------------

void CVoidPtrCicList::Add(CVoidPtrCicListItem *pitem)
{
    if (!_pitemLast)
        _pitemHdr = pitem;
    else
        _pitemLast->_pNext = pitem;
    pitem->_pNext = NULL;
    _pitemLast = pitem;
}

//+---------------------------------------------------------------------------
//
// Remove
//
//----------------------------------------------------------------------------

BOOL CVoidPtrCicList::Remove(CVoidPtrCicListItem *pitem)
{
    CVoidPtrCicListItem *pitemTmp;
    CVoidPtrCicListItem *pitemPrev = NULL;

    pitemTmp = _pitemHdr;
    while(pitemTmp)
    {
        if (pitemTmp == pitem)
        {
            if (!pitemPrev)
            {
                _pitemHdr = pitemTmp->_pNext;
            }
            else
            {
                pitemPrev->_pNext = pitemTmp->_pNext;
            }

            if (_pitemLast == pitem)
            {
                _pitemLast = pitemPrev;
            }

            return TRUE;

        }
        pitemPrev = pitemTmp;
        pitemTmp = pitemTmp->_pNext;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// Find
//
//----------------------------------------------------------------------------

CVoidPtrCicListItem *CVoidPtrCicList::Find(void *pHandle)
{
    CVoidPtrCicListItem *pitem;

    pitem = _pitemHdr;
    while(pitem)
    {
        if (pitem->_pHandle == pHandle)
            return pitem;
        pitem = pitem->_pNext;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\immxutil.cpp ===
#include "private.h"
#include "immxutil.h"
#include "helpers.h"
#include "regsvr.h"

//+---------------------------------------------------------------------------
//
// GetTextExtInActiveView
//
//	Get a range text extent from the active view of a document mgr.
//----------------------------------------------------------------------------

HRESULT GetTextExtInActiveView(TfEditCookie ec, ITfRange *pRange, RECT *prc, BOOL *pfClipped)
{
    ITfContext *pic;
    ITfContextView *pView;
    HRESULT hr;

    // do the deref: range->ic->defView->GetTextExt()

    if (pRange->GetContext(&pic) != S_OK)
        return E_FAIL;

    hr = pic->GetActiveView(&pView);
    pic->Release();

    if (hr != S_OK)
        return E_FAIL;

    hr = pView->GetTextExt(ec, pRange, prc, pfClipped);
    pView->Release();

    return hr;
}

//+---------------------------------------------------------------------------
//
// IsActiveView
//
// Returns TRUE iff pView is the active view in the specified context.
//----------------------------------------------------------------------------

BOOL IsActiveView(ITfContext *pic, ITfContextView *pView)
{
    ITfContextView *pActiveView;
    BOOL fRet;

    if (pic->GetActiveView(&pActiveView) != S_OK)
        return FALSE;

    fRet = IdentityCompare(pActiveView, pView);

    pActiveView->Release();

    return fRet;
}

//+---------------------------------------------------------------------------
//
// ShiftToOrClone
//
//----------------------------------------------------------------------------

BOOL ShiftToOrClone(IAnchor **ppaDst, IAnchor *paSrc)
{
    if (*ppaDst == paSrc)
        return TRUE;

    if (*ppaDst == NULL)
    {
        paSrc->Clone(ppaDst);
    }
    else
    {
        (*ppaDst)->ShiftTo(paSrc);
    }

    return (*ppaDst != NULL);
}

//+---------------------------------------------------------------------------
//
// AsciiToNum
//
//----------------------------------------------------------------------------

DWORD AsciiToNum( char *pszAscii)
{
   DWORD dwNum = 0;

   for (; *pszAscii; pszAscii++) {
       if (*pszAscii >= '0' && *pszAscii <= '9') {
           dwNum = (dwNum << 4) | (*pszAscii - '0');
       } else if (*pszAscii >= 'A' && *pszAscii <= 'F') {
           dwNum = (dwNum << 4) | (*pszAscii - 'A' + 0x000A);
       } else if (*pszAscii >= 'a' && *pszAscii <= 'f') {
           dwNum = (dwNum << 4) | (*pszAscii - 'a' + 0x000A);
       } else {
           return (0);
       }
   }

   return (dwNum);
}

//+---------------------------------------------------------------------------
//
// AsciiToNumDec
//
//----------------------------------------------------------------------------

BOOL AsciiToNumDec(char *pszAscii, DWORD *pdw)
{
    *pdw = 0;

   for (; *pszAscii; pszAscii++)
   {
       if (*pszAscii >= '0' && *pszAscii <= '9')
       {
           *pdw *= 10;
           *pdw += (*pszAscii - '0');
       }
       else
       {
           *pdw = 0;
           return FALSE;
       }
   }

   return TRUE;
}

//+---------------------------------------------------------------------------
//
// NumToA
//
//----------------------------------------------------------------------------

void NumToA(DWORD dw, char *psz)
{
    int n = 7;
    while (n >= 0)
    {
        BYTE b = (BYTE)(dw >> (n * 4)) & 0x0F;
        if (b < 0x0A)
           *psz = (char)('0' + b);
        else 
           *psz = (char)('A' + b - 0x0A);
        psz++;
        n--;
    }
    *psz = L'\0';

    return;
}

//+---------------------------------------------------------------------------
//
// WToNum
//
//----------------------------------------------------------------------------

DWORD WToNum( WCHAR *psz)
{
   DWORD dwNum = 0;

   for (; *psz; psz++) {
       if (*psz>= L'0' && *psz<= L'9') {
           dwNum = (dwNum << 4) | (*psz - L'0');
       } else if (*psz>= L'A' && *psz<= L'F') {
           dwNum = (dwNum << 4) | (*psz - L'A' + 0x000A);
       } else if (*psz>= L'a' && *psz<= L'f') {
           dwNum = (dwNum << 4) | (*psz - L'a' + 0x000A);
       } else {
           return (0);
       }
   }

   return (dwNum);
}

//+---------------------------------------------------------------------------
//
// NumToW
//
//----------------------------------------------------------------------------

void NumToW(DWORD dw, WCHAR *psz)
{
    int n = 7;
    while (n >= 0)
    {
        BYTE b = (BYTE)(dw >> (n * 4)) & 0x0F;
        if (b < 0x0A)
           *psz = (WCHAR)(L'0' + b);
        else 
           *psz = (WCHAR)(L'A' + b - 0x0A);
        psz++;
        n--;
    }
    *psz = L'\0';

    return;
}

//+---------------------------------------------------------------------------
//
// GetTopIC
//
//----------------------------------------------------------------------------

BOOL GetTopIC(ITfDocumentMgr *pdim, ITfContext **ppic)
{
    HRESULT hr;

    *ppic = NULL;

    if (pdim == NULL)
        return FALSE;

    hr = pdim->GetTop(ppic);

    return SUCCEEDED(hr) ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
// AdjustAnchor
//
//----------------------------------------------------------------------------

LONG AdjustAnchor(LONG ichAdjStart, LONG ichAdjEnd, LONG cchNew, LONG ichAnchor, BOOL fGravityRight)
{
    int cchAdjust;

    // if the adjustment is entirely to the right, nothing to do
    if (ichAdjStart > ichAnchor)
        return ichAnchor;

    // if the adjustment was a simple replacement -- no size change -- nothing to do
    if ((cchAdjust = cchNew - (ichAdjEnd - ichAdjStart)) == 0)
        return ichAnchor;

    if (ichAdjStart == ichAnchor && ichAdjEnd == ichAnchor)
    {
        // inserting at the anchor pos
        Assert(cchAdjust > 0);
        if (fGravityRight)
        {
            ichAnchor += cchAdjust;
        }
    }
    else if (ichAdjEnd <= ichAnchor)
    {
        // the adjustment is to the left of the anchor, just add the delta
        ichAnchor += cchAdjust;
    }
    else if (cchAdjust < 0)
    {
        // need to slide the anchor back if it's within the deleted range of text
        ichAnchor = min(ichAnchor, ichAdjEnd + cchAdjust);
    }
    else // cchAdjust > 0
    {
        // there's nothing to do
    }

    return ichAnchor;
}

//+---------------------------------------------------------------------------
//
// CompareRanges
//
//----------------------------------------------------------------------------

int CompareRanges(TfEditCookie ec, ITfRange *pRangeSrc, ITfRange *pRangeCmp)
{
    int nRet = CR_ERROR;
    BOOL fEqual;
    LONG l;

    pRangeCmp->CompareEnd(ec, pRangeSrc, TF_ANCHOR_START, &l);
    if (l <= 0)
        return CR_LEFT;

    pRangeSrc->CompareEnd(ec, pRangeCmp, TF_ANCHOR_START, &l);
    if (l < 0) // incl char to right
        return CR_RIGHT;

    if (pRangeSrc->IsEqualStart(ec, pRangeCmp, TF_ANCHOR_START, &fEqual) == S_OK && fEqual &&
        pRangeSrc->IsEqualEnd(ec, pRangeCmp, TF_ANCHOR_END, &fEqual) == S_OK && fEqual)
    {
        return CR_EQUAL;
    }

    pRangeSrc->CompareStart(ec, pRangeCmp, TF_ANCHOR_START, &l);
    if (l <= 0)
    {
        pRangeSrc->CompareEnd(ec, pRangeCmp, TF_ANCHOR_END, &l);
        if (l < 0)
            return CR_RIGHTMEET;
        else
            return CR_PARTIAL;
    }
    else
    {
        pRangeSrc->CompareEnd(ec, pRangeCmp, TF_ANCHOR_END, &l);
        if (l < 0)
            return CR_INCLUSION;
        else
            return CR_LEFTMEET;
    }

    return nRet;
}

//+---------------------------------------------------------------------------
//
// GetRangeForWholeDoc
//
//----------------------------------------------------------------------------

HRESULT GetRangeForWholeDoc(TfEditCookie ec, ITfContext *pic, ITfRange **pprange)
{
    HRESULT hr;
    ITfRange *pRangeEnd = NULL;
    ITfRange *pRange = NULL;

    *pprange = NULL;

    if (FAILED(hr = pic->GetStart(ec,&pRange)))
        return hr;

    if (FAILED(hr = pic->GetEnd(ec,&pRangeEnd)))
        return hr;

    hr = pRange->ShiftEndToRange(ec, pRangeEnd, TF_ANCHOR_END);
    pRangeEnd->Release();

    if (SUCCEEDED(hr))
        *pprange = pRange;
    else
        pRange->Release();

    return hr;
}

//+---------------------------------------------------------------------------
//
// CompareGUIDs
//
//----------------------------------------------------------------------------
__inline int CompUnsigned(ULONG u1, ULONG u2)
{
    if (u1 == u2)
        return 0;

    return (u1 > u2) ? 1 : -1;
}

int CompareGUIDs(REFGUID guid1, REFGUID guid2)
{
    int i;
    int nRet;

    if (nRet = CompUnsigned(guid1.Data1, guid2.Data1))
        return nRet;

    if (nRet = CompUnsigned(guid1.Data2, guid2.Data2))
        return nRet;

    if (nRet = CompUnsigned(guid1.Data3, guid2.Data3))
        return nRet;

    for (i = 0; i < 8; i++)
    {
        if (nRet = CompUnsigned(guid1.Data4[i], guid2.Data4[i]))
            return nRet;
    }

    return 0;
}


//+---------------------------------------------------------------------------
//
// IsDisabledTextServices
//
//----------------------------------------------------------------------------
BOOL IsDisabledTextServices(void)
{
    static const TCHAR c_szCTFKey[]     = TEXT("SOFTWARE\\Microsoft\\CTF");
    static const TCHAR c_szDiableTim[]  = TEXT("Disable Thread Input Manager");

    HKEY hKey;

    if (RegOpenKey(HKEY_CURRENT_USER, c_szCTFKey, &hKey) == ERROR_SUCCESS)
    {
        DWORD cb;
        DWORD dwDisableTim = 0;

        cb = sizeof(DWORD);

        RegQueryValueEx(hKey,
                        c_szDiableTim,
                        NULL,
                        NULL,
                        (LPBYTE)&dwDisableTim,
                        &cb);

        RegCloseKey(hKey);

        //
        // Ctfmon disabling flag is set, so return fail CreateInstance.
        //
        if (dwDisableTim)
            return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// IsTIPClsidEnabled
//
//----------------------------------------------------------------------------
const TCHAR c_szLanguageProfile[]   = TEXT("\\LanguageProfile");
const TCHAR c_szCTFTipPath[]        = TEXT("SOFTWARE\\Microsoft\\CTF\\TIP\\");

BOOL IsTIPClsidEnabled(
    HKEY hkeyTop,
    LPTSTR szTipClsid,
    BOOL *bExistEnable)
{
    BOOL bRet = FALSE;
    HKEY hkeyTipLang;
    HKEY hkeyTipLangid;
    HKEY hkeyTipGuid;
    UINT uIndex;
    UINT uIndex2;
    DWORD cb;
    DWORD cchLangid;
    DWORD cchGuid;
    DWORD dwEnableTIP = 0;
    LPTSTR pszGuid;
    LPTSTR pszLangid;
    TCHAR szTIPLangid[15];
    TCHAR szTIPGuid[128];
    TCHAR szTIPClsidLang[MAX_PATH];
    FILETIME lwt;
    UINT uLangidLen;
    UINT uGuidLen;

    StringCchCopy(szTIPClsidLang, ARRAYSIZE(szTIPClsidLang), c_szCTFTipPath);
    StringCchCat(szTIPClsidLang, ARRAYSIZE(szTIPClsidLang), szTipClsid);
    StringCchCat(szTIPClsidLang, ARRAYSIZE(szTIPClsidLang), c_szLanguageProfile);

    pszLangid = szTIPClsidLang + lstrlen(szTIPClsidLang);
    uLangidLen = ARRAYSIZE(szTIPClsidLang) - lstrlen(szTIPClsidLang);

    if (RegOpenKeyEx(hkeyTop,
                     szTIPClsidLang, 0,
                     KEY_READ, &hkeyTipLang) != ERROR_SUCCESS)
    {
        goto Exit;
    }

    for (uIndex = 0; bRet == FALSE; uIndex++)
    {
        cchLangid = sizeof(szTIPLangid) / sizeof(TCHAR);

        if (RegEnumKeyEx(hkeyTipLang, uIndex,
                         szTIPLangid, &cchLangid,
                         NULL, NULL, NULL, &lwt) != ERROR_SUCCESS)
        {
            break;
        }

        if (cchLangid != 10)
        {
            // string langid subkeys should be like 0x00000409
            continue;
        }

        if (uLangidLen > (cchLangid + 1))
        {
            StringCchCopy(pszLangid, uLangidLen, TEXT("\\"));
            StringCchCat(szTIPClsidLang, ARRAYSIZE(szTIPClsidLang), szTIPLangid);
        }

        if (RegOpenKeyEx(hkeyTop,
                         szTIPClsidLang, 0,
                         KEY_READ, &hkeyTipLangid) != ERROR_SUCCESS)
        {
            continue;
        }

        pszGuid = szTIPClsidLang + lstrlen(szTIPClsidLang);
        uGuidLen = ARRAYSIZE(szTIPClsidLang) - lstrlen(szTIPClsidLang);

        for (uIndex2 = 0; bRet == FALSE; uIndex2++)
        {
            cchGuid = sizeof(szTIPGuid) / sizeof(TCHAR);

            if (RegEnumKeyEx(hkeyTipLangid, uIndex2,
                             szTIPGuid, &cchGuid,
                             NULL, NULL, NULL, &lwt) != ERROR_SUCCESS)
            {
                break;
            }

            if (cchGuid != 38)
            {
                continue;
            }

            if (uGuidLen > (cchGuid + 1))
            {
                StringCchCopy(pszGuid, uGuidLen, TEXT("\\"));
                StringCchCat(szTIPClsidLang, ARRAYSIZE(szTIPClsidLang), szTIPGuid);
            }

            if (RegOpenKeyEx(hkeyTop,
                             szTIPClsidLang, 0,
                             KEY_READ, &hkeyTipGuid) == ERROR_SUCCESS)
            {
                cb = sizeof(DWORD);

                if (RegQueryValueEx(hkeyTipGuid,
                                    TEXT("Enable"),
                                    NULL,
                                    NULL,
                                    (LPBYTE)&dwEnableTIP,
                                    &cb) == ERROR_SUCCESS)
                {
                    *bExistEnable = TRUE;

                    if (dwEnableTIP)
                    {
                        bRet = TRUE;
                    }
                }
                else if (hkeyTop == HKEY_LOCAL_MACHINE)
                {
                    // Default is the enabled status on HKLM
                    *bExistEnable = TRUE;
                    bRet = TRUE;
                }
                else
                {
                    *bExistEnable = FALSE;
                }

                RegCloseKey(hkeyTipGuid);
            }

        }

        RegCloseKey(hkeyTipLangid);
    }

    RegCloseKey(hkeyTipLang);

Exit:

    return bRet;
}

//+---------------------------------------------------------------------------
//
// NoTipsInstalled
//
//----------------------------------------------------------------------------
// grab CLSID_SOFTKBDIMX here
#include <initguid.h>
#include "SoftKbd.h"

BOOL NoTipsInstalled(BOOL *pfOnlyTranslationRunning)
{
    const CLSID CLSID_SapiLayr = {0xdcbd6fa8, 0x032f, 0x11d3, {0xb5, 0xb1, 0x00, 0xc0, 0x4f, 0xc3, 0x24, 0xa1}};

    static const TCHAR c_szSpeechRecognizersKey[] = TEXT("Software\\Microsoft\\Speech\\Recognizers\\Tokens");
    static const TCHAR c_szCategory[] = TEXT("\\Category\\Category");

    BOOL bRet = TRUE;
    BOOL bExistEnable;
    HKEY hkeyTip;
    HKEY hkeyTipSub;
    UINT uIndex;
    DWORD dwSubKeys;
    DWORD cchClsid;
    CLSID clsidTip;
    TCHAR szTipClsid[128];
    TCHAR szTipClsidPath[MAX_PATH];
    FILETIME lwt;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     TEXT("Software\\Microsoft\\CTF\\TIP"),
                     0, KEY_READ, &hkeyTip) != ERROR_SUCCESS)
    {
        goto Exit;
    }

    // enum through all the TIP subkeys
    for (uIndex = 0; TRUE; uIndex++)
    {
        bExistEnable = FALSE;

        cchClsid = sizeof(szTipClsid) / sizeof(TCHAR);

        if (RegEnumKeyEx(hkeyTip, uIndex,
                         szTipClsid, &cchClsid,
                         NULL, NULL, NULL, &lwt) != ERROR_SUCCESS)
        {
            break;
        }

        if (cchClsid != 38)
        {
            // string clsid subkeys should be like {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
            continue;
        }

        StringCchCopy(szTipClsidPath, ARRAYSIZE(szTipClsidPath), szTipClsid);

        // we want subkey\Language Profiles key
        StringCchCat(szTipClsidPath, ARRAYSIZE(szTipClsidPath), c_szLanguageProfile);

        // is this subkey a tip?
        if (RegOpenKeyEx(hkeyTip,
                         szTipClsidPath, 0,
                         KEY_READ, &hkeyTipSub) == ERROR_SUCCESS)
        {
            RegCloseKey(hkeyTipSub);

            // it's a tip, get the clsid
            if (!StringAToCLSID(szTipClsid, &clsidTip))
                continue;

            // special case certain known tips
            if (IsEqualGUID(clsidTip, CLSID_SapiLayr))
            {
                //
                // This is SAPI TIP and need to handle it specially, since sptip has
                // a default option as the enabled status.
                //
                if (!IsTIPClsidEnabled(HKEY_CURRENT_USER, szTipClsid, &bExistEnable))
                {
                    //
                    // If SPTIP has enable registry setting on HKCU with the disabled
                    // speech tip, we assume user intentionally disable it.
                    //
                    if (bExistEnable)
                        continue;
                }

                // this is the sapi tip, which is always installed
                // but it will not activate if sapi is not installed
                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 c_szSpeechRecognizersKey, 0,
                                 KEY_READ, &hkeyTipSub) != ERROR_SUCCESS)
                {
                    continue; // this tip doesn't count
                }

                // need 1 or more subkeys for sapi to be truely installed...whistler has a Tokens with nothing underneath
                if (RegQueryInfoKey(hkeyTipSub,
                                    NULL, NULL, NULL, &dwSubKeys, NULL,
                                    NULL, NULL, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
                {
                    dwSubKeys = 0; // assume no sub keys on failure
                }

                RegCloseKey(hkeyTipSub);

                if (dwSubKeys != 0)
                {
                    bRet = FALSE;
                    break;
                }
            }
            else if (IsEqualGUID(clsidTip, CLSID_SoftkbdIMX))
            {
                // don't count the softkbd, it is disabled until another tip
                // enables it
                continue;
            }
            else if(IsTIPClsidEnabled(HKEY_CURRENT_USER, szTipClsid, &bExistEnable))
            {
                bRet = FALSE;
                break;
            }
            else if (!bExistEnable)
            {
                if(IsTIPClsidEnabled(HKEY_LOCAL_MACHINE, szTipClsid, &bExistEnable))
                {
                   bRet = FALSE;
                   break;
                }
            }
        }
    }

    RegCloseKey(hkeyTip);

Exit:
    if (bRet == TRUE && pfOnlyTranslationRunning != NULL) // skip the check for aimm, which passes in NULL pfOnlyTranslationRunning
    {
        // word10 compart: check for bookshelf's translation service
        // it uses cicero, but does not formally register itself as a tip.
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         TEXT("SOFTWARE\\Microsoft\\Microsoft Reference\\Bilinguals 1.0"),
                         0, KEY_READ, &hkeyTip) == ERROR_SUCCESS)
        {
            *pfOnlyTranslationRunning = TRUE;
            bRet = FALSE;
            RegCloseKey(hkeyTip);
        }
    }

    return bRet;
}

//+---------------------------------------------------------------------------
//
// RunningOnWow64
//
//----------------------------------------------------------------------------

BOOL RunningOnWow64()
{
    BOOL bOnWow64 = FALSE;
    // check to make sure that we are running on wow64
    LONG lStatus;
    ULONG_PTR Wow64Info;

    typedef BOOL (WINAPI *PFN_NTQUERYINFORMATIONPROCESS)(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);

    PFN_NTQUERYINFORMATIONPROCESS pfnNtQueryInformationProcess;
    HINSTANCE hLibNtDll = NULL;
    hLibNtDll = GetSystemModuleHandle( TEXT("ntdll.dll") );
    if (hLibNtDll)
    {
        pfnNtQueryInformationProcess = (PFN_NTQUERYINFORMATIONPROCESS)GetProcAddress(hLibNtDll, TEXT("NtQueryInformationProcess"));
        if (pfnNtQueryInformationProcess)
        {
            lStatus = pfnNtQueryInformationProcess(GetCurrentProcess(), ProcessWow64Information, &Wow64Info, sizeof(Wow64Info), NULL);
            if (NT_SUCCESS(lStatus) && Wow64Info)
            {
                bOnWow64 = TRUE;
            }
        }
    }

    return bOnWow64;
}

//+---------------------------------------------------------------------------
//
// GetSystemDefaultHKL
//
//----------------------------------------------------------------------------

HKL GetSystemDefaultHKL()
{
    HKL hkl;
    if (SystemParametersInfo( SPI_GETDEFAULTINPUTLANG, 0, &hkl, 0))
        return hkl;

    return GetKeyboardLayout(0);
}

//+---------------------------------------------------------------------------
//
// IsDisabledCUAS
//
//----------------------------------------------------------------------------
BOOL IsDisabledCUAS()
{
    static const TCHAR c_szCtfShared[]  = TEXT("SOFTWARE\\Microsoft\\CTF\\SystemShared");
    static const TCHAR c_szCUAS[]       = TEXT("CUAS");

    DWORD cb;
    HKEY hkeyCTF;
    BOOL bRet = TRUE;
    DWORD dwEnableCUAS = 0;

    if (RegOpenKey(HKEY_LOCAL_MACHINE, c_szCtfShared, &hkeyCTF) == ERROR_SUCCESS)
    {
        cb = sizeof(DWORD);

        RegQueryValueEx(hkeyCTF,
                        c_szCUAS,
                        NULL,
                        NULL,
                        (LPBYTE)&dwEnableCUAS,
                        &cb);

        if (dwEnableCUAS)
            bRet = FALSE;

        RegCloseKey(hkeyCTF);
    }

    return bRet;
}

//+---------------------------------------------------------------------------
//
// IsInstalledEALangPack
//
//----------------------------------------------------------------------------
BOOL IsInstalledEALangPack()
{
    static const TCHAR c_szLangGroup[]  = TEXT("System\\CurrentControlSet\\Control\\Nls\\Language Groups");
    static const TCHAR c_szLangJPN[]    = TEXT("7");

    BOOL bRet = FALSE;
    HKEY hkeyLangGroup;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     c_szLangGroup,
                     0,
                     KEY_READ,
                     &hkeyLangGroup) == ERROR_SUCCESS)
    {
        DWORD cb;
        TCHAR szLangInstall[10];

        cb = sizeof(szLangInstall);

        //
        //  The checking of Japan Language is enough to know EA language pack
        //  installation.
        //
        if (RegQueryValueEx(hkeyLangGroup,
                            c_szLangJPN,
                            NULL,
                            NULL,
                            (LPBYTE)szLangInstall,
                            &cb) == ERROR_SUCCESS)
        {
            if (szLangInstall[0] != 0)
                return TRUE;
        }

        RegCloseKey(hkeyLangGroup);
    }

    return bRet;
}

//+---------------------------------------------------------------------------
//
// SetDisableCUAS
//
//----------------------------------------------------------------------------
void SetDisableCUAS(
    BOOL bDisableCUAS)
{
    static const TCHAR c_szCtfShared[]  = TEXT("SOFTWARE\\Microsoft\\CTF\\SystemShared");
    static const TCHAR c_szIMM[]        = TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IMM");
    static const TCHAR c_szLoadIMM[]    = TEXT("LoadIMM");
    static const TCHAR c_szIMMFile[]    = TEXT("IME File");
    static const TCHAR c_szIMMFileName[]= TEXT("msctfime.ime");
    static const TCHAR c_szCUAS[]       = TEXT("CUAS");

    HKEY hkeyIMM;
    HKEY hkeyCTF;
    DWORD cb = sizeof(DWORD);
    DWORD dwIMM32, dwCUAS;

    if (bDisableCUAS)
        dwIMM32 = dwCUAS = 0;
    else
        dwIMM32 = dwCUAS = 1;

    if (RegCreateKey(HKEY_LOCAL_MACHINE, c_szIMM, &hkeyIMM) != ERROR_SUCCESS)
    {
        hkeyIMM = NULL;
    }

    if (RegCreateKey(HKEY_LOCAL_MACHINE, c_szCtfShared, &hkeyCTF) != ERROR_SUCCESS)
    {
        hkeyCTF = NULL;
    }

    if (!bDisableCUAS)
    {
        //
        //  Turn on LoadIMM and CUAS flags
        //

        if (hkeyIMM)
        {
            RegSetValueEx(hkeyIMM,
                          c_szIMMFile,
                          0,
                          REG_SZ,
                          (LPBYTE)c_szIMMFileName,
                          (lstrlen(c_szIMMFileName) + 1) * sizeof(TCHAR));
        }
    }
    else
    {
        //
        //  Turn off LoadIMM and CUAS flags
        //

        BOOL bEALang = IsInstalledEALangPack();

        if (bEALang)
        {
            dwIMM32 = 1;
        }
    }

    if (hkeyIMM)
    {
        RegSetValueEx(hkeyIMM,
                      c_szLoadIMM,
                      0,
                      REG_DWORD,
                      (LPBYTE)&dwIMM32,
                      cb);
    }

    if (hkeyCTF)
    {
        RegSetValueEx(hkeyCTF,
                      c_szCUAS,
                      0,
                      REG_DWORD,
                      (LPBYTE)&dwCUAS,
                      cb);
    }

    if (hkeyIMM)
        RegCloseKey(hkeyIMM);

    if (hkeyCTF)
        RegCloseKey(hkeyCTF);
}

//+---------------------------------------------------------------------------
//
// RebootTheSystem
//
//----------------------------------------------------------------------------
void RebootTheSystem()
{
    HANDLE Token = NULL;
    ULONG ReturnLength, Index;
    PTOKEN_PRIVILEGES NewState = NULL;
    PTOKEN_PRIVILEGES OldState = NULL;
    BOOL Result;

    //  Only allow admin privilege user for system reboot.
    if (!IsAdminPrivilege())
        return;

    Result = OpenProcessToken( GetCurrentProcess(),
                               TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                               &Token );
    if (Result)
    {
        ReturnLength = 4096;
        NewState = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR, ReturnLength);
        OldState = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR, ReturnLength);
        Result = (BOOL)((NewState != NULL) && (OldState != NULL));
        if (Result)
        {
            Result = GetTokenInformation( Token,            // TokenHandle
                                          TokenPrivileges,  // TokenInformationClass
                                          NewState,         // TokenInformation
                                          ReturnLength,     // TokenInformationLength
                                          &ReturnLength );  // ReturnLength
            if (Result)
            {
                //
                //  Set the state settings so that all privileges are
                //  enabled...
                //
                if (NewState->PrivilegeCount > 0)
                {
                    for (Index = 0; Index < NewState->PrivilegeCount; Index++)
                    {
                        NewState->Privileges[Index].Attributes = SE_PRIVILEGE_ENABLED;
                    }
                }

                Result = AdjustTokenPrivileges( Token,           // TokenHandle
                                                FALSE,           // DisableAllPrivileges
                                                NewState,        // NewState
                                                ReturnLength,    // BufferLength
                                                OldState,        // PreviousState
                                                &ReturnLength ); // ReturnLength
                if (Result)
                {
                    ExitWindowsEx(EWX_REBOOT, 0);


                    AdjustTokenPrivileges( Token,
                                           FALSE,
                                           OldState,
                                           0,
                                           NULL,
                                           NULL );
                }
            }
        }
    }

    if (NewState != NULL)
    {
        LocalFree(NewState);
    }
    if (OldState != NULL)
    {
        LocalFree(OldState);
    }
    if (Token != NULL)
    {
        CloseHandle(Token);
    }
}

//+---------------------------------------------------------------------------
//
// IsAdminPrivilege
//
//----------------------------------------------------------------------------
BOOL IsAdminPrivilege()
{
    BOOL bAdmin = FALSE;
    BOOL bResult = FALSE;
    BOOL fSIDCreated = FALSE;
    HANDLE hToken = NULL;
    PSID AdminSid;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    fSIDCreated = AllocateAndInitializeSid(&NtAuthority,
                                           2,
                                           SECURITY_BUILTIN_DOMAIN_RID,
                                           DOMAIN_ALIAS_RID_ADMINS,
                                           0, 0, 0, 0, 0, 0,
                                           &AdminSid);

    if (!fSIDCreated)
        return FALSE;

    bResult = OpenProcessToken(GetCurrentProcess(),
                               TOKEN_QUERY,
                               &hToken );

    if (bResult)
    {
        DWORD dwSize = 0;
        TOKEN_GROUPS *pTokenGrpInfo;

        GetTokenInformation(hToken,
                            TokenGroups,
                            NULL,
                            dwSize,
                            &dwSize);

        if (dwSize)
            pTokenGrpInfo = (PTOKEN_GROUPS) LocalAlloc(LPTR, dwSize);
        else
            pTokenGrpInfo = NULL;

        if (pTokenGrpInfo && GetTokenInformation(hToken,
                                                 TokenGroups,
                                                 pTokenGrpInfo,
                                                 dwSize,
                                                 &dwSize))
        {
            UINT i;

            for (i = 0; i < pTokenGrpInfo->GroupCount; i++)
            {
                if (EqualSid(pTokenGrpInfo->Groups[i].Sid, AdminSid) &&
                    (pTokenGrpInfo->Groups[i].Attributes & SE_GROUP_ENABLED))
                {
                    bAdmin = TRUE;
                    break;
                }
            }
        }

        if (pTokenGrpInfo)
            LocalFree(pTokenGrpInfo);
    }

    if (hToken)
        CloseHandle(hToken);

    if (AdminSid)
        FreeSid(AdminSid);

    return bAdmin;
}

//+---------------------------------------------------------------------------
//
// IsInteractiveUserLogon
//
//----------------------------------------------------------------------------
BOOL IsInteractiveUserLogon()
{
    PSID InteractiveSid;
    BOOL bCheckSucceeded;
    BOOL bAmInteractive = FALSE;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    if (!AllocateAndInitializeSid(&NtAuthority,
                                  1,
                                  SECURITY_INTERACTIVE_RID,
                                  0, 0, 0, 0, 0, 0, 0,
                                  &InteractiveSid))
    {
        return FALSE;
    }

    //
    // This checking is for logged on user or not. So we can blcok running
    // ctfmon.exe process from non-authorized user.
    //
    bCheckSucceeded = CheckTokenMembership(NULL,
                                           InteractiveSid,
                                           &bAmInteractive);

    if (InteractiveSid)
        FreeSid(InteractiveSid);

    return (bCheckSucceeded && bAmInteractive);
}



//+---------------------------------------------------------------------------
//
// GetSystemModuleHandle
//
//----------------------------------------------------------------------------

HMODULE GetSystemModuleHandle(LPCSTR lpModuleName)
{
    CicSystemModulePath path;

    if (!path.Init(lpModuleName))
         return NULL;

    return GetModuleHandle(path.GetPath());
}

//+---------------------------------------------------------------------------
//
// LoadSystemLibrary
//
//----------------------------------------------------------------------------

HMODULE LoadSystemLibrary(LPCSTR lpModuleName)
{
    CicSystemModulePath path;

    if (!path.Init(lpModuleName))
         return NULL;

    return LoadLibrary(path.GetPath());
}

//+---------------------------------------------------------------------------
//
// LoadSystemLibraryEx
//
//----------------------------------------------------------------------------

HMODULE LoadSystemLibraryEx(LPCSTR lpModuleName, HANDLE hFile, DWORD dwFlags)
{
    CicSystemModulePath path;

    if (!path.Init(lpModuleName))
         return NULL;

    return LoadLibraryEx(path.GetPath(), hFile, dwFlags);
}


//+---------------------------------------------------------------------------
//
// GetSystemModuleHandleW
//
//----------------------------------------------------------------------------

HMODULE GetSystemModuleHandleW(LPCWSTR lpModuleName)
{
    CicSystemModulePathW path;

    if (!path.Init(lpModuleName))
         return NULL;

    return GetModuleHandleW(path.GetPath());
}

//+---------------------------------------------------------------------------
//
// LoadSystemLibraryW
//
//----------------------------------------------------------------------------

HMODULE LoadSystemLibraryW(LPCWSTR lpModuleName)
{
    CicSystemModulePathW path;

    if (!path.Init(lpModuleName))
         return NULL;

    return LoadLibraryW(path.GetPath());
}

//+---------------------------------------------------------------------------
//
// LoadSystemLibraryEx
//
//----------------------------------------------------------------------------

HMODULE LoadSystemLibraryExW(LPCWSTR lpModuleName, HANDLE hFile, DWORD dwFlags)
{
    CicSystemModulePathW path;

    if (!path.Init(lpModuleName))
         return NULL;

    return LoadLibraryExW(path.GetPath(), hFile, dwFlags);
}

//+---------------------------------------------------------------------------
//
// FullPathExec
//
//----------------------------------------------------------------------------

BOOL FullPathExec(
    LPCSTR pszAppName,
    LPCSTR pszCmdLine,
    WORD wShowWindow,
    BOOL fWinDir)
{
    char szCmdLine[MAX_PATH + 1];
    CicSystemModulePath fullpath;
    fullpath.Init(pszAppName, fWinDir);
    if (!fullpath.GetLength())
        return FALSE;

    //
    // CreateProcess() wants an out buffer for CmdLine. So we just have it in
    // stack.
    //
    StringCchCopy(szCmdLine, ARRAYSIZE(szCmdLine), pszCmdLine);

    PROCESS_INFORMATION pi;
    STARTUPINFO si = {0};

    si.cb = sizeof(STARTUPINFO);
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = (WORD)wShowWindow;

    return CreateProcess(fullpath.GetPath(),
                         szCmdLine,
                         NULL,
                         NULL,
                         FALSE,
                         NORMAL_PRIORITY_CLASS,
                         NULL,
                         NULL,
                         &si,
                         &pi);
}

//+---------------------------------------------------------------------------
//
// RunCPLs
//
//----------------------------------------------------------------------------

BOOL RunCPLSetting(
    LPTSTR pCmdLine)
{
    const TCHAR c_szRundll32[]   = TEXT("Rundll32.exe");

    if (!pCmdLine)
        return FALSE;

    return FullPathExec(c_szRundll32, 
                        pCmdLine, 
                        SW_SHOWMINNOACTIVE,
                        FALSE);
}

//+---------------------------------------------------------------------------
//
// DllShutdownInProgress
//
//+---------------------------------------------------------------------------

typedef BYTE (*PFNRTLDLLSHUTDOWININPROGRESS)(void);

BOOL DllShutdownInProgress()
{
    BOOL fRet = FALSE;
    static PFNRTLDLLSHUTDOWININPROGRESS pfn = NULL;

    if (!pfn)
    {
        HINSTANCE hInst;
        hInst= GetSystemModuleHandle("ntdll.dll");
        if (hInst)
        {
            pfn = (PFNRTLDLLSHUTDOWININPROGRESS)GetProcAddress(hInst,
                                                   "RtlDllShutdownInProgress");
        }
    }

    if (pfn)
        fRet = pfn() ? TRUE : FALSE;

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\init.cpp ===
//
// init.cpp
//

#include "private.h"
#include "immxutil.h"
#include "globals.h"
#include "dispattr.h"

HINSTANCE g_lib_hOle32 = 0;

//+---------------------------------------------------------------------------
//
// TFInitLib
//
//----------------------------------------------------------------------------

BOOL TFInitLib(void)
{
    return TFInitLib_PrivateForCiceroOnly(NULL);
}

// NB: this is going away once we cleanup/separate the private/public libs
BOOL TFInitLib_PrivateForCiceroOnly(PFNCOCREATE pfnCoCreate)
{
    if ((g_pfnCoCreate = pfnCoCreate) == NULL)
    {
        g_lib_hOle32 = LoadSystemLibrary(TEXT("ole32.dll"));

        if (g_lib_hOle32 == NULL)
        {
            Assert(0);
            return FALSE;
        }

        g_pfnCoCreate = (PFNCOCREATE)GetProcAddress(g_lib_hOle32, TEXT("CoCreateInstance"));

        if (g_pfnCoCreate == NULL)
        {
            Assert(0);
            FreeLibrary(g_lib_hOle32);
            g_lib_hOle32 = 0;
            return FALSE;
        }
    }

    g_uiACP = GetACP();

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// TFUninitLib
//
//----------------------------------------------------------------------------

void TFUninitLib(void)
{
    if (g_pPropCache)
        delete g_pPropCache;

    g_pPropCache = NULL;

    if (g_hMlang != 0) // Issue: get rid of this and g_cs if xml lib goes away
    {
        // Issue: we want to call this from PROCESSDETACH to 
        //         clean up library. So we don't call FreeLibrary here.
        // FreeLibrary(g_hMlang);
        g_hMlang = 0;
        g_pfnGetGlobalFontLinkObject = NULL;
    }
    Assert(g_pfnGetGlobalFontLinkObject == NULL);

    // don't free this lib!  people call us from process detach
    //FreeLibrary(g_lib_hOle32);
}

//+---------------------------------------------------------------------------
//
// TFUninitLib_Thread
//
//----------------------------------------------------------------------------

void TFUninitLib_Thread(LIBTHREAD *plt)
{
    if (plt == NULL )  
        return;

    if (plt->_pcat)
        plt->_pcat->Release();
    plt->_pcat = NULL;

    if (plt->_pDAM)
        plt->_pDAM->Release();
    plt->_pDAM = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\ico.cpp ===
//
// ico.cpp
//

#include "private.h"
#include "ico.h"
#include "helpers.h"

//////////////////////////////////////////////////////////////////////////////
//
// CInputContextOwner
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CInputContextOwner::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfContextOwner))
    {
        *ppvObj = SAFECAST(this, CInputContextOwner *);
    }
    else if (IsEqualIID(riid, IID_ITfMouseTrackerACP))
    {
        *ppvObj = SAFECAST(this, ITfMouseTrackerACP *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CInputContextOwner::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CInputContextOwner::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CInputContextOwner::CInputContextOwner(ICOCALLBACK pfnCallback, void *pv)
{
    Dbg_MemSetThisName(TEXT("CInputContextOwner"));

    _cRef = 1;
    _dwCookie = ICO_INVALID_COOKIE;

    _pfnCallback = pfnCallback;
    _pv = pv;
}

//+---------------------------------------------------------------------------
//
// CInputContextOwner::PointToACP
//
//----------------------------------------------------------------------------

STDAPI CInputContextOwner::GetACPFromPoint(const POINT *pt, DWORD dwFlags, LONG *pacp)
{
    ICOARGS args;

    args.pta.pt = pt;
    args.pta.dwFlags = dwFlags;
    args.pta.pacp = pacp;

    return _pfnCallback(ICO_POINT_TO_ACP, &args, _pv);
}

//+---------------------------------------------------------------------------
//
// CInputContextOwner::GetScreenExt
//
//----------------------------------------------------------------------------

STDAPI CInputContextOwner::GetScreenExt(RECT *prc)
{
    ICOARGS args;

    args.scr_ext.prc = prc;

    return _pfnCallback(ICO_SCREENEXT, &args, _pv);
}

//+---------------------------------------------------------------------------
//
// CInputContextOwner::GetStatus
//
//----------------------------------------------------------------------------

STDAPI CInputContextOwner::GetStatus(TF_STATUS *pdcs)
{
    ICOARGS args;

    args.status.pdcs = pdcs;

    return _pfnCallback(ICO_STATUS, &args, _pv);
}

//+---------------------------------------------------------------------------
//
// CInputContextOwner::GetTextExt
//
//----------------------------------------------------------------------------

STDAPI CInputContextOwner::GetTextExt(LONG acpStart, LONG acpEnd, RECT *prc, BOOL *pfClipped)
{
    ICOARGS args;

    args.text_ext.acpStart = acpStart;
    args.text_ext.acpEnd = acpEnd;
    args.text_ext.prc = prc;
    args.text_ext.pfClipped = pfClipped;

    return _pfnCallback(ICO_TEXTEXT, &args, _pv);
}

//+---------------------------------------------------------------------------
//
// CInputContextOwner::GetWnd
//
//----------------------------------------------------------------------------

STDAPI CInputContextOwner::GetWnd(HWND *phwnd)
{
    ICOARGS args;

    args.hwnd.phwnd = phwnd;

    return _pfnCallback(ICO_WND, &args, _pv);
}

//+---------------------------------------------------------------------------
//
// CInputContextOwner::GetAttribute
//
//----------------------------------------------------------------------------

STDAPI CInputContextOwner::GetAttribute(REFGUID rguidAttribute, VARIANT *pvarValue)
{
    ICOARGS args;

    QuickVariantInit(pvarValue); // in case _pfnCallback ignores it

    args.sys_attr.pguid = &rguidAttribute;
    args.sys_attr.pvar = pvarValue;

    return _pfnCallback(ICO_ATTR, &args, _pv);
}

//+---------------------------------------------------------------------------
//
// CInputContextOwner::AdviseMouseSink
//
//----------------------------------------------------------------------------

STDAPI CInputContextOwner::AdviseMouseSink(ITfRangeACP *rangeACP, ITfMouseSink *pSink, DWORD *pdwCookie)
{
    ICOARGS args;

    args.advise_mouse.rangeACP = rangeACP;
    args.advise_mouse.pSink = pSink;
    args.advise_mouse.pdwCookie = pdwCookie;

    return _pfnCallback(ICO_ADVISEMOUSE, &args, _pv);
}

//+---------------------------------------------------------------------------
//
// CInputContextOwner::UnadviseMouseSink
//
//----------------------------------------------------------------------------

STDAPI CInputContextOwner::UnadviseMouseSink(DWORD dwCookie)
{
    ICOARGS args;

    args.unadvise_mouse.dwCookie = dwCookie;

    return _pfnCallback(ICO_UNADVISEMOUSE, &args, _pv);
}

//+---------------------------------------------------------------------------
//
// CInputContextOwner::_Advise
//
//----------------------------------------------------------------------------

HRESULT CInputContextOwner::_Advise(ITfContext *pic)
{
    HRESULT hr;
    ITfSource *source = NULL;

    _pic = NULL;
    hr = E_FAIL;

    if (FAILED(pic->QueryInterface(IID_ITfSource, (void **)&source)))
        goto Exit;

    if (FAILED(source->AdviseSink(IID_ITfContextOwner, SAFECAST(this, ITfContextOwner *), &_dwCookie)))
        goto Exit;

    _pic = pic;
    _pic->AddRef();

    hr = S_OK;

Exit:
    SafeRelease(source);
    return hr;
}

//+---------------------------------------------------------------------------
//
// CInputContextOwner::_Unadvise
//
//----------------------------------------------------------------------------

HRESULT CInputContextOwner::_Unadvise()
{
    HRESULT hr;
    ITfSource *source = NULL;

    hr = E_FAIL;

    if (_pic == NULL)
        goto Exit;

    if (FAILED(_pic->QueryInterface(IID_ITfSource, (void **)&source)))
        goto Exit;

    if (FAILED(source->UnadviseSink(_dwCookie)))
        goto Exit;

    hr = S_OK;

Exit:
    SafeRelease(source);
    SafeReleaseClear(_pic);
    return hr;
}


////////////////////////////////////////////////////////////////////////////////
//
// CInputContextKeyEventSink
//
////////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CInputContextKeyEventSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfContextKeyEventSink))
    {
        *ppvObj = SAFECAST(this, CInputContextKeyEventSink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CInputContextKeyEventSink::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CInputContextKeyEventSink::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CInputContextKeyEventSink::CInputContextKeyEventSink(ICOCALLBACK pfnCallback, void *pv)
{
    Dbg_MemSetThisName(TEXT("CInputContextKeyEventSink"));

    _cRef = 1;
    _dwCookie = ICO_INVALID_COOKIE;

    _pfnCallback = pfnCallback;
    _pv = pv;
}

//+---------------------------------------------------------------------------
//
// CInputContextKeyEventSink::Advise
//
//----------------------------------------------------------------------------

HRESULT CInputContextKeyEventSink::_Advise(ITfContext *pic)
{
    HRESULT hr;
    ITfSource *source = NULL;

    _pic = NULL;
    hr = E_FAIL;

    if (FAILED(pic->QueryInterface(IID_ITfSource, (void **)&source)))
        goto Exit;

    if (FAILED(source->AdviseSink(IID_ITfContextKeyEventSink, this, &_dwCookie)))
        goto Exit;

    _pic = pic;
    _pic->AddRef();

    hr = S_OK;

Exit:
    SafeRelease(source);
    return hr;
}

//+---------------------------------------------------------------------------
//
// CInputContextOwner::Unadvise
//
//----------------------------------------------------------------------------

HRESULT CInputContextKeyEventSink::_Unadvise()
{
    HRESULT hr;
    ITfSource *source = NULL;

    hr = E_FAIL;

    if (_pic == NULL)
        goto Exit;

    if (FAILED(_pic->QueryInterface(IID_ITfSource, (void **)&source)))
        goto Exit;

    if (FAILED(source->UnadviseSink(_dwCookie)))
        goto Exit;

    hr = S_OK;

Exit:
    SafeRelease(source);
    SafeReleaseClear(_pic);
    return hr;
}

//+---------------------------------------------------------------------------
//
// KeyDown
//
//----------------------------------------------------------------------------

STDAPI CInputContextKeyEventSink::OnKeyDown(WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    ICOARGS args;

    args.key.wParam = wParam;
    args.key.lParam = lParam;
    args.key.pic = _pic;
    args.key.pfEaten = pfEaten;

    return _pfnCallback(ICO_KEYDOWN, &args, _pv);
}

//+---------------------------------------------------------------------------
//
// OnKeyUp
//
//----------------------------------------------------------------------------

STDAPI CInputContextKeyEventSink::OnKeyUp(WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    ICOARGS args;

    args.key.wParam = wParam;
    args.key.lParam = lParam;
    args.key.pic = _pic;
    args.key.pfEaten = pfEaten;

    return _pfnCallback(ICO_KEYUP, &args, _pv);
}

//+---------------------------------------------------------------------------
//
// KeyTestDown
//
//----------------------------------------------------------------------------

STDAPI CInputContextKeyEventSink::OnTestKeyDown(WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    ICOARGS args;

    args.key.wParam = wParam;
    args.key.lParam = lParam;
    args.key.pic = _pic;
    args.key.pfEaten = pfEaten;

    return _pfnCallback(ICO_TESTKEYDOWN, &args, _pv);
}

//+---------------------------------------------------------------------------
//
// OnTestKeyUp
//
//----------------------------------------------------------------------------

STDAPI CInputContextKeyEventSink::OnTestKeyUp(WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    ICOARGS args;

    args.key.wParam = wParam;
    args.key.lParam = lParam;
    args.key.pic = _pic;
    args.key.pfEaten = pfEaten;

    return _pfnCallback(ICO_TESTKEYUP, &args, _pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\lbmenu.cpp ===
//
// lbmenu.cpp
//

#include "private.h"
#include "lbmenu.h"
#include "xstring.h"
#include "helpers.h"

//////////////////////////////////////////////////////////////////////////////
//
// CCicLibMenuItem
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CCicLibMenuItem::~CCicLibMenuItem()
{
    if (_pSubMenu)
        _pSubMenu->Release();

    if (_hbmp)
    {
        DeleteObject(_hbmp);
        _hbmp = NULL;
    }

    if (_hbmpMask)
    {
        DeleteObject(_hbmpMask);
        _hbmpMask = NULL;
    }

    SysFreeString(_bstr);
}

//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

BOOL CCicLibMenuItem::Init(UINT uId, DWORD dwFlags, HBITMAP hbmp, HBITMAP hbmpMask, const WCHAR *pch, ULONG cch, CCicLibMenu *pSubMenu)
{
    _uId = uId;
    _dwFlags = dwFlags;
    _bstr = SysAllocStringLen(pch, cch);

    if (!_bstr && cch)
        return FALSE;

    _pSubMenu = pSubMenu;

    _hbmp = CreateBitmap(hbmp);
    _hbmpMask = CreateBitmap(hbmpMask);

    if (hbmp)
        DeleteObject(hbmp);

    if (hbmpMask)
        DeleteObject(hbmpMask);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// CreateBitmap
//
//----------------------------------------------------------------------------

HBITMAP CCicLibMenuItem::CreateBitmap(HBITMAP hbmp)
{
    if (!hbmp)
        return NULL;

    HDC hdcTmp = CreateDC("DISPLAY", NULL, NULL, NULL);
    if (!hdcTmp)
        return NULL;

    HBITMAP hbmpOut = NULL;

    BITMAP bmp;
    GetObject(hbmp, sizeof(bmp), &bmp);

    HBITMAP hbmpOldSrc = NULL;
    HDC hdcSrc = CreateCompatibleDC(hdcTmp);
    if (hdcSrc)
    {
        hbmpOldSrc = (HBITMAP)SelectObject(hdcSrc, hbmp);
    }

    HBITMAP hbmpOldDst = NULL;
    HDC hdcDst = CreateCompatibleDC(hdcTmp);
    if (hdcDst)
    {
        hbmpOut = CreateCompatibleBitmap(hdcTmp , bmp.bmWidth, bmp.bmHeight);
        hbmpOldDst = (HBITMAP)SelectObject(hdcDst, hbmpOut);
    }

    BitBlt(hdcDst, 0, 0, bmp.bmWidth, bmp.bmHeight, hdcSrc, 0, 0, SRCCOPY);

    if (hbmpOldSrc)
        SelectObject(hdcSrc, hbmpOldSrc);

    if (hbmpOldDst)
        SelectObject(hdcDst, hbmpOldDst);

    DeleteDC(hdcTmp);

    if (hdcSrc)
        DeleteDC(hdcSrc);

    if (hdcDst)
        DeleteDC(hdcDst);

    return hbmpOut;
}

//////////////////////////////////////////////////////////////////////////////
//
// CCicLibMenu
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CCicLibMenu::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfMenu))
    {
        *ppvObj = SAFECAST(this, ITfMenu *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CCicLibMenu::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CCicLibMenu::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CCicLibMenu::CCicLibMenu()
{
    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CCicLibMenu::~CCicLibMenu()
{
    int i;

    for (i = 0; i < _rgItem.Count(); i++)
    {
        CCicLibMenuItem *pItem = _rgItem.Get(i);
        delete pItem;
    }
}

//+---------------------------------------------------------------------------
//
// AddMenuItem
//
//----------------------------------------------------------------------------

STDAPI CCicLibMenu::AddMenuItem(UINT uId, DWORD dwFlags, HBITMAP hbmp, HBITMAP hbmpMask, const WCHAR *pch, ULONG cch, ITfMenu **ppMenu)
{
    CCicLibMenuItem *pMenuItem;
    CCicLibMenu *pSubMenu = NULL;

    if (ppMenu)
        *ppMenu = NULL;

    if (dwFlags & TF_LBMENUF_SUBMENU)
    {
        if (!ppMenu)
            return E_INVALIDARG;

        pSubMenu = CreateSubMenu();
    }

    pMenuItem = CreateMenuItem();
    if (!pMenuItem)
        return E_OUTOFMEMORY;

    if (!pMenuItem->Init(uId, dwFlags, hbmp, hbmpMask, pch, cch, pSubMenu))
        return E_FAIL;

    if (ppMenu && pSubMenu)
    {
        *ppMenu = pSubMenu;
        (*ppMenu)->AddRef();
    }

    CCicLibMenuItem **ppItem = _rgItem.Append(1);
    *ppItem = pMenuItem;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\kes.cpp ===
//
// kes.cpp
//

#include "private.h"
#include "helpers.h"
#include "kes.h"

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CKeyEventSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfKeyEventSink))
    {
        *ppvObj = this;
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CKeyEventSink::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CKeyEventSink::Release()
{
    _cRef--;
    Assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
        return 0;
    }

    return _cRef;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CKeyEventSink::CKeyEventSink(KESCALLBACK pfnCallback, void *pv)
{
    Dbg_MemSetThisName(TEXT("CKeyEventSink"));

    _pfnPreKeyCallback = NULL;
    _pfnCallback = pfnCallback;
    _pv = pv;
    _cRef = 1;
}

CKeyEventSink::CKeyEventSink(KESCALLBACK pfnCallback, KESPREKEYCALLBACK pfnPreKeyCallback, void *pv)
{
    Dbg_MemSetThisName(TEXT("CKeyEventSink"));

    _pfnCallback = pfnCallback;
    _pfnPreKeyCallback = pfnPreKeyCallback;
    _pv = pv;
    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CKeyEventSink::~CKeyEventSink()
{
}

//+---------------------------------------------------------------------------
//
// OnTestKeyDown
//
//----------------------------------------------------------------------------

STDAPI CKeyEventSink::OnTestKeyDown(ITfContext *pic, WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    return _pfnCallback(KES_CODE_KEYDOWN | KES_CODE_TEST, pic, wParam, lParam, pfEaten, _pv);
}

//+---------------------------------------------------------------------------
//
// OnKeyDown
//
//----------------------------------------------------------------------------

STDAPI CKeyEventSink::OnKeyDown(ITfContext *pic, WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    return _pfnCallback(KES_CODE_KEYDOWN, pic, wParam, lParam, pfEaten, _pv);
}

//+---------------------------------------------------------------------------
//
// OnTestKeyUp
//
//----------------------------------------------------------------------------

STDAPI CKeyEventSink::OnTestKeyUp(ITfContext *pic, WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    return _pfnCallback(KES_CODE_KEYUP | KES_CODE_TEST, pic, wParam, lParam, pfEaten, _pv);
}

//+---------------------------------------------------------------------------
//
// OnKeyUp
//
//----------------------------------------------------------------------------

STDAPI CKeyEventSink::OnKeyUp(ITfContext *pic, WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    return _pfnCallback(KES_CODE_KEYUP, pic, wParam, lParam, pfEaten, _pv);
}

//+---------------------------------------------------------------------------
//
// SetFocus
//
//----------------------------------------------------------------------------

STDAPI CKeyEventSink::OnSetFocus(BOOL fForeground)
{
    return _pfnCallback(KES_CODE_FOCUS, NULL, fForeground, 0, NULL, _pv);
}

//+---------------------------------------------------------------------------
//
// OnPreservedKey
//
//----------------------------------------------------------------------------

STDAPI CKeyEventSink::OnPreservedKey(ITfContext *pic, REFGUID rguid, BOOL *pfEaten)
{
    if (!_pfnPreKeyCallback)
         return E_NOTIMPL;

    return _pfnPreKeyCallback(pic, rguid, pfEaten, _pv);
}

//+---------------------------------------------------------------------------
//
// Register
//
//----------------------------------------------------------------------------

HRESULT CKeyEventSink::_Register(ITfThreadMgr *ptim, TfClientId tid, const KESPRESERVEDKEY *pprekey)
{
    HRESULT hr;
    ITfKeystrokeMgr *pKeyMgr;

    Assert(_pfnPreKeyCallback);

    if (FAILED(ptim->QueryInterface(IID_ITfKeystrokeMgr, (void **)&pKeyMgr)))
        return E_FAIL;

    hr = E_FAIL;

    while (pprekey->pguid)
    {
        if (FAILED(pKeyMgr->PreserveKey(tid, 
                                        *pprekey->pguid,
                                        &pprekey->tfpk,
                                        pprekey->psz,
                                        wcslen(pprekey->psz))))
            goto Exit;

        pprekey++;
    }

    ptim->AddRef();

    hr = S_OK;

Exit:
    SafeRelease(pKeyMgr);
    return hr;
}

//+---------------------------------------------------------------------------
//
// CKeyEventSink::Unadvise
//
//----------------------------------------------------------------------------

HRESULT CKeyEventSink::_Unregister(ITfThreadMgr *ptim, TfClientId tid, const KESPRESERVEDKEY *pprekey)
{
    HRESULT hr;
    ITfKeystrokeMgr *pKeyMgr = NULL;

    hr = E_FAIL;

    Assert(_pfnPreKeyCallback);

    if (FAILED(ptim->QueryInterface(IID_ITfKeystrokeMgr, (void **)&pKeyMgr)))
        goto Exit;

    while (pprekey->pguid)
    {
        if (FAILED(pKeyMgr->UnpreserveKey(*pprekey->pguid, &pprekey->tfpk)))
            goto Exit;

        pprekey++;
    }

    hr = S_OK;
    SafeRelease(ptim);

Exit:
    SafeRelease(pKeyMgr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\lpns.cpp ===
//
// lpns.cpp
//

#include "private.h"
#include "lpns.h"
#include "helpers.h"

//////////////////////////////////////////////////////////////////////////////
//
// CLanguageProfileNotifySink
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CLanguageProfileNotifySink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfLanguageProfileNotifySink))
    {
        *ppvObj = SAFECAST(this, CLanguageProfileNotifySink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CLanguageProfileNotifySink::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CLanguageProfileNotifySink::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLanguageProfileNotifySink::CLanguageProfileNotifySink(LPNSCALLBACK pfn, void *pv)
{
    Dbg_MemSetThisName(TEXT("CLanguageProfileNotifySink"));

    _cRef = 1;
    _dwCookie = LPNS_INVALID_COOKIE;
 
    _pfn = pfn;
    _pv = pv;
}

//+---------------------------------------------------------------------------
//
// OnLanguageChange
//
//----------------------------------------------------------------------------

STDAPI CLanguageProfileNotifySink::OnLanguageChange(LANGID langid, BOOL *pfAccept)
{
    return _pfn ? _pfn(FALSE, langid, pfAccept, _pv) : S_OK;
}


//+---------------------------------------------------------------------------
//
// OnLanguageChanged
//
//----------------------------------------------------------------------------

STDAPI CLanguageProfileNotifySink::OnLanguageChanged()
{
    return _pfn ? _pfn(TRUE, 0, NULL, _pv) : S_OK;
}

//+---------------------------------------------------------------------------
//
// CLanguageProfileNotifySink::Advise
//
//----------------------------------------------------------------------------

HRESULT CLanguageProfileNotifySink::_Advise(ITfInputProcessorProfiles *pipp)
{
    HRESULT hr;
    ITfSource *source = NULL;

    _pipp = NULL;
    hr = E_FAIL;

    if (FAILED(pipp->QueryInterface(IID_ITfSource, (void **)&source)))
        goto Exit;

    if (FAILED(source->AdviseSink(IID_ITfLanguageProfileNotifySink, this, &_dwCookie)))
        goto Exit;

    _pipp = pipp;
    _pipp->AddRef();

    hr = S_OK;

Exit:
    SafeRelease(source);
    return hr;
}

//+---------------------------------------------------------------------------
//
// CLanguageProfileNotifySink::Unadvise
//
//----------------------------------------------------------------------------

HRESULT CLanguageProfileNotifySink::_Unadvise()
{
    HRESULT hr;
    ITfSource *source = NULL;

    hr = E_FAIL;

    if (_pipp == NULL)
        goto Exit;

    if (FAILED(_pipp->QueryInterface(IID_ITfSource, (void **)&source)))
        goto Exit;

    if (FAILED(source->UnadviseSink(_dwCookie)))
        goto Exit;

    hr = S_OK;

Exit:
    SafeRelease(source);
    SafeReleaseClear(_pipp);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\mes.cpp ===
//
// mes.cpp
//

#include "private.h"
#include "mes.h"

//////////////////////////////////////////////////////////////////////////////
//
// CMouseSink
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CMouseSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfMouseSink))
    {
        *ppvObj = SAFECAST(this, CMouseSink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CMouseSink::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CMouseSink::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CMouseSink::CMouseSink(MOUSECALLBACK pfnCallback, void *pv)
{
    Dbg_MemSetThisName(TEXT("CMouseSink"));

    _cRef = 1;
    _pfnCallback = pfnCallback;
    _pv = pv;
    Assert(_pic == NULL);
}

//+---------------------------------------------------------------------------
//
// OnMouseEvent
//
//----------------------------------------------------------------------------

STDAPI CMouseSink::OnMouseEvent(ULONG uEdge, ULONG uQuadrant, DWORD dwBtnStatus, BOOL *pfEaten)
{
    return _pfnCallback(uEdge, uQuadrant, dwBtnStatus, pfEaten, _pv);
}

//+---------------------------------------------------------------------------
//
// CMouseSink::Advise
//
//----------------------------------------------------------------------------

HRESULT CMouseSink::_Advise(ITfRange *range, ITfContext *pic)
{
    HRESULT hr;
    ITfMouseTracker *tracker = NULL;

    Assert(_pic == NULL);
    hr = E_FAIL;

    if (FAILED(pic->QueryInterface(IID_ITfMouseTracker, (void **)&tracker)))
        goto Exit;

    if (FAILED(tracker->AdviseMouseSink(range, this, &_dwCookie)))
        goto Exit;

    _pic = pic;
    _pic->AddRef();

    hr = S_OK;

Exit:
    SafeRelease(tracker);
    return hr;
}

//+---------------------------------------------------------------------------
//
// CMouseSink::Unadvise
//
//----------------------------------------------------------------------------

HRESULT CMouseSink::_Unadvise()
{
    HRESULT hr;
    ITfMouseTracker *tracker = NULL;

    hr = E_FAIL;

    if (_pic == NULL)
        goto Exit;

    if (FAILED(_pic->QueryInterface(IID_ITfMouseTracker, (void **)&tracker)))
        goto Exit;

    if (FAILED(tracker->UnadviseMouseSink(_dwCookie)))
        goto Exit;

    hr = S_OK;

Exit:
    SafeRelease(tracker);
    SafeReleaseClear(_pic);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\nuibase.cpp ===
//
// nuibase.cpp
//

#include "private.h"
#include "nuibase.h"
#include "helpers.h"

#define NUIBASE_ITEMSINK_COOKIE 0x80000001

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemBase
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemBase::CLBarItemBase()
{


    _dwStatus = 0;
    _szToolTip[0] = L'\0';

    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemBase::~CLBarItemBase()
{
    SafeRelease(_plbiSink);
}

//+---------------------------------------------------------------------------
//
// InitNuiInfo
//
//----------------------------------------------------------------------------

void CLBarItemBase::InitNuiInfo(REFCLSID rclsid, 
                                REFGUID rguid, 
                                DWORD dwStyle, 
                                ULONG ulSort, 
                                WCHAR *pszDesc)
{
    // init nuiInfo.
    _lbiInfo.clsidService = rclsid;
    _lbiInfo.guidItem = rguid;
    _lbiInfo.dwStyle = dwStyle;
    _lbiInfo.ulSort = ulSort;
    wcsncpy(_lbiInfo.szDescription, pszDesc, ARRAYSIZE(_lbiInfo.szDescription));
}

//+---------------------------------------------------------------------------
//
// GetType
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBase::GetInfo(TF_LANGBARITEMINFO *pInfo)
{
    *pInfo = _lbiInfo;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetStatus
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBase::GetStatus(DWORD *pdw)
{
    *pdw = _dwStatus;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBase::Show(BOOL fShow)
{
    return ShowInternal(fShow, TRUE);
}

//+---------------------------------------------------------------------------
//
// GetTooltipString
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBase::GetTooltipString(BSTR *pbstrToolTip)
{
    if (!pbstrToolTip)
        return E_INVALIDARG;

    *pbstrToolTip = SysAllocString(_szToolTip);

    if (*pbstrToolTip)
        return S_OK;
    else
        return E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

HRESULT CLBarItemBase::AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie)
{
    HRESULT hr;

    if (IsEqualIID(IID_ITfLangBarItemSink, riid))
    {
        if (_plbiSink)
            hr = CONNECT_E_CANNOTCONNECT;
        else
        {
            hr = punk->QueryInterface(IID_ITfLangBarItemSink, (void **)&_plbiSink);
            if (SUCCEEDED(hr))
            {
                *pdwCookie = NUIBASE_ITEMSINK_COOKIE;
            }
        }
    }
    else
    {
        hr = CONNECT_E_CANNOTCONNECT;
    }
    
    return hr;
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

HRESULT CLBarItemBase::UnadviseSink(DWORD dwCookie)
{
    if (NUIBASE_ITEMSINK_COOKIE  != dwCookie)
        return E_FAIL;

    if (!_plbiSink)
        return E_UNEXPECTED;

    _plbiSink->Release();
    _plbiSink = NULL;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

HRESULT CLBarItemBase::ShowInternal(BOOL fShow, BOOL fNotify)
{
    DWORD dwOldStatus = _dwStatus;

    if (fShow)
        _dwStatus &= ~TF_LBI_STATUS_HIDDEN;
    else
        _dwStatus |= TF_LBI_STATUS_HIDDEN;

    if (fNotify && (dwOldStatus != _dwStatus) && _plbiSink)
         _plbiSink->OnUpdate(TF_LBI_STATUS);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT CLBarItemBase::OnLButtonUp(const POINT pt, const RECT *prcArea)
{
   return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// OnRButtonUp
//
//----------------------------------------------------------------------------

HRESULT CLBarItemBase::OnRButtonUp(const POINT pt, const RECT *prcArea)
{
   return E_NOTIMPL;
}


//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemButtonBase
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CLBarItemButtonBase::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfLangBarItem))
    {
        *ppvObj = SAFECAST(this, ITfLangBarItem *);
    }
    else if (IsEqualIID(riid, IID_ITfLangBarItemButton))
    {
        *ppvObj = SAFECAST(this, ITfLangBarItemButton *);
    }
    else if (IsEqualIID(riid, IID_ITfSource))
    {
        *ppvObj = SAFECAST(this, ITfSource *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CLBarItemButtonBase::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CLBarItemButtonBase::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemButtonBase::CLBarItemButtonBase()
{
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemButtonBase::~CLBarItemButtonBase()
{
    if (_hIcon)
    {
        DestroyIcon(_hIcon);
        _hIcon = NULL;
    }
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

STDAPI CLBarItemButtonBase::AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie)
{
    return CLBarItemBase::AdviseSink(riid, punk, pdwCookie);
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

STDAPI CLBarItemButtonBase::UnadviseSink(DWORD dwCookie)
{
    return CLBarItemBase::UnadviseSink(dwCookie);
}

//+---------------------------------------------------------------------------
//
// GetInfo
//
//----------------------------------------------------------------------------

STDAPI CLBarItemButtonBase::GetInfo(TF_LANGBARITEMINFO *pInfo)
{
    return CLBarItemBase::GetInfo(pInfo);
}

//+---------------------------------------------------------------------------
//
// GetStatus
//
//----------------------------------------------------------------------------

STDAPI CLBarItemButtonBase::GetStatus(DWORD *pdw)
{
    return CLBarItemBase::GetStatus(pdw);
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

STDAPI CLBarItemButtonBase::Show(BOOL fShow)
{
    return CLBarItemBase::Show(fShow);
}

//+---------------------------------------------------------------------------
//
// GetTooltipString
//
//----------------------------------------------------------------------------

STDAPI CLBarItemButtonBase::GetTooltipString(BSTR *pbstrToolTip)
{
    return CLBarItemBase::GetTooltipString(pbstrToolTip);
}

//+---------------------------------------------------------------------------
//
// OnClick
//
//----------------------------------------------------------------------------

STDAPI CLBarItemButtonBase::OnClick(TfLBIClick click, POINT pt, const RECT *prcArea)
{
    switch (click)
    {
        case TF_LBI_CLK_RIGHT:
            return OnRButtonUp(pt, prcArea);
        case TF_LBI_CLK_LEFT:
            return OnLButtonUp(pt, prcArea);
    }
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// InitMenu
//
//----------------------------------------------------------------------------

STDAPI CLBarItemButtonBase::InitMenu(ITfMenu *pMenu)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// OnMenuSelect
//
//----------------------------------------------------------------------------

STDAPI CLBarItemButtonBase::OnMenuSelect(UINT uID)
{
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemButtonBase::GetIcon(HICON *phIcon)
{
    if (_hIcon)
        *phIcon = CopyIcon(_hIcon);
    else
        *phIcon = NULL;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetText
//
//----------------------------------------------------------------------------

STDAPI CLBarItemButtonBase::GetText(BSTR *pbstrText)
{
    if (!pbstrText)
        return E_INVALIDARG;

    *pbstrText = SysAllocString(_szText);

    if (*pbstrText)
        return S_OK;
    else
        return E_OUTOFMEMORY;
}


//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemBitmapButtonBase
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBitmapButtonBase::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfLangBarItem))
    {
        *ppvObj = SAFECAST(this, ITfLangBarItem *);
    }
    else if (IsEqualIID(riid, IID_ITfLangBarItemBitmapButton))
    {
        *ppvObj = SAFECAST(this, ITfLangBarItemBitmapButton *);
    }
    else if (IsEqualIID(riid, IID_ITfSource))
    {
        *ppvObj = SAFECAST(this, ITfSource *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CLBarItemBitmapButtonBase::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CLBarItemBitmapButtonBase::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemBitmapButtonBase::CLBarItemBitmapButtonBase()
{
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemBitmapButtonBase::~CLBarItemBitmapButtonBase()
{
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBitmapButtonBase::AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie)
{
    return CLBarItemBase::AdviseSink(riid, punk, pdwCookie);
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBitmapButtonBase::UnadviseSink(DWORD dwCookie)
{
    return CLBarItemBase::UnadviseSink(dwCookie);
}

//+---------------------------------------------------------------------------
//
// GetInfo
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBitmapButtonBase::GetInfo(TF_LANGBARITEMINFO *pInfo)
{
    return CLBarItemBase::GetInfo(pInfo);
}

//+---------------------------------------------------------------------------
//
// GetStatus
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBitmapButtonBase::GetStatus(DWORD *pdw)
{
    return CLBarItemBase::GetStatus(pdw);
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBitmapButtonBase::Show(BOOL fShow)
{
    return CLBarItemBase::Show(fShow);
}

//+---------------------------------------------------------------------------
//
// GetTooltipString
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBitmapButtonBase::GetTooltipString(BSTR *pbstrToolTip)
{
    return CLBarItemBase::GetTooltipString(pbstrToolTip);
}

//+---------------------------------------------------------------------------
//
// OnClick
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBitmapButtonBase::OnClick(TfLBIClick click, POINT pt, const RECT *prcArea)
{
    switch (click)
    {
        case TF_LBI_CLK_RIGHT:
            return OnRButtonUp(pt, prcArea);
        case TF_LBI_CLK_LEFT:
            return OnLButtonUp(pt, prcArea);
    }
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// InitMenu
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBitmapButtonBase::InitMenu(ITfMenu *pMenu)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// OnMenuSelect
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBitmapButtonBase::OnMenuSelect(UINT uID)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// GetPreferredSize
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBitmapButtonBase::GetPreferredSize(const SIZE *pszDefault, SIZE *psize)
{
    *psize = _sizePrefered;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetText
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBitmapButtonBase::GetText(BSTR *pbstrText)
{
    if (!pbstrText)
        return E_INVALIDARG;

    *pbstrText = SysAllocString(_szText);

    if (*pbstrText)
        return S_OK;
    else
        return E_OUTOFMEMORY;
}


//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemBitmapBase
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBitmapBase::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfLangBarItem))
    {
        *ppvObj = SAFECAST(this, ITfLangBarItem *);
    }
    else if (IsEqualIID(riid, IID_ITfLangBarItemBitmap))
    {
        *ppvObj = SAFECAST(this, ITfLangBarItemBitmap *);
    }
    else if (IsEqualIID(riid, IID_ITfSource))
    {
        *ppvObj = SAFECAST(this, ITfSource *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CLBarItemBitmapBase::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CLBarItemBitmapBase::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemBitmapBase::CLBarItemBitmapBase()
{
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemBitmapBase::~CLBarItemBitmapBase()
{
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBitmapBase::AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie)
{
    return CLBarItemBase::AdviseSink(riid, punk, pdwCookie);
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBitmapBase::UnadviseSink(DWORD dwCookie)
{
    return CLBarItemBase::UnadviseSink(dwCookie);
}

//+---------------------------------------------------------------------------
//
// GetInfo
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBitmapBase::GetInfo(TF_LANGBARITEMINFO *pInfo)
{
    return CLBarItemBase::GetInfo(pInfo);
}

//+---------------------------------------------------------------------------
//
// GetStatus
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBitmapBase::GetStatus(DWORD *pdw)
{
    return CLBarItemBase::GetStatus(pdw);
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBitmapBase::Show(BOOL fShow)
{
    return CLBarItemBase::Show(fShow);
}

//+---------------------------------------------------------------------------
//
// GetTooltipString
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBitmapBase::GetTooltipString(BSTR *pbstrToolTip)
{
    return CLBarItemBase::GetTooltipString(pbstrToolTip);
}


//+---------------------------------------------------------------------------
//
// OnClick
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBitmapBase::OnClick(TfLBIClick click, POINT pt, const RECT *prcArea)
{
    switch (click)
    {
        case TF_LBI_CLK_RIGHT:
            return OnRButtonUp(pt, prcArea);
        case TF_LBI_CLK_LEFT:
            return OnLButtonUp(pt, prcArea);
    }
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
// GetPreferredSize
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBitmapBase::GetPreferredSize(const SIZE *pszDefault, SIZE *psize)
{
    *psize = _sizePrefered;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemBalloonBase
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBalloonBase::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfLangBarItem))
    {
        *ppvObj = SAFECAST(this, ITfLangBarItem *);
    }
    else if (IsEqualIID(riid, IID_ITfLangBarItemBalloon))
    {
        *ppvObj = SAFECAST(this, ITfLangBarItemBalloon *);
    }
    else if (IsEqualIID(riid, IID_ITfSource))
    {
        *ppvObj = SAFECAST(this, ITfSource *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CLBarItemBalloonBase::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CLBarItemBalloonBase::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemBalloonBase::CLBarItemBalloonBase()
{
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemBalloonBase::~CLBarItemBalloonBase()
{
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBalloonBase::AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie)
{
    return CLBarItemBase::AdviseSink(riid, punk, pdwCookie);
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBalloonBase::UnadviseSink(DWORD dwCookie)
{
    return CLBarItemBase::UnadviseSink(dwCookie);
}

//+---------------------------------------------------------------------------
//
// GetInfo
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBalloonBase::GetInfo(TF_LANGBARITEMINFO *pInfo)
{
    return CLBarItemBase::GetInfo(pInfo);
}

//+---------------------------------------------------------------------------
//
// GetStatus
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBalloonBase::GetStatus(DWORD *pdw)
{
    return CLBarItemBase::GetStatus(pdw);
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBalloonBase::Show(BOOL fShow)
{
    return CLBarItemBase::Show(fShow);
}

//+---------------------------------------------------------------------------
//
// GetTooltipString
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBalloonBase::GetTooltipString(BSTR *pbstrToolTip)
{
    return CLBarItemBase::GetTooltipString(pbstrToolTip);
}


//+---------------------------------------------------------------------------
//
// OnClick
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBalloonBase::OnClick(TfLBIClick click, POINT pt, const RECT *prcArea)
{
    switch (click)
    {
        case TF_LBI_CLK_RIGHT:
            return OnRButtonUp(pt, prcArea);
        case TF_LBI_CLK_LEFT:
            return OnLButtonUp(pt, prcArea);
    }
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
// GetPreferredSize
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBalloonBase::GetPreferredSize(const SIZE *pszDefault, SIZE *psize)
{
    *psize = _sizePrefered;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\plex.cpp ===
//
// plex.cpp
//
// CPlex
//

#include "private.h"
#include "template.h"

/////////////////////////////////////////////////////////////////////////////
// CPlex

CPlex* PASCAL
CPlex::Create(
    CPlex*& pHead,
    UINT nMax,
    UINT cbElement
    )
{
    ASSERT(nMax > 0 && cbElement > 0);

    CPlex* p = (CPlex*) new BYTE[sizeof(CPlex) + nMax * cbElement];
                    // may throw exception
    if ( p == NULL )
        return NULL;

    p->pNext = pHead;
    pHead = p;      // change head (adds in reverse order for simplicity)
    return p;
}

void
CPlex::FreeDataChain(
    )
{
    CPlex* p = this;
    while (p != NULL) {
        BYTE* bytes = (BYTE*) p;
        CPlex* pNext = p->pNext;
        delete[] bytes;
        p = pNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for dimm project.
//
//----------------------------------------------------------------------------

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#define _OLEAUT32_

#include <nt.h>    // for NtQuery
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <ole2.h>
#include <advpub.h>
#include <ccstock.h>
#include <debug.h>
#include <inetreg.h>
#include <ocidl.h>
#include <comcat.h>
#include <olectl.h>
#include <mlang.h>
#include <limits.h>
#ifndef STRSAFE_NO_DEPRECATE
#define STRSAFE_NO_DEPRECATE
#endif
#include <strsafe.h> 
#include "msctf.h"
#include "helpers.h"
#include "mem.h" // must be last
#include "chkobj.h"

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\pkes.cpp ===
//
// pkes.cpp
//

#include "private.h"
#include "pkes.h"
#include "helpers.h"

//////////////////////////////////////////////////////////////////////////////
//
// CPreservedKeyNotifySink
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CPreservedKeyNotifySink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfPreservedKeyNotifySink))
    {
        *ppvObj = SAFECAST(this, CPreservedKeyNotifySink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CPreservedKeyNotifySink::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CPreservedKeyNotifySink::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CPreservedKeyNotifySink::CPreservedKeyNotifySink(PKESCALLBACK pfnCallback, void *pv)
{
    Dbg_MemSetThisName(TEXT("CPreservedKeyNotifySink"));

    _cRef = 1;
    _dwCookie = (DWORD)PKES_INVALID_COOKIE;

    _pfnCallback = pfnCallback;
    _pv = pv;
}

//+---------------------------------------------------------------------------
//
// OnUpdated
//
//----------------------------------------------------------------------------

STDAPI CPreservedKeyNotifySink::OnUpdated(const TF_PRESERVEDKEY *pprekey)
{
    return _pfnCallback(pprekey, _pv);
}

//+---------------------------------------------------------------------------
//
// CPreservedKeyNotifySink::Advise
//
//----------------------------------------------------------------------------

HRESULT CPreservedKeyNotifySink::_Advise(ITfThreadMgr *ptim)
{
    HRESULT hr;
    ITfSource *source = NULL;

    _ptim = NULL;
    hr = E_FAIL;

    if (FAILED(ptim->QueryInterface(IID_ITfSource, (void **)&source)))
        goto Exit;

    if (FAILED(source->AdviseSink(IID_ITfPreservedKeyNotifySink, this, &_dwCookie)))
        goto Exit;

    _ptim = ptim;
    _ptim->AddRef();

    hr = S_OK;

Exit:
    SafeRelease(source);
    return hr;
}

//+---------------------------------------------------------------------------
//
// CPreservedKeyNotifySink::Unadvise
//
//----------------------------------------------------------------------------

HRESULT CPreservedKeyNotifySink::_Unadvise()
{
    HRESULT hr;
    ITfSource *source = NULL;

    hr = E_FAIL;

    if (_ptim == NULL)
        goto Exit;

    if (FAILED(_ptim->QueryInterface(IID_ITfSource, (void **)&source)))
        goto Exit;

    if (FAILED(source->UnadviseSink(_dwCookie)))
        goto Exit;

    hr = S_OK;

Exit:
    SafeRelease(source);
    SafeReleaseClear(_ptim);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\ptrary.cpp ===
//
// ptrary.cpp
//
// CPtrArray
//

#include "private.h"
#include "ptrary.h"
#include "mem.h"

//+---------------------------------------------------------------------------
//
// Insert(int iIndex, int cElems)
//
// Grows the array to accomodate cElems at offset iIndex.
//
// The new cells are NOT initialized!
//
//----------------------------------------------------------------------------

BOOL CVoidPtrArray::Insert(int iIndex, int cElems)
{
    void **ppv;
    int iSizeNew;

    Assert(iIndex >= 0);
    Assert(iIndex <= _cElems);
    Assert(cElems >= 0);

    if (cElems == 0)
        return TRUE;

    // allocate space if necessary
    if (_iSize < _cElems + cElems)
    {
        // allocate 1.5x what we need to avoid future allocs
        iSizeNew = max(_cElems + cElems, _cElems + _cElems / 2);

        if ((ppv = (_rgpv == NULL) ? (void **)cicMemAlloc(iSizeNew*sizeof(void *)) :
                                     (void **)cicMemReAlloc(_rgpv, iSizeNew*sizeof(void *)))
            == NULL)
        {
            return FALSE;
        }

        _rgpv = ppv;
        _iSize = iSizeNew;
    }

    if (iIndex < _cElems)
    {
        // make room for the new addition
        memmove(&_rgpv[iIndex + cElems], &_rgpv[iIndex], (_cElems - iIndex)*sizeof(void *));
    }

    _cElems += cElems;
    Assert(_iSize >= _cElems);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// Remove(int Index, int cElems)
//
// Removes cElems at offset iIndex.
//
//----------------------------------------------------------------------------

void CVoidPtrArray::Remove(int iIndex, int cElems)
{
    int iSizeNew;

    Assert(cElems > 0);
    Assert(iIndex >= 0);
    Assert(iIndex + cElems <= _cElems);

    if (iIndex + cElems < _cElems)
    {
        // shift following eles left
        memmove(&_rgpv[iIndex], &_rgpv[iIndex + cElems], (_cElems - iIndex - cElems)*sizeof(void *));
    }

    _cElems -= cElems;

    // free mem when array contents uses less than half alloc'd mem
    iSizeNew = _iSize / 2;
    if (iSizeNew > _cElems)
    {
        CompactSize(iSizeNew);
    }
}

//+---------------------------------------------------------------------------
//
// Move
//
// Move an entry from one position to another, shifting other entries as
// appropriate to maintain the array size.
//
// The entry currently at iIndexNew will follow the moved entry on return.
//
// Returns the new index, which will be iIndexNew or iIndexNew - 1 if
// iIndexOld < iIndexNew.
//----------------------------------------------------------------------------

int CVoidPtrArray::Move(int iIndexNew, int iIndexOld)
{
    int iSrc;
    int iDst;
    int iActualNew;
    void *pv;
    int c;

    Assert(iIndexOld >= 0);
    Assert(iIndexOld < _cElems);
    Assert(iIndexNew >= 0);

    if (iIndexOld == iIndexNew)
        return iIndexOld;

    pv = _rgpv[iIndexOld];
    if (iIndexOld < iIndexNew)
    {
        c = iIndexNew - iIndexOld - 1;
        iSrc = iIndexOld + 1;
        iDst = iIndexOld;
        iActualNew = iIndexNew - 1;
    }
    else
    {
        c = iIndexOld - iIndexNew;
        iSrc = iIndexOld - c;
        iDst = iIndexOld - c + 1;
        iActualNew = iIndexNew;
    }
    Assert(iActualNew >= 0);
    Assert(iActualNew < _cElems);

    memmove(&_rgpv[iDst], &_rgpv[iSrc], c*sizeof(void *));

    _rgpv[iActualNew] = pv;

    return iActualNew;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\regimx.cpp ===
//
// regimx.cpp
//

#include "private.h"
#include "regimx.h"
#include "xstring.h"
#include "catutil.h"
#include "msctfp.h"

//+---------------------------------------------------------------------------
//
// RegisterTIP
//
//----------------------------------------------------------------------------

BOOL RegisterTIP(HINSTANCE hInst, REFCLSID rclsid, WCHAR *pwszDesc, const REGTIPLANGPROFILE *plp)
{
    ITfInputProcessorProfiles *pReg = NULL;
    ITfInputProcessorProfilesEx *pRegEx = NULL;
    HRESULT hr;

    // register ourselves with the ActiveIMM
    hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, 
                          CLSCTX_INPROC_SERVER,
                          IID_ITfInputProcessorProfiles, (void**)&pReg);
    if (FAILED(hr))
        goto Exit;

    hr = pReg->Register(rclsid);

    if (FAILED(hr))
        goto Exit;

    pReg->QueryInterface(IID_ITfInputProcessorProfilesEx, (void**)&pRegEx);

    while (plp->langid)
    {
        WCHAR wszFilePath[MAX_PATH];
        WCHAR *pv = &wszFilePath[0];

        wszFilePath[0] = L'\0';

        if (wcslen(plp->szIconFile))
        {
            char szFilePath[MAX_PATH];
            WCHAR *pvCur;

            if (0 != 
                GetModuleFileName(hInst, szFilePath, ARRAYSIZE(szFilePath)))
            {
                StringCchCopyW(wszFilePath, ARRAYSIZE(wszFilePath), AtoW(szFilePath));
            }

            pv = pvCur = &wszFilePath[0];
            while (*pvCur)
            { 
                if (*pvCur == L'\\')
                    pv = pvCur + 1;
                pvCur++;
            }
            *pv = L'\0';
           
        }

        UINT uRemainFilePathLen = (ARRAYSIZE(wszFilePath) - (UINT)(pv - &wszFilePath[0] + 1));
        StringCchCopyW(pv, uRemainFilePathLen, plp->szIconFile);
        
        pReg->AddLanguageProfile(rclsid, 
                                 plp->langid, 
                                 *plp->pguidProfile, 
                                 plp->szProfile, 
                                 wcslen(plp->szProfile),
                                 wszFilePath,
                                 wcslen(wszFilePath),
                                 plp->uIconIndex);

        if (pRegEx && plp->uDisplayDescResIndex)
        {
            pRegEx->SetLanguageProfileDisplayName(rclsid, 
                                                  plp->langid, 
                                                  *plp->pguidProfile, 
                                                  wszFilePath,
                                                  wcslen(wszFilePath),
                                                  plp->uDisplayDescResIndex);
        }

        plp++;
    }

    RegisterGUIDDescription(rclsid, rclsid, pwszDesc);
Exit:
    SafeRelease(pReg);
    SafeRelease(pRegEx);
    return SUCCEEDED(hr);
}

//+---------------------------------------------------------------------------
//
// UnregisterTIP
//
//----------------------------------------------------------------------------

BOOL UnregisterTIP(REFCLSID rclsid)
{
    ITfInputProcessorProfiles *pReg;
    HRESULT hr;

    UnregisterGUIDDescription(rclsid, rclsid);

    hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, 
                          CLSCTX_INPROC_SERVER,
                          IID_ITfInputProcessorProfiles, (void**)&pReg);
    if (FAILED(hr))
        goto Exit;

    hr = pReg->Unregister(rclsid);
    pReg->Release();

Exit:

    return FAILED(hr) ? FALSE : TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\strary.cpp ===
//
// strary.cpp
//
// CStructArray
//

#include "private.h"
#include "strary.h"
#include "mem.h"

#define StrPB(x) (_pb + ((x) * _iElemSize))

//+---------------------------------------------------------------------------
//
// Insert(int iIndex, int cElems)
//
// Grows the array to accomodate cElems at offset iIndex.
//
// The new cells are NOT initialized!
//
//----------------------------------------------------------------------------

BOOL CVoidStructArray::Insert(int iIndex, int cElems)
{
    BYTE *pb;
    int iSizeNew;

    Assert(iIndex >= 0);
    Assert(iIndex <= _cElems);
    Assert(cElems > 0);

    // allocate space if necessary
    if (_iSize < _cElems + cElems)
    {
        // allocate 1.5x what we need to avoid future allocs
        iSizeNew = max(_cElems + cElems, _cElems + _cElems / 2);

        if ((pb = (_pb == NULL) ? 
                   (BYTE *)cicMemAlloc(iSizeNew*_iElemSize) :
                   (BYTE *)cicMemReAlloc(_pb, iSizeNew* _iElemSize))
            == NULL)
        {
            return FALSE;
        }

        _pb = pb;
        _iSize = iSizeNew;
    }

    if (iIndex < _cElems)
    {
        // make room for the new addition
        memmove(StrPB(iIndex + cElems), 
                StrPB(iIndex), 
                (_cElems - iIndex)*_iElemSize);
#ifdef DEBUG
        memset(StrPB(iIndex), 0xFE, cElems * _iElemSize);
#endif
    }

    _cElems += cElems;
    Assert(_iSize >= _cElems);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// Remove(int Index, int cElems)
//
// Removes cElems at offset iIndex.
//
//----------------------------------------------------------------------------

void CVoidStructArray::Remove(int iIndex, int cElems)
{
    BYTE *pb;
    int iSizeNew;

    Assert(cElems > 0);
    Assert(iIndex >= 0);
    Assert(iIndex + cElems <= _cElems);

    if (iIndex + cElems < _cElems)
    {
        // shift following eles left
        memmove(StrPB(iIndex), 
                StrPB(iIndex + cElems), 
                (_cElems - iIndex - cElems) * _iElemSize);
#ifdef DEBUG
        memset(StrPB(_cElems - cElems), 0xFE, cElems * _iElemSize);
#endif
    }

    _cElems -= cElems;

    // free mem when array contents uses less than half alloc'd mem
    iSizeNew = _iSize / 2;
    if (iSizeNew > _cElems)
    {
        if ((pb = (BYTE *)cicMemReAlloc(_pb, iSizeNew * _iElemSize)) != NULL)
        {
            _pb = pb;
            _iSize = iSizeNew;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\proputil.cpp ===
#include "private.h"
#include "proputil.h"
#include "immxutil.h"
#include "helpers.h"


//+---------------------------------------------------------------------------
//
// HrVariantToBlob
//
// cbvalue: on sizeof VARTYPE
//
//----------------------------------------------------------------------------

HRESULT HrVariantToBlob(VARIANT *pv, void *pvalue, ULONG *pcbvalue, VARTYPE vt)
{
    HRESULT hr = S_OK;
    SAFEARRAY *psa = NULL;
    void *pdata = NULL;
    int lb, ub;
    int iElemSize;
    ULONG cbvalue;

    while (V_VT(pv) == (VT_BYREF | VT_VARIANT))
        pv = V_VARIANTREF(pv);

    if (V_VT(pv) != (VT_ARRAY | vt)) 
        return E_FAIL;

    psa = V_ARRAY(pv);

    hr = SafeArrayLock(psa);
    if (FAILED(hr)) 
        goto Ret;

    hr = SafeArrayGetLBound(psa, 1, (LONG *)&lb);
    if (FAILED(hr)) 
        goto Ret;

    hr = SafeArrayGetUBound(psa, 1, (LONG *)&ub);
    if (FAILED(hr)) 
        goto Ret;

    iElemSize = SafeArrayGetElemsize(psa);
    cbvalue = ub - lb + 1;

    if (cbvalue * iElemSize > *pcbvalue)
    {
        hr = E_FAIL;
        goto Ret;
    }

    hr = SafeArrayAccessData(psa, (void **)&pdata);
    if (FAILED(hr)) 
        goto Ret;

    memcpy(pvalue, pdata, cbvalue * iElemSize);

    hr = SafeArrayUnaccessData(psa);
    if (FAILED(hr)) 
        goto Ret;

    *pcbvalue = cbvalue;

Ret:
    if (psa) SafeArrayUnlock(psa);
    return hr;
}

//+---------------------------------------------------------------------------
//
// HrBlobToVariant
//
// cbvalue: on sizeof VARTYPE
//
//----------------------------------------------------------------------------

HRESULT HrBlobToVariant(const void *value, ULONG cbvalue, VARIANT *pv, VARTYPE vt)
{
    HRESULT hr = S_OK;
    SAFEARRAY *psa = NULL;
    SAFEARRAYBOUND rsabound[1];
    void *pdata = NULL;
    int iElemSize;
    
    rsabound[0].lLbound = 0;
    rsabound[0].cElements = cbvalue;
    if (!(psa = SafeArrayCreate(vt, 1, rsabound)))
    {
        hr = E_OUTOFMEMORY;
        goto Ret;
    }

    iElemSize = SafeArrayGetElemsize(psa);

    hr = SafeArrayAccessData(psa, (void **)&pdata);
    if (FAILED(hr)) 
        goto Ret;

    memcpy(pdata, value, cbvalue * iElemSize);

    hr = SafeArrayUnaccessData(psa);
    if (FAILED(hr)) 
        goto Ret;

    V_VT(pv) = VT_ARRAY | vt;
    V_ARRAY(pv) = psa;
    psa = NULL;

Ret:
    if (psa) SafeArrayDestroy(psa);
    return hr;
}

//+---------------------------------------------------------------------------
//
// GetGUIDPropertyData
//
//----------------------------------------------------------------------------

HRESULT GetGUIDPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, TfGuidAtom *pguid)
{
    VARIANT var;
    HRESULT hr = E_FAIL;

    *pguid = TF_INVALID_GUIDATOM;

    if (SUCCEEDED(pProp->GetValue(ec, pRange, &var)))
    {
        if (var.vt == VT_I4)
            *pguid = (TfGuidAtom)var.lVal;

        // no need to VariantClear because VT_I4
        hr = S_OK;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// SetGUIDPropertyData
//
//----------------------------------------------------------------------------

HRESULT SetGUIDPropertyData(LIBTHREAD *plt, TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, REFGUID rguid)
{
    VARIANT var;
    GUID guid = rguid;

    var.vt = VT_I4;
    GetGUIDATOMFromGUID(plt, guid, (TfGuidAtom *)&var.lVal);

    return pProp->SetValue(ec, pRange, &var);
}

//+---------------------------------------------------------------------------
//
// VarToLangId
//
//----------------------------------------------------------------------------

WORD VarToWORD(VARIANT *pv)
{
    if (V_VT(pv) == VT_I2)
        return (WORD)V_I2(pv);

    return 0;
}

//+---------------------------------------------------------------------------
//
// SetLangToVar
//
//----------------------------------------------------------------------------

void SetWORDToVar(VARIANT *pv, WORD w)
{
    V_VT(pv) = VT_I2;
    V_I2(pv) = w;
}

//+---------------------------------------------------------------------------
//
// GetDWORDPropertyData
//
//----------------------------------------------------------------------------

HRESULT GetDWORDPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, DWORD *pdw)
{
    VARIANT var;
    HRESULT hr = E_FAIL;

    if (pProp->GetValue(ec, pRange, &var) == S_OK)
    {
        Assert(var.vt == VT_I4); // expecting DWORD
        *pdw = var.lVal;
        // no need to VariantClear because VT_I4
        hr = S_OK;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// SetDWORDPropertyData
//
//----------------------------------------------------------------------------

HRESULT SetDWORDPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, DWORD dw)
{
    VARIANT var;

    if (!dw)
    {
        return pProp->Clear(ec, pRange);
    }

    var.vt = VT_I4;
    var.lVal = dw;

    return pProp->SetValue(ec, pRange, &var);
}

//+---------------------------------------------------------------------------
//
// GetBSTRPropertyData
//
//----------------------------------------------------------------------------

HRESULT GetBSTRPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, BSTR *pbstr)
{
    VARIANT var = { 0 };
    HRESULT hr = E_FAIL;

    *pbstr = NULL;

    if (pProp->GetValue(ec, pRange, &var) != S_OK)
        return E_FAIL;

    if (var.vt != VT_BSTR)
        goto Exit;

    *pbstr = SysAllocString(var.bstrVal);

    if (*pbstr)
        hr = S_OK;
    else
        hr = E_OUTOFMEMORY;

Exit:
    VariantClear(&var);
    return hr;
}

//+---------------------------------------------------------------------------
//
// SetBSTRPropertyData
//
//----------------------------------------------------------------------------

HRESULT SetBSTRPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, BSTR bstr)
{
    VARIANT var;
    HRESULT hr;

    if (!bstr)
        return pProp->Clear(ec, pRange);

    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString(bstr);

    if (!var.bstrVal)
         return E_OUTOFMEMORY;

    hr = pProp->SetValue(ec, pRange, &var);

    VariantClear(&var);

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetUnknownPropertyData
//
//----------------------------------------------------------------------------

HRESULT GetUnknownPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, IUnknown **ppunk)
{
    VARIANT var = { 0 };

    *ppunk = NULL;

    if (pProp->GetValue(ec, pRange, &var) != S_OK)
        return E_FAIL;

    if (var.vt != VT_UNKNOWN)
        goto Exit;

    *ppunk = var.punkVal;
    (*ppunk)->AddRef();

Exit:
    VariantClear(&var);
    return (*ppunk == NULL) ? E_FAIL : S_OK;
}

//+---------------------------------------------------------------------------
//
// SetUnknownPropertyData
//
//----------------------------------------------------------------------------

HRESULT SetUnknownPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, IUnknown *punk)
{
    VARIANT var;

    if (!punk)
        return pProp->Clear(ec, pRange);

    var.vt = VT_UNKNOWN;
    var.punkVal = punk;

    return pProp->SetValue(ec, pRange, &var);
}

//+---------------------------------------------------------------------------
//
// GetReadingStrPropertyData
//
//----------------------------------------------------------------------------

HRESULT GetReadingStrPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, BSTR *pbstr)
{
    return GetBSTRPropertyData(ec, pProp, pRange, pbstr);
}


//+---------------------------------------------------------------------------
//
// SetIntAttribute
//
//----------------------------------------------------------------------------

void SetIntAttribute(IXMLDOMElement *pElem, WCHAR *pszTag, int nData)
{
    WCHAR wch[32];

    NumToW((DWORD)nData, wch);
    SetCharAttribute(pElem, pszTag, wch);
}

//+---------------------------------------------------------------------------
//
// SetCharAttribute
//
//----------------------------------------------------------------------------

void SetCharAttribute(IXMLDOMElement *pElem, WCHAR *pszTag, WCHAR *pszData)
{
    VARIANT var;
    BSTR bstrTmp = SysAllocString(pszTag);
    BSTR bstrTmp2;

    if (!bstrTmp)
        return;

    bstrTmp2 = SysAllocString(pszData);

    if (bstrTmp2)
    {
        V_VT(&var) = VT_BSTR;
        V_BSTR(&var) = bstrTmp2;

        pElem->setAttribute(bstrTmp, var);
    }

    VariantClear(&var);
    SysFreeString(bstrTmp);
}

//+---------------------------------------------------------------------------
//
// GetIntAttribute
//
//----------------------------------------------------------------------------

HRESULT GetIntAttribute(IXMLDOMElement *pElem, WCHAR *pszTag, int *pnRet)
{
    WCHAR wch[32];
    if (FAILED(GetCharAttribute(pElem, pszTag, wch, ARRAYSIZE(wch))))
        return E_FAIL;

    *pnRet = (int)WToNum(wch);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetCharAttribute
//
//----------------------------------------------------------------------------

HRESULT GetCharAttribute(IXMLDOMElement *pElem, WCHAR *pszTag, WCHAR *pszData, int nSize)
{
    BSTR bstrTmp;
    VARIANT var;
    int nData = 0;
    HRESULT hr = E_FAIL;

    *pszData = L'\0';
    QuickVariantInit(&var);
    bstrTmp = SysAllocString(pszTag);

    if (!bstrTmp)
        return E_OUTOFMEMORY;

    if (SUCCEEDED(pElem->getAttribute(bstrTmp, &var)))
    {
        if (V_VT(&var) == VT_BSTR)
        {
            if (wcsncpy(pszData, V_BSTR(&var), nSize))
                hr = S_OK;
        }
    }
    SysFreeString(bstrTmp);
    VariantClear(&var);

    return hr;
}

//+---------------------------------------------------------------------------
//
// SetTextAndProperty
//
//----------------------------------------------------------------------------

HRESULT SetTextAndProperty(LIBTHREAD *plt, TfEditCookie ec, ITfContext *pic, ITfRange *pRange, const WCHAR *pchText, LONG cchText, LANGID langid, const GUID *pattr)
{
    HRESULT hr;

    // Issue: sometimes we want to set TFST_CORRECTION
    hr = pRange->SetText(ec, 0, pchText, cchText);

    if (SUCCEEDED(hr) && cchText)
    {
        ITfProperty *pProp = NULL;

        // set langid 
        if (SUCCEEDED(hr = pic->GetProperty(GUID_PROP_LANGID, &pProp)))
        {
            SetLangIdPropertyData(ec, pProp, pRange, langid);
            pProp->Release();
        }
  
        if (pattr)
        {
            // set attr 
            if (SUCCEEDED(hr = pic->GetProperty(GUID_PROP_ATTRIBUTE, &pProp)))
            {
                hr = SetAttrPropertyData(plt, ec, pProp, pRange, *pattr);
                pProp->Release();
            }

        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// SetTextAndReading
//
//----------------------------------------------------------------------------

HRESULT SetTextAndReading(LIBTHREAD *plt, TfEditCookie ec, ITfContext *pic, ITfRange *pRange, const WCHAR *pchText, LONG cchText, LANGID langid, const WCHAR *pszRead)
{
    ITfProperty *pProp;
    HRESULT hr;

    hr = SetTextAndProperty(plt, ec, pic, pRange, pchText, cchText, langid, NULL);

    if (SUCCEEDED(hr = pic->GetProperty(GUID_PROP_READING, &pProp)))
    {
        BSTR bstr = SysAllocString(pszRead);

        if (bstr)
        {
            SetBSTRPropertyData(ec, pProp, pRange, bstr);
            SysFreeString(bstr);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        pProp->Release();
    }
    return hr;
}


//+---------------------------------------------------------------------------
//
// IsOwnerAndFocus
//
// This is service function for EnumTrackTextAndFocus.
//
//----------------------------------------------------------------------------

BOOL IsOwnerAndFocus(LIBTHREAD *plt, TfEditCookie ec, REFCLSID rclsid, ITfReadOnlyProperty *pProp, ITfRange *pRange)
{
    IEnumTfPropertyValue *pEnumPropVal;
    BOOL bRet = FALSE;
    VARIANT var;
    ULONG iTextOwner;
    ULONG iFocus;
    TF_PROPERTYVAL rgValue[2];

    if (SUCCEEDED(pProp->GetValue(ec, pRange, &var)))
    {
        Assert(var.vt == VT_UNKNOWN);

        if (SUCCEEDED(var.punkVal->QueryInterface(IID_IEnumTfPropertyValue, 
                                                (void **)&pEnumPropVal)))
        {
            if (pEnumPropVal->Next(2, rgValue, NULL) == S_OK)
            {
                Assert(rgValue[0].varValue.vt == VT_I4);
                Assert(rgValue[1].varValue.vt == VT_I4);

                // Issue: should we change the spec so the order is guaranteed maintained?
                if (IsEqualGUID(rgValue[0].guidId, GUID_PROP_TEXTOWNER))
                {
                    Assert(IsEqualGUID(rgValue[1].guidId, GUID_PROP_COMPOSING));
                    iTextOwner = 0;
                    iFocus = 1;
                }
                else
                {
                    iTextOwner = 1;
                    iFocus = 0;
                }

                // does the owner match rclisd?
                if (IsEqualTFGUIDATOM(plt, (TfGuidAtom)rgValue[iTextOwner].varValue.lVal, rclsid))
                {
                    // is the focus property set (not VT_EMPTY) and is it set TRUE?
                    bRet = (rgValue[iFocus].varValue.vt == VT_I4 && rgValue[iFocus].varValue.lVal != 0);
                }
            }
            pEnumPropVal->Release();
        }
        VariantClear(&var);
    }

    return bRet;
}

//+---------------------------------------------------------------------------
//
// EnumTrackTextAndFocus
//
//----------------------------------------------------------------------------

HRESULT EnumTrackTextAndFocus(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfReadOnlyProperty **ppProp, IEnumTfRanges **ppEnumTrack)
{
    static const GUID *rgguidProp[2] = { &GUID_PROP_TEXTOWNER, &GUID_PROP_COMPOSING };

    ITfReadOnlyProperty *pPropTrack = NULL;
    HRESULT hr;

    *ppEnumTrack = NULL;
    *ppProp = NULL;

    if (SUCCEEDED(hr = pic->TrackProperties(rgguidProp, ARRAYSIZE(rgguidProp),
                                            0, NULL,
                                            &pPropTrack)))

    {
        hr = pPropTrack->EnumRanges(ec, ppEnumTrack, pRange);
        *ppProp = pPropTrack;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// IsGUIDProp
//
//----------------------------------------------------------------------------

BOOL IsGUIDProp(LIBTHREAD *plt, TfEditCookie ec, REFGUID rclsid, ITfProperty *pProp, ITfRange *pRange)
{
    TfGuidAtom guidatom;
    if (SUCCEEDED(GetGUIDPropertyData(ec, pProp, pRange, &guidatom)))
    {
        if (IsEqualTFGUIDATOM(plt, guidatom, rclsid))
        {
            return TRUE;
        }
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
// AdjustRangeByProperty
//
//----------------------------------------------------------------------------

HRESULT AdjustRangeByTextOwner(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfRange **ppRange, REFCLSID rclsid)
{
    ITfProperty *pProp;
    ITfRange *pRangeStart = NULL;
    ITfRange *pRangeEnd = NULL;
    HRESULT hr = E_FAIL;

    if (SUCCEEDED(pic->GetProperty(GUID_PROP_TEXTOWNER, &pProp)))
    {
        BOOL fEmpty = FALSE;

        pRange->IsEmpty(ec, &fEmpty);

        if (fEmpty)
        {
            pProp->FindRange(ec, pRange, &pRangeStart, TF_ANCHOR_START);
        }
        else
        {
            pProp->FindRange(ec, pRange, &pRangeStart, TF_ANCHOR_START);
            pProp->FindRange(ec, pRange, &pRangeEnd, TF_ANCHOR_END);
        }
        pProp->Release();
    }
    
    if (!pRangeStart)
        goto Exit;

    if (pRangeEnd)
    {
        pRangeStart->ShiftEndToRange(ec, pRangeEnd, TF_ANCHOR_END);
    }

    pRangeStart->Clone(ppRange);
    hr = S_OK;

Exit:
    SafeRelease(pRangeStart);
    SafeRelease(pRangeEnd);
    return hr;
}

//+---------------------------------------------------------------------------
//
// AdjustRangeByAttribute
//
//----------------------------------------------------------------------------

HRESULT AdjustRangeByAttribute(LIBTHREAD *plt, TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfRange **ppRange, const GUID *rgRGuid, int cGuid)
{
    ITfProperty *pProp;
    ITfRange *pRangeStart = NULL;
    ITfRange *pRangeEnd = NULL;
    HRESULT hr = E_FAIL;

    if (SUCCEEDED(pic->GetProperty(GUID_PROP_ATTRIBUTE, &pProp)))
    {
        IEnumTfRanges *pEnumProp;
        if (SUCCEEDED(pProp->EnumRanges(ec, &pEnumProp, pRange)))
        {
            ITfRange *pRangeProp;
            //
            // first range.
            //
            while (!pRangeStart && 
                   pEnumProp->Next(1, &pRangeProp, NULL) == S_OK)
            {
 
                for ( int i = 0; i < cGuid; i++ )
                {
                    if (IsGUIDProp(plt, ec, rgRGuid[i], pProp, pRangeProp))
                    {
                        pRangeProp->Clone(&pRangeStart);
                    }
                }
                pRangeProp->Release();
            }

            if (pRangeStart)
            {
                //
                // last range.
                //
                while (pEnumProp->Next(1, &pRangeProp, NULL) == S_OK)
                {
                    for ( int i = 0; i < cGuid; i++ )
                    {
                        if (IsGUIDProp(plt, ec, rgRGuid[i], pProp, pRangeProp))
                        {   
                            SafeRelease(pRangeEnd);
                            pRangeProp->Clone(&pRangeEnd);
                        }
                    }
                    pRangeProp->Release();
                }
            }
            pEnumProp->Release();
        }
        pProp->Release();
    }
    
    if (!pRangeStart)
        goto Exit;

    if (pRangeEnd)
    {
        pRangeStart->ShiftEndToRange(ec, pRangeEnd, TF_ANCHOR_END);
    }

    pRangeStart->Clone(ppRange);
    hr = S_OK;

Exit:
    SafeRelease(pRangeStart);
    SafeRelease(pRangeEnd);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\sdo.cpp ===
//
// sdo.cpp
//

#include "private.h"
#include "sdo.h"
#include "helpers.h"

//////////////////////////////////////////////////////////////////////////////
//
// CDataObject
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CDataObject::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IDataObject))
    {
        *ppvObj = SAFECAST(this, IDataObject *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CDataObject::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CDataObject::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CDataObject::CDataObject()
{
    Dbg_MemSetThisName(TEXT("CDataObject"));

    memset(&_fe, 0, sizeof(_fe));
    memset(&_sm, 0, sizeof(_sm));
    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CDataObject::~CDataObject()
{
    ReleaseStgMedium(&_sm);
}

//+---------------------------------------------------------------------------
//
// GetData
//
//----------------------------------------------------------------------------

STDAPI CDataObject::GetData(FORMATETC *pfe, STGMEDIUM *psm)
{
    WCHAR *pch;
    ULONG cch;

    if (pfe == NULL || psm == NULL)
        return E_INVALIDARG;

    // verify the formatetc -- Issue: use QueryGetData
    if (pfe->cfFormat != _fe.cfFormat)
        return DV_E_FORMATETC;
    // Issue: ignoring ptd
    if (pfe->dwAspect != _fe.dwAspect)
        return DV_E_DVASPECT;
    if (pfe->lindex != _fe.lindex)
        return DV_E_LINDEX;
    if (!(pfe->tymed & _fe.lindex))
        return DV_E_TYMED;

    Assert(_fe.tymed == _sm.tymed);

    // allocate the medium
    if ((pfe->tymed & _fe.lindex) == TYMED_HGLOBAL)
    {
        switch (pfe->cfFormat)
        {
            case CF_UNICODETEXT:
                pch = (WCHAR *)GlobalLock(_sm.hGlobal);
                cch = wcslen(pch) + 1; // include the '\0'

                if ((psm->hGlobal = GlobalAlloc(GMEM_FIXED, cch*sizeof(WCHAR))) == NULL)
                {
                    GlobalUnlock(_sm.hGlobal);
                    return STG_E_MEDIUMFULL;
                }

                memcpy(psm->hGlobal, pch, cch*sizeof(WCHAR));
                GlobalUnlock(_sm.hGlobal);

                psm->tymed = TYMED_HGLOBAL;

                psm->pUnkForRelease = NULL; // caller must GlobalFree
                break;

            default:
                Assert(0); // shouldn't have let anyone SetData with something we can't handle
                break;
        }
    }
    else
    {
        Assert(0); // shouldn't have let anyone SetData with something we can't handle
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetDataHere
//
//----------------------------------------------------------------------------

STDAPI CDataObject::GetDataHere(FORMATETC *pfe, STGMEDIUM *psm)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// QueryGetData
//
//----------------------------------------------------------------------------

STDAPI CDataObject::QueryGetData(FORMATETC *pfe)
{
    if (pfe == NULL)
        return E_INVALIDARG;

    // verify the formatetc
    if (pfe->cfFormat != _fe.cfFormat)
        return DV_E_FORMATETC;
    // Issue: ignoring ptd
    if (pfe->dwAspect != _fe.dwAspect)
        return DV_E_DVASPECT;
    if (pfe->lindex != _fe.lindex)
        return DV_E_LINDEX;
    if (!(pfe->tymed & _fe.lindex))
        return DV_E_TYMED;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetCanonicalFormatEtc
//
//----------------------------------------------------------------------------

STDAPI CDataObject::GetCanonicalFormatEtc(FORMATETC *pfeIn, FORMATETC *pfeOut)
{
    return E_NOTIMPL; // Issue: may not be legal to leave this unimpl
}

//+---------------------------------------------------------------------------
//
// SetData
//
//----------------------------------------------------------------------------

STDAPI CDataObject::SetData(FORMATETC *pfe, STGMEDIUM *psm, BOOL fRelease)
{
    Assert(fRelease == TRUE); // bogus, but for now we don't support copying

    if (pfe == NULL || psm == NULL)
        return E_INVALIDARG;

    if (pfe->tymed != psm->tymed)
        return E_INVALIDARG;

    // free up any storage
    ReleaseStgMedium(&_sm);

    // copy the new stuff
    _fe = *pfe;
    _sm = *psm;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// EnumFormatEtc
//
//----------------------------------------------------------------------------

STDAPI CDataObject::EnumFormatEtc(DWORD dwDir, IEnumFORMATETC **ppefe)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// DAdvise
//
//----------------------------------------------------------------------------

STDAPI CDataObject::DAdvise(FORMATETC *pfe, DWORD advf, IAdviseSink *pas, DWORD *pdwCookie)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// DUnadvise
//
//----------------------------------------------------------------------------

STDAPI CDataObject::DUnadvise(DWORD dwCookie)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// EnumDAdvise
//
//----------------------------------------------------------------------------

STDAPI CDataObject::EnumDAdvise(IEnumSTATDATA **ppesd)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// _SetData
//
//----------------------------------------------------------------------------

HRESULT CDataObject::_SetData(const WCHAR *pch, ULONG cch)
{
    FORMATETC fe;
    STGMEDIUM sm;

    fe.cfFormat = CF_UNICODETEXT;
    fe.ptd = NULL;
    fe.dwAspect = DVASPECT_CONTENT;
    fe.lindex = -1;
    fe.tymed = TYMED_HGLOBAL;

    sm.tymed = TYMED_HGLOBAL;
    sm.hGlobal = NULL;
    sm.pUnkForRelease = NULL;
    sm.hGlobal = GlobalAlloc(GMEM_FIXED, (cch+1)*sizeof(WCHAR));

    if (sm.hGlobal == NULL)
        return E_OUTOFMEMORY;

    memcpy(sm.hGlobal, pch, cch*sizeof(WCHAR));
    ((WCHAR *)sm.hGlobal)[cch] = '\0';

    return SetData(&fe, &sm, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\lib\sink.cpp ===
//
// sink.cpp
//

#include "private.h"
#include "sink.h"
#include "strary.h"

//+---------------------------------------------------------------------------
//
// GenericAdviseSink
//
// Never returns cookies with the high bit set, use this behavior to chain
// other cookie allocators along with GenericAdviseSink....
//----------------------------------------------------------------------------

HRESULT GenericAdviseSink(REFIID riid, IUnknown *punk, const IID **rgiidConnectionPts,
                          CStructArray<GENERICSINK> *rgSinkArrays, UINT cConnectionPts,
                          DWORD *pdwCookie, GENERICSINK **ppSink /* = NULL */)
{
    UINT iArray;
    int  iSink;
    UINT cSinks;
    DWORD dwCookie;
    DWORD dw;
    IUnknown *punkSink;
    GENERICSINK *pgs;
    CStructArray<GENERICSINK> *rgSinks;

    Assert(cConnectionPts < 128); // 127 maximum IIDs

    if (pdwCookie == NULL)
        return E_INVALIDARG;

    *pdwCookie = GENERIC_ERROR_COOKIE;

    if (punk == NULL)
        return E_INVALIDARG;

    for (iArray=0; iArray<cConnectionPts; iArray++)
    {
        if (IsEqualIID(riid, *rgiidConnectionPts[iArray]))
            break;
    }

    if (iArray == cConnectionPts)
        return CONNECT_E_CANNOTCONNECT;

    rgSinks = &rgSinkArrays[iArray];
    