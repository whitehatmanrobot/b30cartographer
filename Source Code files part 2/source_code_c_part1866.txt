       ||
//                                        |+--- bit 5-10  (6 bits)
//                                        |
//                                        +---- bit 11-15 (5 bits)
//
//                      BMF_24BPP:
//
//                          This field is ignored, it alway assume BGR as
//                          shown below
//
//                          PRIMARY_ORDER_BGR
//                                        |||
//                                        ||+-- bit 0-7   (8 bits)
//                                        ||
//                                        |+--- bit 8-15  (8 bits)
//                                        |
//                                        +---- bit 16-23 (8 bits)
//
//                      BMF_32BPP:
//
//                          PRIMARY_ORDER_abc
//                                        |||
//                                        ||+-- bit 0-7   (8 bits)
//                                        ||
//                                        |+--- bit 8-15  (8 bits)
//                                        |
//                                        +---- bit 16-23 (8 bits)
//
//
//  rclSrc          - RECTL data structure defined the source rectangle area
//                    to be bitblt from, fields in this data structure are
//                    relative to the source HTSURFACEINFO's width/height.
//
//  rclDest         - RECTL data structure defined the destination rectangle
//                    area to be bitblt to, fields in this data structure are
//                    relative to the destination HTSURFACEINFO's width/height.
//
//  rclClip         - RECTL data structure defined the destination clipping
//                    rectangle area, fields in this data structure are
//                    relative to the destination HTSURFACEINFO's width/height.
//
//  rclBand         - RECTL data structure defined the device banding rectangle
//                    area, fields in this data structure are relative to the
//                    destination HTSURFACEINFO's width/height.
//
//                    This RECTL only used if BBPF_HAS_BANDRECT flag is set,
//                    when this flag is set, halftone DLL will automatically
//                    clipped the destination to this rectangle area and
//                    copied this rectangle to the output buffer with rclBand's
//                    left/top aligned to the buffer's physical origin.  The
//                    destination's buffer (bitmap) must the format specified
//                    in the destination HTSURFACEINFO.
//
//                    If rclBand rectangle is larger than the logical destination
//                    surface size (destination HTSURFACEINFO), halftone dll
//                    still move the the band's left/top location to the 0/0
//                    origin and extra width/height is remain unchanged.
//
//                    The rclBand normally is used for device which does not
//                    have enough memory to hold all the destination surface
//                    at one time, it just like to repeatly using same buffer
//                    to temporary holding the halftone results.
//
//                    The rclBand's left/top/right/bottom may not be negative
//                    numbers.
//
//  ptlSrcMask      - a POINTL data structure to specified the logical
//                    coordinate of starting point for the source mask bitmap,
//                    this field only used if a HTSURFACEINFO for the source
//                    mask is passed.
//
//                    This source mask bitmap must always monochrome and its
//                    width/height must
//
//                      Width  >= ptlSrcMask.x + source surface width.
//                      Height >= ptlSrcMask.y + source surface height;
//
//
//  NOTE:   1) all RECTL data structure are left/top inclusive and right/bottom
//             exclusive.
//
//          2) if rclSrc rectangle is not will ordered it specified the source
//             should be inverted before process for not ordered directions.
//
//          3) if rclDest rectangle is not will ordered it specified the
//             destination should be inverted after process for not ordered
//             directions.
//
//          4) if BBPF_HAS_DEST_CLIPRECT flag is set and rclClip is not well
//             ordered or its left equal to its right, or its top equal to its
//             bottom, then all destination are clipped, destination will not
//             be updated that is.
//
//          5) if BBPF_HAS_BANDRECT flag is set and rclBand is not well orderd
//             or it left eqaul to its right, or its top eqaul to its bottom,
//             then a HTERR_INVALID_BANDRECT is returned.
//
//

//
// ABIF_USE_CONST_ALPHA_VALUE   - The ConstAlphaValue field is used
// ABIF_DSTPAL_IS_RGRBUAD       - The pDstPal Pointed to RGBQUAD structure
//                                array rather PALETTEENTRY array
// ABIF_SRC_ALPHA_IS_PREMUL     - In 32bpp per-pixel alpha blending the
//                                source RGB already pre-multiply with its
//                                per-pixel alpha value
// ABIF_BLEND_DEST_ALPHA        - Only valid if source and destination
//                                both are 32bpp and per-pixel alpha is used
//                                d = s + (1 - s) * d
//


#define ABIF_USE_CONST_ALPHA_VALUE      0x01
#define ABIF_DSTPAL_IS_RGBQUAD          0x02
#define ABIF_SRC_ALPHA_IS_PREMUL        0x04
#define ABIF_BLEND_DEST_ALPHA           0x08

typedef struct _ABINFO {
    BYTE            Flags;
    BYTE            ConstAlphaValue;
    WORD            cDstPal;
    LPPALETTEENTRY  pDstPal;
    } ABINFO, *PABINFO;


#define BBPF_HAS_DEST_CLIPRECT      0x0001
#define BBPF_USE_ADDITIVE_PRIMS     0x0002
#define BBPF_NEGATIVE_DEST          0x0004
#define BBPF_INVERT_SRC_MASK        0x0008
#define BBPF_HAS_BANDRECT           0x0010
#define BBPF_BW_ONLY                0x0020
#define BBPF_TILE_SRC               0x0040
#define BBPF_ICM_ON                 0x0080
#define BBPF_NO_ANTIALIASING        0x0100
#define BBPF_DO_ALPHA_BLEND         0x0200

typedef struct _BITBLTPARAMS {
    WORD    Flags;
    BYTE    bReserved;
    BYTE    DestPrimaryOrder;
    PABINFO pABInfo;
    RECTL   rclSrc;
    RECTL   rclDest;
    RECTL   rclClip;
    RECTL   rclBand;
    POINTL  ptlBrushOrg;
    POINTL  ptlSrcMask;
    LPVOID  pBBData;
    } BITBLTPARAMS, FAR *PBITBLTPARAMS;



//
// DEVICEHALFTONEINFO
//
//  This data structure is passed for every HT_xxx api calls except the
//  HT_CreateDeviceHalftoneInfo() which return the pointer to this data
//  structure.  It is used to identify the device color characteristics
//  durning the halftone process.
//
//  DeviceOwnData       - this field will initially set to NULL, and will be
//                        used by the caller to stored useful information
//                        such as handle/pointer.
//
//  cxPattern           - width of the halftone pattern in pels
//
//  cyPattern           - height of the halftone pattern in pels.
//
//  HTColorAdjustment   - Current default color adjustment, if an halftone
//                        APIs required a PHTCOLORADJUSTMENT parameter and its
//                        passed as NULL pointer then default color adjustment
//                        is taken from here, the caller can change the
//                        HTCOLORADJUSTMENT data structure to affect all the
//                        color adjustment on this device.
//

typedef struct _DEVICEHALFTONEINFO {
    ULONG_PTR           DeviceOwnData;
    WORD                cxPattern;
    WORD                cyPattern;
    HTCOLORADJUSTMENT   HTColorAdjustment;
    } DEVICEHALFTONEINFO;

typedef DEVICEHALFTONEINFO  FAR *PDEVICEHALFTONEINFO;
typedef PDEVICEHALFTONEINFO FAR *PPDEVICEHALFTONEINFO;


//
// CHBINFO
//
//  This data structure is one of the parameter passed to the halftone entry
//  point HT_CreateHalftoneBrush();
//
//  Flags                   - one or more following flags can be defined
//
//                              CHBF_BW_ONLY
//
//                                  Create only black/white even the device is
//                                  color.
//
//                              CHBF_USE_ADDITIVE_PRIMS
//
//
//                                  Specified if the halftone result will be
//                                  using Red/Green/Blue primary color or using
//                                  Cyan/Magenta/Yellow primary color, depends
//                                  on the destination surface format as
//
//                                  BMF_1BPP:
//
//                                          Additive Prims: 0=Black, 1=White
//                                      Substractive Prims: 0=White, 1=Black
//
//                                  BMF_4BPP_VGA16:
//                                  BMF_8BPP_VGA256:
//                                  BMF_16BPP_555:
//                                  BMF_24BPP:
//
//                                      Always using RED, GREEN, BLUE primaries
//                                      and this flag is ignored.
//
//                                  BMF_4BPP:
//
//                                      Additive Prims: RED, GREEN. BLUE
//                                  Substractive Prims: CYAN, MAGENTA, YELLOW
//
//                                  The order of the RGB, or CMY is specified
//                                  by DestPrimaryOrder field. (see below)
//
//                              CHBF_NEGATIVE_BRUSH
//
//                                  Create the negative version of the brush.
//
//
//  DestSurfaceFormat       - One of the following can be specified,
//
//                              BMF_1BPP, BMF_4BPP, BMF_4BPP_VGA16,
//                              BMF_8BPP_VGA256, BMF_16BPP_555.
//
//                              for VGA16, VGA256, 16BPP_555  surface format
//                              see HTSURFACEINFO for descriptions.
//
//  DestScanLineAlignBytes  - Alignment bytes needed for each output pattern
//                            scan line, some common ones are
//
//                              BMF_ALIGN_BYTE      ( 8-bit aligned)
//                              BMF_ALIGN_WORD      (16-bit aligned)
//                              BMF_ALIGN_DWORD     (32-bit aligned)
//                              BMF_ALIGN_QWORD     (64-bit aligned)
//
//  DestPrimaryOrder        - Specified destination primary color order, it can
//                            be either PRIMARY_ORDER_RGB or PRIMARY_ORDER_CMY
//                            group, it depends on the surface format has
//                            following meaning.
//
//                              BMF_1BPP:
//
//                                  This field is ignored.
//
//
//                              BMF_4BPP_VGA16:
//
//                                  This field automatically set to
//                                  PRIMARY_ORDER_BGR by the halftone DLL.
//
//                              BMF_4BPP:
//
//                                  for each byte there are two indices
//                                  entries, and for each nibble has following
//                                  meaning, notice that bit 3/7 always set to
//                                  0, the index number only range from 0 to 7.
//
//                                      PRIMARY_ORDER_abc
//                                                    |||
//                                                    ||+-- bit 0/4
//                                                    ||
//                                                    |+--- bit 1/5
//                                                    |
//                                                    +---- bit 2/7
//
//
//                              BMF_8BPP_VGA256:
//
//                                  This field is ignored, the palette entries
//                                  and its order is defined by halftone DLL
//                                  at run time, the caller should get the
//                                  palette for the VGA256 surface through
//                                  HT_Get8BPPFormatPalette() API call.
//
//                              BMF_16BPP_555:
//
//                                  PRIMARY_ORDER_abc
//                                                |||
//                                                ||+-- bit 0-4   (5 bits)
//                                                ||
//                                                |+--- bit 5-9   (5 bits)
//                                                |
//                                                +---- bit 10-15 (5 bits)
//
//
//


#define CHBF_BW_ONLY                    0x01
#define CHBF_USE_ADDITIVE_PRIMS         0x02
#define CHBF_NEGATIVE_BRUSH             0x04
#define CHBF_BOTTOMUP_BRUSH             0x08
#define CHBF_ICM_ON                     0x10


typedef struct _CHBINFO {
    BYTE        Flags;
    BYTE        DestSurfaceFormat;
    BYTE        DestScanLineAlignBytes;
    BYTE        DestPrimaryOrder;
    } CHBINFO;



//
// STDMONOPATTERN
//
//  This data structure is used when calling the HT_CreateStdMonoPattern().
//
//  Flags               - One or more following flags may be defined
//
//                          SMP_TOPDOWN
//
//                              Specified that first scan line of the pattern
//                              bitmap will be the viewing top, if this flag
//                              is not defined then the last scan line is the
//                              viewing top.
//
//                          SMP_0_IS_BLACK
//
//                              specified that the in the bitmap a bit value
//                              0 = black and bit value 1=white, if this flag
//                              is not defined then bit value 0=white and
//                              bit value 1=black.
//
//  ScanLineAlignBytes  - Alignment bytes needed for each output pattern scan
//                        line, some common ones are
//
//                          BMF_ALIGN_BYTE      ( 8-bit aligned)
//                          BMF_ALIGN_WORD      (16-bit aligned)
//                          BMF_ALIGN_DWORD     (32-bit aligned)
//                          BMF_ALIGN_QWORD     (64-bit aligned)
//
//  PatternIndex        - Specified the pattern index number, this has the
//                        predefined value as HT_STDMONOPAT_xxxx.  If a invalid
//                        index number is passed then it return an error
//                        HTERR_INVALID_STDMONOPAT_INDEX is returned.
//
//  LineWidth           - This field only applied to the pattern which has
//                        lines in them, the value range from 0-255 (byte) and
//                        it repesent as LineWidth/1000 of inch, for example
//                        a 3 indicate 3/1000 = 0.003 inch width, if this value
//                        is less than the device minimum pel size, it will
//                        default to the 1 pel, the maximum is 255/1000 = 0.255
//                        inch width.
//
//                        If a zero is specified then it halftone will using
//                        default line width settting.
//
//  LinesPerInch        - This field only applied to the pattern wich has lines
//                        in them, the value range from 0 to 255 (byte). The
//                        LinesPerInch is calculated in the perpendicular
//                        direction of two parallel lines, the distances
//                        between two parallel lines that is.
//
//                        If a zero is specified then it halftone will using
//                        default line per inch setting.
//
//  BytesPerScanLine    - If will be filled by halftone dll to specified the
//                        size in bytes for each scan line in the pattern.
//
//  cxPels              - It will be filled by halftone dll of the final
//                        pattern's width in pel.
//
//  cyPels              - It will be filled by halftone dll of the final
//                        pattern's height in scan line.
//
//  pPattern            - Specified the memory location where the pattern will
//                        be stored, if this field is NULL then it will fill in
//                        the width/height fields.
//
//




#define HT_SMP_HORZ_LINE                0
#define HT_SMP_VERT_LINE                1
#define HT_SMP_HORZ_VERT_CROSS          2
#define HT_SMP_DIAG_15_LINE_UP          3
#define HT_SMP_DIAG_15_LINE_DOWN        4
#define HT_SMP_DIAG_15_CROSS            5
#define HT_SMP_DIAG_30_LINE_UP          6
#define HT_SMP_DIAG_30_LINE_DOWN        7
#define HT_SMP_DIAG_30_CROSS            8
#define HT_SMP_DIAG_45_LINE_UP          9
#define HT_SMP_DIAG_45_LINE_DOWN        10
#define HT_SMP_DIAG_45_CROSS            11
#define HT_SMP_DIAG_60_LINE_UP          12
#define HT_SMP_DIAG_60_LINE_DOWN        13
#define HT_SMP_DIAG_60_CROSS            14
#define HT_SMP_DIAG_75_LINE_UP          15
#define HT_SMP_DIAG_75_LINE_DOWN        16
#define HT_SMP_DIAG_75_CROSS            17

#define HT_SMP_PERCENT_SCREEN_START     (HT_SMP_DIAG_75_CROSS + 1)
#define HT_SMP_PERCENT_SCREEN(x)        (x + HT_SMP_PERCENT_SCREEN_START)

#define HT_SMP_MAX_INDEX                HT_SMP_PERCENT_SCREEN(100)


#define SMP_TOPDOWN             W_BITPOS(0)
#define SMP_0_IS_BLACK          W_BITPOS(1)


typedef struct _STDMONOPATTERN {
    WORD    Flags;
    BYTE    ScanLineAlignBytes;
    BYTE    PatternIndex;
    BYTE    LineWidth;
    BYTE    LinesPerInch;
    WORD    BytesPerScanLine;
    WORD    cxPels;
    WORD    cyPels;
    LPBYTE  pPattern;
    } STDMONOPATTERN;

typedef STDMONOPATTERN FAR *PSTDMONOPATTERN;


//
// Following is used in ConvertColorTable
//


#define CCTF_BW_ONLY        0x0001
#define CCTF_NEGATIVE       0x0002
#define CCTF_ICM_ON         0x0004


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//                                                                          //
// Exposed Halftone DLL APIs                                                //
//                                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#ifndef _HTAPI_ENTRY_

LONG
APIENTRY
HT_CreateDeviceHalftoneInfo(
    PHTINITINFO             pHTInitInfo,
    PPDEVICEHALFTONEINFO    ppDeviceHalftoneInfo
    );

BOOL
APIENTRY
HT_DestroyDeviceHalftoneInfo(
    PDEVICEHALFTONEINFO     pDeviceHalftoneInfo
    );

LONG
APIENTRY
HT_CreateHalftoneBrush(
    PDEVICEHALFTONEINFO pDeviceHalftoneInfo,
    PHTCOLORADJUSTMENT  pHTColorAdjustment,
    PCOLORTRIAD         pColorTriad,
    CHBINFO             CHBInfo,
    LPVOID              pOutputBuffer
    );

#ifndef _WINDDI_

LONG
APIENTRY
HT_ComputeRGBGammaTable(
    WORD    GammaTableEntries,
    WORD    GammaTableType,
    UDECI4  RedGamma,
    UDECI4  GreenGamma,
    UDECI4  BlueGamma,
    LPBYTE  pGammaTable
    );

LONG
APIENTRY
HT_Get8BPPFormatPalette(
    LPPALETTEENTRY  pPaletteEntry,
    UDECI4          RedGamma,
    UDECI4          GreenGamma,
    UDECI4          BlueGamma
    );

LONG
APIENTRY
HT_Get8BPPMaskPalette(
    LPPALETTEENTRY  pPaletteEntry,
    BOOL            Use8BPPMaskPal,
    BYTE            CMYMask,
    UDECI4          RedGamma,
    UDECI4          GreenGamma,
    UDECI4          BlueGamma
    );

#endif

LONG
APIENTRY
HT_CreateStandardMonoPattern(
    PDEVICEHALFTONEINFO pDeviceHalftoneInfo,
    PSTDMONOPATTERN     pStdMonoPattern
    );


LONG
APIENTRY
HT_HalftoneBitmap(
    PDEVICEHALFTONEINFO pDeviceHalftoneInfo,
    PHTCOLORADJUSTMENT  pHTColorAdjustment,
    PHTSURFACEINFO      pSourceHTSurfaceInfo,
    PHTSURFACEINFO      pSourceMaskHTSurfaceInfo,
    PHTSURFACEINFO      pDestinationHTSurfaceInfo,
    PBITBLTPARAMS       pBitbltParams
    );

#endif  // _HTAPI_ENTRY_
#endif  // _HT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\inc\kdftdbg.h ===
/******************************Module*Header*******************************\
* Module Name: kdftdbg.h
*
* Copyright (c) 1995-1999 Microsoft Corporation
\**************************************************************************/

#include <winfont.h>
#define WOW_EMBEDING 2

extern "C" VOID
vPrintFONTDIFF(
    FONTDIFF *pfd  ,
    CHAR     *psz      )
{
//
// This is where you put the code common to vDumpFONTDIFF and vPrintFONTDIFF
//

    dprintf("  ** %s **\n"                         , psz                 );
    dprintf("    jReserved1             %d\n"      , pfd->jReserved1     );
    dprintf("    jReserved2             %d\n"      , pfd->jReserved2     );
    dprintf("    jReserved3             %d\n"      , pfd->jReserved3     );
    dprintf("    bWeight                %d\n"      , pfd->bWeight        );
    dprintf("    usWinWeight            %d\n"      , pfd->usWinWeight    );
    dprintf("    fsSelection            %-#6x\n"   , pfd->fsSelection    );
    dprintf("    fwdAveCharWidth        %d\n"      , pfd->fwdAveCharWidth);
    dprintf("    fwdMaxCharInc          %d\n"      , pfd->fwdMaxCharInc  );
    dprintf("    ptlCaret               {%d,%d}\n" , pfd->ptlCaret.x
                                                  , pfd->ptlCaret.y     );
}

/******************************Public*Routine******************************\
* vPrintTEXTMETRICW
*
* History:
*  Tue 08-Dec-1992 11:41:36 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID
vPrintTEXTMETRICW(
    TEXTMETRICW *p    )
{
    dprintf("    tmHeight               = %d\n",    p->tmHeight           );
    dprintf("    tmAscent               = %d\n",    p->tmAscent           );
    dprintf("    tmDescent              = %d\n",    p->tmDescent          );
    dprintf("    tmInternalLeading      = %d\n",    p->tmInternalLeading  );
    dprintf("    tmExternalLeading      = %d\n",    p->tmExternalLeading  );
    dprintf("    tmAveCharWidth         = %d\n",    p->tmAveCharWidth     );
    dprintf("    tmMaxCharWidth         = %d\n",    p->tmMaxCharWidth     );
    dprintf("    tmWeight               = %d\n",    p->tmWeight           );
    dprintf("    tmOverhang             = %d\n",    p->tmOverhang         );
    dprintf("    tmDigitizedAspectX     = %d\n",    p->tmDigitizedAspectX );
    dprintf("    tmDigitizedAspectY     = %d\n",    p->tmDigitizedAspectY );
    dprintf("    tmFirstChar            = %-#6x\n", p->tmFirstChar        );
    dprintf("    tmLastChar             = %-#6x\n", p->tmLastChar         );
    dprintf("    tmDefaultChar          = %-#6x\n", p->tmDefaultChar      );
    dprintf("    tmBreakChar            = %-#6x\n", p->tmBreakChar        );
    dprintf("    tmItalic               = %-#4x\n", p->tmItalic           );
    dprintf("    tmUnderlined           = %-#4x\n", p->tmUnderlined       );
    dprintf("    tmStruckOut            = %-#4x\n", p->tmStruckOut        );
    dprintf("    tmPitchAndFamily       = %-#4x\n", p->tmPitchAndFamily   );
    dprintf("    tmCharSet              = %-#4x\n", p->tmCharSet          );
}


extern "C" VOID
vPrintIFIMETRICS(
    IFIMETRICS *pifi    )
{
//
// Convenient pointer to Panose number
//
    char *psz;

    PANOSE *ppan = &pifi->panose;

    PWSZ pwszFamilyName = (PWSZ)(((BYTE*) pifi) + pifi->dpwszFamilyName);
    PWSZ pwszStyleName  = (PWSZ)(((BYTE*) pifi) + pifi->dpwszStyleName );
    PWSZ pwszFaceName   = (PWSZ)(((BYTE*) pifi) + pifi->dpwszFaceName  );
    PWSZ pwszUniqueName = (PWSZ)(((BYTE*) pifi) + pifi->dpwszUniqueName);

    dprintf("    cjThis                 %-#8lx\n" , pifi->cjThis      );
    dprintf("    cjIfiExtra             %-#8lx\n" , pifi->cjIfiExtra  );
    dprintf("    pwszFamilyName         \"%ws\"\n", pwszFamilyName    );
    dprintf("    pwszStyleName          \"%ws\"\n", pwszStyleName     );
    dprintf("    pwszFaceName           \"%ws\"\n", pwszFaceName      );
    dprintf("    pwszUniqueName         \"%ws\"\n", pwszUniqueName    );
    dprintf("    dpFontSim              %-#8lx\n" , pifi->dpFontSim   );
    dprintf("    lEmbedId               %-#8lx\n" , pifi->lEmbedId    );
    dprintf("    lItalicAngle           %d\n"     , pifi->lItalicAngle);
    dprintf("    lCharBias              %d\n"     , pifi->lCharBias   );
    dprintf("    dpCharSets             %d\n"     , pifi->dpCharSets  );


    dprintf("    jWinCharSet            %04x\n"   , pifi->jWinCharSet          );
    switch (pifi->jWinCharSet)
    {
    case ANSI_CHARSET       : psz = "ANSI_CHARSET"         ; break;
    case DEFAULT_CHARSET    : psz = "DEFAULT_CHARSET"      ; break;
    case SYMBOL_CHARSET     : psz = "SYMBOL_CHARSET"       ; break;
    case SHIFTJIS_CHARSET   : psz = "SHIFTJIS_CHARSET"     ; break;
    case HANGEUL_CHARSET    : psz = "HANGEUL_CHARSET"      ; break;
    case GB2312_CHARSET     : psz = "GB2312_CHARSET"       ; break;
    case CHINESEBIG5_CHARSET: psz = "CHINESEBIG5_CHARSET"  ; break;
    case OEM_CHARSET        : psz = "OEM_CHARSET"          ; break;
    case JOHAB_CHARSET      : psz = "JOHAB_CHARSET"        ; break;
    case HEBREW_CHARSET     : psz = "HEBREW_CHARSET"       ; break;
    case ARABIC_CHARSET     : psz = "ARABIC_CHARSET"       ; break;
    case GREEK_CHARSET      : psz = "GREEK_CHARSET"        ; break;
    case TURKISH_CHARSET    : psz = "TURKISH_CHARSET"      ; break;
    case THAI_CHARSET       : psz = "THAI_CHARSET"         ; break;
    case EASTEUROPE_CHARSET : psz = "EASTEUROPE_CHARSET"   ; break;
    case RUSSIAN_CHARSET    : psz = "RUSSIAN_CHARSET"      ; break;
    case MAC_CHARSET        : psz = "MAC_CHARSET"          ; break;
    case BALTIC_CHARSET     : psz = "BALTIC_CHARSET"       ; break;
    default                 : psz = "UNKNOWN"              ; break;
    }
    dprintf("                             %s\n", psz);


    if (pifi->dpCharSets)
    {
        BYTE *pj  = (BYTE *)pifi + pifi->dpCharSets;
        BYTE *pjEnd = pj + 16;
        dprintf("    Supported Charsets: \n");

        for (; pj < pjEnd; pj++)
        {
            switch (*pj)
            {
            case ANSI_CHARSET       : psz = "ANSI_CHARSET"         ; break;
            case DEFAULT_CHARSET    : psz = "DEFAULT_CHARSET"      ; break;
            case SYMBOL_CHARSET     : psz = "SYMBOL_CHARSET"       ; break;
            case SHIFTJIS_CHARSET   : psz = "SHIFTJIS_CHARSET"     ; break;
            case HANGEUL_CHARSET    : psz = "HANGEUL_CHARSET"      ; break;
            case GB2312_CHARSET     : psz = "GB2312_CHARSET"       ; break;
            case CHINESEBIG5_CHARSET: psz = "CHINESEBIG5_CHARSET"  ; break;
            case OEM_CHARSET        : psz = "OEM_CHARSET"          ; break;
            case JOHAB_CHARSET      : psz = "JOHAB_CHARSET"        ; break;
            case HEBREW_CHARSET     : psz = "HEBREW_CHARSET"       ; break;
            case ARABIC_CHARSET     : psz = "ARABIC_CHARSET"       ; break;
            case GREEK_CHARSET      : psz = "GREEK_CHARSET"        ; break;
            case TURKISH_CHARSET    : psz = "TURKISH_CHARSET"      ; break;
            case THAI_CHARSET       : psz = "THAI_CHARSET"         ; break;
            case EASTEUROPE_CHARSET : psz = "EASTEUROPE_CHARSET"   ; break;
            case RUSSIAN_CHARSET    : psz = "RUSSIAN_CHARSET"      ; break;
            case MAC_CHARSET        : psz = "MAC_CHARSET"          ; break;
            case BALTIC_CHARSET     : psz = "BALTIC_CHARSET"       ; break;
            default                 : psz = "UNKNOWN"              ; break;
            }
            dprintf("                             0x%lx, %s\n", (DWORD)(*pj), psz);
        }
    }



    dprintf("    jWinPitchAndFamily     %04x\n"   , pifi->jWinPitchAndFamily   );
    switch (pifi->jWinPitchAndFamily & 0xF)
    {
    case DEFAULT_PITCH      : psz = "DEFAULT_PITCH";    break;
    case FIXED_PITCH        : psz = "FIXED_PITCH";      break;
    case VARIABLE_PITCH     : psz = "VARIABLE_PITCH";   break;
    default                 : psz = "UNKNOWN_PITCH";    break;
    }
    dprintf("                             %s | ", psz);
    switch (pifi->jWinPitchAndFamily & 0xF0)
    {
    case FF_DONTCARE    : psz = "FF_DONTCARE";      break;
    case FF_ROMAN       : psz = "FF_ROMAN";         break;
    case FF_SWISS       : psz = "FF_SWISS";         break;
    case FF_MODERN      : psz = "FF_MODERN";        break;
    case FF_SCRIPT      : psz = "FF_SCRIPT";        break;
    case FF_DECORATIVE  : psz = "FF_DECORATIVE";    break;
    default             : psz = "FF_UNKNOWN";       break;
    }
    dprintf("%s\n", psz);




    dprintf("    usWinWeight            %d\n"     , pifi->usWinWeight          );

    dprintf("    flInfo                 %-#8lx\n" , pifi->flInfo               );
    if (pifi->flInfo & FM_INFO_TECH_TRUETYPE)
        dprintf("                             FM_INFO_TECH_TRUETYPE\n");
    if (pifi->flInfo & FM_INFO_TECH_BITMAP)
        dprintf("                             FM_INFO_TECH_BITMAP\n");
    if (pifi->flInfo & FM_INFO_TECH_STROKE)
        dprintf("                             FM_INFO_TECH_STROKE\n");
    if (pifi->flInfo & FM_INFO_TECH_OUTLINE_NOT_TRUETYPE)
        dprintf("                             FM_INFO_TECH_OUTLINE_NOT_TRUETYPE\n");
    if (pifi->flInfo & FM_INFO_ARB_XFORMS)
        dprintf("                             FM_INFO_ARB_XFORMS\n");
    if (pifi->flInfo & FM_INFO_1BPP)
        dprintf("                             FM_INFO_1BPP\n");
    if (pifi->flInfo & FM_INFO_4BPP)
        dprintf("                             FM_INFO_4BPP\n");
    if (pifi->flInfo & FM_INFO_8BPP)
        dprintf("                             FM_INFO_8BPP\n");
    if (pifi->flInfo & FM_INFO_16BPP)
        dprintf("                             FM_INFO_16BPP\n");
    if (pifi->flInfo & FM_INFO_24BPP)
        dprintf("                             FM_INFO_24BPP\n");
    if (pifi->flInfo & FM_INFO_32BPP)
        dprintf("                             FM_INFO_32BPP\n");
    if (pifi->flInfo & FM_INFO_INTEGER_WIDTH)
        dprintf("                             FM_INFO_INTEGER_WIDTH\n");
    if (pifi->flInfo & FM_INFO_CONSTANT_WIDTH)
        dprintf("                             FM_INFO_CONSTANT_WIDTH\n");
    if (pifi->flInfo & FM_INFO_NOT_CONTIGUOUS)
        dprintf("                             FM_INFO_NOT_CONTIGUOUS\n");
    if (pifi->flInfo & FM_INFO_TECH_MM)
        dprintf("                             FM_INFO_TECH_MM\n");
    if (pifi->flInfo & FM_INFO_RETURNS_OUTLINES)
        dprintf("                             FM_INFO_RETURNS_OUTLINES\n");
    if (pifi->flInfo & FM_INFO_RETURNS_STROKES)
        dprintf("                             FM_INFO_RETURNS_STROKES\n");
    if (pifi->flInfo & FM_INFO_RETURNS_BITMAPS)
        dprintf("                             FM_INFO_RETURNS_BITMAPS\n");
    if (pifi->flInfo & FM_INFO_DSIG)
        dprintf("                             FM_INFO_DSIG\n");
    if (pifi->flInfo & FM_INFO_RIGHT_HANDED)
        dprintf("                             FM_INFO_RIGHT_HANDED\n");
    if (pifi->flInfo & FM_INFO_INTEGRAL_SCALING)
        dprintf("                             FM_INFO_INTEGRAL_SCALING\n");
    if (pifi->flInfo & FM_INFO_90DEGREE_ROTATIONS)
        dprintf("                             FM_INFO_90DEGREE_ROTATIONS\n");
    if (pifi->flInfo & FM_INFO_OPTICALLY_FIXED_PITCH)
        dprintf("                             FM_INFO_OPTICALLY_FIXED_PITCH\n");
    if (pifi->flInfo & FM_INFO_DO_NOT_ENUMERATE)
        dprintf("                             FM_INFO_DO_NOT_ENUMERATE\n");
    if (pifi->flInfo & FM_INFO_ISOTROPIC_SCALING_ONLY)
        dprintf("                             FM_INFO_ISOTROPIC_SCALING_ONLY\n");
    if (pifi->flInfo & FM_INFO_ANISOTROPIC_SCALING_ONLY)
        dprintf("                             FM_INFO_ANISOTROPIC_SCALING_ONLY\n");
    if (pifi->flInfo & FM_INFO_TECH_CFF)
        dprintf("                             FM_INFO_TECH_CFF\n");
    if (pifi->flInfo & FM_INFO_FAMILY_EQUIV)
        dprintf("                             FM_INFO_FAMILY_EQUIV\n");
    if (pifi->flInfo & FM_INFO_IGNORE_TC_RA_ABLE)
        dprintf("                             FM_INFO_IGNORE_TC_RA_ABLE\n");



    dprintf("    fsSelection            %-#6lx\n" , pifi->fsSelection          );
    if (pifi->fsSelection & FM_SEL_ITALIC)
        dprintf("                             FM_SEL_ITALIC\n");
    if (pifi->fsSelection & FM_SEL_UNDERSCORE)
        dprintf("                             FM_SEL_UNDERSCORE\n");
    if (pifi->fsSelection & FM_SEL_NEGATIVE)
        dprintf("                             FM_SEL_NEGATIVE\n");
    if (pifi->fsSelection & FM_SEL_OUTLINED)
        dprintf("                             FM_SEL_OUTLINED\n");
    if (pifi->fsSelection & FM_SEL_STRIKEOUT)
        dprintf("                             FM_SEL_STRIKEOUT\n");
    if (pifi->fsSelection & FM_SEL_BOLD)
        dprintf("                             FM_SEL_BOLD\n");
    if (pifi->fsSelection & FM_SEL_REGULAR)
        dprintf("                             FM_SEL_REGULAR\n");

    dprintf("    fsType                 %-#6lx\n" , pifi->fsType               );
    if (pifi->fsType & FM_TYPE_LICENSED)
        dprintf("                             FM_TYPE_LICENSED\n");
    if (pifi->fsType & FM_READONLY_EMBED)
        dprintf("                             FM_READONLY_EMBED\n");
    if (pifi->fsType & FM_NO_EMBEDDING)
        dprintf("                             FM_NO_EMBEDDING\n");

    dprintf("    fwdUnitsPerEm          %d\n"     , pifi->fwdUnitsPerEm        );
    dprintf("    fwdLowestPPEm          %d\n"     , pifi->fwdLowestPPEm        );
    dprintf("    fwdWinAscender         %d\n"     , pifi->fwdWinAscender       );
    dprintf("    fwdWinDescender        %d\n"     , pifi->fwdWinDescender      );
    dprintf("    fwdMacAscender         %d\n"     , pifi->fwdMacAscender       );
    dprintf("    fwdMacDescender        %d\n"     , pifi->fwdMacDescender      );
    dprintf("    fwdMacLineGap          %d\n"     , pifi->fwdMacLineGap        );
    dprintf("    fwdTypoAscender        %d\n"     , pifi->fwdTypoAscender      );
    dprintf("    fwdTypoDescender       %d\n"     , pifi->fwdTypoDescender     );
    dprintf("    fwdTypoLineGap         %d\n"     , pifi->fwdTypoLineGap       );
    dprintf("    fwdAveCharWidth        %d\n"     , pifi->fwdAveCharWidth      );
    dprintf("    fwdMaxCharInc          %d\n"     , pifi->fwdMaxCharInc        );
    dprintf("    fwdCapHeight           %d\n"     , pifi->fwdCapHeight         );
    dprintf("    fwdXHeight             %d\n"     , pifi->fwdXHeight           );
    dprintf("    fwdSubscriptXSize      %d\n"     , pifi->fwdSubscriptXSize    );
    dprintf("    fwdSubscriptYSize      %d\n"     , pifi->fwdSubscriptYSize    );
    dprintf("    fwdSubscriptXOffset    %d\n"     , pifi->fwdSubscriptXOffset  );
    dprintf("    fwdSubscriptYOffset    %d\n"     , pifi->fwdSubscriptYOffset  );
    dprintf("    fwdSuperscriptXSize    %d\n"     , pifi->fwdSuperscriptXSize  );
    dprintf("    fwdSuperscriptYSize    %d\n"     , pifi->fwdSuperscriptYSize  );
    dprintf("    fwdSuperscriptXOffset  %d\n"     , pifi->fwdSuperscriptXOffset);
    dprintf("    fwdSuperscriptYOffset  %d\n"     , pifi->fwdSuperscriptYOffset);
    dprintf("    fwdUnderscoreSize      %d\n"     , pifi->fwdUnderscoreSize    );
    dprintf("    fwdUnderscorePosition  %d\n"     , pifi->fwdUnderscorePosition);
    dprintf("    fwdStrikeoutSize       %d\n"     , pifi->fwdStrikeoutSize     );
    dprintf("    fwdStrikeoutPosition   %d\n"     , pifi->fwdStrikeoutPosition );
    dprintf("    chFirstChar            %-#4x\n"  , (int) (BYTE) pifi->chFirstChar   );
    dprintf("    chLastChar             %-#4x\n"  , (int) (BYTE) pifi->chLastChar    );
    dprintf("    chDefaultChar          %-#4x\n"  , (int) (BYTE) pifi->chDefaultChar );
    dprintf("    chBreakChar            %-#4x\n"  , (int) (BYTE) pifi->chBreakChar   );
    dprintf("    wcFirsChar             %-#6x\n"  , pifi->wcFirstChar          );
    dprintf("    wcLastChar             %-#6x\n"  , pifi->wcLastChar           );
    dprintf("    wcDefaultChar          %-#6x\n"  , pifi->wcDefaultChar        );
    dprintf("    wcBreakChar            %-#6x\n"  , pifi->wcBreakChar          );
    dprintf("    ptlBaseline            {%ld,%ld}\n"  , pifi->ptlBaseline.x,
                                                   pifi->ptlBaseline.y        );
    dprintf("    ptlAspect              {%ld,%ld}\n"  , pifi->ptlAspect.x,
                                                   pifi->ptlAspect.y          );
    dprintf("    ptlCaret               {%ld,%ld}\n"  , pifi->ptlCaret.x,
                                                   pifi->ptlCaret.y           );
    dprintf("    rclFontBox             {%ld,%ld,%ld,%ld}\n",pifi->rclFontBox.left,
                                                      pifi->rclFontBox.top,
                                                      pifi->rclFontBox.right,
                                                      pifi->rclFontBox.bottom    );
    dprintf("    achVendId              \"%c%c%c%c\"\n",pifi->achVendId[0],
                                                   pifi->achVendId[1],
                                                   pifi->achVendId[2],
                                                   pifi->achVendId[3]         );
    dprintf("    cKerningPairs          %ld\n"     , pifi->cKerningPairs        );
    dprintf("    ulPanoseCulture        %-#8lx\n" , pifi->ulPanoseCulture);
    dprintf(
           "    panose                 {%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x}\n"
                                                 , ppan->bFamilyType
                                                 , ppan->bSerifStyle
                                                 , ppan->bWeight
                                                 , ppan->bProportion
                                                 , ppan->bContrast
                                                 , ppan->bStrokeVariation
                                                 , ppan->bArmStyle
                                                 , ppan->bLetterform
                                                 , ppan->bMidline
                                                 , ppan->bXHeight             );
    if (pifi->dpFontSim)
    {
        FONTSIM *pfs = (FONTSIM*) (((BYTE*) pifi) + pifi->dpFontSim);
        if (pfs->dpBold)
        {
            vPrintFONTDIFF(
                (FONTDIFF*) (((BYTE*) pfs) + pfs->dpBold),
                "BOLD SIMULATION"                );
        }
        if (pfs->dpItalic)
        {
            vPrintFONTDIFF(
                (FONTDIFF*) (((BYTE*) pfs) + pfs->dpItalic),
                "ITALIC SIMULATION"                );
        }
        if (pfs->dpBoldItalic)
        {
            vPrintFONTDIFF(
                (FONTDIFF*) (((BYTE*) pfs) + pfs->dpBoldItalic),
                "BOLD ITALIC SIMULATION"                );
        }
    }
    dprintf("\n\n");
}

extern "C" VOID vPrintLOGFONTW(LOGFONTW* plfw)
{
    char *psz;

    dprintf("    lfw.lfHeight              = %d\n",     plfw->lfHeight);
    dprintf("    lfw.lfWidth               = %d\n",     plfw->lfWidth);
    dprintf("    lfw.lfEscapement          = %d\n",     plfw->lfEscapement);
    dprintf("    lfw.lfOrientation         = %d\n",     plfw->lfOrientation);

    dprintf("    lfw.lfWeight              = %d = ",     plfw->lfWeight);
    switch (plfw->lfWeight)
    {
    case FW_DONTCARE    : psz = "FW_DONTCARE  "; break;
    case FW_THIN        : psz = "FW_THIN      "; break;
    case FW_EXTRALIGHT  : psz = "FW_EXTRALIGHT"; break;
    case FW_LIGHT       : psz = "FW_LIGHT     "; break;
    case FW_NORMAL      : psz = "FW_NORMAL    "; break;
    case FW_MEDIUM      : psz = "FW_MEDIUM    "; break;
    case FW_SEMIBOLD    : psz = "FW_SEMIBOLD  "; break;
    case FW_BOLD        : psz = "FW_BOLD      "; break;
    case FW_EXTRABOLD   : psz = "FW_EXTRABOLD "; break;
    case FW_HEAVY       : psz = "FW_HEAVY     "; break;
    default             : psz = "NON STANDARD "; break;
    }
    dprintf("%s\n",psz);

    dprintf("    lfw.lfItalic              = %-#8lx\n", plfw->lfItalic);
    dprintf("    lfw.lfUnderline           = %-#8lx\n", plfw->lfUnderline);
    dprintf("    lfw.lfStrikeOut           = %-#8lx\n", plfw->lfStrikeOut);

//
// lfCharSet
//
    dprintf("    lfw.lfCharSet             = %-#8lx = ", plfw->lfCharSet);
    switch (plfw->lfCharSet)
    {
    case ANSI_CHARSET       : psz = "ANSI_CHARSET"         ; break;
    case DEFAULT_CHARSET    : psz = "DEFAULT_CHARSET"      ; break;
    case SYMBOL_CHARSET     : psz = "SYMBOL_CHARSET"       ; break;
    case SHIFTJIS_CHARSET   : psz = "SHIFTJIS_CHARSET"     ; break;
    case HANGEUL_CHARSET    : psz = "HANGEUL_CHARSET"      ; break;
    case GB2312_CHARSET     : psz = "GB2312_CHARSET"       ; break;
    case CHINESEBIG5_CHARSET: psz = "CHINESEBIG5_CHARSET"  ; break;
    case OEM_CHARSET        : psz = "OEM_CHARSET"          ; break;
    case JOHAB_CHARSET      : psz = "JOHAB_CHARSET"        ; break;
    case HEBREW_CHARSET     : psz = "HEBREW_CHARSET"       ; break;
    case ARABIC_CHARSET     : psz = "ARABIC_CHARSET"       ; break;
    case GREEK_CHARSET      : psz = "GREEK_CHARSET"        ; break;
    case TURKISH_CHARSET    : psz = "TURKISH_CHARSET"      ; break;
    case THAI_CHARSET       : psz = "THAI_CHARSET"         ; break;
    case EASTEUROPE_CHARSET : psz = "EASTEUROPE_CHARSET"   ; break;
    case RUSSIAN_CHARSET    : psz = "RUSSIAN_CHARSET"      ; break;
    case MAC_CHARSET        : psz = "MAC_CHARSET"          ; break;
    case BALTIC_CHARSET     : psz = "BALTIC_CHARSET"       ; break;
    default                 : psz = "UNKNOWN"              ; break;
    }
    dprintf("%s\n", psz);

//
// lfOutPrecision
//
    dprintf("    lfw.lfOutPrecision        = %-#8lx = ", plfw->lfOutPrecision);
    switch (plfw->lfOutPrecision)
    {
    case OUT_DEFAULT_PRECIS     : psz = "OUT_DEFAULT_PRECIS";   break;
    case OUT_STRING_PRECIS      : psz = "OUT_STRING_PRECIS";    break;
    case OUT_CHARACTER_PRECIS   : psz = "OUT_CHARACTER_PRECIS"; break;
    case OUT_STROKE_PRECIS      : psz = "OUT_STROKE_PRECIS";    break;
    case OUT_TT_PRECIS          : psz = "OUT_TT_PRECIS";        break;
    case OUT_DEVICE_PRECIS      : psz = "OUT_DEVICE_PRECIS";    break;
    case OUT_RASTER_PRECIS      : psz = "OUT_RASTER_PRECIS";    break;
    case OUT_TT_ONLY_PRECIS     : psz = "OUT_TT_ONLY_PRECIS";   break;
    case OUT_OUTLINE_PRECIS     : psz = "OUT_OUTLINE_PRECIS";   break;
    default                     : psz = "UNKNOWN";              break;
    }
    dprintf("%s\n", psz);

//
// lfClipPrecision
//
    dprintf("    lfw.lfClipPrecision       = %-#8lx", plfw->lfClipPrecision);
    switch (plfw->lfClipPrecision & CLIP_MASK)
    {
    case CLIP_DEFAULT_PRECIS    : psz = "CLIP_DEFAULT_PRECIS";      break;
    case CLIP_CHARACTER_PRECIS  : psz = "CLIP_CHARACTER_PRECIS";    break;
    case CLIP_STROKE_PRECIS     : psz = "CLIP_STROKE_PRECIS";       break;
    default                     : psz = "UNKNOWN";                  break;
    }
    dprintf(" = %s\n", psz);
    if (plfw->lfClipPrecision & CLIP_LH_ANGLES)
    {
        dprintf("                                     CLIP_LH_ANGLES\n");
    }
    if (plfw->lfClipPrecision & CLIP_TT_ALWAYS)
    {
        dprintf("                                     CLIP_TT_ALWAYS\n");
    }
    if (plfw->lfClipPrecision & CLIP_EMBEDDED)
    {
        dprintf("                                     CLIP_EMBEDDED\n");
    }

//
// lfQuality
//
    dprintf("    lfw.lfQuality             = %-#8lx", plfw->lfQuality);
    switch (plfw->lfQuality)
    {
    case DEFAULT_QUALITY    : psz = "DEFAULT_QUALITY";  break;
    case DRAFT_QUALITY      : psz = "DRAFT_QUALITY";    break;
    case PROOF_QUALITY      : psz = "PROOF_QUALITY";    break;
    default                 : psz = "UNKNOWN";          break;
    }
    dprintf(" = %s\n", psz);

//
// lfPitchAndFamily
//
    dprintf("    lfw.lfPitchAndFamily      = %-#8lx", plfw->lfPitchAndFamily);
    switch (plfw->lfPitchAndFamily & 0xF0)
    {
    case FF_DONTCARE    : psz = "FF_DONTCARE";      break;
    case FF_ROMAN       : psz = "FF_ROMAN";         break;
    case FF_SWISS       : psz = "FF_SWISS";         break;
    case FF_MODERN      : psz = "FF_MODERN";        break;
    case FF_SCRIPT      : psz = "FF_SCRIPT";        break;
    case FF_DECORATIVE  : psz = "FF_DECORATIVE";    break;
    default             : psz = "FF_UNKNOWN";       break;
    }
    dprintf(" = %s | ", psz);
    switch (plfw->lfPitchAndFamily & 0xF)
    {
    case DEFAULT_PITCH      : psz = "DEFAULT_PITCH";    break;
    case FIXED_PITCH        : psz = "FIXED_PITCH";      break;
    case VARIABLE_PITCH     : psz = "VARIABLE_PITCH";   break;
    default                 : psz = "UNKNOWN_PITCH";    break;
    }
    dprintf("%s\n", psz);

//
// lfFaceName
//
    dprintf("    lfw.lfFaceName            = \"%ws\"\n",plfw->lfFaceName);
}

extern "C" VOID
vPrintENUMLOGFONTEXDVW(
    ENUMLOGFONTEXDVW *pelfw
    )
{
    vPrintLOGFONTW(&pelfw->elfEnumLogfontEx.elfLogFont);
    PANOSE *ppan;

    dprintf("    elfFullName   = \"%ws\"\n",  pelfw->elfEnumLogfontEx.elfFullName );
    dprintf("    elfStyle      = \"%ws\"\n",  pelfw->elfEnumLogfontEx.elfStyle    );
    dprintf("    elfScript     = \"%ws\"\n",  pelfw->elfEnumLogfontEx.elfScript   );

    // now print design vector if any...


}


/******************************Public*Routine******************************\
* vPrintFONTOBJ
*
* History:
*  Fri 18-Feb-1994 10:23:33 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintFONTOBJ(FONTOBJ *pfo)
{
    FLONG fl = pfo->flFontType;

    dprintf("    iUniq       = %d\n", pfo->iUniq     );
    dprintf("    iFace       = %d\n", pfo->iFace     );
    dprintf("    cxMax       = %d\n", pfo->cxMax     );

    dprintf("    flFontType  = %x\n", fl             );
    if (fl & FO_TYPE_RASTER)
        dprintf("                    FO_TYPE_RASTER\n");
    if (fl & FO_TYPE_DEVICE)
        dprintf("                    FO_TYPE_DEVICE\n");
    if (fl & FO_TYPE_TRUETYPE)
        dprintf("                    FO_TYPE_TRUETYPE\n");
    if (fl & FO_SIM_BOLD)
        dprintf("                    FO_SIM_BOLD\n");
    if (fl & FO_SIM_ITALIC)
        dprintf("                    FO_SIM_ITALIC\n");
    if (fl & FO_EM_HEIGHT)
        dprintf("                    FO_EM_HEIGHT\n");

    dprintf("    iTTUniq     = %d\n", pfo->iTTUniq   );
    dprintf("    iFile       = %d\n", pfo->iFile     );
    dprintf(  "    sizLogResPpi= (%d,%d)\n"
           , pfo->sizLogResPpi.cx
           , pfo->sizLogResPpi.cy
        );
    dprintf("    ulStyleSize = %u\n", pfo->ulStyleSize);
    dprintf("    pvConsumer  = %-#8x\n", pfo->pvConsumer);
    dprintf("    pvProducer  = %-#8x\n", pfo->pvProducer);
}

/******************************Public*Routine******************************\
* vPrintEXTFONTOBJ
*
* History:
*  Fri 18-Feb-1994 11:19:44 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintEXTFONTOBJ(EXTFONTOBJ *pefo)
{
    vPrintFONTOBJ(&(pefo->fobj));
    dprintf("*** BEGIN GDI INTERNAL STRUCTURE ***\n");
}

/******************************Public*Routine******************************\
* vPrintFLOAT
*
* History:
*  Mon 29-Aug-1994 11:51:17 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintFLOAT(FLOATL l_e)
{
    dprintf("%#+12.6f", l_e);
}

/******************************Public*Routine******************************\
* vPrintFD_XFORM(FD_XFORM
*
* History:
*  Mon 29-Aug-1994 11:50:52 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintFD_XFORM(FD_XFORM *pfdx, char * psz)
{
    dprintf("%seXX = ",psz); vPrintFLOAT(pfdx->eXX); dprintf("\n");
    dprintf("%seXY = ",psz); vPrintFLOAT(pfdx->eXY); dprintf("\n");
    dprintf("%seYX = ",psz); vPrintFLOAT(pfdx->eYX); dprintf("\n");
    dprintf("%seYY = ",psz); vPrintFLOAT(pfdx->eYY); dprintf("\n");
}

/**********w********************Public*Routine******************************\
* vPrintFD_REALIZEEXTRA
*
* History:
*  Mon 29-Aug-1994 11:50:29 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

//extern "C" VOID
//vPrintFD_REALIZEEXTRA(FD_REALIZEEXTRA *p, char *psz)
//{
//  dprintf("    fdxQuantized =\n",psz);
//  vPrintFD_XFORM(&(p->fdxQuantized), psz);
//  dprintf("%slExtLeading = %d\n", psz, p->lExtLeading);
//  dprintf("%salReserved = \n%s\t[%d]\n%s\t[%d]\n%s\t[%d]\n%s\t[%d]\n"
//      , psz
//      , psz
//      , p->alReserved[0]
//      , psz
//      , p->alReserved[1]
//      , psz
//      , p->alReserved[2]
//      , psz
//      , p->alReserved[3]
//      );
//}

/******************************Public*Routine******************************\
* vPrintEFLOAT
*
* History:
*  Mon 29-Aug-1994 11:49:57 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintEFLOAT(EFLOAT *pef)
{
    FLOATL l_e;

    pef->vEfToF(l_e);
    vPrintFLOAT(l_e);
}

/******************************Public*Routine******************************\
* vPrintFIX
*
* History:
*  Mon 29-Aug-1994 11:49:47 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintFIX(FIX fx)
{
    dprintf("%-#x%x",fx>>4, fx & 0xf);
}

/******************************Public*Routine******************************\
* vPrintMATRIX
*
* History:
*  Mon 29-Aug-1994 11:49:27 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintMATRIX( MATRIX *pmx, char *psz)
{
    FLONG fl = pmx->flAccel;

    if (!psz) psz = "";

    dprintf("%sefM11 = ",psz); vPrintEFLOAT(&(pmx->efM11)); dprintf("\n");
    dprintf("%sefM12 = ",psz); vPrintEFLOAT(&(pmx->efM12)); dprintf("\n");
    dprintf("%sefM21 = ",psz); vPrintEFLOAT(&(pmx->efM21)); dprintf("\n");
    dprintf("%sefM22 = ",psz); vPrintEFLOAT(&(pmx->efM22)); dprintf("\n");
    dprintf("%sefDx  = ",psz); vPrintEFLOAT(&(pmx->efDx )); dprintf("\n");
    dprintf("%sefDy  = ",psz); vPrintEFLOAT(&(pmx->efDy )); dprintf("\n");
    dprintf("%sfxDx  = ",psz); vPrintFIX(pmx->fxDx); dprintf("\n");
    dprintf("%sfxDy  = ",psz); vPrintFIX(pmx->fxDy); dprintf("\n");

    dprintf("    flAccel = %-#8x\n", fl);

    if (fl & XFORM_SCALE)           dprintf("%sXFORM_SCALE\n"         ,psz);
    if (fl & XFORM_UNITY)           dprintf("%sXFORM_UNITY\n"         ,psz);
    if (fl & XFORM_Y_NEG)           dprintf("%sXFORM_Y_NEG\n"         ,psz);
    if (fl & XFORM_FORMAT_LTOFX)    dprintf("%sXFORM_FORMAT_LTOFX\n"  ,psz);
    if (fl & XFORM_FORMAT_FXTOL)    dprintf("%sXFORM_FORMAT_FXTOL\n"  ,psz);
    if (fl & XFORM_FORMAT_LTOL)     dprintf("%sXFORM_FORMAT_LTOL\n"   ,psz);
    if (fl & XFORM_NO_TRANSLATION)  dprintf("%sXFORM_NO_TRANSLATION\n",psz);
}

/******************************Public*Routine******************************\
* vPrintCACHE
*
* History:
*  Mon 29-Aug-1994 11:49:12 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintCACHE(CACHE *pc, char *psz)
{
    dprintf("%spgdNext            = %-#x\n", psz, pc->pgdNext     );
    dprintf("%spgdThreshold       = %-#x\n", psz, pc->pgdThreshold);
    dprintf("%spgdFirstBlockEnd   = %-#x\n", psz, pc->pjFirstBlockEnd );

    dprintf("%scjbbl        = %u\n", psz, pc->cjbbl);
    dprintf("%scBlocksMax   = %u\n", psz, pc->cBlocksMax);
    dprintf("%scBlocks      = %u\n", psz, pc->cBlocks);
    dprintf("%scGlyphs      = %u\n", psz, pc->cGlyphs);
    dprintf("%scMetrics     = %u\n", psz, pc->cMetrics);
    dprintf("%spbblBase     = %-#x\n", psz, pc->pbblBase);
    dprintf("%spbblCur      = %-#x\n", psz, pc->pbblCur);
    dprintf("%spgbNext      = %-#x\n", psz, pc->pgbNext);
    dprintf("%spgbThreshold = %-#x\n", psz, pc->pgbThreshold);

    dprintf("%spjAuxCacheMem= %-#x\n", psz, pc->pjAuxCacheMem);
    dprintf("%scjAuxCacheMem= %u\n"  , psz, pc->cjAuxCacheMem);
    dprintf("%scjGlyphMax   = %u\n"  , psz, pc->cjGlyphMax);
    dprintf("%sbSmallMetrics= %u\n" , psz, pc->bSmallMetrics);
}

/******************************Public*Routine******************************\
* vPrintflInfo
*
* History:
*  Mon 29-Aug-1994 11:51:48 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintflInfo(FLONG flInfo, char *psz)
{
    if (FM_INFO_TECH_TRUETYPE & flInfo)
        dprintf("%s  FM_INFO_TECH_TRUETYPE\n",psz);
    if (FM_INFO_TECH_BITMAP & flInfo)
        dprintf("%s  FM_INFO_TECH_BITMAP\n",psz);
    if (FM_INFO_TECH_STROKE & flInfo)
        dprintf("%s  FM_INFO_TECH_STROKE\n",psz);
    if (FM_INFO_TECH_OUTLINE_NOT_TRUETYPE & flInfo)
        dprintf("%s  FM_INFO__OUTLINE_NOT_TRUETYPE\n",psz);
    if (FM_INFO_ARB_XFORMS & flInfo)
        dprintf("%s  FM_INFO_ARB_XFORMS\n",psz);
    if (FM_INFO_1BPP & flInfo)
       dprintf("%s  FM_INFO_1BPP\n",psz);
    if (FM_INFO_4BPP & flInfo)
       dprintf("%s  FM_INFO_4BPP\n",psz);
    if (FM_INFO_8BPP & flInfo)
       dprintf("%s  FM_INFO_8BPP\n",psz);
    if (FM_INFO_16BPP & flInfo)
       dprintf("%s  FM_INFO_16BPP\n",psz);
    if (FM_INFO_24BPP & flInfo)
       dprintf("%s  FM_INFO_24BPP\n",psz);
    if (FM_INFO_32BPP & flInfo)
       dprintf("%s  FM_INFO_32BPP\n",psz);
    if (FM_INFO_INTEGER_WIDTH & flInfo)
       dprintf("%s  FM_INFO_INTEGER_WIDTH\n",psz);
    if (FM_INFO_CONSTANT_WIDTH & flInfo)
       dprintf("%s  FM_INFO_CONSTANT_WIDTH\n",psz);
    if (FM_INFO_NOT_CONTIGUOUS & flInfo)
       dprintf("%s  FM_INFO_NOT_CONTIGUOUS\n",psz);
    if (FM_INFO_TECH_MM & flInfo)
       dprintf("%s  FM_INFO_TECH_MM\n",psz);
    if (FM_INFO_RETURNS_OUTLINES & flInfo)
       dprintf("%s  FM_INFO_RETURNS_OUTLINES\n",psz);
    if (FM_INFO_RETURNS_STROKES & flInfo)
       dprintf("%s  FM_INFO_RETURNS_STROKES\n",psz);
    if (FM_INFO_RETURNS_BITMAPS & flInfo)
       dprintf("%s  FM_INFO_RETURNS_BITMAPS\n",psz);
    if (FM_INFO_DSIG & flInfo)
       dprintf("%s  FM_INFO_DSIG\n",psz);
    if (FM_INFO_RIGHT_HANDED & flInfo)
       dprintf("%s  FM_INFO_RIGHT_HANDED\n",psz);
    if (FM_INFO_INTEGRAL_SCALING & flInfo)
       dprintf("%s  FM_INFO_INTEGRAL_SCALING\n",psz);
    if (FM_INFO_90DEGREE_ROTATIONS & flInfo)
       dprintf("%s  FM_INFO_90DEGREE_ROTATIONS\n",psz);
    if (FM_INFO_OPTICALLY_FIXED_PITCH & flInfo)
       dprintf("%s  FM_INFO_OPTICALLY_FIXED_PITCH\n",psz);
    if (FM_INFO_DO_NOT_ENUMERATE & flInfo)
       dprintf("%s  INFO_DO_NOT_ENUMERATE\n",psz);
    if (FM_INFO_ISOTROPIC_SCALING_ONLY & flInfo)
       dprintf("%s  FM_INSOTROPIC_SCALING_ONLY\n",psz);
    if (FM_INFO_ANISOTROPIC_SCALING_ONLY & flInfo)
       dprintf("%s  FM_INFOSOTROPIC_SCALING_ONLY\n",psz);
    if (FM_INFO_TECH_CFF & flInfo)
       dprintf("%s  FM_INFO_TECH_CFF\n",psz);
    if (FM_INFO_FAMILY_EQUIV & flInfo)
       dprintf("%s  FM_INFO_FAMILY_EQUIV\n",psz);
}

/******************************Public*Routine******************************\
* vPrintRFONT
*
* History:
*  Fri 18-Feb-1994 11:26:10 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintRFONT(VOID *pvIn)
{
    RFONT *prf = (RFONT*) pvIn;

    vPrintEXTFONTOBJ((EXTFONTOBJ*) prf);
    dprintf("    iUnique     = %d\n", prf->iUnique);

    dprintf("    flType      = %d = ",prf->flType);

    if (prf->flType & ~(RFONT_TYPE_NOCACHE | RFONT_TYPE_MASK))
    {
        dprintf("ERROR!!! UNKNOWN TYPE\n");
    }
    else
    {
        if (prf->flType & RFONT_TYPE_NOCACHE)
        {
            dprintf("RFONT_TYPE_NOCACHE\n");
        }
        switch (prf->flType & RFONT_TYPE_MASK)
        {
        case RFONT_TYPE_HGLYPH:  dprintf("RFONT_TYPE_HGLYPH \n"); break;
        case RFONT_TYPE_UNICODE: dprintf("RFONT_TYPE_UNICODE\n"); break;
        default:                 dprintf("RFONT_TYPE_???????\n"); break;
        }
    }

    dprintf("    ulContent   = %d = ", prf->ulContent);
    switch (prf->ulContent)
    {
    case RFONT_CONTENT_METRICS: dprintf("RFONT_CONTENT_METRICS\n"); break;
    case RFONT_CONTENT_BITMAPS: dprintf("RFONT_CONTENT_BITMAPS\n"); break;
    case RFONT_CONTENT_PATHS:   dprintf("RFONT_CONTENT_PATHS\n"); break;
    default:                 dprintf("ERROR!!! UNKNOWN TYPE\n");
    }

    dprintf("    hdevProducer = %-#8x\n", prf->hdevProducer);
    dprintf("    bDeviceFont = %d\n", prf->bDeviceFont);
    dprintf("    hdevConsumer = %-#8x\n", prf->hdevConsumer);
    dprintf("    dhpdev =      %-#8x\n", prf->dhpdev);
    dprintf("    ppfe =        %-#8x\n", prf->ppfe);
    dprintf("    pPFF =        %-#8x\n", prf->pPFF);

    dprintf("    fdx  = \n");
    vPrintFD_XFORM(&(prf->fdx), "\t\t");
    dprintf("    cBitsPerPel = %d\n", prf->cBitsPerPel);

    dprintf("    mxWorldToDevice =\n");
    vPrintMATRIX(&(prf->mxWorldToDevice), "\t");

    dprintf("    iGraphicsMode = %d\n", prf->iGraphicsMode);

    {
        dprintf("    eptflNtoWScale = ");
        vPrintEFLOAT(&(prf->eptflNtoWScale.x));
        dprintf(", ");
        vPrintEFLOAT(&(prf->eptflNtoWScale.y));
        dprintf("\n");
    }

    dprintf("    bNtoWIdent =  %d\n", prf->bNtoWIdent);

    dprintf("    xoForDDI.pmx    = %-#8x\n", prf->xoForDDI.pmx);
    dprintf("    xoForDDI.ulMode = %u\n",    prf->xoForDDI.ulMode);

    dprintf("    mxForDDI =\n");
    vPrintMATRIX(&(prf->mxForDDI), "\t");
    dprintf("    flRealizedType =\n");
    if (prf->flRealizedType & SO_FLAG_DEFAULT_PLACEMENT)
        dprintf("\t\tSO_FLAG_DEFAULT_PLACEMENT\n");
    if (prf->flRealizedType & SO_HORIZONTAL)
        dprintf("\t\tSO_HORIZONTAL\n");
    if (prf->flRealizedType & SO_VERTICAL)
        dprintf("\t\tSO_VERTICAL\n");
    if (prf->flRealizedType & SO_REVERSED)
        dprintf("\t\tSO_REVERSED\n");
    if (prf->flRealizedType & SO_ZERO_BEARINGS)
        dprintf("\t\tSO_ZERO_BEARINGS\n");
    if (prf->flRealizedType & SO_CHAR_INC_EQUAL_BM_BASE)
        dprintf("\t\tSO_CHAR_INC_EQUAL_BM_BASE\n");
    if (prf->flRealizedType & SO_MAXEXT_EQUAL_BM_SIDE)
        dprintf("\t\tSO_MAXEXT_EQUAL_BM_SIDE\n");
    dprintf("    ptlUnderline1 = (%d,%d)\n"
        ,  prf->ptlUnderline1.x
        ,  prf->ptlUnderline1.y);
    dprintf("    ptlStrikeOut  = (%d,%d)\n"
      , prf->ptlStrikeOut.x
      , prf->ptlStrikeOut.y);
    dprintf("    ptlULThickness = (%d,%d)\n"
      , prf->ptlULThickness.x
      , prf->ptlULThickness.y);
    dprintf("    ptlSOThickness = (%d,%d)\n"
      , prf->ptlSOThickness.x
      , prf->ptlSOThickness.y);
    dprintf("    lCharInc       = %d\n", prf->lCharInc);
    dprintf("    fxMaxAscent    = "); vPrintFIX(prf->fxMaxAscent); dprintf("\n");
    dprintf("    fxMaxDescent   = "); vPrintFIX(prf->fxMaxDescent); dprintf("\n");
    dprintf("    fxMaxExtent    = "); vPrintFIX(prf->fxMaxExtent); dprintf("\n");
    dprintf("    cxMax          = %u\n", prf->cxMax);
    dprintf("    lMaxAscent     = %d\n", prf->lMaxAscent);
    dprintf("    lMaxHeight     = %d\n", prf->lMaxHeight);
    dprintf("    ulOrientation  = %u\n", prf->ulOrientation);

    dprintf("    pteUnitBase    = (");
        vPrintEFLOAT(&(prf->pteUnitBase.x));
        dprintf(",");
        vPrintEFLOAT(&(prf->pteUnitBase.y));
        dprintf(")\n");

    dprintf("    efWtoDBase     = ");
        vPrintEFLOAT(&(prf->efWtoDBase));
        dprintf("\n");

    dprintf("    efDtoWBase     = ");
        vPrintEFLOAT(&(prf->efDtoWBase));
        dprintf("\n");

    dprintf("    lAscent        = %d\n", prf->lAscent);

    dprintf("    pteUnitAscent  = (");
        vPrintEFLOAT(&(prf->pteUnitAscent.x));
        dprintf(",");
        vPrintEFLOAT(&(prf->pteUnitAscent.y));
        dprintf(")\n");

    dprintf("    efWtoDAscent   = ");
        vPrintEFLOAT(&(prf->efWtoDAscent));
        dprintf("\n");

    dprintf("    efDtoWAscent   = ");
        vPrintEFLOAT(&(prf->efDtoWAscent));
        dprintf("\n");

    dprintf("    lEscapement    = %d\n", prf->lEscapement);

    dprintf("    pteUnitEsc     = (");
        vPrintEFLOAT(&(prf->pteUnitEsc.x));
        dprintf(",");
        vPrintEFLOAT(&(prf->pteUnitEsc.y));
        dprintf(")\n");

    dprintf("    efWtoDEsc      = ");
        vPrintEFLOAT(&(prf->efWtoDEsc));
        dprintf("\n");

    dprintf("    efDtoWEsc      = ");
        vPrintEFLOAT(&(prf->efDtoWEsc));
        dprintf("\n");

    dprintf("    efEscToBase    = ");
        vPrintEFLOAT(&(prf->efEscToBase));
        dprintf("\n");

    dprintf("    efEscToAscent  = ");
        vPrintEFLOAT(&(prf->efEscToAscent));
        dprintf("\n");

    dprintf("    flInfo         =  %-#8lx\n" , prf->flInfo);

    vPrintflInfo(prf->flInfo, "\t\t");

    //dprintf("    wcDefault =      %u\n",  prf->wcDefault);
    dprintf("    hgDefault =      %-#x\n", prf->hgDefault);
    dprintf("    hgBreak   =      %-#x\n", prf->hgBreak);
    dprintf("    fxBreak   =      "); vPrintFIX(prf->fxBreak); dprintf("\n");
    dprintf("    pfdg      =      %-#x\n", prf->pfdg);
    dprintf("    wcgp      =      %-#x\n", prf->wcgp);
    dprintf("    cSelected =      %d\n",   prf->cSelected);
    dprintf("    rflPDEV.prfntPrev = %-#x\n", prf->rflPDEV.prfntPrev);
    dprintf("    rflPDEV.prfntNext = %-#x\n", prf->rflPDEV.prfntNext);
    dprintf("    rflPFF.prfntPrev  = %-#x\n", prf->rflPFF.prfntPrev);
    dprintf("    rflPFF.prfntNext  = %-#x\n", prf->rflPFF.prfntNext);
    dprintf("    cache =\n");
    vPrintCACHE(&(prf->cache),"\t");
    dprintf("    ptlSim       =   (%d,%d)\n", prf->ptlSim.x, prf->ptlSim.y);
    dprintf("    bNeededPaths =   %d\n", prf->bNeededPaths);

    dprintf("    reExtra =\n");
    //vPrintFD_REALIZEEXTRA(&(prf->reExtra),"\t\t");
    dprintf("    efDtoWBase_31   = "); vPrintEFLOAT(&(prf->efDtoWBase_31)); dprintf("\n");
    dprintf("    efDtoWAscent_31 = "); vPrintEFLOAT(&(prf->efDtoWAscent_31)); dprintf("\n");

}

/******************************Public*Routine******************************\
* vPrintPFT
*
* Print Physical Font Table
*
* History:
*  Mon 29-Aug-1994 10:26:56 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintPFT(PFT *pPFT)
{
    unsigned i;

    dprintf("\tpfhFamily         = %-#x\n", pPFT->pfhFamily);
    dprintf("\tpfhFace           = %-#x\n", pPFT->pfhFace  );
    dprintf("\tcBuckets          = %u\n",   pPFT->cBuckets);
    dprintf("\tcFiles            = %u\n",   pPFT->cFiles);
    for (i = 0; i < pPFT->cBuckets; i++)
    {
        PFF *pPFF = pPFT->apPFF[i];
        if (pPFF)
        {
            // print the head of the chain

            dprintf("\tapPFF[%u]  = %-#x\n", i, pPFF);
            while (pPFF)
            {
                // the colliding PFF pointers are printed
                // on subsequent lines and are indented
                // from the PFF pointer at the head of the list

                pPFF = pPFF->pPFFNext;
                dprintf("\t           = %-#x\n", pPFF);
            }
        }
    }
    dprintf("\n\n");
}

/******************************Public*Routine******************************\
* vPrintPFF
*
* Dumps the contents of a PFF object via the specified output routine.
*
* History:
*  05-May-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintPFF (VOID *pv)
{
    PFF *pPFF = (PFF*) pv;
    PFE **ppPFE, **ppPFE_;
    ULONG ul;

    ULONG ulMax = pPFF->cFonts;

    dprintf("    sizeofThis   = %u\n",   pPFF->sizeofThis);
    dprintf("    pPFFNext     = %-#x\n", pPFF->pPFFNext  );
    dprintf("    pPFFPrev     = %-#x\n", pPFF->pPFFPrev  );
    dprintf("   *pwszPathname_= \"%ws\"\n", pPFF->pwszPathname_);
    dprintf("    flState      = %-#x\n", pPFF->flState   );
    if (pPFF->flState & PFF_STATE_READY2DIE)
        dprintf("                   PFF_STATE_READY2DIE\n");
    if (pPFF->flState & PFF_STATE_PERMANENT_FONT)
        dprintf("                   PFF_STATE_PERMANENT_FONT\n");
    if (pPFF->flState & PFF_STATE_NETREMOTE_FONT)
        dprintf("                   PFF_STATE_NETREMOTE_FONT\n");
    if (pPFF->flState & PFF_STATE_DCREMOTE_FONT)
        dprintf("                   PFF_STATE_DCREMOTE_FONT\n");
    if (pPFF->flState & PFF_STATE_EUDC_FONT)
        dprintf("                   PFF_STATE_EUDC_FONT\n");
    if (pPFF->flState & ~(PFF_STATE_READY2DIE | PFF_STATE_PERMANENT_FONT | PFF_STATE_NETREMOTE_FONT | PFF_STATE_EUDC_FONT | PFF_STATE_MEMORY_FONT | PFF_STATE_DCREMOTE_FONT))
        dprintf("                   UNKNOWN FLAG\n");
    dprintf("    cLoaded      = %u\n"  , pPFF->cLoaded   );
    dprintf("    cNotEnum     = %u\n"  , pPFF->cNotEnum  );
    dprintf("    pPvtDataHead = %-#x\n", pPFF->pPvtDataHead);
    dprintf("    cRFONT       = %u\n"  , pPFF->cRFONT    );
    dprintf("    prfntList    = %-#x\n", pPFF->prfntList );
    dprintf("    hff          = %-#x\n", pPFF->hff       );
    if (pPFF->hff == 0)
        dprintf("                   DEVICE PFF\n");
    dprintf("    hdev         = %-#x\n", pPFF->hdev      );
//    dprintf("    dhpdev       = %-#x\n", pPFF->dhpdev    );
    dprintf("    pfhFace      = %-#x\n", pPFF->pfhFace   );
    dprintf("    pfhFamily    = %-#x\n", pPFF->pfhFamily );
    dprintf("    pPFT         = %-#x\n", pPFF->pPFT      );
    dprintf("    cFonts       = %u\n"  , pPFF->cFonts    );
    for (ppPFE  = (PFE **) &(pPFF->aulData[0]), ul = 0; ul < ulMax; ul++)
    {
        dprintf("    apPFE[%u]     = %-#x\n", ul, ppPFE[ul]);
    }
    //if (pPFF->cFonts > gulTableLimit)
    //    dprintf("Table exceeds set limit.  Edit gulTableLimit to change.\n");
}

/******************************Public*Routine******************************\
* vPrintWCRUN
*
* History:
*  Sat 31-Oct-1992 05:57:36 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintWCRUN(WCRUN *pwcr)
{
    DbgPrint("\n    vPrintWCRUN");
    DbgPrint("\n        pwcr    = %-#8lx", pwcr);
    DbgPrint("\n        cGlyphs = %d",     pwcr->cGlyphs);
    DbgPrint("\n        wcLow   = %-#6lx", pwcr->wcLow);
    DbgPrint("\n        phg     = %-#8lx", pwcr->phg);

    WCHAR   wc  = pwcr->wcLow;
    HGLYPH *phg = pwcr->phg;
    HGLYPH *phgSup = phg + pwcr->cGlyphs;

    if (phg)
    {
        for (;phg < phgSup; phg += 1, wc += 1)
        {
            DbgPrint("\n            %-#6lx  %-#8lx", wc, *phg);
        }
    }
    DbgPrint("\n");
}

/******************************Member*Function*****************************\
* RFONTOBJ::vPrintFD_GLYPHSET
*
* History:
*  Sat 31-Oct-1992 05:58:01 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID RFONTOBJ::vPrintFD_GLYPHSET()
{
    FD_GLYPHSET *pfdg = prfnt->pfdg;

    DbgPrint("\nRFONTOBJ::vPrintFD_GLYPHSET()");
    DbgPrint("\n    pfdg = %-#8lx", pfdg);
    if (pfdg == 0)
    {
        DbgPrint("\n");
        return;
    }

    DbgPrint("\n    cjThis           = %-#8lx", pfdg->cjThis);
    DbgPrint("\n    flAccel          = %-#8lx", pfdg->flAccel);
    DbgPrint("\n    cGlyphsSupported = %d",     pfdg->cGlyphsSupported);
    DbgPrint("\n    cRuns            = %d",     pfdg->cRuns);

    for (
        WCRUN *pwcr = pfdg->awcrun;
        pwcr < pfdg->awcrun + pfdg->cRuns;
        pwcr++
        )
    {
        vPrintWCRUN(pwcr);
    }
}

/******************************Public*Routine******************************\
* vPrintOUTLINETEXTMETRIC
*
* History:
*  Tue 08-Dec-1992 11:34:10 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID
vPrintOUTLINETEXTMETRICW(
    OUTLINETEXTMETRICW *p    )
{
    PANOSE *ppan = &(p->otmPanoseNumber);

    dprintf("    otmSize                = %d\n", p->otmSize                    );
    vPrintTEXTMETRICW(&(p->otmTextMetrics)                            );
    dprintf("    otmFiller              = %-#4x\n", p->otmFiller               );
    dprintf("    otmPanoseNumber        = {%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x}\n"
                                                 , ppan->bFamilyType
                                                 , ppan->bSerifStyle
                                                 , ppan->bWeight
                                                 , ppan->bProportion
                                                 , ppan->bContrast
                                                 , ppan->bStrokeVariation
                                                 , ppan->bArmStyle
                                                 , ppan->bLetterform
                                                 , ppan->bMidline
                                                 , ppan->bXHeight             );
    dprintf("    otmfsSelection         = %-#8lx\n", p->otmfsSelection         );
    dprintf("    otmfsType              = %-#8lx\n", p->otmfsType              );
    dprintf("    otmsCharSlopeRise      = %d\n"    , p->otmsCharSlopeRise      );
    dprintf("    otmsCharSlopeRun       = %d\n"    , p->otmsCharSlopeRun       );
    dprintf("    otmItalicAngle         = %d\n"    , p->otmItalicAngle         );
    dprintf("    otmEMSquare            = %d\n"    , p->otmEMSquare            );
    dprintf("    otmAscent              = %d\n"    , p->otmAscent              );
    dprintf("    otmDescent             = %d\n"    , p->otmDescent             );
    dprintf("    otmLineGap             = %d\n"    , p->otmLineGap             );
    dprintf("    otmsCapEmHeight        = %d\n"    , p->otmsCapEmHeight        );
    dprintf("    otmsXHeight            = %d\n"    , p->otmsXHeight            );
    dprintf("    otmrcFontBox           = %d %d %d %d\n"
                                                  , p->otmrcFontBox.left
                                                  , p->otmrcFontBox.top
                                                  , p->otmrcFontBox.right
                                                  , p->otmrcFontBox.bottom    );
    dprintf("    otmMacAscent           = %d\n"    , p->otmMacAscent           );
    dprintf("    otmMacDescent          = %d\n"    , p->otmMacDescent          );
    dprintf("    otmMacLineGap          = %d\n"    , p->otmMacLineGap          );
    dprintf("    otmusMinimumPPEM       = %d\n"    , p->otmusMinimumPPEM       );
    dprintf("    otmptSubscriptSize     = %d %d\n" , p->otmptSubscriptSize.x    , p->otmptSubscriptSize.y     );
    dprintf("    otmptSubscriptOffset   = %d %d\n" , p->otmptSubscriptOffset.x  , p->otmptSubscriptOffset.y   );
    dprintf("    otmptSuperscriptSize   = %d %d\n" , p->otmptSuperscriptSize.x  , p->otmptSuperscriptSize.y   );
    dprintf("    otmptSuperscriptOffset = %d %d\n" , p->otmptSuperscriptOffset.x, p->otmptSuperscriptOffset.y );
    dprintf("    otmsStrikeoutSize      = %d\n"    , p->otmsStrikeoutSize        );
    dprintf("    otmsStrikeoutPosition  = %d\n"    , p->otmsStrikeoutPosition    );
    dprintf("    otmsUnderscoreSize     = %d\n"    , p->otmsUnderscoreSize       );
    dprintf("    otmsUnderscorePosition = %d\n"    , p->otmsUnderscorePosition   );


    if (p->otmpFamilyName)
    {
        dprintf(
            "    otmpFamilyName         = \"%ws\"\n"   ,
            (WCHAR*) ((BYTE*)p + (ULONG)(ULONG_PTR) p->otmpFamilyName)
            );
    }

    if (p->otmpFaceName)
    {
        dprintf(
            "    otmpFaceName           = \"%ws\"\n"   ,
            (WCHAR*) ((BYTE*)p + (ULONG)(ULONG_PTR) p->otmpFaceName)
            );
    }

    if (p->otmpStyleName)
    {
        dprintf(
            "    otmpStyleName          = \"%ws\"\n"   ,
            (WCHAR*) ((BYTE*)p + (ULONG)(ULONG_PTR) p->otmpStyleName)
            );
    }

    if (p->otmpFullName)
    {
        dprintf(
            "    otmpFullName           = \"%ws\"\n"   ,
            (WCHAR*) ((BYTE*)p + (ULONG)(ULONG_PTR) p->otmpFullName)
            );
    }
}

/******************************Public*Routine******************************\
* vPrintPFE                                                                *
*                                                                          *
* Dumps the contents of a PFE to a specified output routine.               *
*                                                                          *
* History:                                                                 *
*  Sat 06-Jun-1992 21:19:31 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/
#ifdef FONTLINK
extern "C" VOID vPrintQUICKLOOKUP(QUICKLOOKUP *pql)
{
    dprintf("    ql.wcLow  = %-#x\n" , pql->wcLow);
    dprintf("    ql.wcHigh = %-#x\n" , pql->wcHigh);
    dprintf("    ql.puiBits = %-#x\n", pql->puiBits);
}
#endif

extern "C" VOID vPrintPFE(VOID *pv)
{
    PFE *ppfe = (PFE*) pv;
    ULONG *pul = (ULONG *)pv;

    dprintf("    ppfe                 = %-#x\n",ppfe               );
    dprintf("    pPFF                 = %-#x\n",ppfe->pPFF                );
    dprintf("    iFont                = %-#x\n",ppfe->iFont               );
    dprintf("    flPFE                = %-#x\n", ppfe->flPFE              );
    if (ppfe->flPFE & PFE_DEVICEFONT)
    dprintf("                           PFE_DEVICE_FONT\n");
    if (ppfe->flPFE & PFE_DEADSTATE)
    dprintf("                           PFE_DEADSTATE\n");
    if (ppfe->flPFE & PFE_UFIMATCH)
    dprintf("                           PFE_UFIMATCH\n");
#ifdef FONTLINK
    if (ppfe->flPFE & PFE_EUDC)
    dprintf("                           PFE_EUDC\n");
#endif
    if (ppfe->flPFE & ~(PFE_DEVICEFONT | PFE_DEADSTATE
#ifdef FONTLINK
          | PFE_EUDC
#endif
        ))
    dprintf("                           UNKNOWN FLAGS\n");

    dprintf("    pfdg                 = %-#x\n",ppfe->pfdg                );
    dprintf("    idfdg                = %-#x\n",ppfe->idfdg               );
    dprintf("    pifi                 = %-#x\n",ppfe->pifi                );
    dprintf("    idifi                = %-#x\n",ppfe->idifi               );
    dprintf("    pkp                  = %-#x\n",ppfe->pkp                 );
    dprintf("    ckp                  = %-#x\n",ppfe->ckp                 );
    dprintf("    iOrientation         = %-#x\n",ppfe->iOrientation        );

    dprintf("    pgiset               = %-#x\n",ppfe->pgiset              );

    dprintf("    ulTimeStamp          = %-#x\n",ppfe->ulTimeStamp         );

#ifdef FONTLINK
    vPrintQUICKLOOKUP(&(ppfe->ql));
    dprintf("    appfeFaceName        = %-#x\n",ppfe->appfeFaceName);
    dprintf("    bVerticalFace        = %-#x\n",ppfe->bVerticalFace);
#endif
}

/******************************Public*Routine******************************\
* vPrintGLYPHPOS                                                           *
*                                                                          *
* History:                                                                 *
*  Wed 23-Feb-1994 11:10:03 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

extern "C" VOID vPrintGLYPHPOS(
    const GLYPHPOS *pgpos
  ,       char     *pszLeft
    )
{
    dprintf("%shg   = %-#x\n",   pszLeft, pgpos->hg);
    dprintf("%spgdf = %-#x\n",   pszLeft, pgpos->pgdf);
    dprintf("%sptl  = (%d,%d)\n",pszLeft, pgpos->ptl.x, pgpos->ptl.y);
}

/******************************Public*Routine******************************\
* vPrintESTROBJ                                                            *
*                                                                          *
* History:                                                                 *
*  Wed 23-Feb-1994 11:09:38 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

extern "C" VOID vPrintESTROBJ(
    ESTROBJ *pso    // pointer to the engine string object
  , PWSZ pwszCopy   // pointer to a copy of the original string
                    //   this is necessary for the extensions
    )
{
    unsigned i,j;
    static char pszBorder[] = "-----------------------------\n\n";

    dprintf("%s",pszBorder);
    dprintf("ESTROBJ located at %-#x\n", pso);
    dprintf("\tcGlyphs     = %d\n", pso->cGlyphs);

    dprintf("\tflAccel     = %-#x\n", pso->flAccel);
    if (SO_FLAG_DEFAULT_PLACEMENT & pso->flAccel)
        dprintf("\t\tSO_FLAG_DEFAULT_PLACEMENT\n");
    if (SO_HORIZONTAL & pso->flAccel)
        dprintf("\t\tSO_HORIZONTAL\n");
    if (SO_VERTICAL & pso->flAccel)
        dprintf("\t\tSO_VERTICAL\n");
    if (SO_REVERSED & pso->flAccel)
        dprintf("\t\tSO_REVERSED\n");
    if (SO_ZERO_BEARINGS & pso->flAccel)
        dprintf("\t\tSO_ZERO_BEARINGS\n");
    if (SO_CHAR_INC_EQUAL_BM_BASE & pso->flAccel)
        dprintf("\t\tSO_CHAR_INC_EQUAL_BM_BASE\n");
    if (SO_MAXEXT_EQUAL_BM_SIDE & pso->flAccel)
        dprintf("\t\tSO_MAXEXT_EQUAL_BM_SIDE\n");

    dprintf("\tulCharInc   = %u\n", pso->ulCharInc);
    dprintf(
           "\trclBkGround = {(%d,%d),(%d,%d)}\n"
      , pso->rclBkGround.left
      , pso->rclBkGround.top
      , pso->rclBkGround.right
      , pso->rclBkGround.bottom
      );
    dprintf("\tpgp         = %-#x\n", pso->pgp        );
    dprintf("\tpwszOrg     = %-#x\n", pso->pwszOrg    );
    if (pwszCopy)
        dprintf("\t              \"%ws\"\n", pwszCopy   );

    dprintf("*** BEGIN GDI EXTENSION ***\n");
    dprintf("\tcgposCopied = %u\n",   pso->cgposCopied);
    dprintf("\tprfo        = %-#x\n", pso->prfo       );
    dprintf("\tflTO        = %-#x\n", pso->flTO);
    if (TO_MEM_ALLOCATED & pso->flTO)
        dprintf("\t\tTO_MEM_ALLOCATED\n");
    if (TO_ALL_PTRS_VALID & pso->flTO)
        dprintf("\t\tTO_ALL_PTRS_VALID\n");
    if (TO_VALID & pso->flTO)
        dprintf("\t\tTO_VALID\n");
    if (TO_ESC_NOT_ORIENT & pso->flTO)
        dprintf("\t\tTO_ESC_NOT_ORIENT\n");
    if (TO_PWSZ_ALLOCATED & pso->flTO)
        dprintf("\t\tTO_PWSZ_ALLOCATED\n");
    if (TO_HIGHRESTEXT & pso->flTO)
        dprintf("\t\tTO_HIGHRESTEXT\n");

    dprintf("\tpgpos       = %-#x\n", pso->pgpos);

    dprintf(
           "\tptfxRef     = (%-#x,%-#x)\n"
      , pso->ptfxRef.x
      , pso->ptfxRef.y
        );
    dprintf(
        "\tptfxUpdate  = (%-#x,%-#x)\n"
      , pso->ptfxUpdate.x
      , pso->ptfxUpdate.y
        );
    dprintf(
        "\tptfxEscapement  = (%-#x,%-#x)\n"
      , pso->ptfxEscapement.x
      , pso->ptfxEscapement.y
        );
    dprintf("\trcfx        = {(%-#x,%-#x)\t(%-#x,%-#x)}\n"
      , pso->rcfx.xLeft
      , pso->rcfx.yTop
      , pso->rcfx.xRight
      , pso->rcfx.yBottom
        );
    dprintf("\tfxExtent    = %-#x\n", pso->fxExtent);
    dprintf("\tcExtraRects = %u\n", pso->cExtraRects);
    if (pso->cExtraRects > 3)
    {
        dprintf("\n\n\t!!! Wow that is a LOT of rectangles !!!\n\n");
        dprintf("\t    I will just print 3, if you don't mind...\n\n\n");
        pso->cExtraRects = 3;
    }

    if (pso->cExtraRects)
    {
        dprintf("\tarclExtra   =\n");
        for (i = 0; i < pso->cExtraRects; i++)
        {
            dprintf("                (%d,%d)\t(%d,%d)\n"
              ,  pso->arclExtra[i].left
              ,  pso->arclExtra[i].top
              ,  pso->arclExtra[i].right
              ,  pso->arclExtra[i].bottom
                );
        }
    }
    dprintf("%s",pszBorder);
}

/******************************Public*Routine******************************\
* vPrintGLYPHBITS                                                          *
*                                                                          *
* History:                                                                 *
*  Wed 23-Feb-1994 10:58:33 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

extern "C" VOID vPrintGLYPHBITS(
    GLYPHBITS *pgb,
    char      *pszLeft
    )
{
    BYTE *pj, *pjNext, *pjEnd;
    ptrdiff_t cjScan;


    static char *apszNibble[] =
    {
        "    ", "   *", "  * ", "  **"
      , " *  ", " * *", " ** ", " ***"
      , "*   ", "*  *", "* * ", "* **"
      , "**  ", "** *", "*** ", "****"
    };

    dprintf("%sptlOrigin = (%d,%d)\n"
          , pszLeft
          , pgb->ptlOrigin.x
          , pgb->ptlOrigin.y
                );
    dprintf("%ssizlBitmap = (%d,%d)\n"
          , pszLeft
          , pgb->sizlBitmap.cx
          , pgb->sizlBitmap.cy
            );


    pj     = pgb->aj;
    cjScan = ((ptrdiff_t) pgb->sizlBitmap.cx + 7)/8;
    pjNext = pj + cjScan;
    pjEnd  = pj + cjScan * (ptrdiff_t) pgb->sizlBitmap.cy;

    dprintf("\n\n");

    {
        ptrdiff_t i = cjScan;
        dprintf("%s+",pszLeft);
        while (i--)
            dprintf("--------");
        dprintf("+\n");
    }
    while (pj < pjEnd)
    {
        dprintf("%s|",pszLeft);
        while (pj < pjNext)
        {
            dprintf(
                "%s%s"
              , apszNibble[(*pj >> 4) & 0xf]
              , apszNibble[*pj & 0xf]
              );
              pj += 1;
        }
        pj = pjNext;
        pjNext += cjScan;
        dprintf("|\n");
    }

    {
        ptrdiff_t i = cjScan;
        dprintf("%s+",pszLeft);
        while (i--)
            dprintf("--------");
        dprintf("+\n");
    }
    dprintf("\n\n");
}

/******************************Public*Routine******************************\
* vPrintGLYPHDEF
*
* History:
*  Thu 24-Feb-1994 11:17:10 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintGLYPHDEF(
    GLYPHDEF *pgdf
  , char     *pszLeft
  )
{    dprintf("%s(pgb|ppo) = %-#x\n", pszLeft, pgdf->pgb);
}

/******************************Public*Routine******************************\
* vPrintGLYPHDATA
*
* History:
*  Tue 17-May-1994 10:24:32 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" VOID vPrintGLYPHDATA(
    const GLYPHDATA *pgd
  ,       char     *pszLeft
    )
{
    dprintf("%sgdf           = %-#x\n", pszLeft, pgd->gdf);
    dprintf("%shg            = %-#x\n", pszLeft, pgd->hg);
    dprintf("%sptqD          = (%-#x.%08x,  %-#x.%08x)\n", pszLeft
     , pgd->ptqD.x.HighPart, pgd->ptqD.x.LowPart
     , pgd->ptqD.y.HighPart, pgd->ptqD.y.LowPart
    );
    dprintf("%sfxD           = %-#x\n", pszLeft, pgd->fxD);
    dprintf("%sfxA           = %-#x\n", pszLeft, pgd->fxA);
    dprintf("%sfxAB          = %-#x\n", pszLeft, pgd->fxAB);
    dprintf("%sfxInkTop      = %-#x\n", pszLeft, pgd->fxInkTop);
    dprintf("%sfxInkBottom   = %-#x\n", pszLeft, pgd->fxInkBottom);
    dprintf("%srclInk        = (%-#x, %-#x) (%-#x, %-#x) = (%d, %d) (%d, %d)\n"
        , pszLeft
        , pgd->rclInk.left,  pgd->rclInk.top
        , pgd->rclInk.right, pgd->rclInk.bottom
        , pgd->rclInk.left,  pgd->rclInk.top
        , pgd->rclInk.right, pgd->rclInk.bottom
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\inc\mapfile.h ===
/******************************Module*Header*******************************\
* Module Name: mapfile.h
*
* Created: 26-Oct-1990 18:07:56
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/


// warning the first two fields of FILEVIEW and FONTFILE view must be
// the same so that they can be used in common routines

typedef struct _FILEVIEW {
    LARGE_INTEGER  LastWriteTime;   // time stamp
            PVOID  pvKView;         // for kernel mode font access
            PVOID  pvViewFD;        // font driver process view of file
            ULONG  cjView;          // size of font file view in bytes
             void *pSection;        // kernel mode pointer to the section object
            BOOL   bLastUpdated;    // Add this for the bug #383101
} FILEVIEW, *PFILEVIEW;

typedef struct _FONTFILEVIEW {
    FILEVIEW  fv;
      LPWSTR  pwszPath;            // path of the file
      SIZE_T  ulRegionSize;        // used by ZwFreeVirtualMemory
       ULONG  cKRefCount;          // kernel mode load count
       ULONG  cRefCountFD;         // font driver load count
       PVOID  SpoolerBase;         // base of spooler's view of spooler section
      W32PID  SpoolerPid;          // spooler pid
} FONTFILEVIEW, *PFONTFILEVIEW;

#define FONTFILEVIEW_bRemote(p) (((FONTFILEVIEW*)(p))->pwszPath==0)

//moved from "engine.h"

typedef struct tagDOWNLOADFONTHEADER
{
    ULONG   Type1ID;          // if non-zero then this is a remote Type1 font
    ULONG   NumFiles;
    ULONG   FileOffsets[1];
}DOWNLOADFONTHEADER,*PDOWNLOADFONTHEADER;


// file mapping


BOOL bMapFile(
        PWSTR pwszFileName,
    PFILEVIEW pfvw,
          INT iFileSize,
        BOOL *pbIsFAT
    );

VOID vUnmapFile( PFILEVIEW pfvw );

INT cComputeGlyphSet(
          WCHAR  *pwc,       // input buffer with a sorted array of cChar supported WCHAR's
           BYTE  *pj,        // input buffer with original ansi values
            INT   cChar,
            INT   cRuns,     // if nonzero, the same as return value
    FD_GLYPHSET  *pgset      // output buffer to be filled with cRanges runs
    );

INT cUnicodeRangesSupported(
      INT  cp,          // code page, not used for now, the default system code page is used
      INT  iFirstChar,  // first ansi char supported
      INT  cChar,       // # of ansi chars supported, cChar = iLastChar + 1 - iFirstChar
    WCHAR *pwc,         // input buffer with a sorted array of cChar supported WCHAR's
     BYTE *pj
    );

// size of glyphset with runs and glyph handles appended at the bottom

#define SZ_GLYPHSET(cRuns, cGlyphs) \
   (offsetof(FD_GLYPHSET,awcrun)    \
 + sizeof(WCRUN)*(cRuns)            \
 + sizeof(HGLYPH)*(cGlyphs))

//
// WINBUG #83140 2-7-2000 bhouse Investgate removal of vToUNICODEN macro
// Old Comment:
//   - bogus macro that we need to remove.
//

#define vToUNICODEN( pwszDst, cwch, pszSrc, cch )                               \
    {                                                                           \
        EngMultiByteToUnicodeN((LPWSTR)(pwszDst),(ULONG)((cwch)*sizeof(WCHAR)), \
               (PULONG)NULL,(PSZ)(pszSrc),(ULONG)(cch));                        \
        (pwszDst)[(cwch)-1] = 0;                                                \
    }


typedef struct _CP_GLYPHSET {
    UINT                 uiRefCount;      // Number of references to this FD_GLYPHSET
    UINT                 uiFirstChar;     // First char supported
    UINT                 uiLastChar;      // Last char supported
    BYTE                 jCharset;        // charset
    struct _CP_GLYPHSET *pcpNext;         // Next element in list
    FD_GLYPHSET          gset;            // The actual glyphset

} CP_GLYPHSET;


CP_GLYPHSET
*pcpComputeGlyphset(
    CP_GLYPHSET **pcpHead,
    UINT         uiFirst,
    UINT         uiLast,
    BYTE         jCharSet
    );

VOID
vUnloadGlyphset(
    CP_GLYPHSET **pcpHead,
    CP_GLYPHSET  *pcpTarget
    );


// needed in font substitutions

// FACE_CHARSET structure represents either value name or the value data
// of an entry in the font substitution section of "win.ini".

// this flag describes one of the old style entries where char set is not
// specified.

#define FJ_NOTSPECIFIED    1

// this flag indicates that the charset is not one of those that the
// system knows about. Could be garbage or application defined charset.

#define FJ_GARBAGECHARSET  2

typedef struct _FACE_CHARSET {
    WCHAR awch[LF_FACESIZE];
     BYTE jCharSet;
     BYTE fjFlags;
} FACE_CHARSET;


VOID vCheckCharSet(FACE_CHARSET *pfcs, WCHAR * pwsz); // in mapfile.c


#define IS_DBCS_CHARSET(CharSet)  (((CharSet) == DBCS_CHARSET) ? TRUE : FALSE)

#define IS_ANY_DBCS_CHARSET( CharSet )                              \
                   ( ((CharSet) == SHIFTJIS_CHARSET)    ? TRUE :    \
                     ((CharSet) == HANGEUL_CHARSET)     ? TRUE :    \
                     ((CharSet) == CHINESEBIG5_CHARSET) ? TRUE :    \
                     ((CharSet) == GB2312_CHARSET)      ? TRUE : FALSE )


#define IS_ANY_DBCS_CODEPAGE( CodePage ) (((CodePage) == 932) ? TRUE :    \
                                          ((CodePage) == 949) ? TRUE :    \
                                          ((CodePage) == 950) ? TRUE :    \
                                          ((CodePage) == 936) ? TRUE : FALSE )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\inc\ntgdi.h ===
/******************************Module*Header*******************************\
* Module Name: ntgdi.h
*
* Structures defining kernel-mode entry points for GDI.
*
* Copyright (c) 1994-1999 Microsoft Corporation
\**************************************************************************/

#ifndef W32KAPI
#define W32KAPI  DECLSPEC_ADDRSAFE
#endif

// Trace creation of all GDI SURFACE objects
#define TRACE_SURFACE_ALLOCS    (DBG || 1)


// PRIVATE

W32KAPI BOOL     APIENTRY NtGdiInit();
W32KAPI int      APIENTRY NtGdiSetDIBitsToDeviceInternal(IN HDC hdcDest,IN int xDst,IN int yDst,IN DWORD cx,IN DWORD cy,
                                                         IN int xSrc,IN int ySrc,IN DWORD iStartScan,IN DWORD cNumScan,
                                                         IN LPBYTE pInitBits,IN LPBITMAPINFO pbmi,IN DWORD iUsage,
                                                         IN UINT cjMaxBits,IN UINT cjMaxInfo,IN BOOL bTransformCoordinates,
                                                         IN HANDLE hcmXform);
W32KAPI BOOL     APIENTRY NtGdiGetFontResourceInfoInternalW(IN LPWSTR pwszFiles,IN ULONG cwc,IN ULONG cFiles,IN UINT cjIn,
                                                            OUT LPDWORD pdwBytes,OUT LPVOID pvBuf,IN DWORD iType);
W32KAPI DWORD    APIENTRY NtGdiGetGlyphIndicesW(IN HDC hdc,IN LPWSTR pwc,IN int cwc,OUT LPWORD pgi,IN DWORD iMode);
W32KAPI DWORD    APIENTRY NtGdiGetGlyphIndicesWInternal(IN HDC hdc,IN LPWSTR pwc,IN int cwc,OUT LPWORD pgi,IN DWORD iMode, BOOL bSubset);
W32KAPI HPALETTE APIENTRY NtGdiCreatePaletteInternal(IN LPLOGPALETTE pLogPal,IN UINT cEntries);
W32KAPI BOOL     APIENTRY NtGdiArcInternal(IN ARCTYPE arctype,IN HDC hdc,IN int x1,IN int y1,IN int x2,IN int y2,IN int x3,
                                           IN int y3,IN int x4,IN int y4);
W32KAPI int      APIENTRY NtGdiStretchDIBitsInternal(IN HDC hdc,IN int xDst,IN int yDst,IN int cxDst,IN int cyDst,IN int xSrc,
                                                     IN int ySrc,IN int cxSrc,IN int cySrc,IN LPBYTE pjInit,IN LPBITMAPINFO pbmi,
                                                     IN DWORD dwUsage,IN DWORD dwRop4,IN UINT cjMaxInfo,IN UINT cjMaxBits,IN HANDLE hcmXform);
W32KAPI ULONG    APIENTRY NtGdiGetOutlineTextMetricsInternalW(IN HDC hdc,IN ULONG cjotm,OUT OUTLINETEXTMETRICW *potmw,
                                                              OUT TMDIFF *ptmd);
W32KAPI BOOL     APIENTRY NtGdiGetAndSetDCDword(IN HDC hdc,IN UINT u,IN DWORD dwIn,OUT DWORD *pdwResult);
W32KAPI HANDLE   APIENTRY NtGdiGetDCObject(IN HDC hdc,IN int itype);
W32KAPI HDC      APIENTRY NtGdiGetDCforBitmap(IN HBITMAP hsurf);

W32KAPI BOOL     APIENTRY NtGdiGetMonitorID(IN HDC hdc, IN DWORD dwSize, OUT LPWSTR pszMonitorID);

// flags returned from GetUFI and passed to GetUFIBits
#define FL_UFI_PRIVATEFONT      1
#define FL_UFI_DESIGNVECTOR_PFF 2
#define FL_UFI_MEMORYFONT       4

W32KAPI INT      APIENTRY NtGdiGetLinkedUFIs(IN HDC hdc,OUT PUNIVERSAL_FONT_ID pufiLinkedUFIs,IN INT BufferSize);
W32KAPI BOOL     APIENTRY NtGdiSetLinkedUFIs(IN HDC hdc,IN PUNIVERSAL_FONT_ID pufiLinks,IN ULONG uNumUFIs);
W32KAPI BOOL     APIENTRY NtGdiGetUFI(IN HDC hdc,OUT PUNIVERSAL_FONT_ID pufi,OUT DESIGNVECTOR *pdv,OUT ULONG *pcjDV,
                                      OUT ULONG *pulBaseCheckSum,OUT FLONG  *pfl);
W32KAPI BOOL     APIENTRY NtGdiForceUFIMapping(IN HDC hdc,IN PUNIVERSAL_FONT_ID pufi);
        BOOL     APIENTRY NtGdiGetUFIBits(IN PUNIVERSAL_FONT_ID pufi, IN ULONG cjMaxBytes, OUT PVOID pjBits,
                                          OUT PULONG pulFileSize,IN FLONG  fl);
W32KAPI BOOL     APIENTRY NtGdiGetUFIPathname(IN PUNIVERSAL_FONT_ID pufi,OUT ULONG* pcwc,OUT LPWSTR pwszPathname,
                                              OUT ULONG* pcNumFiles, IN FLONG fl, OUT BOOL *pbMemFont, OUT ULONG *pcjView,
                                              OUT PVOID pvView, OUT BOOL  *pbTTC, OUT ULONG *piTTC);
W32KAPI BOOL     APIENTRY NtGdiAddRemoteFontToDC(IN HDC hdc,IN PVOID pvBuffer, IN ULONG cjBuffer,IN PUNIVERSAL_FONT_ID pufi);
W32KAPI HANDLE   APIENTRY NtGdiAddFontMemResourceEx(IN PVOID pvBuffer,IN DWORD cjBuffer,IN DESIGNVECTOR *pdv,IN ULONG cjDV,
                                                    OUT DWORD *pNumFonts);
W32KAPI BOOL     APIENTRY NtGdiRemoveFontMemResourceEx(IN HANDLE hMMFont);
W32KAPI BOOL     APIENTRY NtGdiUnmapMemFont(IN PVOID pvView);
W32KAPI BOOL     APIENTRY NtGdiRemoveMergeFont(IN HDC hdc,IN UNIVERSAL_FONT_ID *pufi);
W32KAPI BOOL     APIENTRY NtGdiAnyLinkedFonts();

// local printing with embedded fonts

W32KAPI BOOL     APIENTRY NtGdiGetEmbUFI(IN HDC hdc,OUT PUNIVERSAL_FONT_ID pufi,OUT DESIGNVECTOR *pdv,OUT ULONG *pcjDV,
                                      OUT ULONG *pulBaseCheckSum,OUT FLONG  *pfl, OUT KERNEL_PVOID *embFontID);
W32KAPI ULONG   APIENTRY  NtGdiGetEmbedFonts();
W32KAPI BOOL    APIENTRY  NtGdiChangeGhostFont(IN KERNEL_PVOID *pfontID, IN BOOL bLoad);
W32KAPI BOOL    APIENTRY  NtGdiAddEmbFontToDC(IN HDC hdc, IN VOID **pFontID);

W32KAPI BOOL     APIENTRY NtGdiFontIsLinked(IN HDC hdc);
W32KAPI ULONG_PTR APIENTRY NtGdiPolyPolyDraw(IN HDC hdc,IN PPOINT ppt,IN PULONG pcpt,IN ULONG ccpt,IN int iFunc);
W32KAPI LONG     APIENTRY NtGdiDoPalette(IN HPALETTE hpal,IN WORD iStart,IN WORD cEntries,IN PALETTEENTRY *pPalEntries,
                                         IN DWORD iFunc,IN BOOL bInbound);
W32KAPI BOOL     APIENTRY NtGdiComputeXformCoefficients(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiGetWidthTable(IN HDC hdc,IN ULONG cSpecial,IN WCHAR *pwc,IN ULONG cwc,OUT USHORT *psWidth,
                                             OUT WIDTHDATA *pwd, OUT FLONG *pflInfo);
W32KAPI int      APIENTRY NtGdiDescribePixelFormat(IN HDC hdc,IN int ipfd,IN UINT cjpfd,OUT PPIXELFORMATDESCRIPTOR ppfd);
W32KAPI BOOL     APIENTRY NtGdiSetPixelFormat(IN HDC hdc,IN int ipfd);
W32KAPI BOOL     APIENTRY NtGdiSwapBuffers(IN HDC hdc);
W32KAPI int      APIENTRY NtGdiSetupPublicCFONT(IN HDC hdc,IN HFONT hf,IN ULONG ulAve);


W32KAPI DWORD  APIENTRY NtGdiDxgGenericThunk(IN ULONG_PTR ulIndex,
                                             IN ULONG_PTR ulHandle,
                                             IN OUT SIZE_T *pdwSizeOfPtr1,
                                             IN OUT PVOID pvPtr1,
                                             IN OUT SIZE_T *pdwSizeOfPtr2,
                                             IN OUT PVOID pvPtr2);
W32KAPI DWORD    APIENTRY NtGdiDdAddAttachedSurface(IN HANDLE hSurface,IN HANDLE hSurfaceAttached,
                                                    IN OUT PDD_ADDATTACHEDSURFACEDATA puAddAttachedSurfaceData);
W32KAPI BOOL     APIENTRY NtGdiDdAttachSurface(IN HANDLE  hSurfaceFrom, IN HANDLE  hSurfaceTo);
W32KAPI DWORD    APIENTRY NtGdiDdBlt(IN HANDLE hSurfaceDest,IN HANDLE hSurfaceSrc,IN OUT PDD_BLTDATA puBltData);
W32KAPI DWORD    APIENTRY NtGdiDdCanCreateSurface(IN HANDLE hDirectDraw,IN OUT PDD_CANCREATESURFACEDATA puCanCreateSurfaceData);
W32KAPI DWORD    APIENTRY NtGdiDdColorControl(IN HANDLE hSurface,IN OUT PDD_COLORCONTROLDATA puColorControlData);
W32KAPI HANDLE   APIENTRY NtGdiDdCreateDirectDrawObject(IN HDC hdc);
W32KAPI DWORD    APIENTRY NtGdiDdCreateSurface(IN HANDLE hDirectDraw,IN HANDLE* hSurface,
                                               IN OUT DDSURFACEDESC* puSurfaceDescription,
                                               IN OUT DD_SURFACE_GLOBAL* puSurfaceGlobalData,
                                               IN OUT DD_SURFACE_LOCAL* puSurfaceLocalData,
                                               IN OUT DD_SURFACE_MORE* puSurfaceMoreData,
                                               IN OUT DD_CREATESURFACEDATA* puCreateSurfaceData,
                                               OUT HANDLE* puhSurface);
W32KAPI HANDLE   APIENTRY NtGdiDdCreateSurfaceObject(IN HANDLE hDirectDrawLocal,IN HANDLE hSurface,IN PDD_SURFACE_LOCAL puSurfaceLocal,
                                                     IN PDD_SURFACE_MORE puSurfaceMore, IN PDD_SURFACE_GLOBAL puSurfaceGlobal,IN BOOL bComplete);
W32KAPI BOOL     APIENTRY NtGdiDdDeleteSurfaceObject(IN HANDLE hSurface);
W32KAPI BOOL     APIENTRY NtGdiDdDeleteDirectDrawObject(HANDLE hDirectDrawLocal);
W32KAPI DWORD    APIENTRY NtGdiDdDestroySurface(IN HANDLE hSurface, IN BOOL bRealDestroy);
        HANDLE   APIENTRY NtGdiDdDuplicateSurface(IN HANDLE hSurface);
W32KAPI DWORD    APIENTRY NtGdiDdFlip(IN HANDLE hSurfaceCurrent,IN HANDLE hSurfaceTarget,IN HANDLE hSurfaceCurrentLeft,IN HANDLE hSurfaceTargetLeft,IN OUT PDD_FLIPDATA puFlipData);
W32KAPI DWORD    APIENTRY NtGdiDdGetAvailDriverMemory(IN HANDLE hDirectDraw, IN OUT PDD_GETAVAILDRIVERMEMORYDATA puGetAvailDriverMemoryData);
W32KAPI DWORD    APIENTRY NtGdiDdGetBltStatus(IN HANDLE hSurface,IN OUT PDD_GETBLTSTATUSDATA puGetBltStatusData);
W32KAPI HDC      APIENTRY NtGdiDdGetDC(IN HANDLE hSurface,IN PALETTEENTRY* puColorTable);
W32KAPI DWORD    APIENTRY NtGdiDdGetDriverInfo(IN HANDLE hDirectDraw, IN OUT PDD_GETDRIVERINFODATA puGetDriverInfoData);
W32KAPI DWORD    APIENTRY NtGdiDdGetFlipStatus(IN HANDLE hSurface,IN OUT PDD_GETFLIPSTATUSDATA puGetFlipStatusData);
W32KAPI DWORD    APIENTRY NtGdiDdGetScanLine(IN HANDLE hDirectDraw, IN OUT PDD_GETSCANLINEDATA puGetScanLineData);
W32KAPI DWORD    APIENTRY NtGdiDdSetExclusiveMode(IN HANDLE hDirectDraw,IN OUT PDD_SETEXCLUSIVEMODEDATA puSetExclusiveModeData);
W32KAPI DWORD    APIENTRY NtGdiDdFlipToGDISurface(IN HANDLE hDirectDraw,IN OUT PDD_FLIPTOGDISURFACEDATA puFlipToGDISurfaceData);
W32KAPI DWORD    APIENTRY NtGdiDdLock(IN HANDLE hSurface,IN OUT PDD_LOCKDATA puLockData,IN HDC hdcClip);
W32KAPI BOOL     APIENTRY NtGdiDdQueryDirectDrawObject(IN HANDLE,OUT PDD_HALINFO,DWORD*,OUT LPD3DNTHAL_CALLBACKS,OUT LPD3DNTHAL_GLOBALDRIVERDATA,OUT PDD_D3DBUFCALLBACKS,OUT LPDDSURFACEDESC,OUT DWORD*,OUT VIDEOMEMORY*,OUT DWORD*,OUT DWORD*);
W32KAPI BOOL     APIENTRY NtGdiDdReenableDirectDrawObject(IN HANDLE hDirectDrawLocal,IN OUT BOOL* pubNewMode);
W32KAPI BOOL     APIENTRY NtGdiDdReleaseDC(IN HANDLE hSurface);
W32KAPI BOOL     APIENTRY NtGdiDdResetVisrgn(IN HANDLE hSurface,IN HWND hwnd);
W32KAPI DWORD    APIENTRY NtGdiDdSetColorKey(IN HANDLE hSurface,IN OUT PDD_SETCOLORKEYDATA puSetColorKeyData);
W32KAPI DWORD    APIENTRY NtGdiDdSetOverlayPosition(IN HANDLE hSurfaceSource,IN HANDLE hSurfaceDestination,
                                                    IN OUT PDD_SETOVERLAYPOSITIONDATA puSetOverlayPositionData);
W32KAPI VOID     APIENTRY NtGdiDdUnattachSurface(IN HANDLE hSurface,IN HANDLE hSurfaceAttached);
W32KAPI DWORD    APIENTRY NtGdiDdUnlock(IN HANDLE hSurface,IN OUT PDD_UNLOCKDATA puUnlockData);
W32KAPI DWORD    APIENTRY NtGdiDdUpdateOverlay(IN HANDLE hSurfaceDestination, IN HANDLE hSurfaceSource,
                                               IN OUT PDD_UPDATEOVERLAYDATA puUpdateOverlayData);
W32KAPI DWORD    APIENTRY NtGdiDdWaitForVerticalBlank(IN HANDLE hDirectDraw,IN OUT PDD_WAITFORVERTICALBLANKDATA puWaitForVerticalBlankData);
W32KAPI HANDLE   APIENTRY NtGdiDdGetDxHandle(IN HANDLE hDirectDraw,IN HANDLE hSurface,IN BOOL bRelease);
W32KAPI BOOL     APIENTRY NtGdiDdSetGammaRamp(IN HANDLE hDirectDraw,IN HDC hdc,IN LPVOID lpGammaRamp);


W32KAPI DWORD    APIENTRY NtGdiDdLockD3D(IN HANDLE hSurface,IN OUT PDD_LOCKDATA puLockData);
W32KAPI DWORD    APIENTRY NtGdiDdUnlockD3D(IN HANDLE hSurface, IN OUT PDD_UNLOCKDATA puUnlockData);
W32KAPI DWORD    APIENTRY NtGdiDdCreateD3DBuffer(HANDLE hDirectDraw, HANDLE* hSurface, IN OUT DDSURFACEDESC* puSurfaceDescription,
                                                 IN OUT DD_SURFACE_GLOBAL* puSurfaceGlobalData, IN OUT DD_SURFACE_LOCAL* puSurfaceLocalData,
                                                 IN OUT DD_SURFACE_MORE* puSurfaceMoreData, IN OUT DD_CREATESURFACEDATA* puCreateSurfaceData,
                                                 IN OUT HANDLE* puhSurface);
W32KAPI DWORD    APIENTRY NtGdiDdCanCreateD3DBuffer(IN HANDLE hDirectDraw,IN OUT PDD_CANCREATESURFACEDATA puCanCreateSurfaceData);
W32KAPI DWORD    APIENTRY NtGdiDdDestroyD3DBuffer(IN HANDLE hSurface);
W32KAPI DWORD    APIENTRY NtGdiD3dContextCreate(IN HANDLE hDirectDrawLocal,IN HANDLE hSurfColor,IN HANDLE hSurfZ,
                                                IN OUT D3DNTHAL_CONTEXTCREATEI *pdcci);

W32KAPI DWORD    APIENTRY NtGdiD3dContextDestroy(LPD3DNTHAL_CONTEXTDESTROYDATA);

W32KAPI DWORD    APIENTRY NtGdiD3dContextDestroyAll(OUT LPD3DNTHAL_CONTEXTDESTROYALLDATA pdcdad);

W32KAPI DWORD    APIENTRY NtGdiD3dValidateTextureStageState(IN OUT LPD3DNTHAL_VALIDATETEXTURESTAGESTATEDATA pData);
W32KAPI DWORD    APIENTRY NtGdiD3dDrawPrimitives2(IN HANDLE hCmdBuf, IN HANDLE hVBuf, IN OUT LPD3DNTHAL_DRAWPRIMITIVES2DATA pded,
                                                  IN OUT FLATPTR* pfpVidMemCmd, IN OUT DWORD* pdwSizeCmd, IN OUT FLATPTR* pfpVidMemVtx,
                                                  IN OUT DWORD* pdwSizeVtx);
W32KAPI DWORD    APIENTRY NtGdiDdGetDriverState(IN OUT PDD_GETDRIVERSTATEDATA pdata);
W32KAPI DWORD    APIENTRY NtGdiDdCreateSurfaceEx(IN HANDLE hDirectDraw, IN HANDLE hSurface,IN DWORD dwSurfaceHandle);
W32KAPI DWORD    APIENTRY NtGdiDvpCanCreateVideoPort(IN HANDLE hDirectDraw, IN OUT PDD_CANCREATEVPORTDATA puCanCreateVPortData);
W32KAPI DWORD    APIENTRY NtGdiDvpColorControl(IN HANDLE hVideoPort,IN OUT PDD_VPORTCOLORDATA puVPortColorData);
W32KAPI HANDLE   APIENTRY NtGdiDvpCreateVideoPort(IN HANDLE hDirectDraw,IN OUT PDD_CREATEVPORTDATA puCreateVPortData);
W32KAPI DWORD    APIENTRY NtGdiDvpDestroyVideoPort(IN HANDLE hVideoPort,IN OUT PDD_DESTROYVPORTDATA puDestroyVPortData);
W32KAPI DWORD    APIENTRY NtGdiDvpFlipVideoPort(IN HANDLE hVideoPort,IN HANDLE hDDSurfaceCurrent,IN HANDLE hDDSurfaceTarget,
                                                IN OUT PDD_FLIPVPORTDATA puFlipVPortData);
W32KAPI DWORD    APIENTRY NtGdiDvpGetVideoPortBandwidth(IN HANDLE hVideoPort, IN OUT PDD_GETVPORTBANDWIDTHDATA puGetVPortBandwidthData);
W32KAPI DWORD    APIENTRY NtGdiDvpGetVideoPortField(IN HANDLE hVideoPort,IN OUT PDD_GETVPORTFIELDDATA puGetVPortFieldData);
W32KAPI DWORD    APIENTRY NtGdiDvpGetVideoPortFlipStatus(IN HANDLE hDirectDraw,IN OUT PDD_GETVPORTFLIPSTATUSDATA puGetVPortFlipStatusData);
W32KAPI DWORD    APIENTRY NtGdiDvpGetVideoPortInputFormats(IN HANDLE hVideoPort, IN OUT PDD_GETVPORTINPUTFORMATDATA puGetVPortInputFormatData);
W32KAPI DWORD    APIENTRY NtGdiDvpGetVideoPortLine(IN HANDLE hVideoPort,IN OUT PDD_GETVPORTLINEDATA puGetVPortLineData);
W32KAPI DWORD    APIENTRY NtGdiDvpGetVideoPortOutputFormats(IN HANDLE hVideoPort,IN OUT PDD_GETVPORTOUTPUTFORMATDATA puGetVPortOutputFormatData);
W32KAPI DWORD    APIENTRY NtGdiDvpGetVideoPortConnectInfo(IN HANDLE hDirectDraw,IN OUT PDD_GETVPORTCONNECTDATA puGetVPortConnectData);
W32KAPI DWORD    APIENTRY NtGdiDvpGetVideoSignalStatus(IN HANDLE hVideoPort,IN OUT PDD_GETVPORTSIGNALDATA puGetVPortSignalData);
W32KAPI DWORD    APIENTRY NtGdiDvpUpdateVideoPort(IN HANDLE hVideoPort, IN HANDLE* phSurfaceVideo,IN HANDLE* phSurfaceVbi,IN OUT PDD_UPDATEVPORTDATA puUpdateVPortData);
W32KAPI DWORD    APIENTRY NtGdiDvpWaitForVideoPortSync(IN HANDLE hVideoPort,IN OUT PDD_WAITFORVPORTSYNCDATA puWaitForVPortSyncData);
W32KAPI DWORD    APIENTRY NtGdiDvpAcquireNotification(IN HANDLE hVideoPort,IN OUT HANDLE* hEvent,IN LPDDVIDEOPORTNOTIFY pNotify);
W32KAPI DWORD    APIENTRY NtGdiDvpReleaseNotification(IN HANDLE hVideoPort,IN HANDLE hEvent);

W32KAPI DWORD    APIENTRY NtGdiDdGetMoCompGuids(IN HANDLE hDirectDraw,IN OUT PDD_GETMOCOMPGUIDSDATA puGetMoCompGuidsData);
W32KAPI DWORD    APIENTRY NtGdiDdGetMoCompFormats(IN HANDLE hDirectDraw,IN OUT PDD_GETMOCOMPFORMATSDATA puGetMoCompFormatsData);
W32KAPI DWORD    APIENTRY NtGdiDdGetMoCompBuffInfo(IN HANDLE hDirectDraw,IN OUT PDD_GETMOCOMPCOMPBUFFDATA puGetBuffData);
W32KAPI DWORD    APIENTRY NtGdiDdGetInternalMoCompInfo(IN HANDLE hDirectDraw,IN OUT PDD_GETINTERNALMOCOMPDATA puGetInternalData);
W32KAPI HANDLE   APIENTRY NtGdiDdCreateMoComp(IN HANDLE hDirectDraw,IN OUT PDD_CREATEMOCOMPDATA puCreateMoCompData);
W32KAPI DWORD    APIENTRY NtGdiDdDestroyMoComp(IN HANDLE hMoComp,IN OUT PDD_DESTROYMOCOMPDATA puDestroyMoCompData);
W32KAPI DWORD    APIENTRY NtGdiDdBeginMoCompFrame(IN HANDLE hMoComp, IN OUT PDD_BEGINMOCOMPFRAMEDATA puBeginFrameData);
W32KAPI DWORD    APIENTRY NtGdiDdEndMoCompFrame(IN HANDLE hMoComp,IN OUT PDD_ENDMOCOMPFRAMEDATA  puEndFrameData);
W32KAPI DWORD    APIENTRY NtGdiDdRenderMoComp(IN HANDLE hMoComp,IN OUT PDD_RENDERMOCOMPDATA puRenderMoCompData);
W32KAPI DWORD    APIENTRY NtGdiDdQueryMoCompStatus(IN OUT HANDLE hMoComp,IN OUT PDD_QUERYMOCOMPSTATUSDATA puQueryMoCompStatusData);

W32KAPI DWORD    APIENTRY NtGdiDdAlphaBlt(IN HANDLE hSurfaceDest, IN HANDLE hSurfaceSrc,IN OUT PDD_BLTDATA puBltData);

// Image32

W32KAPI BOOL     APIENTRY NtGdiAlphaBlend(IN HDC hdcDst, IN LONG DstX,IN LONG DstY,IN LONG DstCx,IN LONG DstCy,IN HDC hdcSrc,
                                          IN LONG SrcX,IN LONG SrcY, IN LONG SrcCx, IN LONG SrcCy, IN BLENDFUNCTION BlendFunction,
                                          IN HANDLE hcmXform);
W32KAPI BOOL     APIENTRY NtGdiGradientFill(IN HDC hdc,IN PTRIVERTEX pVertex,IN ULONG uVertex,IN PVOID pMesh,IN ULONG uMesh,IN ULONG ulMode);

// icm (Image Color Matching)
W32KAPI BOOL     APIENTRY NtGdiSetIcmMode(IN HDC hdc,IN ULONG nCommand,IN ULONG ulMode);

#define ICM_SET_MODE             1
#define ICM_SET_CALIBRATE_MODE   2
#define ICM_SET_COLOR_MODE       3
#define ICM_CHECK_COLOR_MODE     4

typedef struct _LOGCOLORSPACEEXW
{
    LOGCOLORSPACEW lcsColorSpace;
    DWORD          dwFlags;
} LOGCOLORSPACEEXW, *PLOGCOLORSPACEEXW;

#define LCSEX_ANSICREATED    0x0001 // Created by CreateColorSpaceA()
#define LCSEX_TEMPPROFILE    0x0002 // Color profile is temporary file

W32KAPI HANDLE   APIENTRY NtGdiCreateColorSpace(IN PLOGCOLORSPACEEXW pLogColorSpace);
W32KAPI BOOL     APIENTRY NtGdiDeleteColorSpace(IN HANDLE hColorSpace);
W32KAPI BOOL     APIENTRY NtGdiSetColorSpace(IN HDC hdc,IN HCOLORSPACE hColorSpace);

W32KAPI HANDLE   APIENTRY NtGdiCreateColorTransform(IN HDC hdc,IN LPLOGCOLORSPACEW pLogColorSpaceW,IN PVOID pvSrcProfile,
                                                    IN ULONG cjSrcProfile,IN PVOID pvDestProfile, IN ULONG cjDestProfile,
                                                    IN PVOID pvTargetProfile, IN ULONG cjTargetProfile);
W32KAPI BOOL     APIENTRY NtGdiDeleteColorTransform(IN HDC hdc, IN HANDLE hColorTransform);
W32KAPI BOOL     APIENTRY NtGdiCheckBitmapBits(IN HDC hdc,IN HANDLE hColorTransform,IN PVOID pvBits, IN ULONG bmFormat,
                                               IN DWORD dwWidth, IN DWORD dwHeight,IN DWORD dwStride,OUT PBYTE paResults);

W32KAPI ULONG    APIENTRY NtGdiColorCorrectPalette(IN HDC hdc,IN HPALETTE hpal,IN ULONG FirstEntry,IN ULONG NumberOfEntries,
                                                   IN OUT PALETTEENTRY *ppalEntry,IN ULONG);

W32KAPI ULONG_PTR APIENTRY NtGdiGetColorSpaceforBitmap(IN HBITMAP hsurf);

typedef enum _COLORPALETTEINFO
{
    ColorPaletteQuery,
    ColorPaletteSet
} COLORPALETTEINFO, *PCOLORPALETTEINFO;

W32KAPI BOOL     APIENTRY NtGdiGetDeviceGammaRamp(IN HDC hdc, OUT LPVOID lpGammaRamp);
W32KAPI BOOL     APIENTRY NtGdiSetDeviceGammaRamp(IN HDC hdc, IN LPVOID  lpGammaRamp);

W32KAPI BOOL     APIENTRY NtGdiIcmBrushInfo(IN HDC hdc,IN HBRUSH hbrush,IN OUT PBITMAPINFO pbmiDIB, IN OUT PVOID pvBits,
                                            IN OUT ULONG *pulBits, OUT DWORD *piUsage, OUT BOOL *pbAlreadyTran, IN ULONG Command);

typedef enum _ICM_DIB_INFO_CMD
{
    IcmQueryBrush,
    IcmSetBrush
} ICM_DIB_INFO, *PICM_DIB_INFO;

// PUBLIC

W32KAPI VOID     APIENTRY NtGdiFlush();
W32KAPI HDC      APIENTRY NtGdiCreateMetafileDC(IN HDC hdc);

W32KAPI BOOL     APIENTRY NtGdiMakeInfoDC(IN HDC hdc, IN BOOL bSet);
W32KAPI HANDLE   APIENTRY NtGdiCreateClientObj(IN ULONG ulType);
W32KAPI BOOL     APIENTRY NtGdiDeleteClientObj(IN HANDLE h);

W32KAPI LONG     APIENTRY NtGdiGetBitmapBits(IN HBITMAP hbm, IN ULONG cjMax, OUT PBYTE pjOut);

W32KAPI BOOL     APIENTRY NtGdiDeleteObjectApp(IN HANDLE hobj);
W32KAPI int      APIENTRY NtGdiGetPath(IN HDC hdc, OUT LPPOINT pptlBuf, OUT LPBYTE pjTypes,IN int cptBuf);

W32KAPI HDC      APIENTRY NtGdiCreateCompatibleDC(IN HDC hdc);
W32KAPI HBITMAP  APIENTRY NtGdiCreateDIBitmapInternal(IN HDC hdc,IN INT cx,IN INT cy, IN DWORD fInit, IN LPBYTE pjInit,
                                                      IN LPBITMAPINFO pbmi, IN DWORD iUsage,IN UINT cjMaxInitInfo,
                                                      IN UINT cjMaxBits, IN FLONG f, IN HANDLE hcmXform);
W32KAPI HBITMAP  APIENTRY NtGdiCreateDIBSection(IN HDC hdc,IN HANDLE hSectionApp,IN DWORD dwOffset, IN LPBITMAPINFO pbmi,
                                                IN DWORD iUsage,IN UINT cjHeader,IN FLONG fl, IN ULONG_PTR dwColorSpace,
                                                OUT PVOID *ppvBits);

W32KAPI HBRUSH   APIENTRY NtGdiCreateSolidBrush(IN COLORREF cr, IN HBRUSH hbr);
W32KAPI HBRUSH   APIENTRY NtGdiCreateDIBBrush(IN PVOID pv, IN FLONG fl, IN UINT  cj, IN BOOL  b8X8, IN BOOL bPen,
                                              IN PVOID pClient);
W32KAPI HBRUSH   APIENTRY NtGdiCreatePatternBrushInternal(IN HBITMAP hbm,IN BOOL bPen,IN BOOL b8X8);
W32KAPI HBRUSH   APIENTRY NtGdiCreateHatchBrushInternal(IN ULONG ulStyle,IN COLORREF clrr,IN BOOL bPen);

W32KAPI HPEN     APIENTRY NtGdiExtCreatePen(IN ULONG flPenStyle, IN ULONG ulWidth, IN ULONG iBrushStyle,
                                            IN ULONG ulColor, IN ULONG_PTR  lClientHatch, IN ULONG_PTR   lHatch,
                                            IN ULONG cstyle, IN PULONG pulStyle, IN ULONG cjDIB, IN BOOL bOldStylePen,
                                            IN HBRUSH hbrush);
W32KAPI HRGN     APIENTRY NtGdiCreateEllipticRgn(IN int xLeft,IN int yTop,IN int xRight,IN int yBottom);
W32KAPI HRGN     APIENTRY NtGdiCreateRoundRectRgn(IN int xLeft, IN int yTop, IN int xRight, IN int yBottom,
                                                  IN int xWidth, IN int yHeight);
W32KAPI HANDLE   APIENTRY NtGdiCreateServerMetaFile(IN DWORD iType, IN ULONG cjData, IN LPBYTE pjData, IN DWORD mm,
                                                    IN DWORD xExt, IN DWORD yExt);
W32KAPI HRGN     APIENTRY NtGdiExtCreateRegion(IN LPXFORM px, IN DWORD cj, IN LPRGNDATA prgn);
W32KAPI ULONG    APIENTRY NtGdiMakeFontDir(IN FLONG flEmbed,OUT PBYTE pjFontDir,IN unsigned cjFontDir, IN LPWSTR pwszPathname, IN unsigned cjPathname);

W32KAPI BOOL     APIENTRY NtGdiPolyDraw(IN HDC hdc,IN LPPOINT ppt,IN LPBYTE pjAttr,IN ULONG cpt);
W32KAPI BOOL     APIENTRY NtGdiPolyTextOutW(IN HDC hdc,IN POLYTEXTW *pptw,IN UINT cStr,IN DWORD dwCodePage);

W32KAPI ULONG    APIENTRY NtGdiGetServerMetaFileBits(IN HANDLE hmo, IN ULONG cbData, OUT LPBYTE lpClientData,OUT PDWORD piType,
                                                     OUT PDWORD pmm, OUT PDWORD pxExt, OUT PDWORD pyExt);
W32KAPI BOOL     APIENTRY NtGdiEqualRgn(IN HRGN hrgn1,IN HRGN hrgn2);
W32KAPI BOOL     APIENTRY NtGdiGetBitmapDimension(IN HBITMAP hbm, OUT LPSIZE psize);
W32KAPI UINT     APIENTRY NtGdiGetNearestPaletteIndex(IN HPALETTE hpal,IN COLORREF crColor);
W32KAPI BOOL     APIENTRY NtGdiPtVisible(IN HDC hdc,IN int x,IN int y);
W32KAPI BOOL     APIENTRY NtGdiRectVisible(IN HDC hdc,IN LPRECT prc);
W32KAPI BOOL     APIENTRY NtGdiRemoveFontResourceW(IN WCHAR *pwszFiles, IN ULONG cwc,IN ULONG cFiles, IN ULONG fl,
                                                   IN DWORD dwPidTid,IN DESIGNVECTOR *pdv);
W32KAPI BOOL     APIENTRY NtGdiResizePalette(IN HPALETTE hpal,IN UINT cEntry);
W32KAPI BOOL     APIENTRY NtGdiSetBitmapDimension(IN HBITMAP hbm,IN int cx,IN int cy,OUT LPSIZE  psizeOut);
W32KAPI int      APIENTRY NtGdiOffsetClipRgn(IN HDC hdc,IN int x,IN int y);
W32KAPI int      APIENTRY NtGdiSetMetaRgn(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiSetTextJustification(IN HDC hdc, IN int lBreakExtra,IN int cBreak);
W32KAPI int      APIENTRY NtGdiGetAppClipBox(IN HDC hdc,OUT LPRECT prc);
W32KAPI BOOL     APIENTRY NtGdiGetTextExtentExW(IN HDC hdc, IN LPWSTR lpwsz, IN ULONG cwc,IN ULONG dxMax,
                                                OUT ULONG *pcCh,OUT PULONG pdxOut,OUT LPSIZE psize,IN FLONG fl);
W32KAPI BOOL     APIENTRY NtGdiGetCharABCWidthsW(IN HDC hdc,IN UINT wchFirst,IN ULONG cwch,IN PWCHAR pwch,
                                                 IN FLONG fl,OUT PVOID pvBuf);
W32KAPI DWORD    APIENTRY NtGdiGetCharacterPlacementW(IN HDC hdc,IN LPWSTR pwsz,IN int nCount, IN int nMaxExtent,
                                                      IN OUT LPGCP_RESULTSW pgcpw, IN DWORD dwFlags);
W32KAPI BOOL     APIENTRY NtGdiAngleArc(IN HDC hdc,IN int x,IN int y, IN DWORD dwRadius,IN DWORD dwStartAngle, IN DWORD dwSweepAngle);
W32KAPI BOOL     APIENTRY NtGdiBeginPath(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiSelectClipPath(IN HDC hdc, IN int iMode);
W32KAPI BOOL     APIENTRY NtGdiCloseFigure(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiEndPath(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiAbortPath(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiFillPath(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiStrokeAndFillPath(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiStrokePath(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiWidenPath(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiFlattenPath(IN HDC hdc);
W32KAPI HRGN     APIENTRY NtGdiPathToRegion(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiSetMiterLimit(IN HDC hdc,IN DWORD dwNew,IN OUT PDWORD pdwOut);
W32KAPI BOOL     APIENTRY NtGdiSetFontXform(IN HDC hdc,IN DWORD dwxScale,IN DWORD dwyScale);
W32KAPI BOOL     APIENTRY NtGdiGetMiterLimit(IN HDC hdc,OUT PDWORD pdwOut);
W32KAPI BOOL     APIENTRY NtGdiEllipse(IN HDC hdc,IN int xLeft,IN int yTop,IN int xRight,IN int yBottom);
W32KAPI BOOL     APIENTRY NtGdiRectangle(IN HDC hdc,IN int xLeft,IN int yTop,IN int xRight,IN int yBottom);
W32KAPI BOOL     APIENTRY NtGdiRoundRect(IN HDC hdc, IN int x1,IN int y1,IN int x2,IN int y2,IN int x3,IN int y3);
W32KAPI BOOL     APIENTRY NtGdiPlgBlt(IN HDC hdcTrg,IN LPPOINT pptlTrg,IN HDC hdcSrc,IN int xSrc, IN int ySrc,
                                      IN int cxSrc, IN int cySrc,IN HBITMAP hbmMask,IN int xMask, IN int yMask, IN DWORD crBackColor);
W32KAPI BOOL     APIENTRY NtGdiMaskBlt(IN HDC hdc,IN int xDst,IN int yDst,IN int cx,IN int cy,IN HDC hdcSrc,IN int xSrc,
                                       IN int ySrc, IN HBITMAP hbmMask, IN int xMask,IN int yMask,IN DWORD dwRop4,IN DWORD crBackColor);
W32KAPI BOOL     APIENTRY NtGdiExtFloodFill(IN HDC hdc,IN INT x,IN INT y, IN COLORREF crColor,IN UINT iFillType);
W32KAPI BOOL     APIENTRY NtGdiFillRgn(IN HDC hdc,IN HRGN hrgn,IN HBRUSH hbrush);
W32KAPI BOOL     APIENTRY NtGdiFrameRgn(IN HDC hdc,IN HRGN hrgn,IN HBRUSH hbrush,IN int xWidth,IN int yHeight);
W32KAPI COLORREF APIENTRY NtGdiSetPixel(IN HDC hdcDst, IN int x, IN int y, IN COLORREF crColor);
W32KAPI DWORD    APIENTRY NtGdiGetPixel(IN HDC hdc, IN int x, IN int y);
W32KAPI BOOL     APIENTRY NtGdiStartPage(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiEndPage(IN HDC hdc);
W32KAPI int      APIENTRY NtGdiStartDoc(IN HDC hdc,IN DOCINFOW *pdi,OUT BOOL *pbBanding, IN INT iJob);
W32KAPI BOOL     APIENTRY NtGdiEndDoc(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiAbortDoc(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiUpdateColors(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiGetCharWidthW(IN HDC hdc,IN UINT wcFirst,IN UINT cwc,IN PWCHAR pwc,
                                             IN FLONG fl,OUT PVOID pvBuf);
W32KAPI BOOL     APIENTRY NtGdiGetCharWidthInfo(IN HDC hdc,OUT PCHWIDTHINFO pChWidthInfo);
W32KAPI int      APIENTRY NtGdiDrawEscape(IN HDC hdc,IN int iEsc,IN int cjIn, IN LPSTR pjIn);
W32KAPI int      APIENTRY NtGdiExtEscape(IN HDC hdc,IN PWCHAR pDriver,IN int nDriver,IN int iEsc, IN int cjIn, IN LPSTR pjIn,
                                         IN int cjOut, OUT LPSTR pjOut);
W32KAPI ULONG    APIENTRY NtGdiGetFontData(IN HDC hdc,IN DWORD dwTable,IN DWORD dwOffset,OUT PVOID  pvBuf,IN ULONG cjBuf);
W32KAPI ULONG    APIENTRY NtGdiGetGlyphOutline(IN HDC hdc, IN WCHAR wch, IN UINT iFormat, OUT LPGLYPHMETRICS pgm,
                                               IN ULONG cjBuf,OUT PVOID pvBuf, IN LPMAT2 pmat2, IN BOOL bIgnoreRotation);
W32KAPI BOOL     APIENTRY NtGdiGetETM(IN HDC hdc,OUT EXTTEXTMETRIC *petm);
W32KAPI BOOL     APIENTRY NtGdiGetRasterizerCaps(OUT LPRASTERIZER_STATUS praststat, IN ULONG cjBytes);
W32KAPI ULONG    APIENTRY NtGdiGetKerningPairs(IN HDC hdc,IN ULONG cPairs,OUT KERNINGPAIR *pkpDst);
W32KAPI BOOL     APIENTRY NtGdiMonoBitmap(IN HBITMAP hbm);
W32KAPI HBITMAP  APIENTRY NtGdiGetObjectBitmapHandle(IN HBRUSH hbr,OUT UINT *piUsage);
W32KAPI ULONG    APIENTRY NtGdiEnumObjects(IN HDC hdc,IN int iObjectType,IN ULONG cjBuf,OUT PVOID pvBuf);
W32KAPI BOOL     APIENTRY NtGdiResetDC(IN HDC hdc, IN LPDEVMODEW pdm,OUT PBOOL pbBanding,IN VOID *pDriverInfo2, OUT VOID *ppUMdhpdev);
W32KAPI DWORD    APIENTRY NtGdiSetBoundsRect(IN HDC hdc,IN LPRECT prc,IN DWORD f);
W32KAPI BOOL     APIENTRY NtGdiGetColorAdjustment(IN HDC hdc,OUT PCOLORADJUSTMENT pcaOut);
W32KAPI BOOL     APIENTRY NtGdiSetColorAdjustment(IN HDC hdc, IN PCOLORADJUSTMENT pca);
W32KAPI BOOL     APIENTRY NtGdiCancelDC(IN HDC hdc);
W32KAPI HDC      APIENTRY NtGdiOpenDCW(IN PUNICODE_STRING pustrDevice, IN DEVMODEW *pdm, IN PUNICODE_STRING pustrLogAddr,
                                       IN ULONG iType, IN HANDLE hspool, IN VOID *pDriverInfo2, OUT VOID *pUMdhpdev);
W32KAPI BOOL     APIENTRY NtGdiGetDCDword( IN HDC hdc, IN UINT u, OUT DWORD *Result);
        PVOID    APIENTRY NtGdiMapSharedHandleTable(VOID);
W32KAPI BOOL     APIENTRY NtGdiGetDCPoint(IN HDC hdc,IN UINT iPoint,OUT PPOINTL pptOut);
W32KAPI BOOL     APIENTRY NtGdiScaleViewportExtEx(IN HDC hdc, IN int xNum, IN int xDenom, IN int yNum,
                                                  IN int yDenom, OUT LPSIZE pszOut);
W32KAPI BOOL     APIENTRY NtGdiScaleWindowExtEx(IN HDC hdc, IN int xNum,IN int xDenom, IN int yNum, IN int yDenom, OUT LPSIZE pszOut);
W32KAPI BOOL     APIENTRY NtGdiSetVirtualResolution(IN HDC hdc, IN int cxVirtualDevicePixel,IN int cyVirtualDevicePixel,
                                                    IN int cxVirtualDeviceMm, IN int cyVirtualDeviceMm);
W32KAPI BOOL     APIENTRY NtGdiSetSizeDevice(IN HDC hdc, IN int cxVirtualDevice,IN int cyVirtualDevice);
W32KAPI BOOL     APIENTRY NtGdiGetTransform(IN HDC hdc, IN DWORD iXform, OUT LPXFORM pxf);
W32KAPI BOOL     APIENTRY NtGdiModifyWorldTransform(IN HDC hdc, IN LPXFORM pxf,IN DWORD iXform);
W32KAPI BOOL     APIENTRY NtGdiCombineTransform(OUT LPXFORM pxfDst,IN LPXFORM pxfSrc1,IN LPXFORM pxfSrc2);
W32KAPI BOOL     APIENTRY NtGdiTransformPoints(IN HDC hdc,IN PPOINT pptIn,OUT PPOINT pptOut, IN int c,IN int iMode);
W32KAPI LONG     APIENTRY NtGdiConvertMetafileRect(IN HDC hdc,IN OUT PRECTL prect);

W32KAPI int      APIENTRY NtGdiGetTextCharsetInfo(IN HDC hdc, OUT LPFONTSIGNATURE lpSig, IN DWORD dwFlags);
        BOOL     APIENTRY NtGdiTranslateCharsetInfo(IN OUT DWORD FAR *lpSrc,  OUT LPCHARSETINFO lpCs, IN DWORD dwFlags);

W32KAPI BOOL     APIENTRY NtGdiDoBanding(IN HDC hdc, IN BOOL bStart, OUT POINTL *pptl, OUT PSIZE pSize);
W32KAPI ULONG    APIENTRY NtGdiGetPerBandInfo( IN HDC hdc, IN OUT PERBANDINFO *ppbi);

#define GS_NUM_OBJS_ALL    0
#define GS_HANDOBJ_CURRENT 1
#define GS_HANDOBJ_MAX     2
#define GS_HANDOBJ_ALLOC   3
#define GS_LOOKASIDE_INFO  4
W32KAPI NTSTATUS APIENTRY NtGdiGetStats(IN HANDLE hProcess,IN int iIndex, IN int iPidType, OUT PVOID pResults,IN UINT cjResultSize);

//API's used by USER
W32KAPI BOOL     APIENTRY NtGdiSetMagicColors(IN HDC hdc,IN PALETTEENTRY peMagic,IN ULONG Index);

W32KAPI HBRUSH   APIENTRY NtGdiSelectBrush(IN HDC hdc,IN HBRUSH hbrush);
W32KAPI HPEN     APIENTRY NtGdiSelectPen(IN HDC hdc,IN HPEN hpen);
W32KAPI HBITMAP  APIENTRY NtGdiSelectBitmap(IN HDC hdc,IN HBITMAP hbm);
W32KAPI HFONT    APIENTRY NtGdiSelectFont(IN HDC hdc, IN HFONT hf);

W32KAPI int      APIENTRY NtGdiExtSelectClipRgn(IN HDC hdc, IN HRGN hrgn, IN int iMode);

W32KAPI HPEN     APIENTRY NtGdiCreatePen(IN int iPenStyle, IN int iPenWidth, IN COLORREF cr, IN HBRUSH hbr);

//
// Define _WINDOWBLT_NOTIFICATION_ to turn on Window BLT notification.
// This notification will set a special flag in the SURFOBJ passed to
// drivers when the DrvCopyBits operation is called to move a window.
//
// See also:
//      ntgdi\gre\maskblt.cxx
//
#ifndef _WINDOWBLT_NOTIFICATION_
#define _WINDOWBLT_NOTIFICATION_
#endif
#ifdef _WINDOWBLT_NOTIFICATION_
W32KAPI BOOL     APIENTRY NtGdiBitBlt(IN HDC hdcDst,IN int x,IN int y,IN int cx, IN int cy, IN HDC hdcSrc, IN int xSrc,
                                      IN int ySrc, IN DWORD rop4, IN DWORD crBackColor, IN FLONG fl);
#else
W32KAPI BOOL     APIENTRY NtGdiBitBlt(IN HDC hdcDst,IN int x,IN int y,IN int cx, IN int cy, IN HDC hdcSrc, IN int xSrc,
                                      IN int ySrc, IN DWORD rop4, IN DWORD crBackColor);
#endif
W32KAPI BOOL     APIENTRY NtGdiTileBitBlt(IN HDC hdcDst,IN RECTL * prectDst, IN HDC hdcSrc, IN RECTL * prectSrc, IN POINTL * pptlOrigin,
                                      IN DWORD rop4, IN DWORD crBackColor);

W32KAPI BOOL     APIENTRY NtGdiTransparentBlt(IN HDC hdcDst, IN int xDst, IN int yDst, IN int cxDst, IN int cyDst,
                                              IN HDC hdcSrc, IN int xSrc, IN int ySrc, IN int cxSrc, IN int cySrc,
                                              IN COLORREF TransColor);
W32KAPI BOOL     APIENTRY NtGdiGetTextExtent(IN HDC hdc, IN LPWSTR lpwsz, IN int cwc, OUT LPSIZE psize, IN UINT flOpts);
W32KAPI BOOL     APIENTRY NtGdiGetTextMetricsW(IN HDC hdc, OUT TMW_INTERNAL * ptm, IN ULONG cj);
W32KAPI int      APIENTRY NtGdiGetTextFaceW(IN HDC hdc, IN int cChar, OUT LPWSTR pszOut, IN BOOL bAliasName);
W32KAPI int      APIENTRY NtGdiGetRandomRgn(IN HDC hdc, IN HRGN hrgn, IN int iRgn);
W32KAPI BOOL     APIENTRY NtGdiExtTextOutW(IN HDC hdc, IN int x, IN int y, IN UINT flOpts, IN LPRECT prcl, IN LPWSTR pwsz,
                                           IN int cwc, IN LPINT pdx, IN DWORD dwCodePage);
W32KAPI int      APIENTRY NtGdiIntersectClipRect(IN HDC hdc,IN int xLeft,IN int yTop,IN int xRight,IN int yBottom);
W32KAPI HRGN     APIENTRY NtGdiCreateRectRgn(IN int xLeft, IN int yTop, IN int xRight, IN int yBottom);
W32KAPI BOOL     APIENTRY NtGdiPatBlt(IN HDC hdcDst,IN int x,IN int y,IN int cx,IN int cy, IN DWORD rop4);
typedef struct _POLYPATBLT POLYPATBLT,*PPOLYPATBLT;
W32KAPI BOOL     APIENTRY NtGdiPolyPatBlt(IN HDC hdc,IN DWORD rop4, IN PPOLYPATBLT pPoly, IN DWORD Count, IN DWORD Mode);

W32KAPI BOOL     APIENTRY NtGdiUnrealizeObject(IN HANDLE h);
W32KAPI HANDLE   APIENTRY NtGdiGetStockObject(IN int iObject);
W32KAPI HBITMAP  APIENTRY NtGdiCreateCompatibleBitmap(IN HDC hdc,IN int cx,IN int cy);
W32KAPI BOOL     APIENTRY NtGdiLineTo(IN HDC hdc, IN int x, IN int y);
W32KAPI BOOL     APIENTRY NtGdiMoveTo(IN HDC hdc,IN int x,IN int y,OUT LPPOINT pptOut);
W32KAPI int      APIENTRY NtGdiExtGetObjectW(IN HANDLE h,IN int cj,OUT LPVOID pvOut);
W32KAPI int      APIENTRY NtGdiGetDeviceCaps(IN HDC hdc, IN int i);
W32KAPI BOOL     APIENTRY NtGdiGetDeviceCapsAll (IN HDC hdc, OUT PDEVCAPS pDevCaps);
W32KAPI BOOL     APIENTRY NtGdiStretchBlt(IN HDC hdcDst, IN int xDst, IN int yDst, IN int cxDst, IN int cyDst,
                                          IN HDC hdcSrc, IN int xSrc, IN int ySrc, IN int cxSrc, IN int cySrc,
                                          IN DWORD dwRop,IN DWORD dwBackColor);
W32KAPI BOOL     APIENTRY NtGdiSetBrushOrg(IN HDC hdc,IN int x, IN int y, OUT LPPOINT pptOut);
W32KAPI HBITMAP  APIENTRY NtGdiCreateBitmap(IN int cx, IN int cy, IN UINT cPlanes, IN UINT cBPP, OUT LPBYTE pjInit);
W32KAPI HPALETTE APIENTRY NtGdiCreateHalftonePalette(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiRestoreDC(IN HDC hdc,IN int iLevel);
W32KAPI int      APIENTRY NtGdiExcludeClipRect(IN HDC hdc,IN int xLeft,IN int yTop,IN int xRight,IN int yBottom);
W32KAPI int      APIENTRY NtGdiSaveDC(IN HDC hdc);
W32KAPI int      APIENTRY NtGdiCombineRgn(IN HRGN hrgnDst,IN HRGN hrgnSrc1, IN HRGN hrgnSrc2,IN int iMode);
W32KAPI BOOL     APIENTRY NtGdiSetRectRgn(IN HRGN hrgn,IN int xLeft,IN int  yTop, IN int xRight,IN int yBottom);
W32KAPI LONG     APIENTRY NtGdiSetBitmapBits(IN HBITMAP hbm,IN ULONG cj,IN PBYTE pjInit);

W32KAPI int      APIENTRY NtGdiGetDIBitsInternal(IN HDC hdc, IN HBITMAP hbm, IN UINT iStartScan,IN UINT cScans,
                                                 OUT LPBYTE pBits, IN OUT LPBITMAPINFO pbmi, IN UINT iUsage,
                                                 IN UINT cjMaxBits, IN UINT cjMaxInfo);
W32KAPI int      APIENTRY NtGdiOffsetRgn(IN HRGN hrgn,IN int cx,IN int  cy);
W32KAPI int      APIENTRY NtGdiGetRgnBox(IN HRGN hrgn, OUT LPRECT prcOut);
W32KAPI BOOL     APIENTRY NtGdiRectInRegion(IN HRGN hrgn, OUT LPRECT prcl);
W32KAPI DWORD    APIENTRY NtGdiGetBoundsRect(IN HDC hdc, OUT LPRECT prc,IN DWORD f);
W32KAPI BOOL     APIENTRY NtGdiPtInRegion(IN HRGN hrgn,IN int x,IN int y);
W32KAPI COLORREF APIENTRY NtGdiGetNearestColor(IN HDC hdc, IN COLORREF cr);
W32KAPI UINT     APIENTRY NtGdiGetSystemPaletteUse(IN HDC hdc);
W32KAPI UINT     APIENTRY NtGdiSetSystemPaletteUse(IN HDC hdc, IN UINT ui);
W32KAPI DWORD    APIENTRY NtGdiGetRegionData(IN HRGN hrgn,IN DWORD nCount, OUT LPRGNDATA lpRgnData);
W32KAPI BOOL     APIENTRY NtGdiInvertRgn(IN HDC hdc, IN HRGN hrgn);
        int      APIENTRY NtGdiPerf(IN HDC hdc,IN int iEsc,IN PVOID pvIn);

// MISC FONT API's

int     W32KAPI  APIENTRY NtGdiAddFontResourceW(IN WCHAR *pwszFiles,IN ULONG cwc,IN ULONG cFiles,IN FLONG f,
                                                IN DWORD dwPidTid, IN DESIGNVECTOR *pdv);
#if (_WIN32_WINNT >= 0x0500)
W32KAPI HFONT    APIENTRY NtGdiHfontCreate(IN ENUMLOGFONTEXDVW *pelfw, IN ULONG cjElfw, IN LFTYPE lft,
                                           IN FLONG  fl, IN PVOID pvCliData);
#else
W32KAPI HFONT    APIENTRY NtGdiHfontCreate(IN LPEXTLOGFONTW pelfw, IN ULONG cjElfw, IN LFTYPE lft,
                                           IN FLONG fl, IN PVOID pvCliData);
#endif

W32KAPI ULONG    APIENTRY NtGdiSetFontEnumeration(IN ULONG ulType);
W32KAPI BOOL     APIENTRY NtGdiEnumFontClose(IN ULONG_PTR idEnum);
#if (_WIN32_WINNT >= 0x0500)
W32KAPI BOOL     APIENTRY NtGdiEnumFontChunk(IN HDC hdc,IN ULONG_PTR idEnum,IN ULONG cefdw,
                                             OUT ULONG *pcefdw,OUT PENUMFONTDATAW pefdw);
#endif
W32KAPI ULONG_PTR  APIENTRY NtGdiEnumFontOpen(IN HDC hdc, IN ULONG iEnumType, IN FLONG flWin31Compat, IN ULONG cwchMax,
                                              IN LPWSTR pwszFaceName, IN ULONG lfCharSet, OUT ULONG *pulCount);

#define TYPE_ENUMFONTS          1
#define TYPE_ENUMFONTFAMILIES   2
#define TYPE_ENUMFONTFAMILIESEX 3

W32KAPI INT      APIENTRY NtGdiQueryFonts(OUT PUNIVERSAL_FONT_ID pufiFontList,IN ULONG nBufferSize,
                                          OUT PLARGE_INTEGER pTimeStamp );

// Console API

W32KAPI BOOL     APIENTRY NtGdiConsoleTextOut(IN HDC hdc, IN POLYTEXTW *lpto,IN UINT nStrings, IN RECTL *prclBounds);
W32KAPI NTSTATUS APIENTRY NtGdiFullscreenControl(IN FULLSCREENCONTROL FullscreenCommand, IN PVOID FullscreenInput,
                                                 IN DWORD FullscreenInputLength, OUT PVOID FullscreenOutput,
                                                 IN OUT PULONG FullscreenOutputLength);


// needed for win95 functionality

W32KAPI DWORD    NtGdiGetCharSet(IN HDC hdc);

// needed for fontlinking

W32KAPI BOOL APIENTRY  NtGdiEnableEudc(IN BOOL);
        UINT APIENTRY  NtGdiEudcQuerySystemLink(OUT LPWSTR pszOut,IN UINT cChar);

W32KAPI BOOL APIENTRY  NtGdiEudcLoadUnloadLink(IN LPCWSTR pBaseFaceName, IN UINT cwcBaseFaceName, IN LPCWSTR pEudcFontPath,
                                               IN UINT cwcEudcFontPath, IN INT iPriority, IN INT iFontLinkType, IN BOOL bLoadLin);
W32KAPI UINT APIENTRY  NtGdiGetStringBitmapW(IN HDC hdc, IN LPWSTR pwsz, IN UINT cwc, OUT BYTE *lpSB, IN UINT cj);
W32KAPI ULONG APIENTRY NtGdiGetEudcTimeStampEx(IN LPWSTR lpBaseFaceName,IN ULONG cwcBaseFaceName,IN BOOL bSystemTimeStamp);
W32KAPI ULONG APIENTRY NtGdiQueryFontAssocInfo(IN HDC hdc);

#if (_WIN32_WINNT >= 0x0500)
W32KAPI DWORD NtGdiGetFontUnicodeRanges(IN HDC hdc, OUT LPGLYPHSET pgs);
#endif

#ifdef LANGPACK
W32KAPI BOOL NtGdiGetRealizationInfo(IN HDC hdc, OUT PREALIZATION_INFO pri, IN HFONT hf);
#endif

typedef struct tagDOWNLOADDESIGNVECTOR {
    UNIVERSAL_FONT_ID ufiBase;
    DESIGNVECTOR      dv;
} DOWNLOADDESIGNVECTOR;

W32KAPI BOOL NtGdiAddRemoteMMInstanceToDC(IN HDC hdc,IN DOWNLOADDESIGNVECTOR *pddv,IN ULONG cjDDV);

        int  APIENTRY NtGdiGetMessage(IN OUT void* );           // client/server
        BOOL APIENTRY NtGdiCall(IN OUT GDICALL*);               // misc helper functions
// user-mode printer support

W32KAPI BOOL APIENTRY NtGdiUnloadPrinterDriver(IN LPWSTR pDriverName,IN ULONG cbDriverName);
W32KAPI BOOL APIENTRY NtGdiEngAssociateSurface(IN HSURF  hsurf,IN HDEV hdev,IN FLONG  flHooks);
W32KAPI BOOL APIENTRY NtGdiEngEraseSurface(IN SURFOBJ *pso,IN RECTL *prcl,IN ULONG iColor);
W32KAPI HBITMAP APIENTRY NtGdiEngCreateBitmap(IN SIZEL sizl,IN LONG lWidth,IN ULONG iFormat,IN FLONG fl,IN PVOID pvBits);
W32KAPI BOOL APIENTRY NtGdiEngDeleteSurface(IN HSURF hsurf);
W32KAPI SURFOBJ* APIENTRY NtGdiEngLockSurface(IN HSURF hsurf);
W32KAPI VOID APIENTRY NtGdiEngUnlockSurface(IN SURFOBJ *);
W32KAPI BOOL APIENTRY NtGdiEngMarkBandingSurface(HSURF hsurf);
W32KAPI HSURF APIENTRY NtGdiEngCreateDeviceSurface(IN DHSURF dhsurf, IN SIZEL sizl, IN ULONG iFormatCompat);
W32KAPI HBITMAP APIENTRY NtGdiEngCreateDeviceBitmap(IN DHSURF dhsurf, IN SIZEL sizl, IN ULONG iFormatCompat);

W32KAPI BOOL APIENTRY NtGdiEngCopyBits(IN SURFOBJ *psoDst,IN SURFOBJ *psoSrc,IN CLIPOBJ *pco,IN XLATEOBJ *pxlo,
                                       IN RECTL *prclDst,IN POINTL *pptlSrc);
W32KAPI BOOL APIENTRY NtGdiEngStretchBlt(IN SURFOBJ *psoDest,IN SURFOBJ *psoSrc,IN SURFOBJ *psoMask,IN CLIPOBJ *pco,
                                         IN XLATEOBJ *pxlo, IN COLORADJUSTMENT *pca, IN POINTL *pptlHTOrg, IN RECTL *prclDest,
                                         IN RECTL *prclSrc, IN POINTL *pptlMask, IN ULONG iMode);
W32KAPI BOOL APIENTRY NtGdiEngBitBlt(IN SURFOBJ *psoDst,IN SURFOBJ *psoSrc,IN SURFOBJ *psoMask,IN CLIPOBJ *pco,IN XLATEOBJ *pxlo,
                                     IN RECTL *prclDst,IN POINTL *pptlSrc,IN POINTL *pptlMask,IN BRUSHOBJ *pbo,IN POINTL *pptlBrush,
                                     IN ROP4 rop4);
W32KAPI BOOL APIENTRY NtGdiEngPlgBlt(IN SURFOBJ *psoTrg,IN SURFOBJ *psoSrc, IN SURFOBJ *psoMsk, IN CLIPOBJ *pco,
                                     IN XLATEOBJ *pxlo, IN COLORADJUSTMENT *pca, IN POINTL *pptlBrushOrg, IN POINTFIX *pptfxDest,
                                     IN RECTL *prclSrc, IN POINTL *pptlMask, IN ULONG iMode);
W32KAPI HPALETTE APIENTRY NtGdiEngCreatePalette(IN ULONG iMode, IN ULONG cColors, IN ULONG *pulColors, IN FLONG flRed,
                                                IN FLONG flGreen, IN FLONG flBlue);
W32KAPI BOOL APIENTRY NtGdiEngDeletePalette(IN HPALETTE hPal);
W32KAPI BOOL APIENTRY NtGdiEngStrokePath(IN SURFOBJ *pso,IN PATHOBJ *ppo,IN CLIPOBJ *pco, IN XFORMOBJ *pxo,
                                         IN BRUSHOBJ *pbo,IN POINTL *pptlBrushOrg,IN LINEATTRS *plineattrs,MIX mix);
W32KAPI BOOL APIENTRY NtGdiEngFillPath(IN SURFOBJ *pso,IN PATHOBJ *ppo,IN CLIPOBJ *pco,IN BRUSHOBJ *pbo,
                                       IN POINTL *pptlBrushOrg,IN MIX mix,IN FLONG flOptions);
W32KAPI BOOL APIENTRY NtGdiEngStrokeAndFillPath(IN SURFOBJ *pso,IN PATHOBJ *ppo,IN CLIPOBJ *pco,IN XFORMOBJ *pxo,
                                                IN BRUSHOBJ *pboStroke,IN LINEATTRS *plineattrs,IN BRUSHOBJ *pboFill,
                                                IN POINTL *pptlBrushOrg,IN MIX mix,IN FLONG flOptions);
W32KAPI BOOL APIENTRY NtGdiEngPaint(IN SURFOBJ *pso, IN CLIPOBJ *pco, IN BRUSHOBJ *pbo, IN POINTL *pptlBrushOrg, IN MIX mix);
W32KAPI BOOL APIENTRY NtGdiEngLineTo(IN SURFOBJ *pso, IN CLIPOBJ *pco, IN BRUSHOBJ *pbo, IN LONG x1, IN LONG y1,
                                     IN LONG x2, IN LONG y2, IN RECTL *prclBounds, IN MIX mix);
W32KAPI BOOL APIENTRY NtGdiEngAlphaBlend(IN SURFOBJ *psoDest,IN SURFOBJ *psoSrc, IN CLIPOBJ *pco, XLATEOBJ *pxlo,IN RECTL *prclDest,
                                         IN RECTL *prclSrc,IN BLENDOBJ *pBlendObj);
W32KAPI BOOL APIENTRY NtGdiEngGradientFill(IN SURFOBJ *psoDest,IN CLIPOBJ *pco, IN XLATEOBJ *pxlo, TRIVERTEX *pVertex,
                                           IN ULONG nVertex, IN PVOID pMesh, IN ULONG nMesh, IN RECTL *prclExtents,
                                           IN POINTL *pptlDitherOrg, IN ULONG ulMode);
W32KAPI BOOL APIENTRY NtGdiEngTransparentBlt(IN SURFOBJ *psoDst, IN SURFOBJ *psoSrc, IN CLIPOBJ *pco, IN XLATEOBJ *pxlo,
                                             IN RECTL *prclDst, IN RECTL *prclSrc, IN ULONG iTransColor, ULONG ulReserved);
W32KAPI BOOL APIENTRY NtGdiEngTextOut(IN SURFOBJ *pso,IN STROBJ *pstro, IN FONTOBJ *pfo, IN CLIPOBJ *pco, IN RECTL *prclExtra,
                                      IN RECTL *prclOpaque, IN BRUSHOBJ *pboFore, IN BRUSHOBJ *pboOpaque, IN POINTL *pptlOrg,
                                      IN MIX mix);
W32KAPI BOOL APIENTRY NtGdiEngStretchBltROP(IN SURFOBJ *psoTrg, IN SURFOBJ *psoSrc, IN SURFOBJ *psoMask, IN CLIPOBJ *pco,
                                            IN XLATEOBJ *pxlo, IN COLORADJUSTMENT *pca, IN POINTL *pptlBrushOrg,
                                            IN RECTL *prclTrg, IN RECTL *prclSrc, IN POINTL *pptlMask, IN ULONG iMode,
                                            IN BRUSHOBJ *pbo, IN ROP4 rop4);

W32KAPI ULONG APIENTRY NtGdiXLATEOBJ_cGetPalette(IN XLATEOBJ *pxlo, IN ULONG iPal, IN ULONG cPal, OUT ULONG *pPal);

W32KAPI ULONG    APIENTRY NtGdiCLIPOBJ_cEnumStart(IN CLIPOBJ *pco, IN BOOL bAll, IN ULONG iType, IN ULONG iDirection, IN ULONG cLimit);
W32KAPI BOOL     APIENTRY NtGdiCLIPOBJ_bEnum(IN CLIPOBJ *pco, IN ULONG cj, OUT ULONG *pul);
W32KAPI PATHOBJ* APIENTRY NtGdiCLIPOBJ_ppoGetPath(IN CLIPOBJ *pco);
W32KAPI CLIPOBJ* APIENTRY NtGdiEngCreateClip();
W32KAPI VOID     APIENTRY NtGdiEngDeleteClip(IN CLIPOBJ*pco);

W32KAPI PVOID    APIENTRY NtGdiBRUSHOBJ_pvAllocRbrush(IN BRUSHOBJ *pbo,IN ULONG cj);
W32KAPI PVOID    APIENTRY NtGdiBRUSHOBJ_pvGetRbrush(IN BRUSHOBJ *pbo);
W32KAPI ULONG    APIENTRY NtGdiBRUSHOBJ_ulGetBrushColor(IN BRUSHOBJ *pbo);
W32KAPI HANDLE   APIENTRY NtGdiBRUSHOBJ_hGetColorTransform(IN BRUSHOBJ *pbo);

W32KAPI BOOL     APIENTRY NtGdiXFORMOBJ_bApplyXform(IN XFORMOBJ *pxo, IN ULONG iMode, IN ULONG cPoints, IN PVOID pvIn, OUT PVOID pvOut);
W32KAPI ULONG    APIENTRY NtGdiXFORMOBJ_iGetXform(IN XFORMOBJ *pxo, OUT XFORML *pxform);

W32KAPI VOID     APIENTRY NtGdiFONTOBJ_vGetInfo(IN FONTOBJ *pfo, IN ULONG cjSize, OUT FONTINFO *pfi);
W32KAPI ULONG    APIENTRY NtGdiFONTOBJ_cGetGlyphs(IN FONTOBJ *pfo, IN ULONG iMode, IN ULONG cGlyph, IN HGLYPH *phg, OUT PVOID *ppvGlyph);
W32KAPI XFORMOBJ*  APIENTRY NtGdiFONTOBJ_pxoGetXform(IN FONTOBJ *pfo);
W32KAPI IFIMETRICS* APIENTRY NtGdiFONTOBJ_pifi(IN FONTOBJ *pfo);
W32KAPI FD_GLYPHSET* APIENTRY NtGdiFONTOBJ_pfdg(IN FONTOBJ *pfo);
W32KAPI ULONG    APIENTRY NtGdiFONTOBJ_cGetAllGlyphHandles(IN FONTOBJ *pfo, OUT HGLYPH *phg);
W32KAPI PVOID    APIENTRY  NtGdiFONTOBJ_pvTrueTypeFontFile(IN FONTOBJ *pfo, OUT ULONG *pcjFile);
W32KAPI PFD_GLYPHATTR APIENTRY NtGdiFONTOBJ_pQueryGlyphAttrs(IN FONTOBJ *pfo, IN ULONG iMode);

W32KAPI BOOL     APIENTRY NtGdiSTROBJ_bEnum(IN STROBJ *pstro, OUT ULONG *pc, OUT PGLYPHPOS *ppgpos);
W32KAPI BOOL     APIENTRY NtGdiSTROBJ_bEnumPositionsOnly(IN STROBJ *pstro,ULONG *pc,OUT PGLYPHPOS *ppgpos);
W32KAPI VOID     APIENTRY NtGdiSTROBJ_vEnumStart(IN STROBJ *pstro);
W32KAPI DWORD    APIENTRY NtGdiSTROBJ_dwGetCodePage(IN STROBJ *pstro);
W32KAPI BOOL     APIENTRY NtGdiSTROBJ_bGetAdvanceWidths(IN STROBJ*pstro, IN ULONG iFirst, IN ULONG c, OUT POINTQF*pptqD);
W32KAPI FD_GLYPHSET* APIENTRY NtGdiEngComputeGlyphSet(IN INT nCodePage, IN INT nFirstChar, IN INT cChars);

W32KAPI ULONG    APIENTRY NtGdiXLATEOBJ_iXlate(IN XLATEOBJ *pxlo, IN ULONG iColor);
W32KAPI HANDLE   APIENTRY NtGdiXLATEOBJ_hGetColorTransform(IN XLATEOBJ *pxlo);

W32KAPI VOID     APIENTRY NtGdiPATHOBJ_vGetBounds(IN PATHOBJ *ppo, OUT PRECTFX prectfx);
W32KAPI BOOL     APIENTRY NtGdiPATHOBJ_bEnum(IN PATHOBJ *ppo, OUT PATHDATA  *ppd);  
W32KAPI VOID     APIENTRY NtGdiPATHOBJ_vEnumStart(IN PATHOBJ *ppo);
W32KAPI VOID     APIENTRY NtGdiEngDeletePath(IN PATHOBJ *ppo);
W32KAPI VOID     APIENTRY NtGdiPATHOBJ_vEnumStartClipLines(IN PATHOBJ *ppo, IN CLIPOBJ *pco, IN SURFOBJ *pso, IN LINEATTRS *pla);
W32KAPI BOOL     APIENTRY NtGdiPATHOBJ_bEnumClipLines(IN PATHOBJ *ppo, IN ULONG cb, OUT CLIPLINE *pcl);

W32KAPI BOOL     APIENTRY NtGdiEngCheckAbort(IN SURFOBJ *pso);
W32KAPI DHPDEV            NtGdiGetDhpdev(IN HDEV hdev);

W32KAPI LONG     APIENTRY NtGdiHT_Get8BPPFormatPalette(OUT LPPALETTEENTRY pPaletteEntry, IN USHORT RedGamma,
                                                       IN USHORT GreenGamma, IN USHORT BlueGamma);
W32KAPI LONG     APIENTRY NtGdiHT_Get8BPPMaskPalette(OUT LPPALETTEENTRY pPaletteEntry, IN BOOL Use8BPPMaskPal,
                                                     IN BYTE CMYMask, IN USHORT RedGamma, IN USHORT GreenGamma, IN USHORT BlueGamma);

W32KAPI BOOL              NtGdiUpdateTransform(IN HDC hdc);

W32KAPI DWORD    APIENTRY NtGdiSetLayout(IN HDC hdc, IN LONG wox, IN DWORD dwLayout);
W32KAPI BOOL     APIENTRY NtGdiMirrorWindowOrg(IN HDC hdc);
W32KAPI LONG     APIENTRY NtGdiGetDeviceWidth(IN HDC hdc);

W32KAPI BOOL              NtGdiSetPUMPDOBJ(IN HUMPD humpd, IN BOOL bStoreID, OUT HUMPD *phumpd, OUT BOOL *pbWOW64);
W32KAPI BOOL              NtGdiBRUSHOBJ_DeleteRbrush(IN BRUSHOBJ *pbo, IN BRUSHOBJ *pboB);
W32KAPI BOOL              NtGdiUMPDEngFreeUserMem(IN KERNEL_PVOID *ppv);
W32KAPI HBITMAP APIENTRY NtGdiSetBitmapAttributes(IN HBITMAP hbm, IN DWORD dwFlags);
W32KAPI HBITMAP APIENTRY NtGdiClearBitmapAttributes(IN HBITMAP hbm, IN DWORD dwFlags);
W32KAPI HBRUSH APIENTRY NtGdiSetBrushAttributes(IN HBRUSH hbm, IN DWORD dwFlags);
W32KAPI HBRUSH APIENTRY NtGdiClearBrushAttributes(IN HBRUSH hbm, IN DWORD dwFlags);

// Private draw stream interface

W32KAPI BOOL APIENTRY NtGdiDrawStream(IN HDC, IN ULONG, IN VOID *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\inc\umpd.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    umpd.cxx

Abstract:

    User-mode printer driver support

Environment:

        Windows NT 5.0

Revision History:

        07/8/97 -lingyunw-
                Created it.

--*/

#ifndef __UMPD__
#define __UMPD__

#define INDEX_UMPDDrvEnableDriver       INDEX_LAST+1

#define INDEX_LoadUMPrinterDrv          INDEX_LAST+2        // used for WOW64, spooler calls
#define INDEX_UnloadUMPrinterDrv        INDEX_LAST+3
#define INDEX_UMDriverFN                INDEX_LAST+4
#define INDEX_DocumentEvent             INDEX_LAST+5
#define INDEX_StartDocPrinterW          INDEX_LAST+6
#define INDEX_StartPagePrinter          INDEX_LAST+7
#define INDEX_EndPagePrinter            INDEX_LAST+8
#define INDEX_EndDocPrinter             INDEX_LAST+9
#define INDEX_AbortPrinter              INDEX_LAST+10
#define INDEX_ResetPrinterW             INDEX_LAST+11
#define INDEX_QueryColorProfile         INDEX_LAST+12

#define INDEX_UMPDAllocUserMem          INDEX_LAST+13     // used for WOW64, large bitmaps
#define INDEX_UMPDCopyMemory            INDEX_LAST+14
#define INDEX_UMPDFreeMemory            INDEX_LAST+15
#define INDEX_UMPDEngFreeUserMem        INDEX_LAST+16


typedef struct _HPRINTERLIST
{
    struct _HPRINTERLIST  *pNext;
    DWORD                 clientPid;
    DWORD                 hPrinter32;
    HANDLE                hPrinter64;
}HPRINTERLIST, *PHPRINTERLIST;

typedef struct _UMPD {
    DWORD               dwSignature;        // data structure signature
    struct _UMPD *      pNext;             // linked list pointer
    PDRIVER_INFO_2W     pDriverInfo2;       // pointer to driver info
    HINSTANCE           hInst;              // instance handle to user-mode printer driver module
    DWORD               dwFlags;            // misc. flags
    BOOL                bArtificialIncrement; // indicates if the ref cnt has been bumped up to
                                          // defer unloading
    DWORD               dwDriverVersion;    // version number of the loaded driver
    INT                 iRefCount;          // reference count

    struct ProxyPort *  pp;                 // UMPD proxy server
    KERNEL_PVOID        umpdCookie;         // cookie returned back from proxy
    
    
    PHPRINTERLIST       pHandleList;        // list of hPrinter's opened on the proxy server


    PFN                 apfn[INDEX_LAST];   // driver function table
} UMPD, *PUMPD;


typedef struct _UMDHPDEV {

    PUMPD  pUMPD;
    DHPDEV dhpdev;

//    HDC    hdc;          // the printer DC that's associated with the pdev
//    PBYTE  pvEMF;        // the pointer to the emf if we are playing the emf on the hdc
//    PBYTE  pvCurrentRecord; // the pointer to the current emf record if we are playing emf

} UMDHPDEV, *PUMDHPDEV;

typedef KERNEL_PVOID   KERNEL_PUMDHPDEV;

typedef struct
{
    UMTHDR          umthdr;
    HUMPD           humpd;
} UMPDTHDR;

typedef struct
{
    UMPDTHDR        umpdthdr;
    KERNEL_PVOID    cookie;
}  DRVDRIVERFNINPUT, *PDRVDRIVERFNINPUT;

typedef struct
{
    UMPDTHDR  umpdthdr;
    PWSTR   pwszDriver;
}  DRVENABLEDRIVERINPUT, *PDRVENABLEDRIVERINPUT;

typedef struct
{
    UMPDTHDR    umpdthdr;
    KERNEL_PVOID umpdCookie;
    PDEVMODEW   pdm;
    PWSTR       pLogAddress;
    ULONG       cPatterns;
    HSURF       *phsurfPatterns;
    ULONG       cjCaps;
    ULONG       *pdevcaps;
    ULONG       cjDevInfo;
    DEVINFO     *pDevInfo;
    HDEV        hdev;
    PWSTR       pDeviceName;
    HANDLE      hPrinter;
    BOOL        bWOW64;
    DWORD       clientPid;
}  DRVENABLEPDEVINPUT, *PDRVENABLEPDEVINPUT;

typedef struct
{
    UMPDTHDR  umpdthdr;
    DHPDEV  dhpdev;
    HDEV    hdev;
}  DRVCOMPLETEPDEVINPUT, *PDRVCOMPLETEPDEVINPUT;

typedef struct
{
    UMPDTHDR  umpdthdr;
    DHPDEV  dhpdevOld;
    DHPDEV  dhpdevNew;
}  DRVRESETPDEVINPUT, *PDRVRESETPDEVINPUT;

typedef struct
{
    UMPDTHDR  umpdthdr;
    DHPDEV  dhpdev;
}  DHPDEVINPUT, *PDHPDEVINPUT;

//
// Note: can't pass kernel pointers over to client side.
//

typedef struct _DRVESCAPEINPUT
{
    UMPDTHDR      umpdthdr;
    SURFOBJ     *pso;
    ULONG       iEsc;
    ULONG       cjIn;
    PVOID       pvIn;
    ULONG       cjOut;
    PVOID       pvOut;
} DRVESCAPEINPUT, *PDRVESCAPEINPUT;

typedef struct _DRVDRAWESCAPEINPUT
{
    UMPDTHDR      umpdthdr;
    SURFOBJ     *pso;
    ULONG       iEsc;
    CLIPOBJ     *pco;
    RECTL       *prcl;
    ULONG       cjIn;
    PVOID       pvIn;
} DRVDRAWESCAPEINPUT, *PDRVDRAWESCAPEINPUT;


typedef struct
{
    UMPDTHDR     umpdthdr;
    SURFOBJ    *pso;
    CLIPOBJ    *pco;
    BRUSHOBJ   *pbo;
    POINTL     *pptlBrushOrg;
    POINTL     ptlBrushOrg;
    MIX        mix;
}  DRVPAINTINPUT, *PDRVPAINTINPUT;

typedef struct
{
    UMPDTHDR     umpdthdr;
    SURFOBJ    *pso;
    CLIPOBJ    *pco;
    BRUSHOBJ   *pbo;
    LONG       x1;
    LONG       y1;
    LONG       x2;
    LONG       y2;
    RECTL      *prclBounds;
    MIX        mix;
}  DRVLINETOINPUT, *PDRVLINETOINPUT;

typedef struct
{
    UMPDTHDR     umpdthdr;
    SURFOBJ    *psoTrg;
    SURFOBJ    *psoSrc;
    SURFOBJ    *psoMask;
    CLIPOBJ    *pco;
    XLATEOBJ   *pxlo;
    RECTL      *prclTrg;
    POINTL     *pptlSrc;
    POINTL     *pptlMask;
    BRUSHOBJ   *pbo;
    POINTL     *pptlBrush;
    ROP4       rop4;
}  DRVBITBLTINPUT, *PDRVBITBLTINPUT;

typedef struct
{
    UMPDTHDR     umpdthdr;
    SURFOBJ    *psoTrg;
    SURFOBJ    *psoSrc;
    CLIPOBJ    *pco;
    XLATEOBJ   *pxlo;
    RECTL      *prclTrg;
    POINTL     *pptlSrc;
}  DRVCOPYBITSINPUT, *PDRVCOPYBITSINPUT;


typedef struct
{
    UMPDTHDR          umpdthdr;
    SURFOBJ         *psoTrg;
    SURFOBJ         *psoSrc;
    SURFOBJ         *psoMask;
    CLIPOBJ         *pco;
    XLATEOBJ        *pxlo;
    COLORADJUSTMENT *pca;
    POINTL          *pptlHTOrg;
    RECTL           *prclTrg;
    RECTL           *prclSrc;
    POINTL          *pptlMask;
    ULONG           iMode;
    BRUSHOBJ        *pbo;
    ROP4            rop4;
}  DRVSTRETCHBLTINPUT, *PDRVSTRETCHBLTINPUT;

typedef struct
{
    UMPDTHDR          umpdthdr;
    SURFOBJ         *psoTrg;
    SURFOBJ         *psoSrc;
    SURFOBJ         *psoMask;
    CLIPOBJ         *pco;
    XLATEOBJ        *pxlo;
    COLORADJUSTMENT *pca;
    POINTL          *pptlBrushOrg;
    POINTFIX        *pptfx;
    RECTL           *prcl;
    POINTL          *pptl;
    ULONG           iMode;
}  DRVPLGBLTINPUT, *PDRVPLGBLTINPUT;

typedef struct
{
    UMPDTHDR          umpdthdr;
    SURFOBJ         *psoTrg;
    SURFOBJ         *psoSrc;
    CLIPOBJ         *pco;
    XLATEOBJ        *pxlo;
    RECTL           *prclDest;
    RECTL           *prclSrc;
    BLENDOBJ        *pBlendObj;
}  ALPHAINPUT, *PALPHAINPUT;

typedef struct
{
    UMPDTHDR          umpdthdr;
    SURFOBJ         *psoTrg;
    SURFOBJ         *psoSrc;
    CLIPOBJ         *pco;
    XLATEOBJ        *pxlo;
    RECTL           *prclDst;
    RECTL           *prclSrc;
    ULONG           TransColor;
    UINT            ulReserved;
}  TRANSPARENTINPUT, *PTRANSPARENTINPUT;

typedef struct
{
    UMPDTHDR          umpdthdr;
    SURFOBJ         *psoTrg;
    CLIPOBJ         *pco;
    XLATEOBJ        *pxlo;
    TRIVERTEX       *pVertex;
    ULONG           nVertex;
    PVOID           pMesh;
    ULONG           nMesh;
    RECTL           *prclExtents;
    POINTL          *pptlDitherOrg;
    ULONG           ulMode;
}  GRADIENTINPUT, *PGRADIENTINPUT;


typedef struct
{
    UMPDTHDR  umpdthdr;
    SURFOBJ *pso;
    PWSTR   pwszDocName;
    DWORD   dwJobId;
}  DRVSTARTDOCINPUT, *PDRVSTARTDOCINPUT;

typedef struct
{
    UMPDTHDR   umpdthdr;
    SURFOBJ  *pso;
    FLONG    fl;
}  DRVENDDOCINPUT, *PDRVENDDOCINPUT;

typedef struct
{
    UMPDTHDR   umpdthdr;
    SURFOBJ  *pso;
}  SURFOBJINPUT, *PSURFOBJINPUT;

typedef struct
{
    UMPDTHDR   umpdthdr;
    SURFOBJ  *pso;
    POINTL   *pptl;
}  DRVBANDINGINPUT, *PDRVBANDINGINPUT;

typedef struct
{
    UMPDTHDR   umpdthdr;
    SURFOBJ  *pso;
    PERBANDINFO *pbi;
}  DRVPERBANDINPUT, *PDRVPERBANDINPUT;


typedef struct
{
    UMPDTHDR     umpdthdr;
    SURFOBJ    *psoTrg;
    SURFOBJ    *psoPat;
    SURFOBJ    *psoMsk;
    BRUSHOBJ   *pbo;
    XLATEOBJ   *pxlo;
    ULONG      iHatch;
}  DRVREALIZEBRUSHINPUT, *PDRVREALIZEBRUSHINPUT;

typedef struct
{
    UMPDTHDR     umpdthdr;
    SURFOBJ    *pso;
    PATHOBJ    *ppo;
    CLIPOBJ    *pco;
    XFORMOBJ   *pxo;
    BRUSHOBJ   *pbo;
    POINTL     *pptlBrushOrg;
    LINEATTRS  *plineattrs;
    BRUSHOBJ   *pboFill;
    MIX        mix;
    FLONG      flOptions;
}  STORKEANDFILLINPUT, *PSTROKEANDFILLINPUT;

typedef struct
{
    UMPDTHDR      umpdthdr;
    SURFOBJ     *pso;
    STROBJ      *pstro;
    FONTOBJ     *pfo;
    CLIPOBJ     *pco;
    RECTL       *prclExtra;
    RECTL       *prclOpaque;
    BRUSHOBJ    *pboFore;
    BRUSHOBJ    *pboOpaque;
    POINTL      *pptlOrg;
    MIX         mix;
}  TEXTOUTINPUT, *PTEXTOUTINPUT;

typedef struct
{
    UMPDTHDR    umpdthdr;
    DHPDEV      dhpdev;
    ULONG_PTR   iFile;
    ULONG       iFace;
    ULONG       iMode;
    ULONG       *pid;
    ULONG       cjMaxData;
    PVOID       pv;
}  QUERYFONTINPUT, *PQUERYFONTINPUT;

typedef struct
{
    UMPDTHDR    umpdthdr;
    DHPDEV    dhpdev;
    FONTOBJ   *pfo;
    ULONG     iMode;
    HGLYPH    hg;
    GLYPHDATA *pgd;
    PVOID     pv;
    ULONG     cjSize;
}  QUERYFONTDATAINPUT, *PQUERYFONTDATAINPUT;

typedef struct
{
    UMPDTHDR    umpdthdr;
    DHPDEV    dhpdev;
    FONTOBJ   *pfo;
    ULONG     iMode;
    HGLYPH    *phg;
    PVOID     pvWidths;
    ULONG     cGlyphs;
}  QUERYADVWIDTHSINPUT, *PQUERYADVWIDTHSINPUT;

typedef struct
{
    UMPDTHDR    umpdthdr;
    DHPDEV    dhpdev;
    FONTOBJ   *pfo;
} GETGLYPHMODEINPUT, *PGETGLYPHMODEINPUT;

typedef struct
{
    UMPDTHDR    umpdthdr;
    SURFOBJ   *pso;
    DHPDEV    dhpdev;
    FONTOBJ   *pfo;
    ULONG     iMode;
    ULONG     cjIn;
    PVOID     pvIn;
    ULONG     cjOut;
    PVOID     pvOut;
} FONTMANAGEMENTINPUT, *PFONTMANAGEMENTINPUT;

typedef struct
{
    UMPDTHDR    umpdthdr;
    DHPDEV    dhpdev;
    ULONG     iMode;
    ULONG     rgb;
    ULONG     *pul;
} DRVDITHERCOLORINPUT, *PDRVDITHERCOLORINPUT;

typedef struct
{
    UMPDTHDR    umpdthdr;
    DHPDEV    dhpdev;
    PVOID     pv;
    ULONG     id;
} DRVFREEINPUT, *PDRVFREEINPUT;

typedef struct
{
    UMPDTHDR    umpdthdr;
    DHPDEV    dhpdev;
    DHSURF    dhsurf;
} DRVDELETEDEVBITMAP, *PDRVDELETEDEVBITMAP;

typedef struct
{
    UMPDTHDR    umpdthdr;
    DHPDEV    dhpdev;
    HANDLE    hcmXform;
} DRVICMDELETECOLOR, *PDRVICMDELETECOLOR;

typedef struct
{
    UMPDTHDR           umpdthdr;
    DHPDEV           dhpdev;
    LPLOGCOLORSPACEW pLogColorSpace;
    PVOID            pvSourceProfile;
    ULONG            cjSourceProfile;
    PVOID            pvDestProfile;
    ULONG            cjDestProfile;
    PVOID            pvTargetProfile;
    ULONG            cjTargetProfile;
    DWORD            dwReserved;
} DRVICMCREATECOLORINPUT, *PDRVICMCREATECOLORINPUT;

typedef struct
{
    UMPDTHDR    umpdthdr;
    DHPDEV    dhpdev;
    HANDLE    hColorTransform;
    SURFOBJ   *pso;
    PBYTE     paResults;
} DRVICMCHECKBITMAPINPUT, *PDRVICMCHECKBITMAPINPUT;

typedef struct
{
    UMPDTHDR     umpdthdr;
    SURFOBJ    *pso;
    XLATEOBJ   *pxlo;
    XFORMOBJ   *pxo;
    ULONG      iType;
    ULONG      cjIn;
    PVOID      pvIn;
    ULONG      cjOut;
    PVOID      pvOut;
}  DRVQUERYDEVICEINPUT, *PDRVQUERYDEVICEINPUT;

typedef struct
{
    UMPDTHDR    umpdthdr;
    ULONG       cjSize;
} UMPDALLOCUSERMEMINPUT, *PUMPDALLOCUSERMEMINPUT;

typedef struct
{
    UMPDTHDR        umpdthdr;
    KERNEL_PVOID    pvSrc;
    KERNEL_PVOID    pvDest;
    ULONG           cjSize;
}  UMPDCOPYMEMINPUT, *PUMPDCOPYMEMINPUT;

typedef struct
{
    UMPDTHDR        umpdthdr;
    KERNEL_PVOID    pvTrg;
    KERNEL_PVOID    pvSrc;
    KERNEL_PVOID    pvMsk;
}  UMPDFREEMEMINPUT, *PUMPDFREEMEMINPUT;

#endif // __UMPD__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\inc\xfflags.h ===
/******************************Module*Header*******************************\
* Module Name: xfflags.h
*
* Shared flags for use in client and server side transform code.
*
* Created: 3-Aug-1992 22:34:23
* Author: Gerrit van Wingerden [gerritv]
*
* Copyright (c) 1992-1999 Microsoft Corporation
\**************************************************************************/

#ifndef INC_XFFLAGS
#define INC_XFFLAGS


#define XFORM_SCALE             1   // off-diagonal are 0
#define XFORM_UNITY             2   // diagonal are 1s, off-diagonal are 0
                                    // will be set only if XFORM_SCALE is set
#define XFORM_Y_NEG             4   // M22 is negative.  Will be set only if
                                    // XFORM_SCALE|XFORM_UNITY are set
#define XFORM_FORMAT_LTOFX      8   // transform from LONG to FIX format
#define XFORM_FORMAT_FXTOL     16   // transform from FIX to LONG format
#define XFORM_FORMAT_LTOL      32   // transform from LONG to LONG format
#define XFORM_NO_TRANSLATION   64   // no translations

#define MATRIX_SET_IDENTITY     1
#define MATRIX_SET              2
#define MATRIX_MODIFY           3



#define METAFILE_TO_WORLD_IDENTITY       0x00000001L
#define WORLD_TO_PAGE_IDENTITY	         0x00000002L
#define DEVICE_TO_PAGE_INVALID	         0x00000008L
#define DEVICE_TO_WORLD_INVALID          0x00000010L
#define WORLD_TRANSFORM_SET              0x00000020L
#define POSITIVE_Y_IS_UP                 0x00000040L
#define INVALIDATE_ATTRIBUTES            0x00000080L
#define PTOD_EFM11_NEGATIVE              0x00000100L
#define PTOD_EFM22_NEGATIVE              0x00000200L
#define ISO_OR_ANISO_MAP_MODE            0x00000400L
#define PAGE_TO_DEVICE_IDENTITY          0x00000800L
#define PAGE_TO_DEVICE_SCALE_IDENTITY    0x00001000L
#define PAGE_XLATE_CHANGED               0x00002000L
#define PAGE_EXTENTS_CHANGED             0x00004000L
#define WORLD_XFORM_CHANGED              0x00008000L


#endif  // #ifndef INC_XFFLAGS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\array.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    array.cxx

Abstract:

    This file contains Array class implementation.

Author:

    Jason Hartman (JasonHa) 2000-12-28

Environment:

    User Mode

--*/

#include "precomp.hxx"



template <class T>
Array<T>::Array(
    SIZE_T StartLength
    )
{
    Init();
    Expand(StartLength);
    return;
}


template <class T>
Array<T>::Array(
    T *Data,
    SIZE_T Count
    )
{
    Init();
    Set(Data, Count);
    return;
}


template <class T>
SIZE_T
Array<T>::Expand(
    SIZE_T NewLength
    )
{
    if (NewLength > Length)
    {
        if (NewLength <= Size)
        {
            RtlZeroMemory(Buffer+Length, sizeof(T)*(NewLength-Length));
            Length = NewLength;
        }
        else
        {
            if (hHeap == NULL)
            {
                hHeap = GetProcessHeap();
            }

            if (hHeap != NULL)
            {
                T *NewBuffer;

                NewBuffer = (T *) ((Buffer == NULL) ?
                                   HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(T)*NewLength):
                                   HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, Buffer, sizeof(T)*NewLength));

                if (NewBuffer != NULL)
                {
                    Buffer = NewBuffer;
                    Size = HeapSize(hHeap, 0, Buffer) / sizeof(T);
                    Length = NewLength;
                }
            }

        }
    }

    return Length;
}


template <class T>
void
Array<T>::Set(
    T *Data,
    SIZE_T Count,
    SIZE_T Start
    )
{
    if (Count+Start > Expand(Count+Start)) return;

    RtlCopyMemory(Buffer+Start, Data, sizeof(T)*Count);

    return;
}



template class Array<BOOL>;
template class Array<CHAR>;
template class Array<ULONG>;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\inc\stdcall.inc ===
;****************************Public Macro************************************
;
;   ComposeInst Inst,p1,p2,p3,p4,p5,p6,p7,p8,p9
;
;       This macro simply concatenates all arguments into one string.
;
;   History:
;       Thu 15-Aug-1991 16:21:14    -by-    Viroon Touranachun [viroont]
;           Created
;
; Module Name: stdcall.inc
;
; Copyright (c) 1991-1999 Microsoft Corporation
;****************************************************************************
  
;
;****************************************************************************

ComposeInst macro   Inst,p1,p2,p3,p4,p5,p6,p7,p8,p9
        &Inst   &p1&p2&p3&p4&p5&p6&p7&p8&p9
endm

;****************************Public Macro************************************
;
;   CountArg    cCount,ArgList
;
;       This macro count the number of arguments in the ArgList and returns
;       the value in cCount.
;
;   History:
;       Thu 15-Aug-1991 16:21:14    -by-    Viroon Touranachun [viroont]
;           Created
;
;****************************************************************************

CountArg    macro   cCount,ArgList

        cCount = 0

        irp arg,<ArgList>
            cCount = cCount+1
        endm
endm

;****************************Public Macro************************************
;
;   RevPush     ArgList,cCount
;
;       This macro pushes the arguments in ArgList in the reverse order
;       and returns the number of arguments in cCount.
;
;   History:
;       Thu 15-Aug-1991 16:21:14    -by-    Viroon Touranachun [viroont]
;           Created
;
;****************************************************************************

RevPush macro   ArgList,cCount
        Local   index,x

        CountArg cCount,<ArgList>

        index  = cCount
        rept    cCount
            x = 0
            irp arg,<ArgList>
                x = x+1
                ife index-x
                    push    arg
                    exitm
                endif
            endm
            index = index-1
        endm
endm

;****************************Public Macro************************************
;
;   The following sections contain calling-convention related macros for:
;
;   PUBLICP     Func,N
;       to define a public label
;
;   EXTRNP      Func,N
;       to define a external near label
;
;   LABELP      Func,N
;       to label an address as a routine entry point
;
;   cProc       Func,N,ArgList
;       to declare a routine header
;
;   ProcName    Name,Func,N
;       to rename a function Func to Name. Using it in conjunction with
;       normal function declaration (with the new name) will solve an error
;       caused by a long parameter list routine that exhausts page width.
;
;   cRet        Func
;       to return from Func routines (declared with cProc or ProcName.)
;
;   endProc     Func
;       to declare the end of routine (declared with cProc or ProcName.)
;
;   endMod      Func
;       to declare the end of module with an entry point at Func (declared
;       with cProc or ProcName.)
;
;   cCall       Func,ArgList
;       to call to a routine--Func--with the arguments pushed on the stack
;
;   ptrCall     Func,ArgList
;       to call through a pointer with the arguments pushed on the stack
;
;   MovAddr     dest,Func,n
;       to move the address of the routine--Func--into dest.
;
;   Note that for the standard calling convention all the function names,
;   Func, are automatically converted to Func@N where N is the number of
;   bytes in the argument list.
;
;   History:
;       Thu 15-Aug-1991 16:21:14    -by-    Viroon Touranachun [viroont]
;           Created
;
;****************************************************************************

IFNDEF  DOS_PLATFORM
IFNDEF  STD_CALL

;****************************************************************************
;
;   This section is used exclusively for C calling convention.
;
;****************************************************************************

PUBLICP macro   Func,N

        public      &Func
endm

EXTRNP  macro   Func,N

        extrn       &Func:NEAR
endm

LABELP  macro   Func,N

        &Func       LABEL   NEAR
endm

ProcName macro  Name,Func,N

        &Name        EQU     <&Func>
endm

cProc   macro   Func,N,ArgList

        ProcName xxx&Func,Func,N

        xxx&Func proc &ArgList
endm

cRet    macro   Func

        ret
endm

endProc macro   Func

        xxx&Func   endp
endm

endMod  macro   Func

end     xxx&Func

endm

ptrCall macro   Func,ArgList
        Local   Bytes

        RevPush <ArgList>,Bytes
        Bytes = Bytes*4

        call    &Func

        if      Bytes GT 0
            add     esp,Bytes
        endif
endm

cCall   macro   Func,ArgList
        Local   Bytes

        RevPush <ArgList>,Bytes
        Bytes = Bytes*4

        call    &Func

        if      Bytes GT 0
            add     esp,Bytes
        endif

endm

MovAddr macro   dest,addr,n

        mov     dest,offset FLAT:&addr
endm

ENDIF   ; STD_CALL

ELSE

IFNDEF  STD_CALL

;****************************************************************************
;
;   This section is used exclusively for Pascal calling convention.
;
;****************************************************************************

PUBLICP macro   Func,N

        public      &Func
endm

EXTRNP  macro   Func,N

        extrn       &Func:NEAR
endm

LABELP  macro   Func,N

        &Func       LABEL   NEAR
endm

ProcName macro  Name,Func,N

        &Name        EQU     <&Func>
endm

cProc   macro   Func,N,ArgList

        ProcName xxx&Func,Func,N

        xxx&Func proc &ArgList
endm

cRet    macro   Func

        ret
endm

endProc macro   Func

        xxx&Func   endp
endm

endMod  macro   Func

end     xxx&Func

endm

cCall   macro   Func,ArgList
        irp arg,<ArgList>
            push    arg
        endm

        call    &Func
endm

MovAddr macro   dest,addr,n

        mov     dest,offset FLAT:&addr
endm

ENDIF   : ~STD_CALL
ENDIF   ; DOS_PLATFORM

IFDEF STD_CALL
;****************************************************************************
;
;   This section is used exclusively for the standard calling convention.
;
;****************************************************************************

PUBLICP macro   Func,N

        ifb    <N>
            public      &Func&@0
        else
            public      &Func&@&N
        endif
endm

EXTRNP  macro   Func,N

        ifb    <N>
            extrn       &Func&@0:NEAR
        else
            extrn       &Func&@&N:NEAR
        endif
endm

LABELP  macro   Func,N

        ifb    <N>
            &Func&@0    LABEL   NEAR
        else
            &Func&@&N   LABEL   NEAR
        endif
endm

ProcName macro  Name,Func,N

        ifb <N>
            cByte&Func   EQU     0
            &Name        EQU     <&Func&@0>
        else
            cByte&Func   EQU     N
            &Name        EQU     <&Func&@&N>
        endif
endm

cProc   macro   Func,N,ArgList

        ProcName xxx&Func,Func,N

        xxx&Func proc &ArgList
endm

cRet    macro   Func

        ret     cByte&Func

endm


endProc macro   Func

        xxx&Func   endp

endm

endMod  macro   Func

end     xxx&Func

endm

ptrCall macro   Func,ArgList
        Local   Bytes

        RevPush <ArgList>,Bytes
        call    &Func
endm

cCall   macro   Func,ArgList
        Local   Bytes

        RevPush <ArgList>,Bytes
        Bytes = Bytes*4

        ComposeInst <call>,&Func,<@>,%(Bytes)
endm

MovAddr macro   dest,addr,n

        ComposeInst <mov >,dest,<,offset FLAT:>,addr,<@>,n
endm

ENDIF   ;STD_CALL

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\inc\winres.h ===
/******************************Module*Header*******************************\
* Module Name: winres.h
*
* structures for accessing font resources within 16 bit fon dlls
*
* Created: 08-May-1991 13:12:57
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

//
//   The main structure for manipulating the resource data.  One of these
//  is created when access is required to a resource,  and it is destroyed
//  when the resource is no longer required.


typedef  struct                 // wrd
{
    PVOID     pvView;           // view of the mapped *.fon file
    ULONG     cjView;           // size of the view

// stuff referring to general resources

    PTRDIFF   dpNewExe;     // Base address of new header in file
    ULONG     ulShift;      // Shift factor for resource info
    PTRDIFF   dpResTab;     // Offset in file of resource table (first RSRC_TYPEINFO struct)
    ULONG     cjResTab;     // Bytes  in file to store for above

// stuff referring to font resources specifically

    ULONG     cFntRes;          // # of font resources in a file
    PTRDIFF   dpFntTab;         // File location of first RSRC_NAMEINFO corresponding to an *.fnt resource
    PTRDIFF   dpFdirRes;        // File location of first RSRC_NAMEINFO corresponding to an FONTDIR resource

} WINRESDATA,  *PWINRESDATA;

//  Bit fields for use with status above.


#define WRD_NOTHING     0x0000  // Unitialised state
#define WRD_FOPEN       0x0001  // File is open
#define WRD_RESDATOK        0x0002  // Resource data available ???


//  The structure passed to,  and filled in by, vGetFontRes().  Contains
//  information about a specific resource type & name.


typedef  struct _RES_ELEM       // re
{
    PVOID   pvResData;      // Address of data
    PTRDIFF dpResData;      // offset of the data above, not used for fon32
    ULONG   cjResData;      // Resource size
    PBYTE   pjFaceName;     // Face name from the font directory
} RES_ELEM, *PRES_ELEM;



//  Function Prototypes

BOOL   bInitWinResData
(
    PVOID pvView,
    ULONG cjView,
    PWINRESDATA pwrd
);

VOID vGetFntResource
(
    PWINRESDATA pwrd,
    ULONG       iRes,
    PRES_ELEM   pre
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\callback.cxx ===
/******************************Module*Header*******************************\
* Module Name: callback.cxx
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/


#include "precomp.hxx"


BOOL        gbCallbacksPrintNewline = FALSE;
int         gCallbacksPrintNameWidth = -1;
NTSTATUS    gCallbackReturnValue = STATUS_SUCCESS;


ULONG FieldCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    if (gbCallbacksPrintNewline) dprintf("\n");
    dprintf(" ** FieldCallback(%lx, %lx) **\n", pField, UserContext);
    if (pField)
    {
        dprintf(" Field:\n");
        dprintf("  fName        : %s\n", pField->fName);
        dprintf("  printName    : %s\n", pField->printName);
        dprintf("  size         : %d\n", pField->size);
        dprintf("  fOptions     : %#x\n", pField->fOptions);
        dprintf("  address      : %#I64x\n", pField->address);
        dprintf("  fieldCallBack: %lx\n", pField->fieldCallBack);
    }
    if (UserContext)
    {
        dprintf(" UserContext:  ???\n");
    }

    return gCallbackReturnValue;
}


/**************************************************************************\
*
* PrintName
*
*   Prints the field name or print name if callbacks are supposed to.
*
\**************************************************************************/

VOID PrintName(PFIELD_INFO pField)
{
    if (pField)
    {
        if (gCallbacksPrintNameWidth >= 0)
        {
            if (pField->printName)
            {
                dprintf("%*s", gCallbacksPrintNameWidth, pField->printName);
            }
            else if (pField->fName)
            {
                dprintf("%*s", gCallbacksPrintNameWidth, pField->fName);
            }
        }
        else
        {
            if (pField->fOptions & DBG_DUMP_FIELD_NO_PRINT)
            {
                if (pField->printName)
                {
                    dprintf("  +0x___ %s ", pField->printName);
                }
                else if (pField->fName)
                {
                    dprintf("  +0x___ %s ", pField->fName);
                }
            }
        }
    }
}


/**************************************************************************\
*
* NextItemCallbackInit
*
*   Specify printing and validation info to NextItemCallbacks.
*
\**************************************************************************/

BOOL    PrintItemHeader = FALSE;
char    szItemHeader[512] = "";
ULONG64 LastItemExpected = 0;
BOOL    FoundLastItemExpected = FALSE;

void NextItemCallbackInit(
    const char *pszPrintHeader,
    ULONG64 LastItemAddr
    )
{
    if (pszPrintHeader != NULL)
    {
        strncpy(szItemHeader, pszPrintHeader, sizeof(szItemHeader));
        szItemHeader[sizeof(szItemHeader)-1] = 0;
        PrintItemHeader = TRUE;
    }
    else
    {
        PrintItemHeader = FALSE;
    }

    LastItemExpected = LastItemAddr;
    FoundLastItemExpected = (LastItemExpected == 0);
}


/**************************************************************************\
*
* LastCallbackItemFound
*
*   Returns TRUE if address specified in NextItemCallbackInit was found.
*   Note: Always returns TRUE if 0 was specified for address.
*
\**************************************************************************/

BOOL LastCallbackItemFound()
{
    return FoundLastItemExpected;
}


/**************************************************************************\
*
* NextItemCallback
*
*   Use with linked list dumping when initial address is the first item's.
*
\**************************************************************************/

ULONG NextItemCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    ULONG64 NextAddr = 0;

    if (pField == NULL)
    {
        if (gbCallbacksPrintNewline) dprintf("\n");
        dprintf("Error: NextItemCallback was given NULL pField.\n");
    }
    else
    {
        if (pField->address == 0)
            return STATUS_UNSUCCESSFUL;

        if (LastItemExpected != 0)
        {
            if (FoundLastItemExpected)
            {
                dprintf(" * Error: Next item is beyond last expected @ %#p\n", LastItemExpected);
            }
            else if (LastItemExpected == pField->address)
            {
                FoundLastItemExpected = TRUE;
            }
        }

        if (PrintItemHeader)
        {
            dprintf(szItemHeader);
            dprintf("%#p\n", pField->address);
        }
    }

    return STATUS_SUCCESS;
}


/**************************************************************************\
*
* PointerToNextItemCallback
*
*   Use with linked list dumping when initial address is a pointer to type.
*
\**************************************************************************/

ULONG PointerToNextItemCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    ULONG64 NextAddr = 0;

    if (pField == NULL)
    {
        if (gbCallbacksPrintNewline) dprintf("\n");
        dprintf("Error: PointerToNextItemCallback was given NULL pField.\n");
    }
    else
    {
        if (pField->address == 0)
            return STATUS_UNSUCCESSFUL;

        if (!ReadPointer(pField->address, &NextAddr) || NextAddr == 0)
            return STATUS_UNSUCCESSFUL;

        if (LastItemExpected != 0)
        {
            if (FoundLastItemExpected)
            {
                dprintf(" * Error: Next item is beyond last expected @ %#p\n", LastItemExpected);
            }
            else if (LastItemExpected == NextAddr)
            {
                FoundLastItemExpected = TRUE;
            }
        }

        if (PrintItemHeader)
        {
            dprintf(szItemHeader);
        }
    }

    return STATUS_SUCCESS;
}


/**************************************************************************\
*
* ArrayCallback
*
*   Use with array dumping.
*
\**************************************************************************/

ULONG ArrayCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    static PFIELD_INFO  ArrayField = NULL;
    static ULONG        ArrayIndex = 0;
    static ULONG        ArrayIndexWidth;

    if (pField != ArrayField || pField->size <= ArrayIndex)
    {
        ArrayField = pField;

        if (ArrayIndex != 0 && gbVerbose)
        {
            dprintf("Warning: Beginning new array w/o completing last.\n");
        }
        ArrayIndex = 0;
    }

    if (ArrayIndex == 0)
    {
        ULONG i = pField->size-1;
        ArrayIndexWidth = 1;
        dprintf("Idx");
        while (i /= 10)
        {
            dprintf(" ");
            ArrayIndexWidth++;
        }

        PrintName(pField);
    }

    dprintf("\n[%*u]", ArrayIndexWidth, ArrayIndex++);

    // If we hit the end of an array,
    // prepare for a new array.
    if (pField->size == ArrayIndex)
    {
        ArrayField = NULL;
        ArrayIndex = 0;
    }

    return STATUS_SUCCESS;
}


/**************************************************************************\
*
* NewlineCallback
*
*   To be used with DBG_DUMP_COMPACT_OUT as default callback.
*
\**************************************************************************/

ULONG NewlineCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    dprintf("\n");

    if (!gbCallbacksPrintNewline && gbVerbose)
    {
        dprintf(" Note: NewlineCallback called, but gbCallbacksPrintNewline is FALSE.\n");
    }

    return STATUS_SUCCESS;
}


/**************************************************************************\
*
* AddressPrintCallback
*
*   Useful with DBG_DUMP_FIELD_RETURN_ADDRESS when the field is 
*   a large embedded structure you don't want to print.
*
\**************************************************************************/

ULONG AddressPrintCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    if (pField == NULL)
    {
        dprintf("\nError: AddressPrintCallback was given NULL pField.");
    }
    else
    {
        PrintName(pField);

        if (gbVerbose) dprintf(" (pField->size = %d) ", pField->size);
        dprintf("%#p", pField->address);
    }

    if (gbCallbacksPrintNewline) dprintf("\n");

    return gCallbackReturnValue;
}


/**************************************************************************\
*
* Basic Type Callbacks:
*   BOOL, BYTE, CHAR, DecimalCHAR, DecimalUCHAR,
*   DWORD, LONG, SHORT, WORD, ULONG, USHORT
*
\**************************************************************************/

ULONG BOOLCallback(PFIELD_INFO pField, PVOID UserContext)
{
    PrintName(pField);
    dprintf("%s", ((BOOL)pField->address) ? "TRUE" : "FALSE");
    if (gbCallbacksPrintNewline) dprintf("\n");
    return gCallbackReturnValue;
}

ULONG BYTECallback(PFIELD_INFO pField, PVOID UserContext)
{
    PrintName(pField);
    dprintf("0x%2.2X", (BYTE)pField->address);
    if (gbCallbacksPrintNewline) dprintf("\n");
    return gCallbackReturnValue;
}

ULONG CHARCallback(PFIELD_INFO pField, PVOID UserContext)
{
    PrintName(pField);
    dprintf("'%c'", (CHAR)pField->address);
    if (gbCallbacksPrintNewline) dprintf("\n");
    return gCallbackReturnValue;
}

ULONG DecimalCHARCallback(PFIELD_INFO pField, PVOID UserContext)
{
    PrintName(pField);
    dprintf("%d", (CHAR)pField->address);
    if (gbCallbacksPrintNewline) dprintf("\n");
    return gCallbackReturnValue;
}

ULONG DecimalUCHARCallback(PFIELD_INFO pField, PVOID UserContext)
{
    PrintName(pField);
    dprintf("%u", (UCHAR)pField->address);
    if (gbCallbacksPrintNewline) dprintf("\n");
    return gCallbackReturnValue;
}

ULONG DWORDCallback(PFIELD_INFO pField, PVOID UserContext)
{
    PrintName(pField);
    dprintf("0x%8.8lX", (DWORD)pField->address);
    if (gbCallbacksPrintNewline) dprintf("\n");
    return gCallbackReturnValue;
}

ULONG LONGCallback(PFIELD_INFO pField, PVOID UserContext)
{
    PrintName(pField);
    dprintf("%ld", (LONG)pField->address);
    if (gbCallbacksPrintNewline) dprintf("\n");
    return gCallbackReturnValue;
}

ULONG WORDCallback(PFIELD_INFO pField, PVOID UserContext)
{
    PrintName(pField);
    dprintf("0x%4.4X", (WORD)pField->address);
    if (gbCallbacksPrintNewline) dprintf("\n");
    return gCallbackReturnValue;
}

ULONG SHORTCallback(PFIELD_INFO pField, PVOID UserContext)
{
    PrintName(pField);
    dprintf("%d", (SHORT)pField->address);
    if (gbCallbacksPrintNewline) dprintf("\n");
    return gCallbackReturnValue;
}

ULONG ULONGCallback(PFIELD_INFO pField, PVOID UserContext)
{
    PrintName(pField);
    dprintf("%lu", (ULONG)pField->address);
    if (gbCallbacksPrintNewline) dprintf("\n");
    return gCallbackReturnValue;
}

ULONG USHORTCallback(PFIELD_INFO pField, PVOID UserContext)
{
    PrintName(pField);
    dprintf("%u", (USHORT)pField->address);
    if (gbCallbacksPrintNewline) dprintf("\n");
    return gCallbackReturnValue;
}


/**************************************************************************\
*
* EnumCallback
*
*   Specify ENUMDEF * in SYM_DUMP_PARAM.Context field
*
*   Note: Only one Enum/FlagCallback can be specified per FIELD_INFO array.
*
\**************************************************************************/

ULONG EnumCallback(
    PFIELD_INFO pField,
    ENUMDEF *pEnumDef
    )
{
    if (pField == NULL || pEnumDef == NULL)
    {
        if (gbCallbacksPrintNewline) dprintf("\n");
        dprintf("Error: EnumCallback had NULL parameter.\n");
        return STATUS_UNSUCCESSFUL;
    }

    PrintName(pField);

    if (!gbCallbacksPrintNewline &&
        !(pField->fOptions & DBG_DUMP_FIELD_NO_PRINT))
    {
        dprintf("     ");
    }

    dprintf(" ");
    if (! bPrintEnum(pEnumDef, (ULONG)pField->address))
    {
        dprintf("Unknown Value");
        if (pField->fOptions & DBG_DUMP_FIELD_NO_PRINT)
        {
            dprintf(": %lu", (ULONG)pField->address);
        }
    }
    dprintf("\n");

    return gCallbackReturnValue;
}


/**************************************************************************\
*
* FlagCallback
*
*   Specify FLAGDEF * in SYM_DUMP_PARAM.Context field
*
*   Note: Only one Enum/FlagCallback can be specified per FIELD_INFO array.
*
\**************************************************************************/

ULONG FlagCallback(
    PFIELD_INFO pField,
    FLAGDEF *pFlagDef
    )
{
    ULONG64 UnknownFlags;

    PrintName(pField);

    if (gbCallbacksPrintNewline) dprintf("\n");

    if (pField == NULL || pFlagDef == NULL)
    {
        dprintf("Error: FlagCallback had NULL parameter.\n");
        return STATUS_UNSUCCESSFUL;
    }

    UnknownFlags = flPrintFlags(pFlagDef, pField->address);
    if (UnknownFlags)
    {
        if (UnknownFlags != pField->address) dprintf("\n");
        dprintf("      Uknown flags: 0x%lx", UnknownFlags);
    }
    dprintf("\n");

    return gCallbackReturnValue;
}


/**************************************************************************\
*
* POINTLCallback
*
\**************************************************************************/

ULONG POINTLCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    NTSTATUS RetVal = gCallbackReturnValue;
    ULONG error;

    if (pField == NULL)
    {
        dprintf("\nError: POINTLCallback was given NULL pField.");
    }
    else
    {
        PrintName(pField);

        if (!pField->address)
        {
            dprintf("\nError: POINTLCallback: pField->address = NULL");

            RetVal = STATUS_UNSUCCESSFUL;
        }
        else if (error = (ULONG)InitTypeRead(pField->address, win32k!_POINTL))
        {
            dprintf("\n  InitTypeRead returned %s", pszWinDbgError(error));

            RetVal = error;
        }
        else
        {
            dprintf("(%d,%d)",
                    (LONG)ReadField(x),
                    (LONG)ReadField(y));
        }
    }

    if (gbCallbacksPrintNewline) dprintf("\n");

    return RetVal;
}


/**************************************************************************\
*
* RECTLCallback
*
\**************************************************************************/

ULONG RECTLCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    NTSTATUS RetVal = gCallbackReturnValue;
    ULONG error;

    if (pField == NULL)
    {
        dprintf("\nError: RECTLCallback was given NULL pField.");
    }
    else
    {
        PrintName(pField);

        if (!pField->address)
        {
            dprintf("\nError: RECTLCallback: pField->address = NULL");

            RetVal = STATUS_UNSUCCESSFUL;
        }
        else if (error = (ULONG)InitTypeRead(pField->address, win32k!_RECTL))
        {
            dprintf("\n  InitTypeRead returned %s", pszWinDbgError(error));

            RetVal = error;
        }
        else
        {
            dprintf("(%d,%d) - (%d,%d)",
                    (LONG)ReadField(left),
                    (LONG)ReadField(top),
                    (LONG)ReadField(right),
                    (LONG)ReadField(bottom));
        }
    }

    if (gbCallbacksPrintNewline) dprintf("\n");

    return RetVal;
}


/**************************************************************************\
*
* SIZECallback
*
\**************************************************************************/

ULONG SIZECallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    NTSTATUS RetVal = gCallbackReturnValue;
    ULONG error;

    if (pField == NULL)
    {
        dprintf("\nError: SIZECallback was given NULL pField.");
    }
    else
    {
        PrintName(pField);

        if (!pField->address)
        {
            dprintf("\nError: SIZECallback: pField->address = NULL");

            RetVal = STATUS_UNSUCCESSFUL;
        }
        else if (error = (ULONG)InitTypeRead(pField->address, win32k!tagSIZE))
        {
            dprintf("\n  InitTypeRead returned %s", pszWinDbgError(error));

            RetVal = error;
        }
        else
        {
            dprintf("%d x %d",
                    (LONG)ReadField(cx),
                    (LONG)ReadField(cy));
        }
    }

    if (gbCallbacksPrintNewline) dprintf("\n");

    return RetVal;
}


/**************************************************************************\
*
* SIZELCallback
*
\**************************************************************************/

ULONG SIZELCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    return SIZECallback(pField, UserContext);
}


/**************************************************************************\
*
* PrintDEVMODEList
*
\**************************************************************************/

ULONG PrintDEVMODEList(
    ULONG64 DevModeListAddr,
    ULONG   DevModeListSize
    )
{
    ULONG64 DevModeEnd;
    ULONG   error = 0;

    #define DEVMODE_DMDRIVEREXTRA       0
    #define DEVMODE_DMSIZE              1
    #define DEVMODE_DMPELSWIDTH         2
    #define DEVMODE_DMPELSHEIGHT        3
    #define DEVMODE_DMBITSPERPEL        4
    #define DEVMODE_DMDISPLAYFREQUENCY  5

    FIELD_INFO  DevModeFields[] = {
        { DbgStr("dmDriverExtra"),     NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("dmSize"),     NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("dmPelsWidth"),     NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("dmPelsHeight"),     NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("dmBitsPerPel"),     NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("dmDisplayFrequency"),     NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
    };
    SYM_DUMP_PARAM DevModeSym = {
        sizeof(SYM_DUMP_PARAM), DbgStr(GDIType(_devicemodeW)), DBG_DUMP_NO_PRINT, DevModeListAddr,
        NULL, NULL, NULL, sizeof(DevModeFields)/sizeof(DevModeFields[0]), DevModeFields
    };

    DevModeEnd = DevModeSym.addr + DevModeListSize;
    while ((DevModeSym.addr < DevModeEnd) && 
           !(error = Ioctl( IG_DUMP_SYMBOL_INFO, &DevModeSym, DevModeSym.size )))
    {
        dprintf("\t %4d x %4d %2d %3d\n",
                (DWORD)DevModeFields[DEVMODE_DMPELSWIDTH].address,
                (DWORD)DevModeFields[DEVMODE_DMPELSHEIGHT].address,
                (DWORD)DevModeFields[DEVMODE_DMBITSPERPEL].address,
                (DWORD)DevModeFields[DEVMODE_DMDISPLAYFREQUENCY].address);

        DevModeSym.addr += DevModeFields[DEVMODE_DMDRIVEREXTRA].address + DevModeFields[DEVMODE_DMSIZE].address;
    }

    return error;
}


/**************************************************************************\
*
* DEVMODECallback
*
\**************************************************************************/

ULONG DEVMODECallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    PrintName(pField);

    if (pField == NULL)
    {
        if (gbCallbacksPrintNewline) dprintf("\n");
        dprintf(" Error: DEVMODEListCallback was given NULL pField.\n");
    }
    else if (pField->address)
    {
        ULONG error;

        if (error = PrintDEVMODEList(pField->address, 1))
        {
            dprintf("  PrintDEVMODEList returned %s in DEVMODECallback\n", pszWinDbgError(error));
        }
    }
    else
    {
        dprintf(" DEVMODE address is NULL\n");
    }

    return gCallbackReturnValue;
}


/**************************************************************************\
*
* DEVMODEListCallback and SizeDEVMODEListCallback
*
*   Make sure these are always called in conjuction with
*   SizeDEVMODEListCallback before DEVMODEListCallback.
*
\**************************************************************************/

ULONG   cbDevModeList = -1;

ULONG SizeDEVMODEListCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    if (gbCallbacksPrintNewline) dprintf("\n");

    if (pField == NULL)
    {
        dprintf("Error: SizeDEVMODEListCallback was given NULL pField.\n");
    }
    else
    {
        if (cbDevModeList != -1)
        {
            dprintf(" Warning: cbDevModeList (%d) was not clear before call to SizeDEVMODEListCallback\n", cbDevModeList);
        }

        cbDevModeList = (ULONG)pField->address;
    }

    return STATUS_SUCCESS;
}

ULONG DEVMODEListCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    PrintName(pField);

    if (gbCallbacksPrintNewline) dprintf("\n");

    if (pField == NULL)
    {
        dprintf(" Error: DEVMODEListCallback was given NULL pField.\n");
    }
    else if (cbDevModeList == -1)
    {
        dprintf(" Error: cbDevModeList has not been set properly.\n");
    }
    else if (pField->address)
    {
        ULONG error;

        if (error = PrintDEVMODEList(pField->address, cbDevModeList))
        {
            dprintf("  PrintDEVMODEList returned %s in DEVMODEListCallback\n", pszWinDbgError(error));
        }
    }
    else if (cbDevModeList != 0)
    {
        dprintf(" DEVMODE list size (%d) is non-zero, but DEVMODE list address is NULL.\n", cbDevModeList);
    }

    cbDevModeList = -1;

    return gCallbackReturnValue;
}



/**************************************************************************\
*
* PrintAString
*
*   Reads and prints a char string at given target address.
*
*   Returns address just past end of string or address of read failure.
*
\**************************************************************************/

ULONG64 PrintAString(
    ULONG64 StringAddr
    )
{
    CHAR    Char;
    ULONG   cbRead;

    if (StringAddr != 0)
    {
        while (ReadMemory(StringAddr, &Char, sizeof(Char), &cbRead) &&
               cbRead == sizeof(Char) &&
               (StringAddr+=sizeof(Char)) &&
               Char != 0)
        {
            dprintf("%hc", Char);
        }
    }

    return StringAddr;
}


/**************************************************************************\
*
* PrintWString
*
*   Reads and prints a two-byte char string at given target address.
*
*   Returns address just past end of string or address of read failure.
*
\**************************************************************************/

ULONG64 PrintWString(
    ULONG64 StringAddr
    )
{
    WCHAR   Char;
    ULONG   cbRead;

    if (StringAddr != 0)
    {
        while (ReadMemory(StringAddr, &Char, sizeof(Char), &cbRead) &&
               cbRead == sizeof(Char) &&
               (StringAddr+=sizeof(Char)) &&
               Char != 0)
        {
            dprintf("%lc", Char);
        }
    }

    return StringAddr;
}



/**************************************************************************\
*
* String printing callbacks
*
*   To be used when DBG_DUMP_FIELD_xxx_STRING flags can't be used.
*
\**************************************************************************/

/**************************************************************************\
*
* ACharArrayCallback callback for an array of chars
*
*   Use DBG_DUMP_FIELD_RETURN_ADDRESS flag
*
\**************************************************************************/

ULONG ACharArrayCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    CHAR    szBuffer[128];
    ULONG   cbRead = 0;

    if (pField == NULL)
    {
        dprintf("\nError: ACharArrayCallback was given NULL pField.");
    }
    else
    {
        PrintName(pField);

        if (gbVerbose && pField->size == 0)
            dprintf("\n Note: ACharArrayCallback was given zero length array.\n");

        if (pField->address)
        {
            if (pField->size < sizeof(szBuffer))
            {
                if (!ReadMemory(pField->address, szBuffer, pField->size, &cbRead) || cbRead == 0)
                {
                    dprintf(" Memory read failed @ %#p", pField->address);
                }
                else
                {
                    szBuffer[min(cbRead,sizeof(szBuffer)-sizeof(CHAR))/sizeof(CHAR)] = (CHAR) 0;
                    dprintf(" \"%hs\"", szBuffer);
                }
            }
            else
            {
                PCHAR  pszBuffer = (PCHAR) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, pField->size+sizeof(CHAR));

                if (pszBuffer == NULL)
                {
                    dprintf(" Buffer allocation failed - single-byte string @ %#p", pField->address);
                }
                else if (!ReadMemory(pField->address, szBuffer, pField->size, &cbRead) || cbRead == 0)
                {
                    dprintf(" Memory read failed @ %#p", pField->address);
                }
                else
                {
                    dprintf(" \"%hs\"", szBuffer);
                }
            }
        }
        else
        {
            dprintf(" (null)");
        }
    }

    if (gbCallbacksPrintNewline) dprintf("\n");

    return gCallbackReturnValue;
}


/**************************************************************************\
*
* WCharArrayCallback callback for an array of two-byte chars
*
*   Use DBG_DUMP_FIELD_RETURN_ADDRESS flag
*
\**************************************************************************/

ULONG WCharArrayCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    WCHAR   wszBuffer[128];
    ULONG   cbRead = 0;

    if (pField == NULL)
    {
        dprintf("\nError: WStringCallback was given NULL pField.");
    }
    else
    {
        PrintName(pField);

        if (gbVerbose && pField->size == 0)
            dprintf("\n Note: WCharArrayCallback was given zero length array.\n");

        if (pField->address)
        {
            if (pField->size < sizeof(wszBuffer))
            {
                if (!ReadMemory(pField->address, wszBuffer, pField->size, &cbRead) || cbRead == 0)
                {
                    dprintf(" Memory read failed @ %#p", pField->address);
                }
                else
                {
                    wszBuffer[min(cbRead,sizeof(wszBuffer)-sizeof(WCHAR))/sizeof(WCHAR)] = (WCHAR) 0;
                    dprintf(" \"%ls\"", wszBuffer);
                }
            }
            else
            {
                PWCHAR  pwszBuffer = (PWCHAR) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, pField->size+sizeof(WCHAR));

                if (pwszBuffer == NULL)
                {
                    dprintf(" Buffer allocation failed - wide string @ %#p", pField->address);
                }
                else if (!ReadMemory(pField->address, wszBuffer, pField->size, &cbRead) || cbRead == 0)
                {
                    dprintf(" Memory read failed @ %#p", pField->address);
                }
                else
                {
                    dprintf(" \"%ls\"", wszBuffer);
                }
            }
        }
        else
        {
            dprintf(" (null)");
        }
    }

    if (gbCallbacksPrintNewline) dprintf("\n");

    return gCallbackReturnValue;
}


/**************************************************************************\
*
* AStringCallback callback for a pointer to char string
*
\**************************************************************************/

ULONG AStringCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    CHAR    szBuffer[128];
    ULONG   cbRead = 0;

    if (pField == NULL)
    {
        dprintf("\nError: AStringCallback was given NULL pField.");
    }
    else
    {
        PrintName(pField);

        if (gbVerbose)
        {
            if (pField->size == 0)
                dprintf("\n Note: AStringCallback was given zero length type.\n");
            else if (pField->size != GetTypeSize("PVOID"))
                dprintf("\n Note: AStringCallback: String length is not the size of a pointer.\n"
                        "       Should you be using ACharArrayCallback?\n");
        }

        if (pField->address)
        {
            dprintf(" \"");
            PrintAString(pField->address);
            dprintf("\"");
        }
        else
        {
            dprintf(" (null)");
        }
    }

    if (gbCallbacksPrintNewline) dprintf("\n");

    return gCallbackReturnValue;
}


/**************************************************************************\
*
* WStringCallback callback for a pointer to two-byte char string
*
\**************************************************************************/

ULONG WStringCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    CHAR    szBuffer[128];
    ULONG   cbRead = 0;

    if (pField == NULL)
    {
        dprintf("\nError: WStringCallback was given NULL pField.");
    }
    else
    {
        PrintName(pField);

        if (gbVerbose)
        {
            if (pField->size == 0)
                dprintf("\n Note: WStringCallback was given zero length type.\n");
            else if (pField->size != GetTypeSize("PVOID"))
                dprintf("\n Note: WStringCallback: String length is not the size of a pointer.\n"
                        "       Should you be using WCharArrayCallback?\n");
        }

        if (pField->address)
        {
            dprintf(" \"");
            PrintWString(pField->address);
            dprintf("\"");
        }
        else
        {
            dprintf(" (null)");
        }
    }

    if (gbCallbacksPrintNewline) dprintf("\n");

    return gCallbackReturnValue;
}


/**************************************************************************\
*
* AMultiStringCallback callback for a pointer to several char
*   strings one after another.
*
\**************************************************************************/

ULONG AMultiStringCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    if (pField == NULL)
    {
        dprintf("\nError: AMultiStringCallback was given NULL pField.");
    }
    else
    {
        PrintName(pField);

        if (gbVerbose)
        {
            if (pField->size == 0)
                dprintf("\n Note: AMultiStringCallback was given zero length type.\n");
            else if (pField->size != GetTypeSize("PVOID"))
                dprintf("\n Note: AMulitStringCallback: String length is not the size of a pointer.\n"
                        "       Should you be using ACharArrayCallback?\n");
        }

        if (pField->address)
        {
            ULONG64 PrevAddr = NULL;
            ULONG64 CurAddr = pField->address;
            CHAR    Char;
            ULONG   cbRead;

            while (CurAddr != PrevAddr &&
                   ReadMemory(CurAddr, &Char, sizeof(Char), &cbRead) &&
                   cbRead == sizeof(Char) &&
                   Char != 0)
            {
                PrevAddr = CurAddr;

                dprintf("\n\t\"");
                CurAddr = PrintAString(CurAddr);
                dprintf("\"");
            }
        }
        else
        {
            dprintf(" (null)");
        }
    }

    if (gbCallbacksPrintNewline) dprintf("\n");

    return gCallbackReturnValue;
}


/**************************************************************************\
*
* WMultiStringCallback callback for a pointer to several two-byte char
*   strings one after another.
*
\**************************************************************************/

ULONG WMultiStringCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    if (pField == NULL)
    {
        dprintf("\nError: WMultiStringCallback was given NULL pField.");
    }
    else
    {
        PrintName(pField);

        if (gbVerbose)
        {
            if (pField->size == 0)
                dprintf("\n Note: WMultiStringCallback was given zero length type.\n");
            else if (pField->size != GetTypeSize("PVOID"))
                dprintf("\n Note: WMulitStringCallback: String length is not the size of a pointer.\n"
                        "       Should you be using WCharArrayCallback?\n");
        }

        if (pField->address)
        {
            ULONG64 PrevAddr = NULL;
            ULONG64 CurAddr = pField->address;
            WCHAR   Char;
            ULONG   cbRead;

            while (CurAddr != PrevAddr &&
                   ReadMemory(CurAddr, &Char, sizeof(Char), &cbRead) &&
                   cbRead == sizeof(Char) &&
                   Char != 0)
            {
                PrevAddr = CurAddr;

                dprintf("\n\t\"");
                CurAddr = PrintWString(CurAddr);
                dprintf("\"");
            }
        }
        else
        {
            dprintf(" (null)");
        }
    }

    if (gbCallbacksPrintNewline) dprintf("\n");

    return gCallbackReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\dbgkdext.h ===
/******************************Module*Header*******************************\
* Module Name: dbgext.h
*
* Copyright (c) 1995-1999 Microsoft Corporation
*
* Dependencies:
*
* common macros for debugger extensions
*
*
\**************************************************************************/


/**************************************************************************\
 *
 * GetAddress - symbol of another module
 *
\**************************************************************************/

#define GetAddress(dst, src)						\
    *((ULONG_PTR *) &dst) = GetExpression(src);

#define GetValue(dst,src)						\
    GetAddress(dst,src) 						\
    move(dst,dst);

/**************************************************************************\
 *
 * move(dst, src ptr)
 *
\**************************************************************************/

#define move(dst, src)							\
    ReadMemory((ULONG_PTR) (src), &(dst), sizeof(dst), NULL)

/**************************************************************************\
 *
 * move2(dst ptr, src ptr, num bytes)
 *
\**************************************************************************/
#define move2(dst, src, size)						\
    ReadMemory((ULONG_PTR) (src), (dst), (size), NULL)

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\basictypes.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    basictypes.cxx

Abstract:

    This file contains output routines for primitive types.

Author:

    Jason Hartman (JasonHa) 2000-12-18

Environment:

    User Mode

--*/

#include "precomp.hxx"


typedef struct {
    PCSTR               Type;
    ULONG               TypeId;
    FN_OutputKnownType *OutFunc;
} KnownType;

typedef struct {
    ULONG64     Module;
    ULONG       NumTypes;
    ULONG       TypesReady;     // Types for which GetTypeId has succeeded
    ULONG       TypesNotReady;  // Types for which GetTypeId hasn't been tried
    KnownType  *Types;
} KnownModuleTypes;


ULONG               BTModules = 0;
KnownModuleTypes    BTModule[4];

HANDLE              BTHeap;


FN_OutputKnownType OutputPOINTFIX;
FN_OutputKnownType OutputPOINTL;
FN_OutputKnownType OutputRECTFX;
FN_OutputKnownType OutputRECTL;
FN_OutputKnownType OutputSIZE;

KnownType   BTTypes[] = {
    {"_EFLOAT",     0, OutputEFLOAT_S},
    {"EFLOAT",      0, OutputEFLOAT_S},
    {"_EFLOAT_S",   0, OutputEFLOAT_S},
    {"EFLOAT_S",    0, OutputEFLOAT_S},
    {"_POINTFIX",   0, OutputPOINTFIX},
    {"POINTFIX",    0, OutputPOINTFIX},
    {"_POINTL",     0, OutputPOINTL},
    {"POINTL",      0, OutputPOINTL},
    {"EPOINTL",     0, OutputPOINTL},
    {"tagPOINT",    0, OutputPOINTL},
    {"POINT",       0, OutputPOINTL},
    {"_RECTFX",     0, OutputRECTFX},
    {"RECTFX",      0, OutputRECTFX},
    {"_RECTL",      0, OutputRECTL},
    {"RECTL",       0, OutputRECTL},
    {"ERECTL",      0, OutputRECTL},
    {"tagRECT",     0, OutputRECTL},
    {"RECT",        0, OutputRECTL},
    {"tagSIZE",     0, OutputSIZE},
    {"SIZE",        0, OutputSIZE},
    {"SIZEL",       0, OutputSIZE},
};

KnownModuleTypes    BTTemplate = { 0, lengthof(BTTypes), 0, 0, BTTypes };


/**************************************************************************\
*
* Routine Name:
*
*   BasicTypesInit
*
* Routine Description:
*
*   Initialize or reinitialize information to be read from symbols files
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*
* Return Value:
*
*   none
*
\**************************************************************************/

void
BasicTypesInit(
    PDEBUG_CLIENT Client
    )
{
    BasicTypesExit();
    return;
}


/**************************************************************************\
*
* Routine Name:
*
*   BasicTypesExit
*
* Routine Description:
*
*   Clean up any outstanding allocations or references
*
* Arguments:
*
*   none
*
* Return Value:
*
*   none
*
\**************************************************************************/

void
BasicTypesExit(
    )
{
    while (BTModules > 0)
    {
        BTModules--;

        HeapFree(BTHeap, 0, BTModule[BTModules].Types);
        BTModule[BTModules].Types = NULL;
        BTModule[BTModules].Module = 0;
    }

}


/**************************************************************************\
*
* Routine Name:
*
*   FindKnownType
*
* Routine Description:
*
*   Finds known type entry is type is one of the GDI primitive types.
*
\**************************************************************************/

KnownType *
FindKnownType(
    PDEBUG_CLIENT Client,
    ULONG64 Module,
    ULONG TypeId)
{
    BOOL        FoundType = FALSE;
    ULONG       ModIndex;

    for (ModIndex = 0; ModIndex < BTModules; ModIndex++)
    {
        if (BTModule[ModIndex].Module == Module)
        {
            break;
        }
    }

    // Allocate a new module type list if current module isn't found.
    if (ModIndex == BTModules &&
        BTModules < lengthof(BTModule))
    {
        SIZE_T  TemplateSize;

        if (BTHeap == NULL)
        {
            BTHeap = GetProcessHeap();
            if (BTHeap == NULL) return NULL;
        }

        TemplateSize = BTTemplate.NumTypes * sizeof(KnownType);

        BTModule[BTModules].Types = (KnownType *)HeapAlloc(BTHeap, 0, TemplateSize);

        if (BTModule[BTModules].Types != NULL)
        {
            BTModule[BTModules].Module = Module;
            BTModule[BTModules].NumTypes = BTTemplate.NumTypes;
            BTModule[BTModules].TypesReady = 0;
            BTModule[BTModules].TypesNotReady = BTModule[BTModules].NumTypes;
            RtlCopyMemory(BTModule[BTModules].Types, BTTemplate.Types, TemplateSize);

            BTModules++;
        }
    }

    if (ModIndex < BTModules)
    {
        KnownType      *Type;
        KnownType      *TypeLast;
        PDEBUG_SYMBOLS  Symbols;

        Type = BTModule[ModIndex].Types;

        // Search ready list
        TypeLast = Type + BTModule[ModIndex].TypesReady;

        while (Type < TypeLast)
        {
            if (Type->TypeId == TypeId) return Type;
            Type++;
        }

        // Initialize and search not ready list
        if (Client != NULL &&
            Client->QueryInterface(__uuidof(IDebugSymbols),
                                   (void **)&Symbols) == S_OK)
        {
            // Type is at beginning of not ready list;
            TypeLast = Type + BTModule[ModIndex].TypesNotReady;

            while (Type < TypeLast)
            {
                BTModule[ModIndex].TypesNotReady--;

                if (Symbols->GetTypeId(Module, Type->Type, &Type->TypeId) == S_OK)
                {
                    BTModule[ModIndex].TypesReady++;
                    if (Type->TypeId == TypeId) return Type;

                    Type++;
                }
                else
                {
                    // TypeLast to last entry of not ready list
                    TypeLast--;

                    if (Type < TypeLast)
                    {
                        // Swap last not ready entry with this failed type
                        // This entry will then be in failed list
                        KnownType TempKT = *Type;

                        *Type = *TypeLast;
                        *TypeLast = TempKT;
                    }
                }
            }

            Symbols->Release();
        }
    }

    return NULL;
}


/**************************************************************************\
*
* Routine Name:
*
*   IsKnownType
*
* Routine Description:
*
*   Checks if specified type one of the GDI primitive types.
*
\**************************************************************************/

BOOL
IsKnownType(
    PDEBUG_CLIENT Client,
    ULONG64 Module,
    ULONG TypeId)
{
    return (FindKnownType(Client, Module, TypeId) != NULL);
}


/**************************************************************************\
*
* Routine Name:
*
*   OutputKnownType
*
* Routine Description:
*
*   Output GDI primitive type at specified offset.
*
* Arguments:
*
*   
*
* Return Value:
*
*   S_OK if everything succeeded.
*
\**************************************************************************/

HRESULT
OutputKnownType(
    PDEBUG_CLIENT Client,
    OutputControl *OutCtl,
    ULONG64 Module,
    ULONG TypeId,
    ULONG64 Offset,
    ULONG Flags)
{
    HRESULT         hr = S_OK;
    OutputControl   NoOutput;
    KnownType      *Type;

    if (OutCtl == NULL) OutCtl = &NoOutput;

    Type = FindKnownType(Client, Module, TypeId);

    if (Type != NULL)
    {
        OutputReader    TypeReader;
        OutputState     OutState(Client, FALSE);
        PSTR            TypeDump;

        if (Offset == 0)
        {
            OutCtl->Output("%s", Type->Type);
        }
        else if ((hr = OutState.Setup(0, &TypeReader)) == S_OK &&
                 (hr = OutState.OutputTypeVirtual(Offset,
                                                  Module,
                                                  TypeId,
                                                  Flags)) == S_OK &&
                 (hr = TypeReader.GetOutputCopy(&TypeDump)) == S_OK)
        {
            if (TypeDump != NULL)
            {
                hr = Type->OutFunc(Client, OutCtl,
                                   Module, TypeId,
                                   TypeDump,
                                   Flags,
                                   NULL);

                TypeReader.FreeOutputCopy(TypeDump);
            }
        }
    }
    else
    {
        OutCtl->OutVerb("TypeId %lu in 0x%p is unknown GDI primitve.\n",
                        TypeId, Module);
        hr = S_FALSE;
    }

    return hr;
}


/**************************************************************************\
*
* Routine Name:
*
*   OutputFIXDec
*
* Routine Description:
*
*   Outputs a FIX in dotted Decimal format (##+#/16)
*
\**************************************************************************/

HRESULT
OutputFIXDec(
    OutputControl *OutCtl,
    PDEBUG_VALUE Fix
    )
{
    return OutCtl->Output(((Fix->Type != DEBUG_VALUE_INT32) ? "?" :
                          "%ld+%ld/16"), ((LONG)Fix->I32) >> 4, Fix->I32 & 0x0000000F);
}


/**************************************************************************\
*
* Routine Name:
*
*   OutputFIXHex
*
* Routine Description:
*
*   Outputs a FIX in dotted Hex format (0x#######.#)
*
\**************************************************************************/

HRESULT
OutputFIXHex(
    OutputControl *OutCtl,
    PDEBUG_VALUE Fix
    )
{
    return OutCtl->Output(((Fix->Type != DEBUG_VALUE_INT32) ? "?" :
                          "0x%lx.%lx"), Fix->I32 >> 4, Fix->I32 & 0x0000000F);
}


/**************************************************************************\
*
* Routine Name:
*
*   OutputPOINTFIX
*
* Routine Description:
*
*   Outputs a POINTFIX
*
\**************************************************************************/

HRESULT
OutputPOINTFIX(
    PDEBUG_CLIENT Client,
    OutputControl *OutCtl,
    ULONG64 Module,
    ULONG TypeId,
    PSTR Buffer,
    ULONG Flags,
    PULONG BufferUsed
    )
{
    HRESULT hr = S_FALSE;

    TypeOutputParser    Parser(Client);
    DEBUG_VALUE         x, y;

    if (Parser.LookFor(&x, "x", DEBUG_VALUE_INT32) == S_OK)
    {
        Parser.Parse(Buffer, NULL);
    }
    if (Parser.LookFor(&y, "y", DEBUG_VALUE_INT32) == S_OK)
    {
        Parser.Parse(Buffer, NULL);
    }

    OutCtl->Output("(");
    OutputFIXHex(OutCtl, &x);
    OutCtl->Output(",");
    OutputFIXHex(OutCtl, &y);
    OutCtl->Output(")   (");
    OutputFIXDec(OutCtl, &x);
    OutCtl->Output(",");
    OutputFIXDec(OutCtl, &y);
    hr = OutCtl->Output(")");

    return hr;
}


/**************************************************************************\
*
* Routine Name:
*
*   OutputPOINTL
*
* Routine Description:
*
*   Outputs a POINTL
*
\**************************************************************************/

HRESULT
OutputPOINTL(
    PDEBUG_CLIENT Client,
    OutputControl *OutCtl,
    ULONG64 Module,
    ULONG TypeId,
    PSTR Buffer,
    ULONG Flags,
    PULONG BufferUsed
    )
{
    HRESULT hr = S_FALSE;

    TypeOutputParser    Parser(Client);
    PCSTR               pszValue;

    OutCtl->Output("(");
    if (Parser.LookFor(NULL, "x") == S_OK &&
        Parser.Parse(Buffer, NULL) == S_OK &&
        Parser.GetValueString(&pszValue) == S_OK)
    {
        OutCtl->Output("%s", pszValue);
    }
    OutCtl->Output(",");
    if (Parser.LookFor(NULL, "y") == S_OK &&
        Parser.Parse(Buffer, NULL) == S_OK &&
        Parser.GetValueString(&pszValue) == S_OK)
    {
        hr = OutCtl->Output("%s", pszValue);
    }
    OutCtl->Output(")");

    return hr;
}


/**************************************************************************\
*
* Routine Name:
*
*   OutputRECTFX
*
* Routine Description:
*
*   Outputs a RECTFX
*
\**************************************************************************/

HRESULT
OutputRECTFX(
    PDEBUG_CLIENT Client,
    OutputControl *OutCtl,
    ULONG64 Module,
    ULONG TypeId,
    PSTR Buffer,
    ULONG Flags,
    PULONG BufferUsed
    )
{
    HRESULT hr = S_FALSE;

    TypeOutputParser    Parser(Client);
    DEBUG_VALUE         xLeft, xRight;
    DEBUG_VALUE         yTop, yBottom;
    PCSTR               pszValue;

    if (Parser.LookFor(&xLeft, "xLeft", DEBUG_VALUE_INT32) == S_OK)
    {
        Parser.Parse(Buffer, NULL);
    }
    if (Parser.LookFor(&yTop, "yTop", DEBUG_VALUE_INT32) == S_OK)
    {
        Parser.Parse(Buffer, NULL);
    }
    if (Parser.LookFor(&xRight, "xRight", DEBUG_VALUE_INT32) == S_OK)
    {
        Parser.Parse(Buffer, NULL);
    }
    if (Parser.LookFor(&yBottom, "yBottom", DEBUG_VALUE_INT32) == S_OK)
    {
        Parser.Parse(Buffer, NULL);
    }

    OutCtl->Output("(");
    OutputFIXHex(OutCtl, &xLeft);
    OutCtl->Output(",");
    OutputFIXHex(OutCtl, &yTop);
    OutCtl->Output(")-(");
    OutputFIXHex(OutCtl, &xRight);
    OutCtl->Output(",");
    OutputFIXHex(OutCtl, &yBottom);
    OutCtl->Output(")   (");
    OutputFIXDec(OutCtl, &xLeft);
    OutCtl->Output(",");
    OutputFIXDec(OutCtl, &yTop);
    OutCtl->Output(")-(");
    OutputFIXDec(OutCtl, &xRight);
    OutCtl->Output(",");
    OutputFIXDec(OutCtl, &yBottom);
    hr = OutCtl->Output(")");

    return hr;
}


/**************************************************************************\
*
* Routine Name:
*
*   OutputRECTL
*
* Routine Description:
*
*   Outputs a RECTL
*
\**************************************************************************/

HRESULT
OutputRECTL(
    PDEBUG_CLIENT Client,
    OutputControl *OutCtl,
    ULONG64 Module,
    ULONG TypeId,
    PSTR Buffer,
    ULONG Flags,
    PULONG BufferUsed
    )
{
    HRESULT hr = S_FALSE;

    TypeOutputParser    Parser(Client);
    PCSTR               pszValue;

    OutCtl->Output("(");
    if (Parser.LookFor(NULL, "left") == S_OK &&
        Parser.Parse(Buffer, NULL) == S_OK &&
        Parser.GetValueString(&pszValue) == S_OK)
    {
        OutCtl->Output("%s", pszValue);
    }
    OutCtl->Output(",");
    if (Parser.LookFor(NULL, "top") == S_OK &&
        Parser.Parse(Buffer, NULL) == S_OK &&
        Parser.GetValueString(&pszValue) == S_OK)
    {
        OutCtl->Output("%s", pszValue);
    }
    OutCtl->Output(") - (");
    if (Parser.LookFor(NULL, "right") == S_OK &&
        Parser.Parse(Buffer, NULL) == S_OK &&
        Parser.GetValueString(&pszValue) == S_OK)
    {
        OutCtl->Output("%s", pszValue);
    }
    OutCtl->Output(",");
    if (Parser.LookFor(NULL, "bottom") == S_OK &&
        Parser.Parse(Buffer, NULL) == S_OK &&
        Parser.GetValueString(&pszValue) == S_OK)
    {
        hr = OutCtl->Output("%s", pszValue);
    }
    OutCtl->Output(")");

    return hr;
}


/**************************************************************************\
*
* Routine Name:
*
*   OutputSIZE
*
* Routine Description:
*
*   Outputs a SIZE
*
\**************************************************************************/

HRESULT
OutputSIZE(
    PDEBUG_CLIENT Client,
    OutputControl *OutCtl,
    ULONG64 Module,
    ULONG TypeId,
    PSTR Buffer,
    ULONG Flags,
    PULONG BufferUsed
    )
{
    HRESULT hr = S_FALSE;

    TypeOutputParser    Parser(Client);
    PCSTR               pszValue;

    if (Parser.LookFor(NULL, "cx") == S_OK &&
        Parser.Parse(Buffer, NULL) == S_OK &&
        Parser.GetValueString(&pszValue) == S_OK)
    {
        OutCtl->Output("%s", pszValue);
    }
    OutCtl->Output(" x ");
    if (Parser.LookFor(NULL, "cy") == S_OK &&
        Parser.Parse(Buffer, NULL) == S_OK &&
        Parser.GetValueString(&pszValue) == S_OK)
    {
        hr = OutCtl->Output("%s", pszValue);
    }

    return hr;
}


#if 0
// Template for known type output routines

/**************************************************************************\
*
* Routine Name:
*
*   _KnownType_
*
* Routine Description:
*
*   Output a _KnownType_
*
\**************************************************************************/

HRESULT
Output_KnownType_(
    PDEBUG_CLIENT Client,
    OutputControl *OutCtl,
    ULONG64 Module,
    ULONG TypeId,
    PSTR Buffer,
    ULONG Flags,
    PULONG BufferUsed
    )
{
    HRESULT hr = S_FALSE;

    return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\ddiexts.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ddiexts.cxx

Abstract:

    This file contains the DDI related extensions.

Author:

    Jason Hartman (JasonHa) 2000-11-01

Environment:

    User Mode

--*/

#include "precomp.hxx"


/******************************Public*Routine******************************\
* BLENDOBJ
*
\**************************************************************************/
DECLARE_API( blendobj )
{
    return ExtDumpType(Client, "blendobj", "BLENDOBJ", args);
}


/******************************Public*Routine******************************\
* BRUSHOBJ
*
\**************************************************************************/
DECLARE_API( brushobj )
{
    return ExtDumpType(Client, "brushobj", "BRUSHOBJ", args);
}


/******************************Public*Routine******************************\
* CLIPOBJ
*
\**************************************************************************/
DECLARE_API( clipobj )
{
    return ExtDumpType(Client, "clipobj", "CLIPOBJ", args);
}


/******************************Public*Routine******************************\
* LINEATTRS
*
\**************************************************************************/
DECLARE_API( lineattrs )
{
    HRESULT         hr = S_OK;
    OutputControl   OutCtl(Client);
    DEBUG_VALUE     Offset;

    BEGIN_API( lineattrs );

    while (isspace(*args)) args++;

    if (*args == '-' ||
        (hr = OutCtl.Evaluate(args, DEBUG_VALUE_INT64, &Offset, NULL)) != S_OK ||
        Offset.I64 == 0)
    {
        if (hr != S_OK)
        {
            OutCtl.OutErr("Evaluate '%s' returned %s.\n",
                          args,
                          pszHRESULT(hr));
        }
        OutCtl.Output("Usage: lineattrs [-?] <LINEATTRS Addr>\n");
    }
    else
    {
        OutputFilter    OutFilter(Client);
        OutputState     OutState(Client, FALSE);

        if (hr == S_OK &&
            (hr = OutState.Setup(0, &OutFilter)) == S_OK &&
            (hr = OutCtl.SetControl(DEBUG_OUTCTL_THIS_CLIENT |
                                    DEBUG_OUTCTL_NOT_LOGGED |
                                    DEBUG_OUTCTL_OVERRIDE_MASK,
                                    OutState.Client)) == S_OK)

        {
            hr = DumpType(Client,
                          "_LINEATTRS",
                          Offset.I64,
                          DEBUG_OUTTYPE_DEFAULT,
                          &OutCtl);

            OutCtl.SetControl(DEBUG_OUTCTL_AMBIENT, Client);

            if (hr == S_OK)
            {
                // Determine if FLOAT_LONG unions contain
                // FLOATL's or LONG's.
                if (OutFilter.Query("LA_GEOMETRIC") == S_OK)
                {
                    OutFilter.Skip(OUTFILTER_QUERY_EVERY_LINE |
                                   OUTFILTER_QUERY_WHOLE_WORD,
                                   "l");
                }
                else
                {
                    OutFilter.Skip(OUTFILTER_QUERY_EVERY_LINE |
                                   OUTFILTER_QUERY_WHOLE_WORD,
                                   "e");
                }

                OutFilter.OutputText();
            }
            else
            {
                OutCtl.OutErr("Type Dump for LINEATTRS returned %s.\n", pszHRESULT(hr));
            }
        }
        else
        {
            OutCtl.OutErr("Type Dump setup for LINEATTRS returned %s.\n", pszHRESULT(hr));
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
* PATHOBJ
*
\**************************************************************************/
DECLARE_API( pathobj )
{
    return ExtDumpType(Client, "pathobj", "PATHOBJ", args);
}


/******************************Public*Routine******************************\
* SURFOBJ
*
\**************************************************************************/
DECLARE_API( surfobj )
{
    BEGIN_API( surfobj );

    HRESULT             hr = S_OK;
    DEBUG_VALUE         Arg;
    DEBUG_VALUE         Offset;
    TypeOutputParser    TypeParser(Client);
    OutputState         OutState(Client);

    OutputControl       OutCtl(Client);

    while (isspace(*args)) args++;

    if (*args == '-' ||
        (hr = Evaluate(Client, args, DEBUG_VALUE_INT64, 0, &Arg, NULL)) != S_OK ||
        Arg.I64 == 0)
    {
        OutCtl.Output("Usage: surfobj [-?] <HSURF | SURFOBJ Addr>\n");
    }
    else if ((hr = OutState.Setup(0, &TypeParser)) == S_OK)
    {
        ULONG64             SurfAddr;
        ULONG64             SurfObjAddr = 0;
        DEBUG_VALUE         SurfObjHandle;
        BOOL                SurfObjHandleChecked = FALSE;

        hr = GetObjectAddress(Client, Arg.I64, &SurfAddr, SURF_TYPE, TRUE, TRUE);

        if (hr != S_OK || SurfAddr == 0)
        {
            // Invalid handle try argument as a SURFOBJ address
            SurfObjAddr = Arg.I64;

            // Try to read hsurf from SURFOBJ
            if ((hr = OutState.OutputTypeVirtual(SurfObjAddr, GDIType(_SURFOBJ), 0)) != S_OK ||
                (hr = TypeParser.Get(&SurfObjHandle, "hsurf", DEBUG_VALUE_INT64)) != S_OK)
            {
                OutCtl.OutErr("Unable to get contents of SURFOBJ's handle\n");
                OutCtl.OutErr("  (Type Read returned %s)\n", pszHRESULT(hr));
                OutCtl.OutErr(" 0x%p is neither an HSURF nor valid SURFOBJ address\n", Arg.I64);
            }
        }

        if (hr == S_OK)
        {
            PDEBUG_SYMBOLS  Symbols;

            ULONG64 SurfModule = 0;
            ULONG   SurfTypeId = 0;
            ULONG   BaseObjTypeId = 0;
            ULONG   SurfObjOffset = 0;

            if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                             (void **)&Symbols)) == S_OK)
            {
                // Try to read SURFOBJ offset from SURFACE type, but
                // if that fails assume it is directly after BASEOBJECT.
                if ((hr = GetTypeId(Client, "SURFACE", &SurfTypeId, &SurfModule)) != S_OK ||
                    (hr = Symbols->GetFieldOffset(SurfModule, SurfTypeId, "so", &SurfObjOffset)) != S_OK)
                {
                    if ((hr = Symbols->GetTypeId(Type_Module.Base, "_BASEOBJECT", &BaseObjTypeId)) == S_OK)
                    {
                        hr = Symbols->GetTypeSize(Type_Module.Base, BaseObjTypeId, &SurfObjOffset);
                    }
                }

                Symbols->Release();
            }

            if (SurfObjAddr != 0)
            {
                // If we were given a address, check hsurf validity.
                // hsurf value (SurfObjHandle) is retrieved above.

                hr = GetObjectAddress(Client, SurfObjHandle.I64, &SurfAddr,
                                      SURF_TYPE, TRUE, FALSE);

                if (hr != S_OK || SurfAddr == 0)
                {
                    OutCtl.OutWarn(" SURFOBJ's hsurf is not valid.\n");
                }
                else if (SurfObjOffset != 0 &&
                         SurfObjAddr != SurfAddr + SurfObjOffset)
                {
                    OutCtl.OutWarn(" SURFOBJ's hsurf may not be valid.\n");
                }
                else
                {
                    ULONG64 SurfaceHandle;
                    hr = GetObjectHandle(Client, SurfAddr, &SurfaceHandle, FALSE);

                    if (hr != S_OK)
                    {
                        OutCtl.OutErr("Unable to get contents of surface handle\n");
                        OutCtl.OutErr("  (Type Read returned %s)\n", pszHRESULT(hr));
                    }
                    else if (SurfaceHandle != SurfObjHandle.I64)
                    {
                        OutCtl.OutWarn(" Surface has an invalid handle.\n");
                    }
                }
            }
            else
            {
                // If we were given a handle,
                // compute SURFOBJ address.
                if (SurfObjOffset != 0)
                {
                    SurfObjAddr = SurfAddr + SurfObjOffset;

                    // Try to read hsurf from SURFOBJ
                    if ((hr = OutState.OutputTypeVirtual(SurfObjAddr, GDIType(_SURFOBJ), 0)) != S_OK ||
                        (hr = TypeParser.Get(&SurfObjHandle, "hsurf", DEBUG_VALUE_INT64)) != S_OK)
                    {
                        OutCtl.OutErr("Unable to get contents of SURFOBJ's handle\n");
                        OutCtl.OutErr("  (Type Read returned %s)\n", pszHRESULT(hr));
                    }
                    else if (SurfObjHandle.I64 != Arg.I64)
                    {
                        OutCtl.OutWarn(" SURFOBJ's hsurf is not valid.\n");
                    }
                }
            }

            if (SurfObjAddr != 0)
            {
                hr = DumpType(Client, "_SURFOBJ", SurfObjAddr);

                if (hr != S_OK)
                {
                    OutCtl.OutErr("Type Dump for %s returned %s.\n", GDIType(_SURFOBJ), pszHRESULT(hr));
                }
            }
        }
    }
    else
    {
        OutCtl.OutErr("Couldn't setup type reader, %s.\n", pszHRESULT(hr));
    }

    return hr;
}


/******************************Public*Routine******************************\
* WNDOBJ
*
\**************************************************************************/
DECLARE_API( wndobj )
{
    return ExtDumpType(Client, "wndobj", "WNDOBJ", args);
}


/******************************Public*Routine******************************\
* XLATEOBJ
*
\**************************************************************************/
DECLARE_API( xlateobj )
{
    return ExtDumpType(Client, "xlateobj", "XLATEOBJ", args);
}


/******************************Public*Routine******************************\
* DEVMODEA
*
\**************************************************************************/
DECLARE_API( devmodea )
{
    return ExtDumpType(Client, "devmodea", "_devicemodeA", args);
}


/******************************Public*Routine******************************\
* DEVMODEW
*
\**************************************************************************/
DECLARE_API( devmodew )
{
    return ExtDumpType(Client, "devmodeW", "_devicemodeW", args);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\ddexts.cxx ===
/******************************Module*Header*******************************\
* Module Name: ddexts.cxx
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/


#include "precomp.hxx"



/******************************Public*Routine******************************\
* vPrintDDSURFACE
*
* Print out DirectDraw surface contents.
*
* History:
*  Apr-09-1996 -by- J. Andrew Goossen andrewgo
* Wrote it.
\**************************************************************************/

#define DDSURFACE_LOCKS             0x00000001
#define DDSURFACE_PUBLIC            0x00000002
#define DDSURFACE_PRIVATE           0x00000004
#define DDSURFACE_DDNEXT            0x00000008

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
VOID
vPrintDDSURFACE(
    VOID *  pvServer,
    FLONG   fl
        )
{
    char eSurface[sizeof(EDD_SURFACE)];
    char AttachList[sizeof(DD_ATTACHLIST)];
    EDD_SURFACE *peSurface;
    ULONG ul;
    FLAGDEF *pfd;
    PDD_ATTACHLIST pAttach;

Next_Surface:

    move2(eSurface, pvServer, sizeof(EDD_SURFACE));

    dprintf("EDD_SURFACE structure at 0x%p:\n", pvServer);

    peSurface =  (EDD_SURFACE *)eSurface;

    if (fl & DDSURFACE_PUBLIC)
    {
        dprintf("--------------------------------------------------\n");
        dprintf("PDD_SURFACE_GLOBAL     lpGbl              0x%lx\n", peSurface->lpGbl);
        dprintf("PDD_SURFACE_MORE       lpMore             0x%lx\n", peSurface->lpSurfMore);

        ul = peSurface->dwFlags;
        dprintf("DWORD                  dwFlags            0x%lx\n", ul);

//CHECKLOOP
        for (pfd = afdDDRAWISURF; pfd->psz; pfd++)
            if (ul & pfd->fl)
                dprintf("\t\t\t\t%s\n", pfd->psz);

        ul = peSurface->ddsCaps.dwCaps;
        dprintf("DWORD                  ddsCaps.dwCaps     0x%lx\n", ul);

//CHECKLOOP
        for (pfd = afdDDSCAPS; pfd->psz; pfd++)
            if (ul & pfd->fl)
                dprintf("\t\t\t\t%s\n", pfd->psz);

        ul = peSurface->ddsCapsEx.dwCaps2;
        dprintf("DWORD                  ddsCapsEx.dwCaps2  0x%lx\n", ul);

//CHECKLOOP
        for (pfd = afdDDSCAPS2; pfd->psz; pfd++)
            if (ul & pfd->fl)
               dprintf("\t\t\t\t%s\n", pfd->psz);

        dprintf("DWORD                  dwSurfaceHandle    0x%lx\n", peSurface->dwSurfaceHandle);

        dprintf("DDCOLORKEY ddckCKSrcBlt/Overlay           0x%lx:0x%lx\n", peSurface->ddckCKSrcOverlay.dwColorSpaceHighValue,
                                                                           peSurface->ddckCKSrcOverlay.dwColorSpaceLowValue);
        dprintf("DDCOLORKEY ddckCKDestBlt/Overlay          0x%lx:0x%lx\n", peSurface->ddckCKDestOverlay.dwColorSpaceHighValue,
                                                                           peSurface->ddckCKDestOverlay.dwColorSpaceLowValue);
        dprintf("PDD_ATTACHLIST         lpAttachList       0x%lx\n", peSurface->lpAttachList);

//CHECKLOOP
        for (pAttach = peSurface->lpAttachList;
             pAttach != NULL;
             pAttach = pAttach->lpLink)
        {
            move2(AttachList, pAttach, sizeof(DD_ATTACHLIST));
            pAttach = (PDD_ATTACHLIST) AttachList;

            dprintf("  EDD_SURFACE*\t\t\t0x%lx\n", pedFromLp(pAttach->lpAttached));

            if (pAttach->lpLink == pAttach)
            {
                dprintf("  !!! Endless lpAttachList loop\n");
                break;
            }

            if (CheckControlC())
                return;
        }
        dprintf("PDD_ATTACHLIST         lpAttachListFrom   0x%lx\n", peSurface->lpAttachListFrom);

//CHECKLOOP
        for (pAttach = peSurface->lpAttachListFrom;
             pAttach != NULL;
             pAttach = pAttach->lpLink)
        {
            move2(AttachList, pAttach, sizeof(DD_ATTACHLIST));
            pAttach = (PDD_ATTACHLIST) AttachList;

            dprintf("  EDD_SURFACE*\t\t\t0x%lx\n", pedFromLp(pAttach->lpAttached));

            if (pAttach->lpLink == pAttach)
            {
                dprintf("  !!! Endless lpAttachListFrom loop\n");
                break;
            }

            if (CheckControlC())
                return;
        }

        dprintf("DWORD                  dwMipMapCount      0x%lx\n", peSurface->dwMipMapCount);
        dprintf("EDD_VIDEOPORT*         peVideoPort        0x%lx\n",
            peSurface->lpVideoPort != NULL ? pedFromLp(peSurface->lpVideoPort) : 0);
        dprintf("HBITMAP                hbmGdi             0x%lx\n", peSurface->hbmGdi);
        dprintf("DWORD                  dwOverlayFlags     0x%lx\n", peSurface->dwOverlayFlags);
        dprintf("DWORD                  dwBlockSizeX       0x%lx\n", peSurface->dwBlockSizeX);
        dprintf("DWORD                  dwBlockSizeY       0x%lx\n", peSurface->dwBlockSizeY);
        dprintf("FLATPTR                fpVidMem           0x%lx\n", peSurface->fpVidMem);
        dprintf("LONG                   lPitch             0x%lx\n", peSurface->lPitch);
        dprintf("LONG                   xHint              0x%lx\n", peSurface->xHint);
        dprintf("LONG                   yHint              0x%lx\n", peSurface->yHint);
        dprintf("DWORD                  wWidth             0x%lx\n", peSurface->wWidth);
        dprintf("DWORD                  wHeight            0x%lx\n", peSurface->wHeight);
        dprintf("DWORD         (global) dwReserved1        0x%lx\n", peSurface->DD_SURFACE_GLOBAL::dwReserved1);
        dprintf("DWORD          (local) dwReserved1        0x%lx\n", peSurface->DD_SURFACE_LOCAL::dwReserved1);
        dprintf("DDPIXELFORMAT          ddpfSurface\n");
        dprintf("  DWORD dwSize (should be 0x20)           0x%lx\n", peSurface->ddpfSurface.dwSize);

        ul = peSurface->ddpfSurface.dwFlags;
        dprintf("  DWORD dwFlags                           0x%lx\n", ul);

//CHECKLOOP
        for (pfd = afdDDPIXELFORMAT; pfd->psz; pfd++)
            if (ul & pfd->fl)
                dprintf("\t\t\t\t%s\n", pfd->psz);

        dprintf("  DWORD dwFourCC                          0x%lx\n", peSurface->ddpfSurface.dwFourCC);
        dprintf("  DWORD dwRGB/YUV/ZBuffer/AlphaBitCount   0x%lx\n", peSurface->ddpfSurface.dwRGBBitCount);
        dprintf("  DWORD dwRBitMask/dwYBitMask             0x%lx\n", peSurface->ddpfSurface.dwRBitMask);
        dprintf("  DWORD dwGBitMask/dwUBitMask             0x%lx\n", peSurface->ddpfSurface.dwGBitMask);
        dprintf("  DWORD dwBBitMask/dwVBitMask             0x%lx\n", peSurface->ddpfSurface.dwBBitMask);
        dprintf("  DWORD dwRGB/YUVAlphaBitMask             0x%lx\n", peSurface->ddpfSurface.dwRGBAlphaBitMask);
    }
    if (fl & DDSURFACE_PRIVATE)
    {
        dprintf("--------------------------------------------------\n");
        dprintf("EDD_SURFACE*           peSurface_DdNext   0x%lx\n", peSurface->peSurface_DdNext);
        dprintf("EDD_SURFACE*           peSurface_LockNext 0x%lx\n", peSurface->peSurface_PrimaryLockNext);
        dprintf("EDD_DIRECTDRAW_GLOBAL* peDirectDrawGlobal 0x%lx\n", peSurface->peDirectDrawGlobal);
        dprintf("EDD_DIRECTDRAW_LOCAL*  peDirectDrawLocal  0x%lx\n", peSurface->peDirectDrawLocal);


        ul = peSurface->fl;
        dprintf("FLONG                  fl                 0x%lx\n", ul);

//CHECKLOOP
        for (pfd = afdDDSURFACEFL; pfd->psz; pfd++)
            if (ul & pfd->fl)
                dprintf("\t\t\t\t%s\n", pfd->psz);

        dprintf("ULONG                  iVisRgnUniqueness  0x%lx\n", peSurface->iVisRgnUniqueness);
        dprintf("BOOL                   bLost              %s\n",
            peSurface->bLost ? "TRUE" : "FALSE");
        dprintf("HANDLE                 hSecure            0x%lx\n", peSurface->hSecure);
        dprintf("ERECTL                 rclLock:           (%li, %li, %li, %li)\n",
            peSurface->rclLock.left,  peSurface->rclLock.top,
            peSurface->rclLock.right, peSurface->rclLock.bottom);
    }

    if (fl & DDSURFACE_LOCKS)
    {
        dprintf("--------------------------------------------------\n");
        dprintf("ULONG                  cLocks             0x%lx\n", peSurface->cLocks);
        dprintf("HDC                    hdc                0x%lx\n", peSurface->hdc);
    }

    if (fl & DDSURFACE_DDNEXT)
    {
        if (CheckControlC())
            return;

        pvServer = peSurface->peSurface_DdNext;
        if (pvServer != NULL)
            goto Next_Surface;
    }

}
#endif  // DOES NOT SUPPORT API64


/******************************Public*Routine******************************\
* DECLARE_API( dddsurface  )
*
* Dumps a DirectDraw surface structure.
*
\**************************************************************************/

DECLARE_API( dddsurface  )
{
    dprintf("Extension 'dddsurface' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    FLONG   fl = 0;
    ULONG_PTR   ddsurface;

    PARSE_ARGUMENTS(dddsurface_help);
    if(ntok<1) { goto dddsurface_help; }


    if(parse_iFindSwitch(tokens, ntok, 'h')!=-1) { goto dddsurface_help; }
    if(parse_iFindSwitch(tokens, ntok, 'a')!=-1) {
      fl |= (DDSURFACE_PRIVATE | DDSURFACE_PUBLIC | DDSURFACE_LOCKS);
    }
    if(parse_iFindSwitch(tokens, ntok, 'r')!=-1) { fl |= DDSURFACE_PRIVATE; }
    if(parse_iFindSwitch(tokens, ntok, 'u')!=-1) { fl |= DDSURFACE_PUBLIC; }
    if(parse_iFindSwitch(tokens, ntok, 'l')!=-1) { fl |= DDSURFACE_LOCKS; }
    if(parse_iFindSwitch(tokens, ntok, 'n')!=-1) { fl |= DDSURFACE_DDNEXT; }

    tok_pos = parse_FindNonSwitch(tokens, ntok);
    if(tok_pos==-1) { goto dddsurface_help; }

    ddsurface = GetExpression(tokens[tok_pos]);

    if (fl == 0) {
      fl |= (DDSURFACE_PRIVATE | DDSURFACE_PUBLIC | DDSURFACE_LOCKS);
    }

    vPrintDDSURFACE((PVOID)ddsurface, fl);
    return;

dddsurface_help:
    dprintf("Usage: dddsurface [-?haruln] ddsurface");
    dprintf(" a - all info\n");
    dprintf(" r - private info\n");
    dprintf(" u - public info\n");
    dprintf(" l - locks\n");
    dprintf(" n - all surfaces in DdNext link\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
* vPrintDDLOCAL
*
* Print out DirectDraw local object contents.
*
* History:
*  Apr-09-1996 -by- J. Andrew Goossen andrewgo
* Wrote it.
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
VOID
vPrintDDLOCAL(
    VOID *  pvServer,
    FLONG   fl
        )
{
    char pbr[sizeof(EDD_DIRECTDRAW_LOCAL)];
    EDD_DIRECTDRAW_LOCAL * peDirectDrawLocal;

    move2(pbr, pvServer, sizeof(EDD_DIRECTDRAW_LOCAL));

    dprintf("EDD_DIRECTDRAW_LOCAL structure at 0x%p:\n",pvServer);

    peDirectDrawLocal =  (EDD_DIRECTDRAW_LOCAL *)pbr;

    dprintf("--------------------------------------------------\n");
    dprintf("FLATPTR                fpProcess           0x%lx\n", peDirectDrawLocal->fpProcess);
    dprintf("--------------------------------------------------\n");
    dprintf("EDD_DIRECTDRAW_GLOBAL* peDirectDrawGlobal  0x%lx\n", peDirectDrawLocal->peDirectDrawGlobal);
    dprintf("EDD_SURFACE*           peSurface_DdList    0x%lx\n", peDirectDrawLocal->peSurface_DdList);
    dprintf("EDD_DIRECTDRAW_LOCAL*  peDirectDrawLocalNext 0x%lx\n", peDirectDrawLocal->peDirectDrawLocalNext);
    dprintf("FLONG                  fl                  0x%lx\n", peDirectDrawLocal->fl);
    dprintf("HANDLE                 UniqueProcess       0x%lx\n", peDirectDrawLocal->UniqueProcess);
    dprintf("PEPROCESS              Process             0x%lx\n", peDirectDrawLocal->Process);
}
#endif  // DOES NOT SUPPORT API64


/******************************Public*Routine******************************\
* DECLARE_API( dddlocal  )
*
\**************************************************************************/

DECLARE_API( dddlocal  )
{
    dprintf("Extension 'dddlocal' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    FLONG   fl = 0;
    ULONG_PTR   ddlocal;

    PARSE_ARGUMENTS(dddlocal_help);
    if(ntok<1) { goto dddlocal_help; }

    if(parse_iFindSwitch(tokens, ntok, 'h')!=-1) { goto dddlocal_help; }
    if(parse_iFindSwitch(tokens, ntok, 'a')!=-1) { fl |= 0; }

    tok_pos = parse_FindNonSwitch(tokens, ntok);
    if(tok_pos==-1) { goto dddlocal_help; }
    ddlocal = GetExpression(tokens[tok_pos]);

    vPrintDDLOCAL((PVOID)ddlocal, fl);

    return;

dddlocal_help:
    dprintf("dddlocal [-?] [-h] [-a]\n\n");
    dprintf(" a - all info\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
* vPrintDDGLOBAL
*
* Print out DirectDraw global object contents.
*
* History:
*  Apr-09-1996 -by- J. Andrew Goossen andrewgo
* Wrote it.
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
VOID
vPrintDDGLOBAL(
    VOID *  pvServer,
    FLONG   fl
        )
{
    char pbr[sizeof(EDD_DIRECTDRAW_GLOBAL) + 100];
    EDD_DIRECTDRAW_GLOBAL * peDirectDrawGlobal;

    move2(pbr, pvServer, sizeof(EDD_DIRECTDRAW_GLOBAL));

    dprintf("EDD_DIRECTDRAW_GLOBAL structure at 0x%p:\n", pvServer);

    peDirectDrawGlobal =  (EDD_DIRECTDRAW_GLOBAL *)pbr;

    dprintf("--------------------------------------------------\n");
    dprintf("VOID*                  dhpdev              0x%lx\n", peDirectDrawGlobal->dhpdev);
    dprintf("DWORD                  dwReserved1         0x%lx\n", peDirectDrawGlobal->dwReserved1);
    dprintf("DWORD                  dwReserved2         0x%lx\n", peDirectDrawGlobal->dwReserved2);
    dprintf("EDD_DIRECTDRAW_LOCAL*  peDirectDrawLocalList 0x%lx\n", peDirectDrawGlobal->peDirectDrawLocalList);
    dprintf("EDD_SURFACE*           peSurface_LockList  0x%lx\n", peDirectDrawGlobal->peSurface_PrimaryLockList);
    dprintf("FLONG                  fl                  0x%lx\n", peDirectDrawGlobal->fl);
    dprintf("ULONG                  cSurfaceLocks       0x%lx\n", peDirectDrawGlobal->cSurfaceLocks);
    dprintf("ULONG                  cSurfaceAliasedLocks 0x%lx\n", peDirectDrawGlobal->cSurfaceAliasedLocks);
    dprintf("PKEVENT                pAssertModeEvent    0x%lx\n", peDirectDrawGlobal->pAssertModeEvent);
    dprintf("LONGLONG               llAssertModeTimeout 0x%lx\n", (DWORD) peDirectDrawGlobal->llAssertModeTimeout);
    dprintf("EDD_SURFACE*           peSurfaceCurrent    0x%lx\n", peDirectDrawGlobal->peSurfaceCurrent);
    dprintf("EDD_SURFACE*           peSurfacePrimary    0x%lx\n", peDirectDrawGlobal->peSurfacePrimary);
    dprintf("BOOL                   bSuspended          0x%lx\n", peDirectDrawGlobal->bSuspended);
    dprintf("HDEV                   hdev                0x%lx\n", peDirectDrawGlobal->hdev);
    dprintf("LONG                   cDriverReferences   0x%lx\n", peDirectDrawGlobal->cDriverReferences);
    dprintf("DWORD                  dwNumHeaps          0x%lx\n", peDirectDrawGlobal->dwNumHeaps);
    dprintf("VIDEOMEMORY*           pvmList             0x%lx\n", peDirectDrawGlobal->pvmList);
    dprintf("DWORD                  dwNumFourCC         0x%lx\n", peDirectDrawGlobal->dwNumFourCC);
    dprintf("DWORD*                 pdwFourCC           0x%lx\n", peDirectDrawGlobal->pdwFourCC);
    dprintf("DD_HALINFO             HalInfo\n");
    dprintf("DD_CALLBACKS           CallBacks\n");
    dprintf("DD_SURFACECALLBACKS    SurfaceCallBacks\n");
    dprintf("DD_PALETTECALLBACKS    PaletteCallBacks\n");
    dprintf("RECTL                  rclBounds           (%ld, %ld), (%ld, %ld)\n",
        peDirectDrawGlobal->rclBounds.left,  peDirectDrawGlobal->rclBounds.top,
        peDirectDrawGlobal->rclBounds.right, peDirectDrawGlobal->rclBounds.bottom);
}
#endif  // DOES NOT SUPPORT API64


/******************************Public*Routine******************************\
* DECLARE_API( dddglobal  )
*
\**************************************************************************/

DECLARE_API( dddglobal  )
{
    dprintf("Extension 'dddglobal' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    FLONG   fl = 0;
    ULONG_PTR   ddglobal;

    PARSE_ARGUMENTS(dddglobal_help);
    if(ntok<1) { goto dddglobal_help; }

    if(parse_iFindSwitch(tokens, ntok, 'h')!=-1) { goto dddglobal_help; }
    if(parse_iFindSwitch(tokens, ntok, 'a')!=-1) { fl |= 0; }

    tok_pos = parse_FindNonSwitch(tokens, ntok);
    if(tok_pos==-1) { goto dddglobal_help; }
    ddglobal = GetExpression(tokens[tok_pos]);

    vPrintDDGLOBAL((PVOID)ddglobal, fl);
    return;

dddglobal_help:
    dprintf("dddglobal [-?] [-h] [-a]\n\n");
    dprintf(" a - all info\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}


char *pszDdTypes[] = {
"DD_DEF_TYPE       ",
"DD_DIRECTDRAW_TYPE",
"DD_SURFACE_TYPE   ",
"D3D_HANDLE_TYPE   ",
"DD_VIDEOPORT_TYPE ",
"DD_MOTIONCOMP_TYPE",
"TOTALS            ",
"DEF               "
};

#define DD_TOTAL_TYPE (DD_MAX_TYPE+1)

/******************************Public*Routine******************************\
* DECLARE_API( dumpdd  )
*
* Dumps the count of handles in DdHmgr for each object type.
*
* History:
*  30-Apr-1999    -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

DECLARE_API( dumpdd  )
{
    dprintf("Extension 'dumpdd' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    PENTRY pent;
    ULONG gcMaxHmgr;
    ULONG gcSizeHmgr;
    ULONG ulLoop;    // loop variable
    ULONG objt;
    ULONG pulCount[DD_MAX_TYPE + 2];
    ULONG cUnknown = 0;
    ULONG cUnknownSize = 0;
    ULONG cUnused = 0;
    ENTRY entry;
    ULONG HmgCurrentNumberOfObjects[DD_MAX_TYPE + 2] = {0};
    ULONG HmgMaximumNumberOfObjects[DD_MAX_TYPE + 2] = {0};
    ULONG HmgNumberOfObjectsAllocated[DD_MAX_TYPE + 2] = {0};
    ULONG HmgCurrentNumberOfHandles[DD_MAX_TYPE + 2] = {0};
    ULONG HmgMaximumNumberOfHandles[DD_MAX_TYPE + 2] = {0};
    ULONG HmgNumberOfHandlesAllocated[DD_MAX_TYPE + 2] = {0};

    PARSE_ARGUMENTS(dumpdd_help);

    // Get the pointers and counts from win32k

    GetValue (pent, "win32k!gpentDdHmgr");
    GetValue (gcMaxHmgr, "win32k!gcMaxDdHmgr");
    GetValue (gcSizeHmgr, "win32k!gcSizeDdHmgr");


    dprintf("Max handles out so far %lu\n", gcMaxHmgr - DD_HMGR_HANDLE_BASE);

    if (pent == NULL || gcMaxHmgr == 0)
    {
        dprintf("terminating: pent = %lx, gcMaxDdHmgr = %lx\n",pent,gcMaxHmgr);
        return;
    }

// Print out the amount reserved and committed, note we assume a 4K page size

    dprintf("Total allocated for DdHmgr %lu (%d handles)\n", gcSizeHmgr * sizeof(ENTRY), gcSizeHmgr);


//CHECKLOOP
    for (ulLoop = 0; ulLoop <= DD_TOTAL_TYPE; ulLoop++)
    {
        pulCount[ulLoop] = 0;
    }


//CHECKLOOP
    for (ulLoop = DD_HMGR_HANDLE_BASE; ulLoop < gcMaxHmgr; ulLoop++)
    {
        move (entry, &(pent[ulLoop]));

        objt = (ULONG) entry.Objt;

        if (objt == DD_DEF_TYPE)
        {
            cUnused++;
        }
        if (objt > DD_MAX_TYPE)
        {
            cUnknown++;
        }
        else
        {
            pulCount[objt]++;
        }
        if (CheckControlC())
           return;
    }
    dprintf("ulLoop=%d, gcMaxDdHmgr=%d\n", ulLoop, gcMaxHmgr);

    dprintf("%8s%17s\n","TYPE","Current");

    // init the totals

    pulCount[DD_TOTAL_TYPE]                           = 0;
    HmgMaximumNumberOfHandles[DD_TOTAL_TYPE]          = 0;

    // now go through printing each line and accumulating totals

    for (ulLoop = 0; ulLoop <= DD_MAX_TYPE; ulLoop++)
    {
        dprintf("%s%4lu\n",
            pszDdTypes[ulLoop],
            pulCount[ulLoop]);

        if (ulLoop != DD_DEF_TYPE)
        {
            pulCount[DD_TOTAL_TYPE]                    += pulCount[ulLoop];
        }

        if (CheckControlC())
            return;
    }

    dprintf("%s%4lu\n", pszDdTypes[DD_TOTAL_TYPE],
                        pulCount[DD_TOTAL_TYPE]);

    dprintf ("\ncUnused objects %lu\n", cUnused);
    dprintf("cUnknown objects %lu\n",cUnknown);
    return;

dumpdd_help:
    dprintf("Usage: dumpdd [-?]\n");
    dprintf("dumpdd displays the amount of each type of object in the ddraw handle manager\n");
    dprintf("-? produces this help\ndumpdd ignores all other arguments\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

char *pszDdTypes2[] = {
"DEF",
"DDRAW",
"SURF",
"D3DH",
"VPE",
"MOCOMP"
};

/******************************Public*Routine******************************\
* DECLARE_API( dumpddobj  )
*
* History:
*  30-Apr-1999    -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

DECLARE_API( dumpddobj  )
{
    dprintf("Extension 'dumpddobj' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    PENTRY pent;
    ULONG gcMaxHmgr;
    ULONG ulLoop;
    ENTRY entry;
    LONG  Pid = PID_ALL;
    LONG  Type = TYPE_ALL;
    BOOL  bCheckLock = FALSE;
    BOOL  bSummary = FALSE;
    int   i;

    PARSE_ARGUMENTS(dumpddobj_help);
    if(ntok<1) {
      goto dumpddobj_help;
    }

    //find valid tokens - ignore the rest
    bCheckLock = (parse_iFindSwitch(tokens, ntok, 'l') >= 0);
    bSummary = (parse_iFindSwitch(tokens, ntok, 's') >= 0);
    tok_pos = parse_iFindSwitch(tokens, ntok, 'p');
    if(tok_pos>=0) {
      tok_pos++;
      if((tok_pos+1)>=ntok) {
        goto dumpddobj_help;               //-p requires a pid and it can't be the last arg
      }
      Pid = (LONG)GetExpression(tokens[tok_pos]);
    }

    //find first non-switch token not preceeded by a -p
    tok_pos = -1;
    do {
      tok_pos = parse_FindNonSwitch(tokens, ntok, tok_pos+1);
    } while ( (tok_pos!=-1)&&(parse_iIsSwitch(tokens, tok_pos-1, 'p')));
    if(tok_pos==-1) {
      goto dumpddobj_help;
    }


//CHECKLOOP
    for (Type = 0; Type <= DD_MAX_TYPE; ++Type) {
      if(parse_iIsToken(tokens, tok_pos, pszDdTypes2[Type])) {
        break;
      }
    }

    if (Type > DD_MAX_TYPE) {
      goto dumpddobj_help;
    }
    //
    // Get the pointers and counts from win32k
    //

    GetValue(pent, "win32k!gpentDdHmgr");
    GetValue(gcMaxHmgr, "win32k!gcMaxDdHmgr");

    if (pent == NULL || gcMaxHmgr == 0)
    {
        dprintf("terminating: pent = %lx, gcMaxDdHmgr = %lx\n",pent,gcMaxHmgr);
        return;
    }

    //
    // dprintf out the amount reserved and committed, note we assume a 4K page size
    //

    dprintf("object list for %s type objects",Type == TYPE_ALL ? "ALL" : pszDdTypes2[Type]);
    if (Pid == PID_ALL)
    {
        dprintf(" owned by ALL PIDs\n");
    }
    else
    {
        dprintf(" owned by PID 0x%lx\n",Pid);
    }

    if(!bSummary) {
      dprintf("%4s, %8s, %6s, %6s, %4s, %8s, %8s, %6s, %6s, %8s,%9s\n",
           "I","handle","Lock","sCount","pid","pv","objt","unique","Flags","pUser","Tlock");

      dprintf("--------------------------------------------------------------------------------------------\n");
    }

    {
        LONG ObjCount = 0;
        LONG ObjArray[DD_MAX_TYPE+1];
        for(i=0;i<=DD_MAX_TYPE;i++) {
          ObjArray[i]=0;
        }

//CHECKLOOP
        for (ulLoop = 0; ulLoop < gcMaxHmgr; ulLoop++)
        {
            LONG  objt;
            LONG  ThisPid;

            move(entry, &(pent[ulLoop]));
            objt = entry.Objt;
            ThisPid = OBJECTOWNER_PID(entry.ObjectOwner);

            if (
                 ((objt == Type) || (Type == TYPE_ALL)) &&
                 ((ThisPid == Pid) || (Pid == PID_ALL)) &&
                 ((!bCheckLock) || (entry.ObjectOwner.Share.Lock))
               )
            {

                ObjCount++;

                if (!bSummary)
                {
                    BASEOBJECT baseObj;
            move(baseObj, entry.einfo.pobj);

                    dprintf("%4lx, %8lx, %6lx, %6lx, %4lx, %8lx, %8s, %6lx, %6lx, %08x, %08lx\n",
                        ulLoop,
                        DD_MAKE_HMGR_HANDLE(ulLoop,entry.FullUnique),
                        (entry.ObjectOwner.Share.Lock != 0),
                        baseObj.ulShareCount,
                        OBJECTOWNER_PID(entry.ObjectOwner),
                        entry.einfo,
                        pszDdTypes2[entry.Objt],
                        entry.FullUnique,
                        entry.Flags,
                        entry.pUser,
                        entry.pUser);
                }
                else
                {
                    ObjArray[entry.Objt]++;
                }

            }

            if (CheckControlC())
                return;
        }

        if(bSummary && (Type==TYPE_ALL)) {
          for(i=0;i<=DD_MAX_TYPE; i++) {
            if(ObjArray[i]>0) {
              dprintf("%s\t%ld\n", pszDdTypes2[i], ObjArray[i]);
            }
          }
        }
        dprintf("Total objects = %li\n",ObjCount);
    }

    return;

dumpddobj_help:
  dprintf("Usage: dumpddobj [-?] [-p pid] [-l] [-s] object_type\n");
  dprintf("-l check lock\n");
  dprintf("-s summary\n");
  dprintf("\nThe -s option combined with the DEF object type will produce"
          " a list of the totals for each object type\n");

  dprintf("\nValid object_type values are:\n");
  for(i=0;i<=DD_MAX_TYPE;i++) {
    dprintf("%s\n", pszDdTypes2[i]);
  }
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
* DECLARE_API( dddh  )
*
* Debugger extension to dump a handle.
*
* History:
*  30-Apr-1999    -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

DECLARE_API( dddh  )
{
    dprintf("Extension 'dddh' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    HOBJ    ho;                             // dump this handle
    PENTRY  pent;                           // base address of hmgr entries
    ENTRY   ent;                            // copy of handle entry
    BASEOBJECT obj;
    ULONG   ulTemp;
    int     iRet;

    PARSE_POINTER(dddh_help);
    ho = (HOBJ)arg;
// Get argument (handle to dump).

    dprintf("--------------------------------------------------\n");
    dprintf("Entry from ghmgr for handle 0x%08lx:\n", ho        );

// Dereference the handle via the engine's handle manager.

    GetAddress(pent, "win32k!gpentDdHmgr");

    dprintf("&pent = %lx\n",pent);

    GetValue(pent, "win32k!gpentDdHmgr");

    dprintf("pent = %lx\n",pent);

    iRet = move(ent,  &(pent[DdHmgIfromH((ULONG_PTR) ho)]));

    dprintf("move() = %lx\n",iRet);

// dprintf the entry.
    BASEOBJECT baseObj;
    move(baseObj, ent.einfo.pobj);

    dprintf("    pobj/hfree  = 0x%08lx\n"  , ent.einfo.pobj);
    dprintf("    ObjectOwner = 0x%08lx\n"  , ent.ObjectOwner.ulObj);
    dprintf("    pidOwner    = 0x%x\n"     , OBJECTOWNER_PID(ent.ObjectOwner));
    dprintf("    ShareCount  = 0x%x\n"     , baseObj.ulShareCount);
    dprintf("    lock        = %s\n"       , ent.ObjectOwner.Share.Lock ? "LOCKED" : "UNLOCKED");
    dprintf("    puser       = 0x%x\n"     , ent.pUser);
    dprintf("    objt        = 0x%hx\n"    , ent.Objt);
    dprintf("    usUnique    = 0x%hx\n"    , ent.FullUnique);
    dprintf("    fsHmgr      = 0x%hx\n"    , ent.Flags);

// If it has an object we get the lock counts and tid owner.

    if (ent.Objt != DD_DEF_TYPE)
    {
        if (ent.einfo.pobj != NULL)
        {
            move(obj,ent.einfo.pobj);
            dprintf("    hHmgr       = 0x%08lx\n"  , obj.hHmgr);
            dprintf("    cExcluLock  = 0x%08lx\n"    , obj.cExclusiveLock);
            dprintf("    tid         = 0x%08lx\n"    , obj.Tid);
        }
        else
        {
            dprintf("It has a NULL pointer\n");
        }
    }

    ulTemp = (ULONG) ent.Objt;

    switch(ulTemp)
    {
    case DD_DEF_TYPE:
        dprintf("This is DD_DEF_TYPE\n");
        break;

    case DD_DIRECTDRAW_TYPE:
        dprintf("This is DD_DIRECTDRAW_TYPE\n");
        break;

    case DD_SURFACE_TYPE:
        dprintf("This is DD_SURFACE_TYPE\n");
        break;

    case D3D_HANDLE_TYPE:
        dprintf("This is D3D_HANDLE_TYPE\n");
        break;

    case DD_VIDEOPORT_TYPE:
        dprintf("This is DD_VIDEOPORT_TYPE\n");
        break;

    case DD_MOTIONCOMP_TYPE:
        dprintf("This is DD_MOTIONCOMP_TYPE\n");
        break;
    
    default:
            dprintf("This is of unknown type - an error\n");
    }
    dprintf("--------------------------------------------------\n");

  return;

dddh_help:
  dprintf("Usage: dddh [-?] object_handle\n");
  dprintf("-? displays this help\n");
  dprintf("object_handle must be in hexadecimal\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
* DECLARE_API( dddht  )
*
* Debugger extension to dump a handle type.
*
* History:
*  21-Feb-1995    -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DECLARE_API( dddht  )
{
    dprintf("Extension 'dddht' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    DWORD dwHandle;

    PARSE_POINTER(dddht_help);
    dwHandle = (DWORD)arg;

    // Get argument (handle to dump).
    dprintf("Handle: %lx\n",dwHandle);
    dprintf("\tIndex | UNIQUE | SRV TYPE\n");
    dprintf("\t %.4x |   %.2x   | %.6s (%2x)\n",
           DdHmgIfromH(dwHandle),
           (dwHandle & DD_UNIQUE_MASK) >> DD_UNIQUE_SHIFT,
           pszDdTypes[DdHmgObjtype(dwHandle)], DdHmgObjtype(dwHandle));

    return;

dddht_help:
  dprintf("Usage: dddht [-?] object_handle\n");
  dprintf("-? displays this help\n");
  dprintf("object_handle must be in hexadecimal\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\dcexts.cxx ===
/******************************Module*Header*******************************\
* Module Name: dcexts.cxx
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/


#include "precomp.hxx"


// class DC    
#define GetDCField(field)                   \
        GetDCSubField(#field, field)

#define GetDCSubField(field,local)          \
        GetFieldData(offDC, GDIType(DC), field, sizeof(local), &local)

#define GetDCOffset(field)                  \
        GetFieldOffset(GDIType(DC), #field, &offset)

#define GetDCFieldAndOffset(field)          \
    do {                                    \
        GetDCField(field);                  \
        GetDCOffset(field);                 \
    } while (0)

// _DC_ATTR
#define GetDCATTRField(field)               \
        GetDCATTRSubField(#field, field)

#define GetDCATTRSubField(field,local)      \
        GetFieldData(offDCATTR, GDIType(_DC_ATTR), field, sizeof(local), &local)

#define GetDCATTROffset(field)              \
        GetFieldOffset(GDIType(_DC_ATTR), #field, &offset)

#define GetDCATTRFieldAndOffset(field)      \
    do {                                    \
        GetDCATTRField(field);              \
        GetDCATTROffset(field);             \
    } while (0)

// DCLEVEL
#define GetDCLEVELField(field)              \
        GetDCLEVELSubField(#field, field)

#define GetDCLEVELSubField(field,local)     \
        GetFieldData(offDCLEVEL, GDIType(DCLEVEL), field, sizeof(local), &local)

#define GetDCLEVELOffset(field)             \
        GetFieldOffset(GDIType(DCLEVEL), #field, &offset)

#define GetDCLEVELFieldAndOffset(field)     \
    do {                                    \
        GetDCLEVELField(field);             \
        GetDCLEVELOffset(field);            \
    } while (0)


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpDCGeneral
*
\**************************************************************************/
void vDumpDCgeneral(ULONG64 offDC)
{
#define     DPRINTDCPP(aa,bb)   \
            DPRINTPP(aa,bb,offDC)
#define     DPRINTDCPX(aa,bb)   \
            DPRINTPX(aa,bb,offDC)
#define     DPRINTDCPS(bb)   \
            DPRINTPS(bb,offDC)

#define GetERECTLvalues {   \
        GetFieldData(percl, "ERECTL", "left", sizeof(left), &left);         \
        GetFieldData(percl, "ERECTL", "top", sizeof(top), &top);            \
        GetFieldData(percl, "ERECTL", "right", sizeof(right), &right);      \
        GetFieldData(percl, "ERECTL", "bottom", sizeof(bottom), &bottom);   \
}

    ULONG64     ppdev_, dhpdev_;
    ULONG64     hdcNext_, hdcPrev_;
    ULONG64     prgnAPI_, prgnVis_, prgnRao_;
    ULONG64     psurfInfo_, pDCAttr, ebrushobj;
    ULONG64     hlfntCur_, prfnt_, pPFFList;
    ULONG64     percl;
    SHORT       ipfdDevMax_;
    FSHORT      fs_;
    POINTL      ptlFillOrigin_;
    FLONG       flGraphicsCaps_,flSimulationFlags_;
    LONG        lEscapement_, left, right, top, bottom;
    ULONG       ulCopyCount_, offset;
    DCTYPE      dctp_;
    FLAGDEF     *pfd;

    GetDCFieldAndOffset(ppdev_);
    DPRINTDCPP( ppdev_,          "ppdev_             " );

    GetDCFieldAndOffset(dhpdev_);
    DPRINTDCPP( dhpdev_,         "dhpdev_            " );

    GetDCFieldAndOffset(flGraphicsCaps_);
    DPRINTDCPX( flGraphicsCaps_, "flGraphicsCaps_    " );
    for (pfd = afdGInfo; pfd->psz; pfd++)
        if (pfd->fl & flGraphicsCaps_) {
            dprintf("\t\t\t\t%s\n", pfd->psz);
            flGraphicsCaps_ &= ~pfd->fl;
        }
    if (flGraphicsCaps_) dprintf(" \t\t\t%-#x BAD FLAGS\n", flGraphicsCaps_);
    
    GetDCFieldAndOffset(hdcNext_);
    DPRINTDCPP( hdcNext_,        "hdcNext_           " );

    GetDCFieldAndOffset(hdcPrev_);
    DPRINTDCPP( hdcPrev_,        "hdcPrev_           " );
    
    GetDCOffset(erclClip_);
    percl = offDC + offset;
    GetERECTLvalues;
    DPRINTDCPS( "erclClip            " );
    dprintf("%d %d %d %d\n", left, top, right, bottom );
    
    GetDCOffset(erclWindow_);
    percl = offDC + offset;
    GetERECTLvalues;
    DPRINTDCPS( "erclWindow          " );
    dprintf("%d %d %d %d\n", left, top, right, bottom );
    
    GetDCOffset(erclBounds_);
    percl = offDC + offset;
    GetERECTLvalues;
    DPRINTDCPS( "erclBounds_         " );
    dprintf("%d %d %d %d\n", left, top, right, bottom );

    GetDCOffset(erclBoundsApp_);
    percl = offDC + offset;
    GetERECTLvalues;
    DPRINTDCPS( "erclBoundsApp_      " );
    dprintf("%d %d %d %d\n", left, top, right, bottom);

    GetDCFieldAndOffset(prgnAPI_);
    DPRINTDCPP( prgnAPI_,        "prgnAPI_           " );

    GetDCFieldAndOffset(prgnVis_);
    DPRINTDCPP( prgnVis_,        "prgnVis_           " );
    
    GetDCFieldAndOffset(prgnRao_);
    DPRINTDCPP( prgnRao_,        "prgnRao_           " );
    
    GetDCFieldAndOffset(ipfdDevMax_);
    DPRINTDCPS( "ipfdDevMax_\n" );
    
    GetDCFieldAndOffset(ptlFillOrigin_);
    DPRINTDCPS( "ptlFillOrigin       " );
    dprintf("%d %d\n", ptlFillOrigin_.x, ptlFillOrigin_.y);
    
    GetDCOffset(eboFill_);
    ebrushobj = offDC + offset;
    DPRINTDCPS("eboFill_\n");
    
    GetDCOffset(eboLine_);
    ebrushobj = offDC + offset;
    DPRINTDCPS("eboLine_\n");
    
    GetDCOffset(eboText_);
    ebrushobj = offDC + offset;
    DPRINTDCPS("eboText_\n");
    
    GetDCOffset(eboBackground_);
    ebrushobj = offDC + offset;
    DPRINTDCPS("eboBackground_\n");
    
    GetDCFieldAndOffset(hlfntCur_);
    DPRINTDCPP( hlfntCur_,       "hlfntCur_          " );

    GetDCFieldAndOffset(flSimulationFlags_);
    DPRINTDCPX( flSimulationFlags_, "flSimulationFlags_ " );
    for (pfd = afdTSIM; pfd->psz; pfd++)
        if (pfd->fl & flSimulationFlags_) {
            dprintf(" \t\t\t\t%s\n", pfd->psz);
            flSimulationFlags_ &= ~pfd->fl;
        }
    if (flSimulationFlags_) dprintf(" \t\t\t%-#x BAD FLAGS\n", flSimulationFlags_);
    
    GetDCFieldAndOffset(lEscapement_);
    DPRINTDCPS("lEscapement_        " );
    dprintf( "%d\n", lEscapement_ );

    GetDCFieldAndOffset(prfnt_);
    DPRINTDCPP( prfnt_,          "prfnt_             " );

    GetDCFieldAndOffset(pPFFList);
    DPRINTDCPP( pPFFList,        "pPFFList           " );

    GetDCOffset(co_);
    DPRINTDCPS("co_                 " );
    dprintf("!gdikdx.dco %p\n", offDC + offset);

    GetDCFieldAndOffset(pDCAttr);
    DPRINTDCPP( pDCAttr,         "pDCAttr            " );

    GetDCOffset(dcattr);
    DPRINTDCPS( "dcattr              " );
    dprintf("!gdikdx.dca %p\n", offDC + offset);

    GetDCOffset(dclevel);
    DPRINTDCPS( "dclevel             " );
    dprintf("!gdikdx.dcl %p\n", offDC + offset);

    GetDCFieldAndOffset(ulCopyCount_);
    DPRINTDCPS( "ulCopyCount_        " );
    dprintf("%u\n" , ulCopyCount_);

    GetDCFieldAndOffset(psurfInfo_);
    DPRINTDCPP( psurfInfo_,      "pSurfInfo          " );

    GetDCFieldAndOffset(dctp_);                
    DPRINTDCPS( "dctp_               " );
    dprintf("%d %s\n", dctp_, pszDCTYPE(dctp_));

    GetDCFieldAndOffset(fs_);
    DPRINTDCPX( fs_,            "fs_                " );
    for (pfd = afdDCfs; pfd->psz; pfd++)
        if (pfd->fl & fs_) {
            dprintf("\t\t\t\t%s\n", pfd->psz);
            fs_ &= ~pfd->fl;
        }
    if (fs_)
        dprintf(" \t\t\t%-#x BAD FLAGS\n", fs_);
    
    dprintf("\n");

#undef GetERECTLvalues
    
    return;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpDC_ATTR
*
\**************************************************************************/
void vDumpDC_ATTR(ULONG64 offDCATTR)
{
#define     DPRINTDCATTRPP(aa,bb)  \
            DPRINTPP(aa,bb,offDCATTR)
#define     DPRINTDCATTRPX(aa,bb)  \
            DPRINTPX(aa,bb,offDCATTR)
#define     DPRINTDCATTRPS(bb)  \
            DPRINTPS(bb,offDCATTR)
#define     DPRINTDCATTRPD(aa,bb)  \
            DPRINTPD(aa,bb,offDCATTR)

    ULONG64     pvLDC, hbrush, hcmXform, hColorSpace, hlfntNew, pvisrectrgn;
    ULONG       ulDirty_, offset, Flags;
    DWORD       crBackgroundClr, crForegroundClr, iCS_CP, IcmBrushColor, IcmPenColor, dwLayout;
    ULONG       ulBackgroundClr, ulForegroundClr;
    LONG        lIcmMode,lBkMode, lFillMode, lStretchBltMode, lTextAlign, lTextExtra, lRelAbs, lBreakExtra, cBreak, lWindowOrgx;
    FLONG       flTextAlign, flFontMapper, flXform;
    BYTE        jROP2, jBkMode, jFillMode, jStretchBltMode;
    POINTL      ptlCurrent, ptfxCurrent, ptlWindowOrg, ptlViewportOrg, ptlBrushOrigin;
    SIZEL       szlWindowExt, szlViewportExt, szlVirtualDevicePixel,szlVirtualDeviceMm;
    int         iGraphicsMode;
    INT         iMapMode;
    LONG        left, top, right, bottom;
    FLAGDEF     *pfd;
    char        ach[128], *psz = ach;
    
    if (offDCATTR)
    {
        dprintf("\nDC_ATTR\n address\n -------\n");
        
        GetDCATTRFieldAndOffset(pvLDC);
        DPRINTDCATTRPP(pvLDC, " pvLDC               ");

        GetDCATTRFieldAndOffset(ulDirty_);
        dprintf("[%x]", offDCATTR + offset);
        dprintf(" ulDirty_              %-#x\n",ulDirty_);
        for (pfd=afdDirty; pfd->psz; pfd++)
            if (ulDirty_ & pfd->fl) {
                dprintf("\t\t\t\t%s\n", pfd->psz);
                ulDirty_ &= ~pfd->fl;
            }
        if (ulDirty_)
            dprintf("\t\t\t\t? %-#x\tBAD FLAGS\n", ulDirty_);
        
        //
        // hbrush
        //
        GetDCATTRFieldAndOffset(hbrush);
        DPRINTDCATTRPP(hbrush, "hbrush                 ");
    
        GetDCATTRFieldAndOffset(crBackgroundClr);
        DPRINTDCATTRPX(crBackgroundClr, "crBackgroundClr        ");
    
        GetDCATTRFieldAndOffset(ulBackgroundClr);
        DPRINTDCATTRPX(ulBackgroundClr, "ulBackgroundClr        ");
    
        GetDCATTRFieldAndOffset(crForegroundClr);
        DPRINTDCATTRPX(crForegroundClr, "crForegroundClr        ");
    
        GetDCATTRFieldAndOffset(ulForegroundClr);
        DPRINTDCATTRPX(ulForegroundClr, "ulForegroundClr        ");
    
        GetDCATTRFieldAndOffset(iCS_CP);
        DPRINTDCATTRPX(iCS_CP, "iCS_CP                 ");
    
        GetDCATTRFieldAndOffset(iGraphicsMode);
        dprintf("[%p] iGraphicsMode           %d= %s\n",
                offDCATTR + offset, iGraphicsMode, pszGraphicsMode(iGraphicsMode));
    
        GetDCATTRFieldAndOffset(jROP2);
        dprintf("[%p] jROP2                   %d= %s\n",
                offDCATTR + offset, jROP2, pszROP2(jROP2));
    
        GetDCATTRFieldAndOffset(jBkMode);
        dprintf("[%p] jBkMode                 %d= %s\n",
                offDCATTR + offset, jBkMode, pszBkMode(jBkMode));
    
        // jFillMode
        GetDCATTRFieldAndOffset(jFillMode);
        switch (jFillMode) {
            case ALTERNATE: psz = "ALTERNATE"; break;
            case WINDING  : psz = "WINDING"  ; break;
            default       : psz = "?FILLMODE"; break;
        }
        dprintf("[%p] jFillMode               %d = %s\n", offDCATTR + offset, jFillMode, psz);
        
        // jStretchBltMode
        GetDCATTRFieldAndOffset(jStretchBltMode);
        switch (jStretchBltMode) {
            case BLACKONWHITE: psz = "BLACKONWHITE"; break;
            case WHITEONBLACK: psz = "WHITEONBLACK"; break;
            case COLORONCOLOR: psz = "COLORONCOLOR"; break;
            case HALFTONE    : psz = "HALFTONE"    ; break;
            default          : psz = "?STRETCHMODE"; break;
        }
        dprintf("[%p] jStretchBltMode         %d = %s\n", offDCATTR + offset, jStretchBltMode, psz);
        
        //
        // ICM
        //
    
        GetDCATTRFieldAndOffset(lIcmMode);
        DPRINTDCATTRPX(lIcmMode, "lIcmMode               ");
    
        GetDCATTRFieldAndOffset(hcmXform);
        DPRINTDCATTRPP(hcmXform, "hcmXform               ");
    
        GetDCATTRFieldAndOffset(hColorSpace);
        DPRINTDCATTRPP(hColorSpace, "hColorSpace            ");
    
        GetDCATTRFieldAndOffset(IcmBrushColor);
        DPRINTDCATTRPX(IcmBrushColor, "IcmBrushColor          ");
    
        GetDCATTRFieldAndOffset(IcmPenColor);
        DPRINTDCATTRPX(IcmPenColor, "IcmPenColor            ");
        
        GetDCATTRFieldAndOffset(ptlCurrent);
        dprintf("[%p] ptlCurrent              %d %d\n", offDCATTR + offset, ptlCurrent.x, ptlCurrent.y);
    
        GetDCATTRFieldAndOffset(ptfxCurrent);
        dprintf("[%p] ptfxCurrent             %-#x %-#x\n", offDCATTR + offset, ptfxCurrent.x, ptfxCurrent.y);
        
        GetDCATTRFieldAndOffset(lBkMode);
        dprintf("[%p] lBkMode                 %d = %s\n",
                offDCATTR + offset, lBkMode, pszBkMode(lBkMode));
        
        GetDCATTRFieldAndOffset(lFillMode);
        switch (lFillMode) {
            case ALTERNATE: psz = "ALTERNATE"; break;
            case WINDING  : psz = "WINDING"  ; break;
            default       : psz = "?"        ; break;
        }
        dprintf("[%p] lFillMode               %d = %s\n", offDCATTR + offset, lFillMode, psz);
    
        GetDCATTRFieldAndOffset(lStretchBltMode);
        switch (lStretchBltMode) {
            case BLACKONWHITE: psz = "BLACKONWHITE"; break;
            case WHITEONBLACK: psz = "WHITEONBLACK"; break;
            case COLORONCOLOR: psz = "COLORONCOLOR"; break;
            case HALFTONE    : psz = "HALFTONE"    ; break;
            default          : psz = "?"           ; break;
        }
        dprintf("[%p] lStretchBltMode         %d = %s\n", offDCATTR + offset, lStretchBltMode, psz);
    
        GetDCATTRFieldAndOffset(flTextAlign);
        DPRINTDCATTRPS("flTextAlign             ");
        dprintf("%-#x = %s | %s | %s\n", flTextAlign, pszTA_U(flTextAlign), pszTA_H(flTextAlign), pszTA_V(flTextAlign));
    
        GetDCATTRFieldAndOffset(lTextAlign);
        DPRINTDCATTRPS("lTextAlign              ");
        dprintf("%-#x = %s | %s | %s\n", lTextAlign, pszTA_U(lTextAlign), pszTA_H(lTextAlign), pszTA_V(lTextAlign));
    
        GetDCATTRFieldAndOffset(lTextExtra);
        DPRINTDCATTRPD(lTextExtra, "lTextExtra             ");
        
        GetDCATTRFieldAndOffset(lRelAbs);
        DPRINTDCATTRPD(lRelAbs, "lRelAbs                ");

        GetDCATTRFieldAndOffset(lBreakExtra);
        DPRINTDCATTRPD(lBreakExtra, "lBreakExtra            ");

        GetDCATTRFieldAndOffset(cBreak);
        DPRINTDCATTRPD(cBreak, "cBreak                 ");

        GetDCATTRFieldAndOffset(hlfntNew);
        DPRINTDCATTRPP(hlfntNew, "hlfntNew               ");
        
        GetDCATTRFieldAndOffset(iMapMode);
        DPRINTDCATTRPX(iMapMode,"iMapMode               ");
        dprintf("\t\t\t\t%s\n",pszMapMode(iMapMode));
    
        GetDCATTRFieldAndOffset(flFontMapper);
        DPRINTDCATTRPX(flFontMapper, "flFontMapper           ");    

        GetDCATTRFieldAndOffset(dwLayout);
        DPRINTDCATTRPD(dwLayout, "dwLayout               ");

        GetDCATTRFieldAndOffset(lWindowOrgx);
        DPRINTDCATTRPD(lWindowOrgx, "lWindowOrgx            ");

        GetDCATTRFieldAndOffset(ptlWindowOrg);
        dprintf("[%p] ptlWindowOrg            %d %d\n",
                offDCATTR + offset, ptlWindowOrg.x, ptlWindowOrg.y);
    
        GetDCATTRFieldAndOffset(szlWindowExt);
        dprintf("[%p] szlWindowExt            %d %d\n",
                offDCATTR + offset, szlWindowExt.cx, szlWindowExt.cy);
    
        GetDCATTRFieldAndOffset(ptlViewportOrg);
        dprintf("[%p] ptlViewportOrg          %d %d\n",
                offDCATTR + offset, ptlViewportOrg.x, ptlViewportOrg.y);
    
        GetDCATTRFieldAndOffset(szlViewportExt);
        dprintf("[%p] szlViewportExt          %d %d\n",
                offDCATTR + offset, szlViewportExt.cx, szlViewportExt.cy);
    
        GetDCATTRFieldAndOffset(flXform);
        DPRINTDCATTRPX(flXform, "flXform                ");
        for (pfd = afdflx; pfd->psz; pfd++) {
            if (flXform & pfd->fl) {
                dprintf("\t\t\t\t%s\n", pfd->psz);
                flXform &= ~pfd->fl;
            }
        }
        if (flXform)
            dprintf("\t\t\t\t%-#x bad flags\n", flXform);
    
        GetDCATTROffset(mxWtoD);
        dprintf("[%p] mxWorldToDevice         !gdikdx.mx %p\n", offDCATTR + offset, offDCATTR + offset);
        GetDCATTROffset(mxDtoW);
        dprintf("[%p] mxDeviceToWorld         !gdikdx.mx %p\n", offDCATTR + offset, offDCATTR + offset);
        GetDCATTROffset(mxWtoP);
        dprintf("[%p] mxWorldToPage           !gdikdx.mx %p\n", offDCATTR + offset, offDCATTR + offset);
        
        GetDCATTRFieldAndOffset(szlVirtualDevicePixel);
        dprintf("[%p] szlVirtualDevicePixel   %d %d\n",
            offDCATTR + offset, szlVirtualDevicePixel.cx, szlVirtualDevicePixel.cy);
     
        GetDCATTRFieldAndOffset(szlVirtualDeviceMm);
        dprintf("[%p] szlVirtualDeviceMm      %d %d\n",
            offDCATTR + offset, szlVirtualDeviceMm.cx, szlVirtualDeviceMm.cy);     
     
        GetDCATTRFieldAndOffset(ptlBrushOrigin);
        dprintf("[%p] ptlBrushOrigin\t     %d %d\n",
            offDCATTR + offset, ptlBrushOrigin.x, ptlBrushOrigin.y);   
   
        GetDCATTROffset(VisRectRegion);
        pvisrectrgn = offDCATTR + offset;
        dprintf("[%p] VisRectRegion", pvisrectrgn);
        
        GetFieldData(pvisrectrgn, "_RGNATTR", "Flags", sizeof(Flags), &Flags);
        if (Flags & ATTR_RGN_VALID)
        {
            GetFieldData(pvisrectrgn, "_RGNATTR", "Rect.left", sizeof(left), &left);
            GetFieldData(pvisrectrgn, "_RGNATTR", "Rect.top", sizeof(top), &top);
            GetFieldData(pvisrectrgn, "_RGNATTR", "Rect.right", sizeof(right), &right);
            GetFieldData(pvisrectrgn, "_RGNATTR", "Rect.bottom", sizeof(bottom), &bottom);
            dprintf("                        %d %d %d %d", left, top, right, bottom);
        }
        else
           dprintf("           INVALID");
        dprintf("\n");
    }
    else
        dprintf("Address of _DC_ATTR is NULL.\n");

    return;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpDCLEVEL
*
* Routine Description:
*
* Arguments:
*
* Return Value:
*
\**************************************************************************/
void vDumpDCLEVEL(ULONG64 offDCLEVEL)
{
#define     DPRINTDCLEVELPP(aa,bb)  \
            DPRINTPP(aa,bb,offDCLEVEL)
#define     DPRINTDCLEVELPX(aa,bb)  \
            DPRINTPX(aa,bb,offDCLEVEL)
#define     DPRINTDCLEVELPS(bb)  \
            DPRINTPS(bb,offDCLEVEL)
#define     DPRINTDCLEVELPD(aa,bb)  \
            DPRINTPD(aa,bb,offDCLEVEL)
    
    ULONG64     pSurface, hpal, ppal, hdcSave, pbrFill, pbrLine, hpath, pColorSpace;
    ULONG64     prgnClip, prgnMeta;
    ULONG64     pfield;
    FLONG       flPath, flFontState, fl, flbrush;
    LONG        lSaveDepth, lIcmMode;
    SIZEL       sizl;
    ULONG       offset;
    FLAGDEF     *pfd;


    dprintf("\nDCLEVEL @ %p\n address\n -------\n", offDCLEVEL);

    GetDCLEVELFieldAndOffset(pSurface);
    DPRINTDCLEVELPP( pSurface,           "pSurface        " );

    GetDCLEVELFieldAndOffset(hpal);
    DPRINTDCLEVELPP( hpal,               "hpal            " );

    GetDCLEVELFieldAndOffset(ppal);
    DPRINTDCLEVELPP( ppal,               "ppal            " );

    GetDCLEVELFieldAndOffset(sizl);
    DPRINTDCLEVELPS("sizl             " );
      dprintf("%d %d\n", sizl.cx, sizl.cy);

    GetDCLEVELFieldAndOffset(lSaveDepth);
    DPRINTDCLEVELPX(lSaveDepth,         "lSaveDepth      ");

    GetDCLEVELFieldAndOffset(hdcSave);
    DPRINTDCLEVELPP( hdcSave,            "hdcSave         " );

    GetDCLEVELFieldAndOffset(pbrFill);
    DPRINTDCLEVELPP( pbrFill,            "pbrFill         " );

    GetDCLEVELFieldAndOffset(pbrLine);
    DPRINTDCLEVELPP( pbrLine,            "pbrLine         " );

    GetDCLEVELFieldAndOffset(hpath);
    DPRINTDCLEVELPP( hpath,              "hpath           " );

    GetDCLEVELFieldAndOffset(pColorSpace);
    DPRINTDCLEVELPP( pColorSpace,        "pColorSpace     " );

    GetDCLEVELFieldAndOffset(lIcmMode);
    DPRINTDCLEVELPP( lIcmMode,           "lIcmMode        " );

// flPath
    GetDCLEVELFieldAndOffset(flPath);
    DPRINTDCLEVELPP( flPath,             "flPath          " );
    for (pfd = afdDCPATH; pfd->psz; pfd++)
        if (flPath & pfd->fl) {
            dprintf("\t\t\t\t%s\n", pfd->psz);
            flPath &= ~pfd->fl;
        }
    if (flPath)
        dprintf("\t\t\t\t%-#x bad flags\n", flPath);

// laPath

    GetDCLEVELOffset(laPath);
    pfield = offDCLEVEL + offset;
    DPRINTDCLEVELPS("laPath           ");
    dprintf("!gdikdx.la %p\n", pfield);

    GetDCLEVELFieldAndOffset(prgnClip);
    DPRINTDCLEVELPP( prgnClip,           "prgnClip        " );

    GetDCLEVELFieldAndOffset(prgnMeta);
    DPRINTDCLEVELPP( prgnMeta,           "prgnMeta        " );

// ca

    GetDCLEVELOffset(ca);
    pfield = offDCLEVEL + offset;
    dprintf("[%p] ca               !gdikdx.ca %p\n", pfield, pfield);

// flFontState

    GetDCLEVELFieldAndOffset(flFontState);
    DPRINTDCLEVELPS("flFontState      ");
    if (!flFontState)
        dprintf("0\n");
    else
    {
        for (pfd = afdFS2; pfd->psz; pfd++) {
            if (flFontState & pfd->fl) {
                dprintf("\t\t\t\t%s\n", pfd->psz);
                flFontState &= ~pfd->fl;
            }
        }
        if (flFontState)
            dprintf("\t\t\t\t%-#x bad flags\n", flFontState);
    }

    GetDCLEVELOffset(ufi);
    pfield = offDCLEVEL + offset;
    DPRINTDCLEVELPS("ufi");
    dprintf("\n");

    GetDCLEVELFieldAndOffset(fl);
    DPRINTDCLEVELPX( fl,                 "fl              " );
    if (fl == DC_FL_PAL_BACK)
        dprintf("\t\t\t\t\tDC_FL_PAL_BACK\n");
    else if (fl != 0)
        dprintf("\t\t\t\tbad flags\n");

    GetDCLEVELFieldAndOffset(flbrush);
    DPRINTDCLEVELPX( flbrush,            "flbrush         " );

    GetDCLEVELOffset(mxWorldToDevice);
    DPRINTDCLEVELPS("mxWorldToDevice\t !gdikdx.mx ");
    dprintf("%p\n", offDCLEVEL + offset);

    
    GetDCLEVELOffset(mxDeviceToWorld);
    DPRINTDCLEVELPS("mxDeviceToWorld\t !gdikdx.mx ");
    dprintf("%p\n", offDCLEVEL + offset);

    GetDCLEVELOffset(mxWorldToPage);
    DPRINTDCLEVELPS("mxWorldToPage\t !gdikdx.mx ");
    dprintf("%p\n", offDCLEVEL + offset);
    
    dprintf("\n");
    return;

/*    #define M3(aa,bb) \
        dprintf("[%x] %s%-#x\n", &(pdclSrc->##aa), (bb), pdcl->##aa)
    #define M2(aa,bb) \
        dprintf("[%x] %s", &(pdclSrc->##aa), (bb))

    FLAGDEF *pfd;
    FLONG fl;
    LONG l;
    CHAR ach[128], *psz;


    GetDCLEVELFieldAndOffset(efM11PtoD);
    sprintEFLOAT( ach, pdcl->efM11PtoD );
    M2( efM11PtoD,  "efM11PtoD      ");
    dprintf("%s\n", ach);

    sprintEFLOAT( ach, pdcl->efM22PtoD );
    M2( efM22PtoD,  "efM22PtoD      ");
    dprintf("%s\n", ach);

    sprintEFLOAT( ach, pdcl->efDxPtoD );
    M2( efDxPtoD,   "efDxPtoD       ");
    dprintf("%s\n", ach);

    sprintEFLOAT( ach, pdcl->efDyPtoD );
    M2( efDyPtoD,   "efDyPtoD       ");
    dprintf("%s\n", ach);

    sprintEFLOAT( ach, pdcl->efM11_TWIPS );
    M2( efM11_TWIPS,"efM11_TWIPS    ");
    dprintf("%s\n", ach);

    sprintEFLOAT( ach, pdcl->efM22_TWIPS );
    M2( efM22_TWIPS,"efM22_TWIPS    ");
    dprintf("%s\n", ach);

    sprintEFLOAT( ach, pdcl->efPr11 );
    M2( efPr11,     "efPr11         ");
    dprintf("%s\n", ach);

    sprintEFLOAT( ach, pdcl->efPr22 );
    M2( efPr22,     "efPr22         ");
    dprintf("%s\n", ach);

    #undef M2
    #undef M3
*/
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpDCFontInfo
*
\**************************************************************************/
void vDumpDCFontInfo(ULONG64 offDC)
{
    ULONG64     prfnt_, hlfntCur_, pDCAttr, offDCLEVEL;
    FLONG       flFontState, fl, flFontMapper, flXform;
    INT         iMapMode;
    ULONG       offset;
    FLAGDEF     *pfd;

    dprintf("\n");

    GetDCFieldAndOffset(prfnt_);
    dprintf("[%p] prfnt_           %p\t(!gdikdx.fo -f %p)\n",
        offDC + offset, prfnt_, prfnt_);

    GetDCFieldAndOffset(hlfntCur_);
    dprintf("[%p] hlfntCur_        %p", offDC + offset, hlfntCur_);
    if (hlfntCur_)
        vDumpHFONT(hlfntCur_);
    else
        dprintf("\n");
    
    GetDCField(pDCAttr);
    if (pDCAttr)
    {
        ULONG64  offDCATTR, hlfntNew;
        int      iGraphicsMode;
        LONG     lBkMode, lTextAlign, lTextExtra, lBreakExtra, cBreak;

        offDCATTR = pDCAttr;
        GetDCATTRFieldAndOffset(hlfntNew);
        dprintf("[%p] hlfntNew         %p", offDCATTR + offset, hlfntNew);
    
        if (hlfntNew != hlfntCur_)
            vDumpHFONT(hlfntNew);
        else
            dprintf(" (same as hlfntCur_)\n");
        
        // iGraphicsMode

        GetDCATTRFieldAndOffset(iGraphicsMode);
        dprintf("[%p] iGraphicsMode    %d = %s\n",
            offDCATTR + offset,
            iGraphicsMode,
            pszGraphicsMode(iGraphicsMode)
            );

        // lBkMode

        GetDCATTRFieldAndOffset(lBkMode);
        dprintf("[%p] lBkMode          %d = %s\n",
            offDCATTR + offset, lBkMode, pszBkMode(lBkMode));
        
        // lTextAlign

        GetDCATTRFieldAndOffset(lTextAlign);
        dprintf("[%p] lTextAlign       %d =",
                offDCATTR + offset, lTextAlign);
        dprintf(" %s | %s | %s\n",
            pszTA_U(lTextAlign),
            pszTA_H(lTextAlign),pszTA_V(lTextAlign));

        GetDCATTRFieldAndOffset(lTextExtra);
        dprintf("[%p] lTextExtra       %d\n",
            offDCATTR + offset, lTextExtra);

        GetDCATTRFieldAndOffset(lBreakExtra);
        dprintf("[%p] lBreakExtra      %d\n",
            offDCATTR + offset, lBreakExtra);

        GetDCATTRFieldAndOffset(cBreak);
        dprintf("[%p] cBreak           %d\n",
            offDCATTR + offset, cBreak);

        GetDCATTRFieldAndOffset(flFontMapper);
        dprintf("[%p] flFontMapper     %-#x",
            offDCATTR + offset, flFontMapper);
        if (flFontMapper == ASPECT_FILTERING)
            dprintf(" = ASPECT_FILTERING");
        else if (flFontMapper != 0)
            dprintf(" = ?");
        dprintf("\n");
        
        GetDCATTRFieldAndOffset(iMapMode);
        dprintf("[%p] iMapMode         %d = %s\n",
            offDCATTR + offset,
            iMapMode,
            pszMapMode(iMapMode)
            );
    
        GetDCATTRFieldAndOffset(flXform);
        dprintf("[%p] flXform          %-#x\n", offDCATTR + offset, flXform);
        for (pfd = afdflx; pfd->psz; pfd++)
            if (flXform & pfd->fl) dprintf("\t\t\t\t%s\n", pfd->psz);
    }
    else
        dprintf("pdc->pDCAttr == 0\n");
        
    GetDCOffset(dclevel);
    offDCLEVEL= offDC + offset;
    GetDCLEVELField(flFontState);
    dprintf("[%p] flFontState      %-#x", offDCLEVEL, flFontState);
    for (pfd = afdDCFS; pfd->psz; pfd++) {
        if (pfd->fl & flFontState) {
            dprintf(" = %s", pfd->psz);
        }        
    }
    dprintf("\n");
    
    GetDCLEVELOffset(mxWorldToDevice);
    dprintf("[%p] mxWorldToDevice\n", offDCLEVEL + offset);
    
    dprintf("\n");
       
    return;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   dca
*
\**************************************************************************/

DECLARE_API( dca )
{
    PARSE_POINTER(dca_help);  
    vDumpDC_ATTR(arg);
    
    EXIT_API(S_OK);

dca_help:
    dprintf("Usage: dca [-?] DC_ATTR pointer\n");
    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   dcl
*
\**************************************************************************/

DECLARE_API( dcl )
{
    PARSE_POINTER(dcl_help);
    vDumpDCLEVEL(arg);

    EXIT_API(S_OK);

dcl_help:
    dprintf("Usage: dcl [-?] DCLEVEL pointer\n");
    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   hdc
*
\**************************************************************************/

DECLARE_API( hdc )
{
    HRESULT hr;
    ULONG64 addrDC;
    BOOL    General =FALSE;
    BOOL    DCLevel =FALSE;
    BOOL    DCAttr  =FALSE;
    BOOL    FontInfo=FALSE;
    
    PARSE_POINTER(hdc_help);
    hr = GetObjectAddress(Client,arg,&addrDC,DC_TYPE,TRUE,TRUE);

    if(ntok<2) {
      General=TRUE;
    } else {
      if(parse_iFindSwitch(tokens, ntok, 'g')!=-1) {General=TRUE;}
      if(parse_iFindSwitch(tokens, ntok, 'l')!=-1) {DCLevel=TRUE;}
      if(parse_iFindSwitch(tokens, ntok, 't')!=-1) {DCAttr=TRUE;}
      if(parse_iFindSwitch(tokens, ntok, 'f')!=-1) {FontInfo=TRUE;}
    }
    if(!(General||DCLevel||DCAttr||FontInfo)) {General=TRUE;}

    if (hr == S_OK && addrDC)
    {
        dprintf("\nDC @ 0x%p\n address\n -------\n", addrDC);

    // general info
        if (General)
            vDumpDCgeneral(addrDC);

    // dcattr
        if (DCAttr)
        {
            ULONG64     addrDCAttr;
            ULONG       error;

            if (error = GetFieldData(addrDC, GDIType(DC), "pDCAttr", sizeof(addrDCAttr), &addrDCAttr))
            {
                dprintf("Unable to get pDCAttr\n");
                dprintf("  (GetFieldData returned %s)\n", pszWinDbgError(error));
            }
            else
            {
                vDumpDC_ATTR(addrDCAttr);
            }
        }

    // dclevel
        if (DCLevel)
        {
            ULONG   offDCLevel;
            GetFieldOffset(GDIType(DC), "dclevel", &offDCLevel);
            vDumpDCLEVEL(addrDC + offDCLevel);
        }

    // font information
        if (FontInfo)
            vDumpDCFontInfo(addrDC);
    }

    EXIT_API(S_OK);

hdc_help:
    dprintf("Usage: hdc [-?] [-g] [-l] [-t] [-f] handle\n"
            " -? help\n"
            " -g general\n"
            " -l dclevel\n"
            " -t dcattr\n"
            " -f font information\n");
    EXIT_API(S_OK);

}



/**************************************************************************\
* DC (ddc) Fields
\**************************************************************************/

PCSTR   DCAttribFields[] = {
    "dcattr.*",                 // "dcattr.ptlBrushOrigin",
    "pDCAttr",
    // Extended
    "ptlFillOrigin_",
    NULL
};

PCSTR   DCDrawFields[] = {
    "pDCAttr",
    "dclevel.hpath",
    "dclevel.flPath",
    // Extended
    "dclevel.laPath",
    NULL
};

PCSTR   DCFontFields[] = {
    "prfnt_",
    "pDCAttr",
    NULL
};

PCSTR   DCGeneralFields[] = {
    "hHmgr",
    "pDCAttr",
    "dclevel.",
    "dclevel.pSurface",
    "dctp_",
    "prgnVis_",
    "dclevel.prgnClip",
    "dclevel.prgnMeta",
    "prgnAPI_",
    "prgnRao_",
    "dclevel.sizl",
    "erclClip_",
    "eptlOrigin_",
    "erclWindow_",
    "erclBounds_",
    // Extended
    "fs_",
    "dhpdev_",
    "ppdev_",
    "hsemDcDevLock_",
    "flGraphicsCaps_",
    "flGraphicsCaps2_",
    "hdcPrev_",
    "hdcNext_",
    "hlfntCur_",
    "prfnt_",
    NULL
};

PCSTR   DCLevelFields[] = {
    "dclevel.*",
    NULL
};

PCSTR   DCSavedFields[] = {
    "dclevel.hdcSave",
    "dclevel.lSaveDepth",
    // Extended
    "dclevel.hpal",
    "dclevel.ppal",
    "pDCAttr",  //dprintf("\thlfntNew   =     0x%08lx\n", pdcattr->hlfntNew);
    "dclevel.flFontState", //afdDCFS
    "fs_",  // afdDCFS
    NULL
};

PCSTR   DCTextFields[] = {
    "pDCAttr",
    NULL
};

PCSTR   DCXformFields[] = {
    "dclevel.mxWorldToDevice.",
    "dclevel.mxDeviceToWorld.",
    "dclevel.mxWorldToPage.",
    // Extended
    "dclevel.mxWorldToDevice",
    NULL
};

/******************************Public*Routine******************************\
* DC (ddc)
*
* Debugger extension to dump a DC.
*
* History:
*  10-Jul-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
*
*  21-Feb-1995    -by- Lingyun Wang [lingyunw]
* Made it to work in the kernel.
*
*  22-Dec-2000 -by- Jason Hartman [jasonha]
* Rewrote for type knowledgable debugger.
*
\**************************************************************************/
DECLARE_API( ddc  )
{
    if (Client == NULL) return E_INVALIDARG;

    HRESULT         hr = S_OK;
    ULONG64         DCAddr;
    DEBUG_VALUE     Arg;
    ULONG64         Module;
    ULONG           TypeId;
    OutputControl   OutCtl(Client);

    BOOL    BadSwitch = FALSE;
    BOOL    DumpAll = FALSE;
    BOOL    bAttrib = FALSE;
    BOOL    bDraw   = FALSE;
    BOOL    bExtend = FALSE;
    BOOL    bFont   = FALSE;
    BOOL    bGeneral= FALSE;
    BOOL    bLevel  = FALSE;
    BOOL    bSaved  = FALSE;
    BOOL    bText   = FALSE;
    BOOL    bXform  = FALSE;

    while (!BadSwitch)
    {
        while (isspace(*args)) args++;

        if (*args != '-') break;

        args++;
        BadSwitch = (*args == '\0' || isspace(*args));

        while (*args != '\0' && !isspace(*args))
        {
            switch (tolower(*args))
            {
                case 'a': bAttrib = TRUE; break;
                case 'd': bDraw = TRUE; break;
                case 'e': bExtend = TRUE; break;
                case 'f': bFont = TRUE; break;
                case 'g': bGeneral = TRUE; break;
                case 'l': bLevel = TRUE; break;
                case 's': bSaved = TRUE; break;
                case 't': bText = TRUE; break;
                case 'v': DumpAll = TRUE; break;
                case 'x': bXform = TRUE; break;
                default:
                    BadSwitch = TRUE;
                    break;
            }

            if (BadSwitch) break;
            args++;
        }
    }

    if (BadSwitch)
    {
        OutCtl.Output("Usage: hdc [-?adefgstvx] <HDC | DC Addr>\n"
                      "\n"
                      "a - DC_ATTR\n"
                      "d - Drawing attributes\n"
                      "e - Extended info\n"
                      "f - Font data\n\n"
                      "g - General data (default)\n"
                      "l - DCLEVEL\n"
                      "s - Saved data\n"
                      "t - Text attributes\n"
                      "v - Verbose mode (print everything)\n"
                      "x - Transform data\n");

        return S_OK;
    }


    hr = GetTypeId(Client, "DC", &TypeId, &Module);

    if (hr != S_OK)
    {
        OutCtl.OutErr("Error getting type info for %s (%s).\n",
                      GDIType(DC), pszHRESULT(hr));
    }
    else if ((hr = Evaluate(Client, args, DEBUG_VALUE_INT64, 0, &Arg, NULL)) != S_OK ||
             Arg.I64 == 0)
    {
        if (hr == S_OK)
        {
            OutCtl.Output("Expression %s evalated to zero.\n", args);
        }
        else
        {
            OutCtl.OutErr("Evaluate(%s) returned %s.\n", args, pszHRESULT(hr));
        }
    }
    else
    {
        hr = GetObjectAddress(Client, Arg.I64, &DCAddr, DC_TYPE, TRUE, TRUE);

        if (hr != S_OK || DCAddr == 0)
        {
            DEBUG_VALUE         ObjHandle;
            TypeOutputParser    TypeParser(Client);
            OutputState         OutState(Client);
            ULONG64             DCAddrFromHmgr;

            DCAddr = Arg.I64;

            if ((hr = OutState.Setup(0, &TypeParser)) != S_OK ||
                (hr = OutState.OutputTypeVirtual(DCAddr, Module, TypeId, 0)) != S_OK ||
                (hr = TypeParser.Get(&ObjHandle, "hHmgr", DEBUG_VALUE_INT64)) != S_OK)
            {
                OutCtl.OutErr("Unable to get contents of DC::hHmgr\n");
                OutCtl.OutErr("  (Type Read returned %s)\n", pszHRESULT(hr));
                OutCtl.OutErr(" 0x%p is neither an HDC nor valid DC address\n", Arg.I64);
            }
            else
            {
                if (GetObjectAddress(Client, ObjHandle.I64, &DCAddrFromHmgr,
                                     DC_TYPE, TRUE, FALSE) == S_OK &&
                    DCAddrFromHmgr != DCAddr)
                {
                    OutCtl.OutWarn("\tNote: DC may not be valid.\n"
                                   "\t      It does not have a valid handle manager entry.\n");
                }
            }
        }

        //
        // If nothing was specified, dump main section
        //

        if (!(bAttrib || bDraw || bFont || bSaved || bText || bXform))
        {
            bGeneral = TRUE;
        }

        if (hr == S_OK)
        {
            TypeOutputDumper    TypeReader(Client, &OutCtl);

            if (DumpAll)
            {
                TypeReader.ExcludeMarked();

                // Don't recurse for big sub structures
                TypeReader.MarkField("dclevel.*");
                TypeReader.MarkField("dcattr.*");
                TypeReader.MarkField("co_.*");
                TypeReader.MarkField("eboFill_.*");
                TypeReader.MarkField("eboLine_.*");
                TypeReader.MarkField("eboText_.*");
                TypeReader.MarkField("eboBackground_.*");
            }
            else
            {
                TypeReader.IncludeMarked();

                if (bAttrib)
                {
                    TypeReader.MarkFields(DCAttribFields, bExtend ? -1 : 2);
                }

                if (bDraw)
                {
                    TypeReader.MarkFields(DCDrawFields, bExtend ? -1 : 3);
                }

                if (bFont)
                {
                    TypeReader.MarkFields(DCFontFields);
                }

                if (bGeneral)
                {
                    TypeReader.MarkFields(DCGeneralFields, bExtend ? -1 : 14);
                }

                if (bLevel)
                {
                    TypeReader.MarkFields(DCLevelFields);
                }

                if (bSaved)
                {
                    TypeReader.MarkFields(DCSavedFields, bExtend ? -1 : 2);
                }

                if (bText)
                {
                    TypeReader.MarkFields(DCTextFields);
                }

                if (bXform)
                {
                    TypeReader.MarkFields(DCXformFields, bExtend ? -1 : 3);
                }
            }

            OutCtl.Output(" DC @ 0x%p:\n", DCAddr);

            hr = TypeReader.OutputVirtual(Module, TypeId, DCAddr);

            if (hr != S_OK)
            {
                OutCtl.OutErr("Type Dump for DC returned %s.\n", pszHRESULT(hr));
            }
        }
    }

    return hr;
}



/******************************Public*Routine******************************\
* DCLIST
*
*   List DC and brief info
*
\**************************************************************************/

PCSTR   DCListFields[] = {
    "hHmgr",
    "dhpdev_",
    "ppdev_",
    "dclevel.pSurface",
    NULL
};

DECLARE_API(dclist)
{
    INIT_API();

    HRESULT hr;
    HRESULT hrMask;
    ULONG64 index;
    ULONG64 gcMaxHmgr;
    ULONG64 DCAddr;
    BOOL    BadSwitch = FALSE;
    BOOL    DumpBaseObject = FALSE;
    BOOL    DumpUserFields = FALSE;

    OutputControl   OutCtl(Client);

    while (isspace(*args)) args++;

    while (!BadSwitch)
    {
        while (isspace(*args)) args++;

        if (*args != '-') break;

        args++;
        BadSwitch = (*args == '\0' || isspace(*args));

        while (*args != '\0' && !isspace(*args))
        {
            switch (*args)
            {
                case 'b': DumpBaseObject = TRUE; break;
                default:
                    BadSwitch = TRUE;
                    break;
            }

            if (BadSwitch) break;
            args++;
        }
    }

    if (BadSwitch)
    {
        if (*args == '?')
        {
            OutCtl.Output("Lists all DCs and a few basic members.\n"
                          "\n");
        }

        OutCtl.Output("Usage: dclist [-?b] [<Member List>]\n"
                      "\n"
                      "   b - Dump BASEOBJECT information\n"
                      "\n"
                      "   Member List - Space seperated list of other SURFACE members\n"
                      "                 to be included in the dump\n");

        return S_OK;
    }

    if ((hr = GetMaxHandles(Client, &gcMaxHmgr)) != S_OK)
    {
        OutCtl.OutErr("Unable to get sizeof GDI handle table. HRESULT %s\n", pszHRESULT(hr));
        return hr;
    }

    gcMaxHmgr = (ULONG64)(ULONG)gcMaxHmgr;

    OutCtl.Output("Searching 0x%I64x handle entries for DCs.\n", gcMaxHmgr);

    OutputFilter    OutFilter(Client);
    OutputState     OutState(Client, FALSE);
    OutputControl   OutCtlToFilter;
    ULONG64         Module;
    ULONG           TypeId;
    ULONG           OutputMask;

    if ((hr = OutState.Setup(DEBUG_OUTPUT_NORMAL, &OutFilter)) == S_OK &&
        (hr = OutCtlToFilter.SetControl(DEBUG_OUTCTL_THIS_CLIENT |
                                DEBUG_OUTCTL_NOT_LOGGED,
                                OutState.Client)) == S_OK &&
        (hr = GetTypeId(Client, "DC", &TypeId, &Module)) == S_OK)
    {
        TypeOutputDumper    TypeReader(OutState.Client, &OutCtlToFilter);

        TypeReader.SelectMarks(1);
        TypeReader.IncludeMarked();
        if (DumpBaseObject) TypeReader.MarkFields(BaseObjectFields);

        // Add user specified fields to dump list
        PSTR    MemberList = NULL;
        CHAR   *pBOF = (CHAR *)args;

        if (iscsymf(*pBOF))
        {
            MemberList = (PSTR) HeapAlloc(GetProcessHeap(), 0, strlen(pBOF)+1);

            if (MemberList != NULL)
            {
                strcpy(MemberList, pBOF);
                pBOF = MemberList;

                DumpUserFields = TRUE;

                while (iscsymf(*pBOF))
                {
                    CHAR   *pEOF = pBOF;
                    CHAR    EOFChar;

                    // Get member
                    do {
                         pEOF++;
                    } while (iscsym(*pEOF) || *pEOF == '.' || *pEOF == '*');
                    EOFChar = *pEOF;
                    *pEOF = '\0';
                    TypeReader.MarkField(pBOF);

                    // Advance to next
                    if (EOFChar != '\0')
                    {
                        do
                        {
                            pEOF++;
                        } while (isspace(*pEOF));
                    }

                    pBOF = pEOF;
                }
            }
            else
            {
                OutCtl.OutErr("Error: Couldn't allocate memory for Member List.\n");
                hr = E_OUTOFMEMORY;
            }
        }

        if (hr == S_OK && *pBOF != '\0')
        {
            OutCtl.OutErr("Error: \"%s\" is not a valid member list.\n", pBOF);
            hr = E_INVALIDARG;
        }

        if (hr == S_OK)
        {
            // Setup default dump specifications
            TypeReader.SelectMarks(0);
            TypeReader.IncludeMarked();
            TypeReader.MarkFields(DCListFields);

            OutFilter.Replace(OUTFILTER_REPLACE_THIS, "hHmgr ", NULL);
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, "DC_TYPE : ", NULL);
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, " dhpdev_ ", NULL);
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, " ppdev_ ", NULL);
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, " dclevel DCLEVEL ", NULL);
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, " pSurface ", NULL);
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, "(null)", "(null)    ");

            OutCtl.Output(" &DC        HDC        dhpdev_    ppdev_     pSurface");
            if (DumpBaseObject) OutCtl.Output(" \tBASEOBJECT");
            if (DumpUserFields) OutCtl.Output(" %s", args);
            OutCtl.Output("\n");

            for (index = 0;
                 index < gcMaxHmgr;
                 index++)
            {
                if (OutCtl.GetInterrupt() == S_OK)
                {
                    OutCtl.OutWarn("User aborted search:\n"
                                   "  0x%I64x entries were checked.\n"
                                   "  0x%I64x entries remain.\n",
                                   index, gcMaxHmgr - index);
                    break;
                }

                // Turn off error and verbose messages for this call to
                // GetObjectAddress since it will spew for non-DCs.
                if ((hrMask = Client->GetOutputMask(&OutputMask)) == S_OK &&
                    OutputMask & (DEBUG_OUTPUT_ERROR | DEBUG_OUTPUT_VERBOSE))
                {
                    hrMask = Client->SetOutputMask(OutputMask & ~(DEBUG_OUTPUT_ERROR | DEBUG_OUTPUT_VERBOSE));
                }

                hr = GetObjectAddress(Client, index, &DCAddr, DC_TYPE, FALSE, FALSE);

                // Restore mask
                if (hrMask == S_OK &&
                    OutputMask & (DEBUG_OUTPUT_ERROR | DEBUG_OUTPUT_VERBOSE))
                {
                    Client->SetOutputMask(OutputMask);
                }

                if (hr != S_OK || DCAddr == 0) continue;

                OutCtl.Output(" 0x%p ", DCAddr);

                OutFilter.DiscardOutput();


                hr = TypeReader.OutputVirtual(Module, TypeId, DCAddr,
                                              DEBUG_OUTTYPE_NO_OFFSET |
                                              DEBUG_OUTTYPE_COMPACT_OUTPUT);

                if (hr == S_OK)
                {
                    if (DumpBaseObject || DumpUserFields)
                    {
                        OutCtlToFilter.Output("  \t");
                        TypeReader.SelectMarks(1);
                        TypeReader.OutputVirtual(Module, TypeId, DCAddr,
                                                 DEBUG_OUTTYPE_NO_OFFSET |
                                                 DEBUG_OUTTYPE_COMPACT_OUTPUT);
                        TypeReader.SelectMarks(0);
                    }

                    OutFilter.OutputText(&OutCtl, DEBUG_OUTPUT_NORMAL);

                    OutCtl.Output("\n");
                }
                else
                {
                    OutCtl.Output("0x????%4.4I64x  ** failed to read DC **\n", index);
                }
            }
        }

        if (MemberList != NULL)
        {
            HeapFree(GetProcessHeap(), 0, MemberList);
        }
    }
    else
    {
        OutCtl.OutErr(" Output state/control setup returned %s.\n",
                      pszHRESULT(hr));
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\debug.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    debug.cxx

Abstract:

    This file contains debug routines to debug extenstion problems.

Author:

    JasonHa

--*/


#include <precomp.hxx>


#if DBG

const char NoIndent[] = "";

void
vPrintNativeFieldInfo(
    PFIELD_INFO pFI,
    const char *pszIndent)
{
    if (!pFI) return;

    DbgPrint("  %sPUCHAR  fName     = \"%s\"\n", pszIndent, pFI->fName);
    DbgPrint("  %sPUCHAR  printName = \"%s\"\n", pszIndent, pFI->printName);
    DbgPrint("  %sULONG   size      = 0x%x\n", pszIndent, pFI->size);
    DbgPrint("  %sULONG   fOptions  = 0x%08x\n", pszIndent, pFI->fOptions);
    DbgPrint("  %sULONG64 address   = 0x%I64x\n", pszIndent, pFI->address);
    DbgPrint("  %sPVOID   fieldCallBack = 0x%p\n", pszIndent, pFI->fieldCallBack);
}


void
vPrintNativeSymDumpParam(
    PSYM_DUMP_PARAM pSDP,
    BOOL bDumpFields,
    const char *pszIndent)
{
    if (!pSDP) return;

    char    pszNextIndent[80];
    _snprintf(pszNextIndent, sizeof(pszNextIndent), "%s  ", pszIndent);

    DbgPrint("  %sULONG               size     = 0x%x\n", pszIndent, pSDP->size);
    DbgPrint("  %sPUCHAR              sName    = \"%s\"\n", pszIndent, pSDP->sName);
    DbgPrint("  %sULONG               Options  = 0x%08x\n", pszIndent, pSDP->Options);
    DbgPrint("  %sULONG64             addr     = 0x%I64x\n", pszIndent, pSDP->addr);
    DbgPrint("  %sPFIELD_INFO         listLink = 0x%p\n", pszIndent, pSDP->listLink);
    DbgPrint("  %sPVOID               Context  = 0x%p\n", pszIndent, pSDP->Context);
    DbgPrint("  %sPSYM_DUMP_FIELD_CALLBACK CallbackRoutine = 0x%p\n", pszIndent, pSDP->CallbackRoutine);
    DbgPrint("  %sULONG               nFields  = %d\n", pszIndent, pSDP->nFields);
    DbgPrint("  %sPFIELD_INFO         Fields   = 0x%p\n", pszIndent, pSDP->Fields);

    if (bDumpFields && pSDP->Fields)
    {
        for (ULONG nField = 0; nField < pSDP->nFields; nField++)
        {
            DbgPrint("  %sFIELD_INFO          Fields[%d] = {\n", pszIndent, nField);
            vPrintNativeFieldInfo(&pSDP->Fields[nField], pszNextIndent);
            DbgPrint("  %s}\n", pszIndent);
        }
    }
}

#endif  DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\extapi.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    extapi.cxx

Abstract:

    This file contains the generic routines and initialization code
    used by the debugger extensions routines.

Author:

    Jason Hartman (JasonHa) 2000-08-18

Environment:

    User Mode

--*/

#include "precomp.hxx"

const BOOL ClientInitialized = FALSE;

PDEBUG_ADVANCED         g_pExtAdvanced;
PDEBUG_CLIENT           g_pExtClient;
PDEBUG_CONTROL          g_pExtControl;
PDEBUG_DATA_SPACES      g_pExtData;
PDEBUG_REGISTERS        g_pExtRegisters;
PDEBUG_SYMBOLS          g_pExtSymbols;
PDEBUG_SYMBOL_GROUP     g_pExtSymbolGroup;
PDEBUG_SYSTEM_OBJECTS   g_pExtSystem;


#define REF_LIMIT   100
LONG    ExtRefCount = 0;
BOOL    ExtReady = FALSE;

#define MAX_NAME                 2048


DefOutputCallbacks   *g_pDefOutputCallbacks = NULL;

// Queries for all debugger interfaces.
extern "C" HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Hr;
    LONG    RefCheck;
    
    // Have to have a client to start with;)
    if (Client == NULL)
    {
        return S_FALSE;
    }

    RefCheck  = InterlockedIncrement(&ExtRefCount);

    if (RefCheck > REF_LIMIT)
    {
        DbgPrint("ExtQuery has calls exceeding limit.\n");
        InterlockedDecrement(&ExtRefCount);
        return S_FALSE;
    }

    if (RefCheck > 1)
    {
        // Wait until original refencer completes setup.
        //
        // If ExtRefCount drops below RefCheck then the
        //   original referencer failed as well as any
        //   waiters who started after us.
        while (!ExtReady && ExtRefCount >= RefCheck)
            Sleep(10);

        if (ExtReady)
        {
            // Make sure the clients match
            if (g_pExtClient != Client)
            {
                InterlockedDecrement(&ExtRefCount);
                return S_FALSE;
            }
            return S_OK;
        }
    }

    // Prepare to query interfaces.
    // Make sure no one is currently cleaning up.
    while (ExtReady)
    {
        Sleep(10);
    }

    if ((Hr = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                 (void **)&g_pExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Hr = Client->QueryInterface(__uuidof(IDebugControl),
                                 (void **)&g_pExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Hr = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                 (void **)&g_pExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Hr = Client->QueryInterface(__uuidof(IDebugRegisters),
                                 (void **)&g_pExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                 (void **)&g_pExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Hr = g_pExtSymbols->CreateSymbolGroup(&g_pExtSymbolGroup)) != S_OK)
    {
        goto Fail;
    }
    if ((Hr = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_pExtSystem)) != S_OK)
    {
        goto Fail;
    }

    // If symbols state has changed, make sure GDI symbols are loaded.
    if (gbSymbolsNotLoaded)
    {
        SymbolLoad(Client);
    }

    g_pExtClient = Client;

    ExtReady = TRUE;
    
    return S_OK;

Fail:
    ExtRelease(TRUE);
    InterlockedDecrement(&ExtRefCount);

    return Hr;
}


// Cleans up all debugger interfaces when there are no more references.
// A cleanup will be forced if Cleanup is TRUE.
void
ExtRelease(BOOL Cleanup)
{
    // Don't decrement the count when forcing cleanup.
    if (Cleanup || InterlockedDecrement(&ExtRefCount) < 1)
    {
        DbgPrint("Cleaning up interfaces.\n");

        EXT_RELEASE(g_pExtAdvanced);
        EXT_RELEASE(g_pExtControl);
        EXT_RELEASE(g_pExtData);
        EXT_RELEASE(g_pExtRegisters);
        EXT_RELEASE(g_pExtSymbols);
        EXT_RELEASE(g_pExtSystem);
        g_pExtClient = NULL;
        ExtReady = FALSE;
    }

    return;
}


// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;
    
    if (g_pExtControl == NULL)
    {
        DbgPrint("g_pExtControl is NULL.\n");
        return;
    }

    va_start(Args, Format);
    g_pExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}


// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;
    
    if (g_pExtControl == NULL)
    {
        DbgPrint("g_pExtControl is NULL.\n");
        return;
    }

    va_start(Args, Format);
    g_pExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}


// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;
    
    if (g_pExtControl == NULL)
    {
        DbgPrint("g_pExtControl is NULL.\n");
        return;
    }

    va_start(Args, Format);
    g_pExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}


// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;
    
    if (g_pExtControl == NULL)
    {
        DbgPrint("g_pExtControl is NULL.\n");
        return;
    }

    va_start(Args, Format);
    g_pExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}



ExtApiClass::ExtApiClass(
    PDEBUG_CLIENT DbgClient
    )
{
    Client = DbgClient ? DbgClient : g_pExtClient;

    if (Client != NULL)
    {
        Client->AddRef();
    }
    else
    {
        if (GetDebugClient(&Client) != S_OK)
        {
            DbgPrint("Error: Client creation failed.\n");
            return;
        }
    }

    if (ExtQuery(Client) != S_OK)
    {
        DbgPrint("Error: Interface queries failed.\n");
        EXT_RELEASE(Client);
    }
}


ExtApiClass::~ExtApiClass()
{
    if (Client)
    {
        ExtRelease();
        EXT_RELEASE(Client);
    }
}




HRESULT
ReadSymbolData(
    IN PDEBUG_CLIENT Client,
    IN PCSTR Symbol,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG SizeRead
    )
{
    HRESULT hr;
    ULONG64 Module;
    ULONG64 Offset;
    ULONG   TypeId;
    ULONG   TypeSize;

    if (Buffer != NULL)
    {
        RtlZeroMemory(Buffer, BufferSize);
    }

    if (SizeRead != NULL)
    {
        *SizeRead = 0;
    }

    if (Client == NULL)
    {
        return E_POINTER;
    }

    OutputControl   OutCtl(Client);
    PDEBUG_SYMBOLS  Symbols;

    if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                     (void **)&Symbols)) != S_OK)
    {
        return hr;
    }

    if ((hr = Symbols->GetOffsetByName(Symbol, &Offset)) == S_OK)
    {
        if ((hr = Symbols->GetSymbolTypeId(Symbol, &TypeId, &Module)) == S_OK &&
            (hr = Symbols->GetTypeSize(Module, TypeId, &TypeSize)) == S_OK)
        {
            BufferSize = min(BufferSize, TypeSize);

            if (SessionId == CURRENT_SESSION)
            {
                hr = Symbols->ReadTypedDataVirtual(Offset, Module, TypeId, Buffer, BufferSize, SizeRead);
            }
            else
            {
                ULONG64 OffsetPhys;

                if ((hr = GetPhysicalAddress(Client,
                                             SessionId,
                                             Offset,
                                             &OffsetPhys)) == S_OK)
                {
                    hr = Symbols->ReadTypedDataPhysical(OffsetPhys, Module, TypeId, Buffer, BufferSize, SizeRead);
                }
            }
        }
        else
        {
            OutCtl.OutErr("Couldn't get type info for %s; result 0x%lx.\n", Symbol, hr);
        }
    }
    else
    {
        OutCtl.OutErr("Couldn't get offset of %s; result 0x%lx.\n", Symbol, hr);
    }

    Symbols->Release();

    return hr;
}


const CHAR szNULL[] = "(null)";
DEBUG_VALUE DbgValNULL = { 0, DEBUG_VALUE_INT64 };

HRESULT
Evaluate(
    IN PDEBUG_CLIENT Client,
    IN PCSTR Expression,
    IN ULONG DesiredType,
    IN ULONG Radix,
    OUT PDEBUG_VALUE Value,
    OUT OPTIONAL PULONG RemainderIndex,
    OUT OPTIONAL PULONG StartIndex,
    OUT OPTIONAL FLONG Flags
    )
{
    HRESULT         hr = S_FALSE;
    PDEBUG_CONTROL  Control;
    PSTR            pStr;
    BOOL            FoundNULL = FALSE;
    ULONG           OrgRadix;
    CHAR            EvalBuffer[128];
    ULONG           EvalLen;

    if (RemainderIndex != NULL) *RemainderIndex = 0;
    if (StartIndex != NULL) *StartIndex = 0;

    if (Expression == NULL ||
        Client == NULL ||
        (hr = Client->QueryInterface(__uuidof(IDebugControl),
                                     (void **)&Control)) != S_OK)
    {
        return hr;
    }

    pStr = (PSTR)Expression;

    while (*pStr != '\n' && (isspace(*pStr) || (*pStr != '-' && ispunct(*pStr))))
    {
        if (_strnicmp(pStr, szNULL, sizeof(szNULL)-1) == 0)
        {
            FoundNULL = TRUE;
            break;
        }

        pStr++;
    }

    if (FoundNULL)
    {
        hr = Control->CoerceValue(&DbgValNULL,
                                  (DesiredType == DEBUG_VALUE_INVALID) ?
                                  DEBUG_VALUE_INT64 : DesiredType,
                                  Value);
        EvalLen = sizeof(szNULL)-1;
    }
    else
    {
        // Find expression string and only text revalent
        // to evalutating that expression.
        //
        // Otherwise IDebugControl::Evaluate will spend
        // too much time looking up values that are not
        // really part of the expression.
        //
        // IDebugControl::Evaluate also doesn't handle
        // binary strings well.  We expect binary strings
        // to be followed by a non-binary value enclosed
        // in parenthesis.  Just use that value.

        char *psz;
        int i = 0;

        while (pStr[i] != '\0' &&
               (pStr[i] == '0' || pStr[i] == '1'))
        {
            i++;
        }

        if (i &&
            pStr[i] == ' ' &&
            pStr[i+1] == '(' &&
            isdigit(pStr[i+2]))
        {
            pStr += i + 1;
        }

        psz = pStr;
        i = 0;

        if (Flags & EVALUATE_COMPACT_EXPR)
        {
            while ((i < sizeof(EvalBuffer)-1) &&
                   *psz != '\0' && !isspace(*psz))
            {
                EvalBuffer[i++] = *psz++;
            }
        }
        else
        {
            do
            {
                while ((i < sizeof(EvalBuffer)-1) &&
                       *psz != '\0' && !isspace(*psz))
                {
                    EvalBuffer[i++] = *psz++;
                }
                while ((i < sizeof(EvalBuffer)-1) &&
                    (*psz == ' ' || *psz == '\t'))
                {
                    EvalBuffer[i++] = *psz++;
                }
            } while ((i < sizeof(EvalBuffer)-1) &&
                     (ispunct(*psz) && *psz != '-' && *psz != '_' &&
                      !(psz[0] == '-' && psz[1] == '>')));

            // Remove any trailing whitespace
            while (i > 0 && isspace(EvalBuffer[i-1])) i--;
        }

        EvalBuffer[i] = '\0';

        if (Radix == 0 ||
                 ((hr = Control->GetRadix(&OrgRadix)) == S_OK &&
                  (hr = Control->SetRadix(Radix)) == S_OK)
            )
        {
//            DbgPrint("Calling Eval(%s) --\n", EvalBuffer);
            hr = Control->Evaluate(EvalBuffer, 
                                   DesiredType,
                                   Value,
                                   &EvalLen);
//            DbgPrint("-- Eval returned\n");

            if (Radix != 0)
            {
                Control->SetRadix(OrgRadix);
            }

            if (hr == S_OK &&
                Flags & EVALUATE_COMPACT_EXPR &&
                EvalLen != i)
            {
                hr = S_FALSE;
            }
        }
        else
        {
            DbgPrint("Can't setup new radix, %lu, for Evaluate.\n", Radix);
        }
    }

    Control->Release();

    if (hr == S_OK)
    {
        if (RemainderIndex != NULL)
        {
            *RemainderIndex = (ULONG)(pStr - Expression) + EvalLen;
        }

        if (StartIndex != NULL)
        {
            *StartIndex = (ULONG)(pStr - Expression);
        }
    }

    return hr;
}



HRESULT
ReadPointerPhysical(
    PDEBUG_CLIENT Client,
    ULONG64 Offset,
    PULONG64 Ptr
    )
{
    HRESULT             hr;
    PDEBUG_CONTROL      Control;
    PDEBUG_DATA_SPACES  Data;
    DEBUG_VALUE         PtrVal;
    ULONG               BytesRead;

    if (Ptr != NULL) *Ptr = 0;

    if (Client == NULL) return E_INVALIDARG;

    if ((hr = Client->QueryInterface(__uuidof(IDebugControl),
                                     (void **)&Control)) != S_OK)
    {
        return hr;
    }

    if ((hr = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                     (void **)&Data)) != S_OK)
    {
        Client->Release();
        return hr;
    }

    if (Control->IsPointer64Bit() == S_OK)
    {
        Control->Output(DEBUG_OUTPUT_VERBOSE, "Read64PointerPhysical(0x%p)\n", Offset);

        hr = Data->ReadPhysical(Offset,
                                &PtrVal.I64,
                                sizeof(PtrVal.I64),
                                &BytesRead);
        if (hr == S_OK &&
            BytesRead != sizeof(PtrVal.I64))
        {
            Control->Output(DEBUG_OUTPUT_VERBOSE,
                            "ReadPhysicalPointer only read %lu bytes not %lu.\n",
                            BytesRead, sizeof(PtrVal.I64));
            hr = S_FALSE;
        }

        if (hr == S_OK) Control->Output(DEBUG_OUTPUT_VERBOSE, " read 0x%p\n", PtrVal.I64);
    }
    else
    {
        Control->Output(DEBUG_OUTPUT_VERBOSE, "Read32PointerPhysical(0x%p)\n", Offset);

        hr = Data->ReadPhysical(Offset,
                                &PtrVal.I32,
                                sizeof(PtrVal.I32),
                                &BytesRead);
        if (hr == S_OK)
        {
            if (BytesRead != sizeof(PtrVal.I32))
            {
                Control->Output(DEBUG_OUTPUT_VERBOSE,
                                "ReadPhysicalPointer only read %lu bytes not %lu.\n",
                                BytesRead, sizeof(PtrVal.I32));
                hr = S_FALSE;
            }
            else
            {
                Control->Output(DEBUG_OUTPUT_VERBOSE, " read 0x%p", PtrVal.I64);

                PtrVal.I64 = DEBUG_EXTEND64(PtrVal.I32);

                Control->Output(DEBUG_OUTPUT_VERBOSE, " -> 0x%I64x\n", PtrVal.I64);
            }
        }
    }

    if (hr == S_OK && Ptr != NULL)
    {
        *Ptr = PtrVal.I64;
    }

    Data->Release();
    Control->Release();

    return hr;
}


HRESULT
GetTypeId(
    IN PDEBUG_CLIENT Client,
    IN PCSTR Type,
    OUT PULONG TypeId,
    OUT OPTIONAL PULONG64 Module
    )
{
    HRESULT         hr;
    PDEBUG_SYMBOLS  Symbols;

    if (Client == NULL || Type == NULL || TypeId == NULL)
    {
        return E_INVALIDARG;
    }

    if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                     (void **)&Symbols)) != S_OK)
    {
        return hr;
    }

    if (strchr(Type, '!') == NULL &&
        Type_Module.Base != 0 &&
        (hr = Symbols->GetTypeId(Type_Module.Base, Type, TypeId)) == S_OK)
    {
        if (Module != NULL)
        {
            *Module = Type_Module.Base;
        }
    }
    else
    {
        hr = Symbols->GetSymbolTypeId(Type, TypeId, Module);
    }

    Symbols->Release();

    return hr;
}


HRESULT
GetBasicTypeSize(
    IN PCSTR Type,
    OUT PULONG Size
    )
{
    HRESULT hr;
    ULONG   Bytes = 0;

    static CHAR PointerBase[] = "Ptr";
    static CHAR Char[] = "Char";
    static CHAR IntBase[] = "Int";

    if (_strnicmp(Type, PointerBase, sizeof(PointerBase)) == 0)
    {
        Bytes = strtoul(Type+sizeof(PointerBase), NULL, 10) / 8;
    }
    else
    {
        // Remove U indicating unsigned
        if (*Type == 'U')
        {
            Type++;
        }

        if (_strnicmp(Type, Char, sizeof(Char)) == 0)
        {
            Bytes = 1;
        }
        else if (_strnicmp(Type, IntBase, sizeof(IntBase)) == 0)
        {
            PCHAR   NextChar;
            Bytes = strtoul(Type+sizeof(IntBase), &NextChar, 10);
            if (NextChar == NULL ||
                toupper(*NextChar) != 'B')
            {
                Bytes = 0;
            }
        }
    }

    if (Bytes != 0)
    {
        hr = S_OK;
        if (Size != NULL)
        {
            *Size = Bytes;
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}


HRESULT
GetFieldSize(
    IN PDEBUG_CLIENT Client,
    IN ULONG64 Module,
    IN ULONG TypeId,
    IN PCSTR FieldPath,
    OUT PULONG pSize,
    OUT OPTIONAL PULONG pLength,
    OUT OPTIONAL PULONG pEntrySize
    )
{
    HRESULT             hr;
    PDEBUG_CONTROL      Control;
    PDEBUG_SYMBOLS      Symbols;

    if (pSize != NULL) *pSize = 0;
    if (pLength != NULL) *pLength = 0;
    if (pEntrySize != NULL) *pEntrySize = 0;

    if (Client == NULL ||
        FieldPath == NULL ||
        !iscsymf(*FieldPath))
    {
        return E_INVALIDARG;
    }

    if ((hr = Client->QueryInterface(__uuidof(IDebugControl),
                                     (void **)&Control)) != S_OK)
    {
        return hr;
    }

    if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                     (void **)&Symbols)) != S_OK)
    {
        Client->Release();
        return hr;
    }

    OutputReader    OutReader;
    OutputState     OutState(Client, FALSE);
    PSTR            TypeLayout;
    PSTR            Field;
    SIZE_T          FieldLen;
    CHAR            FieldCopy[80];
    PCSTR           SubFieldPath;
    ULONG           Size, ArrayLen = 0;

    if ((hr = OutState.Setup(0, &OutReader)) == S_OK &&
        (hr = OutState.OutputTypeVirtual(0,
                                         Module,
                                         TypeId,
                                         DEBUG_OUTTYPE_NO_INDENT |
                                         DEBUG_OUTTYPE_NO_OFFSET |
                                         DEBUG_OUTTYPE_COMPACT_OUTPUT)) == S_OK &&
        (hr = OutReader.GetOutputCopy(&TypeLayout)) == S_OK)
    {
        SubFieldPath = strchr(FieldPath, '.');

        if (SubFieldPath != NULL)
        {
            FieldLen = SubFieldPath - FieldPath - 1;
            SubFieldPath++;

            if (FieldLen + 1 > sizeof(FieldCopy))
            {
                Field = (PSTR)HeapAlloc(GetProcessHeap(), 0, FieldLen + 1);
                if (Field == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                Field = FieldCopy;
            }

            if (hr == S_OK)
            {
                RtlCopyMemory(Field, FieldPath, FieldLen);
                Field[FieldLen] = '\0';
            }
        }
        else
        {
            Field = (PSTR)FieldPath;
        }

        if (hr == S_OK)
        {
            PSTR    pStr = TypeLayout;
            BOOL    FieldFound = FALSE;

            while (!FieldFound && pStr != NULL)
            {
                pStr = strstr(pStr, Field);
                if (pStr != NULL)
                {
                    // Check Field is bounded by non-symbol characters
                    BOOL FieldStart = (pStr-1 < TypeLayout) || (!__iscsym(*(pStr-1)));

                    // Advance search location
                    pStr += strlen(Field);

                    if (FieldStart && !__iscsym(*pStr))
                    {
                        FieldFound = TRUE;
                    }
                }
            }

            if (FieldFound)
            {
                while (isspace(*pStr)) pStr++;

                // Check for an array
                if (*pStr == '[')
                {
                    PCHAR   EvalEnd;

                    ArrayLen = strtoul(pStr+1, &EvalEnd, 10);

                    if (ArrayLen != 0 && *EvalEnd == ']')
                    {
                        pStr = EvalEnd + 1;
                        while (isspace(*pStr)) pStr++;
                    }
                    // else following csym check will fail returning error.
                }

                if (iscsymf(*pStr))
                {
                    PSTR    FieldType = pStr;
                    ULONG   SubTypeId;

                    while (iscsym(*pStr)) pStr++;
                    *pStr = '\0';

                    hr = Symbols->GetTypeId(Module, FieldType, &SubTypeId);

                    if (SubFieldPath != NULL)
                    {
                        if (hr == S_OK)
                        {
                            hr = GetFieldSize(Client,
                                              Module,
                                              SubTypeId,
                                              SubFieldPath,
                                              pSize,
                                              pLength,
                                              pEntrySize);
                        }
                    }
                    else
                    {
                        if (hr == S_OK)
                        {
                            hr = Symbols->GetTypeSize(Module, SubTypeId, &Size);
                        }
                        else
                        {
                            if (GetBasicTypeSize(FieldType, &Size) == S_OK)
                            {
                                hr = S_OK;
                            }
                        }

                        if (hr == S_OK)
                        {
                            if (pEntrySize != NULL) *pEntrySize = Size;
                            if (pLength != NULL) *pLength = ArrayLen;
                            if (pSize != NULL)
                            {
                                if (ArrayLen != 0) Size *= ArrayLen;
                                *pSize = Size;
                            }
                        }
                    }
                }
                else
                {
                    hr = S_FALSE;
                }
            }
        }

        if (Field != NULL && Field != FieldCopy && Field != FieldPath)
        {
            HeapFree(GetProcessHeap(), 0, Field);
        }

        OutReader.FreeOutputCopy(TypeLayout);
    }

    Symbols->Release();
    Control->Release();

    return hr;
}


ULONG
DbgIntValTypeFromSize(
    ULONG Size
    )
{
    ULONG   Type;

    switch (Size)
    {
        case 1: Type = DEBUG_VALUE_INT8; break;
        case 2: Type = DEBUG_VALUE_INT16; break;
        case 4: Type = DEBUG_VALUE_INT32; break;
        case 8: Type = DEBUG_VALUE_INT64; break;
        default: Type = DEBUG_VALUE_INVALID; break;
    }
    return Type;
}

BOOL
GetArrayDimensions(
    IN PDEBUG_CLIENT Client,
    IN PCSTR Type,
    OPTIONAL IN PCSTR Field,
    OPTIONAL OUT PULONG ArraySize,
    OPTIONAL OUT PULONG ArrayLength,
    OPTIONAL OUT PULONG EntrySize
    )
{
    HRESULT hr;
    ULONG64 Module;
    ULONG   TypeId;

    BOOL    GotDimensions = FALSE;
    ULONG   Size, ESize;

    if (ArraySize) *ArraySize = 0;
    if (ArrayLength) *ArrayLength = 0;
    if (EntrySize) *EntrySize = 0;

    if (Type == NULL)
    {
        return FALSE;
    }

    if (Field != NULL)
    {
        hr = GetTypeId(Client, Type, &TypeId, &Module);

        if (hr == S_OK)
        {
            hr = GetFieldSize(Client, Module, TypeId, Field,
                              ArraySize, ArrayLength, EntrySize);

            if (hr == S_OK) GotDimensions = TRUE;
        }
    }

    if (!GotDimensions && ExtQuery(Client) == S_OK)
    {
        ULONG   GrpIndex;
        CHAR    SymbolName[MAX_PATH];
        DEBUG_SYMBOL_PARAMETERS Array;

        _snprintf(SymbolName, sizeof(SymbolName),
                  (Field) ? "%s.%s" : Type,
                  Type, Field);

        if (g_pExtSymbolGroup->AddSymbol(SymbolName, &GrpIndex) == S_OK)
        {
            if (g_pExtSymbolGroup->GetSymbolParameters(GrpIndex, 1, &Array) == S_OK)
            {
                if (Array.SubElements)
                {
                    if (g_pExtSymbols->GetTypeSize(Array.Module, Array.TypeId, &Size) == S_OK)
                    {
                        ExtVerb(" Array %s - Size: %u bytes  Length: %u\n", SymbolName, Size, Array.SubElements);
                        if (ArraySize) *ArraySize = Size;
                        if (ArrayLength) *ArrayLength = Array.SubElements;
                        if (EntrySize) *EntrySize = Size / Array.SubElements;
                        GotDimensions = TRUE;
                    }
                    else
                    {
                        ExtErr("Couldn't get size of %s.\n", Type);
                    }
                }
                else
                {
                    ExtErr("%s has 0 subelements.\n", SymbolName);
                }
            }
            else
            {
                ExtErr("Couldn't get parameter info for %s.\n", SymbolName);
            }

            g_pExtSymbolGroup->RemoveSymbolByIndex(GrpIndex);
        }
        else
        {
            ExtErr("Couldn't lookup symbol %s.\n", SymbolName);
        }

        ExtRelease();
    }

    if (!GotDimensions)
    {
        ULONG   Index = -1;
        PCSTR   ArrayName = Field ? Field : Type;
        char    FirstEntryName[128];
        ULONG   error;

        FIELD_INFO EntrySizeField = { DbgStr(Field), NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL};
        SYM_DUMP_PARAM ArraySym = {
           sizeof (SYM_DUMP_PARAM), DbgStr(Type), 
           DBG_DUMP_NO_PRINT, 0,
           NULL, NULL, NULL,
           (Field ? 1 : 0), &EntrySizeField
        };

        ExtVerb("Using WinDbg extension interface.\n");

        if (Field)
        {
            error = Ioctl(IG_DUMP_SYMBOL_INFO, &ArraySym, ArraySym.size);
            Size = (error) ? 0 : EntrySizeField.size;

            EntrySizeField.fName = DbgStr(FirstEntryName);
        }
        else
        {
            Size = Ioctl(IG_GET_TYPE_SIZE, &ArraySym, ArraySym.size);

            ArraySym.sName = DbgStr(FirstEntryName);
        }

        if (Size == 0)
        {
            dprintf("Array size is zero.\n");

            return FALSE;
        }

        if (ArraySize) *ArraySize = Size;

        _snprintf(FirstEntryName, sizeof(FirstEntryName), "%s[0]", ArrayName);

        if (Field)
        {
            error = Ioctl(IG_DUMP_SYMBOL_INFO, &ArraySym, ArraySym.size);
            ESize = (error) ? 0 : EntrySizeField.size;
        
            vPrintNativeSymDumpParam(&ArraySym);
        }
        else
        {
            ESize = Ioctl(IG_GET_TYPE_SIZE, &ArraySym, ArraySym.size);
        }

        if (ESize)
        {
            DbgPrint("%s dimensions: %u bytes [%u] = %u bytes.\n",
                     ArrayName, ESize, Size/ESize, Size);

            if (ArrayLength) *ArrayLength = Size/ESize;
            if (EntrySize) *EntrySize = ESize;

            GotDimensions = TRUE;
        }
    }

    return GotDimensions;
}



HRESULT
DumpType(
    PDEBUG_CLIENT Client,
    PCSTR Type,
    ULONG64 Offset,
    ULONG Flags,
    OutputControl *OutCtl,
    BOOL Physical
    )
{
    HRESULT         hr;
    PDEBUG_SYMBOLS  Symbols;
    ULONG64         Module;
    ULONG           TypeId;
    OutputControl   DefaultOutput;

    if (Client == NULL) return E_INVALIDARG;

    if (OutCtl == NULL)
    {
        DefaultOutput.SetControl(DEBUG_OUTCTL_AMBIENT, Client);
        OutCtl = &DefaultOutput;
    }

    if ((hr = GetTypeId(Client, Type, &TypeId, &Module)) != S_OK)
    {
        OutCtl->OutErr(" Not a type nor symbol - HRESULT %s.\n", pszHRESULT(hr));
    }
    else
    {
        TypeOutputDumper    TypeReader(Client, OutCtl);

        if (!(Flags & DEBUG_OUTTYPE_NO_OFFSET))
        {
            OutCtl->Output(" %s", Type);
            if (Offset != 0) OutCtl->Output(" @ %s0x%p", ((Physical) ? "#" : ""), Offset);
            OutCtl->Output((Flags & DEBUG_OUTTYPE_COMPACT_OUTPUT) ? " " : ":\n");
        }

        hr = TypeReader.OutputType(Physical, Module, TypeId, Offset, Flags, NULL);
    }

    return hr;
}


HRESULT
ExtDumpType(
    IN PDEBUG_CLIENT Client,
    IN PCSTR ExtName,
    IN PCSTR Type,
    IN PCSTR Args
    )
{
    INIT_API();

    HRESULT         hr = S_OK;
    DEBUG_VALUE     Offset;

    Offset.I64 = 0;

    while (isspace(*Args)) Args++;

    if (*Args == '-' ||
        (hr = Evaluate(Client, Args, DEBUG_VALUE_INT64, 0, &Offset, NULL)) != S_OK)
    {
        if (hr != S_OK)
        {
            ExtErr("Evaluate '%s' returned %s.\n", Args, pszHRESULT(hr));
        }
        ExtOut("Usage: %s [-?] [%s Addr]\n", ExtName, Type);
    }
    else
    {
        hr = DumpType(Client, Type, Offset.I64);

        if (hr != S_OK)
        {
            ExtErr("Type Dump for %s returned %s.\n", Type, pszHRESULT(hr));
        }
    }

    EXIT_API(hr);
}


void
DumpDSP(PDEBUG_CLIENT Client, PDEBUG_SYMBOL_PARAMETERS pDSP)
{
    ExtOut("  Module Base   : %p\n", pDSP->Module);
    ExtOut("  TypeId        : %lx\n", pDSP->TypeId);
    ExtOut("  ParentSymbol  : %lx\n", pDSP->ParentSymbol);
    ExtOut("  SubElements   : %lu\n", pDSP->SubElements);
    ExtOut("  Flags         : %lx\n", pDSP->Flags);
    ExtOut("  Reserved      : %I64u\n", pDSP->Reserved);
}


DECLARE_API(dt)
{
    HRESULT                 Hr = E_INVALIDARG;
    BOOL                    VerboseInfo = FALSE;
    BOOL                    NotGDIType = FALSE;
    BOOL                    AllClients = FALSE;
    BOOL                    SessionAddr = FALSE;
    BOOL                    Physical = FALSE;
    char                    TypeSym[MAX_NAME];
    char                   *pcTypeSym = TypeSym;
    DEBUG_VALUE             Offset;
    ULONG                   Index;
    DEBUG_SYMBOL_PARAMETERS DSP;
    DEBUG_VALUE             RepeatCount = { {1}, DEBUG_VALUE_INVALID};
    ULONG                   Size = 0;

    INIT_API();

    while (isspace(*args)) args++;

    while (*args == '-')
    {
        args++;

        do
        {
            switch (tolower(*args))
            {
                case 'v': VerboseInfo = TRUE; break;
                case 's': SessionAddr = TRUE; break;
                case 'n': NotGDIType = TRUE; break;
                case 'c': AllClients = TRUE; break;
                case 'l':
                {
                    ULONG RemIndex;

                    Hr = Evaluate(Client, args+1, DEBUG_VALUE_INT32, 0, &RepeatCount, &RemIndex);

                    if (Hr == S_OK)
                    {
                        if (RepeatCount.Type == DEBUG_VALUE_INT32 &&
                            RepeatCount.I32 > 0)
                        {
                            if (RepeatCount.I32 < 512)
                            {
                                args += RemIndex;
                                break;
                            }
                            else
                            {
                                ExtErr("Array count %lu is higher than 512 limit.\n\n", RepeatCount.I32);
                            }
                        }
                        else
                        {
                            ExtErr("Invalid array count at \"%s\"\n\n", args+1);
                        }
                        Hr = E_INVALIDARG;
                    }
                    else
                    {
                        ExtErr("Missing array count.\n\n");
                    }
                }
                default:
                {
                    ExtOut("dt dumps GDI types expanding enum and flag values.\n"
                           "\n"
                           "Usage: dt [-?vsn] [-l<Count>] <Type|Symbol> [[#]Offset]\n"
                           "\n"
                           "    -v  Verbose type/symbol information\n"
                           "    -s  Lookup according to !session setting\n"
                           "    -n  Directly through debug engine\n"
                           "    -l  Dump an array of Type/Symbol Count times\n");

                    EXIT_API(*args == '?' ? S_OK : Hr);
                }
            }

            args++;

        } while (!isspace(*args) && *args != '\0');

        while (isspace(*args)) args++;
    }

    // Get Type/Symbol name from argument string
    while (*args != '\0' && !isspace(*args) &&
           (pcTypeSym < (TypeSym + sizeof(TypeSym) - 2)))
    {
        *pcTypeSym++ = *args++;
    }

    // Type/Symbols should be followed by a space or nothing
    if (*args != '\0' && !isspace(*args))
    {
        ExtErr("Invalid arguments\n");
        EXIT_API(E_INVALIDARG);
    }

    *pcTypeSym = '\0';

    while (isspace(*args))
    {
        args++;
    }

    if (*args == '#')
    {
        if (SessionAddr)
        {
            ExtErr("-s may not be combined with physical addresses.\n");
            EXIT_API(E_INVALIDARG);
        }

        Physical = TRUE;
        args++;
    }

    Offset.Type = DEBUG_VALUE_INVALID;
    Hr = Evaluate(Client, args, DEBUG_VALUE_INT64, 0, &Offset, NULL);

    if (Physical && Offset.Type == DEBUG_VALUE_INVALID)
    {
        ExtErr("Invalid offset\n");
        EXIT_API(((Hr != S_OK) ? Hr : E_INVALIDARG));
    }

    if ((Hr = g_pExtSymbolGroup->AddSymbol(TypeSym, &Index)) == S_OK)
    {
        if ((Hr = g_pExtSymbolGroup->GetSymbolParameters(Index, 1, &DSP)) == S_OK)
        {
            if (VerboseInfo) DumpDSP(Client, &DSP);
        }
        else
        {
            ExtErr(" GetSymbolParameters returned error %lX.\n", Hr);
        }
        g_pExtSymbolGroup->RemoveSymbolByIndex(Index);
    }
    else
    {
        ExtVerb(" Not a symbol - Symbol lookup returned error %lX.\n", Hr);

        Hr = GetTypeId(Client, TypeSym, &DSP.TypeId, &DSP.Module);

        if (Hr == S_OK)
        {
            if (VerboseInfo)
            {
                ExtOut("  Module Base   : %p\n", DSP.Module);
                ExtOut("  TypeId        : %lx\n", DSP.TypeId);
            }
        }
        else
        {
            ExtErr(" Not a type/symbol - %s.\n", pszHRESULT(Hr));
        }
    }

    if (Hr == S_OK && VerboseInfo)
    {
        HRESULT HrCur;

        char    ModuleName[40];
        Hr = g_pExtSymbols->GetModuleNames(DEBUG_ANY_ID, DSP.Module,
                                           NULL, 0, NULL,
                                           ModuleName, sizeof(ModuleName), NULL,
                                           NULL, 0, NULL);
        if (Hr == S_OK)
        {
            ExtOut("  Module Name   : %s\n", ModuleName);
        }
        else
        {
            ExtErr(" GetModuleNames returned error %lx.\n", Hr);
        }

        ExtVerb("GetTypeName(%p, %lx)\n", DSP.Module, DSP.TypeId);
        char    TypeName[MAX_NAME];
        HrCur = g_pExtSymbols->GetTypeName(DSP.Module, DSP.TypeId,
                                           TypeName, sizeof(TypeName),
                                           NULL);
        if (HrCur == S_OK)
        {
            ExtOut("  Type Name     : %s\n", TypeName);
        }
        else
        {
            ExtErr(" GetTypeName returned error %lx.\n", HrCur);
            if (Hr == S_OK) Hr = HrCur;
        }
    }

    if (Hr == S_OK && ((RepeatCount.I32 != 1) || VerboseInfo))
    {
        Hr = g_pExtSymbols->GetTypeSize(DSP.Module, DSP.TypeId, &Size);
        if (Hr == S_OK)
        {
            if (VerboseInfo)
            {
                ExtOut("  Type Size     : %lu\n", Size);
            }

            if (RepeatCount.I32 != 1 && Size == 0)
            {
                ExtErr("Error: GetTypeSize returned size of 0.\n");
                Hr = E_FAIL;
            }
        }
        else
        {
            ExtErr(" GetTypeSize returned error %lx.\n", Hr);
        }
    }

    if (Hr == S_OK)
    {
        // Try to evaluate TypeSym for an offset if none was specified.
        if (*args == '\0' &&
            (Offset.Type == DEBUG_VALUE_INVALID ||
             (Offset.I64 == 0 && !Physical)))
        {
            Offset.Type = DEBUG_VALUE_INVALID;
            Evaluate(Client, TypeSym, DEBUG_VALUE_INT64, 0, &Offset, NULL);
        }

        if (Offset.Type == DEBUG_VALUE_INVALID)
        {
            Offset.I64 = 0;
        }
        else if (SessionAddr && SessionId != CURRENT_SESSION)
        {
            ULONG64 PhysAddr;

            Hr = GetPhysicalAddress(Client, SessionId, Offset.I64, &PhysAddr);

            if (Hr == S_OK)
            {
                Physical = TRUE;
                Offset.I64 = PhysAddr;

                if (RepeatCount.I32 != 1)
                {
                    ExtWarn("Array dumping is not supported for session dumps.\n");
                    RepeatCount.I32 = 1;
                }
            }
            else
            {
                ExtErr("Couldn't lookup 0x%p in Session %s.\n", Offset.I64, SessionStr);
            }
        }

        if (Hr == S_OK)
        {
            if (Offset.I64 == 0 && !Physical && RepeatCount.I32 != 1)
            {
                ExtWarn("No valid offset was found so array dump has been overridden.\n");
                RepeatCount.I32 = 1;
            }

            while (RepeatCount.I32 > 0 && Hr == S_OK)
            {
                if ((Offset.I64 == 0 && !Physical) || NotGDIType)
                {
                    ExtVerb("OutputTypedData(DEBUG_OUTCTL_THIS_CLIENT, 0x%p, %p, %lx, 0)\n",
                            Offset.I64, DSP.Module, DSP.TypeId);
                    if (Physical)
                    {
                        Hr = g_pExtSymbols->OutputTypedDataPhysical((AllClients ? DEBUG_OUTCTL_ALL_CLIENTS : DEBUG_OUTCTL_THIS_CLIENT),
                                                                    Offset.I64,
                                                                    DSP.Module,
                                                                    DSP.TypeId,
                                                                    0);
                    }
                    else
                    {
                        Hr = g_pExtSymbols->OutputTypedDataVirtual((AllClients ? DEBUG_OUTCTL_ALL_CLIENTS : DEBUG_OUTCTL_THIS_CLIENT),
                                                                   Offset.I64,
                                                                   DSP.Module,
                                                                   DSP.TypeId,
                                                                   0);
                    }
                }
                else
                {
                    Hr = DumpType(Client, TypeSym, Offset.I64, DEBUG_OUTTYPE_DEFAULT, NULL, Physical);
                }

                if (--RepeatCount.I32 > 0)
                {
                    Offset.I64 += Size;
                }
            }

            if (Hr != S_OK)
            {
                ExtErr("Type dump returned %s.\n", pszHRESULT(Hr));
            }
        }
    }

    EXIT_API(Hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\event.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    event.cxx

Abstract:

    This file contains the routines to track and handle
    debugger events.

Author:

    Jason Hartman (JasonHa) 2000-11-20

Environment:

    User Mode

--*/

#include "precomp.hxx"

BOOL gbSymbolsNotLoaded = TRUE;

ULONG UniqueTargetState = INVALID_UNIQUE_STATE;

#if DBG
ULONG
DbgEventPrint(
    IN PCHAR Format,
    ...
    )
{
    va_list arglist;

    va_start(arglist, Format);
    return vDbgPrintExWithPrefix("Event: ", -1, 0, Format, arglist);
}

#else
#define DbgEventPrint
#endif

typedef struct {
    PDEBUG_CLIENT   Client;
    BOOL            ParamsRead;
} MonitorThreadParams;


DWORD WINAPI EventMonitorThread(MonitorThreadParams *);


class EventMonitorCallbacks : public DebugBaseEventCallbacks
{
private:
    ULONG           RefCount;

public:

    EventMonitorCallbacks()
    {
        RefCount = 1;
    }

    // IUnknown
    STDMETHOD_(ULONG, AddRef)(
        THIS
        )
    {
        RefCount++;

        return RefCount;
    }

    STDMETHOD_(ULONG, Release)(
        THIS
        )
    {
        RefCount--;

        if (RefCount == 0)
        {
            delete this;
            return 0;
        }

        return RefCount;
    }


    // IDebugEventCallbacks.
    
    STDMETHOD(GetInterestMask)(
        THIS_
        OUT PULONG Mask
        )
    {
        DbgEventPrint("GetInterestMask\n");

        if (Mask != NULL)
        {
            *Mask = DEBUG_EVENT_SESSION_STATUS |
                    DEBUG_EVENT_CHANGE_DEBUGGEE_STATE |
                    DEBUG_EVENT_CHANGE_ENGINE_STATE |
                    DEBUG_EVENT_CHANGE_SYMBOL_STATE |
                    DEBUG_EVENT_UNLOAD_MODULE;
        }

        return S_OK;
    }

    STDMETHOD(Breakpoint)(
        THIS_
        IN PDEBUG_BREAKPOINT Bp
        )
    {
        DbgEventPrint("BP\n");
        return DEBUG_STATUS_NO_CHANGE;
    }

    STDMETHOD(Exception)(
        THIS_
        IN PEXCEPTION_RECORD64 Exception,
        IN ULONG FirstChance
        )
    {
        DbgEventPrint("Exception\n");
        return DEBUG_STATUS_NO_CHANGE;
    }

    STDMETHOD(CreateThread)(
        THIS_
        IN ULONG64 Handle,
        IN ULONG64 DataOffset,
        IN ULONG64 StartOffset
        )
    {
        DbgEventPrint("CreateThread\n");
        return DEBUG_STATUS_NO_CHANGE;
    }

    STDMETHOD(ExitThread)(
        THIS_
        IN ULONG ExitCode
        )
    {
        DbgEventPrint("ExitThread\n");
        return DEBUG_STATUS_NO_CHANGE;
    }

    STDMETHOD(CreateProcess)(
        THIS_
        IN ULONG64 ImageFileHandle,
        IN ULONG64 Handle,
        IN ULONG64 BaseOffset,
        IN ULONG ModuleSize,
        IN PCSTR ModuleName,
        IN PCSTR ImageName,
        IN ULONG CheckSum,
        IN ULONG TimeDateStamp,
        IN ULONG64 InitialThreadHandle,
        IN ULONG64 ThreadDataOffset,
        IN ULONG64 StartOffset
        )
    {
        DbgEventPrint("CreateProcess\n");
        return DEBUG_STATUS_NO_CHANGE;
    }

    STDMETHOD(ExitProcess)(
        THIS_
        IN ULONG ExitCode
        )
    {
        DbgEventPrint("ExitProcess\n");
        return DEBUG_STATUS_NO_CHANGE;
    }

    STDMETHOD(LoadModule)(
        THIS_
        IN ULONG64 ImageFileHandle,
        IN ULONG64 BaseOffset,
        IN ULONG ModuleSize,
        IN PCSTR ModuleName,
        IN PCSTR ImageName,
        IN ULONG CheckSum,
        IN ULONG TimeDateStamp
        )
    {
        DbgEventPrint("LoadModule:\n"
                      "  ModuleName: %s\n"
                      "  ImageName: %s\n"
                      "  BaseOffset: %I64x\n",
                      ModuleName, ImageName, BaseOffset);
        return DEBUG_STATUS_NO_CHANGE;
    }

    STDMETHOD(UnloadModule)(
        THIS_
        IN PCSTR ImageBaseName,
        IN ULONG64 BaseOffset
        )
    {
        // Don't use Image base name for now - Debugger bug
        //DbgEventPrint("UnloadModule %s @ %I64x\n", ImageBaseName, BaseOffset);
        DbgEventPrint("UnloadModule ? @ %I64x\n", BaseOffset);
        return DEBUG_STATUS_NO_CHANGE;
    }

    STDMETHOD(SystemError)(
        THIS_
        IN ULONG Error,
        IN ULONG Level
        )
    {
        DbgEventPrint("SystemError(%lu, %lu)\n", Error, Level);
        return DEBUG_STATUS_NO_CHANGE;
    }

    STDMETHOD(SessionStatus)(
        THIS_
        IN ULONG Status
        )
    {
        DbgEventPrint("SessionStatus(%lu)\n", Status);
        if (Status == DEBUG_SESSION_ACTIVE) DbgEventPrint("DEBUG_SESSION_ACTIVE\n");
        if (Status == DEBUG_SESSION_END_SESSION_ACTIVE_TERMINATE) DbgEventPrint("DEBUG_SESSION_END_SESSION_ACTIVE_TERMINATE\n");
        if (Status == DEBUG_SESSION_END_SESSION_ACTIVE_DETACH) DbgEventPrint("DEBUG_SESSION_END_SESSION_ACTIVE_DETACH\n");
        if (Status == DEBUG_SESSION_END_SESSION_PASSIVE) DbgEventPrint("DEBUG_SESSION_END_SESSION_PASSIVE\n");
        if (Status == DEBUG_SESSION_END) DbgEventPrint("DEBUG_SESSION_END\n");
        if (Status == DEBUG_SESSION_REBOOT) DbgEventPrint("DEBUG_SESSION_REBOOT\n");
        if (Status == DEBUG_SESSION_HIBERNATE) DbgEventPrint("DEBUG_SESSION_HIBERNATE\n");
        if (Status == DEBUG_SESSION_FAILURE) DbgEventPrint("DEBUG_SESSION_FAILURE\n");
        return DEBUG_STATUS_NO_CHANGE;
    }

    STDMETHOD(ChangeDebuggeeState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        )
    {
        DbgEventPrint("ChangeDebuggeeState(0x%lx, 0x%I64x)\n", Flags, Argument);
        if (Flags == DEBUG_CDS_ALL)
        {
            DbgEventPrint("DEBUG_CDS_ALL\n");
            UniqueTargetState++;
        }
        else
        {
            if (Flags & DEBUG_CDS_REGISTERS) DbgEventPrint("DEBUG_CDS_REGISTERS\n");
            if (Flags & DEBUG_CDS_DATA)
            {
                DbgEventPrint("DEBUG_CDS_DATA\n");
                UniqueTargetState++;
            }
        }
        if (UniqueTargetState==INVALID_UNIQUE_STATE) UniqueTargetState++;
        return S_OK;
    }

    STDMETHOD(ChangeEngineState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        )
    {
        //DbgEventPrint("ChangeEngineState(0x%lx, 0x%I64x)\n", Flags, Argument);
        if (Flags == DEBUG_CES_ALL)
        {
            DbgEventPrint("DEBUG_CES_ALL\n");
            UniqueTargetState++;
            if (UniqueTargetState==INVALID_UNIQUE_STATE) UniqueTargetState++;
        }
        else
        {
            if (Flags & DEBUG_CES_CURRENT_THREAD) DbgEventPrint("DEBUG_CES_CURRENT_THREAD\n");
            if (Flags & DEBUG_CES_EFFECTIVE_PROCESSOR) DbgEventPrint("DEBUG_CES_EFFECTIVE_PROCESSOR\n");
            if (Flags & DEBUG_CES_BREAKPOINTS) DbgEventPrint("DEBUG_CES_BREAKPOINTS\n");
            if (Flags & DEBUG_CES_CODE_LEVEL) DbgEventPrint("DEBUG_CES_CODE_LEVEL\n");
            if (Flags & DEBUG_CES_EXECUTION_STATUS)
            {
                DbgEventPrint("DEBUG_CES_EXECUTION_STATUS\n");
                switch (Argument & DEBUG_STATUS_MASK)
                {
                    case DEBUG_STATUS_NO_CHANGE: DbgPrint("Exec Status: DEBUG_STATUS_NO_CHANGE\n"); break;
                    case DEBUG_STATUS_GO: DbgPrint("Exec Status: DEBUG_STATUS_GO\n"); break;
                    case DEBUG_STATUS_GO_HANDLED: DbgPrint("Exec Status: DEBUG_STATUS_GO_HANDLED\n"); break;
                    case DEBUG_STATUS_GO_NOT_HANDLED: DbgPrint("Exec Status: DEBUG_STATUS_GO_NOT_HANDLED\n"); break;
                    case DEBUG_STATUS_STEP_OVER: DbgPrint("Exec Status: DEBUG_STATUS_STEP_OVER\n"); break;
                    case DEBUG_STATUS_STEP_INTO: DbgPrint("Exec Status: DEBUG_STATUS_STEP_INTO\n"); break;
                    case DEBUG_STATUS_BREAK: DbgPrint("Exec Status: DEBUG_STATUS_BREAK\n"); break;
                    case DEBUG_STATUS_NO_DEBUGGEE: DbgPrint("Exec Status: DEBUG_STATUS_NO_DEBUGGEE\n"); break;
                    case DEBUG_STATUS_STEP_BRANCH: DbgPrint("Exec Status: DEBUG_STATUS_STEP_BRANCH\n"); break;
                    case DEBUG_STATUS_IGNORE_EVENT: DbgPrint("Exec Status: DEBUG_STATUS_IGNORE_EVENT\n"); break;
                    default: DbgPrint("Exec Status: Unknown\n"); break;
                }
                if (Argument & DEBUG_STATUS_INSIDE_WAIT) DbgPrint("Exec Status: DEBUG_STATUS_INSIDE_WAIT\n");
                if ((Argument & DEBUG_STATUS_MASK) != DEBUG_STATUS_NO_CHANGE)
                {
                    UniqueTargetState++;
                    if (UniqueTargetState==INVALID_UNIQUE_STATE) UniqueTargetState++;
                }
            }
            if (Flags & DEBUG_CES_ENGINE_OPTIONS) DbgEventPrint("DEBUG_CES_ENGINE_OPTIONS\n");
            if (Flags & DEBUG_CES_LOG_FILE) DbgEventPrint("DEBUG_CES_LOG_FILE\n");
            //if (Flags & DEBUG_CES_RADIX) DbgEventPrint("DEBUG_CES_RADIX\n");
            if (Flags & DEBUG_CES_EVENT_FILTERS) DbgEventPrint("DEBUG_CES_EVENT_FILTERS\n");
            if (Flags & DEBUG_CES_PROCESS_OPTIONS) DbgEventPrint("DEBUG_CES_PROCESS_OPTIONS\n");
            if (Flags & DEBUG_CES_EXTENSIONS) DbgEventPrint("DEBUG_CES_EXTENSIONS\n");
        }
        return S_OK;
    }

    STDMETHOD(ChangeSymbolState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        )
    {
        DbgEventPrint("ChangeSymbolState(0x%lx, 0x%I64x)\n", Flags, Argument);
        gbSymbolsNotLoaded = gbSymbolsNotLoaded || (Flags & DEBUG_CSS_UNLOADS);
        UniqueTargetState++;
        if (UniqueTargetState==INVALID_UNIQUE_STATE) UniqueTargetState++;
        return S_OK;
    }
};

typedef enum {
    NO_DISPATCHING,
    NEED_DISPATCH,
    DISPATCHED
} MonitorState;

LONG            g_MonitorState = NO_DISPATCHING;
PDEBUG_CLIENT   g_pMonitorClient = NULL;
BOOL            g_MonitorThreadSet = FALSE;

DWORD
WINAPI
EventMonitorThread(
    MonitorThreadParams *Params
    )
{
    HRESULT                 hr = S_OK;
    PDEBUG_CLIENT           Client;
    MonitorThreadParams     ParamCopy;
    HMODULE                 hModule = NULL;
    TCHAR                   ModulePath[256];

    if (Params != NULL && Params->Client != NULL)
    {
        ASSERTMSG("EventMonitorThread not started with NEED_DISPATCH.\n", g_MonitorState == NEED_DISPATCH);

        if (GetModuleFileName(ghDllInst, ModulePath, sizeof(ModulePath)/sizeof(TCHAR)) == 0)
        {
            DbgPrint("EventMonitorThread failed to get Module path.\n");
            hr = S_FALSE;
        }
        else
        {
            // LoadLibrary so we have a reference while this thread lives
            hModule = LoadLibrary(ModulePath);

            if (hModule != ghDllInst)
            {
                DbgPrint("EventMonitorThread retrieving an hModule different from ghDllInst.\n");
                hr = S_FALSE;
            }
        }

        if (hr == S_OK)
        {
            Params->Client->AddRef();

            ParamCopy = *Params;
            Params->ParamsRead = TRUE;
            Params = &ParamCopy;

            hr = Params->Client->CreateClient(&Client);
            DbgPrint("EventMonitorThread created client %p.\n", Client);

            Params->Client->Release();

            if (hr == S_OK)
            {
                EventMonitorCallbacks  *EventMonitor = new EventMonitorCallbacks;

                if (EventMonitor != NULL)
                {
                    hr = Client->SetEventCallbacks(EventMonitor);

                    if (hr == S_OK)
                    {
                        // Pass monitoring client back to caller.
                        Client->AddRef();
                        if (InterlockedCompareExchangePointer((PVOID*)&g_pMonitorClient, Client, NULL) == NULL &&
                            InterlockedCompareExchange(&g_MonitorState, DISPATCHED, NEED_DISPATCH) == NEED_DISPATCH)
                        {
                            DbgPrint("EventMonitorThread dispatching for client %p.\n", Client);
                            UniqueTargetState++;
                            hr = Client->DispatchCallbacks(INFINITE);
                        }
                        else
                        {
                            // Another EventMonitorThread has already started or
                            // ReleaseEventCallbacks has already been called; so,
                            // release this client and
                            // NULL global monitor client if we set it
                            DbgPrint("EventMonitorThread exiting instead of dispatching for client %p.\n", Client);
                            InterlockedCompareExchangePointer((PVOID*)&g_pMonitorClient, NULL, Client);
                            Client->Release();
                        }
                    }
                    else
                    {
                        OutputControl   OutCtl(Client);
                        OutCtl.OutErr("EventMonitorThread callbacks setup failed, %s.\n", pszHRESULT(hr));
                    }

                    EventMonitor->Release();
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                Client->Release();
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    DbgPrint("EventMonitorThread calling ExitThread().\n");

    FreeLibraryAndExitThread(hModule, (DWORD)hr);
}


void
ReleaseEventCallbacks(
    PDEBUG_CLIENT Client
    )
{
    if (g_MonitorThreadSet)
    {
        if (InterlockedExchange(&g_MonitorState, NO_DISPATCHING) == DISPATCHED)
        {
            PDEBUG_CLIENT   pMonitorClient;
            
            pMonitorClient = (PDEBUG_CLIENT)InterlockedExchangePointer((PVOID *)&g_pMonitorClient, NULL);

            ASSERTMSG("g_MonitorState shows g_pMonitorClient should be set.\n", pMonitorClient != NULL);

            if (Client == NULL)
            {
                if (GetDebugClient(&Client) != S_OK)
                {
                    Client = pMonitorClient;
                    Client->AddRef();
                }
            }
            else
            {
                Client->AddRef();
            }

            Client->ExitDispatch(pMonitorClient);
            pMonitorClient->Release();
            Client->Release();
        }

        g_MonitorThreadSet = FALSE;
    }
}


HRESULT
SetEventCallbacks(
    PDEBUG_CLIENT Client
    )
{
    HRESULT hr = S_FALSE;

    if (!g_MonitorThreadSet)
    {
        MonitorThreadParams  NewThreadParams = { Client, FALSE };
        HANDLE  hThread;
        DWORD   ThreadID;
        LONG    PrevMonitorState;

        PrevMonitorState = InterlockedExchange(&g_MonitorState, NEED_DISPATCH);
        ASSERTMSG("Previous EventMonitor thread was never shutdown properly.\n", PrevMonitorState != DISPATCHED);
        ASSERTMSG("Previous EventMonitor thread never completed setup.\n", PrevMonitorState != NEED_DISPATCH);

        g_pMonitorClient = NULL;

        hThread = CreateThread(NULL,
                               0,
                               (LPTHREAD_START_ROUTINE)EventMonitorThread,
                               &NewThreadParams,
                               0,
                               &ThreadID);

        if (hThread)
        {
            // Default ExitCode to STILL_ACTIVE since it doesn't matter
            // if the Params were read before we started checking.
            DWORD ExitCode = STILL_ACTIVE;

            while (!NewThreadParams.ParamsRead)
            {
                ExitCode = 0;
                if (!GetExitCodeThread(hThread, &ExitCode))
                    DbgPrint("GetExitCodeThread returned error %lx.\n", GetLastError());
                if (ExitCode != STILL_ACTIVE)
                {
                    break;
                }

                SleepEx(10, TRUE);
            }

            if (ExitCode == STILL_ACTIVE)
            {
                hr = S_OK;
                g_MonitorThreadSet = TRUE;
            }

            CloseHandle(hThread);
        }
    }

    return hr;
}


HRESULT
EventCallbacksReady(
    PDEBUG_CLIENT Client
    )
{
    return (g_MonitorThreadSet && g_MonitorState == DISPATCHED) ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\dumpers.cxx ===
/******************************Module*Header*******************************\
* Module Name: dumpers.cxx
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/


#include "precomp.hxx"

// A resonable count limit for scans and walls
#define COUNT_LIMIT 0x07ffffff

/**************************************************************************\
*
*   class ScanDumper
*
\**************************************************************************/

const FIELD_INFO ScanFieldsInit[SCAN_FIELDS_LENGTH] = {
    { DbgStr("cWalls"),     NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL },
    { DbgStr("yTop"),       NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL },
    { DbgStr("yBottom"),    NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL },
    { DbgStr("ai_x[0]"),    NULL, 0, DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL },
};
const SYM_DUMP_PARAM ScanSymInit = {
    sizeof (SYM_DUMP_PARAM), DbgStr(GDIType(SCAN)), DBG_DUMP_NO_PRINT, 0,
    NULL, NULL, NULL, SCAN_FIELDS_LENGTH, NULL
};
const FIELD_INFO WallFieldsInit[1] = {
    { DbgStr("x"),     NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, LeftWallCallback },
};
const SYM_DUMP_PARAM WallSymInit = {
    sizeof (SYM_DUMP_PARAM), DbgStr(GDIType(_INDEX_LONG)), DBG_DUMP_NO_PRINT | DBG_DUMP_ARRAY, 0,
    NULL, NULL, NULL, 1, NULL
};
const SYM_DUMP_PARAM cWalls2SymInit = {
    sizeof (SYM_DUMP_PARAM), DbgStr("ULONG"), DBG_DUMP_NO_PRINT | DBG_DUMP_ADDRESS_AT_END | DBG_DUMP_COPY_TYPE_DATA, 0,
    NULL, NULL, NULL, 0, NULL
};


/**************************************************************************\
*
*   ScanDumper::ScanDumper
*
\**************************************************************************/
ScanDumper::ScanDumper(
    ULONG64 HeadScanAddr,
    ULONG64 TailScanAddr,
    ULONG   ScanCount,
    ULONG64 AllocationBase,
    ULONG64 AllocationLimit,
    ULONG   Flags
    )
{
    block = 0;
    Top = POS_INFINITY;
    Bottom = NEG_INFINITY;
    FirstScanAddr = HeadScanAddr;
    LastScanAddr = TailScanAddr;
    ScanLimit = ScanCount ? ScanCount : COUNT_LIMIT;
    AddressBase = AllocationBase;
    AddressLimit = AllocationLimit;
    PrintBlocks = (Flags & SCAN_DUMPER_NO_PRINT) == 0;
    ForceDump = (Flags & SCAN_DUMPER_FORCE) != 0; 
    Reverse = (Flags & SCAN_DUMPER_FROM_TAIL) != 0; 

    // Enable to print a . after each right wall is 
    // processed when block printing is disabled.
    PrintProgress = FALSE;
    ProgressCount = 0;

    RtlCopyMemory(ScanFields, ScanFieldsInit, sizeof(ScanFields));
    RtlCopyMemory(&ScanSym, &ScanSymInit, sizeof(ScanSym));
    ScanSym.Fields = ScanFields;

    ListWallSize.fOptions = 0;
    ListWallSize.fieldCallBack = WallArrayEntryCallback;

    RtlCopyMemory(WallFields, WallFieldsInit, sizeof(WallFields));
    RtlCopyMemory(&WallSym, &WallSymInit, sizeof(WallSym));
    WallSym.listLink = &ListWallSize;
    WallSym.Fields = WallFields;

    RtlCopyMemory(&cWalls2Sym, &cWalls2SymInit, sizeof(cWalls2Sym));

    Valid = TRUE;

    // Get basic scan structure information
    ScanSize = GetTypeSize(GDIType(SCAN));

    if (1)
    {
        cWallsSize = GetTypeSize("ULONG");
        IXSize = GetTypeSize(GDIType(_INDEX_LONG));
    }
    else
    {
        ULONG error;

        error = Ioctl(IG_DUMP_SYMBOL_INFO, &ScanSym, ScanSym.size);

        if (error)
        {
            dprintf("  SCAN type info Ioctl returned %s\n", pszWinDbgError(error));
        }

        cWallsSize = ScanFields[SCAN_CWALLS].size;
        IXSize = ScanFields[SCAN_AI_X_ADDR].size;
    }

    if (Reverse && cWallsSize != GetTypeSize("ULONG"))
    {
        dprintf(" * Error: sizeof(SCAN::cWalls) != sizeof(ULONG)\n"
                "     => From tail scan dumping won't work.\n");
        Reverse = FALSE;
    }

    if (Reverse)
    {
        scan = ScanCount;
        NegativeScanCount = (ScanCount == 0);
        ScanAddr = TailScanAddr;
    }
    else
    {
        scan = -1;
        NegativeScanCount = FALSE;
        ScanAddr = HeadScanAddr;
    }

    // Will DumpScans work?
    CanDump = (ScanSize != 0) && (cWallsSize != 0) && (IXSize != 0);
}


/**************************************************************************\
*
*   ScanDumper::DumpScans
*
\**************************************************************************/
BOOL
ScanDumper::DumpScans(
    ULONG Count
    )
{
    ULONG64 NextScanAddr;
    ULONG   cWalls1, cWalls2;
    ULONG   error;

    if (!CanDump)
    {
        dprintf(" An error occured in this extension preventing DumpScans from working.\n");
        return FALSE;
    }

    if (! Count && PrintBlocks)
    {
        dprintf("\tNo scans to dump.\n");
    }

    if (Count > 100)
    {
        PrintProgress = TRUE;
        ProgressCount = 0;
    }

    while (Count-- && !CheckControlC())
    {
        cWalls1 = cWalls2 = 0;

        if (Reverse)
        {
            if (!NT_SUCCESS(ValidateAddress(ScanAddr, "End of ScanAddr", SCAN_VALID_AT_END)))
            {
                if (!ForceDump) break;
            }

            cWalls2Sym.addr = ScanAddr;
            cWalls2Sym.Context = &cWalls2;

            error = Ioctl(IG_DUMP_SYMBOL_INFO, &cWalls2Sym, cWalls2Sym.size);
            if (error)
            {
                dprintf("  Ioctl returned %s\n", pszWinDbgError(error));
                break;
            }

            ScanAddr -= cWalls2 * IXSize + ScanSize;
        }

        if (gbVerbose)
        {
            dprintf(" Examining scan %d @ %#p\n", scan+(Reverse?-1:+1), ScanAddr);
        }

        if (!NT_SUCCESS(ValidateAddress(ScanAddr, "ScanAddr", SCAN_VALID_AT_START)))
        {
            if (!ForceDump) break;
        }

        ScanSym.addr = ScanAddr;
        error = Ioctl(IG_DUMP_SYMBOL_INFO, &ScanSym, ScanSym.size);

        if (error)
        {
            dprintf("  Ioctl returned %s\n", pszWinDbgError(error));
            break;
        }

        cWalls1 = (ULONG)ScanFields[SCAN_CWALLS].address;

        // Update Top and Bottom information
        if (!ScanAdvance((LONG)ScanFields[SCAN_YTOP].address, (LONG)ScanFields[SCAN_YBOTTOM].address, Reverse ? cWalls2 : cWalls1))
        {
            if (!ForceDump) break;
        }


        // Read cWalls2 if we don't know it.
        if (!Reverse)
        {
            NextScanAddr = ScanAddr + ScanSize + cWalls1 * IXSize;

            if (!NT_SUCCESS(ValidateAddress(NextScanAddr, "End of Wall array", SCAN_VALID_AT_END | SCAN_VALID_NO_ERROR_PRINT)))
            {
                dprintf(" * End of Wall array @ %#p, length %u, at scan %d lies outside valid scan range\n", NextScanAddr, cWalls1, scan);
                if (!ForceDump) break;
            }

            cWalls2Sym.addr = NextScanAddr;
            cWalls2Sym.Context = &cWalls2;

            error = Ioctl(IG_DUMP_SYMBOL_INFO, &cWalls2Sym, cWalls2Sym.size);
            if (error)
            {
                dprintf("  Ioctl returned %s\n", pszWinDbgError(error));
                break;
            }
        }

        // Check cWalls against cWalls2
        if (cWalls1 != cWalls2)
        {
            dprintf(" * cWalls (%u) != cWalls2 (%u) at scan %d\n", cWalls1, cWalls2, scan);
            Valid = FALSE;
            if (!ForceDump) break;
        }

        // cWalls is set by ScanAdvance
        if (cWalls != 0)
        {
            WallSym.Context = (PVOID)this;
            WallSym.addr = ScanFields[SCAN_AI_X_ADDR].address;
            ListWallSize.size = cWalls;
            WallFields[0].fieldCallBack = LeftWallCallback;

            error = Ioctl(IG_DUMP_SYMBOL_INFO, &WallSym, WallSym.size);

            if (error)
            {
                dprintf("  Ioctl returned %s\n", pszWinDbgError(error));
                break;
            }

            if (!Valid && !ForceDump) break;
        }

        if (!Reverse)
        {
            if (!NT_SUCCESS(ValidateAddress(NextScanAddr, "Next ScanAddr", SCAN_VALID_AT_END)))
            {
                if (!ForceDump) break;
            }

            ScanAddr = NextScanAddr;
        }
    }

    return Valid;
}


/**************************************************************************\
*
*   ScanDumper::NextScan
*
\**************************************************************************/
BOOL
ScanDumper::NextScan(
    LONG NextTop,
    LONG NextBottom,
    ULONG NumWalls
    )
{
    LONG PrevBottom = Bottom;
    BOOL bRet = TRUE;

    scan++;

    if (scan < 0 || (ULONG)scan >= ScanLimit)
    {
        dprintf(" * Scan count %d is not in range 1 to %u\n", scan+1, ScanLimit);
        Valid = FALSE;
        bRet = FALSE;
    }

    wall = 0;
    PrevRight = NEG_INFINITY;

    cWalls = NumWalls;

    Top = NextTop;
    Bottom = NextBottom;

    if ((bRet || ForceDump) && Top < PrevBottom)
    {
        dprintf(" * Scan %d top (%d) < prev bottom (%d)\n",
                scan, Top, PrevBottom);
        Valid = FALSE;
        bRet = FALSE;
    }

    if (gbVerbose)
    {
        dprintf(" * Scan %d covers from %d to %d and has %u walls.\n", scan, Top, Bottom, cWalls);
    }

    if ((bRet || ForceDump) && Bottom < Top)
    {
        dprintf(" * Scan %d bottom (%d) < top (%d)\n",
                scan, Bottom, Top);
        Valid = FALSE;
        bRet = FALSE;
    }

    if ((bRet || ForceDump) && cWalls > COUNT_LIMIT)
    {
        dprintf(" * cWalls (%u) is suspiciously long at scan %d\n", cWalls, scan);
        Valid = FALSE;
        bRet = FALSE;
    }

    if ((bRet || ForceDump) && cWalls == 0 && PrintBlocks)
    {
        dprintf("\tNULL Scans from %d to %d.\n", Top, Bottom);
    }

    return bRet;
}


/**************************************************************************\
*
*   ScanDumper::PrevScan
*
\**************************************************************************/
BOOL
ScanDumper::PrevScan(
    LONG PrevTop,
    LONG PrevBottom,
    ULONG NumWalls
    )
{
    LONG NextTop = Top;
    BOOL bRet = TRUE;

    scan--;

    if (NegativeScanCount)
    {
        if (-scan < 1 || (ULONG)-scan > ScanLimit)
        {
            dprintf(" * Scan count %u is not in range 1 to %u\n", -scan, ScanLimit);
            Valid = FALSE;
            bRet = FALSE;
        }
    }
    else
    {
        if (scan < 0 || (ULONG)scan >= ScanLimit)
        {
            dprintf(" * Scan count %u is not in range 1 to %u\n", scan+1, ScanLimit);
            Valid = FALSE;
            bRet = FALSE;
        }
    }

    wall = 0;
    PrevRight = NEG_INFINITY;

    cWalls = NumWalls;

    Top = PrevTop;
    Bottom = PrevBottom;

    if ((bRet || ForceDump) && Bottom > NextTop)
    {
        dprintf(" * Scan %d bottom (%d) > next top (%d)\n",
                scan, Bottom, NextTop);
        Valid = FALSE;
        bRet = FALSE;
    }

    if (gbVerbose)
    {
        dprintf(" * Scan %d covers from %d to %d and has %u walls.\n", scan, Top, Bottom, cWalls);
    }

    if ((bRet || ForceDump) && Bottom < Top)
    {
        dprintf(" * Scan %d bottom (%d) < top (%d)\n",
                scan, Bottom, Top);
        Valid = FALSE;
        bRet = FALSE;
    }

    if ((bRet || ForceDump) && cWalls > COUNT_LIMIT)
    {
        dprintf(" * cWalls (%u) is suspiciously long at scan %d\n", cWalls, scan);
        Valid = FALSE;
        bRet = FALSE;
    }

    if ((bRet || ForceDump) && cWalls == 0 && PrintBlocks)
    {
        dprintf("\tNULL Scans from %d to %d.\n", Top, Bottom);
    }

    return bRet;
}


/**************************************************************************\
*
*   ScanDumper::NextLeftWall
*
\**************************************************************************/
ULONG
ScanDumper::NextLeftWall(
    LONG NextLeft
    )
{
    ULONG Status = STATUS_SUCCESS;

    if (wall > cWalls)
    {
        dprintf(" * More walls (%u) than expected (%u).\n", wall, cWalls);
        Valid = FALSE;
        return STATUS_UNSUCCESSFUL;
    }

    Left = NextLeft;

    if (Left <= PrevRight)
    {
        dprintf(" * Left wall %d (%d) <= previous right (%d) @ scan %d\n",
                wall, Left, PrevRight, scan);
        Valid = FALSE;
        Status = STATUS_UNSUCCESSFUL;
    }

    wall++;

    return Status;
}


/**************************************************************************\
*
*   ScanDumper::NextRightWall
*
\**************************************************************************/
ULONG ScanDumper::NextRightWall(
    LONG Right
    )
{
    ULONG Status = STATUS_SUCCESS;

    if (wall > cWalls)
    {
        dprintf(" * More walls (%u) than expected (%u).\n", wall, cWalls);
        Valid = FALSE;
        return STATUS_UNSUCCESSFUL;
    }

    if (Right <= Left)
    {
        dprintf(" * Right wall %d (%d) <= left (%d) @ scan %d\n",
                wall, Right, Left, scan);
        Valid = FALSE;
        Status = STATUS_UNSUCCESSFUL;
    }

    if (PrintBlocks)
    {
        dprintf("\tRectangle #%d  (%d,%d) - (%d,%d)\n",
                block, Left, Top, Right, Bottom);
    }
    else if (PrintProgress)
    {
        dprintf(".");
        if ((ProgressCount++ % 60) == 0)
        {
            dprintf("\n");
        }
    }

    wall++;
    block++;
    PrevRight = Right;

    return Status;
}


/**************************************************************************\
*
*   ScanDumper::ValidateAddress
*
\**************************************************************************/
ULONG ScanDumper::ValidateAddress(
    ULONG64     Address,
    const char *pszAddrName,
    ULONG       Flags
    )
{
    if (pszAddrName == NULL)
    {
        pszAddrName = "address";
    }

    if (gbVerbose)
    {
        dprintf(" Validating %s %#p\n", pszAddrName, Address);
    }

    // Check allocation limits
    if (Address < AddressBase)
    {
        if ((Flags & SCAN_VALID_NO_ERROR_PRINT) == 0)
            dprintf(" * %s %#p is before address base %#p\n", pszAddrName, Address, AddressBase);
        Valid = FALSE;
        return STATUS_UNSUCCESSFUL;
    }
    if (Address > AddressLimit)
    {
        if ((Flags & SCAN_VALID_NO_ERROR_PRINT) == 0)
            dprintf(" * %s %#p is beyond address limit %#p\n", pszAddrName, Address, AddressLimit);
        Valid = FALSE;
        return STATUS_UNSUCCESSFUL;
    }

    // Check head and tail limits
    if (Address < FirstScanAddr)
    {
        if ((Flags & SCAN_VALID_NO_ERROR_PRINT) == 0)
            dprintf(" * %s %#p is before head address %#p\n", pszAddrName, Address, FirstScanAddr);
        Valid = FALSE;
        return STATUS_UNSUCCESSFUL;
    }
    if (Address > LastScanAddr)
    {
        if ((Flags & SCAN_VALID_NO_ERROR_PRINT) == 0)
            dprintf(" * %s %#p beyond tail address %#p\n", pszAddrName, Address, LastScanAddr);
        Valid = FALSE;
        return STATUS_UNSUCCESSFUL;
    }

    // Check end edge limits
    if (! (Flags & SCAN_VALID_AT_END))
    {
        if (Address == AddressLimit)
        {
            if ((Flags & SCAN_VALID_NO_ERROR_PRINT) == 0)
                dprintf(" * %s %#p is at address limit %#p\n", pszAddrName, Address, AddressLimit);
            Valid = FALSE;
            return STATUS_UNSUCCESSFUL;
        }
        if (Address == LastScanAddr)
        {
            if ((Flags & SCAN_VALID_NO_ERROR_PRINT) == 0)
                dprintf(" * %s %#p is at tail address %#p\n", pszAddrName, Address, LastScanAddr);
            Valid = FALSE;
            return STATUS_UNSUCCESSFUL;
        }
    }

    // Check start edge limits
    if (! (Flags & SCAN_VALID_AT_START))
    {
        if (Address == AddressBase)
        {
            if ((Flags & SCAN_VALID_NO_ERROR_PRINT) == 0)
                dprintf(" * %s %#p is at address base %#p\n", pszAddrName, Address, AddressBase);
            Valid = FALSE;
            return STATUS_UNSUCCESSFUL;
        }
        if (Address == FirstScanAddr)
        {
            if ((Flags & SCAN_VALID_NO_ERROR_PRINT) == 0)
                dprintf(" * %s %#p is at head address %#p\n", pszAddrName, Address, FirstScanAddr);
            Valid = FALSE;
            return STATUS_UNSUCCESSFUL;
        }
    }

    return STATUS_SUCCESS;
}


/**************************************************************************\
*
*   ScanDumper callback interfaces
*
\**************************************************************************/
ULONG
WallArrayEntryCallback(
    PFIELD_INFO pField,
    ScanDumper *pScanDumper
    )
{
    if (pScanDumper == NULL || pField == NULL)
    {
        return STATUS_UNSUCCESSFUL;
    }

    return pScanDumper->ValidateAddress(pField->address, "Wall @", SCAN_VALID_EXCLUSIVE);
}


ULONG
LeftWallCallback(
    PFIELD_INFO pField,
    ScanDumper *pScanDumper
    )
{
    if (pField == NULL)
    {
        dprintf(" * Error: LeftWallCallback was given NULL pField.\n");
        return STATUS_UNSUCCESSFUL;
    }

    pField->fieldCallBack = RightWallCallback;

    if (pScanDumper == NULL)
    {
        dprintf(" * Error: LeftWallCallback was given NULL pScanDumper.\n");
        return STATUS_UNSUCCESSFUL;
    }

    return pScanDumper->NextLeftWall((LONG)pField->address);
}


ULONG
RightWallCallback(
    PFIELD_INFO pField,
    ScanDumper *pScanDumper
    )
{
    if (pField == NULL)
    {
        dprintf(" * Error: RightWallCallback was given NULL pField.\n");
        return STATUS_UNSUCCESSFUL;
    }

    pField->fieldCallBack = LeftWallCallback;

    if (pScanDumper == NULL)
    {
        dprintf(" * Error: RightWallCallback was given NULL pScanDumper.\n");
        return STATUS_UNSUCCESSFUL;
    }

    return pScanDumper->NextRightWall((LONG)pField->address);
}



template <class T, int Spec>
PrintfTypeFormat<T,Spec>::PrintfTypeFormat() : PrintfFormat()
{
    ComposeFormat();
}

template <class T, int Spec>
void PrintfTypeFormat<T,Spec>::ComposeFormat()
{
    int pos = 0;

    Format[pos++] = '%';

    if (Width != -1)          
    {          
        int stored = _snprintf(&Format[pos], sizeof(Format)-5-pos, "%d", Width);
        if (stored > 0)
        {
            pos += stored;
        }
    }

    if (Spec & (PRINT_FORMAT_CHARACTER | PRINT_FORMAT_STRING))
    {
        if (Spec & PRINT_FORMAT_1BYTE)
        {
            Format[pos++] = 'h';
        }
        else if (Spec & PRINT_FORMAT_2BYTES)
        {
            Format[pos++] = 'l';
        }
        else
        {
            ExtWarn("Warning: Unknown character print size specification.\n");
        }

        if (Spec & PRINT_FORMAT_CHARACTER)
        {
            Format[pos++] = 'c';
        }
        else
        {
            Format[pos++] = 's';
        }
    }
    else if (Spec & PRINT_FORMAT_POINTER)
    {
        Format[pos++] = 'p';
    }
    else
    {
        if (Spec & PRINT_FORMAT_1BYTE)
        {
        }
        else if (Spec & PRINT_FORMAT_2BYTES)
        {
            Format[pos++] = 'h';
        }
        else if (Spec & PRINT_FORMAT_4BYTES)
        {
            Format[pos++] = 'l';
        }
        else if (Spec & PRINT_FORMAT_8BYTES)
        {
            Format[pos++] = 'I';
            Format[pos++] = '6';
            Format[pos++] = '4';
        }
        else
        {
            ExtWarn("Warning: Unknown print format size specification.\n");
        }

        if (Spec & PRINT_FORMAT_HEX)
        {
            Format[pos++] = 'x';
        }
        else if (Spec & PRINT_FORMAT_SIGNED)
        {
            Format[pos++] = 'd';
        }
        else if (Spec & PRINT_FORMAT_UNSIGNED)
        {
            Format[pos++] = 'u';
        }
        else
        {
            ExtErr("Error: Unknown print format specification.\n");
            Format[0] = 0;
            return;
        }
    }

    Format[pos] = 0;

    IsDirty = FALSE;
}


template <class T, int PrintSpec>
BOOL
ArrayDumper<T, PrintSpec>::ReadArray(
    const char * SymbolName
    )
{
    DEBUG_VALUE Addr;
    ULONG   error;

    ULONG   ArraySize;
    ULONG   ArrayLength;
    ULONG   EntrySize;

    DbgPrint("ReadArray called for %s\n", SymbolName);

    Length = 0;

    if (!GetArrayDimensions(Client, SymbolName, NULL, &ArraySize, &ArrayLength, &EntrySize) ||
        !(ArraySize > 0 && ArrayLength > 0 && EntrySize > 0)
        )
    {
        ExtErr("GetArrayDimensions failed or returned a zero value dimension for\n\t%s.\n", SymbolName);
        ExtVerb("ArraySize: %u  ArrayLength: %u  EntrySize: %u.\n",
                ArraySize, ArrayLength, EntrySize);
        return FALSE;
    }

    if (EntrySize != sizeof(T))
    {
        ExtErr("Error: %s has entries of size %u not %u as expected.\n",
                SymbolName, EntrySize, sizeof(T));
        return FALSE;
    }

    if (S_OK == g_pExtControl->Evaluate(SymbolName, DEBUG_VALUE_INT64, &Addr, NULL))
    {
        if (Addr.I64 != 0)
        {
            HANDLE hHeap = GetProcessHeap();

            if (ArrayBuffer == NULL || ArrayLength > HeapSize(hHeap, 0, ArrayBuffer))
            {
                T *NewBuffer;

                NewBuffer = (T *) ((ArrayBuffer == NULL) ?
                                   HeapAlloc(hHeap, 0, ArraySize):
                                   HeapReAlloc(hHeap, 0, ArrayBuffer, ArraySize));

                if (NewBuffer == NULL)
                {
                    ExtErr("Buffer alloc failed.\n");
                    return FALSE;
                }
                ArrayBuffer = NewBuffer;
            }

            
            if (S_OK == g_pExtData->ReadVirtual(Addr.I64, ArrayBuffer, ArraySize, NULL))
            {
                Length = ArrayLength;

                return TRUE;
            }

            ExtErr("ReadMemory at %p for %u bytes failed.\n", Addr.I64, ArrayLength);
        }
        else
        {
            ExtWarn("Symbol %s evaluated to zero.\n", SymbolName);
        }
    }
    else
    {
        ExtErr("Couldn't evalutate: %s\n", SymbolName);
    }

    return FALSE;
}



template class PrintfTypeFormat<FormatTemplate(BYTE)>;
template class PrintfTypeFormat<FormatTemplate(WORD)>;
template class PrintfTypeFormat<FormatTemplate(DWORD)>;
template class PrintfTypeFormat<FormatTemplate(DWORD64)>;

template class PrintfTypeFormat<FormatTemplate(CHAR)>;
template class PrintfTypeFormat<FormatTemplate(WCHAR)>;

template class PrintfTypeFormat<FormatTemplate(SHORT)>;
template class PrintfTypeFormat<FormatTemplate(LONG)>;
template class PrintfTypeFormat<FormatTemplate(LONG64)>;

template class PrintfTypeFormat<FormatTemplate(USHORT)>;
template class PrintfTypeFormat<FormatTemplate(ULONG)>;
template class PrintfTypeFormat<FormatTemplate(ULONG64)>;

template class PrintfTypeFormat<ULONG64, PRINT_FORMAT_POINTER>;

template class PrintfTypeFormat<char [], PRINT_FORMAT_STRING>;
template class PrintfTypeFormat<char [], PRINT_FORMAT_WSTRING>;


template class ArrayDumper<FormatTemplate(ULONG)>;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\extparse.cxx ===
/******************************Module*Header*******************************\
* Module Name: extparse.cxx
*
* Copyright (c) 1998-2000 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

/* Command line parsing routines
 *
 * This routine should return an array of char* 's in the idx parameter
 * with the beginning of each token in the array.
 * It also returns the number of tokens found. 
 */
int parse_Tokenizer(char *cmdstr, char **tok) {
  char *seps=" \t\n";                  //white space separators
  int tok_count = 0;                   //the token count
  char *token = strtok(cmdstr, seps);  //get the first token
  while(token) {
    tok[tok_count++]=token;
    token = strtok(NULL, seps);
  }
  return tok_count;
}

/* This routine finds the token specified in srchtok 
 * and returns the index into tok.
 * A return value of -1 is used if the token is not found.
 *
 * Generally we use the case insensitive version (parse_iFindToken) 
 * but occasionally we need the case sensitive version (parse_FindToken).
 */
int parse_FindToken(char **tok, int ntok, char *srchtok) {
  for(int i=0; i<ntok; i++) {
    if(strcmp(tok[i], srchtok)==0) break;
  }
  if(i>=ntok) return -1;
  return i;
}

int parse_iFindToken(char **tok, int ntok, char *srchtok) {
  for(int i=0; i<ntok; i++) {
    if(_strnicmp(tok[i], srchtok, strlen(srchtok))==0) break;
  }
  if(i>=ntok) return -1;
  return i;
}

/* Verifies that the given token at tok[tok_pos] is a switch
 * and contains the switch value sw.
 *
 * Both case sensitive and insensitive versions.
 */
int parse_iIsSwitch(char **tok, int tok_pos, char sw) {
  if(tok_pos<0) return 0;
  char *s=tok[tok_pos];
  if((s[0]=='-')||(s[0]=='/')) {  //is a switch.
    for(s++; *s; s++) {
      if(toupper(*s)==toupper(sw)) {return 1;}
    }
  }
  return 0;
}

int parse_IsSwitch(char **tok, int tok_pos, char sw) {
  if(tok_pos<0) return 0;
  char *s=tok[tok_pos];
  if((s[0]=='-')||(s[0]=='/')) {  //is a switch.
    for(s++; *s; s++) {
      if(*s==sw) {return 1;}      //search each char
    }
  }
  return 0;
}

/* Finds a switch in a given list of tokens.
 * of the form -xxx(sw)xxx or /xxx(sw)xxx
 * example:
 * searching for 'a' in -jklabw returns true.
 *
 * Again both case sensitive and insensitive versions are needed.
 */
int parse_FindSwitch(char **tok, int ntok, char sw) {
  for(int i=0; i<ntok; i++) {                          //search each token
    if(parse_IsSwitch(tok, i, sw)) {return i;}         //found it? return position.
  }
  return -1;
}

int parse_iFindSwitch(char **tok, int ntok, char sw) {
  for(int i=0; i<ntok; i++) {
    if(parse_IsSwitch(tok, i, sw)) {return i;}         //found it? return position.
  }
  return -1;
}


/* Find the first non-switch token starting from position start
 * Will find token at position start
 */
int parse_FindNonSwitch(char **tok, int ntok, int start) {
  for(int i=start; i<ntok; i++) {
    if((tok[i][0]!='-')&&(tok[i][0]!='/')) break;
  }
  if(i>=ntok) return -1;
  return i;
}

/* case insensitive token comparer.
 * returns 1 if chk==tok[tok_pos] otherwise returns 0
 *
 * Pay careful attention to the length specifier in the _strnicmp
 */
int parse_iIsToken(char **tok, int tok_pos, char *chk) {
  if(tok_pos<0) {return 0;}
  return (_strnicmp(tok[tok_pos], chk, strlen(chk))==0);
}

/* case sensitive token comparer.
 * returns 1 if chk==tok[tok_pos] otherwise returns 0
 */
int parse_IsToken(char **tok, int tok_pos, char *chk) {
  if(tok_pos<0) {return 0;}
  return (strcmp(tok[tok_pos], chk)==0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\fontexts.cxx ===
/******************************Module*Header*******************************\
* Module Name: fontexts.cxx
*
* Created: 29-Aug-1994 08:42:10
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1994-2000 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

// TODO: Break this file up grouping close knit extensions together.

// LOGFONTW
#define GetLOGFONTWField(field)   \
        GetLOGFONTWSubField(#field, field)

#define GetLOGFONTWSubField(field,local)    \
        GetFieldData(offLOGFONTW, GDIType(LOGFONTW), field, sizeof(local), &local)

#define GetLOGFONTWOffset(field)  \
        GetFieldOffset(GDIType(LOGFONTW), #field, &offset)

#define GetLOGFONTWFieldAndOffset(field) {    \
        GetLOGFONTWField(field);              \
        GetLOGFONTWOffset(field);             \
}

// RFONT
#define GetRFONTField(field)   \
        GetRFONTSubField(#field, field)

#define GetRFONTSubField(field,local)    \
        GetFieldData(foSrc, GDIType(RFONT), field, sizeof(local), &local)

#define GetRFONTOffset(field)  \
        GetFieldOffset(GDIType(RFONT), #field, &offset)

#define GetRFONTFieldAndOffset(field) {    \
        GetRFONTField(field);              \
        GetRFONTOffset(field);             \
}

// FONTOBJ
#define GetFONTOBJField(field)   \
        GetFONTOBJSubField(#field, field)

#define GetFONTOBJSubField(field,local)    \
        GetFieldData(foSrc, GDIType(FONTOBJ), field, sizeof(local), &local)

#define GetFONTOBJOffset(field)  \
        GetFieldOffset(GDIType(FONTOBJ), #field, &offset)

#define GetFONTOBJFieldAndOffset(field) {    \
        GetFONTOBJField(field);              \
        GetFONTOBJOffset(field);             \
}

// PFE
#define GetPFEField(field)   \
        GetPFESubField(#field, field)

#define GetPFESubField(field,local)    \
        GetFieldData(pfeSrc, GDIType(PFE), field, sizeof(local), &local)

#define GetPFEOffset(field)  \
        GetFieldOffset(GDIType(PFE), #field, &offset)

#define GetPFEFieldAndOffset(field) {    \
        GetPFEField(field);              \
        GetPFEOffset(field);             \
}

// IFIMETRICS
#define GetIFIMETRICSField(field)   \
        GetIFIMETRICSSubField(#field, field)

#define GetIFIMETRICSSubField(field,local)    \
        GetFieldData(pifiSrc, GDIType(IFIMETRICS), field, sizeof(local), &local)

#define GetIFIMETRICSOffset(field)  \
        GetFieldOffset(GDIType(IFIMETRICS), #field, &offset)

#define GetIFIMETRICSFieldAndOffset(field) {    \
        GetIFIMETRICSField(field);              \
        GetIFIMETRICSOffset(field);             \
}

// PFF
#define GetPFFField(field)   \
        GetPFFSubField(#field, field)

#define GetPFFSubField(field,local)    \
        GetFieldData(pffSrc, GDIType(PFF), field, sizeof(local), &local)

#define GetPFFOffset(field)  \
        GetFieldOffset(GDIType(PFF), #field, &offset)

#define GetPFFFieldAndOffset(field) {    \
        GetPFFField(field);              \
        GetPFFOffset(field);             \
}

// ESTROBJ
#define GetESTROBJField(field)   \
        GetESTROBJSubField(#field, field)

#define GetESTROBJSubField(field,local)    \
        GetFieldData(estrobjSrc, GDIType(ESTROBJ), field, sizeof(local), &local)

#define GetESTROBJOffset(field)  \
        GetFieldOffset(GDIType(ESTROBJ), #field, &offset)

#define GetESTROBJFieldAndOffset(field) {    \
        GetESTROBJField(field);              \
        GetESTROBJOffset(field);             \
}

// GLYPHPOS
#define GetGLYPHPOSField(field)   \
        GetGLYPHPOSSubField(#field, field)

#define GetGLYPHPOSSubField(field,local)    \
        GetFieldData(glyphposSrc, GDIType(GLYPHPOS), field, sizeof(local), &local)

#define GetGLYPHPOSOffset(field)  \
        GetFieldOffset(GDIType(GLYPHPOS), #field, &offset)

#define GetGLYPHPOSFieldAndOffset(field) {    \
        GetGLYPHPOSField(field);              \
        GetGLYPHPOSOffset(field);             \
}


// GLYPHBITS
#define GetGLYPHBITSField(field)   \
        GetGLYPHBITSSubField(#field, field)

#define GetGLYPHBITSSubField(field,local)    \
        GetFieldData(glyphbitsSrc, GDIType(GLYPHBITS), field, sizeof(local), &local)

#define GetGLYPHBITSOffset(field)  \
        GetFieldOffset(GDIType(GLYPHBITS), #field, &offset)

#define GetGLYPHBITSFieldAndOffset(field) {    \
        GetGLYPHBITSField(field);              \
        GetGLYPHBITSOffset(field);             \
}

// GLYPHDEF
#define GetGLYPHDEFField(field)   \
        GetGLYPHDEFSubField(#field, field)

#define GetGLYPHDEFSubField(field,local)    \
        GetFieldData(glyphdefSrc, GDIType(GLYPHDEF), field, sizeof(local), &local)

#define GetGLYPHDEFOffset(field)  \
        GetFieldOffset(GDIType(GLYPHDEF), #field, &offset)

#define GetGLYPHDEFFieldAndOffset(field) {    \
        GetGLYPHDEFField(field);              \
        GetGLYPHDEFOffset(field);             \
}

// CACHE
#define GetCACHEField(field)   \
        GetCACHESubField(#field, field)

#define GetCACHESubField(field,local)    \
        GetFieldData(cacheSrc, GDIType(CACHE), field, sizeof(local), &local)

#define GetCACHEOffset(field)  \
        GetFieldOffset(GDIType(CACHE), #field, &offset)

#define GetCACHEFieldAndOffset(field) {    \
        GetCACHEField(field);              \
        GetCACHEOffset(field);             \
}

DWORD adw[4*1024];                // scratch buffer

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64

#include <winfont.h>
#define WOW_EMBEDING 2


VOID Gdidpft(PFT *);

void vDumpFONTHASH(FONTHASH*,FONTHASH*);
void vDumpCOLORADJUSTMENT(COLORADJUSTMENT*, COLORADJUSTMENT*);
void vDumpLINEATTRS(LINEATTRS*, LINEATTRS*);
void vDumpIFIMETRICS(IFIMETRICS*, IFIMETRICS*);
void vDumpPFF(PFF*, PFF*);
void vDumpGlyphMemory(RFONT*);
unsigned cjGLYPHBITS(GLYPHBITS*, RFONT*);
void vDumpRFONTList(RFONT*,unsigned*,unsigned*,unsigned*,unsigned*);

#endif  // DOES NOT SUPPORT API64

void vDumpLOGFONTW(ULONG64);
void vDumpCACHE(ULONG64);

#define tmalloc(a,b) (a *) LocalAlloc(LMEM_FIXED, (b))
#define tfree(b) LocalFree((b))


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   wcsncpy
*
* Routine Description:
*
*   Copies a zero terminated Unicode from the source on the remote
*   address space to a destination in the local address space.
*
* Arguments:
*
*   pwszDst - local address
*
*   pwszSrc - remote address
*
*   c - maximum count of characters in destination
*
* Called by:
*
* Return Value:
*
\**************************************************************************/

LPWSTR wcsncpy(
    LPWSTR  pwszDst,
    ULONG64 pwszSrc,
    size_t  c)
{
    LPWSTR pwszRet = pwszDst;
    ULONG  cbRead;

    if (c)
    {
        WCHAR wc;
        
        __try {
            ReadMemory( pwszSrc, &wc, sizeof(wc), &cbRead );
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            return(NULL);
        }

        while (wc && c && cbRead) {
            pwszSrc += sizeof(wc);
            *pwszDst++ = wc;
            ReadMemory( pwszSrc, &wc, sizeof(wc), &cbRead );
            --c;
        }

        // Add trailing 0 if we have room.
        if (c)
            *pwszDst = 0;
    }

    return(pwszRet);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpHFONT
*
\**************************************************************************/

void vDumpHFONT(ULONG64 hf)
{
    ULONG64     pobj, plfwSrc;
    ULONG       offset;

    if (GetObjectAddress(NULL,hf,&pobj) != S_OK) return;
    GetFieldOffset("LFONT", "elfw", &offset);
    plfwSrc = pobj + offset;

    vDumpLOGFONTW(plfwSrc);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   tstats
*
* Routine Description:
*
*   Returns statistics for TextOut
*   It gives you the distibution of character counts for
*   GreExtTextOutW calls.
*
\**************************************************************************/

DECLARE_API( tstats )
{
    dprintf("Extension 'tstats' not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    typedef struct _TSTATENTRY {
        int c;         // number observed
    } TSTATENTRY;
    typedef struct _TSTAT {
        TSTATENTRY NO; // pdx == 0, opaque
        TSTATENTRY DO; // pdx != 0, opaque
        TSTATENTRY NT; // pdx == 0, transparent
        TSTATENTRY DT; // pdx != 0, transparent
    } TSTAT;
    typedef struct _TEXTSTATS {
        int cchMax;
        TSTAT ats[1];
    } TEXTSTATS;
    TEXTSTATS *pTS, TS;
    TSTAT *ats, *pts, *ptsBin;
    int cj, binsize, cLast, cMin, cNO, cDO, cNT, cDT, cBins;

    PARSE_ARGUMENTS(tstats_help);
    if(ntok==0) {
      binsize=1;
    } else {
      tok_pos = parse_FindNonSwitch(tokens, ntok);
      if(tok_pos==-1) { goto tstats_help; }
//check this and see if it makes more sense to use GetValue() or GetExpression()
      sscanf(tokens[tok_pos], "%d", &binsize);
      if( (binsize<0) || (binsize>50) ) { goto tstats_help; }
    }

    pTS = 0;
    GetAddress(pTS,"win32k!gTS");
    if (pTS == 0) {
        dprintf("Could not find address of win32k!gTS\n");
        return;
    }
    move2(&TS,pTS,sizeof(TS));
    if (TS.ats == 0) {
        dprintf("No statistics are available\n");
        return;
    }
    cj = (TS.cchMax + 2) * sizeof(TSTAT);
    if (!(ats = tmalloc(TSTAT,cj))) {
        dprintf("memory allocation failure\n");
        return;
    }
    move2(ats, &(pTS->ats), cj);
    dprintf("\n\n\n");
    dprintf(" +------------+------ OPAQUE -------+----- TRANSPARENT ---+\n");
    dprintf(" |  strlen    | pdx == 0 | pdx != 0 | pdx == 0 | pdx != 0 |\n");
    dprintf(" +------------+----------+----------+----------+----------+\n");

    // I will partition TS.cchMax+2 entries into bins with
    // binsize enties each. The total number of bins needed
    // to get everything is ceil((TS.cchMax+2)/binsize)
    // which is equal to floor((TS.cchMax+1)/binsize) + 1
    // The last one is dealt with separately. Thus the number
    // of entries in the very last bin is equal to
    //
    // cLast = TS.cchMax + 2 - (floor((TS.cchMax+1)/binsize)+1)
    //
    // which is equal to 1 + (TS.cchMax+1) mod binsize

    cLast = 1 + ((TS.cchMax + 1) % binsize);
    for (cMin=0,pts=ptsBin=ats; pts<ats+(TS.cchMax+2-cLast); cMin+=binsize) {
        ptsBin += binsize;
        for (cNO=cDO=cNT=cDT=0 ; pts < ptsBin ; pts++) {
            cNO += pts->NO.c;
            cDO += pts->DO.c;
            cNT += pts->NT.c;
            cDT += pts->DT.c;
        }
        if (binsize == 1)
            dprintf(
                "         %-5d %10d %10d %10d %10d\n" ,
                cMin,   cNO,   cDO,   cNT,   cDT
            );
        else
            dprintf(
                "  %5d--%-5d %10d %10d %10d %10d\n" ,
                cMin, cMin+binsize-1, cNO, cDO, cNT, cDT
            );
    }
    // do the last bin which may or may not be full
    for (cNO=cDO=cNT=cDT=0 ; cLast ; cLast--, pts++) {
       cNO += pts->NO.c;
       cDO += pts->DO.c;
       cNT += pts->NT.c;
       cDT += pts->DT.c;
    }
    dprintf("  %5d--Inf   %10d %10d %10d %10d\n\n\n",cMin,cNO,cDO,cNT,cDT);
    tfree(ats);
    return;

tstats_help:
    dprintf("Usage: tstats [-?] [1..50]\n");
    dprintf("tstats can be used without parameters in which case the binsize defaults to 1\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   gs
*
* Routine Description:
*
*   dumps FD_GLYPHSET structure
*
* Arguments:
*
*   address of structure
*
* Return Value:
*
*   none
*
\**************************************************************************/

DECLARE_API( gs )
{
    dprintf("Extension 'gs' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    FD_GLYPHSET fdg, *pfdg;
    FLONG fl;
    WCRUN *pwc;
    unsigned BytesPerHandle, i;
    unsigned u;
    HANDLE *ph, *phLast;
    FLAGDEF *pfd;

    PARSE_POINTER(gs_help);
    move( fdg, arg );
    if (fdg.cjThis > sizeof(adw))
    {
        dprintf("FD_GLYPHSET table too big to fit into adw\n");
        return;
    }
    move2( adw, arg, fdg.cjThis );
    pfdg = (FD_GLYPHSET*) adw;


    dprintf("\t\t     cjThis  = %u = %-#x\n", pfdg->cjThis, pfdg->cjThis );
    dprintf("\t\t     flAccel = %-#x\n", pfdg->flAccel );
    fl = pfdg->flAccel;
    for (pfd=afdGS; pfd->psz; pfd++)
    {
        if (pfd->fl & fl)
            dprintf("\t\t\t       %s\n", pfd->psz);
        fl &= ~pfd->fl;
    }
    if (fl) dprintf("\t\t\t       %-#x (BAD FLAGS)\n", fl);
    dprintf("\t\t     cGlyphsSupported = %u\n", pfdg->cGlyphsSupported );
    dprintf("\t\t     cRuns   = %u\n", pfdg->cRuns );
    dprintf("\t\t\t\tWCHAR  HGLYPH\n");

    if ( pfdg->flAccel & GS_UNICODE_HANDLES )
        BytesPerHandle = 0;
    else
        BytesPerHandle = 4;

    for ( pwc = pfdg->awcrun; pwc < pfdg->awcrun + pfdg->cRuns; pwc++ )
    {
        dprintf("                                ------------\n");
        ph = (HANDLE*)((BYTE*) pwc->phg + (UINT_PTR) adw - (unsigned) arg);
        phLast = ph + pwc->cGlyphs;
        i = (unsigned) pwc->wcLow;
        for ( ; ph < phLast; i++, ph++ )
        {
            if (CheckControlC())                // CTRL-C hit?
                break;                          // yes stop the loop
            u = BytesPerHandle ? (ULONG)(UINT_PTR) *ph : i;
            dprintf("\t\t\t\t%-#6x %-#x\n",i,u);
        }
    }
    return;
gs_help:
    dprintf ("Usage: gs [-?] pointer to FD_GLYPHSET structure\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   gdata
*
* Routine Description:
*
*   dumps a GLYPHDATA structure
*
* Arguments:
*
* address of structure
*
* Return Value:
*
*   none
*
\**************************************************************************/

DECLARE_API( gdata )
{
    dprintf("Extension 'gdata' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    GLYPHDATA gd, *pgd;
    LONG *al;

    PARSE_POINTER(gdata_help);
    move( gd, arg );
    pgd = (GLYPHDATA*) arg;
    dprintf("\n\n");
    dprintf("[%x]         gdf %-#x\n", &(pgd->gdf), gd.gdf.pgb);
    dprintf("[%x]          hg %-#x\n", &(pgd->hg ), gd.hg);
    dprintf("[%x]         fxD %-#x\n", &(pgd->fxD), gd.fxD);
    dprintf("[%x]         fxA %-#x\n", &(pgd->fxA), gd.fxA);
    dprintf("[%x]        fxAB %-#x\n", &(pgd->fxAB), gd.fxAB);
    dprintf("[%x]    fxInkTop %-#x\n", &(pgd->fxInkTop), gd.fxInkTop);
    dprintf("[%x] fxInkBottom %-#x\n", &(pgd->fxInkBottom), gd.fxInkBottom);
    dprintf("[%x]      rclInk %d %d %d %d\n",
        &(pgd->rclInk),
        gd.rclInk.left,
        gd.rclInk.top,
        gd.rclInk.right,
        gd.rclInk.bottom
    );
    al = (LONG*) &gd.ptqD.x;
    dprintf("[%x]        ptqD % 8x.%08x % 8x.%08x\n",
        &(pgd->ptqD),
        al[1], al[0], al[3], al[2]
    );
    dprintf("\n");
    return;
gdata_help:
    dprintf ("Usage: gdata [-?] pointer to a GLYPHDATA structure\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

DECLARE_API( fv )
{
    dprintf("Extension 'fv' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    FILEVIEW fv, *pfv;
    
    PARSE_POINTER(fv_help);
    move( fv, arg );
    pfv = (FILEVIEW*) arg;
    dprintf("\n");
    dprintf("[%x] LastWriteTime %08x%08x\n", &(pfv->LastWriteTime), fv.LastWriteTime.HighPart, fv.LastWriteTime.LowPart);
    dprintf("[%x]       pvKView %-#x\n"    , &(pfv->pvKView), fv.pvKView);
    dprintf("[%x]      pvViewFD %-#x\n"    , &(pfv->pvViewFD), fv.pvViewFD);
    dprintf("[%x]        cjView %-#x\n"    , &(pfv->cjView), fv.cjView);
    dprintf("[%x]      pSection %-#x\n"    , &(pfv->pSection), fv.pSection);
    dprintf("\n");
    return;
fv_help:
    dprintf ("Usage: fv [-?] pointer to a FILEVIEW structure\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

DECLARE_API( ffv )
{
    dprintf("Extension 'ffv' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    FONTFILEVIEW ffv, *pffv;
    PWSZ pwszDest;

    PARSE_POINTER(ffv_help);
    move( ffv, arg );
    pffv = (FONTFILEVIEW*) arg;
    dprintf("\n");
    dprintf("[%x]    LastWriteTime %08x%08x\n", &pffv->fv.LastWriteTime , ffv.fv.LastWriteTime.HighPart, ffv.fv.LastWriteTime.LowPart);
    dprintf("[%x]          pvKView %-#x\n"    , &pffv->fv.pvKView       , ffv.fv.pvKView    );
    dprintf("[%x]         pvViewFD %-#x\n"    , &pffv->fv.pvViewFD      , ffv.fv.pvViewFD  );
    dprintf("[%x]           cjView %-#x\n"    , &pffv->fv.cjView        , ffv.fv.cjView    );
    dprintf("[%x]         pSection %-#x\n"    , &pffv->fv.pSection      , ffv.fv.pSection  );

    dprintf("[%x]         pwszPath %-#x"      , &pffv->pwszPath         , ffv.pwszPath     );
    if ( ffv.pwszPath )
    {
        pwszDest = wcsncpy((PWSZ) adw,  ffv.pwszPath, sizeof(adw)/sizeof(WCHAR));
        dprintf(" = \"%ws\"\n", pwszDest );
    }
    else
    {
        dprintf("\n");
    }

    dprintf("[%x]     ulRegionSize %-#x\n"    , &pffv->ulRegionSize     , ffv.ulRegionSize );
    dprintf("[%x]       cKRefCount %-#x\n"    , &pffv->cKRefCount       , ffv.cKRefCount   );
    dprintf("[%x]      cRefCountFD %-#x\n"    , &pffv->cRefCountFD      , ffv.cRefCountFD  );
    dprintf("[%x]      SpoolerBase %-#x\n"    , &pffv->SpoolerBase      , ffv.SpoolerBase  );
    dprintf("[%x]       SpoolerPid %-#x\n"    , &pffv->SpoolerPid       , ffv.SpoolerPid   );
    dprintf("\n");
    return;
ffv_help:
    dprintf ("Usage: ffv [-?] pointer to a FONTFILEVIEW structure\n");
    return;
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* History:
*  21-Feb-1995    -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DECLARE_API( elf )
{
    dprintf("Extension 'elf' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    LOGFONTW lf;

    PARSE_POINTER(elf_help);
    move(lf,arg);
    vDumpLOGFONTW( &lf, (LOGFONTW*) arg );
    return;
elf_help:
    dprintf ("Usage: elf [-?] pointer to an LOGFONTW structure\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
* History:
*  21-Feb-1995    -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DECLARE_API( helf )
{
    dprintf("Extension 'helf' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    LOGFONTW lf, *plf;

    PARSE_POINTER(helf_help);
    plf = (LOGFONTW*) ((BYTE*)_pobj((HANDLE) arg) + offsetof(LFONT,elfw));
    move( lf , plf );
    vDumpLOGFONTW( &lf, plf );
    return;
helf_help:
    dprintf ("Usage: helf [-?] font handle\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   dhelf
*
\**************************************************************************/

DECLARE_API( dhelf )
{
    dprintf("Extension 'dhelf' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    dprintf("\n\ngdikdx.dhelf will soon be replaced by gdikdx.helf\n\n");
    helf(hCurrentProcess, hCurrentThread, dwCurrentPc, dwProcessor, args);
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   ifi
*
\**************************************************************************/

DECLARE_API( ifi )
{
    dprintf("Extension 'ifi' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    IFIMETRICS *pifiDst, *pifiSrc;
    ULONG cjIFI=0;

    PARSE_POINTER(ifi_help);
    pifiSrc = (IFIMETRICS *)arg;
    move(cjIFI,&pifiSrc->cjThis);
    if (cjIFI == 0) {
        dprintf("cjIFI == 0 ... no dump\n");
        return;
    }
    pifiDst = tmalloc(IFIMETRICS, cjIFI);
    if (pifiDst == 0) {
        dprintf("LocalAlloc Failed\n");
        return;
    }
    move2(pifiDst, pifiSrc, cjIFI);
    vDumpIFIMETRICS(pifiDst, pifiSrc);
    tfree(pifiDst);
    return;
ifi_help:
    dprintf ("Usage: [-?] pointer to an IFIMETRICS structure\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   difi
*
\**************************************************************************/

DECLARE_API( difi )
{
    dprintf("Extension 'difi' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    dprintf("\n\n");
    dprintf("WARNING gdikdx.difi will soon be replaced by gdikdx.ifi\n");
    dprintf("\n\n");
    ifi(hCurrentProcess, hCurrentThread, dwCurrentPc, dwProcessor, args);
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   bParseDbgFlags
*
* Routine Description:
*
*   Looks at a flag string of the form
*
*       -[abc..]*[ \t]
*
*   and and sets the corresponding flags
*
* Arguments:
*
*   pszFlags            pointer to the flags string
*
*   ppszStop            pointer to place to put a pointer
*                       to the terminating character
*
*   pai                 pointer to an ARGINFO structure
*
*
* Return Value:
*
*   Returns TRUE if all the flags were good. The corresponding flags are
*   set in pai->fl. Returns FALSE if an error occurs. The pointer to
*   the terminating character is set.
*
\**************************************************************************/
/*
int bParseDbgFlags(const char *pszFlags, const char **ppchStop, ARGINFO *pai)
{
    char ch;
    const char *pch;
    OPTDEF *pod;

    pch = pszFlags;                              // go to beginning of string
    pch += (*pch == '-' || *pch == '/');         // first char a '-'?
    for (ch = *pch; !isspace(ch); ch = *pch++) { // character not a space?
        for (pod = pai->aod; pod->ch; pod++) {   // yes, go to start of table
            if (ch == pod->ch) {                 // found character?
                pai->fl |= pod->fl;              // yes, set flag
                break;                           // and stop
            }
        }                                        // go to next table entry
        if (pod->ch == 0)                        // charater found in table?
            return(0);                           // no, return error
    }                                            // go to next char in string
    return((*ppchStop = pch) != pszFlags);       // set stop pos'n and return
}
*/
/******************************Public*Routine******************************\
*
* Routine Name:
*
*   bParseDbgArgs
*
* Routine Description:
*
*   This routine parses the argument string pointer in pai looking
*   for a string of the form:
*
*   [ \t]*(-[abc..]*[ \t]+)* hexnumber
*
*   The value of the hexadecimal number is placed in pai->pv and the
*   flags are set in pai->fl according to the options table set
*   in pai->aod;
*
* Arguments:
*
*   pai                 Pointer to an ARGINFO structure
*
* Return Value:
*
*   Returns TRUE if parsing was good, FALSE otherwise.
*
\**************************************************************************/
/*
int bParseDbgArgs(ARGINFO *pai)
{
    int argc;       // # args in command line
    char ch;
    const char *pch;
    int bInArg;
    int bParseDbgFlags(const char*,const char**,ARGINFO*);

    pai->fl = 0;                                // clear flags
    pai->pv = 0;                                // clear pointer
    for (bInArg=0, pch=pai->psz, argc=0; ch = *pch; pch++) {
        if (isspace(ch))                        // count the number of args
            bInArg = 0;
        else {
            argc += (bInArg == 0);
            bInArg = 1;
        }
    }
    for (pch = pai->psz; 1 < argc; argc--) {    // get the flags from the
        if (!bParseDbgFlags(pch, &pch, pai))    // first (argc-1) arguments
            break;
    }
    // get the number from the last argument in command line
    return (argc == 1 && sscanf(pch, "%x", &(pai->pv)) == 1);
}
*/
/******************************Public*Routine******************************\
*
* History:
*  20-Aug-1995 -by  Kirk Olynyk [kirko]
* Now has option flags.
*  21-Feb-1995 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DECLARE_API( fo )
{
    INIT_API();

    ULONG64     foSrc;
    ULONG       offset;
    ULONG       localULONG;
    
    char *psz, ach[128];
    int i;

    BOOL Maximal=FALSE;
    BOOL Transform=FALSE;
    BOOL Font=FALSE;
    BOOL Header=FALSE;
    BOOL Glyphset=FALSE;
    BOOL Memory=FALSE;
    BOOL Cache=FALSE;

    PARSE_POINTER(fo_help);
	foSrc = arg;

    if(parse_iFindSwitch(tokens, ntok, 'a')!=-1) {Maximal=TRUE;}
    if(parse_iFindSwitch(tokens, ntok, 'x')!=-1) {Transform=TRUE;}
    if(parse_iFindSwitch(tokens, ntok, 'f')!=-1) {Font=TRUE;}
    if(parse_iFindSwitch(tokens, ntok, 'c')!=-1) {Cache=TRUE;}
    if(parse_iFindSwitch(tokens, ntok, 'h')!=-1) {Header=TRUE;}
    if(parse_iFindSwitch(tokens, ntok, 'w')!=-1) {Glyphset=TRUE;}
    if(parse_iFindSwitch(tokens, ntok, 'y')!=-1) {Memory=TRUE;}

    if(!(Maximal||Transform||Font||Cache||Header||Glyphset||Memory)) {Header=TRUE;}

    
#define Dprint(expr, member)  \
      dprintf("[0x%p] " #expr "    " #member "\n", foSrc+offset, ##member)

    #define vDumpFoEFLOAT(member)                                            \
        GetFieldOffset(GDIType(RFONT), #member, &offset);                       \
        sprintEFLOAT(Client, ach, foSrc+offset);                             \
        dprintf("[0x%p]            %s    " #member "\n", foSrc+offset, ach)

    #define vDumpFoULONG(member)                                            \
        GetFieldOffset(GDIType(RFONT), #member, &offset);                       \
        GetRFONTSubField(#member,localULONG); \
        dprintf("[0x%p] %20u      " #member "\n", foSrc+offset, localULONG)

    if(Maximal) {Header=TRUE;}

    if (Header) {
        FLONG fl;
		ULONG      iUniq;
		ULONG      iFace;
		ULONG      cxMax;
		FLONG      flFontType;
		ULONG64    iTTUniq;
		ULONG64    iFile;
		SIZE       sizLogResPpi;
		ULONG      ulStyleSize;
		ULONG64      pvConsumer;
		ULONG64      pvProducer;

		GetFONTOBJFieldAndOffset(iUniq);
        Dprint( %+#20x, iUniq);
		GetFONTOBJFieldAndOffset(iFace);
        Dprint( %+#20x, iFace);
		GetFONTOBJFieldAndOffset(cxMax);
        Dprint( %20d  , cxMax);
		GetFONTOBJFieldAndOffset(flFontType);
        Dprint( %+#20x, flFontType);
        for (FLAGDEF *pfd = afdFO; pfd->psz; pfd++)
            if (pfd->fl & flFontType)
                dprintf(" \t\t%s\n", pfd->psz);
		GetFONTOBJFieldAndOffset(iTTUniq);
        Dprint( %+#20p, iTTUniq);
		GetFONTOBJFieldAndOffset(iFile);
        Dprint( %+#20p, iFile);
		GetFONTOBJFieldAndOffset(sizLogResPpi.cx);
        Dprint( %20u  , sizLogResPpi.cx);
		GetFONTOBJFieldAndOffset(sizLogResPpi.cy);
        Dprint( %20u  , sizLogResPpi.cy);
		GetFONTOBJFieldAndOffset(ulStyleSize);
        Dprint( %20u  , ulStyleSize);
		GetFONTOBJFieldAndOffset(pvConsumer);
        Dprint( %+#20p, pvConsumer);
		GetFONTOBJFieldAndOffset(pvProducer);
        Dprint( %+#20p, pvProducer);
    }

    if (Maximal) {

typedef struct _RFONTLINK { /* rfl */
    ULONG64 prfntPrev;
    ULONG64 prfntNext;
} RFONTLINK, *PRFONTLINK;


typedef struct _CACHE {

// Info for GLYPHDATA portion of cache

    ULONG64 pgdNext;         // ptr to next free place to put GLYPHDATA
    ULONG64 pgdThreshold;    // ptr to first uncommited spot
    ULONG64      pjFirstBlockEnd; // ptr to end of first GLYPHDATA block
    ULONG64 pdblBase;        // ptr to base of current GLYPHDATA block
    ULONG      cMetrics;        // number of GLYPHDATA's in the metrics cache

// Info for GLYPHBITS portion of cache

    ULONG     cjbblInitial;     // size of initial bit block
    ULONG     cjbbl;            // size of any individual block in bytes
    ULONG     cBlocksMax;       // max # of blocks allowed
    ULONG     cBlocks;          // # of blocks allocated so far
    ULONG     cGlyphs;          // for statistical purposes only
    ULONG     cjTotal;          // also for stat purposes only
    ULONG64 pbblBase;         // ptr to the first bit block (head of the list)
    ULONG64 pbblCur;          // ptr to the block containing next
    ULONG64     pgbNext;          // ptr to next free place to put GLYPHBITS
    ULONG64     pgbThreshold;     // end of the current block

// Info for lookaside portion of cache

    ULONG64           pjAuxCacheMem;  // ptr to lookaside buffer, if any
    SIZE_T          cjAuxCacheMem;  // size of current lookaside buffer

// Miscellany

    ULONG cjGlyphMax;          // size of largest glyph

//  Type of metrics being cached

    BOOL   bSmallMetrics;

// binary cache search, used mostly for fe fonts

    INT iMax;
    INT iFirst;
    INT cBits;

} CACHE;

    ULONG           iUnique;        // uniqueness number
    FLONG           flType;         // Cache type -
    ULONG           ulContent;      // Type of contents
    ULONG64            hdevProducer;   // HDEV of the producer of font.
    BOOL            bDeviceFont;    // TRUE if realization of a device specific font
    ULONG64            hdevConsumer;   // HDEV of the consumer of font.
    ULONG64          dhpdev;         // device handle of PDEV of the consumer of font
    ULONG64         ppfe;           // pointer to physical font entry
    ULONG64         pPFF;           // point to physical font file
    FD_XFORM        fdx;            // N->D transform used to realize font
    ULONG           cBitsPerPel;    // number of bits per pel
//    MATRIX          mxWorldToDevice;// RFONT was realized with this DC xform
    INT             iGraphicsMode;  // graphics mode used when
//    EPOINTFL        eptflNtoWScale; // baseline and ascender scaling factors --
    BOOL            bNtoWIdent;     // TRUE if Notional to World is identity
//    EXFORMOBJ       xoForDDI;       // notional to device EXFORMOBJ
//    MATRIX          mxForDDI;       // xoForDDI's matrix
    FLONG           flRealizedType;
    POINTL          ptlUnderline1;
    POINTL          ptlStrikeOut;
    POINTL          ptlULThickness;
    POINTL          ptlSOThickness;
    LONG            lCharInc;
    FIX             fxMaxAscent;
    FIX             fxMaxDescent;
    FIX             fxMaxExtent;
    POINTFIX        ptfxMaxAscent;
    POINTFIX        ptfxMaxDescent;
    ULONG           cxMax; // width in pels of the widest glyph
    LONG            lMaxAscent;
    LONG            lMaxHeight;
    ULONG cyMax;      // did not use to be here
    ULONG cjGlyphMax; // (cxMax + 7)/8 * cyMax, or at least it should be
    FD_XFORM  fdxQuantized;
    LONG      lNonLinearExtLeading;
    LONG      lNonLinearIntLeading;
    LONG      lNonLinearMaxCharWidth;
    LONG      lNonLinearAvgCharWidth;
    ULONG           ulOrientation;
//    EPOINTFL        pteUnitBase;
//    EFLOAT          efWtoDBase;
//    EFLOAT          efDtoWBase;
    LONG            lAscent;
 //   EPOINTFL        pteUnitAscent;
//    EFLOAT          efWtoDAscent;
//    EFLOAT          efDtoWAscent;
    LONG            lEscapement;
//    EPOINTFL        pteUnitEsc;
//    EFLOAT          efWtoDEsc;
//    EFLOAT          efDtoWEsc;
//    EFLOAT          efEscToBase;
//    EFLOAT          efEscToAscent;
    HGLYPH          hgDefault;
    HGLYPH          hgBreak;
    FIX             fxBreak;
    ULONG64     pfdg;          // ptr to wchar-->hglyph map
    ULONG64            wcgp;          // ptr to wchar->pglyphdata map, if any
    FLONG           flInfo;
    INT             cSelected;      // number of times selected
    RFONTLINK       rflPDEV;        // doubly linked list links
    RFONTLINK       rflPFF;         // doubly linked list links
    ULONG64      hsemCache;      // glyph cache semaphore
    CACHE           cache;          // glyph bitmap cache
    POINTL          ptlSim;         //  for bitmap scaling
    BOOL            bNeededPaths;   // was this rfont realized for a path bracket
//    EFLOAT          efDtoWBase_31;
//    EFLOAT          efDtoWAscent_31;
    ULONG64    ptmw;           // cached text metrics
    LONG            lMaxNegA;
    LONG            lMaxNegC;
    LONG            lMinWidthD;
    BOOL            bIsSystemFont;     // is this fixedsys/system/or terminal
    FLONG           flEUDCState;       // EUDC state information.
    ULONG64           prfntSystemTT;    // system TT linked rfont
    ULONG64           prfntSysEUDC;     // pointer to System wide EUDC Rfont.
    ULONG64           prfntDefEUDC;     // pointer to Default EUDC Rfont.
    ULONG64           paprfntFaceName; // facename links
    ULONG64           aprfntQuickBuff;
                                       // quick buffer for face name and remote links
    BOOL            bFilledEudcArray;  // will be TRUE, the buffer is filled.
    ULONG           ulTimeStamp;       // timestamp for current link.
    UINT            uiNumLinks;        // number of linked fonts.
    BOOL            bVertical;         // vertical face flag.
    ULONG64      hsemEUDC;          // EUDC semaphore
       // maximal dump
#define GetAndPrintRFONTFieldAndOffset(expr, member) \
				GetRFONTFieldAndOffset(member); Dprint(expr, member)

        GetAndPrintRFONTFieldAndOffset( %+#20x, iUnique);
        GetAndPrintRFONTFieldAndOffset( %+#20x, flType);
        GetAndPrintRFONTFieldAndOffset( %+#20x, ulContent);
        GetAndPrintRFONTFieldAndOffset( %+#20x, hdevProducer);
        GetAndPrintRFONTFieldAndOffset( %+#20x, bDeviceFont);
        GetAndPrintRFONTFieldAndOffset( %+#20x, hdevConsumer);
        GetAndPrintRFONTFieldAndOffset( %+#20x, dhpdev);
        GetAndPrintRFONTFieldAndOffset( %+#20p, ppfe);
        GetAndPrintRFONTFieldAndOffset( %+#20p, pPFF);

        GetAndPrintRFONTFieldAndOffset( %+#20x, fdx.eXX);
        GetAndPrintRFONTFieldAndOffset( %+#20x, fdx.eXY);
        GetAndPrintRFONTFieldAndOffset( %+#20x, fdx.eYX);
        GetAndPrintRFONTFieldAndOffset( %+#20x, fdx.eYY);

        GetAndPrintRFONTFieldAndOffset( %20u  , cBitsPerPel);

		GetRFONTOffset (mxWorldToDevice);
        dprintf("[0x%p] mxWorldToDevice: \n",foSrc+offset);
		vDumpMATRIX(Client, foSrc+offset);

        GetAndPrintRFONTFieldAndOffset( %20u  , iGraphicsMode);

		vDumpFoEFLOAT(eptflNtoWScale.x);
		vDumpFoEFLOAT(eptflNtoWScale.y);

        GetAndPrintRFONTFieldAndOffset( %20d  , bNtoWIdent);

		GetRFONTOffset (xoForDDI.pmx);
        dprintf("[0x%p] xoForDDI.pmx: \n",foSrc+offset);
		vDumpMATRIX(Client, foSrc+offset);
        vDumpFoULONG(xoForDDI.ulMode);

		GetRFONTOffset (mxForDDI);
        dprintf("[0x%p] mxForDDI: \n",foSrc+offset);
		vDumpMATRIX(Client, foSrc+offset);

        GetAndPrintRFONTFieldAndOffset( %+#20x, flRealizedType);

        GetAndPrintRFONTFieldAndOffset( %20d  , ptlUnderline1.x);
        GetAndPrintRFONTFieldAndOffset( %20d  , ptlUnderline1.y);

        GetAndPrintRFONTFieldAndOffset( %20d  , ptlStrikeOut.x);
        GetAndPrintRFONTFieldAndOffset( %20d  , ptlStrikeOut.y);

        GetAndPrintRFONTFieldAndOffset( %20d  , ptlULThickness.x);
        GetAndPrintRFONTFieldAndOffset( %20d  , ptlULThickness.y);

        GetAndPrintRFONTFieldAndOffset( %20d  , ptlSOThickness.x);
        GetAndPrintRFONTFieldAndOffset( %20d  , ptlSOThickness.y);

        GetAndPrintRFONTFieldAndOffset( %20d  , lCharInc);
        GetAndPrintRFONTFieldAndOffset( %+#20x, fxMaxAscent);
        GetAndPrintRFONTFieldAndOffset( %+#20x, fxMaxDescent);
        GetAndPrintRFONTFieldAndOffset( %+#20x, fxMaxExtent);

        GetAndPrintRFONTFieldAndOffset( %+#20x, ptfxMaxAscent.x);
        GetAndPrintRFONTFieldAndOffset( %+#20x, ptfxMaxAscent.y);

        GetAndPrintRFONTFieldAndOffset( %+#20x, ptfxMaxDescent.x);
        GetAndPrintRFONTFieldAndOffset( %+#20x, ptfxMaxDescent.y);
        GetAndPrintRFONTFieldAndOffset( %20u  , cxMax);
        GetAndPrintRFONTFieldAndOffset( %20d  , lMaxAscent);
        GetAndPrintRFONTFieldAndOffset( %20d  , lMaxHeight);
        GetAndPrintRFONTFieldAndOffset( %20u  , cyMax);
        GetAndPrintRFONTFieldAndOffset( %20u  , cjGlyphMax);

        GetAndPrintRFONTFieldAndOffset( %+#20x, fdxQuantized.eXX);
        GetAndPrintRFONTFieldAndOffset( %+#20x, fdxQuantized.eXY);
        GetAndPrintRFONTFieldAndOffset( %+#20x, fdxQuantized.eYX);
        GetAndPrintRFONTFieldAndOffset( %+#20x, fdxQuantized.eYY);

        GetAndPrintRFONTFieldAndOffset( %20d  , lNonLinearExtLeading);
        GetAndPrintRFONTFieldAndOffset( %20d  , lNonLinearIntLeading);
        GetAndPrintRFONTFieldAndOffset( %20d  , lNonLinearMaxCharWidth);
        GetAndPrintRFONTFieldAndOffset( %20d  , lNonLinearAvgCharWidth);
        GetAndPrintRFONTFieldAndOffset( %20u  , ulOrientation);

		vDumpFoEFLOAT(pteUnitBase.x);
		vDumpFoEFLOAT(pteUnitBase.y);

		vDumpFoEFLOAT(efWtoDBase);
		vDumpFoEFLOAT(efDtoWBase);

        GetAndPrintRFONTFieldAndOffset( %20d  , lAscent);

		vDumpFoEFLOAT(pteUnitAscent.x);
		vDumpFoEFLOAT(pteUnitAscent.y);

        vDumpFoEFLOAT(efWtoDAscent);
        vDumpFoEFLOAT(efDtoWAscent);

        GetAndPrintRFONTFieldAndOffset( %20d  , lEscapement);

        vDumpFoEFLOAT(pteUnitEsc.x);
        vDumpFoEFLOAT(pteUnitEsc.y);

        vDumpFoEFLOAT(efWtoDEsc);
        vDumpFoEFLOAT(efDtoWEsc);
        vDumpFoEFLOAT(efEscToBase);
        vDumpFoEFLOAT(efEscToAscent);

        GetAndPrintRFONTFieldAndOffset( %+#20x, flInfo);
        GetAndPrintRFONTFieldAndOffset( %+#20x, hgBreak);
        GetAndPrintRFONTFieldAndOffset( %+#20x, fxBreak);
        GetAndPrintRFONTFieldAndOffset( %+#20x, pfdg);

        GetAndPrintRFONTFieldAndOffset( %+#20p, wcgp);
        GetAndPrintRFONTFieldAndOffset( %20u  , cSelected);

      //rflPDEV
        GetAndPrintRFONTFieldAndOffset( %+#20x, rflPDEV.prfntPrev);
        GetAndPrintRFONTFieldAndOffset( %+#20x, rflPDEV.prfntNext);

      //rflPFF
        GetAndPrintRFONTFieldAndOffset( %+#20x, rflPFF.prfntPrev);
        GetAndPrintRFONTFieldAndOffset( %+#20x, rflPFF.prfntNext);

      //hsemCache
        GetAndPrintRFONTFieldAndOffset( %+#20x, hsemCache);

        //cache
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.pgdNext);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.pgdThreshold);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.pjFirstBlockEnd);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.pdblBase);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.cMetrics);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.cjbbl);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.cBlocksMax);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.cBlocks);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.cGlyphs);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.cjTotal);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.pbblBase);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.pbblCur);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.pgbNext);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.pgbThreshold);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.pjAuxCacheMem);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.cjAuxCacheMem);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.cjGlyphMax);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.bSmallMetrics);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.iMax);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.iFirst);
        GetAndPrintRFONTFieldAndOffset( %+#20x, cache.cBits);

        GetAndPrintRFONTFieldAndOffset( %20d  , ptlSim.x);
        GetAndPrintRFONTFieldAndOffset( %20d  , ptlSim.y);

        GetAndPrintRFONTFieldAndOffset( %20d  , bNeededPaths);

        vDumpFoEFLOAT(efDtoWBase_31);
        vDumpFoEFLOAT(efDtoWAscent_31);

        GetAndPrintRFONTFieldAndOffset( %+#20x, ptmw);
        GetAndPrintRFONTFieldAndOffset( %20d  , lMaxNegA);
        GetAndPrintRFONTFieldAndOffset( %20d  , lMaxNegC);
        GetAndPrintRFONTFieldAndOffset( %20d  , lMinWidthD);
        GetAndPrintRFONTFieldAndOffset( %20d  , bIsSystemFont);
        GetAndPrintRFONTFieldAndOffset( %+#20x, flEUDCState);
        GetAndPrintRFONTFieldAndOffset( %+#20x, prfntSystemTT);
        GetAndPrintRFONTFieldAndOffset( %+#20x, prfntSysEUDC);
        GetAndPrintRFONTFieldAndOffset( %+#20x, prfntDefEUDC);
        GetAndPrintRFONTFieldAndOffset( %+#20x, paprfntFaceName);\

      //aprfntQuickBuff
#if 0
        GetAndPrintRFONTFieldAndOffset( %+20x, aprfntQuickBuff[0]);
        GetAndPrintRFONTFieldAndOffset( %+20x, aprfntQuickBuff[1]);
        GetAndPrintRFONTFieldAndOffset( %+20x, aprfntQuickBuff[2]);
        GetAndPrintRFONTFieldAndOffset( %+20x, aprfntQuickBuff[3]);
        GetAndPrintRFONTFieldAndOffset( %+20x, aprfntQuickBuff[4]);
        GetAndPrintRFONTFieldAndOffset( %+20x, aprfntQuickBuff[5]);
        GetAndPrintRFONTFieldAndOffset( %+20x, aprfntQuickBuff[6]);
        GetAndPrintRFONTFieldAndOffset( %+20x, aprfntQuickBuff[7]);
#endif

        GetAndPrintRFONTFieldAndOffset( %20d  , bFilledEudcArray);
        GetAndPrintRFONTFieldAndOffset( %20u  , ulTimeStamp);
        GetAndPrintRFONTFieldAndOffset( %20u  , uiNumLinks);
        GetAndPrintRFONTFieldAndOffset( %20d  , bVertical);

    }

    if (Memory)
	{
		dprintf("Extension 'fo -y' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
        vDumpGlyphMemory((RFONT*)arg);
#endif
	}

    if (Font) {
		ULONG64         ppfe;           // pointer to physical font entry
        GetRFONTFieldAndOffset(ppfe);
        dprintf("[Font Information]\n    ppfe = %-#p\n",  ppfe);
        // print the face name of the font
        if (ppfe) {
			ULONG64     pfeSrc= ppfe;
			ULONG64     pifi;
			GetPFEFieldAndOffset(pifi);
            if (pifi) {
                ULONG		dpwszFaceName, cjThis;
				ULONG64     pifiSrc = pifi;
				GetIFIMETRICSFieldAndOffset(cjThis);
				GetIFIMETRICSFieldAndOffset(dpwszFaceName);
                if (cjThis) {
					WCHAR  wszFaceName[MAX_PATH+1];
					
					ReadMemory(pifiSrc+dpwszFaceName, wszFaceName,MAX_PATH, NULL);
                    dprintf("           [%ws]\n", wszFaceName);
                }
            }
        }
		ULONG64         pPFF;           // point to physical font file
        GetRFONTFieldAndOffset(pPFF);
        dprintf("    pPFF  = %-#p\n", pPFF);
        if (pPFF) {
			ULONG64     pffSrc = pPFF;
			SIZE_T          sizeofThis;
			ULONG           cFonts;         // number of fonts (same as chpfe)
			ULONG64       aulData;     // data buffer for HPFE and filename
			ULONG64  sizeOfPVOID;

			sizeOfPVOID = GetTypeSize("PVOID");

			GetPFFFieldAndOffset(sizeofThis);
			GetPFFFieldAndOffset(cFonts);
			GetPFFFieldAndOffset(aulData);

			offset = offset + cFonts * (ULONG)sizeOfPVOID;
            if (sizeofThis) {
					WCHAR  wszPathName[MAX_PATH+1];
					
					ReadMemory(pffSrc+offset, wszPathName,MAX_PATH, NULL);
                    dprintf("           [%ws]\n", wszPathName);
            }
        }
    }
    if (Transform) {
		dprintf("Extension 'fo -x' is not converted.\n");
#if 0   // DOES NOT SUPPORT API64
        LONG l1,l2,l3,l4;

        psz = ach;
        psz += sprintFLOATL( psz, rf.fdx.eXX );
        *psz++ = ' ';
        psz += sprintFLOATL( psz, rf.fdx.eXY );
        dprintf("[transform]\n   fdx             = %s\n", ach);

        psz = ach;
        psz += sprintFLOATL( psz, rf.fdx.eXY );
        *psz++ = ' ';
        psz += sprintFLOATL( psz, rf.fdx.eYY );
        dprintf ("                     %s\n", ach );

        l1 = rf.mxWorldToDevice.efM11.lEfToF();
        l2 = rf.mxWorldToDevice.efM12.lEfToF();
        l3 = rf.mxWorldToDevice.efM21.lEfToF();
        l4 = rf.mxWorldToDevice.efM22.lEfToF();
        dprintf(
        "   mxWorldToDevice =\n"
        );

        sprintEFLOAT( ach, rf.mxWorldToDevice.efM11 );
        dprintf("       efM11 = %s\n", ach );
        sprintEFLOAT( ach, rf.mxWorldToDevice.efM12 );
        dprintf("       efM12 = %s\n", ach );
        sprintEFLOAT( ach, rf.mxWorldToDevice.efM21 );
        dprintf("       efM21 = %s\n", ach );
        sprintEFLOAT( ach, rf.mxWorldToDevice.efM22 );
        dprintf("       efM22 = %s\n", ach );


        dprintf(
        "       fxDx  = %-#x\n"
        "       fxDy  = %-#x\n"
        , rf.mxWorldToDevice.fxDx
        , rf.mxWorldToDevice.fxDy
        );
        l1 = (LONG) rf.mxWorldToDevice.flAccel;
        dprintf("       flAccel = %-#x\n", l1);
        for (FLAGDEF *pfd=afdMX; pfd->psz; pfd++)
            if (l1 & pfd->fl)
                dprintf("\t\t%s\n", pfd->psz);

        psz = ach;
        psz += sprintEFLOAT( psz, rf.eptflNtoWScale.x);
        *psz++ = ' ';
        psz += sprintEFLOAT( psz, rf.eptflNtoWScale.y);
        dprintf("   eptflNtoWScale  = %s\n", ach );

        dprintf(
            "   bNtoWIdent      = %d\n"
            ,   rf.bNtoWIdent
        );
        dprintf(
        "   xoForDDI        =\n"
        "   mxForDDI        =\n"
        );
        dprintf(
        "   ulOrientation   = %u\n"
        , rf.ulOrientation
        );

        psz = ach;
        psz += sprintEFLOAT( ach, rf.pteUnitBase.x );
        *psz++ = ' ';
        psz += sprintEFLOAT( ach, rf.pteUnitBase.y );
        dprintf("   pteUnitBase     = %s\n", ach );

        sprintEFLOAT( ach, rf.efWtoDBase );
        dprintf("   efWtoDBase      = %s\n", ach );

        sprintEFLOAT( ach, rf.efDtoWBase );
        dprintf("   efDtoWBase      = %s\n", ach );

        dprintf("   lAscent         = %d\n", rf.lAscent);

        psz = ach;
        psz += sprintEFLOAT( ach, rf.pteUnitAscent.x );
        *psz++ = ' ';
        psz += sprintEFLOAT( ach, rf.pteUnitAscent.y );
        dprintf("   pteUnitAscent   = %s\n", ach );

        sprintEFLOAT( ach, rf.efWtoDAscent );
        dprintf("   efWtoDAscent    = %s\n", ach );

        sprintEFLOAT( ach, rf.efDtoWAscent );
        dprintf("   efDtoWAscent    = %s\n", ach );

        psz = ach;
        psz += sprintEFLOAT( ach, rf.pteUnitEsc.x );
        *psz++ = ' ';
        psz += sprintEFLOAT( ach, rf.pteUnitEsc.y );
        dprintf("   pteUnitEsc      = %s\n", ach );


        sprintEFLOAT( ach, rf.efWtoDEsc    );
        dprintf("   efWtoDEsc       = %s\n", ach );

        sprintEFLOAT( ach, rf.efDtoWEsc    );
        dprintf("   efDtoWEsc       = %s\n", ach );

        sprintEFLOAT( ach, rf.efEscToBase  );
        dprintf("   efEscToBase     = %s\n", ach );

        sprintEFLOAT( ach, rf.efEscToAscent);
        dprintf("   efEscToAscent   = %s\n", ach );

        dprintf("\n");
#endif
    }

    if (Glyphset) {
		dprintf("Extension 'fo -w' is not converted.\n");
#if 0   // DOES NOT SUPPORT API64
        if (rf.pfdg) {
            FD_GLYPHSET fdg, *pfdg;
            WCRUN *pwc;
            move( fdg, rf.pfdg );
            move2( adw, rf.pfdg, fdg.cjThis );
            pfdg = (FD_GLYPHSET*) adw;
            dprintf(
                "\t\t     cjThis  = %u = %-#x\n"
                , pfdg->cjThis
                , pfdg->cjThis
                );
            dprintf("\t\t     flAccel = %-#x\n", pfdg->flAccel );
            FLONG flAccel = pfdg->flAccel;
            for (FLAGDEF *pfd=afdGS; pfd->psz; pfd++)
                if (flAccel & pfd->fl) {
                    dprintf("\t\t\t\t%s\n", pfd->psz);
                    flAccel &= ~pfd->fl;
                }
            if (flAccel)
                    dprintf("\t\t\t\t????????\n");
            dprintf("\t\t\tcGlyphsSupported\t= %u\n", pfdg->cGlyphsSupported );
            dprintf("\t\t\tcRuns\t\t= %u\n", pfdg->cRuns );
            dprintf("\t\t\t\tWCHAR  HGLYPH\n");
            for ( pwc = pfdg->awcrun; pwc < pfdg->awcrun + pfdg->cRuns; pwc++ ) {
                dprintf("\t\t\t\t------------\n");
                HGLYPH *ahg= tmalloc(HGLYPH,sizeof(HGLYPH)*pwc->cGlyphs);
                if ( ahg ) {
                    move2(ahg, pwc->phg, sizeof(HGLYPH) * pwc->cGlyphs );
                    for (unsigned i = 0; i < pwc->cGlyphs; i++) {
                        if (CheckControlC()) {
                            tfree( ahg );
                            return;
                        }
                        dprintf("\t\t\t\t%-#6x %-#x\n",
                            pwc->wcLow + (USHORT) i, ahg[i]);
                    }
                    tfree( ahg );
                }
            }
        }
#endif
    }

    if (Cache) {
        ULONG64      hsemCache;      // glyph cache semaphore
        GetRFONTFieldAndOffset(hsemCache);
        GetRFONTOffset( cache.pgdNext);
        dprintf(
            "[cache]\n"
            "   hsemCache = %-#x\n" // semaphore
            , hsemCache
        );
        vDumpCACHE(foSrc+offset);
    }
    EXIT_API(S_OK);
fo_help:
    dprintf("Usage: fo [-?] [-a] [-c] [-f] [-h] [-w] [-x] [-y] pointer to FONTOBJ"
            "   -a    maximal dump\n"
            "   -c    cache\n"
            "   -x    transform data\n"
            "   -?    this message\n"
            "   -f    font\n"
            "   -h    FONTOBJ header\n"
            "   -w    FD_GLYPHSET\n"
            "   -y    Glyph Memory Usage\n");

#undef Dprintf
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpPFE
*
\**************************************************************************/

void vDumpPFE(ULONG64 offPFE)
{
#define N3(a,b,c) \
        GetPFEFieldAndOffset(c); \
        dprintf( "[%p] %s", pfeSrc + offset, (a)); dprintf( (b), ##c )
#define N2(a,c) \
        GetPFEOffset(c); \
        dprintf( "[%p] %s", pfeSrc + offset, (a)); 

    ULONG     offset;
    ULONG64     pfeSrc= offPFE;
    FLAGDEF *pfd;
    FLONG fl;

    ULONG64            pPFF;               // pointer to physical font file object
    ULONG           iFont;              // index of the font for IFI or device
    FLONG           flPFE;
    ULONG64     pfdg;              // ptr to wc-->hg map
    ULONG           idfdg;              // id returned by driver for FD_GLYPHSET
    ULONG64     pifi;               // pointer to ifimetrics
    ULONG           idifi;              // id returned by driver for IFIMETRICS
    ULONG64  pkp;               // pointer to kerning pairs (lazily loaded on demand)
    ULONG           idkp;               // id returned by driver for FD_KERNINGPAIR
    ULONG           ckp;                // count of kerning pairs in the FD_KERNINGPAIR arrary
    LONG            iOrientation;       // Cache IFI orientation.
    ULONG           cjEfdwPFE;          // size of enumeration data needed for this pfe
    ULONG64           pgiset;    // initialized to NULL;
    ULONG           ulTimeStamp;        // unique time stamp (smaller == older)
    ULONG         pid;
//    QUICKLOOKUP     ql;                 // QUICKLOOKUP if a linked font
    ULONG64        pFlEntry;           // Pointer to linked font list
    ULONG           cAlt;
    ULONG           cPfdgRef;
    BYTE            aiFamilyName[1]; // aiFamilyNameg[cAltCharSets]

    dprintf("\nPFE\n\n");
    N3("pPFF              ", "%-#x\n", pPFF);
    N3("iFont             ", "%u\n", iFont);
    N3("pifi              ", "%-#x\n", pifi);

    N3("flPFE             ", "%-#x\n", flPFE);
    for (fl = flPFE, pfd=afdPFE; pfd->psz; pfd++) {
        if (fl & pfd->fl) {
            dprintf("                   %s\n", pfd->psz);
        }
    }

    N3("pfdg              ", "%-#x\n", pfdg);
    N2("idifi\n", idifi);
    N3("pkp               ", "%-#x\n", pkp);
    N3("idkp              ", "%-#x\n", idkp);
    N3("ckp               ", "%u\n", ckp);
    N3("iOrieintation     ", "%d\n", iOrientation);
    N3("cjEfdwPFE         ", "%-#x\n", cjEfdwPFE);
    N3("pgiset            ", "%-#x\n", pgiset);
    N3("ulTimeStamp       ", "%u\n", ulTimeStamp);
    N2("ufi\n",                      ufi);
    N3("pid               ", "%-#x\n", pid);


    N2("ql\n"                        , ql);
    N3("pFlEntry          ", "%-#x\n", pFlEntry);


    N3("cAlt              ", "%u\n",   cAlt);
    N3("cPfdgRef          ", "%u\n",   cPfdgRef);
    N2("aiFamilyName[]"    , aiFamilyName[0]);
    dprintf("\n\n");
    #undef  N2
    #undef  N3

}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   pfe
*
\**************************************************************************/

DECLARE_API( pfe )
{
    PARSE_POINTER(pfe_help);
    vDumpPFE( arg );
    EXIT_API(S_OK);
pfe_help:
    dprintf ("Usage: pfe [-?] pointer to PFE\n");
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* History:
*  21-Feb-1995 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DECLARE_API( hpfe )
{
    dprintf("Why are you using a handle? Nobody uses a handle to a PFE\n");
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
* vPrintSkeletonPFF
*
* Argument
*
*    pLocalPFF          points to a complete local PFF structure
*                       (including PFE*'s and path name)
*                       all addresses contained are remote
*                       except for pwszPathname_ which has
*                       been converted before this routine
*                       was called
*
* History:
*  Tue 30-Aug-1994 07:25:18 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
VOID vPrintSkeletonPFF( PFF *pLocalPFF )
{
    PFE **ppPFEl, **ppPFEl_;

    if (pLocalPFF->hdev)
        dprintf("\t%-#8x (HDEV)\n", pLocalPFF->hdev);
    else
        dprintf("\t\"%ws\"\n", pLocalPFF->pwszPathname_);
    dprintf("\t    PFE*        IFI*\n");

    ppPFEl  = (PFE**)  &(pLocalPFF->aulData[0]);
    ppPFEl_ = ppPFEl + pLocalPFF->cFonts;
    while (ppPFEl < ppPFEl_) {
        PFE *pPFEr = *ppPFEl;

        dprintf("\t    %-#10x", pPFEr);
        if ( pPFEr ) {
            PFE PFEt;
            move2(&PFEt, pPFEr, sizeof(PFEt));
            dprintf("  %-#10x\t", PFEt.pifi);
            {
                ULONG sizeofIFI;
                IFIMETRICS *pHeapIFI;
                move2(
                    &sizeofIFI
                  , PFEt.pifi + offsetof(IFIMETRICS,cjThis)
                  , sizeof(sizeofIFI));
                if (pHeapIFI = tmalloc(IFIMETRICS,sizeofIFI)) {
                    move2(pHeapIFI, PFEt.pifi, sizeofIFI);
                    IFIOBJ ifio(pHeapIFI);
                    dprintf(
                        "\"%ws\" %d %d\n"
                      , ifio.pwszFaceName()
                      , ifio.lfHeight()
                      , ifio.lfWidth()
                      );
                    tfree(pHeapIFI);
                } else
                    dprintf("!!! memory allocation failure !!!\n");
            }
        } else
            dprintf("  INVALID PFE\n");
        ppPFEl++;
    }
    // Now print the RFONT list
    {
        RFONT LocalRFONT, *pRemoteRFONT;

        if (pRemoteRFONT = pLocalPFF->prfntList) {
            dprintf("\t\tRFONT*      PFE*\n");
            do {
                move2(&LocalRFONT, pRemoteRFONT, sizeof(LocalRFONT));
                dprintf("\t\t%-#10x  %-#10x\n", pRemoteRFONT, LocalRFONT.ppfe);
                pRemoteRFONT = LocalRFONT.rflPFF.prfntNext;
            } while (pRemoteRFONT);
        }
    }
}
#endif  // DOES NOT SUPPORT API64
        
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
void vDumpPFT( PFT *pLocal, PFT *pRemote )
{
    COUNT i;

    dprintf("[%8x]  pfhFamily %-#x\n", &pRemote->pfhFamily, pLocal->pfhFamily);
    dprintf("[%8x]    pfhFace %-#x\n", &pRemote->pfhFace  , pLocal->pfhFace  );
    dprintf("[%8x]     pfhUFI %-#x\n", &pRemote->pfhUFI   , pLocal->pfhUFI   );
    dprintf("[%8x]   cBuckets %-#x\n", &pRemote->cBuckets , pLocal->cBuckets );
    dprintf("[%8x]     cFiles %-#x\n", &pRemote->cFiles   , pLocal->cFiles   );

    for (i = 0; i < pLocal->cBuckets; i++)
    {
        PFF *pRemotePFF = pLocal->apPFF[i];

        if (pRemotePFF)
        {
            PFF *pLast;

            dprintf("[%8x]", &pRemote->apPFF[i]);

            pLast = 0;
            while (pRemotePFF && !CheckControlC())
            {
                PFF LocalPFF;

                dprintf(" %8x", pRemotePFF);

                move(LocalPFF, pRemotePFF);
                pLast      = pRemotePFF;
                pRemotePFF = LocalPFF.pPFFNext;
                if (pRemotePFF && pRemotePFF == pLast)
                {
                    dprintf(" <---- BAD PFF ?");
                    pRemotePFF = 0;
                }
            }
            dprintf("\n");
        }
    }

    dprintf("\n"
            "PFF*     Pathname_\n"
            "-------- ---------\n");

    for (i = 0; i < pLocal->cBuckets; i++)
    {
        PFF *pRemotePFF, LocalPFF;
        PWSZ pwszDst;

        if ( pRemotePFF = pLocal->apPFF[i] )
        {
            dprintf("apPFF[%d]\n", i);
            for ( ; pRemotePFF; pRemotePFF=LocalPFF.pPFFNext)
            {
                move(LocalPFF, pRemotePFF);
                pwszDst = wcsncpy((PWSZ) adw, LocalPFF.pwszPathname_, sizeof(adw)/sizeof(WCHAR));
                if ( pwszDst == 0 )
                {
                    pwszDst = L"";
                }
                dprintf("%8x \"%ws\"\n", pRemotePFF, pwszDst);
            }
            dprintf("\n");
        }
    }
}
#endif  // DOES NOT SUPPORT API64

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
void vDumpFONTHASH( FONTHASH *pLocal, FONTHASH *pRemote )
{
    UINT i;
    union {
        UINT id;
        char ach[4];
    } u;

    /*
    UINT         id;        // 'HASH'
    FONTHASHTYPE fht;       // table type
    UINT         cBuckets;  // total number of buckets
    UINT         cUsed;     // number of buckets in use
    UINT         cCollisions;
    HASHBUCKET  *pbktFirst; // first bucket of doubly linked list of hash
                            // buckets maintained in order loaded into system
    HASHBUCKET  *pbktLast;  // last bucket of doubly linked list of hash
                            // buckets maintained in order loaded into system
    HASHBUCKET  *apbkt[1];  // array of bucket pointers.
    */

    u.id = pLocal->id;
    dprintf("[%8x]          id %8x   %c%c%c%c\n", &pRemote->id, u.id, u.ach[0], u.ach[1], u.ach[2], u.ach[3]);
    dprintf("[%8x]         fht %-#10x %s\n", &pRemote->fht, pLocal->fht, pszFONTHASHTYPE(pLocal->fht));
    dprintf("[%8x]    cBuckets %-#x\n", &pRemote->cBuckets, pLocal->cBuckets);
    dprintf("[%8x]       cUsed %-#x\n", &pRemote->cUsed, pLocal->cUsed);
    dprintf("[%8x] cCollisions %-#x\n", &pRemote->cCollisions, pLocal->cCollisions);
    dprintf("[%8x]   pbktFirst %-#x\n", &pRemote->pbktFirst, pLocal->pbktFirst);
    dprintf("[%8x]    pbktLast %-#x\n", &pRemote->pbktLast, pLocal->pbktLast);
    dprintf("\n");

    i = pLocal->cBuckets * sizeof(HASHBUCKET*);
    if (i == 0 )
    {
        dprintf("No buckets here\n");
        return;
    }

    move2(adw,&(pRemote->apbkt[0]),i);

    for ( i = 0; i < pLocal->cBuckets; i++)
    {
        HASHBUCKET *pRemoteHB = ((HASHBUCKET**) adw)[i];

        if ( pRemoteHB )
        {
            HASHBUCKET LocalHB;

            dprintf("apbkt[%3u]", i);

            for ( ; pRemoteHB; pRemoteHB = LocalHB.pbktCollision)
            {
                dprintf(" %-#x", pRemoteHB);
                move(LocalHB, pRemoteHB);
            }
            dprintf("\n");
        }
    }
    dprintf("\n");

    for ( i = 0; i < pLocal->cBuckets; i++)
    {
        HASHBUCKET *pRemoteHB = ((HASHBUCKET**) adw)[i];

        if ( pRemoteHB )
        {
            HASHBUCKET LocalHB;

            dprintf("--------------------------------------\n");
            dprintf("apbkt[%3u]\n", i);

            for ( ; pRemoteHB; pRemoteHB = LocalHB.pbktCollision)
            {
                dprintf("HASHBUCKET* %-#x ", pRemoteHB);
                move(LocalHB, pRemoteHB);

                switch ( pLocal->fht )
                {
                case FHT_FACE:
                case FHT_FAMILY:

                    dprintf("\t\"%ws\"", LocalHB.u.wcCapName);
                    break;

                case FHT_UFI:

                    dprintf("\tUFI(%-#x,%-#x)", LocalHB.u.ufi.CheckSum, LocalHB.u.ufi.Index);
                    break;

                default:

                    break;
                }
                dprintf("\n");

                {
                    PFELINK *ppfel = LocalHB.ppfelEnumHead;
                    PFELINK  pfelLocal;

                    PFE LocalPFE;

                    if (ppfel)
                    {
                        dprintf("PFE*\n");
                        while (ppfel)
                        {
                            move(pfelLocal, ppfel);
                            dprintf("%-#x", pfelLocal.ppfe);
                            move(LocalPFE,pfelLocal.ppfe);

                            if (LocalPFE.pPFF)
                            {
                                PFF LocalPFF;
                                WCHAR awc[MAX_PATH];

                                move(LocalPFF, LocalPFE.pPFF);
                                wcsncpy( awc, LocalPFF.pwszPathname_, MAX_PATH);
                                awc[MAX_PATH-1]=0;
                                dprintf(" \"%ws\"", awc);
                            }

                            if (LocalPFE.pifi)
                            {
                                ULONG dp;
                                WCHAR awc[LF_FACESIZE+1];
                                PWSZ pwszSrc;
                                FWORD fwdAscender, fwdDescender, fwdWidth;

                                move(dp,&((LocalPFE.pifi)->dpwszFaceName));
                                pwszSrc = (PWSZ)(((char*) (LocalPFE.pifi)) + dp);
                                wcsncpy(awc, pwszSrc, LF_FACESIZE);
                                awc[LF_FACESIZE] = 0;
                                dprintf(" \"%ws\"", awc);

                                move(fwdAscender, &LocalPFE.pifi->fwdWinAscender);
                                move(fwdDescender, &LocalPFE.pifi->fwdWinDescender);
                                move(fwdWidth, &LocalPFE.pifi->fwdAveCharWidth);

                                dprintf(" %4d %4d %4d", fwdAscender, fwdDescender, fwdWidth);

                            }

                            dprintf("\n");

                            ppfel = pfelLocal.ppfelNext;
                        }
                    }
                }
            }
        }
    }
    dprintf("--------------------------------------\n");
}
#endif  // DOES NOT SUPPORT API64

/******************************Public*Routine******************************\
* vPrintSkeletonPFT
*
* History:
*  Mon 29-Aug-1994 15:51:16 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
VOID vPrintSkeletonPFT( PFT *pLocalPFT )
{
    PFF *pPFFr, **ppPFFl, **ppPFFl_, *pPFFNext ,*pHeapPFF;

    dprintf("pfhFamily      = %-#x\n" , pLocalPFT->pfhFamily       );
    dprintf("pfhFace        = %-#x\n" , pLocalPFT->pfhFace         );
    dprintf("cBuckets       = %u\n"   , pLocalPFT->cBuckets        );
    dprintf("cFiles         = %u\n"   , pLocalPFT->cFiles          );
    dprintf("\n\n");


    for (
            ppPFFl  = pLocalPFT->apPFF
          , ppPFFl_ = pLocalPFT->apPFF + pLocalPFT->cBuckets
        ;   ppPFFl < ppPFFl_
        ;   ppPFFl++
    ) {
        // if the bucket is empty skip to the next otherwise print
        // the bucket number and then print the contents of all
        // the PFF's hanging off the bucket.

        if (!(pPFFr = *ppPFFl))
            continue;
        dprintf("apPFF[%u]\n", ppPFFl - pLocalPFT->apPFF);
        while ( pPFFr ) {
            // get the size of the remote PFF and allocate enough space
            // on the heap

            dprintf("    %-#8x", pPFFr);
            PFF FramePFF;
            move(FramePFF, pPFFr);
            if (pHeapPFF = tmalloc(PFF,FramePFF.sizeofThis)) {
                // get a local copy of the PFF and fix up the sting pointer
                // to point to the address in the local heap then print
                // the local copy. Some of the addresses in the local
                // PFF point to remote object but vPrintSkeleton will
                // take care of that. When we are done we free the memory.

                move2(pHeapPFF, pPFFr, (ULONG)(ULONG_PTR)FramePFF.sizeofThis);
                PFFOBJ pffo(pHeapPFF);
                pHeapPFF->pwszPathname_ = pffo.pwszCalcPathname();
                vPrintSkeletonPFF(
                   pHeapPFF
                  );
                tfree(pHeapPFF);
            }
            else {
                dprintf("Allocation failure\n");
                break;
            }
            pPFFr = FramePFF.pPFFNext;
        }
    }
}
#endif  // DOES NOT SUPPORT API64

/******************************Public*Routine******************************\
*
* History:
*  21-Feb-1995 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DECLARE_API( pft )
{
    dprintf("Extension 'pft' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    PARSE_POINTER(pft_help);
    Gdidpft((PFT *) arg);
    return;
pft_help:
    dprintf ("Usage: pft [-?] pointer to PFT\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
* dpft
*
* History:
*  Mon 29-Aug-1994 15:39:39 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
VOID Gdidpft( PFT *pRemotePFT)
{
    ULONG size;
    PFT LocalPFT, *pLocalPFT;

    move(LocalPFT, pRemotePFT);
    size = offsetof(PFT, apPFF[0]) + LocalPFT.cBuckets * sizeof(PFF *);
    if (pLocalPFT = tmalloc(PFT, size)) {
        move2(pLocalPFT, pRemotePFT, size);
        vDumpPFT(pLocalPFT, pRemotePFT);
        tfree(pLocalPFT);
    } else
        dprintf("dpft error --- failed to allocate memory\n");
    dprintf("\n");
}
#endif  // DOES NOT SUPPORT API64

/******************************Public*Routine******************************\
* dpubft
*
* dumps the public font table
*
* History:
*  Thu 01-Sep-1994 23:20:54 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

DECLARE_API( pubft )
{
    dprintf("Extension 'pubft' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    PFT * pft;
    PARSE_ARGUMENTS(pubft_help);

    GetValue (pft,  "win32k!gpPFTPublic");
    Gdidpft(pft);
    return;
pubft_help:
    dprintf("Usage: pubft [-?]\n");
//check that this is true
    dprintf("Equivalent to pft win32k!gpPFTPublic\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
* Gdidpvtft( )
*
* dumps the private PFT
*
* History:
*  01-Oct-1996 -by-  Xudong Wu [TessieW]
* Wrote it.
\**************************************************************************/

DECLARE_API( pvtft )
{
    dprintf("Extension 'pvtft' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    PFT * pft;
    PARSE_ARGUMENTS(pvtft_help);
    GetValue (pft,  "win32k!gpPFTPrivate");
    Gdidpft(pft);
    return;
pvtft_help:
    dprintf("Usage: pvtft [-?]\n");
//check that this is true
    dprintf("Equivalent to pft win32k!gpPFTPrivate\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
* ddevft
*
* dumps the device font table
*
* History:
*  Thu 01-Sep-1994 23:21:15 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

DECLARE_API( devft )
{
    dprintf("Extension 'devft' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    PFT *pft;
    PARSE_ARGUMENTS(devft_help);
    GetValue (pft,  "win32k!gpPFTDevice");
    Gdidpft(pft);
    return;
devft_help:
    dprintf("Usage: devft [-?]\n");
//check that this is true
    dprintf("Equivalent to pft win32k!gpPFTDevice\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* History:
*  Sat 23-Sep-1995 08:26:09 by Kirk Olynyk [kirko]
* Re-wrote it.
*  21-Feb-1995 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DECLARE_API( stro )
{
#define QUICK_FACE_NAME_LINKS      8

    ULONG     offset;
    ULONG64     estrobjSrc;

    ULONG     cGlyphs;     // Number of glyphs.
    FLONG     flAccel;     // Accelerator flags exposed to the driver.
    ULONG     ulCharInc;   // Non-zero if constant character increment.
    RECTL     rclBkGround; // Background rect of the string.
    ULONG64 pgp;         // Accelerator if all GLYPHPOS's are valid.
    ULONG64     pwszOrg;     // pointer to original unicode string.

    ULONG      cgposCopied;          // For enumeration.
    ULONG      cgposPositionsEnumerated;   // only used for enumerating positions in linked strings
    ULONG64  prfo;                 // Remember our RFONTOBJ.
    FLONG      flTO;                 // flags
    ULONG64 pgpos;                // Pointer to the GLYPHPOS structures.
    POINTFIX   ptfxRef;              // Reference point.
    POINTFIX   ptfxUpdate;           // CP advancement for the string.
    POINTFIX   ptfxEscapement;       // The total escapement vector.
    RECTFX     rcfx;                 // The TextBox, projected onto the base and ascent.
    FIX        fxExtent;             // The Windows compatible text extent.
    FIX        xExtra;               // computed in H3, G2,3 cases
    FIX        xBreakExtra;          // computed in H3, G2,3 cases
    DWORD      dwCodePage;           // accelerator for ps driver
    ULONG      cExtraRects;          // Rectangles for underline
    RECTL      arclExtra[3];         //  and strikeout.
    RECTL      rclBkGroundSave;      // used to save a copy of BkGroundRect
    ULONG64      pwcPartition;        // For partitioning
    ULONG64       plPartition;         // Points to partitioning information
    ULONG64      plNext;              // Next glyph in font
    ULONG64   pgpNext;             // For enumeration
    LONG       lCurrentFont;         // For enumeration
    POINTL     ptlBaseLineAdjust;     // Used to adjust SysEUDC baseline
    ULONG      cTTSysGlyphs;         // Number of TT system font glyphs in a string
    ULONG      cSysGlyphs;           // Number of system eudc glyphs in a string.
    ULONG      cDefGlyphs;           // Number of default eudc glyphs in a string.
    ULONG      cNumFaceNameLinks;    // Number of linked face name eudc in a string .
    ULONG64     pacFaceNameGlyphs;    // Pointer to array of number of face name glyphs.
    ULONG      acFaceNameGlyphs[QUICK_FACE_NAME_LINKS];

    FLONG fl;
    FLAGDEF *pfd;
    WCHAR *awc;
    int i;
    BOOL Header=FALSE;
    BOOL Position=FALSE;
    BOOL East=FALSE;

    PARSE_POINTER(stro_help);
    estrobjSrc= arg;

    if(parse_iFindSwitch(tokens, ntok, 'p')!=-1) {Position=TRUE;}
    if(parse_iFindSwitch(tokens, ntok, 'h')!=-1) {Header=TRUE;}
    if(parse_iFindSwitch(tokens, ntok, 'e')!=-1) {East=TRUE;}

    if(!(Position||East||Header)) {Header=TRUE;}
    if(East) {Header=TRUE;}

    if (Header) {
        GetESTROBJFieldAndOffset(cGlyphs); 
        dprintf("[%-#p] cGlyphs                %-#x\n", estrobjSrc+offset               , cGlyphs               );
        GetESTROBJFieldAndOffset(flAccel); 
        dprintf("[%-#p] flAccel                %-#x\n", estrobjSrc+offset               , flAccel               );
        for (fl=flAccel, pfd=afdSO; pfd->psz; pfd++)
            if (fl & pfd->fl) {
                dprintf("\t\t%s\n", pfd->psz);
                fl &= ~pfd->fl;
            }
        GetESTROBJFieldAndOffset(ulCharInc); 
        dprintf("[%-#p] ulCharInc              %-#x=%u\n", estrobjSrc+offset             , ulCharInc            , ulCharInc              );
        GetESTROBJFieldAndOffset(rclBkGround.left); 
        dprintf("[%-#p] rclBkGround.left       %-#x=%d\n", estrobjSrc+offset      , rclBkGround.left     , rclBkGround.left       );
        GetESTROBJFieldAndOffset(rclBkGround.top); 
        dprintf("[%-#p] rclBkGround.top        %-#x=%d\n", estrobjSrc+offset       , rclBkGround.top      , rclBkGround.top        );
        GetESTROBJFieldAndOffset(rclBkGround.right); 
        dprintf("[%-#p] rclBkGround.right      %-#x=%d\n", estrobjSrc+offset     , rclBkGround.right    , rclBkGround.right      );
        GetESTROBJFieldAndOffset(rclBkGround.bottom); 
        dprintf("[%-#p] rclBkGround.bottom     %-#x=%d\n", estrobjSrc+offset    , rclBkGround.bottom   , rclBkGround.bottom     );
        GetESTROBJFieldAndOffset(pgp); 
       dprintf("[%-#p] pgp                    %-#x\n", estrobjSrc+offset                   , pgp                   );

        GetESTROBJFieldAndOffset(pwszOrg); 
        awc = (WCHAR*) adw;
        awc[0] = 0;
        if (pwszOrg && cGlyphs < 256) {
            ReadMemory((ULONG_PTR) pwszOrg, adw, cGlyphs * sizeof(WCHAR), 0);
            awc[255] = 0;
        }
        dprintf("[%-#p] pwszOrg                %-#x ", estrobjSrc+offset, pwszOrg);
        GetESTROBJFieldAndOffset(prfo); 
        if (awc[0] && prfo) {
#if 0
            if (offsetof(RFONTOBJ,prfnt) != 0)
                dprintf("\noffsetof(RFONTOBJ,prfnt) != 0\n");
            else 
#endif
            {
                ULONG64         foSrc;
                FLONG           flType;         // Cache type -

                GetFieldData(prfo, "PVOID", NULL, sizeof(foSrc), &foSrc);
                GetRFONTFieldAndOffset( flType);


                WCHAR wc, *pwc;
                USHORT *pus, *pusStnl;

                switch (flType & (RFONT_TYPE_UNICODE | RFONT_TYPE_HGLYPH)) {

                case RFONT_TYPE_UNICODE:

                    dprintf("%c", '\"');
                    for (pwc = awc; wc = *pwc; pwc++) {
                        if (wc < 256 )
                            dprintf("%c", isprint((int)wc) ? (char) wc : 250);
                        else
                            dprintf("\\u%04X", wc);
                    }
                    dprintf("\"\n");
                    break;

                case RFONT_TYPE_HGLYPH:

                    for (pwc = awc; wc = *pwc; pwc++)
                        dprintf("\t\t\t\tu%04X", wc);
                    dprintf("\n");
                    break;

                default:

                      dprintf("   flType = %-#x [unknown string type]\n", flType);
                      break;
                }
            }
        } else
            dprintf("\n");
    }

    if (East) {

        GetESTROBJFieldAndOffset(cgposCopied); 
        dprintf("[%-#p] cgposCopied            %-#x\n", estrobjSrc+offset           , cgposCopied           );
        GetESTROBJFieldAndOffset(cgposPositionsEnumerated); 
        dprintf("[%-#p] cgposPositionsEnumerated %-#x\n", estrobjSrc+offset          , cgposPositionsEnumerated           );
        GetESTROBJFieldAndOffset(prfo); 
        dprintf("[%-#p] prfo                   %-#p\n", estrobjSrc+offset                  , prfo                  );
        GetESTROBJFieldAndOffset(flTO); 
        dprintf("[%-#p] flTO                   %-#x\n", estrobjSrc+offset                  , flTO                  );
        for (fl=flTO, pfd=afdTO; pfd->psz; pfd++)
            if (fl & pfd->fl) {
                dprintf("\t\t%s\n", pfd->psz);
                fl &= ~pfd->fl;
            }
        GetESTROBJFieldAndOffset(pgpos); 
        dprintf("[%-#p] pgpos                  %-#p\n", estrobjSrc+offset                 , pgpos                 );
        GetESTROBJFieldAndOffset(ptfxRef.x); 
        dprintf("[%-#p] ptfxRef.x              %-#x\n", estrobjSrc+offset             , ptfxRef.x             );
        GetESTROBJFieldAndOffset(ptfxRef.y); 
        dprintf("[%-#p] ptfxRef.y              %-#x\n", estrobjSrc+offset             , ptfxRef.y             );
        GetESTROBJFieldAndOffset(ptfxUpdate.x); 
        dprintf("[%-#p] ptfxUpdate.x           %-#x\n", estrobjSrc+offset          , ptfxUpdate.x          );
        GetESTROBJFieldAndOffset(ptfxUpdate.y); 
        dprintf("[%-#p] ptfxUpdate.y           %-#x\n", estrobjSrc+offset          , ptfxUpdate.y          );
        GetESTROBJFieldAndOffset(ptfxEscapement.x); 
        dprintf("[%-#p] ptfxEscapement.x       %-#x\n", estrobjSrc+offset      , ptfxEscapement.x      );
        GetESTROBJFieldAndOffset(ptfxEscapement.y); 
        dprintf("[%-#p] ptfxEscapement.y       %-#x\n", estrobjSrc+offset      , ptfxEscapement.y      );
        GetESTROBJFieldAndOffset(rcfx.xLeft); 
        dprintf("[%-#p] rcfx.xLeft             %-#x\n", estrobjSrc+offset            , rcfx.xLeft            );
        GetESTROBJFieldAndOffset(rcfx.yTop); 
        dprintf("[%-#p] rcfx.yTop              %-#x\n", estrobjSrc+offset             , rcfx.yTop             );
        GetESTROBJFieldAndOffset(rcfx.xRight); 
        dprintf("[%-#p] rcfx.xRight            %-#x\n", estrobjSrc+offset           , rcfx.xRight           );
        GetESTROBJFieldAndOffset(rcfx.yBottom); 
        dprintf("[%-#p] rcfx.yBottom           %-#x\n", estrobjSrc+offset          , rcfx.yBottom          );
        GetESTROBJFieldAndOffset(fxExtent); 
        dprintf("[%-#p] fxExtent               %-#x\n", estrobjSrc+offset              , fxExtent              );
        GetESTROBJFieldAndOffset(xExtra); 
        dprintf("[%-#p] xExtra                 %-#x\n", estrobjSrc+offset                , xExtra                );
        GetESTROBJFieldAndOffset(xBreakExtra); 
        dprintf("[%-#p] xBreakExtra            %-#x\n", estrobjSrc+offset           , xBreakExtra           );
        GetESTROBJFieldAndOffset(dwCodePage); 
        dprintf("[%-#p] dwCodePage             %-#x=%u\n", estrobjSrc+offset            , dwCodePage            , dwCodePage            );
        GetESTROBJFieldAndOffset(cExtraRects); 
        dprintf("[%-#p] cExtraRects            %-#x=%u\n", estrobjSrc+offset           , cExtraRects           , cExtraRects           );
        GetESTROBJFieldAndOffset(arclExtra[0].left); 
        dprintf("[%-#p] arclExtra[0].left      %-#x=%d\n", estrobjSrc+offset     , arclExtra[0].left     , arclExtra[0].left     );
        GetESTROBJFieldAndOffset(arclExtra[0].top); 
        dprintf("[%-#p] arclExtra[0].top       %-#x=%d\n", estrobjSrc+offset      , arclExtra[0].top      , arclExtra[0].top      );
        GetESTROBJFieldAndOffset(arclExtra[0].right); 
        dprintf("[%-#p] arclExtra[0].right     %-#x=%d\n", estrobjSrc+offset    , arclExtra[0].right    , arclExtra[0].right    );
        GetESTROBJFieldAndOffset(arclExtra[0].bottom); 
        dprintf("[%-#p] arclExtra[0].bottom    %-#x=%d\n", estrobjSrc+offset   , arclExtra[0].bottom   , arclExtra[0].bottom   );
        GetESTROBJFieldAndOffset(arclExtra[1].left); 
        dprintf("[%-#p] arclExtra[1].left      %-#x=%d\n", estrobjSrc+offset     , arclExtra[1].left     , arclExtra[1].left     );
        GetESTROBJFieldAndOffset(arclExtra[1].top); 
        dprintf("[%-#p] arclExtra[1].top       %-#x=%d\n", estrobjSrc+offset      , arclExtra[1].top      , arclExtra[1].top      );
        GetESTROBJFieldAndOffset(arclExtra[1].right); 
        dprintf("[%-#p] arclExtra[1].right     %-#x=%d\n", estrobjSrc+offset    , arclExtra[1].right    , arclExtra[1].right    );
        GetESTROBJFieldAndOffset(arclExtra[1].bottom); 
        dprintf("[%-#p] arclExtra[1].bottom    %-#x=%d\n", estrobjSrc+offset   , arclExtra[1].bottom   , arclExtra[1].bottom   );
        GetESTROBJFieldAndOffset(arclExtra[2].left); 
        dprintf("[%-#p] arclExtra[2].left      %-#x=%d\n", estrobjSrc+offset     , arclExtra[2].left     , arclExtra[2].left     );
        GetESTROBJFieldAndOffset(arclExtra[2].top); 
        dprintf("[%-#p] arclExtra[2].top       %-#x=%d\n", estrobjSrc+offset      , arclExtra[2].top      , arclExtra[2].top      );
        GetESTROBJFieldAndOffset(arclExtra[2].right); 
        dprintf("[%-#p] arclExtra[2].right     %-#x=%d\n", estrobjSrc+offset    , arclExtra[2].right    , arclExtra[2].right    );
        GetESTROBJFieldAndOffset(arclExtra[2].bottom); 
        dprintf("[%-#p] arclExtra[2].bottom    %-#x=%d\n", estrobjSrc+offset   , arclExtra[2].bottom   , arclExtra[2].bottom   );
        GetESTROBJFieldAndOffset(rclBkGroundSave.top); 
        dprintf("[%-#p] rclBkGroundSave.top    %-#x=%d\n", estrobjSrc+offset   , rclBkGroundSave.top   , rclBkGroundSave.top   );
        GetESTROBJFieldAndOffset(rclBkGroundSave.left); 
        dprintf("[%-#p] rclBkGroundSave.left   %-#x=%d\n", estrobjSrc+offset  , rclBkGroundSave.left  , rclBkGroundSave.left  );
        GetESTROBJFieldAndOffset(rclBkGroundSave.right); 
        dprintf("[%-#p] rclBkGroundSave.right  %-#x=%d\n", estrobjSrc+offset , rclBkGroundSave.right , rclBkGroundSave.right );
        GetESTROBJFieldAndOffset(rclBkGroundSave.bottom); 
        dprintf("[%-#p] rclBkGroundSave.bottom %-#x=%d\n", estrobjSrc+offset, rclBkGroundSave.bottom, rclBkGroundSave.bottom);
        GetESTROBJFieldAndOffset(pwcPartition); 
        dprintf("[%-#p] pwcPartition           %-#p\n", estrobjSrc+offset          , pwcPartition          );
        GetESTROBJFieldAndOffset(plPartition); 
        dprintf("[%-#p] plPartition            %-#p\n", estrobjSrc+offset           , plPartition           );
        GetESTROBJFieldAndOffset(plNext); 
        dprintf("[%-#p] plNext                 %-#p\n", estrobjSrc+offset                , plNext                );
        GetESTROBJFieldAndOffset(pgpNext); 
        dprintf("[%-#p] pgpNext                %-#p\n", estrobjSrc+offset               , pgpNext               );
        GetESTROBJFieldAndOffset(lCurrentFont); 
        dprintf("[%-#p] lCurrentFont           %-#x\n", estrobjSrc+offset          , lCurrentFont          );
        GetESTROBJFieldAndOffset(ptlBaseLineAdjust.x); 
        dprintf("[%-#p] ptlBaseLineAdjust.x     %-#x\n", estrobjSrc+offset    , ptlBaseLineAdjust.x    );
        GetESTROBJFieldAndOffset(ptlBaseLineAdjust.y); 
        dprintf("[%-#p] ptlBaseLineAdjust.y     %-#x\n", estrobjSrc+offset    , ptlBaseLineAdjust.y    );
        GetESTROBJFieldAndOffset(cTTSysGlyphs); 
        dprintf("[%-#p] cTTSysGlyphs           %-#x\n", estrobjSrc+offset          , cTTSysGlyphs          );
        GetESTROBJFieldAndOffset(cSysGlyphs); 
        dprintf("[%-#p] cSysGlyphs             %-#x\n", estrobjSrc+offset            , cSysGlyphs            );
        GetESTROBJFieldAndOffset(cDefGlyphs); 
        dprintf("[%-#p] cDefGlyphs             %-#x\n", estrobjSrc+offset            , cDefGlyphs            );
        GetESTROBJFieldAndOffset(cNumFaceNameLinks); 
        dprintf("[%-#p] cNumFaceNameLinks      %-#x\n", estrobjSrc+offset     , cNumFaceNameLinks     );
        GetESTROBJFieldAndOffset(pacFaceNameGlyphs); 
        dprintf("[%-#p] pacFaceNameGlyphs      %-#p\n", estrobjSrc+offset     , pacFaceNameGlyphs     );

        GetESTROBJFieldAndOffset(acFaceNameGlyphs[0]); 
        dprintf("[%-#p] acFaceNameGlyphs[%d]    %-#x\n", estrobjSrc+offset, 0, acFaceNameGlyphs[0]   );
        GetESTROBJFieldAndOffset(acFaceNameGlyphs[1]); 
        dprintf("[%-#p] acFaceNameGlyphs[%d]    %-#x\n", estrobjSrc+offset, 1, acFaceNameGlyphs[1]   );
        GetESTROBJFieldAndOffset(acFaceNameGlyphs[2]); 
        dprintf("[%-#p] acFaceNameGlyphs[%d]    %-#x\n", estrobjSrc+offset, 2, acFaceNameGlyphs[2]   );
        GetESTROBJFieldAndOffset(acFaceNameGlyphs[3]); 
        dprintf("[%-#p] acFaceNameGlyphs[%d]    %-#x\n", estrobjSrc+offset, 3, acFaceNameGlyphs[3]   );
        GetESTROBJFieldAndOffset(acFaceNameGlyphs[4]); 
        dprintf("[%-#p] acFaceNameGlyphs[%d]    %-#x\n", estrobjSrc+offset, 4, acFaceNameGlyphs[4]   );
        GetESTROBJFieldAndOffset(acFaceNameGlyphs[5]); 
        dprintf("[%-#p] acFaceNameGlyphs[%d]    %-#x\n", estrobjSrc+offset, 5, acFaceNameGlyphs[5]   );
        GetESTROBJFieldAndOffset(acFaceNameGlyphs[6]); 
        dprintf("[%-#p] acFaceNameGlyphs[%d]    %-#x\n", estrobjSrc+offset, 6, acFaceNameGlyphs[6]   );
        GetESTROBJFieldAndOffset(acFaceNameGlyphs[7]); 
        dprintf("[%-#p] acFaceNameGlyphs[%d]    %-#x\n", estrobjSrc+offset, 7, acFaceNameGlyphs[7]   );
    }
    if (Position) {

      /* GLYPHPOS: */
      ULONG      hg, i;
      ULONG64     pgdf;
      POINTL      ptl;

      /* GLYPHDEF */
      ULONG64 pgb = 0;

      ULONG64 glyphposSrc, sizeOfGlyphPos;

	  sizeOfGlyphPos = GetTypeSize("GLYPHPOS");

      GetESTROBJFieldAndOffset(rclBkGround.left); 
      GetESTROBJFieldAndOffset(rclBkGround.top); 
      GetESTROBJFieldAndOffset(rclBkGround.right); 
      GetESTROBJFieldAndOffset(rclBkGround.bottom); 
      GetESTROBJFieldAndOffset(cGlyphs); 
      GetESTROBJFieldAndOffset(pgp); 

      glyphposSrc = pgp;

      dprintf("   ---------- ----------      ---------- ----------\n");
      dprintf("   HGLYPH      GLYPHBITS*         x          y\n");
      dprintf("   ---------- ----------      ---------- ----------\n");

      for (i = 0; i < cGlyphs; i++) {
          char *pszOutOfBounds = "";
          GetGLYPHPOSFieldAndOffset(pgdf); 
          GetGLYPHPOSFieldAndOffset(hg); 
          GetGLYPHPOSFieldAndOffset(ptl.x); 
          GetGLYPHPOSFieldAndOffset(ptl.y); 


          if (pgdf) {
              POINTL      ptlOrigin;
              SIZEL       sizlBitmap;
              BYTE        aj[1];
              ULONG64 glyphdefSrc = pgdf;

              GetGLYPHDEFFieldAndOffset(pgb); 

              if (pgb) {
                  RECT rcGlyph;
                  ULONG64 glyphbitsSrc = pgb;

                  GetGLYPHBITSFieldAndOffset(ptlOrigin.x); 
                  GetGLYPHBITSFieldAndOffset(ptlOrigin.y); 
                  GetGLYPHBITSFieldAndOffset(sizlBitmap.cx); 
                  GetGLYPHBITSFieldAndOffset(sizlBitmap.cy); 

                  rcGlyph.left   = ptl.x   + ptlOrigin.x;
                  rcGlyph.top    = ptl.y   + ptlOrigin.y;
                  rcGlyph.right  = rcGlyph.left + sizlBitmap.cx;
                  rcGlyph.bottom = rcGlyph.top  + sizlBitmap.cy;

                  if (
                      ( rcGlyph.left   < rclBkGround.left   ) ||
                      ( rcGlyph.right  > rclBkGround.right  ) ||
                      ( rcGlyph.top    < rclBkGround.top    ) ||
                      ( rcGlyph.bottom > rclBkGround.bottom )
                  )
                  {
                      pszOutOfBounds = " *** out of bounds ***";
                  }
              } /* if (pgb) */
          } /* if (pgdf) */
          dprintf(
              "   %-#10x %-#18p      %-10d %-10d%s\n"
              , hg
              , pgb        // print the CONTENTS of the GLYPHDEF
              , ptl.x
              , ptl.y
              , pszOutOfBounds
          );
          glyphposSrc += sizeOfGlyphPos;
      } /* for */
        dprintf("   ---------- ----------      ---------- ----------\n\n");
    }
    EXIT_API(S_OK);
stro_help:
    dprintf("!gdikdx.stro [-p] address\n"
            "-? print this message\n"
            "-p print glyph positions\n"
            "-h print header\n"
            "-e far east\n");

    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   dstro
*
\**************************************************************************/

DECLARE_API( dstro )
{
    dprintf("Extension 'dstro' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    dprintf("\n\n");
    dprintf("gdikdx.dstro will soon be replaced by gdikdx.stro\n");
    dprintf("\n\n");
    stro(hCurrentProcess, hCurrentThread, dwCurrentPc, dwProcessor, args);
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Dumps monochrome bitmaps.
*
* History:
*  Sat 23-Sep-1995 08:26:43 by Kirk Olynyk [kirko]
* Re-wrote it.
*  21-Feb-1995 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DECLARE_API( gb )
{
    #define CH_TOP_LEFT_CORNER '\xDA'
    #define CH_HORIZONTAL_BAR  '\xC4'
    #define CH_VERTICAL_BAR    '\xB3'
    #define CH_PIXEL_ON        '\x02'
    #define CH_PIXEL_OFF       '\xFA'
    #define CH_GARBAGE         '+'
    

    ULONG64 glyphbitsSrc;
    ULONG       offset;

    BYTE     j, *pj8, *pj, *pjNext, *pjEnd;
    int      i, k, cj, cjScan, c4, c8, cLast;
    char     *pch;

    POINTL      ptlOrigin;
    SIZEL       sizlBitmap;
    BYTE        aj[1];

    BOOL Gray=FALSE;
    BOOL Mono=FALSE;
    BOOL Header=FALSE;

    PARSE_POINTER(gb_help);
    if(parse_iFindSwitch(tokens, ntok, 'h')!=-1) {Header=TRUE;}
    if(parse_iFindSwitch(tokens, ntok, 'm')!=-1) {Mono=TRUE;}
    if(parse_iFindSwitch(tokens, ntok, 'g')!=-1) {Gray=TRUE;}
    if(Mono&&Gray) {
      Gray=FALSE;
      dprintf("cannot have Monochrome and Gray simultaneously\n"
              "assuming Monochrome\n");
    }
    if(!(Header||Mono||Gray)) {
      Header=TRUE;
      Mono=TRUE;
    }

    //arg from PARSE_POINTER() above.
    glyphbitsSrc = arg;

    GetGLYPHBITSFieldAndOffset(ptlOrigin.x); 
    GetGLYPHBITSFieldAndOffset(ptlOrigin.y); 
    GetGLYPHBITSFieldAndOffset(sizlBitmap.cx); 
    GetGLYPHBITSFieldAndOffset(sizlBitmap.cy); 

    // header information
    if (Header) {
        dprintf(
            "ptlOrigin  = (%d,%d)\n"
            "sizlBitmap = (%d,%d)\n"
            "\n\n"
            , ptlOrigin.x
            , ptlOrigin.y
            , sizlBitmap.cx
            , sizlBitmap.cy
        );
    }
    // do stuff common to monochrome and gray glyphs
    if (Mono||Gray) {
        if ( sizlBitmap.cx > 150 ) {
            dprintf("\nBitmap is wider than 150 characters\n");
            EXIT_API(S_OK);
        }
        // cjScan = number of bytes per scan
        if (Mono) {
            cjScan = (sizlBitmap.cx + 7)/8;  // 8 pixels per byte
        } else
            cjScan = (sizlBitmap.cx + 1)/2;  // 2 pixels per byte
        // cj = number of bytes in image bits (excluding header)
        if ( ( cj = cjScan * sizlBitmap.cy ) > sizeof(adw) ) {
            dprintf( "\nThe bits will blow out the buffer\n" );
            EXIT_API(S_OK);
        }

        GetGLYPHBITSFieldAndOffset(aj[0]); 

        ReadMemory((ULONG_PTR) (glyphbitsSrc + offset), adw, cj, NULL);
        dprintf("\n\n  ");           // leave space for number and vertical bar
        for (i = 0, k = 0; i < sizlBitmap.cx; i++, k++) {
            k = (k > 9) ? 0 : k;                // print x-coordinates (mod 10)
            dprintf("%1d", k);
        }                                       // go to new line
        dprintf("\n %c",CH_TOP_LEFT_CORNER);    // leave space for number
        for (i = 0; i < sizlBitmap.cx; i++)  // and then mark corner
            dprintf("%c",CH_HORIZONTAL_BAR);    // fill out horizontal line
        dprintf("\n");                          // move down to scan output
    }
    // monochrome glyph
    if (Mono)
    {
        static char ach[16*4] = {
            CH_PIXEL_OFF, CH_PIXEL_OFF, CH_PIXEL_OFF, CH_PIXEL_OFF,
            CH_PIXEL_OFF, CH_PIXEL_OFF, CH_PIXEL_OFF, CH_PIXEL_ON ,
            CH_PIXEL_OFF, CH_PIXEL_OFF, CH_PIXEL_ON , CH_PIXEL_OFF,
            CH_PIXEL_OFF, CH_PIXEL_OFF, CH_PIXEL_ON , CH_PIXEL_ON ,
            CH_PIXEL_OFF, CH_PIXEL_ON , CH_PIXEL_OFF, CH_PIXEL_OFF,
            CH_PIXEL_OFF, CH_PIXEL_ON , CH_PIXEL_OFF, CH_PIXEL_ON ,
            CH_PIXEL_OFF, CH_PIXEL_ON , CH_PIXEL_ON , CH_PIXEL_OFF,
            CH_PIXEL_OFF, CH_PIXEL_ON , CH_PIXEL_ON , CH_PIXEL_ON ,
            CH_PIXEL_ON , CH_PIXEL_OFF, CH_PIXEL_OFF, CH_PIXEL_OFF,
            CH_PIXEL_ON , CH_PIXEL_OFF, CH_PIXEL_OFF, CH_PIXEL_ON ,
            CH_PIXEL_ON , CH_PIXEL_OFF, CH_PIXEL_ON , CH_PIXEL_OFF,
            CH_PIXEL_ON , CH_PIXEL_OFF, CH_PIXEL_ON , CH_PIXEL_ON ,
            CH_PIXEL_ON , CH_PIXEL_ON , CH_PIXEL_OFF, CH_PIXEL_OFF,
            CH_PIXEL_ON , CH_PIXEL_ON , CH_PIXEL_OFF, CH_PIXEL_ON ,
            CH_PIXEL_ON , CH_PIXEL_ON , CH_PIXEL_ON , CH_PIXEL_OFF,
            CH_PIXEL_ON , CH_PIXEL_ON , CH_PIXEL_ON , CH_PIXEL_ON
        };

        i      = sizlBitmap.cx;
        c8     = i / 8;     // c8 = number of whole bytes
        i      = i % 8;     // i = remaining number of pixels = 0..7
        c4     = i / 4;     // number of whole nybbles        = 0..1
        cLast  = i % 4;     // remaining number of pixels     = 0..3

        // k      = row number
        // pjEnd  = pointer to address of scan beyond last scan
        // pjNext = pointer to next scan
        // pj     = pointer to current byte
        // for each scan ...

        for (
            pj = (BYTE*)adw, pjNext=pj+cjScan , pjEnd=pjNext+cj, k=0 ;
            pjNext < pjEnd                                           ;
            pj=pjNext , pjNext+=cjScan, k++
        )
        {
            if (CheckControlC())
                EXIT_API(S_OK);

            k = (k > 9) ? 0 : k;

            // print row number (mod 10) followed by a vertical bar ...

            dprintf("%1d%c",k,CH_VERTICAL_BAR);

            // then do the pixels of the scan ...
            // whole bytes first ...

            for (pj8 = pj+c8 ; pj < pj8; pj++)
            {
                // high nybble first ...

                pch = ach + 4 * (*pj >> 4);
                dprintf("%c%c%c%c",pch[0],pch[1],pch[2],pch[3]);

                // low nybble next ...

                pch = ach + 4 * (*pj & 0xf);
                dprintf("%c%c%c%c",pch[0],pch[1],pch[2],pch[3]);
            }

            // last partial byte ...

            if (c4 || cLast)
            {
                // high nybble first ...

                pch = ach + 4 * (*pj >> 4);

                if (c4)
                {
                    // print the entire high nybble ...

                    dprintf("%c%c%c%c",pch[0],pch[1],pch[2],pch[3]);

                    // go to the low nybble ...

                    pch = ach + 4 * (*pj & 0xf);
                }

                // last partial nybble ...

                switch(cLast)
                {
                case 3: dprintf("%c",*pch++);
                case 2: dprintf("%c",*pch++);
                case 1: dprintf("%c",*pch);
                }

                //
                // print any extraneous bits
                //
                for (j = *pj << i; j; j <<= 1)
                {
                    if ( j & 0x80 )
                    {
                        dprintf("%c",CH_GARBAGE);
                    }
                }

            }
            dprintf("\n");
        }
    }
    // gray glyph
    if (Gray)
    {
        static char achGray[16] = {
            CH_PIXEL_OFF,
            '1','2','3','4','5','6','7','8','9','a','b','c','d','e',
            CH_PIXEL_ON
        };
        c8 = sizlBitmap.cx / 2; // number of whole bytes;
        c4 = sizlBitmap.cx % 2; // number of whole nybbles;
        // k      = row number
        // pjEnd  = pointer to address of scan beyond last scan
        // pjNext = pointer to next scan
        // pj     = pointer to current byte
        // for each scan ...
        for (
            pj = (BYTE*)adw, pjNext=pj+cjScan , pjEnd=pjNext+cj, k=0 ;
            pjNext < pjEnd                                           ;
            pj=pjNext , pjNext+=cjScan, k++
        )
        {
            if (CheckControlC())
                EXIT_API(S_OK);
            k = (k > 9) ? 0 : k;
            // print row number (mod 10) followed by a vertical bar ...
            dprintf("%1d%c",k,CH_VERTICAL_BAR);
            // then do the pixels of the scan ...
            // whole bytes first ...
            for (pj8 = pj+c8 ; pj < pj8; pj++)
                dprintf("%c%c", achGray[*pj>>4], achGray[*pj & 0xf]);
            // last partial byte ...
            if (c4)
                dprintf("%c", achGray[*pj >> 4]);
            dprintf("\n");
        }
    }
    EXIT_API(S_OK);

gb_help:
    dprintf("Usage: gb [-?] [-g|-m] [-h] address\n"
            "   -?    this message\n"
            "   -h    print header\n"
            "   -m    print monochrome bitmap\n"
            "   -g    print 4-bpp bitmap\n"
            "If no flags are supplied, -m -h assumed.\n"
            "Cannot supply -m and -g together.");
    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpCOLORADJUSTMENT
*
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
void vDumpCOLORADJUSTMENT(COLORADJUSTMENT *pdca, COLORADJUSTMENT *pdcaSrc)
{
    FLAGDEF *pfd;
    FLONG fl;

    #define M3(aa,bb) \
        dprintf("[%x] %s%-#x\n", &(pdcaSrc->##aa), (bb), pdca->##aa)
    #define M2(aa,bb) \
        dprintf("[%x] %s", &(pdcaSrc->##aa), (bb))

    dprintf("\nCOLORADJUSTMENT\n address\n -------\n");
    M3( caSize           , "caSize            " );

    // caFlags

    M3( caFlags          , "caFlags           " );
    for ( fl = pdca->caFlags, pfd = afdCOLORADJUSTMENT; pfd->psz; pfd++)
        if (fl & pfd->fl) {
            dprintf("\t\t\t\t\t%s\n", pfd->psz);
            fl &= ~pfd->fl;
        }
    if (fl)
        dprintf("\t\t\t\t\tbad flags %-#x\n", fl);

    M3( caIlluminantIndex, "caIlluminantIndex " );
    M3( caRedGamma       , "caRedGamma        " );
    M3( caGreenGamma     , "caGreenGamma      " );
    M3( caBlueGamma      , "caBlueGamma       " );
    M3( caReferenceBlack , "caReferenceBlack  " );
    M3( caReferenceWhite , "caReferenceWhite  " );
    M3( caContrast       , "caContrast        " );
    M3( caBrightness     , "caBrightness      " );
    M3( caColorfulness   , "caColorfulness    " );
    M3( caRedGreenTint   , "caRedGreenTint    " );
    dprintf("\n");

    #undef M2
    #undef M3
}
#endif  // DOES NOT SUPPORT API64

/******************************Public*Routine******************************\
*
* History:
*  21-Feb-1995 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DECLARE_API( gdf )
{
    dprintf("Extension 'gdf' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    GLYPHDEF gd;
    PARSE_POINTER(gdf_help);    
    move(gd, arg);
    dprintf("\n\nGLYPHDEF\n\n");
    dprintf("[%x] %-#x\n", arg, gd.pgb);
    dprintf("\n");
    return;
gdf_help:
    dprintf("Usage: gdf [-?] GLYPHDEF pointer\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpGLYPHPOS
*
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
void vDumpGLYPHPOS(GLYPHPOS *p1, GLYPHPOS *p0)
{
    dprintf("\nGLYPHPOS\n\n");
    dprintf("[%x] hg   %-#x\n" , &p0->hg  , p1->hg  );
    dprintf("[%x] pgdf %-#x\n" , &p0->pgdf, p1->pgdf);
    dprintf("[%x] ptl  %d %d\n", &p0->ptl , p1->ptl.x, p1->ptl.y);
    dprintf("\n");
}
#endif  // DOES NOT SUPPORT API64

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   gp
*
\**************************************************************************/

DECLARE_API( gp )
{
    dprintf("Extension 'gp' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    GLYPHPOS gp;
    PARSE_POINTER(gp_help);
    move(gp,arg);
    vDumpGLYPHPOS(&gp,(GLYPHPOS*)arg);
    return;
gp_help:
    dprintf("Usage: gp [-?] GLYPHPOS pointer\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   ca
*
\**************************************************************************/

DECLARE_API( ca )
{
    dprintf("Extension 'ca' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    COLORADJUSTMENT ca;
    PARSE_POINTER(ca_help);
    move(ca, arg);
    vDumpCOLORADJUSTMENT(&ca, (COLORADJUSTMENT*) arg);
    return;
ca_help:
    dprintf("Usage: ca [-?] COLORADJUSTMENT pointer\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpDATABLOCK
*
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
void vDumpDATABLOCK(
    DATABLOCK *p,     // pointer to local DATABLOCK copy
    DATABLOCK *p0     // pointer to original DATABLOCK on debug machine
    )
{
    dprintf( "\nDATABLOCK\n address\n -------\n" );
    dprintf( "[%x] pdblNext %-#x\n", &(p0->pdblNext), p->pdblNext);
    dprintf( "[%x] cgd        %u\n",   &(p0->cgd       ), p->cgd       );
    dprintf( "\n" );
}
#endif  // DOES NOT SUPPORT API64

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpCACHE
*
\**************************************************************************/

void vDumpCACHE(ULONG64 cacheSrc)
{
    ULONG       offset;

    ULONG64 pgdNext;         // ptr to next free place to put GLYPHDATA
    ULONG64 pgdThreshold;    // ptr to first uncommited spot
    ULONG64      pjFirstBlockEnd; // ptr to end of first GLYPHDATA block
    ULONG64 pdblBase;        // ptr to base of current GLYPHDATA block
    ULONG      cMetrics;        // number of GLYPHDATA's in the metrics cache
    ULONG     cjbblInitial;     // size of initial bit block
    ULONG     cjbbl;            // size of any individual block in bytes
    ULONG     cBlocksMax;       // max # of blocks allowed
    ULONG     cBlocks;          // # of blocks allocated so far
    ULONG     cGlyphs;          // for statistical purposes only
    ULONG     cjTotal;          // also for stat purposes only
    ULONG64 pbblBase;         // ptr to the first bit block (head of the list)
    ULONG64 pbblCur;          // ptr to the block containing next
    ULONG64     pgbNext;          // ptr to next free place to put GLYPHBITS
    ULONG64     pgbThreshold;     // end of the current block
    ULONG64           pjAuxCacheMem;  // ptr to lookaside buffer, if any
    SIZE_T          cjAuxCacheMem;  // size of current lookaside buffer
    ULONG cjGlyphMax;          // size of largest glyph
    BOOL   bSmallMetrics;
    INT iMax;
    INT iFirst;
    INT cBits;
    

    #define GetAndPrintCACHEFieldAndOffset(expr, member) \
				GetCACHEFieldAndOffset(member); dprintf("[0x%p] " #expr "    " #member "\n", cacheSrc+offset, ##member)


    dprintf("\nCACHE\n address\n -------\n" );
    GetAndPrintCACHEFieldAndOffset( %+#20p, pgdNext);
    GetAndPrintCACHEFieldAndOffset( %+#20p, pgdThreshold);
    GetAndPrintCACHEFieldAndOffset( %+#20p, pjFirstBlockEnd);
    GetAndPrintCACHEFieldAndOffset( %+#20p, pdblBase);
    GetAndPrintCACHEFieldAndOffset( %+#20x, cMetrics);
    GetAndPrintCACHEFieldAndOffset( %+#20x, cjbbl);
    GetAndPrintCACHEFieldAndOffset( %+#20x, cBlocksMax);
    GetAndPrintCACHEFieldAndOffset( %+#20x, cBlocks);
    GetAndPrintCACHEFieldAndOffset( %+#20x, cGlyphs);
    GetAndPrintCACHEFieldAndOffset( %+#20x, cjTotal);
    GetAndPrintCACHEFieldAndOffset( %+#20p, pbblBase);
    GetAndPrintCACHEFieldAndOffset( %+#20p, pbblCur);
    GetAndPrintCACHEFieldAndOffset( %+#20p, pgbNext);
    GetAndPrintCACHEFieldAndOffset( %+#20p, pgbThreshold);
    GetAndPrintCACHEFieldAndOffset( %+#20p, pjAuxCacheMem);
    GetAndPrintCACHEFieldAndOffset( %+#20x, cjAuxCacheMem);
    GetAndPrintCACHEFieldAndOffset( %+#20x, cjGlyphMax);
    GetAndPrintCACHEFieldAndOffset( %+#20x, bSmallMetrics);
    GetAndPrintCACHEFieldAndOffset( %+#20x, iMax);
    GetAndPrintCACHEFieldAndOffset( %+#20x, iFirst);
    GetAndPrintCACHEFieldAndOffset( %+#20x, cBits);
    dprintf("\n");

    #undef M3
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   cache
*
\**************************************************************************/

DECLARE_API( cache )
{
    PARSE_POINTER(cache_help);
    vDumpCACHE(arg);
    EXIT_API(S_OK);
cache_help:
    dprintf("Usage: cache [-?] CACHE pointer\n");
    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpLOGFONTW
*
* Arguments:
*
*   plfw    -- pointer to local copy of LOGFONTW,
*              dereferences are off of this address are safe
*   plfwSrc -- address of original on debug machine,
*              dereferences off of this address are not safe
*
* Return Value:
*
*   none
*
\**************************************************************************/

void vDumpLOGFONTW(ULONG64 offLOGFONTW)
{
#define N3(a,b,c) \
        dprintf( "[%p] %s", offLOGFONTW + offset, (a)); dprintf( (b), ##c )
    
    // LOGFONTW

    LONG      lfHeight;
    LONG      lfWidth;
    LONG      lfEscapement;
    LONG      lfOrientation;
    LONG      lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    WCHAR     lfFaceName[LF_FACESIZE];

    ULONG     offset;
    
    dprintf("\nLOGFONTW\n address\n --------\n" );
    
    GetLOGFONTWFieldAndOffset(lfHeight);
    N3( "lfHeight         " , "%d\n"    , lfHeight         );
    
    GetLOGFONTWFieldAndOffset(lfWidth);
    N3( "lfWidth          " , "%d\n"    , lfWidth          );

    GetLOGFONTWFieldAndOffset(lfEscapement);
    N3( "lfEscapement     " , "%d\n"    , lfEscapement     );

    GetLOGFONTWFieldAndOffset(lfOrientation);
    N3( "lfOrientation    " , "%d\n"    , lfOrientation    );

    GetLOGFONTWFieldAndOffset(lfWeight);
    N3( "lfWeight         " , "%d"      , lfWeight         );
    dprintf(" = %s\n", pszFW(lfWeight) );
    
    GetLOGFONTWFieldAndOffset(lfItalic);
    N3( "lfItalic         " , "0x%02x\n"  , lfItalic         );
    
    GetLOGFONTWFieldAndOffset(lfUnderline);
    N3( "lfUnderline      " , "0x%02x\n"  , lfUnderline      );
    
    GetLOGFONTWFieldAndOffset(lfStrikeOut);
    N3( "lfStrikeOut      " , "0x%02x\n"  , lfStrikeOut      );
    
    GetLOGFONTWFieldAndOffset(lfCharSet);
    N3( "lfCharSet        " , "0x%02x"    , lfCharSet        );
    dprintf(" = %s\n", pszCHARSET(lfCharSet));
    
    GetLOGFONTWFieldAndOffset(lfOutPrecision);
    N3( "lfOutPrecision   " , "0x%02x"    , lfOutPrecision   );
    dprintf(" = %s\n", pszOUT_PRECIS(lfOutPrecision ));
        
    GetLOGFONTWFieldAndOffset(lfClipPrecision);
    N3( "lfClipPrecision  " , "0x%02x"    , lfClipPrecision  );
    dprintf(" = %s\n", pszCLIP_PRECIS(lfClipPrecision));
        
    GetLOGFONTWFieldAndOffset(lfQuality);
    N3( "lfQuality        " , "0x%02x"    , lfQuality        );
    dprintf(" = %s\n", pszQUALITY(lfQuality));

    GetLOGFONTWFieldAndOffset(lfPitchAndFamily);
    N3( "lfPitchAndFamily " , "0x%02x"    , lfPitchAndFamily );
    dprintf(" = %s\n", pszPitchAndFamily(lfPitchAndFamily ) );

    GetLOGFONTWFieldAndOffset(lfFaceName);
    dprintf("[%p] lfFaceName       \"%ws\"\n", offLOGFONTW + offset, lfFaceName);
    dprintf("\n");
    
#undef N3
    
    return;
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpFONTDIFF
*
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
void vDumpFONTDIFF(FONTDIFF *p1/*copy*/ , FONTDIFF *p0 /* original */)
{

    #define N2(a,c)   dprintf("[%x] %s", &p0->##c, (a))
    #define N3(a,b,c) dprintf("[%x] %s", &p0->##c, (a)); dprintf((b),p1->##c)

    dprintf("\nFONTDIFF\n-------\n");
    N3("jReserved1      ", "0x%02x\n", jReserved1);
    N3("jReserved2      ", "0x%02x\n", jReserved2);
    N3("jReserved3      ", "0x%02x\n", jReserved3);
    N3("bWeight         ", "0x%02x", bWeight   );
    dprintf(" = %s\n", pszPanoseWeight(p1->bWeight));
    N3("usWinWeight     ", "%u"    , usWinWeight);
    dprintf(" = %s\n", pszFW(p1->usWinWeight));
    N3("fsSelection     ", "%-#x\n"  , fsSelection);
    for (FLAGDEF *pfd=afdFM_SEL; pfd->psz; pfd++) {
        if ((FLONG)p1->fsSelection & pfd->fl) {
            dprintf("                %s\n", pfd->psz);
        }
    }
    N3("fwdAveCharWidth ", "%d\n"    , fwdAveCharWidth);
    N3("fwdMaxCharInc   ", "%d\n"    , fwdMaxCharInc);
    N2("ptlCaret        ", ptlCaret);
    dprintf("%d %d\n", p1->ptlCaret.x, p1->ptlCaret.y);
    dprintf("\n");

    #undef N2
    #undef N3
}
#endif  // DOES NOT SUPPORT API64

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpIFIMETRICS
*
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
void vDumpIFIMETRICS(IFIMETRICS *p1, IFIMETRICS *p0)
{
    FLONG fl;
    FLAGDEF *pfd;

    #define GETPTR(p,a) ((void*)(((BYTE*)(p))+(a)))

    #define N2(a,c)   dprintf("[%x] %s", &p0->##c, (a))
    #define N3(a,b,c) dprintf("[%x] %s", &p0->##c, (a)); dprintf((b),p1->##c)

    dprintf("\nIFIMETICS\n address\n -------\n");
    N3("cjThis                ", "%u\n"    , cjThis                );
    N3("cjIfiExtra            ", "%u\n"    , cjIfiExtra            );
    N3("dpwszFamilyName       ", "%-#x"  ,  dpwszFamilyName        );
    dprintf(" \"%ws\"\n", GETPTR(p1,p1->dpwszFamilyName));
    N3("dpwszStyleName        ", "%-#x"  , dpwszStyleName          );
    dprintf(" \"%ws\"\n", GETPTR(p1,p1->dpwszStyleName));
    N3("dpwszFaceName         ", "%-#x"  , dpwszFaceName           );
    dprintf(" \"%ws\"\n", GETPTR(p1,p1->dpwszFaceName));
    N3("dpwszUniqueName       ", "%-#x"  , dpwszUniqueName         );
    dprintf(" \"%ws\"\n", GETPTR(p1,p1->dpwszUniqueName));
    N3("dpFontSim             ", "%-#x\n"  , dpFontSim             );
    N3("lEmbedId              ", "%-#x\n"  , lEmbedId              );
    N3("lItalicAngle          ", "%d\n"    , lItalicAngle          );
    N3("lCharBias             ", "%d\n"    , lCharBias             );
    N3("dpCharSets            ", "%-#x\n"  , dpCharSets            );

    if (p1->dpCharSets)
    {

        BYTE *pj0  = (BYTE *) GETPTR(p0,p1->dpCharSets);
        BYTE *pj1  = (BYTE *) GETPTR(p1,p1->dpCharSets);
        BYTE *pj1End = pj1 + 16; // number of charsets

        dprintf("    Supported Charsets: \n");
        for (; pj1 < pj1End; pj1++, pj0++)
            dprintf("[%x]\t\t\t%s\n", pj0, pszCHARSET(*pj1));
    }


    N3("jWinCharSet           ", "0x%02x", jWinCharSet           );
    dprintf(" %s\n", pszCHARSET(p1->jWinCharSet));

    N3("jWinPitchAndFamily    ", "0x%02x", jWinPitchAndFamily    );
    dprintf(" %s\n", pszPitchAndFamily(p1->jWinPitchAndFamily));


    N3("usWinWeight           ", "%u"    , usWinWeight           );
    dprintf(" %s\n", pszFW(p1->usWinWeight));

    N3("flInfo                ", "%-#x\n"  , flInfo                );
    for (fl=p1->flInfo,pfd=afdInfo;pfd->psz;pfd++) {
        if (fl & pfd->fl) {
            dprintf("                      %s\n", pfd->psz);
        }
    }

    N3("fsSelection           ", "%-#x\n"  , fsSelection           );
    for (fl = p1->fsSelection, pfd = afdFM_SEL; pfd->psz; pfd++) {
        if (fl & pfd->fl) {
            dprintf("                      %s\n", pfd->psz);
        }
    }

    N3("fsType                ", "%-#x\n"  , fsType                );
    for (fl=p1->fsType, pfd=afdFM_TYPE; pfd->psz; pfd++) {
        if (fl & pfd->fl) {
            dprintf("                      %s\n", pfd->psz);
        }
    }

    N3("fwdUnitsPerEm         ", "%d\n"    , fwdUnitsPerEm         );
    N3("fwdLowestPPEm         ", "%d\n"    , fwdLowestPPEm         );
    N3("fwdWinAscender        ", "%d\n"    , fwdWinAscender        );
    N3("fwdWinDescender       ", "%d\n"    , fwdWinDescender       );
    N3("fwdMacAscender        ", "%d\n"    , fwdMacAscender        );
    N3("fwdMacDescender       ", "%d\n"    , fwdMacDescender       );
    N3("fwdMacLineGap         ", "%d\n"    , fwdMacLineGap         );
    N3("fwdTypoAscender       ", "%d\n"    , fwdTypoAscender       );
    N3("fwdTypoDescender      ", "%d\n"    , fwdTypoDescender      );
    N3("fwdTypoLineGap        ", "%d\n"    , fwdTypoLineGap        );
    N3("fwdAveCharWidth       ", "%d\n"    , fwdAveCharWidth       );
    N3("fwdMaxCharInc         ", "%d\n"    , fwdMaxCharInc         );
    N3("fwdCapHeight          ", "%d\n"    , fwdCapHeight          );
    N3("fwdXHeight            ", "%d\n"    , fwdXHeight            );
    N3("fwdSubscriptXSize     ", "%d\n"    , fwdSubscriptXSize     );
    N3("fwdSubscriptYSize     ", "%d\n"    , fwdSubscriptYSize     );
    N3("fwdSubscriptXOffset   ", "%d\n"    , fwdSubscriptXOffset   );
    N3("fwdSubscriptYOffset   ", "%d\n"    , fwdSubscriptYOffset   );
    N3("fwdSuperscriptXSize   ", "%d\n"    , fwdSuperscriptXSize   );
    N3("fwdSuperscriptYSize   ", "%d\n"    , fwdSuperscriptYSize   );
    N3("fwdSuperscriptXOffset ", "%d\n"    , fwdSuperscriptXOffset );
    N3("fwdSuperscriptYOffset ", "%d\n"    , fwdSuperscriptYOffset );
    N3("fwdUnderscoreSize     ", "%d\n"    , fwdUnderscoreSize     );
    N3("fwdUnderscorePosition ", "%d\n"    , fwdUnderscorePosition );
    N3("fwdStrikeoutSize      ", "%d\n"    , fwdStrikeoutSize      );
    N3("fwdStrikeoutPosition  ", "%d\n"    , fwdStrikeoutPosition  );
    N3("chFirstChar           ", "0x%02x\n", chFirstChar           );
    N3("chLastChar            ", "0x%02x\n", chLastChar            );
    N3("chDefaultChar         ", "0x%02x\n", chDefaultChar         );
    N3("chBreakChar           ", "0x%02x\n", chBreakChar           );
    N3("wcFirstChar           ", "%-#x\n"    , wcFirstChar           );
    N3("wcLastChar            ", "%-#x\n"    , wcLastChar            );
    N3("wcDefaultChar         ", "%-#x\n"    , wcDefaultChar         );
    N3("wcBreakChar           ", "%-#x\n"    , wcBreakChar           );
    N2("ptlBaseline           ", ptlBaseline);
        dprintf("%d %d\n", p1->ptlBaseline.x, p1->ptlBaseline.y);
    N2("ptlAspect             ", ptlAspect  );
        dprintf("%d %d\n", p1->ptlAspect.x, p1->ptlAspect.y);
    N2("ptlCaret              ", ptlCaret   );
        dprintf("%d %d\n", p1->ptlCaret.x, p1->ptlCaret.y);
    N2("rclFontBox            ", rclFontBox );
        dprintf("%d %d %d %d\n",
        p1->rclFontBox.left,
        p1->rclFontBox.top,
        p1->rclFontBox.right,
        p1->rclFontBox.bottom);
    N2("achVendId\n"        , achVendId[0]);
    N3("cKerningPairs         ", "%d\n"    , cKerningPairs         );
    N3("ulPanoseCulture       ", "%u\n"    , ulPanoseCulture       );
    N2("panose\n", panose);

    if (p1->dpFontSim) {
        FONTDIFF *pfd0, *pfd1;
        FONTSIM *pfs0 = (FONTSIM*) GETPTR(p0, p1->dpFontSim);
        FONTSIM *pfs1 = (FONTSIM*) GETPTR(p1, p1->dpFontSim);
        if (pfs1->dpBold) {
            pfd0 = (FONTDIFF*) GETPTR(pfs0, pfs1->dpBold);
            pfd1 = (FONTDIFF*) GETPTR(pfs1, pfs1->dpBold);
            dprintf("\nBold Simulation ");
            vDumpFONTDIFF(pfd1, pfd0);
        }
        if (pfs1->dpItalic) {
            pfd0 = (FONTDIFF*) GETPTR(pfs0, pfs1->dpItalic);
            pfd1 = (FONTDIFF*) GETPTR(pfs1, pfs1->dpItalic);
            dprintf("\nItalic Simulation ");
            vDumpFONTDIFF(pfd1, pfd0);
        }
        if (pfs1->dpBoldItalic) {
            pfd0 = (FONTDIFF*) GETPTR(pfs0, pfs1->dpBoldItalic);
            pfd1 = (FONTDIFF*) GETPTR(pfs1, pfs1->dpBoldItalic);
            dprintf("\nBold Italic Simulation ");
            vDumpFONTDIFF(pfd1, pfd0);
        }
    }

    if (p1->cjIfiExtra)
    {
        // #define GETIFIEX(a) ((ULONG)p1 + sizeof(IFIMETRICS) + offsetof(IFIEXTRA,##a))

        dprintf("\nIFIEXTRA\n -------\n");
        IFIEXTRA *pifiex = (IFIEXTRA *)(p1 + 1);
        if (p1->cjIfiExtra > offsetof(IFIEXTRA,ulIdentifier))
            dprintf("ulIdentifier:   0x%x\n", pifiex->ulIdentifier);
        if (p1->cjIfiExtra > offsetof(IFIEXTRA,dpFontSig))
            dprintf("dpFontSig:      0x%x\n", pifiex->dpFontSig);
        if (p1->cjIfiExtra > offsetof(IFIEXTRA,cig))
            dprintf("cig:            %u\n", pifiex->cig);
        if (p1->cjIfiExtra > offsetof(IFIEXTRA,dpDesignVector))
            dprintf("dpDesignVector: 0x%x\n", pifiex->dpDesignVector);
        if (p1->cjIfiExtra > offsetof(IFIEXTRA,dpAxesInfoW))
            dprintf("dpAxesInfoW:    0x%x\n", pifiex->dpAxesInfoW);

        dprintf("\n -------\n");
    }

    dprintf("\n");

    #undef N3
    #undef N2
}
#endif  // DOES NOT SUPPORT API64

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   pff
*
\**************************************************************************/


DECLARE_API( pff )
{
    dprintf("Extension 'pff' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    PFF *pPFFCopy, *pPFFSrc;
    ULONG size;
    
    PARSE_POINTER(pff_help);
    pPFFSrc = (PFF *)arg;
    move(size,&pPFFSrc->sizeofThis);
    if (pPFFCopy = tmalloc(PFF, size)) {
        move2(pPFFCopy, pPFFSrc, size);
        PFFOBJ pffo(pPFFCopy);
        pPFFCopy->pwszPathname_ = pffo.pwszCalcPathname();
        vDumpPFF(pPFFCopy,pPFFSrc);
        tfree(pPFFCopy);
    } else
        dprintf("could not allocate memory\n");
    return;
pff_help:
    dprintf("Usage: pff [-?] PFF pointer\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpPFF
*
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
void vDumpPFF(PFF *p1 /*copy*/, PFF *p0 /*original*/)
{
    ULONG iFile;
    PWSZ  pwszSrc, pwszDest;

    #define N2(a,c)   dprintf("[%x] %s", &p0->##c, (a))
    #define N3(a,b,c) dprintf("[%x] %s", &p0->##c, (a)); dprintf((b),p1->##c)

    N3("sizeofThis    ", "%u\n", sizeofThis);
    N3("pPFFNext      ", "%-#x\n", pPFFNext);
    N3("pPFFPrev      ", "%-#x\n", pPFFPrev);

    if (p1->hff != HFF_INVALID) // if not device font
    {
    N2("pwszPathname_ ", pwszPathname_);
    move( pwszSrc, &p0->pwszPathname_ );
    pwszDest = wcsncpy((PWSZ) adw,  pwszSrc, sizeof(adw)/sizeof(WCHAR));
    if ( pwszDest )
    {
        dprintf("%-#x = \"%ws\"\n", pwszSrc, (PWSZ) adw );
    }
    else
    {
        dprintf("\n");
    }
    }

    N3("flState       ", "%-#x\n", flState);
    for (FLAGDEF *pfd = afdPFF; pfd->psz; pfd++) {
        if (p1->flState & pfd->fl) {
            dprintf("              %s\n", pfd->psz);
        }
    }
    N3("cwc           ", "%u\n", cwc);
    N3("cFiles        ", "%u\n", cFiles);
    N3("cLoaded       ", "%u\n", cLoaded);
    N3("cNotEnum      ", "%u\n", cNotEnum);
    N3("cRFONT        ", "%u\n", cRFONT);
    N3("prfntList     ", "%-#x\n", prfntList);
    N3("hff           ", "%-#x\n", hff);
    N3("hdev          ", "%-#x\n", hdev);
    N3("dhpdev        ", "%-#x\n", dhpdev);
    N3("pfhFace       ", "%-#x\n", pfhFace);
    N3("pfhFamily     ", "%-#x\n", pfhFamily);
    N3("pfhUFI        ", "%-#x\n", pfhUFI);
    N3("pPFT          ", "%-#x\n", pPFT);
    N3("ulCheckSum    ", "%-#x\n", ulCheckSum);
    N3("cFonts        ", "%u\n", cFonts);
    N3("ppfv          ", "%-#x\n", ppfv);
    N3("pPvtDataHead  ", "%-#x\n", pPvtDataHead);
    dprintf("\n\n");

    #undef N3
    #undef N2
}

///******************************Public*Routine******************************\
//*
//* Routine Name:
//*
//*   vDumpFONTHASH
//*
//\**************************************************************************/
//
//void vDumpFONTHASH(FONTHASH *p1 /*copy*/,FONTHASH *p0 /*org*/)
//{
//    #define N2(a,c)   dprintf("[%x] %s", &p0->##c, (a))
//    #define N3(a,b,c) dprintf("[%x] %s", &p0->##c, (a)); dprintf((b),p1->##c)
//
//    dprintf("\nFONTHASH\n");
//    N3("id            ", "%4x\n", id);
//    N3("fht           ", "%d",    fht);
//    dprintf(" = %s\n", pszFONTHASHTYPE(p1->fht));
//    N3("cBuckets      ", "%u\n", cBuckets);
//    N3("cCollisions   ", "%u\n", cCollisions);
//    N3("pbktFirst     ", "%-#x\n", pbktFirst);
//    N3("pbktLast      ", "%-#x\n", pbktLast);
//    N3("apbkt         ", "%-#x\n", apbkt);
//
//    #undef N3
//   #undef N2
//}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpHASHBUCKET
*
\**************************************************************************/

void vDumpHASHBUCKET(HASHBUCKET *p1 /*copy*/, HASHBUCKET *p0 /*org*/)
{
    #define N2(a,c)   dprintf("[%x] %s", &p0->##c, (a))
    #define N3(a,b,c) dprintf("[%x] %s", &p0->##c, (a)); dprintf((b),p1->##c)

    dprintf("\nHASHBUCKET\n");
    N3("pbktCollision   ", "%-#x\n", pbktCollision);
    N3("ppfelEnumHead   ", "%-#x\n", ppfelEnumHead);
    N3("ppfelEnumTail   ", "%-#x\n", ppfelEnumTail);
    N3("cTrueType       ", "%u\n",   cTrueType);
    N3("fl              ", "%-#x\n", fl);
    N3("pbktPrev        ", "%-#x\n", pbktPrev);
    N3("pbktNext        ", "%-#x\n", pbktNext);
    N3("ulTime          ", "%u\n",   ulTime);
    N2("u\n", u);

    N2("u.wcCapName     ", u.wcCapName);
    wcscpy((PWSZ) adw, p1->u.wcCapName);
    dprintf("\"%ws\"\n", adw);

    N2("u.ufi\n", u.ufi);
    N3("u.ufi.CheckSum  ", "%-#x\n", u.ufi.CheckSum);
    N3("u.ufi.Index     ", "%u\n",   u.ufi.Index);



    {

        dprintf("\n");

        {
            PFELINK *ppfel = p1->ppfelEnumHead;
            PFELINK  pfelLocal;

            PFE LocalPFE;

            if (ppfel)
            {
                dprintf("PFE*\n");
                while (ppfel)
                {
                    move(pfelLocal, ppfel);
                    dprintf("%-#x", pfelLocal.ppfe);
                    move(LocalPFE,pfelLocal.ppfe);

                    if (LocalPFE.pPFF)
                    {
                        PFF LocalPFF;
                        WCHAR awc[MAX_PATH];

                        move(LocalPFF, LocalPFE.pPFF);
                        wcsncpy( awc, LocalPFF.pwszPathname_, MAX_PATH);
                        awc[MAX_PATH-1]=0;
                        dprintf(" \"%ws\"", awc);
                    }

                    if (LocalPFE.pifi)
                    {
                        ULONG dp;
                        WCHAR awc[LF_FACESIZE+1];
                        PWSZ pwszSrc;
                        FWORD fwdAscender, fwdDescender, fwdWidth;

                        move(dp,&((LocalPFE.pifi)->dpwszFaceName));
                        pwszSrc = (PWSZ)(((char*) (LocalPFE.pifi)) + dp);
                        wcsncpy(awc, pwszSrc, LF_FACESIZE);
                        awc[LF_FACESIZE] = 0;
                        dprintf(" \"%ws\"", awc);

                        move(fwdAscender, &LocalPFE.pifi->fwdWinAscender);
                        move(fwdDescender, &LocalPFE.pifi->fwdWinDescender);
                        move(fwdWidth, &LocalPFE.pifi->fwdAveCharWidth);

                        dprintf(" %4d %4d %4d", fwdAscender, fwdDescender, fwdWidth);

                    }

                    dprintf("\n");

                    ppfel = pfelLocal.ppfelNext;
                }
            }
        }
    }

    #undef N3
    #undef N2
}

void vDumpTEXTMETRICW(TEXTMETRICW *ptmLocal, TEXTMETRICW *ptmRemote)
{
    #define N3(a,b,c) dprintf("[%x] %s", &ptmRemote->##c, (a)); dprintf((b),ptmLocal->##c)

    dprintf("\nTEXTMETRICW\n");
    N3("tmHeight            ", "%d\n",    tmHeight           );
    N3("tmAscent            ", "%d\n",    tmAscent           );
    N3("tmDescent           ", "%d\n",    tmDescent          );
    N3("tmInternalLeading   ", "%d\n",    tmInternalLeading  );
    N3("tmExternalLeading   ", "%d\n",    tmExternalLeading  );
    N3("tmAveCharWidth      ", "%d\n",    tmAveCharWidth     );
    N3("tmMaxCharWidth      ", "%d\n",    tmMaxCharWidth     );
    N3("tmWeight            ", "%d\n",    tmWeight           );
    N3("tmOverhang          ", "%d\n",    tmOverhang         );
    N3("tmDigitizedAspectX  ", "%d\n",    tmDigitizedAspectX );
    N3("tmDigitizedAspectY  ", "%d\n",    tmDigitizedAspectY );
    N3("tmFirstChar         ", "%-#6x\n", tmFirstChar        );
    N3("tmLastChar          ", "%-#6x\n", tmLastChar         );
    N3("tmDefaultChar       ", "%-#6x\n", tmDefaultChar      );
    N3("tmBreakChar         ", "%-#6x\n", tmBreakChar        );
    N3("tmItalic            ", "%-#4x\n", tmItalic           );
    N3("tmUnderlined        ", "%-#4x\n", tmUnderlined       );
    N3("tmStruckOut         ", "%-#4x\n", tmStruckOut        );
    N3("tmPitchAndFamily    ", "%-#4x\n", tmPitchAndFamily   );
    N3("tmCharSet           ", "%-#4x\n", tmCharSet          );

    dprintf("\n");
    #undef N3
}

void vDumpTMDIFF(TMDIFF *ptmdLocal, TMDIFF *ptmdRemote)
{
    #define N3(a,b,c) dprintf("[%x] %s", &ptmdRemote->##c, (a)); dprintf((b),ptmdLocal->##c)

    dprintf("\nTMDIFF\n");
    N3("cjotma              ", "%u\n",    cjotma             );
    N3("chFirst             ", "%-#4x\n", chFirst            );
    N3("chLast              ", "%-#4x\n", chLast             );
    N3("chDefault           ", "%-#4x\n", chDefault          );
    N3("chBreak             ", "%-#4x\n", chBreak            );

    dprintf("\n");
    #undef N3
}
#endif 0   // DOES NOT SUPPORT API64

DECLARE_API( tmwi )
{
    dprintf("Extension 'tmwi' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    TMW_INTERNAL tmwi, *ptmwi;
   
    PARSE_POINTER(tmwi_help);
    ptmwi = (TMW_INTERNAL *)arg;
    move(tmwi, ptmwi);
    vDumpTEXTMETRICW(&tmwi.tmw, &ptmwi->tmw);
    vDumpTMDIFF(&tmwi.tmdTmw, &ptmwi->tmdTmw);
    return;
tmwi_help:
    dprintf("Usage: tmwi [-?] TMW_INTERNAL pointer\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

DECLARE_API( tm )
{
    dprintf("Extension 'tm' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    TEXTMETRICW tm;
    PARSE_POINTER(tm_help);
    move(tm, arg);
    vDumpTEXTMETRICW(&tm, (TEXTMETRICW*) arg);
    return;
tm_help:
    dprintf("Usage: tm [-?] TEXTMETRIC pointer\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   fh
*
\**************************************************************************/

DECLARE_API( fh )
{
    dprintf("Extension 'fh' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    FONTHASH fh;
    PARSE_POINTER(fh_help);
    move(fh, arg);
    vDumpFONTHASH( &fh, (FONTHASH*) arg);
    return;
fh_help:
    dprintf("Usage: fh [-?] FONTHASH pointer\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   hb
*
\**************************************************************************/

DECLARE_API( hb )
{
    dprintf("Extension 'hb' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    HASHBUCKET hb;
    PARSE_POINTER(hb_help);
    move(hb, arg);
    vDumpHASHBUCKET(&hb, (HASHBUCKET*) arg);
    return;
hb_help:
    dprintf("Usage: hb [-?] HASHBUCKET pointer\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   cjGLYPHBITS
*
* Routine Description:
*
*   Calculates the amount of memory associated with a GLYPHBITS structure
*
* Arguments:
*
*   pgb     pointer to GLYPHBITS structure
*   prf     pointer to RFONT
*
* Return Value:
*
*   count of byte's
*
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
unsigned cjGLYPHBITS(GLYPHBITS *pgb, RFONT *prf)
{
    unsigned cj = 0;
    if (pgb) {
        if (prf->ulContent & FO_GLYPHBITS) {
            cj = offsetof(GLYPHBITS, aj);
            cj = (cj + 3) & ~3;
            unsigned cjRow = pgb->sizlBitmap.cx;
            if (prf->fobj.flFontType & FO_GRAY16)
                cjRow = (cjRow+1)/2;
            else
                cjRow = (cjRow+7)/8;
            cj += pgb->sizlBitmap.cy * cjRow;
            cj = (cj + 3) & ~3;
        }
    }
    return( cj );
}
#endif 0   // DOES NOT SUPPORT API64

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpGlyphMemory
*
* Routine Description:
*
*   Dumps the memory usage for the glyphs associated with an RFONT
*
* Arguments:
*
*   pRemoteRFONT        pointer to a remote RFONT
*
* Return Value:
*
*   none
*
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
void vDumpGlyphMemory(RFONT *pRemoteRFONT)
{
    unsigned cj;
    if (!pRemoteRFONT)
        return;
    RFONT rf;
    move(rf, pRemoteRFONT);
    if ( rf.wcgp ) {
        WCGP wcgp;
        move(wcgp, rf.wcgp);
        cj = offsetof(WCGP,agpRun[0]) + wcgp.cRuns * sizeof(GPRUN);
        WCGP *pWCGP;
        if ( pWCGP = tmalloc(WCGP, cj) ) {
            move2(pWCGP, rf.wcgp, cj);
            dprintf("------------------\n");
            dprintf("character     size\n");
            dprintf("------------------\n");
            GPRUN *pRun = pWCGP->agpRun;
            GPRUN *pRunSentinel = pRun + pWCGP->cRuns;
            for (; pRun < pRunSentinel ; pRun++ ) {
                if (!pRun->apgd)
                    continue;
                cj = sizeof(GLYPHDATA*) * pRun->cGlyphs;
                GLYPHDATA **apgd;
                if (!(apgd = tmalloc(GLYPHDATA*, cj)))
                    continue;
                move2(apgd, pRun->apgd, cj);
                unsigned wc = pRun->wcLow;
                unsigned wcSentinel = wc + pRun->cGlyphs;
                GLYPHDATA **ppgd = apgd;
                for (; wc < wcSentinel; wc++, ppgd++) {
                    if (!*ppgd)
                        continue;
                    GLYPHDEF gdf;
                    move(gdf, &((*ppgd)->gdf));
                    if (gdf.pgb) {
                        GLYPHBITS gb;
                        move(gb, gdf.pgb);
                        cj = cjGLYPHBITS(&gb, &rf);
                        dprintf("%-#8x  %8u\n", wc, cj);
                    }
                }
                tfree(apgd);
            }
            dprintf("------------------\n");


            tfree(pWCGP);
        }
    }
}
#endif  // DOES NOT SUPPORT API64

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   pdev
*
* Routine Description:
*
*   Alternate version of PDEV dumper
*
* Arguments:
*
* Return Value:
*
*   none
*
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
char *pszDrvProcName(int index);

DECLARE_API( pdev )
{
    dprintf("Extension 'pdev' is not converted.\n");
    PDEV _pdev, *pPDEV;
    RFONT rf, *prf;
    CACHE cache;
    BOOL HookFn=FALSE;
    BOOL GlyphMem=FALSE;
    BOOL MemAddr=FALSE;

    PARSE_POINTER(pdev_help);
    pPDEV = (PDEV *)arg;

    if(parse_iFindSwitch(tokens, ntok, 'y')!=-1) {GlyphMem=TRUE;}
    if(parse_iFindSwitch(tokens, ntok, 'o')!=-1) {MemAddr=TRUE;}
    if(parse_iFindSwitch(tokens, ntok, 'f')!=-1) {HookFn=TRUE;}

    move( _pdev, arg );

    if (GlyphMem) {
        dprintf("\n\nGlyph Bits Memory Allocation\n\n");

        dprintf("cMetrics, cGlyphs, cjTotal, Total/Max, cBlocks,  Ht, Wd, cjGlyphMax, FaceName\n");

        unsigned cTouchedTotal, cAllocTotal, cjWastedTotal, cjAllocTotal;
        cTouchedTotal = cAllocTotal = cjWastedTotal = cjAllocTotal = 0;
        dprintf("[Active Fonts]\n");
        vDumpRFONTList(
            _pdev.prfntActive,
            &cTouchedTotal,
            &cAllocTotal,
            &cjWastedTotal,
            &cjAllocTotal
            );
        dprintf("[Inactive Fonts]\n");
        vDumpRFONTList(
            _pdev.prfntInactive,
            &cTouchedTotal,
            &cAllocTotal,
            &cjWastedTotal,
            &cjAllocTotal
            );
    }

    //
    // offsets
    //

    if (MemAddr)
    {
    #define N2(a,c)   dprintf("[%x] %s\n", &pPDEV->##c, (a))
    #define N3(a,b,c) dprintf("[%x] %s", &pPDEV->##c, (a)); dprintf((b),_pdev.##c)

    N3( "                  hHmgr ", "%-#x\n", hHmgr                   );
    N3( "         cExclusiveLock ", "%-#x\n", cExclusiveLock          );
    N3( "                    Tid ", "%-#x\n", Tid                     );
    N3( "              ppdevNext ", "%-#x\n", ppdevNext               );
    N3( "              cPdevRefs ", "%-#x\n", cPdevRefs               );
    N3( "  pfnDrvSetPointerShape ", "%-#x\n", pfnDrvSetPointerShape   );
    N3( "      pfnDrvMovePointer ", "%-#x\n", pfnDrvMovePointer       );
    N3( "         pfnMovePointer ", "%-#x\n", pfnMovePointer          );
    N3( "                pfnSync ", "%-#x\n", pfnSync                 );
    N3( "                  pldev ", "%-#x\n", pldev                   );
    N3( "                 dhpdev ", "%-#x\n", dhpdev                  );
    N3( "               ppalSurf ", "%-#x\n", ppalSurf                );
    N2( "                devinfo ",           devinfo                 );
    N2( "                GdiInfo ",           GdiInfo                 );
    N3( "               pSurface ", "%-#x\n", pSurface                );
    N3( "               hSpooler ", "%-#x\n", hSpooler                );
    N2( "              ptlOrigin ",           ptlOrigin               );
    N2( "      eDirectDrawGlobal ",           eDirectDrawGlobal       );
    N3( "            ppdevParent ", "%-#x\n", ppdevParent             );
    N3( "                     fl ", "%-#x\n", fl                      );
    N3( "            hsemDevLock ", "%-#x\n", hsemDevLock             );
    N2( "            hsemPointer ",           hsemPointer             );
    N2( "             ptlPointer ",           ptlPointer              );
    N3( "           hlfntDefault ", "%-#x\n", hlfntDefault            );
    N3( "      hlfntAnsiVariable ", "%-#x\n", hlfntAnsiVariable       );
    N3( "         hlfntAnsiFixed ", "%-#x\n", hlfntAnsiFixed          );
    N2( "                 ahsurf ",           ahsurf                  );
    N3( "           pwszDataFile ", "%-#x\n", pwszDataFile            );
    N3( "             pDevHTInfo ", "%-#x\n", pDevHTInfo              );
    N3( "            prfntActive ", "%-#x\n", prfntActive             );
    N3( "          prfntInactive ", "%-#x\n", prfntInactive           );
    N3( "              cInactive ", "%-#x\n", cInactive               );
    N2( "                   ajbo ",           ajbo                    );
    N3( "cDirectDrawDisableLocks ", "%-#x\n", cDirectDrawDisableLocks );
    N3( "            TypeOneInfo ", "%-#x\n", TypeOneInfo             );
    N3( "          RemoteTypeOne ", "%-#x\n", RemoteTypeOne           );
    N2( "                   apfn ",           apfn                    );

    #undef N3
    #undef N2
    }

    if (HookFn)
    {
        dprintf("\nDispatch Table\n");

        for (int i = 0; i < INDEX_LAST; i++)
        {
            if (_pdev.apfn[i])
            {
                dprintf("[%-#x] %-#10x %s\n", &(pPDEV->apfn[i]), _pdev.apfn[i], pszDrvProcName(i));
            }
        }
        dprintf("\n");
    }
    return;
pdev_help:
    dprintf("Usage: pdev [-?] [-o] [-f] [-y] pointer to a PDEV\n");
    dprintf("-y     glyph memory usage\n");
    dprintf("-o     memory addresses\n");
    dprintf("-f     functions hooked\n");
    EXIT_API(S_OK);
}
#endif  // DOES NOT SUPPORT API64


DECLARE_API( fdm )
{
    dprintf("Extension 'fdm' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    FD_DEVICEMETRICS Fdm, *pFdm;
    FLONG fl;
    char ach[128], *psz;
    FLAGDEF *pfd;

    PARSE_POINTER(fdm_help);
    pFdm = (FD_DEVICEMETRICS *)arg;
    move( Fdm, arg );

    #define N2(a,c)   dprintf("[%x] %s", &pFdm->##c, (a))
    #define N3(a,b,c) dprintf("[%x] %s", &pFdm->##c, (a)); dprintf((b),Fdm.##c)

    N3("flRealizedType         ", "%-#x\n", flRealizedType);
    fl = Fdm.flRealizedType;
    for (pfd=afdFDM; pfd->psz; pfd++) {
        if (pfd->fl & fl)
            dprintf("\t\t\t       %s\n", pfd->psz);
        fl &= ~pfd->fl;
    }

    N2("pteBase                ", pteBase);
    psz = ach;
    psz += sprintFLOATL( psz, Fdm.pteBase.x );
    *psz++ = ' ';
    psz += sprintFLOATL( psz, Fdm.pteBase.y );
    dprintf("%s\n", ach);

    N2("pteSide                ", pteSide);
    psz = ach;
    psz += sprintFLOATL( psz, Fdm.pteSide.x );
    *psz++ = ' ';
    psz += sprintFLOATL( psz, Fdm.pteSide.y );
    dprintf("%s\n", ach);

    N3("lD                     ", "%d\n", lD);
    N3("fxMaxAscender          ", "%-#x\n", fxMaxAscender);
    N3("fxMaxDescender         ", "%-#x\n", fxMaxDescender);

    N2("ptlUnderline1          ", ptlUnderline1);
    dprintf("%d %d\n", Fdm.ptlUnderline1.x, Fdm.ptlUnderline1.y);

    N2("ptlStrikeOut           ", ptlStrikeOut );
    dprintf("%d %d\n", Fdm.ptlStrikeOut.x,  Fdm.ptlStrikeOut.y );

    N2("ptlULThickness         ", ptlULThickness);
    dprintf("%d %d\n", Fdm.ptlULThickness.x, Fdm.ptlULThickness.y);

    N2("ptlSOThickness         ", ptlSOThickness);
    dprintf("%d %d\n", Fdm.ptlSOThickness.x, Fdm.ptlSOThickness.y);

    N3("cxMax                  ", "%-#x\n", cxMax);
    N3("cyMax                  ", "%-#x\n", cyMax);
    N3("cjGlyphMax             ", "%-#x\n", cjGlyphMax);

    N2("fdxQuantized           ", fdxQuantized);
    psz = ach;
    psz += sprintFLOATL( psz, Fdm.fdxQuantized.eXX );
    *psz++ = ' ';
    psz += sprintFLOATL( psz, Fdm.fdxQuantized.eXY );
    dprintf("%s\n", ach);
    psz = ach;
    psz += sprintFLOATL( psz, Fdm.fdxQuantized.eYX );
    *psz++ = ' ';
    psz += sprintFLOATL( psz, Fdm.fdxQuantized.eYY );
    dprintf("\t\t\t\t  %s\n", ach);

    N3("lNonLinearExtLeading   ", "%-#x\n", lNonLinearExtLeading);
    N3("lNonLinearIntLeading   ", "%-#x\n", lNonLinearIntLeading);
    N3("lNonLinearMaxCharWidth ", "%-#x\n", lNonLinearMaxCharWidth);
    N3("lNonLinearAvgCharWidth ", "%-#x\n", lNonLinearAvgCharWidth);
    N3("lMinA                  ", "%-#x\n", lMinA );
    N3("lMinC                  ", "%-#x\n", lMinC );
    N3("lMinD                  ", "%-#x\n", lMinD );
    N3("alReserved[0]          ", "%-#x\n", alReserved[0]);


    /*
    FLONG  flRealizedType
   POINTE  pteBase
   POINTE  pteSide
     LONG  lD
      FIX  fxMaxAscender
      FIX  fxMaxDescender
   POINTL  ptlUnderline1
   POINTL  ptlStrikeOut
   POINTL  ptlULThickness
   POINTL  ptlSOThickness
    ULONG  cxMax;
    ULONG  cyMax;
    ULONG  cjGlyphMax;
 FD_XFORM  fdxQuantized
     LONG  lNonLinearExtLeading
     LONG  lNonLinearIntLeading
     LONG  lNonLinearMaxCharWidth
     LONG  lNonLinearAvgCharWidth
     LONG  lMinA
     LONG  lMinC
     LONG  lMinD
     LONG  alReserved
     */

    #undef N3
    #undef N2
    return;
fdm_help:
    dprintf("Usage: fdm [-?] pointer to FD_DEVICEMETRICS structure.\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpRFONTList
*
* Routine Description:
*
*   Dump the memory allocation information for the RFONT structures
*   along the linked list.
*
* Arguments:
*
* Return Value:
*
*   none
*
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
void vDumpRFONTList(
    RFONT *prfRemote,
    unsigned *pcTouchedTotal,
    unsigned *pcAllocTotal,
    unsigned *pcjWastedTotal,
    unsigned *pcjAllocTotal
    )
{

    RFONT rf, *prf;

    for (prf = prfRemote; prf; prf = rf.rflPDEV.prfntNext) {
        move( rf, prf );
        if (rf.ppfe) {
            PFE _pfe;
            move(_pfe, rf.ppfe);
            if (_pfe.pifi) {
                unsigned cjIFI;
                move(cjIFI, &(_pfe.pifi->cjThis));
                if (cjIFI) {
                    IFIMETRICS *pifi;
                    if (pifi = tmalloc(IFIMETRICS, cjIFI)) {
                        // Create an IFIOBJ to get the face name
                        // out of the IFIMETRICS structure
                        move2(pifi, (_pfe.pifi), cjIFI);
                        IFIOBJ ifio(pifi);

                        dprintf("%8d, %5d,%8d,%8d,%8d,%8d,%4d,%4d,%ws\n",
                           rf.cache.cMetrics,
                           rf.cache.cGlyphs,
                           rf.cache.cjTotal,
                           (rf.cache.cjTotal + rf.cache.cjGlyphMax/2) / rf.cache.cjGlyphMax,
                           rf.cache.cBlocks,
                           rf.lMaxHeight, rf.cxMax,
                           rf.cache.cjGlyphMax,
                           ifio.pwszFaceName()
                           );
                        tfree(pifi);
                    }
                }
            }
        }
    }
}
#endif 0   // DOES NOT SUPPORT API64

DECLARE_API ( dispcache )
{
    dprintf("Extension 'dispcache' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    PDEV *pPDEV;
    char ach[32];
    PARSE_ARGUMENTS(dispcache_help);
    GetValue( pPDEV, "win32k!ghdev");
    sprintf(ach, "-y %p", pPDEV);
    pdev( hCurrentProcess, hCurrentThread, dwCurrentPc, dwProcessor, ach );
    return;
dispcache_help:
    dprintf("Usage: dispcache [-?]\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}

DECLARE_API ( xo )
{
    dprintf("Extension 'xo' is not converted.\n");
    dprintf("Use 'dt win32k!EXFORMOBJ Address' and '!gdikdx.mx Matrix_Address'\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    EXFORMOBJ xo, *pxo;
    MATRIX mx;
    
    PARSE_POINTER(xo_help);
    pxo = (EXFORMOBJ *)arg;
    move(xo, pxo);
    dprintf("EXFORMOBJ\n");
    dprintf("[%8x]  %8x\n", &pxo->pmx, xo.pmx);
    dprintf("[%8x]  %8x\n", &pxo->ulMode, xo.ulMode);
    if ( xo.pmx ) {
        move( mx, xo.pmx );
        vDumpMATRIX( &mx, xo.pmx );
    }
    return;
xo_help:
    dprintf("Usage: xo [-?] EXFORMOBJ pointer\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\help.cxx ===
/******************************Module*Header*******************************\
* Module Name: help.cxx
*
* Display the help information for gdiexts
*
* Created: 16-Feb-1995
* Author: Lingyun Wang [lingyunw]
*
* Copyright (c) 1995-2000 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* help
*
* Prints a simple help summary of the debugging extentions.
*
* History:
*  05-May-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

//
// Debugger extention help.  If you add any debugger extentions, please
// add a brief description here.  Thanks!
//

char *szHelp = 
"=======================================================================\n"
"GDIEXTS server debugger extentions:\n"
"-----------------------------------------------------------------------\n"
"\n"
"help                                     -- Displays this help page.\n"
"\n"
"All of the debugger extensions support a -? option for extension\n"
" specific help.\n"
"All of the debugger extensions that expect a pointer (or handle)\n"
" can parse expressions such as:\n"
"    ebp+8\n"
" or\n"
"    win32k!gpentHmgr\n"
"\n"
"Switches are case insensitive and can be reordered unless otherwise\n"
"specified in the extension help.\n"
"\n"
"  - general extensions -\n"
"\n"
"dumphmgr                                 -- handle manager objects\n"
//"dumpdd                                   -- DirectDraw: handle manager objects\n"
"dumpobj      [-p pid] [type]             -- all objects of specific type\n"
"dh           <GDI HANDLE>                -- HMGR entry of handle\n"
"dht          <GDI HANDLE>                -- handle type/uniqueness/index\n"
"dldev        [LDEV ptr]                  -- LDEV\n"
"dgdev        [-clr | GRAPHICS_DEVICE]    -- GRAPHICS_DEVICE list\n"
"dfloat       [-l num] Value              -- Dump an IEEE float or float array\n"
"dblt         [BLTRECORD ptr]             -- BLTRECORD\n"
//"dddsurface   [EDD_SURFACE ptr]           -- EDD_SURFACE\n"
//"dddlocal     [EDD_DIRECTDRAW_LOCAL ptr]  -- EDD_DIRECTDRAW_LOCAL\n"
//"dddglobal    [EDD_DIRECTDRAW_GLOBAL ptr] -- EDD_DIRECTDRAW_GLOBAL\n"
"rgnlog       nnn                         -- last nnn rgnlog entries\n"
"stats                                    -- accumulated statistics\n"
"verifier                                 -- Dump verifier information\n"
"\n"
"\n"
"  - type dump extensions -\n"
"\n"
"dt           <Type> <Offset>              -- GDI Type Dump w/ flag/enums\n"
"bltinfo      <BLTINFO Address>            -- BLTINFO\n"
"blendobj     <BLENDOBJ Address>           -- BLENDOBJ\n"
"brush        <BRUSH Address | HBRUSH>     -- BRUSH\n"
"brushobj     <BRUSHOBJ Address>           -- BRUSHOBJ\n"
"clipobj      <CLIPOBJ Address>            -- CLIPOBJ\n"
"ddc          <DC Address | HDC>           -- DC (ddc -? for more info)\n"
"ebrush       <EBRUSHOBJ Address>          -- EBRUSHOBJ\n"
"epathobj     <EPATHOBJ Address>           -- EPATHOBJ (+PATH)\n"
"lineattrs    <LINEATTRS Address>          -- LINEATTRS\n"
"palette      <PALETTE Address | HPALETTE> -- PALETTE\n"
"path         <PATH Address | HPATH>       -- PATH\n"
"pathobj      <PATHOBJ Address>            -- PATHOBJ\n"
"pdev         <PDEV Address>               -- PDEV (pdev -? for more info)\n"
"region       <REGION Address | HRGN>      -- REGION\n"
"sprite       <SPRITE Address>             -- SPRITE\n"
"spritestate  <SPRITESTATE Address>        -- SPRITE_STATE\n"
"surface      <SURFACE Address | HSURF>    -- SURFACE\n"
"surfobj      <SURFOBJ Address | HSURF>    -- SURFOBJ\n"
"wndobj       <WNDOBJ Address>             -- WNDOBJ\n"
"xlate        <XLATE Address>              -- XLATE\n"
"xlateobj     <XLATEOBJ Address>           -- XLATEOBJ\n"
//"obj      <OBJ Address>            -- OBJ\n"
"\n"
"\n"
"  - dc extensions -\n"
"dclist         -- list compact info about all known and readble surfaces\n"
"ddc          <DC Address | HDC>           -- DC (ddc -? for more info)\n"
"\n"
"  - session extensions -\n"
"session      [SessionId]                 -- Get/set session settings\n"
"spoolfind    <Tag>                       -- Search session pool for Tag\n"
"spoolsum                                 -- Summarize/verify pool numbers\n"
"spoolused                                -- Show pool allocs by tag\n"
"sprocess     [SessionId [Flags]]         -- Dump Processes in Session\n"
"svtop        <Session Virtual Address>   -- Lookup physical address\n"
"\n"
"  - surface extensions -\n"
"pageinsurfs                          -- Page-in all surf objects found in hmgr\n"
"pageinsurface <SURFACE Address>      -- Page-in image bits for a surface\n"
"surface    <SURFACE Address | HSURF | -o SURFOBJ Address>  -- Dump SURFACE type\n"
"surfobj    <SURFOBJ Address | HSURF>                       -- Dump SURFOBJ type\n"
"surflist       -- list compact info about all known and readable surfaces\n"
"vsurf      <SURFACE Address | HSURF | -o SURFOBJ Address>  -- display a surface\n"
"\n"
"  - process/thread extensions -\n"
"batch      [TEB Address | -t Thread]           -- list batched GDI commands\n"
"semorder   [Thread]                            -- show semaphore usage history\n"
"w32p       [W32PROCESS Address | -p Process]   -- dump W32PROCESS structure\n"
"w32t       [W32THREAD Address | -t Thread]     -- dump W32THREAD structure\n"
"\n"
"\n"
"hdc          HDC [-?gltf]\n"
"dcl          DCLEVEL*\n"
"dca          DC_ATTR*\n"
"ca           COLORADJUSTMENT*\n"
"efloat       <EFLOAT Address> [Count]\n"
"mx           <MATRIX Address>\n"
"batch        DISPLAY TEB BATCHED COMMANDS\n"
"dpeb         DISPLAY PEB CACHED OBJECTS\n"
"floatl       <FLOATL Address> [Count]\n"
"xo           XFORMOBJ*\n"
"\n"
"  - font extensions -\n"
"\n"
"tstats\n"
"gs        FD_GLYPHSET*\n"
"gdata     GLYPHDATA*\n"
"elf       LOGFONTW*\n"
"tm        TEXTMETRICW*\n"
"tmwi      TMW_INTERNAL*\n"
"helf      HFONT\n"
"ifi       IFIMETRICS*\n"
"fo        RFONT* [-?axedtrfmoculhw]\n"
"pfe       PFE*\n"
"pff       PFF*\n"
"pft       PFT*\n"
"stro      STROBJ* [-?pheo]\n"
"gb        GLYPHBITS* [-?gh]\n"
"gdf       GLYPHDEF*\n"
"gp        GLYPHPOS*\n"
"cache     CACHE*\n"
"fh        FONTHASH*\n"
"hb        HASHBUCKET*\n"
"fv        FILEVIEW*\n"
"ffv       FONTFILEVIEW*\n"
"cliserv   CLISERV*\n"
"dhelf     HFONT\n"
"difi      IFIMETRICS*\n"
"dstro     STROBJ*\n"
"gdicall   GDICALL*\n"
"hpfe      HPFE\n"
"proxymsg  PROXYMSG*\n"
"\n"
"pubft -- dumps all PUBLIC fonts\n"
"pvtft -- dumps all Private or Embedded fonts\n"
"devft -- dumps all DEVICE fonts\n"
"dispcache -- dumps glyph cache for display PDEV\n"
"\n"
"=======================================================================\n";


DECLARE_API( help )
{
    OutputControl   OutCtl(Client);

    OutCtl.Output(szHelp);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\hmgr.cxx ===
/******************************Module*Header*******************************\
* Module Name: hmgr.cxx
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/


#include "precomp.hxx"

// Sometimes GDI _ENTRY structure can't be read.
//  We can use another module's version since the structure should be the same.
CHAR szEntryType[MAX_PATH];

CachedType Entry = {FALSE, "_ENTRY", 0, 0, 0};

// Cache virtual table addresses for each session since the lookup is slow.
// Additionally cache one for the current session since it too is now slow.
#define NUM_CACHED_SESSIONS 8
struct {
    ULONG   UniqueState;
    ULONG64 VirtualTableAddr;
} CachedTableAddr[NUM_CACHED_SESSIONS+1] = { { 0, 0 } };

BitFieldInfo *HandleIndex;
BitFieldInfo *HandleType;
BitFieldInfo *HandleAltType;
BitFieldInfo *HandleFullType;
BitFieldInfo *HandleStock;
BitFieldInfo *HandleFullUnique;


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   HmgrInit
*
* Routine Description:
*
*   Initialize or reinitialize information to be read from symbols files
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*
* Return Value:
*
*   none
*
\**************************************************************************/

void HmgrInit(PDEBUG_CLIENT Client)
{
    strcpy(szEntryType, GDIType(_ENTRY));

    Entry.Valid = FALSE;
    Entry.Module = 0;
    Entry.TypeId = 0;
    Entry.Size = 0;

    if (HandleIndex != NULL) HandleIndex->Valid = FALSE;
    if (HandleType != NULL) HandleType->Valid = FALSE;
    if (HandleAltType != NULL) HandleAltType->Valid = FALSE;
    if (HandleFullType != NULL) HandleFullType->Valid = FALSE;
    if (HandleStock != NULL) HandleStock->Valid = FALSE;
    if (HandleFullUnique != NULL) HandleFullUnique->Valid = FALSE;

    for (int s = 0; s < sizeof(CachedTableAddr)/sizeof(CachedTableAddr[0]); s++)
    {
        CachedTableAddr[s].UniqueState = INVALID_UNIQUE_STATE;
    }

    return;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   HmgrExit
*
* Routine Description:
*
*   Clean up any outstanding allocations or references
*
* Arguments:
*
*   none
*
* Return Value:
*
*   none
*
\**************************************************************************/

void HmgrExit()
{
    if (HandleIndex != NULL)
    {
        delete HandleIndex;
        HandleIndex = NULL;
    }

    if (HandleType != NULL)
    {
        delete HandleType;
        HandleType = NULL;
    }

    if (HandleAltType != NULL)
    {
        delete HandleAltType;
        HandleAltType = NULL;
    }

    if (HandleFullType != NULL)
    {
        delete HandleFullType;
        HandleFullType = NULL;
    }

    if (HandleStock != NULL)
    {
        delete HandleStock;
        HandleStock = NULL;
    }

    if (HandleFullUnique != NULL)
    {
        delete HandleFullUnique;
        HandleFullUnique = NULL;
    }

    return;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetEntryType
*
* Routine Description:
*
*   looks up hmgr entry type id and module
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*   TypeId - Pointer to receive entry's type id
*   Module - Pointer to receive entry's module
*
* Return Value:
*
*   S_OK if successful.
*
\**************************************************************************/

HRESULT
GetEntryType(
    PDEBUG_CLIENT Client,
    PULONG TypeId,
    PULONG64 Module
    )
{
    HRESULT hr = S_OK;

    if (!Entry.Valid)
    {
        OutputControl   OutCtl(Client);
        PDEBUG_SYMBOLS  Symbols;

        if (TypeId != NULL) *TypeId = 0;
        if (Module != NULL) *Module = 0;

        if (Client == NULL) return E_INVALIDARG;

        if (Type_Module.Base == 0)
        {
            OutCtl.OutErr("Symbols not initialized properly.\n"
                           " Please use !reinit.\n");
            return S_FALSE;
        }

        if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                         (void **)&Symbols)) != S_OK)
        {
            return hr;
        }

        if ((hr = Symbols->GetTypeId(Type_Module.Base, Entry.Type, &Entry.TypeId)) == S_OK)
        {
            Entry.Module = Type_Module.Base;
            Entry.Valid = TRUE;

            sprintf(szEntryType, "%s!%s", Type_Module.Name, Entry.Type);

            OutCtl.OutVerb("Found %s in module %s @ 0x%p.\n",
                            Entry.Type, Type_Module.Name, Entry.Module);
        }
        else
        {
            ULONG   ModuleIndex = 0;
            ULONG64 ModuleBase = 0;

            while (Symbols->GetModuleByIndex(ModuleIndex, &Entry.Module) == S_OK &&
                   Entry.Module != 0)
            {
                if ((hr = Symbols->GetTypeId(Entry.Module,
                                             Entry.Type,
                                             &Entry.TypeId)) == S_OK)
                {
                    OutCtl.OutVerb("Found %s: TypeId 0x%lx in module @ 0x%p.\n",
                                   Entry.Type, Entry.TypeId, Entry.Module);
                    break;
                }

                ModuleIndex++;
                Entry.Module = 0;
            }

            if (hr != S_OK)
            {
                Entry.Module = 0;
                Entry.TypeId = 0;
                OutCtl.OutErr("Unable to find type '%s'.\n", Entry.Type);
            }
            else
            {
                Entry.Valid = TRUE;

                if (Symbols->GetModuleNames(ModuleIndex, Entry.Module,
                                            NULL, 0, NULL,
                                            szEntryType, sizeof(szEntryType), NULL,
                                            NULL, 0, NULL) == S_OK)
                {
                    OutCtl.OutVerb("Found %s in module(%lu) %s @ %p.\n",
                                    Entry.Type, ModuleIndex, szEntryType, Entry.Module);
                    strcat(szEntryType, "!");
                    strcat(szEntryType, "_ENTRY");
                }
                else
                {
                    OutCtl.OutVerb("Found %s in unknown module(%lu) @ %p.\n",
                                    Entry.Type, ModuleIndex, Entry.Module);
                    strcpy(szEntryType, Entry.Type);
                }
            }
        }
    }

    if (hr == S_OK)
    {
        if (TypeId != NULL) *TypeId = Entry.TypeId;
        if (Module != NULL) *Module = Entry.Module;
    }

    return hr;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetEntrySize
*
* Routine Description:
*
*   looks up hmgr entry size
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*
* Return Value:
*
*   address of handle manager entry
*
\**************************************************************************/

ULONG GetEntrySize(
    PDEBUG_CLIENT Client
    )
{
    if (Entry.Size == 0)
    {
        PDEBUG_SYMBOLS  Symbols;

        if (Client != NULL &&
            GetEntryType(Client, NULL, NULL) == S_OK &&
            Client->QueryInterface(__uuidof(IDebugSymbols),
                                   (void **)&Symbols) == S_OK)
        {
            if (Symbols->GetTypeSize(Entry.Module,
                                     Entry.TypeId,
                                     &Entry.Size) != S_OK)
            {
                OutputControl   OutCtl(Client);
                OutCtl.OutErr("Unable to get size of _ENTRY.\n");
                Entry.Size = 0;
            }

            Symbols->Release();
        }
    }

    return Entry.Size;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetIndexFromHandle
*
* Routine Description:
*
*   Decodes entry index from engine handle
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*   Handle64 - engine handle
*   Index - Address to receive extracted handle index
*
* Return Value:
*
*   S_OK on success
*
\**************************************************************************/

HRESULT
GetIndexFromHandle(
    PDEBUG_CLIENT Client,
    ULONG64 Handle64,
    PULONG64 Index
    )
{
    HRESULT hr = S_FALSE;

    if (HandleIndex == NULL)
    {
        HandleIndex = new BitFieldInfo;
    }

    if (HandleIndex == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (HandleIndex->Valid)
    {
        hr = S_OK;
    }
    else
    {
        BitFieldParser      BitFieldReader(Client, HandleIndex);
        OutputState         OutState(Client);

        if ((hr = BitFieldReader.Ready()) == S_OK &&
            (hr = OutState.Setup(0, &BitFieldReader)) == S_OK)
        {
            // Read index bit field from symbol file
            if (OutState.Execute("dt " GDIType(GDIHandleBitFields) " Index") != S_OK ||
                BitFieldReader.ParseOutput() != S_OK ||
                BitFieldReader.Complete() != S_OK)
            {
                // Use position 0 and INDEX_BITS from ntgdistr.h
                HandleIndex->Valid = HandleIndex->Compose(0, INDEX_BITS);
                hr = HandleIndex->Valid ? S_OK : S_FALSE;
            }
        }
    }

    if (Index != NULL)
    {
        if (hr == S_OK)
        {
            *Index = (Handle64 & HandleIndex->Mask) >> HandleIndex->BitPos;
        }
        else
        {
            *Index = 0;
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetTypeFromHandle
*
* Routine Description:
*
*   Decodes base type from engine handle
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*   Handle64 - engine handle
*   Type - Address to receive extracted handle type
*   Flags - Extraction options
*       GET_BITS_UNSHIFTED - Field bits not shifted to start at bit 0
*
* Return Value:
*
*   S_OK on success
*
\**************************************************************************/

HRESULT
GetTypeFromHandle(
    PDEBUG_CLIENT Client,
    ULONG64 Handle64,
    PULONG64 Type,
    FLONG Flags
    )
{
    HRESULT hr = S_FALSE;

    if (HandleType == NULL)
    {
        HandleType = new BitFieldInfo;
    }

    if (HandleType == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (HandleType->Valid)
    {
        hr = S_OK;
    }
    else
    {
        BitFieldParser      BitFieldReader(Client, HandleType);
        OutputState         OutState(Client);

        if ((hr = BitFieldReader.Ready()) == S_OK &&
            (hr = OutState.Setup(0, &BitFieldReader)) == S_OK)
        {
            // Read index bit field from symbol file
            if ((hr = OutState.Execute("dt " GDIType(GDIHandleBitFields) " Type")) != S_OK ||
                (hr = BitFieldReader.ParseOutput()) != S_OK ||
                (hr = BitFieldReader.Complete()) != S_OK)
            {
                // Use position TYPE_SHIFT and TYPE_BITS from ntgdistr.h
                HandleType->Valid = HandleType->Compose(TYPE_SHIFT, TYPE_BITS);
                hr = HandleType->Valid ? S_OK : S_FALSE;
            }
        }
    }

    if (Type != NULL)
    {
        if (hr == S_OK)
        {
            *Type = Handle64 & HandleType->Mask;
            if (!(Flags & GET_BITS_UNSHIFTED))
            {
                *Type >>= HandleType->BitPos;
            }
        }
        else
        {
            *Type = 0;
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetAltTypeFromHandle
*
* Routine Description:
*
*   Decodes alt type from engine handle
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*   Handle64 - engine handle
*   AltType - Address to receive extracted alt handle type
*   Flags - Extraction options
*       GET_BITS_UNSHIFTED - Field bits not shifted to start at bit 0
*
* Return Value:
*
*   S_OK on success
*
\**************************************************************************/

HRESULT
GetAltTypeFromHandle(
    PDEBUG_CLIENT Client,
    ULONG64 Handle64,
    PULONG64 AltType,
    FLONG Flags
    )
{
    HRESULT hr = S_FALSE;

    if (HandleAltType == NULL)
    {
        HandleAltType = new BitFieldInfo;
    }

    if (HandleAltType == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (HandleAltType->Valid)
    {
        hr = S_OK;
    }
    else
    {
        BitFieldParser      BitFieldReader(Client, HandleAltType);
        OutputState         OutState(Client);

        if ((hr = BitFieldReader.Ready()) == S_OK &&
            (hr = OutState.Setup(0, &BitFieldReader)) == S_OK)
        {
            // Read index bit field from symbol file
            if ((hr = OutState.Execute("dt " GDIType(GDIHandleBitFields) " AltType")) != S_OK ||
                (hr = BitFieldReader.ParseOutput()) != S_OK ||
                (hr = BitFieldReader.Complete()) != S_OK)
            {
                // Use position ALTTYPE_SHIFT and ALTTYPE_BITS from ntgdistr.h
                HandleAltType->Valid = HandleAltType->Compose(ALTTYPE_SHIFT, ALTTYPE_BITS);
                hr = HandleAltType->Valid ? S_OK : S_FALSE;
            }
        }
    }

    if (AltType != NULL)
    {
        if (hr == S_OK)
        {
            *AltType = Handle64 & HandleAltType->Mask;
            if (!(Flags & GET_BITS_UNSHIFTED))
            {
                *AltType >>= HandleAltType->BitPos;
            }
        }
        else
        {
            *AltType = 0;
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetFullTypeFromHandle
*
* Routine Description:
*
*   Decodes full type from engine handle
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*   Handle64 - engine handle
*   FullType - Address to receive extracted full handle type
*   Flags - Extraction options
*       GET_BITS_UNSHIFTED - Field bits not shifted to start at bit 0
*
* Return Value:
*
*   S_OK on success
*
\**************************************************************************/

HRESULT
GetFullTypeFromHandle(
    PDEBUG_CLIENT Client,
    ULONG64 Handle64,
    PULONG64 FullType,
    FLONG Flags
    )
{
    HRESULT hr = S_FALSE;

    if (HandleFullType == NULL)
    {
        HandleFullType = new BitFieldInfo;
    }

    if (HandleFullType == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (HandleFullType->Valid)
    {
        hr = S_OK;
    }
    else
    {
        if ((hr = GetTypeFromHandle(Client, 0, NULL)) == S_OK &&
            (hr = GetAltTypeFromHandle(Client, 0, NULL)) == S_OK)
        {
            if (!HandleType->Valid || HandleType->Bits == 0)
            {
                *HandleFullType = *HandleAltType;
            }
            else if (!HandleAltType->Valid || HandleAltType->Bits == 0)
            {
                *HandleFullType = *HandleType;
            }
            else
            {
                ULONG64 Mask;

                HandleFullType->BitPos = min(HandleType->BitPos, HandleAltType->BitPos);
                HandleFullType->Bits = max(HandleAltType->Bits+HandleAltType->BitPos,
                                           HandleType->Bits+HandleType->BitPos) -
                                       HandleFullType->BitPos;
                HandleFullType->Mask = HandleAltType->Mask | HandleType->Mask;

                // Make sure we have the BitPos and Bits count correct
                for (Mask = HandleFullType->Mask >> HandleFullType->BitPos;
                     HandleFullType->Bits > 0 && ((Mask & 1) == 0);
                     HandleFullType->Bits--, Mask >> 1)
                {
                    HandleFullType->BitPos++;
                }

                HandleFullType->Valid = (HandleFullType->Bits > 0);
            }

            if (!HandleFullType->Valid)
            {
                hr = S_FALSE;
            }
        }
    }

    if (FullType != NULL)
    {
        if (hr == S_OK)
        {
            *FullType = Handle64 & HandleFullType->Mask;
            if (!(Flags & GET_BITS_UNSHIFTED))
            {
                *FullType >>= HandleFullType->BitPos;
            }
        }
        else
        {
            *FullType = 0;
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetStockFromHandle
*
* Routine Description:
*
*   Decodes stock value from engine handle
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*   Handle64 - engine handle
*   Stock - Address to receive extracted handle stock setting
*   Flags - Extraction options
*       GET_BITS_UNSHIFTED - Field bits not shifted to start at bit 0
*
* Return Value:
*
*   S_OK on success
*
\**************************************************************************/

HRESULT
GetStockFromHandle(
    PDEBUG_CLIENT Client,
    ULONG64 Handle64,
    PULONG64 Stock,
    FLONG Flags
    )
{
    HRESULT hr = S_FALSE;

    if (HandleStock == NULL)
    {
        HandleStock = new BitFieldInfo;
    }

    if (HandleStock == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (HandleStock->Valid)
    {
        hr = S_OK;
    }
    else
    {
        BitFieldParser      BitFieldReader(Client, HandleStock);
        OutputState         OutState(Client);

        if ((hr = BitFieldReader.Ready()) == S_OK &&
            (hr = OutState.Setup(0, &BitFieldReader)) == S_OK)
        {
            // Read index bit field from symbol file
            if ((hr = OutState.Execute("dt " GDIType(GDIHandleBitFields) " Stock")) != S_OK ||
                (hr = BitFieldReader.ParseOutput()) != S_OK ||
                (hr = BitFieldReader.Complete()) != S_OK)
            {
                // Use position STOCK_SHIFT and STOCK_BITS from ntgdistr.h
                HandleStock->Valid = HandleStock->Compose(STOCK_SHIFT, STOCK_BITS);
                hr = HandleStock->Valid ? S_OK : S_FALSE;
            }
        }
    }

    if (Stock != NULL)
    {
        if (hr == S_OK)
        {
            *Stock = Handle64 & HandleStock->Mask;
            if (!(Flags & GET_BITS_UNSHIFTED))
            {
                *Stock >>= HandleStock->BitPos;
            }
        }
        else
        {
            *Stock = 0;
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetFullUniqueFromHandle
*
* Routine Description:
*
*   Decodes full unique value from engine handle
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*   Handle64 - engine handle
*   FullUnique - Address to receive extracted handle FullUnique value
*   Flags - Extraction options
*       GET_BITS_UNSHIFTED - Field bits not shifted to start at bit 0
*
* Return Value:
*
*   S_OK on success
*
\**************************************************************************/

HRESULT
GetFullUniqueFromHandle(
    PDEBUG_CLIENT Client,
    ULONG64 Handle64,
    PULONG64 FullUnique,
    ULONG Flags
    )
{
    HRESULT hr = S_FALSE;

    if (HandleFullUnique == NULL)
    {
        HandleFullUnique = new BitFieldInfo;
    }

    if (HandleFullUnique == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (HandleFullUnique->Valid)
    {
        hr = S_OK;
    }
    else
    {
        if (HandleIndex == NULL || !HandleIndex->Valid)
        {
            // Try to read Index bitfield
            hr = GetIndexFromHandle(Client, 0, NULL);
        }

        if (HandleIndex != NULL && HandleIndex->Valid)
        {
            BitFieldInfo        GDIHandle;
            BitFieldParser      BitFieldReader(Client, &GDIHandle);
            OutputState         OutState(Client);

            if ((hr = BitFieldReader.Ready()) == S_OK &&
                (hr = OutState.Setup(0, &BitFieldReader)) == S_OK)
            {
                // Read FullUnique from symbol file
                if (OutState.Execute("dt " GDIType(GDIHandleBitFields)) == S_OK &&
                    BitFieldReader.ParseOutput() == S_OK &&
                    BitFieldReader.Complete() == S_OK)
                {
                    ULONG64 Mask;

                    HandleFullUnique->BitPos = HandleIndex->BitPos + HandleIndex->Bits;
                    HandleFullUnique->Bits = GDIHandle.Bits - HandleFullUnique->BitPos;
                    HandleFullUnique->Mask = GDIHandle.Mask & ~HandleIndex->Mask;
                    
                    // Make sure we have the BitPos and Bits count correct
                    for (Mask = HandleFullUnique->Mask >> HandleFullUnique->BitPos;
                         HandleFullUnique->Bits > 0 && ((Mask & 1) == 0);
                         HandleFullUnique->Bits--, Mask >> 1)
                    {
                        HandleFullUnique->BitPos++;
                    }

                    HandleFullUnique->Valid = (HandleFullUnique->Bits > 0);
                }
                else
                {
                    // Use values from ntgdistr.h
                    HandleFullUnique->Valid =
                        HandleFullUnique->Compose(TYPE_SHIFT,
                                                 TYPE_BITS + 
                                                 ALTTYPE_BITS + 
                                                 STOCK_BITS + 
                                                 UNIQUE_BITS);
                }

                hr = HandleFullUnique->Valid ? S_OK : S_FALSE;
            }
        }
    }

    if (FullUnique != NULL)
    {
        if (hr == S_OK)
        {
            *FullUnique = Handle64 & HandleFullUnique->Mask;
            if (!(Flags & GET_BITS_UNSHIFTED))
            {
                *FullUnique >>= HandleFullUnique->BitPos;
            }
        }
        else
        {
            *FullUnique = 0;
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetHandleTable
*
* Routine Description:
*
*   reads current location of handle table
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*   TableAddr - PULONG64 to return start address of handle table
*
* Return Value:
*
*   If successful, S_OK.
*
\**************************************************************************/

HRESULT
GetHandleTable(
    PDEBUG_CLIENT Client,
    PULONG64 TableAddr
    )
{
    ULONG CurrentUniqueState = UniqueTargetState;

    HRESULT     hr;

    PDEBUG_CONTROL      Control;
    PDEBUG_SYMBOLS      Symbols;
    PDEBUG_DATA_SPACES  Data;

    if (TableAddr == NULL)
    {
        return E_INVALIDARG;
    }

    if (CurrentUniqueState != INVALID_UNIQUE_STATE)
    {
        if (SessionId < NUM_CACHED_SESSIONS)
        {
            if (CachedTableAddr[SessionId].UniqueState == CurrentUniqueState)
            {
                *TableAddr = CachedTableAddr[SessionId].VirtualTableAddr;
                return S_OK;
            }
        }
        else if (SessionId == CURRENT_SESSION)
        {
            if (CachedTableAddr[NUM_CACHED_SESSIONS].UniqueState == CurrentUniqueState)
            {
                *TableAddr = CachedTableAddr[NUM_CACHED_SESSIONS].VirtualTableAddr;
                return S_OK;
            }
        }
    }

    *TableAddr = 0;

    if (Client == NULL) return E_INVALIDARG;

    OutputControl   OutCtl(Client);

    if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                     (void **)&Symbols)) != S_OK)
    {
        return hr;
    }

    if ((hr = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                     (void **)&Data)) != S_OK)
    {
        Symbols->Release();
        return hr;
    }

    CHAR    PointerName[80];
    ULONG64 pent;

    hr = S_FALSE;

    if (TargetClass != DEBUG_CLASS_USER_WINDOWS)
    {
        sprintf(PointerName, "%s!gpentHmgr", GDIKM_Module.Name);
        hr = Symbols->GetOffsetByName(PointerName, &pent);
        if (hr != S_OK)
        {
            OutCtl.OutErr("Unable to locate %s\n", PointerName);
        }
    }

    if (hr != S_OK && SessionId == CURRENT_SESSION)
    {
        sprintf(PointerName, "%s!pGdiSharedHandleTable", GDIUM_Module.Name);
        hr = Symbols->GetOffsetByName(PointerName, &pent);
        if (hr != S_OK)
        {
            OutCtl.OutErr("Unable to locate %s\n", PointerName);
        }
    }


    if (hr == S_OK)
    {
        if (SessionId == CURRENT_SESSION)
        {
            hr = Data->ReadPointersVirtual(1, pent, TableAddr);

            if (hr == S_OK)
            {
                CachedTableAddr[NUM_CACHED_SESSIONS].VirtualTableAddr = *TableAddr;
                CachedTableAddr[NUM_CACHED_SESSIONS].UniqueState = CurrentUniqueState;
            }
        }
        else
        {
            ULONG64 pentPhys;

            if ((hr = GetPhysicalAddress(Client,
                                         SessionId,
                                         pent,
                                         &pentPhys)) == S_OK)
            {
                hr = ReadPointerPhysical(Client, pentPhys, TableAddr);

                if (hr == S_OK)
                {
                    if (SessionId < NUM_CACHED_SESSIONS)
                    {
                        CachedTableAddr[SessionId].VirtualTableAddr = *TableAddr;
                        CachedTableAddr[SessionId].UniqueState = CurrentUniqueState;
                    }
                }
            }
        }

        if (hr == S_OK)
        {
            if (!*TableAddr)
            {
                OutCtl.OutErr(" GDI handle manager is not initialized or symbols are incorrect.\n"
                              "  %s @ %#p is NULL.\n", PointerName, pent);
                hr = S_FALSE;
            }
        }
        else
        {
            OutCtl.OutErr("Unable to get the contents of %s @ %#p\n",
                          PointerName, pent);
        }
    }

    Data->Release();
    Symbols->Release();

    return hr;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetMaxHandles
*
* Routine Description:
*
*   reads current maximum number of handles
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*
* Return Value:
*
*   Zero for failure, otherwise maximum valid handle index
*
\**************************************************************************/

HRESULT
GetMaxHandles(
    PDEBUG_CLIENT Client,
    PULONG64 MaxHandles
    )
{
    static ULONG    CachedUniqueState = INVALID_UNIQUE_STATE;
    static ULONG    LastSession = INVALID_SESSION;
    static ULONG64  LastMaxHandles = 0;

    ULONG CurrentUniqueState = UniqueTargetState;

    HRESULT         hr;


    if (MaxHandles == NULL) return E_INVALIDARG;

    if (CurrentUniqueState != INVALID_UNIQUE_STATE &&
        CachedUniqueState == CurrentUniqueState &&
        LastSession == SessionId)
    {
        *MaxHandles = LastMaxHandles;
        return S_OK;
    }


    if (Client == NULL) return E_INVALIDARG;

    OutputControl   OutCtl(Client);


    hr = S_FALSE;

    if (TargetClass != DEBUG_CLASS_USER_WINDOWS)
    {
        CHAR    SymName[80];

        sprintf(SymName, "%s!gcMaxHmgr", GDIKM_Module.Name);
        hr = ReadSymbolData(Client, SymName, MaxHandles, sizeof(*MaxHandles), NULL);
        if (hr != S_OK)
        {
            OutCtl.OutErr("Unable to get contents of %s\n", SymName);
        }
    }

    if (hr != S_OK)
    {
        ULONG64 Module;
        ULONG   TypeId;

        if ((hr = GetTypeId(Client, "_GDI_SHARED_MEMORY", &TypeId, &Module)) == S_OK)
        {
            ULONG   NumHandles;

            hr = GetFieldSize(Client, Module, TypeId, "aentryHmgr",
                              NULL, &NumHandles, NULL);

            if (hr == S_OK)
            {
                *MaxHandles = NumHandles;
            }
            else
            {
                OutCtl.OutErr("Unable to get length of _GDI_SHARED_MEMORY.aentryHmgr\n");
            }
        }
    }

    if (hr == S_OK)
    {
        CachedUniqueState = CurrentUniqueState;
        LastSession = SessionId;
        LastMaxHandles = *MaxHandles;
    }

    return hr;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetEntryAddress
*
* Routine Description:
*
*   looks up hmgr entry for an engine handle index
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*   Index64 -- engine handle index
*
* Return Value:
*
*   address of handle manager entry
*
\**************************************************************************/

HRESULT
GetEntryAddress(
    PDEBUG_CLIENT Client,
    ULONG64 Handle64,
    PULONG64 EntryAddr,
    PBOOL Physical
    )
{
    HRESULT     hr;
    ULONG64     Index;
    ULONG64     MaxIndex;
    ULONG64     TableAddr;
    ULONG       EntSize;

    *EntryAddr = 0;
    *Physical = FALSE;

    if ((hr = GetIndexFromHandle(Client, Handle64, &Index)) == S_OK &&
        (hr = GetHandleTable(Client, &TableAddr)) == S_OK &&
        (hr = GetMaxHandles(Client, &MaxIndex)) == S_OK)
    {
        if (Index >= MaxIndex)
        {
            OutputControl   OutCtl(Client);
            OutCtl.OutVerb("Bad index: Index (%I64x) >= Max Handles (%I64x)\n",
                           Index, MaxIndex);

            hr = S_FALSE;
        }
        else
        {
            if ((EntSize = GetEntrySize(Client)) == 0)
            {
                hr = S_FALSE;
            }
        }
    }

    if (hr == S_OK)
    {
        if (SessionId != CURRENT_SESSION)
        {
            *Physical = TRUE;
            hr = GetPhysicalAddress(Client, SessionId,
                                    TableAddr + EntSize * Index,
                                    EntryAddr);
        }
        else
        {
            *EntryAddr = TableAddr + EntSize * Index;
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetObjectAddress
*
* Routine Desciption:
*
*   Converts an engine handle to an address of an object
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*   Handle64 -- engine handle
*   ValidateBaseObj -- verifies _BASEOBJECT.hHmgr == Handle64
*   ExcpectedType -- Object type expected to find
*
* Return Value:
*
*   Address of object if Handle64 leads to valid object of ExpectedType
*   otherwise 0.
*
\**************************************************************************/

HRESULT
GetObjectAddress(
    PDEBUG_CLIENT Client,
    ULONG64 Handle64,
    PULONG64 Address,
    UCHAR ExpectedType,
    BOOL ValidateFullUnique,
    BOOL ValidateBaseObj
    )
{
    HRESULT         hr;
    PDEBUG_CONTROL  Control;
    PDEBUG_SYMBOLS  Symbols;
    ULONG64         EntryAddr;
    BOOL            Physical;
    UCHAR           Type;
    ULONG64         ObjAddr = 0;

    if (Address != NULL) *Address = 0;

    if (Client == NULL) return E_INVALIDARG;

    if ((hr = Client->QueryInterface(__uuidof(IDebugControl),
                                     (void **)&Control)) != S_OK)
    {
        return hr;
    }

    if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                     (void **)&Symbols)) != S_OK)
    {
        Control->Release();
        return hr;
    }

    OutputControl   OutCtl(Client);

    if ((hr = GetEntryAddress(Client, Handle64, &EntryAddr, &Physical)) == S_OK)
    {
        ULONG64                 EntryModule = 0;
        ULONG                   EntryTypeId = 0;
        ULONG64                 HandlesFullUnique;
        DEBUG_VALUE             FullUnique;
        DEBUG_VALUE             Objt;
        DEBUG_VALUE             pobj;
        TypeOutputParser        EntryReader(Client);
        OutputState             OutState(Client);
        ULONG                   TypeOutFlags = DEBUG_OUTTYPE_RECURSION_LEVEL(((Physical || !ValidateBaseObj) ? 1 : 2));

        if ((hr = OutState.Setup(0, &EntryReader)) == S_OK &&
            (hr = OutState.OutputType(Physical,
                                      EntryAddr,
                                      Entry.Module,
                                      Entry.TypeId,
                                      TypeOutFlags)) == S_OK)
        {
            if (ExpectedType != ANY_TYPE)
            {
                if ((hr = EntryReader.Get(&Objt, "Objt", DEBUG_VALUE_INT8)) != S_OK)
                {
                    OutCtl.OutErr("Unable to get entry's object type, %s.\n",
                                  pszHRESULT(hr));
                }

                if (hr == S_OK &&
                    ExpectedType != Objt.I8)
                {
                    OutCtl.OutVerb(" Expected type (0x%lx) doesn't match entry's (0x%lx)\n",
                                   (ULONG)ExpectedType, (ULONG)Objt.I8);
                    hr = S_FALSE;
                }
            }

            if (hr == S_OK && ValidateFullUnique)
            {
                if ((hr = EntryReader.Get(&FullUnique, "FullUnique", DEBUG_VALUE_INT64)) != S_OK)
                {
                    OutCtl.OutErr("Unable to get entry's full unique value, %s.\n",
                                  pszHRESULT(hr));
                }

                if (hr == S_OK &&
                    (hr = GetFullUniqueFromHandle(Client, Handle64, &HandlesFullUnique)) != S_OK)
                {
                    OutCtl.OutErr("Unable to extract full unique value from handle, %s.\n",
                                  pszHRESULT(hr));
                }

                if (hr == S_OK &&
                    HandlesFullUnique != FullUnique.I64)
                {
                    OutCtl.OutVerb(" Handle's full unique value (0x%p) doesn't match entry's (0x%p)\n",
                                   HandlesFullUnique, FullUnique.I64);
                    hr = S_FALSE;
                }
            }

            // If valid so far, get the object address.
            if (hr == S_OK)
            {
                if ((hr = EntryReader.Get(&pobj, "pobj", DEBUG_VALUE_INT64)) != S_OK)
                {
                    OutCtl.OutErr("Unable to get entry's object address, %s.\n",
                                  pszHRESULT(hr));
                }
                else
                {
                    ObjAddr = pobj.I64;
                }
            }

            if (hr == S_OK && ValidateBaseObj)
            {
                DEBUG_VALUE     ObjHandle;

                if (Physical)
                {
                    hr = OutState.OutputTypeVirtual(ObjAddr, "_BASEOBJECT", 0);
                }

                if (hr != S_OK ||
                    (hr = EntryReader.Get(&ObjHandle, "hHmgr", DEBUG_VALUE_INT64)) != S_OK)
                {
                    OutCtl.OutErr("Unable to read object's base info, %s.\n",
                                  pszHRESULT(hr));
                }

                if (hr == S_OK &&
                    ObjHandle.I64 != Handle64)
                {
                    // If Handle64's full unique bits weren't validated and
                    // Handle64 doesn't match hHmgr in baseobj,
                    // set them to to full unique from entry.
                    if (!ValidateFullUnique)
                    {
                        if ((hr = EntryReader.Get(&FullUnique, "FullUnique", DEBUG_VALUE_INT64)) != S_OK)
                        {
                            OutCtl.OutErr("Unable to get entry's full unique value, %s.\n",
                                          pszHRESULT(hr));
                        }

                        // Make sure HandleFullUnique is valid
                        if (hr == S_OK &&
                            (hr = GetFullUniqueFromHandle(Client, 0, NULL)) != S_OK)
                        {
                            OutCtl.OutErr("Unable to compose handle from entry, %s.\n", pszHRESULT(hr));
                        }
                        else
                        {
                            Handle64 = (Handle64 & ~(HandleFullUnique->Mask)) |
                                       (FullUnique.I64 << HandleFullUnique->BitPos);

                            if (Control->IsPointer64Bit() != S_OK)
                            {
                                Handle64 = DEBUG_EXTEND64(Handle64);
                            }
                        }
                    }

                    if (hr == S_OK &&
                        ObjHandle.I64 != Handle64)
                    {
                        OutCtl.OutVerb(" Handle (0x%p) doesn't match object's hHmgr (0x%p)\n",
                                       Handle64, ObjHandle.I64);
                        hr = S_FALSE;
                    }
                }
            }
        }
    }
    
    if (hr == S_OK &&
        Address != NULL)
    {
        *Address = ObjAddr;
    }

    Symbols->Release();
    Control->Release();

    return hr;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetObjectHandle
*
* Routine Desciption:
*
*   Retrieves handle of an object from it address
*
* Arguments:
*
*   Client -- PDEBUG_CLIENT
*   ObjectAddr -- Address of OBJECT
*   Handle64 -- ULONG64 to receive engine handle
*   ValidateHandle -- verifies ENTRY.pobj == ObjectAddr
*   ExcpectedType -- Object type expected to find
*                    Currently only value when ValidateHandle is TRUE
*
* Return Value:
*
*   HRESULT of retrieval attempts and validation.
*       S_OK indicates everything succeeded.
*
\**************************************************************************/

HRESULT
GetObjectHandle(
    PDEBUG_CLIENT Client,
    ULONG64 ObjectAddr,
    PULONG64 Handle64,
    BOOL ValidateHandle,
    UCHAR ExpectedType
    )
{
    HRESULT                 hr;
    DEBUG_VALUE             ObjHandle;
    TypeOutputParser        ObjectReader(Client);
    OutputState             OutState(Client);

    if (Handle64 != NULL) *Handle64 = 0;

    if (ObjectAddr == 0) return E_INVALIDARG;

    if ((hr = OutState.Setup(0, &ObjectReader)) == S_OK &&
        (hr = OutState.OutputTypeVirtual(ObjectAddr,
                                         "_BASEOBJECT",
                                         0)) == S_OK)
    {
        hr = ObjectReader.Get(&ObjHandle, "hHmgr", DEBUG_VALUE_INT64);
    }

    if (hr == S_OK && ValidateHandle)
    {
        ULONG64 ObjectAddrFromHmgr;

        hr = GetObjectAddress(Client, ObjHandle.I64, &ObjectAddrFromHmgr,
                              ExpectedType, TRUE, FALSE);

        if (hr == S_OK &&
            ObjectAddrFromHmgr != ObjectAddr)
        {
            hr = S_FALSE;
        }
    }

    if (hr == S_OK && Handle64 != NULL)
    {
        *Handle64 = ObjHandle.I64;
    }

    return hr;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   OutputHandleInfo
*
* Routine Desciption:
*
*   Retrieves handle of an object from it address
*
* Arguments:
*
*   Client -- PDEBUG_CLIENT
*   Handle64 -- engine handle
*
* Return Value:
*
*   HRESULT of retrieval attempts and validation.
*       S_OK indicates everything succeeded.
*
\**************************************************************************/

HRESULT
OutputHandleInfo(
    OutputControl *OutCtl,
    PDEBUG_CLIENT Client,
    PDEBUG_VALUE Handle
    )
{
    if (Client == NULL || OutCtl == NULL || Handle == NULL)
    {
        return E_INVALIDARG;
    }

    HRESULT     hrRet;
    HRESULT     hr;
    DEBUG_VALUE ConvValue;
    ULONG64     Type;
    ULONG64     FullType;
    ULONG64     Stock;
    ENUMDEF    *pEnumDef;

    if (Handle->Type != DEBUG_VALUE_INT64)
    {
        if ((hr = OutCtl->CoerceValue(Handle, DEBUG_VALUE_INT64, &ConvValue)) != S_OK)
        {
            return hr;
        }

        Handle = &ConvValue;
    }

    if (Handle->I64 == 0) 
    {
        return S_OK;
    }

    hrRet = GetTypeFromHandle(Client, Handle->I64, &Type);

    if (hrRet == S_OK)
    {
        DbgPrint("Handle 0x%I64x's type is %I64x.\n", Handle->I64, Type);

        pEnumDef = aedENTRY_Objt;

        while (pEnumDef->psz != NULL)
        {
            if (pEnumDef->ul == Type)
            {
                OutCtl->Output(pEnumDef->psz);
                break;
            }

            pEnumDef++;
        }

        if (pEnumDef->psz == NULL)
        {
            OutCtl->Output("Unknown type %I64d", Type);
        }
    }
    else
    {
        OutCtl->Output("Unable to extract type");
    }

    hr = GetFullTypeFromHandle(Client, Handle->I64, &FullType, GET_BITS_UNSHIFTED);

    if (hr == S_OK)
    {
        DbgPrint("Handle 0x%I64x's Full Type is %I64x.\n", Handle->I64, FullType);

        pEnumDef = aedENTRY_FullType;

        while (pEnumDef->psz != NULL)
        {
            if (pEnumDef->ul == FullType)
            {
                OutCtl->Output(" : %s", pEnumDef->psz);
                break;;
            }

            pEnumDef++;
        }

        if (pEnumDef->psz == NULL)
        {
            ULONG64 AltType;

            hr = GetAltTypeFromHandle(Client, Handle->I64, &AltType);

            if (hr == S_OK && AltType != 0)
            {
                OutCtl->Output(" : Unknown alt type %I64d", AltType);
            }
        }
    }
    else if (hrRet == S_OK)
    {
        hrRet = hr;
    }

    hr = GetStockFromHandle(Client, Handle->I64, &Stock);

    if (hr == S_OK)
    {
        if (Stock)
        {
            OutCtl->Output(" (STOCK)");
        }
    }
    else if (hrRet == S_OK)
    {
        hrRet = hr;
    }

    return hrRet;
}


HRESULT
OutputFullUniqueInfo(
    OutputControl *OutCtl,
    PDEBUG_CLIENT Client,
    PDEBUG_VALUE FullUnique
    )
{
    if (Client == NULL || OutCtl == NULL || FullUnique == NULL)
    {
        return E_INVALIDARG;
    }

    HRESULT     hr;
    ULONG64     FullUniqTest;
    DEBUG_VALUE Handle;

    hr = GetFullUniqueFromHandle(Client, -1, &FullUniqTest);

    if (hr == S_OK)
    {
        if (FullUniqTest == 0)
        {
            hr = S_FALSE;
        }
        else
        {
            if (FullUnique->Type == DEBUG_VALUE_INT64)
            {
                Handle = *FullUnique;
            }
            else
            {
                hr = OutCtl->CoerceValue(FullUnique, DEBUG_VALUE_INT64, &Handle);

                if (hr != S_OK) return hr;
            }

            Handle.I64 <<= HandleFullUnique->BitPos;

            hr = OutputHandleInfo(OutCtl, Client, &Handle);
        }
    }

    return hr;
}


char *pszTypes[] = {
"DEF_TYPE     ",
"DC_TYPE      ",
"UNUSED1      ",
"UNUSED2      ",
"RGN_TYPE     ",
"SURF_TYPE    ",
"CLIOBJ_TYPE  ",
"PATH_TYPE    ",
"PAL_TYPE     ",
"ICMLCS_TYPE  ",
"LFONT_TYPE   ",
"RFONT_TYPE   ",
"PFE_TYPE     ",
"PFT_TYPE     ",
"ICMCXF_TYPE  ",
"ICMDLL_TYPE  ",
"BRUSH_TYPE   ",
"UNUSED3      ",
"UNUSED4      ",
"SPACE_TYPE   ",
"UNUSED5      ",
"META_TYPE    ",
"EFSTATE_TYPE ",
"BMFD_TYPE    ",
"VTFD_TYPE    ",
"TTFD_TYPE    ",
"RC_TYPE      ",
"TEMP_TYPE    ",
"DRVOBJ_TYPE  ",
"DCIOBJ_TYPE  ",
"SPOOL_TYPE   ",
"TOTALS       ",
"DEF          "
};

/******************************Public*Routine******************************\
* DECLARE_API( dumphmgr  )
*
* Dumps the count of handles in Hmgr for each object type.
*
* History:
*  21-Feb-1995    -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

/*
HmgCurrentNumberOfObjects
HmgMaximumNumberOfObjects
HmgCurrentNumberOfLookAsideObjects
HmgMaximumNumberOfLookAsideObjects
HmgNumberOfObjectsAllocated
HmgNumberOfLookAsideHits
HmgCurrentNumberOfHandles
HmgMaximumNumberOfHandles
HmgNumberOfHandlesAllocated
*/

DECLARE_API( dumphmgr  )
{
    INIT_API();
    ExtWarn("Extension 'dumphmgr' is not fully converted.\n");
    HRESULT hr;
    ULONG64 pent;
    ULONG64 gcMaxHmgr;
    ULONG   entSize;

    DEBUG_VALUE ObjType;

    ULONG ulLoop;    // loop variable
    ULONG pulCount[MAX_TYPE + 2];
    ULONG cUnknown = 0;
    ULONG cUnknownSize = 0;
    ULONG cUnused = 0;

    DecArrayDumper(HmgCurrentNumberOfHandles, ULONG);
    DecArrayDumper(HmgMaximumNumberOfHandles, ULONG);
    DecArrayDumper(HmgNumberOfHandlesAllocated, ULONG);
    DecArrayDumper(HmgCurrentNumberOfObjects, ULONG);
    DecArrayDumper(HmgMaximumNumberOfObjects, ULONG);
    DecArrayDumper(HmgNumberOfObjectsAllocated, ULONG);
    DecArrayDumper(HmgCurrentNumberOfLookAsideObjects, ULONG);
    DecArrayDumper(HmgMaximumNumberOfLookAsideObjects, ULONG);
    DecArrayDumper(HmgNumberOfLookAsideHits, ULONG);

    char   *TableHeader;
    char    TableFormat[128];

    while (*args && isspace(*args)) args++;
    
    if (*args != '\0')
    {
        ExtOut("dumphmgr displays the count of each type of object in the handle manager\n"
               "\n"
               "Usage: dumphmgr [-?]\n"
               "    -? shows this help\n"
               "\n"
               "    If available statics for Handles, Objects, and objects allocated\n"
               "    from LookAside lists are shown.  Each class has three statics:\n"
               "        Cur - current number of items allocated\n"
               "        Max - largest number of items ever allocated at one time\n"
               "        Total - total allocations ever made for that item\n"
               );

        EXIT_API(S_OK);
    }

    // Get the pointers and counts

    if ((hr = GetHandleTable(Client, &pent)) != S_OK ||
        (hr = GetMaxHandles(Client, &gcMaxHmgr)) != S_OK)
    {
        EXIT_API(hr);
    }
    
    ExtOut("Handle Entry Table at 0x%p.\n", pent);
    ExtOut("Max handles out so far %I64u.\n", gcMaxHmgr);

    entSize = GetEntrySize(Client);

    if (!entSize || !gcMaxHmgr)
    {
        EXIT_API(S_FALSE);
    }

    ULONG   Reserved;
    ULONG64 Module;
    ULONG   TypeId;
    if ((hr = GetTypeId(Client, "_GDI_SHARED_MEMORY", &TypeId, &Module)) == S_OK)
    {
        hr = GetFieldSize(Client, Module, TypeId, "aentryHmgr", &Reserved);
    }

    // Print out the amount reserved and committed
    ExtOut("Page Size: %lu   Entry Size: %lu\n", PageSize, entSize);
    ExtOut("Total Hmgr: Reserved memory ");
    if (hr == S_OK)
    {
        ExtOut("%lu", Reserved);
    }
    else
    {
        ExtOut("?");
    }
    ExtOut(" Committed %lu\n", ((( (ULONG)gcMaxHmgr * entSize) + PageSize) & ~(PageSize - 1)));
    ExtOut("\n");


    for (ulLoop = 0; ulLoop <= TOTAL_TYPE; ulLoop++)
    {
        pulCount[ulLoop] = 0;
    }

    TypeOutputParser    TypeReader(Client);
    OutputState         OutState(Client);
    ULONG64             EntryModule;
    ULONG               EntryTypeId;

    if ((hr = TypeReader.LookFor(&ObjType, "Objt", DEBUG_VALUE_INT8)) == S_OK &&
        (hr = OutState.Setup(0, &TypeReader)) == S_OK)
    {
        if ((hr = GetTypeId(Client, szEntryType,
                            &EntryTypeId, &EntryModule)) != S_OK)
        {
            ExtErr("GetTypeId(%s) failed.\n", szEntryType);
        }
    }

    if (hr != S_OK)
    {
        ExtErr("Failed to prepare type read: %s\n", pszHRESULT(hr));
        EXIT_API(hr);
    }

    for (ulLoop = 0; ulLoop < gcMaxHmgr; ulLoop++)
    {
        if (g_pExtControl->GetInterrupt() == S_OK)
        {
            ExtErr("User cancled.\n");
            EXIT_API(E_ABORT);
        }

        TypeReader.DiscardOutput();
        TypeReader.Relook();
        if ((hr = OutState.OutputTypeVirtual(pent,
                                             EntryModule,
                                             EntryTypeId,
                                             0)) != S_OK ||
            (hr = TypeReader.ParseOutput()) != S_OK ||
            (hr = TypeReader.Complete()) != S_OK)
        {
            ExtErr("Error reading table entry @ %p, %s\n", pent, pszHRESULT(hr));
            ExtWarn("Only %lu entries were read.\n", ulLoop);
            break;
        }

        if (ObjType.I8 == DEF_TYPE)
        {
            cUnused++;
        }
        if (ObjType.I8 > MAX_TYPE)
        {
            cUnknown++;
        }
        else
        {
            pulCount[ObjType.I8]++;
        }

        pent += entSize;
    }


    ULONG64 TmpOffset;  // Have to pass an valid pointer when checking for a symbol.

    if (g_pExtSymbols->GetOffsetByName(GDISymbol(HmgCurrentNumberOfObjects), &TmpOffset) == S_OK &&
        HmgCurrentNumberOfObjects.ReadArray(GDISymbol(HmgCurrentNumberOfObjects)) &&
        HmgMaximumNumberOfObjects.ReadArray(GDISymbol(HmgMaximumNumberOfObjects)) &&
        HmgCurrentNumberOfLookAsideObjects.ReadArray(GDISymbol(HmgCurrentNumberOfLookAsideObjects)) &&
        HmgMaximumNumberOfLookAsideObjects.ReadArray(GDISymbol(HmgMaximumNumberOfLookAsideObjects)) &&
        HmgNumberOfObjectsAllocated.ReadArray(GDISymbol(HmgNumberOfObjectsAllocated)) &&
        HmgNumberOfLookAsideHits.ReadArray(GDISymbol(HmgNumberOfLookAsideHits)) &&
        HmgCurrentNumberOfHandles.ReadArray(GDISymbol(HmgCurrentNumberOfHandles)) &&
        HmgMaximumNumberOfHandles.ReadArray(GDISymbol(HmgMaximumNumberOfHandles)) &&
        HmgNumberOfHandlesAllocated.ReadArray(GDISymbol(HmgNumberOfHandlesAllocated))
        )
    {
        ExtOut("             Current  ---- Handles -----  ---- Objects -----  --- LookAside ----\n"
               "    TYPE     Handles   Cur   Max  Total    Cur   Max  Total    Cur   Max  Total\n");

        _snprintf(TableFormat, sizeof(TableFormat),
                  "%%s%%6lu %%c %s %s %s  %s %s %s  %s %s %s\n",
                  HmgCurrentNumberOfHandles.SetPrintFormat(5),
                  HmgMaximumNumberOfHandles.SetPrintFormat(5),
                  HmgNumberOfHandlesAllocated.SetPrintFormat(6),
                  HmgCurrentNumberOfObjects.SetPrintFormat(5),
                  HmgMaximumNumberOfObjects.SetPrintFormat(5),
                  HmgNumberOfObjectsAllocated.SetPrintFormat(6),
                  HmgCurrentNumberOfLookAsideObjects.SetPrintFormat(5),
                  HmgMaximumNumberOfLookAsideObjects.SetPrintFormat(5),
                  HmgNumberOfLookAsideHits.SetPrintFormat(6)
                  );
    }
    else
    {
        ExtOut("             Current\n"
               "    TYPE     Handles\n");

        _snprintf(TableFormat, sizeof(TableFormat), "%%s%%6lu\n");
    }

    // init the totals
    pulCount[TOTAL_TYPE]                           = 0;
    HmgCurrentNumberOfObjects[TOTAL_TYPE]          = 0;
    HmgCurrentNumberOfLookAsideObjects[TOTAL_TYPE] = 0;
    HmgMaximumNumberOfHandles[TOTAL_TYPE]          = 0;
    HmgMaximumNumberOfObjects[TOTAL_TYPE]          = 0;
    HmgMaximumNumberOfLookAsideObjects[TOTAL_TYPE] = 0;
    HmgNumberOfHandlesAllocated[TOTAL_TYPE]        = 0;
    HmgNumberOfObjectsAllocated[TOTAL_TYPE]        = 0;
    HmgNumberOfLookAsideHits[TOTAL_TYPE]           = 0;

    // now go through printing each line and accumulating totals
    for (ulLoop = 0; ulLoop <= MAX_TYPE; ulLoop++)
    {
        ExtOut(TableFormat,
               pszTypes[ulLoop],
               pulCount[ulLoop],
               ((pulCount[ulLoop] == HmgCurrentNumberOfHandles[ulLoop]) ? '=' :
                ((pulCount[ulLoop] < HmgCurrentNumberOfHandles[ulLoop]) ? '<' : '>')),
               HmgCurrentNumberOfHandles[ulLoop],
               HmgMaximumNumberOfHandles[ulLoop],
               HmgNumberOfHandlesAllocated[ulLoop],
               HmgCurrentNumberOfObjects[ulLoop],
               HmgMaximumNumberOfObjects[ulLoop],
               HmgNumberOfObjectsAllocated[ulLoop],
               HmgCurrentNumberOfLookAsideObjects[ulLoop],
               HmgMaximumNumberOfLookAsideObjects[ulLoop],
               HmgNumberOfLookAsideHits[ulLoop]);

        if (ulLoop != DEF_TYPE)
        {
            pulCount[TOTAL_TYPE]                    += pulCount[ulLoop];

            HmgCurrentNumberOfHandles[TOTAL_TYPE]   += HmgCurrentNumberOfHandles[ulLoop];
            HmgMaximumNumberOfHandles[TOTAL_TYPE]   += HmgMaximumNumberOfHandles[ulLoop];
            HmgNumberOfHandlesAllocated[TOTAL_TYPE] += HmgNumberOfHandlesAllocated[ulLoop];

            HmgCurrentNumberOfObjects[TOTAL_TYPE]   += HmgCurrentNumberOfObjects[ulLoop];
            HmgMaximumNumberOfObjects[TOTAL_TYPE]   += HmgMaximumNumberOfObjects[ulLoop];
            HmgNumberOfObjectsAllocated[TOTAL_TYPE] += HmgNumberOfObjectsAllocated[ulLoop];

            HmgCurrentNumberOfLookAsideObjects[TOTAL_TYPE] += HmgCurrentNumberOfLookAsideObjects[ulLoop];
            HmgMaximumNumberOfLookAsideObjects[TOTAL_TYPE] += HmgMaximumNumberOfLookAsideObjects[ulLoop];
            HmgNumberOfLookAsideHits[TOTAL_TYPE]    += HmgNumberOfLookAsideHits[ulLoop];
        }

    }

    ExtOut(TableFormat,
           pszTypes[TOTAL_TYPE],
           pulCount[TOTAL_TYPE],
           ((pulCount[TOTAL_TYPE] == HmgCurrentNumberOfHandles[TOTAL_TYPE]) ? '=' :
            ((pulCount[TOTAL_TYPE] < HmgCurrentNumberOfHandles[TOTAL_TYPE]) ? '<' : '>')),
           HmgCurrentNumberOfHandles[TOTAL_TYPE],
           HmgMaximumNumberOfHandles[TOTAL_TYPE],
           HmgNumberOfHandlesAllocated[TOTAL_TYPE],
           HmgCurrentNumberOfObjects[TOTAL_TYPE],
           HmgMaximumNumberOfObjects[TOTAL_TYPE],
           HmgNumberOfObjectsAllocated[TOTAL_TYPE],
           HmgCurrentNumberOfLookAsideObjects[TOTAL_TYPE],
           HmgMaximumNumberOfLookAsideObjects[TOTAL_TYPE],
           HmgNumberOfLookAsideHits[TOTAL_TYPE]);

    ExtOut ("\ncUnused objects %lu\n", cUnused);

    ExtOut("cUnknown objects %lu %lu\n",cUnknown,cUnknownSize);

    EXIT_API(S_OK);
}


char *pszTypes2[] = {
"DEF",
"DC",
"UNUSED_2",     // "LDB",
"UNUSED_3",     // "PDB",
"RGN",
"SURF",
"CLIOBJ",
"PATH",
"PAL",
"ICMLCS",
"LFONT",
"RFONT",
"PFE",
"PFT",
"ICMCXF",
"ICMDLL",
"BRUSH",
"UNUSED_17",    // "D3D_HANDLE",
"UNUSED_18",    // "CACHE",
"SPACE",
"UNUSED_20",    // "DBRUSH"
"META",
"EFSTATE",
"BMFD",
"VTFD",
"TTFD",
"RC",
"TEMP",
"DRVOBJ",
"DCIOBJ",
"SPOOL"
};


/******************************Public*Routine******************************\
* DECLARE_API( dumpobj  )
*
* History:
*  21-Feb-1995    -by- Lingyun Wang [lingyunw]
* Wrote it.
*  29-Dec-2000    -by- Jason Hartman [jasonha]
* Ported to Type debugging API.
\**************************************************************************/

#define USE_READ   0
#define ENTRY_RECURSE_LEVELS    1

DECLARE_API( dumpobjr )
{
    HRESULT     hr;

    BEGIN_API( dumpobjr );

    BOOL        CheckType = TRUE;
    Array<BOOL> MatchType(TOTAL_TYPE);
    Array<CHAR> TypeList;

    BOOL        CheckPid = FALSE;
    BOOL        ThisPid;
    DEBUG_VALUE MatchPid = {0, DEBUG_VALUE_INVALID};

    BOOL        CheckLock = FALSE;
    BOOL        Summary = FALSE;
    BOOL        BadArg = FALSE;

    BOOL        UseIndex = FALSE;
    DEBUG_VALUE StartIndex = {0, DEBUG_VALUE_INVALID};

    OutputControl   OutCtl(Client);
    ULONG64         EntryAddr;
    ULONG64         gcMaxHmgr;
    ULONG           EntrySize;

    ULONG           Index = 0;

    ULONG           LongestType = 0;
    int         i;

    for (i = 0; i <= MAX_TYPE; i++)
    {
        ULONG   Len = strlen(pszTypes2[i]);
        if (Len > LongestType)
        {
            LongestType = Len;
        }
    }

    while (!BadArg)
    {
        while (isspace(*args)) args++;

        if (*args == '-')
        {
            // Process switches

            args++;
            BadArg = (*args == '\0' || isspace(*args));

            while (*args != '\0' && !isspace(*args))
            {
                switch (tolower(*args))
                {
                    case 'a':
                        if (CheckType && !TypeList.IsEmpty())
                        {
                            BadArg = TRUE;
                            OutCtl.OutErr("Error: -a may not be specified with a Type list.\n");
                        }
                        else
                        {
                            CheckType = FALSE;
                        }
                        break;
                    case 'i':
                        if (CheckPid && MatchPid.Type == DEBUG_VALUE_INVALID)
                        {
                            BadArg = TRUE;
                            OutCtl.OutErr("Error: PID value not found after -%c.\n",
                                          (ThisPid ? 'p' : 'n'));
                        }
                        else
                        {
                            UseIndex = TRUE;
                        }
                        break;
                    case 'l': CheckLock = TRUE; break;
                    case 'n':
                        if (UseIndex && StartIndex.Type == DEBUG_VALUE_INVALID)
                        {
                            BadArg = TRUE;
                            OutCtl.OutErr("Error: Index value not found after -i.\n");
                        }
                        else if (CheckPid && ThisPid)
                        {
                            BadArg = TRUE;
                            OutCtl.OutErr("Error: -n may not be used with -p.\n");
                        }
                        else
                        {
                            CheckPid = TRUE;
                            ThisPid = FALSE;
                        }
                        break;
                    case 'p':
                        if (UseIndex && StartIndex.Type == DEBUG_VALUE_INVALID)
                        {
                            BadArg = TRUE;
                            OutCtl.OutErr("Error: Index value not found after -i.\n");
                        }
                        if (CheckPid && !ThisPid)
                        {
                            BadArg = TRUE;
                            OutCtl.OutErr("Error: -p may not be used with -n.\n");
                        }
                        else
                        {
                            CheckPid = TRUE;
                            ThisPid = TRUE;
                        }
                        break;
                    case 's': Summary = TRUE; break;
                    default:
                        BadArg = TRUE;
                        break;
                }

                if (BadArg) break;
                args++;
            }
        }
        else
        {
            if (*args == '\0') break;

            if (CheckPid && MatchPid.Type == DEBUG_VALUE_INVALID)
            {
                // This argument must be a PID.
                CHAR    EOPChar;
                PSTR    EOP = (PSTR)args;
                ULONG   Rem;

                // Find end of string to evaulate as a pid
                while (*EOP != '\0' && !isspace(*EOP)) EOP++;
                EOPChar = *EOP;
                *EOP = '\0';

                if (isxdigit(*args) &&
                    Evaluate(Client, args, DEBUG_VALUE_INT32,
                             EVALUATE_DEFAULT_RADIX, &MatchPid,
                             &Rem) == S_OK &&
                    args + Rem == EOP)
                {
                    args = EOP;
                }
                else
                {
                    OutCtl.OutErr("Error: Couldn't evaluate '%s' as a PID.\n",
                                  args);
                    BadArg = TRUE;
                }
                *EOP = EOPChar;
            }
            else if (UseIndex && StartIndex.Type == DEBUG_VALUE_INVALID)
            {
                // This argument must be the start Index.
                CHAR    EOIChar;
                PSTR    EOI = (PSTR)args;
                ULONG   Rem;

                // Find end of string to evaulate as an index
                while (*EOI != '\0' && !isspace(*EOI)) EOI++;
                EOIChar = *EOI;
                *EOI = '\0';

                if (isxdigit(*args) &&
                    Evaluate(Client, args, DEBUG_VALUE_INT32,
                             EVALUATE_DEFAULT_RADIX, &StartIndex,
                             &Rem) == S_OK &&
                    args + Rem == EOI)
                {
                    args = EOI;
                }
                else
                {
                    OutCtl.OutErr("Error: Couldn't evaluate '%s' as an Index.\n",
                                  args);
                    BadArg = TRUE;
                }
                *EOI = EOIChar;
            }
            else
            {
                // This argument must be a Type specification.
                if (!CheckType)
                {
                    OutCtl.OutErr("Error: a Type list may not be specified with -a.\n");
                    BadArg = TRUE;
                    break;
                }

                for (i = 0; i <= MAX_TYPE; i++)
                {
                    SIZE_T CheckLen = strlen(pszTypes2[i]);

                    if (_strnicmp(args, pszTypes2[i], CheckLen) == 0 &&
                        (!iscsym(args[CheckLen]) ||
                         (_strnicmp(&args[CheckLen], "_TYPE", 5) == 0 &&
                          !iscsym(args[CheckLen+5])
                       )))
                    {
                        if (!MatchType[i])
                        {
                            // Add Type to list
                            SIZE_T CatLoc = TypeList.GetLength();
                            if (CatLoc > 0)
                            {
                                TypeList[CatLoc] = ' ';
                            }
                            TypeList.Set(pszTypes2[i], CheckLen+1, CatLoc);
                        }
                        MatchType[i] = TRUE;
                        args += CheckLen;
                        if (iscsym(*args)) args += 5;
                        break;
                    }
                }

                if (i > MAX_TYPE)
                {
                    OutCtl.OutErr("Error: Unknown Type in '%s'.\n", args);
                    BadArg = TRUE;
                    break;
                }
            }
        }
    }

    if (!BadArg)
    {
        if (CheckType && TypeList.IsEmpty())
        {
            OutCtl.OutErr("Error: Missing -a or Type list.\n");
            BadArg = TRUE;
        }
        else if (CheckPid && MatchPid.Type == DEBUG_VALUE_INVALID)
        {
            OutCtl.OutErr("Error: Missing PID.\n");
            BadArg = TRUE;
        }
        else if (UseIndex && StartIndex.Type == DEBUG_VALUE_INVALID)
        {
            OutCtl.OutErr("Error: Missing Index.\n");
            BadArg = TRUE;
        }
    }

    if (BadArg)
    {
        OutCtl.Output("Usage: dumpobj [-?ls] [-np PID] [-i Index] <-a | Type(s)>\n"
                      "\n"
                      "     a - All object types\n"
                      "     i - Hmgr Entry Index to begin dump\n"
                      "     l - Check Lock\n"
                      "     n - Entries NOT owned by pid\n"
                      "     p - Entries owned by pid\n"
                      "     s - Summary counts only\n"
                      "\n"
                      " The -s option combined with the -a option will produce\n"
                      "  a list of the totals for each object type.\n");

        OutCtl.Output("\n Valid Type values are:\n");
        i = 0;
        while (i <= MAX_TYPE)
        {
            do
            {
                OutCtl.Output("   %-*s", LongestType, pszTypes2[i++]);
            } while (i <= MAX_TYPE && i%4);
            OutCtl.Output("\n");
        }

        return S_OK;
    }

    //
    // Get the pointers and counts from win32k
    //

    if ((hr = GetHandleTable(Client, &EntryAddr)) != S_OK ||
        (hr = GetMaxHandles(Client, &gcMaxHmgr)) != S_OK)
    {
        return hr;
    }
    
    EntrySize = GetEntrySize(Client);

    if (!gcMaxHmgr || !EntrySize || !EntryAddr)
    {
        OutCtl.OutErr("Error: gpentHmgr = %p, gcMaxHmgr = %I64u\n", EntryAddr, gcMaxHmgr);
        return S_OK;
    }

    if (UseIndex) Index = StartIndex.I32;

    OutCtl.Output("Searching %s %I64u entries starting at 0x%p",
                  (Index ? "remaining" : "all"), gcMaxHmgr - Index, EntryAddr);
    if (SessionId != CURRENT_SESSION)
    {
        OutCtl.Output(" in session %s", SessionStr);
    }
    OutCtl.Output(".\n");

    PDEBUG_CONTROL  Control;
    PDEBUG_SYMBOLS  Symbols;
    BOOL            IsPointer64Bit;
    BOOL            ComposeHandles;
    ULONG           PointerSize;

    if ((hr = Client->QueryInterface(__uuidof(IDebugControl),
                                     (void **)&Control)) != S_OK)
    {
        return hr;
    }

    if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                     (void **)&Symbols)) != S_OK)
    {
        Control->Release();
        return hr;
    }

    if (!Summary)
    {
        // Setup some things neded for listing entries.

        IsPointer64Bit = (Control->IsPointer64Bit() == S_OK);

        // Make sure HandleFullUnique is valid
        hr = GetFullUniqueFromHandle(Client, 0, NULL);
        if (hr != S_OK)
        {
            OutCtl.OutWarn("Unable to compose handles from entries, %s.\n",
                          pszHRESULT(hr));
        }
        ComposeHandles = (hr == S_OK);
    }

    OutCtl.Output("Object %s for %s objects",
                  Summary ? "count" : "list",
                  CheckType ? TypeList.GetBuffer() : "all");

    if (CheckPid)
    {
        if (!ThisPid) OutCtl.Output(" NOT");
        OutCtl.Output(" owned by PID 0x%lx\n", MatchPid.I32);
    }
    else
    {
        OutCtl.Output(" with any owner\n");
    }

    if (!Summary)
    {
        PointerSize = IsPointer64Bit ? 21 : 10;

        //            "0x1234 0x12345678 0xXX 0x12345678 1    4294967295 Tttt 0x1234 0xXX 0x...\n"
        OutCtl.Output("Index  Handle     %-*s PID        Lock ShareCount %-*s Unique %-*s Flags\n",
                      PointerSize, "ObjectAddr", LongestType, "Type", PointerSize, "UserAddr");
    }

    Array<ULONG>    TypeCount(TOTAL_TYPE);

    TypeOutputParser    TypeReader(Client);
    OutputState         OutState(Client, FALSE);
    DEBUG_VALUE     Type;
#if ENTRY_RECURSE_LEVELS >= 2
    DEBUG_VALUE     Lock;
    DEBUG_VALUE     PID;
#else
    DEBUG_VALUE     ulObj;
#endif
    DEBUG_VALUE     Unique;
    DEBUG_VALUE     Flags;
    ULONG           FailedReads = 0;
    BOOL            FailedRead = FALSE;
    BOOL            NeedNewLine = FALSE;

    HANDLE          hHeap = GetProcessHeap();
    PBYTE           EntryBuffer = NULL;
    ULONG           ObjtOffset;

    if (hHeap != NULL &&
        (EntryBuffer = (PBYTE)HeapAlloc(hHeap, 0, EntrySize)) != NULL &&
        Symbols->GetFieldOffset(Entry.Module, Entry.TypeId, "Objt", &ObjtOffset) == S_OK &&
        (hr = OutState.Setup(0, &TypeReader)) == S_OK)
    {
        for (Index = 0; Index < gcMaxHmgr; Index++, EntryAddr += EntrySize/*, DbgPrint(" }\n")*/)
        {
//            DbgPrint("{");
            if (FailedRead) FailedReads++;

            if (Index % 40 == 0)
            {
                OutCtl.Output((Summary ? DEBUG_OUTPUT_NORMAL : DEBUG_OUTPUT_VERBOSE), ".");
                NeedNewLine = TRUE;
            }

            if (Control->GetInterrupt() == S_OK)
            {
                NeedNewLine = FALSE;
                OutCtl.OutErr("User aborted at index %lu\n", Index);
                hr = E_ABORT;
                break;
            }

            TypeReader.DiscardOutput();
/*            DbgPrint(" Read");
            Symbols->ReadTypedDataVirtual(EntryAddr,
                                          Entry.Module,
                                          Entry.TypeId,
                                          EntryBuffer,
                                          EntrySize,
                                          NULL);
            DbgPrint("Type");*/
//            DbgPrint(" Out");
            if (SessionId != CURRENT_SESSION)
            {
                ULONG64 PhysEntryAddr;

                if ((hr = GetPhysicalAddress(Client,
                                             SessionId,
                                             EntryAddr,
                                             &PhysEntryAddr)) == S_OK)
                {
                    hr = OutState.OutputType(TRUE,
                                             PhysEntryAddr,
                                             Entry.Module,
                                             Entry.TypeId,
                                             DEBUG_OUTTYPE_NO_INDENT |
                                             DEBUG_OUTTYPE_NO_OFFSET |
                                             DEBUG_OUTTYPE_COMPACT_OUTPUT |
                                             DEBUG_OUTTYPE_RECURSION_LEVEL(ENTRY_RECURSE_LEVELS));
                }
            }
            else
            {
                hr = OutState.OutputTypeVirtual(EntryAddr,
                                                Entry.Module,
                                                Entry.TypeId,
                                                DEBUG_OUTTYPE_NO_INDENT |
                                                DEBUG_OUTTYPE_NO_OFFSET |
                                                DEBUG_OUTTYPE_COMPACT_OUTPUT |
                                                DEBUG_OUTTYPE_RECURSION_LEVEL(ENTRY_RECURSE_LEVELS));
            }
//            DbgPrint("Type");

            if (hr == S_OK)
            {
//                DbgPrint(" Objt");
#if USE_READ
                
#else
                hr = TypeReader.Get(&Type, "Objt", DEBUG_VALUE_INT32);
#endif
                if (hr != S_OK) Type.Type = DEBUG_VALUE_INVALID;

                if (CheckType &&
                    ((FailedRead = (Type.Type != DEBUG_VALUE_INT32)) ||
                     !MatchType[Type.I32]))
                {
//                    OutCtl.OutWarn("Type %lu doesn't match.\n", Type.I32);
                    continue;
                }

#if ENTRY_RECURSE_LEVELS >= 2
//                DbgPrint(" Lock");
                if (CheckLock &&
                    ((FailedRead = (TypeReader.Get(&Lock, "Lock",
                                                   DEBUG_VALUE_INT32) != S_OK)) ||
                     Lock.I32 == 0))
                {
                    OutCtl.OutWarn("Lock required, but not locked.\n");
                    continue;
                }

//                DbgPrint(" PID");
                PID.Type = DEBUG_VALUE_INVALID;
                if (CheckPid)
                {
                    if ((FailedRead = (TypeReader.Get(&PID, "Pid_Shifted",
                                                      DEBUG_VALUE_INT32) != S_OK)) ||
                        ((2*PID.I32 == MatchPid.I32) ? !ThisPid : ThisPid))
                    {
                        continue;
                    }
                }
#else
                ulObj.Type = DEBUG_VALUE_INVALID;

                if (CheckLock || CheckPid)
                {
                    if (FailedRead = (TypeReader.Get(&ulObj, "ulObj",
                                                     DEBUG_VALUE_INT32) != S_OK))
                    {
//                        OutCtl.OutWarn("ulObj is required, but wasn't read.\n");
                        continue;
                    }

//                    DbgPrint(" Lock");
                    if (CheckLock && (ulObj.I32 & 1) == 0)
                    {
//                        OutCtl.OutWarn("Lock required, but not locked.\n");
                        continue;
                    }

//                    DbgPrint(" PID");
                    if (CheckPid &&
                        ((ulObj.I32 & ~1) == MatchPid.I32) ? !ThisPid : ThisPid)
                    {
                        continue;
                    }
                }
#endif

                FailedRead = (Type.Type != DEBUG_VALUE_INT32);

                if (!FailedRead)
                {
//                    DbgPrint(" MATCH");
                    TypeCount[Type.I32]++;
                }

                if (!Summary)
                {
                    PCSTR   pszValue;

                    if (NeedNewLine) 
                    {
                        OutCtl.OutVerb("\n");
                        NeedNewLine = FALSE;
                    }

                    // Index
                    OutCtl.Output("0x%.4lx ", Index);

                    // Handle
                    if (ComposeHandles &&
                        TypeReader.Get(&Unique, "FullUnique", DEBUG_VALUE_INT64) == S_OK)
                    {
                        ULONG64 Handle64;

                        Handle64 = (Index & ~(HandleFullUnique->Mask)) |
                                   (Unique.I64 << HandleFullUnique->BitPos);

                        if (IsPointer64Bit)
                        {
                            Handle64 = DEBUG_EXTEND64(Handle64);
                        }

                        OutCtl.Output("0x%p ", Handle64);
                    }
                    else
                    {
                        OutCtl.Output("%*s ", PointerSize, "?");
                    }

                    // ObjectAddr
                    if (TypeReader.Get(NULL, "pobj") == S_OK &&
                        TypeReader.GetValueString(&pszValue) == S_OK)
                    {
                        OutCtl.Output("%*s ", PointerSize, pszValue);
                    }
                    else
                    {
                        OutCtl.Output("%*s ", PointerSize, "?");
                    }

                    // PID
#if ENTRY_RECURSE_LEVELS >= 2
                    if (PID.Type == DEBUG_VALUE_INT32 ||
                        TypeReader.Get(&PID, "Pid_Shifted", DEBUG_VALUE_INT32) == S_OK)
                    {
                        OutCtl.Output("0x%8lx ", 2*PID.I32);
                    }
                    else
                    {
                        OutCtl.Output("       ? ");
                    }
#else
                    if (ulObj.Type == DEBUG_VALUE_INT32 ||
                        TypeReader.Get(&ulObj, "ulObj", DEBUG_VALUE_INT32) == S_OK)
                    {
                        OutCtl.Output("0x%.8lx ", ulObj.I32 & ~1);
                    }
                    else
                    {
                        OutCtl.Output("       ? ");
                    }
#endif

                    // Lock
#if ENTRY_RECURSE_LEVELS >= 2
                    if (Lock.Type == DEBUG_VALUE_INT32 ||
                        TypeReader.Get(&Lock, "Lock", DEBUG_VALUE_INT32) == S_OK)
                    {
                        OutCtl.Output("%4lu ", Lock.I32);
                    }
                    else
                    {
                        OutCtl.Output("   ? ");
                    }
#else
                    if (ulObj.Type == DEBUG_VALUE_INT32)
                    {
                        OutCtl.Output("%4lu ", ulObj.I32 & 1);
                    }
                    else
                    {
                        OutCtl.Output("   ? ");
                    }
#endif

                    // ShareCount
                    OutCtl.Output("<Not Read> ");

                    // Type
                    if (Type.Type == DEBUG_VALUE_INT32 ||
                        TypeReader.Get(&Type, "Objt", DEBUG_VALUE_INT32) == S_OK)
                    {
                        OutCtl.Output("%-*s ", LongestType, pszTypes2[Type.I32]);
                    }
                    else
                    {
                        OutCtl.Output("%-*s ", LongestType, "?");
                    }

                    // Unique
                    if (Unique.Type == DEBUG_VALUE_INT64 ||
                        TypeReader.Get(&Unique, "FullUnique", DEBUG_VALUE_INT64) == S_OK)
                    {
                        OutCtl.Output("0x%.4I64x ", Unique.I64);
                    }
                    else
                    {
                        OutCtl.Output("     ? ");
                    }

                    // UserAddr
                    if (TypeReader.Get(NULL, "pUser") == S_OK &&
                        TypeReader.GetValueString(&pszValue) == S_OK)
                    {
                        OutCtl.Output("%*s ", PointerSize, pszValue);
                    }
                    else
                    {
                        OutCtl.Output("%*s ", PointerSize, "?");
                    }

                    // Flags
                    if (TypeReader.Get(&Flags, "Flags", DEBUG_VALUE_INT64) == S_OK &&
                        TypeReader.GetValueString(&pszValue) == S_OK)
                    {
                        OutCtl.Output("%s (", pszValue);
                        Flags.I64 = OutputFlags(&OutCtl, afdENTRY_Flags, Flags.I64, TRUE);
                        OutCtl.Output(")");
                        if (Flags.I64)
                        {
                            OutCtl.Output(" Unknown Flags: 0x%I64x", Flags.I64);
                        }
                    }
                    else
                    {
                        OutCtl.Output("?");
                    }

                    OutCtl.Output("\n");
                }
            }
            else
            {
                FailedRead = TRUE;
            }
        }

        if (FailedRead) FailedReads++;

        if (NeedNewLine) 
        {
            OutCtl.Output((Summary ? DEBUG_OUTPUT_NORMAL : DEBUG_OUTPUT_VERBOSE), "\n");
        }

        if (FailedReads)
        {
            OutCtl.OutWarn("Warning: %lu entry reads failed -> uncounted.\n", FailedReads);
        }

        if (Index < gcMaxHmgr)
        {
            OutCtl.OutWarn("Warning: Entries at and beyond index 0x%lx weren't processed.\n", Index);
        }

        // Display results
        ULONG   ObjCount = 0;

        for (i = 0; i <= MAX_TYPE; i++)
        {
            if (CheckType ? MatchType[i] : TypeCount[i] > 0)
            {
                ObjCount += TypeCount[i];
                OutCtl.Output("%-*s %lu\n", LongestType, pszTypes2[i], TypeCount[i]);
            }
        }

        OutCtl.Output("Total objects = %lu", ObjCount);
        // Subtract any unused objects
        if (TypeCount[0] > 0)
        {
            OutCtl.Output(" - %lu %s = %lu",
                          TypeCount[0], pszTypes2[0],
                          ObjCount - TypeCount[0]);
        }
        OutCtl.Output("\n");
    }

    if (EntryBuffer != NULL)
    {
        HeapFree(hHeap, 0, EntryBuffer);
    }

    Symbols->Release();
    Control->Release();

    return S_OK;
}

#if 1

#define TYPE_ALL          0
#define PID_ALL      0x8002

DECLARE_API( dumpobj  )
{
    BEGIN_API( dumpobj );
    INIT_API();
    ExtWarn("Extension 'dumpobj' is not fully converted.\n");
    HRESULT hr;
    ULONG64 pent;
    ULONG64 gcMaxHmgr;
    ULONG   entSize;
    ULONG   ulLoop;
    ULONG   Pid = PID_ALL;
    BOOL    AnyPid = TRUE;
    BOOL    MatchPid = TRUE;
    ULONG   Type = TYPE_ALL;
    BOOL    bCheckLock = FALSE;
    BOOL    bSummary = FALSE;
    BOOL    bShareCount = FALSE;
    int     i;

    PARSE_ARGUMENTS(dumpobj_help);

    if(ntok<1) {
      goto dumpobj_help;
    }

    //find valid tokens - ignore the rest
    bShareCount = (parse_iFindSwitch(tokens, ntok, 'c') >= 0);
    bCheckLock = (parse_iFindSwitch(tokens, ntok, 'l') >= 0);
    bSummary = (parse_iFindSwitch(tokens, ntok, 's') >= 0);
    MatchPid = !(parse_iFindSwitch(tokens, ntok, 'n') >= 0);
    tok_pos = parse_iFindSwitch(tokens, ntok, 'p');
    if (tok_pos>=0)
    {
        tok_pos++;

        if ((tok_pos+1)>=ntok)
        {
            goto dumpobj_help;               //-p requires a pid and it can't be the last arg
        }

        AnyPid = FALSE;
        Pid = (LONG)GetExpression(tokens[tok_pos]);
    }

    //find first non-switch token not preceeded by a -p
    tok_pos = -1;
    do {
      tok_pos = parse_FindNonSwitch(tokens, ntok, tok_pos+1);
    } while ( (tok_pos!=-1)&&(parse_iIsSwitch(tokens, tok_pos-1, 'p')));
    if(tok_pos==-1) {
      goto dumpobj_help;
    }


//CHECKLOOP
    for (Type = 0; Type <= MAX_TYPE; ++Type)
    {
        if (parse_iIsToken(tokens, tok_pos, pszTypes2[Type]) ||
            parse_iIsToken(tokens, tok_pos, pszTypes[Type]))
        {
            break;
        }
    }

    if (Type > MAX_TYPE) {
        goto dumpobj_help;
    }
    //
    // Get the pointers and counts from win32k
    //

    if ((hr = GetHandleTable(Client, &pent)) != S_OK ||
        (hr = GetMaxHandles(Client, &gcMaxHmgr)) != S_OK)
    {
        EXIT_API(hr);
    }
    
    entSize = GetEntrySize(Client);

    ExtVerb("gpentHmgr = %p, gcMaxHmgr = %I64u\n", pent, gcMaxHmgr);

    if (!gcMaxHmgr || !entSize || !pent)
    {
        ExtErr("Error: gpentHmgr = %p, gcMaxHmgr = %I64u\n", pent, gcMaxHmgr);
        EXIT_API(S_OK);
    }

    //
    // dprintf out the amount reserved and committed, note we assume a 4K page size
    //

    dprintf("object list for %s type objects",Type == TYPE_ALL ? "ALL" : pszTypes2[Type]);

    if (AnyPid)
    {
        dprintf(" with any owner\n");
    }
    else
    {
        if (!MatchPid) dprintf(" NOT");
        dprintf(" owned by PID 0x%lx\n",Pid);
    }

    if(!bSummary) {
      dprintf("%4s, %8s, %6s, %6s, %4s, %8s, %8s, %6s, %6s, %8s,%9s\n",
           "I","handle","Lock","sCount","pid","pv","objt","unique","Flags","pUser","Tlock");

      dprintf("--------------------------------------------------------------------------------------------\n");
    }

    {
        LONG ObjCount = 0;
        LONG ObjArray[MAX_TYPE+1];

        for(i=0;i<=MAX_TYPE;i++) {
          ObjArray[i]=0;
        }

//CHECKLOOP
        for (ulLoop = 0; ulLoop < gcMaxHmgr; ulLoop++)
        {
            if (CheckControlC())
            {
                ExtErr("User aborted at index %lu\n", ulLoop);
                EXIT_API(E_ABORT);
            }

            if (bSummary && ulLoop % 40 == 0) ExtVerb(".");

            ULONG   error;
            ULONG   objt;
            ULONG   ThisPid;
            ULONG64 pobj;
            USHORT  fullUnique;
            UCHAR   flags;
            ULONG64 pUser;
            ULONG   owner;
            ULONG   shareCount;

            if (error = GetFieldValue(pent, szEntryType, "Objt", objt))
            {
                ExtErr("Error reading table entry\n");
                ExtErr("  (GetFieldValue returned %s @ %p)\n", pszWinDbgError(error), pent);
                EXIT_API(S_OK);
            }
            
            if (error = GetFieldValue(pent, szEntryType, "ObjectOwner", owner))
            {
                ExtErr("error reading table entry\n");
                ExtErr("  (GetFieldValue returned %s)\n", pszWinDbgError(error));
                EXIT_API(S_OK);
            }
            
            ThisPid = owner & PID_MASK;

            if (0 && gbVerbose)
            {
                dprintf("Type: %lu, PID: %lu, Locked: %s\n", objt, ThisPid, (owner & LOCK_MASK) ? "YES" : "NO");
            }

            if (
                 ((objt == Type) || (Type == TYPE_ALL)) &&
                 (AnyPid ||
                  (MatchPid ? (ThisPid == Pid) : (ThisPid != Pid))) &&
                 ((!bCheckLock) || (owner & LOCK_MASK))
               )
            {

                ObjCount++;

                if (!bSummary)
                {
                    if (GetFieldData(pent, szEntryType, "FullUnique", sizeof(fullUnique), &fullUnique))
                    {
                        ExtErr("error reading FullUnique\n");
                        EXIT_API(S_OK);
                    }

                    if (GetFieldData(pent, szEntryType, "Flags", sizeof(flags), &flags))
                    {
                        ExtErr("error reading flags\n");
                        EXIT_API(S_OK);
                    }

                    if (GetFieldData(pent, szEntryType, "pUser", sizeof(pUser), &pUser))
                    {
                        ExtErr("error reading pUser\n");
                        EXIT_API(S_OK);
                    }

                    if (GetFieldData(pent, szEntryType, "einfo.pobj", sizeof(pobj), &pobj))
                    {
                        ExtErr("error reading einfo.pobj\n");
                        EXIT_API(S_OK);
                    }

                    dprintf("%4lx, %08lx, %6lx",
                        ulLoop,
                        MAKE_HMGR_HANDLE(ulLoop,fullUnique),
                        owner & LOCK_MASK);

                    if (!bShareCount)
                    {
                        dprintf(", Unread");
                    }
                    else if (GetFieldData(pobj, GDIType(_BASEOBJECT), "ulShareCount", sizeof(shareCount), &shareCount))
                    {
                        dprintf(", ??????");
                    }
                    else
                    {
                        dprintf(", %6lx", shareCount);
                    }

                    dprintf(", %4lx, %p", ThisPid, pobj);

                    dprintf(", %8s, %6hx, %6lx, %p, %p\n",
                        pszTypes2[objt],
                        fullUnique,
                        flags,
                        pUser,
                        pUser);
                }
                else
                {
                    ObjArray[objt]++;
                }

            }

            pent += entSize;
        }

        if(bSummary && (Type==TYPE_ALL)) {
          for(i=0;i<=MAX_TYPE; i++) {
            if(ObjArray[i]>0) {
              dprintf("%s\t%ld\n", pszTypes2[i], ObjArray[i]);
            }
          }
        }

        ExtOut("Total objects = %li",ObjCount);
        // Subtract any unused objects
        if (bSummary && ObjArray[0])
        {
            ExtOut(" - %li = %li", ObjArray[0], ObjCount - ObjArray[0]);
        }
        ExtOut("\n");
    }

    EXIT_API(S_OK);

dumpobj_help:
    dprintf("Usage: dumpobj [-?] [-n] [-p pid] [-l] [-s] object_type\n");
    dprintf("\t-l check lock\n");
    dprintf("\t-s summary\n");
    dprintf("\t-n not pid\n\n");
    dprintf(" The -s option combined with the DEF object type will produce\n"
            "  a list of the totals for each object type.\n\n");

    dprintf(" Valid object_type values are:\n");
    for (i=0; i<=MAX_TYPE; ) {
        do
        {
            dprintf("   %-12s", pszTypes2[i++]);
        } while (i <= MAX_TYPE && i%4);
        dprintf("\n");
    }

    EXIT_API(S_OK);
}
#endif



/******************************Public*Routine******************************\
* DECLARE_API( dh  )
*
* Debugger extension to dump a handle.
*
* History:
*  21-Feb-1995    -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DECLARE_API( dh  )
{
    BEGIN_API( dh );

    HRESULT     hr;
    DEBUG_VALUE Handle;
    ULONG64     offENTRY;
    BOOL        Physical;
    OutputControl   OutCtl(Client);

    while (isspace(*args)) args++;

    if (*args == '-' ||
        (hr = Evaluate(Client, args, DEBUG_VALUE_INT64, 0, &Handle, NULL)) != S_OK ||
        Handle.I64 == 0)
    {
        OutCtl.Output("Usage: dh [-?] <Handle>\n");
    }
    else
    {
        OutCtl.Output("--------------------------------------------------\n");
        OutCtl.Output("GDI Entry for handle 0x%p:\n", Handle.I64);

        if ((hr = GetEntryAddress(Client, Handle.I64, &offENTRY, &Physical)) == S_OK)
        {
            OutputFilter    OutFilter(Client);
            OutputState     OutState(Client, FALSE);
            OutputControl   OutCtl;

            if ((hr = OutState.Setup(DEBUG_OUTPUT_NORMAL |
                                     DEBUG_OUTPUT_ERROR |
                                     DEBUG_OUTPUT_WARNING,
                                     &OutFilter)) == S_OK &&
                (hr = OutCtl.SetControl(DEBUG_OUTCTL_THIS_CLIENT |
                                        DEBUG_OUTCTL_NOT_LOGGED,
                                        OutState.Client)) == S_OK)
            {
                hr = DumpType(OutState.Client,
                              szEntryType,
                              offENTRY,
                              DEBUG_OUTTYPE_NO_INDENT | DEBUG_OUTTYPE_NO_OFFSET,
                              &OutCtl,
                              Physical);

                if (hr == S_OK)
                {
                    OutFilter.Skip(OUTFILTER_QUERY_EVERY_LINE |
                                   OUTFILTER_QUERY_WHOLE_WORD,
                                   "_EINFO");
                    OutFilter.Skip(OUTFILTER_SKIP_DEFAULT, "_OBJECTOWNER");

                    BOOL        DumpObj = FALSE;
                    DEBUG_VALUE Value;
                    CHAR        ReplacementText[80];

                    // Check for used vs free entry
                    if (OutFilter.Query("Objt", &Value, DEBUG_VALUE_INT8) == S_OK)
                    {
                        DumpObj = (Value.I8 != DEF_TYPE);
                        OutFilter.Skip(OUTFILTER_QUERY_EVERY_LINE |
                                       OUTFILTER_QUERY_WHOLE_WORD,
                                       (Value.I8 == DEF_TYPE) ? "pobj" : "hFree");
                    }

                    // Account for Pid shifting
                    if (OutFilter.Query("Pid_Shifted", &Value, DEBUG_VALUE_INT32) == S_OK)
                    {
                        sprintf(ReplacementText,
                                "Pid              : 0x%lx (%ld)",
                                2*Value.I32, 2*Value.I32);
                        OutFilter.Replace(OUTFILTER_REPLACE_LINE | OUTFILTER_QUERY_ONE_LINE,
                                          "Pid_Shifted", ReplacementText);
                    }

                    hr = OutFilter.OutputText();

                    if (hr == S_OK && DumpObj)
                    {
                        if (TargetClass != DEBUG_CLASS_USER_WINDOWS)
                        {
                            if ((hr = OutFilter.Query("pobj", &Value, DEBUG_VALUE_INT64)) == S_OK)
                            {
                                // Restore OutCtl settings
                                OutCtl.SetControl(DEBUG_OUTCTL_AMBIENT, Client);
                                OutCtl.Output("--------------------------------------------------\n");

                                if (Physical)
                                {
                                    ULONG64 PhysAddr;

                                    ASSERTMSG("HMGR Entry was looked up thru a physical address, but the SessionId is CURRENT.\n", SessionId != CURRENT_SESSION);
                                    hr = GetPhysicalAddress(Client,
                                                            SessionId,
                                                            Value.I64,
                                                            &PhysAddr);
                                    if (hr == S_OK)
                                    {
                                        Value.I64 = PhysAddr;
                                    }
                                    else
                                    {
                                        OutCtl.OutErr("GDI BaseObject @ 0x%p in session %lu in unavailable.\n",
                                                      Value.I64, SessionId);
                                    }
                                }

                                if (hr == S_OK)
                                {
                                    OutCtl.Output("GDI BaseObject @ %s0x%p:\n",
                                                  ((Physical) ? "#" : ""),
                                                  Value.I64);

                                    hr = DumpType(Client,
                                                  "_BASEOBJECT",
                                                  Value.I64,
                                                  DEBUG_OUTTYPE_NO_INDENT |
                                                  DEBUG_OUTTYPE_NO_OFFSET,
                                                  &OutCtl,
                                                  Physical);
                                }
                            }
                        }
                    }
                }

                if (hr != S_OK)
                {
                    OutCtl.OutErr("Type Dump returned %s.\n", pszHRESULT(hr));
                }
            }
            else
            {
                OutCtl.OutErr(" Output state/control setup returned %s.\n",
                              pszHRESULT(hr));
            }
        }
        else
        {
            OutCtl.Output(" ** Unable to find a valid entry address. **\n");
        }

        OutCtl.Output("--------------------------------------------------\n");  
    }

    return S_OK;
}


/******************************Public*Routine******************************\
* DECLARE_API( dht  )
*
* Debugger extension to extract type data from a handle.
*
* History:
*  21-Feb-1995    -by- Lingyun Wang [lingyunw]
* Wrote it.
*  30-Nov-2000    -by- Jason Hartman [jasonha]
* Ported to 64 bit debugger API.
\**************************************************************************/

DECLARE_API( dht  )
{
    BEGIN_API( dht );

    HRESULT     hr;
    DEBUG_VALUE Handle;
    ULONG64     Index;
    ULONG64     FullUnique;
    OutputControl   OutCtl(Client);

    while (isspace(*args)) args++;

    if (*args == '-' ||
        (hr = Evaluate(Client, args, DEBUG_VALUE_INT64, 0, &Handle, NULL)) != S_OK ||
        Handle.I64 == 0)
    {
        OutCtl.Output("Usage: dht [-?] <Handle>\n");
    }
    else
    {
        OutCtl.Output("Handle: 0x%p\n", Handle.I64);

        if (GetIndexFromHandle(Client, Handle.I64, &Index) == S_OK)
        {
            OutCtl.Output("  Index: 0x%p\n", Index);
        }
        if (GetFullUniqueFromHandle(Client, Handle.I64, &FullUnique) == S_OK)
        {
            OutCtl.Output("  FullUnique: 0x%p\n", FullUnique);
        }
        OutCtl.Output("  Type: ");
        hr = OutputHandleInfo(&OutCtl, Client, &Handle);
        OutCtl.Output("\n");
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\gdiexts.cxx ===
/******************************Module*Header*******************************\
* Module Name: gdiexts.cxx
*
* Copyright (c) 1995-2000 Microsoft Corporation
*
\**************************************************************************/


#include "precomp.hxx"

// TODO: Break this file up grouping close knit extensions together.


#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
VOID vPrintBLTRECORD(VOID  *pv);
void vDumpLOGFONTW(LOGFONTW*, LOGFONTW*);

#endif  // DOES NOT SUPPORT API64

//
// This function is used for writing DIB images to disk in BMP format
// from a debugger extension.
//

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
#define DIBDBG
int WriteDIBToFile(void *pBits, DWORD w, DWORD h,
                   LONG byte_width, int colordepth,
                   void *pPal, DWORD palentries,
                   char *filename) {
  FILE *fp;
  VOID *pvTmpBits=NULL;
  VOID *pvTmpPal=NULL;
  int r;

  #ifdef DIBDBG
    dprintf("input:\n");
    dprintf("pBits: %p\n", pBits);
    dprintf("width: %ld\n", w);
    dprintf("height: %ld\n", h);
    dprintf("byte width: %ld\n", byte_width);
    dprintf("color depth: %ld\n", colordepth);
    dprintf("pPal: %p\n", pPal);
    dprintf("palette entries: %ld\n", palentries);
    dprintf("filename: %s\n", filename);
  #endif

  dprintf("starting\n");
  if((fp = fopen(filename, "wb")) == NULL) {
    dprintf("Error opening %s\n", filename);
    dprintf("If you're using a share, make sure the share is writeable by the machine running the debugger\n");
    return 1;
  }

  dprintf("opened\n");

  if((pPal==NULL)&&(palentries!=0)) {
    dprintf("Palette pointer is NULL, but palentries is %ld (should be 0)\n", palentries);
    fclose(fp);
    return 2;
  }

  if(byte_width<0) {
    dprintf("Upside down DIB, inverting...\n");
    byte_width = -byte_width;
  }

  //write the file header
  BITMAPFILEHEADER bfh;
  bfh.bfType='MB';    //backwords 'BM'
  bfh.bfSize = (DWORD)byte_width*h+sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFOHEADER);
  bfh.bfReserved1=0;
  bfh.bfReserved2=0;
  bfh.bfOffBits=sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFOHEADER)+sizeof(DWORD)*palentries;
  r = fwrite(&bfh, sizeof(bfh), 1, fp);
  if(!r) {
    dprintf("Error writing file header\n");
    fclose(fp);
    return 5;
  }
  dprintf("header\n");

  //write the BITMAPINFOHEADER
  BITMAPINFOHEADER bih;
  bih.biSize = sizeof(BITMAPINFOHEADER);
  bih.biWidth = (LONG)w;
  bih.biHeight = (LONG)h;
  bih.biPlanes = 1;
  bih.biBitCount = (WORD)colordepth;
  bih.biCompression = 0;
  bih.biSizeImage = 0;
  bih.biXPelsPerMeter = 0;
  bih.biYPelsPerMeter = 0;
  bih.biClrUsed = 0;
  bih.biClrImportant = 0;
  r = fwrite(&bih, sizeof(bih), 1, fp);
  if(!r) {
    dprintf("Error writing header\n");
    fclose(fp);
    return 4;
  }
  dprintf("header\n");

  //write out the palette - if one exists
  if( (pPal!=NULL)&&(palentries>0) ) {
    dprintf("writing the palette\n");
    pvTmpPal = (void *)malloc(sizeof(DWORD)*palentries);
    if(pvTmpPal==NULL) {
      fclose(fp);
      return 7;
    }
    move2(pvTmpPal, pPal, sizeof(DWORD)*palentries);
    r = fwrite(pvTmpPal, sizeof(DWORD)*palentries, 1, fp);
    if(!r) {
      dprintf("Error writing palette\n");
      fclose(fp);
      return 3;
    }
  }
  dprintf("palette\n");


  //write out the bits
  pvTmpBits = (VOID *)malloc(byte_width*h);
  if(pvTmpBits==NULL) {
    if(pvTmpPal) free(pvTmpPal);
    fclose(fp);
    return 8;
  }
  move2(pvTmpBits, pBits, byte_width*h);

  dprintf("bits\n");


  r = fwrite(pvTmpBits, byte_width*h, 1, fp);
  if(!r) {
    dprintf("Error writing bits\n");
    fclose(fp);
    return 6;
  }
  dprintf("write\n");

  fclose(fp);
  if(pvTmpPal) free(pvTmpPal);
  if(pvTmpBits) free(pvTmpBits);

  dprintf("Wrote DIB to %s\n", filename);
  return 0;
}
#endif  // DOES NOT SUPPORT API64


/******************************Public*Routine******************************\
* DECLARE_API( ddib  )
*
* History:
*  11/12/98    -by- Adrian Secchia [asecchia]
* Wrote it.
\**************************************************************************/
DECLARE_API( ddib )
{
    PARSE_ARGUMENTS(ddib_help);
    if(ntok<1) {
      goto ddib_help;
    }

    int w_sw, h_sw, b_sw, f_sw, y_sw, p_sw, i_sw;
    
    //find valid tokens - ignore the rest
    w_sw = parse_iFindSwitch(tokens, ntok, 'w');
    h_sw = parse_iFindSwitch(tokens, ntok, 'h');
    b_sw = parse_iFindSwitch(tokens, ntok, 'b');
    f_sw = parse_iFindSwitch(tokens, ntok, 'f');
    y_sw = parse_iFindSwitch(tokens, ntok, 'y');
    p_sw = parse_iFindSwitch(tokens, ntok, 'p');
    i_sw = parse_iFindSwitch(tokens, ntok, 'i');

    //
    // i must be present unless all of w, h and b are present.
    // conversely w, h and b must be present unless i is present.
    // f must always be present
    //
    if( ((i_sw<0) && ((w_sw<0) || (h_sw<0) || (b_sw<0)) ) ||
        (f_sw<0)) {
      dprintf("required parameter missing\n");
      goto ddib_help;
    }

    if( (w_sw>ntok-3) || (h_sw>ntok-3) ||
        (b_sw>ntok-3) || (f_sw>ntok-3) ||
        (y_sw>ntok-3) || (p_sw>ntok-4) ||
        (i_sw>ntok-3) ) {
      dprintf("invalid parameter format\n");
      goto ddib_help;
    }

    EXIT_API(S_OK);

ddib_help:
  dprintf("Usage: ddib [-?] [-i LPBITMAPINFO] [-w Width] [-h Height] [-f filename] [-b Bits] [-y Byte_Width] [-p palbits palsize] pbits\n");
  dprintf("\t-i required parameter specifies LPBITMAPINFO structure (hex)\n");
  dprintf("\t-w required parameter specifies width in pixels (hex)\n");
  dprintf("\t-h required parameter specifies height in pixels (hex)\n");
  dprintf("\t-b required parameter specifies number of bits per pixel (hex)\n");
  dprintf("\t-y optional parameter specifies byte width of dib (hex)\n"
          "\t   if omitted this parameter is computed from w and b parameters\n");
  dprintf("\t-p optonal parameter specifies the palette pointer and the number of palette entries (hex)\n");
  dprintf("\t-f required parameter specifies the filename to store the dib - usually a public share\n");
  dprintf("\tpBits required parameter specifies pointer to the bit data - must be last.\n");
  dprintf("If the -i option is supplied then the -w, -h and -b become optional.\n");
  dprintf("If the -i is omitted, then -w, -h and -b are required.\n");

  EXIT_API(S_OK);

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
  int r;
  PVOID pvBits;
  PVOID pvPal=NULL;
  DWORD palsize = 0;

  DWORD bmiSize;
  LPBITMAPINFO pbmi;
  BITMAPINFO bmi;

  LONG w, h, b, bw;





  if(i_sw>=0) {
    pbmi = (LPBITMAPINFO)GetExpression(tokens[i_sw+1]);
    move2(&bmiSize, pbmi, sizeof(DWORD));                   //Get the size of the BITMAPINFOHEADER
    if(bmiSize>sizeof(BITMAPINFOHEADER)) {
      dprintf("Invalid bmiSize\n");
      bmiSize = sizeof(BITMAPINFOHEADER);
    }
    move2(&bmi, pbmi, bmiSize);                             //I wonder if this could run off the end of the bitmapinfoheader while reading (it is a variable length structure - both the BITMAPINFOHEADER and the RGBQUAD)

    //
    // Set the parameters - they are possibly overwritten later
    // if other parameters are specified.
    //
    w = bmi.bmiHeader.biWidth;
    h = bmi.bmiHeader.biHeight;
    b = bmi.bmiHeader.biBitCount;

    //
    // Get the palette from the LPBITMAPINFO structure providing that
    // the user hasn't specified a manual palette address
    //
    if(p_sw<0) {
      pvPal = (PVOID) ( (PBYTE)pbmi+sizeof(BITMAPINFOHEADER) );  //point to the start of the rgbquad array
      switch(b) {
        case 0: break;
        case 1: palsize = 2; break;
        case 4: palsize = 16; break;
        case 8: palsize = 256; break;
        case 16:
          if(bmi.bmiHeader.biCompression==BI_BITFIELDS) {
            palsize = 3;
            break;
          }
        case 24:
        case 32:
          palsize = 0;
          pvPal = NULL;
          break;
        default:
          palsize = 0;
          pvPal = NULL;
          dprintf("WARNING: you're trying to dump a DIB with an unusual bit depth %d\n", b);
          dprintf("bit depth should be specified in hex!\n");
        break;
      }
    }

    if( (bmi.bmiHeader.biClrUsed<palsize) && (bmi.bmiHeader.biClrUsed>0) ) {
      palsize = bmi.bmiHeader.biClrUsed;
    }

  }

  if(w_sw>=0) { w = (LONG)GetExpression(tokens[w_sw+1]); }
  if(h_sw>=0) { h = (LONG)GetExpression(tokens[h_sw+1]); }
  if(b_sw>=0) { b = (LONG)GetExpression(tokens[b_sw+1]); }

  if(p_sw>=0) {
    pvPal = (PVOID)GetExpression(tokens[p_sw+1]);
    palsize = (LONG)GetExpression(tokens[p_sw+2]);
  }

  if(y_sw>=0) {
    bw = (LONG)GetExpression(tokens[y_sw+1]);
  } else {
    switch(b) {
      case 32: bw = w*4; break;
      case 24: bw = w*3; break;
      case 16: bw = w*2; break;
      case 8: bw = w; break;
      case 1: bw = w/8 + (int)((w%8) != 0); break;
      default: bw = w;
    }
  }

  pvBits = (PVOID)GetExpression(tokens[ntok-1]);

  if( (r=WriteDIBToFile(pvBits, w, h, bw, b, pvPal, palsize, tokens[f_sw+1])) !=0 ) {
    dprintf("Error %d writing to file\n", r);
    goto ddib_help;
  }
  return;

#endif  // DOES NOT SUPPORT API64
}



/******************************Public*Routine******************************\
* VOID vPrintBLTRECORD
*
* Dump the contents of BLTRECORD structure
*
* History:
*  13-Apr-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
VOID vPrintBLTRECORD(VOID  *pv)
{
    BLTRECORD   *pblt = (BLTRECORD *) pv;

    dprintf("SURFOBJ   *psoTrg        0x%08lx\n", pblt->pSurfTrg()->pSurfobj());
    dprintf("SURFOBJ   *psoSrc        0x%08lx\n", pblt->pSurfSrc()->pSurfobj());
    dprintf("SURFOBJ   *psoMsk        0x%08lx\n", pblt->pSurfMsk()->pSurfobj());

    dprintf("POINTFIX  aptfx[0]     = (0x%07lx.%1lx, 0x%07lx.%1lx)\n",
        pblt->pptfx()[0].x >> 4, pblt->pptfx()[0].x & 15, pblt->pptfx()[0].y >> 4, pblt->pptfx()[0].y & 15);
    dprintf("POINTFIX  aptfx[1]     = (0x%07lx.%1lx, 0x%07lx.%1lx)\n",
        pblt->pptfx()[1].x >> 4, pblt->pptfx()[1].x & 15, pblt->pptfx()[1].y >> 4, pblt->pptfx()[1].y & 15);
    dprintf("POINTFIX  aptfx[2]     = (0x%07lx.%1lx, 0x%07lx.%1lx)\n",
        pblt->pptfx()[2].x >> 4, pblt->pptfx()[2].x & 15, pblt->pptfx()[2].y >> 4, pblt->pptfx()[2].y & 15);
    dprintf("POINTFIX  aptfx[3]     = (0x%07lx.%1lx, 0x%07lx.%1lx)\n",
        pblt->pptfx()[3].x >> 4, pblt->pptfx()[3].x & 15, pblt->pptfx()[3].y >> 4, pblt->pptfx()[3].y & 15);

    dprintf("POINTL    aptlTrg[0]   = (0x%08lx, 0x%08lx)\n", pblt->pptlTrg()[0].x, pblt->pptlTrg()[0].y);
    dprintf("POINTL    aptlTrg[1]   = (0x%08lx, 0x%08lx)\n", pblt->pptlTrg()[1].x, pblt->pptlTrg()[1].y);
    dprintf("POINTL    aptlTrg[2]   = (0x%08lx, 0x%08lx)\n", pblt->pptlTrg()[2].x, pblt->pptlTrg()[2].y);

    dprintf("POINTL    aptlSrc[0]   = (0x%08lx, 0x%08lx)\n", pblt->pptlSrc()[0].x, pblt->pptlSrc()[0].y);
    dprintf("POINTL    aptlSrc[1]   = (0x%08lx, 0x%08lx)\n", pblt->pptlSrc()[1].x, pblt->pptlSrc()[1].y);

    dprintf("POINTL    aptlMask[0]  = (0x%08lx, 0x%08lx)\n", pblt->pptlMask()[0].x, pblt->pptlMask()[0].y);

    dprintf("POINTL    aptlBrush[0] = (0x%08lx, 0x%08lx)\n", pblt->pptlBrush()[0].x, pblt->pptlBrush()[0].y);

    dprintf("ROP4  rop4 = 0x%08lx, FLONG flState = 0x%08lx\n", pblt->rop(), pblt->flGet());
}
#endif  // DOES NOT SUPPORT API64

/******************************Public*Routine******************************\
* DECLARE_API( dblt  )
*
* History:
*  21-Feb-1995    -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DECLARE_API( dblt )
{
    dprintf("Use 'dt win32k!BLTRECORD -r <Address>'\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
  DWORD blt[1024];
  PARSE_POINTER(dblt_help);
  dprintf("BLTRECORD structure at 0x%p:\n", (PVOID)arg);
  move2(blt, (BLTRECORD *)arg, sizeof(BLTRECORD));
  vPrintBLTRECORD(blt);
  return;

dblt_help:
  dprintf("Usage: dblt [-?] BLTRECORD_PTR\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
* xlate
*
\**************************************************************************/

DECLARE_API( xlate )
{
    return ExtDumpType(Client, "xlate", "XLATE", args);
}


/******************************Public*Routine******************************\
* bltinfo
*
\**************************************************************************/

DECLARE_API( bltinfo )
{
    return ExtDumpType(Client, "bltinfo", "BLTINFO", args);
}


/******************************Public*Routine******************************\
* stats
*
*  27-Feb-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

PSZ apszGetDCDword[] =
{
    "GCAPS              ",
    "STRETCHBLTMODE     ",
    "GRAPHICSMODE       ",
    "ROP2               ",
    "BKMODE             ",
    "POLYFILLMODE       ",
    "TEXTALIGN          ",
    "TEXTCHARACTEREXTRA ",
    "TEXTCOLOR          ",
    "BKCOLOR            ",
    "RELABS             ",
    "BREAKEXTRA         ",
    "CBREAK             ",
    "MAPMODE            ",
    "ARCDIRECTION       ",
    "SAVEDEPTH          ",
    "FONTLANGUAGEINFO   "
};

PSZ apszSetDCDword[] =
{
    "UNUSED             ",
    "EPSPRINTESCCALLED  ",
    "COPYCOUNT          ",
    "BKMODE             ",
    "POLYFILLMODE       ",
    "ROP2               ",
    "STRETCHBLTMODE     ",
    "TEXTALIGN          ",
    "BKCOLOR            ",
    "RELABS             ",
    "TEXTCHARACTEREXTRA ",
    "TEXTCOLOR          ",
    "SELECTFONT         ",
    "MAPPERFLAGS        ",
    "MAPMODE            ",
    "ARCDIRECTION       ",
    "GRAPHICSMODE       "
};


PSZ apszGetDCPoint[] =
{
    "UNUSED             ",
    "VPEXT              ",
    "WNDEXT             ",
    "VPORG              ",
    "WNDORG             ",
    "ASPECTRATIOFILTER  ",
    "BRUSHORG           ",
    "DCORG              ",
    "CURRENTPOSITION    "
};

PSZ apszSetDCPoint[] =
{
    "VPEXT              ",
    "WNDEXT             ",
    "VPORG              ",
    "WNDORG             ",
    "OFFVPORG           ",
    "OFFWNDORG          ",
    "MAX                "
};

DECLARE_API( stats  )
{
    dprintf("Extension 'stats' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
#if DBG

    DWORD adw[100];
    PDWORD pdw;
    int i;

    PARSE_ARGUMENTS(stats_help);

    // Get DCDword

    GetAddress(pdw, "win32k!acGetDCDword");
    move2(adw, pdw, sizeof(DWORD) * DDW_MAX);

    dprintf("\nGetDCDword %lx:\n",pdw);

//CHECKLOOP
    for (i = 0; i < DDW_MAX; ++i)
    {
        if (adw[i])
            dprintf("\t%2ld: %s, %4d\n",i,apszGetDCDword[i],adw[i]);
    }

    // Set DCDword

    GetAddress(pdw, "win32k!acSetDCDword");
    move2(adw, pdw, sizeof(DWORD) * GASDDW_MAX);

    dprintf("\nSetDCDword:\n");

//CHECKLOOP
    for (i = 0; i < GASDDW_MAX; ++i)
    {
        if (adw[i])
            dprintf("\t%2ld: %s, %4d\n",i,apszSetDCDword[i],adw[i]);
    }

    // Get DCPoint

    GetAddress(pdw, "win32k!acGetDCPoint");
    move2(adw, pdw, sizeof(DWORD) * DCPT_MAX);

    dprintf("\nGetDCPoint:\n");

//CHECKLOOP
    for (i = 0; i < DCPT_MAX; ++i)
    {
        if (adw[i])
            dprintf("\t%2ld: %s, %4d\n",i,apszGetDCPoint[i],adw[i]);
    }

    // Set DCPoint

    GetAddress(pdw, "win32k!acSetDCPoint");
    move2(adw, pdw, sizeof(DWORD) * GASDCPT_MAX);

    dprintf("\nSetDCPoint:\n");

//CHECKLOOP
    for (i = 0; i < GASDCPT_MAX; ++i)
    {
        if (adw[i])
            dprintf("\t%2ld: %s, %4d\n",i,apszSetDCPoint[i],adw[i]);
    }

#else
    goto stats_help;
#endif

  return;
stats_help:
  dprintf("Usage: stats [-?]\n");
  dprintf("-? displays this help.\n");
  dprintf("stats only works in checked builds.\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}



/******************************Public*Routine******************************\
* PALETTE
*
\**************************************************************************/

DECLARE_API( palette )
{
    BEGIN_API( palette );

    HRESULT         hr = S_OK;
    OutputControl   OutCtl(Client);
    ULONG64         PaletteAddr;
    DEBUG_VALUE     Arg;
    DEBUG_VALUE     Offset;

    while (isspace(*args)) args++;

    if (*args == '-' ||
        (hr = Evaluate(Client, args, DEBUG_VALUE_INT64, 0, &Arg, NULL)) != S_OK)
    {
        OutCtl.Output("Usage: palette [-?] <HPALETTE | PALETTE Addr>\n");
    }
    else
    {
        hr = GetObjectAddress(Client,Arg.I64,&PaletteAddr,PAL_TYPE,TRUE,TRUE);

        if (hr != S_OK || PaletteAddr == 0)
        {
            DEBUG_VALUE         ObjHandle;
            TypeOutputParser    TypeParser(Client);
            OutputState         OutState(Client);
            ULONG64             PaletteAddrFromHmgr;

            PaletteAddr = Arg.I64;

            // Try to read hHmgr from PALETTE type, but if that
            // fails use the BASEOBJECT type, which is public.
            if ((hr = OutState.Setup(0, &TypeParser)) != S_OK ||
                (hr = OutState.OutputTypeVirtual(PaletteAddr, GDIType(PALETTE), 0)) != S_OK ||
                (hr = TypeParser.Get(&ObjHandle, "hHmgr", DEBUG_VALUE_INT64)) != S_OK)
            {
                OutCtl.OutErr("Unable to get contents of PALETTE's handle\n");
                OutCtl.OutErr("  (Type Read returned %s)\n", pszHRESULT(hr));
                OutCtl.OutErr(" 0x%p is neither an HPALETTE nor valid PALETTE address\n", Arg.I64);
            }
            else
            {
                if (GetObjectAddress(Client,ObjHandle.I64,&PaletteAddrFromHmgr,
                                     PAL_TYPE,TRUE,FALSE) == S_OK &&
                    PaletteAddr != PaletteAddrFromHmgr)
                {
                    OutCtl.OutWarn("\tNote: PALETTE may not be valid.\n"
                                   "\t      It does not have a valid handle manager entry.\n");
                }
            }
        }

        if (hr == S_OK)
        {
            hr = DumpType(Client, "PALETTE", PaletteAddr);

            if (hr != S_OK)
            {
                OutCtl.OutErr("Type Dump for PALETTE returned %s.\n", pszHRESULT(hr));
            }
        }
    }

    return hr;
}


DECLARE_API( dppal  )
{
    INIT_API();
    ExtOut("Obsolete: Use 'palette poi(<EPALOBJ Addr>)'.\n");
    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
* DECLARE_API( sprite  )
*
\**************************************************************************/

PCSTR SpriteFields[] = {
    "dwShape",
    "fl",
    "BlendFunction",
    "pState",
    "pNextZ",
    "pNextY",
    "pPreviousY",
    "pNextActive",
    "rclSprite",
    "rclSrc",
    "psoShape",
    "psoUnderlay",
    "prgnClip",
    "ppalShape",
    NULL
};

DECLARE_API( sprite  )
{
    BEGIN_API( sprite );

    HRESULT         hr = S_OK;
    BOOL            DumpAll = FALSE;
    DEBUG_VALUE     Offset;
    ULONG64         Module;
    ULONG           TypeId;
    OutputControl   OutCtl(Client);


    while (isspace(*args)) args++;

    if (args[0] == '-' && tolower(args[1]) == 'a' && isspace(args[2]))
    {
        DumpAll = TRUE;
        args+=3;
    }

    if (*args == '-' ||
        (hr = Evaluate(Client, args, DEBUG_VALUE_INT64, 0, &Offset, NULL)) != S_OK ||
        Offset.I64 == 0)
    {
        OutCtl.Output("Usage: sprite [-?a] <SPRITE Addr>\n"
               "        -a  - dump entire structure\n");
    }
    else
    {
        if ((hr = GetTypeId(Client, "SPRITE", &TypeId, &Module)) == S_OK)
        {
            TypeOutputDumper    TypeReader(Client, &OutCtl);

            if (!DumpAll)
            {
                TypeReader.MarkFields(SpriteFields);
            }

            OutCtl.Output(" SPRITE @ 0x%p:\n", Offset.I64);

            hr = TypeReader.OutputVirtual(Module, TypeId, Offset.I64);
        }

        if (hr != S_OK)
        {
            OutCtl.OutErr("Type Dump for SPRITE returned %s.\n", pszHRESULT(hr));
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
* DECLARE_API( spritestate  )
*
\**************************************************************************/

PCSTR SpriteStateFields[] = {
    "hdev",
    "cVisible",
    "pListZ",
    "pListY",
    "psoScreen",
    "cVisible",
    "pRange",
    "pRangeLimit",
    "psoComposite",
    "prgnUnlocked",
    NULL
};

PCSTR SpriteStateCursorFields[] = {
    "pSpriteCursor",
    "xHotCursor",
    "yHotCursor",
    "ulNumCursors",
    "pTopCursor",
    "pBottomCursor",
    "ulTrailTimeStamp",
    "ulTrailPeriod",
    NULL
};

PCSTR SpriteStateHookFields[] = {
    "bHooked",
    "bInsideDriverCall",
    "flOriginalSurfFlags",
    "iOriginalType",
    "flSpriteSurfFlags",
    "iSpriteType",
    NULL
};

PCSTR SpriteStateMetaFields[] = {
    "cMultiMon",
    "ahdevMultiMon",
    "pListMeta",
    NULL
};

PCSTR SpriteStateLargeFields[] = {
    "coTmp",
    "coRectangular",
    NULL
};


DECLARE_API( spritestate  )
{
    BEGIN_API( spritestate );

    HRESULT         hr = S_OK;
    BOOL            BadSwitch = FALSE;
    BOOL            DumpAll = FALSE;
    BOOL            DumpCursor = FALSE;
    BOOL            DumpHook = FALSE;
    BOOL            DumpMeta = FALSE;
    DEBUG_VALUE     Offset;
    ULONG64         Module;
    ULONG           TypeId;
    OutputControl   OutCtl(Client);


    while (!BadSwitch)
    {
        while (isspace(*args)) args++;

        if (*args != '-') break;

        args++;
        BadSwitch = (*args == '\0' || isspace(*args));

        while (*args != '\0' && !isspace(*args))
        {
            switch (*args)
            {
                case 'a': DumpAll = TRUE; break;
                case 'c': DumpCursor = TRUE; break;
                case 'h': DumpHook = TRUE; break;
                case 'm': DumpMeta = TRUE; break;
                default:
                    BadSwitch = TRUE;
                    break;
            }

            if (BadSwitch) break;
            args++;
        }
    }

    if (BadSwitch ||
        (hr = Evaluate(Client, args, DEBUG_VALUE_INT64, 0, &Offset, NULL)) != S_OK ||
        Offset.I64 == 0)
    {
        OutCtl.Output("Usage: spritestate [-?chma] <SPRITESTATE Addr>\n"
               "        -c  - dump cursor fields\n"
               "        -h  - dump hook fields\n"
               "        -m  - dump meta fields\n"
               "        -a  - dump entire structure\n");
    }
    else
    {
        if ((hr = GetTypeId(Client, "SPRITESTATE", &TypeId, &Module)) == S_OK)
        {
            TypeOutputDumper    TypeReader(Client, &OutCtl);

            if (DumpAll)
            {
                TypeReader.ExcludeMarked();

                TypeReader.MarkFields(SpriteStateLargeFields);
            }
            else
            {
                TypeReader.IncludeMarked();

                TypeReader.MarkFields(SpriteStateFields);

                if (DumpCursor)
                {
                    TypeReader.MarkFields(SpriteStateCursorFields);
                }

                if (DumpHook)
                {
                    TypeReader.MarkFields(SpriteStateHookFields);
                }

                if (DumpMeta)
                {
                    TypeReader.MarkFields(SpriteStateMetaFields);
                }
            }

            OutCtl.Output(" SPRITESTATE @ 0x%p:\n", Offset.I64);

            hr = TypeReader.OutputVirtual(Module, TypeId, Offset.I64);
        }

        if (hr != S_OK)
        {
            OutCtl.OutErr("Type Dump for SPRITESTATE returned %s.\n", pszHRESULT(hr));
        }
    }

    return hr;
}



/**************************************************************************\
* PDEV Fields
*
\**************************************************************************/

PCSTR   GeneralPDEVFields[] = {
    "ppdevNext",
    "fl",
    "cPdevRefs",
    "cPdevOpenRefs",
    "pldev",
    "dhpdev",
    "hSpooler",
    "pSurface",
    "ppalSurf",
    "eDirectDrawGlobal.",
    "SpriteState.",
    "pDesktopId",
    "pGraphicsDevice",
    "ppdevParent",
    "hsemDevLock",
    "ptlOrigin",
    "apfn.",
    "daDirectDrawContext.",
    NULL
};

PCSTR   PDEVPointerFields[] = {
    "ptlPointer",
    "pfnDrvSetPointerShape",
    "pfnDrvMovePointer",
    "pfnMovePointer",
    "pfnSync",
    "hsemPointer",
    NULL
};

PCSTR   PDEVFontFields[] = {
    "hlfntDefault",
    "hlfntAnsiVariable",
    "hlfntAnsiFixed",
    "prfntActive",
    "prfntInactive",
    "cInactive",
    NULL
};

PCSTR   PDEVDevInfoFields[] = {
    "devinfo.flGraphicsCaps",
    "devinfo.cFonts",
    "devinfo.iDitherFormat",
    "devinfo.cxDither",
    "devinfo.cyDither",
    "devinfo.hpalDefault",
    "devinfo.flGraphicsCaps2",
    NULL
};

PCSTR   PDEVPatternFields[] = {
    "ahsurf",       // To Do: make sure array gets dumped
    "pDevHTInfo",
    NULL
};

PCSTR   PDEVGDIInfoFields[] = {
    "GdiInfo",
    "flAccelerated",
    NULL
};

PCSTR   PDEVSpriteStateFields[] = {
    "SpriteState.bHooked",
    "SpriteState.pListZ",
    "SpriteState.psoScreen",
    "SpriteState.cVisible",
    "SpriteState.cMultiMon",
    "SpriteState.bInsideDriverCall",
    "SpriteState.iOriginalType",
    "SpriteState.iSpriteType",
    "SpriteState.pBottomCursor",
    "SpriteState.ulNumCursors",
    NULL
};


/******************************Public*Routine******************************\
* PDEV
*
\**************************************************************************/

DECLARE_API( pdev )
{
    BEGIN_API( pdev );
    INIT_API();

    HRESULT         hr = S_OK;
    DEBUG_VALUE     Offset;
    ULONG64         Module;
    ULONG           TypeId;
    OutputControl   OutCtl(Client);

    BOOL    BadSwitch = FALSE;
    BOOL    DumpAll = FALSE;
    BOOL    DumpDEVINFO = FALSE;
    BOOL    DumpFont = FALSE;
    BOOL    DumpGDIINFO = FALSE;
    BOOL    DumpPattern = FALSE;
    BOOL    DumpPointer = FALSE;
    BOOL    DumpSpriteState = FALSE;
    BOOL    Recurse = FALSE;
    BOOL    DisplaysOnly = FALSE;

    while (!BadSwitch)
    {
        while (isspace(*args)) args++;

        if (*args != '-') break;

        args++;
        BadSwitch = (*args == '\0' || isspace(*args));

        while (*args != '\0' && !isspace(*args))
        {
            switch (*args)
            {
                case 'a': DumpAll = TRUE; break;
                case 'd': DumpDEVINFO = TRUE; break;
                case 'f': DumpFont = TRUE; break;
                case 'g': DumpGDIINFO = TRUE; break;
                case 'n': DumpPattern = TRUE; break;
                case 'p': DumpPointer = TRUE; break;
                case 's': DumpSpriteState = TRUE; break;
                case 'r':
                case 'R': Recurse = TRUE; break;
                case 'D': DisplaysOnly = TRUE; break;
                default:
                    BadSwitch = TRUE;
                    break;
            }

            if (BadSwitch) break;
            args++;
        }
    }

    if (BadSwitch)
    {
        OutCtl.Output("Usage: pdev [-?adfgnpsRD] [PDEV Addr]\n"
               "\n"
               "   PDEV Addr - address of PDEV otherwise win32k!gppdevList is used\n"
               "\n"
               "   a - All info (dump everything)\n"
               "   d - DEVINFO struct\n"
               "   f - Font info\n"
               "   g - GDIINFO struct\n"
               "   m - DEVMODE\n"
               "   n - Default patterns\n"
               "   p - Pointer info\n"
               "   s - SpriteState\n"
               "\n"
               "   R - Recurse\n"
               "   D - Display devices only\n");
    }
    else if (*args != '\0' &&
             ((hr = Evaluate(Client, args, DEBUG_VALUE_INT64, 0, &Offset, NULL)) != S_OK ||
              Offset.I64 == 0))
    {
        if (hr == S_OK)
        {
            OutCtl.Output("Expression %s evalated to zero.\n", args);
        }
        else
        {
            OutCtl.OutErr("Evaluate(%s) returned %s.\n", args, pszHRESULT(hr));
        }
    }
    else
    {
        // If no address was given use win32k!gppdevList
        if (*args == '\0')
        {
            DEBUG_VALUE ppdevList;

            hr = g_pExtControl->Evaluate(GDISymbol(gppdevList),
                                         DEBUG_VALUE_INT64,
                                         &ppdevList,
                                         NULL);

            if (hr == S_OK)
            {
                if (SessionId == CURRENT_SESSION)
                {
                    hr = g_pExtData->ReadPointersVirtual(1, ppdevList.I64, &Offset.I64);
                }
                else
                {
                    ULONG64 ppdevListPhys;

                    if ((hr = GetPhysicalAddress(Client,
                                                 SessionId,
                                                 ppdevList.I64,
                                                 &ppdevListPhys)) == S_OK)
                    {
                        hr = ReadPointerPhysical(Client, ppdevListPhys, &Offset.I64);

                        if (hr == S_OK)
                        {
                            OutCtl.Output("First PDEV in session %lu located at 0x%p.\n",
                                   SessionId, Offset.I64);
                        }
                    }
                }

                if (hr == S_OK)
                {
                    if (Offset.I64 == 0)
                    {
                        OutCtl.OutErr(" Displays are not initialized or symbols are incorrect.\n"
                                "  %s @ %#p is NULL.\n", GDISymbol(gppdevList), ppdevList.I64);
                        hr = S_FALSE;
                    }
                }
                else
                {
                    OutCtl.OutErr("Unable to get the contents of %s @ %#p\n", GDISymbol(gppdevList), ppdevList.I64);
                }
            }
            else
            {
                OutCtl.OutErr("Unable to locate %s\n", GDISymbol(gppdevList));
            }
        }

        OutputFilter        OutFilter(Client);
        OutputState         OutState(Client);

        if (hr == S_OK &&
            (hr = OutState.Setup(0, &OutFilter)) == S_OK &&
            (hr = GetTypeId(Client, "PDEV", &TypeId, &Module)) == S_OK)
        {
            TypeOutputDumper    TypeReader(OutState.Client, &OutCtl);

            do
            {
                if (OutCtl.GetInterrupt() == S_OK) break;

                OutCtl.Output("PDEV @ 0x%p:\n", Offset.I64);

                // Read two fields to OutFilter: 'ppdevNext' and 'fl'
                OutFilter.DiscardOutput();

                TypeReader.IncludeMarked();
                TypeReader.ClearMarks();
                TypeReader.MarkField("ppdevNext");
                TypeReader.MarkField("fl");

                if ((hr = OutCtl.SetControl(DEBUG_OUTCTL_THIS_CLIENT |
                                            DEBUG_OUTCTL_NOT_LOGGED |
                                            DEBUG_OUTCTL_OVERRIDE_MASK,
                                            OutState.Client)) == S_OK &&
                    (hr = TypeReader.OutputVirtual(Module, TypeId, Offset.I64)) == S_OK &&
                    (hr = OutCtl.SetControl(DEBUG_OUTCTL_AMBIENT, Client)) == S_OK)
                {
                    // If we only want displays, check for PDEV_DISPLAY
                    // in OutFilter (
                    if (!DisplaysOnly ||
                        OutFilter.Query("PDEV_DISPLAY") == S_OK)
                    {
                        TypeReader.ClearMarks();

                        if (DumpAll)
                        {
                            TypeReader.ExcludeMarked();

                            // Don't recurse for big sub structures
                            TypeReader.MarkField("SpriteState.*");
                            TypeReader.MarkField("devinfo.*");
                            TypeReader.MarkField("GdiInfo.*");
                        }
                        else
                        {
                            TypeReader.IncludeMarked();

                            TypeReader.MarkFields(GeneralPDEVFields);

                            if (DumpDEVINFO)
                            {
                                TypeReader.MarkFields(PDEVDevInfoFields);
                            }

                            if (DumpFont)
                            {
                                TypeReader.MarkFields(PDEVFontFields);
                            }

                            if (DumpGDIINFO)
                            {
                                TypeReader.MarkFields(PDEVGDIInfoFields);
                            }

                            if (DumpPattern)
                            {
                                TypeReader.MarkFields(PDEVPatternFields);
                            }

                            if (DumpPointer)
                            {
                                TypeReader.MarkFields(PDEVPointerFields);
                            }

                            if (DumpSpriteState)
                            {
                                TypeReader.MarkFields(PDEVSpriteStateFields);
                            }
                        }

                        hr = TypeReader.OutputVirtual(Module, TypeId, Offset.I64);
                    }
                    else
                    {
                        OutCtl.Output("  Not marked PDEV_DISPLAY.\n");
                    }

                    if (Recurse)
                    {
                        hr = OutFilter.Query("ppdevNext", &Offset, DEBUG_VALUE_INT64);
                        if (hr == S_OK)
                        {
                            if (Offset.I64 != 0)
                            {
                                OutCtl.Output("-----------------------------------\n");
                            }
                            else
                            {
                                Recurse = FALSE;
                            }
                        }
                    }
                }
            } while (hr == S_OK && Recurse);

            if (hr != S_OK)
            {
                OutCtl.OutErr("Type Dump for PDEV returned %s.\n", pszHRESULT(hr));
            }
        }
        else
        {
            OutCtl.OutErr("Type Dump setup for PDEV returned %s.\n", pszHRESULT(hr));
        }
    }

    EXIT_API(hr);
}

DECLARE_API( dpdev  )
{
    return pdev(Client, args);
}


/******************************Public*Routine******************************\
* dldev
*
* Syntax:   dldev [LDEV pointer]
*
* History:
*  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

DECLARE_API (dldev)
{
    dprintf("Extension 'dldev' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    BOOL   recursive = TRUE;
    PWSZ   psz;
    PLDEV  pldevNext, pl_CD;
    LDEV   ldev;
    WCHAR  DriverName[MAX_PATH];
    SYSTEM_GDI_DRIVER_INFORMATION GdiDriverInfo;
    BOOL   invalid_type = false;
    BOOL   force;
    int    forcenum=0;
    BOOL   forcecount;
    BOOL   FirstLoop=FALSE;


    GetValue(pldevNext, "win32k!gpldevDrivers");

    PARSE_ARGUMENTS(dldev_help);
    if(ntok<1) { goto dldev_help; }
    tok_pos = parse_FindNonSwitch(tokens, ntok);
    if(tok_pos==-1) { goto dldev_help; }
    if(parse_IsSwitch(tokens, tok_pos-1, 'F')) {
      tok_pos = parse_FindNonSwitch(tokens, ntok, tok_pos+1);
    }
    if(tok_pos==-1) { goto dldev_help; }

    pl_CD = pldevNext = (PLDEV)GetExpression(tokens[tok_pos]);

    force = (parse_FindSwitch(tokens, ntok, 'f')!=-1);
    forcecount = ((tok_pos = parse_FindSwitch(tokens, ntok, 'F'))!=-1);
    if(tok_pos != -1) {
      if(((tok_pos+1)>=ntok)||
         (sscanf(tokens[tok_pos+1], "%d", &forcenum)!=1)) {
        goto dldev_help;
      }
    }


    dprintf("\n--------------------------------------------------\n");

    do
    {
        if(forcecount) {
          if((--forcenum)<0) {
            break;
          }
        }

        if(pl_CD) {
          ReadMemory((UINT_PTR)pl_CD, &ldev, sizeof(LDEV), NULL);
          pl_CD = ldev.pldevNext;
          if(pl_CD) {
            ReadMemory((UINT_PTR)pl_CD, &ldev, sizeof(LDEV), NULL);
            pl_CD = ldev.pldevNext;
          }
        }
        ReadMemory((UINT_PTR)pldevNext, &ldev, sizeof(LDEV), NULL);

        dprintf("ldev  = 0x%lx\n", pldevNext);

        switch (ldev.ldevType)
        {
        case LDEV_DEVICE_DISPLAY:
            psz = L"LDEV_DEVICE_DISPLAY";
            break;
        case LDEV_DEVICE_PRINTER:
            psz = L"LDEV_DEVICE_PRINTER";
            break;
        case LDEV_FONT:
            psz = L"LDEV_FONT";
            break;
        case LDEV_DEVICE_META:
            psz = L"LDEV_DEVICE_META";
            break;
        case LDEV_DEVICE_MIRROR:
            psz = L"LDEV_DEVICE_MIRROR";
            break;
        case LDEV_IMAGE:
            psz = L"LDEV_IMAGE";
            break;
        default:
            invalid_type = true;
            psz = L"INVALID LDEV TYPE";
            break;
        }

        dprintf("next ldev       = 0x%lx\n", ldev.pldevNext      );
        dprintf("previous ldev   = 0x%lx\n", ldev.pldevPrev      );

        dprintf("levtype         = %ws\n",   psz                 );
        dprintf("cRefs           = %d\n",    ldev.cldevRefs      );
        dprintf("ulDriverVersion = 0x%lx\n", ldev.ulDriverVersion);
        dprintf("pGdiDriverInfo  = 0x%lx\n", ldev.pGdiDriverInfo );

        dprintf("name            = ");

        if (ldev.pGdiDriverInfo == NULL)
        {
            dprintf("Linked-in driver\n");

        }
        else
        {
            ReadMemory((ULONG_PTR) ldev.pGdiDriverInfo,
                       &GdiDriverInfo,
                       sizeof(SYSTEM_GDI_DRIVER_INFORMATION),
                       NULL);

            ReadMemory((ULONG_PTR) GdiDriverInfo.DriverName.Buffer,
                       DriverName,
                       GdiDriverInfo.DriverName.Length,
                       NULL);

            *(DriverName + GdiDriverInfo.DriverName.Length/2) = UNICODE_NULL;

            dprintf("%ws\n", &DriverName);
        }

        if(invalid_type) {
          dprintf("The ldev is invalid\n");
        }
        dprintf("\n");
        if(!FirstLoop&&(pl_CD==pldevNext)) {
          dprintf("ERROR: Cycle detected in linked list.\n");
          break;
        }
        if(CheckControlC()) {
          dprintf("User Break\n");
          return;
        }
        FirstLoop=FALSE;
    } while ( (!invalid_type||force||forcecount) && recursive && (pldevNext = ldev.pldevNext));

    dprintf("--------------------------------------------------\n\n");
  return;
dldev_help:
  dprintf("Usage: dldev [-?] [-f] [-F #] ldev\n");
  dprintf("-f forces the recursion even if the type is invalid\n");
  dprintf("In an infinite loop, Ctrl-C will eventually break the recursion\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
* dgdev
*
* Syntax:   dgdev [GRAPHICS_DEVICE pointer]
*
* History:
*  Andre Vachon [andreva]
*   Wrote it.
*  Jason Hartman [jasonha]
*   Converted to new debugger API.
\**************************************************************************/

char szCurrentDeviceList[]      = GDISymbol(gpGraphicsDeviceList);
char szLocalDeviceList[]        = GDISymbol(gpLocalGraphicsDeviceList);
char szRemoteDeviceList[]       = GDISymbol(gpRemoteGraphicsDeviceList);

char szCurrentDeviceListLast[]  = GDISymbol(gpGraphicsDeviceListLast);
char szLocalDeviceListLast[]    = GDISymbol(gpLocalGraphicsDeviceListLast);
char szRemoteDeviceListLast[]   = GDISymbol(gpRemoteGraphicsDeviceListLast);

char szGraphicsDeviceHeader[] = "--------------------------------------------------\n"
                                "GRAPHICS_DEVICE @ ";

DECLARE_API( dgdev )
{
    INIT_API();
    BEGIN_API( dgdev );

    HRESULT     hr;

    ULONG64     GDeviceAddr = 0;
    ULONG64     LastPointerAddr = 0;
    ULONG64     LastGDExpected = 0;
    BOOL        recursive = FALSE;
    BOOL        bDumpModes = FALSE;
    BOOL        UseAddress = FALSE;
    char       *pszDeviceList = NULL;
    char        szPGDSymbolBuffer[128];
    ULONG       error;

    OutputControl   OutCtl(Client);

    #define GRAPHICS_DEVICE_CBDEVMODEINFO   0
    #define GRAPHICS_DEVICE_DEVMODEINFO     1

    FIELD_INFO  GraphicsDeviceFields[] = {
        { DbgStr("cbdevmodeInfo"),      NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("devmodeInfo"),        NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("szNtDeviceName"),     NULL, 0, DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_WCHAR_STRING, 0, NULL},
        { DbgStr("szWinDeviceName"),    NULL, 0, DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_WCHAR_STRING, 0, NULL},
        { DbgStr("pNextGraphicsDevice"),NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("pVgaDevice"),         NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("pDeviceHandle"),      NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("pPhysDeviceHandle"),  NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("hkClassDriverConfig"),NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("stateFlags"),         NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, FlagCallback},
        { DbgStr("numRawModes"),        NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("devmodeMarks"),       NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("DiplayDriverNames"),  DbgStr("Di(s)playDriverNames :"), 0, DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_MULTI_STRING | DBG_DUMP_FIELD_WCHAR_STRING, 0, NULL},
#if 1
        { DbgStr("DeviceDescription"),  NULL, 0, DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_WCHAR_STRING, 0, NULL},
#else
        { DbgStr("DeviceDescription"),  NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, WStringCallback},
#endif
        { DbgStr("numMonitorDevice"),   NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("MonitorDevices"),     NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("pFileObject"),        NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
    };

    FIELD_INFO  GraphicsDeviceLink = { DbgStr("pNextGraphicsDevice"),  DbgStr(""), 0, DBG_DUMP_FIELD_FULL_NAME, 0, NextItemCallback};

    SYM_DUMP_PARAM GraphicsDeviceSym = {
        sizeof(SYM_DUMP_PARAM), DbgStr(GDIType(tagGRAPHICS_DEVICE)), 0, 0/*GDeviceAddr*/,
        NULL, afdGRAPHICS_DEVICE_stateFlags, NULL,
        sizeof(GraphicsDeviceFields)/sizeof(GraphicsDeviceFields[0]),
        GraphicsDeviceFields
    };
    PrepareCallbacks(FALSE);


    // Interpret command line

    PARSE_ARGUMENTS(dgdev_help);

    if (parse_iFindSwitch(tokens, ntok, 'm')!=-1)
    {
        GraphicsDeviceFields[GRAPHICS_DEVICE_CBDEVMODEINFO].fieldCallBack = SizeDEVMODEListCallback;
        GraphicsDeviceFields[GRAPHICS_DEVICE_DEVMODEINFO].fieldCallBack = DEVMODEListCallback;
    }
    if (parse_iFindSwitch(tokens, ntok, 'R')!=-1) { recursive = TRUE; }

    // Determine where to start looking: global or commnad line arg?

    // -c means current/last device list
    if (parse_iFindSwitch(tokens, ntok, 'c')!=-1)
    {
        pszDeviceList = szCurrentDeviceList;

        LastPointerAddr = GetExpression(szCurrentDeviceListLast);
    }
    // -l means local device list
    if (parse_iFindSwitch(tokens, ntok, 'l')!=-1)
    {
        if (pszDeviceList != NULL) goto dgdev_help;

        pszDeviceList = szLocalDeviceList;

        LastPointerAddr = GetExpression(szLocalDeviceListLast);
    }
    // -r means remote device list
    if (parse_iFindSwitch(tokens, ntok, 'r')!=-1)
    {
        if (pszDeviceList != NULL) goto dgdev_help;

        pszDeviceList = szRemoteDeviceList;

        LastPointerAddr = GetExpression(szRemoteDeviceListLast);
    }
    // -p may not be used with -c, -l, or -r
    if (parse_iFindSwitch(tokens, ntok, 'p')!=-1)
    {
        if (pszDeviceList != NULL) goto dgdev_help;
    }

    tok_pos = parse_FindNonSwitch(tokens, ntok);

    // Evaluate expression
    if (tok_pos != -1)
    {
        ULONG64 Displacement;

        if (pszDeviceList != NULL)
        {
            dprintf("  No expression maybe used with -c, -l, or -r.\n");
            goto dgdev_help;
        }

        GDeviceAddr = GetExpression(tokens[tok_pos]);

        if (GDeviceAddr == 0)
        {
            dprintf("  Expression \"%s\" evaluated to NULL.\n", tokens[tok_pos]);
            EXIT_API(S_OK);
        }

        // Look up symbol for address if we can
        Displacement = -1;
        szPGDSymbolBuffer[0] = 0;
        GetSymbol(GDeviceAddr, szPGDSymbolBuffer, &Displacement);

        if (Displacement == 0 && szPGDSymbolBuffer[0] != 0)
        {
            pszDeviceList = szPGDSymbolBuffer;
        }
        else
        {
            UseAddress = TRUE;
        }
    }

    // -p means the expression is a list pointer
    if (parse_iFindSwitch(tokens, ntok, 'p')!=-1)
    {
        if (tok_pos == -1)
        {
            dprintf(" Missing expression with -p.\n");
            goto dgdev_help;
        }

        // Use list show method
        GDeviceAddr = 0;
        if (pszDeviceList == NULL)
        {
            pszDeviceList = tokens[tok_pos];
        }
    }

    // User either specified a list or a pointer to a list
    if (GDeviceAddr == 0)
    {
        // TRUE if no -R, FALSE otherwise
        recursive = !recursive;

        if (pszDeviceList == NULL)
        {
            pszDeviceList = szCurrentDeviceList;
        }
        
        dprintf("Using Graphics Device List from %s\n", pszDeviceList);

        DEBUG_VALUE pgdevList;

        hr = g_pExtControl->Evaluate(pszDeviceList,
                                     DEBUG_VALUE_INT64,
                                     &pgdevList,
                                     NULL);

        if (hr == S_OK && pgdevList.I64 != 0)
        {
            if (SessionId == CURRENT_SESSION)
            {
                hr = g_pExtData->ReadPointersVirtual(1, pgdevList.I64, &GDeviceAddr);

                if (hr != S_OK)
                {
                    OutCtl.OutErr("  ReadPointer for %s failed at 0x%p.\n",
                                  pszDeviceList, pgdevList.I64);
                }
            }
            else
            {
                ULONG64 pgdevListPhys;

                UseAddress = TRUE;

                if ((hr = GetPhysicalAddress(Client,
                                             SessionId,
                                             pgdevList.I64,
                                             &pgdevListPhys)) == S_OK)
                {
                    hr = ReadPointerPhysical(Client, pgdevListPhys, &GDeviceAddr);

                    if (hr == S_OK)
                    {
                        OutCtl.Output("First GRAPHICS_DEVICE in session %lu located at 0x%p.\n",
                                      SessionId, GDeviceAddr);
                    }
                    else
                    {
                        OutCtl.OutErr("  ReadPointerPhysical for %s failed at # 0x%p.\n",
                               pszDeviceList, pgdevListPhys);
                    }
                }
                else
                {
                    OutCtl.OutErr("  Failed Virtual to Physical conversion for %s (0x%p) in session %ld.\n",
                                  pszDeviceList, pgdevList.I64, SessionId);
                }
            }

            if (hr != S_OK) EXIT_API(S_OK);

            // If a list last pointer exists, look it up.
            if (LastPointerAddr != 0)
            {
                if (SessionId == CURRENT_SESSION)
                {
                    hr = g_pExtData->ReadPointersVirtual(1, LastPointerAddr, &LastGDExpected);

                    if (hr != S_OK)
                    {
                        OutCtl.OutErr("  ReadPointer 0x%p failed.\n", LastPointerAddr);
                    }
                }
                else
                {
                    ULONG64 pgdevLastPhys;

                    if ((hr = GetPhysicalAddress(Client,
                                                 SessionId,
                                                 LastPointerAddr,
                                                 &pgdevLastPhys)) == S_OK)
                    {
                        hr = ReadPointerPhysical(Client, pgdevLastPhys, &LastGDExpected);

                        if (hr == S_OK)
                        {
                            OutCtl.Output("Last GRAPHICS_DEVICE in session %lu located at 0x%p.\n",
                                          SessionId, LastGDExpected);
                        }
                        else
                        {
                            OutCtl.OutErr("  ReadPointerPhysical for %s failed at # 0x%p.\n",
                                          pszDeviceList, pgdevLastPhys);
                        }
                    }
                    else
                    {
                        OutCtl.OutErr("  Failed Virtual to Physical conversion for %s (0x%p) in session %ld.\n",
                                      pszDeviceList, LastPointerAddr, SessionId);
                    }
                }
            }

            if (GDeviceAddr == 0)
            {
                OutCtl.Output("Graphics Device address is NULL.\n");
                EXIT_API(S_OK);
            }
        }
        else
        {
            // We should only be here if a -clr look up failed.
            if (hr != S_OK)
            {
                OutCtl.OutErr("  Evaluate(%s) returned %s\n",
                              pszDeviceList, pszHRESULT(hr));
            }
            else
            {
                OutCtl.OutErr("  Evaluate(%s) = NULL\n", pszHRESULT(hr));
            }
            OutCtl.OutErr("  Please double check symbols for " GDIModule() ".\n");
            EXIT_API(S_OK);
        }
    }

    if (recursive)
    {
        // Enable linked list resursion
        GraphicsDeviceSym.Options |= DBG_DUMP_LIST;
        GraphicsDeviceSym.listLink = &GraphicsDeviceLink;

        NextItemCallbackInit(szGraphicsDeviceHeader, LastGDExpected);
    }
    else
    {
        // Printer header since this is a single structure dump
        dprintf(szGraphicsDeviceHeader);
        if (UseAddress)
        {
            dprintf("%#p\n", GDeviceAddr);
        }
    }

    if (UseAddress)
    {
        // Dump from a type w/ an address
        GraphicsDeviceSym.addr = GDeviceAddr;
    }
    else
    {
        // Dump from a symbol
        GraphicsDeviceSym.sName = DbgStr(pszDeviceList);
        if (GetTypeSize(pszDeviceList) == 8)
        {
            GraphicsDeviceLink.fieldCallBack = PointerToNextItemCallback;
        }
    }

    // Do the dumping
    error = Ioctl( IG_DUMP_SYMBOL_INFO, &GraphicsDeviceSym, GraphicsDeviceSym.size );

    if (error)
    {
        dprintf("Unable to get contents of GRAPHICS_DEVICE\n");
        dprintf("  (Ioctl returned %s)\n", pszWinDbgError(error));
    }

    dprintf("--------------------------------------------------\n\n");

    // Did we find end of list as expected?
    if (recursive && !LastCallbackItemFound())
    {
        dprintf(" * Error: Last expected GRAPHICS_DEVICE @ %#p was not found.\n", LastGDExpected);
    }

    EXIT_API(S_OK);

dgdev_help:
    dprintf("Usage: dgdev [-?] [-mR] [-clr | [-p] expr ]\n"
            "         ? - Show this help\n"
            "         m - Dump modes\n"
            "         R - Recurse for address; don't for list\n"
            "         c - Recurse list from current list [default]\n"
            "         l - Recurse list from local list\n"
            "         r - Recurse list from remote list\n"
            "         p - expr is address or symbol for pointer to list\n"
            "      expr - Address or symbol for GRAPHICS_DEVICE to show\n"
            );
    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
* BRUSH
*
\**************************************************************************/

DECLARE_API( brush )
{
    BEGIN_API( brush );

    HRESULT         hr = S_OK;
    ULONG64         BrushAddr;
    DEBUG_VALUE     Arg;
    DEBUG_VALUE     Offset;
    OutputControl   OutCtl(Client);

    while (isspace(*args)) args++;

    if (*args == '-' ||
        (hr = Evaluate(Client, args, DEBUG_VALUE_INT64, 0, &Arg, NULL)) != S_OK)
    {
        OutCtl.Output("Usage: brush [-?] <HBRUSH | BRUSH Addr>\n");
    }
    else
    {
        hr = GetObjectAddress(Client,Arg.I64,&BrushAddr,BRUSH_TYPE,TRUE,TRUE);

        if (hr != S_OK || BrushAddr == 0)
        {
            DEBUG_VALUE         ObjHandle;
            TypeOutputParser    TypeParser(Client);
            OutputState         OutState(Client);
            ULONG64             BrushAddrFromHmgr;

            BrushAddr = Arg.I64;

            // Try to read hHmgr from BRUSH type, but if that
            // fails use the BASEOBJECT type, which is public.
            if ((hr = OutState.Setup(0, &TypeParser)) != S_OK ||
                (hr = OutState.OutputTypeVirtual(BrushAddr, GDIType(BRUSH), 0)) != S_OK ||
                (hr = TypeParser.Get(&ObjHandle, "hHmgr", DEBUG_VALUE_INT64)) != S_OK)
            {
                OutCtl.OutErr("Unable to get contents of BRUSH's handle\n");
                OutCtl.OutErr("  (Type Read returned %s)\n", pszHRESULT(hr));
                OutCtl.OutErr(" 0x%p is neither an HBRUSH nor valid BRUSH address\n", Arg.I64);
            }
            else
            {
                if (GetObjectAddress(Client,ObjHandle.I64,&BrushAddrFromHmgr,
                                     BRUSH_TYPE,TRUE,FALSE) == S_OK &&
                    BrushAddrFromHmgr != BrushAddr)
                {
                    OutCtl.OutWarn("\tNote: BRUSH may not be valid.\n"
                            "\t      It does not have a valid handle manager entry.\n");
                }
            }
        }

        if (hr == S_OK)
        {
            hr = DumpType(Client, "BRUSH", BrushAddr);

            if (hr != S_OK)
            {
                OutCtl.OutErr("Type Dump for BRUSH returned %s.\n", pszHRESULT(hr));
            }
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
* DECLARE_API( dpbrush ) - OBSOLETE
*
\**************************************************************************/

DECLARE_API( dpbrush )
{
    INIT_API();
    ExtOut("Obsolete: Use '!gdikdx.brush <Handle | Address>'.\n");
    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
* DECLARE_API( ebrush )
*
*   Dumps an EBRUSHOBJ
*
\**************************************************************************/

DECLARE_API( ebrush )
{
    return ExtDumpType(Client, "ebrush", "EBRUSHOBJ", args);
}


/******************************Public*Routine******************************\
* DECLARE_API( semorder )
*
\**************************************************************************/

#define NUM_ALOC_FIELDS 5

ULONG gSemAcquireLocArrayLength = 0;

ULONG SemAcquireLocCountCallback(
    PFIELD_INFO pField,
    PULONG pSemAcquireLocArrayLength
    )
{
    ULONG Count = (ULONG)pField->address;

    *pSemAcquireLocArrayLength = (Count < gSemAcquireLocArrayLength) ? Count : 0;

    return ULONGCallback(pField, pSemAcquireLocArrayLength);
}

DECLARE_API( semorder )
{
    ULONG64 ThreadAddress = CURRENT_THREAD_ADDRESS;
    ULONG64 Tcb_Header_Type;
    DEBUG_VALUE W32ThreadAddress;
    ULONG64 SemTableAddress;
    BOOL    bShowALocs = TRUE;
    ULONG   error;

    static char szHeader[]      = " hSem x hold count\tOrder\tParent";
    static char szHeaderALoc[]  = " hSem x hold count\tOrder\tParent    \n\t Acquisitions: name and location";

    ULONG   dwProcessor=0;
    HANDLE  hCurrentThread=NULL;

    INIT_API();

    PARSE_ARGUMENTS(semorder_help);

    if (parse_iFindSwitch(tokens, ntok, 'n')!=-1)
    {
        bShowALocs = FALSE;
    }

    if (!GetExpressionEx(args, &ThreadAddress, &args))
    {
        while (*args && isspace(*args)) args++;
        if (*args)
        {
            if (args[0] == '-' && args[1]=='n' && (args[2] == 0 || isspace(args[2])))
            {
                args += 2;
                while (*args && isspace(*args)) args++;

                if (*args && !GetExpressionEx(args, &ThreadAddress, &args))
                {
                    dprintf("Error: invalid arguments: %s\n", args);
                    goto semorder_help;
                }
            }
            else
            {
                dprintf("Error: invalid arguments: %s\n", args);
                goto semorder_help;
            }
        }
    }

    if (S_OK != GetThreadField(Client, &ThreadAddress, "Tcb.Win32Thread",
                               &W32ThreadAddress, DEBUG_VALUE_INT64))
    {
        EXIT_API(S_OK);
    }

    ExtVerb("  W32Thread = 0x%p\n", W32ThreadAddress.I64);

    if (error = GetFieldValue(W32ThreadAddress.I64, GDIType(W32THREAD), "pSemTable", SemTableAddress))
    {
        dprintf("Unable to get pSemTable from W32THREAD 0x%p\n", W32ThreadAddress.I64 );
        dprintf("  (GetFieldValue returned %s)\n", pszWinDbgError(error));
        EXIT_API(S_OK);
    }

    ExtVerb("  pSemTable = %p\n", SemTableAddress);

    if (SemTableAddress == 0)
    {
        dprintf("  No semaphores have been tracked for validation.\n");
    }
    else
    {
        FIELD_INFO SemEntryList = { NULL, DbgStr(szHeaderALoc),
                                    0 /*pSemTable->numEntries*/, 0, 0, ArrayCallback };
        FIELD_INFO SemEntryFields[] = {
            { DbgStr("Acquired"),           NULL,           0, DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_ARRAY, 0, NULL},
            { DbgStr("Acquired.name"),      DbgStr("\n\t"), 0, DBG_DUMP_FIELD_FULL_NAME, 0, AStringCallback},
            { DbgStr("Acquired.func"),      DbgStr(" in"),  0, DBG_DUMP_FIELD_FULL_NAME, 0, AStringCallback},
            { DbgStr("Acquired.file"),      DbgStr(" @"),   0, DBG_DUMP_FIELD_FULL_NAME, 0, AStringCallback},
            { DbgStr("Acquired.line"),      DbgStr(":"),    0, DBG_DUMP_FIELD_FULL_NAME, 0, LONGCallback},
            { DbgStr("hsem"),               DbgStr(" "),    0, DBG_DUMP_FIELD_FULL_NAME, 0, DWORDCallback},
            { DbgStr("count"),              DbgStr(" x "),  0, DBG_DUMP_FIELD_FULL_NAME, 0, SemAcquireLocCountCallback},
            { DbgStr("order"),              DbgStr("\t"),   0, DBG_DUMP_FIELD_FULL_NAME, 0, ULONGCallback},
            { DbgStr("parent"),             DbgStr("\t"),   0, DBG_DUMP_FIELD_FULL_NAME, 0, DWORDCallback},
        };
        SYM_DUMP_PARAM SemEntrySym = {
           sizeof (SYM_DUMP_PARAM), DbgStr(GDIType(SemEntry)), 
           DBG_DUMP_NO_PRINT | DBG_DUMP_ARRAY,
           0 /*pSemTable->entries*/,
           &SemEntryList, &SemEntryFields[0].size, NULL,
           sizeof(SemEntryFields)/sizeof(SemEntryFields[0]), SemEntryFields
        };
        PrepareCallbacks(FALSE, 0);

        if (error = (ULONG)InitTypeRead(SemTableAddress, win32k!SemTable))
        {
            dprintf("Error: InitTypeRead for SemTable returned %s\n", pszWinDbgError(error));
            EXIT_API(S_OK);
        }

        SemEntryList.size = (ULONG)ReadField(numEntries);

        if (SemEntryList.size == 0)
        {
            dprintf(" No entries are currently held.\n");
        }
        else
        {
            SemEntrySym.addr = ReadField(entries);

            gSemAcquireLocArrayLength = 0;

            if (bShowALocs)
            {
                FIELD_INFO SemEntryLocEntrySizeField = { DbgStr("Acquired[0]"), NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL};
                FIELD_INFO SemEntryLocArraySizeField = { DbgStr("Acquired"), NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL};
                SYM_DUMP_PARAM SemEntryLocSizeSym = {
                   sizeof (SYM_DUMP_PARAM), DbgStr(GDIType(SemEntry)), 
                   DBG_DUMP_NO_PRINT, 0,
                   NULL, NULL, NULL,
                   1, &SemEntryLocEntrySizeField
                };

                // Get size of one entry
                error = Ioctl(IG_DUMP_SYMBOL_INFO, &SemEntryLocSizeSym, SemEntryLocSizeSym.size);

                if (!error && SemEntryLocEntrySizeField.size != 0)
                {
                    SemEntryLocSizeSym.Fields = &SemEntryLocArraySizeField;

                    // Get size of entire array
                    error = Ioctl(IG_DUMP_SYMBOL_INFO, &SemEntryLocSizeSym, SemEntryLocSizeSym.size);

                    if (!error)
                    {
                        gSemAcquireLocArrayLength = SemEntryLocArraySizeField.size / SemEntryLocEntrySizeField.size;
                    }
                }
            }

            if (gSemAcquireLocArrayLength == 0)
            {
                // Setup dump to ignore acquisition location info
                SemEntryList.printName = DbgStr(szHeader);

                SemEntrySym.nFields -= NUM_ALOC_FIELDS;
                SemEntrySym.Fields += NUM_ALOC_FIELDS;

                SemEntryFields[NUM_ALOC_FIELDS+1].fieldCallBack = ULONGCallback;
            }

            error = Ioctl(IG_DUMP_SYMBOL_INFO, &SemEntrySym, SemEntrySym.size);

            dprintf("\n");

            if (error)
            {
                dprintf("Error: Ioctl returned %s\n", pszWinDbgError(error));
            }
        }
    }

    EXIT_API(S_OK);

semorder_help:
    dprintf("Usage: semorder [-n] [thread]\n"
            "\n"
            "           -n  Don't display acquisition location details\n");
    EXIT_API(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\input.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    input.cxx

Abstract:

    This file contains the routines to get user input.

Author:

    Jason Hartman (JasonHa) 2001-05-22

Environment:

    User Mode

--*/

#include "precomp.hxx"



HRESULT
GetYNInput(
    PDEBUG_CONTROL Control,
    PCSTR Prompt
    )
{
    HRESULT hr;
    CHAR    Response[4];
    ULONG   ResponseLen;

    Control->Output(DEBUG_OUTPUT_NORMAL, "%s yn\n", Prompt);

    do
    {
        hr = Control->Input(Response, sizeof(Response), &ResponseLen);

        if (hr == E_ABORT) break;

        if (hr == S_OK)
        {
            if (ResponseLen != 2)
            {
                hr = E_INVALIDARG;
            }
            else
            {
                Response[0] = (CHAR)tolower(Response[0]);

                if (Response[0] != 'y' && Response[0] != 'n')
                {
                    hr = E_INVALIDARG;
                }
            }
        }

        if (hr != S_OK)
        {
            Control->Output(DEBUG_OUTPUT_WARNING, " Please answer y or n.\n");
        }
    } while (hr != S_OK);

    if (hr == S_OK && Response[0] != 'y')
    {
        hr = S_FALSE;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\flags.cxx ===
/******************************Module*Header*******************************\
* Module Name: flags.cxx
*
* Copyright (c) 1995-2000 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

// The following define expands 'FLAG(x)' to '"x", x':

#define FLAG(x) { #x, x }

#define END_FLAG { 0, 0 }


// The following define expands 'ENUM(x)' to '"x", x':

#define ENUM(x) { #x, x }

#define END_ENUM { 0, 0 }


#define CASEENUM(x) case x: psz = #x; break


FLAGDEF afdFDM[] = {
    {"FDM_TYPE_BM_SIDE_CONST         " , FDM_TYPE_BM_SIDE_CONST          },
    {"FDM_TYPE_MAXEXT_EQUAL_BM_SIDE  " , FDM_TYPE_MAXEXT_EQUAL_BM_SIDE   },
    {"FDM_TYPE_CHAR_INC_EQUAL_BM_BASE" , FDM_TYPE_CHAR_INC_EQUAL_BM_BASE },
    {"FDM_TYPE_ZERO_BEARINGS         " , FDM_TYPE_ZERO_BEARINGS          },
    {"FDM_TYPE_CONST_BEARINGS        " , FDM_TYPE_CONST_BEARINGS         },
    {                                 0, 0                               }
};


FLAGDEF afdPFF[] = {
    {"PFF_STATE_READY2DIE     ", PFF_STATE_READY2DIE     },
    {"PFF_STATE_PERMANENT_FONT", PFF_STATE_PERMANENT_FONT},
    {"PFF_STATE_NETREMOTE_FONT", PFF_STATE_NETREMOTE_FONT},
    {"PFF_STATE_EUDC_FONT     ", PFF_STATE_EUDC_FONT     },
    {"PFF_STATE_MEMORY_FONT   ", PFF_STATE_MEMORY_FONT   },
    {"PFF_STATE_DCREMOTE_FONT ", PFF_STATE_DCREMOTE_FONT },
    {                         0, 0                       }
};

FLAGDEF afdLINEATTRS[] = {
    { "LA_GEOMETRIC", LA_GEOMETRIC },
    { "LA_ALTERNATE", LA_ALTERNATE },
    { "LA_STARTGAP ", LA_STARTGAP  },
    { "LA_STYLED   ", LA_STYLED    },
    {              0, 0            }
};

FLAGDEF afdDCPATH[] = {
    { "DCPATH_ACTIVE   ", DCPATH_ACTIVE    },
    { "DCPATH_SAVE     ", DCPATH_SAVE      },
    { "DCPATH_CLOCKWISE", DCPATH_CLOCKWISE },
    {                  0, 0                }
};

FLAGDEF afdCOLORADJUSTMENT[] = {
    { "CA_NEGATIVE  ", CA_NEGATIVE   },
    { "CA_LOG_FILTER", CA_LOG_FILTER },
    {               0, 0             }
};

FLAGDEF afdATTR[] = {
    { "ATTR_CACHED       ", ATTR_CACHED        },
    { "ATTR_TO_BE_DELETED", ATTR_TO_BE_DELETED },
    { "ATTR_NEW_COLOR    ", ATTR_NEW_COLOR     },
    { "ATTR_CANT_SELECT  ", ATTR_CANT_SELECT   },
    { "ATTR_RGN_VALID    ", ATTR_RGN_VALID     },
    { "ATTR_RGN_DIRTY    ", ATTR_RGN_DIRTY     },
    {                    0, 0                  }
};

FLAGDEF afdDCla[] = {
    { "LA_GEOMETRIC", LA_GEOMETRIC },
    { "LA_ALTERNATE", LA_ALTERNATE },
    { "LA_STARTGAP ", LA_STARTGAP  },
    { "LA_STYLED   ", LA_STYLED    },
    {              0, 0            }
};

FLAGDEF afdDCPath[] = {
    { "DCPATH_ACTIVE   ", DCPATH_ACTIVE    },
    { "DCPATH_SAVE     ", DCPATH_SAVE      },
    { "DCPATH_CLOCKWISE", DCPATH_CLOCKWISE },
    {                  0, 0                }
};

FLAGDEF afdDirty[] = {
    { "DIRTY_FILL              ", DIRTY_FILL              },
    { "DIRTY_LINE              ", DIRTY_LINE              },
    { "DIRTY_TEXT              ", DIRTY_TEXT              },
    { "DIRTY_BACKGROUND        ", DIRTY_BACKGROUND        },
    { "DIRTY_CHARSET           ", DIRTY_CHARSET           },
    { "SLOW_WIDTHS             ", SLOW_WIDTHS             },
    { "DC_CACHED_TM_VALID      ", DC_CACHED_TM_VALID      },
    { "DISPLAY_DC              ", DISPLAY_DC              },
    { "DIRTY_PTLCURRENT        ", DIRTY_PTLCURRENT        },
    { "DIRTY_PTFXCURRENT       ", DIRTY_PTFXCURRENT       },
    { "DIRTY_STYLESTATE        ", DIRTY_STYLESTATE        },
    { "DC_PLAYMETAFILE         ", DC_PLAYMETAFILE         },
    { "DC_BRUSH_DIRTY          ", DC_BRUSH_DIRTY          },
    { "DC_PEN_DIRTY            ", DC_PEN_DIRTY            },
    { "DC_DIBSECTION           ", DC_DIBSECTION           },
    { "DC_LAST_CLIPRGN_VALID   ", DC_LAST_CLIPRGN_VALID   },
    { "DC_PRIMARY_DISPLAY      ", DC_PRIMARY_DISPLAY      },
    {                          0, 0                       }
};

FLAGDEF afdPAL[] = {
    {"PAL_INDEXED           ",PAL_INDEXED       },
    {"PAL_BITFIELDS         ",PAL_BITFIELDS     },
    {"PAL_RGB               ",PAL_RGB           },
    {"PAL_BGR               ",PAL_BGR           },
    {"PAL_DC                ",PAL_DC            },
    {"PAL_FIXED             ",PAL_FIXED         },
    {"PAL_FREE              ",PAL_FREE          },
    {"PAL_MANAGED           ",PAL_MANAGED       },
    {"PAL_NOSTATIC          ",PAL_NOSTATIC      },
    {"PAL_MONOCHROME        ",PAL_MONOCHROME    },
    {"PAL_BRUSHHACK         ",PAL_BRUSHHACK     },
    {"PAL_DIBSECTION        ",PAL_DIBSECTION    },
    {"PAL_NOSTATIC256       ",PAL_NOSTATIC256   },
    {"PAL_HT                ",PAL_HT            },
    {"PAL_RGB16_555         ",PAL_RGB16_555     },
    {"PAL_RGB16_565         ",PAL_RGB16_565     },
    {                       0, 0                }
};

FLAGDEF afdDCFL[] = {
    { "DC_FL_PAL_BACK", DC_FL_PAL_BACK },
    {                0, 0              }
};

FLAGDEF afdDCFS[] = {
    { "DC_DIRTYFONT_XFORM", DC_DIRTYFONT_XFORM },
    { "DC_DIRTYFONT_LFONT", DC_DIRTYFONT_LFONT },
    { "DC_UFI_MAPPING    ", DC_UFI_MAPPING     },
    {                    0, 0                  }
};

FLAGDEF afdPD[] = {
    { "PD_BEGINSUBPATH", PD_BEGINSUBPATH },
    { "PD_ENDSUBPATH  ", PD_ENDSUBPATH   },
    { "PD_RESETSTYLE  ", PD_RESETSTYLE   },
    { "PD_CLOSEFIGURE ", PD_CLOSEFIGURE  },
    { "PD_BEZIERS     ", PD_BEZIERS      },
    {                 0, 0               }
};


FLAGDEF afdFS[] = {
    { "PDEV_DISPLAY                    ", PDEV_DISPLAY                    },
    { "PDEV_HARDWARE_POINTER           ", PDEV_HARDWARE_POINTER           },
    { "PDEV_SOFTWARE_POINTER           ", PDEV_SOFTWARE_POINTER           },
    { "PDEV_GOTFONTS                   ", PDEV_GOTFONTS                   },
    { "PDEV_PRINTER                    ", PDEV_PRINTER                    },
    { "PDEV_ALLOCATEDBRUSHES           ", PDEV_ALLOCATEDBRUSHES           },
    { "PDEV_HTPAL_IS_DEVPAL            ", PDEV_HTPAL_IS_DEVPAL            },
    { "PDEV_DISABLED                   ", PDEV_DISABLED                   },
    { "PDEV_SYNCHRONIZE_ENABLED        ", PDEV_SYNCHRONIZE_ENABLED        },
    { "PDEV_FONTDRIVER                 ", PDEV_FONTDRIVER                 },
    { "PDEV_GAMMARAMP_TABLE            ", PDEV_GAMMARAMP_TABLE            },
    { "PDEV_UMPD                       ", PDEV_UMPD                       },
    { "PDEV_SHARED_DEVLOCK             ", PDEV_SHARED_DEVLOCK             },
    { "PDEV_META_DEVICE                ", PDEV_META_DEVICE                },
    { "PDEV_DRIVER_PUNTED_CALL         ", PDEV_DRIVER_PUNTED_CALL         },
    { "PDEV_CLONE_DEVICE               ", PDEV_CLONE_DEVICE               },
    {                                  0, 0                               }
};

FLAGDEF afdDCX[] = {
    { "METAFILE_TO_WORLD_IDENTITY   ",  METAFILE_TO_WORLD_IDENTITY    },
    { "WORLD_TO_PAGE_IDENTITY       ",  WORLD_TO_PAGE_IDENTITY        },
    { "DEVICE_TO_PAGE_INVALID       ",  DEVICE_TO_PAGE_INVALID        },
    { "DEVICE_TO_WORLD_INVALID      ",  DEVICE_TO_WORLD_INVALID       },
    { "WORLD_TRANSFORM_SET          ",  WORLD_TRANSFORM_SET           },
    { "POSITIVE_Y_IS_UP             ",  POSITIVE_Y_IS_UP              },
    { "INVALIDATE_ATTRIBUTES        ",  INVALIDATE_ATTRIBUTES         },
    { "PTOD_EFM11_NEGATIVE          ",  PTOD_EFM11_NEGATIVE           },
    { "PTOD_EFM22_NEGATIVE          ",  PTOD_EFM22_NEGATIVE           },
    { "ISO_OR_ANISO_MAP_MODE        ",  ISO_OR_ANISO_MAP_MODE         },
    { "PAGE_TO_DEVICE_IDENTITY      ",  PAGE_TO_DEVICE_IDENTITY       },
    { "PAGE_TO_DEVICE_SCALE_IDENTITY",  PAGE_TO_DEVICE_SCALE_IDENTITY },
    { "PAGE_XLATE_CHANGED           ",  PAGE_XLATE_CHANGED            },
    { "PAGE_EXTENTS_CHANGED         ",  PAGE_EXTENTS_CHANGED          },
    { "WORLD_XFORM_CHANGED          ",  WORLD_XFORM_CHANGED           },
    {                               0,  0                             }
};

FLAGDEF afdDC[] = {
    { "DC_DISPLAY          ", DC_DISPLAY           },
    { "DC_DIRECT           ", DC_DIRECT            },
    { "DC_CANCELED         ", DC_CANCELED          },
    { "DC_PERMANANT        ", DC_PERMANANT         },
    { "DC_DIRTY_RAO        ", DC_DIRTY_RAO         },
    { "DC_ACCUM_WMGR       ", DC_ACCUM_WMGR        },
    { "DC_ACCUM_APP        ", DC_ACCUM_APP         },
    { "DC_RESET            ", DC_RESET             },
    { "DC_SYNCHRONIZEACCESS", DC_SYNCHRONIZEACCESS },
    { "DC_EPSPRINTINGESCAPE", DC_EPSPRINTINGESCAPE },
    { "DC_TEMPINFODC       ", DC_TEMPINFODC        },
    { "DC_FULLSCREEN       ", DC_FULLSCREEN        },
    { "DC_IN_CLONEPDEV     ", DC_IN_CLONEPDEV      },
    { "DC_REDIRECTION      ", DC_REDIRECTION       },   
    { "DC_SHAREACCESS      ", DC_SHAREACCESS       },   
    {                      0, 0                    }
};

FLAGDEF afdGC[] = {
    { "GCAPS_BEZIERS         ", GCAPS_BEZIERS          },
    { "GCAPS_GEOMETRICWIDE   ", GCAPS_GEOMETRICWIDE    },
    { "GCAPS_ALTERNATEFILL   ", GCAPS_ALTERNATEFILL    },
    { "GCAPS_WINDINGFILL     ", GCAPS_WINDINGFILL      },
    { "GCAPS_HALFTONE        ", GCAPS_HALFTONE         },
    { "GCAPS_COLOR_DITHER    ", GCAPS_COLOR_DITHER     },
    { "GCAPS_HORIZSTRIKE     ", GCAPS_HORIZSTRIKE      },
    { "GCAPS_VERTSTRIKE      ", GCAPS_VERTSTRIKE       },
    { "GCAPS_OPAQUERECT      ", GCAPS_OPAQUERECT       },
    { "GCAPS_VECTORFONT      ", GCAPS_VECTORFONT       },
    { "GCAPS_MONO_DITHER     ", GCAPS_MONO_DITHER      },
    { "GCAPS_ASYNCCHANGE     ", GCAPS_ASYNCCHANGE      },
    { "GCAPS_ASYNCMOVE       ", GCAPS_ASYNCMOVE        },
    { "GCAPS_DONTJOURNAL     ", GCAPS_DONTJOURNAL      },
    { "GCAPS_ARBRUSHOPAQUE   ", GCAPS_ARBRUSHOPAQUE    },
    { "GCAPS_PANNING         ", GCAPS_PANNING          },
    { "GCAPS_HIGHRESTEXT     ", GCAPS_HIGHRESTEXT      },
    { "GCAPS_PALMANAGED      ", GCAPS_PALMANAGED       },
    { "GCAPS_DITHERONREALIZE ", GCAPS_DITHERONREALIZE  },
    { "GCAPS_NO64BITMEMACCESS", GCAPS_NO64BITMEMACCESS },
    { "GCAPS_FORCEDITHER     ", GCAPS_FORCEDITHER      },
    { "GCAPS_GRAY16          ", GCAPS_GRAY16           },
    { "GCAPS_ICM             ", GCAPS_ICM              },
    { "GCAPS_CMYKCOLOR       ", GCAPS_CMYKCOLOR        },
    {                        0, 0                      }
};

FLAGDEF afdGC2[] = {
    { "GCAPS2_JPEGSRC        ", GCAPS2_JPEGSRC         },
    { "GCAPS2_SYNCFLUSH      ", GCAPS2_SYNCFLUSH       },
    { "GCAPS2_PNGSRC         ", GCAPS2_PNGSRC          },
    {                        0, 0                      }
};

FLAGDEF afdTSIM[] = {
  { "TO_MEM_ALLOCATED ", TO_MEM_ALLOCATED  },
  { "TO_ALL_PTRS_VALID", TO_ALL_PTRS_VALID },
  { "TO_VALID         ", TO_VALID          },
  { "TO_ESC_NOT_ORIENT", TO_ESC_NOT_ORIENT },
  { "TO_PWSZ_ALLOCATED", TO_PWSZ_ALLOCATED },
  { "TO_HIGHRESTEXT   ", TO_HIGHRESTEXT    },
  { "TSIM_UNDERLINE1  ", TSIM_UNDERLINE1   },
  { "TSIM_UNDERLINE2  ", TSIM_UNDERLINE2   },
  { "TSIM_STRIKEOUT   ", TSIM_STRIKEOUT    },
  {                   0, 0                 }
};

FLAGDEF afdRC[] = {
    { "RC_NONE        ", RC_NONE         },
    { "RC_BITBLT      ", RC_BITBLT       },
    { "RC_BANDING     ", RC_BANDING      },
    { "RC_SCALING     ", RC_SCALING      },
    { "RC_BITMAP64    ", RC_BITMAP64     },
    { "RC_GDI20_OUTPUT", RC_GDI20_OUTPUT },
    { "RC_GDI20_STATE ", RC_GDI20_STATE  },
    { "RC_SAVEBITMAP  ", RC_SAVEBITMAP   },
    { "RC_DI_BITMAP   ", RC_DI_BITMAP    },
    { "RC_PALETTE     ", RC_PALETTE      },
    { "RC_DIBTODEV    ", RC_DIBTODEV     },
    { "RC_BIGFONT     ", RC_BIGFONT      },
    { "RC_STRETCHBLT  ", RC_STRETCHBLT   },
    { "RC_FLOODFILL   ", RC_FLOODFILL    },
    { "RC_STRETCHDIB  ", RC_STRETCHDIB   },
    { "RC_OP_DX_OUTPUT", RC_OP_DX_OUTPUT },
    { "RC_DEVBITS     ", RC_DEVBITS      },
    { 0                , 0               }
};

FLAGDEF afdTC[] = {
    { "TC_OP_CHARACTER", TC_OP_CHARACTER },
    { "TC_OP_STROKE   ", TC_OP_STROKE    },
    { "TC_CP_STROKE   ", TC_CP_STROKE    },
    { "TC_CR_90       ", TC_CR_90        },
    { "TC_CR_ANY      ", TC_CR_ANY       },
    { "TC_SF_X_YINDEP ", TC_SF_X_YINDEP  },
    { "TC_SA_DOUBLE   ", TC_SA_DOUBLE    },
    { "TC_SA_INTEGER  ", TC_SA_INTEGER   },
    { "TC_SA_CONTIN   ", TC_SA_CONTIN    },
    { "TC_EA_DOUBLE   ", TC_EA_DOUBLE    },
    { "TC_IA_ABLE     ", TC_IA_ABLE      },
    { "TC_UA_ABLE     ", TC_UA_ABLE      },
    { "TC_SO_ABLE     ", TC_SO_ABLE      },
    { "TC_RA_ABLE     ", TC_RA_ABLE      },
    { "TC_VA_ABLE     ", TC_VA_ABLE      },
    { "TC_RESERVED    ", TC_RESERVED     },
    { "TC_SCROLLBLT   ", TC_SCROLLBLT    },
    { 0                , 0               }
};

FLAGDEF afdHT[] = {
    { "HT_FLAG_SQUARE_DEVICE_PEL", HT_FLAG_SQUARE_DEVICE_PEL },
    { "HT_FLAG_HAS_BLACK_DYE    ", HT_FLAG_HAS_BLACK_DYE     },
    { "HT_FLAG_ADDITIVE_PRIMS   ", HT_FLAG_ADDITIVE_PRIMS    },
    { "HT_FLAG_OUTPUT_CMY       ", HT_FLAG_OUTPUT_CMY        },
    { 0                          , 0                         }
};

FLAGDEF afdDCfs[] = {
  { "DC_DISPLAY          ", DC_DISPLAY           },
  { "DC_DIRECT           ", DC_DIRECT            },
  { "DC_CANCELED         ", DC_CANCELED          },
  { "DC_PERMANANT        ", DC_PERMANANT         },
  { "DC_DIRTY_RAO        ", DC_DIRTY_RAO         },
  { "DC_ACCUM_WMGR       ", DC_ACCUM_WMGR        },
  { "DC_ACCUM_APP        ", DC_ACCUM_APP         },
  { "DC_RESET            ", DC_RESET             },
  { "DC_SYNCHRONIZEACCESS", DC_SYNCHRONIZEACCESS },
  { "DC_EPSPRINTINGESCAPE", DC_EPSPRINTINGESCAPE },
  { "DC_TEMPINFODC       ", DC_TEMPINFODC        },
  { "DC_FULLSCREEN       ", DC_FULLSCREEN        },
  { "DC_IN_CLONEPDEV     ", DC_IN_CLONEPDEV      },
  { "DC_REDIRECTION      ", DC_REDIRECTION       },
  {                     0, 0                    }
};

FLAGDEF afdGInfo[] = {
  { "GCAPS_BEZIERS         ", GCAPS_BEZIERS          },
  { "GCAPS_GEOMETRICWIDE   ", GCAPS_GEOMETRICWIDE    },
  { "GCAPS_ALTERNATEFILL   ", GCAPS_ALTERNATEFILL    },
  { "GCAPS_WINDINGFILL     ", GCAPS_WINDINGFILL      },
  { "GCAPS_HALFTONE        ", GCAPS_HALFTONE         },
  { "GCAPS_COLOR_DITHER    ", GCAPS_COLOR_DITHER     },
  { "GCAPS_HORIZSTRIKE     ", GCAPS_HORIZSTRIKE      },
  { "GCAPS_VERTSTRIKE      ", GCAPS_VERTSTRIKE       },
  { "GCAPS_OPAQUERECT      ", GCAPS_OPAQUERECT       },
  { "GCAPS_VECTORFONT      ", GCAPS_VECTORFONT       },
  { "GCAPS_MONO_DITHER     ", GCAPS_MONO_DITHER      },
  { "GCAPS_ASYNCCHANGE     ", GCAPS_ASYNCCHANGE      },
  { "GCAPS_ASYNCMOVE       ", GCAPS_ASYNCMOVE        },
  { "GCAPS_DONTJOURNAL     ", GCAPS_DONTJOURNAL      },
  { "GCAPS_ARBRUSHOPAQUE   ", GCAPS_ARBRUSHOPAQUE    },
  { "GCAPS_HIGHRESTEXT     ", GCAPS_HIGHRESTEXT      },
  { "GCAPS_PALMANAGED      ", GCAPS_PALMANAGED       },
  { "GCAPS_DITHERONREALIZE ", GCAPS_DITHERONREALIZE  },
  { "GCAPS_NO64BITMEMACCESS", GCAPS_NO64BITMEMACCESS },
  { "GCAPS_FORCEDITHER     ", GCAPS_FORCEDITHER      },
  { "GCAPS_GRAY16          ", GCAPS_GRAY16           },
  { "GCAPS_ICM             ", GCAPS_ICM              },
  { "GCAPS_CMYKCOLOR       ", GCAPS_CMYKCOLOR        },
  {                        0, 0                      }
};

// IFIMETRICS::flInfo
FLAGDEF afdInfo[] = {
  { "FM_INFO_TECH_TRUETYPE            ", FM_INFO_TECH_TRUETYPE             },
  { "FM_INFO_TECH_BITMAP              ", FM_INFO_TECH_BITMAP               },
  { "FM_INFO_TECH_STROKE              ", FM_INFO_TECH_STROKE               },
  { "FM_INFO_TECH_OUTLINE_NOT_TRUETYPE", FM_INFO_TECH_OUTLINE_NOT_TRUETYPE },
  { "FM_INFO_ARB_XFORMS               ", FM_INFO_ARB_XFORMS                },
  { "FM_INFO_1BPP                     ", FM_INFO_1BPP                      },
  { "FM_INFO_4BPP                     ", FM_INFO_4BPP                      },
  { "FM_INFO_8BPP                     ", FM_INFO_8BPP                      },
  { "FM_INFO_16BPP                    ", FM_INFO_16BPP                     },
  { "FM_INFO_24BPP                    ", FM_INFO_24BPP                     },
  { "FM_INFO_32BPP                    ", FM_INFO_32BPP                     },
  { "FM_INFO_INTEGER_WIDTH            ", FM_INFO_INTEGER_WIDTH             },
  { "FM_INFO_CONSTANT_WIDTH           ", FM_INFO_CONSTANT_WIDTH            },
  { "FM_INFO_NOT_CONTIGUOUS           ", FM_INFO_NOT_CONTIGUOUS            },
  { "FM_INFO_TECH_MM                  ", FM_INFO_TECH_MM                   },
  { "FM_INFO_RETURNS_OUTLINES         ", FM_INFO_RETURNS_OUTLINES          },
  { "FM_INFO_RETURNS_STROKES          ", FM_INFO_RETURNS_STROKES           },
  { "FM_INFO_RETURNS_BITMAPS          ", FM_INFO_RETURNS_BITMAPS           },
  { "FM_INFO_DSIG                     ", FM_INFO_DSIG                      },
  { "FM_INFO_RIGHT_HANDED             ", FM_INFO_RIGHT_HANDED              },
  { "FM_INFO_INTEGRAL_SCALING         ", FM_INFO_INTEGRAL_SCALING          },
  { "FM_INFO_90DEGREE_ROTATIONS       ", FM_INFO_90DEGREE_ROTATIONS        },
  { "FM_INFO_OPTICALLY_FIXED_PITCH    ", FM_INFO_OPTICALLY_FIXED_PITCH     },
  { "FM_INFO_DO_NOT_ENUMERATE         ", FM_INFO_DO_NOT_ENUMERATE          },
  { "FM_INFO_ISOTROPIC_SCALING_ONLY   ", FM_INFO_ISOTROPIC_SCALING_ONLY    },
  { "FM_INFO_ANISOTROPIC_SCALING_ONLY ", FM_INFO_ANISOTROPIC_SCALING_ONLY  },
  { "FM_INFO_TECH_CFF                 ", FM_INFO_TECH_CFF                  },
  { "FM_INFO_FAMILY_EQUIV             ", FM_INFO_FAMILY_EQUIV              },
  { "FM_INFO_DBCS_FIXED_PITCH         ", FM_INFO_DBCS_FIXED_PITCH          },
  { "FM_INFO_NONNEGATIVE_AC           ", FM_INFO_NONNEGATIVE_AC            },
  { "FM_INFO_IGNORE_TC_RA_ABLE        ", FM_INFO_IGNORE_TC_RA_ABLE         },
  { "FM_INFO_TECH_TYPE1               ", FM_INFO_TECH_TYPE1                },
  {                                   0, 0                                 }
};


FLAGDEF afdFM_SEL[] = {
  { "FM_SEL_ITALIC    ", FM_SEL_ITALIC    },
  { "FM_SEL_UNDERSCORE", FM_SEL_UNDERSCORE},
  { "FM_SEL_NEGATIVE  ", FM_SEL_NEGATIVE  },
  { "FM_SEL_OUTLINED  ", FM_SEL_OUTLINED  },
  { "FM_SEL_STRIKEOUT ", FM_SEL_STRIKEOUT },
  { "FM_SEL_BOLD      ", FM_SEL_BOLD      },
  { "FM_SEL_REGULAR   ", FM_SEL_REGULAR   },
  {                   0, 0                }
};


// STROBJ::flAccel

FLAGDEF afdSO[] = {
    { "SO_FLAG_DEFAULT_PLACEMENT", SO_FLAG_DEFAULT_PLACEMENT },
    { "SO_HORIZONTAL            ", SO_HORIZONTAL             },
    { "SO_VERTICAL              ", SO_VERTICAL               },
    { "SO_REVERSED              ", SO_REVERSED               },
    { "SO_ZERO_BEARINGS         ", SO_ZERO_BEARINGS          },
    { "SO_CHAR_INC_EQUAL_BM_BASE", SO_CHAR_INC_EQUAL_BM_BASE },
    { "SO_MAXEXT_EQUAL_BM_SIDE  ", SO_MAXEXT_EQUAL_BM_SIDE   },
    {                           0, 0                         }
};

// ESTROBJ::flTO

FLAGDEF afdTO[] = {
    { "TO_MEM_ALLOCATED ", TO_MEM_ALLOCATED  },
    { "TO_ALL_PTRS_VALID", TO_ALL_PTRS_VALID },
    { "TO_VALID         ", TO_VALID          },
    { "TO_ESC_NOT_ORIENT", TO_ESC_NOT_ORIENT },
    { "TO_PWSZ_ALLOCATED", TO_PWSZ_ALLOCATED },
    { "TO_HIGHRESTEXT   ", TO_HIGHRESTEXT    },
    { "TO_BITMAPS       ", TO_BITMAPS        },
    { "TO_PARTITION_INIT", TO_PARTITION_INIT },
    { "TO_ALLOC_FACENAME", TO_ALLOC_FACENAME },
    { "TO_SYS_PARTITION ", TO_SYS_PARTITION  },
    { "TSIM_UNDERLINE1  ", TSIM_UNDERLINE1   },
    { "TSIM_UNDERLINE2  ", TSIM_UNDERLINE2   },
    { "TSIM_STRIKEOUT   ", TSIM_STRIKEOUT    },
    {                   0, 0                 }
};

// DCLEVEL::flXform

FLAGDEF afdflx[] = {
  { "METAFILE_TO_WORLD_IDENTITY   ", METAFILE_TO_WORLD_IDENTITY    },
  { "WORLD_TO_PAGE_IDENTITY       ", WORLD_TO_PAGE_IDENTITY        },
  { "DEVICE_TO_PAGE_INVALID       ", DEVICE_TO_PAGE_INVALID        },
  { "DEVICE_TO_WORLD_INVALID      ", DEVICE_TO_WORLD_INVALID       },
  { "WORLD_TRANSFORM_SET          ", WORLD_TRANSFORM_SET           },
  { "POSITIVE_Y_IS_UP             ", POSITIVE_Y_IS_UP              },
  { "INVALIDATE_ATTRIBUTES        ", INVALIDATE_ATTRIBUTES         },
  { "PTOD_EFM11_NEGATIVE          ", PTOD_EFM11_NEGATIVE           },
  { "PTOD_EFM22_NEGATIVE          ", PTOD_EFM22_NEGATIVE           },
  { "ISO_OR_ANISO_MAP_MODE        ", ISO_OR_ANISO_MAP_MODE         },
  { "PAGE_TO_DEVICE_IDENTITY      ", PAGE_TO_DEVICE_IDENTITY       },
  { "PAGE_TO_DEVICE_SCALE_IDENTITY", PAGE_TO_DEVICE_SCALE_IDENTITY },
  { "PAGE_XLATE_CHANGED           ", PAGE_XLATE_CHANGED            },
  { "PAGE_EXTENTS_CHANGED         ", PAGE_EXTENTS_CHANGED          },
  { "WORLD_XFORM_CHANGED          ", WORLD_XFORM_CHANGED           },
  {                               0, 0                             }
};

// DCLEVEL::flFontState

FLAGDEF afdFS2[] = {
    { "DC_DIRTYFONT_XFORM", DC_DIRTYFONT_XFORM },
    { "DC_DIRTYFONT_LFONT", DC_DIRTYFONT_LFONT },
    { "DC_UFI_MAPPING    ", DC_UFI_MAPPING     },
    {                    0, 0                  }
};


// RFONT::flType

FLAGDEF afdRT[] = {
    { "RFONT_TYPE_NOCACHE", RFONT_TYPE_NOCACHE },
    { "RFONT_TYPE_UNICODE", RFONT_TYPE_UNICODE },
    { "RFONT_TYPE_HGLYPH ", RFONT_TYPE_HGLYPH  },
    {                    0, 0                  }
};

// FONTOBJ::flFontType

FLAGDEF afdFO[] = {
    { "FO_TYPE_RASTER  ", FO_TYPE_RASTER   },
    { "FO_TYPE_DEVICE  ", FO_TYPE_DEVICE   },
    { "FO_TYPE_TRUETYPE", FO_TYPE_TRUETYPE },
    { "FO_SIM_BOLD     ", FO_SIM_BOLD      },
    { "FO_SIM_ITALIC   ", FO_SIM_ITALIC    },
    { "FO_EM_HEIGHT    ", FO_EM_HEIGHT     },
    { "FO_GRAY16       ", FO_GRAY16        },
    { "FO_NOHINTS      ", FO_NOHINTS       },
    { "FO_NO_CHOICE    ", FO_NO_CHOICE     },
    {                  0, 0                }
};

// FD_GLYPHSET::flAccel

FLAGDEF afdGS[] = {
    { "GS_UNICODE_HANDLES", GS_UNICODE_HANDLES },
    { "GS_8BIT_HANDLES   ", GS_8BIT_HANDLES    },
    { "GS_16BIT_HANDLES  ", GS_16BIT_HANDLES   },
    {                    0, 0                  }
};

// IFIMETRICS::fsType

FLAGDEF afdFM_TYPE[] = {
    { "FM_TYPE_LICENSED ", FM_TYPE_LICENSED  },
    { "FM_READONLY_EMBED", FM_READONLY_EMBED },
    { "FM_EDITABLE_EMBED", FM_EDITABLE_EMBED },
    {                   0, 0                 }
};

FLAGDEF afdPFE[] = {
    { "PFE_DEVICEFONT ", PFE_DEVICEFONT },
    { "PFE_DEADSTATE  ", PFE_DEADSTATE  },
    { "PFE_REMOTEFONT ", PFE_REMOTEFONT },
    { "PFE_EUDC       ", PFE_EUDC       },
    { "PFE_SBCS_SYSTEM", PFE_SBCS_SYSTEM},
    { "PFE_UFIMATCH   ", PFE_UFIMATCH   },
    { "PFE_MEMORYFONT ", PFE_MEMORYFONT },
    { "PFE_DBCS_FONT  ", PFE_DBCS_FONT  },
    { "PFE_VERT_FACE  ", PFE_VERT_FACE  },
    {                0, 0              }
};

FLAGDEF afdBMF[] = {
    { "BMF_TOPDOWN            ", BMF_TOPDOWN            },
    { "BMF_NOZEROINIT         ", BMF_NOZEROINIT         },
    { "BMF_DONTCACHE          ", BMF_DONTCACHE          },
    { "BMF_USERMEM            ", BMF_USERMEM            },
    { "BMF_KMSECTION          ", BMF_KMSECTION          },
    { "BMF_NOTSYSMEM          ", BMF_NOTSYSMEM          },
    FLAG(BMF_WINDOW_BLT),
    FLAG(BMF_UMPDMEM),
    FLAG(BMF_ISREADONLY),
    FLAG(BMF_MAKEREADWRITE),
    {                         0, 0                      }
};

FLAGDEF afdDDSCAPS[] = {
    { "DDSCAPS_ALPHA              ", DDSCAPS_ALPHA              },
    { "DDSCAPS_BACKBUFFER         ", DDSCAPS_BACKBUFFER         },
    { "DDSCAPS_COMPLEX            ", DDSCAPS_COMPLEX            },
    { "DDSCAPS_FLIP               ", DDSCAPS_FLIP               },
    { "DDSCAPS_FRONTBUFFER        ", DDSCAPS_FRONTBUFFER        },
    { "DDSCAPS_OFFSCREENPLAIN     ", DDSCAPS_OFFSCREENPLAIN     },
    { "DDSCAPS_OVERLAY            ", DDSCAPS_OVERLAY            },
    { "DDSCAPS_PALETTE            ", DDSCAPS_PALETTE            },
    { "DDSCAPS_PRIMARYSURFACE     ", DDSCAPS_PRIMARYSURFACE     },
    { "DDSCAPS_PRIMARYSURFACELEFT ", DDSCAPS_PRIMARYSURFACELEFT },
    { "DDSCAPS_SYSTEMMEMORY       ", DDSCAPS_SYSTEMMEMORY       },
    { "DDSCAPS_TEXTURE            ", DDSCAPS_TEXTURE            },
    { "DDSCAPS_3DDEVICE           ", DDSCAPS_3DDEVICE           },
    { "DDSCAPS_VIDEOMEMORY        ", DDSCAPS_VIDEOMEMORY        },
    { "DDSCAPS_VISIBLE            ", DDSCAPS_VISIBLE            },
    { "DDSCAPS_WRITEONLY          ", DDSCAPS_WRITEONLY          },
    { "DDSCAPS_ZBUFFER            ", DDSCAPS_ZBUFFER            },
    { "DDSCAPS_OWNDC              ", DDSCAPS_OWNDC              },
    { "DDSCAPS_LIVEVIDEO          ", DDSCAPS_LIVEVIDEO          },
    { "DDSCAPS_HWCODEC            ", DDSCAPS_HWCODEC            },
    { "DDSCAPS_MODEX              ", DDSCAPS_MODEX              },
    { "DDSCAPS_MIPMAP             ", DDSCAPS_MIPMAP             },
    { "DDSCAPS_ALLOCONLOAD        ", DDSCAPS_ALLOCONLOAD        },
    { "DDSCAPS_VIDEOPORT          ", DDSCAPS_VIDEOPORT          },
    { "DDSCAPS_LOCALVIDMEM        ", DDSCAPS_LOCALVIDMEM        },
    { "DDSCAPS_NONLOCALVIDMEM     ", DDSCAPS_NONLOCALVIDMEM     },
    { "DDSCAPS_STANDARDVGAMODE    ", DDSCAPS_STANDARDVGAMODE    },
    { "DDSCAPS_OPTIMIZED          ", DDSCAPS_OPTIMIZED          },
    {                             0, 0                          }
};

FLAGDEF afdDDSCAPS2[] = {
    { "DDSCAPS2_HARDWAREDEINTERLACE ", DDSCAPS2_HARDWAREDEINTERLACE },
    { "DDSCAPS2_HINTDYNAMIC         ", DDSCAPS2_HINTDYNAMIC         },
    { "DDSCAPS2_HINTSTATIC          ", DDSCAPS2_HINTSTATIC          },
    { "DDSCAPS2_TEXTUREMANAGE       ", DDSCAPS2_TEXTUREMANAGE       },
    { "DDSCAPS2_RESERVED1           ", DDSCAPS2_RESERVED1           },
    { "DDSCAPS2_RESERVED2           ", DDSCAPS2_RESERVED2           },
    { "DDSCAPS2_OPAQUE              ", DDSCAPS2_OPAQUE              },
    { "DDSCAPS2_HINTANTIALIASING    ", DDSCAPS2_HINTANTIALIASING    },
    { "DDSCAPS2_CUBEMAP             ", DDSCAPS2_CUBEMAP             },
    { "DDSCAPS2_CUBEMAP_POSITIVEX   ", DDSCAPS2_CUBEMAP_POSITIVEX   },
    { "DDSCAPS2_CUBEMAP_NEGATIVEX   ", DDSCAPS2_CUBEMAP_NEGATIVEX   },
    { "DDSCAPS2_CUBEMAP_POSITIVEY   ", DDSCAPS2_CUBEMAP_POSITIVEY   },
    { "DDSCAPS2_CUBEMAP_NEGATIVEY   ", DDSCAPS2_CUBEMAP_NEGATIVEY   },
    { "DDSCAPS2_CUBEMAP_POSITIVEZ   ", DDSCAPS2_CUBEMAP_POSITIVEZ   },
    { "DDSCAPS2_CUBEMAP_NEGATIVEZ   ", DDSCAPS2_CUBEMAP_NEGATIVEZ   },
    { "DDSCAPS2_CUBEMAP_ALLFACES    ", DDSCAPS2_CUBEMAP_ALLFACES    },
    { "DDSCAPS2_MIPMAPSUBLEVEL      ", DDSCAPS2_MIPMAPSUBLEVEL      },
    {                              0, 0                             }
};

FLAGDEF afdDDRAWISURF[] = {
    FLAG(DDRAWISURF_HASCKEYSRCBLT),
    FLAG(DDRAWISURF_HASPIXELFORMAT),
    FLAG(DDRAWISURF_FRONTBUFFER),
    FLAG(DDRAWISURF_BACKBUFFER),
    END_FLAG
};

#if ENABLE_ALL_FLAGS
FLAGDEF afdDDSURFACEFL[] = {
    FLAG(DD_SURFACE_FLAG_PRIMARY),
    FLAG(DD_SURFACE_FLAG_CLIP),
    FLAG(DD_SURFACE_FLAG_DRIVER_CREATED),
    FLAG(DD_SURFACE_FLAG_CREATE_COMPLETE),
    FLAG(DD_SURFACE_FLAG_UMEM_ALLOCATED),
    FLAG(DD_SURFACE_FLAG_VMEM_ALLOCATED),
    END_FLAG
};
#endif  // ENABLE_ALL_FLAGS

FLAGDEF afdDDPIXELFORMAT[] = {
    FLAG(DDPF_ALPHAPIXELS),
    FLAG(DDPF_ALPHA),
    FLAG(DDPF_FOURCC),
    FLAG(DDPF_PALETTEINDEXED4),
    FLAG(DDPF_PALETTEINDEXEDTO8),
    FLAG(DDPF_PALETTEINDEXED8),
    FLAG(DDPF_RGB),
    FLAG(DDPF_COMPRESSED),
    FLAG(DDPF_RGBTOYUV),
    FLAG(DDPF_YUV),
    FLAG(DDPF_ZBUFFER),
    FLAG(DDPF_PALETTEINDEXED1),
    FLAG(DDPF_PALETTEINDEXED2),
    FLAG(DDPF_ZPIXELS),
    END_FLAG
};

FLAGDEF afdDVERIFIER[] = {
    FLAG(DRIVER_VERIFIER_SPECIAL_POOLING),
    FLAG(DRIVER_VERIFIER_FORCE_IRQL_CHECKING),
    FLAG(DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES),
    FLAG(DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS),
    FLAG(DRIVER_VERIFIER_IO_CHECKING),
    END_FLAG
};


char *pszGraphicsMode(LONG l)
{
    char *psz;
    switch (l) {
    case GM_COMPATIBLE: psz = "GM_COMPATIBLE"; break;
    case GM_ADVANCED  : psz = "GM_ADVANCED"  ; break;
    default           : psz = "GM_?"         ; break;
    }
    return( psz );
}

char *pszROP2(LONG l)
{
    char *psz;
    switch (l) {
    case  R2_BLACK      : psz = "R2_BLACK"      ; break;
    case  R2_NOTMERGEPEN: psz = "R2_NOTMERGEPEN"; break;
    case  R2_MASKNOTPEN : psz = "R2_MASKNOTPEN" ; break;
    case  R2_NOTCOPYPEN : psz = "R2_NOTCOPYPEN" ; break;
    case  R2_MASKPENNOT : psz = "R2_MASKPENNOT" ; break;
    case  R2_NOT        : psz = "R2_NOT"        ; break;
    case  R2_XORPEN     : psz = "R2_XORPEN"     ; break;
    case  R2_NOTMASKPEN : psz = "R2_NOTMASKPEN" ; break;
    case  R2_MASKPEN    : psz = "R2_MASKPEN"    ; break;
    case  R2_NOTXORPEN  : psz = "R2_NOTXORPEN"  ; break;
    case  R2_NOP        : psz = "R2_NOP"        ; break;
    case  R2_MERGENOTPEN: psz = "R2_MERGENOTPEN"; break;
    case  R2_COPYPEN    : psz = "R2_COPYPEN"    ; break;
    case  R2_MERGEPENNOT: psz = "R2_MERGEPENNOT"; break;
    case  R2_MERGEPEN   : psz = "R2_MERGEPEN"   ; break;
    case  R2_WHITE      : psz = "R2_WHITE"      ; break;
    default             : psz = "R2_?"          ; break;
    }
    return( psz );
}

char *pszDCTYPE(LONG l)
{
    char *psz;
    switch (l) {
    case DCTYPE_DIRECT: psz = "DCTYPE_DIRECT"; break;
    case DCTYPE_MEMORY: psz = "DCTYPE_MEMORY"; break;
    case DCTYPE_INFO  : psz = "DCTYPE_INFO"  ; break;
    default           : psz = "DCTYPE_?"     ; break;
    }
    return( psz );
}

char *pszTA_V(long l)
{
    char *psz;
    switch (l & ( TA_TOP | TA_BOTTOM | TA_BASELINE )) {
    case TA_TOP   : psz = "TA_TOP"     ; break;
    case TA_RIGHT : psz = "TA_BOTTOM"  ; break;
    case TA_CENTER: psz = "TA_BASELINE"; break;
    default       : psz = "TA_?"       ; break ;
    }
    return( psz );
}

char *pszTA_H(long l)
{
    char *psz;
    switch (l & ( TA_LEFT | TA_RIGHT | TA_CENTER )) {
    case TA_LEFT  : psz = "TA_LEFT"  ; break;
    case TA_RIGHT : psz = "TA_RIGHT" ; break;
    case TA_CENTER: psz = "TA_CENTER"; break;
    default       : psz = "TA_?"     ; break;
    }
    return( psz );
}

char *pszTA_U(long l)
{
    char *psz;
    switch (l & (TA_NOUPDATECP | TA_UPDATECP)) {
    case TA_NOUPDATECP: psz = "TA_NOUPDATECP"; break;
    case TA_UPDATECP  : psz = "TA_UPDATECP"  ; break;
    default           : psz = "TA_?"         ; break;
    }
    return( psz );
}

char *pszMapMode(long l)
{
    char *psz;
    switch (l) {
    case MM_TEXT       : psz = "MM_TEXT"       ; break;
    case MM_LOMETRIC   : psz = "MM_LOMETRIC"   ; break;
    case MM_HIMETRIC   : psz = "MM_HIMETRIC"   ; break;
    case MM_LOENGLISH  : psz = "MM_LOENGLISH"  ; break;
    case MM_HIENGLISH  : psz = "MM_HIENGLISH"  ; break;
    case MM_TWIPS      : psz = "MM_TWIPS"      ; break;
    case MM_ISOTROPIC  : psz = "MM_ISOTROPIC"  ; break;
    case MM_ANISOTROPIC: psz = "MM_ANISOTROPIC"; break;
    default            : psz = "MM_?"          ; break;
    }
    return( psz );
}

char *pszBkMode(long l)
{
    char *psz;
    switch (l) {
    case TRANSPARENT:   psz = "TRANSPARENT"; break;
    case OPAQUE     :   psz = "OPAQUE"     ; break;
    default         :   psz = "BKMODE_?"   ; break;
    }
    return( psz );
}

char *pszFW(long l)
{
    char *psz;
    switch ( l ) {
    case FW_DONTCARE  : psz = "FW_DONTCARE  "; break;
    case FW_THIN      : psz = "FW_THIN      "; break;
    case FW_EXTRALIGHT: psz = "FW_EXTRALIGHT"; break;
    case FW_LIGHT     : psz = "FW_LIGHT     "; break;
    case FW_NORMAL    : psz = "FW_NORMAL    "; break;
    case FW_MEDIUM    : psz = "FW_MEDIUM    "; break;
    case FW_SEMIBOLD  : psz = "FW_SEMIBOLD  "; break;
    case FW_BOLD      : psz = "FW_BOLD      "; break;
    case FW_EXTRABOLD : psz = "FW_EXTRABOLD "; break;
    case FW_HEAVY     : psz = "FW_HEAVY     "; break;
    default           : psz = "?FW"          ; break;
    }
    return( psz );
}

char *pszCHARSET(long l)
{
    char *psz;
    switch ( l ) {
    case ANSI_CHARSET        : psz = "ANSI_CHARSET       "; break;
    case DEFAULT_CHARSET     : psz = "DEFAULT_CHARSET    "; break;
    case SYMBOL_CHARSET      : psz = "SYMBOL_CHARSET     "; break;
    case SHIFTJIS_CHARSET    : psz = "SHIFTJIS_CHARSET   "; break;
    case HANGEUL_CHARSET     : psz = "HANGEUL_CHARSET    "; break;
    case GB2312_CHARSET      : psz = "GB2312_CHARSET     "; break;
    case CHINESEBIG5_CHARSET : psz = "CHINESEBIG5_CHARSET"; break;
    case OEM_CHARSET         : psz = "OEM_CHARSET        "; break;
    case JOHAB_CHARSET       : psz = "JOHAB_CHARSET      "; break;
    case HEBREW_CHARSET      : psz = "HEBREW_CHARSET     "; break;
    case ARABIC_CHARSET      : psz = "ARABIC_CHARSET     "; break;
    case GREEK_CHARSET       : psz = "GREEK_CHARSET      "; break;
    case TURKISH_CHARSET     : psz = "TURKISH_CHARSET    "; break;
    case THAI_CHARSET        : psz = "THAI_CHARSET       "; break;
    case EASTEUROPE_CHARSET  : psz = "EASTEUROPE_CHARSET "; break;
    case RUSSIAN_CHARSET     : psz = "RUSSIAN_CHARSET    "; break;
    case BALTIC_CHARSET      : psz = "BALTIC_CHARSET     "; break;
    default                  : psz = "?_CHARSET"          ; break;
    }
    return( psz );
}

char *pszOUT_PRECIS( long l )
{
    char *psz;
    switch ( l ) {
    case OUT_DEFAULT_PRECIS   : psz = "OUT_DEFAULT_PRECIS  "; break;
    case OUT_STRING_PRECIS    : psz = "OUT_STRING_PRECIS   "; break;
    case OUT_CHARACTER_PRECIS : psz = "OUT_CHARACTER_PRECIS"; break;
    case OUT_STROKE_PRECIS    : psz = "OUT_STROKE_PRECIS   "; break;
    case OUT_TT_PRECIS        : psz = "OUT_TT_PRECIS       "; break;
    case OUT_DEVICE_PRECIS    : psz = "OUT_DEVICE_PRECIS   "; break;
    case OUT_RASTER_PRECIS    : psz = "OUT_RASTER_PRECIS   "; break;
    case OUT_TT_ONLY_PRECIS   : psz = "OUT_TT_ONLY_PRECIS  "; break;
    case OUT_OUTLINE_PRECIS   : psz = "OUT_OUTLINE_PRECIS  "; break;
    default                   : psz = "OUT_?"               ; break;
    }
    return( psz );
}

char achFlags[100];

char *pszCLIP_PRECIS( long l )
{
    char *psz, *pch;

    switch ( l & CLIP_MASK) {
    case CLIP_DEFAULT_PRECIS   : psz = "CLIP_DEFAULT_PRECIS  "; break;
    case CLIP_CHARACTER_PRECIS : psz = "CLIP_CHARACTER_PRECIS"; break;
    case CLIP_STROKE_PRECIS    : psz = "CLIP_STROKE_PRECIS   "; break;
    default                    : psz = "CLIP_?"               ; break;
    }
    pch = achFlags;
    pch += sprintf(pch, "%s", psz);
    if ( l & CLIP_LH_ANGLES )
        pch += sprintf(pch, " | CLIP_LH_ANGLES");
    if ( l & CLIP_TT_ALWAYS )
        pch += sprintf(pch, " | CLIP_TT_ALWAYS");
    if ( l & CLIP_EMBEDDED )
        pch += sprintf(pch, " | CLIP_EMBEDDED");
    return( achFlags );
}

char *pszQUALITY( long l )
{
    char *psz;
    switch (l) {
    case DEFAULT_QUALITY        : psz = "DEFAULT_QUALITY       "; break;
    case DRAFT_QUALITY          : psz = "DRAFT_QUALITY         "; break;
    case PROOF_QUALITY          : psz = "PROOF_QUALITY         "; break;
    case NONANTIALIASED_QUALITY : psz = "NONANTIALIASED_QUALITY"; break;
    case ANTIALIASED_QUALITY    : psz = "ANTIALIASED_QUALITY   "; break;
    default                     : psz = "?_QUALITY"             ; break;
    }
    return( psz );
}

char *pszPitchAndFamily( long l )
{
    char *psz, *pch = achFlags;

    switch ( l & 0xf) {
    case DEFAULT_PITCH : psz = "DEFAULT_PITCH "; break;
    case FIXED_PITCH   : psz = "FIXED_PITCH   "; break;
    case VARIABLE_PITCH: psz = "VARIABLE_PITCH"; break;
    case MONO_FONT     : psz = "MONO_FONT     "; break;
    default            : psz = "PITCH_?"       ; break;
    }
    pch += sprintf(pch, "%s", psz);
    switch ( l & 0xf0) {
    case FF_DONTCARE   : psz = "FF_DONTCARE  "; break;
    case FF_ROMAN      : psz = "FF_ROMAN     "; break;
    case FF_SWISS      : psz = "FF_SWISS     "; break;
    case FF_MODERN     : psz = "FF_MODERN    "; break;
    case FF_SCRIPT     : psz = "FF_SCRIPT    "; break;
    case FF_DECORATIVE : psz = "FF_DECORATIVE"; break;
    default            : psz = "FF_?"         ; break;
    }
    pch += sprintf(pch, " | %s", psz);
    return( achFlags );
}

char *pszPanoseWeight( long l )
{
    char *psz;
    switch ( l ) {
    case PAN_ANY               : psz = "PAN_ANY              "; break;
    case PAN_NO_FIT            : psz = "PAN_NO_FIT           "; break;
    case PAN_WEIGHT_VERY_LIGHT : psz = "PAN_WEIGHT_VERY_LIGHT"; break;
    case PAN_WEIGHT_LIGHT      : psz = "PAN_WEIGHT_LIGHT     "; break;
    case PAN_WEIGHT_THIN       : psz = "PAN_WEIGHT_THIN      "; break;
    case PAN_WEIGHT_BOOK       : psz = "PAN_WEIGHT_BOOK      "; break;
    case PAN_WEIGHT_MEDIUM     : psz = "PAN_WEIGHT_MEDIUM    "; break;
    case PAN_WEIGHT_DEMI       : psz = "PAN_WEIGHT_DEMI      "; break;
    case PAN_WEIGHT_BOLD       : psz = "PAN_WEIGHT_BOLD      "; break;
    case PAN_WEIGHT_HEAVY      : psz = "PAN_WEIGHT_HEAVY     "; break;
    case PAN_WEIGHT_BLACK      : psz = "PAN_WEIGHT_BLACK     "; break;
    case PAN_WEIGHT_NORD       : psz = "PAN_WEIGHT_NORD      "; break;
    default:                     psz = "PAN_WEIGHT_?         "; break;
    }
    return(psz);
}

char *pszFONTHASHTYPE(FONTHASHTYPE fht)
{
    char *psz;

    switch (fht) {
    case FHT_FACE  : psz = "FHT_FACE"  ; break;
    case FHT_FAMILY: psz = "FHT_FAMILY"; break;
    case FHT_UFI   : psz = "FHT_UFI"   ; break;
    default        : psz = "FHT_?"     ; break;
    }
    return(psz);
}

char *pszDrvProcName(int index)
{
    char *pwsz;

    switch (index)
    {
    case INDEX_DrvEnablePDEV             : pwsz = "EnablePDEV             "; break;
    case INDEX_DrvCompletePDEV           : pwsz = "CompletePDEV           "; break;
    case INDEX_DrvDisablePDEV            : pwsz = "DisablePDEV            "; break;
    case INDEX_DrvEnableSurface          : pwsz = "EnableSurface          "; break;
    case INDEX_DrvDisableSurface         : pwsz = "DisableSurface         "; break;
    case INDEX_DrvAssertMode             : pwsz = "AssertMode             "; break;
    case INDEX_DrvOffset                 : pwsz = "Offset                 "; break;
    case INDEX_DrvResetPDEV              : pwsz = "ResetPDEV              "; break;
    case INDEX_DrvDisableDriver          : pwsz = "DisableDriver          "; break;
    case INDEX_DrvCreateDeviceBitmap     : pwsz = "CreateDeviceBitmap     "; break;
    case INDEX_DrvDeleteDeviceBitmap     : pwsz = "DeleteDeviceBitmap     "; break;
    case INDEX_DrvRealizeBrush           : pwsz = "RealizeBrush           "; break;
    case INDEX_DrvDitherColor            : pwsz = "DitherColor            "; break;
    case INDEX_DrvStrokePath             : pwsz = "StrokePath             "; break;
    case INDEX_DrvFillPath               : pwsz = "FillPath               "; break;
    case INDEX_DrvStrokeAndFillPath      : pwsz = "StrokeAndFillPath      "; break;
    case INDEX_DrvPaint                  : pwsz = "Paint                  "; break;
    case INDEX_DrvBitBlt                 : pwsz = "BitBlt                 "; break;
    case INDEX_DrvCopyBits               : pwsz = "CopyBits               "; break;
    case INDEX_DrvStretchBlt             : pwsz = "StretchBlt             "; break;
    case INDEX_DrvSetPalette             : pwsz = "SetPalette             "; break;
    case INDEX_DrvTextOut                : pwsz = "TextOut                "; break;
    case INDEX_DrvEscape                 : pwsz = "Escape                 "; break;
    case INDEX_DrvDrawEscape             : pwsz = "DrawEscape             "; break;
    case INDEX_DrvQueryFont              : pwsz = "QueryFont              "; break;
    case INDEX_DrvQueryFontTree          : pwsz = "QueryFontTree          "; break;
    case INDEX_DrvQueryFontData          : pwsz = "QueryFontData          "; break;
    case INDEX_DrvSetPointerShape        : pwsz = "SetPointerShape        "; break;
    case INDEX_DrvMovePointer            : pwsz = "MovePointer            "; break;
    case INDEX_DrvLineTo                 : pwsz = "LineTo                 "; break;
    case INDEX_DrvSendPage               : pwsz = "SendPage               "; break;
    case INDEX_DrvStartPage              : pwsz = "StartPage              "; break;
    case INDEX_DrvEndDoc                 : pwsz = "EndDoc                 "; break;
    case INDEX_DrvStartDoc               : pwsz = "StartDoc               "; break;
    case INDEX_DrvGetGlyphMode           : pwsz = "GetGlyphMode           "; break;
    case INDEX_DrvSynchronize            : pwsz = "Synchronize            "; break;
    case INDEX_DrvSaveScreenBits         : pwsz = "SaveScreenBits         "; break;
    case INDEX_DrvGetModes               : pwsz = "GetModes               "; break;
    case INDEX_DrvFree                   : pwsz = "Free                   "; break;
    case INDEX_DrvDestroyFont            : pwsz = "DestroyFont            "; break;
    case INDEX_DrvQueryFontCaps          : pwsz = "QueryFontCaps          "; break;
    case INDEX_DrvLoadFontFile           : pwsz = "LoadFontFile           "; break;
    case INDEX_DrvUnloadFontFile         : pwsz = "UnloadFontFile         "; break;
    case INDEX_DrvFontManagement         : pwsz = "FontManagement         "; break;
    case INDEX_DrvQueryTrueTypeTable     : pwsz = "QueryTrueTypeTable     "; break;
    case INDEX_DrvQueryTrueTypeOutline   : pwsz = "QueryTrueTypeOutline   "; break;
    case INDEX_DrvGetTrueTypeFile        : pwsz = "GetTrueTypeFile        "; break;
    case INDEX_DrvQueryFontFile          : pwsz = "QueryFontFile          "; break;
    case INDEX_DrvMovePanning            : pwsz = "MovePanning            "; break;
    case INDEX_DrvQueryAdvanceWidths     : pwsz = "QueryAdvanceWidths     "; break;
    case INDEX_DrvSetPixelFormat         : pwsz = "SetPixelFormat         "; break;
    case INDEX_DrvDescribePixelFormat    : pwsz = "DescribePixelFormat    "; break;
    case INDEX_DrvSwapBuffers            : pwsz = "SwapBuffers            "; break;
    case INDEX_DrvStartBanding           : pwsz = "StartBanding           "; break;
    case INDEX_DrvNextBand               : pwsz = "NextBand               "; break;
    case INDEX_DrvGetDirectDrawInfo      : pwsz = "GetDirectDrawInfo      "; break;
    case INDEX_DrvEnableDirectDraw       : pwsz = "EnableDirectDraw       "; break;
    case INDEX_DrvDisableDirectDraw      : pwsz = "DisableDirectDraw      "; break;
    case INDEX_DrvQuerySpoolType         : pwsz = "QuerySpoolType         "; break;
    case INDEX_DrvIcmCreateColorTransform: pwsz = "IcmCreateColorTransform"; break;
    case INDEX_DrvIcmDeleteColorTransform: pwsz = "IcmDeleteColorTransform"; break;
    case INDEX_DrvIcmCheckBitmapBits     : pwsz = "IcmCheckBitmapBits     "; break;
    case INDEX_DrvIcmSetDeviceGammaRamp  : pwsz = "IcmSetDeviceGammaRamp  "; break;
    case INDEX_DrvGradientFill           : pwsz = "GradientFill           "; break;
    case INDEX_DrvStretchBltROP          : pwsz = "StretchBltROP          "; break;
    case INDEX_DrvPlgBlt                 : pwsz = "PlgBlt                 "; break;
    case INDEX_DrvAlphaBlend             : pwsz = "AlphaBlend             "; break;
    case INDEX_DrvSynthesizeFont         : pwsz = "SynthesizeFont         "; break;
    case INDEX_DrvGetSynthesizedFontFiles: pwsz = "GetSynthesizedFontFiles"; break;
    case INDEX_DrvTransparentBlt         : pwsz = "TransparentBlt         "; break;
    case INDEX_DrvQueryPerBandInfo       : pwsz = "QueryPerBandInfo       "; break;
    default                              : pwsz = "???                    "; break;
    }
    return(pwsz);
}


char *pszHRESULT(HRESULT hr)
{
    char *psz;

    switch (hr)
    {
    case 0: psz = "OK"; break;
    CASEENUM(S_FALSE);
    CASEENUM(E_NOTIMPL);
    CASEENUM(E_OUTOFMEMORY);
    CASEENUM(E_INVALIDARG);
    CASEENUM(E_NOINTERFACE);
    CASEENUM(E_ABORT);
    CASEENUM(E_FAIL);
    default:
        switch (hr & 0xCFFFFFFF)
        {
        CASEENUM(STATUS_UNSUCCESSFUL);
        default:
            psz = achFlags;
            sprintf(psz, "unknown HRESULT 0x%08lx", hr);
            break;
        }
        break;
    }
    return(psz);
}


char *pszWinDbgError(ULONG ulError)
{
    char *psz;

    switch (ulError)
    {
    case 0: psz = "no error"; break;
    CASEENUM(MEMORY_READ_ERROR);
    CASEENUM(SYMBOL_TYPE_INDEX_NOT_FOUND);
    CASEENUM(SYMBOL_TYPE_INFO_NOT_FOUND);
    CASEENUM(FIELDS_DID_NOT_MATCH);
    CASEENUM(NULL_SYM_DUMP_PARAM);
    CASEENUM(NULL_FIELD_NAME);
    CASEENUM(INCORRECT_VERSION_INFO);
    CASEENUM(EXIT_ON_CONTROLC);
    CASEENUM(CANNOT_ALLOCATE_MEMORY);
    default:
        psz = achFlags;
        sprintf(psz, "unknown WinDbg error 0x08%x", ulError);
        break;
    }
    return(psz);
}


/******************************Public*Routine******************************\
*   print standard flags
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    6-Mar-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

ULONG64
flPrintFlags(
    FLAGDEF *pFlagDef,
    ULONG64 fl
    )
{
    ULONG64 FlagsFound = 0;

    while (pFlagDef->psz != NULL)
    {
        if (pFlagDef->fl & fl)
        {
            if (FlagsFound) dprintf("\n");
            dprintf("       %s",pFlagDef->psz);
            if (FlagsFound & pFlagDef->fl)
            {
                dprintf(" (SHARED FLAG)");
            }
            FlagsFound |= pFlagDef->fl;
        }

        pFlagDef++;
    }

    return fl & ~FlagsFound;
}

BOOL
bPrintEnum(
    ENUMDEF *pEnumDef,
    ULONG64 ul
    )
{
    while (pEnumDef->psz != NULL)
    {
        if (pEnumDef->ul == ul)
        {
            dprintf(pEnumDef->psz);
            return (TRUE);
        }

        pEnumDef++;
    }

    return (FALSE);
}


// BASEOBJECT.BaseFlags
FLAGDEF afdBASEOBJECT_BaseFlags[] = {
    FLAG(HMGR_LOOKASIDE_ALLOC_FLAG),
    END_FLAG
};


// _BLENDFUNCTION.BlendOp
ENUMDEF aed_BLENDFUNCTION_BlendOp[] = {
    ENUM(AC_SRC_OVER),
    END_ENUM
};

// _BLENDFUNCTION.BlendFlags
FLAGDEF afd_BLENDFUNCTION_BlendFlags[] = {
    FLAG(AC_USE_HIGHQUALITYFILTER),
    FLAG(AC_MIRRORBITMAP),
    END_FLAG
};

// _BLENDFUNCTION.AlphaFormat
FLAGDEF afd_BLENDFUNCTION_AlphaFormat[] = {
    FLAG(AC_SRC_ALPHA),
    END_FLAG
};


// BRUSH._flAttrs
// EBRUSHOBJ.flAttrs
FLAGDEF afdBRUSH__flAttrs[] = {
    FLAG(BR_NEED_FG_CLR),
    FLAG(BR_NEED_BK_CLR),
    FLAG(BR_DITHER_OK),
    FLAG(BR_IS_SOLID),
    FLAG(BR_IS_HATCH),
    FLAG(BR_IS_BITMAP),
    FLAG(BR_IS_DIB),
    FLAG(BR_IS_NULL),
    FLAG(BR_IS_GLOBAL),
    FLAG(BR_IS_PEN),
    FLAG(BR_IS_OLDSTYLEPEN),
    FLAG(BR_IS_DIBPALCOLORS),
    FLAG(BR_IS_DIBPALINDICES),
    FLAG(BR_IS_DEFAULTSTYLE),
    FLAG(BR_IS_MASKING),
    FLAG(BR_IS_INSIDEFRAME),
    FLAG(BR_IS_MONOCHROME),
    FLAG(BR_CACHED_ENGINE),
    FLAG(BR_CACHED_IS_SOLID),
    END_FLAG
};

// BRUSH._ulStyle
ENUMDEF aedBRUSH__ulStyle[] = {
    ENUM(HS_HORIZONTAL),
    ENUM(HS_VERTICAL),
    ENUM(HS_FDIAGONAL),
    ENUM(HS_BDIAGONAL),
    ENUM(HS_CROSS),
    ENUM(HS_DIAGCROSS),
    ENUM(HS_SOLIDCLR),
    ENUM(HS_DITHEREDCLR),
    ENUM(HS_SOLIDTEXTCLR),
    ENUM(HS_DITHEREDTEXTCLR),
    ENUM(HS_SOLIDBKCLR),
    ENUM(HS_DITHEREDBKCLR),
    ENUM(HS_API_MAX),
    ENUM(HS_NULL),
    ENUM(HS_PAT),
    ENUM(HS_MSK),
    ENUM(HS_PATMSK),
    ENUM(HS_STYLE_MAX),
    END_ENUM
};


// BRUSHOBJ.flColorType
FLAGDEF afdBRUSHOBJ_flColorType[] = {
    FLAG(BR_DEVICE_ICM),
    FLAG(BR_HOST_ICM),
    FLAG(BR_CMYKCOLOR),
    FLAG(BR_ORIGCOLOR),
    END_FLAG
};


// CLIPOBJ.iDComplexity
ENUMDEF aedCLIPOBJ_iDComplexity[] = {
    ENUM(DC_TRIVIAL),
    ENUM(DC_RECT),
    ENUM(DC_COMPLEX),
    END_ENUM
};

// CLIPOBJ.iFComplexity
ENUMDEF aedCLIPOBJ_iFComplexity[] = {
    ENUM(FC_RECT),
    ENUM(FC_RECT4),
    ENUM(FC_COMPLEX),
    END_ENUM
};

// CLIPOBJ.iMode
ENUMDEF aedCLIPOBJ_iMode[] = {
    ENUM(TC_RECTANGLES),
    ENUM(TC_PATHOBJ),
    END_ENUM
};

// CLIPOBJ.fjOptions
FLAGDEF afdCLIPOBJ_fjOptions[] = {
    FLAG(OC_BANK_CLIP),
    END_FLAG
};


// DC.fs_
FLAGDEF afdDC_fs_[] = {
    FLAG(DC_DISPLAY),
    FLAG(DC_DIRECT),
    FLAG(DC_CANCELED),
    FLAG(DC_PERMANANT),
    FLAG(DC_DIRTY_RAO),
    FLAG(DC_ACCUM_WMGR),
    FLAG(DC_ACCUM_APP),
    FLAG(DC_RESET),
    FLAG(DC_SYNCHRONIZEACCESS),
    FLAG(DC_EPSPRINTINGESCAPE),
    FLAG(DC_TEMPINFODC),
    FLAG(DC_FULLSCREEN),
    FLAG(DC_IN_CLONEPDEV),
    FLAG(DC_REDIRECTION),
    FLAG(DC_SHAREACCESS),
    FLAG(DC_STOCKBITMAP),
    END_FLAG
};

// DC.flGraphicsCaps_
// DEVINFO.flGraphicsCaps
FLAGDEF afdDC_flGraphicsCaps_[] = {
    FLAG(GCAPS_BEZIERS),
    FLAG(GCAPS_GEOMETRICWIDE),
    FLAG(GCAPS_ALTERNATEFILL),
    FLAG(GCAPS_WINDINGFILL),
    FLAG(GCAPS_HALFTONE),
    FLAG(GCAPS_COLOR_DITHER),
    {"GCAPS_HORIZSTRIKE (obsolete)", GCAPS_HORIZSTRIKE },
    {"GCAPS_VERTSTRIKE (obsolete)", GCAPS_VERTSTRIKE },
    FLAG(GCAPS_OPAQUERECT),
    FLAG(GCAPS_VECTORFONT),
    FLAG(GCAPS_MONO_DITHER),
    {"GCAPS_ASYNCCHANGE (obsolete)", GCAPS_ASYNCCHANGE },
    FLAG(GCAPS_ASYNCMOVE),
    FLAG(GCAPS_DONTJOURNAL),
    {"GCAPS_DIRECTDRAW (obsolete)", GCAPS_DIRECTDRAW },
    FLAG(GCAPS_ARBRUSHOPAQUE),
    FLAG(GCAPS_PANNING),
    FLAG(GCAPS_HIGHRESTEXT),
    FLAG(GCAPS_PALMANAGED),
    FLAG(GCAPS_DITHERONREALIZE),
    {"GCAPS_NO64BITMEMACCESS (obsolete)", GCAPS_NO64BITMEMACCESS },
    FLAG(GCAPS_FORCEDITHER),
    FLAG(GCAPS_GRAY16),
    FLAG(GCAPS_ICM),
    FLAG(GCAPS_CMYKCOLOR),
    FLAG(GCAPS_LAYERED),
    FLAG(GCAPS_ARBRUSHTEXT),
    FLAG(GCAPS_SCREENPRECISION),
    FLAG(GCAPS_FONT_RASTERIZER),
    FLAG(GCAPS_NUP),
    END_FLAG
};

// DC.flGraphicsCaps2_
// DEVINFO.flGraphicsCaps2
FLAGDEF afdDC_flGraphicsCaps2_[] = {
    FLAG(GCAPS2_JPEGSRC),
    FLAG(GCAPS2_xxxx),
    FLAG(GCAPS2_PNGSRC),
    FLAG(GCAPS2_CHANGEGAMMARAMP),
    FLAG(GCAPS2_ALPHACURSOR),
    FLAG(GCAPS2_SYNCFLUSH),
    FLAG(GCAPS2_SYNCTIMER),
    FLAG(GCAPS2_ICD_MULTIMON),
    FLAG(GCAPS2_MOUSETRAILS),
    END_FLAG
};


// DEVMODEx.dmFields
FLAGDEF afdDEVMODE_dmFields[] = {
    FLAG(DM_ORIENTATION),
    FLAG(DM_PAPERSIZE),
    FLAG(DM_PAPERLENGTH),
    FLAG(DM_PAPERWIDTH),
    FLAG(DM_SCALE),
    FLAG(DM_POSITION),
    FLAG(DM_NUP),
    FLAG(DM_DISPLAYORIENTATION),
    FLAG(DM_COPIES),
    FLAG(DM_DEFAULTSOURCE),
    FLAG(DM_PRINTQUALITY),
    FLAG(DM_COLOR),
    FLAG(DM_DUPLEX),
    FLAG(DM_YRESOLUTION),
    FLAG(DM_TTOPTION),
    FLAG(DM_COLLATE),
    FLAG(DM_FORMNAME),
    FLAG(DM_LOGPIXELS),
    FLAG(DM_BITSPERPEL),
    FLAG(DM_PELSWIDTH),
    FLAG(DM_PELSHEIGHT),
    FLAG(DM_DISPLAYFLAGS),
    FLAG(DM_DISPLAYFREQUENCY),
    FLAG(DM_ICMMETHOD),
    FLAG(DM_ICMINTENT),
    FLAG(DM_MEDIATYPE),
    FLAG(DM_DITHERTYPE),
    FLAG(DM_PANNINGWIDTH),
    FLAG(DM_PANNINGHEIGHT),
    FLAG(DM_DISPLAYFIXEDOUTPUT),

    END_FLAG
};

// DEVMODEx.dmPaperSize
ENUMDEF aedDEVMODE_dmPaperSize[] = {
    { "Unspecified", 0},
    ENUM(DMPAPER_LETTER),
    ENUM(DMPAPER_LETTERSMALL),
    ENUM(DMPAPER_TABLOID),
    ENUM(DMPAPER_LEDGER),
    ENUM(DMPAPER_LEGAL),
    ENUM(DMPAPER_STATEMENT),
    ENUM(DMPAPER_EXECUTIVE),
    ENUM(DMPAPER_A3),
    ENUM(DMPAPER_A4),
    ENUM(DMPAPER_A4SMALL),
    ENUM(DMPAPER_A5),
    ENUM(DMPAPER_B4),
    ENUM(DMPAPER_B5),
    ENUM(DMPAPER_FOLIO),
    ENUM(DMPAPER_QUARTO),
    ENUM(DMPAPER_10X14),
    ENUM(DMPAPER_11X17),
    ENUM(DMPAPER_NOTE),
    ENUM(DMPAPER_ENV_9),
    ENUM(DMPAPER_ENV_10),
    ENUM(DMPAPER_ENV_11),
    ENUM(DMPAPER_ENV_12),
    ENUM(DMPAPER_ENV_14),
    ENUM(DMPAPER_CSHEET),
    ENUM(DMPAPER_DSHEET),
    ENUM(DMPAPER_ESHEET),
    ENUM(DMPAPER_ENV_DL),
    ENUM(DMPAPER_ENV_C5),
    ENUM(DMPAPER_ENV_C3),
    ENUM(DMPAPER_ENV_C4),
    ENUM(DMPAPER_ENV_C6),
    ENUM(DMPAPER_ENV_C65),
    ENUM(DMPAPER_ENV_B4),
    ENUM(DMPAPER_ENV_B5),
    ENUM(DMPAPER_ENV_B6),
    ENUM(DMPAPER_ENV_ITALY),
    ENUM(DMPAPER_ENV_MONARCH),
    ENUM(DMPAPER_ENV_PERSONAL),
    ENUM(DMPAPER_FANFOLD_US),
    ENUM(DMPAPER_FANFOLD_STD_GERMAN),
    ENUM(DMPAPER_FANFOLD_LGL_GERMAN),
    ENUM(DMPAPER_ISO_B4),
    ENUM(DMPAPER_JAPANESE_POSTCARD),
    ENUM(DMPAPER_9X11),
    ENUM(DMPAPER_10X11),
    ENUM(DMPAPER_15X11),
    ENUM(DMPAPER_ENV_INVITE),
    ENUM(DMPAPER_RESERVED_48),
    ENUM(DMPAPER_RESERVED_49),
    ENUM(DMPAPER_LETTER_EXTRA),
    ENUM(DMPAPER_LEGAL_EXTRA),
    ENUM(DMPAPER_TABLOID_EXTRA),
    ENUM(DMPAPER_A4_EXTRA),
    ENUM(DMPAPER_LETTER_TRANSVERSE),
    ENUM(DMPAPER_A4_TRANSVERSE),
    ENUM(DMPAPER_LETTER_EXTRA_TRANSVERSE),
    ENUM(DMPAPER_A_PLUS),
    ENUM(DMPAPER_B_PLUS),
    ENUM(DMPAPER_LETTER_PLUS),
    ENUM(DMPAPER_A4_PLUS),
    ENUM(DMPAPER_A5_TRANSVERSE),
    ENUM(DMPAPER_B5_TRANSVERSE),
    ENUM(DMPAPER_A3_EXTRA),
    ENUM(DMPAPER_A5_EXTRA),
    ENUM(DMPAPER_B5_EXTRA),
    ENUM(DMPAPER_A2),
    ENUM(DMPAPER_A3_TRANSVERSE),
    ENUM(DMPAPER_A3_EXTRA_TRANSVERSE),
    ENUM(DMPAPER_DBL_JAPANESE_POSTCARD),
    ENUM(DMPAPER_A6),
    ENUM(DMPAPER_JENV_KAKU2),
    ENUM(DMPAPER_JENV_KAKU3),
    ENUM(DMPAPER_JENV_CHOU3),
    ENUM(DMPAPER_JENV_CHOU4),
    ENUM(DMPAPER_LETTER_ROTATED),
    ENUM(DMPAPER_A3_ROTATED),
    ENUM(DMPAPER_A4_ROTATED),
    ENUM(DMPAPER_A5_ROTATED),
    ENUM(DMPAPER_B4_JIS_ROTATED),
    ENUM(DMPAPER_B5_JIS_ROTATED),
    ENUM(DMPAPER_JAPANESE_POSTCARD_ROTATED),
    ENUM(DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED),
    ENUM(DMPAPER_A6_ROTATED),
    ENUM(DMPAPER_JENV_KAKU2_ROTATED),
    ENUM(DMPAPER_JENV_KAKU3_ROTATED),
    ENUM(DMPAPER_JENV_CHOU3_ROTATED),
    ENUM(DMPAPER_JENV_CHOU4_ROTATED),
    ENUM(DMPAPER_B6_JIS),
    ENUM(DMPAPER_B6_JIS_ROTATED),
    ENUM(DMPAPER_12X11),
    ENUM(DMPAPER_JENV_YOU4),
    ENUM(DMPAPER_JENV_YOU4_ROTATED),
    ENUM(DMPAPER_P16K),
    ENUM(DMPAPER_P32K),
    ENUM(DMPAPER_P32KBIG),
    ENUM(DMPAPER_PENV_1),
    ENUM(DMPAPER_PENV_2),
    ENUM(DMPAPER_PENV_3),
    ENUM(DMPAPER_PENV_4),
    ENUM(DMPAPER_PENV_5),
    ENUM(DMPAPER_PENV_6),
    ENUM(DMPAPER_PENV_7),
    ENUM(DMPAPER_PENV_8),
    ENUM(DMPAPER_PENV_9),
    ENUM(DMPAPER_PENV_10),
    ENUM(DMPAPER_P16K_ROTATED),
    ENUM(DMPAPER_P32K_ROTATED),
    ENUM(DMPAPER_P32KBIG_ROTATED),
    ENUM(DMPAPER_PENV_1_ROTATED),
    ENUM(DMPAPER_PENV_2_ROTATED),
    ENUM(DMPAPER_PENV_3_ROTATED),
    ENUM(DMPAPER_PENV_4_ROTATED),
    ENUM(DMPAPER_PENV_5_ROTATED),
    ENUM(DMPAPER_PENV_6_ROTATED),
    ENUM(DMPAPER_PENV_7_ROTATED),
    ENUM(DMPAPER_PENV_8_ROTATED),
    ENUM(DMPAPER_PENV_9_ROTATED),
    ENUM(DMPAPER_PENV_10_ROTATED),

    ENUM(DMPAPER_USER),

    END_ENUM
};

// DEVMODEx.dmDisplayOrientation
ENUMDEF aedDEVMODE_dmDisplayOrientation[] = {
    ENUM(DMDO_DEFAULT),
    ENUM(DMDO_90),
    ENUM(DMDO_180),
    ENUM(DMDO_270),

    END_ENUM
};

// DEVMODEx.dmDisplayFixedOutput
ENUMDEF aedDEVMODE_dmDisplayFixedOutput[] = {
    ENUM(DMDFO_DEFAULT),
    ENUM(DMDFO_STRETCH),
    ENUM(DMDFO_CENTER),

    END_ENUM
};

// DEVMODEx.dmDisplayFlags
FLAGDEF afdDEVMODE_dmDisplayFlags[] = {
    { "DM_GRAYSCALE (obsolete)", 0x00000001 },
    { "DM_INTERLACED (obsolete)", 0x00000002 },
    FLAG(DMDISPLAYFLAGS_TEXTMODE),

    END_FLAG
};

// DEVMODEx.dmICMMethod
ENUMDEF aedDEVMODE_dmICMMethod[] = {
    { "Unspecified", 0},
    ENUM(DMICMMETHOD_NONE),
    ENUM(DMICMMETHOD_SYSTEM),
    ENUM(DMICMMETHOD_DRIVER),
    ENUM(DMICMMETHOD_DEVICE),

    ENUM(DMICMMETHOD_USER),

    END_ENUM
};

// DEVMODEx.dmICMIntent
ENUMDEF aedDEVMODE_dmICMIntent[] = {
    { "Unspecified", 0},
    ENUM(DMICM_SATURATE),
    ENUM(DMICM_CONTRAST),
    ENUM(DMICM_COLORIMETRIC),
    ENUM(DMICM_ABS_COLORIMETRIC),

    ENUM(DMICM_USER),

    END_ENUM
};

// DEVMODEx.dmMediaType
ENUMDEF aedDEVMODE_dmMediaType[] = {
    { "Unspecified", 0},
    ENUM(DMMEDIA_STANDARD),
    ENUM(DMMEDIA_TRANSPARENCY),
    ENUM(DMMEDIA_GLOSSY),

    ENUM(DMMEDIA_USER),

    END_ENUM
};

// DEVMOCEx.dmDitherType
ENUMDEF aedDEVMODE_dmDitherType[] = {
    { "Unspecified", 0},
    ENUM(DMDITHER_NONE),
    ENUM(DMDITHER_COARSE),
    ENUM(DMDITHER_FINE),
    ENUM(DMDITHER_LINEART),
    ENUM(DMDITHER_ERRORDIFFUSION),
    ENUM(DMDITHER_RESERVED6),
    ENUM(DMDITHER_RESERVED7),
    ENUM(DMDITHER_RESERVED8),
    ENUM(DMDITHER_RESERVED9),
    ENUM(DMDITHER_GRAYSCALE),

    ENUM(DMDITHER_USER),

    END_ENUM
};


// GDIINFO.flRaster
FLAGDEF afdGDIINFO_flRaster[] = {
    FLAG(RC_NONE),
    FLAG(RC_BITBLT),
    FLAG(RC_BANDING),
    FLAG(RC_SCALING),
    FLAG(RC_BITMAP64),
    FLAG(RC_GDI20_OUTPUT),
    FLAG(RC_GDI20_STATE),
    FLAG(RC_SAVEBITMAP),
    FLAG(RC_DI_BITMAP),
    FLAG(RC_PALETTE),
    FLAG(RC_DIBTODEV),
    FLAG(RC_BIGFONT),
    FLAG(RC_STRETCHBLT),
    FLAG(RC_FLOODFILL),
    FLAG(RC_STRETCHDIB),
    FLAG(RC_OP_DX_OUTPUT),
    FLAG(RC_DEVBITS),
    END_FLAG
};


// GRAPHICS_DEVICE.stateFlags
FLAGDEF afdGRAPHICS_DEVICE_stateFlags[] = {
    FLAG(DISPLAY_DEVICE_ATTACHED_TO_DESKTOP),
    FLAG(DISPLAY_DEVICE_MULTI_DRIVER),
    FLAG(DISPLAY_DEVICE_PRIMARY_DEVICE),
    FLAG(DISPLAY_DEVICE_MIRRORING_DRIVER),
    FLAG(DISPLAY_DEVICE_VGA_COMPATIBLE),
    FLAG(DISPLAY_DEVICE_REMOVABLE),
    FLAG(DISPLAY_DEVICE_MODESPRUNED),
    FLAG(DISPLAY_DEVICE_POWERED_OFF),
    FLAG(DISPLAY_DEVICE_ACPI),
    FLAG(DISPLAY_DEVICE_DUALVIEW),
    FLAG(DISPLAY_DEVICE_REMOTE),
    FLAG(DISPLAY_DEVICE_DISCONNECT),
    END_FLAG
};


// ENTRY FullType (Shifted Portion of ENTRY.FullUnique)
ENUMDEF aedENTRY_FullType[] = {
    ENUM(LO_BRUSH_TYPE),
    ENUM(LO_DC_TYPE),
    ENUM(LO_BITMAP_TYPE),
    ENUM(LO_PALETTE_TYPE),
    ENUM(LO_FONT_TYPE),
    ENUM(LO_REGION_TYPE),
    ENUM(LO_ICMLCS_TYPE),
    ENUM(LO_CLIENTOBJ_TYPE),

    ENUM(LO_ALTDC_TYPE),
    ENUM(LO_PEN_TYPE),
    ENUM(LO_EXTPEN_TYPE),
    ENUM(LO_DIBSECTION_TYPE),
    ENUM(LO_METAFILE16_TYPE),
    ENUM(LO_METAFILE_TYPE),
    ENUM(LO_METADC16_TYPE),

    END_ENUM
};

// ENTRY.Objt
ENUMDEF aedENTRY_Objt[] = {
    ENUM(DEF_TYPE),
    ENUM(DC_TYPE),
    ENUM(UNUSED1_TYPE),
    ENUM(UNUSED2_TYPE),
    ENUM(RGN_TYPE),
    ENUM(SURF_TYPE),
    ENUM(CLIENTOBJ_TYPE),
    ENUM(PATH_TYPE),
    ENUM(PAL_TYPE),
    ENUM(ICMLCS_TYPE),
    ENUM(LFONT_TYPE),
    ENUM(RFONT_TYPE),
    ENUM(PFE_TYPE),
    ENUM(PFT_TYPE),
    ENUM(ICMCXF_TYPE),
    ENUM(SPRITE_TYPE),
    ENUM(BRUSH_TYPE),
    ENUM(UMPD_TYPE),
    ENUM(UNUSED4_TYPE),
    ENUM(SPACE_TYPE),
    ENUM(UNUSED5_TYPE),
    ENUM(META_TYPE),
    ENUM(EFSTATE_TYPE),
    ENUM(BMFD_TYPE),
    ENUM(VTFD_TYPE),
    ENUM(TTFD_TYPE),
    ENUM(RC_TYPE),
    ENUM(TEMP_TYPE),
    ENUM(DRVOBJ_TYPE),
    ENUM(DCIOBJ_TYPE),
    ENUM(SPOOL_TYPE),
    END_ENUM
};

// ENTRY.Flags
FLAGDEF afdENTRY_Flags[] = {
    FLAG(HMGR_ENTRY_UNDELETABLE),
    FLAG(HMGR_ENTRY_LAZY_DEL),
    FLAG(HMGR_ENTRY_INVALID_VIS),
    FLAG(HMGR_ENTRY_LOOKASIDE_ALLOC),
    END_FLAG
};


// LINEATTRS.fl
FLAGDEF afdLINEATTRS_fl[] = {
    FLAG(LA_GEOMETRIC),
    FLAG(LA_ALTERNATE),
    FLAG(LA_STARTGAP),
    FLAG(LA_STYLED),
    END_FLAG
};

// LINEATTRS.iJoin
ENUMDEF aedLINEATTRS_iJoin[] = {
    ENUM(JOIN_ROUND),
    ENUM(JOIN_BEVEL),
    ENUM(JOIN_MITER),
    END_ENUM
};

// LINEATTRS.iEndCap
ENUMDEF aedLINEATTRS_iEndCap[] = {
    ENUM(ENDCAP_ROUND),
    ENUM(ENDCAP_SQUARE),
    ENUM(ENDCAP_BUTT),
    END_ENUM
};


// MATRIX.flAccel
FLAGDEF afdMATRIX_flAccel[] = {
    FLAG(XFORM_SCALE),
    FLAG(XFORM_UNITY),
    FLAG(XFORM_Y_NEG),
    FLAG(XFORM_FORMAT_LTOFX),
    FLAG(XFORM_FORMAT_FXTOL),
    FLAG(XFORM_FORMAT_LTOL),
    FLAG(XFORM_NO_TRANSLATION),
    END_FLAG
};


// PALETTE.flPal
FLAGDEF afdPALETTE_flPal[] = {
    FLAG(PAL_INDEXED),
    FLAG(PAL_BITFIELDS),
    FLAG(PAL_RGB),
    FLAG(PAL_BGR),
    FLAG(PAL_CMYK),
    FLAG(PAL_DC),
    FLAG(PAL_FIXED),
    FLAG(PAL_FREE),
    FLAG(PAL_MANAGED),
    FLAG(PAL_NOSTATIC),
    FLAG(PAL_MONOCHROME),
    FLAG(PAL_BRUSHHACK),
    FLAG(PAL_DIBSECTION),
    FLAG(PAL_NOSTATIC256),
    FLAG(PAL_HT),
    FLAG(PAL_RGB16_555),
    FLAG(PAL_RGB16_565),
    FLAG(PAL_GAMMACORRECT),
    END_FLAG
};


// PATH.flags
FLAGDEF afdPATH_flags[] = {
    FLAG(PD_BEGINSUBPATH),
    FLAG(PD_ENDSUBPATH),
    FLAG(PD_RESETSTYLE),
    FLAG(PD_CLOSEFIGURE),
    FLAG(PD_BEZIERS),
    FLAG(PATH_JOURNAL),
    END_FLAG
};

// PATH.flType
FLAGDEF afdPATH_flType[] = {
    FLAG(PATHTYPE_KEEPMEM),
    FLAG(PATHTYPE_STACK),
    END_FLAG
};


// PATHOBJ.fl
// PATH.fl
FLAGDEF afdPATHOBJ_fl[] = {
    FLAG(PO_BEZIERS),
    FLAG(PO_ELLIPSE),
    FLAG(PO_ALL_INTEGERS),
    FLAG(PO_ENUM_AS_INTEGERS),
    END_FLAG
};


// PDEV.fl
FLAGDEF afdPDEV_fl[] = {
    FLAG(PDEV_DISPLAY),
    FLAG(PDEV_HARDWARE_POINTER),
    FLAG(PDEV_SOFTWARE_POINTER),
    FLAG(PDEV_xxx1),
    FLAG(PDEV_xxx2),
    FLAG(PDEV_xxx3),
    FLAG(PDEV_GOTFONTS),
    FLAG(PDEV_PRINTER),
    FLAG(PDEV_ALLOCATEDBRUSHES),
    FLAG(PDEV_HTPAL_IS_DEVPAL),
    FLAG(PDEV_DISABLED),
    FLAG(PDEV_SYNCHRONIZE_ENABLED),
    FLAG(PDEV_xxx4),
    FLAG(PDEV_FONTDRIVER),
    FLAG(PDEV_GAMMARAMP_TABLE),
    FLAG(PDEV_UMPD),
    FLAG(PDEV_SHARED_DEVLOCK),
    FLAG(PDEV_META_DEVICE),
    FLAG(PDEV_DRIVER_PUNTED_CALL),
    FLAG(PDEV_CLONE_DEVICE),
    FLAG(PDEV_MOUSE_TRAILS),
    FLAG(PDEV_SYNCHRONOUS_POINTER),
    END_FLAG
};

// PDEV.flAccelerated
FLAGDEF afdPDEV_flAccelerated[] = {
    FLAG(ACCELERATED_CONSTANT_ALPHA),
    FLAG(ACCELERATED_PIXEL_ALPHA),
    FLAG(ACCELERATED_TRANSPARENT_BLT),
    END_FLAG
};

// PDEV.dwDriverCapableOverride
FLAGDEF afdPDEV_dwDriverCapableOverride[] = {
    FLAG(DRIVER_CAPABLE_ALL),
    FLAG(DRIVER_NOT_CAPABLE_GDI),
    FLAG(DRIVER_NOT_CAPABLE_DDRAW),
    FLAG(DRIVER_NOT_CAPABLE_D3D),
    FLAG(DRIVER_NOT_CAPABLE_OPENGL),
    END_FLAG
};


// SPRITE.fl
FLAGDEF afdSPRITE_fl[] = {
    FLAG(SPRITE_FLAG_CLIPPING_OBSCURED),
    FLAG(SPRITE_FLAG_JUST_TRANSFERRED),
    FLAG(SPRITE_FLAG_NO_WINDOW),
    FLAG(SPRITE_FLAG_EFFECTIVELY_OPAQUE),
    FLAG(SPRITE_FLAG_HIDDEN),
    FLAG(SPRITE_FLAG_VISIBLE),
    END_FLAG
};

// SPRITE.dwShape
// _SpriteCachedAttributes.dwShape
FLAGDEF afdSPRITE_dwShape[] = {
    FLAG(ULW_COLORKEY),
    FLAG(ULW_ALPHA),
    FLAG(ULW_OPAQUE),

    // Private flags
    //FLAG(ULW_NOREPAINT),
    //FLAG(ULW_DEFAULT_ATTRIBUTES),
    //FLAG(ULW_NEW_ATTRIBUTES),
    FLAG(ULW_CURSOR),
    FLAG(ULW_DRAGRECT),
    END_FLAG
};


// SURFACE.SURFOBJ.iType
ENUMDEF aedSTYPE[] = {
    ENUM(STYPE_BITMAP),
    ENUM(STYPE_DEVICE),
    ENUM(STYPE_DEVBITMAP),
    END_ENUM
};

// SURFACE.SURFOBJ.fjBitmap
FLAGDEF afdSURFOBJ_fjBitmap[] = {
    FLAG(BMF_TOPDOWN),
    FLAG(BMF_NOZEROINIT),
    FLAG(BMF_DONTCACHE),
    FLAG(BMF_USERMEM),
    FLAG(BMF_KMSECTION),
    FLAG(BMF_NOTSYSMEM),
    FLAG(BMF_WINDOW_BLT),
    FLAG(BMF_UMPDMEM),
    {"BMF_SPRITE (obsolete)", 0x0100},
    FLAG(BMF_ISREADONLY),
    FLAG(BMF_MAKEREADWRITE),
    END_FLAG
};

// SURFACE.SURFOBJ.iBitmapFormat
// BLTINFO.iFormatSrc
// BLTINFO.iFormatDst
// DEVINFO.iDitherFormat
// EBRUSHOBJ._iMetaFormat
ENUMDEF aedBMF[] = {
    ENUM(BMF_1BPP),
    ENUM(BMF_4BPP),
    ENUM(BMF_8BPP),
    ENUM(BMF_16BPP),
    ENUM(BMF_24BPP),
    ENUM(BMF_32BPP),
    ENUM(BMF_4RLE),
    ENUM(BMF_8RLE),
    ENUM(BMF_JPEG),
    ENUM(BMF_PNG),
    END_ENUM
};

// SURFACE.SurfFlags
FLAGDEF afdSURFACE_SurfFlags[] = {
    FLAG(HOOK_BITBLT),
    FLAG(HOOK_STRETCHBLT),
    FLAG(HOOK_PLGBLT),
    FLAG(HOOK_TEXTOUT),
    { "HOOK_PAINT (obsolete)", HOOK_PAINT },
    FLAG(HOOK_STROKEPATH),
    FLAG(HOOK_FILLPATH),
    FLAG(HOOK_STROKEANDFILLPATH),
    FLAG(HOOK_LINETO),
//    FLAG(SHAREACCESS_SURFACE),
    FLAG(HOOK_COPYBITS),
//    { "HOOK_MOVEPANNING (obsolete)", HOOK_MOVEPANNING },
    FLAG(HOOK_SYNCHRONIZE),
    FLAG(HOOK_STRETCHBLTROP),
//    { "HOOK_SYNCHRONIZEACCESS (obsolete)", HOOK_SYNCHRONIZEACCESS },
    FLAG(HOOK_TRANSPARENTBLT),
    FLAG(HOOK_ALPHABLEND),
    FLAG(HOOK_GRADIENTFILL),

    FLAG(USE_DEVLOCK_SURFACE),

    FLAG(PDEV_SURFACE),
    FLAG(ABORT_SURFACE),
    FLAG(DYNAMIC_MODE_PALETTE),
    FLAG(UNREADABLE_SURFACE),
    FLAG(PALETTE_SELECT_SET),
    FLAG(API_BITMAP),
    FLAG(BANDING_SURFACE),
    FLAG(INCLUDE_SPRITES_SURFACE),
    FLAG(LAZY_DELETE_SURFACE),
    FLAG(DDB_SURFACE),
    FLAG(ENG_CREATE_DEVICE_SURFACE),
    FLAG(DRIVER_CREATED_SURFACE),
    FLAG(DIRECTDRAW_SURFACE),
    FLAG(MIRROR_SURFACE),
    FLAG(UMPD_SURFACE),

    FLAG(REDIRECTION_SURFACE),
    FLAG(SHAREACCESS_SURFACE),

    END_FLAG
};


// XLATEOBJ.flXlate
FLAGDEF afdXLATEOBJ_flXlate[] = {
    FLAG(XO_TRIVIAL),
    FLAG(XO_TABLE),
    FLAG(XO_TO_MONO),
    FLAG(XO_FROM_CMYK),
    FLAG(XO_DEVICE_ICM),
    FLAG(XO_HOST_ICM),
    END_FLAG
};


// XLATE.lCachIndex
ENUMDEF aedXLATE_lCacheIndex[] = {
    ENUM(XLATE_CACHE_INVALID),
    ENUM(XLATE_CACHE_JOURNAL),
    END_ENUM
};

// XLATE.flPrivate
FLAGDEF afdXLATE_flPrivate[] = {
    FLAG(XLATE_FROM_MONO),
    FLAG(XLATE_RGB_SRC),
    FLAG(XLATE_RGB_BOTH),
    FLAG(XLATE_PAL_MANAGED),
    FLAG(XLATE_USE_CURRENT),
    FLAG(XLATE_USE_SURFACE_PAL),
    FLAG(XLATE_USE_FOREGROUND),
    END_FLAG
};


extern EnumFlagEntry efe_PATHOBJ;
extern EnumFlagEntry efeXCLIPOBJ;


EnumFlagField aeff_BASEOBJECT[] = {
    { "hHmgr",      CALL_FUNC,  OutputHandleInfo        },
    { "BaseFlags",  FLAG_FIELD, afdBASEOBJECT_BaseFlags },
};
EnumFlagEntry efe_BASEOBJECT = EFTypeEntry(_BASEOBJECT);

EnumFlagField aeff_BLENDFUNCTION[] = {
    { "BlendOp",        ENUM_FIELD, aed_BLENDFUNCTION_BlendOp       },
    { "BlendFlags",     FLAG_FIELD, afd_BLENDFUNCTION_BlendFlags    },
    { "AlphaFormat",    FLAG_FIELD, afd_BLENDFUNCTION_AlphaFormat   },
};

EnumFlagField aeffBLTINFO[] = {
    { "iFormatSrc", ENUM_FIELD, aedBMF  },
    { "iFormatDst", ENUM_FIELD, aedBMF  },
};

EnumFlagField aeffBRUSH[] = {
    { "_BASEOBJECT",    PARENT_FIELDS,  &efe_BASEOBJECT     },
    { "_ulStyle",       ENUM_FIELD,     aedBRUSH__ulStyle   },
    { "_flAttrs",       FLAG_FIELD,     afdBRUSH__flAttrs   },
};

EnumFlagField aeff_BRUSHOBJ[] = {
    { "flColorType",    FLAG_FIELD, afdBRUSHOBJ_flColorType },
};
EnumFlagEntry efe_BRUSHOBJ = EFTypeEntry(_BRUSHOBJ);

EnumFlagField aeff_CLIPOBJ[] = {
    { "iDComplexity",   ENUM_FIELD, aedCLIPOBJ_iDComplexity },
    { "iFComplexity",   ENUM_FIELD, aedCLIPOBJ_iFComplexity },
    { "iMode",          ENUM_FIELD, aedCLIPOBJ_iMode        },
    { "fjOptions",      FLAG_FIELD, afdCLIPOBJ_fjOptions    },
};
EnumFlagEntry efe_CLIPOBJ = EFTypeEntry(_CLIPOBJ);

EnumFlagField aeffDC[] = {
    { "_BASEOBJECT",        PARENT_FIELDS,  &efe_BASEOBJECT         },
    { "fs_",                FLAG_FIELD,     afdDC_fs_               },
    { "flGraphicsCaps_",    FLAG_FIELD,     afdDC_flGraphicsCaps_   },
    { "flGraphicsCaps2_",   FLAG_FIELD,     afdDC_flGraphicsCaps2_  },
};

EnumFlagField aeff_devicemodeA[] = {
    { "dmFields",               FLAG_FIELD, afdDEVMODE_dmFields             },
    { "dmPaperSize",            ENUM_FIELD, aedDEVMODE_dmPaperSize          },
    { "dmDisplayOrientation",   ENUM_FIELD, aedDEVMODE_dmDisplayOrientation },
    { "dmDisplayFixedOutput",   ENUM_FIELD, aedDEVMODE_dmDisplayFixedOutput },
    { "dmDisplayFlags",         FLAG_FIELD, afdDEVMODE_dmDisplayFlags       },
    { "dmICMMethod",            ENUM_FIELD, aedDEVMODE_dmICMMethod          },
    { "dmICMIntent",            ENUM_FIELD, aedDEVMODE_dmICMIntent          },
    { "dmMediaType",            ENUM_FIELD, aedDEVMODE_dmMediaType          },
    { "dmDitherType",           ENUM_FIELD, aedDEVMODE_dmDitherType         },
};

EnumFlagField aeff_devicemodeW[] = {
    { "dmFields",               FLAG_FIELD, afdDEVMODE_dmFields             },
    { "dmPaperSize",            ENUM_FIELD, aedDEVMODE_dmPaperSize          },
    { "dmDisplayOrientation",   ENUM_FIELD, aedDEVMODE_dmDisplayOrientation },
    { "dmDisplayFixedOutput",   ENUM_FIELD, aedDEVMODE_dmDisplayFixedOutput },
    { "dmDisplayFlags",         FLAG_FIELD, afdDEVMODE_dmDisplayFlags       },
    { "dmICMMethod",            ENUM_FIELD, aedDEVMODE_dmICMMethod          },
    { "dmICMIntent",            ENUM_FIELD, aedDEVMODE_dmICMIntent          },
    { "dmMediaType",            ENUM_FIELD, aedDEVMODE_dmMediaType          },
    { "dmDitherType",           ENUM_FIELD, aedDEVMODE_dmDitherType         },
};

EnumFlagField aefftagDEVINFO[] = {
    { "flGraphicsCaps",     FLAG_FIELD, afdDC_flGraphicsCaps_   },
    { "iDitherFormat",      ENUM_FIELD, aedBMF                  },
    { "flGraphicsCaps2",    FLAG_FIELD, afdDC_flGraphicsCaps2_  },
};

EnumFlagField aeffEBRUSHOBJ[] = {
    { "_BRUSHOBJ",      PARENT_FIELDS,  &efe_BRUSHOBJ       },
    { "flAttrs",        FLAG_FIELD,     afdBRUSH__flAttrs   },
    { "_iMetaFormat",   ENUM_FIELD,     aedBMF              },
};

EnumFlagField aeffECLIPOBJ[] = {
    { "XCLIPOBJ",   PARENT_FIELDS, &efeXCLIPOBJ     },
};

EnumFlagField aeffEPATHOBJ[] = {
    { "_PATHOBJ",   PARENT_FIELDS, &efe_PATHOBJ     },
};

EnumFlagField aeff_ENTRY[] = {
    { "FullUnique",     CALL_FUNC,  OutputFullUniqueInfo    },
    { "Objt",           ENUM_FIELD, aedENTRY_Objt           },
    { "Flags",          FLAG_FIELD, afdENTRY_Flags          },
};

EnumFlagField aeff_FLOAT_LONG[] = {
    { "e",  CALL_FUNC, OutputFLOATL },
};

EnumFlagField aeff_GDIINFO[] = {
    { "flRaster",       FLAG_FIELD, afdGDIINFO_flRaster     },
};

EnumFlagField aefftagGRAPHICS_DEVICE[] = {
    { "stateFlags",     FLAG_FIELD, afdGRAPHICS_DEVICE_stateFlags   },
};

EnumFlagField aeff_LINEATTRS[] = {
    { "fl",             FLAG_FIELD, afdLINEATTRS_fl         },
    { "iJoin",          ENUM_FIELD, aedLINEATTRS_iJoin      },
    { "iEndCap",        ENUM_FIELD, aedLINEATTRS_iEndCap    },
};

EnumFlagField aeffMATRIX[] = {
    { "flAccel",        FLAG_FIELD, afdMATRIX_flAccel       },
};

EnumFlagField aeffPALETTE[] = {
    { "_BASEOBJECT",    PARENT_FIELDS,  &efe_BASEOBJECT     },
    { "flPal",          FLAG_FIELD,     afdPALETTE_flPal    },
};

EnumFlagField aeffPATH[] = {
    { "_BASEOBJECT",    PARENT_FIELDS,  &efe_BASEOBJECT     },
    { "flags",          FLAG_FIELD, afdPATH_flags           },
    { "flType",         FLAG_FIELD, afdPATH_flType          },
    { "fl",             FLAG_FIELD, afdPATHOBJ_fl           },
};

EnumFlagField aeff_PATHOBJ[] = {
    { "fl",             FLAG_FIELD, afdPATHOBJ_fl   },
};
EnumFlagEntry efe_PATHOBJ = EFTypeEntry(_PATHOBJ);

EnumFlagField aeffPDEV[] = {
    { "_BASEOBJECT",    PARENT_FIELDS,  &efe_BASEOBJECT         },
    { "fl",             FLAG_FIELD,     afdPDEV_fl              },
    { "flAccelerated",  FLAG_FIELD,     afdPDEV_flAccelerated   },
    { "dwDriverCapableOverride", FLAG_FIELD, afdPDEV_dwDriverCapableOverride},
//    { "dwDriverAccelerationLevel", CALL_FUNC, },
};

EnumFlagField aeffSPRITE[] = {
    { "fl",             FLAG_FIELD,     afdSPRITE_fl            },
    { "dwShape",        FLAG_FIELD,     afdSPRITE_dwShape       },
};

EnumFlagField aeff_SpriteCachedAttributes[] = {
    { "dwShape",        FLAG_FIELD,     afdSPRITE_dwShape       },
};

EnumFlagField aeff_SPRITESTATE[] = {
    { "flOriginalSurfFlags",    FLAG_FIELD, afdSURFACE_SurfFlags    },
    { "iOriginalType",          ENUM_FIELD, aedSTYPE                },
    { "flSpriteSurfFlags",      FLAG_FIELD, afdSURFACE_SurfFlags    },
    { "iSpriteType",            ENUM_FIELD, aedSTYPE                },
};

EnumFlagField aeff_SURFOBJ[] = {
    { "iBitmapFormat",  ENUM_FIELD, aedBMF      },
    { "iType",          ENUM_FIELD, aedSTYPE    },
    { "fjBitmap",       FLAG_FIELD, afdSURFOBJ_fjBitmap     },
};

EnumFlagField aeffSURFACE[] = {
    { "_BASEOBJECT",    PARENT_FIELDS,  &efe_BASEOBJECT         },
    { "SurfFlags",      FLAG_FIELD,     afdSURFACE_SurfFlags    },
};

EnumFlagField aeffXCLIPOBJ[] = {
    { "_CLIPOBJ",   PARENT_FIELDS, &efe_CLIPOBJ     },
};
EnumFlagEntry efeXCLIPOBJ = EFTypeEntry(XCLIPOBJ);

EnumFlagField aeff_XLATEOBJ[] = {
    { "flXlate",    FLAG_FIELD, afdXLATEOBJ_flXlate },
};
EnumFlagEntry efe_XLATEOBJ = EFTypeEntry(_XLATEOBJ);

EnumFlagField aeffXLATE[] = {
    { "_XLATEOBJ",      PARENT_FIELDS,     &efe_XLATEOBJ            },
    { "lCacheIndex",    ENUM_FIELD_LIMITED, aedXLATE_lCacheIndex    },
    { "flPrivate",      FLAG_FIELD,         afdXLATE_flPrivate      },
};


EnumFlagEntry EFDatabase[] = {
//    { , 0, , aeff },
    EFTypeEntry(_BASEOBJECT),
    EFTypeEntry(_BLENDFUNCTION),
    EFTypeEntry(BLTINFO),
    EFTypeEntry(BRUSH),
    EFTypeEntry(_BRUSHOBJ),
    EFTypeEntry(_CLIPOBJ),
    EFTypeEntry(DC),
    EFTypeEntry(_devicemodeA),
    EFTypeEntry(_devicemodeW),
    EFTypeEntry(tagDEVINFO),
    EFTypeEntry(EBRUSHOBJ),
    EFTypeEntry(ECLIPOBJ),
    EFTypeEntry(_ENTRY),
    EFTypeEntry(EPATHOBJ),
    EFTypeEntry(_FLOAT_LONG),
    EFTypeEntry(_GDIINFO),
    EFTypeEntry(tagGRAPHICS_DEVICE),
    EFTypeEntry(_LINEATTRS),
    EFTypeEntry(MATRIX),
    EFTypeEntry(PALETTE),
    EFTypeEntry(PATH),
    EFTypeEntry(_PATHOBJ),
    EFTypeEntry(PDEV),
    EFTypeEntry(SPRITE),
    EFTypeEntry(_SpriteCachedAttributes),
    EFTypeEntry(_SPRITESTATE),
    EFTypeEntry(SURFACE),
    EFTypeEntry(_SURFOBJ),
    EFTypeEntry(XCLIPOBJ),
    EFTypeEntry(_XLATEOBJ),
    EFTypeEntry(XLATE),
    { "", 0, 0, NULL}
};


/******************************Public*Routine******************************\
*   output standard flags
*
* History:
*
*   11-30-2000 -by- Jason Hartman [jasonha]
*
\**************************************************************************/

ULONG64
OutputFlags(
    OutputControl *OutCtl,
    FLAGDEF *pFlagDef,
    ULONG64 fl,
    BOOL SingleLine
    )
{
    ULONG64 FlagsFound = 0;

    if (fl == 0)
    {
        while (pFlagDef->psz != NULL)
        {
            if (pFlagDef->fl == 0)
            {
                if (!SingleLine) OutCtl->Output("\n       ");
                OutCtl->Output("%s",pFlagDef->psz);
            }

            pFlagDef++;
        }
    }
    else
    {
        while (pFlagDef->psz != NULL)
        {
            if (pFlagDef->fl & fl)
            {
                if (!SingleLine)
                {
                    OutCtl->Output("\n       ");
                }
                else if (FlagsFound)
                {
                    OutCtl->Output(" | ");
                }

                OutCtl->Output("%s",pFlagDef->psz);

                if (FlagsFound & pFlagDef->fl)
                {
                    OutCtl->Output(" (SHARED FLAG)");
                }
                FlagsFound |= pFlagDef->fl;
            }

            pFlagDef++;
        }
    }

    return fl & ~FlagsFound;
}


/******************************Public*Routine******************************\
*   output standard enum values
*
* History:
*
*   11-30-2000 -by- Jason Hartman [jasonha]
*
\**************************************************************************/

BOOL
OutputEnum(
    OutputControl *OutCtl,
    ENUMDEF *pEnumDef,
    ULONG64 ul
    )
{
    while (pEnumDef->psz != NULL)
    {
        if (pEnumDef->ul == ul)
        {
            OutCtl->Output(pEnumDef->psz);
            return (TRUE);
        }

        pEnumDef++;
    }

    return (FALSE);
}

BOOL
OutputEnumWithParenthesis(
    OutputControl *OutCtl,
    ENUMDEF *pEnumDef,
    ULONG64 ul
    )
{
    while (pEnumDef->psz != NULL)
    {
        if (pEnumDef->ul == ul)
        {
            OutCtl->Output("(%s)", pEnumDef->psz);
            return (TRUE);
        }

        pEnumDef++;
    }

    return (FALSE);
}


/******************************Public*Routine******************************\
*   Output interpretation of pszField's value if found in pEFEntry
*
* History:
*
*   11-30-2000 -by- Jason Hartman [jasonha]
*
\**************************************************************************/

BOOL
OutputFieldValue(
    OutputControl *OutCtl,
    EnumFlagEntry *pEFEntry,
    const CHAR *pszField,
    PDEBUG_VALUE Value,
    PDEBUG_CLIENT Client,
    BOOL Compact
    )
{
    EnumFlagField  *pEFField;
    DEBUG_VALUE     ConvValue;

    if (OutCtl == NULL ||
        pEFEntry == NULL ||
        pszField == NULL ||
        Value == NULL ||
        Value->Type == DEBUG_VALUE_INVALID)
    {
        return E_INVALIDARG;
    }

    for (ULONG i = 0; i < pEFEntry->FieldEntries; i++)
    {
        pEFField = &pEFEntry->FieldEntry[i];

        if (pEFField->EFType == PARENT_FIELDS)
        {
            if (OutputFieldValue(OutCtl, pEFField->Parent, pszField, Value, Client, Compact))
            {
                return TRUE;
            }
        }
        else if (strcmp(pszField, pEFField->FieldName) == 0)
        {
            switch (pEFField->EFType)
            {
                case FLAG_FIELD:
                {
                    ULONG64 flRem;

                    if (Value->Type != DEBUG_VALUE_INT64)
                    {
                        if (OutCtl->CoerceValue(Value, DEBUG_VALUE_INT64, &ConvValue) != S_OK)
                        {
                            return FALSE;
                        }
                        Value = &ConvValue;
                    }

                    if (Compact)
                    {
                        OutCtl->Output(" (");
                    }
                    flRem = OutputFlags(OutCtl, pEFField->FlagDef, Value->I64, Compact);
                    if (flRem && ((flRem != 0xffffffff00000000) || !(Value->I64 & 0x80000000)))
                    {
                        if (!Compact) OutCtl->Output("\n      ");
                        OutCtl->Output("  Unknown Flags: 0x%I64x", flRem);
                    }
                    if (Compact)
                    {
                        OutCtl->Output(")");
                    }
                    return TRUE;
                }

                case ENUM_FIELD:
                case ENUM_FIELD_LIMITED:
                {
                    if (Value->Type != DEBUG_VALUE_INT64)
                    {
                        if (OutCtl->CoerceValue(Value, DEBUG_VALUE_INT64, &ConvValue) != S_OK)
                        {
                            return FALSE;
                        }
                        Value = &ConvValue;
                    }

                    OutCtl->Output(" ");
                    if (!OutputEnumWithParenthesis(OutCtl, pEFField->EnumDef, Value->I64))
                    {
                        if (pEFField->EFType != ENUM_FIELD_LIMITED)
                        {
                            OutCtl->Output("(Unknown Value)", Value->I64);
                        }
                    }
                    return TRUE;
                }

                case CALL_FUNC:
                    OutCtl->Output(" ");
                    pEFField->EFFunc(OutCtl, Client, Value);
                    return TRUE;

                default:
                    OutCtl->OutErr("        Unknown database entry type.\n");
                    break;
            }
        }
    }

    return FALSE;
}


/******************************Public*Routine******************************\
*   Output interpretations of known fields as stored in EFDatabase
*       (Known flags & enum values as well some special fields.)
*
* History:
*
*   11-30-2000 -by- Jason Hartman [jasonha]
*
\**************************************************************************/

BOOL
OutputTypeFieldValue(
    OutputControl *OutCtl,
    const CHAR *pszType,
    const CHAR *pszField,
    PDEBUG_VALUE Value,
    PDEBUG_CLIENT Client,
    BOOL Compact
    )
{
    if (OutCtl == NULL ||
        Value == NULL ||
        Value->Type == DEBUG_VALUE_INVALID)
    {
        return E_INVALIDARG;
    }

    BOOL            FoundType = FALSE;
    EnumFlagEntry  *pEFEntry = EFDatabase;

    BOOL            FoundField;

    for (pEFEntry = EFDatabase;
         pEFEntry->TypeName[0] != '\0';
         pEFEntry++)
    {
        if (strcmp(pszType, pEFEntry->TypeName) == 0)
        {
            FoundType = TRUE;
            break;
        }
    }

    if (!FoundType)
    {
        // Check if this type is a clean typedef
        // (Test it against database with prefixed
        // '_'s and 'tag's removed.)
        for (pEFEntry = EFDatabase;
             pEFEntry->TypeName[0] != '\0';
             pEFEntry++)
        {
            if ((pEFEntry->TypeName[0] == '_') ?
                (strcmp(pszType, &pEFEntry->TypeName[1]) == 0) :
                (pEFEntry->TypeName[0] == 't' &&
                 pEFEntry->TypeName[1] == 'a' &&
                 pEFEntry->TypeName[2] == 'g' &&
                 strcmp(pszType, &pEFEntry->TypeName[3]) == 0))
            {
                FoundType = TRUE;
                break;
            }
        }

    }

    return (FoundType) ?
        OutputFieldValue(OutCtl, pEFEntry, pszField, Value, Client, Compact) :
        FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\math.cxx ===
/******************************Module*Header*******************************\
* Module Name: math.cxx
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/


#include "precomp.hxx"

#include <limits.h>



HRESULT
GetAddressAndLength(
    OutputControl &OutCtl,
    PCSTR args,
    PBOOL UnknownArg,
    PDEBUG_VALUE Address,
    PDEBUG_VALUE Length
    )
{
    HRESULT     hr = S_OK;
    BOOL        ArgsOk = TRUE;
    DEBUG_VALUE Addr;
    DEBUG_VALUE Len;
    ULONG       RemIndex;

    if (UnknownArg != NULL) *UnknownArg = FALSE;
    if (Address != NULL) Address->Type = DEBUG_VALUE_INVALID;
    if (Length != NULL) Length->Type = DEBUG_VALUE_INVALID;

    Addr.Type = DEBUG_VALUE_INVALID;
    Len.Type = DEBUG_VALUE_INVALID;

    while (isspace(*args)) args++;

    while (hr == S_OK && ArgsOk && *args != '\0')
    {
        if (*args == '-')
        {
            ArgsOk = FALSE;
            do
            {
                args++;
            } while (*args != '\0' && !isspace(*args));
        }
        else if (Addr.Type == DEBUG_VALUE_INVALID)
        {
            hr = OutCtl.Evaluate(args, DEBUG_VALUE_INT64, &Addr, &RemIndex);
            if (hr == S_OK && Addr.I64 != 0)
            {
                args += RemIndex;
            }
            else
            {
                PCHAR   pEOA;
                CHAR    EOAChar;

                ArgsOk = FALSE;

                if (hr == S_OK)
                {
                    pEOA = (PCHAR)&args[RemIndex];
                    EOAChar = *pEOA;
                    *pEOA = '\0';
                }
                OutCtl.OutErr("Invalid Address: %s\n", args);
                if (hr == S_OK)
                {
                    *pEOA = EOAChar;
                }
            }
        }
        else if (Len.Type == DEBUG_VALUE_INVALID)
        {
            hr = OutCtl.Evaluate(args, DEBUG_VALUE_INT32, &Len, &RemIndex);
            if (hr == S_OK && Len.I64 != 0)
            {
                args += RemIndex;
            }
            else
            {
                PCHAR   pEOA;
                CHAR    EOAChar;

                ArgsOk = FALSE;

                if (hr == S_OK)
                {
                    pEOA = (PCHAR)&args[RemIndex];
                    EOAChar = *pEOA;
                    *pEOA = '\0';
                }
                OutCtl.OutErr("Invalid Length: %s\n", args);
                if (hr == S_OK)
                {
                    *pEOA = EOAChar;
                }
            }
        }
        else
        {
            ArgsOk = FALSE;
        }

        while (isspace(*args)) args++;
    }

    if (hr == S_OK)
    {
        if (UnknownArg != NULL) *UnknownArg = !ArgsOk;
        if (Address != NULL) *Address = Addr;
        if (Length != NULL) *Length = Len;
    }

    return hr;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   dfloat
*
\**************************************************************************/

DECLARE_API( dfloat ) 
{
    dprintf("Extension 'dfloat' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
  ULONG Num;
  ULONG Adr;
  BOOL List=FALSE;
  ULONG Value;
  
  PARSE_ARGUMENTS(dfloat_help);
  if(ntok<1) { 
    goto dfloat_help;
  }

  //find valid tokens - ignore the rest
  tok_pos = parse_iFindSwitch(tokens, ntok, 'l');
  if(tok_pos>=0) {
    List = TRUE;
    if((tok_pos+1)>=ntok) { 
      goto dfloat_help;               //-l requires an argument and it can't be the last arg
    }
    tok_pos++;
    Num = (LONG)GetExpression(tokens[tok_pos]);
  }

  //find first non-switch token not preceeded by a -l
  tok_pos = -1;
  do {
    tok_pos = parse_FindNonSwitch(tokens, ntok, tok_pos+1);
  } while ( (tok_pos!=-1)&&(parse_iIsSwitch(tokens, tok_pos-1, 'l')));
  if(tok_pos==-1) {
    goto dfloat_help;
  }

  Adr = (ULONG)GetExpression(tokens[tok_pos]);

  if(List) {
    for(ULONG i=0; i<Num; i++) {
      move(Value, Adr);
      dprintf("%lx: %lx %g\n", Adr, Value, *(float *)&Value);
      Adr+=sizeof(ULONG);
    }
  } else {
    dprintf("%g\n", *(float *)&Adr);
  }

  return;

dfloat_help:
  dprintf("Usage: dfloat [-?] [-l num] Value");
  dprintf("Displays the 32bit Value as an IEEE float\n");
  dprintf("if the -l option is specified the Value is interpreted as a pointer\n"
          "and an array of num 32bit values is displayed starting at the pointer\n");
#endif  // DOES NOT SUPPORT API64
  EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   efloat address [count]
*
* Routine Description:
*
*   dumps an EFLOAT
*
* Arguments:
*
*   address [count]
*
* Return Value:
*
*   none
*
\**************************************************************************/

DECLARE_API( efloat )
{
#if 1
    HRESULT         hr = E_POINTER;
    PDEBUG_SYMBOLS  Symbols;
    OutputControl   OutCtl(Client);
    DEBUG_VALUE     Addr;
    DEBUG_VALUE     Length;
    BOOL            UnknownArg;

    if (Client == NULL ||
        (hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                     (void **)&Symbols)) != S_OK)
    {
        return hr;
    }

    BEGIN_API( efloat );

    hr = GetAddressAndLength(OutCtl, args, &UnknownArg, &Addr, &Length);

    if (hr != S_OK || UnknownArg || Addr.Type != DEBUG_VALUE_INT64)
    {
        OutCtl.Output("Usage: efloat <EFLOAT Address> [Length]\n");
    }
    else
    {
        if (Length.Type != DEBUG_VALUE_INT32)
        {
            Length.I32 = 1;
        }

        OutputReader    OutputBuffer;
        OutputState     OutState(Client, FALSE);
        ULONG64         Module;
        ULONG           TypeId;
        ULONG           Size;
        PSTR            TypeDump;

        if ((hr = OutState.Setup(0, &OutputBuffer)) == S_OK &&
            (hr = GetTypeId(Client, "EFLOAT", &TypeId, &Module)) == S_OK &&
            (hr = Symbols->GetTypeSize(Module, TypeId, &Size)) == S_OK)
        {
            if (Size == 0)
            {
                OutCtl.OutErr("EFLOAT type has 0 size.\n");
                hr = S_FALSE;
            }
            else
            {
                ULONG64 LastAddr = Addr.I64 + Size*Length.I32;
                ULONG   BytesRead;

                while (Addr.I64 < LastAddr &&
                       OutCtl.GetInterrupt() != S_OK)
                {
                    OutCtl.Output("0x%p  ", Addr.I64);

                    OutputBuffer.DiscardOutput();

                    hr = OutState.OutputTypeVirtual(Addr.I64,
                                                    Module,
                                                    TypeId,
                                                    DEBUG_OUTTYPE_NO_INDENT |
                                                    DEBUG_OUTTYPE_NO_OFFSET |
                                                    DEBUG_OUTTYPE_COMPACT_OUTPUT);
                    if (hr == S_OK &&
                        (hr = OutputBuffer.GetOutputCopy(&TypeDump)) == S_OK)
                    {
                        for (PSTR psz = TypeDump; *psz != '\0'; psz++)
                        {
                            if (*psz == '\n') *psz = ' ';
                        }

                        OutCtl.Output("%s", TypeDump);
                        OutputEFLOAT_S(Client, &OutCtl,
                                       Module, TypeId,
                                       TypeDump,
                                       DEBUG_OUTTYPE_NO_INDENT |
                                       DEBUG_OUTTYPE_NO_OFFSET |
                                       DEBUG_OUTTYPE_COMPACT_OUTPUT,
                                       NULL);
                        OutputBuffer.FreeOutputCopy(TypeDump);
                    }
                    else
                    {
                        OutCtl.Output("?");
                    }
                    OutCtl.Output("\n");

                    Addr.I64 += Size;
                }
            }
        }
    }

    Symbols->Release();

    return hr;
#else
    INIT_API();

    ULONG64 EFloatAddr;
    ULONG   EFloatSize;
    int     count;
    char    ach[64];

    PARSE_POINTER(efloat_help);

    tok_pos = parse_FindNonSwitch(tokens, ntok, tok_pos+1);
    if (tok_pos==-1)
    {
        count=1;
    }
    else
    {
        if (sscanf(tokens[tok_pos], "%d", &count) == EOF ||
            count <= 0)
        {
            goto efloat_help;
        }
    }

    EFloatAddr = arg;
    EFloatSize = GetTypeSize(GDIType(EFLOAT));

    while (count > 0 && !CheckControlC())
    {
        for (ULONG offset = 0;  offset < EFloatSize; offset+=sizeof(DWORD))
        {
            ULONG64 Value;

            GetFieldValue(EFloatAddr+offset, "DWORD", NULL, Value);
            sprintf(ach, " %%0%dx", 2*min(sizeof(DWORD), EFloatSize-offset));
            dprintf(ach, (DWORD)Value);
        }

        dprintf(" = ");
        sprintEFLOAT(Client, ach, EFloatAddr );
        dprintf("%s\n", ach);

        EFloatAddr += EFloatSize;
        count--;
    }

    EXIT_API(S_OK);

efloat_help:
    dprintf("Usage: efloat [-?] address [count]\n");
    EXIT_API(S_OK);
#endif
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   sprintEFLOAT
*
\**************************************************************************/

#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
// Here for reference
int sprintEFLOAT_Old(char *ach, EFLOAT& ef)
{
    EFLOATEXT efInt;
    EFLOATEXT efFrac;
    LONG lInt, lFrac;
    char chSign;
    efFrac = ef;

    if (efFrac.bIsNegative()) {
        efFrac.vNegate();
        chSign = '-';
    }
    else
        chSign = '+';
    efFrac.bEfToLTruncate(lInt);
    efInt = lInt;
    efFrac -= efInt;
    efFrac *= (LONG) 1000000;
    efFrac.bEfToLTruncate(lFrac);

    return(sprintf(ach,"%c%d.%06d", chSign, lInt, lFrac));
}
#endif  // DOES NOT SUPPORT API64

int sprintEFLOAT_I386(PDEBUG_CLIENT Client, char *ach, ULONG64 offEF)
{
    ULONG64 lMant;
    LONG    lExp;
    ULONG   lInt, lFrac;
    ULONG64 fx3232;
    ULONG   error;
    char    chSign = '+';

    if (error = (ULONG)InitTypeRead(offEF, win32k!EFLOAT_S))
    {
        dprintf(" Unable to get contents of EFLOAT\n");
        dprintf("  (InitTypeRead returned %s)\n", pszWinDbgError(error));
        return 0;
    }
    lMant = ReadField(lMant);
    lExp  = (LONG)ReadField(lExp);

    if (lMant & 0x80000000)      // EFLOAT::bIsNegative
    {
        // EFLOAT::vNegate()
        if ((lMant & 0x7FFFFFFF) == 0)
        {
            lMant = 0x40000000;
            lExp += 1;
        }
        else
        {
            lMant = - (LONG)lMant;
        }
        chSign = '-';
    }
    // EFLOAT::bEfToLTruncate
    if (lExp > 32)
        return(sprintf(ach,"Overflow: exponent %d > 32", lExp));
    if (lExp < -32)
        return(sprintf(ach,"%c0.000000", chSign));


    if (lExp < 0)
    {
        fx3232 = lMant >> -lExp;
    }
    else
    {
        fx3232 = lMant << lExp;
    }

    lInt = (ULONG) (fx3232 >> 32);
    lFrac = (ULONG) ( ( (fx3232 & 0xFFFFFFFF) * 1000000 + 0x80000000) >> 32);

    if (lFrac > 1000000)
    {
        return(sprintf(ach,"Bug in sprintEFLOAT_I386: fraction above 1000000"));
    }

    if (lFrac == 1000000)
    {
        lInt++;
        lFrac = 0;
    }

    return(sprintf(ach,"%c%u.%06d", chSign, lInt, lFrac));
}

int sprintEFLOAT_IA64(PDEBUG_CLIENT Client, char *ach, ULONG64 offEF)
{
    return(sprintf(ach,"EFLOAT parser needs written for IA64"));
}

int sprintEFLOAT(PDEBUG_CLIENT Client, char *ach, ULONG64 offEF)
{
    switch (TargetMachine)
    {
    case IMAGE_FILE_MACHINE_I386:
        return(sprintEFLOAT_I386(Client, ach, offEF));
    case IMAGE_FILE_MACHINE_IA64:
        return(sprintEFLOAT_IA64(Client, ach, offEF));
    default:
        return(sprintf(ach,"EFLOAT parser needs written for machine type %X", TargetMachine));
    }
}


/**************************************************************************\
*
* Routine Name:
*
*   OutputEFLOAT_S
*
* Routine Description:
*
*   Outputs an EFLOAT_S
*
\**************************************************************************/

HRESULT
OutputEFLOAT_S(
    PDEBUG_CLIENT Client,
    OutputControl *OutCtl,
    ULONG64 Module,
    ULONG TypeId,
    PSTR Buffer,
    ULONG Flags,
    PULONG BufferUsed
    )
{
    HRESULT hr = S_FALSE;

    TypeOutputParser    Parser(Client);
    DEBUG_VALUE         Mant, Exp;

    if (Parser.LookFor(&Mant, "lMant", DEBUG_VALUE_INT32) == S_OK &&
        Parser.Parse(Buffer, NULL) == S_OK &&
        Parser.Complete() == S_OK &&
        Parser.LookFor(&Exp, "lExp", DEBUG_VALUE_INT32) == S_OK &&
        Parser.Parse(Buffer, NULL) == S_OK &&
        Parser.Complete() == S_OK)
    {
        LONG    lMant = Mant.I32;
        LONG    lExp = Exp.I32;
        ULONG   lInt, lFrac;
        ULONG64 fx3232;
        char    chSign = '+';

        if (lMant < 0)  // EFLOAT::bIsNegative
        {
            // EFLOAT::vNegate()
            if (lMant == LONG_MIN)
            {
                lMant = -(LONG_MIN/2);
                lExp += 1;
            }
            else
            {
                lMant = -lMant;
            }
            chSign = '-';
        }

        // EFLOAT::bEfToLTruncate
        if (lExp > 32)
            return OutCtl->Output("Overflow: exponent %d > 32", lExp);
        if (lExp < -32)
            return OutCtl->Output("%c0.000000", chSign);


        fx3232 = (lExp < 0) ? (((ULONG64) lMant) >> -lExp) : (((ULONG64) lMant) << lExp);
        lInt = (ULONG) (fx3232 >> 32);
        lFrac = (ULONG) ( ( (fx3232 & 0xFFFFFFFF) * 1000000 + 0x80000000) >> 32);

        if (lFrac > 1000000)
        {
            OutCtl->Output(DEBUG_OUTPUT_NORMAL | DEBUG_OUTPUT_ERROR,
                           "Bug in sprintEFLOAT_I386: fraction above 1000000");
        }
        else
        {
            if (lFrac == 1000000)
            {
                lInt++;
                lFrac = 0;
            }

            hr = OutCtl->Output("%c%u.%06d", chSign, lInt, lFrac);
        }
    }
    else
    {
        hr = OutCtl->Output("%s", Buffer);
    }

    return hr;
}


/**************************************************************************\
*
* Routine Name:
*
*   OutputFLOATL
*
* Routine Description:
*
*   Outputs a FLOAT from a DEBUG_VALUE regardless of Type
*
\**************************************************************************/

HRESULT
OutputFLOATL(
    OutputControl *OutCtl,
    PDEBUG_CLIENT Client,
    PDEBUG_VALUE Value
    )
{
    if (OutCtl == NULL || Value == NULL)
    {
        return E_INVALIDARG;
    }

    return OutCtl->Output("%#g", (double) Value->F32);
}


/******************************Public*Routine******************************\
* FLOATL
*
*   dumps an array of FLOAT's
*
* History:
*  Wed 24-Apr-1996 10:00:27 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

DECLARE_API( floatl )
{
    HRESULT         hr = E_POINTER;
    PDEBUG_SYMBOLS  Symbols;
    OutputControl   OutCtl(Client);
    DEBUG_VALUE     Addr;
    DEBUG_VALUE     Length;
    BOOL            UnknownArg;

    if (Client == NULL ||
        (hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                     (void **)&Symbols)) != S_OK)
    {
        return hr;
    }

    BEGIN_API( floatl );

    hr = GetAddressAndLength(OutCtl, args, &UnknownArg, &Addr, &Length);

    if (hr != S_OK || UnknownArg || Addr.Type != DEBUG_VALUE_INT64)
    {
        OutCtl.Output("Usage: floatl <FLOATL Address> [Count]\n");
    }
    else
    {
        if (Length.Type != DEBUG_VALUE_INT32)
        {
            Length.I32 = 1;
        }

        ULONG64     Module;
        ULONG       TypeId;
        ULONG       Size;
        DEBUG_VALUE Value;

        if ((hr = GetTypeId(Client, "FLOATL", &TypeId, &Module)) == S_OK &&
            (hr = Symbols->GetTypeSize(Module, TypeId, &Size)) == S_OK)
        {
            if (Size == 0 || Size > sizeof(Value.RawBytes))
            {
                OutCtl.OutErr("FLOATL type has unexpected size.\n");
                hr = S_FALSE;
            }
            else
            {
                ULONG64 LastAddr = Addr.I64 + Size*Length.I32;
                ULONG   BytesRead;

                while (Addr.I64 < LastAddr &&
                       OutCtl.GetInterrupt() != S_OK)
                {
                    OutCtl.Output("0x%p  ", Addr.I64);

                    if (Symbols->ReadTypedDataVirtual(Addr.I64,
                                                      Type_Module.Base,
                                                      TypeId,
                                                      &Value,
                                                      Size,
                                                      &BytesRead) == S_OK &&
                        BytesRead == Size)
                    {
                        OutputFLOATL(&OutCtl, Client, &Value);
                    }
                    else
                    {
                        OutCtl.Output("?");
                    }
                    OutCtl.Output("\n");

                    Addr.I64 += Size;
                }
            }
        }
    }

    Symbols->Release();

    return hr;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpMATRIX
*
\**************************************************************************/

void vDumpMATRIX(PDEBUG_CLIENT Client, ULONG64 offMX)
{
    DumpType(Client, "MATRIX", offMX);
}


/******************************Public*Routine******************************\
* MATRIX
*
\**************************************************************************/

DECLARE_API( matrix )
{
    return ExtDumpType(Client, "matrix", "MATRIX", args); 
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   mx
*
\**************************************************************************/

DECLARE_API( mx )
{
    return ExtDumpType(Client, "mx", "MATRIX", args); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\objects.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    objects.cxx

Abstract:

    This file contains the routines to list objects.

Author:

    Jason Hartman (JasonHa) 2001-05-12

Environment:

    User Mode

--*/

#include "precomp.hxx"


PCSTR   BaseObjectFields[] = {
    "hHmgr",
    "ulShareCount",
    "cExclusiveLock",
    "BaseFlags",
    "Tid",
    NULL
};

PCSTR   SurfaceObjectFields[] = {
    "so.hsurf",
    "so.hdev",
    "so.sizlBitmap",
    "so.cjBits",
    "so.pvBits",
    "so.iBitmapFormat",
    "so.iType",
    "so.fjBitmap",
    NULL
};

PCSTR   ExtendedSurfaceObjectFields[] = {
    "ulShareCount",
    "BaseFlags",
    "so.dhsurf",
    "SurfFlags",
    NULL
};


#if 0

HRESULT
ListObjectFilter(
    OutputControl *OutCtl,
    ULONG64 PoolAddr,
    ULONG TagFilter,
    TypeOutputParser *PoolHeadReader,
    PDEBUG_VALUE Tag,
    ULONG BlockSize,
    BOOL bQuotaWithTag,
    PVOID Context
    )
{
    HRESULT         hr;
    DEBUG_VALUE     PoolType;
      * = ( *)Context;
    PALLOCATION_STATS   AllocStatsAccum = (PALLOCATION_STATS)atu;

    if ( != S_OK)
    {
        return S_FALSE;
    }

    hr = PoolHeadReader->Get(&PoolType, "PoolType", DEBUG_VALUE_INT32);

    if (hr == S_OK)
    {
        if (PoolType.I32 == 0)
        {
            hr = atu->Add(Tag->I32, FreePool, BlockSize);
            AllocStatsAccum->Free++;
            AllocStatsAccum->FreeSize += BlockSize;
        }
        else
        {
            DEBUG_VALUE PoolIndex;

            if (!(PoolType.I32 & POOL_QUOTA_MASK) ||
                bQuotaWithTag)
            {
                Tag->I32 &= ~PROTECTED_POOL;
            }
            else if (PoolType.I32 & POOL_QUOTA_MASK)
            {
                Tag->I32 = 'CORP';
            }

            if (!NewPool)
            {
                hr = PoolHeadReader->Get(&PoolIndex, "PoolIndex", DEBUG_VALUE_INT32);
            }

            if (hr == S_OK)
            {
                if (NewPool ? (PoolType.I32 & 0x04) : (PoolIndex.I32 & 0x80))
                {
                    hr = atu->Add(Tag->I32, AllocatedPool, BlockSize);
                    AllocStatsAccum->Allocated++;
                    AllocStatsAccum->AllocatedSize += BlockSize;

                    if (AllocStatsAccum->Allocated % 100 == 0)
                    {
                        OutCtl->Output(".");

                        if (AllocStatsAccum->Allocated % 8000 == 0)
                        {
                            OutCtl->Output("\n");
                        }
                    }
                }
                else
                {
                    hr = atu->Add(Tag->I32, FreePool, BlockSize);
                    AllocStatsAccum->Free++;
                    AllocStatsAccum->FreeSize += BlockSize;
                }
            }
            else
            {
                hr = atu->Add(Tag->I32, IndeterminatePool, BlockSize);
                AllocStatsAccum->Indeterminate++;
                AllocStatsAccum->IndeterminateSize += BlockSize;
            }
        }
    }
    else
    {
        AllocStatsAccum->Indeterminate++;
        AllocStatsAccum->IndeterminateSize += BlockSize;
    }

    return hr;
}
#endif


DECLARE_API( listobj )
{
    HRESULT     hr;

    BEGIN_API( listobj );

    BOOL        CheckType = TRUE;
    Array<BOOL> MatchType(TOTAL_TYPE);
    Array<CHAR> TypeList;

    ULONG       TagFilter = '  *G';
    FLONG       SearchFlags = 0;
    BOOL        CheckHandle = FALSE;
    BOOL        Summary = FALSE;
    BOOL        BadArg = FALSE;

    OutputControl   OutCtl(Client);
    ULONG64         EntryAddr;
    ULONG64         gcMaxHmgr;
    ULONG           EntrySize;

    ULONG           Index = 0;

    ULONG           LongestType = 0;
    int         i;

    for (i = 0; i <= MAX_TYPE; i++)
    {
        ULONG   Len = strlen(pszTypes2[i]);
        if (Len > LongestType)
        {
            LongestType = Len;
        }
    }

    while (!BadArg)
    {
        while (isspace(*args)) args++;

        if (*args == '-')
        {
            // Process switches

            args++;
            BadArg = (*args == '\0' || isspace(*args));

            while (*args != '\0' && !isspace(*args))
            {
                switch (tolower(*args))
                {
                    case 'a':
                        if (CheckType && !TypeList.IsEmpty())
                        {
                            BadArg = TRUE;
                            OutCtl.OutErr("Error: -a may not be specified with a Type list.\n");
                        }
                        else
                        {
                            CheckType = FALSE;
                        }
                        break;

                    case 'h':
                        CheckHandle = TRUE;
                        break;

                    case 'n':
                        SearchFlags |= SEARCH_POOL_NONPAGED;
                        break;

                    case 'p':
                        SearchFlags |= SEARCH_POOL_PAGED;
                        break;

                    case 's':
                        Summary = TRUE;
                        break;

                    default:
                        BadArg = TRUE;
                        break;
                }

                if (BadArg) break;
                args++;
            }
        }
        else
        {
            if (*args == '\0') break;

            {
                // This argument must be a Type specification.
                if (!CheckType)
                {
                    OutCtl.OutErr("Error: a Type list may not be specified with -a.\n");
                    BadArg = TRUE;
                    break;
                }

                for (i = 0; i <= MAX_TYPE; i++)
                {
                    SIZE_T CheckLen = strlen(pszTypes2[i]);

                    if (_strnicmp(args, pszTypes2[i], CheckLen) == 0 &&
                        (!iscsym(args[CheckLen]) ||
                         (_strnicmp(&args[CheckLen], "_TYPE", 5) == 0 &&
                          !iscsym(args[CheckLen+5])
                       )))
                    {
                        if (!MatchType[i])
                        {
                            // Add Type to list
                            SIZE_T CatLoc = TypeList.GetLength();
                            if (CatLoc > 0)
                            {
                                TypeList[CatLoc] = ' ';
                                TagFilter = '???G';
                            }
                            else
                            {
                                TagFilter = '0??G' + (i << 24);
                            }
                            TypeList.Set(pszTypes2[i], CheckLen+1, CatLoc);
                        }
                        MatchType[i] = TRUE;
                        args += CheckLen;
                        if (iscsym(*args)) args += 5;
                        break;
                    }
                }

                if (i > MAX_TYPE)
                {
                    OutCtl.OutErr("Error: Unknown Type in '%s'.\n", args);
                    BadArg = TRUE;
                    break;
                }
            }
        }
    }

    if (!BadArg)
    {
        if (CheckType && TypeList.IsEmpty())
        {
            OutCtl.OutErr("Error: Missing -a or Type list.\n");
            BadArg = TRUE;
        }
    }

    if (BadArg)
    {
        if (*args == '?')
        {
            OutCtl.Output("listobj searches session pool for known GDI objects\n"
                          " and displays basic object properties\n"
                          "\n");
        }

        OutCtl.Output("Usage: listobj [-?hnps] <-a | Type(s)>\n"
                      "\n"
                      "     a - All object types\n"
                      "     h - Validate handle\n"
                      "     n - Search non-paged pool\n"
                      "     p - Seach paged pool\n"
                      "     s - Summary counts only\n"
                      "\n"
                      " The -s option combined with the -a option will produce\n"
                      "  a list of the totals for each object type.\n");

        OutCtl.Output("\n Valid Type values are:\n");
        i = 0;
        while (i <= MAX_TYPE)
        {
            do
            {
                OutCtl.Output("   %-*s", LongestType, pszTypes2[i++]);
            } while (i <= MAX_TYPE && i%4);
            OutCtl.Output("\n");
        }

        hr = S_OK;
    }
    else
    {
        ALLOCATION_STATS    AllocStats = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    
        if ((SearchFlags & (SEARCH_POOL_PAGED | SEARCH_POOL_NONPAGED)) == 0)
        {
            SearchFlags |= SEARCH_POOL_PAGED | SEARCH_POOL_NONPAGED;
        }

#if 0
        hr = SearchSessionPool(Client,
                               DEFAULT_SESSION, TagFilter, SearchFlags,
                               0,
                               ListObjectsFilter, &AllocStats, &AllocStats);
#else
        OutCtl.OutWarn("listobj not implemented.\n");
        hr = E_NOTIMPL;
#endif
    
        if (hr == S_OK || hr == E_ABORT)
        {
            //OutputAllocStats(&OutCtl, &AllocStats, (hr != S_OK));
        }
        else
        {
            OutCtl.OutWarn("SearchSessionPool returned %s\n", pszHRESULT(hr));
        }
    }

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\kdexts.cxx ===
/*++

Copyright (c) 1993-2000  Microsoft Corporation

Module Name:

    kdexts.cxx

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Wesley Witt (wesw) 26-Aug-1993

Environment:

    User Mode

--*/

#include "precomp.hxx"


//
// globals
//
HINSTANCE               ghDllInst;
WINDBG_EXTENSION_APIS64 ExtensionApis;
BOOL                    gbVerbose = FALSE;


DBGKD_GET_VERSION64     KernelVersionPacket;

ULONG64 EXPRLastDump = 0;

//
// Valid for the lifetime of the debug session.
//

ULONG   PageSize;
ULONG   PageShift;
ULONG64 PaeEnabled;
ULONG   TargetMachine;
ULONG   TargetClass;
ULONG   PlatformId = -1;
ULONG   MajorVer = 0;
ULONG   MinorVer = 0;
ULONG   SrvPack = 0;
ULONG   BuildNo = 0;
BOOL    NewPool = FALSE;
ULONG   PoolBlockShift;

BOOL    Connected = FALSE;
BOOL    Remote = FALSE;
CHAR    RemoteID[MAX_PATH];

ModuleParameters GDIKM_Module = { 0, DEBUG_ANY_ID, "win32k", "sys" };
ModuleParameters GDIUM_Module = { 0, DEBUG_ANY_ID, "gdi32", "dll" };
ModuleParameters Type_Module;

HRESULT SymbolInit(PDEBUG_CLIENT);


BOOLEAN
WINAPI
DllMain(
    HINSTANCE hInstDll,
	DWORD fdwReason,
	LPVOID lpvReserved
    )
{
    switch (fdwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            DbgPrint("DllMain: DLL_PROCESS_ATTACH: hInstance = %lx => ghDllInit(%lx)\n", hInstDll, ghDllInst);
            ghDllInst = hInstDll;
            break;
    }

    return TRUE;
}


extern "C"
HRESULT
CALLBACK
DebugExtensionSetClient(
    LPCSTR RemoteArgs
    )
{
    if (RemoteArgs != NULL)
    {
        Remote = TRUE;
        strncpy(RemoteID, RemoteArgs, sizeof(RemoteID));
    }
    else
    {
        Remote = FALSE;
    }

    return S_OK;
}


HRESULT
GetDebugClient(
    PDEBUG_CLIENT *pClient
    )
{
    HRESULT         Hr = S_FALSE;
    PDEBUG_CLIENT   Client;

    if (pClient == NULL)
    {
        return S_FALSE;
    }

    *pClient = NULL;

    if (Remote)
    {
        Hr = DebugConnect(RemoteID, __uuidof(IDebugClient), (void **)&Client);
        if (Hr == S_OK)
        {
            Hr = Client->ConnectSession(DEBUG_CONNECT_SESSION_NO_VERSION |
                                        DEBUG_CONNECT_SESSION_NO_ANNOUNCE,
                                        0);
            if (Hr != S_OK)
            {
                Client->Release();
            }
        }
    }
    else
    {
        Hr = DebugCreate(__uuidof(IDebugClient), (void **)&Client);
    }

    if (Hr == S_OK)
    {
        *pClient = Client;
    }

    return Hr;
}


void
GetLabIdFromBuildString(
    PSTR BuildString,
    PULONG pLabId
    )
{
    PCHAR pstr;

    *pLabId = 0;
    _strlwr(BuildString);
    pstr = strstr(BuildString, "lab");
    if (pstr) {
        sscanf(pstr+3, "%ld", pLabId);
    }
}



//PDEBUG_EXTENSION_INITIALIZE
extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(
    PULONG Version,
    PULONG Flags
    )
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    DbgPrint("DebugExtensionInitialize called.\n");

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    
    if ((Hr = GetDebugClient(&DebugClient)) != S_OK)
    {
        return Hr;
    }

    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                              (void **)&DebugControl)) != S_OK)
    {
        DebugClient->Release();
        return Hr;
    }

    ExtensionApis.nSize = sizeof(ExtensionApis);
    if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK)
    {
        GetRemoteWindbgExtApis(&ExtensionApis);
    }

    Hr = SetEventCallbacks(DebugClient);
    DbgPrint("EventCallbacks set for 0x%p returned %s.\n",
             DebugClient, pszHRESULT(Hr));

    ViewerInit();

    DebugControl->Release();
    DebugClient->Release();
    return S_OK;
}


//PDEBUG_EXTENSION_NOTIFY
extern "C"
void
CALLBACK
DebugExtensionNotify(
    ULONG Notify,
    ULONG64 Argument
    )
{
    switch (Notify) {
        case DEBUG_NOTIFY_SESSION_ACTIVE:
            DbgPrint("DebugExtensionNotify recieved DEBUG_NOTIFY_SESSION_ACTIVE\n");
            break;
        case DEBUG_NOTIFY_SESSION_INACTIVE:
            DbgPrint("DebugExtensionNotify recieved DEBUG_NOTIFY_SESSION_INACTIVE\n");
            break;
        case DEBUG_NOTIFY_SESSION_ACCESSIBLE:
            DbgPrint("DebugExtensionNotify recieved DEBUG_NOTIFY_SESSION_ACCESSIBLE\n");
            break;
        case DEBUG_NOTIFY_SESSION_INACCESSIBLE:
            DbgPrint("DebugExtensionNotify recieved DEBUG_NOTIFY_SESSION_INACCESSIBLE\n");
            break;
        default:
            DbgPrint("DebugExtensionNotify recieved unknown notification %u\n", Notify);
            break;
    }

    //
    // The first time we actually connect to a target, get the architecture
    //

    if ((Notify == DEBUG_NOTIFY_SESSION_ACCESSIBLE) && (!Connected))
    {
        IDebugClient *DebugClient;
        PDEBUG_CONTROL DebugControl;
        PDEBUG_DATA_SPACES DebugDataSpaces;
        HRESULT Hr;
        ULONG64 Page;

        if ((Hr = GetDebugClient(&DebugClient)) == S_OK)
        {
            //
            // Get the page size and PAE enable flag
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugDataSpaces),
                                       (void **)&DebugDataSpaces)) == S_OK)
            {
                if ((Hr = DebugDataSpaces->ReadDebuggerData(
                                            DEBUG_DATA_PaeEnabled, &PaeEnabled,
                                            sizeof(PaeEnabled), NULL)) == S_OK)
                {
                    if ((Hr = DebugDataSpaces->ReadDebuggerData(
                                                DEBUG_DATA_MmPageSize, &Page,
                                                sizeof(Page), NULL)) == S_OK)
                    {
                        PageSize = (ULONG)(ULONG_PTR)Page;
                        for (PageShift = 0; Page >>= 1; PageShift++) ;
                    }
                }

                DebugDataSpaces->Release();
            }

            //
            // Get the architecture type.
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                       (void **)&DebugControl)) == S_OK)
            {
                if ((Hr = DebugControl->GetActualProcessorType(
                                             &TargetMachine)) == S_OK)
                {
                    Connected = TRUE;
                }

                ULONG Qualifier;
                if ((Hr = DebugControl->GetDebuggeeType(&TargetClass, &Qualifier)) != S_OK)
                {
                    TargetClass = DEBUG_CLASS_UNINITIALIZED;
                }

                ULONG StringUsed;
                CHAR  BuildString[100];
                if ((Hr = DebugControl->GetSystemVersion(&PlatformId, &MajorVer,
                                                         &MinorVer, NULL,
                                                         0, NULL,
                                                         &SrvPack, BuildString,
                                                         sizeof(BuildString), &StringUsed)) == S_OK)
                {
                    PCHAR pstr;
                    ULONG LabId = 0;
                    BuildNo = MinorVer;

                    _strlwr(BuildString);
                    pstr = strstr(BuildString, "lab");
                    if (pstr != NULL)
                    {
                        sscanf(pstr+3, "%ld", &LabId);
                    }

                    NewPool = ((BuildNo > 2407) || (LabId == 1 && BuildNo >= 2402));
                    PoolBlockShift = NewPool ? 
                        POOL_BLOCK_SHIFT_LAB1_2402 : POOL_BLOCK_SHIFT_OLD;
                }
                else
                {
                    PlatformId = -1;
                    MajorVer = 0;
                    MinorVer = 0;
                    SrvPack = 0;
                    BuildNo = 0;

                    NewPool = FALSE;
                    PoolBlockShift = PageShift - 8;
                }

                DebugControl->Release();
            }

            // Try to initialize symbols only if the event monitor
            // hasn't fully registered.  This indicates that the
            // extension is just being loaded as opposed to being
            // loaded at system boot and reconnect (when GDI modules
            // won't even be loaded yet).
            if (UniqueTargetState == INVALID_UNIQUE_STATE)
            {
                SymbolInit(DebugClient);
            }

            DebugClient->Release();
        }
    }


    if (Notify == DEBUG_NOTIFY_SESSION_INACTIVE)
    {
        Connected = FALSE;
        TargetMachine = 0;
        PlatformId = -1;
        MajorVer = 0;
        MinorVer = 0;
        SrvPack = 0;
    }

    return;
}

//PDEBUG_EXTENSION_UNINITIALIZE
extern "C"
void
CALLBACK
DebugExtensionUninitialize(void)
{
    DbgPrint("DebugExtensionUninitialize called.\n");

    SessionExit();
    HmgrExit();
    ViewerExit();
    BasicTypesExit();

    ReleaseEventCallbacks(NULL);

    ExtRelease(TRUE);

    return;
}



BOOLEAN
IsCheckedBuild(
    PBOOLEAN Checked
    )
{
    if (MajorVer == 0) return FALSE;

    //
    // 0xC for checked, 0xF for free.
    //
    *Checked = ((MajorVer & 0xFF) == 0xc) ;
    return TRUE;
}


HRESULT GetModuleParameters(
    PDEBUG_CLIENT Client,
    ModuleParameters *Module,
    BOOL TryReload
    )
{
    HRESULT         hr;
    PDEBUG_SYMBOLS  Symbols;
    OutputControl   OutCtl(Client);

    if (Client == NULL) return E_POINTER;

    if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                    (void **)&Symbols)) != S_OK)
    {
        return hr;
    }

    hr = Symbols->GetModuleByModuleName(Module->Name, 0, &Module->Index, &Module->Base);

    Client->FlushCallbacks();

    if (hr != S_OK && TryReload)
    {
        CHAR ReloadArgs[MAX_PATH];

        OutCtl.OutVerb("GetModuleByModuleName returned %s.\n", pszHRESULT(hr));

        sprintf(ReloadArgs,
                (Module->Base != 0) ? "%s.%s=0x%I64x" : "%s.%s",
                Module->Name, Module->Ext, Module->Base);

        OutCtl.OutWarn("Trying %s reload.\n", ReloadArgs);

        hr = Symbols->Reload(ReloadArgs);

        Client->FlushCallbacks();

        if (hr == S_OK)
        {
            hr = Symbols->GetModuleByModuleName(Module->Name, 0, &Module->Index, &Module->Base);
            OutCtl.OutVerb("Module %s @ 0x%p; HRESULT %s\n", Module->Name, Module->Base, pszHRESULT(hr));

            Client->FlushCallbacks();
        }
        else
        {
            OutCtl.OutWarn("Reload(\"%s\") returned %s\n", ReloadArgs, pszHRESULT(hr));
        }
    }
    else
    {
        OutCtl.OutVerb("Module %s @ 0x%p.\n", Module->Name, Module->Base);
    }

    if (hr == S_OK)
    {
        hr = Symbols->GetModuleParameters(1,
                                          NULL,
                                          Module->Index,
                                          &Module->DbgModParams);

        OutCtl.OutVerb("SymbolType for %s: ", Module->Name);
        switch (Module->DbgModParams.SymbolType)
        {
            case DEBUG_SYMTYPE_NONE: OutCtl.OutVerb("NONE"); break;
            case DEBUG_SYMTYPE_COFF: OutCtl.OutVerb("COFF"); break;
            case DEBUG_SYMTYPE_CODEVIEW: OutCtl.OutVerb("CODEVIEW"); break;
            case DEBUG_SYMTYPE_PDB: OutCtl.OutVerb("PDB"); break;
            case DEBUG_SYMTYPE_EXPORT: OutCtl.OutVerb("EXPORT"); break;
            case DEBUG_SYMTYPE_DEFERRED: OutCtl.OutVerb("DEFERRED"); break;
            case DEBUG_SYMTYPE_SYM: OutCtl.OutVerb("SYM"); break;
            case DEBUG_SYMTYPE_DIA: OutCtl.OutVerb("DIA"); break;
            default:
                OutCtl.OutVerb("unknown %ld", Module->DbgModParams.SymbolType);
                break;
        }
        OutCtl.OutVerb(" (HRESULT %s)\n", pszHRESULT(hr));

        Client->FlushCallbacks();
    }

    Symbols->Release();

    return hr;
}


HRESULT
SymbolLoad(
    PDEBUG_CLIENT Client
    )
{
    HRESULT hr;
    ULONG   Class;
    ULONG   Qualifier;

    if (TargetClass != DEBUG_CLASS_USER_WINDOWS)
    {
        GetModuleParameters(Client, &GDIUM_Module, FALSE);

        if ((hr = GetModuleParameters(Client, &GDIKM_Module, TRUE)) == S_OK &&
            GDIKM_Module.Base != 0)
        {
            Type_Module = GDIKM_Module;
        }
    }
    else
    {
        hr = GetModuleParameters(Client, &GDIUM_Module, TRUE);
    }

    if (hr == S_OK)
    {
        gbSymbolsNotLoaded = FALSE;
    }

    if (Type_Module.Base == 0)
    {
        Type_Module = GDIUM_Module;
    }

    DbgPrint("Using %s for type module.\n", Type_Module.Name);

    return hr;
}


HRESULT SymbolInit(PDEBUG_CLIENT Client)
{
    HRESULT hr;

    GDIKM_Module.Base = 0;
    GDIUM_Module.Base = 0;
    Type_Module.Base = 0;

    hr = SymbolLoad(Client);

    BasicTypesInit(Client);
    HmgrInit(Client);
    SessionInit(Client);

    return hr;
}


HRESULT
InitAPI(PDEBUG_CLIENT Client, PCSTR ExtName)
{
    static BOOL SecondaryCall = FALSE;

    HRESULT hr;

    hr = EventCallbacksReady(Client);

    if (hr != S_OK)
    {
        OutputControl   OutCtl(Client);

        OutCtl.OutWarn(" Warning: Event callbacks have not been registered.\n");

        if (SecondaryCall)
        {
            OutCtl.OutWarn("   All extension caching is disabled.\n");
        }
        else
        {
            OutCtl.OutWarn("   If %s is the first extension used, use .load or !load in the future.\n"
                           "   Caching is disabled for this use of !%s.\n",
                           ExtName, ExtName);
        }
    }

    SecondaryCall = TRUE;

    if (gbSymbolsNotLoaded)
    {
        SymbolInit(Client);
    }

    return hr;
}


DECLARE_API(reinit)
{
    HRESULT hr;
    hr = SymbolInit(Client);
    return hr;
}


DECLARE_API(verbose)
{
    INIT_API();

    gbVerbose = !gbVerbose;
    ExtOut(" GDIKDX Verbose mode is now %s.\n", gbVerbose ? "ON" : "OFF");

    EXIT_API(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\output.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    output.cxx

Abstract:

    This file contains output state control and output callback classes.

Author:

    Jason Hartman (JasonHa) 2000-11-20

Environment:

    User Mode

--*/

#include "precomp.hxx"


HRESULT
OutputControl::SetControl(
    ULONG OutputControl,
    PDEBUG_CLIENT Client
    )
{
    ULONG   SendMask = OutputControl & DEBUG_OUTCTL_SEND_MASK;

    if (OutputControl != DEBUG_OUTCTL_AMBIENT &&
        (
#if DEBUG_OUTCTL_THIS_CLIENT > 0
        SendMask < DEBUG_OUTCTL_THIS_CLIENT ||
#endif
        SendMask > DEBUG_OUTCTL_LOG_ONLY ||
        (OutputControl & ~(DEBUG_OUTCTL_SEND_MASK |
                           DEBUG_OUTCTL_NOT_LOGGED |
                           DEBUG_OUTCTL_OVERRIDE_MASK))))
    {
        return E_INVALIDARG;
    }

    if (Client != NULL)
    {
        HRESULT         hr;
        PDEBUG_CONTROL  NewControl;

        // Switch to new client
        if ((hr = Client->QueryInterface(__uuidof(IDebugControl),
                                         (void **)&NewControl)) != S_OK)
        {
            return hr;
        }

        if (Control != NULL) Control->Release();
        Control = NewControl;
    }

    OutCtl = OutputControl;

    return S_OK;
}


HRESULT
OutputControl::Output(
    ULONG Mask,
    PCSTR Format,
    ...
    )
{
    HRESULT hr;
    va_list Args;

    if (Control == NULL) return E_FAIL;

    va_start(Args, Format);
    if (OutCtl == DEBUG_OUTCTL_AMBIENT)
    {
        hr = Control->OutputVaList(Mask, Format, Args);
    }
    else
    {
        hr = Control->ControlledOutputVaList(OutCtl, Mask, Format, Args);
    }
    va_end(Args);

    return hr;
}

HRESULT
OutputControl::OutputVaList(
    ULONG Mask,
    PCSTR Format,
    va_list Args
    )
{
    HRESULT hr;

    if (Control == NULL) return E_FAIL;

    if (OutCtl == DEBUG_OUTCTL_AMBIENT)
    {
        hr = Control->OutputVaList(Mask, Format, Args);
    }
    else
    {
        hr = Control->ControlledOutputVaList(OutCtl, Mask, Format, Args);
    }

    return hr;
}

HRESULT
OutputControl::Output(
    PCSTR Format,
    ...
    )
{
    HRESULT hr;
    va_list Args;

    va_start(Args, Format);
    hr = OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);

    return hr;
}

HRESULT
OutputControl::OutErr(
    PCSTR Format,
    ...
    )
{
    HRESULT hr;
    va_list Args;

    va_start(Args, Format);
    hr = OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);

    return hr;
}

HRESULT
OutputControl::OutWarn(
    PCSTR Format,
    ...
    )
{
    HRESULT hr;
    va_list Args;

    va_start(Args, Format);
    hr = OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);

    return hr;
}

HRESULT
OutputControl::OutVerb(
    PCSTR Format,
    ...
    )
{
    HRESULT hr;
    va_list Args;

    va_start(Args, Format);
    hr = OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);

    return hr;
}


HRESULT
OutputControl::GetInterrupt(
    )
{
    return (Control == NULL) ?
        E_FAIL :
        Control->GetInterrupt();
}


HRESULT
OutputControl::SetInterrupt(
    ULONG Flags
    )
{
    return (Control == NULL) ?
        E_FAIL :
        Control->SetInterrupt(Flags);
}


HRESULT
OutputControl::Evaluate(
    IN PCSTR Expression,
    IN ULONG DesiredType,
    OUT PDEBUG_VALUE Value,
    OUT OPTIONAL PULONG RemainderIndex
    )
{
    return (Control == NULL) ?
        E_FAIL :
        Control->Evaluate(Expression,
                          DesiredType,
                          Value,
                          RemainderIndex);
}


HRESULT
OutputControl::CoerceValue(
    IN PDEBUG_VALUE In,
    IN ULONG OutType,
    OUT PDEBUG_VALUE Out
    )
{
    return (Control == NULL) ?
        E_FAIL :
        Control->CoerceValue(In,
                             OutType,
                             Out);
}


HRESULT
OutputControl::IsPointer64Bit(
    )
{
    return (Control == NULL) ?
        E_FAIL :
        Control->IsPointer64Bit();
}



OutputState::OutputState(
    PDEBUG_CLIENT OrgClient,
    BOOL SameClient
    )
{
    hrInit = S_FALSE;
    Client = NULL;
    Control = NULL;
    Symbols = NULL;

    SetCallbacks = FALSE;

    CreatedClient = FALSE;
    Saved = FALSE;

    if (OrgClient != NULL)
    {
        if (SameClient)
        {
            Client = OrgClient;
            Client->AddRef();
            CreatedClient = TRUE;
            hrInit = S_OK;
        }
        else
        {
            hrInit = OrgClient->CreateClient(&Client);
        }
    }
}


OutputState::~OutputState()
{
    if (!CreatedClient) Restore();

    EXT_RELEASE(Symbols);
    EXT_RELEASE(Control);

    // If Client was newly created for OutputState, then
    // there shouldn't be any other references to Client.
    if (CreatedClient)
    {
        ULONG   RemainingRefs;

        RemainingRefs = Client->AddRef();
        if (RemainingRefs > 2)
        {
            DbgPrint("OutputState: %lu refs outstanding on created client.\n",
                     RemainingRefs-2);
            DbgBreakPoint();

            // As a precaution, Restore the callbacks;
            // so, any set callback may be cleaned up.
            Restore();
        }
        Client->Release();
    }

    if (Client != NULL) Client->Release();
}


HRESULT
OutputState::Setup(
    ULONG OutMask,
    PDEBUG_OUTPUT_CALLBACKS OutCallbacks
    )
{
    HRESULT hr = hrInit;
    ULONG   LastOutMask;

    if (hr == S_OK)
    {
        if (CreatedClient && !Saved)
        {
            if ((hr = Client->GetOutputMask(&OrgOutMask)) == S_OK &&
                (hr = Client->GetOutputCallbacks(&OrgOutCallbacks)) == S_OK)
            {
                Saved = TRUE;
            }
        }

        if (hr == S_OK &&
            (hr = Client->GetOutputMask(&LastOutMask)) == S_OK &&
            (hr = Client->SetOutputMask(OutMask)) == S_OK)
        {
            if (!Saved && !SetCallbacks)
            {
                OrgOutMask = LastOutMask;
                OrgOutCallbacks = NULL;
            }

            if ((hr = Client->SetOutputCallbacks(OutCallbacks)) == S_OK)
            {
                SetCallbacks = TRUE;
            }
            else
            {
                Client->SetOutputMask(LastOutMask);
            }
        }
    }


    if (hr == S_OK &&
        Symbols == NULL)
    {
        hr = Client->QueryInterface(__uuidof(IDebugSymbols), (void **)&Symbols);
    }

    return hr;
}


HRESULT
OutputState::Execute(
    PCSTR pszCommand
    )
{
    HRESULT hr = hrInit;

    if (hr == S_OK)
    {
        if (Control == NULL)
        {
            hr = Client->QueryInterface(__uuidof(IDebugControl), (void **)&Control);
        }

        if (hr == S_OK)
        {
            hr = Control->Execute(DEBUG_OUTCTL_THIS_CLIENT |
                                  DEBUG_OUTCTL_NOT_LOGGED |
                                  DEBUG_OUTCTL_OVERRIDE_MASK,
                                  pszCommand,
                                  DEBUG_EXECUTE_NOT_LOGGED |
                                  DEBUG_EXECUTE_NO_REPEAT);

            if (hr != S_OK)
            {
                DbgPrint("IDebugControl::Execute returned %s.\n",
                         pszHRESULT(hr));
            }
        }
    }

    return hr;
}


HRESULT
OutputState::OutputType(
    IN BOOL Physical,
    IN ULONG64 Offset,
    IN PCSTR Type,
    IN ULONG Flags
    )
{
    HRESULT hr = hrInit;

    if (hr == S_OK)
    {
        if (Symbols == NULL)
        {
            hr = Client->QueryInterface(__uuidof(IDebugSymbols), (void **)&Symbols);
        }

        if (hr == S_OK)
        {
            ULONG64 Module;
            ULONG   TypeId;

            hr = GetTypeId(Client, Type, &TypeId, &Module);

            if (hr != S_OK)
            {
                OutputControl   OutCtl(Client);
                ULONG           ModuleIndex = 0;

                while ((hr = Symbols->GetModuleByIndex(ModuleIndex, &Module)) == S_OK &&
                       (Module != 0))
                {
                    if ((hr = Symbols->GetTypeId(Module, Type, &TypeId)) == S_OK)
                    {
                        OutCtl.OutVerb("Found %s: TypeId 0x%lx in module @ %p.\n",
                                       Type, TypeId, Module);
                        break;
                    }

                    ModuleIndex++;
                    Module = 0;
                }

                if (hr == S_OK &&
                    (Module == 0 || TypeId == 0))
                {
                    hr = S_FALSE;
                }

                if (hr != S_OK)
                {
                    OutCtl.OutVerb("Couldn't find %s in any of %lu modules.\n",
                                   Type, ModuleIndex);
                }
            }

            if (hr == S_OK)
            {
                hr = OutputType(Physical, Offset, Module, TypeId, Flags);
            }
        }
    }

    return hr;
}


HRESULT
OutputState::OutputType(
    IN BOOL Physical,
    IN ULONG64 Offset,
    IN ULONG64 Module,
    IN ULONG TypeId,
    IN ULONG Flags
    )
{
    HRESULT hr = hrInit;

    if (hr == S_OK)
    {
        if (Symbols == NULL)
        {
            hr = Client->QueryInterface(__uuidof(IDebugSymbols), (void **)&Symbols);
        }

        if (hr == S_OK)
        {
            if (Physical)
            {
                hr = Symbols->OutputTypedDataPhysical(DEBUG_OUTCTL_THIS_CLIENT |
                                                      DEBUG_OUTCTL_NOT_LOGGED |
                                                      DEBUG_OUTCTL_OVERRIDE_MASK,
                                                      Offset,
                                                      Module,
                                                      TypeId,
                                                      Flags);
            }
            else
            {
                hr = Symbols->OutputTypedDataVirtual(DEBUG_OUTCTL_THIS_CLIENT |
                                                     DEBUG_OUTCTL_NOT_LOGGED |
                                                     DEBUG_OUTCTL_OVERRIDE_MASK,
                                                     Offset,
                                                     Module,
                                                     TypeId,
                                                     Flags);
            }

            if (hr != S_OK)
            {
                DbgPrint("IDebugSymbols::OutputTypedData%s returned %s for 0x%I64x.\n",
                         (Physical ? "Physical" : "Virtual"),
                         pszHRESULT(hr),
                         Offset);
            }
        }
    }

    return hr;
}


void OutputState::Restore()
{
    if (SetCallbacks)
    {
        Client->SetOutputCallbacks(OrgOutCallbacks);
        Client->SetOutputMask(OrgOutMask);

        SetCallbacks = FALSE;
    }

    if (Saved)
    {
        if (OrgOutCallbacks != NULL) OrgOutCallbacks->Release();
        Saved = FALSE;
    }
}



//----------------------------------------------------------------------------
//
// Default output callbacks implementation, provides IUnknown for
// static classes.
//
//----------------------------------------------------------------------------

STDMETHODIMP
DefOutputCallbacks::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    *Interface = NULL;

    if (//(InterfaceId == IID_IUnknown) ||
        (InterfaceId == __uuidof(IDebugOutputCallbacks)))
    {
        *Interface = (IDebugOutputCallbacks *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
DefOutputCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be allocated on a
    // stack or statically, but we retain a refcount
    // for debugging purposes.
    return ++RefCount;
}

STDMETHODIMP_(ULONG)
DefOutputCallbacks::Release(
    THIS
    )
{
    // This class is designed to be allocated on a
    // stack or statically, but we retain a refcount
    // for debugging purposes.
    RefCount--;

    if (RefCount < 1)
    {
        DbgPrint("DefOutputCallbacks@0x%p::RefCount(%lu) < 1.\n", this, RefCount);
        DbgBreakPoint();
    }

    return RefCount;
}

STDMETHODIMP
DefOutputCallbacks::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    // The default Output ignores all Output calls.
    return S_OK;
}


//----------------------------------------------------------------------------
//
// DebugOutputCallbacks::Output
//
//----------------------------------------------------------------------------

STDMETHODIMP
DebugOutputCallbacks::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    DbgPrint("Mask: 0x%lx\tOutput Begin:\n%s:Output End\n", Mask, Text);

    return S_OK;
}


//----------------------------------------------------------------------------
//
// OutputReader
//
// General DebugOutputCallback class to parse output.
//
//----------------------------------------------------------------------------

STDMETHODIMP
OutputReader::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    ULONG       TextLen = strlen(Text);

    if (BufferLeft < TextLen)
    {
        PSTR    NewBuffer;
        SIZE_T  NewBufferSize;

        if (hHeap == NULL)
        {
            hHeap = GetProcessHeap();
            if (hHeap == NULL) return S_FALSE;
        }

        // New length we need plus some extra space
        NewBufferSize = BufferSize + TextLen + 256;

        NewBuffer = (PSTR) ((Buffer == NULL) ?
                            HeapAlloc(hHeap, 0, NewBufferSize):
                            HeapReAlloc(hHeap, 0, Buffer, NewBufferSize));

        if (NewBuffer == NULL)
        {
            DbgPrint("Buffer alloc failed.\n");
            return E_OUTOFMEMORY;
        }

        // How much was really allocated?
        NewBufferSize = HeapSize(hHeap, 0, NewBuffer);

        // If this was the first alloc, initialize
        // buffer and account for terminating zero.
        if (Buffer == NULL)
        {
            NewBuffer[0] = '\0';
            BufferLeft = -1;
        }

        // Update buffer data
        Buffer = NewBuffer;
        BufferLeft += NewBufferSize - BufferSize;
        BufferSize = NewBufferSize;
    }

    // Append new text
    strcat(Buffer, Text);
    BufferLeft -= TextLen;

    return S_OK;
}


// Discard any text left unused by Parse
void
OutputReader::DiscardOutput()
{
    if (Buffer != NULL)
    {
        Buffer[0] = '\0';
        BufferLeft = BufferSize - 1;
    }
}


// Get a copy of the output buffer
HRESULT
OutputReader::GetOutputCopy(
    PSTR *Copy
    )
{
    if (Copy == NULL) return E_INVALIDARG;

    *Copy = NULL;

    if (Buffer == NULL) return S_OK;

    SIZE_T  BufferLength = BufferSize - BufferLeft;

    *Copy = (PSTR)HeapAlloc(hHeap, 0, BufferLength);

    if (*Copy != NULL)
    {
        RtlCopyMemory(*Copy, Buffer, BufferLength);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}


//----------------------------------------------------------------------------
//
// OutputParser
//
// General DebugOutputCallback class to parse output.
//
//----------------------------------------------------------------------------

HRESULT
OutputParser::ParseOutput(FLONG Flags)
{
    HRESULT hr;
    ULONG   TextRemainingIndex;

    if (Buffer == NULL)
    {
        return S_OK;
    }

    if (Flags & PARSE_OUTPUT_ALL)
    {
        UnparsedIndex = 0;
    }

    if ((hr = Parse(Buffer + UnparsedIndex, &TextRemainingIndex)) == S_OK)
    {
        UnparsedIndex += TextRemainingIndex;

        if (((Flags & PARSE_OUTPUT_NO_DISCARD) == 0) &&
            (UnparsedIndex > 0))
        {
            RtlMoveMemory(Buffer,
                          Buffer + UnparsedIndex,
                          BufferSize - UnparsedIndex - BufferLeft + 1);

            BufferLeft += UnparsedIndex;
            UnparsedIndex = 0;
        }
    }

    return hr;
}


void
OutputParser::DiscardOutput()
{
    OutputReader::DiscardOutput();
    UnparsedIndex = 0;
}


//----------------------------------------------------------------------------
//
// BasicOutputParser
//
// Basic DebugOutputCallback class to parse output looking for 
// string keys and subsequent values.
//
//----------------------------------------------------------------------------

HRESULT
BasicOutputParser::LookFor(
    PDEBUG_VALUE Value,
    PCSTR Key,
    ULONG Type,
    ULONG Radix
    )
{
    if ((1 > strlen(Key)) ||
        (strlen(Key) >= sizeof(Entries->Key)/sizeof(Entries->Key[0])))
    {
        return E_INVALIDARG;
    }

    if (NumEntries >= MaxEntries) return E_OUTOFMEMORY;

    Entries[NumEntries].Value = Value;
    strcpy(Entries[NumEntries].Key, Key);

    if (Value != NULL)
    {
        Value->Type = DEBUG_VALUE_INVALID;

        if (Radix == PARSER_UNSPECIFIED_RADIX)
        {
            // Set Radix to Hex since value is likely to be an address
            // Otherwise type a deafult of decimal.
            Radix = (Type == DEBUG_VALUE_INT64) ? 16 : 10;
        }

        Entries[NumEntries].Type = Type;
        Entries[NumEntries].Radix = Radix;
    }

    NumEntries++;

    return S_OK;
}

HRESULT
BasicOutputParser::Parse(
    IN PCSTR Text,
    OUT OPTIONAL PULONG RemainderIndex
    )
{
    HRESULT     hr = S_OK;
    PCSTR       pStrUnused = Text;
    PCSTR       pStr;
    ULONG       EvalLen;

//    DbgPrint("BasicOutputParser::Parse: Searching \"%s\"\n", pStrUnused);

    while (CurEntry < NumEntries)
    {
        pStr = strstr(pStrUnused, Entries[CurEntry].Key);
        if (pStr == NULL)
        {
            break;
        }

        pStr += strlen(Entries[CurEntry].Key);

        if (Entries[CurEntry].Value != NULL)
        {
            hr = Evaluate(Client,
                          pStr,
                          Entries[CurEntry].Type,
                          Entries[CurEntry].Radix,
                          Entries[CurEntry].Value,
                          &EvalLen);

            if (hr != S_OK)
            {
                DbgPrint("Evaluate returned HRESULT 0x%lx.\n", hr);
                break;
            }

//            DbgPrint("BasicOutputParser::Parse: Found 0x%I64x after \"%s\".\n", Entries[CurEntry].Value->I64, Entries[CurEntry].Key);

            pStr += EvalLen;
        }

        CurEntry++;
        pStrUnused = pStr;
    }

    if (RemainderIndex != NULL)
    {
        *RemainderIndex = (ULONG)(pStrUnused - Text);
    }

    return hr;
}


//----------------------------------------------------------------------------
//
// BitFieldParser
//
// DebugOutputCallback class to parse bitfield type output
//
//----------------------------------------------------------------------------

BitFieldParser::BitFieldParser(
    PDEBUG_CLIENT Client,
    BitFieldInfo *BFI
    ) :
    BitFieldReader(Client, 2)
{
    if (BFI != NULL &&
        BitFieldReader.LookFor(&BitPos, ": Pos ", DEBUG_VALUE_INT32) == S_OK &&
        BitFieldReader.LookFor(&Bits, ", ", DEBUG_VALUE_INT32) == S_OK)
    {
        BitField = BFI;
        BitField->Valid = FALSE;
        BitField->BitPos = 0;
        BitField->Bits = 0;
        BitField->Mask = 0;
    }
    else
    {
        BitField = NULL;
    }
}


HRESULT
BitFieldParser::Parse(
    IN PCSTR Text,
    OUT OPTIONAL PULONG RemainderIndex
    )
{
    PCSTR           pStrUnused = Text;
    ULONG           UnusedIndex = 0;
    PCSTR           pStrRemaining;
    BitFieldInfo    Field;

    do
    {
        if (BitFieldReader.Complete() == S_OK)
        {
            BitFieldReader.Relook();
        }

        BitFieldReader.Parse(pStrUnused, &UnusedIndex);
        pStrUnused += UnusedIndex;

        if (BitFieldReader.Complete() != S_OK)
        {
            break;
        }

        if (!BitField->Valid)
        {
            BitField->Valid = BitField->Compose(BitPos.I32, Bits.I32);
        }
        else
        {
            // Full extent of bit fields seen so far
            BitField->Bits = Bits.I32 + BitPos.I32 - BitField->BitPos;

            // Full mask of bit fields seen so far
            if (Field.Compose(BitPos.I32, Bits.I32))
            {
                BitField->Mask |= Field.Mask;
            }
        }

        // See if there is anything else we might want to parse.
        pStrRemaining = pStrUnused;
        while (isspace(*pStrRemaining) || *pStrRemaining == '\n')
        {
            pStrRemaining++;
        }
    } while (pStrRemaining != '\0');

    if (RemainderIndex != NULL)
    {
        *RemainderIndex = (ULONG)(pStrUnused - Text);
    }

    return S_OK;
}



//----------------------------------------------------------------------------
//
// OutputFilter
//
// DebugOutputCallback class to filter output
// by skipping/replacing lines.
//
//----------------------------------------------------------------------------

STDMETHODIMP
OutputFilter::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    return (Outputing) ?
        S_OK :
        OutputReader::Output(Mask, Text);
}


HRESULT
OutputFilter::Query(
    PCSTR Query,
    PDEBUG_VALUE Value,
    ULONG Type,
    ULONG Radix
    )
{
    if (Query == NULL) return E_INVALIDARG;

    if (Buffer == NULL) return S_FALSE;

    HRESULT hr;
    BasicOutputParser   Parser(Client, 1);

    if ((hr = Parser.LookFor(Value, Query, Type, Radix)) == S_OK &&
        (hr = Parser.Parse(Buffer, NULL)) == S_OK)
    {
        hr = Parser.Complete();
    }

    return hr;
}


OutputFilter::QuerySpec::QuerySpec(
    ULONG QueryFlags,
    PCSTR QueryText
    )
{
    Next = NULL;
    Flags = QueryFlags;
    QueryLen = (QueryText== NULL) ? 0 : strlen(QueryText);
    if (QueryLen)
    {
        Query = new CHAR[QueryLen+1];
        if (Query == NULL)
        {
            QueryLen = 0;
        }
        else
        {
            strcpy(Query, QueryText);
        }
    }
    else
    {
        Query = NULL;
    }
}


OutputFilter::ReplacementSpec::ReplacementSpec(
    ULONG QueryFlags,
    PCSTR QueryText,
    PCSTR ReplacementText
    ) : QuerySpec(QueryFlags, QueryText)
{
    ReplacementLen = (ReplacementText== NULL) ? 0 : strlen(ReplacementText);
    if (ReplacementLen)
    {
        Replacement = new CHAR[ReplacementLen+1];
        if (Replacement == NULL)
        {
            ReplacementLen = 0;
        }
        else
        {
            strcpy(Replacement, ReplacementText);
        }
    }
    else
    {
        Replacement = NULL;
    }
}


OutputFilter::QuerySpec **
OutputFilter::FindPrior(
    ULONG Flags,
    PCSTR Query,
    QuerySpec **List
    )
{
    QuerySpec **Prior = List;
    QuerySpec  *Next;

    for (Next = *Prior; Next != NULL; Next = Next->Next)
    {
        if (Flags > Next->Flags ||
            (Flags == Next->Flags &&
             strcmp(Query, Next->Query) >= 0))
        {
            break;
        }

        Prior = &Next->Next;
    }

    return Prior;
}


HRESULT
OutputFilter::Replace(
    ULONG Flags,
    PCSTR Query,
    PCSTR Replacement
    )
{
    if (Query == NULL ||
        (Flags & OUTFILTER_REPLACE_LINE) == 0 ||
        (Flags & OUTFILTER_REPLACE_LINE) == (OUTFILTER_REPLACE_BEFORE | OUTFILTER_REPLACE_AFTER))
    {
        return E_INVALIDARG;
    }

    // Don't support replacing one query each time in a single line.
    // This is ok if there can be no further replacements on a matching line.
    if (((Flags & (OUTFILTER_REPLACE_ONCE | OUTFILTER_QUERY_ONE_LINE)) ==
          (OUTFILTER_REPLACE_EVERY | OUTFILTER_QUERY_ONE_LINE)) &&
        !(Flags & (OUTFILTER_REPLACE_AFTER | OUTFILTER_REPLACE_NEXT_LINE)))
    {
        return E_NOTIMPL;
    }

    // Set priority to level 0 if not specified.
    if ((Flags & OUTFILTER_REPLACE_PRIORITY(7)) == 0)
    {
        Flags |= OUTFILTER_REPLACE_PRIORITY(0);
    }

    ReplacementSpec   **PriorNext;
    ReplacementSpec    *Next;
    ULONG               ReplacementLen;

    ReplacementLen = (Replacement == NULL) ? 0 : strlen(Replacement);

    PriorNext = (ReplacementSpec **)FindPrior(Flags, Query, (QuerySpec**)&ReplaceList);
    Next = *PriorNext;

    if (Next != NULL &&
        Flags == Next->Flags &&
        strcmp(Query, Next->Query) == 0)
    {
        if (ReplacementLen == 0)
        {
            if (Next->Replacement != NULL)
            {
                Next->Replacement[0] = '\0';
            }
        }
        else
        {
            if (ReplacementLen > Next->ReplacementLen)
            {
                PSTR NewReplacement = new CHAR[ReplacementLen+1];

                if (NewReplacement == NULL) return E_OUTOFMEMORY;

                if (Next->Replacement != NULL)
                {
                    delete[] Next->Replacement;
                    Next->Replacement = NewReplacement;
                }
            }
            strcpy(Next->Replacement, Replacement);
        }
        Next->ReplacementLen = ReplacementLen;
    }
    else
    {
        ReplacementSpec    *NewQuery;

        NewQuery = new ReplacementSpec(Flags, Query, Replacement);

        if (NewQuery == NULL) return E_OUTOFMEMORY;

        if (NewQuery->Query == NULL ||
            (ReplacementLen && NewQuery->Replacement == NULL))
        {
            delete NewQuery;
            return E_OUTOFMEMORY;
        }

        NewQuery->Next = Next;
        *PriorNext = NewQuery;
    }

    return S_OK;
}

HRESULT
OutputFilter::Skip(
    ULONG Flags,
    PCSTR Query
    )
{
    if (Query == NULL)
    {
        return E_INVALIDARG;
    }

    QuerySpec **PriorNext;
    QuerySpec  *Next;

    PriorNext = FindPrior(Flags, Query, &SkipList);
    Next = *PriorNext;

    if (Next == NULL ||
        Flags != Next->Flags ||
        strcmp(Query, Next->Query) != 0)
    {
        QuerySpec  *NewQuery;

        NewQuery = new QuerySpec(Flags, Query);

        if (NewQuery == NULL) return E_OUTOFMEMORY;

        if (NewQuery->Query == NULL)
        {
            delete NewQuery;
            return E_OUTOFMEMORY;
        }

        NewQuery->Next = Next;
        *PriorNext = NewQuery;
    }

    return S_OK;
}

OutputFilter::QuerySpec *
OutputFilter::FindMatch(
    PCSTR Text,
    QuerySpec *List,
    ULONG Start,
    ULONG Flags,
    PULONG MatchPos
    )
{
    ULONG       Remaining = strlen(Text);
    PCSTR       Search;
    QuerySpec  *Match;

    if (MatchPos != NULL) *MatchPos = 0;

    if (List == NULL ||
        Text == NULL ||
        (Remaining = strlen(Text)) <= Start) return NULL;

    Search = Text + Start;
    Remaining -= Start;

    do
    {
        for (Match = List; Match != NULL; Match = Match->Next)
        {
            if (Match->Flags & OUTFILTER_QUERY_ENABLED &&
                Remaining >= Match->QueryLen &&
                strncmp(Search, Match->Query, Match->QueryLen) == 0)
            {
                if (Match->Flags & OUTFILTER_QUERY_WHOLE_WORD)
                {
                    if ((Search > Text && iscsym(Search[-1])) ||
                        iscsym(Search[Match->QueryLen]))
                    {
                        continue;
                    }
                }
/*
                if (Match->Flags & OUTFILTER_QUERY_ONE_LINE)
                {
                    Match->Flags &= ~OUTFILTER_QUERY_ENABLED;
                }
*/
                Match->Flags |= OUTFILTER_QUERY_HIT;

                if (MatchPos != NULL)
                {
                    *MatchPos = (ULONG)(Search - Text);
                }

                return Match;
            }
        }

        Search++;
        Remaining--;
    } while (Remaining &&
             !(Flags & OUTFILTER_FINDMATCH_AT_START));

    return NULL;
}


HRESULT
OutputFilter::OutputText(
    OutputControl *OutCtl,
    ULONG Mask
    )
{
    // 1. Get line of read buffer
    // 2. Search for a skip query match
    // 3. Search for any/all replace query matches

    if (Buffer == NULL) return S_OK;

    HRESULT         hr;
    PSTR            pNextLine;
    CHAR            EndChar;
    PSTR            pFilter;

    if (OutCtl == NULL)
    {
        OutCtl = new OutputControl(Client);

        if (OutCtl == NULL)
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        OutCtl->AddRef();
    }

    // Can we quickly just output all text?
    if (SkipList == NULL && ReplaceList == NULL)
    {
        hr = OutCtl->Output(Mask, Buffer);
        OutCtl->Release();
        return hr;
    }

    Outputing = TRUE;

    // Enable all queries and reset hit markings.
    QuerySpec *Query;
    for (Query = SkipList; Query != NULL; Query = Query->Next)
    {
        Query->Flags = (Query->Flags & ~OUTFILTER_QUERY_HIT) | OUTFILTER_QUERY_ENABLED;
    }
    for (Query = (QuerySpec *)ReplaceList; Query != NULL; Query = Query->Next)
    {
        Query->Flags = (Query->Flags & ~OUTFILTER_QUERY_HIT) | OUTFILTER_QUERY_ENABLED;
    }

    hr = S_OK;
    pNextLine = Buffer;

    while (hr == S_OK && *pNextLine != '\0')
    {
        if (OutCtl->GetInterrupt() == S_OK)
        {
            OutCtl->SetInterrupt(DEBUG_INTERRUPT_PASSIVE);
            break;
        }

        pFilter = pNextLine;

        // Find end of this line
        while ((*pNextLine != '\0') &&
               (*pNextLine != '\n') &&
               (*pNextLine != '\r') &&
               (*pNextLine != '\f'))
        {
            pNextLine++;
        }

        EndChar = *pNextLine;
        *pNextLine = '\0';

        // Search for a skip match
        Query = FindMatch(pFilter, SkipList);

        if (Query != NULL)
        {
            DbgPrint("Skipping line with %s.\n", Query->Query);

            if (Query->Flags & OUTFILTER_QUERY_ONE_LINE)
            {
                Query->Flags &= ~OUTFILTER_QUERY_ENABLED;
            }

            *pNextLine = EndChar;
            if (EndChar != '\0')
            {
                pNextLine++;
            }
        }
        else
        {
            PSTR                pFilterLine = pFilter;
            ULONG               MatchPos = 0;
            ReplacementSpec    *Replace;

            for (Replace = ReplaceList;
                 Replace != NULL;
                 Replace = (ReplacementSpec *)Replace->Next)
            {
                if (!(Replace->Flags & (OUTFILTER_QUERY_ONE_LINE | OUTFILTER_QUERY_ENABLED)))
                {
                    Replace->Flags |= OUTFILTER_QUERY_ENABLED;
                }
            }

            while (pFilter < pNextLine &&
                   (Replace = (ReplacementSpec *)FindMatch(pFilterLine,
                                                           ReplaceList,
                                                           MatchPos,
                                                           OUTFILTER_FINDMATCH_DEFAULT,
                                                           &MatchPos)) != NULL)
            {
                if (Replace->Flags & (OUTFILTER_QUERY_ONE_LINE | OUTFILTER_REPLACE_ONCE))
                {
                    Replace->Flags &= ~OUTFILTER_QUERY_ENABLED;
                }

                if (Replace->Flags & OUTFILTER_REPLACE_BEFORE)
                {
                    if (Replace->ReplacementLen)
                    {
                        hr = OutCtl->Output(Mask, "%s", Replace->Replacement);
                    }

                    pFilter = pFilterLine + MatchPos;

                    if (!(Replace->Flags & OUTFILTER_REPLACE_NEXT_LINE) &&
                        !(Replace->Flags & OUTFILTER_REPLACE_ONCE) &&
                        !(Replace->Flags & OUTFILTER_REPLACE_TO_END))
                    {
                        // This replacement leaves the query text intact.
                        // Hence this query will keep matching; so, look for
                        // another query which will actually modify the
                        // query text or the text following it.
                        Replace = (ReplacementSpec *)Replace->Next;

                        while (Replace != NULL &&
                               Replace->Flags & OUTFILTER_REPLACE_BEFORE)
                        {
                            Replace = (ReplacementSpec *)Replace->Next;
                        }

                        Replace = (ReplacementSpec *)
                                    FindMatch(pFilterLine,
                                              Replace,
                                              MatchPos,
                                              OUTFILTER_FINDMATCH_AT_START |
                                              OUTFILTER_FINDMATCH_NO_MARK);

                        if (Replace == NULL)
                        {
                            // Advance MatchPos, but not filtered text.
                            // This unfiltered text may yet be replaced.
                            MatchPos++;
                            continue;
                        }
                    }
                }

                if (!(Replace->Flags & OUTFILTER_REPLACE_BEFORE))
                {
                    CHAR    TempHolder;
                    ULONG   BeginReplacePos = MatchPos;

                    if (!(Replace->Flags & OUTFILTER_REPLACE_THIS))
                    {
                        BeginReplacePos += Replace->QueryLen;
                    }

                    TempHolder = pFilterLine[BeginReplacePos];
                    pFilterLine[BeginReplacePos] = '\0';

                    if ((hr = OutCtl->Output(Mask, "%s", pFilter)) == S_OK &&
                        Replace->ReplacementLen)
                    {
                        hr = OutCtl->Output(Mask, "%s", Replace->Replacement);
                    }

                    pFilterLine[BeginReplacePos] = TempHolder;
                }

                if (Replace->Flags & OUTFILTER_REPLACE_AFTER)
                {
                    pFilter = pNextLine;
                }
                else
                {
                    if (Replace->Flags & OUTFILTER_REPLACE_THIS)
                    {
                        MatchPos += Replace->QueryLen;
                    }
                    pFilter = pFilterLine + MatchPos;
                }

                if (Replace->Flags & OUTFILTER_REPLACE_NEXT_LINE) break;
            }

            *pNextLine = EndChar;
            if (EndChar != '\0')
            {
                pNextLine++;

                // Include any following zero length lines
                while ((*pNextLine == '\n') ||
                       (*pNextLine == '\r') ||
                       (*pNextLine == '\f'))
                {
                    pNextLine++;
                }

                EndChar = *pNextLine;
                *pNextLine = '\0';
            }

            // Output remaining portion of filtered line
            hr = OutCtl->Output(Mask, pFilter);

            if (EndChar != '\0')
            {
                *pNextLine = EndChar;
            }
        }

    }

    Outputing = FALSE;

    OutCtl->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\process.cxx ===
/******************************Module*Header*******************************\
* Module Name: process.cxx
*
*   Support for dteb and dpeb APIs
*
* Created: 12-Mar-1996
* Author: Mark Enstrom [marke]
*
* Copyright (c) 1996-2000 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"


HRESULT
GetProcessField(
    IN PDEBUG_CLIENT Client,
    IN OUT PULONG64 pProcessAddress,
    IN PCSTR FieldPath,
    OUT PDEBUG_VALUE FieldValue,
    IN ULONG DesiredType
    )
{
    HRESULT                 hr;
    OutputControl           OutCtl(Client);
    PDEBUG_SYSTEM_OBJECTS   System;
    PDEBUG_SYMBOLS          Symbols;

    ULONG64 ProcessAddress = (pProcessAddress != NULL) ? *pProcessAddress : CURRENT_PROCESS_ADDRESS;

    if (Client == NULL || FieldPath == NULL) return E_INVALIDARG;

    PCSTR Field = FieldPath;
    PCSTR Dot;

    // Check FieldPath's basic validity
    if (!iscsymf(*Field)) return E_INVALIDARG;

    while ((Dot = strchr(Field, '.')) != NULL)
    {
        Field = Dot + 1;
        if (!iscsymf(*Field)) return E_INVALIDARG;
    }

    // Query interfaces needed
    if ((hr = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                     (void **)&System)) != S_OK)
    {
        return hr;
    }

    if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                     (void **)&Symbols)) != S_OK)
    {
        System->Release();
        return hr;
    }

    if (ProcessAddress == CURRENT_PROCESS_ADDRESS)
    {
        hr = System->GetCurrentProcessDataOffset(&ProcessAddress);

        if (hr == S_OK)
        {
            if (ProcessAddress != NULL) *pProcessAddress = ProcessAddress;
        }
        else
        {
            OutCtl.OutErr("GetCurrentProcess returned %s.\n", pszHRESULT(hr));
        }
    }

    if (hr == S_OK)
    {
        TypeOutputParser    TypeParser(Client);
        OutputState         OutState(Client, FALSE);
        OutputControl       OutCtlToParser;
        ULONG               ProcessTypeId;
        ULONG64             NTModule;
        DEBUG_VALUE         ProcessObject;
        DEBUG_VALUE         ObjectType;

        if ((hr = OutState.Setup(0, &TypeParser)) == S_OK &&
            (hr = OutCtlToParser.SetControl(DEBUG_OUTCTL_THIS_CLIENT |
                                            DEBUG_OUTCTL_NOT_LOGGED |
                                            DEBUG_OUTCTL_OVERRIDE_MASK,
                                            OutState.Client)) == S_OK &&
            (hr = Symbols->GetSymbolTypeId("nt!_EPROCESS", &ProcessTypeId, &NTModule)) == S_OK)
        {
            TypeOutputDumper    TypeReader(OutState.Client, &OutCtlToParser);

            if ((hr = OutState.OutputTypeVirtual(0, "nt!KOBJECTS", 0)) == S_OK)
            {
                hr = TypeParser.Get(&ProcessObject, "ProcessObject", DEBUG_VALUE_INT64);
            }

            if (hr != S_OK)
            {
                OutCtl.OutWarn("enum nt!KOBJECTS's ProcessObject value wasn't found.\n");
                ProcessObject.I64 = 3;   // From ke.h
            }

            TypeParser.DiscardOutput();

            TypeReader.IncludeMarked();
            TypeReader.MarkField("Pcb.Header.Type");
            TypeReader.MarkField(FieldPath);

            if ((hr = TypeReader.OutputVirtual(NTModule, ProcessTypeId, ProcessAddress)) == S_OK)
            {
                // Make sure this object is a process
                if ((hr = TypeParser.Get(&ObjectType, "Type", DEBUG_VALUE_INT64)) == S_OK &&
                    ObjectType.I64 == ProcessObject.I64)
                {
                    OutCtl.OutVerb("  Process Addr = 0x%p\n", ProcessAddress);

                    hr = TypeParser.Get(FieldValue, Field, DesiredType);
                }
                else
                {
                    if (hr == S_OK)
                    {
                        OutCtl.OutErr("0x%p is not a process object.\n", ProcessAddress);
                        hr = S_FALSE;
                    }
                    else
                    {
                        OutCtl.OutErr("Unable to find 'Type' value from nt!_EPROCESS Pcb.Header.\n");
                    }
                }
            }
            else
            {
                OutCtl.OutErr("Unable to get process contents at 0x%p.\n", ProcessAddress);
            }
        }
        else
        {
            OutCtl.OutErr("Unable to prepare nt!_EPROCESS type read.\n");
        }
    }

    Symbols->Release();
    System->Release();

    return hr;
}


HRESULT
GetThreadField(
    IN PDEBUG_CLIENT Client,
    IN OUT PULONG64 pThreadAddress,
    IN PCSTR FieldPath,
    OUT PDEBUG_VALUE FieldValue,
    IN ULONG DesiredType
    )
{
    HRESULT                 hr;
    OutputControl           OutCtl(Client);
    PDEBUG_SYSTEM_OBJECTS   System;
    PDEBUG_SYMBOLS          Symbols;

    ULONG64 ThreadAddress = (pThreadAddress != NULL) ? *pThreadAddress : CURRENT_THREAD_ADDRESS;

    if (Client == NULL || FieldPath == NULL) return E_INVALIDARG;

    PCSTR Field = FieldPath;
    PCSTR Dot;

    // Check FieldPath's basic validity
    if (!iscsymf(*Field)) return E_INVALIDARG;

    while ((Dot = strchr(Field, '.')) != NULL)
    {
        Field = Dot + 1;
        if (!iscsymf(*Field)) return E_INVALIDARG;
    }

    // Query interfaces needed
    if ((hr = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                     (void **)&System)) != S_OK)
    {
        return hr;
    }

    if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                     (void **)&Symbols)) != S_OK)
    {
        System->Release();
        return hr;
    }

    if (ThreadAddress == CURRENT_THREAD_ADDRESS)
    {
        hr = System->GetCurrentThreadDataOffset(&ThreadAddress);

        if (hr == S_OK && ThreadAddress != NULL)
            *pThreadAddress = ThreadAddress;
    }

    if (hr == S_OK)
    {
        TypeOutputParser    TypeParser(Client);
        OutputState         OutState(Client, FALSE);
        OutputControl       OutCtlToParser;
        ULONG               ThreadTypeId;
        ULONG64             NTModule;
        DEBUG_VALUE         ThreadObject;
        DEBUG_VALUE         ObjectType;

        if ((hr = OutState.Setup(0, &TypeParser)) == S_OK &&
            (hr = OutCtlToParser.SetControl(DEBUG_OUTCTL_THIS_CLIENT |
                                            DEBUG_OUTCTL_NOT_LOGGED |
                                            DEBUG_OUTCTL_OVERRIDE_MASK,
                                            OutState.Client)) == S_OK &&
            (hr = Symbols->GetSymbolTypeId("nt!_ETHREAD", &ThreadTypeId, &NTModule)) == S_OK)
        {
            TypeOutputDumper    TypeReader(OutState.Client, &OutCtlToParser);

            if ((hr = OutState.OutputTypeVirtual(0, "nt!KOBJECTS", 0)) == S_OK)
            {
                hr = TypeParser.Get(&ThreadObject, "ThreadObject", DEBUG_VALUE_INT64);
            }

            if (hr != S_OK)
            {
                OutCtl.OutWarn("enum nt!KOBJECTS's ThreadObject value wasn't found.\n");
                ThreadObject.I64 = 6;   // From ke.h
            }

            TypeParser.DiscardOutput();

            TypeReader.IncludeMarked();
            TypeReader.MarkField("Tcb.Header.Type");
            TypeReader.MarkField(FieldPath);

            if ((hr = TypeReader.OutputVirtual(NTModule, ThreadTypeId, ThreadAddress)) == S_OK)
            {
                // Make sure this object is a thread
                if ((hr = TypeParser.Get(&ObjectType, "Type", DEBUG_VALUE_INT64)) == S_OK &&
                    ObjectType.I64 == ThreadObject.I64)
                {
                    OutCtl.OutVerb("  Thread Addr = 0x%p\n", ThreadAddress);

                    hr = TypeParser.Get(FieldValue, Field, DesiredType);
                }
                else
                {
                    if (hr == S_OK)
                    {
                        OutCtl.OutErr("0x%p is not a thread object.\n", ThreadAddress);
                        hr = S_FALSE;
                    }
                    else
                    {
                        OutCtl.OutErr("Unable to find 'Type' value from nt!_ETHREAD Tcb.Header.\n");
                    }
                }
            }
            else
            {
                OutCtl.OutErr("Unable to get thread contents at 0x%p.\n", ThreadAddress);
            }
        }
        else
        {
            OutCtl.OutErr("Unable to prepare nt!_ETHREAD type read.\n");
        }
    }

    Symbols->Release();
    System->Release();

    return hr;
}


HRESULT
GetCurrentProcessor(
    IN PDEBUG_CLIENT Client,
    OPTIONAL OUT PULONG pProcessor,
    OPTIONAL OUT PHANDLE phCurrentThread
    )
{
    HRESULT                 hr = E_INVALIDARG;
    PDEBUG_SYSTEM_OBJECTS   DebugSystem;
    ULONG64                 hCurrentThread;

    if (phCurrentThread != NULL) *phCurrentThread = NULL;
    if (pProcessor != NULL) *pProcessor = 0;

    if (Client == NULL ||
        (hr = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                     (void **)&DebugSystem)) != S_OK)
    {
        return hr;
    }

    hr = DebugSystem->GetCurrentThreadHandle(&hCurrentThread);

    if (hr == S_OK)
    {
        if (phCurrentThread != NULL)
        { 
            *phCurrentThread = (HANDLE) hCurrentThread;
        }

        if (pProcessor != NULL)
        {
            *pProcessor = (ULONG) hCurrentThread - 1;
        }
    }

    DebugSystem->Release();

    return hr;
}


/******************************Public*Routine******************************\
*   DumpTebBatch
*
*   Dumps GDI TEB batch info
*
* Arguments:
*
*   TebAddress - address of Teb
*
* Return Value:
*
*   None
*
* History:
*
*    20-Sep-2000 -by- Jason Hartman [jasonha]
*
\**************************************************************************/

// from hmgshare.h
enum _BATCH_TYPE
{
    BatchTypePatBlt,
    BatchTypePolyPatBlt,
    BatchTypeTextOut,
    BatchTypeTextOutRect,
    BatchTypeSetBrushOrg,
    BatchTypeSelectClip,
    BatchTypeSelectFont,
    BatchTypeDeleteBrush,
    BatchTypeDeleteRegion
};

VOID
DumpTebBatch(
    PDEBUG_CLIENT Client,
    ULONG64 TebAddress
    )
{
    FIELD_INFO TebBatchFields[] = {
        { DbgStr("GdiBatchCount"),      NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("GdiTebBatch.Offset"), NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("GdiTebBatch.HDC"),    NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("GdiTebBatch.Buffer"), NULL,  0, DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL},
    };
    SYM_DUMP_PARAM TebBatchSym = {
       sizeof (SYM_DUMP_PARAM), DbgStr(GDIType(_TEB)), 
       0,
       TebAddress,
       NULL, NULL, NULL,
       sizeof(TebBatchFields)/sizeof(TebBatchFields[0]), TebBatchFields
    };
    ULONG   BatchCount;
    BOOL    OldBatch = FALSE;
    ULONG64 BatchEntryAddress;
    ULONG64 BatchBufferLength = 0;
    ULONG64 BatchBufferEnd;
    ULONG   SmallestBatchEntrySize = max(1, GetTypeSize(GDIType(BATCHCOMMAND)));
    USHORT  BatchEntryLength;
    USHORT  BatchEntryType;
    ULONG   error;
    PrepareCallbacks(FALSE, 0);

    ExtOut("GDI Batch Info from Teb %p:\n", TebAddress);

    error = Ioctl(IG_DUMP_SYMBOL_INFO, &TebBatchSym, TebBatchSym.size);

    if (error)
    {
        ExtErr("Ioctl returned %s\n", pszWinDbgError(error));
    }
    else
    {
        BatchCount = (ULONG)TebBatchFields[0].address;
        BatchEntryAddress = TebBatchFields[3].address;

        if (BatchCount == 0)
        {
            ExtOut(" ** Dumping old batch entries **\n");
            OldBatch = TRUE;
        }

        ExtOut("First batch entry @ %p.\n", BatchEntryAddress);

        GetArrayDimensions(Client, "_GDI_TEB_BATCH", "Buffer", NULL, (ULONG *)&BatchBufferLength, NULL);

        if (TebBatchFields[1].address && TebBatchFields[1].address < BatchBufferLength)
        {
            BatchBufferLength = TebBatchFields[1].address;
        }

        BatchBufferEnd = BatchEntryAddress + BatchBufferLength;

        while ((OldBatch || BatchCount > 0) && BatchEntryAddress < BatchBufferEnd)
        {
            error = (ULONG)InitTypeRead(BatchEntryAddress, win32k!BATCHCOMMAND);

            if (error)
            {
                ExtErr("InitTypeRead(%p, %s) returned %s.\n", BatchEntryAddress, GDIType(BATCHCOMMAND), pszWinDbgError(error));
                break;
            }

            BatchEntryLength = (USHORT)ReadField(Length);

            if (BatchEntryAddress + BatchEntryLength > BatchBufferEnd)
            {
                ExtOut("Invalid batch entry - length is too long.\n");
                break;
            }

            if (BatchEntryLength < SmallestBatchEntrySize)
            {
                ExtOut("Invalid batch entry - length is too small.\n");
                break;
            }

            BatchEntryType = (USHORT)ReadField(Type);

            switch (BatchEntryType)
            {
                case BatchTypePatBlt:
                    {
                        ExtOut("  BatchTypePatBlt\n");
                    }
                    break;

                case BatchTypePolyPatBlt:
                    {
                        ExtOut("  BatchTypePolyPatBlt\n");
                    }
                    break;

                case BatchTypeTextOut:
                    {
                        ExtOut("  BatchTypeTextOut\n");
                    }
                    break;

                case BatchTypeTextOutRect:
                    {
                        ExtOut("  BatchTypeTextOutRect\n");
                    }
                    break;

                case BatchTypeSetBrushOrg:
                    {
                        ExtOut("  BatchTypeSetBrushOrg\n");
                    }
                    break;

                case BatchTypeSelectClip:
                    {
                        ExtOut("  BatchTypeSelectClip\n");
                    }
                    break;

                case BatchTypeSelectFont:
                    {
                        ExtOut("  BatchTypeSelectFont\n");
                    }
                    break;

                case BatchTypeDeleteBrush:
                    {
                        ExtOut("  BatchTypeDeleteBrush\n");
                    }
                    break;

                case BatchTypeDeleteRegion:
                    {
                        ExtOut("  BatchTypeDeleteRegion\n");
                    }
                    break;

                default:
                    ExtOut("  BatchType %hu is not recognized.\n", BatchEntryType);
            }

            BatchCount--;
            BatchEntryAddress += (ULONG64)BatchEntryLength;
        }

        if (!OldBatch && BatchCount)
        {
            ExtOut("Batch may be invalid %lu entries unchecked.\n", BatchCount);
        }
    }
#if 0
    if (istatus)
    {
        dprintf ("\nGDI Batch count = %li\n",pteb->GdiBatchCount);

        if (pteb->GdiBatchCount > 0)
        {
            ULONG index;
            PBATCHCOMMAND pBatch = (PBATCHCOMMAND)&pteb->GdiTebBatch.Buffer[0];

            dprintf ("\nGDI Batch HDC   = 0x%lx\n",pteb->GdiTebBatch.HDC);
            dprintf ("\nGDI Batch offet = 0x%lx\n",pteb->GdiTebBatch.Offset);

            for (index=pteb->GdiBatchCount;index>0;index--)
            {

                dprintf("-----------------------------------------------------\n");
                switch (pBatch->Type)
                {
                case BatchTypePatBlt:
                    {
                        PBATCHPATBLT pPatblt = (PBATCHPATBLT)pBatch;

                        dprintf("Patblt: length  = 0x%lx\n",pPatblt->Length);
                        dprintf("Patblt: x       = 0x%lx\n",pPatblt->x);
                        dprintf("Patblt: y       = 0x%lx\n",pPatblt->y);
                        dprintf("Patblt: cx      = 0x%lx\n",pPatblt->cx);
                        dprintf("Patblt: cy      = 0x%lx\n",pPatblt->cy);
                        dprintf("Patblt: hbr     = 0x%lx\n",pPatblt->hbr);
                        dprintf("Patblt: rop4    = 0x%lx\n",pPatblt->rop4);
                        dprintf("Patblt: textclr = 0x%lx\n",pPatblt->TextColor);
                        dprintf("Patblt: backclr = 0x%lx\n",pPatblt->BackColor);
                    }
                    break;

                case BatchTypePolyPatBlt:
                    {
                        PBATCHPOLYPATBLT pPatblt = (PBATCHPOLYPATBLT)pBatch;
                        PPOLYPATBLT ppoly = (PPOLYPATBLT)(&pPatblt->ulBuffer[0]);
                        ULONG Count = pPatblt->Count;

                        dprintf("PolyPatblt: length  = 0x%lx\n",pPatblt->Length);
                        dprintf("Patblt: Count       = 0x%lx\n",pPatblt->Count);
                        dprintf("Patblt: Mode        = 0x%lx\n",pPatblt->Mode);
                        dprintf("Patblt: rop4        = 0x%lx\n",pPatblt->rop4);
                        dprintf("Patblt: textclr     = 0x%lx\n",pPatblt->TextColor);
                        dprintf("Patblt: backclr     = 0x%lx\n",pPatblt->BackColor);

                        while (Count--)
                        {
                            dprintf("\n");
                            dprintf("\t x               = 0x%lx\n",ppoly->x);
                            dprintf("\t y               = 0x%lx\n",ppoly->y);
                            dprintf("\t cx              = 0x%lx\n",ppoly->cx);
                            dprintf("\t cy              = 0x%lx\n",ppoly->cy);
                            dprintf("\t hbr             = 0x%lx\n",ppoly->BrClr.hbr);
                            ppoly++;
                        }
                    }
                    break;

                case BatchTypeTextOut:
                    {
                        PBATCHTEXTOUT pText = (PBATCHTEXTOUT)pBatch;
                        PWCHAR pwchar = (PWCHAR)(&pText->ulBuffer[0]);
                        PLONG  pdx    = (PLONG)(&pText->ulBuffer[pText->PdxOffset]);

                        dprintf("Textout: length      = 0x%lx\n",pText->Length);
                        dprintf("Textout: TextColor   = 0x%lx\n",pText->TextColor);
                        dprintf("Textout: BackColor   = 0x%lx\n",pText->BackColor);
                        dprintf("Textout: BackMode    = 0x%lx\n",pText->BackMode);
                        dprintf("Textout: x           = 0x%lx\n",pText->x);
                        dprintf("Textout: y           = 0x%lx\n",pText->y);
                        dprintf("Textout: fl          = 0x%lx\n",pText->fl);
                        dprintf("Textout: rcl.left    = 0x%lx\n",pText->rcl.left);
                        dprintf("Textout: rcl.top     = 0x%lx\n",pText->rcl.top);
                        dprintf("Textout: rcl.right   = 0x%lx\n",pText->rcl.right);
                        dprintf("Textout: rcl.bottom  = 0x%lx\n",pText->rcl.bottom);
                        dprintf("Textout: dwCodePage  = 0x%lx\n",pText->dwCodePage);
                        dprintf("Textout: cChar       = 0x%lx\n",pText->cChar);
                        dprintf("Textout: PdxOffset   = 0x%lx\n",pText->PdxOffset);

                        if (pText->cChar != 0)
                        {
                            dprintf("\t wchar array\n");
                            dprintf("\t\t");

                            ULONG ix = pText->cChar;
                            while (ix--)
                            {
                                dprintf("%x ",*pwchar++);
                            }
                            dprintf("\n");

                            if (pText->PdxOffset != 0)
                            {
                                dprintf("\t pdx array\n");
                                dprintf("\t\t");

                                ULONG ix = pText->cChar;
                                while (ix--)
                                {
                                    dprintf("%li ",*pdx++);
                                }
                                dprintf("\n");
                            }
                        }
                    }
                    break;

                case BatchTypeTextOutRect:
                    {
                        PBATCHTEXTOUTRECT pText = (PBATCHTEXTOUTRECT)pBatch;

                        dprintf("TextoutRect: length      = 0x%lx\n",pText->Length);
                        dprintf("TextoutRect: BackColor   = 0x%lx\n",pText->BackColor);
                        dprintf("TextoutRect: fl          = 0x%lx\n",pText->fl);
                        dprintf("TextoutRect: rcl.left    = 0x%lx\n",pText->rcl.left);
                        dprintf("TextoutRect: rcl.top     = 0x%lx\n",pText->rcl.top);
                        dprintf("TextoutRect: rcl.right   = 0x%lx\n",pText->rcl.right);
                        dprintf("TextoutRect: rcl.bottom  = 0x%lx\n",pText->rcl.bottom);
                    }
                    break;

                case BatchTypeSetBrushOrg:
                    {
                        PBATCHSETBRUSHORG pOrg = (PBATCHSETBRUSHORG)pBatch;

                        dprintf("SetBrushOrg: length      = 0x%lx\n",pOrg->Length);
                        dprintf("SetBrushOrg: x           = 0x%lx\n",pOrg->x);
                        dprintf("SetBrushOrg: y           = 0x%lx\n",pOrg->y);
                    }
                    break;

                case BatchTypeSelectClip:
                    {
                        PBATCHSETBRUSHORG pOrg = (PBATCHSETBRUSHORG)pBatch;

                        dprintf("SetBrushOrg: length      = 0x%lx\n",pOrg->Length);
                        dprintf("SetBrushOrg: x           = 0x%lx\n",pOrg->x);
                        dprintf("SetBrushOrg: y           = 0x%lx\n",pOrg->y);
                    }
                    break;


                case BatchTypeDeleteBrush:
                    {
                        PBATCHDELETEBRUSH pbr = (PBATCHDELETEBRUSH)pBatch;

                        dprintf("DeleteBrush: length      = 0x%lx\n",pbr->Length);
                        dprintf("DeleteBrush: hbrush      = 0x%lx\n",pbr->hbrush);
                    }
                    break;

                case BatchTypeDeleteRegion:
                    {
                        PBATCHDELETEREGION prg = (PBATCHDELETEREGION)pBatch;

                        dprintf("DeleteRegion: length      = 0x%lx\n",prg->Length);
                        dprintf("DeleteRegion: hregion     = 0x%lx\n",prg->hregion);
                    }
                    break;
                }

                pBatch = (PBATCHCOMMAND)((PBYTE)pBatch + pBatch->Length);
            }
        }
    }
    else
    {
        dprintf("Error reading TEB contents\n");
    }
#endif  // DOES NOT SUPPORT API64
}


/******************************Public*Routine******************************\
* batch
*
*  Lists a threads batched GDI commands
\**************************************************************************/

DECLARE_API( batch )
{
    dprintf("Extension 'batch' is not fully implemented.\n");
    DEBUG_VALUE DebugValue;
    ULONG64 TebAddress = -1;
    BOOL    bShowHelp = FALSE;
    
    INIT_API();

    while (*args && isspace(*args)) args++;
    if (*args)
    {
        if (args[0] == '-')
        {
            if (args[1]=='t' && isspace(args[2]))
            {
                ULONG64 ThreadAddress;

                args += 2;
                while (*args && isspace(*args)) args++;

                if (*args && 
                    (g_pExtControl->Evaluate(args,
                                             DEBUG_VALUE_INT64,
                                             &DebugValue,
                                             NULL) != S_OK)
                    )
                {
                    ExtErr("Invalid arguments: %s\n", args);
                    bShowHelp = TRUE;
                }
                else
                {
                    ThreadAddress = DebugValue.I64;
                    GetThreadField(Client, &ThreadAddress, "Tcb.Teb", 
                                   &DebugValue, DEBUG_VALUE_INT64);
                    TebAddress = DebugValue.I64;
                }
            }
            else
            {
                if (args[1]!='?')
                    ExtErr("Invalid arguments: %s\n", args);
                bShowHelp = TRUE;
            }
        }
        else
        {
            if (S_OK != g_pExtControl->Evaluate(args, DEBUG_VALUE_INT64, &DebugValue, NULL))
            {
                ExtErr("Couldn't evaluate: %s\n", args);
                EXIT_API(S_OK);
            }

            TebAddress = DebugValue.I64;
        }
    }


    if (!bShowHelp)
    {
        if (TebAddress == (ULONG64)-1)
        {
            g_pExtSystem->GetCurrentThreadTeb(&TebAddress);
        }

        ExtVerb("  Teb = %p\n", TebAddress);

        if (TebAddress)
        {
            DumpTebBatch(Client, TebAddress);
        }
        else
        {
            ExtErr("NULL Teb.\n");
        }
    }

    if (bShowHelp)
    {
        ExtOut("Usage: batch [-?] [TEB | -t Thread]\n");
        ExtOut("   If TEB and Thread are omitted, defaults to the current thread\n");
    }

    EXIT_API(S_OK);
}


/******************************Public*Routine******************************\
* dpeb
*
*   Dump gdi structure in PEB
*
* Arguments:
*
*    pPEB
*
* Return Value:
*
*    None
*
* History:
*
*    6-Mar-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

#if 0   // DOES NOT SUPPORT API64
VOID
GdiDPEB(
    PPEB        ppebIn,
    PW32PROCESS pw32process,
    BOOL        bw32
    )
{
    BYTE  lpeb[4096];
    BYTE  lw32proc[sizeof(W32PROCESS)];
    PPEB  ppeb = (PPEB)&lpeb[0];
    PW32PROCESS pw32 = (PW32PROCESS)&lw32proc[0];
    PGDIHANDLECACHE pCache = (PGDIHANDLECACHE)ppeb->GdiHandleBuffer;

    int iStatus = move2(lpeb,ppebIn,sizeof(PEB));

    if (iStatus)
    {
        dprintf("\nDump PEB  0x%lx\n",ppebIn);
        dprintf("GdiSharedHandleTable = 0x%lx\n",ppeb->GdiSharedHandleTable);
        dprintf("GdiDCAttributeList   = 0x%lx\n",ppeb->GdiDCAttributeList);
        dprintf("\n");

        dprintf("GDI Cached brush  handles = %li\n",pCache->ulNumHandles[BrushHandle]);
        dprintf("GDI Cached pen    handles = %li\n",pCache->ulNumHandles[PenHandle]);
        dprintf("GDI Cached region handles = %li\n",pCache->ulNumHandles[RegionHandle]);
        dprintf("GDI Cached lfont  handles = %li\n",pCache->ulNumHandles[LFontHandle]);

        PHANDLE pHandle = &pCache->Handle[0];
        ULONG ux;

        dprintf("\nBRUSH handles\n");

        for (ux=0;ux<CACHE_BRUSH_ENTRIES;ux++)
        {
            dprintf("0x%08lx ",*pHandle++);
            if (((ux+1) % 4)  == 0)
            {
                dprintf("\n");
            }
        }

        dprintf("\n\nPEN handles\n");

        for (ux=0;ux<CACHE_PEN_ENTRIES;ux++)
        {
            dprintf("0x%08lx ",*pHandle++);
            if (((ux+1) % 4)  == 0)
            {
                dprintf("\n");
            }
        }

        dprintf("\nREGION handles\n");

        for (ux=0;ux<CACHE_REGION_ENTRIES;ux++)
        {
            dprintf("0x%08lx ",*pHandle++);
            if (((ux+1) % 4)  == 0)
            {
                dprintf("\n");
            }
        }

        dprintf("\n");
    }
    else
    {
        dprintf("Error reading PEB contents\n");
        return;
    }

    if (bw32)
    {
        iStatus = move2(lw32proc,pw32process,sizeof(W32PROCESS));

        if (iStatus)
        {
            dprintf("W32PROCESS\n");

            dprintf("Process Handle Count %li\n",pw32->GDIHandleCount);


            PSINGLE_LIST_ENTRY pList = (PSINGLE_LIST_ENTRY)pw32->pDCAttrList;

            dprintf("Process DC_ATTRs 0x%lx\n",pw32->pDCAttrList);

            //
            // dump DCATTRs
            //

          //  while (pList)
          //  {
          //      BYTE lList[sizeof(SINGLE_LIST_ENTRY)];
          //      PSINGLE_LIST_ENTRY puList = (PSINGLE_LIST_ENTRY)&lList[0];
          //
          //      move2(lList,pList,sizeof(SINGLE_LIST_ENTRY));
          //
          //      dprintf("dcattr 0x%lx, next = 0x%lx\n",pList,puList->Next);
          //
          //      pList = puList->Next;
          //
          //      if (CheckControlC())
          //      {
          //          return;
          //      }
          //  }
          //
            //
            // dump brushattrs
            //

            pList = (PSINGLE_LIST_ENTRY)pw32->pBrushAttrList;

            dprintf("Process BRUSHATTRs 0x%lx:\n",pw32->pBrushAttrList);

          //  while (pList)
          //  {
          //      BYTE lList[sizeof(SINGLE_LIST_ENTRY)];
          //      PSINGLE_LIST_ENTRY puList = (PSINGLE_LIST_ENTRY)&lList[0];
          //
          //      move2(lList,pList,sizeof(SINGLE_LIST_ENTRY));
          //
          //      dprintf("brushattr 0x%lx, next = 0x%lx\n",pList,puList->Next);
          //
          //      pList = puList->Next;
          //
          //      if (CheckControlC())
          //      {
          //          return;
          //      }
          //  }
        }
    }
}
#endif  // DOES NOT SUPPORT API64



DECLARE_API( dpeb )
{
    dprintf("Extension 'dpeb' is not converted.\n");
#if 0   // DOES NOT SUPPORT API64
    PVOID       Process;
    EPROCESS    ProcessContents;
    PPEB        ppeb;
    PW32PROCESS pw32process;
    BOOL        bW32Thread = FALSE;

    //
    // dpeb [peb], look for peb input
    //
    PARSE_ARGUMENTS(peb_help);
    if(parse_iFindSwitch(tokens, ntok, 'w')!=-1) {bW32Thread=TRUE;}

    //
    // use current peb
    //

    Process = GetCurrentProcessAddress( dwProcessor, hCurrentThread, NULL );

    if ( !ReadMemory( (UINT_PTR)Process,
                      &ProcessContents,
                      sizeof(EPROCESS),
                      NULL))
    {
       dprintf("%08lx: Unable to read _EPROCESS\n", Process );
       return;
    }

    dprintf("Process 0x%p      W32Process: 0x%p\n",
               (ULONG_PTR)Process,
               (ULONG_PTR)ProcessContents.Win32Process);

    ppeb        = ProcessContents.Peb;
    pw32process = (PW32PROCESS)ProcessContents.Win32Process;

    GdiDPEB(ppeb,pw32process,bW32Thread);
    return;
peb_help:
    dprintf("Usage: dpeb [-?] [-w]\n");
    dprintf("-w indicates W32PROCESS structure\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
}



DECLARE_API( w32p )
{
    HRESULT         hr = S_OK;
    OutputControl   OutCtl(Client);
    BOOL            BadArg = FALSE;
    BOOL            ProcessArg = FALSE;
    DEBUG_VALUE     Address = {0, DEBUG_VALUE_INVALID};

    while (!BadArg)
    {
        while (isspace(*args)) args++;

        if (*args == '-')
        {
            // Process switches

            args++;
            BadArg = (*args == '\0' || isspace(*args));

            while (*args != '\0' && !isspace(*args))
            {
                switch (tolower(*args))
                {
                    case 'p':
                        ProcessArg = TRUE;
                        break;
                    default:
                        BadArg = TRUE;
                        break;
                }

                if (BadArg) break;
                args++;
            }
        }
        else
        {
            if (*args == '\0') break;

            if (Address.Type == DEBUG_VALUE_INVALID)
            {
                // This argument must be an address or a Process.
                CHAR    EOPChar;
                PSTR    EOP = (PSTR)args;
                ULONG   Rem;

                // Find end of string to evaulate as an address or Process
                while (*EOP != '\0' && !isspace(*EOP)) EOP++;
                EOPChar = *EOP;
                *EOP = '\0';

                if (isxdigit(*args) &&
                    Evaluate(Client, args, DEBUG_VALUE_INT64,
                             EVALUATE_DEFAULT_RADIX, &Address,
                             &Rem) == S_OK &&
                    args + Rem == EOP &&
                    Address.I64 != 0)
                {
                    args = EOP;
                }
                else
                {
                    OutCtl.OutErr("Error: Couldn't evaluate '%s' as a %s.\n",
                                  args,
                                  (ProcessArg ? "Process" : "W32PROCESS address"));
                    BadArg = TRUE;
                }
                *EOP = EOPChar;
            }
            else
            {
                // All other arguments are invalid
                OutCtl.OutErr("Error: Invalid argument '%s'.\n", args);
                BadArg = TRUE;
                break;
            }
        }
    }

    if (!BadArg)
    {
        if (ProcessArg && Address.Type == DEBUG_VALUE_INVALID)
        {
            OutCtl.OutErr("Error: Missing Process.\n");
            BadArg = TRUE;
        }
    }

    if (BadArg)
    {
        if (*args == '?')
        {
            OutCtl.Output("w32p dumps W32PROCESS stucture for current or specified process.\n\n");
        }

        OutCtl.Output("Usage: w32p [-?] [W32PROCESS Addr | -p Process]\n");
    }
    else
    {
        if (Address.Type == DEBUG_VALUE_INVALID || ProcessArg)
        {
            ULONG64 ProcessAddr = (Address.Type == DEBUG_VALUE_INVALID) ?
                                    CURRENT_PROCESS_ADDRESS :
                                    Address.I64;

            hr = GetProcessField(Client, &ProcessAddr, "Win32Process", &Address, DEBUG_VALUE_INT64);

            if (hr == S_OK)
            {
                if (Address.I64 == 0)
                {
                    OutCtl.Output(" Process 0x%p does not have a Win32Process.\n", ProcessAddr);
                    hr = S_FALSE;
                }
            }
            else
            {
                OutCtl.OutErr("Unable to look up Win32Process address.\n");
            }
        }

        if (hr == S_OK)
        {
            hr = DumpType(Client, "_W32PROCESS", Address.I64);
        }
    }

    return hr;
}


DECLARE_API( w32t )
{
    HRESULT         hr = S_OK;
    OutputControl   OutCtl(Client);
    BOOL            BadArg = FALSE;
    BOOL            ThreadArg = FALSE;
    DEBUG_VALUE     Address = {0, DEBUG_VALUE_INVALID};

    while (!BadArg)
    {
        while (isspace(*args)) args++;

        if (*args == '-')
        {
            // Process switches

            args++;
            BadArg = (*args == '\0' || isspace(*args));

            while (*args != '\0' && !isspace(*args))
            {
                switch (tolower(*args))
                {
                    case 't':
                        ThreadArg = TRUE;
                        break;
                    default:
                        BadArg = TRUE;
                        break;
                }

                if (BadArg) break;
                args++;
            }
        }
        else
        {
            if (*args == '\0') break;

            if (Address.Type == DEBUG_VALUE_INVALID)
            {
                // This argument must be an address or a Thread.
                CHAR    EOPChar;
                PSTR    EOP = (PSTR)args;
                ULONG   Rem;

                // Find end of string to evaulate as an address or Thread
                while (*EOP != '\0' && !isspace(*EOP)) EOP++;
                EOPChar = *EOP;
                *EOP = '\0';

                if (isxdigit(*args) &&
                    Evaluate(Client, args, DEBUG_VALUE_INT64,
                             EVALUATE_DEFAULT_RADIX, &Address,
                             &Rem) == S_OK &&
                    args + Rem == EOP &&
                    Address.I64 != 0)
                {
                    args = EOP;
                }
                else
                {
                    OutCtl.OutErr("Error: Couldn't evaluate '%s' as a %s.\n",
                                  args,
                                  (ThreadArg ? "Thread" : "W32THREAD address"));
                    BadArg = TRUE;
                }
                *EOP = EOPChar;
            }
            else
            {
                // All other arguments are invalid
                OutCtl.OutErr("Error: Invalid argument '%s'.\n", args);
                BadArg = TRUE;
                break;
            }
        }
    }

    if (!BadArg)
    {
        if (ThreadArg && Address.Type == DEBUG_VALUE_INVALID)
        {
            OutCtl.OutErr("Error: Missing Thread.\n");
            BadArg = TRUE;
        }
    }

    if (BadArg)
    {
        if (*args == '?')
        {
            OutCtl.Output("w32t dumps W32TRHEAD stucture for current or specified thread.\n\n");
        }

        OutCtl.Output("Usage: w32t [-?] [W32THREAD Addr | -t Thread]\n");
    }
    else
    {
        if (Address.Type == DEBUG_VALUE_INVALID || ThreadArg)
        {
            ULONG64 ThreadAddr = (Address.Type == DEBUG_VALUE_INVALID) ?
                                    CURRENT_THREAD_ADDRESS :
                                    Address.I64;

            hr = GetThreadField(Client, &ThreadAddr, "Tcb.Win32Thread", &Address, DEBUG_VALUE_INT64);

            if (hr == S_OK)
            {
                if (Address.I64 == 0)
                {
                    OutCtl.Output(" Thread 0x%p does not have a Win32Thread.\n", ThreadAddr);
                    hr = S_FALSE;
                }
            }
            else
           {
               OutCtl.OutErr("Unable to look up Win32Thread address.\n");
           }
        }

        if (hr == S_OK)
        {
            hr = DumpType(Client, "_W32THREAD", Address.I64);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\path.cxx ===
/******************************Module*Header*******************************\
* Module Name: path.cxx
*
* PATHOBJ gdikdx extension code.
*  
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#include  "precomp.hxx"

// PATH
#define GetPATHField(field) \
        GetPATHSubField(#field,field)
#define GetPATHSubField(field,local) \
        GetFieldData(offPATH, "PATH", field, sizeof(local), &local)
// PATHRECORD
#define GetPATHRECORDField(field) \
        GetPATHRECORDSubField(#field,field)
#define GetPATHRECORDSubField(field,local) \
        GetFieldData(offPATHRECORD, "PATHRECORD", field, sizeof(local), &local)



/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vPrintPOINTFIX
*
* Routine Description:
*
*   prints a POINTFIX
*
* Arguments:
*
*   pointer to a POINTFIX
*
* Return Value:
*
*   none
*
\**************************************************************************/

void
vPrintPOINTFIX(ULONG64 pPOINTFIX)
{
    FIX x;
    FIX y;
    ULONG error;

    FIELD_INFO vFields[] = 
    {
        { DbgStr("x"),	NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("y"),  NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL}
    };

    SYM_DUMP_PARAM vSym =
    {
       sizeof (SYM_DUMP_PARAM),
       DbgStr(GDIType(POINTFIX)),
       DBG_DUMP_NO_PRINT,
       0/*address*/,
       NULL, NULL, NULL,
       sizeof(vFields)/sizeof(vFields[0]),
       vFields
    };

    vSym.addr = pPOINTFIX;

    error = Ioctl(IG_DUMP_SYMBOL_INFO, &vSym, vSym.size);
    if(error)
    {
        dprintf("Unable to get contents of POINTFIX\n");
        dprintf("  (Ioctl returned %s)\n", pszWinDbgError(error));
        return;
    }
    x = (FIX) vFields[0].address;
    y = (FIX) vFields[1].address;

    dprintf(
        "(%-#10x, %-#10x) = (%d+(%d/16), %d+(%d/16))"
        , x, y, x/16, x&15, y/16, y&15
    );
}

ULONG
pointFixCallback(
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    if(pField)
    {
        vPrintPOINTFIX(pField->address);
        dprintf("\n");
    }

    return STATUS_SUCCESS;
}


/******************************Public*Routine******************************\
* vPrintPATHRECORD
*
* History:
*  Mon 20-Jun-1994 15:33:37 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

void
vPrintPATHRECORD(ULONG64 offPATHRECORD)
{
    FLONG flags, fl;
    ULONG count;
    ULONG64 pprnext, pprprev;
    ULONG offaptfx;
    ULONG error;

    if(offPATHRECORD)
    {
        FIELD_INFO vFields[] = 
        {
            { DbgStr("pprnext"), NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
            { DbgStr("pprprev"), NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
            { DbgStr("flags"),   NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
            { DbgStr("count"),   NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL}
        };

        SYM_DUMP_PARAM vSym =
        {
           sizeof (SYM_DUMP_PARAM),
           DbgStr(GDIType(PATHRECORD)),
           DBG_DUMP_NO_PRINT,
           0/*address*/,
           NULL, NULL, NULL,
           sizeof(vFields)/sizeof(vFields[0]),
           vFields
        };

        vSym.addr = offPATHRECORD;

        error = Ioctl(IG_DUMP_SYMBOL_INFO, &vSym, vSym.size);
        if(error)
        {
            dprintf("Unable to get contents of PATHRECORD\n");
            dprintf("  (Ioctl returned %s)\n", pszWinDbgError(error));
            return;
        }

        pprnext = vFields[0].address; 
        pprprev = vFields[1].address;
        dprintf("\tpprnext           = %-#p\n", pprnext);
        dprintf("\tpprprev           = %-#p\n", pprprev);
        flags = (FLONG)vFields[2].address;
        fl = flags;
        dprintf("\tflags             = %-#x\n", fl);

        for(FLAGDEF *pfd=afdPD; pfd->psz; pfd++)
        {
            if(fl & pfd->fl)
                dprintf("\t\t\t      %s\n", pfd->psz);
        }
        count = (ULONG)vFields[3].address;
        dprintf("\tcount    = %u\n", count);

        // Get the offset of aptfx in PATHRECORD.
        GetFieldOffset("PATHRECORD","aptfx",&offaptfx);
        if(count)
        {
    	    FIELD_INFO vField = { NULL, NULL, count, 0, 0, pointFixCallback};

    	    SYM_DUMP_PARAM vSym =
            {
       	        sizeof(SYM_DUMP_PARAM),
                DbgStr(GDIType(POINTFIX)),
                DBG_DUMP_ARRAY | DBG_DUMP_NO_PRINT,
                offPATHRECORD+offaptfx,
                &vField, NULL, NULL, 0, NULL
            };

            error = Ioctl(IG_DUMP_SYMBOL_INFO, &vSym, vSym.size);
            if(error)
            {
                  dprintf("Unable to dump contents of aptfx\n");
                  dprintf("  (Ioctl returned %s)\n", pszWinDbgError(error));
                  return;
            }
        }
        dprintf("\n");
    }
}

/******************************Public*Routine******************************\
* vPrintPATHList
*
* History:
*  Sat 20-May-2000 18:25:21 by Pravin Santiago [pravins]
* Wrote it.
\**************************************************************************/

void vPrintPATHList(ULONG64 offPATH)
{
    ULONG64 pprfirst;
    ULONG64 pprnext;
    ULONG64 ppr_CD;
    ULONG64 ppr;
    ULONG64 offPATHRECORD;
    ULONG count;

    GetPATHField(pprfirst);

    ppr = ppr_CD = offPATHRECORD = pprfirst;

    while(ppr)
    {
        GetPATHRECORDField(pprnext);

        //simple multi-rate cycle detection.
        if(ppr_CD)
        {
            GetFieldData(ppr_CD,
                         "PATHRECORD",
                         "pprnext",
                         sizeof(ppr_CD),
                         &ppr_CD);
            if(ppr_CD)
            {
                GetFieldData(ppr_CD,
                             "PATHRECORD",
                             "pprnext",
                             sizeof(ppr_CD),
                             &ppr_CD);
            }
        }
        if(ppr==ppr_CD)
        {
            dprintf("ERROR: Cycle detected in linked list.\n");
            break;
        }
        if(CheckControlC())
        {
            break;
        }

        vPrintPATHRECORD(offPATHRECORD);

        ppr = offPATHRECORD = pprnext;
    }
}


HRESULT
OutputPATH(
    PDEBUG_CLIENT Client,
    OutputControl *OutCtl,
    ULONG64 Offset,
    BOOL DumpRecords
    )
{
    HRESULT         hr = S_OK;
    ULONG64         Module;
    ULONG           TypeId;
    OutputControl   FilterOutCtl(Client);

    if ((hr = GetTypeId(Client, "PATH", &TypeId, &Module)) == S_OK)
    {
        OutputFilter        OutFilter(Client);
        OutputState         OutState(Client);

        if (!DumpRecords ||
            ((hr = OutState.Setup(0, &OutFilter)) == S_OK &&
             (hr = FilterOutCtl.SetControl(DEBUG_OUTCTL_THIS_CLIENT |
                                           DEBUG_OUTCTL_NOT_LOGGED |
                                           DEBUG_OUTCTL_OVERRIDE_MASK,
                                           OutState.Client)) == S_OK))
        {
            TypeOutputDumper    TypeReader(Client,
                                           (DumpRecords ? &FilterOutCtl : OutCtl));

            OutCtl->Output(" PATH @ 0x%p:\n", Offset);

            TypeReader.ExcludeMarked();
            TypeReader.MarkField("cle.*");

            hr = TypeReader.OutputVirtual(Module, TypeId, Offset);

            if (hr != S_OK)
            {
                OutCtl->OutErr("Type Dump for PATH returned %s.\n", pszHRESULT(hr));
            }
            else if (DumpRecords)
            {
                DEBUG_VALUE RecOffset;

                OutFilter.OutputText(OutCtl, DEBUG_OUTPUT_NORMAL);

                if ((hr = OutFilter.Query("pprfirst", &RecOffset, DEBUG_VALUE_INT64)) == S_OK)
                {
                    if (RecOffset.I64 != 0)
                    {
                        OutCtl->OutWarn("Path record dumping to be converted.\n");
                        vPrintPATHList(Offset);
                    }
                    else
                    {
                        OutCtl->OutErr(" No records to dump.\n");
                    }
                }
                else
                {
                    OutCtl->OutErr("Error evaluating 'pprfirst' member.\n");
                }
            }
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
* EPATHOBJ
*
\**************************************************************************/

DECLARE_API( epathobj )
{
    HRESULT         hr = S_OK;
    BOOL            BadSwitch = FALSE;
    BOOL            DumpPath = FALSE;
    BOOL            DumpRecords = FALSE;
    DEBUG_VALUE     Offset;
    ULONG64         Module;
    ULONG           TypeId;
    OutputControl   OutCtl(Client);

    while (!BadSwitch)
    {
        while (isspace(*args)) args++;

        if (*args != '-') break;

        args++;
        BadSwitch = (*args == '\0' || isspace(*args));

        while (*args != '\0' && !isspace(*args))
        {
            switch (*args)
            {
                case 'r': DumpRecords = TRUE; // Make sure DumpPath is set too
                case 'p': DumpPath = TRUE; break;
                default:
                    BadSwitch = TRUE;
                    break;
            }

            if (BadSwitch) break;
            args++;
        }
    }

    if (BadSwitch ||
        (hr = Evaluate(Client, args, DEBUG_VALUE_INT64, 0, &Offset, NULL)) != S_OK ||
        Offset.I64 == 0)
    {
        OutCtl.Output("Usage: epathobj [-?pr] <EPATHOBJ Addr>\n"
                      "        -p  - dump path\n"
                      "        -r  - dump path records\n");
    }
    else
    {
        if ((hr = GetTypeId(Client, "EPATHOBJ", &TypeId, &Module)) == S_OK)
        {
            OutputFilter        OutFilter(Client);
            OutputState         OutState(Client);

            OutCtl.Output(" EPATHOBJ @ 0x%p:\n", Offset.I64);

            if (!DumpPath ||
                ((hr = OutState.Setup(0, &OutFilter)) == S_OK &&
                 (hr = OutCtl.SetControl(DEBUG_OUTCTL_THIS_CLIENT |
                                         DEBUG_OUTCTL_NOT_LOGGED |
                                         DEBUG_OUTCTL_OVERRIDE_MASK,
                                         OutState.Client)) == S_OK))
            {
                TypeOutputDumper    TypeReader(Client, &OutCtl);

                hr = TypeReader.OutputVirtual(Module, TypeId, Offset.I64);

                if (DumpPath)
                {
                    OutCtl.SetControl(DEBUG_OUTCTL_AMBIENT, Client);
                }

                if (hr != S_OK)
                {
                    OutCtl.OutErr("Type Dump for EPATHOBJ returned %s.\n", pszHRESULT(hr));
                }
                else if (DumpPath)
                {
                    OutFilter.OutputText(&OutCtl, DEBUG_OUTPUT_NORMAL);

                    if ((hr = OutFilter.Query("ppath", &Offset, DEBUG_VALUE_INT64)) == S_OK)
                    {
                        if (Offset.I64 != 0)
                        {
                            hr = OutputPATH(Client, &OutCtl, Offset.I64, DumpRecords);
                        }
                        else
                        {
                            OutCtl.OutErr(" No path to dump.\n");
                        }
                    }
                    else
                    {
                        OutCtl.OutErr("Error evaluating 'ppath' member.\n");
                    }
                }
            }
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
* PATH
*
\**************************************************************************/

DECLARE_API( path )
{
    HRESULT         hr = S_OK;
    BOOL            BadSwitch = FALSE;
    BOOL            DumpRecords = FALSE;
    ULONG64         PathAddr;
    DEBUG_VALUE     Arg;
    ULONG64         Module;
    ULONG           TypeId;
    OutputControl   OutCtl(Client);

    while (!BadSwitch)
    {
        while (isspace(*args)) args++;

        if (*args != '-') break;

        args++;
        BadSwitch = (*args == '\0' || isspace(*args));

        while (*args != '\0' && !isspace(*args))
        {
            switch (*args)
            {
                case 'r': DumpRecords = TRUE; break;
                default:
                    BadSwitch = TRUE;
                    break;
            }

            if (BadSwitch) break;
            args++;
        }
    }

    if (BadSwitch ||
        (hr = Evaluate(Client, args, DEBUG_VALUE_INT64, 0, &Arg, NULL)) != S_OK ||
        Arg.I64 == 0)
    {
        OutCtl.Output("Usage: path [-?r] <HPATH | PATH Addr>\n"
                      "        -r  - dump records\n");
    }
    else
    {
        hr = GetObjectAddress(Client, Arg.I64, &PathAddr, PATH_TYPE, TRUE, TRUE);

        if (hr != S_OK || PathAddr == 0)
        {
            DEBUG_VALUE         ObjHandle;
            TypeOutputParser    TypeParser(Client);
            OutputState         OutState(Client);
            ULONG64             PathAddrFromHmgr;

            PathAddr = Arg.I64;

            if ((hr = OutState.Setup(0, &TypeParser)) != S_OK ||
                (hr = OutState.OutputTypeVirtual(PathAddr, "PATH", 0)) != S_OK ||
                (hr = TypeParser.Get(&ObjHandle, "hHmgr", DEBUG_VALUE_INT64)) != S_OK)
            {
                OutCtl.OutErr("Unable to get contents of PATH::hHmgr\n");
                OutCtl.OutErr("  (Type Read returned %s)\n", pszHRESULT(hr));
                OutCtl.OutErr(" 0x%p is neither an HPATH nor valid PATH address\n", Arg.I64);
            }
            else
            {
                if (GetObjectAddress(Client, ObjHandle.I64, &PathAddrFromHmgr,
                                     PATH_TYPE, TRUE, FALSE) == S_OK &&
                    PathAddrFromHmgr != PathAddr)
                {
                    OutCtl.OutWarn("\tNote: PATH may not be valid.\n"
                                   "\t      It does not have a valid handle manager entry.\n");
                }
            }
        }

        if (hr == S_OK)
        {
            hr = OutputPATH(Client, &OutCtl, PathAddr, DumpRecords);
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
* DECLARE_API( dpo  )
*
* dpo -- "dump PATHOBJ"
*
*  21-Feb-1995    -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DECLARE_API( dpo )
{
    OutputControl   OutCtl(Client);
    OutCtl.OutWarn("dpo is obsolete. Please use epathobj.\n");
    return epathobj(Client, args);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\surface.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    surface.cxx

Abstract:

    This file contains the routines to page in surface data.

Author:

    Jason Hartman (JasonHa) 2001-05-16

Environment:

    User Mode

--*/

#include "precomp.hxx"


BYTE    x86_jmp_here[] = { 0xeb, 0xfe };   // spin jmp
BYTE    x86_jmp_plus_0x0e[] = { 0xeb, 0x0e };   // jmp
BYTE    x86_jb_plus_0x02[] = { 0x72, 0x02 };    // je
BYTE    x86_jne_minus_0x18[] = { 0x75, 0xe7 };    // jne

BYTE    x86_jmp_plus_0x06[] = { 0xeb, 0x06 };   // jmp
BYTE    x86_jb_plus_0x0c[] = { 0x72, 0x0c };    // je
BYTE    x86_jnz_minus_0x08[] = { 0x75, 0xf8 };    // jne

#define I_START_IP          0x00000001
#define I_WRITE_ADDRESS     0x00000002

typedef struct _Instruction {
    FLONG   Flags;
    ULONG   ByteLen;
    PSTR    Code;
} Instruction;



/******************************Public*Routine******************************\
* SURFACE
*
\**************************************************************************/

DECLARE_API( surface )
{
    BEGIN_API( surface );

    HRESULT         hr = S_OK;
    ULONG64         SurfAddr;
    DEBUG_VALUE     Arg;
    BOOL            BadSwitch = FALSE;
    BOOL            AddressIsSURFOBJ = FALSE;
    BOOL            AddressIsSURFACE = FALSE;
    BOOL            ArgumentIsHandle = FALSE;

    OutputControl   OutCtl(Client);

    while (!BadSwitch)
    {
        while (isspace(*args)) args++;

        if (*args != '-') break;

        args++;
        BadSwitch = (*args == '\0' || isspace(*args));

        while (*args != '\0' && !isspace(*args))
        {
            switch (tolower(*args))
            {
                case 'a':
                    if (ArgumentIsHandle || AddressIsSURFOBJ)
                    {
                        OutCtl.OutErr("Error: Only one of -a, -h, or -o may be specified.\n");
                        BadSwitch = TRUE;
                    }
                    else
                    {
                        AddressIsSURFACE = TRUE;
                    }
                    break;
                case 'h':
                    if (AddressIsSURFACE || AddressIsSURFOBJ)
                    {
                        OutCtl.OutErr("Error: Only one of -a, -h, or -o may be specified.\n");
                        BadSwitch = TRUE;
                    }
                    else
                    {
                        ArgumentIsHandle = TRUE;
                    }
                    break;
                case 'o':
                    if (ArgumentIsHandle || AddressIsSURFACE)
                    {
                        OutCtl.OutErr("Error: Only one of -a, -h, or -o may be specified.\n");
                        BadSwitch = TRUE;
                    }
                    else
                    {
                        AddressIsSURFOBJ = TRUE;
                    }
                    break;
                default:
                    BadSwitch = TRUE;
                    break;
            }

            if (BadSwitch) break;
            args++;
        }
    }

    if (BadSwitch ||
        (hr = Evaluate(Client, args, DEBUG_VALUE_INT64, 0, &Arg, NULL)) != S_OK ||
        Arg.I64 == 0)
    {
        OutCtl.Output("Usage: surface [-?] < [-h] HSURF | [-a] SURFACE Addr | -o SURFOBJ Addr>\n"
                      "\n"
                      "  Note: HBITMAP is the same as HSURF.\n");
    }
    else
    {
        if (AddressIsSURFOBJ)
        {
            PDEBUG_SYMBOLS  Symbols;

            ULONG64 SurfModule;
            ULONG   SurfTypeId;
            ULONG   BaseObjTypeId;
            ULONG   SurfObjOffset;

            if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                             (void **)&Symbols)) == S_OK)
            {
                // Try to read SURFOBJ offset from SURFACE type, but
                // if that fails assume it is directly after BASEOBJECT.
                if ((hr = GetTypeId(Client, "SURFACE", &SurfTypeId, &SurfModule)) != S_OK ||
                    (hr = Symbols->GetFieldOffset(SurfModule, SurfTypeId, "so", &SurfObjOffset)) != S_OK)
                {
                    if ((hr = Symbols->GetTypeId(Type_Module.Base, "_BASEOBJECT", &BaseObjTypeId)) == S_OK)
                    {
                        hr = Symbols->GetTypeSize(Type_Module.Base, BaseObjTypeId, &SurfObjOffset);
                    }
                }

                Symbols->Release();
            }

            if (hr != S_OK)
            {
                OutCtl.OutErr("Error: SURFOBJ to SURFACE lookup failed.\n");
            }
            else
            {
                SurfAddr = Arg.I64 - SurfObjOffset;
            }
        }
        else if (AddressIsSURFACE)
        {
            SurfAddr = Arg.I64;
        }
        else
        {
            // Try to look value up as a SURFACE handle
            hr = GetObjectAddress(Client, Arg.I64, &SurfAddr, SURF_TYPE, TRUE, TRUE);

            if (hr != S_OK || SurfAddr == 0)
            {
                if (ArgumentIsHandle)
                {
                    OutCtl.OutErr(" 0x%p is not a valid HSURF\n", Arg.I64);
                }
                else
                {
                    // The value wasn't restricted to a handle
                    // so try as a SURFACE address.
                    SurfAddr = Arg.I64;
                    hr = S_OK;
                }
            }
            else
            {
                ArgumentIsHandle = TRUE;
            }
        }

        if (hr == S_OK && !ArgumentIsHandle)
        {
            DEBUG_VALUE         ObjHandle;
            TypeOutputParser    TypeParser(Client);
            OutputState         OutState(Client);
            ULONG64             SurfAddrFromHmgr;

            if ((hr = OutState.Setup(0, &TypeParser)) != S_OK ||
                (hr = OutState.OutputTypeVirtual(SurfAddr, "SURFACE", 0)) != S_OK ||
                (hr = TypeParser.Get(&ObjHandle, "hHmgr", DEBUG_VALUE_INT64)) != S_OK)
            {
                OutCtl.OutErr("Unable to get contents of SURFACE::hHmgr\n");
                OutCtl.OutErr("  (Type Read returned %s)\n", pszHRESULT(hr));
                if (AddressIsSURFOBJ)
                {
                    OutCtl.OutErr(" 0x%p is not a valid SURFOBJ address\n", Arg.I64);
                }
                else if (AddressIsSURFACE)
                {
                    OutCtl.OutErr(" 0x%p is not a valid SURFACE address\n", Arg.I64);
                }
                else
                {
                    OutCtl.OutErr(" 0x%p is neither an HSURF nor valid SURFACE address\n", Arg.I64);
                }
            }
            else
            {
                if (GetObjectAddress(Client, ObjHandle.I64, &SurfAddrFromHmgr,
                                     SURF_TYPE, TRUE, FALSE) == S_OK &&
                    SurfAddrFromHmgr != SurfAddr)
                {
                    OutCtl.OutWarn("\tNote: SURFACE may not be valid.\n"
                                   "\t      It does not have a valid handle manager entry.\n");
                }
            }
        }

        if (hr == S_OK)
        {
            hr = DumpType(Client, "SURFACE", SurfAddr);

            if (hr != S_OK)
            {
                OutCtl.OutErr("Type Dump for SURFACE returned %s.\n", pszHRESULT(hr));
            }
        }
    }

    EXIT_API(hr);
}


DECLARE_API( dpso  )
{
    INIT_API();
    ExtOut("Obsolete: Use 'surfobj <SURFOBJ Addr>'.\n");
    EXIT_API(S_OK);
}



/******************************Public*Routine******************************\
* SURFLIST
*
*   List readable surfaces and brief info
*
\**************************************************************************/

PCSTR   SurfaceListFields[] = {
    "so.hsurf",
    "so.hdev",
    "so.sizlBitmap",
    "so.cjBits",
    "so.pvBits",
    "so.iBitmapFormat",
    "so.iType",
    "so.fjBitmap",
    NULL
};

PCSTR   ExtendedSurfaceListFields[] = {
    "ulShareCount",
    "BaseFlags",
    "so.dhsurf",
    "SurfFlags",
    NULL
};

DECLARE_API( surflist )
{
    BEGIN_API( surflist );

    HRESULT hr;
    HRESULT hrMask;
    ULONG64 index = 0;
    ULONG64 gcMaxHmgr;
    ULONG64 SurfAddr;
    BOOL    BadSwitch = FALSE;
    BOOL    DumpBaseObject = FALSE;
    BOOL    DumpExtended = FALSE;
    BOOL    DumpUserFields = FALSE;

    OutputControl   OutCtl(Client);

    while (!BadSwitch)
    {
        while (isspace(*args)) args++;

        if (*args != '-') break;

        args++;
        BadSwitch = (*args == '\0' || isspace(*args));

        while (*args != '\0' && !isspace(*args))
        {
            switch (*args)
            {
                case 'b': DumpBaseObject = TRUE; break;
                case 'e': DumpExtended = TRUE; break;
                default:
                    BadSwitch = TRUE;
                    break;
            }

            if (BadSwitch) break;
            args++;
        }
    }

    if (BadSwitch)
    {
        OutCtl.Output("Usage: surflist [-?be] [<Start Index>] [<Member List>]\n"
                      "\n"
                      "   b - Dump BASEOBJECT information\n"
                      "   e - Dump extended members\n"
                      "         ulShareCount, BaseFlags, dhsurf, SurfFlags\n"
                      "\n"
                      "   Start Index - First hmgr entry index to begin listing\n"
                      "   Member List - Space seperated list of other SURFACE members\n"
                      "                 to be included in the dump\n");

        return S_OK;
    }

    DEBUG_VALUE dvIndex;
    ULONG       RemIndex;
    if (*args != '\0' && !iscsymf(*args) &&
        ((hr = Evaluate(Client, args, DEBUG_VALUE_INT64, 0, &dvIndex, &RemIndex)) == S_OK))
    {
        index = dvIndex.I64;
        args += RemIndex;

        // Always keep args at the next unhandled argument
        while (isspace(*args)) args++;
    }

    if ((hr = GetMaxHandles(Client, &gcMaxHmgr)) != S_OK)
    {
        OutCtl.OutErr("Unable to get sizeof GDI handle table. HRESULT %s\n", pszHRESULT(hr));
        return hr;
    }

    gcMaxHmgr = (ULONG64)(ULONG)gcMaxHmgr;

    if (index != 0 && index >= gcMaxHmgr)
    {
        OutCtl.Output("No remaining handle entries to be searched.\n");
        return hr;
    }

    OutCtl.Output("Searching %s 0x%I64x handle entries for Surfaces.\n",
                  (index ? "remaining" : "all"), gcMaxHmgr - index);

    OutputFilter    OutFilter(Client);
    OutputState     OutState(Client, FALSE);
    OutputControl   OutCtlToFilter;
    ULONG64         Module;
    ULONG           TypeId;
    ULONG           OutputMask;
    BOOL            IsPointer64Bit;
    ULONG           PointerSize;

    if ((hr = OutState.Setup(DEBUG_OUTPUT_NORMAL,
                             &OutFilter)) == S_OK &&
        (hr = OutCtlToFilter.SetControl(DEBUG_OUTCTL_THIS_CLIENT |
                                DEBUG_OUTCTL_NOT_LOGGED,
                                OutState.Client)) == S_OK &&
        (hr = GetTypeId(Client, "SURFACE", &TypeId, &Module)) == S_OK)
    {
        TypeOutputDumper    TypeReader(OutState.Client, &OutCtlToFilter);

        TypeReader.SelectMarks(1);
        TypeReader.IncludeMarked();
        if (DumpBaseObject) TypeReader.MarkFields(BaseObjectFields);
        if (DumpExtended) TypeReader.MarkFields(ExtendedSurfaceListFields);

        // Add user specified fields to dump list
        PSTR    MemberList = NULL;
        CHAR   *pBOF = (CHAR *)args;

        if (iscsymf(*pBOF))
        {
            MemberList = (PSTR) HeapAlloc(GetProcessHeap(), 0, strlen(pBOF)+1);

            if (MemberList != NULL)
            {
                strcpy(MemberList, pBOF);
                pBOF = MemberList;

                DumpUserFields = TRUE;

                while (iscsymf(*pBOF))
                {
                    CHAR   *pEOF = pBOF;
                    CHAR    EOFChar;

                    // Get member
                    do {
                         pEOF++;
                    } while (iscsym(*pEOF) || *pEOF == '.' || *pEOF == '*');
                    EOFChar = *pEOF;
                    *pEOF = '\0';
                    TypeReader.MarkField(pBOF);

                    // Advance to next
                    if (EOFChar != '\0')
                    {
                        do
                        {
                            pEOF++;
                        } while (isspace(*pEOF));
                    }

                    pBOF = pEOF;
                }
            }
            else
            {
                OutCtl.OutErr("Error: Couldn't allocate memory for Member List.\n");
                hr = E_OUTOFMEMORY;
            }
        }

        if (hr == S_OK && *pBOF != '\0')
        {
            OutCtl.OutErr("Error: \"%s\" is not a valid member list.\n", pBOF);
            hr = E_INVALIDARG;
        }

        if (hr == S_OK)
        {
            // Setup default dump specifications
            TypeReader.SelectMarks(0);
            TypeReader.IncludeMarked();
            TypeReader.MarkFields(SurfaceListFields);

            OutFilter.Replace(OUTFILTER_REPLACE_THIS, " so _SURFOBJ ", NULL);
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, " hsurf ", NULL);
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, " hdev ", NULL);
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, "(null)", "(null)    ");
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, " sizlBitmap", NULL);
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, " cjBits", NULL);
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, " pvBits", NULL);
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, " iBitmapFormat", NULL);
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, " iType", NULL);
            OutFilter.Replace(OUTFILTER_REPLACE_THIS, " fjBitmap", NULL);

            // Output dump header
            PointerSize = (OutCtl.IsPointer64Bit() == S_OK) ? 21 : 10;
            OutCtl.Output(" %-*s HSURF      HDEV        Dimensions cjBits %-*s Format\t\t\t",
                          PointerSize, "&SURFACE", PointerSize, "pvBits");
            if (DumpBaseObject) OutCtl.Output(" \tBASEOBJECT");
            if (DumpExtended) OutCtl.Output(" ulShareCount  BaseFlags  dhsurf  SurfFlags");
            if (DumpUserFields) OutCtl.Output(" %s", args);
            OutCtl.Output("\n");

            for (; index < gcMaxHmgr; index++)
            {
                if (OutCtl.GetInterrupt() == S_OK) break;

                // Turn off error and verbose messages for this call to
                // GetObjectAddress since it will spew for non-surfaces.
                if ((hrMask = Client->GetOutputMask(&OutputMask)) == S_OK &&
                    OutputMask & (DEBUG_OUTPUT_ERROR | DEBUG_OUTPUT_VERBOSE))
                {
                    hrMask = Client->SetOutputMask(OutputMask & ~(DEBUG_OUTPUT_ERROR | DEBUG_OUTPUT_VERBOSE));
                }

                hr = GetObjectAddress(Client, index, &SurfAddr, SURF_TYPE, FALSE, FALSE);

                // Restore mask
                if (hrMask == S_OK &&
                    OutputMask & (DEBUG_OUTPUT_ERROR | DEBUG_OUTPUT_VERBOSE))
                {
                    Client->SetOutputMask(OutputMask);
                }

                if (hr != S_OK || SurfAddr == 0) continue;

                OutCtl.Output(" 0x%p ", SurfAddr);

                // Read to fields to OutFilter: 'ppdevNext' and 'fl'
                OutFilter.DiscardOutput();


                hr = TypeReader.OutputVirtual(Module, TypeId, SurfAddr,
                                              DEBUG_OUTTYPE_NO_OFFSET |
                                              DEBUG_OUTTYPE_COMPACT_OUTPUT);

                if (hr == S_OK)
                {
                    if (DumpBaseObject || DumpExtended || DumpUserFields)
                    {
                        OutCtlToFilter.Output("  \t");
                        TypeReader.SelectMarks(1);
                        TypeReader.OutputVirtual(Module, TypeId, SurfAddr,
                                                 DEBUG_OUTTYPE_NO_OFFSET |
                                                 DEBUG_OUTTYPE_COMPACT_OUTPUT);
                        TypeReader.SelectMarks(0);
                    }

                    OutFilter.OutputText(&OutCtl, DEBUG_OUTPUT_NORMAL);

                    OutCtl.Output("\n");
                }
                else
                {
                    OutCtl.Output("0x????%4.4I64x  ** failed to read surface **\n", index);
                }
            }

            hr = S_OK;
        }

        if (MemberList != NULL)
        {
            HeapFree(GetProcessHeap(), 0, MemberList);
        }
    }
    else
    {
        OutCtl.OutErr(" Output state/control setup returned %s.\n",
                      pszHRESULT(hr));
    }

    return hr;
}



/******************************Public*Routine******************************\
* VSURF
*
*   View the contents of a surface
*
\**************************************************************************/

DECLARE_API( vsurf )
{
    HRESULT     hr = S_OK;

    BEGIN_API( vsurf );

    BOOL        BadArg = FALSE;
    BOOL        AddressIsSURFOBJ = FALSE;
    BOOL        AddressIsSURFACE = FALSE;
    BOOL        ArgumentIsHandle = FALSE;

    BOOL        DisplayToDesktop = FALSE;

    PSTR        pszMetaFile = NULL;

    // Values that can be overridden
    DEBUG_VALUE pvScan0 = { 0, DEBUG_VALUE_INVALID};
    DEBUG_VALUE lDelta = { 0, DEBUG_VALUE_INVALID};
    DEBUG_VALUE iBitmapFormat = { -1, DEBUG_VALUE_INVALID};
    DEBUG_VALUE pPal = { 0, DEBUG_VALUE_INVALID};

    // Dimension specifications
    enum {
        left = 0,
        top = 1,
        cx = 2,
        cy = 3,
        right = 2,
        bottom = 3,
    };
    BOOL        GotAllDims = FALSE;
    ULONG       DimsFound = 0;
    BOOL        DimsSpecWxH = FALSE;
    DEBUG_VALUE dim[4];

    // The address or handle
    DEBUG_VALUE SurfSpec = { 0, DEBUG_VALUE_INVALID};

    ULONG       Rem;

    OutputControl   OutCtl(Client);

    if (Client == NULL)
    {
        return E_INVALIDARG;
    }

    while (!BadArg && hr == S_OK)
    {
        while (isspace(*args)) args++;

        if (*args == '-')
        {
            // Dimensions must be adjacent - raise error later otherwise
            if (DimsFound)
            {
                GotAllDims = TRUE;
            }

            // Process switches

            args++;
            BadArg = (*args == '\0' || isspace(*args));

            while (*args != '\0' && !isspace(*args))
            {
                switch (tolower(*args))
                {
                    case 'a':
                        if (ArgumentIsHandle || AddressIsSURFOBJ)
                        {
                            OutCtl.OutErr("Error: Only one of -a, -h, or -o may be specified.\n");
                            BadArg = TRUE;
                        }
                        else
                        {
                            AddressIsSURFACE = TRUE;
                            args++;
                        }
                        break;
                    case 'b':
                        {
                            args++;
                            if (Evaluate(Client, args, DEBUG_VALUE_INT64,
                                         EVALUATE_DEFAULT_RADIX, &pvScan0,
                                         &Rem, NULL,
                                         EVALUATE_COMPACT_EXPR) == S_OK)
                            {
                                args += Rem;
                            }
                            else
                            {
                                OutCtl.OutErr("Error: Couldn't evaluate pvScan0 value from '%s'.\n",
                                              args);
                                BadArg = TRUE;
                            }

                            if (!BadArg &&
                                Evaluate(Client, args, DEBUG_VALUE_INT64,
                                         EVALUATE_DEFAULT_RADIX, &lDelta,
                                         &Rem, NULL,
                                         EVALUATE_COMPACT_EXPR) == S_OK)
                            {
                                args += Rem;
                            }
                            else
                            {
                                OutCtl.OutErr("Error: Couldn't evaluate lDelta value from '%s'.\n",
                                              args);
                                BadArg = TRUE;
                            }
                        }
                        break;
                    case 'd':
                        DisplayToDesktop = TRUE;
                        args++;
                        break;
                    case 'e':
                        {
                            PCSTR   pszStart;
                            SIZE_T  FileNameLen;

                            // Find beginning of path
                            do
                            {
                                args++;
                            } while (isspace(*args));

                            pszStart = args;

                            if (*pszStart == '\0')
                            {
                                OutCtl.OutErr("Error: Missing EMF filepath.\n");
                                BadArg = TRUE;
                            }
                            else
                            {
                                // Point args beyond path
                                while (*args != '\0' && !isspace(*args))
                                {
                                    args++;
                                }

                                FileNameLen = args - pszStart;
                                pszMetaFile = (PSTR) HeapAlloc(GetProcessHeap(), 0, FileNameLen+4+1);
                                if (pszMetaFile != NULL)
                                {
                                    RtlCopyMemory(pszMetaFile, pszStart, FileNameLen);
                                    pszMetaFile[FileNameLen] = 0;

                                    // Append .emf if needed
                                    if (FileNameLen < 4 ||
                                        _strnicmp(&pszMetaFile[FileNameLen-4], ".emf", 4) != 0)
                                    {
                                        strcat(pszMetaFile, ".emf");
                                    }
                                }
                                else
                                {
                                    OutCtl.OutErr("Failed to allocate memory.\n");
                                    hr = E_OUTOFMEMORY;
                                }
                            }
                        }
                        break;
                    case 'f':
                        {
                            do
                            {
                                args++;
                            } while (isspace(*args));

                            if (_strnicmp(args, "BMF_", sizeof("BMF_")) == 0)
                            {
                                ENUMDEF *ped = aedBMF;
                                SIZE_T CheckLen;

                                for (ped = aedBMF; ped->psz != NULL; ped++)
                                {
                                    CheckLen = strlen(ped->psz);
                                    if (_strnicmp(args, ped->psz, CheckLen) == 0 &&
                                        !iscsym(args[CheckLen]))
                                    {
                                        iBitmapFormat.I64 = ped->ul;
                                        iBitmapFormat.Type = DEBUG_VALUE_INT64;
                                        break;
                                    }
                                }

                                if (iBitmapFormat.Type != DEBUG_VALUE_INT64)
                                {
                                    BadArg = TRUE;
                                }
                            }
                            else if (Evaluate(Client, args, DEBUG_VALUE_INT64,
                                              EVALUATE_DEFAULT_RADIX, &iBitmapFormat,
                                              &Rem, NULL,
                                              EVALUATE_COMPACT_EXPR) == S_OK)
                            {
                                args += Rem;
                            }
                            else
                            {
                                BadArg = TRUE;
                            }

                            if (BadArg)
                            {
                                OutCtl.OutErr("Error: Couldn't evaluate iBitmapFormat value from '%s'.\n",
                                              args);
                            }
                        }
                        break;
                    case 'h':
                        if (AddressIsSURFACE || AddressIsSURFOBJ)
                        {
                            OutCtl.OutErr("Error: Only one of -a, -h, or -o may be specified.\n");
                            BadArg = TRUE;
                        }
                        else
                        {
                            ArgumentIsHandle = TRUE;
                            args++;
                        }
                        break;
                    case 'o':
                        if (ArgumentIsHandle || AddressIsSURFACE)
                        {
                            OutCtl.OutErr("Error: Only one of -a, -h, or -o may be specified.\n");
                            BadArg = TRUE;
                        }
                        else
                        {
                            AddressIsSURFOBJ = TRUE;
                            args++;
                        }
                        break;
                    case 'p':
                        {
                            args++;
                            if (Evaluate(Client, args, DEBUG_VALUE_INT64,
                                         EVALUATE_DEFAULT_RADIX, &pPal,
                                         &Rem, NULL,
                                         EVALUATE_COMPACT_EXPR) == S_OK)
                            {
                                args += Rem;
                            }
                            else
                            {
                                OutCtl.OutErr("Error: Couldn't evaluate PALETTE address from '%s'.\n",
                                              args);
                                BadArg = TRUE;
                            }
                        }
                        break;
                    default:
                        BadArg = TRUE;
                        break;
                }

                if (BadArg) break;
            }
        }
        else
        {
            if (*args == '\0') break;

            if (SurfSpec.Type == DEBUG_VALUE_INVALID)
            {
                // This argument must be an address or handle.
                if (Evaluate(Client, args, DEBUG_VALUE_INT64,
                             EVALUATE_DEFAULT_RADIX, &SurfSpec,
                             &Rem, NULL, EVALUATE_COMPACT_EXPR) == S_OK)
                {
                    args += Rem;
                }
                else
                {
                    OutCtl.OutErr("Error: Couldn't evaluate %s from '%s'.\n",
                                  (AddressIsSURFOBJ ?
                                   "SURFOBJ address" :
                                   "address or handle"),
                                  args);
                    BadArg = TRUE;
                }
            }
            else if (!GotAllDims)
            {
                // This argument must be part of dimension specification.

                // Check for 'x' indicating WxH specification
                if (tolower(args[0]) == 'x' && (args[1] == '\0' || isspace(args[1])))
                {
                    if (DimsFound == 3)
                    {
                        args += 2;
                        DimsSpecWxH = TRUE;
                    }
                    else
                    {
                        OutCtl.OutErr("Error: Malformed dimension specification.\n");
                        BadArg = TRUE;
                        break;
                    }
                }
                else
                {
                    if (Evaluate(Client, args, DEBUG_VALUE_INT32,
                                 EVALUATE_DEFAULT_RADIX, &dim[DimsFound],
                                 &Rem, NULL, EVALUATE_COMPACT_EXPR) == S_OK)
                    {
                        args += Rem;
                        DimsFound++;

                        GotAllDims = (DimsFound == 4);
                    }
                    else
                    {
                        OutCtl.OutErr("Error: Couldn't evaluate dimension from '%s'.\n",
                                      args);
                        BadArg = TRUE;
                    }
                }
            }
            else
            {
                OutCtl.OutErr("Error: Unexpected argument at '%s'.\n", args);
                BadArg = TRUE;
                break;
            }
        }
    }

    if (hr == S_OK)
    {
        if (!BadArg)
        {
            if (DimsFound == 1 || DimsFound == 3)
            {
                OutCtl.OutErr("Error: Missing part of dimensions.\n");
                BadArg = TRUE;
            }
            else if (SurfSpec.Type == DEBUG_VALUE_INVALID)
            {
                OutCtl.OutErr("Error: Missing address or handle.\n");
                BadArg = TRUE;
            }
            else if (SurfSpec.I64 == 0)
            {
                OutCtl.OutErr("Error: Invalid (0) address or handle.\n");
                BadArg = TRUE;
            }
            else if (!DimsSpecWxH && DimsFound == 4)
            {
                dim[cx].I32 = dim[right].I32 - dim[left].I32;
                dim[cy].I32 = dim[bottom].I32 - dim[top].I32;
                if ((LONG)dim[cx].I32 < 0 ||
                    (LONG)dim[cy].I32 < 0)
                {
                    OutCtl.OutErr("Error: Invalid dimensions.\n");
                    BadArg = TRUE;
                }
            }
        }

        if (BadArg)
        {
            if (*args == '?') OutCtl.Output("View (or save) the contents of a surface\n");

            OutCtl.Output("\n"
                          "Usage: vsurf [-?bdefp] < [-h] HSURF | [-a] SURFACE Addr | -o SURFOBJ Addr> [Dimensions]\n"
                          "  b <pvScan0> <lDelta>  - Override those fields from surface\n"
                          "                           Zero values will not override\n"
                          "  d                     - Blt contents to (0,0) on the desktop\n"
                          "  e <Filepath>          - Full path to save surface as an EMF\n"
                          "  f <iBitmapFormat>     - Overrides bitmap format\n"
                          "  p <PALETTE Addr>      - Specifies PALETTE to use for indexed surfaces\n"
                          "  Dimensions = Left Top [Right Bottom | Width x Height]\n"
                          "\n"
                          "  Notes:\n"
                          "    HBITMAP is the same as HSURF.\n"
                          "    When not saving to a file, a window will be opened.\n"
                          "     -> Use GDIView.exe if debugging remotely.\n");
        }
        else
        {
            PDEBUG_SYMBOLS      Symbols = NULL;
            PDEBUG_DATA_SPACES  Data = NULL;
            ULONG64             SurfAddr;

            if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                             (void **)&Symbols)) != S_OK ||
                (hr = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                             (void **)&Data)) != S_OK)
            {
                OutCtl.OutErr("Error setting up debugger interface.\n");
            }
            else
            {
                if (AddressIsSURFOBJ)
                {
                    ULONG64 SurfModule = 0;
                    ULONG   SurfTypeId = 0;
                    ULONG   SurfObjOffset;
                    ULONG   BaseObjTypeId = 0;

                    // Try to read SURFOBJ offset from SURFACE type, but
                    // if that fails assume it is directly after BASEOBJECT.
                    if ((hr = GetTypeId(Client, "SURFACE", &SurfTypeId, &SurfModule)) != S_OK ||
                        (hr = Symbols->GetFieldOffset(SurfModule, SurfTypeId, "so", &SurfObjOffset)) != S_OK)
                    {
                        if ((hr = Symbols->GetTypeId(Type_Module.Base, "_BASEOBJECT", &BaseObjTypeId)) == S_OK)
                        {
                            hr = Symbols->GetTypeSize(Type_Module.Base, BaseObjTypeId, &SurfObjOffset);
                        }
                    }

                    if (hr != S_OK)
                    {
                        OutCtl.OutErr("Error: SURFOBJ to SURFACE lookup failed.\n");
                    }
                    else
                    {
                        SurfAddr = SurfSpec.I64 - SurfObjOffset;
                    }
                }
                else if (AddressIsSURFACE)
                {
                    SurfAddr = SurfSpec.I64;
                }
                else
                {
                    hr = GetObjectAddress(Client, SurfSpec.I64, &SurfAddr, SURF_TYPE, TRUE, TRUE);

                    if (hr != S_OK)
                    {
                        if (ArgumentIsHandle)
                        {
                            OutCtl.OutErr(" 0x%p is not a valid HSURF\n", SurfSpec.I64);
                        }
                        else
                        {
                            SurfAddr = SurfSpec.I64;
                            hr = S_OK;
                        }
                    }
                    else
                    {
                        ArgumentIsHandle = TRUE;
                    }
                }
            }

            if (hr == S_OK)
            {
                enum {
                    SF_hHmgr,
                    //SF_ulShareCount,
                    //SF_cExclusiveLock,
                    //SF_Tid,
                    SF_so_dhsurf,
                    SF_so_hsurf,
                    SF_so_dhpdev,
                    SF_so_hdev,
                    SF_so_sizlBitmap_cx,
                    SF_so_sizlBitmap_cy,
                    SF_so_cjBits,
                    SF_so_pvBits,
                    SF_so_pvScan0,
                    SF_so_lDelta,
                    SF_so_iUniq,
                    SF_so_iBitmapFormat,
                    SF_so_iType,
                    SF_so_fjBitmap,
                    //SF_pdcoAA,
                    //SF_SurfFlags,
                    SF_pPal,
                    //SF_EBitmap_hdc,
                    //SF_EBitmap_cRef,
                    //SF_EBitmap_hpalHint,
                    //SF_EBitmap_sizlDim_cx,
                    //SF_EBitmap_sizlDim_cy,

                    SF_TOTAL
                };

                DEBUG_VALUE         SurfValues[SF_TOTAL];
                DEBUG_VALUE         ObjHandle;
                TypeOutputParser    SurfParser(Client);     // SURFACE dump
                OutputFilter        OutFilter(Client);      // For other misc types
                OutputState         OutState(Client);
                OutputControl       OutCtlToFilter;
                ULONG64             SurfAddrFromHmgr;
                CHAR                szFallbackDTCmd[128];

                struct {
                    BITMAPINFOHEADER    bmiHeader;
                    DWORD               bmiColors[256];
                } bmi;


                for (int svi = 0; svi < SF_TOTAL; svi++)
                {
                    SurfValues[svi].Type = DEBUG_VALUE_INVALID;
                }

                if ((hr = OutState.Setup(0, &SurfParser)) != S_OK ||
                    ((hr = OutState.OutputTypeVirtual(SurfAddr,
                                                      "SURFACE",
                                                      DEBUG_OUTTYPE_BLOCK_RECURSE)) != S_OK &&
                     ((sprintf(szFallbackDTCmd,
                               "dt " GDIType(SURFACE) " hHmgr -y so. -y so.sizlBitmap. pPal 0x%I64x",
                               SurfAddr) == 0) ||
                      (hr = OutState.Execute(szFallbackDTCmd)) != S_OK)) ||
                    (hr = SurfParser.Get(&SurfValues[SF_hHmgr],
                                         "hHmgr",
                                         DEBUG_VALUE_INT64)) != S_OK)
                {
                    OutCtl.OutErr("Unable to get contents of SURFACE::hHmgr\n");
                    OutCtl.OutErr("  (Type Read returned %s)\n", pszHRESULT(hr));
                    if (AddressIsSURFOBJ)
                    {
                        OutCtl.OutErr(" 0x%p is not a valid SURFOBJ address\n", SurfSpec.I64);
                    }
                    else if (AddressIsSURFACE)
                    {
                        OutCtl.OutErr(" 0x%p is not a valid SURFACE address\n", SurfSpec.I64);
                    }
                    else if (ArgumentIsHandle)
                    {
                        OutCtl.OutErr(" although 0x%p is a valid HSURF\n", SurfSpec.I64);
                    }
                    else
                    {
                        OutCtl.OutErr(" 0x%p is neither an HSURF nor valid SURFACE address\n", SurfSpec.I64);
                    }
                }
                else if ((hr = OutState.Setup(0, &OutFilter)) != S_OK ||
                         (hr = OutCtlToFilter.SetControl(DEBUG_OUTCTL_THIS_CLIENT |
                                                         DEBUG_OUTCTL_NOT_LOGGED |
                                                         DEBUG_OUTCTL_OVERRIDE_MASK,
                                                         OutState.Client)) != S_OK)
                {
                    OutCtl.OutErr("Error preparing misc type reader.\n");
                }
                else
                {
                    if (!ArgumentIsHandle)
                    {
                        if (GetObjectAddress(Client, SurfValues[SF_hHmgr].I64, &SurfAddrFromHmgr,
                                             SURF_TYPE, TRUE, FALSE) == S_OK &&
                            SurfAddrFromHmgr != SurfAddr)
                        {
                            OutCtl.OutWarn("\tNote: SURFACE may not be valid.\n"
                                           "\t      It does not have a valid handle manager entry.\n");
                        }
                    }

                    if (SurfParser.Get(&SurfValues[SF_so_hsurf], "hsurf", DEBUG_VALUE_INT64) != S_OK)
                    {
                        OutCtl.OutWarn("Warning: Couldn't read hsurf.\n");
                    }
                    else
                    {
                        if (SurfValues[SF_so_hsurf].I64 != SurfValues[SF_hHmgr].I64)
                        {
                            OutCtl.OutWarn("Warning: hsurf, 0x%p, != hHmgr, 0x%p.\n",
                                           SurfValues[SF_so_hsurf].I64,
                                           SurfValues[SF_hHmgr].I64);
                        }
                    }

                    // Check dimensions
                    if (DimsFound < 2)
                    {
                        dim[left].I32 = 0;
                        dim[top].I32 = 0;
                    }

                    if ((hr = SurfParser.Get(&SurfValues[SF_so_sizlBitmap_cx], "cx", DEBUG_VALUE_INT32)) != S_OK ||
                        (hr = SurfParser.Get(&SurfValues[SF_so_sizlBitmap_cy], "cy", DEBUG_VALUE_INT32)) != S_OK)
                    {
                        if (DimsFound == 4 && dim[cx].Type == DEBUG_VALUE_INT32 && dim[cy].Type == DEBUG_VALUE_INT32)
                        {
                            hr = S_OK;
                            bmi.bmiHeader.biWidth = dim[cx].I32;
                            bmi.bmiHeader.biHeight = dim[cy].I32;
                        }
                        else
                        {
                            OutCtl.OutErr("Error: Couldn't get SURFACE dimensions.\n");
                        }
                    }
                    else
                    {
                        bmi.bmiHeader.biWidth = SurfValues[SF_so_sizlBitmap_cx].I32;
                        bmi.bmiHeader.biHeight = SurfValues[SF_so_sizlBitmap_cy].I32;

                        bmi.bmiHeader.biWidth -= dim[left].I32;
                        bmi.bmiHeader.biHeight -= dim[top].I32;

                        if (DimsFound == 4)
                        {
                            if ((LONG)dim[cx].I32 < bmi.bmiHeader.biWidth)
                            {
                                bmi.bmiHeader.biWidth = (LONG)dim[cx].I32;
                            }
                            if ((LONG)dim[cy].I32 < bmi.bmiHeader.biHeight)
                            {
                                bmi.bmiHeader.biHeight = (LONG)dim[cy].I32;
                            }
                        }
                    }

                    if (hr == S_OK)
                    {
                        if (bmi.bmiHeader.biWidth <= 0)
                        {
                            OutCtl.OutWarn("Error: Invalid x dimensions.\n");
                            hr = S_FALSE;
                        }
                        else if (bmi.bmiHeader.biHeight <= 0)
                        {
                            OutCtl.OutWarn("Error: Invalid y dimensions.\n");
                            hr = S_FALSE;
                        }
                    }

                    // Check pvScan0
                    if (hr == S_OK)
                    {
                        if ((hr = SurfParser.Get(&SurfValues[SF_so_pvScan0], "pvScan0", DEBUG_VALUE_INT64)) != S_OK)
                        {
                            if (pvScan0.Type == DEBUG_VALUE_INT64 && pvScan0.I64 != 0)
                            {
                                hr = S_OK;
                            }
                            else
                            {
                                OutCtl.OutErr("Error: Couldn't get address of first scanline.\n");
                                if (SurfParser.Get(&SurfValues[SF_so_dhsurf], "dhsurf", DEBUG_VALUE_INT64) == S_OK)
                                {
                                    OutCtl.Output(" dhsurf is 0x%p.\n", SurfValues[SF_so_dhsurf].I64);
                                }
                            }
                        }
                        else if (SurfValues[SF_so_pvScan0].I64 == 0 &&
                                 pvScan0.Type == DEBUG_VALUE_INT64 &&
                                 pvScan0.I64 != 0)
                        {
                            OutCtl.OutWarn("  Overriding pvScan0, 0x%p, with 0x%p.\n",
                                           SurfValues[SF_so_pvScan0].I64,
                                           pvScan0.I64);
                        }
                        else
                        {
                            pvScan0 = SurfValues[SF_so_pvScan0];
                        }
                    }

                    // Check lDelta
                    if (hr == S_OK)
                    {
                        if ((hr = SurfParser.Get(&SurfValues[SF_so_lDelta], "lDelta", DEBUG_VALUE_INT64)) != S_OK)
                        {
                            if (lDelta.Type == DEBUG_VALUE_INT64 && lDelta.I64 != 0)
                            {
                                hr = S_OK;
                            }
                            else
                            {
                                OutCtl.OutErr("Error: Couldn't get SURFACE lDelta.\n");
                                if (SurfParser.Get(&SurfValues[SF_so_dhsurf], "dhsurf", DEBUG_VALUE_INT64) == S_OK)
                                {
                                    OutCtl.Output(" dhsurf is 0x%p.\n", SurfValues[SF_so_dhsurf].I64);
                                }
                            }
                        }
                        else if (SurfValues[SF_so_lDelta].I64 == 0 &&
                                 lDelta.Type == DEBUG_VALUE_INT64 &&
                                 lDelta.I64 != 0)
                        {
                            OutCtl.OutWarn("  Overriding lDelta, 0x%p, with 0x%p.\n",
                                           SurfValues[SF_so_lDelta].I64,
                                           lDelta.I64);
                        }
                        else
                        {
                            lDelta = SurfValues[SF_so_lDelta];
                        }
                    }

                    // Check iBitmapFormat
                    if (hr == S_OK)
                    {
                        if ((hr = SurfParser.Get(&SurfValues[SF_so_iBitmapFormat], "iBitmapFormat", DEBUG_VALUE_INT64)) != S_OK)
                        {
                            if (iBitmapFormat.Type == DEBUG_VALUE_INT64 && iBitmapFormat.I64 != 0)
                            {
                                hr = S_OK;
                            }
                            else
                            {
                                OutCtl.OutErr("Error: Couldn't get SURFACE iBitmapFormat.\n");
                            }
                        }
                        else if (SurfValues[SF_so_iBitmapFormat].I64 == 0 &&
                                 iBitmapFormat.Type == DEBUG_VALUE_INT64 &&
                                 iBitmapFormat.I64 != 0)
                        {
                            OutCtl.OutWarn("  Overriding iBitmapFormat, 0x%p, with 0x%p.\n",
                                           SurfValues[SF_so_iBitmapFormat].I64,
                                           iBitmapFormat.I64);
                        }
                        else
                        {
                            iBitmapFormat = SurfValues[SF_so_iBitmapFormat];
                        }
                    }

                    if (hr == S_OK)
                    {
                        bmi.bmiHeader.biSize = sizeof(bmi.bmiHeader);
                        bmi.bmiHeader.biPlanes = 1;
                        bmi.bmiHeader.biCompression = BI_RGB;

                        bmi.bmiHeader.biSizeImage = 0;
                        bmi.bmiHeader.biXPelsPerMeter = bmi.bmiHeader.biYPelsPerMeter = 0;
                        bmi.bmiHeader.biClrUsed = 0;
                        bmi.bmiHeader.biClrImportant = 0;

                        if (SurfValues[SF_so_iBitmapFormat].I32 == BMF_32BPP)
                        {
                            bmi.bmiHeader.biBitCount = 32;
                        }
                        else if (SurfValues[SF_so_iBitmapFormat].I32 == BMF_24BPP)
                        {
                            bmi.bmiHeader.biBitCount = 24;
                        }
                        else
                        {
                            if (SurfValues[SF_so_iBitmapFormat].I32 == BMF_16BPP)
                            {
                                bmi.bmiHeader.biBitCount = 16;
                            }
                            else if (SurfValues[SF_so_iBitmapFormat].I32 == BMF_8BPP)
                            {
                                bmi.bmiHeader.biBitCount = 8;
                            }
                            else if (SurfValues[SF_so_iBitmapFormat].I32 == BMF_4BPP)
                            {
                                bmi.bmiHeader.biBitCount = 4;
                            }
                            else if (SurfValues[SF_so_iBitmapFormat].I32 == BMF_1BPP)
                            {
                                bmi.bmiHeader.biBitCount = 1;
                            }
                            else
                            {
                                OutCtl.OutErr("Unrecognized iBitmapFormat %ld.\n", SurfValues[SF_so_iBitmapFormat].I32);
                                hr = S_FALSE;
                            }
                        }
                    }

                    if (hr == S_OK && bmi.bmiHeader.biBitCount < 24)
                    {
                        // Get PALETTE
                        if (SurfParser.Get(&SurfValues[SF_pPal], "pPal", DEBUG_VALUE_INT64) == S_OK)
                        {
                            if (pPal.Type == DEBUG_VALUE_INT64)
                            {
                                if (SurfValues[SF_pPal].I64 != 0 &&
                                    pPal.I64 != SurfValues[SF_pPal].I64)
                                {
                                    OutCtl.OutWarn(" Overriding PALETTE address, 0x%p, with 0x%p.\n",
                                                   SurfValues[SF_pPal].I64,
                                                   pPal.I64);
                                }
                            }
                            else
                            {
                                pPal = SurfValues[SF_pPal];
                            }
                        }
                        else if (pPal.Type != DEBUG_VALUE_INT64)
                        {
                            OutCtl.OutWarn(" Error reading PALETTE address from SURFACE.\n");
                        }

                        // Try getting the PALETTE from the PDEV if need be
                        if (pPal.Type != DEBUG_VALUE_INT64 || pPal.I64 == 0)
                        {
                            if ((hr = SurfParser.Get(&SurfValues[SF_so_hdev], "hdev", DEBUG_VALUE_INT64)) == S_OK &&
                                SurfValues[SF_so_hdev].I64 != 0)
                            {
                                OutFilter.DiscardOutput();

                                if ((hr = OutState.OutputTypeVirtual(SurfValues[SF_so_hdev].I64, "PDEV", 0)) != S_OK ||
                                    (hr = OutFilter.Query("ppalSurf", &pPal, DEBUG_VALUE_INT64)) != S_OK)
                                {
                                    OutCtl.OutErr(" Error reading PALETTE address from PDEV.\n");
                                    pPal.Type = DEBUG_VALUE_INVALID;
                                }
                            }
                        }

                        // Read PALETTE settings
                        if (pPal.Type == DEBUG_VALUE_INT64 && pPal.I64 != 0)
                        {
                            PCSTR   ReqPALETTEFields[] = {
                                "flPal",
                                "cEntries",
                                "apalColor",
                                NULL
                            };

                            TypeOutputDumper    PALReader(OutState.Client, &OutCtlToFilter);
                            DEBUG_VALUE         cEntries;
                            DEBUG_VALUE         ppalColor;
                            BOOL                Check565 = FALSE;
                            BOOL                Check555 = FALSE;

                            PALReader.IncludeMarked();
                            PALReader.MarkFields(ReqPALETTEFields);

                            OutFilter.DiscardOutput();

                            if ((hr = PALReader.OutputVirtual("PALETTE", pPal.I64)) == S_OK &&
                                (hr = OutFilter.Query("cEntries", &cEntries, DEBUG_VALUE_INT32)) == S_OK)
                            {
                                bmi.bmiHeader.biClrUsed = cEntries.I32;

                                if ((hr = OutFilter.Query("PAL_FIXED")) != S_OK &&
                                    (hr = OutFilter.Query("PAL_INDEXED")) != S_OK)
                                {
                                    OutCtl.OutErr(" Error: vsurf only supports fixed and indexed palettes.\n");
                                }
                                else if (OutFilter.Query("PAL_BITFIELDS") == S_OK)
                                {
                                    if (bmi.bmiHeader.biClrUsed > 0)
                                    {
                                        OutCtl.OutErr(" Error: PALETTE @ 0x%p is BITFIELDS, but has Entries.\n", pPal.I64);
                                        hr = S_FALSE;
                                    }
                                    else
                                    {
                                        bmi.bmiHeader.biCompression = BI_BITFIELDS;
                                        bmi.bmiHeader.biClrUsed = 3;

                                        if (OutFilter.Query("PAL_RGB16_565") == S_OK)
                                        {
                                            Check565 = TRUE;
                                        }
                                        else if (OutFilter.Query("PAL_RGB16_555") == S_OK)
                                        {
                                            Check555 = TRUE;
                                        }
                                        else
                                        {
                                            OutCtl.OutWarn(" Warning: Nonstandard bitfields format in PALETTE @ 0x%p.\n",
                                                          pPal.I64);
                                        }
                                    }
                                }

                                if (hr == S_OK && bmi.bmiHeader.biClrUsed > 0)
                                {
                                    if (bmi.bmiHeader.biClrUsed > 256 ||
                                        OutFilter.Query("apalColor", &ppalColor, DEBUG_VALUE_INT64) != S_OK ||
                                        ppalColor.I64 == 0)
                                    {
                                        OutCtl.OutErr(" Error: PALETTE @ 0x%p is invalid.\n", pPal.I64);
                                        hr = S_FALSE;
                                    }
                                    else
                                    {
                                        ULONG PALBytes = bmi.bmiHeader.biClrUsed * sizeof(DWORD);
                                        ULONG BytesRead;

                                        OutCtl.OutVerb("Reading %ld palette entries @ 0x%p.\n", 
                                                       bmi.bmiHeader.biClrUsed, ppalColor.I64);

                                        hr = Data->ReadVirtual(ppalColor.I64, bmi.bmiColors, PALBytes, &BytesRead);
                                        if (hr != S_OK)
                                        {
                                            OutCtl.OutErr("Error: Couldn't read any PALETTE entries at 0x%p.\n", ppalColor.I64);
                                        }
                                        else if (BytesRead != PALBytes)
                                        {
                                            OutCtl.OutErr("Error: Only read %lu of %lu bytes from PALETTE entries at 0x%p.\n",
                                                          BytesRead,
                                                          PALBytes,
                                                          ppalColor.I64);
                                            hr = S_FALSE;
                                        }
                                        else
                                        {
                                            if (Check565)
                                            {
                                                if (bmi.bmiColors[0] != 0xf800 ||
                                                    bmi.bmiColors[1] != 0x07e0 ||
                                                    bmi.bmiColors[2] != 0x001f)
                                                {
                                                    OutCtl.OutWarn(" Palette bitfields don't match standard 565 format.\n");
                                                }
                                            }
                                            else if (Check555)
                                            {
                                                if (bmi.bmiColors[0] != 0x7c00 ||
                                                    bmi.bmiColors[1] != 0x03e0 ||
                                                    bmi.bmiColors[2] != 0x001f)
                                                {
                                                    OutCtl.OutWarn(" Palette bitfields don't match standard 555 format.\n");
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else
                            {
                                OutCtl.OutErr(" Error reading PALETTE.\n");
                            }
                        }
                        else
                        {
                            OutCtl.OutErr("Error: Unable to obtain valid PALETTE address.\n");
                            if (hr == S_OK) hr = S_FALSE;
                        }
                    }

                    if (hr == S_OK)
                    {
                        // We have all the format information we need from the target.
                        ULONG       FirstBit = dim[left].I32*bmi.bmiHeader.biBitCount;
                        LONG        xOrigin;
                        LONG        Width;
                        HBITMAP     hBitmap;
                        LPVOID      pDIBits;

                        if (SurfParser.Get(&SurfValues[SF_so_iUniq], "iUniq", DEBUG_VALUE_INT32) != S_OK)
                        {
                            SurfValues[SF_so_iUniq].I32 = 0;
                        }

                        // Save original width and adjust for full byte reads if needed
                        xOrigin = (LONG)(FirstBit & 0x7);
                        Width = (LONG)bmi.bmiHeader.biWidth;
                        bmi.bmiHeader.biWidth += (FirstBit & 0x7);
                        bmi.bmiHeader.biWidth = (bmi.bmiHeader.biWidth + 0x7) & ~0x7;

                        // Create a Top-Down DIB Section
                        bmi.bmiHeader.biHeight = -bmi.bmiHeader.biHeight;

                        hBitmap = CreateDIBSection(NULL, (LPBITMAPINFO)&bmi, DIB_RGB_COLORS, &pDIBits, NULL, 0);

                        if (hBitmap)
                        {
                            DIBSECTION  ds;

                            if (GetObject(hBitmap, sizeof(ds), &ds) != 0)
                            {
                                HRESULT hr = S_OK;
                                PBYTE   pBits = (PBYTE)pDIBits;
                                ULONG64 ScanAddr = pvScan0.I64;
                                ULONG   ScanSize;
                                ULONG   ScanBytesRead;
                                BOOL    GoodRead = FALSE;
                                LONG    LastScanWithData = -1;

                                ScanSize = ds.dsBm.bmWidthBytes;

                                ScanAddr += FirstBit/8 + dim[top].I32*lDelta.I64;

                                for (LONG y = 0; y < ds.dsBm.bmHeight; y++)
                                {
                                    OutCtl.Output(".");
                                    if (y % 70 == 69) OutCtl.Output("%ld%% read\n", 100*y/ds.dsBm.bmHeight);

                                    if (OutCtl.GetInterrupt() == S_OK)
                                    {
                                        break;
                                    }

                                    if ((hr = Data->ReadVirtual(ScanAddr, pBits, ScanSize, &ScanBytesRead)) != S_OK)
                                    {
                                        ScanBytesRead = 0;
                                        hr = S_OK;
                                    }
                                    else
                                    {
                                        GoodRead = TRUE;
                                    }

                                    if (ScanBytesRead != ScanSize)
                                    {
                                        if (LastScanWithData+1 == y || ScanBytesRead != 0)
                                        {
                                            OutCtl.OutErr("ReadVirtual(0x%p) failed read @ 0x%p (scan %ld).\n", ScanAddr, ScanAddr+ScanBytesRead, y);
                                        }
                                        RtlZeroMemory(pBits+ScanBytesRead,ScanSize-ScanBytesRead);

                                        // If this scan crosses into next page,
                                        // try reading a partial scan from that page.
                                        if (ScanBytesRead == 0 && PageSize != 0)
                                        {
                                            ULONG64 NextPage;
                                            ULONG ReadSize;

                                            for (NextPage = (ScanAddr + PageSize) & ~((ULONG64)PageSize-1);
                                                 NextPage < ScanAddr + ScanSize;
                                                 NextPage += PageSize
                                                 )
                                            {
                                                ReadSize = ScanSize - (ULONG)(NextPage - ScanAddr);
                                                if (Data->ReadVirtual(NextPage, pBits + ScanSize - ReadSize, ReadSize, &ScanBytesRead) == S_OK)
                                                {
                                                    GoodRead = TRUE;
                                                    if (ScanBytesRead != 0)
                                                    {
                                                        OutCtl.OutErr("Partial scan read of %lu bytes succeeded @ 0x%p (scan %ld).\n", ScanBytesRead, NextPage, y);
                                                        if (ScanBytesRead == ReadSize) break;
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    if (ScanBytesRead != 0)
                                    {
                                        if (LastScanWithData+1 != y && ScanBytesRead == ScanSize)
                                        {
                                            OutCtl.OutErr("Next fully successful ReadVirtual @ 0x%p (scan %ld).\n", ScanAddr, y);
                                        }
                                        LastScanWithData = y;
                                    }

                                    pBits += ScanSize;
                                    ScanAddr += lDelta.I64;
                                }

                                OutCtl.Output("\n");

                                if (LastScanWithData + 1 != ds.dsBm.bmHeight)
                                {
                                    OutCtl.OutErr("Scans %ld to %ld weren't read.\n",
                                                  LastScanWithData + 1,
                                                  ds.dsBm.bmHeight - 1);
                                }

                                SURF_INFO   SurfInfo = { {0}, hBitmap,
                                                        xOrigin,
                                                        0,
                                                        Width,
                                                        ds.dsBm.bmHeight,
                                                        ds.dsBm.bmBitsPixel
                                                        };

                                _stprintf(SurfInfo.SurfName,
                                          "%s @ 0x%I64x (%lu,%lu)-(%lu,%lu) [Uniq=0x%lx]",
                                          ((AddressIsSURFOBJ) ?
                                            _T("SURFOBJ") :
                                            _T("SURFACE")),
                                          ((AddressIsSURFOBJ) ?
                                            SurfSpec.I64 :
                                            SurfAddr),
                                          dim[left].I32,
                                          dim[top].I32,
                                          dim[left].I32 + Width,
                                          dim[top].I32 + ds.dsBm.bmHeight,
                                          SurfValues[SF_so_iUniq].I32);

                                if (GoodRead)
                                {
                                    OutCtl.OutVerb("%s %s\n",
                                                   ((pszMetaFile != NULL) ?
                                                    "Saving" : "Displaying"),
                                                   SurfInfo.SurfName);
                                }

                                if (!GoodRead)
                                {
                                    OutCtl.OutErr("No image data was read.\n");
                                    DeleteObject(hBitmap);
                                }
                                else if (pszMetaFile != NULL || DisplayToDesktop)
                                {
                                    HDC hdcSurface = CreateCompatibleDC(NULL);

                                    if (hdcSurface == NULL ||
                                        SelectObject(hdcSurface, hBitmap) == NULL)
                                    {
                                        OutCtl.OutErr("Error: Failed to prepare captured surface for Blt.\n");
                                        OutCtl.OutVerb(" Last error: 0x%lx.\n", GetLastError());
                                    }
                                    else
                                    {
                                        if (pszMetaFile != NULL)
                                        {
                                            HDC hdcMeta = CreateEnhMetaFile(NULL, pszMetaFile, NULL, SurfInfo.SurfName);

                                            if (hdcMeta == NULL ||
                                                !BitBlt(hdcMeta, 0, 0, Width, ds.dsBm.bmHeight,
                                                        hdcSurface, xOrigin, 0, SRCCOPY))
                                            {
                                                OutCtl.OutErr("Error: Save to metafile failed.\n");
                                                OutCtl.OutVerb(" Last error: 0x%lx.\n", GetLastError());
                                            }

                                            DeleteEnhMetaFile(CloseEnhMetaFile(hdcMeta));
                                        }

                                        if (DisplayToDesktop)
                                        {
                                            HDC hdcScreen = GetDC(NULL);

                                            if (hdcScreen == NULL ||
                                                !Rectangle(hdcScreen, 0, 0, ds.dsBm.bmWidth+2, ds.dsBm.bmHeight+2) ||
                                                !BitBlt(hdcScreen, 1, 1, Width, ds.dsBm.bmHeight,
                                                        hdcSurface, xOrigin, 0, SRCCOPY))
                                            {
                                                OutCtl.OutErr("Error: Display to screen failed.\n");
                                                OutCtl.OutVerb(" Last error: 0x%lx.\n", GetLastError());
                                            }

                                            ReleaseDC(NULL, hdcScreen);
                                        }
                                    }

                                    DeleteObject(hBitmap);
                                    DeleteDC(hdcSurface);
                                }
                                else if (CreateViewer(Client, &SurfInfo) == 0)
                                {
                                    OutCtl.OutErr("CreateViewer failed.\n");
                                    DbgPrint("CreateViewer failed.\n");
                                    DeleteObject(hBitmap);
                                }
                            }
                            else
                            {
                                OutCtl.OutErr("GetDIBits failed.\n");
                                DeleteObject(hBitmap);
                            }
                        }
                        else
                        {
                            OutCtl.OutErr("CreateDIBSection failed.\n");
                            OutCtl.OutVerb(" GetLastError: 0x%lx.\n", GetLastError());
                        }
                    }
                    else
                    {
                        OutCtl.OutErr("Error: Couldn't read required SURFACE fields.\n");
                    }
                }
            }

            if (Data != NULL) Data->Release();
            if (Symbols != NULL) Symbols->Release();
        }
    }

    if (pszMetaFile != NULL)
    {
        HeapFree(GetProcessHeap(), 0, pszMetaFile);
    }

    return hr;
}


                                
LONG
DebuggerExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo,
    PDEBUG_CLIENT Client,
    PCSTR Interface,
    PCSTR Func
    )
{
    // Any references to objects will be leaked.

    OutputControl   OutCtl(Client);
    CHAR            szBuffer[80];

    if (Interface != NULL && Func != NULL)
    {
        OutCtl.OutErr("%08x Exception in debugger %s.%s.\n",
                      ExceptionInfo->ExceptionRecord->ExceptionCode,
                      Interface,
                      Func
                      );
    }
    else
    {
        OutCtl.OutErr("%08x Exception in extension %s.\n",
               ExceptionInfo->ExceptionRecord->ExceptionCode,
               Func
               );
    }

    _snprintf(szBuffer, sizeof(szBuffer),
              "      PC: 0x%p  ExceptionInformation: 0x%p 0x%p 0x%p\n",
                  ExceptionInfo->ExceptionRecord->ExceptionAddress,
                  ExceptionInfo->ExceptionRecord->ExceptionInformation[0],
                  ExceptionInfo->ExceptionRecord->ExceptionInformation[1],
                  ExceptionInfo->ExceptionRecord->ExceptionInformation[2]
              );
    OutCtl.OutErr("%s", szBuffer);

    return EXCEPTION_EXECUTE_HANDLER;
}


HRESULT
AssembleTempRoutine(
    PDEBUG_CLIENT Client,
    Instruction *instructions,
    PCSTR Arguments
    )
{
    static BOOL                 CodeWritten = FALSE;
    static PDEBUG_CONTROL2      Control = NULL;
    static PDEBUG_DATA_SPACES   Data = NULL;
    static PDEBUG_REGISTERS     Registers = NULL;
    static PDEBUG_SYMBOLS       Symbols = NULL;
    static ULONG                RegisterCount = 0;
    static PDEBUG_VALUE         SavedRegisters = NULL;
    static ULONG64              IP = 0;
    static BYTE                 OldCode[256] = "";
    static ULONG                CodeRead = 0;
    static ULONG64              FinalIP = 0;

    HRESULT         hr;
    OutputControl   OutCtl(Client);

    ULONG           CodeRestored;

    if (!CodeWritten && RegisterCount == 0)
    {
        if ((hr = Client->QueryInterface(__uuidof(IDebugControl2),
                                         (void **)&Control)) == S_OK &&
            (hr = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                         (void **)&Data)) == S_OK &&
            (hr = Client->QueryInterface(__uuidof(IDebugRegisters),
                                         (void **)&Registers)) == S_OK &&
            (hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                         (void **)&Symbols)) == S_OK)
        {
            DEBUG_VALUE     Argument;
            ULONG           Rem;

            ULONG64         LimitIP;
            ULONG64         AsmIP;
            ULONG64         StartIP;
            ULONG64         EndIP;
            ULONG           CodeEmitted;

            if (hr == S_OK &&
                (hr = Registers->GetInstructionOffset(&IP)) == S_OK &&
                (hr = Data->ReadVirtual(IP, OldCode, sizeof(OldCode), &CodeRead)) == S_OK &&
                CodeRead == sizeof(OldCode))
            {
                OutCtl.Output("Code from 0x%p to 0x%p saved.\n", IP, IP+CodeRead);

                LimitIP = IP + CodeRead - 0x20;     // Enough space for any instruction
                StartIP = EndIP = IP;

                for (int i = 0; hr == S_OK && instructions[i].Code != NULL; i++)
                {
                    AsmIP = EndIP;

                    if (AsmIP > LimitIP)
                    {
                        OutCtl.OutErr("\nError: There may not be enough code saved to assemble @ 0x%p.\n"
                                      "\n       Aborting to be on the safe side.",
                                      AsmIP);

                        hr = E_OUTOFMEMORY;
                    }

                    if (hr == S_OK &&
                        instructions[i].Flags & I_WRITE_ADDRESS)
                    {
                        hr = Evaluate(Client, Arguments,
                                      DEBUG_VALUE_INT32, EVALUATE_DEFAULT_RADIX,
                                      &Argument, &Rem, NULL, EVALUATE_COMPACT_EXPR);

                        if (hr == S_OK)
                        {
                            Arguments += Rem;
                        }
                        else
                        {
                            OutCtl.OutErr("\nMissing address for instruction %#lu '%s'",
                                          i,
                                          (instructions[i].ByteLen == 0) ?
                                           instructions[i].Code :
                                           "Emitted Bytes");
                        }
                    }

                    if (hr == S_OK)
                    {
                        if (instructions[i].Flags & I_START_IP)
                        {
                            StartIP = AsmIP;
                        }

                        OutCtl.Output(".");
                        if (instructions[i].ByteLen > 0)
                        {
                            OutCtl.OutVerb(" Emitting %lu bytes @ 0x%p...\n",
                                          instructions[i].ByteLen, AsmIP);
                            hr = Data->WriteVirtual(AsmIP, instructions[i].Code, instructions[i].ByteLen, &CodeEmitted);
                            if (hr == S_OK)
                            {
                                if (CodeEmitted == instructions[i].ByteLen)
                                    EndIP = AsmIP + CodeEmitted;
                                else
                                    hr = E_FAIL;
                            }
                        }
                        else
                        {
                            OutCtl.OutVerb(" Assembling '%s' @ 0x%p...\n", instructions[i].Code, AsmIP);
                            hr = Control->Assemble(AsmIP, instructions[i].Code, &EndIP);
                        }
                    }

                    if (hr == S_OK)
                    {
                        if (instructions[i].Flags & I_WRITE_ADDRESS)
                        {
                            hr = Data->WriteVirtual(EndIP-sizeof(Argument.I32),
                                                    &Argument.I32,
                                                    sizeof(Argument.I32),
                                                    &CodeEmitted);
                            if (hr == S_OK)
                            {
                                if (CodeEmitted != sizeof(Argument.I32))
                                {
                                    hr = E_FAIL;
                                }
                                else
                                {
                                    OutCtl.OutVerb("   Wrote argument 0x%lx at 0x%p.\n",
                                                   Argument.I32,
                                                   EndIP - sizeof(Argument.I32));
                                }
                            }

                            if (hr != S_OK)
                            {
                                OutCtl.Output("\nCouldn't write argument at 0x%p.",
                                              EndIP - sizeof(Argument.I32));
                            }
                        }
                    }
                }

                OutCtl.Output("\n");

                if (hr == S_OK)
                {
                    FinalIP = AsmIP;

                    if (EndIP - IP > sizeof(OldCode))
                    {
                        OutCtl.OutErr("Error: Didn't save enough code!\n"
                                      "  Code from 0x%p to 0x%p was trashed.\n",
                                      IP + sizeof(OldCode), EndIP);
                        hr = E_FAIL;
                    }
                }

                if (hr == S_OK)
                {
                    // Save registers
                    if ((hr = Registers->GetNumberRegisters(&RegisterCount)) == S_OK)
                    {
                        SavedRegisters = (PDEBUG_VALUE) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(DEBUG_VALUE)*RegisterCount);
                        if (SavedRegisters != NULL)
                        {
                            if ((hr = Registers->GetValues(RegisterCount, NULL, 0, SavedRegisters)) != S_OK)
                            {
                                HeapFree(GetProcessHeap(), 0, SavedRegisters);
                                SavedRegisters = NULL;
                                RegisterCount = 0;
                            }
                            else
                            {
                                OutCtl.OutVerb(" Saved %lu registers.\n", RegisterCount);
                            }
                        }
                        else
                        {
                            RegisterCount = 0;
                            hr = E_OUTOFMEMORY;
                        }
                    }

                    if (hr != S_OK)
                    {
                        OutCtl.Output("Error saving register values.\n");
                    }
                }

                if (hr == S_OK)
                {
                    CHAR    szDisasmCmd[64];

                    OutCtl.Output(" Temporary routine placed from 0x%p to 0x%p.\n",
                                  IP, EndIP);
                    OutCtl.Output("Please verify code, especially jumps:\n");
                    sprintf(szDisasmCmd, "u 0x%I64x 0x%I64x", IP, EndIP);
                    Control->Execute(DEBUG_OUTCTL_THIS_CLIENT,
                                     szDisasmCmd,
                                     DEBUG_EXECUTE_NOT_LOGGED |
                                     DEBUG_EXECUTE_NO_REPEAT);
                    OutCtl.Output("Then set IP to 0x%p and run machine.\n", StartIP);

                    CodeWritten = TRUE;
                }
                else
                {
                    if (Data->WriteVirtual(IP, OldCode, CodeRead, &CodeRestored) != S_OK ||
                        CodeRestored != CodeRead)
                    {
                        OutCtl.OutErr("Error restoring original code.\n");
                    }
                }
            }
        }
    }
    else
    {
        HRESULT hrGetIP;
        ULONG64 ResultIP;
        HRESULT hrRestore = S_OK;

        hr = S_OK;

        if ((hrGetIP = Registers->GetInstructionOffset(&ResultIP)) == S_OK)
        {
            if (ResultIP != FinalIP)
            {
                OutCtl.OutWarn("Result IP = 0x%p differs from expected 0x%p.\n",
                               ResultIP, FinalIP);
            }
        }
        else
        {
            OutCtl.OutWarn("Unable to confirm result IP.\n");
            ResultIP = (FinalIP == 0) ? -1 : 0;
        }

        if (CodeWritten)
        {
            if (ResultIP == FinalIP ||
                (hrRestore = GetYNInput((PDEBUG_CONTROL)Control, "Restore code anyway?")) == S_OK)
            {
                if ((hr = Data->WriteVirtual(IP, OldCode, CodeRead, &CodeRestored)) == S_OK &&
                    CodeRestored == CodeRead)
                {
                    CodeWritten = FALSE;
                    IP = 0;

                    OutCtl.Output("Original code restored.\n");

                }
                else
                {
                    OutCtl.OutErr("Error restoring original code.\n");
                    if (hr == S_OK) hr = E_FAIL;
                }
            }
        }

        if (hr == S_OK &&
            RegisterCount != 0)
        {
            if (ResultIP == FinalIP ||
                (hrRestore = GetYNInput((PDEBUG_CONTROL)Control, "Restore register values anyway?")) == S_OK)
            {
                DEBUG_VALUE     NewRegValue;
                ULONG           Register;

                for (Register = 0; Register < RegisterCount && hr == S_OK; Register++)
                {
                    __try {
                        hr = Registers->SetValue(Register, &SavedRegisters[Register]);
                    }
                    __except(DebuggerExceptionFilter(GetExceptionInformation(),
                                                     Client,
                                                     "IDebugRegisters", "SetValue"))
                    {
                        hr = S_FALSE;
                    }

                    if (hr != S_OK)
                    {
                        RtlZeroMemory(&NewRegValue, sizeof(NewRegValue));
                        if (Registers->GetValue(Register, &NewRegValue) == S_OK)
                        {
                            if (!RtlEqualMemory(&SavedRegisters[Register], &NewRegValue, sizeof(NewRegValue)))
                            {
                                OutCtl.OutErr(" Registers %lu's value had changed.\n", Register);
                            }
                            else
                            {
                                OutCtl.Output(" However, registers %lu's value had NOT changed.\n", Register);
                                hr = S_OK;
                            }
                        }
                        else
                        {
                            OutCtl.OutErr(" Unable to check register %lu's current value.\n", Register);
                        }

                        if (hr != S_OK)
                        {
                            OutCtl.OutErr(" Register %lu's value has not been restored.\n", Register);
                            hr = GetYNInput((PDEBUG_CONTROL)Control, "Continue restoring registers?");
                        }
                    }
                }

                if (hr == S_OK)
                {
                    OutCtl.Output("Original register values restored.\n");
                }
                else
                {
                    OutCtl.OutErr("Error restoring original register values.\n");
                }
            }
            else
            {
                hr = S_FALSE;
            }

            if (hr != S_OK)
            {
                hr = GetYNInput((PDEBUG_CONTROL)Control, "Discard saved register values?");
            }

            if (hr == S_OK)
            {
                HeapFree(GetProcessHeap(), 0, SavedRegisters);
                SavedRegisters = NULL;
                RegisterCount = 0;
            }
        }

        if (hr == S_OK) hr = hrRestore;
    }

    if (!CodeWritten && RegisterCount == 0)
    {
        if (Symbols != NULL) { Symbols->Release(); Symbols = NULL; }
        if (Registers != NULL) { Registers->Release(); Registers = NULL; }
        if (Data != NULL) { Data->Release(); Data = NULL; }
        if (Control != NULL) { Control->Release(); Control = NULL; }
    }

    return hr;
}


Instruction PageInSurfs_x86_Instructions[] = {
    { 0, sizeof(x86_jmp_here), (PSTR) x86_jmp_here}, // To loop here
    { 0, 0, "int 3" },
    { I_START_IP, 0, "push	 @eax" },
    { 0, 0, "push	 @ecx" },
    { 0, 0, "push	 @edx" },
    { 0, 0, "mov	 @ecx, DWORD PTR [win32k!ghsemShareDevLock]" },
    { 0, 0, "call	 win32k!GreAcquireSemaphore" },
    { 0, 0, "mov	 @ecx, DWORD PTR [win32k!ghsemDriverMgmt]" },
    { 0, 0, "call	 win32k!GreAcquireSemaphore" },
    { 0, 0, "mov	 @ecx, DWORD PTR [win32k!ghsemHmgr]" },
    { 0, 0, "call	 win32k!GreAcquireSemaphore" },
    { 0, 0, "xor	 @ecx, @ecx" },
    { 0, sizeof(x86_jmp_plus_0x0e), (PSTR) x86_jmp_plus_0x0e}, // To loop condition
    // Loop start
    { 0, 0, "mov	 @ecx, DWORD PTR [@eax]" },
    { 0, 0, "mov	 @eax, DWORD PTR [@eax+0x30]" },
    { 0, 0, "cmp	 @eax, 0x80000000" },
    { 0, sizeof(x86_jb_plus_0x02), (PSTR) x86_jb_plus_0x02},   // To loop condition
    { 0, 0, "mov	 @eax, DWORD PTR [@eax]" },
    // Loop condition
    { 0, 0, "mov	 @dl, 5" },
    { 0, 0, "call	 win32k!HmgSafeNextObjt" },
    { 0, 0, "test	 @eax, @eax" },
    { 0, sizeof(x86_jne_minus_0x18), (PSTR) x86_jne_minus_0x18},   // To loop start
    { 0, 0, "mov	 @ecx, DWORD PTR [win32k!ghsemHmgr]" },
    { 0, 0, "call	 win32k!GreReleaseSemaphore" },
    { 0, 0, "mov	 @ecx, DWORD PTR [win32k!ghsemDriverMgmt]" },
    { 0, 0, "call	 win32k!GreReleaseSemaphore" },
    { 0, 0, "mov	 @ecx, DWORD PTR [win32k!ghsemShareDevLock]" },
    { 0, 0, "call	 win32k!GreReleaseSemaphore" },
    { 0, 0, "pop	 @edx" },
    { 0, 0, "pop	 @ecx" },
    { 0, 0, "pop	 @eax" },
    { 0, 0, "int 3" },
    { 0, 0, NULL }
};

DECLARE_API( pageinsurfs )
{
    BEGIN_API( pageinsurfs );

    HRESULT hr = S_OK;

    OutputControl   OutCtl(Client);
    Instruction    *instructions;

    switch (TargetMachine)
    {
        case IMAGE_FILE_MACHINE_I386:
            instructions = PageInSurfs_x86_Instructions;
            break;

        default:
        {
            OutCtl.OutWarn("This extension is only supported on x86 architectures.\n");
            hr = E_NOTIMPL;
            break;
        }
    }

    if (hr == S_OK)
    {
        hr = AssembleTempRoutine(Client, instructions, args);
    }

    return hr;
}



Instruction PageInSurface_x86_Instructions[] = {
    { 0, sizeof(x86_jmp_here), (PSTR) x86_jmp_here}, // To loop here
    { 0, 0, "int 3" },
    {I_START_IP, 0, "push	 @eax" },
    { 0, 0, "push	 @ecx" },
    { 0, 0, "push	 @edx" },
    { 0, 0, "push	 @esi" },
    { 0, 0, "mov	 @ecx, DWORD PTR [win32k!ghsemShareDevLock]" },
    { 0, 0, "call	 win32k!GreAcquireSemaphore" },
    { 0, 0, "mov	 @ecx, DWORD PTR [win32k!ghsemDriverMgmt]" },
    { 0, 0, "call	 win32k!GreAcquireSemaphore" },
    { 0, 0, "mov	 @ecx, DWORD PTR [win32k!ghsemHmgr]" },
    { 0, 0, "call	 win32k!GreAcquireSemaphore" },
    {I_WRITE_ADDRESS, 0, "mov	 @edx, 0xDeadBeef" },
    { 0, 0, "mov	 @esi, DWORD PTR [@edx+0x30]" },                // pvScan0
    { 0, 0, "cmp	 @esi, 0x80000000" },                           // Check User address/NULL
    { 0, 0, "mov	 @ecx, DWORD PTR [@edx+0x24]" },                // sizlBitmap.cy
    { 0, sizeof(x86_jb_plus_0x0c), (PSTR) x86_jb_plus_0x0c},        // To end
    { 0, 0, "test	 @ecx, @ecx" },                                 // Check scan
    { 0, sizeof(x86_jmp_plus_0x06), (PSTR) x86_jmp_plus_0x06},      // To loop condition
    // Loop start
    { 0, 0, "mov	 @eax, DWORD PTR [@esi]" },
    { 0, 0, "add	 @esi, DWORD PTR [@edx+0x34]" },                // lDelta
    { 0, 0, "dec    @ecx" },
    // Loop condition
    { 0, sizeof(x86_jnz_minus_0x08), (PSTR) x86_jnz_minus_0x08},    // To loop start
    // End
    { 0, 0, "mov	 @ecx, DWORD PTR [win32k!ghsemHmgr]" },
    { 0, 0, "call	 win32k!GreReleaseSemaphore" },
    { 0, 0, "mov	 @ecx, DWORD PTR [win32k!ghsemDriverMgmt]" },
    { 0, 0, "call	 win32k!GreReleaseSemaphore" },
    { 0, 0, "mov	 @ecx, DWORD PTR [win32k!ghsemShareDevLock]" },
    { 0, 0, "call	 win32k!GreReleaseSemaphore" },
    { 0, 0, "pop	 @esi" },
    { 0, 0, "pop	 @edx" },
    { 0, 0, "pop	 @ecx" },
    { 0, 0, "pop	 @eax" },
    { 0, 0, "int 3" },
    { 0, 0, NULL }
};

DECLARE_API( pageinsurface )
{
    BEGIN_API( pageinsurface );

    HRESULT hr = S_OK;

    OutputControl   OutCtl(Client);
    Instruction    *instructions;

    switch (TargetMachine)
    {
        case IMAGE_FILE_MACHINE_I386:
            instructions = PageInSurface_x86_Instructions;
            break;

        default:
        {
            OutCtl.OutWarn("This extension is only supported on x86 architectures.\n");
            hr = E_NOTIMPL;
            break;
        }
    }

    if (hr == S_OK)
    {
        hr = AssembleTempRoutine(Client, instructions, args);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\session.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    session.cxx

Abstract:

    This file contains the routines to handle session.

Author:

    Jason Hartman (JasonHa) 2000-09-28

Environment:

    User Mode

--*/

#include "precomp.hxx"


//
// Special defines
//

// ddk\inc\ntddk.h:
#define PROTECTED_POOL          0x80000000

// base\ntos\inc\pool.h:
#define POOL_QUOTA_MASK         8



#define SESSION_SEARCH_LIMIT    50

ULONG   SessionId = CURRENT_SESSION;
CHAR    SessionStr[16] = "CURRENT";

CachedType  HwPte = { FALSE, "NT!HARDWARE_PTE", 0, 0, 0 };

#define NUM_CACHED_SESSIONS 8

struct {
    ULONG   UniqueState;
    ULONG64 SessionSpaceAddr;
} CachedSession[NUM_CACHED_SESSIONS+1] = { { 0, 0 } };
ULONG ExtraCachedSessionId;

#define NUM_CACHED_DIR_BASES    8

struct {
    ULONG   UniqueState;
    ULONG64 PageDirBase;
} CachedDirBase[NUM_CACHED_DIR_BASES+1] = { { FALSE, 0} };


struct {
    ULONG   UniqueState;
    ULONG64 PhysAddr;
    ULONG64 Data;
} CachedPhysAddr[2] = { { 0, 0, 0} };

BitFieldInfo *MMPTEValid = NULL;
BitFieldInfo *MMPTEProto = NULL;
BitFieldInfo *MMPTETrans = NULL;
BitFieldInfo *MMPTEX86LargePage = NULL;
BitFieldInfo *MMPTEpfn = NULL;


/**************************************************************************\
*
* Routine Name:
*
*   SessionInit
*
* Routine Description:
*
*   Initialize or reinitialize information to be read from symbols files
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*
* Return Value:
*
*   none
*
\**************************************************************************/

void SessionInit(PDEBUG_CLIENT Client)
{
    for (int s = 0; s < sizeof(CachedSession)/sizeof(CachedSession[0]); s++)
    {
        CachedSession[s].UniqueState = INVALID_UNIQUE_STATE;
    }
    ExtraCachedSessionId = INVALID_SESSION;

    for (int s = 0; s < sizeof(CachedDirBase)/sizeof(CachedDirBase[0]); s++)
    {
        CachedDirBase[s].UniqueState = INVALID_UNIQUE_STATE;
    }

    if (MMPTEValid != NULL) MMPTEValid->Valid = FALSE;
    if (MMPTEProto != NULL) MMPTEProto->Valid = FALSE;
    if (MMPTETrans != NULL) MMPTETrans->Valid = FALSE;
    if (MMPTEX86LargePage != NULL) MMPTEX86LargePage->Valid = FALSE;
    if (MMPTEpfn != NULL) MMPTEpfn->Valid = FALSE;

    CachedPhysAddr[0].UniqueState = INVALID_UNIQUE_STATE;
    CachedPhysAddr[1].UniqueState = INVALID_UNIQUE_STATE;

    return;
}


/**************************************************************************\
*
* Routine Name:
*
*   SessionExit
*
* Routine Description:
*
*   Clean up any outstanding allocations or references
*
* Arguments:
*
*   none
*
* Return Value:
*
*   none
*
\**************************************************************************/

void SessionExit()
{
    if (MMPTEValid != NULL)
    {
        delete MMPTEValid;
        MMPTEValid = NULL;
    }

    if (MMPTEProto != NULL)
    {
        delete MMPTEProto;
        MMPTEProto = NULL;
    }

    if (MMPTETrans != NULL)
    {
        delete MMPTETrans;
        MMPTETrans = NULL;
    }

    if (MMPTEX86LargePage != NULL)
    {
        delete MMPTEX86LargePage;
        MMPTEX86LargePage = NULL;
    }

    if (MMPTEpfn != NULL)
    {
        delete MMPTEpfn;
        MMPTEpfn = NULL;
    }

    return;
}


/**************************************************************************\
*
* Routine Name:
*
*   GetMMPTEValid
*
* Routine Description:
*
*   Extract Valid value from MMPTE
*
\**************************************************************************/

HRESULT
GetMMPTEValid(
    PDEBUG_CLIENT Client,
    ULONG64 MMPTE64,
    PULONG64 Valid
    )
{
    HRESULT hr = S_FALSE;

    if (MMPTEValid == NULL)
    {
        MMPTEValid = new BitFieldInfo;
    }

    if (MMPTEValid == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (MMPTEValid->Valid)
    {
        hr = S_OK;
    }
    else
    {
        BitFieldParser      BitFieldReader(Client, MMPTEValid);
        OutputState         OutState(Client);

        if ((hr = BitFieldReader.Ready()) == S_OK &&
            (hr = OutState.Setup(0, &BitFieldReader)) == S_OK)
        {
            // Read Valid bit field from symbol file
            if (OutState.Execute("dt NT!HARDWARE_PTE Valid") != S_OK ||
                BitFieldReader.ParseOutput() != S_OK ||
                BitFieldReader.Complete() != S_OK)
            {
                MMPTEValid->Valid = MMPTEValid->Compose(0, 1);
                hr = MMPTEValid->Valid ? S_OK : S_FALSE;
            }
        }
    }

    if (Valid != NULL)
    {
        if (hr == S_OK)
        {
            *Valid = (MMPTE64 & MMPTEValid->Mask) >> MMPTEValid->BitPos;
        }
        else
        {
            *Valid = 0;
        }
    }

    return hr;
}


/**************************************************************************\
*
* Routine Name:
*
*   GetMMPTEProto
*
* Routine Description:
*
*   Extract Prototype value from MMPTE
*
\**************************************************************************/

HRESULT
GetMMPTEProto(
    PDEBUG_CLIENT Client,
    ULONG64 MMPTE64,
    PULONG64 Proto
    )
{
    HRESULT hr = S_FALSE;

    if (MMPTEProto == NULL)
    {
        MMPTEProto = new BitFieldInfo;
    }

    if (MMPTEProto == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (MMPTEProto->Valid)
    {
        hr = S_OK;
    }
    else
    {
        BitFieldParser      BitFieldReader(Client, MMPTEProto);
        OutputState         OutState(Client);

        if ((hr = BitFieldReader.Ready()) == S_OK &&
            (hr = OutState.Setup(0, &BitFieldReader)) == S_OK)
        {
            // Read Prototype bit field from symbol file
            if (OutState.Execute("dt NT!MMPTE_PROTOTYPE Prototype") != S_OK ||
                BitFieldReader.ParseOutput() != S_OK ||
                BitFieldReader.Complete() != S_OK)
            {
                switch (TargetMachine)
                {
                case IMAGE_FILE_MACHINE_I386:
                    MMPTEProto->Valid = MMPTEProto->Compose(10, 1);
                    break;
                case IMAGE_FILE_MACHINE_IA64:
                    MMPTEProto->Valid = MMPTEProto->Compose(1, 1);
                    break;
                default:
                    {
                        OutputControl   OutCtl(Client);
                        OutCtl.OutErr("Couldn't find MMPTE Prototype bit in type info.\n");
                    }
                }

                hr = MMPTEProto->Valid ? S_OK : S_FALSE;
            }
        }
    }

    if (Proto != NULL)
    {
        if (hr == S_OK)
        {
            *Proto = (MMPTE64 & MMPTEProto->Mask) >> MMPTEProto->BitPos;
        }
        else
        {
            *Proto = 0;
        }
    }

    return hr;
}


/**************************************************************************\
*
* Routine Name:
*
*   GetMMPTETrans
*
* Routine Description:
*
*   Extract Transition value from MMPTE
*
\**************************************************************************/

HRESULT
GetMMPTETrans(
    PDEBUG_CLIENT Client,
    ULONG64 MMPTE64,
    PULONG64 Trans
    )
{
    HRESULT hr = S_FALSE;

    if (MMPTETrans == NULL)
    {
        MMPTETrans = new BitFieldInfo;
    }

    if (MMPTETrans == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (MMPTETrans->Valid)
    {
        hr = S_OK;
    }
    else
    {
        BitFieldParser      BitFieldReader(Client, MMPTETrans);
        OutputState         OutState(Client);

        if ((hr = BitFieldReader.Ready()) == S_OK &&
            (hr = OutState.Setup(0, &BitFieldReader)) == S_OK)
        {
            // Read Transition bit field from symbol file
            if (OutState.Execute("dt NT!PROTOTYPE_PTE Transition") != S_OK ||
                BitFieldReader.ParseOutput() != S_OK ||
                BitFieldReader.Complete() != S_OK)
            {
                switch (TargetMachine)
                {
                case IMAGE_FILE_MACHINE_I386:
                    MMPTETrans->Valid = MMPTETrans->Compose(11, 1);
                    break;
                case IMAGE_FILE_MACHINE_IA64:
                    MMPTETrans->Valid = MMPTETrans->Compose(7, 1);
                    break;
                default:
                    {
                        OutputControl   OutCtl(Client);
                        OutCtl.OutErr("Couldn't find MMPTE Transition bit in type info.\n");
                    }
                }

                hr = MMPTETrans->Valid ? S_OK : S_FALSE;
            }
        }
    }

    if (Trans != NULL)
    {
        if (hr == S_OK)
        {
            *Trans = (MMPTE64 & MMPTETrans->Mask) >> MMPTETrans->BitPos;
        }
        else
        {
            *Trans = 0;
        }
    }

    return hr;
}


/**************************************************************************\
*
* Routine Name:
*
*   GetMMPTEX86LargePage
*
* Routine Description:
*
*   Extract LargePage value from X86 MMPTE
*
\**************************************************************************/

HRESULT
GetMMPTEX86LargePage(
    PDEBUG_CLIENT Client,
    ULONG64 MMPTE64,
    PULONG64 X86LargePage
    )
{
    HRESULT hr = S_FALSE;

    if (TargetMachine != IMAGE_FILE_MACHINE_I386)
    {
        if (X86LargePage != NULL) *X86LargePage = 0;
        return hr;
    }

    if (MMPTEX86LargePage == NULL)
    {
        MMPTEX86LargePage = new BitFieldInfo;
    }

    if (MMPTEX86LargePage == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (MMPTEX86LargePage->Valid)
    {
        hr = S_OK;
    }
    else
    {
        BitFieldParser      BitFieldReader(Client, MMPTEX86LargePage);
        OutputState         OutState(Client);

        if ((hr = BitFieldReader.Ready()) == S_OK &&
            (hr = OutState.Setup(0, &BitFieldReader)) == S_OK)
        {
            // Read LargePage bit field from symbol file
            if (OutState.Execute("dt NT!HARDWARE_PTE LargePage") != S_OK ||
                BitFieldReader.ParseOutput() != S_OK ||
                BitFieldReader.Complete() != S_OK)
            {
                MMPTEX86LargePage->Valid = MMPTEX86LargePage->Compose(7, 1);
                hr = MMPTEX86LargePage->Valid ? S_OK : S_FALSE;
            }
        }
    }

    if (X86LargePage != NULL)
    {
        if (hr == S_OK)
        {
            *X86LargePage = (MMPTE64 & MMPTEX86LargePage->Mask) >> MMPTEX86LargePage->BitPos;
        }
        else
        {
            *X86LargePage = 0;
        }
    }

    return hr;
}


/**************************************************************************\
*
* Routine Name:
*
*   GetMMPTEpfn
*
* Routine Description:
*
*   Extract Page Frame Number value from MMPTE
*
\**************************************************************************/

HRESULT
GetMMPTEpfn(
    PDEBUG_CLIENT Client,
    ULONG64 MMPTE64,
    PULONG64 pfn,
    FLONG Flags
    )
{
    HRESULT hr = S_FALSE;

    if (MMPTEpfn == NULL)
    {
        MMPTEpfn = new BitFieldInfo;
    }

    if (MMPTEpfn == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (MMPTEpfn->Valid)
    {
        hr = S_OK;
    }
    else
    {
        BitFieldParser      BitFieldReader(Client, MMPTEpfn);
        OutputState         OutState(Client);

        if ((hr = BitFieldReader.Ready()) == S_OK &&
            (hr = OutState.Setup(0, &BitFieldReader)) == S_OK)
        {
            // Read PageFrameNumber bit field from symbol file
            if (OutState.Execute("dt NT!HARDWARE_PTE PageFrameNumber") != S_OK ||
                BitFieldReader.ParseOutput() != S_OK ||
                BitFieldReader.Complete() != S_OK)
            {
                switch (TargetMachine)
                {
                case IMAGE_FILE_MACHINE_I386:
                    MMPTEpfn->Valid = MMPTEpfn->Compose(12, PaeEnabled ? 24 : 20);
                    break;
                case IMAGE_FILE_MACHINE_IA64:
                    if (PageSize)
                    {
                        MMPTEpfn->Valid = MMPTEpfn->Compose(PageShift, 50-PageShift);
                        break;
                    }
                default:
                    {
                        OutputControl   OutCtl(Client);
                        OutCtl.OutErr("Couldn't find MMPTE pfn in type info.\n");
                    }
                }
                hr = MMPTEpfn->Valid ? S_OK : S_FALSE;
            }
        }
    }

    if (pfn != NULL)
    {
        if (hr == S_OK)
        {
            *pfn = (MMPTE64 & MMPTEpfn->Mask);
            if (!(Flags & GET_BITS_UNSHIFTED))
            {
                *pfn >>= MMPTEpfn->BitPos;
            }
        }
        else
        {
            *pfn = 0;
        }
    }

    return hr;
}


HRESULT
GetSessionNumbers(
    IN PDEBUG_CLIENT Client,
    OUT PULONG CurrentSession,
    OUT PULONG DefaultSession,
    OUT PULONG TotalSessions
    )
{
    HRESULT hr = S_FALSE;

    if (CurrentSession != NULL)
    {
        DEBUG_VALUE         RunningSession;
        BasicOutputParser   SessionReader(Client, 1);
        OutputState         OutState(Client);

        if ((hr = SessionReader.LookFor(&RunningSession, "SessionId:", DEBUG_VALUE_INT32)) == S_OK &&
            (hr = OutState.Setup(0, &SessionReader)) == S_OK &&
            (hr = OutState.Execute("!process -1 0")) == S_OK &&
            (hr = SessionReader.ParseOutput()) == S_OK &&
            (hr = SessionReader.Complete()) == S_OK)
        {
            *CurrentSession = RunningSession.I32;
        }
        else
        {
            *CurrentSession = INVALID_SESSION;
        }
    }

    if (DefaultSession != NULL)
    {
        *DefaultSession = SessionId;
        hr = S_OK;
    }

    if (TotalSessions != NULL)
    {
        ULONG   SessionCount = 0;

        if (S_OK == ReadSymbolData(Client, "NT!MiSessionCount", &SessionCount, sizeof(SessionCount), NULL))
        {
            hr = S_OK;
        }
        *TotalSessions = SessionCount;
    }

    return hr;
}


HRESULT
SetDefaultSession(
    IN PDEBUG_CLIENT Client,
    IN ULONG NewSession,
    OUT OPTIONAL PULONG OldSession
    )
{
    HRESULT hr = S_FALSE;
    ULONG   SessionCount;

    GetSessionNumbers(Client, NULL, OldSession, &SessionCount);

    if ((NewSession == CURRENT_SESSION) ||
        (GetSessionSpace(Client, NewSession, NULL) == S_OK))
    {
        if (NewSession != SessionId)
        {
            SessionId = NewSession;

            if (SessionId == CURRENT_SESSION)
            {
                strcpy(SessionStr, "CURRENT");
            }
            else
            {
                _ultoa(SessionId, SessionStr, 10);
            }

        }

        hr = S_OK;
    }

    return hr;
}



HRESULT
GetCurrentSession(
    PDEBUG_CLIENT Client,
    PULONG64 CurSessionSpace,
    PULONG CurSessionId
    )
{
    static ULONG        LastCachedUniqueState = INVALID_UNIQUE_STATE;
    static DEBUG_VALUE  LastSessionSpace = { 0, DEBUG_VALUE_INVALID };
    static DEBUG_VALUE  LastSessionId = { INVALID_SESSION, DEBUG_VALUE_INVALID };

    HRESULT             hr = S_OK;
    OutputControl       OutCtl(Client);
    BasicOutputParser   SessionSpaceReader(Client);
    BasicOutputParser   SessionIdReader(Client);
    OutputState         OutState(Client);
    CHAR                szCommand[MAX_PATH];

    ULONG               CurrentUniqueState = UniqueTargetState;


    if (CurSessionSpace != NULL) *CurSessionSpace = 0;
    if (CurSessionId != NULL) *CurSessionId = INVALID_SESSION;

    // Get the current session space
    if (CurrentUniqueState == INVALID_UNIQUE_STATE ||
        LastCachedUniqueState != CurrentUniqueState ||
        LastSessionSpace.Type == DEBUG_VALUE_INVALID)
    {
        PDEBUG_SYSTEM_OBJECTS   System;
        ULONG64                 ProcessAddr;

        if ((hr = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&System)) == S_OK)
        {
            if ((hr = System->GetCurrentProcessDataOffset(&ProcessAddr)) == S_OK)
            {
                // Set Output callbacks
                if ((hr = SessionSpaceReader.LookFor(&LastSessionSpace, "Session", DEBUG_VALUE_INT64)) == S_OK &&
                    (hr = OutState.Setup(0, &SessionSpaceReader)) == S_OK)
                {
                    sprintf(szCommand, "dt NT!EPROCESS Session 0x%I64x", ProcessAddr);
                    if ((hr = OutState.Execute(szCommand)) == S_OK &&
                        (hr = SessionSpaceReader.ParseOutput()) == S_OK &&
                        (hr = SessionSpaceReader.Complete()) == S_OK)
                    {
                        if (LastSessionSpace.I64 == 0)
                        {
                            hr = E_FAIL;
                        }
                    }
                }

            }
            else
            {
                OutCtl.OutErr("IDebugSystemObjects::GetCurrentProcessDataOffset returned %s.\n", pszHRESULT(hr));
            }

            System->Release();
        }

        if (hr != S_OK)
        {
            LastSessionSpace.Type = DEBUG_VALUE_INVALID;
        }
        else
        {
            OutCtl.OutVerb("Caching current session space @ 0x%p.\n", LastSessionSpace.I64);

            // Update CachedUniqueState and make sure SessionID
            // is refreshed.
            if (CurrentUniqueState == INVALID_UNIQUE_STATE ||
                LastCachedUniqueState != CurrentUniqueState)
            {
                LastCachedUniqueState = CurrentUniqueState;
                LastSessionId.Type = DEBUG_VALUE_INVALID;
            }
        }
    }

    if (hr == S_OK &&
        CurSessionId != NULL &&
        LastSessionId.Type == DEBUG_VALUE_INVALID)
    {
        DEBUG_VALUE         CurrentSessionId;

        // Set Output callbacks
        if ((hr = SessionIdReader.LookFor(&LastSessionId, "SessionId", DEBUG_VALUE_INT32)) == S_OK &&
            (hr = OutState.Setup(0, &SessionIdReader)) == S_OK)
        {
            sprintf(szCommand, "dt NT!MM_SESSION_SPACE SessionId 0x%I64x", LastSessionSpace.I64);
            if ((hr = OutState.Execute(szCommand)) == S_OK &&
                (hr = SessionIdReader.ParseOutput()) == S_OK &&
                (hr = SessionIdReader.Complete()) == S_OK)
            {
                if (LastSessionId.I32 == INVALID_SESSION)
                {
                    hr = E_FAIL;
                }
            }
        }

        if (hr != S_OK)
        {
            LastSessionId.Type = DEBUG_VALUE_INVALID;
        }
    }


    if (hr == S_OK)
    {
        if (CurSessionSpace != NULL) *CurSessionSpace = LastSessionSpace.I64;
        if (CurSessionId != NULL) *CurSessionId = LastSessionId.I32;
    }

    return hr;
}


HRESULT
GetSessionSpace(
    PDEBUG_CLIENT Client,
    ULONG Session,
    PULONG64 SessionSpace
    )
{
    HRESULT             hr;
    OutputControl       OutCtl(Client);
    DEBUG_VALUE         FoundSession;
    DEBUG_VALUE         SessionSpaceAddr;

    ULONG               CurrentUniqueState = UniqueTargetState;

    if (Session == DEFAULT_SESSION)
    {
        Session = SessionId;
    }

    if (Session == CURRENT_SESSION)
    {
        ULONG64 CurSessionSpace;
        ULONG   CurSessionId;

        hr = GetCurrentSession(Client, &SessionSpaceAddr.I64, &FoundSession.I32);
    }
    else
    {
        if (CurrentUniqueState != INVALID_UNIQUE_STATE)
        {
            if (Session < NUM_CACHED_SESSIONS)
            {
                if (CachedSession[Session].UniqueState == CurrentUniqueState &&
                    CachedSession[Session].SessionSpaceAddr != 0)
                {
                    if (SessionSpace != NULL) *SessionSpace = CachedSession[Session].SessionSpaceAddr;
                    return S_OK;
                }
            }
            else if (ExtraCachedSessionId != INVALID_SESSION &&
                     Session == ExtraCachedSessionId)
            {
                if (CachedSession[NUM_CACHED_SESSIONS].UniqueState == CurrentUniqueState &&
                    CachedSession[NUM_CACHED_SESSIONS].SessionSpaceAddr != 0)
                {
                    if (SessionSpace != NULL) *SessionSpace = CachedSession[NUM_CACHED_SESSIONS].SessionSpaceAddr;
                    return S_OK;
                }
            }
        }

        ULONG64             FirstSessionSpace;
        DEBUG_VALUE         SessionSpaceWsList;
        DEBUG_VALUE         SessionSpaceWsListOffset;
        BasicOutputParser   OffsetReader(Client);
        BasicOutputParser   FlinkReader(Client);
        BasicOutputParser   SessionReader(Client);
        OutputState         OutState(Client);
        CHAR                szCommand[MAX_PATH];

        // Set Output callbacks
        // Get ListEntry offset
        if ((hr = OffsetReader.LookFor(&SessionSpaceWsListOffset, " +", DEBUG_VALUE_INT64)) == S_OK &&
            (hr = OutState.Setup(0, &OffsetReader)) == S_OK)
        {
            sprintf(szCommand, "dt NT!MM_SESSION_SPACE WsListEntry");
            if ((hr = OutState.Execute(szCommand)) == S_OK &&
                (hr = OffsetReader.ParseOutput()) == S_OK)
            {
                hr = OffsetReader.Complete();
            }
        }

        // Get first session space in list
        if (hr == S_OK &&
            (hr = FlinkReader.LookFor(&SessionSpaceWsList, "Flink", DEBUG_VALUE_INT64)) == S_OK &&
            (hr = OutState.Setup(0, &FlinkReader)) == S_OK)
        {
            sprintf(szCommand, "dt NT!MiSessionWsList");
            if ((hr = OutState.Execute(szCommand)) == S_OK &&
                (hr = FlinkReader.ParseOutput()) == S_OK)
            {
                hr = FlinkReader.Complete();
            }
        }

        // Add SessionId to reader search
        if (hr == S_OK &&
            (hr = SessionReader.LookFor(&FoundSession, "SessionId", DEBUG_VALUE_INT32)) == S_OK &&
            (hr = SessionReader.LookFor(&SessionSpaceWsList, "Flink", DEBUG_VALUE_INT64)) == S_OK &&
            (hr = OutState.Setup(0, &SessionReader)) == S_OK)
        {
            SessionSpaceAddr.I64 = SessionSpaceWsList.I64 - SessionSpaceWsListOffset.I64;
            FirstSessionSpace = SessionSpaceAddr.I64;

            OutCtl.OutVerb("First session space @ %p.\n", FirstSessionSpace);

            do
            {
                // Get SessionId for this session space
                SessionReader.DiscardOutput();
                SessionReader.Relook();
                sprintf(szCommand,
                        "dt NT!MM_SESSION_SPACE SessionId WsListEntry.Flink 0x%I64x",
                        SessionSpaceAddr.I64);
                if ((hr = OutState.Execute(szCommand)) == S_OK &&
                    (hr = SessionReader.ParseOutput()) == S_OK &&
                    (hr = SessionReader.Complete()) == S_OK)
                {
                    if (Session == FoundSession.I32)
                    {
                        break;
                    }

                    // Compute next session space
                    SessionSpaceAddr.I64 = SessionSpaceWsList.I64 - SessionSpaceWsListOffset.I64;

                    if (SessionSpaceAddr.I64 == FirstSessionSpace)
                    {
                        hr = S_FALSE;
                    }
                }
                else
                {
                    OutCtl.OutErr("Couldn't get SessionId or next session from \'%s\'\n", szCommand);
                    PSTR pszOutput;
                    if (SessionReader.GetOutputCopy(&pszOutput) == S_OK)
                    {
                        OutCtl.OutVerb(" dt output:\n%s\n", pszOutput);
                        SessionReader.FreeOutputCopy(pszOutput);
                    }
                }
            } while (hr == S_OK);
        }
    }

    if (hr == S_OK)
    {
        OutCtl.OutVerb("Session %ld lookup found Session #%ld @ 0x%p.\n",
                       Session, FoundSession.I32, SessionSpaceAddr.I64);

        if (FoundSession.I32 < NUM_CACHED_SESSIONS)
        {
            CachedSession[FoundSession.I32].UniqueState = CurrentUniqueState;
            CachedSession[FoundSession.I32].SessionSpaceAddr = SessionSpaceAddr.I64;
        }
        else
        {
            ExtraCachedSessionId = FoundSession.I32;
            CachedSession[NUM_CACHED_SESSIONS].UniqueState = CurrentUniqueState;
            CachedSession[NUM_CACHED_SESSIONS].SessionSpaceAddr = SessionSpaceAddr.I64;
        }

        if (SessionSpace != NULL) *SessionSpace = SessionSpaceAddr.I64;
    }

    return hr;
}


HRESULT
GetSessionDirBase(
    PDEBUG_CLIENT Client,
    ULONG Session,
    PULONG64 PageDirBase
    )
{
    HRESULT             hr = S_FALSE;
    OutputControl       OutCtl(Client);
    ULONG64             SessionSpaceOffset;
    ULONG64             Process = -1;
    DEBUG_VALUE         SessionIdCheck;
    DEBUG_VALUE         dvPageDirBase;
    BasicOutputParser   ProcessReader(Client);
    OutputState         OutState(Client);
    CHAR                szCommand[MAX_PATH];

    static ULONG        LastSession = -2;
    static ULONG64      LastSessionPageDirBase = 0;

    if (Session == DEFAULT_SESSION)
    {
        Session = SessionId;
    }

    if (Session == LastSession &&
        LastSessionPageDirBase != 0)
    {
        *PageDirBase = LastSessionPageDirBase;
        return S_OK;
    }

    *PageDirBase = 0;

    if ((hr == GetSessionSpace(Client, Session, &SessionSpaceOffset)) == S_OK)
    {
        DEBUG_VALUE         ProcessSessionListOffset;
        BasicOutputParser   OffsetReader(Client);

        if ((hr = OffsetReader.LookFor(&ProcessSessionListOffset, " +", DEBUG_VALUE_INT64)) == S_OK &&
            (hr = OutState.Setup(0, &OffsetReader)) == S_OK)
        {
            sprintf(szCommand, "dt NT!_EPROCESS SessionProcessLinks");
            if ((hr = OutState.Execute(szCommand)) == S_OK &&
                (hr = OffsetReader.ParseOutput()) == S_OK)
            {
                hr = OffsetReader.Complete();
            }
        }

        DEBUG_VALUE         SessionProcessListAddr;
        BasicOutputParser   FlinkReader(Client);

        if (hr == S_OK &&
            (hr = FlinkReader.LookFor(&SessionProcessListAddr, "Flink", DEBUG_VALUE_INT64)) == S_OK &&
            (hr = OutState.Setup(0, &FlinkReader)) == S_OK)
        {
            sprintf(szCommand, "dt NT!MM_SESSION_SPACE ProcessList.Flink 0x%I64x", SessionSpaceOffset);
            if ((hr = OutState.Execute(szCommand)) == S_OK &&
                (hr = FlinkReader.ParseOutput()) == S_OK &&
                (hr = FlinkReader.Complete()) == S_OK)
            {
                Process = SessionProcessListAddr.I64 - ProcessSessionListOffset.I64;
            }
        }
    }
    else
    {
        OutCtl.OutVerb("GetSessionSpace returned HRESULT 0x%lx.\n", hr);
    }

    if (hr == S_OK &&
        (hr = ProcessReader.LookFor(&SessionIdCheck, "SessionId:", DEBUG_VALUE_INT32)) == S_OK &&
        (hr = ProcessReader.LookFor(&dvPageDirBase, "DirBase:", DEBUG_VALUE_INT64, 16)) == S_OK &&
        (hr = OutState.Setup(0, &ProcessReader)) == S_OK)
    {
        sprintf(szCommand, "!process 0x%I64x 0", Process);
        if ((hr = OutState.Execute(szCommand)) == S_OK &&
            (hr = ProcessReader.ParseOutput()) == S_OK &&
            (hr = ProcessReader.Complete()) == S_OK)
        {
            *PageDirBase = dvPageDirBase.I64;

            OutCtl.OutVerb("DirBase for session %lu is %p.\n", SessionIdCheck.I32, dvPageDirBase.I64);

            if (Session != CURRENT_SESSION &&
                Session != SessionIdCheck.I32)
            {
                hr = S_FALSE;
            }
            else
            {
                LastSession = Session;
                LastSessionPageDirBase = dvPageDirBase.I64;
            }
        }
    }

    return hr;
}


HRESULT
ReadPageTableEntry(
    PDEBUG_DATA_SPACES Data,
    ULONG64 PageTableBase,
    ULONG64 PageTableIndex,
    PULONG64 PageTableEntry
    )
{
    HRESULT hr;
    ULONG64 PhysAddr = PageTableBase + PageTableIndex * HwPte.Size;
    ULONG   BytesRead;
    ULONG   CurrentUniqueState = UniqueTargetState;


    *PageTableEntry = 0;

    if (CurrentUniqueState != INVALID_UNIQUE_STATE)
    {
        if (CachedPhysAddr[0].UniqueState == CurrentUniqueState &&
            CachedPhysAddr[0].PhysAddr == PhysAddr)
        {
            *PageTableEntry = CachedPhysAddr[0].Data;
            return S_OK;
        }
        else if (CachedPhysAddr[1].UniqueState == CurrentUniqueState &&
                 CachedPhysAddr[1].PhysAddr == PhysAddr)
        {
            *PageTableEntry = CachedPhysAddr[1].Data;
            return S_OK;
        }
    }

    hr = Data->ReadPhysical(PhysAddr,
                            PageTableEntry,
                            HwPte.Size,
                            &BytesRead);

    if (hr == S_OK)
    {
        if (BytesRead < HwPte.Size)
        {
            hr = S_FALSE;
        }
        else
        {
            static CacheToggle = 1;

            CacheToggle = (CacheToggle+1) % 2;

            CachedPhysAddr[CacheToggle].UniqueState = CurrentUniqueState;
            CachedPhysAddr[CacheToggle].PhysAddr = *PageTableEntry;
        }
    }

    return hr;
}


HRESULT
GetPageFrameNumber(
    PDEBUG_CLIENT Client,
    PDEBUG_DATA_SPACES Data,
    ULONG64 PageTableBase,
    ULONG64 PageTableIndex,
    PULONG64 PageFrameNumber
    )
{
    HRESULT hr;
    ULONG64 PageTableEntry;
    ULONG64 Valid, Proto, Trans, LargePage;
    ULONG64 pfn;

    if ((hr = ReadPageTableEntry(Data, PageTableBase, PageTableIndex, &PageTableEntry)) == S_OK)
    {
        if ((hr = GetMMPTEValid(Client, PageTableEntry, &Valid)) == S_OK)
        {
            if (Valid)
            {
                hr = GetMMPTEpfn(Client, PageTableEntry, PageFrameNumber, GET_BITS_UNSHIFTED);

                if (GetMMPTEX86LargePage(Client, PageTableEntry, &LargePage) == S_OK &&
                    LargePage != 0)
                {
                    DbgPrint("Found large X86 page.\n");
                    DbgBreakPoint();
                }
            }
            else
            {
                if ((hr = GetMMPTEProto(Client, PageTableEntry, &Proto)) == S_OK &&
                    (hr = GetMMPTETrans(Client, PageTableEntry, &Trans)) == S_OK)
                {
                    if (Proto == 0 && Trans == 1)
                    {
                        hr = GetMMPTEpfn(Client, PageTableEntry, PageFrameNumber, GET_BITS_UNSHIFTED);
                    }
                    else
                    {
                        hr = S_FALSE;
                    }
                }
            }
        }
    }

    return hr;
}


HRESULT
GetPhysicalBase(
    PDEBUG_CLIENT Client,
    ULONG64 PageDirBase,
    ULONG64 PageDirIndex,
    ULONG64 PageTableIndex,
    PULONG64 PhysicalBase
    )
{
    HRESULT             hr;
    PDEBUG_DATA_SPACES  Data;
    ULONG64             PageTableBase;

    if ((hr = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                     (void **)&Data)) == S_OK)
    {
        if ((hr = GetPageFrameNumber(Client, Data,
                                     PageDirBase, PageDirIndex,
                                     &PageTableBase)) == S_OK)
        {
            hr = GetPageFrameNumber(Client, Data,
                                    PageTableBase, PageTableIndex,
                                    PhysicalBase);
        }

        Data->Release();
    }

    return hr;
}


HRESULT
GetPhysicalAddress(
    PDEBUG_CLIENT Client,
    ULONG Session,
    ULONG64 VirtAddr,
    PULONG64 PhysAddr
    )
{
    if (Client == NULL) return E_INVALIDARG;

    HRESULT hr = S_OK;
    ULONG64 PageDirIndex;
    ULONG64 PageTableIndex;
    ULONG64 PageByteIndex;
    ULONG64 PageDirBase;

    OutputControl   OutCtl(Client);

    ULONG CurrentUniqueState = UniqueTargetState;

    if (Session == DEFAULT_SESSION)
    {
        Session = SessionId;
    }

    if (!HwPte.Valid)
    {
        PDEBUG_SYMBOLS  Symbols;

        if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                         (void **)&Symbols)) == S_OK)
        {
            if ((hr = Symbols->GetSymbolTypeId(HwPte.Type, &HwPte.TypeId, &HwPte.Module)) == S_OK &&
                (hr = Symbols->GetTypeSize(HwPte.Module, HwPte.TypeId, &HwPte.Size)) == S_OK &&
                HwPte.Size != 0)
            {
                HwPte.Valid = TRUE;
            }

            Symbols->Release();
        }
    }

    if (HwPte.Valid)
    {
        ULONG   TableEntries = PageSize / HwPte.Size;

        PageByteIndex = VirtAddr & (PageSize-1);
        VirtAddr >>= PageShift;
        PageTableIndex = VirtAddr % TableEntries;
        PageDirIndex = (VirtAddr / TableEntries) % TableEntries;

        if (Session < NUM_CACHED_DIR_BASES &&
            CurrentUniqueState != INVALID_UNIQUE_STATE &&
            CachedDirBase[Session].UniqueState == CurrentUniqueState &&
            (hr = GetPhysicalBase(Client,
                                  CachedDirBase[Session].PageDirBase,
                                  PageDirIndex,
                                  PageTableIndex,
                                  PhysAddr)) == S_OK)
        {
            *PhysAddr |= PageByteIndex;
        }
        else
        {
            DEBUG_VALUE         SessionIdCheck;
            DEBUG_VALUE         dvPageDirBase;
            BasicOutputParser   ProcessReader(Client);
            OutputState         OutState(Client);
            BOOL                ShortProcessList = (Session == CURRENT_SESSION);

            if ((hr = ProcessReader.LookFor(&SessionIdCheck, "SessionId:", DEBUG_VALUE_INT32)) == S_OK &&
                (hr = ProcessReader.LookFor(&dvPageDirBase, "DirBase:", DEBUG_VALUE_INT64, 16)) == S_OK &&
                (hr = OutState.Setup(0, &ProcessReader)) == S_OK &&
                (hr = (ShortProcessList ?
                       OutState.Execute("!process -1 0") :
                       OutState.Execute("!process 0 0"))) == S_OK)
            {
                hr = S_FALSE;

                while (hr != S_OK &&
                       OutCtl.GetInterrupt() != S_OK &&
                       ProcessReader.ParseOutput() == S_OK &&
                       ProcessReader.Complete() == S_OK)
                {
                    ProcessReader.Relook();

                    if (Session == CURRENT_SESSION)
                    {
                        // The current process is always first
                        // due to the '!process -1 0' above.
                        Session = SessionIdCheck.I32;
                    }

                    if (Session != SessionIdCheck.I32)
                    {
                        continue;
                    }

                    hr = GetPhysicalBase(Client,
                                         dvPageDirBase.I64,
                                         PageDirIndex,
                                         PageTableIndex,
                                         PhysAddr);

                    if (hr == S_OK)
                    {
                        *PhysAddr |= PageByteIndex;
                        if (Session < NUM_CACHED_DIR_BASES)
                        {
                            CachedDirBase[Session].UniqueState = CurrentUniqueState;
                            CachedDirBase[Session].PageDirBase = dvPageDirBase.I64;
                        }
                        else if (Session == CURRENT_SESSION)
                        {
                            CachedDirBase[NUM_CACHED_DIR_BASES].UniqueState = CurrentUniqueState;
                            CachedDirBase[NUM_CACHED_DIR_BASES].PageDirBase = dvPageDirBase.I64;
                        }
                    }
                    else if (ShortProcessList &&
                             SessionId == CURRENT_SESSION)
                    {
                        ShortProcessList = FALSE;
                        OutState.Execute("!process 0 0");
                        hr = S_FALSE;
                    }
                }
            }
            else
            {
                OutCtl.OutVerb("Process reading setup failed.\n");
            }
        }
    }
    else
    {
        OutCtl.OutVerb("GetPageLookupData returned 0x%lx.\n", hr);
    }

    return hr;
}


HRESULT
GetNextResidentPage(
    PDEBUG_CLIENT Client,
    ULONG64 PageDirBase,
    ULONG64 VirtAddrStart,
    ULONG64 VirtAddrLimit,
    PULONG64 VirtPage,
    PULONG64 PhysPage
    )
{
    HRESULT             hr;
    BOOL                Interrupted = FALSE;
    PDEBUG_CONTROL      Control = NULL;
    PDEBUG_DATA_SPACES  Data = NULL;
    ULONG64             PageDirIndex;
    ULONG64             PageTableIndex;
    ULONG64             PageDirIndexLimit;
    ULONG64             PageTableIndexLimit;
    ULONG64             PageTableBase;
    ULONG64             TempAddr;

    if (VirtPage == NULL) VirtPage = &TempAddr;
    if (PhysPage == NULL) PhysPage = &TempAddr;

    *VirtPage = 0;
    *PhysPage = 0;

    if ((hr = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                     (void **)&Data)) == S_OK &&
        (hr = Client->QueryInterface(__uuidof(IDebugControl),
                                     (void **)&Control)) == S_OK)
    {
        if (!HwPte.Valid)
        {
            PDEBUG_SYMBOLS  Symbols;

            if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                             (void **)&Symbols)) == S_OK)
            {
                if ((hr = Symbols->GetSymbolTypeId(HwPte.Type, &HwPte.TypeId, &HwPte.Module)) == S_OK &&
                    (hr = Symbols->GetTypeSize(HwPte.Module, HwPte.TypeId, &HwPte.Size)) == S_OK &&
                    HwPte.Size != 0)
                {
                    HwPte.Valid = TRUE;
                }
                else if (hr == S_OK)
                {
                    hr = E_FAIL;
                }

                Symbols->Release();
            }
        }

        if (HwPte.Valid)
        {
            ULONG   TableEntries = PageSize / HwPte.Size;
            ULONG64 Addr;

            *VirtPage = PAGE_ALIGN64(VirtAddrStart);

            Addr = VirtAddrStart >> PageShift;
            PageTableIndex = Addr % TableEntries;
            PageDirIndex = (Addr / TableEntries) % TableEntries;

            Addr = VirtAddrLimit >> PageShift;
            PageTableIndexLimit = Addr % TableEntries;
            PageDirIndexLimit = (Addr / TableEntries) % TableEntries;

            if (VirtAddrLimit & (PageSize-1))
            {
                PageTableIndexLimit++;
            }

            hr = S_FALSE;

            while (PageDirIndex < PageDirIndexLimit && hr != S_OK)
            {
                if ((hr = GetPageFrameNumber(Client, Data,
                                             PageDirBase, PageDirIndex,
                                             &PageTableBase)) == S_OK)
                {
                    do
                    {
                        if ((hr = GetPageFrameNumber(Client, Data,
                                                     PageTableBase, PageTableIndex,
                                                     PhysPage)) != S_OK)
                        {
                            hr = Control->GetInterrupt();

                            if (hr == S_OK)
                            {
                                Interrupted = TRUE;
                                Control->SetInterrupt(DEBUG_INTERRUPT_PASSIVE);
                            }
                            else
                            {
                                PageTableIndex++;
                                *VirtPage += PageSize;
                            }
                        }
                    } while (PageTableIndex < TableEntries && hr != S_OK);
                }
                else
                {
                    *VirtPage += PageSize * (TableEntries - PageTableIndex);
                }

                if (hr != S_OK)
                {
                    hr = Control->GetInterrupt();

                    if (hr == S_OK)
                    {
                        Interrupted = TRUE;
                        Control->SetInterrupt(DEBUG_INTERRUPT_PASSIVE);
                    }
                    else
                    {
                        PageTableIndex = 0;
                        PageDirIndex++;
                    }
                }
            }

            if (PageDirIndex == PageDirIndexLimit &&
                PageTableIndex < PageTableIndexLimit &&
                hr != S_OK)
            {
                if ((hr = GetPageFrameNumber(Client, Data,
                                             PageDirBase, PageDirIndex,
                                             &PageTableBase)) == S_OK)
                {
                    do
                    {
                        if ((hr = GetPageFrameNumber(Client, Data,
                                                     PageTableBase, PageTableIndex,
                                                     PhysPage)) != S_OK)
                        {
                            hr = Control->GetInterrupt();

                            if (hr == S_OK)
                            {
                                Interrupted = TRUE;
                                Control->SetInterrupt(DEBUG_INTERRUPT_PASSIVE);
                            }
                            else
                            {
                                PageTableIndex++;
                                *VirtPage += PageSize;
                            }
                        }
                    } while (PageTableIndex < PageTableIndexLimit && hr != S_OK);
                }
            }
        }

    }

    if (Control != NULL) Control->Release();
    if (Data != NULL) Data->Release();

    return ((Interrupted) ? E_ABORT : hr);
}


HRESULT
GetNextResidentAddress(
    PDEBUG_CLIENT Client,
    ULONG Session,
    ULONG64 VirtAddrStart,
    ULONG64 VirtAddrLimit,
    PULONG64 VirtAddr,
    PULONG64 PhysAddr
    )
{
    if (Client == NULL) return E_INVALIDARG;

    HRESULT hr = S_OK;
    ULONG64 PageDirBase;

    OutputControl   OutCtl(Client);

    ULONG CurrentUniqueState = UniqueTargetState;

    if (Session == DEFAULT_SESSION)
    {
        Session = SessionId;
    }


    if (Session < NUM_CACHED_DIR_BASES &&
        CurrentUniqueState != INVALID_UNIQUE_STATE &&
        CachedDirBase[Session].UniqueState == CurrentUniqueState)
    {
        PageDirBase = CachedDirBase[Session].PageDirBase;
    }
    else if (SessionId == CURRENT_SESSION &&
             CurrentUniqueState != INVALID_UNIQUE_STATE &&
             CachedDirBase[NUM_CACHED_DIR_BASES].UniqueState == CurrentUniqueState)
    {
        PageDirBase = CachedDirBase[NUM_CACHED_DIR_BASES].PageDirBase;
    }
    else
    {
        DEBUG_VALUE         SessionIdCheck;
        DEBUG_VALUE         dvPageDirBase;
        BasicOutputParser   ProcessReader(Client);
        OutputState         OutState(Client);
        BOOL                ShortProcessList = (Session == CURRENT_SESSION);

        if ((hr = ProcessReader.LookFor(&SessionIdCheck, "SessionId:", DEBUG_VALUE_INT32)) == S_OK &&
            (hr = ProcessReader.LookFor(&dvPageDirBase, "DirBase:", DEBUG_VALUE_INT64, 16)) == S_OK &&
            (hr = OutState.Setup(0, &ProcessReader)) == S_OK &&
            (hr = (ShortProcessList ?
                   OutState.Execute("!process -1 0") :
                   OutState.Execute("!process 0 0"))) == S_OK)
        {
            hr = S_FALSE;

            while (hr != S_OK &&
                   OutCtl.GetInterrupt() != S_OK &&
                   ProcessReader.ParseOutput() == S_OK &&
                   ProcessReader.Complete() == S_OK)
            {
                ProcessReader.Relook();

                if (Session == CURRENT_SESSION)
                {
                    // The current process is always first
                    // due to the '!process -1 0' above.
                    Session = SessionIdCheck.I32;
                }

                if (Session == SessionIdCheck.I32)
                {
                    hr = S_OK;
                    PageDirBase = dvPageDirBase.I64;

                    if (Session < NUM_CACHED_DIR_BASES)
                    {
                        CachedDirBase[Session].UniqueState = CurrentUniqueState;
                        CachedDirBase[Session].PageDirBase = dvPageDirBase.I64;
                    }
                    else if (Session == CURRENT_SESSION)
                    {
                        CachedDirBase[NUM_CACHED_DIR_BASES].UniqueState = CurrentUniqueState;
                        CachedDirBase[NUM_CACHED_DIR_BASES].PageDirBase = dvPageDirBase.I64;
                    }
                }
            }
        }
        else
        {
            OutCtl.OutVerb("Process reading setup failed.\n");
        }
    }

    if (hr == S_OK)
    {
        hr = GetNextResidentPage(Client,
                                 PageDirBase,
                                 VirtAddrStart,
                                 VirtAddrLimit,
                                 VirtAddr,
                                 PhysAddr);
    }
    else
    {
        OutCtl.OutVerb("Page Directory Base lookup failed.\n");
    }

    return hr;
}


DECLARE_API( session )
{
    INIT_API();

    HRESULT hr;
    ULONG   NewSession = CURRENT_SESSION;
    ULONG   CurrentSession;
    ULONG   SessionCount = 0;
    DEBUG_VALUE DebugValue;

    while (*args && isspace(*args)) args++;
    if (args[0] == '-' && args[1] == '?')
    {
        ExtOut("session displays number of sessions on machine and\n"
               " the default SessionId used by session related extensions.\n"
               "\n"
               "Usage: session [SessionId]\n"
               "    SessionId - sets default session used for session extensions\n");

        EXIT_API(S_OK);
    }

    ULONG   OldRadix;
    g_pExtControl->GetRadix(&OldRadix);
    g_pExtControl->SetRadix(10);
    hr = g_pExtControl->Evaluate(args, DEBUG_VALUE_INT32, &DebugValue, NULL);
    g_pExtControl->SetRadix(OldRadix);

    if (GetSessionNumbers(Client, &CurrentSession, NULL, &SessionCount) == S_OK)
    {
        if (SessionCount != 0)
        {
            ExtOut("Sesssions on machine: %lu\n", SessionCount);

            // If a session wasn't specified,
            // list valid sessions (up to a point).
            if (hr != S_OK)
            {
                ExtOut("Valid Sessions:");

                for (ULONG CheckSession = 0; CheckSession <= SESSION_SEARCH_LIMIT; CheckSession++)
                {
                    if (GetSessionSpace(Client, CheckSession, NULL) == S_OK)
                    {
                        ExtOut(" %lu", CheckSession);
                        SessionCount--;
                        if (SessionCount == 0) break;
                    }

                    if (g_pExtControl->GetInterrupt() == S_OK)
                    {
                        ExtWarn("\n  User aborted.\n");
                        break;
                    }
                }

                if (SessionCount > 0)
                {
                    ExtOut(" ...?");
                }
                ExtOut("\n");
            }
        }
        else
        {
            ExtErr("Couldn't determine number of sessions.\n");
        }

        if (CurrentSession != INVALID_SESSION)
        {
            ExtVerb("Running session: %lu\n", CurrentSession);
        }
    }

    if (hr == S_OK)
    {
        NewSession = DebugValue.I32;

         ExtVerb("Previous Default Session: %s\n", SessionStr);

        if (SetDefaultSession(Client, NewSession, NULL) != S_OK)
        {
            ExtErr("Couldn't set Session %lu.\n", NewSession);
        }
    }

    ExtOut("Using session %s", SessionStr);
    if (SessionId == CURRENT_SESSION)
    {
        if (GetSessionNumbers(Client, &CurrentSession, NULL, NULL) == S_OK &&
            CurrentSession != INVALID_SESSION)
        {
            ExtOut(" (%d)", CurrentSession);
        }
        else
        {
            ExtOut(" (?)");
        }
    }
    ExtOut("\n");

    EXIT_API(S_OK);
}


DECLARE_API( svtop )
{
    INIT_API();

    HRESULT     hr;
    DEBUG_VALUE SessVirtAddr;
    ULONG64     PhysAddr;

    if (S_OK == g_pExtControl->Evaluate(args, DEBUG_VALUE_INT64, &SessVirtAddr, NULL))
    {
        if ((hr = GetPhysicalAddress(Client, SessionId, SessVirtAddr.I64, &PhysAddr)) == S_OK)
        {
            ExtOut("Session %s: %p -> %p\n", SessionStr, SessVirtAddr.I64, PhysAddr);
        }
        else
        {
            ExtErr("Failed to translate virtual address %p from session %s\n"
                   "  HRESULT: 0x%lx\n",
                   SessVirtAddr.I64, SessionStr, hr);
        }
    }
    else
    {
        ExtOut("Usage: svtop SessionVirtualAddress\n");
    }

    EXIT_API(S_OK);
}


DECLARE_API( sprocess )
{
    INIT_API();

    HRESULT     hr;
    DEBUG_VALUE Session;
    ULONG       RemainingArgIndex;

    while (*args && isspace(*args)) args++;
    if (args[0] == '-' && args[1] == '?')
    {
        ExtOut("sprocess is like !process, but for the SessionId specified.\n"
               "\n"
               "Usage: sprocess [SessionId [Flags]]\n"
               "    SessionId - specifies which session to dump.\n"
               "              Special SessionId values:\n"
               "               -1 - current session\n"
               "               -2 - last !session SessionId (default)\n"
               "    Flags - see !process help\n");

        EXIT_API(S_OK);
    }

    ULONG       OldRadix;
    g_pExtControl->GetRadix(&OldRadix);
    g_pExtControl->SetRadix(10);
    hr = g_pExtControl->Evaluate(args, DEBUG_VALUE_INT32, &Session, &RemainingArgIndex);
    g_pExtControl->SetRadix(OldRadix);

    if (hr != S_OK)
    {
        Session.I32 = DEFAULT_SESSION;
        args = "0";
        hr = S_OK;
    }
    else
    {
        args += RemainingArgIndex;
    }

    ULONG64 SessionSpace;

    if ((hr = GetSessionSpace(Client, Session.I32, &SessionSpace)) == S_OK)
    {
        DEBUG_VALUE         ProcessSessionListAddr;
        DEBUG_VALUE         ProcessSessionListOffset;
        DEBUG_VALUE         ProcessesInSession;
        DEBUG_VALUE         Process;
        BasicOutputParser   OffsetReader(Client, 1);
        BasicOutputParser   SessionReader(Client, 2);
        BasicOutputParser   FlinkReader(Client, 1);
        BasicOutputParser   ErrorChecker(Client, 1);
        OutputState         OutState(Client);
        CHAR                szCommand[MAX_PATH];

        // General parser setup and get ListEntry offset in _EPROCESS structure
        if ((hr = OffsetReader.LookFor(&ProcessSessionListOffset, " +", DEBUG_VALUE_INT64)) == S_OK &&
            (hr = SessionReader.LookFor(&ProcessSessionListAddr, "Flink", DEBUG_VALUE_INT64)) == S_OK &&
            (hr = SessionReader.LookFor(&ProcessesInSession, "ProcessReferenceToSession", DEBUG_VALUE_INT32)) == S_OK &&
            (hr = FlinkReader.LookFor(&ProcessSessionListAddr, "Flink", DEBUG_VALUE_INT64)) == S_OK &&
            (hr = ErrorChecker.LookFor(NULL, "Could not find _EPROCESS")) == S_OK &&
            (hr = OutState.Setup(0, &OffsetReader)) == S_OK)
        {
            strcpy(szCommand, "dt NT!_EPROCESS SessionProcessLinks");
            if ((hr = OutState.Execute(szCommand)) == S_OK &&
                (hr = OffsetReader.ParseOutput()) == S_OK)
            {
                hr = OffsetReader.Complete();
            }
        }

        // Find first process and number of processes
        if (hr == S_OK &&
            (hr = OutState.Setup(0, &SessionReader)) == S_OK)
        {
            sprintf(szCommand, "dt NT!MM_SESSION_SPACE ProcessList.Flink ProcessReferenceToSession 0x%I64x", SessionSpace);
            if ((hr = OutState.Execute(szCommand)) == S_OK &&
                (hr = SessionReader.ParseOutput()) == S_OK &&
                (hr = SessionReader.Complete()) == S_OK)
            {
                Process.I64 = ProcessSessionListAddr.I64 - ProcessSessionListOffset.I64;
            }
        }

        if (hr == S_OK)
        {
            ExtOut("Processes is session: %lu\n", ProcessesInSession.I32);

            // Dump all processes
            while (hr == S_OK &&
                   ProcessesInSession.I32 > 0)
            {
                // dump process and check that the process was valid
                OutState.Setup(DEBUG_OUTPUT_NORMAL |
                               DEBUG_OUTPUT_WARNING |
                               DEBUG_OUTPUT_ERROR,
                               &ErrorChecker);

                sprintf(szCommand, "!process 0x%I64x %s", Process.I64, args);
                hr = g_pExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                                            szCommand,
                                            DEBUG_EXECUTE_NO_REPEAT);

                if (hr == S_OK &&
                    ErrorChecker.Ready() == S_OK &&
                    ErrorChecker.ParseOutput() == S_OK &&
                    ErrorChecker.Complete() == S_OK)
                {
                    hr = S_FALSE;
                }

                OutState.Setup(0, NULL);

                if (hr == S_OK)
                {
                    // Get next process
                    FlinkReader.DiscardOutput();
                    FlinkReader.Relook();
                    sprintf(szCommand,
                            "dt NT!_EPROCESS SessionProcessLinks.Flink 0x%I64x",
                            Process.I64);
                    if ((hr = OutState.Setup(0, &FlinkReader)) == S_OK &&
                        (hr = OutState.Execute(szCommand)) == S_OK &&
                        (hr = FlinkReader.ParseOutput()) == S_OK &&
                        (hr = FlinkReader.Complete()) == S_OK)
                    {
                        Process.I64 = ProcessSessionListAddr.I64 - ProcessSessionListOffset.I64;

                        ProcessesInSession.I32--;
                    }
                    else
                    {
                        ExtVerb("Couldn't get next process from '%s'\n", szCommand);
                    }
                }
            }

            if (ProcessesInSession.I32 > 0)
            {
                ExtErr("%lu processes weren't dumped.\n", ProcessesInSession.I32);
            }
        }
    }
    else
    {
        ExtErr("Couldn't get session %lu's data.\n", Session.I32);
    }

    EXIT_API(hr);
}


HRESULT
SearchLinkedList(
    PDEBUG_CLIENT   Client,
    ULONG64         StartAddr,
    ULONG64         NextLinkOffset,
    ULONG64         SearchAddr,
    PULONG          LinksTraversed
    )
{
    if (LinksTraversed != NULL)
    {
        *LinksTraversed = 0;
    }

    INIT_API();

    HRESULT hr = S_OK;
    ULONG64 PhysAddr;
    ULONG64 NextAddr = StartAddr;
    ULONG   LinkCount = 0;
    ULONG   PointerSize;
    ULONG   BytesRead;

    PointerSize = (g_pExtControl->IsPointer64Bit() == S_OK) ? 8 : 4;

    do
    {
        if ((hr = GetPhysicalAddress(Client, DEFAULT_SESSION, NextAddr, &PhysAddr)) == S_OK)
        {
            if ((hr = g_pExtData->ReadPhysical(PhysAddr + NextLinkOffset,
                                              &NextAddr,
                                              PointerSize,
                                              &BytesRead)) == S_OK)
            {
                if (BytesRead == PointerSize)
                {
                    LinkCount++;
                    if (PointerSize != 8)
                    {
                        NextAddr = DEBUG_EXTEND64(NextAddr);
                    }
                    ExtVerb("NextAddr: %p\n", NextAddr);
                }
                else
                {
                    hr = S_FALSE;
                }
            }
        }
    } while (hr == S_OK &&
             NextAddr != SearchAddr &&
             NextAddr != 0 &&
             LinkCount < 4 &&
             NextAddr != StartAddr);

    if (LinksTraversed != NULL)
    {
        *LinksTraversed = LinkCount;
    }

    // Did we really find SearchAddr?
    if (hr == S_OK &&
        NextAddr != SearchAddr)
    {
        hr = S_FALSE;
    }

    EXIT_API(hr);
}


DECLARE_API( walklist )
{
    INIT_API();

    HRESULT     hr;
    BOOL        NeedHelp = FALSE;
    BOOL        SearchSessions = FALSE;
    DEBUG_VALUE StartAddr;
    DEBUG_VALUE OffsetToNextField = { -1, DEBUG_VALUE_INVALID };//FIELD_OFFSET(Win32PoolHead, pNext);
    DEBUG_VALUE SearchAddr;
    ULONG       NextArg;
    ULONG       SessionCount;
    ULONG       Session = 0;
    ULONG       OldDefSession;
    ULONG       LinksToDest = 0;

    while (*args && isspace(*args)) args++;

    while (args[0] == '-' && !NeedHelp)
    {
        if (tolower(args[1]) == 'a' && isspace(args[2]))
        {
            SearchSessions = TRUE;
            args += 2;
            while (*args && isspace(*args)) args++;
        }
        else if (tolower(args[1]) == 'o' &&
                 Evaluate(Client, args+2,
                          DEBUG_VALUE_INT64, EVALUATE_DEFAULT_RADIX,
                          &OffsetToNextField, &NextArg,
                          NULL, 0) == S_OK)
        {
            args += 2 + NextArg;
            while (*args && isspace(*args)) args++;
        }
        else
        {
            NeedHelp = TRUE;
        }
    }

    if (!NeedHelp &&
        S_OK == g_pExtControl->Evaluate(args, DEBUG_VALUE_INT64, &StartAddr, &NextArg))
    {
        args += NextArg;
        if (S_OK != g_pExtControl->Evaluate(args, DEBUG_VALUE_INT64, &SearchAddr, &NextArg))
        {
            SearchAddr.I64 = 0;
        }

        if (OffsetToNextField.Type == DEBUG_VALUE_INVALID)
        {
            ExtWarn("Assuming next field's offset is +8.\n");
            OffsetToNextField.I64 = 8;
        }
        else
        {
            ExtOut("Using field at offset +0x%I64u for next.\n", OffsetToNextField.I64);
        }

        if (SearchSessions &&
            GetSessionNumbers(Client, NULL, &OldDefSession, &SessionCount) == S_OK &&
            SessionCount > 0)
        {
            ExtOut("Searching all sessions lists @ %p for %p\n", StartAddr.I64, SearchAddr.I64);

            do
            {
                while (SetDefaultSession(Client, Session, NULL) != S_OK &&
                       Session <= SESSION_SEARCH_LIMIT)
                {
                    Session++;
                }

                if (Session <= SESSION_SEARCH_LIMIT)
                {
                    if ((hr = SearchLinkedList(Client, StartAddr.I64, OffsetToNextField.I64, SearchAddr.I64, &LinksToDest)) == S_OK)
                    {
                        ExtOut("Session %lu: Found %p after walking %lu linked list entries.\n", Session, SearchAddr.I64, LinksToDest);
                    }
                    else
                    {
                        ExtOut("Session %lu: Couldn't find %p after walking %lu linked list entries.\n", Session, SearchAddr.I64, LinksToDest);
                    }

                    Session++;
                    SessionCount--;
                }
            } while (SessionCount > 0 && Session <= SESSION_SEARCH_LIMIT);

            if (SessionCount)
            {
                ExtErr("%lu sessions beyond session %lu were not searched.\n",
                       SessionCount, SESSION_SEARCH_LIMIT);
            }

            SetDefaultSession(Client, OldDefSession, NULL);
        }
        else
        {
            ExtOut("Searching Session %s list @ %p for %p\n", SessionStr, StartAddr.I64, SearchAddr.I64);

            if ((hr = SearchLinkedList(Client, StartAddr.I64, OffsetToNextField.I64, SearchAddr.I64, &LinksToDest)) == S_OK)
            {
                ExtOut("Found %p after walking %lu linked list entries.\n", SearchAddr.I64, LinksToDest);
            }
            else
            {
                ExtOut("Couldn't find %p after walking %lu linked list entries.\n", SearchAddr.I64, LinksToDest);
            }
        }
    }
    else
    {
        NeedHelp = TRUE;
    }
    
    if (NeedHelp)
    {
        ExtOut("Usage: walklist [-a] StartAddress [SearchAddr]\n");
    }

    EXIT_API(S_OK);
}


HRESULT
GetBitMap(
    PDEBUG_CLIENT Client,
    ULONG64 pBitMap,
    PRTL_BITMAP *pBitMapOut
    )
{
    HRESULT     hr;
    PRTL_BITMAP p;
    DEBUG_VALUE Size;
    DEBUG_VALUE Buffer;
    ULONG       BufferLen;
    ULONG       BytesRead = 0;

    OutputControl       OutCtl(Client);
    TypeOutputParser    BitMapParser(Client);
    OutputState         OutState(Client);

    *pBitMapOut = NULL;

    if ((hr = OutState.Setup(0, &BitMapParser)) == S_OK &&
        (hr = OutState.OutputTypeVirtual(pBitMap, "NT!_RTL_BITMAP", 0)) == S_OK &&
        (hr = BitMapParser.Get(&Size, "SizeOfBitMap", DEBUG_VALUE_INT32)) == S_OK &&
        (hr = BitMapParser.Get(&Buffer, "Buffer", DEBUG_VALUE_INT64)) == S_OK)
    {
        PDEBUG_DATA_SPACES  Data;

        if ((hr = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                         (void **)&Data)) == S_OK)
        {
            BufferLen = (Size.I32 + 7) / 8;

#if DBG
            OutCtl.OutVerb("Reading RTL_BITMAP @ 0x%p:\n"
                           "  SizeOfBitMap: %lu\n"
                           "  Buffer: 0x%p\n"
                           "   Length in bytes: 0x%lx\n",
                           pBitMap,
                           Size.I32,
                           Buffer.I64,
                           BufferLen);
#endif

            p = (PRTL_BITMAP) HeapAlloc( GetProcessHeap(), 0, sizeof( *p ) + BufferLen );
    
            if (p != NULL)
            {
                RtlInitializeBitMap(p, (PULONG)(p + 1), Size.I32);
                hr = Data->ReadVirtual(Buffer.I64, p->Buffer, BufferLen, &BytesRead);
    
                if (hr != S_OK)
                {
                    OutCtl.OutErr("Error reading bitmap contents @ 0x%p\n", Buffer.I64);
                }
                else if (BytesRead < BufferLen)
                {
                    OutCtl.OutErr("Error reading bitmap contents @ 0x%p\n", Buffer.I64 + BytesRead);
                    hr = E_FAIL;
                }

                if (hr != S_OK)
                {
                    HeapFree( GetProcessHeap(), 0, p );
                    p = NULL;
                }
                else
                {
                    *pBitMapOut = p;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            Data->Release();
        }
        else
        {
            OutCtl.OutErr("Error setting up debugger interface.\n");
        }
    }
    else
    {
        OutCtl.OutErr("Error reading bitmap header @ 0x%p.\n", pBitMap);
    }

    return hr;
}


HRESULT
FreeBitMap(
    PRTL_BITMAP pBitMap
    )
{
    return (HeapFree( GetProcessHeap(), 0, pBitMap) ? S_OK : S_FALSE);
}


HRESULT
CheckSingleFilter(
    PUCHAR Tag,
    PUCHAR Filter
    )
{
    ULONG i;
    UCHAR tc;
    UCHAR fc;

    for ( i = 0; i < 4; i++ )
    {
        tc = (UCHAR) *Tag++;
        fc = (UCHAR) *Filter++;
        if ( fc == '*' ) return S_OK;
        if ( fc == '?' ) continue;
        if (i == 3 && (tc & ~(PROTECTED_POOL >> 24)) == fc) continue;
        if ( tc != fc ) return S_FALSE;
    }

    return S_OK;
}


HRESULT
AccumAllFilter(
    OutputControl *OutCtl,
    ULONG64 PoolAddr,
    ULONG TagFilter,
    TypeOutputParser *PoolHeadReader,
    PDEBUG_VALUE Tag,
    ULONG BlockSize,
    BOOL bQuotaWithTag,
    PVOID Context
    )
{
    HRESULT             hr;
    DEBUG_VALUE         PoolType;
    PALLOCATION_STATS   AllocStatsAccum = (PALLOCATION_STATS)Context;

    if (AllocStatsAccum == NULL)
    {
        return E_INVALIDARG;
    }

    hr = PoolHeadReader->Get(&PoolType, "PoolType", DEBUG_VALUE_INT32);

    if (hr == S_OK)
    {
        if (PoolType.I32 == 0)
        {
            AllocStatsAccum->Free++;
            AllocStatsAccum->FreeSize += BlockSize;
        }
        else
        {
            DEBUG_VALUE PoolIndex;

            if (!NewPool)
            {
                hr = PoolHeadReader->Get(&PoolIndex, "PoolIndex", DEBUG_VALUE_INT32);
            }

            if (hr == S_OK)
            {
                if (NewPool ? (PoolType.I32 & 0x04) : (PoolIndex.I32 & 0x80))
                {
                    AllocStatsAccum->Allocated++;
                    AllocStatsAccum->AllocatedSize += BlockSize;

                    if (AllocStatsAccum->Allocated % 100 == 0)
                    {
                        OutCtl->Output(".");

                        if (AllocStatsAccum->Allocated % 8000 == 0)
                        {
                            OutCtl->Output("\n");
                        }
                    }
                }
                else
                {
                    AllocStatsAccum->Free++;
                    AllocStatsAccum->FreeSize += BlockSize;
                }
            }
            else
            {
                AllocStatsAccum->Indeterminate++;
                AllocStatsAccum->IndeterminateSize += BlockSize;
            }
        }
    }
    else
    {
        AllocStatsAccum->Indeterminate++;
        AllocStatsAccum->IndeterminateSize += BlockSize;
    }

    return hr;
}



HRESULT
CheckPrintAndAccumFilter(
    OutputControl *OutCtl,
    ULONG64 PoolAddr,
    ULONG TagFilter,
    TypeOutputParser *PoolHeadReader,
    PDEBUG_VALUE Tag,
    ULONG BlockSize,
    BOOL bQuotaWithTag,
    PVOID Context
    )
{
    HRESULT             hr;
    DEBUG_VALUE         PoolType;
    PALLOCATION_STATS   AllocStatsAccum = (PALLOCATION_STATS)Context;

    if (CheckSingleFilter(Tag->RawBytes, (PUCHAR)&TagFilter) != S_OK)
    {
        return S_FALSE;
    }

    OutCtl->Output("0x%p size: %5lx ",//previous size: %4lx ",
                   PoolAddr,
                   BlockSize << POOL_BLOCK_SHIFT/*,
                   PreviousSize << POOL_BLOCK_SHIFT*/);

    hr = PoolHeadReader->Get(&PoolType, "PoolType", DEBUG_VALUE_INT32);

    if (hr == S_OK)
    {
        if (PoolType.I32 == 0)
        {
            //
            // "Free " with a space after it before the parentheses means
            // it's been freed to a (pool manager internal) lookaside list.
            // We used to print "Lookaside" but that just confused driver
            // writers because they didn't know if this meant in use or not
            // and many would say "but I don't use lookaside lists - the
            // extension or kernel is broken".
            //
            // "Free" with no space after it before the parentheses means
            // it is not on a pool manager internal lookaside list and is
            // instead on the regular pool manager internal flink/blink
            // chains.
            //
            // Note to anyone using the pool package, these 2 terms are
            // equivalent.  The fine distinction is only for those actually
            // writing pool internal code.
            //
            OutCtl->Output(" (Free)");
            OutCtl->Output("      %c%c%c%c\n",
                    Tag->RawBytes[0],
                    Tag->RawBytes[1],
                    Tag->RawBytes[2],
                    Tag->RawBytes[3]
                   );

            if (AllocStatsAccum != NULL)
            {
                AllocStatsAccum->Free++;
                AllocStatsAccum->FreeSize += BlockSize;
            }
        }
        else
        {
            DEBUG_VALUE PoolIndex;
            DEBUG_VALUE ProcessBilled;

            if (!NewPool)
            {
                hr = PoolHeadReader->Get(&PoolIndex, "PoolIndex", DEBUG_VALUE_INT32);
            }

            if (hr == S_OK)
            {
                if (NewPool ? (PoolType.I32 & 0x04) : (PoolIndex.I32 & 0x80))
                {
                    OutCtl->Output(" (Allocated)");

                    if (AllocStatsAccum != NULL)
                    {
                        AllocStatsAccum->Allocated++;
                        AllocStatsAccum->AllocatedSize += BlockSize;
                    }
                }
                else
                {
                    //
                    // "Free " with a space after it before the parentheses means
                    // it's been freed to a (pool manager internal) lookaside list.
                    // We used to print "Lookaside" but that just confused driver
                    // writers because they didn't know if this meant in use or not
                    // and many would say "but I don't use lookaside lists - the
                    // extension or kernel is broken".
                    //
                    // "Free" with no space after it before the parentheses means
                    // it is not on a pool manager internal lookaside list and is
                    // instead on the regular pool manager internal flink/blink
                    // chains.
                    //
                    // Note to anyone using the pool package, these 2 terms are
                    // equivalent.  The fine distinction is only for those actually
                    // writing pool internal code.
                    //
                    OutCtl->Output(" (Free )    ");

                    if (AllocStatsAccum != NULL)
                    {
                        AllocStatsAccum->Free++;
                        AllocStatsAccum->FreeSize += BlockSize;
                    }
                }
            }
            else
            {
                OutCtl->Output(" (?)        ");

                if (AllocStatsAccum != NULL)
                {
                    AllocStatsAccum->Indeterminate++;
                    AllocStatsAccum->IndeterminateSize += BlockSize;
                }
            }

            if (!(PoolType.I32 & POOL_QUOTA_MASK) ||
                bQuotaWithTag)
            {
                OutCtl->Output(" %c%c%c%c%s",
                               Tag->RawBytes[0],
                               Tag->RawBytes[1],
                               Tag->RawBytes[2],
                               (Tag->RawBytes[3] & ~(PROTECTED_POOL >> 24)),
                               ((Tag->I32 & PROTECTED_POOL) ? " (Protected)" : "")
                               );

            }
            
            if (PoolType.I32 & POOL_QUOTA_MASK &&
                PoolHeadReader->Get(&ProcessBilled, "ProcessBilled", DEBUG_VALUE_INT64) == S_OK &&
                ProcessBilled.I64 != 0)
            {
                OutCtl->Output(" Process: 0x%p\n", ProcessBilled.I64);
            }
            else
            {
                OutCtl->Output("\n");
            }
        }
    }
    else
    {
        OutCtl->OutErr(" Couldn't determine PoolType\n");

        if (AllocStatsAccum != NULL)
        {
            AllocStatsAccum->Indeterminate++;
            AllocStatsAccum->IndeterminateSize += BlockSize;
        }
    }

    return hr;
}


typedef struct _TAG_BUCKET : public ALLOCATION_STATS {
    ULONG Tag;
    _TAG_BUCKET *pNextTag;
} TAG_BUCKET, *PTAG_BUCKET;

typedef enum {
    AllocatedPool,
    FreePool,
    IndeterminatePool,
} PoolType;

class AccumTagUsage : public ALLOCATION_STATS {
public:
    AccumTagUsage(ULONG TagFilter);
    ~AccumTagUsage();

    HRESULT Valid();
    HRESULT Add(ULONG Tag, PoolType Type, ULONG Size);
    HRESULT OutputResults(OutputControl *OutCtl, BOOL TagSort);
    void Reset();

private:
    ULONG GetHashIndex(ULONG Tag);
    PTAG_BUCKET GetBucket(ULONG Tag);
    ULONG SetTagFilter(ULONG TagFilter);

    static const HashBitmaskLimit = 10;     // For little-endian, must <= 16

    HANDLE      hHeap;
    ULONG       Buckets;
    PTAG_BUCKET *Bucket;   // Array of buckets

#if BIG_ENDIAN
    ULONG       HighMask;
    ULONG       HighShift;
    ULONG       LowMask;
    ULONG       LowShift;
#else
    ULONG       HighShiftLeft;
    ULONG       HighShiftRight;
    ULONG       LowShiftRight;
    ULONG       LowMask;
#endif
};


AccumTagUsage::AccumTagUsage(
    ULONG TagFilter
    )
{
    hHeap = GetProcessHeap();
    Buckets = SetTagFilter(TagFilter);
    if (Buckets != 0)
    {
        Bucket = (PTAG_BUCKET *)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, Buckets*sizeof(*Bucket));
        Reset();
    }
    else
    {
        Bucket = NULL;
    }
}


AccumTagUsage::~AccumTagUsage()
{
    PTAG_BUCKET pB, pBNext;
    ULONG       i;

    if (Bucket != NULL)
    {
        for (i = 0; i < Buckets; i++)
        {
            pB = Bucket[i];
            while (pB != NULL)
            {
                pBNext = pB->pNextTag;
                HeapFree(hHeap, 0, pB);
                pB = pBNext;
            }
        }

        HeapFree(hHeap, 0, Bucket);
    }
}


HRESULT
AccumTagUsage::Valid()
{
    return ((Bucket != NULL) ? S_OK : S_FALSE);
}


HRESULT
AccumTagUsage::Add(
    ULONG Tag,
    PoolType Type,
    ULONG Size
    )
{
    PTAG_BUCKET pBucket = GetBucket(Tag);

    if (pBucket == NULL) return E_FAIL;

    switch (Type)
    {
        case AllocatedPool:
            pBucket->Allocated++;
            pBucket->AllocatedSize += Size;
            break;
        case FreePool:
            pBucket->Free++;
            pBucket->FreeSize += Size;
            break;
        case IndeterminatePool:
        default:
            pBucket->Indeterminate++;
            pBucket->IndeterminateSize += Size;
            break;
    }

    return S_OK;
}


HRESULT
AccumTagUsage::OutputResults(
    OutputControl *OutCtl,
    BOOL AllocSort
    )
{
    HRESULT     hr;
    PTAG_BUCKET pB, pBNext;
    ULONG       i;

    if (Bucket == NULL)
    {
        hr = OutCtl->Output(" No results\n");
    }
    else
    {
        CHAR        szNormal[] = "%4.4s %8lu %12I64u  %8lu %12I64u\n";
        CHAR        szShowIndeterminate[] = "%4.4s %8lu %12I64u  %8lu %12I64u  %8lu %12I64u\n";
        PSZ         pszOutFormat = szNormal;

        OutCtl->Output("\n"
                       " %I64u bytes in %lu allocated pages\n"
                       " %I64u bytes in %lu large allocations\n"
                       " %I64u bytes in %lu free pages\n"
                       " %I64u bytes available in %lu expansion pages\n",
                       ((ULONG64) AllocatedPages) << PageShift,
                       AllocatedPages,
                       ((ULONG64) LargePages) << PageShift,
                       LargeAllocs,
                       ((ULONG64) FreePages) << PageShift,
                       FreePages,
                       ((ULONG64) ExpansionPages) << PageShift,
                       ExpansionPages);

        OutCtl->Output("\nTag    Allocs        Bytes     Freed        Bytes");
        if (Indeterminate != 0)
        {
            OutCtl->Output(" Unknown        Bytes");
            pszOutFormat = szShowIndeterminate;
        }
        OutCtl->Output("\n");

        if (AllocSort)
        {
            OutCtl->OutWarn("  Sorting by allocation size isn't supported.\n");
        }
        //else
        {
            // Output results sorted by Tag (natural storage order)

            for (i = 0; i < Buckets; i++)
            {
                for (pB = Bucket[i]; pB != NULL; pB = pB->pNextTag)
                {
                    if (pB->Allocated)
                    {
                        OutCtl->Output(pszOutFormat,
                                       &pB->Tag,
                                       pB->Allocated, ((ULONG64)pB->AllocatedSize) << POOL_BLOCK_SHIFT,
                                       pB->Free, ((ULONG64)pB->FreeSize) << POOL_BLOCK_SHIFT,
                                       pB->Indeterminate, ((ULONG64)pB->IndeterminateSize) << POOL_BLOCK_SHIFT
                                       );
                    }
                }
            }
        }

        OutCtl->Output("-------------------------------------------------------------------------------\n");
        hr = OutCtl->Output(pszOutFormat,
                            "Ttl:",
                            Allocated, ((ULONG64)AllocatedSize) << POOL_BLOCK_SHIFT,
                            Free, ((ULONG64)FreeSize) << POOL_BLOCK_SHIFT,
                            Indeterminate, ((ULONG64)IndeterminateSize) << POOL_BLOCK_SHIFT
                            );
    }

    return hr;
}


void
AccumTagUsage::Reset()
{
    PTAG_BUCKET pB, pBNext;
    ULONG       i;

    AllocatedPages = 0;
    LargePages = 0;
    LargeAllocs = 0;
    FreePages = 0;
    ExpansionPages = 0;

    Allocated = 0;
    AllocatedSize = 0;
    Free = 0;
    FreeSize = 0;
    Indeterminate = 0;
    IndeterminateSize = 0;

    if (Bucket != NULL)
    {
        for (i = 0; i < Buckets; i++)
        {
            pB = Bucket[i];
            if (pB != NULL)
            {
                do
                {
                    pBNext = pB->pNextTag;
                    HeapFree(hHeap, 0, pB);
                    pB = pBNext;
                } while (pB != NULL);

                Bucket[i] = NULL;
            }
        }
    }
}


ULONG
AccumTagUsage::GetHashIndex(
    ULONG Tag
    )
{
#if BIG_ENDIAN
    return (((Tag & HighMask) >> HighShift) | ((Tag & LowMask) >> LowShift));
#else
    return ((((Tag << HighShiftLeft) >> HighShiftRight) & ~LowMask) | ((Tag >> LowShiftRight) & LowMask));
#endif
}


PTAG_BUCKET
AccumTagUsage::GetBucket(
    ULONG Tag
    )
{
    ULONG       Index = GetHashIndex(Tag);
    PTAG_BUCKET pB = Bucket[Index];

    if (pB == NULL ||
#if BIG_ENDIAN
        pB->Tag > Tag
#else
        strncmp((char *)&pB->Tag, (char *)&Tag, 4) > 0
#endif
        )
    {
        pB = (PTAG_BUCKET)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(TAG_BUCKET));

        if (pB != NULL)
        {
            pB->Tag = Tag;
            pB->pNextTag = Bucket[Index];
            Bucket[Index] = pB;
        }
    }
    else
    {
        while (pB->pNextTag != NULL)
        {
            if (
#if BIG_ENDIAN
                pB->pNextTag->Tag > Tag
#else
                strncmp((char *)&pB->pNextTag->Tag, (char *)&Tag, 4) > 0
#endif
                )
            {
                break;
            }

            pB = pB->pNextTag;
        }

        if (pB->Tag != Tag)
        {
            PTAG_BUCKET pBPrev = pB;

            pB = (PTAG_BUCKET)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(TAG_BUCKET));

            if (pB != NULL)
            {
                pB->Tag = Tag;
                pB->pNextTag = pBPrev->pNextTag;
                pBPrev->pNextTag = pB;
            }
        }
    }

    return pB;
}


ULONG
AccumTagUsage::SetTagFilter(
    ULONG TagFilter
    )
{
    ULONG NumBuckets;
    UCHAR *Filter = (UCHAR *)&TagFilter;
    ULONG i;
    ULONG HighMaskBits, LowMaskBits;
    UCHAR fc;

#if BIG_ENDIAN

    ULONG Mask = 0;
    ULONG MaskBits = 0;

    if (Filter[0] == '*')
    {
        Mask = -1;
        MaskBits = 32;
    }
    else
    {
        for ( i = 0; i < 32; i += 8 )
        {
            Mask <<= 8;
            fc = *Filter++;

            if ( fc == '*' )
            {
                Mask |= ((1 << i) - 1);
                MaskBits += 32 - i;
                break;
            }

            if ( fc == '?' )
            {
                Mask |= 0xFF;
                MaskBits += 8;
            }
        }
    }

    if (MaskBits > HashBitmaskLimit)
    {
        MaskBits = HashBitmaskLimit;
    }

    NumBuckets = (1 << MaskBits);

    for (HighShift = 32, HighMaskBits = 0;
         HighShift > 0 && HighMaskBits < MaskBits;
         HighShift--)
    {
        if (Mask & (1 << (HighShift-1)))
        {
            HighMaskBits++;
        }
        else if (HighMaskBits)
        {
            break;
        }
    }

    HighMask = Mask & ~((1 << HighShift) - 1);
    Mask &= ~HighMask;
    MaskBits -= HighMaskBits;
    HighShift -= MaskBits;

    for (LowShift = HighShift, LowMaskBits = 0;
         LowShift > 0 && LowMaskBits < MaskBits;
         LowShift--)
    {
        if (Mask & (1 << (LowShift-1)))
        {
            LowMaskBits++;
        }
        else if (LowMaskBits)
        {
            break;
        }
    }

    LowMask = Mask & ~((1 << LowShift) - 1);

#else

    HighMaskBits = 0;
    LowMaskBits = 0;

    HighShiftLeft = 32;
    HighShiftRight = 32;
    LowShiftRight = 32;
    LowMask = 0;

    for ( i = 0; i < 32; i += 8 )
    {
        fc = *Filter++;

        if ( fc == '*' )
        {
            if (HighMaskBits == 0)
            {
                HighMaskBits = min(8, HashBitmaskLimit);
                HighShiftLeft = 32 - HighMaskBits - i;
                HighShiftRight = 32 - HighMaskBits;

                LowMaskBits = ((HighShiftLeft != 0) ?
                               min(8, HashBitmaskLimit - HighMaskBits) :
                               0);
                HighShiftRight -= LowMaskBits;
                LowShiftRight = (8 - LowMaskBits) + HighMaskBits + i;
                LowMask = (1 << LowMaskBits) - 1;
            }
            else
            {
                LowMaskBits = min(8, HashBitmaskLimit - HighMaskBits);
                HighShiftRight -= LowMaskBits;
                LowShiftRight = (8 - LowMaskBits) + i;
                LowMask = (1 << LowMaskBits) - 1;
            }
            break;
        }

        if ( fc == '?' )
        {
            if (HighMaskBits == 0)
            {
                HighMaskBits = min(8, HashBitmaskLimit);
                HighShiftLeft = 32 - HighMaskBits - i;
                HighShiftRight = 32 - HighMaskBits;
            }
            else
            {
                LowMaskBits = min(8, HashBitmaskLimit - HighMaskBits);
                HighShiftRight -= LowMaskBits;
                LowShiftRight = (8 - LowMaskBits) + i;
                LowMask = (1 << LowMaskBits) - 1;
                break;
            }
        }
    }

    NumBuckets = 1 << (HighMaskBits + LowMaskBits);

#endif

    if (NumBuckets-1 != GetHashIndex(-1))
    {
        DbgPrint("AccumTagUsage::SetTagFilter: Invalid hash was generated.\n");
        NumBuckets = 0;
    }

    return NumBuckets;
}


HRESULT
AccumTagUsageFilter(
    OutputControl *OutCtl,
    ULONG64 PoolAddr,
    ULONG TagFilter,
    TypeOutputParser *PoolHeadReader,
    PDEBUG_VALUE Tag,
    ULONG BlockSize,
    BOOL bQuotaWithTag,
    PVOID Context
    )
{
    HRESULT         hr;
    DEBUG_VALUE     PoolType;
    AccumTagUsage  *atu = (AccumTagUsage *)Context;
    PALLOCATION_STATS   AllocStatsAccum = (PALLOCATION_STATS)atu;

    if (CheckSingleFilter(Tag->RawBytes, (PUCHAR)&TagFilter) != S_OK)
    {
        return S_FALSE;
    }

    hr = PoolHeadReader->Get(&PoolType, "PoolType", DEBUG_VALUE_INT32);

    if (hr == S_OK)
    {
        if (PoolType.I32 == 0)
        {
            hr = atu->Add(Tag->I32, FreePool, BlockSize);
            AllocStatsAccum->Free++;
            AllocStatsAccum->FreeSize += BlockSize;
        }
        else
        {
            DEBUG_VALUE PoolIndex;

            if (!(PoolType.I32 & POOL_QUOTA_MASK) ||
                bQuotaWithTag)
            {
                Tag->I32 &= ~PROTECTED_POOL;
            }
            else if (PoolType.I32 & POOL_QUOTA_MASK)
            {
                Tag->I32 = 'CORP';
            }

            if (!NewPool)
            {
                hr = PoolHeadReader->Get(&PoolIndex, "PoolIndex", DEBUG_VALUE_INT32);
            }

            if (hr == S_OK)
            {
                if (NewPool ? (PoolType.I32 & 0x04) : (PoolIndex.I32 & 0x80))
                {
                    hr = atu->Add(Tag->I32, AllocatedPool, BlockSize);
                    AllocStatsAccum->Allocated++;
                    AllocStatsAccum->AllocatedSize += BlockSize;

                    if (AllocStatsAccum->Allocated % 100 == 0)
                    {
                        OutCtl->Output(".");

                        if (AllocStatsAccum->Allocated % 8000 == 0)
                        {
                            OutCtl->Output("\n");
                        }
                    }
                }
                else
                {
                    hr = atu->Add(Tag->I32, FreePool, BlockSize);
                    AllocStatsAccum->Free++;
                    AllocStatsAccum->FreeSize += BlockSize;
                }
            }
            else
            {
                hr = atu->Add(Tag->I32, IndeterminatePool, BlockSize);
                AllocStatsAccum->Indeterminate++;
                AllocStatsAccum->IndeterminateSize += BlockSize;
            }
        }
    }
    else
    {
        AllocStatsAccum->Indeterminate++;
        AllocStatsAccum->IndeterminateSize += BlockSize;
    }

    return hr;
}


HRESULT
SearchSessionPool(
    PDEBUG_CLIENT Client,
    ULONG Session,
    ULONG TagName,
    FLONG Flags,
    ULONG64 RestartAddr,
    PoolFilterFunc Filter,
    PALLOCATION_STATS AllocStats,
    PVOID Context
    )
/*++

Routine Description:

    Engine to search session pool.

Arguments:

    TagName - Supplies the tag to search for.

    Flags - Supplies 0 if a nonpaged pool search is desired.
            Supplies 1 if a paged pool search is desired.

    RestartAddr - Supplies the address to restart the search from.

    Filter - Supplies the filter routine to use.

    Context - Supplies the user defined context blob.

Return Value:

    HRESULT

--*/
{
    HRESULT     hr;

    OutputControl   OutCtl(Client);

    PDEBUG_SYMBOLS      Symbols;
    PDEBUG_DATA_SPACES  Data;

    LOGICAL     PhysicallyContiguous;
    ULONG       PoolBlockSize;
    ULONG64     PoolHeader;
    ULONG64     PoolPage;
    ULONG64     StartPage;
    ULONG64     Pool;
    ULONG       Previous;
    ULONG64     PoolStart;
    ULONG64     PoolStartPage;
    ULONG64     PoolPteAddress;
    ULONG64     PoolEnd;
    BOOL        PageReadFailed;
    ULONG64     PagesRead;
    ULONG64     PageReadFailures;
    ULONG64     PageReadFailuresAtEnd;
    ULONG64     LastPageRead;

    ULONG       PoolTypeFlags = Flags & (SEARCH_POOL_NONPAGED | SEARCH_POOL_PAGED);

    ULONG64     NTModuleBase;
    ULONG       PoolHeadTypeID;
    ULONG       SessionHeadTypeID;
    ULONG       HdrSize;

    ULONG64 SessionSpace;

    if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                     (void **)&Symbols)) != S_OK)
    {
        return hr;
    }

    if ((hr = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                     (void **)&Data)) != S_OK)
    {
        Symbols->Release();
        return hr;
    }

    if (Session == DEFAULT_SESSION)
    {
        Session = SessionId;
    }

    if ((hr = Symbols->GetSymbolTypeId("NT!_POOL_HEADER", &PoolHeadTypeID, &NTModuleBase)) == S_OK &&
        (hr = Symbols->GetTypeSize(NTModuleBase, PoolHeadTypeID, & HdrSize)) == S_OK &&
        (hr = GetSessionSpace(Client, Session, &SessionSpace)) == S_OK)
    {
        ULONG               PoolTagOffset, ProcessBilledOffset;
        BOOL                bQuotaWithTag;

        DEBUG_VALUE         ReadSessionId;
        DEBUG_VALUE         PagedPoolInfo;

        DEBUG_VALUE         NonPagedPoolBytes;
        DEBUG_VALUE         NonPagedPoolAllocations;
        DEBUG_VALUE         NonPagedPoolStart;
        DEBUG_VALUE         NonPagedPoolEnd;

        DEBUG_VALUE         PagedPoolPages;
        DEBUG_VALUE         PagedPoolBytes;
        DEBUG_VALUE         PagedPoolAllocations;
        DEBUG_VALUE         PagedPoolStart;
        DEBUG_VALUE         PagedPoolEnd;

        ULONG               SessionSpaceTypeID;
        ULONG               PagedPoolInfoOffset;
        TypeOutputParser    SessionParser(Client); // Dump of MM_SESSION_SPACE
        TypeOutputParser    PoolHeadReader(Client);
        OutputState         OutState(Client);

        BOOL                SearchingPaged = FALSE;
        PRTL_BITMAP         PagedPoolAllocationMap = NULL;
        PRTL_BITMAP         EndOfPagedPoolBitmap = NULL;
        ULONG               BusyStart;
        PRTL_BITMAP         PagedPoolLargeSessionAllocationMap = NULL;

        BOOL                Continue = TRUE;

        bQuotaWithTag = (Symbols->GetFieldOffset(NTModuleBase, PoolHeadTypeID, "PoolTag", &PoolTagOffset) == S_OK &&
                         Symbols->GetFieldOffset(NTModuleBase, PoolHeadTypeID, "ProcessBilled", &ProcessBilledOffset) == S_OK &&
                         PoolTagOffset != ProcessBilledOffset);

        // General parser setup and dump MM_SESSION_SPACE structure
        if ((hr = OutState.Setup(0, &SessionParser)) == S_OK &&
            (hr = Symbols->GetTypeId(NTModuleBase, "MM_SESSION_SPACE", &SessionSpaceTypeID)) == S_OK &&
            ((hr = OutState.OutputTypeVirtual(SessionSpace, NTModuleBase, SessionSpaceTypeID, DEBUG_OUTTYPE_BLOCK_RECURSE)) == S_OK ||
             ((hr = OutState.OutputTypeVirtual(SessionSpace, NTModuleBase, SessionSpaceTypeID, 0)) == S_OK &&
              (hr = Symbols->GetFieldOffset(NTModuleBase, SessionSpaceTypeID, "PagedPoolInfo", &PagedPoolInfoOffset)) == S_OK &&
              (hr = OutState.OutputTypeVirtual(SessionSpace + PagedPoolInfoOffset, "NT!_MM_PAGED_POOL_INFO", 0)) == S_OK
            )) &&
            (hr = SessionParser.Get(&ReadSessionId, "SessionId", DEBUG_VALUE_INT32)) == S_OK)
        {
            OutCtl.Output("Searching session %ld pool.\n", ReadSessionId.I32);

            // Remaining type output goes to PoolHead reader
            hr = OutState.Setup(0, &PoolHeadReader);
        }
        else
        {
            OutCtl.OutErr("Error getting basic session pool information.\n");
        }

        while (hr == S_OK && Continue)
        {
            OutCtl.Output("\n");

            if (PoolTypeFlags & SEARCH_POOL_NONPAGED)
            {
                if (SessionParser.Get(&NonPagedPoolBytes, "NonPagedPoolBytes", DEBUG_VALUE_INT64) == S_OK &&
                    SessionParser.Get(&NonPagedPoolAllocations, "NonPagedPoolAllocations", DEBUG_VALUE_INT64) == S_OK)
                {
                    OutCtl.Output("NonPaged pool: %I64u bytes in %I64u allocations\n",
                                  NonPagedPoolBytes.I64, NonPagedPoolAllocations.I64);
                }

                OutCtl.Output(" NonPaged pool range reader isn't implemented.\n");

                PoolStart = 0;
                PoolEnd = 0;
                SearchingPaged = FALSE;
            }
            else
            {
                if (SessionParser.Get(&PagedPoolBytes, "PagedPoolBytes", DEBUG_VALUE_INT64) == S_OK &&
                    SessionParser.Get(&PagedPoolAllocations, "PagedPoolAllocations", DEBUG_VALUE_INT64) == S_OK)
                {
                    OutCtl.Output("Paged pool: %I64u bytes in %I64u allocations\n",
                                  PagedPoolBytes.I64, PagedPoolAllocations.I64);

                    if (SessionParser.Get(&PagedPoolPages, "AllocatedPagedPool", DEBUG_VALUE_INT64) == S_OK)
                    {
                        OutCtl.Output(" Paged Pool Info: %I64u pages allocated\n",
                                      PagedPoolPages.I64);
                    }
                }

                if ((hr = SessionParser.Get(&PagedPoolStart, "PagedPoolStart", DEBUG_VALUE_INT64)) != S_OK ||
                    (hr = SessionParser.Get(&PagedPoolEnd, "PagedPoolEnd", DEBUG_VALUE_INT64)) != S_OK)
                {
                    OutCtl.OutErr(" Couldn't get PagedPool range.\n");
                }
                else
                {
                    PoolStart = PagedPoolStart.I64;
                    PoolEnd = PagedPoolEnd.I64;
                    SearchingPaged = TRUE;

                    DEBUG_VALUE     PagedBitMap;

                    if (SessionParser.Get(&PagedBitMap, "PagedPoolAllocationMap", DEBUG_VALUE_INT64) == S_OK &&
                        GetBitMap(Client, PagedBitMap.I64, &PagedPoolAllocationMap) == S_OK &&
                        SessionParser.Get(&PagedBitMap, "EndOfPagedPoolBitmap", DEBUG_VALUE_INT64) == S_OK &&
                        GetBitMap(Client, PagedBitMap.I64, &EndOfPagedPoolBitmap) == S_OK)
                    {
                        ULONG   PositionAfterLastAlloc;
                        ULONG   AllocBits;
                        ULONG   UnusedBusyBits;

                        if (RtlCheckBit(EndOfPagedPoolBitmap, EndOfPagedPoolBitmap->SizeOfBitMap - 1))
                        {
                            BusyStart = PagedPoolAllocationMap->SizeOfBitMap;
                            UnusedBusyBits = 0;
                        }
                        else
                        {
                            RtlFindLastBackwardRunClear(EndOfPagedPoolBitmap,
                                                        EndOfPagedPoolBitmap->SizeOfBitMap - 1,
                                                        &PositionAfterLastAlloc);

                            BusyStart = RtlFindSetBits(PagedPoolAllocationMap, 1, PositionAfterLastAlloc);
                            if (BusyStart < PositionAfterLastAlloc || BusyStart == -1)
                            {
                                BusyStart = PagedPoolAllocationMap->SizeOfBitMap;
                                UnusedBusyBits = 0;
                            }
                            else
                            {
                                UnusedBusyBits = PagedPoolAllocationMap->SizeOfBitMap - BusyStart;
                            }
                        }

                        AllocBits = RtlNumberOfSetBits(PagedPoolAllocationMap) - UnusedBusyBits;

                        AllocStats->AllocatedPages += AllocBits;
                        AllocStats->FreePages += (BusyStart - AllocBits);
                        AllocStats->ExpansionPages += UnusedBusyBits;

                        if (SessionParser.Get(&PagedBitMap, "PagedPoolLargeSessionAllocationMap", DEBUG_VALUE_INT64) == S_OK &&
                            GetBitMap(Client, PagedBitMap.I64, &PagedPoolLargeSessionAllocationMap) == S_OK)
                        {
                            ULONG AllocStart, AllocEnd;
                            ULONG LargeAllocs = RtlNumberOfSetBits(PagedPoolLargeSessionAllocationMap);

                            AllocStats->LargeAllocs += LargeAllocs;

                            AllocStart = 0;
                            AllocEnd = -1;

                            while (LargeAllocs > 0)
                            {
                                AllocStart = RtlFindSetBits(PagedPoolLargeSessionAllocationMap, 1, AllocStart);
                                if (AllocStart >= AllocEnd+1 && AllocStart != -1)
                                {
                                    AllocEnd = RtlFindSetBits(EndOfPagedPoolBitmap, 1, AllocStart);
                                    if (AllocEnd >= AllocStart && AllocEnd != -1)
                                    {
                                        AllocStats->LargePages += AllocEnd - AllocStart + 1;
                                        AllocStart++;
                                        LargeAllocs--;
                                    }
                                    else
                                    {
                                        OutCtl.OutWarn(" Warning Large Pool Allocation Map or End Of Pool Map is invalid.\n");
                                        break;
                                    }
                                }
                                else
                                {
                                    OutCtl.OutWarn(" Warning Large Pool Allocation Map is invalid.\n");
                                    break;
                                }
                            }

                            if (LargeAllocs != 0)
                            {
                                OutCtl.OutWarn(" %lu large allocations weren't calculated.\n", LargeAllocs);
                                AllocStats->LargeAllocs -= LargeAllocs;
                            }
                        }
                    }
                }
            }

            if (hr == S_OK)
            {
                OutCtl.Output("Searching %s pool (0x%p : 0x%p) for Tag: %c%c%c%c\r\n\n",
                              ((PoolTypeFlags & SEARCH_POOL_NONPAGED) ? "NonPaged" : "Paged"),
                              PoolStart,
                              PoolEnd,
                              TagName,
                              TagName >> 8,
                              TagName >> 16,
                              TagName >> 24);

                PageReadFailed = FALSE;
                PoolStartPage = PAGE_ALIGN64(PoolStart);
                PoolPage = PoolStart;
                PagesRead = 0;
                PageReadFailures = 0;
                PageReadFailuresAtEnd = 0;
                LastPageRead = PAGE_ALIGN64(PoolPage);

                while (PoolPage < PoolEnd && hr == S_OK)
                {
                    Pool        = PAGE_ALIGN64(PoolPage);
                    StartPage   = Pool;
                    Previous    = 0;

                    if (Session != CURRENT_SESSION)
                    {
                        OutCtl.Output("Currently only searching the current session is supported.\n");
                        PoolPage = PoolEnd;
                        break;
                    }

                    if (OutCtl.GetInterrupt() == S_OK)
                    {
                        OutCtl.Output("\n...terminating - searched pool to 0x%p\n",
                                      Pool-1);
                        hr = E_ABORT;
                        break;
                    }

                    if (SearchingPaged)
                    {
                        if (PagedPoolAllocationMap != NULL)
                        {
                            ULONG   StartPosition, EndPosition;

                            StartPosition = (ULONG)((Pool - PoolStartPage) >> PageShift);
                            EndPosition = RtlFindSetBits(EndOfPagedPoolBitmap, 1, StartPosition);
                            if (EndPosition < StartPosition) EndPosition = -1;

                            if (!RtlCheckBit(PagedPoolAllocationMap, StartPosition))
                            {
                                if (PageReadFailed)
                                {
                                    if (Flags & SEARCH_POOL_PRINT_UNREAD)
                                    {
                                        OutCtl.OutWarn(" to 0x%p\n", StartPage-1);
                                    }

                                    PageReadFailures += (StartPage - LastPageRead) >> PageShift;
                                    LastPageRead = StartPage;
                                    PageReadFailed = FALSE;
                                }

                                if (EndPosition == -1)
                                {
                                    if (Flags & SEARCH_POOL_PRINT_UNREAD)
                                    {
                                        OutCtl.OutWarn("No remaining pool allocations from 0x%p to 0x%p.\n", Pool, PoolEnd);
                                    }

                                    PoolPage = PoolEnd;
                                }
                                else
                                {
                                    PoolPage = PoolStartPage + (((ULONG64)EndPosition + 1) << PageShift);
                                }

                                continue;
                            }
                            else if (EndOfPagedPoolBitmap != NULL)
                            {
                                if (PagedPoolLargeSessionAllocationMap != NULL &&
                                    RtlCheckBit(PagedPoolLargeSessionAllocationMap, StartPosition))
                                {
                                    if (EndPosition == -1)
                                    {
                                        OutCtl.OutWarn("No end to large pool allocation @ 0x%p found.\n", Pool);
                                        PoolPage = PoolEnd;
                                    }
                                    else
                                    {
                                        EndPosition++;

                                        if (PageReadFailed)
                                        {
                                            if (Flags & SEARCH_POOL_PRINT_UNREAD)
                                            {
                                                OutCtl.OutWarn(" to 0x%p\n", StartPage-1);
                                            }

                                            PageReadFailures += (StartPage - LastPageRead) >> PageShift;
                                            LastPageRead = StartPage;
                                            PageReadFailed = FALSE;
                                        }

                                        PoolPage = PoolStartPage + (((ULONG64)EndPosition) << PageShift);

                                        if (Flags & SEARCH_POOL_PRINT_LARGE)
                                        {
                                            OutCtl.Output("0x%p size: %5I64x  %s UNTAGGED Large\n",
                                                          StartPage,
                                                          PoolPage - StartPage,
                                                          ((RtlAreBitsSet(PagedPoolAllocationMap, StartPosition, EndPosition - StartPosition)) ?
                                                           "(Allocated)" :
                                                           ((RtlAreBitsClear(PagedPoolAllocationMap, StartPosition, EndPosition - StartPosition)) ?
                                                            "(! Free !) " :
                                                            "(!! Partially Allocated !!)"))
                                                          );
                                        }

                                        if (Flags & SEARCH_POOL_LARGE_ONLY)
                                        {
                                            // Quickly locate next large allocation
                                            StartPosition = RtlFindSetBits(PagedPoolLargeSessionAllocationMap, 1, EndPosition);

                                            if (StartPosition < EndPosition || StartPosition == -1)
                                            {
                                                OutCtl.OutVerb(" No large allocations found after 0x%p\n", PoolPage-1);
                                                PoolPage = PoolEnd;
                                            }
                                            else
                                            {
                                                PoolPage = PoolStartPage + (((ULONG64)StartPosition) << PageShift);
                                            }
                                        }
                                    }

                                    continue;
                                }
                                else if (EndPosition == -1)
                                {
                                    if (PageReadFailed)
                                    {
                                        if (Flags & SEARCH_POOL_PRINT_UNREAD)
                                        {
                                            OutCtl.OutWarn(" to 0x%p\n", StartPage-1);
                                        }

                                        PageReadFailures += (StartPage - LastPageRead) >> PageShift;
                                        LastPageRead = StartPage;
                                        PageReadFailed = FALSE;
                                    }

                                    if (Flags & SEARCH_POOL_PRINT_UNREAD)
                                    {
                                        OutCtl.OutWarn("No remaining pool allocations from 0x%p to 0x%p.\n", Pool, PoolEnd);
                                    }

                                    PoolPage = PoolEnd;

                                    continue;
                                }
                                else if (StartPosition >= BusyStart)
                                {
                                    OutCtl.OutWarn("Found end of allocation at %lu within expansion pages starting at %lu.\n",
                                                   EndPosition, BusyStart);
                                }
                            }
                        }
                    }

                    if (Flags & SEARCH_POOL_LARGE_ONLY)
                    {
                        OutCtl.OutErr(" Unable to identify large pages.  Terminating search at 0x%p.\n", StartPage);
                        PoolPage = PoolEnd;
                        hr = E_FAIL;
                        continue;
                    }

                    // Search page for small allocations
                    while (PAGE_ALIGN64(Pool) == StartPage && hr == S_OK)
                    {
                        DEBUG_VALUE HdrPoolTag, BlockSize, PreviousSize, AllocatorBackTraceIndex, PoolTagHash;
                        ULONG PoolType;

                        PoolHeadReader.DiscardOutput();

                        if ((hr = OutState.OutputType(FALSE, Pool, NTModuleBase, PoolHeadTypeID, 0)) != S_OK ||
                            PoolHeadReader.Get(&HdrPoolTag, "PoolTag", DEBUG_VALUE_INT32) != S_OK)
                        {
                            if (hr != S_OK)
                            {
                                PSTR    psz;

                                OutCtl.OutErr("Type read error %s @ 0x%p.\n", pszHRESULT(hr), Pool);

                                OutCtl.OutWarn("Failed to read an allocated page @ 0x%p.\n", StartPage);

                                if (PoolHeadReader.GetOutputCopy(&psz) == S_OK)
                                {
                                    if (strchr(psz, '?') != NULL)
                                    {
                                        hr = S_OK;
                                    }
                                    else
                                    {
                                        OutCtl.OutVerb("PoolHeadReader contains:\n"
                                                       "%s\n", psz);

                                        OutCtl.Output("\n...terminating - searched pool to 0x%p\n",
                                                      Pool);
                                        hr = E_ABORT;
                                    }

                                    PoolHeadReader.FreeOutputCopy(psz);
                                }

                                if (hr == E_ABORT)
                                {
                                    break;
                                }
                            }

                            if (!PageReadFailed)
                            {
                                if (Flags & SEARCH_POOL_PRINT_UNREAD)
                                {
                                    OutCtl.OutWarn(" Couldn't read pool from 0x%p", Pool);
                                }

                                PagesRead += (StartPage - LastPageRead) / PageSize;
                                LastPageRead = StartPage;
                                PageReadFailed = TRUE;
                            }

                            if ((hr = GetNextResidentAddress(Client,
                                                             Session,
                                                             StartPage + PageSize,
                                                             PoolEnd,
                                                             &PoolPage,
                                                             NULL)) != S_OK)
                            {
                                if (hr != E_ABORT)
                                {
                                    hr = S_OK;
                                }

                                if (Flags & SEARCH_POOL_PRINT_UNREAD)
                                {
                                    OutCtl.OutWarn(" to 0x%p.\n", PoolEnd);
                                    OutCtl.OutWarn("No remaining resident page found.\n");
                                }

                                PageReadFailuresAtEnd = (PoolEnd - LastPageRead) / PageSize;
                                PageReadFailures += PageReadFailuresAtEnd;
                                LastPageRead = PoolEnd;
                                PageReadFailed = FALSE;

                                PoolPage = PoolEnd;
                            }

                            break;
                        }

                        if (PageReadFailed)
                        {
                            if (Flags & SEARCH_POOL_PRINT_UNREAD)
                            {
                                OutCtl.OutWarn(" to 0x%p\n", StartPage-1);
                            }

                            PageReadFailures += (StartPage - LastPageRead) / PageSize;
                            LastPageRead = StartPage;
                            PageReadFailed = FALSE;
                        }

                        if (PoolHeadReader.Get(&BlockSize, "BlockSize", DEBUG_VALUE_INT32) != S_OK)
                        {
                            OutCtl.OutErr("Error reading BlockSize @ 0x%p.\n", Pool);
                            break;
                        }

                        if ((BlockSize.I32 << POOL_BLOCK_SHIFT) > PageSize)//POOL_PAGE_SIZE)
                        {
                            OutCtl.OutVerb("Bad allocation size @ 0x%p, too large\n", Pool);
                            break;
                        }

                        if (BlockSize.I32 == 0)
                        {
                            OutCtl.OutVerb("Bad allocation size @ 0x%p, zero is invalid\n", Pool);
                            break;
                        }

                        if (PoolHeadReader.Get(&PreviousSize, "PreviousSize", DEBUG_VALUE_INT32) != S_OK ||
                            PreviousSize.I32 != Previous)
                        {
                            OutCtl.OutVerb("Bad previous allocation size @ 0x%p, last size was 0x%lx\n", Pool, Previous);
                            break;
                        }

                        Filter(&OutCtl,
                               Pool,
                               TagName,
                               &PoolHeadReader,
                               &HdrPoolTag,
                               BlockSize.I32,
                               bQuotaWithTag,
                               Context
                               );

                        Previous = BlockSize.I32;
                        Pool += (Previous << POOL_BLOCK_SHIFT);

                        if ( OutCtl.GetInterrupt() == S_OK)
                        {
                            OutCtl.Output("\n...terminating - searched pool to 0x%p\n",
                                          PoolPage-1);
                            hr = E_ABORT;
                        }
                    }

                    if (hr == S_OK)
                    {
                        PoolPage = (PoolPage + PageSize);
                    }
                }

                if (PageReadFailed)
                {
                    if (Flags & SEARCH_POOL_PRINT_UNREAD)
                    {
                        OutCtl.OutWarn(" to 0x%p\n", StartPage-1);
                    }

                    PageReadFailuresAtEnd = (PoolPage - LastPageRead) / PageSize;
                    PageReadFailures += PageReadFailuresAtEnd;
                    PageReadFailed = FALSE;
                }
                else
                {
                    PagesRead += (PoolPage - LastPageRead) / PageSize;
                }

                OutCtl.Output(" Pages Read: %I64d\n"
                              "   Failures: %I64d  (%I64d at end of search)\n",
                              PagesRead, PageReadFailures, PageReadFailuresAtEnd);
            }

            if (PoolTypeFlags == (SEARCH_POOL_NONPAGED | SEARCH_POOL_PAGED))
            {
                PoolTypeFlags = SEARCH_POOL_PAGED;
            }
            else
            {
                Continue = FALSE;
            }
        }

        if (PagedPoolAllocationMap != NULL) FreeBitMap(PagedPoolAllocationMap);
        if (EndOfPagedPoolBitmap != NULL) FreeBitMap(EndOfPagedPoolBitmap);
        if (PagedPoolLargeSessionAllocationMap != NULL) FreeBitMap(PagedPoolLargeSessionAllocationMap);
    }

    return hr;
}


HRESULT
GetTagFilter(
    PDEBUG_CLIENT Client,
    PCSTR *pArgs,
    PDEBUG_VALUE TagFilter
    )
{
    HRESULT hr;

    PCSTR   args;
    PCSTR   TagArg;

    ULONG   TagLen;
    CHAR    TagEnd;
    ULONG   WildCardPos;

    OutputControl   OutCtl(Client);

    TagArg = args = *pArgs;
    TagFilter->Type = DEBUG_VALUE_INVALID;

    do
    {
        args++;
    } while (*args != '\0' && !isspace(*args));

    while (isspace(*args)) args++;

    if (TagArg[0] == '0' && TagArg[1] == 'x')
    {
        hr = Evaluate(Client, TagArg, DEBUG_VALUE_INT64,
                      EVALUATE_DEFAULT_RADIX, TagFilter,
                      NULL, NULL,
                      EVALUATE_COMPACT_EXPR);
    }
    else
    {
        if (TagArg[0] == '`' || TagArg[0] == '\'' || TagArg[0] == '\"')
        {
            TagEnd = TagArg[0];
            TagArg++;
            args = TagArg;

            while (args - TagArg < 4 &&
                   *args != '\0' &&
                   *args != TagEnd)
            {
                args++;
            }
            TagLen = (ULONG)(args - TagArg);
            if (*args == TagEnd) args++;
            while (isspace(*args)) args++;
        }
        else
        {
            TagLen = (ULONG)(args - TagArg);
            TagEnd = '\0';
        }

        if (TagLen == 0 ||
            (TagLen < 4 &&
             TagArg[TagLen-1] != '*'
            ) ||
            (TagLen >= 4 &&
             TagArg[4] != '\0' &&
             !isspace(TagArg[4]) &&
             (TagArg[4] != TagEnd || (TagArg[5] != '\0' && !isspace(TagArg[5])))
            )
           )
        {
            OutCtl.OutErr(" Invalid Tag filter.\n");
            hr = E_INVALIDARG;
        }
        else
        {
            hr = S_OK;

            for (WildCardPos = 0; WildCardPos < TagLen; WildCardPos++)
            {
                if (TagArg[WildCardPos] == '*')
                {
                    ULONG NewTagLen = WildCardPos + 1;
                    if (NewTagLen < TagLen)
                    {
                        OutCtl.OutWarn(" Ignoring %lu characters after * in Tag.\n",
                                       TagLen - NewTagLen);
                    }
                    TagLen = NewTagLen;
                    // loop will terminate
                }
            }

            if (TagLen < 4)
            {
                TagFilter->I32 = '    ';
                while (TagLen-- > 0)
                {
                    TagFilter->RawBytes[TagLen] = TagArg[TagLen];
                }
            }
            else
            {
                TagFilter->I32 = TagArg[0] | (TagArg[1] << 8) | (TagArg[2] << 16) | (TagArg[3] << 24);
            }
            TagFilter->Type = DEBUG_VALUE_INT32;
        }
    }

    if (hr == S_OK)
    {
        *pArgs = args;
    }

    return hr;
}


HRESULT
OutputAllocStats(
    OutputControl *OutCtl,
    PALLOCATION_STATS AllocStats,
    BOOL PartialResults
    )
{
    return OutCtl->Output("\n"
                          " %I64u bytes in %lu allocated pages\n"
                          " %I64u bytes in %lu large allocations\n"
                          " %I64u bytes in %lu free pages\n"
                          " %I64u bytes available in %lu expansion pages\n"
                          "\n"
                          "%s found (small allocations only): %lu\n"
                          "  Allocated: %I64u bytes in %lu entries\n"
                          "  Free: %I64u bytes in %lu entries\n"
                          "  Undetermined: %I64u bytes in %lu entries\n",
                          ((ULONG64) AllocStats->AllocatedPages) << PageShift,
                          AllocStats->AllocatedPages,
                          ((ULONG64) AllocStats->LargePages) << PageShift,
                          AllocStats->LargeAllocs,
                          ((ULONG64) AllocStats->FreePages) << PageShift,
                          AllocStats->FreePages,
                          ((ULONG64) AllocStats->ExpansionPages) << PageShift,
                          AllocStats->ExpansionPages,
                          ((PartialResults) ? "PARTIAL entries" : "Entries"),
                          AllocStats->Allocated + AllocStats->Free + AllocStats->Indeterminate,
                          ((ULONG64)AllocStats->AllocatedSize) << POOL_BLOCK_SHIFT,
                          AllocStats->Allocated,
                          ((ULONG64)AllocStats->FreeSize) << POOL_BLOCK_SHIFT,
                          AllocStats->Free,
                          ((ULONG64)AllocStats->IndeterminateSize) << POOL_BLOCK_SHIFT,
                          AllocStats->Indeterminate
                          );
}


DECLARE_API( spoolfind )
{
    HRESULT         hr = S_OK;
    
    BEGIN_API( spoolfind );

    BOOL            BadArg = FALSE;
    ULONG           RemainingArgIndex;

    DEBUG_VALUE     TagName = { 0, DEBUG_VALUE_INVALID };

    FLONG           Flags = 0;
    DEBUG_VALUE     Session = { DEFAULT_SESSION, DEBUG_VALUE_INVALID };
    OutputControl   OutCtl(Client);

    while (isspace(*args)) args++;

    while (!BadArg && hr == S_OK)
    {
        while (isspace(*args)) args++;

        if (*args == '-')
        {
            // Process switches

            args++;
            BadArg = (*args == '\0' || isspace(*args));

            while (*args != '\0' && !isspace(*args))
            {
                switch (tolower(*args))
                {
                    case 'f':
                        Flags |= SEARCH_POOL_PRINT_UNREAD;
                        args++;
                        break;

                    case 'l':
                        Flags |= SEARCH_POOL_PRINT_LARGE;
                        args++;
                        break;

                    case 'n':
                        Flags |= SEARCH_POOL_NONPAGED;
                        args++;
                        break;

                    case 'p':
                        Flags |= SEARCH_POOL_PAGED;
                        args++;
                        break;

                    case 's':
                        if (Session.Type != DEBUG_VALUE_INVALID)
                        {
                            OutCtl.OutErr("Session argument specified multiple times.\n");
                            BadArg = TRUE;
                        }
                        else
                        {
                            args++;
                            hr = Evaluate(Client, args, DEBUG_VALUE_INT32, 10, &Session, &RemainingArgIndex);
                            if (hr != S_OK)
                            {
                                OutCtl.OutErr("Invalid Session.\n");
                            }
                            else
                            {
                                args += RemainingArgIndex;
                            }
                        }
                        break;

                    default:
                        BadArg = TRUE;
                        break;
                }

                if (BadArg) break;
            }
        }
        else
        {
            if (*args == '\0') break;

            if (TagName.Type == DEBUG_VALUE_INVALID)
            {
                hr = GetTagFilter(Client, &args, &TagName);
            }
            else
            {
                OutCtl.OutErr("Unrecognized argument @ %s\n", args);
                BadArg = TRUE;
            }
        }
    }

    if (!BadArg && hr == S_OK)
    {
        if (TagName.Type == DEBUG_VALUE_INVALID)
        {
            if (Flags & SEARCH_POOL_PRINT_LARGE)
            {
                TagName.I32 = '   *';
                Flags |= SEARCH_POOL_LARGE_ONLY;
            }
            else
            {
                OutCtl.OutErr("Missing Tag.\n");
                hr = E_INVALIDARG;
            }
        }
    }

    if (BadArg || hr != S_OK)
    {
        if (*args == '?')
        {
            OutCtl.Output("spoolfind is like !kdexts.poolfind, but for the SessionId specified.\n"
                          "\n");
        }

        OutCtl.Output("Usage: spoolfind [-lnpf] [-s SessionId] Tag\n"
                      "    -f - show read failure ranges\n"
                      "    -l - show large allocations\n"
                      "    -n - show non-paged pool\n"
                      "    -p - show paged pool\n"
                      "\n"
                      "    Tag - Pool tag to search for\n"
                      "            Can be 4 character string or\n"
                      "             hex value in 0xXXXX format\n"
                      "\n"
                      "    SessionId - session to dump\n"
                      "            Special SessionId values:\n"
                      "             -1 - current session\n"
                      "             -2 - last !session SessionId (default)\n"
                      );
    }
    else
    {
        ALLOCATION_STATS    AllocStats = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

        if ((Flags & (SEARCH_POOL_PAGED | SEARCH_POOL_NONPAGED)) == 0)
        {
            Flags |= SEARCH_POOL_PAGED | SEARCH_POOL_NONPAGED;
        }

        if (Session.Type == DEBUG_VALUE_INVALID)
        {
            Session.I32 = DEFAULT_SESSION;
        }

        hr = SearchSessionPool(Client,
                               Session.I32, TagName.I32, Flags,
                               0,
                               CheckPrintAndAccumFilter, &AllocStats, &AllocStats);

        if (hr == S_OK || hr == E_ABORT)
        {
            OutputAllocStats(&OutCtl, &AllocStats, (hr != S_OK));
        }
        else
        {
            OutCtl.OutWarn("SearchSessionPool returned %s\n", pszHRESULT(hr));
        }
    }

    return hr;
}


DECLARE_API( spoolsum )
{
    HRESULT             hr = S_OK;
    
    BEGIN_API( spoolsum );

    ULONG               RemainingArgIndex;

    FLONG               Flags = 0;
    DEBUG_VALUE         Session = { DEFAULT_SESSION, DEBUG_VALUE_INVALID };
    OutputControl       OutCtl(Client);

    while (isspace(*args)) args++;

    while (hr == S_OK)
    {
        while (isspace(*args)) args++;

        if (*args == '-')
        {
            // Process switches

            args++;
            if (*args == '\0' || isspace(*args)) hr = E_INVALIDARG;

            while (*args != '\0' && !isspace(*args))
            {
                switch (tolower(*args))
                {
                    case 'f':
                        Flags |= SEARCH_POOL_PRINT_UNREAD;
                        args++;
                        break;

                    case 'n':
                        Flags |= SEARCH_POOL_NONPAGED;
                        args++;
                        break;

                    case 'p':
                        Flags |= SEARCH_POOL_PAGED;
                        args++;
                        break;

                    case 's':
                        if (Session.Type != DEBUG_VALUE_INVALID)
                        {
                            OutCtl.OutErr("Session argument specified multiple times.\n");
                            hr = E_INVALIDARG;
                        }
                        else
                        {
                            args++;
                            hr = Evaluate(Client, args, DEBUG_VALUE_INT32, 10, &Session, &RemainingArgIndex);
                            if (hr != S_OK)
                            {
                                OutCtl.OutErr("Invalid Session.\n");
                            }
                            else
                            {
                                args += RemainingArgIndex;
                            }
                        }
                        break;

                    default:
                        hr = E_INVALIDARG;
                        break;
                }

                if (hr != S_OK) break;
            }
        }
        else
        {
            if (*args == '\0') break;

            if (Session.Type == DEBUG_VALUE_INVALID)
            {
                hr = Evaluate(Client, args, DEBUG_VALUE_INT32, 10, &Session, &RemainingArgIndex);
                if (hr != S_OK)
                {
                    OutCtl.OutErr("Invalid Session.\n");
                }
                else
                {
                    args += RemainingArgIndex;
                }
            }
            else
            {
                OutCtl.OutErr("Unrecognized argument @ %s\n", args);
                hr = E_INVALIDARG;
            }
        }
    }

    if (hr != S_OK)
    {
        if (*args == '?')
        {
            OutCtl.Output("spoolsum summarizes session pool information for SessionId specified.\n"
                          "\n");
            hr = S_OK;
        }

        OutCtl.Output("Usage: spoolsum [-fnp] [[-s] SessionId]\n"
                      "    f - show read failure ranges\n"
                      "    n - show non-paged pool\n"
                      "    p - show paged pool (Default)\n"
                      "\n"
                      "    SessionId - session to dump\n"
                      "            Special SessionId values:\n"
                      "             -1 - current session\n"
                      "             -2 - last !session SessionId (default)\n"
                      );
    }
    else
    {
        ALLOCATION_STATS    AllocStats = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    
        if ((Flags & (SEARCH_POOL_PAGED | SEARCH_POOL_NONPAGED)) == 0)
        {
            Flags |= SEARCH_POOL_PAGED;
        }

        hr = SearchSessionPool(Client,
                               DEFAULT_SESSION, '   *', Flags,
                               0,
                               AccumAllFilter, &AllocStats, &AllocStats);
    
        if (hr == S_OK || hr == E_ABORT)
        {
            OutputAllocStats(&OutCtl, &AllocStats, (hr != S_OK));
        }
        else
        {
            OutCtl.OutWarn("SearchSessionPool returned %s\n", pszHRESULT(hr));
        }
    }

    return hr;
}


DECLARE_API( spoolused )
{
    HRESULT         hr = S_OK;
    
    BEGIN_API( spoolused );

    BOOL            BadArg = FALSE;
    ULONG           RemainingArgIndex;

    DEBUG_VALUE     TagName = { 0, DEBUG_VALUE_INVALID };

    BOOL            NonPagedUsage = FALSE;
    BOOL            PagedUsage = FALSE;
    BOOL            AllocSort = FALSE;
    DEBUG_VALUE     Session = { DEFAULT_SESSION, DEBUG_VALUE_INVALID };
    OutputControl   OutCtl(Client);

    while (isspace(*args)) args++;

    while (!BadArg && hr == S_OK)
    {
        while (isspace(*args)) args++;

        if (*args == '-')
        {
            // Process switches

            args++;
            BadArg = (*args == '\0' || isspace(*args));

            while (*args != '\0' && !isspace(*args))
            {
                switch (tolower(*args))
                {
                    case 'a':
                        AllocSort = TRUE;
                        args++;
                        break;

                    case 'n':
                        NonPagedUsage = TRUE;
                        args++;
                        break;

                    case 'p':
                        PagedUsage = TRUE;
                        args++;
                        break;

                    case 's':
                        if (Session.Type != DEBUG_VALUE_INVALID)
                        {
                            OutCtl.OutErr("Session argument specified multiple times.\n");
                            BadArg = TRUE;
                        }
                        else
                        {
                            args++;
                            hr = Evaluate(Client, args, DEBUG_VALUE_INT32, 10, &Session, &RemainingArgIndex);
                            if (hr != S_OK)
                            {
                                OutCtl.OutErr("Invalid Session.\n");
                            }
                            else
                            {
                                args += RemainingArgIndex;
                            }
                        }
                        break;

                    default:
                        BadArg = TRUE;
                        break;
                }

                if (BadArg) break;
            }
        }
        else
        {
            if (*args == '\0') break;

            if (TagName.Type == DEBUG_VALUE_INVALID)
            {
                hr = GetTagFilter(Client, &args, &TagName);
            }
            else
            {
                OutCtl.OutErr("Unrecognized argument @ %s\n", args);
                BadArg = TRUE;
            }
        }
    }

    if (BadArg || hr != S_OK)
    {
        if (*args == '?')
        {
            OutCtl.Output("spoolused is like !kdexts.poolused, but for the SessionId specified.\n"
                          "\n");
        }

        OutCtl.Output("Usage: spoolused [-anp] [-s SessionId] [Tag]\n"
                      "    -a - sort by allocation size (Not Implemented)\n"
                      "    -n - show non-paged pool\n"
                      "    -p - show paged pool\n"
                      "\n"
                      "    SessionId - session to dump\n"
                      "            Special SessionId values:\n"
                      "             -1 - current session\n"
                      "             -2 - last !session SessionId (default)\n"
                      "\n"
                      "    Tag - Pool tag filter\n"
                      "            Can be 4 character string or\n"
                      "             hex value in 0xXXXX format\n"
                      );
    }
    else
    {
        if (!NonPagedUsage && !PagedUsage)
        {
            NonPagedUsage = TRUE;
            PagedUsage = TRUE;
        }

        if (Session.Type == DEBUG_VALUE_INVALID)
        {
            Session.I32 = DEFAULT_SESSION;
        }

        if (TagName.Type == DEBUG_VALUE_INVALID)
        {
            TagName.I32 = '   *';
        }

        AccumTagUsage   atu(TagName.I32);

        if (atu.Valid() != S_OK)
        {
            OutCtl.OutErr("Error: failed to prepare tag usage reader.\n");
            hr = E_FAIL;
        }

        if (hr == S_OK && NonPagedUsage)
        {
            hr = SearchSessionPool(Client,
                                   Session.I32, TagName.I32, SEARCH_POOL_NONPAGED,
                                   0,
                                   AccumTagUsageFilter, &atu, &atu);

            if (hr == S_OK || hr == E_ABORT)
            {
                atu.OutputResults(&OutCtl, AllocSort);
            }
            else
            {
                OutCtl.OutWarn("SearchSessionPool returned %s\n", pszHRESULT(hr));
            }
        }

        if (hr == S_OK && PagedUsage)
        {
            if (NonPagedUsage) atu.Reset();

            hr = SearchSessionPool(Client,
                                   Session.I32, TagName.I32, SEARCH_POOL_PAGED,
                                   0,
                                   AccumTagUsageFilter, &atu, &atu);

            if (hr == S_OK || hr == E_ABORT)
            {
                atu.OutputResults(&OutCtl, AllocSort);
            }
            else
            {
                OutCtl.OutWarn("SearchSessionPool returned %s\n", pszHRESULT(hr));
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\typeout.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    typeout.cxx

Abstract:

    This file contains type related output classes.

Author:

    Jason Hartman (JasonHa) 2000-12-18

Environment:

    User Mode

--*/

#include "precomp.hxx"

#define MAX_NAME                 2048


//----------------------------------------------------------------------------
//
// TypeOutputParser
//
// DebugOutputCallback class to parse type output looking for 
// a field and its value.
//
//----------------------------------------------------------------------------

HRESULT
TypeOutputParser::LookFor(
    PDEBUG_VALUE pValueOut,
    PCSTR pszField,
    ULONG DesiredType
    )
{
    Stage = NoField;

    if ((1 > strlen(pszField)) ||
        (strlen(pszField) >= sizeof(Field)/sizeof(Field[0])))
    {
        return E_INVALIDARG;
    }

    Value.Type = DEBUG_VALUE_INVALID;
    strcpy(Field, pszField);

    // Make sure the field name is valid
    while (*pszField)
    {
        if (!__iscsym(*pszField)) return E_INVALIDARG;
        pszField++;
    }

    if (pValueOut != NULL)
    {
        if (Client == NULL) return E_POINTER;
    }

    Type = DesiredType;
    
    ValueOut = pValueOut;

    if (ValueOut != NULL)
    {
        ValueOut->Type = DEBUG_VALUE_INVALID;
    }

    Stage = FieldSpecified;

    return S_OK;
}


HRESULT
TypeOutputParser::Get(
    PDEBUG_VALUE pValueOut,
    PCSTR pszField,
    ULONG DesiredType
    )
{
    HRESULT hr;

    // Check if we've already found this value first
    if (Stage == ValueFound &&
        strcmp(pszField, Field) == 0)
    {
        if (pValueOut != NULL)
        {
            // Make sure to output the right type
            PDEBUG_CONTROL  Control;

            if (Client != NULL)
            {
                hr = Client->QueryInterface(__uuidof(IDebugControl),
                                            (void **)&Control);
                if (hr == S_OK)
                {
                    hr = Control->CoerceValue(&Value, DesiredType, pValueOut);
                    Control->Release();
                }
            }
            else
            {
                hr = E_POINTER;
            }
        }
        else
        {
            hr = S_OK;
        }
    }
    else if ((hr = LookFor(pValueOut, pszField, DesiredType)) == S_OK &&
             (hr = ParseOutput(PARSE_OUTPUT_NO_DISCARD | PARSE_OUTPUT_ALL)) == S_OK)
    {
        hr = Complete();
    }

    return hr;
}


HRESULT
TypeOutputParser::Parse(
    IN PCSTR Text,
    OUT OPTIONAL PULONG RemainderIndex
    )
{
    HRESULT     hr = S_OK;
    PCSTR       pStrUnused = Text;
    PCSTR       pStr = pStrUnused;
    ULONG       EvalStart, EvalEnd;

//    DbgPrint("TypeOutputParser::Parse: Searching \"%s\"\n", pStrUnused);

    while (Stage == FieldSpecified && pStr != NULL)
    {
        pStr = strstr(pStr, Field);
        if (pStr != NULL)
        {
            // Check Field is bounded by non-symbol characters
            BOOL FieldStart = (pStr-1 < pStrUnused) || (!__iscsym(*(pStr-1)));

            // Advance search location
            pStr += strlen(Field);

            if (FieldStart && !__iscsym(*pStr))
            {
                Stage = FieldFound;
            }
        }
    }

    if (Stage == FieldFound)
    {
        pStrUnused = pStr;

        hr = Evaluate(Client,
                      pStrUnused,
                      DEBUG_VALUE_INVALID,
                      10,
                      &Value,
                      &EvalEnd,
                      &EvalStart);

        if (hr == S_OK)
        {
//            DbgPrint("TypeOutputParser::Parse: Found 0x%I64x after \"%s\".\n", Value.I64, Field);

            Stage = ValueFound;

            SIZE_T  EvalLen = min(EvalEnd-EvalStart, sizeof(szValue)-1);

            RtlCopyMemory(szValue, pStrUnused+EvalStart, EvalLen);
            szValue[EvalLen] = '\0';

            if (ValueOut != NULL)
            {
                // Make sure to output the right type
                PDEBUG_CONTROL  Control;

                if (Client != NULL)
                {
                    hr = Client->QueryInterface(__uuidof(IDebugControl),
                                                (void **)&Control);
                    if (hr == S_OK)
                    {
                        hr = Control->CoerceValue(&Value, Type, ValueOut);
                        Control->Release();
                    }
                }
                else
                {
                    hr = E_POINTER;
                }
            }

            pStrUnused += EvalEnd;
        }
        else
        {
            DbgPrint("Evaluate returned HRESULT 0x%lx.\n", hr);
        }
    }

    if (RemainderIndex != NULL)
    {
        *RemainderIndex = (ULONG)(pStrUnused - Text);
    }

    return hr;
}



//----------------------------------------------------------------------------
//
// TypeOutputHelper
//
// DebugOutputCallback class to look up a field's type.
//
//----------------------------------------------------------------------------

class TypeOutputHelper : public OutputReader
{
public:
    TypeOutputHelper(PDEBUG_CLIENT DbgClient) : OutputReader()
    {
        Client = DbgClient;
        if (Client != NULL) Client->AddRef();
    }
    ~TypeOutputHelper()
    {
        if (Client != NULL) Client->Release();
    }

    HRESULT FindFieldType(ULONG64 Module,
                          ULONG TypeId,
                          PCSTR SearchLine,
                          PSTR FieldTypeName,
                          ULONG FieldTypeNameSize);

private:
    PDEBUG_CLIENT   Client;
};

HRESULT
TypeOutputHelper::FindFieldType(
    ULONG64 Module,
    ULONG TypeId,
    PCSTR SearchLine,
    PSTR FieldTypeName,
    ULONG FieldTypeNameSize
    )
{
    HRESULT     hr = S_FALSE;
    PSTR        pLine;
    OutputState OutState(Client);

    if (OutState.Client == NULL)
    {
        DbgPrint("TypeOutputHelper::FindFieldType: Client is NULL.\n");
        return hr;
    }

    if ((hr = OutState.Setup(0, this)) != S_OK)
    {
        return hr;
    }

    if ((hr = OutState.OutputTypeVirtual(0, Module, TypeId, 0)) != S_OK)
    {
        return hr;
    }

    if (Buffer != NULL &&
        (pLine = strstr(Buffer, SearchLine)) != NULL)
    {
        pLine += strlen(SearchLine);

        ULONG i = 0;
        while (i < FieldTypeNameSize &&
               iscsym(*pLine))
        {
            FieldTypeName[i++] = *pLine++;
        }
        FieldTypeName[i] = '\0';
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}



//----------------------------------------------------------------------------
//
// TypeOutputDumper
//
// DebugOutputCallback class to dump type output
// expanding flags and enums.
//
//----------------------------------------------------------------------------

TypeOutputDumper::TypeOutputDumper(
    PDEBUG_CLIENT DbgClient,
    OutputControl *DbgOutCtl
    ) : 
    OutputReader()
{
    Client = DbgClient;
    Symbols = NULL;
    OutCtl = NULL;

    if (Client != NULL)
    {
        Client->AddRef();
        Client->QueryInterface(__uuidof(IDebugSymbols), (void **)&Symbols);

        if (DbgOutCtl == NULL)
        {
            OutCtl = new OutputControl(DEBUG_OUTCTL_AMBIENT, Client);
        }
        else
        {
            OutCtl = DbgOutCtl;
            OutCtl->AddRef();
        }
    }

    Last.Offset = 0;
    Last.Module = 0;
    Last.TypeId = 0;
    Last.Flags = 0;

    MarkUse = IGNORE_MARKS;
    MarkList = NULL;
    Marks = 0;
    MarkListLen = 0;

    CurrentMarkSet = 0;
    for (ULONG Set = 1; Set < lengthof(MarkSet); Set++)
    {
        MarkSet[Set].Use = IGNORE_MARKS;
        MarkSet[Set].List = NULL;
        MarkSet[Set].Marks = 0;
        MarkSet[Set].ListLen = 0;
    }
}


TypeOutputDumper::~TypeOutputDumper()
{
    if (MarkList != NULL) HeapFree(hHeap, 0, MarkList);
    for (ULONG Set = 0; Set < lengthof(MarkSet); Set++)
    {
        if (Set != CurrentMarkSet)
        {
            if (MarkSet[Set].List != NULL) HeapFree(hHeap, 0, MarkSet[Set].List);
        }
    }
    if (OutCtl != NULL) OutCtl->Release();
    if (Symbols != NULL) Symbols->Release();
    if (Client != NULL) Client->Release();
}


void
TypeOutputDumper::DiscardOutput()
{
    // Reset cache id
    Last.Offset = 0;
    Last.Module = 0;
    Last.TypeId = 0;
    Last.Flags = 0;

    OutputReader::DiscardOutput();
}


HRESULT TypeOutputDumper::OutputType(
    BOOL Physical,
    PCSTR Type,
    ULONG64 Offset,
    ULONG Flags,
    PCSTR OutputPrefix
    )
{
    HRESULT hr = S_FALSE;
    char    TypeName[MAX_NAME];
    ULONG64 Module;
    ULONG   TypeId;

    if (OutCtl == NULL)
    {
        DbgPrint("TypeOutputDumper::OutputType: OutCtl is NULL.\n");
        return hr;
    }

    if (Client == NULL)
    {
        DbgPrint("TypeOutputDumper::OutputType: Client is NULL.\n");
        return hr;
    }

    if (Symbols == NULL)
    {
        DbgPrint("TypeOutputDumper::OutputType: Symbols is NULL.\n");
        return hr;
    }

    if ((hr = GetTypeId(Client, Type, &TypeId, &Module)) != S_OK)
    {
        OutCtl->OutVerb(" GetTypeId returned HRESULT 0x%lx.\n", hr);
        return hr;
    }

    if ((hr = Symbols->GetTypeName(Module, TypeId,
                                   TypeName, sizeof(TypeName),
                                   NULL)) != S_OK)
    {
        OutCtl->OutVerb(" GetTypeName returned HRESULT %lx.\n", hr);
        return hr;
    }

    if (Offset == 0)
    {
        Physical = FALSE;

        hr = Symbols->GetOffsetByName(Type, &Offset);

        if (hr != S_OK && hr != S_FALSE)
        {
            OutCtl->OutVerb(" GetOffsetByName returned HRESULT 0x%lx\n", hr);
            return hr;
        }

        OutCtl->OutVerb(" Dumping symbol: Type %s @ %p\n", TypeName, Offset);
    }

    return OutputType(Physical, Module, TypeId, Offset, Flags, OutputPrefix);
}

HRESULT TypeOutputDumper::OutputType(
    BOOL Physical,
    ULONG64 Module,
    ULONG TypeId,
    ULONG64 Offset,
    ULONG Flags,
    PCSTR OutputPrefix
    )
{
    HRESULT     hr = S_FALSE;
    CHAR        TypeName[MAX_NAME];
    PSTR        pNextLine;
    PCHAR       pEOL;
    CHAR        EOLChar;
    PSTR        pTypeLine, pFieldOffset, pField, pFieldValue, pFieldValueInLine;
    ULONG64     FieldOffset;
    CHAR        Field[MAX_NAME];
    ULONG       FieldLen;
    DEBUG_VALUE FieldValue;
    CHAR        FieldTypeName[MAX_NAME];
    ULONG       FieldTypeId;
    ULONG       Remainder;

    if (OutCtl == NULL)
    {
        DbgPrint("TypeOutputDumper::OutputType: OutCtl is NULL.\n");
        return hr;
    }

    if (Client == NULL)
    {
        DbgPrint("TypeOutputDumper::OutputType: Client is NULL.\n");
        return hr;
    }

    if (Symbols == NULL)
    {
        DbgPrint("TypeOutputDumper::OutputType: Symbols is NULL.\n");
        return hr;
    }

    if ((hr = Symbols->GetTypeName(Module, TypeId,
                                   TypeName, sizeof(TypeName),
                                   NULL)) != S_OK)
    {
        OutCtl->OutVerb(" GetTypeName(%p, %lx) returned HRESULT 0x%lx.\n",
                        Module, TypeId, hr);
        return hr;
    }

    // Read type information if we don't already have it cached
    if (Offset != Last.Offset ||
        Module != Last.Module ||
        TypeId != Last.TypeId ||
        Flags != Last.Flags)
    {
        OutputState OutState(Client);

        if ((hr = OutState.Setup(0, this)) != S_OK)
        {
            OutCtl->OutVerb(" Callback Setup returned HRESULT 0x%lx.\n", hr);
            return hr;
        }

        DiscardOutput();

        if ((hr = OutState.OutputType(Physical, Offset, Module, TypeId, Flags)) != S_OK)
        {
            OutCtl->OutVerb(" Type Output returned HRESULT 0x%lx.\n", hr);
            return hr;
        }
    }

    pNextLine = Buffer;

    if (pNextLine == NULL)
    {
        return S_OK;
    }

    // The data won't change between instances of
    // this type so this is a sufficient cache id.
    Last.Offset = Offset;
    Last.Module = Module;
    Last.TypeId = TypeId;
    Last.Flags = Flags;

    if (OutputPrefix == NULL) OutputPrefix = "";

    // Check if this type is a pointer
    FieldLen = strlen(TypeName) - 1;
    if (TypeName[FieldLen] == '*')
    {
        // Remove trailing *
        TypeName[FieldLen] = '\0';

        pTypeLine = pNextLine;

        pEOL = pTypeLine;

        // Find end of this line
        while ((*pEOL != '\0') &&
               (*pEOL != '\n') &&
               (*pEOL != '\r') &&
               (*pEOL != '\f'))
        {
            pEOL++;
        }

        // Save EOL char and then zero-terminate line
        EOLChar = *pEOL;
        *pEOL = '\0';

        // Output TYPE @ Real Address
        OutCtl->Output("%s%s @ %s\n", OutputPrefix, TypeName, pTypeLine);

        // Restore EOL
        *pEOL = EOLChar;

        if (EOLChar == '\0') return S_OK;

        // Look for begining of next line
        do
        {
            pNextLine++;
        } while ((*pNextLine == '\n') ||
                 (*pNextLine == '\r') ||
                 (*pNextLine == '\f'));
    }

    EOLChar = '\0';

    while (*pNextLine != '\0')
    {
        // Restore buffer string
        if (EOLChar != '\0')
        {
            *pEOL = EOLChar;
            EOLChar = '\0';
        }

        hr = OutCtl->GetInterrupt();
//        DbgPrint("GetInt returned %s.\n", pszHRESULT(hr));
        if (hr == S_OK)
        {
            OutCtl->SetInterrupt(DEBUG_INTERRUPT_PASSIVE);
            break;
        }

        pTypeLine = pNextLine;

        // Find end of this line
        pEOL = pTypeLine;
        if (Flags & DEBUG_OUTTYPE_COMPACT_OUTPUT)
        {
            while ((*pEOL != '\0') &&
                   (*pEOL != '\n') &&
                   ((pEOL[0] != ' ') ||
                    (pEOL[1] != ' ')))
            {
                pEOL++;
            }
        }
        else
        {
            while ((*pEOL != '\0') &&
                   (*pEOL != '\n') &&
                   (*pEOL != '\r') &&
                   (*pEOL != '\f'))
            {
                pEOL++;
            }
        }

        pNextLine = pEOL;

        EOLChar = *pEOL;

        if (EOLChar != '\0')
        {
            *pEOL = '\0';

            // Look for begining of next line
            if (Flags & DEBUG_OUTTYPE_COMPACT_OUTPUT)
            {
                do
                {
                    pNextLine++;
                } while ((*pNextLine == '\n') ||
                         ((pNextLine[0] == ' ') &&
                          ((pNextLine[1] == ' ') ||
                           (pNextLine[1] == '\n'))));
            }
            else
            {
                do
                {
                    pNextLine++;
                } while ((*pNextLine == '\n') ||
                         (*pNextLine == '\r') ||
                         (*pNextLine == '\f'));
            }
        }

        pFieldOffset = pTypeLine;
        Remainder = 0;
        FieldOffset = 0;

        while (isspace(*pFieldOffset)) pFieldOffset++;

        if (!(Flags & DEBUG_OUTTYPE_NO_OFFSET))
        {
            if (*pFieldOffset == '+')
            {
                DEBUG_VALUE TypeFieldOffset;

                pFieldOffset++;

                hr = Evaluate(Client, pFieldOffset, DEBUG_VALUE_INT64, 0, &TypeFieldOffset, &Remainder);

                if (hr != S_OK)
                {
                    OutCtl->OutVerb(" Evaluate couldn't evauluate field offset in\n"
                                    "%s%s\n", OutputPrefix, pTypeLine);
                    continue;
                }

                FieldOffset = Offset + TypeFieldOffset.I64;
            }
            else if (*pFieldOffset == '=')
            {
                DEBUG_VALUE StaticFieldOffset;

                pFieldOffset++;

                hr = Evaluate(Client, pFieldOffset, DEBUG_VALUE_INT64, 0, &StaticFieldOffset, &Remainder);

                if (hr != S_OK)
                {
                    OutCtl->OutVerb(" Evaluate couldn't evauluate field offset in\n"
                                    "%s%s\n", OutputPrefix, pTypeLine);
                    continue;
                }

                FieldOffset = StaticFieldOffset.I64;
            }
        }

        // HRESULT indicating line parsing failure
        hr = S_FALSE;

        pField = pFieldOffset + Remainder;

        while (*pField != '\0' && isspace(*pField))
        {
            pField++;
        }

        if (!iscsymf(*pField))
        {
            OutCtl->OutWarn(" Couldn't find field in:\n");
            OutCtl->Output("%s%s\n", OutputPrefix, pTypeLine);
            continue;
        }

        pFieldValue = pField;

        while (iscsym(*pFieldValue)) pFieldValue++;

        // Check for scoped field name: Type::Field
        if (pFieldValue[0] == ':' &&
            pFieldValue[1] == ':' &&
            iscsymf(pFieldValue[2]))
        {
            pFieldValue += 3;
            while (iscsym(*pFieldValue)) pFieldValue++;
        }

        if (!isspace(*pFieldValue))
        {
            OutCtl->OutWarn(" Couldn't find field value in:\n");
            OutCtl->Output("%s%s\n", OutputPrefix, pTypeLine);
            continue;
        }

        FieldLen = (ULONG)(pFieldValue - pField);
        if (FieldLen >= sizeof(Field)/sizeof(Field[0]))
        {
            OutCtl->OutWarn(" Field too long in:\n");
            OutCtl->Output("%s%s\n", OutputPrefix, pTypeLine);
            continue;
        }
        strncpy(Field, pField, FieldLen);
        Field[FieldLen] = '\0';

        if (MarkUse != IGNORE_MARKS)
        {
            ULONG   Mark;
            BOOL    Marked = FALSE;

            for (Mark = 0; Mark < Marks; Mark++)
            {
                if (FieldLen == MarkList[Mark].Len)
                {
                    // For exclusion, entire Field must match.
                    // For inclusion, only top level field must match.
                    Marked = (MarkUse == EXCLUDE_MARKED) ?
                        (strcmp(Field, MarkList[Mark].Field) == 0) :
                        (strncmp(Field, MarkList[Mark].Field, FieldLen) == 0);
                    if (Marked) break;
                }
            }

            // EXCULDE_MARKED - may not be marked
            // INCLUDE_MARKED - must be marked
            if ((MarkUse == EXCLUDE_MARKED) ? Marked : !Marked)
            {
                hr = S_OK;
                continue;
            }
        }

        while (*pFieldValue != '\0' &&
               !(iscsym(*pFieldValue) || *pFieldValue == '('))
        {
            pFieldValue++;
        }

        pFieldValueInLine = pFieldValue;

        if (*pFieldValue == '\0')
        {
            OutCtl->OutWarn(" No value found in:\n");
            OutCtl->OutVerb("  (checking for complex type)\n");

            TypeOutputHelper    FieldTypeReader(Client);
            if ((hr = FieldTypeReader.FindFieldType(Module, TypeId, pTypeLine,
                                                    FieldTypeName,
                                                    sizeof(FieldTypeName))) != S_OK)
            {
                OutCtl->OutErr(" No value/complex type found in:\n", pTypeLine);
                OutCtl->Output("%s%s%c", OutputPrefix, pTypeLine, EOLChar);
                continue;
            }

            pFieldValue = FieldTypeName;
        }

        // We have a full line
        hr = S_OK;

        if (iscsymf(*pFieldValue))
        {
            // If the debugger recognizes this field as a basic type
            // it will output the type and the values together.
            // We just want to get the type name.
            if (pFieldValue != FieldTypeName)
            {
                PSTR pFieldTypeName = FieldTypeName;
                do
                {
                    *pFieldTypeName++ = *pFieldValue++;
                }
                while (iscsym(*pFieldValue) &&
                       pFieldTypeName < &FieldTypeName[sizeof(FieldTypeName)/sizeof(FieldTypeName[0])-1]);
                *pFieldTypeName = '\0';

                // Check for whitespace at the end of the field name
                if (*pFieldValue != '\0' && !isspace(*pFieldValue))
                {
                    // If not, try using entire field value as type name.
                    pFieldValue -= pFieldTypeName - FieldTypeName;
                }
                else
                {
                    // If there is, ignore remaining field value (if any)
                    pFieldValue = FieldTypeName;
                }
            }

            if ((hr = Symbols->GetTypeId(Module, pFieldValue, &FieldTypeId)) == S_OK)
            {
                DbgPrint("Dumping SubType %s (%lx)\n", pFieldValue, FieldTypeId);
                CHAR    SubPrefix[40] = "";

                // 
                if (FieldOffset == 0 &&
                    Offset != 0 &&
                    pFieldOffset == pField)
                {
                    if (!(Flags & DEBUG_OUTTYPE_NO_OFFSET))
                    {
                        OutCtl->OutWarn("Field offset not available while attempting sub-type dump.\n");
                    }

                    ULONG   FieldOffset32;
                    if ((hr = Symbols->GetFieldOffset(Module, TypeId, Field, &FieldOffset32)) == S_OK)
                    {
                        FieldOffset = Offset + FieldOffset32;
                    }
                }

                if (hr == S_OK)
                {
                    // Is this a primitive GDI type
                    if (IsKnownType(Client, Module, FieldTypeId))
                    {
                        *pFieldValueInLine = '\0';
                        // Output the type line w/o field type and newline
                        OutCtl->Output("%s%s", OutputPrefix, pTypeLine);
                        OutputKnownType(Client, OutCtl, Module, FieldTypeId, FieldOffset, Flags);
                        OutCtl->Output("%c", EOLChar);
                    }
                    else
                    {
                        // Output the type line
                        OutCtl->Output("%s%s%c", OutputPrefix, pTypeLine, EOLChar);

                        strcpy(SubPrefix, OutputPrefix);
                        if (!(Flags & (DEBUG_OUTTYPE_NO_INDENT | DEBUG_OUTTYPE_COMPACT_OUTPUT)))
                        {
                            strcat(SubPrefix, "   ");
                        }

                        TypeOutputDumper    SubTypeDumper(Client, OutCtl);
                        BOOL                SubDump = TRUE;

                        if (MarkUse != IGNORE_MARKS)
                        {
                            ULONG   Mark;

                            SubTypeDumper.MarkUse = MarkUse;

                            for (Mark = 0; Mark < Marks; Mark++)
                            {
                                if (FieldLen == MarkList[Mark].Len &&
                                    strncmp(Field, MarkList[Mark].Field, FieldLen) == 0)
                                {
                                    if (MarkUse == EXCLUDE_MARKED)
                                    {
                                        // Exact matches on exclusion shouldn't be here.
                                        if (MarkList[Mark].Field[FieldLen] == '\0')
                                        {
                                            DbgPrint("This field should completely excluded.\n");
                                            DbgBreakPoint();
                                        }

                                        // MarkUse = EXCLUDE_MARKED
                                        if (MarkList[Mark].Field[FieldLen+1] == '*')
                                        {
                                            // All subfields are marked; so,
                                            // no subfields are to be included.
                                            SubDump = FALSE;
                                            break;
                                        }
                                        else if (MarkList[Mark].Field[FieldLen+1] == '\0')
                                        {
                                            // No subfields are marked; so,
                                            // all subfields are to be included.
                                            SubTypeDumper.MarkUse = IGNORE_MARKS;
                                        }
                                        else
                                        {
                                            SubTypeDumper.MarkUse = EXCLUDE_MARKED;
                                            SubTypeDumper.MarkField(MarkList[Mark].Field+FieldLen+1);
                                        }
                                    }
                                    else
                                    {
                                        // MarkUse = INCLUDE_MARKED
                                        if (MarkList[Mark].Field[FieldLen] == '\0' ||
                                            MarkList[Mark].Field[FieldLen+1] == '*')
                                        {
                                            // We have an exact match or all
                                            // subfields are marked; so, all
                                            // subfields are to be included.
                                            SubDump = TRUE;
                                            SubTypeDumper.MarkUse = IGNORE_MARKS;
                                            break;
                                        }
                                        else if (MarkList[Mark].Field[FieldLen+1] == '\0')
                                        {
                                            // No subfields are to be included.
                                            SubDump = FALSE;
                                        }
                                        else
                                        {
                                            SubDump = TRUE;
                                            SubTypeDumper.MarkField(MarkList[Mark].Field+FieldLen+1);
                                        }
                                    }
                                }
                            }
                        }

                        if (SubDump)
                        {
                            hr = SubTypeDumper.OutputType(Physical,
                                                          Module,
                                                          FieldTypeId,
                                                          FieldOffset,
                                                          Flags,
                                                          SubPrefix);
                        }
                    }
                }

                if (hr != S_OK)
                {
                    OutCtl->OutWarn(" SubType dump returned HRESULT 0x%lx.\n",
                                    hr);
                }
            }
            else
            {
                if (strcmp(pFieldValue, "__unnamed") != 0)
                {
                    OutCtl->OutErr(" Couldn't identify type '%s' in:\n",
                                   pFieldValue);
                }
                OutCtl->Output("%s%s%c", OutputPrefix, pTypeLine, EOLChar);
            }

            // Even if the sub type dump failed we
            // can continue the rest of this type.
            hr = S_OK;
        }
        else
        {
            // Use %s so there is no interpretation on pTypeLine.
            OutCtl->Output("%s%s", OutputPrefix, pTypeLine);

            if ((hr = Evaluate(Client, pFieldValue,
                               DEBUG_VALUE_INT64, 10,
                               &FieldValue, NULL)) == S_OK)
            {
                // Send this field through the FlagEnum search
                OutputTypeFieldValue(OutCtl,
                                     TypeName, Field, &FieldValue,
                                     Client,
                                     Flags & DEBUG_OUTTYPE_COMPACT_OUTPUT);
            }
            else
            {
                OutCtl->OutWarn(" Evaluate(%s) returned HRESULT 0x%lx.\n",
                                pFieldValue, hr);
                hr = S_OK;
            }

            // Flush output line
            OutCtl->Output("%c", EOLChar);
        }
    }

    if (EOLChar != '\0')
    {
        *pEOL = EOLChar;
    }

    return hr;
}


HRESULT
TypeOutputDumper::SelectMarks(
    ULONG Set
    )
{
    if (Set >= lengthof(MarkSet)) return E_INVALIDARG;

    if (Set != CurrentMarkSet)
    {
        MarkSet[CurrentMarkSet].Use = MarkUse;
        MarkSet[CurrentMarkSet].List = MarkList;
        MarkSet[CurrentMarkSet].Marks = Marks;
        MarkSet[CurrentMarkSet].ListLen = MarkListLen;

        CurrentMarkSet = Set;
        MarkUse = MarkSet[CurrentMarkSet].Use;
        MarkList = MarkSet[CurrentMarkSet].List;
        Marks = MarkSet[CurrentMarkSet].Marks;
        MarkListLen = MarkSet[CurrentMarkSet].ListLen;
    }

    return S_OK;
}


HRESULT
TypeOutputDumper::MarkField(
    PCSTR Field
    )
{
    if (Field == NULL) return E_INVALIDARG;

    ULONG FieldLen = strlen(Field);

    if (Marks == MarkListLen)
    {
        FieldSpec  *NewList;
        SIZE_T      NewListSize;

        if (hHeap == NULL)
        {
            hHeap = GetProcessHeap();
            if (hHeap == NULL) return S_FALSE;
        }

        // New entry we need plus some extra space
        NewListSize = (MarkListLen+8)*sizeof(FieldSpec);

        NewList = (FieldSpec *) ((MarkList == NULL) ?
                            HeapAlloc(hHeap, 0, NewListSize):
                            HeapReAlloc(hHeap, 0, MarkList, NewListSize));

        if (NewList == NULL)
        {
            DbgPrint("Buffer alloc failed.\n");
            return E_OUTOFMEMORY;
        }

        // How much was really allocated?
        NewListSize = HeapSize(hHeap, 0, NewList);

        // Update List data
        MarkList = NewList;
        MarkListLen = NewListSize / sizeof(FieldSpec);
    }


    // Add new entry
    PCSTR NextField = strchr(Field, '.');

    MarkList[Marks].Len = (NextField != NULL) ?
                            NextField - Field :
                            strlen(Field);

    MarkList[Marks].Field = Field;

    Marks++;

    return S_OK;
}


HRESULT
TypeOutputDumper::MarkFields(
    PCSTR *FieldList,
    ULONG Count
    )
{
    if (FieldList == NULL) return E_INVALIDARG;

    HRESULT hr = S_OK;
    PCSTR   Field;

    while (hr == S_OK &&
           Count &&
           *FieldList != NULL)
    {
        hr = MarkField(*FieldList);
        FieldList++;
        Count--;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\remote.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    remote.cxx

Abstract:

    This file contains the thunk routines to make
    wdbgext api calls from a remote client.

Author:

    Jason Hartman (JasonHa) 2000-10-27

Environment:

    User Mode

--*/

#include "precomp.hxx"



VOID
RemoteWarn(PCSTR pszAPI)
{
    ExtApiClass ExtApi(NULL);
    if (ExtApi.Client != NULL)
    {
        ExtWarn("Extension using WinDbg Extension API, %s, which isn't remote compatible.\n", pszAPI);
    }
}


VOID
WDBGAPIV
RemoteThunkOutputRoutine(
    PCSTR lpFormat,
    ...
    )
{
    ExtApiClass ExtApi(NULL);
//    RemoteWarn("dprintf");
    va_list Args;
    
    if (g_pExtControl == NULL)
    {
        DbgPrint("g_pExtControl is NULL.\n");
        return;
    }

    va_start(Args, lpFormat);
    g_pExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, lpFormat, Args);
    va_end(Args);
}


ULONG64
WDBGAPI
RemoteThunkGetExpressionRoutine(
    PCSTR lpExpression
    )
{
    ExtApiClass ExtApi(NULL);
//    RemoteWarn("GetExpression");
    DEBUG_VALUE Value;

    if (g_pExtControl != NULL)
    {
        if (g_pExtControl->Evaluate(lpExpression, DEBUG_VALUE_INT64, &Value, NULL) == S_OK)
        {
            return Value.I64;
        }
    }

    return 0;
}

//PWINDBG_GET_SYMBOL64
VOID
WDBGAPI
RemoteThunkGetSymbolRoutine(
    ULONG64    offset,
    PCHAR      pchBuffer,
    PULONG64   pDisplacement
    )
{
    RemoteWarn("GetSymbol");
    if (pchBuffer != NULL) ((PSTR)pchBuffer)[0] = '\0';
    if (pDisplacement != NULL) *pDisplacement = 0;
    return;
}


ULONG
WDBGAPI
RemoteThunkDisasmRoutine(
    ULONG64   *lpOffset,
    PCSTR      lpBuffer,
    ULONG      fShowEffectiveAddress
    )
{
    RemoteWarn("Disasm");
    return FALSE;
}


ULONG
WDBGAPI
RemoteThunkCheckControlCRoutine(
    VOID
    )
{
    ExtApiClass ExtApi(NULL);
    RemoteWarn("CheckControlC");

    return (g_pExtControl != NULL) ?
        (g_pExtControl->GetInterrupt() == S_OK) :
        FALSE;
}


ULONG
WDBGAPI
RemoteThunkReadProcessMemoryRoutine(
    ULONG64    offset,
    PVOID      lpBuffer,
    ULONG      cb,
    PULONG     lpcbBytesRead
    )
{
    RemoteWarn("ReadMemory");
    if (lpBuffer != NULL) RtlZeroMemory(lpBuffer, cb);
    if (lpcbBytesRead != NULL) *lpcbBytesRead = 0;
    return FALSE;
}


ULONG
WDBGAPI
RemoteThunkWriteProcessMemoryRoutine(
    ULONG64    offset,
    LPCVOID    lpBuffer,
    ULONG      cb,
    PULONG     lpcbBytesWritten
    )
{
    RemoteWarn("WriteMemory");
    if (lpcbBytesWritten != NULL) *lpcbBytesWritten = 0;
    return FALSE;
}


ULONG
WDBGAPI
RemoteThunkGetThreadContextRoutine(
    ULONG       Processor,
    PCONTEXT    lpContext,
    ULONG       cbSizeOfContext
    )
{
    RemoteWarn("GetContext");
    if (lpContext != NULL) RtlZeroMemory(lpContext, cbSizeOfContext);
    return FALSE;
}


ULONG
WDBGAPI
RemoteThunkSetThreadContextRoutine(
    ULONG       Processor,
    PCONTEXT    lpContext,
    ULONG       cbSizeOfContext
    )
{
    RemoteWarn("SetContext");
    return FALSE;
}


ULONG
WDBGAPI
RemoteThunkIoctlRoutine(
    USHORT   IoctlType,
    PVOID    lpvData,
    ULONG    cbSize
    )
{
    RemoteWarn("Ioctl");
    return 0;
}



ULONG
RemoteThunkStackTraceRoutine(
    ULONG64           FramePointer,
    ULONG64           StackPointer,
    ULONG64           ProgramCounter,
    PEXTSTACKTRACE64  StackFrames,
    ULONG             Frames
    )
{
    RemoteWarn("StackTrace");
    return 0;
}



void GetRemoteWindbgExtApis(
    PWINDBG_EXTENSION_APIS64 ExtensionApis
    )
{
    ExtensionApis->lpOutputRoutine = RemoteThunkOutputRoutine;
    ExtensionApis->lpGetExpressionRoutine = RemoteThunkGetExpressionRoutine;
    ExtensionApis->lpGetSymbolRoutine = RemoteThunkGetSymbolRoutine;
    ExtensionApis->lpDisasmRoutine = RemoteThunkDisasmRoutine;
    ExtensionApis->lpCheckControlCRoutine = RemoteThunkCheckControlCRoutine;
    ExtensionApis->lpReadProcessMemoryRoutine = RemoteThunkReadProcessMemoryRoutine;
    ExtensionApis->lpWriteProcessMemoryRoutine = RemoteThunkWriteProcessMemoryRoutine;
    ExtensionApis->lpGetThreadContextRoutine = RemoteThunkGetThreadContextRoutine;
    ExtensionApis->lpSetThreadContextRoutine = RemoteThunkSetThreadContextRoutine;
    ExtensionApis->lpIoctlRoutine = RemoteThunkIoctlRoutine;
    ExtensionApis->lpStackTraceRoutine = RemoteThunkStackTraceRoutine;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\region.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    region.cxx

Abstract:

    This file contains the routines to debug regions.

Author:

    Jason Hartman (JasonHa) 2001-04-30

Environment:

    User Mode

--*/

#include "precomp.hxx"


/******************************Public*Routine******************************\
* DECLARE_API( dr  )
*
* Debugger extension to dump a region
*
*  21-Feb-1995    -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DECLARE_API( dr  )
{
    OutputControl   OutCtl(Client);
    OutCtl.Output("Obsolete: Use 'region hrgn|prgn'.\n");
    return S_OK;
}

/******************************Public*Routine******************************\
* DECLARE_API( cr  )
*
* Debugger extension to check a region
*
*  21-Feb-1995    -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DECLARE_API( cr  )
{
    OutputControl   OutCtl(Client);
    OutCtl.Output("Obsolete: Use 'region -c hrgn|prgn'\n");
    return S_OK;
}


/******************************Public*Routine******************************\
* DECLARE_API( region  )
*
* Debugger extension to dump and validate a region
*
*  22-May-2000    -by- Jason Hartman [jasonha]
*                   Converted from old dr & cr
*
\**************************************************************************/

DECLARE_API( region  )
{
    ULONG64 RgnAddr;
    ULONG   error;
    ULONG   Flags = 0;

    #define REGION_CSCANS       0
    #define REGION_SCAN_ADDRESS 1
    #define REGION_SCAN_TAIL    2
    #define REGION_SIZEOBJ      3

    #define NUM_REGION_BASEOBJ_FIELDS   3

    FIELD_INFO RegionFields[] = {
        { DbgStr("cScans"),         DbgStr("cScans           :"), 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},    // REGION_CSCANS
        { DbgStr("scan"),           DbgStr("scan <- pscnHead :"), 0, DBG_DUMP_FIELD_RETURN_ADDRESS | DBG_DUMP_FIELD_FULL_NAME, 0, AddressPrintCallback},    // REGION_SCAN_ADDRESS
        { DbgStr("pscnTail"),       DbgStr("pscnTail         :"), 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},    // REGION_SCAN_TAIL
        { DbgStr("sizeObj"),        DbgStr("sizeObj          :"), 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},    // REGION_SIZEOBJ
        { DbgStr("sizeRgn"),        DbgStr("sizeRgn          :"), 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("cRefs"),          DbgStr("cRefs            :"), 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("rcl"),            DbgStr("rcl              :"), 0, DBG_DUMP_FIELD_RETURN_ADDRESS | DBG_DUMP_FIELD_FULL_NAME, 0, RECTLCallback},
        { DbgStr("hHmgr"),          DbgStr("hHmgr            :"), 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("cExclusiveLock"), DbgStr("cExclusiveLock   :"), 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
        { DbgStr("Tid"),            DbgStr("Tid              :"), 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL},
    };
    SYM_DUMP_PARAM RegionSym = {
       sizeof (SYM_DUMP_PARAM), DbgStr(GDIType(REGION)), DBG_DUMP_COMPACT_OUT, 0/*RgnAddr*/,
       NULL, &RegionSym, NewlineCallback, sizeof(RegionFields)/sizeof(RegionFields[0]), RegionFields
    };
    PrepareCallbacks(TRUE);

    INIT_API();

    PARSE_POINTER(region_help);

    if (ntok > 1)
    {
      if (parse_iFindSwitch(tokens, ntok, 'c')!=-1)
      {
          Flags |= SCAN_DUMPER_NO_PRINT;
      }
      else if (parse_iFindSwitch(tokens, ntok, 'f')!=-1)
      {
          Flags |= SCAN_DUMPER_FORCE;
      }

      if (parse_iFindSwitch(tokens, ntok, 'r')!=-1)
      {
          Flags |= SCAN_DUMPER_FROM_TAIL;
      }
    }

    // get pointer to object from handle or use param as pointer
    if ((GetObjectAddress(Client,arg,&RgnAddr,RGN_TYPE,TRUE,TRUE) != S_OK) ||
        (RgnAddr == 0))
    {
        ULONG64 ObjHandle;
        ULONG64 RgnAddrFromHmgr;

        RgnAddr = arg;

        if (error = GetFieldValue(RgnAddr, GDIType(REGION), "hHmgr", ObjHandle))
        {
            ExtErr("Unable to get contents of REGION::hHmgr\n");
            ExtErr("  (Ioctl returned %s)\n", pszWinDbgError(error));
            ExtErr(" %#p is neither an HRGN nor valid REGION address\n", arg);
            EXIT_API(S_OK);
        }

        if (!ObjHandle)
        {
            ExtOut("\tREGION is reserved for system use (no handle manger entry).\n");
            RegionSym.nFields -= NUM_REGION_BASEOBJ_FIELDS;
        }
        else if (GetObjectAddress(Client,ObjHandle,&RgnAddrFromHmgr,
                                  RGN_TYPE,TRUE,FALSE) == S_OK &&
                 RgnAddrFromHmgr != RgnAddr)
        {
            ExtOut("\tNote: REGION may not be valid.\n\t      It does not have a valid handle manager entry.\n");
        }
    }

    ExtOut("REGION @ %#p\n  ", RgnAddr);

    RegionSym.addr = RgnAddr;
    error = Ioctl( IG_DUMP_SYMBOL_INFO, &RegionSym, RegionSym.size );

    if (error)
    {
        ExtErr("Unable to get contents of REGION\n");
        ExtErr("  (Ioctl returned %s)\n", pszWinDbgError(error));
    }
    else
    {
        ScanDumper  Dumper(RegionFields[REGION_SCAN_ADDRESS].address,
                           RegionFields[REGION_SCAN_TAIL].address,
                           (ULONG)RegionFields[REGION_CSCANS].address,
                           RegionFields[REGION_SCAN_ADDRESS].address,
                           RgnAddr+RegionFields[REGION_SIZEOBJ].address,
                           Flags
                           );
        BOOL        Valid;

        if ((Flags & SCAN_DUMPER_FROM_TAIL) != 0 && !Dumper.Reverse)
        {
            // We rquested a reverse dump, but Dumper wouldn't allow it.
            EXIT_API(S_OK);
        }

        Valid = Dumper.DumpScans((ULONG)RegionFields[REGION_CSCANS].address);

        if (Dumper.Reverse)
        {
            if (Dumper.ScanAddr != RegionFields[REGION_SCAN_ADDRESS].address)
            {
                ExtOut(" * Final ScanAddr (%#p) is not at head address (%#p)\n",
                       Dumper.ScanAddr, RegionFields[REGION_SCAN_ADDRESS].address);
                Valid = FALSE;
            }
        }
        else
        {
            if (Dumper.ScanAddr != RegionFields[REGION_SCAN_TAIL].address)
            {
                ExtOut(" * Final ScanAddr (%#p) is not at tail address (%#p)\n",
                       Dumper.ScanAddr, RegionFields[REGION_SCAN_TAIL].address);
                Valid = FALSE;
            }
        }

        if (Valid)
        {
            ExtOut("  Region is valid.\n");
        }
        else
        {
            ExtOut("  Region is NOT valid.\n");
        }
    }

    EXIT_API(S_OK);

region_help:
  ExtOut("Usage: region [-?cfr] hrgn|prgn\n");
  ExtOut(" dumps/validates a region\n");
  ExtOut("  c - doesn't print scans; validation only\n");
  ExtOut("  f - continue printing even if an error is found\n");
  ExtOut("  r - read scans in reverse order\n");
  EXIT_API(S_OK);
}


/**************************************************************************\
 *
\**************************************************************************/

BOOL bStrInStr(CHAR *pchTrg, CHAR *pchSrc)
{
    BOOL bRes  = 0;
    int c = strlen(pchSrc);

//CHECKLOOP umm? This could be difficult to detect
    while (TRUE)
    {
    // find the first character

        pchTrg = strchr(pchTrg,*pchSrc);

    // didn't find it?, fail!

        if (pchTrg == NULL)
            return(FALSE);

    // did we find the string? succeed

        if (strncmp(pchTrg,pchSrc,c) == 0)
            return(TRUE);

    // go get the next one.

        pchTrg++;
    }
}


/******************************Public*Routine******************************\
* rgnlog
*
\**************************************************************************/

#define MAXSEARCH  4

DECLARE_API( rgnlog )
{
#if 1
    HRESULT     hr = S_OK;
    BOOL        BadArg = FALSE;
    ULONG       RemainingArgIndex;
    DEBUG_VALUE DumpCount = { 0, DEBUG_VALUE_INVALID };
    CHAR        EmptySearchString[] = "";
    PSTR        SearchStringList = EmptySearchString;
    PSTR        SearchString = SearchStringList;

    OutputControl   OutCtl(Client);

    while (!BadArg && hr == S_OK)
    {
        while (isspace(*args)) args++;

        if (*args == '-')
        {
            args++;

            if (*args == '\0' || isspace(*args))
            {
                BadArg = TRUE;
            }
            else if (DumpCount.Type == DEBUG_VALUE_INVALID &&
                     args[0] == '1' && (args[1] == '\0' || isspace(args[1])))
            {
                DumpCount.I32 = -1;
                DumpCount.Type = DEBUG_VALUE_INT32;
            }
            else
            {
                while (*args != '\0' && !isspace(*args))
                {
                    switch (*args)
                    {
                        case '?':
                        default:
                            BadArg = TRUE;
                            break;
                    }

                    if (BadArg) break;
                    args++;
                }
            }
        }
        else
        {
            if (DumpCount.Type == DEBUG_VALUE_INVALID)
            {
                if (Evaluate(Client, args, DEBUG_VALUE_INT32, EVALUATE_DEFAULT_RADIX,
                             &DumpCount, &RemainingArgIndex, NULL, EVALUATE_COMPACT_EXPR) != S_OK ||
                    DumpCount.I32 == 0)
                {
                    BadArg = TRUE;
                }
                else
                {
                    args += RemainingArgIndex;
                }
            }
            else
            {
                if (SearchStringList == EmptySearchString)
                {
                    SearchStringList = (PSTR)HeapAlloc(GetProcessHeap(), 0,
                                                       sizeof(*SearchStringList)*(strlen(args)+2));

                    if (SearchStringList == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        SearchString = SearchStringList;
                        *SearchString = '\0';
                    }
                }

                if (hr == S_OK)
                {
                    if (*args == '`' || *args == '\'' || *args == '\"')
                    {
                        CHAR    StringEnd = *args;

                        if (args[1] == StringEnd || args[1] == '\0')
                        {
                            BadArg = TRUE;
                        }
                        else
                        {
                            while (*args != StringEnd && *args != '\0')
                            {
                                *SearchString++ = *args++;
                            }

                            if (*args == StringEnd) args++;

                            if (!isspace(*args) || *args != '\0')
                            {
                                OutCtl.Output("Malformed Search String at '%s'.\n",
                                              args);
                                BadArg = TRUE;
                            }
                            else
                            {
                                *SearchString++ = '\0';
                            }
                        }
                    }
                    else
                    {
                        while (!isspace(*args) && *args != '\0')
                        {
                            *SearchString++ = *args++;
                        }

                        *SearchString++ = '\0';
                    }
                }
            }
        }
    }

    if (hr == S_OK)
    {
        if (BadArg)
        {
            if (*args == '?')  OutCtl.Output("rgnlog - dump/search rgnlog from checked builds.\n");
            OutCtl.Output("Usage: rgnlog [-?] <Entries> [<Search Strings>]\n"
                          "\n"
                          "   Entries - Number of tailing entries to dump/search\n"
                          "   Search Strings - Dump only logs contain one of strings specified\n");
        }
        else
        {
            // Mark end of search string list with a NULL string.
            *SearchString = '\0';

            LONG    iLog, iPass;
            ULONG   LogArraySize, LogLength, LogEntrySize;
            CHAR    SymName[80];

            sprintf(SymName, "%s!iLog", GDIKM_Module.Name);
            hr = ReadSymbolData(Client, SymName, &iLog, sizeof(iLog), NULL);
            if (hr != S_OK) OutCtl.OutErr("Unable to get contents of %s\n", SymName);

            if (hr == S_OK)
            {
                sprintf(SymName, "%s!iPass", GDIKM_Module.Name);
                hr = ReadSymbolData(Client, SymName, &iPass, sizeof(iPass), NULL);
                if (hr != S_OK) OutCtl.OutErr("Unable to get contents of %s\n", SymName);
            }

            if (hr == S_OK)
            {
                sprintf(SymName, "%s!argnlog", GDIKM_Module.Name);
                hr = GetArrayDimensions(Client, SymName, NULL,
                                        &LogArraySize, &LogLength, &LogEntrySize);
                if (hr != S_OK) OutCtl.OutErr("Unable to get dimensions of %s\n", SymName);
            }

            if (hr == S_OK)
            {
            }

            if (hr == S_OK)
            {
                if (*SearchStringList != '\0')
                {
                    OutCtl.Output("Searching last %ld entries for:\n",
                                  DumpCount.I32);

                    for (SearchString = SearchStringList;
                         *SearchString != '\0';
                         *SearchString += strlen(SearchString)+1)
                    {
                        OutCtl.Output("  \"%s\"\n", SearchString);
                    }
                }
                else
                {
                    OutCtl.Output("Dumping last %ld entries.\n",
                                  DumpCount.I32);
                }
                // To Do
            }
        }
    }

    if (SearchStringList != EmptySearchString)
    {
        HeapFree(GetProcessHeap(), 0, SearchStringList);
    }

    return hr;
#else
    dprintf("Extension 'rgnlog' is not converted.\n");
#if ENABLE_OLD_EXTS   // DOES NOT SUPPORT API64
    LONG      cDump;
    LONG      iCurrent;
    RGNLOGENTRY rl;
    RGNLOGENTRY *prl;
    LONG      gml;          // gMaxRgnLog
    int       i, j;
    PVOID     pv;
    CHAR      achTmp[30];
    CHAR      achBuf[256];
    PCHAR     pchS[MAXSEARCH];
    int       cSearch;
    BOOL      bPrint;

    PARSE_ARGUMENTS(rgnlog_help);
    if(ntok<1) { goto rgnlog_help; }

    tok_pos = parse_FindNonSwitch(tokens, ntok);
    if(tok_pos==-1) { goto rgnlog_help; }
//check that this supports decimal
    cDump = (LONG)GetExpression(tokens[tok_pos]);
    if(cDump==0) { goto rgnlog_help; }

    cSearch = 0;
    while(cSearch<MAXSEARCH) {
      tok_pos = parse_FindNonSwitch(tokens, ntok, tok_pos+1);
      if(tok_pos==-1) {break;}
      pchS[cSearch]=tokens[tok_pos];
      cSearch++;
    }

    for (i = 0; i < cSearch; ++i)
        dprintf("search[%s]\n",pchS[i]);

// get some stuff

    GetAddress(pv, "&win32k!iLog");

    dprintf("&iLog = %lx\n",pv);

    if (pv == NULL)
    {
        dprintf("iCurrent was NULL\n");
        return;
    }
    move(iCurrent, pv);

    GetAddress(i,"&win32k!iPass");

    if (pv == NULL)
    {
        dprintf("iPass was NULL\n");
        return;
    }
    move(i,i);

    dprintf("--------------------------------------------------\n");
    dprintf("rgn log list, cDump = %ld, iCur = %ld, iPass = %ld\n", cDump,iCurrent,i);
    dprintf("%5s-%4s:%8s,%8s,(%8s),%8s,%8s,%4s\n",
           "TEB ","i","hrgn","prgn","return","arg1","arg2","arg3");
    dprintf("--------------------------------------------------\n");

// Dereference the handle via the engine's handle manager.

    GetAddress(prl, "win32k!argnlog");

    if (!prl)
    {
        dprintf("prl was NULL\n");
        return;
    }

    GetAddress(gml, "&win32k!gMaxRgnLog");

    if (!gml)
    {
        dprintf("gml was NULL\n");
        return;
    }
    move(gml,gml);

// set iCurrent to the first thing to dump

    if (cDump > gml)
        cDump = gml;

    if (cDump > iCurrent)
        iCurrent += gml;

    iCurrent -= cDump;

    dprintf("prl = %lx, gml = %ld, cDump = %ld, iCurrent = %ld\n",prl,gml,cDump,iCurrent);


//CHECKLOOP add exit/more support
    for (i = 0; i < cDump; ++i)
    {
        move(rl,&prl[iCurrent]);

        if (rl.pszOperation != NULL)
        {
            move2(achTmp,rl.pszOperation,30);
        }
        else
            achTmp[0] = 0;

        sprintf(achBuf,"%5lx-%4ld:%p,%p,(%8lx),%p, %p,%p, %s, %p, %p\n",
              (ULONG_PTR)rl.teb >> 12,iCurrent,rl.hrgn,rl.prgn,rl.lRes,rl.lParm1,
              rl.lParm2,rl.lParm3,achTmp,rl.pvCaller,rl.pvCallersCaller);

        bPrint = (cSearch == 0);

        for (j = 0; (j < cSearch) && !bPrint; ++j)
            bPrint |= bStrInStr(achBuf,pchS[j]);

        if (bPrint)
        {
            dprintf(achBuf);
        }

        if (++iCurrent >= gml)
            iCurrent = 0;

        if (CheckControlC())
            return;
    }
  return;
rgnlog_help:
  dprintf("\n rgnlog nnn [search1] [search2] [search3] [search4]\n");
  dprintf("\t nnn - dumps the last n entries of the rgn log\n");
  dprintf("\t search[n] - displays only entries containing one of n strings\n");
  dprintf("\t NOTE: only works on checked builds.  you must set bLogRgn at run time\n");
#endif  // DOES NOT SUPPORT API64
    EXIT_API(S_OK);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\verifier.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    verifier.cxx

Abstract:

    This file contains the verifier related routines
    for the kernel debugger extensions dll.

Author:

    Jason Hartman (JasonHa)

Environment:

    User Mode

--*/


#include "precomp.hxx"

// Pool tracking is always disabled for graphic drivers. (NTBUG:421768)
#define GRAPHICS_DRIVER_POOL_TRACKING_SUPPORTED 0


/******************************Public*Routine******************************\
* DECLARE_API( verifier )
*
* Dumps the stack backtraces in the tracked pool.  Only for checked Hydra.
*
\**************************************************************************/

CHAR szVSTATE[]              = "win32k!VSTATE";
#if GRAPHICS_DRIVER_POOL_TRACKING_SUPPORTED
CHAR szVERIFIERTRACKHDR[]    = "win32k!VERIFIERTRACKHDR";
#endif

const PSZ gpszVerifierFuncs[] = {
    "EngAllocMem           ",
    "EngFreeMem            ",
    "EngAllocUserMem       ",
    "EngFreeUserMem        ",
    "EngCreateBitmap       ",
    "EngCreateDeviceSurface",
    "EngCreateDeviceBitmap ",
    "EngCreatePalette      ",
    "EngCreateClip         ",
    "EngCreatePath         ",
    "EngCreateWnd          ",
    "EngCreateDriverObj    ",
    "BRUSHOBJ_pvAllocRbrush",
    "CLIPOBJ_ppoGetPath    ",
};

#define NUM_VER_FUNCS   (sizeof(gpszVerifierFuncs)/sizeof(gpszVerifierFuncs[0]))

DECLARE_API( verifier  )
{
    ULONG       error;
    ULONG64     offVState;

    #define GetVSTATEField(field,local)   \
        GetFieldValue(offVState, szVSTATE, field, local)
    
    // VSTATE fields
    FLONG       fl;
#if GRAPHICS_DRIVER_POOL_TRACKING_SUPPORTED
    ULONG64     pList;
#endif
    
#if GRAPHICS_DRIVER_POOL_TRACKING_SUPPORTED
    BOOL bDump = FALSE;
#endif
    BOOL bStats = FALSE;

    //
    // Parse arguments.
    //

    PARSE_ARGUMENTS(verifier_help);
    if(parse_iFindSwitch(tokens, ntok, 'h')!=-1) { goto verifier_help; }
#if GRAPHICS_DRIVER_POOL_TRACKING_SUPPORTED
    if(parse_iFindSwitch(tokens, ntok, 'd')!=-1) { bDump = TRUE; }
#endif
    if(parse_iFindSwitch(tokens, ntok, 's')!=-1) { bStats = TRUE; }

    //
    // Get global veriferier address (VSTATE gvs)
    //

    offVState = GetExpression(GDISymbol(gvs));
    if (! offVState)
    {
        ReloadSymbols(GDIModule());
        offVState = GetExpression(GDISymbol(gvs));

        if (! offVState)
        {
            dprintf(" GetExpression(\"%s\") returned 0.\n", GDISymbol(gvs));
            dprintf("  Please fix symbols and try again.\n");
            EXIT_API(S_OK);
        }
    }


    //
    // Always dump the verifier state.
    //

    dprintf("Global VSTATE (@ %#p)\n", offVState);

    if (error = (ULONG)InitTypeRead(offVState, win32k!VSTATE))
    {
        dprintf(" unable to get contents of verifier state\n");
        dprintf("  (InitTypeRead returned %s)\n", pszWinDbgError(error));
        EXIT_API(S_OK);
    }

    fl = (FLONG)ReadField(fl);
    dprintf("  fl                      = 0x%08lx\n", fl);
    if (fl = (FLONG)flPrintFlags(afdDVERIFIER, (ULONG64)fl))
    {
        dprintf("                              Unknown flags: 0x%08lx\n", fl);
    }
    dprintf("  bSystemStable           = %s\n"     , ReadField(bSystemStable) ? "TRUE" : "FALSE");
    dprintf("  ulRandomSeed            = 0x%08lx\n", (ULONG)ReadField(ulRandomSeed));
    dprintf("  ulFailureMask           = 0x%08lx\n", (ULONG)ReadField(ulFailureMask));
    dprintf("  ulDebugLevel            = %ld\n"    , (ULONG)ReadField(ulDebugLevel));
#if GRAPHICS_DRIVER_POOL_TRACKING_SUPPORTED
    dprintf("  hsemPoolTracker         = %#p\n"    , ReadField(hsemPoolTracker));
    pList = ReadField(lePoolTrackerHead.Flink);
    dprintf("  lePoolTrackerHead.Flink = %#p\n"    , pList);
    dprintf("  lePoolTrackerHead.Blink = %#p\n"    , ReadField(lePoolTrackerHead.Blink));
#endif

    //
    // Optionally dump the statistics for each function hooked by verifier.
    //

    if (bStats)
    {
        FIELD_INFO Array = {
            DbgStr("avs"), DbgStr(""),
            0, DBG_DUMP_FIELD_FULL_NAME,
            0, NULL
        };
        FIELD_INFO Entry = {
            DbgStr("avs[0]"), DbgStr(""),
            0, DBG_DUMP_FIELD_FULL_NAME,
            0, NULL
        };

        SYM_DUMP_PARAM Sym = {
            sizeof (SYM_DUMP_PARAM), DbgStr(szVSTATE),
            DBG_DUMP_NO_PRINT, offVState,
            NULL, NULL, NULL,
            1, &Array
        };

        // Read size of the statistics array
        error = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );

        if (!error)
        {
            // Read size of a single statistics entry
            Sym.Fields = &Entry;

            error = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );
        }

        if (error || (Entry.size == 0))
        {
            dprintf("\n Unable to get verifier statistics.\n");
            if (error)
            {
                if (error == FIELDS_DID_NOT_MATCH)
                {
                    dprintf(" * " GDIModule() " was not built with VERIFIER_STATISTICS defined.\n");
                }
                else
                {
                    dprintf("  Last error was %s\n.", pszWinDbgError(error));
                }
            }
        }
        else
        {
            char szBuffer[80];                          // Composition buffer for field names
            int ArraySize = Array.size/Entry.size;  // Number of hooked functions
            int i;
            ULONG ulAttempts;
            ULONG ulFailures;

            dprintf("\nVerifier statistics:\n");
            dprintf("Function               Attempts   Failures\n");
            dprintf("---------------------- ---------- ----------\n");

            // Read and print statistics for each hooked function
            for (i = 0; i < ArraySize && !CheckControlC(); i++)
            {
                sprintf(szBuffer, "avs[%d].ulAttempts", i);
                error = GetVSTATEField(szBuffer, ulAttempts);
                if (error) break;

                sprintf(szBuffer, "avs[%d].ulFailures", i);
                error = GetVSTATEField(szBuffer, ulFailures);
                if (error) break;

                dprintf("%s 0x%08lx 0x%08lx\n",
                        ((i < NUM_VER_FUNCS) ?
                         gpszVerifierFuncs[i] :
                         " * Uknown Interface * "),
                        ulAttempts,
                        ulFailures);
            }

            if (i == 0)
            {
                dprintf(" ** No Statistics Available **\n");
            }
            else if (i > NUM_VER_FUNCS)
            {
                dprintf("\n  * - .verifier extension needs updated.\n");
            }

            if (error)
            {
                dprintf(" Last statistic read returned %s.\n", szBuffer, pszWinDbgError(error));
            }
        }
    }

#if GRAPHICS_DRIVER_POOL_TRACKING_SUPPORTED
    //
    // Optionally dump tracked pool.
    //

    if (bDump)
    {
        if (fl & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS)
        {
            FIELD_INFO SizeInfo = {DbgStr("ulSize"), NULL, 0, 0, 0, NULL};
            SYM_DUMP_PARAM Sym = {
                sizeof(SYM_DUMP_PARAM), DbgStr(szVERIFIERTRACKHDR),
                DBG_DUMP_NO_PRINT, 0, NULL, NULL, NULL,
                1, &SizeInfo
            };
            BYTE    Tag[4];     // Allocation tag
            ULONG64 Size;       // Size of allocation
            ULONG   SizeSize;
            ULONG   SizeHdr;    // Size of header struct (offset to allocation)

            // Read sizeof of ulSize field
            error = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );
            SizeSize = (error) ? sizeof(Size) : SizeInfo.size;

            // Read sizeof VERIFIERTRACKHDR structure
            Sym.Options |= DBG_DUMP_GET_SIZE_ONLY;
            SizeHdr = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );

            dprintf("\nTracked VerifierEngAllocMem allocations\n");
            dprintf("Tag \tSize    %s\tAddr            \n", (SizeSize == sizeof(ULONG)) ? "" : "        ");
            dprintf("----\t--------%s\t----------------\n", (SizeSize == sizeof(ULONG)) ? "" : "--------");

            // Are there any allocations?
            if (pList)
            {
                ULONG64 pListHead = pList;

                // Read until we loop back to the first allocation.
                do
                {
                    // Attempt to read allocation info
                    error = GetFieldValue(pList, szVERIFIERTRACKHDR, "ulTag", Tag);
                    if (error) break;
                    error = GetFieldValue(pList, szVERIFIERTRACKHDR, "ulSize", Size);
                    if (error) break;

                    // Print Tag
                    dprintf("%c%c%c%c", Tag[0], Tag[1], Tag[2], Tag[3]);
                    // Print allocation size
                    if (SizeSize == sizeof(ULONG))
                    {
                        dprintf("\t%08X", (ULONG)Size);
                    }
                    else
                    {
                        dprintf("\t%I64X", Size);
                    }
                    // Print start address of allocation
                    if (SizeHdr != 0)
                    {
                        dprintf("\t%p\n", pList+SizeHdr);
                    }
                    else
                    {
                        dprintf("\t%p+??\n", pList);
                    }

                    // Get next allocation
                    error = GetFieldValue(pList, GDIType(LIST_ENTRY), "FLink", pList);

                } while (pList != pListHead && !error && !CheckControlC());
            }
            else
            {
                dprintf(" ** No tracked allocations.\n");
            }
        }
        else
            dprintf("\nPool tracking not enabled\n");
    }
#endif

    EXIT_API(S_OK);

    //
    // Debugger extension help.
    //

verifier_help:

    dprintf("Usage: verifier [-?h"
#if GRAPHICS_DRIVER_POOL_TRACKING_SUPPORTED
            "d"
#endif
            "s]\n");
#if GRAPHICS_DRIVER_POOL_TRACKING_SUPPORTED
    dprintf(" d - Dump tracked pool (if pool tracking enabled)\n");
#endif
    dprintf(" s - Dump allocation statistics\n");
    EXIT_API(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\trace.cxx ===
/******************************Module*Header*******************************\
* Module Name: trace.cxx
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/


#include "precomp.hxx"

DECLARE_API( trace )
{
    OutputControl   OutCtl(Client);

    OutCtl.Output("trace is not fully supported yet.\n");

    HRESULT         hr = E_INVALIDARG;
    PDEBUG_SYMBOLS  Symbols;
    ULONG64         Module;
    ULONG           TypeId;

    // Interpret command line

    while (isspace(*args)) args++;

    if (*args != '\0')
    {
        OutCtl.Output("trace [-cdels] [Name]\n");
        return S_OK;
    }

    if (Client == NULL ||
        (hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                     (void **)&Symbols)) != S_OK)
    {
        return hr;
    }

    BEGIN_API( trace );

    if (GDIKM_Module.Base == 0)
    {
        OutCtl.OutErr("Error: win32k.sys module isn't available.\n");
    }
    Module = GDIKM_Module.Base;

    if (Module != 0)
    {
        // Make sure tracing is enabled in GDI
        hr = Symbols->GetTypeId(Module, "GDITraceEntryType", &TypeId);

        if (hr != S_OK)
        {
            OutCtl.OutErr("Error: GDI Tracing is not enabled.\n"
                    "       Rebuild " GDIModule() " with DBG_TRACE enabled.\n");
        }
        else
        {
            OutCtl.OutWarn("no implementation yet.\n");

            CHAR    TypeName[200];
            ULONG   NameSize;

            for (TypeId = 0;
                 Symbols->GetTypeName(Module, TypeId, NULL, 0, NULL) == E_FAIL;
                 TypeId++)
            {
                if (TypeId > 255) break;
            }

            for (;//TypeId = 0;
                 (hr = Symbols->GetTypeName(Module, TypeId,
                                            TypeName, sizeof(TypeName),
                                            &NameSize)) != E_FAIL;
                 TypeId++)
            {
                if ((NameSize > 11 && strncmp(TypeName, "enum_GDITE_", 11) == 0) ||
                    (NameSize > 6 && strncmp(TypeName, "GDITE_", 6) == 0))
                {
                    OutCtl.Output(" %lx ", TypeId);
                    hr = Symbols->OutputTypedDataVirtual(DEBUG_OUTCTL_AMBIENT,
                                                         0, Module, TypeId,
                                                         DEBUG_OUTTYPE_COMPACT_OUTPUT);
                    if (hr != S_OK)
                    {
                        OutCtl.Output("%s = Unknown Value (HRESULT %s)\n", TypeName, pszHRESULT(hr));
                    }
                }
            }

            OutCtl.Output("GetTypeName(,%lx,) returned %s.\n", TypeId, pszHRESULT(hr));
        }
    }

    Symbols->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\math\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#


SRCBASE=$(WINCORE_PATH)

PUBLICINCS=

TARGET_H_DIRECTORY=$(TARGET_DIRECTORY)

PRIVATEINCS= $(NTGDI_PATH)\gre\hmgr.h                \
             $(NTGDI_PATH)\gre\patblt.hxx            \
             $(NTGDI_PATH)\gre\xformobj.hxx          \
             $(NTGDI_PATH)\gre\engine.hxx            \
             $(NTGDI_PATH)\gre\epointfl.hxx          \
             $(NTGDI_PATH)\gre\rfntobj.hxx           \
             $(NTGDI_PATH)\math\daytona\$(TARGET_H_DIRECTORY)\efloat.hxx

$(O)\geninc.cxx:                                          \
		       ..\..\gre\$(TARGET_DIRECTORY)\geninc.m4              \
		       ..\..\gre\$(TARGET_H_DIRECTORY)\geninc.m4
    set PASS0ONLY=
    m4 -DBASE_INC_PATH=$(BASE_INC_PATH) -DNTGDI_PATH=$(NTGDI_PATH) < ..\..\gre\$(TARGET_DIRECTORY)\geninc.m4 \
                            > $@

$(O)\gdi$(TARGET_DIRECTORY).$(ASM_INCLUDE_SUFFIX):			  \
		       $(O)\geninc.cxx                                    \
		       $(PUBLICINCS)					  \
		       $(PRIVATEINCS)					  \
		       $(BASE_INC_PATH)\genxx.h
    set PASS0ONLY=
    nmake $(O)\geninc.obj USE_MSVCRT=1 NTNOPCH=1 FORCENATIVEOBJECT=1
    genxx $(O)\geninc.obj -s$(ASM_INCLUDE_SUFFIX) -o$@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\math\sources.inc ===
MAJORCOMP=windows
MINORCOMP=gdi

TARGETNAME=efloat
TARGETTYPE=LIBRARY

TARGETPATH=$(ALT_PROJECT_TARGET)\$(_OBJ_DIR)

INCLUDES=..\..\inc;                         \
         ..\..\..\dxkernel\inc;             \
         $(WINCORE_PATH)\w32inc;            \
         ..\..\gre;                         \
         $(BASE_INC_PATH);                  \
         $(DRIVERS_INC_PATH);               \
         $(MULTIMEDIA_INC_PATH);            \
         $(DDK_INC_PATH)
         
## Hydra
INCLUDES=$(INCLUDES);                       \
         $(TERMSRV_INC_PATH)

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

C_DEFINES=$(C_DEFINES) -DLANGPACK -DFE_SB

SOURCES=fontmath.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\math\daytona\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\kdexts2\viewer.cxx ===
/******************************Module*Header*******************************\
* Module Name: viewer.cxx
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/


#include "precomp.hxx"

#include <tchar.h>

LRESULT CALLBACK ViewerWndProc(HWND, UINT, WPARAM, LPARAM);


typedef struct {
    HWND            hViewerWnd;     // To be set by created thread
    PDEBUG_CLIENT   Client;
    PSURF_INFO      SurfInfo;
} ViewerThreadParams;

DWORD WINAPI ViewerThread(ViewerThreadParams *);

const _TCHAR    szClassName[] = _T("KD GDI Viewer");
const _TCHAR    szWindowName[] = _T("KD GDI Viewer");
ATOM            gViewerAtom;
HBRUSH          ghbrWhite;
HPEN            ghBorderPen;

const LONG DEFAULT_SCALE = 2;

class ViewerManager
{
public:
    ViewerManager(ULONG GrowLength = 4)
    {
        BeingDestroyed = FALSE;
        Wnds = 0;
        MaxWnds = 0;
        phWndList = NULL;
        GrowLen = (GrowLength == 0) ? 4 : GrowLength;
        __try {
            InitializeCriticalSection(&CritSect);
            CritOk = TRUE;
            Grow();
        }
        __except (STATUS_NO_MEMORY) {
            CritOk = FALSE;
        }
    }

    ~ViewerManager()
    {
        if (CritOk) EnterCriticalSection(&CritSect);
        BeingDestroyed = TRUE;
        if (CritOk) LeaveCriticalSection(&CritSect);

        DestroyAll();
        // If we have Wnds left at this point all of them
        // are now tracked as threads.  Wait for each
        // thread to completely finish.
        if (Wnds)
        {
            DWORD WaitReturn;
            DbgPrint("Waiting for remaining %lu threads...\n", Wnds);
            WaitReturn = WaitForMultipleObjects(Wnds, (HANDLE *)phWndList, TRUE, INFINITE);
            DbgPrint("WaitForMultipleObjects returned %lx.\n", WaitReturn);
            while (Wnds-- > 0)
            {
                CloseHandle(phWndList[Wnds]);
                DbgPrint("ViewerManager::~ViewerManager calling ExtRelease().\n");
                ExtRelease();
            }
        }

        HeapFree(hHeap, 0, phWndList);
        if (CritOk) DeleteCriticalSection(&CritSect);
    }

    BOOL Grow();

    BOOL Destroy(HWND);

    void DestroyAll()
    {
        ULONG i = Wnds;
        while (i-- > 0)
        {
            Destroy(phWndList[i]);
        }
    }

private:
    ULONG   Wnds;
    ULONG   MaxWnds;
    HWND   *phWndList;
    HANDLE  hHeap;
    ULONG   GrowLen;
    BOOL    BeingDestroyed;
    BOOL    CritOk;
    CRITICAL_SECTION    CritSect;

    friend DWORD WINAPI ViewerThread(ViewerThreadParams *);

    BOOL Track(HWND hWnd)
    {
        if (this == NULL || !CritOk) return FALSE;

        BOOL bTracked = FALSE;

        EnterCriticalSection(&CritSect);

        if (!BeingDestroyed &&
            ((Wnds < MaxWnds) || Grow()))
        {
            DbgPrint("ViewerManager: Tracking %lx.\n", hWnd);
            phWndList[Wnds++] = hWnd;
            bTracked = TRUE;
        }

        LeaveCriticalSection(&CritSect);

        return bTracked;
    }

    BOOL Untrack(HWND hWnd)
    {
        if (this == NULL || !CritOk) return FALSE;

        BOOL    bFound = FALSE;

        EnterCriticalSection(&CritSect);

        ULONG i = Wnds;

        while (i-- > 0)
        {
            if (phWndList[i] == hWnd)
            {
                DbgPrint("ViewerManager: No longer tracking %lx.\n", hWnd);
                phWndList[i] = phWndList[--Wnds];
                phWndList[Wnds] = NULL;
                bFound = TRUE;
                if (!BeingDestroyed)
                {
                    DbgPrint("ViewerManager::Untrack calling ExtRelease().\n");
                    ExtRelease();
                }
                break;
            }
        }

        if (!bFound)
            DbgPrint("ViewerManager::Untrack didn't find %lx.\n", hWnd);

        LeaveCriticalSection(&CritSect);

        return bFound;
    }

};

BOOL ViewerManager::Grow()
{
    if (MaxWnds > 0)
    {
        HWND *pNewList = (HWND *)HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, phWndList, (MaxWnds + GrowLen)*sizeof(HWND));

        if (pNewList != NULL)
        {
            phWndList = pNewList;
            MaxWnds += GrowLen;
            return TRUE;
        }
    }
    else
    {
        hHeap = GetProcessHeap();

        if (hHeap)
        {
            phWndList = (HWND *)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, GrowLen*sizeof(HWND));
            if (phWndList != NULL)
            {
                MaxWnds = GrowLen;
                return TRUE;
            }
        }
    }

    DbgPrint("ViewerManager::Grow FAILED!\n");
    return FALSE;
}


BOOL ViewerManager::Destroy(HWND hWnd)
{
    ULONG i = Wnds;

    DbgPrint("Looking for window %lx in %lu entries.\n", hWnd, i);

    while (i-- > 0)
    {
        if (phWndList[i] == hWnd)
        {
            DbgPrint("Destroying window %lx at entry %lu.\n", hWnd, i);
            DWORD   ThreadID = GetWindowThreadProcessId(hWnd, NULL);
            HANDLE  hThread;
            if (hThread = OpenThread(SYNCHRONIZE | THREAD_QUERY_INFORMATION, FALSE, ThreadID))
            {
                BOOL    bCloseHandle = TRUE;

                DWORD   ExitCode = STILL_ACTIVE;
                while (!PostMessage(hWnd, WM_DESTROY, 0, 0))
                {
                    DbgPrint("Waiting on post msg to %lx...\n", hWnd);
                    Sleep(10);
                    if (GetExitCodeThread(hThread, &ExitCode) &&
                        ExitCode != STILL_ACTIVE)
                    {
                        break;
                    }
                }

                // Check thread exit status
                if (ExitCode == STILL_ACTIVE)
                {
                    if (!GetExitCodeThread(hThread, &ExitCode))
                    {
                        DbgPrint("GetExitCodeThread returned error %lx.\n", GetLastError());
                    }
                }

                // Give the thread a chance to exit
                if (ExitCode == STILL_ACTIVE)
                {
                    DWORD WaitReturn;

                    DbgPrint("Waiting for hThread: %lx, ThreadID: %lx, hWnd: %lx.\n", hThread, ThreadID, hWnd);

                    if (WAIT_OBJECT_0 != (WaitReturn = WaitForSingleObject(hThread, 100)))
                    {
                        DbgPrint("WaitForSingleObject returned %lx.\n", WaitReturn);
                        // If it hasn't exited and it called untrack
                        // to remove the hWnd we're concerned with,
                        // replace it with the thread handle so we may
                        // wait on it later.
                        EnterCriticalSection(&CritSect);
                        if (phWndList[i] == hWnd)
                        {
                            phWndList[i] = (HWND)hThread;
                            bCloseHandle = FALSE;
                        }
                        LeaveCriticalSection(&CritSect);
                    }
                }

                if (bCloseHandle)
                {
                    // If the thread was still active, but the track entry
                    // has been removed, we have to wait for the thread to
                    // completely terminate.
                    if (ExitCode == STILL_ACTIVE)
                    {
                        DbgPrint("Inifinitely waiting for thread %lx to complete.\n", ThreadID);
                        WaitForSingleObject(hThread, INFINITE);

                        if (!GetExitCodeThread(hThread, &ExitCode))
                        {
                            DbgPrint("GetExitCodeThread returned error %lx.\n", GetLastError());
                        }
                        else
                        {
                            DbgPrint("Thread exit code was %lx.\n", ExitCode);
                        }
                    }

                    DbgPrint("Closing hThread: %lx\n", hThread);
                    CloseHandle(hThread);

                    if (BeingDestroyed)
                    {
                        DbgPrint("ViewerManager::Destroy calling ExtRelease().\n");
                        ExtRelease();
                    }
                }
            }
            else
            {
                // This really hurts.
                // We have a tracked window, but we can't get 
                // information on it's thread, we have to stop
                // tracking it.

                DbgPrint("ViewerManager::Destroy: OpenThread returned error %lx!\n", GetLastError());

                EnterCriticalSection(&CritSect);
                if (phWndList[i] == hWnd)
                {
                    phWndList[i] = phWndList[--Wnds];
                    phWndList[Wnds] = NULL;
                }
                LeaveCriticalSection(&CritSect);
            }

            return TRUE;
        }
    }
    return FALSE;
}


ViewerManager *ViewerMgr;

void ViewerInit()
{
    if (ViewerMgr == NULL)
    {
        ViewerMgr = new ViewerManager;

        if (ViewerMgr == NULL) return;
    }

    if (! ghbrWhite)
    {
        DbgPrint("ViewerInit: Creating white brush\n");
        ghbrWhite = CreateSolidBrush(RGB(0xFF,0xFF,0xFF));
        DbgPrint("ViewerInit: Created brush %lx\n", ghbrWhite);
    }

    if (! ghBorderPen)
    {
        DbgPrint("ViewerInit: Creating redish pen\n");
        ghBorderPen = CreatePen(PS_SOLID, 1, RGB(0xF0, 0x00, 0x3F));
        DbgPrint("ViewerInit: Created pen %lx\n", ghBorderPen);
    }

    if (! gViewerAtom)
    {
        WNDCLASSEX  wcex;

        DbgPrint("ViewerInit: Registering Class\n");
        DbgPrint("ViewerInit: ghDllInst = %lx\n", ghDllInst);

        wcex.cbSize = sizeof(wcex);
        wcex.style = CS_VREDRAW | CS_HREDRAW;
        wcex.lpfnWndProc = ViewerWndProc;
        wcex.cbClsExtra = 0;
        wcex.cbWndExtra = 0;
        wcex.hInstance = ghDllInst;
        wcex.hIcon = NULL;
        wcex.hCursor = LoadCursor( NULL, IDC_ARROW );
        wcex.hbrBackground = (HBRUSH)( COLOR_WINDOW+1 );
        wcex.lpszMenuName = NULL;
        wcex.lpszClassName = szClassName;
        wcex.hIconSm = NULL;

        gViewerAtom = RegisterClassEx( &wcex );
    }
}

void ViewerExit()
{
    if (ViewerMgr != NULL)
    {
        delete ViewerMgr;
        ViewerMgr = NULL;
    }

    if (gViewerAtom)
    {
        DbgPrint("ViewerExit: Unregistering Class\n");
        UnregisterClass((LPCSTR)gViewerAtom, 0);
        gViewerAtom = 0;
    }

    if (ghBorderPen)
    {
        DbgPrint("ViewerExit: Deleting border pen\n");
        DeleteObject(ghBorderPen);
        ghBorderPen = NULL;
    }

    if (ghbrWhite)
    {
        DbgPrint("ViewerInit: Deleting white brush\n");
        DeleteObject(ghbrWhite);
        ghbrWhite = NULL;
    }
}


BOOL
CALLBACK
ViewerWndEnumProc(
    HWND hWnd,
    LPARAM lParam
    )
{
    HWND    *phWndParent = (HWND *)lParam;

    DbgPrint("Found hWnd %lx.\n", hWnd);

    if (*phWndParent == NULL)
    {
        *phWndParent = hWnd;
    }

    return TRUE;
}


DWORD
WINAPI
ViewerThread(
    ViewerThreadParams *Params
    )
{
    HWND    hWnd;
    BOOL    bGetMsg;
    MSG     msg;
    _TCHAR  ViewerWndName[sizeof(szWindowName) + sizeof(Params->SurfInfo->SurfName) + 20];
    _TCHAR *pszName = Params->SurfInfo->SurfName;

    if (!pszName[0]) pszName = _T("UNAMED");

    _stprintf(ViewerWndName, "%s: %s (%ldx%ldx%hubpp)", szWindowName, pszName,
              Params->SurfInfo->Width,
              Params->SurfInfo->Height,
              Params->SurfInfo->BitsPixel);


    hWnd = CreateWindowEx(WS_EX_LEFT,
                          (LPCSTR)gViewerAtom,
                          ViewerWndName,
                          WS_OVERLAPPEDWINDOW,// | WS_HSCROLL | WS_VSCROLL,
                          0,
                          0,
                          Params->SurfInfo->Width*DEFAULT_SCALE+10,//32,
                          Params->SurfInfo->Height*DEFAULT_SCALE+29,//48,
                          NULL,
                          NULL,
                          ghDllInst,
                          Params->SurfInfo  // lParam passed to WM_CREATE handler
                       );

    if (hWnd)
    {
        ViewerMgr->Track(hWnd);

        Params->hViewerWnd = hWnd;      // Params may no longer be valid.

        ShowWindow(hWnd, SW_SHOWDEFAULT);
        UpdateWindow(hWnd);

        while( (bGetMsg = GetMessage(&msg, NULL, 0, 0 )) != 0 )
        {
            if (bGetMsg == -1)
            {
                DbgPrint("ViewerThread exiting due to GetMessage error 0x%lx.\n",
                         GetLastError());
                break;
            }
            else
            {
                TranslateMessage( &msg );
                DispatchMessage( &msg );
            }
        }

        DbgPrint("ViewerThread exiting properly.\n");

        ViewerMgr->Untrack(hWnd);
    }
    else
    {
        DbgPrint("CreateWindow returned error %lx.\n", GetLastError());

        msg.wParam = -1;
    }

    DbgPrint("ViewerThread calling ExitThread().\n");

    ExitThread((DWORD)msg.wParam);
}


DWORD
CreateViewer(
    PDEBUG_CLIENT   Client,
    PSURF_INFO      SurfInfo
    )
{
    ViewerThreadParams  NewThreadParams = { NULL, Client, SurfInfo };
    HRESULT Status;

    // Reference Debug Client for ViewerThread 
    // since dbgeng/dbghelp aren't thread safe.
    // ViewerManager will release client in a safe manner.
    if ((Status = ExtQuery(Client)) != S_OK) return 0;

    HWND hWndParent = NULL;
    EnumThreadWindows(GetCurrentThreadId(), (WNDENUMPROC)ViewerWndEnumProc, (LPARAM)&hWndParent);

    HANDLE  hThread;
    DWORD   ThreadID = 0;
    hThread = CreateThread(NULL,
                           0,
                           (LPTHREAD_START_ROUTINE)ViewerThread,
                           &NewThreadParams,
                           0,
                           &ThreadID);

    if (hThread)
    {
        while (NewThreadParams.hViewerWnd == NULL)
        {
            DWORD ExitCode = 0;
            if (!GetExitCodeThread(hThread, &ExitCode))
                DbgPrint("GetExitCodeThread returned error %lx.\n", GetLastError());
            if (ExitCode != STILL_ACTIVE)
            {
                ThreadID = 0;
                break;
            }

            SleepEx(10, TRUE);
        }

        CloseHandle(hThread);
    }

    if (ThreadID == 0)
    {
        ExtRelease();
    }

    return ThreadID;
}


// DelPropProc is a callback function 
// that deletes a window property. 
 
BOOL CALLBACK DelPropProc( 
    HWND hwndSubclass,  // handle of window with property 
    LPCSTR lpszString,  // property string or atom 
    HANDLE hData)       // data handle 
{ 
    RemoveProp(hwndSubclass, lpszString); 
 
    return TRUE; 
}


LRESULT
CALLBACK
ViewerWndProc(
    HWND hWnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
//    DbgPrint("ViewerWndProc(%lx, %lx, , )\n", hWnd, msg);

    switch( msg )
    {
        case WM_CREATE:
            {
                LPCREATESTRUCT  CreateStruct = (LPCREATESTRUCT)lParam;
                PSURF_INFO SurfInfo = (PSURF_INFO) CreateStruct->lpCreateParams;

                DbgPrint("ViewerWndProc: WM_CREATE\n");

                if (SurfInfo)
                {
                    SetProp(hWnd, "hBitmap", SurfInfo->hBitmap);
                    SetProp(hWnd, "xOrigin", LongToHandle(SurfInfo->xOrigin));
                    SetProp(hWnd, "yOrigin", LongToHandle(SurfInfo->yOrigin));
                    SetProp(hWnd, "Width", LongToHandle(SurfInfo->Width));
                    SetProp(hWnd, "Height", LongToHandle(SurfInfo->Height));
                    SetProp(hWnd, "BPP", LongToHandle(SurfInfo->BitsPixel));
                    SetProp(hWnd, "Scale", LongToHandle(DEFAULT_SCALE));
//                    SetProp(hWnd, "", SurfInfo->);
                }
                else
                {
                    ExtErr("ViewerWindow created with NULL PSURF_INFO.\n");
                    return -1;
                }
            }
            return 0;

        case WM_KEYDOWN:
            if (wParam == VK_DOWN || wParam == VK_UP)
            {
                LONG Scale = HandleToLong(GetProp(hWnd, "Scale"));
                if (wParam == VK_DOWN)
                {
                    if (Scale > 1)
                    {
                        SetProp(hWnd, "Scale", LongToHandle((Scale-1)));
                        InvalidateRect(hWnd, NULL, TRUE);
                    }
                }
                else
                {
                    if (Scale < 16)
                    {
                        SetProp(hWnd, "Scale", LongToHandle((Scale+1)));
                        InvalidateRect(hWnd, NULL, TRUE);
                    }
                }
                return 0;
            }
            break;

        case WM_PAINT:
            {
                PAINTSTRUCT ps;
                HDC hdc;
                HBITMAP hBitmapOrg;
                HBRUSH  hBrushOrg;
                HPEN    hPenOrg;

                BeginPaint(hWnd, &ps);

                hdc = CreateCompatibleDC(ps.hdc);
                hBitmapOrg = (HBITMAP)SelectObject(hdc, (HBITMAP)GetProp(hWnd, "hBitmap"));
                if (hBitmapOrg == NULL)
                {
                    DbgPrint("Error from SelectObject(, HBITMAP): %lx\n", GetLastError());
                }
                hBrushOrg = (HBRUSH)SelectObject(ps.hdc, ghbrWhite);
                hPenOrg = (HPEN)SelectObject(ps.hdc, ghBorderPen);
                LONG xOrigin = HandleToLong(GetProp(hWnd, "xOrigin"));
                LONG yOrigin = HandleToLong(GetProp(hWnd, "yOrigin"));
                LONG Width = HandleToLong(GetProp(hWnd, "Width"));
                LONG Height = HandleToLong(GetProp(hWnd, "Height"));
                LONG Scale = HandleToLong(GetProp(hWnd, "Scale"));
                Rectangle(ps.hdc, 0, 0, Width*Scale+2, Height*Scale+2);
                if (!StretchBlt(ps.hdc, 1, 1, Width*Scale, Height*Scale, hdc, xOrigin, yOrigin, Width, Height, SRCCOPY))
                {
                    DbgPrint("Error from StrectBlt): %lx\n", GetLastError());
                }
                SelectObject(ps.hdc, hPenOrg);
                SelectObject(ps.hdc, hBrushOrg);
                SelectObject(hdc, hBitmapOrg);
                DeleteDC(hdc);

                EndPaint(hWnd, &ps);
            }
            return DefWindowProc( hWnd, msg, wParam, lParam );

        case WM_DESTROY:

            DbgPrint("ViewerWndProc: WM_DESTROY\n");

            DeleteObject((HBITMAP)GetProp(hWnd, "hBitmap"));

            EnumPropsEx(hWnd, (PROPENUMPROCEX)DelPropProc, NULL); 

            PostQuitMessage(0);
            break;

        default:
//            DbgPrint("ViewerWndProc: unhandled msg %lx\n", msg);
            break;
    }

    return DefWindowProc( hWnd, msg, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\math\daytona\amd64\xformer.cxx ===
/******************************Module*Header*******************************\
* Module Name: xformer.cxx                                                 *
*                                                                          *
* Contains the transform calculation workhorse routines.                   *
*                                                                          *
* Created: 13-Nov-1990 11:06:09                                            *
* Author: Wendy Wu [wendywu]                                               *
*                                                                          *
* Copyright (c) 1990 Microsoft Corporation                                 *
\**************************************************************************/

extern "C" {

// needed until we cleanup the floating point stuff in ntgdistr.h
#define __CPLUSPLUS

    #include "engine.h"
};

#include "engine.hxx"
#include "xformobj.hxx"

/******************************Member*Function******************************\
* bCvtPts(PMATRIX pmx, PPOINTL pSrc, PPOINTL pDest, SIZE cPtl)              *
*                                                                           *
* Apply the given transform matrix to a list of points.                     *
*                                                                           *
* History:                                                                  *
*  13-Nov-1990 -by- Wendy Wu [wendywu]                                      *
* Wrote it.                                                                 *
\***************************************************************************/

BOOL bCvtPts(PMATRIX pmx, PPOINTL pSrc, PPOINTL pDest, SIZE_T cPtl)
{
    FIX     fxX, fxY;

    ASSERTGDI(((pmx->flAccel & XFORM_FORMAT_LTOL) == 0),
              "bCvtPts: transform wrong format\n");

    switch (pmx->flAccel &
            (XFORM_SCALE|XFORM_UNITY|XFORM_FORMAT_LTOFX))
    {
    case XFORM_SCALE|XFORM_UNITY|XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            pDest->x = LTOFX(pSrc->x) + pmx->fxDx;
            pDest->y = LTOFX(pSrc->y) + pmx->fxDy;
        }
        break;

    case XFORM_SCALE:
    case XFORM_SCALE|XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            EFLOAT x,y;

            x = pSrc->x;
            y = pSrc->y;

            x *= pmx->efM11;
            y *= pmx->efM22;

            x.bEfToL(fxX);              // convert result to long int
            y.bEfToL(fxY);

            pDest->x = fxX + pmx->fxDx;
            pDest->y = fxY + pmx->fxDy;
        }
        break;

    case 0:                             // transform not simple
    case XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            EFLOAT x,y,xTemp;

            x = pSrc->x;                // convert x, y to efloat
            y = pSrc->y;

            xTemp = (pmx->efM11 * x) + (pmx->efM21 * y);
            y = (pmx->efM12 * x) + (pmx->efM22 * y);

            xTemp.bEfToL(fxX);          // convert result to long int
            y.bEfToL(fxY);

            pDest->x = fxX + pmx->fxDx;
            pDest->y = fxY + pmx->fxDy;
        }
        break;

    case (XFORM_SCALE|XFORM_UNITY):
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            pDest->x = FXTOLROUND(pSrc->x) + pmx->fxDx;
            pDest->y = FXTOLROUND(pSrc->y) + pmx->fxDy;
        }
        break;

    default:
        RIP("bCvtPts: unknown flAccel\n");
    }
    return(TRUE);
}

/******************************Member*Function******************************\
* bCvtPts1(PMATRIX pmx, PPOINTL pptl, SIZE cPtl)
*
* Apply the given transform matrix to a list of points.
* The input and output points are of the type POINTL.
*
* History:
*  18-Dec-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\***************************************************************************/

BOOL bCvtPts1(PMATRIX pmx, PPOINTL pptl, SIZE_T cPtl)
{
    ASSERTGDI(((pmx->flAccel & XFORM_FORMAT_LTOL) == 0),
              "bCvtPts: transform wrong format\n");

    LONG   lx, ly;
    EFLOAT x, y;

    switch (pmx->flAccel &
            (XFORM_SCALE|XFORM_UNITY|XFORM_FORMAT_LTOFX))
    {
    case XFORM_SCALE|XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            x = pptl->x * pmx->efM11.e;
            y = pptl->y * pmx->efM22.e;

            x.bEfToL(lx);
            y.bEfToL(ly);

            pptl->x = FXTOLROUND(lx + pmx->fxDx);
            pptl->y = FXTOLROUND(ly + pmx->fxDy);
        }
        break;

    case XFORM_SCALE|XFORM_UNITY|XFORM_FORMAT_LTOFX:
        lx = FXTOLROUND(pmx->fxDx);
        ly = FXTOLROUND(pmx->fxDy);

        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            pptl->x += lx;
            pptl->y += ly;
        }
        break;

    case XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            x = pptl->x * pmx->efM11.e + pptl->y * pmx->efM21.e;
            y = pptl->x * pmx->efM12.e + pptl->y * pmx->efM22.e;

            x.bEfToL(lx);
            y.bEfToL(ly);

            pptl->x = FXTOLROUND(lx + pmx->fxDx);
            pptl->y = FXTOLROUND(ly + pmx->fxDy);
        }
        break;

    case XFORM_SCALE:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            x = LTOFX(pptl->x) * pmx->efM11.e;
            y = LTOFX(pptl->y) * pmx->efM22.e;

            x.bEfToL(pptl->x);
            y.bEfToL(pptl->y);

            pptl->x += pmx->fxDx;
            pptl->y += pmx->fxDy;
        }
        break;

    case XFORM_SCALE|XFORM_UNITY:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            pptl->x += pmx->fxDx;
            pptl->y += pmx->fxDy;
        }
        break;

    case 0:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            x = LTOFX(pptl->x) * pmx->efM11.e + LTOFX(pptl->y) * pmx->efM21.e;
            y = LTOFX(pptl->x) * pmx->efM12.e + LTOFX(pptl->y) * pmx->efM22.e;

            x.bEfToL(pptl->x);
            y.bEfToL(pptl->y);

            pptl->x += pmx->fxDx;
            pptl->y += pmx->fxDy;
        }
        break;

    default:
        RIP("bCvtPts: unknown flAccel\n");
    }
    return(TRUE);
}

/******************************Member*Function******************************\
* bCvtVts(PMATRIX pmx, PVECTORL pSrc, PVECTORL pDest, SIZE cPtl)            *
*                                                                           *
* Apply the given transform matrix to a list of vectors.                    *
*                                                                           *
* History:                                                                  *
*  13-Nov-1990 -by- Wendy Wu [wendywu]                                      *
* Wrote it.                                                                 *
\***************************************************************************/

BOOL bCvtVts(PMATRIX pmx, PVECTORL pSrc, PVECTORL pDest, SIZE_T cPtl)
{
    ASSERTGDI(((pmx->flAccel & XFORM_FORMAT_LTOL) == 0),
              "bCvtVts: transform wrong format\n");

    switch (pmx->flAccel &
            (XFORM_SCALE|XFORM_UNITY))
    {
    case XFORM_SCALE:
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            EFLOAT x,y;

            x = pSrc->x;
            y = pSrc->y;

            x *= pmx->efM11;
            y *= pmx->efM22;

            x.bEfToL(pDest->x);
            y.bEfToL(pDest->y);
        }
        break;

    case 0:                             // transform not simple
    case XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            EFLOAT x,y,xTemp;

            x = pSrc->x;                // convert x, y to efloat
            y = pSrc->y;

            xTemp = (pmx->efM11 * x) + (pmx->efM21 * y);
            y = (pmx->efM12 * x) + (pmx->efM22 * y);

            xTemp.bEfToL(pDest->x);
            y.bEfToL(pDest->y);
        }
        break;

    default:
        RIP("bCvtVts: unknown flAccel\n");
    }
    return(TRUE);
}

/******************************Member*Function******************************\
* bCvtVts_FlToFl(PMATRIX pmx, PVECTORFL pSrc, PVECTORFL pDest, SIZE cPts)   *
*                                                                           *
* Convert a list of vectors using the given matrix.                         *
*                                                                           *
* History:                                                                  *
*  13-Nov-1990 -by- Wendy Wu [wendywu]                                      *
* Wrote it.                                                                 *
\***************************************************************************/

BOOL bCvtVts_FlToFl(
MATRIX	 *pmx,
VECTORFL *pvtflSrc,
VECTORFL *pvtflDest,
SIZE_T	  cPts)
{
    for ( ; cPts > 0; cPts--, pvtflSrc++, pvtflDest++)
    {
        EFLOAT efXTemp;

        efXTemp = (pmx->efM11 * pvtflSrc->x) +
                  (pmx->efM21 * pvtflSrc->y);

        pvtflDest->y = (pmx->efM12 * pvtflSrc->x) +
                       (pmx->efM22 * pvtflSrc->y);

        pvtflDest->x = efXTemp;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\math\daytona\amd64\math.cxx ===
/******************************Module*Header*******************************\
* Module Name: math.cxx                                                    *
*                                                                          *
* IEEE single precision floating point math routines.                      *
*                                                                          *
* Created: 03-Jan-1991 11:32:03                                            *
* Author: Wendy Wu [wendywu]                                               *
*                                                                          *
* Copyright (c) 1990 Microsoft Corporation                                 *
\**************************************************************************/

extern "C" {

// needed until we cleanup the floating point stuff in ntgdistr.h
#define __CPLUSPLUS

    #include "engine.h"
};

#include "engine.hxx"

extern "C" {
VOID vEfToLfx(EFLOAT *pefloat, LARGE_INTEGER *plfx);
LONG lCvtWithRound(FLOAT f, LONG l);
BOOL bFToL(FLOAT e, PLONG pl, LONG lType);
FLOAT eFraction(FLOAT e);
};


/******************************Public*Function*****************************\
* bFToL                                                                    *
*                                                                          *
* Converts an IEEE 747 float to a LONG. The form of the conversion is      *
* specified by the caller.                                                 *
*                                                                          *
*  Arguments                                                               *
*                                                                          *
*      e                    IEEE 747 32-bit float to be converted          *
*                                                                          *
*      pl                   pointer to where answer should be placed       *
*                                                                          *
*      lType                contains bits specifying the type of           *
*                           conversion to be done this can be any          *
*                           combination of the following bits:             *
*                                                                          *
*                           CV_TO_FIX   if this bit is set then            *
*                                       the answer should                  *
*                                       should be in the form              *
*                                       of a 28.4 fix point number         *
*                                       otherwise the answer is            *
*                                       to be interpreted as a 32-bit      *
*                                       LONG                               *
*                                                                          *
*                           CV_TRUNCATE if this bit is set then the        *
*                                       answer is floor(e)                 *
*                                       (if CV_TO_FIX is not set) or       *
*                                       floor(16 * e)                      *
*                                       (if CV_TO_FIX is set)              *
*                                                                          *
*  Theory                                                                  *
*                                                                          *
*  An IEEE 747 float is contained in 32 bits which for the                 *
*  purposes of this discussion I shall call "e". e is                      *
*  equivalent to                                                           *
*                                                                          *
*      e = (-1)^s * mu * 2^E                                               *
*                                                                          *
*  s is the sign bit that is contained in the 31'st bit of e.              *
*  mu is the mantissa and E is the exponetial. These are obtained          *
*  from e in the following way.                                            *
*                                                                          *
*      s = e & 0x80000000 ? -1 : 1                                         *
*                                                                          *
*      mu = M * 2^-23      // 2^23 <= M < 2^24                             *
*                                                                          *
*      M = 0x800000 | (0x7FFFFF & e)                                       *
*                                                                          *
*      E = ((0x7F800000 & e) * 2^-23) - 127                                *
*                                                                          *
*  Suppose the 32.32 Fix point number is Q, then the relation              *
*  between the float and the 32.32 is given by                             *
*                                                                          *
*      Q = e * 2^32 = s * M * 2^(E+9)                                      *
*                                                                          *
* History:                                                                 *
*  Tue 15-Aug-1995 10:36:31 by Kirk Olynyk [kirko]                         *
* Rewrote it                                                               *
*                                                                          *
*  03-Jan-1991 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL bFToL(FLOAT e, PLONG pl, LONG lType)
{
    LONGLONG Q;         // 32.32 repn of abs(e)
    LONG E;             // used to hold exponent then integer parts
    LONG le;            // bit identical to FLOAT argument e
    BOOL bRet = TRUE;   // return value

    le = *(LONG*)&e;                                    // get IEEE 747 bits
    E = (int) (((0x7f800000 & le) >> 23) - 127) + 9;    // E = exponent
    if (lType & CV_TO_FIX)                              // if (want FIX point)
        E += 4;                                         //     multiply by 16
    if (E > (63-23))                                    // if (overflow)
    {                                                   //     bail out
        bRet = FALSE;
    }
    else
    {
        Q = (LONGLONG) (0x800000 | (0x7FFFFF & le));    // abs val of mantissa
        Q = (E >= 0) ? Q << E : Q >> -E;                // account for exponent
        if (!(lType & CV_TRUNCATE))                     // if (rounding) then
            Q += 0x80000000;                            //     add 1/2
        E = (long) (Q >> 32);                           // E = abs(integer part)
        *pl = (le < 0) ? -E : E;                        // fix up sign
    }
    return(bRet);
};

/******************************Public*Function*****************************\
* eFraction                                                                *
*                                                                          *
* Get the fractional part of a given IEEE floating point number.           *
*                                                                          *
* History:                                                                 *
*  03-Jan-1991 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

FLOAT eFraction(FLOAT e)
{
    LONG lEf, lExp, l;

    lEf = (*((LONG *) &e));        // convert type EFLOAT to LONG

// if exponent < 0 then there's no integer part, just return itself

    if ((lExp = ((lEf >> 23) & 0xff) -127) < 0) return(e);

// if exponent >= 23 then we do not store the fraction, return 0

    if (lExp >= 23) return FLOAT(0);

// if 0 <= exponent < 23 then
// the integer part l is calculated as:
//     lMantissa = (lEf & 0x7fffff) | 0x800000;
//     l = lMantissa >> (23 - lExponent);

    l = ((lEf & 0x7fffff) | 0x800000) >> (23 - lExp);
    return(e - (FLOAT) l);
};

/******************************Public*Routine******************************\
* VOID EFLOAT::vSqrt();                                                    *
*                                                                          *
* Takes the square root of the IEEE float.                                 *
*                                                                          *
* Assumes that the number is positive.                                     *
*                                                                          *
* History:                                                                 *
*  Fri 01-Mar-1991 12:26:58 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID EFLOAT::vSqrt()
{
    int k;
    ULONG ulY;
    ULONG ulR;
    ULONG ulL;
    ULONG ulF         = *(ULONG*) &e;
    ULONG ulBiasedExp = ((ulF & 0x7F800000)>>23);

    ulL  = 0x7fffff & ulF;
    ulL |= 0x800000;                        // get back the implicit bit
    if ((ulBiasedExp += 127) & 1)
    {
        ulL <<= 8;
        ulBiasedExp -= 1;
    }
    else
    {
        ulL <<= 7;
    }
    ulBiasedExp >>= 1;

    for (ulY = 0, ulR = 0, k = 0; k < 24; k++)
    {
        ulY <<= 2;
        ulY |= (ulL & 0xC0000000)>>30;
        ulL <<= 2;
        ulR <<= 1;
        {
            ULONG ulT = ulR + ulR + 1;
            if (ulT <= ulY)
            {
                ulY -= ulT;
                ulR++;
            }
        }
    }
    ulF = ulR & 0x7fffff;
    ulF |= ulBiasedExp << 23;
    e = *(FLOAT*) &ulF;
}

/******************************Public*Routine******************************\
* vEfToLfx                                                                 *
*                                                                          *
* Converts an IEEE 747 float to a 32.32 fix point number                   *
*                                                                          *
*  Theory                                                                  *
*                                                                          *
*  An IEEE 747 float is contained in 32 bits which for the                 *
*  purposes of this discussion I shall call "e". e is                      *
*  equivalent to                                                           *
*                                                                          *
*      e = (-1)^s * mu * 2^E                                               *
*                                                                          *
*  s is the sign bit that is contained in the 31'st bit of e.              *
*  mu is the mantissa and E is the exponetial. These are obtained          *
*  from e in the following way.                                            *
*                                                                          *
*      s = e & 0x80000000 ? -1 : 1                                         *
*                                                                          *
*      mu = M * 2^-23      // 2^23 <= M < 2^24                             *
*                                                                          *
*      M = 0x800000 | (0x7FFFFF & e)                                       *
*                                                                          *
*      E = ((0x7F800000 & e) * 2^-23) - 127                                *
*                                                                          *
*  Suppose the 32.32 Fix point number is Q, then the relation              *
*  between the float and the 32.32 is given by                             *
*                                                                          *
*      Q = e * 2^32 = s * M * 2^(E+9)                                      *
*                                                                          *
*                                                                          *
* History:                                                                 *
*  Fri 15-Jul-1994 07:01:50 by Kirk Olynyk [kirko]                         *
* Made use of intrinsic 64 bit support                                     *
*  Wed 26-Jun-1991 16:07:49 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID
vEfToLfx(EFLOAT *pefloat, LARGE_INTEGER *plfx)
{
    LONGLONG Q;
    char E;
    LONG e;

    e = *(LONG*)pefloat;
    Q = (LONGLONG) (0x800000 | (0x7FFFFF & e));
    E = (char) (((0x7f800000 & e) >> 23) - 127) + 9;
    Q = (E >= 0) ? Q << E : Q >> -E;
    Q = (e < 0) ? -Q : Q;
    *(LONGLONG*)plfx = Q;
}

/******************************Public*Routine******************************\
* lCvtWithRound(FLOAT f, LONG l);                                          *
*                                                                          *
* Multiplies a float by a long, rounds the results and casts to a LONG     *
*                                                                          *
* History:                                                                 *
*  Wed 26-May-1993 15:07:00 by Gerrit van Wingerden [gerritv]              *
* Wrote it.                                                                *
\**************************************************************************/

LONG lCvtWithRound(FLOAT f, LONG l)
{

    LONG l_ = 0;
    bFToL(f * l, &l_, 0);
    return(l_);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\math\fontmath.cxx ===
/******************************Module*Header*******************************\
* Module Name: fontmath.cxx
*
* math stuff needed by ttfd which uses efloat routines
*
* Created: 04-Apr-1992 10:31:49
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
*
\**************************************************************************/

extern "C"
{
    #define __CPLUSPLUS

    #include <engine.h>
};

#include "engine.hxx"
#include "equad.hxx"

/******************************Public*Routine******************************\
*
* bFDXform, transform an array of points, output in POINTFIX
*
* Effects:
*
* Warnings:
*
* History:
*  05-Apr-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

extern "C" BOOL bFDXform(
    XFORML    *pxf
  , POINTFIX *pptfxDst
  , POINTL   *pptlSrc
  , SIZE_T    c
    )
{
    BOOL bRet;
    EFLOAT ef11;
    EFLOAT ef12;
    EFLOAT ef21;
    EFLOAT ef22;

    ef11 = pxf->eM11;
    ef12 = pxf->eM12;
    ef21 = pxf->eM21;
    ef22 = pxf->eM22;

    bRet = FALSE;

    if ( ef12.bIsZero() && ef21.bIsZero()) {
        for ( ; c ; pptfxDst++, pptlSrc++, c--) {

            EFLOAT ef;

            ef = pptlSrc->x;
            ef *= ef11;

            if ( !ef.bEfToFx( pptfxDst->x )) {
                break;
            }
            ef = pptlSrc->y;
            ef *= ef22;
            if ( !ef.bEfToFx( pptfxDst->y )) {
                break;
            }
        }
        bRet = TRUE;
    } else {
        for ( ; c ; pptfxDst++, pptlSrc++, c--) {
            EFLOAT efX;
            EFLOAT efY;
            EFLOAT ef1;
            EFLOAT ef2;

            efX = pptlSrc->x;
            efY = pptlSrc->y;

            ef1  = efX;
            ef1 *= ef11;
            ef2  = efY;
            ef2 *= ef21;
            ef2 += ef1;

            if ( !ef2.bEfToFx( pptfxDst->x )) {
                break;
            }

            ef1  = efX;
            ef1 *= ef12;
            ef2  = efY;
            ef2 *= ef22;
            ef2 += ef1;

            if ( !ef2.bEfToFx( pptfxDst->y )) {
                break;
            }
        }
        bRet = TRUE;
    }
    return( bRet );
}

/******************************Public*Routine******************************\
*
* bXformUnitVector
*
* xform vector by pfdxo, compute the unit vector of the transformed
* vector and the norm of the transformed vector. Norm and the transformed
* vector are multiplied by 16 so that when converting to long the result
* will acutally be a 28.4 fix
*
* Effects:
*
* Warnings:
*
* History:
*  01-Apr-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

extern "C" BOOL bXformUnitVector(
      POINTL *pptl           // IN  incoming unit vector
 ,    XFORML *pxf            // IN  xform to use
 , PVECTORFL  pvtflXformed   // OUT xform of the incoming unit vector
 ,    POINTE *ppteUnit       // OUT *pptqXormed/|*pptqXormed|, POINTE
 ,  EPOINTQF *pptqUnit       // OUT the same as pteUnit, diff format
 ,    EFLOAT *pefNorm        // OUT |*pptqXormed|
    )
{
    EFLOAT efX_;
    EFLOAT efY_;
    BOOL b = TRUE;

    EFLOAT ef11;
    EFLOAT ef12;
    EFLOAT ef21;
    EFLOAT ef22;
    EFLOAT efX;
    EFLOAT efY;

    //
    // Convert longs to FIX point
    //

    efX = 16 * pptl->x;
    efY = 16 * pptl->y;

    //
    // Convert the matrix elements from FLOAT to EFLOAT
    //

    ef11 = pxf->eM11;
    ef12 = pxf->eM12;
    ef21 = pxf->eM21;
    ef22 = pxf->eM22;

    //
    // Transform the vector and put the result in efX_ and efY_
    //

    if ( ef12.bIsZero() && ef21.bIsZero() ) {
        efX_  = efX;
        efX_ *= ef11;
        efY_  = efY;
        efY_ *= ef22;
    } else {
        EFLOAT ef;

        efX_  = efX;
        efX_ *= ef11;
        ef    = efY;
        ef   *= ef21;
        efX_ += ef;

        ef    = efX;
        ef   *= ef12;
        efY_  = efY;
        efY_ *= ef22;
        efY_ += ef;
    }

    //
    // Record the results
    //

    pvtflXformed->x = efX_;
    pvtflXformed->y = efY_;

    // get the norm

    efX_ *= efX_;
    efY_ *= efY_;
    efX_ += efY_;
    efX_.vSqrt();

    *pefNorm = efX_;

    // make a unit vector out of eptfl

    EVECTORFL vtfl;

    vtfl.x.eqDiv(pvtflXformed->x,*pefNorm);
    vtfl.y.eqDiv(pvtflXformed->y,*pefNorm);

    vtfl.x.vEfToF(ppteUnit->x);
    vtfl.y.vEfToF(ppteUnit->y);

    // compute this same quantity in POINTQF format if requasted to do so:

    if (pptqUnit != (EPOINTQF *)NULL) {
        vtfl.x.vTimes16();
        vtfl.y.vTimes16();

    // convert to 28.36 format. The incoming vector is already
    // multliplied by 16 to ensure that the result is in the 28.36

        *pptqUnit = vtfl;
    }

    return b;
}

/******************************Public*Routine******************************\
*
* vLTimesVtfl
*
* Effects:
*
* Warnings:
*
* History:
*  05-Apr-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


extern "C" VOID vLTimesVtfl     // *pptq = l * pvtfl, *pptq is in 28.36 format
(
LONG       l,
VECTORFL  *pvtfl,
EPOINTQF  *pptq
)
{
    EVECTORFL  vtfl;
    EFLOAT     ef; ef = l;
    vtfl.x.eqMul(pvtfl->x,ef);
    vtfl.y.eqMul(pvtfl->y,ef);

// convert to 28.36 format. The incoming vector will already have been
// multliplied by 16 to ensure that the result is in the 28.36

    *pptq = vtfl;
}

/******************************Public*Routine******************************\
*
* fxLTimesEf
*
* Effects:
*
* Warnings:
*
* History:
*  05-Apr-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

extern "C" FIX  fxLTimesEf
(
EFLOAT *pef,
LONG    l
)
{
// *pef is a norm, already multiplied by 16 to ensure that the result
// is in 28.4 format

    l = lCvt((*pef), l);
    return (FIX)l;
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vLToE
*
* Routine Description:
*
* Arguments:
*
* Called by:
*
* Return Value:
*
\**************************************************************************/

extern "C" VOID vLToE(FLOATL *pe, LONG l)
{
    EFLOAT ef;
    ef = l;
    ef.vEfToF(*pe);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\math\wow6432\i386\geninc.cxx ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\math\daytona\i386\math.asm ===
page ,132
;------------------------------Module-Header----------------------------;
; Module Name: math.asm                                                 ;
;                                                                       ;
; This module contains the arithmetics routines for the engine internal ;
; floating point type EFLOAT.  It is mostly adapted from ChuckWh's      ;
; math.asm for PM.                                                      ;
;                                                                       ;
; Created: 14-Nov-1990                                                  ;
; Author: Wendy Wu [wendywu]                                            ;
;                                                                       ;
; Copyright (c) 1990 Microsoft Corporation                              ;
;-----------------------------------------------------------------------;

        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc
        include gdii386.inc
        .list

        .data
if DBG
  MATH_DivideError  db      'divff3_c - Divide overflow',10,0
endif

        .code

if DBG
  extrn   DbgPrint:proc
endif

NUMBER_OF_INTEGER_BITS_LONG equ 32
NUMBER_OF_INTEGER_BITS_FIX  equ 28
IEEE_NAN     equ     7FFFFFFFh          ; not a number exp = 255 mant != 0
EXPONENT_OF_ONE equ 2
MANTISSA_OF_ONE equ 040000000h

BOOL_TRUNCATE   equ     0
BOOL_ROUND      equ     1

RESULT_NEGATIVE     equ 1

        public  cmp_table_1
        public  cmp_table_2
        public  cmp_table_3
        public  cmp_table_4

cmp_table_1     label   dword
        dd      01000000h
        dd      00000100h

cmp_table_2     label   dword
        dd      10000000h
        dd      00100000h
        dd      00001000h
        dd      00000010h

cmp_table_3     label   dword
        dd      40000000h
        dd      04000000h
        dd      00400000h
        dd      00040000h
        dd      00004000h
        dd      00000400h
        dd      00000040h
        dd      00000004h

cmp_table_4     label   dword
        dd      80000000h
        dd      20000000h
        dd      08000000h
        dd      02000000h
        dd      00800000h
        dd      00200000h
        dd      00080000h
        dd      00020000h
        dd      00008000h
        dd      00002000h
        dd      00000800h
        dd      00000200h
        dd      00000080h
        dd      00000020h
        dd      00000008h
        dd      00000002h

;---------------------------Private-Routine-----------------------------;
; dNormalize
;
;   Normalizes a DWORD so that its absolute value has 0 in sign bit and
;   1 in the highest order non-sign bit.  Return the number of shifts done.
;
; Entry:
;       EAX = DWORD
; Returns:
;       ZF = 1 if zero, 0 otherwise
;       EAX = normalized DWORD
;       ECX = shift count
; Registers Destroyed:
;       EDX
; Calls:
;       None
; History:
;  14-Nov-1990 -by- Wendy Wu [wendywu]
; Wrote it
;-----------------------------------------------------------------------;

cProc   dNormalize

        cdq                             ; save the sign
        xor     ecx,ecx

        xor     eax,edx                 ; absolute eax
        sub     eax,edx
        jz      dNormalize_zero
        js      dNormalize_80000000

        cmp     eax,10000h
        adc     cl,cl                   ; cl = 0 if eax >= 10000h
                                        ; cl = 1 if eax < 10000h
        cmp     eax,cmp_table_1[4*ecx]
        adc     cl,cl                   ; cl = 0 if eax > 1000000h
                                        ; cl = 1 if 1000000h > eax > 10000h
                                        ; cl = 2 if 10000h > eax > 100h
                                        ; cl = 3 if eax < 100h

        cmp     eax,cmp_table_2[4*ecx]
        adc     cl,cl                   ; 0 <= cl <= 7

        cmp     eax,cmp_table_3[4*ecx]
        adc     cl,cl                   ; 0 <= cl <= 15

        cmp     eax,cmp_table_4[4*ecx]
        adc     cl,cl                   ; 1 <= cl <= 31
                                        ; cl will never be 0 since eax > 0

        dec     cl                      ; offset to highest non-sign bit
        shl     eax,cl                  ; shift to highest non-sign bit

        xor     eax,edx                 ; negate eax if was negative number
        sub     eax,edx

dNormalize_zero:
        cRet    dNormalize

dNormalize_80000000:
        sar     eax,1
        mov     ecx,-1
        cRet    dNormalize
endProc dNormalize

;-----------------------------Private-Routine---------------------------;
; ltoef
;
;   Convert a LONG integer to an EFLOAT format number.
;
; Entry:
;       EAX = LONG integer to be converted
; Returns:
;       ZF = 1 if zero, 0 otherwise
;       EAX = mantissa of the EFLOAT number
;       ECX = exponent of the EFLOAT number
; Registers Destroyed:
;       EDX
; Calls:
;       dNormalize
; History:
;  14-Nov-1990 -by- Wendy Wu [wendywu]
; Wrote it
;-----------------------------------------------------------------------;

cProc   ltoef

        cCall   dNormalize                      ; mant = normalized LONG
        jz      @F
        neg     ecx
        add     ecx,NUMBER_OF_INTEGER_BITS_LONG ; exp = 32 - shift count

@@:
        cRet    dNormalize
endproc ltoef

;---------------------------Public-Routine------------------------------;
; ltoef_c
;
;   Convert a LONG integer to an EFLOAT format number.
;
; Arguments:
;       IN  l    LONG integer to be converted
;       OUT pef  points to the EFLOAT number
; Calls:
;       dNormalize
; History:
;  14-Nov-1990 -by- Wendy Wu [wendywu]
; Wrote it
;-----------------------------------------------------------------------;

cProc   ltoef_c,8,<             \
        l:      dword,          \
        pef:    ptr EFLOAT      >

        mov     eax,l
        cCall   dNormalize                      ; mant = normalized LONG
        jz      @F
        neg     ecx
        add     ecx,NUMBER_OF_INTEGER_BITS_LONG ; exp = 32 - shift count

@@:
        mov     edx,pef
        mov     [edx].ef_lMant,eax
        mov     [edx].ef_lExp,ecx

        cRet    ltoef_c
endProc ltoef_c

;-----------------------------Private-Routine---------------------------;
; fxtoef
;
;   Convert a FIX number to an EFLOAT format number.
;
; Entry:
;       EAX = FIX number to be converted
; Returns:
;       ZF = 1 if zero, 0 otherwise
;       EAX = mantissa of the EFLOAT number
;       ECX = exponent of the EFLOAT number
; Registers Destroyed:
;       EDX
; Calls:
;       dNormalize
; History:
;  14-Nov-1990 -by- Wendy Wu [wendywu]
; Wrote it
;-----------------------------------------------------------------------;

cProc   fxtoef

        cCall   dNormalize                      ; mant = normalized fIX number
        jz      @F
        neg     ecx
        add     ecx,NUMBER_OF_INTEGER_BITS_FIX  ; exp = 28 - shift count

@@:
        cRet    fxtoef
endProc fxtoef

;---------------------------Public-Routine------------------------------;
; fxtoef_c
;
;   Convert a FIX number to an EFLOAT format number.
;
; Arguments:
;       IN  fx   FIX number to be converted
;       OUT pEf  points to the EFLOAT number
; Calls:
;       dNormalize
; History:
;  14-Nov-1990 -by- Wendy Wu [wendywu]
; Wrote it
;-----------------------------------------------------------------------;

cProc   fxtoef_c,8,<            \
        fx:     dword,          \
        pEf:    ptr EFLOAT      >

        mov     eax,fx
        cCall   dNormalize                      ; mant = normalized LONG
        jz      @F
        neg     ecx
        add     ecx,NUMBER_OF_INTEGER_BITS_FIX  ; exp = 28 - shift count

@@:
        mov     edx,pEf
        mov     [edx].ef_lMant,eax
        mov     [edx].ef_lExp,ecx

        cRet    fxtoef_c
endProc fxtoef_c

;---------------------------Public-Routine------------------------------;
; ftoef_c
;
;   Convert an IEEE FLOAT format number to an EFLOAT format number.
;
; Arguments:
;       IN  e    IEEE FLOAT number to be converted
;       OUT pEf  points to the EFLOAT number
; Calls:
;       None
; History:
;  14-Nov-1990 -by- Wendy Wu [wendywu]
; Wrote it
;-----------------------------------------------------------------------;

cProc   ftoef_c,8,<              \
        e:      dword,           \
        pEf:    ptr EFLOAT       >

        mov     eax,e
        shld    ecx,eax,9
        and     ecx,0FFh                ; ecx = e.exponent
        jnz     @F

        xor     eax,eax                 ; return 0 if (exp == 0)
        jmp     ftoef_zero

@@:

; We got a non-zero number
; EFLOAT.mantissa = FLOAT.mantissa + hidden one

        cdq                             ; sign extend eax to edx
        and     eax,07FFFFFh            ; mask off sign bit and exponent
        shl     eax,7                   ; shift to its position
        or      eax,040000000h          ; or in the hidden one

        ;ASSERT(((eax & 080000000h) == 0),"ftoef_c error");

        xor     eax,edx                 ; negate mantissa if (e < 0)
        sub     eax,edx

; ef.exp = e.exp + 2 - 127

        sub     ecx,125

ftoef_zero:
        mov     edx,pEf
        mov     [edx].ef_lMant,eax
        mov     [edx].ef_lExp,ecx

        cRet    ftoef_c
endProc ftoef_c

;-----------------------------Public-Routine----------------------------;
; eftofx
;
;   Convert an EFLOAT number to a FIX number.  Fractions of 1/32 or greater
;   are rounded up.
;
; Entry:
;       EAX = mantissa
;       ECX = exponent
; Returns:
;       OF = 0
;       EAX = converted long integer
; Error Returns:
;       OF = 1
; Registers Destroyed:
;       EDX,ECX
; Calls:
;       eftol
; History:
;  14-Nov-1990 -by- Wendy Wu [wendywu]
; Wrote it
;-----------------------------------------------------------------------;

cProc   eftofx

        add     ecx,4                   ; so we can call eftol
        mov     edx,BOOL_ROUND

eftofx_fall_through::

endProc eftofx                          ; fall through to eftol

;-----------------------------Public-Routine----------------------------;
; eftol
;
;   Convert an EFLOAT number to a LONG integer.  Fractions are either
;   rounded or truncated depending on the flag in EDX.
;
; Entry:
;       EAX = mantissa
;       ECX = exponent
;       EDX = roundoff boolean
; Returns:
;       OF = 0
;       EAX = converted long integer
; Error Returns:
;       OF = 1
; Registers Destroyed:
;       ECX
; Calls:
;       None

; History:
;  14-Nov-1990 -by- Wendy Wu [wendywu]
; Wrote it
;-----------------------------------------------------------------------;

cProc   eftol

.errnz  $-eftofx_fall_through

; if exp < 1, return 0.

        cmp     ecx,1
        jl      eftol_exp_small
        cmp     ecx,32
        jg      eftol_exp_big
        jz      @F                      ; return mantissa if (exp == 32)

        ;ASSERT((1 <= ecx <= 31),"eftol exponent error")

        xor     cl,31                   ; 31 - exp

; EDX = 1 if we'll do truncation, LONG = ((mant >> (31 - exp)) + 1) >> 1
; EDX = 0 if we'll do rounding, LONG = (mant >> (31 - exp)) >> 1

        ;ASSERT(((edx & FFFFFFFEh) == 0),"eftol rounding boolean error")

        sar     eax,cl
        add     eax,edx
        jo      eftol_7fffffff          ; overflow if mant = 7fffffff, exp = 31
        sar     eax,1
@@:
        cRet    eftol                   ; normal return

eftol_exp_small:
        xor     eax,eax                 ; exponent too small, return 0
        cRet    eftol                   ; OF = 0 by xor

eftol_exp_big:
        mov     cl,1                    ; OF = 1 if exp > 32
        add     cl,7fh
        cRet    eftol

eftol_7fffffff:
        shr     eax,1                   ; return 40000000h
        xor     cl,cl                   ; OF = 0
        cRet    eftol

endProc eftol

;---------------------------Public-Routine------------------------------;
; eftol_c
;
;   Convert an EFLOAT number to a LONG integer.  Fractions are rounded
;   or truncated depending on the passed in flag.
;
; Arguments:
;       IN  pEf     points to the EFLOAT number
;       OUT pL      points to the LONG integer
;       IN  bRound  roundoff boolean
; Returns:
;       EAX = 1 if success
; Error Returns:
;       EAX = 0 if overflow
; Calls:
;       eftol
; History:
;  14-Nov-1990 -by- Wendy Wu [wendywu]
; Wrote it
;
;CR!!! Delete this if nobody uses it.
;-----------------------------------------------------------------------;

cProc   eftol_c,12,<        \
        pEf:    ptr EFLOAT, \
        pL:     ptr LONG,   \
        bRound: dword       >

        mov     edx,pEf
        mov     eax,[edx].ef_lMant
        mov     ecx,[edx].ef_lExp
        mov     edx,bRound

        cCall   eftol

        mov     edx,pL
        mov     [edx],eax

        mov     eax,0
        setno   al

        cRet    eftol_c
endProc eftol_c

;---------------------------Public-Routine------------------------------;
; eftofx_c
;
;   Convert an EFLOAT number to a FIX number.  Fractions of 1/32 or greater
;   are rounded up.
;
; Arguments:
;       IN  pEf     points to the EFLOAT number
;       OUT pFx     points to the FIX number
; Returns:
;       EAX = 1 if success
; Error Returns:
;       EAX = 0 if overflow
; Calls:
;       eftol
; History:
;  14-Nov-1990 -by- Wendy Wu [wendywu]
; Wrote it
;
;CR!!! Delete this if nobody uses it.
;-----------------------------------------------------------------------;

cProc   eftofx_c,8,<        \
        pEf:    ptr EFLOAT, \
        pFx:    ptr FIX     >

        mov     edx,pEf
        mov     eax,[edx].ef_lMant
        mov     ecx,[edx].ef_lExp
        add     ecx,4

        mov     edx,BOOL_ROUND
        cCall   eftol

        mov     edx,pFx
        mov     [edx],eax

        mov     eax,0
        setno   al

        cRet    eftofx_c
endProc eftofx_c

;---------------------------Public-Routine------------------------------;
; eftof_c
;
;   Convert an EFLOAT number to an IEEE FLOAT format number.
;
; Arguments:
;       IN  pEf     points to the EFLOAT number
; Returns:
;       EAX = resulting IEEE FLOAT number
; Error Returns:
;       EAX = NAN if overflow
; Calls:
;       None
; History:
;  14-Nov-1990 -by- Wendy Wu [wendywu]
; Wrote it
;-----------------------------------------------------------------------;

cProc   eftof_c,4,<                 \
        pEf:    ptr EFLOAT          >

        xor     eax,eax                 ; assume result is 0
        mov     edx,pEf
        mov     ecx,[edx].ef_lMant
        or      ecx,ecx                 ; faster than jcxz
        jz      eftof_zero

        mov     edx,[edx].ef_lExp

        jns     eftof_positive
        or      eax,080000000h          ; turn on sign bit if negative number
        neg     ecx                     ; make it positive

eftof_positive:

        and     ecx,3FFFFFFFh           ; mask off sign bit and hidden one
        shr     ecx,7                   ; shift mantissa to its position
        adc     ecx,0                   ; round the result
        test    ecx,0800000h
        jnz     eftof_rounding_overflow

eftof_mant_done:
        add     edx,125                 ; FLOAT.exp = EFLOAT.exp + 127 - 2
        jo      eftof_NAN

        shl     edx,23                  ; shift exponent to its position

        or      eax,ecx
        or      eax,edx                 ; or sign, mant, exp bits together
eftof_zero:
        cRet    eftof_c

eftof_rounding_overflow:
        xor     ecx,ecx
        inc     edx
        jno     eftof_mant_done

eftof_NAN:
        mov     eax,IEEE_NAN
        cRet    eftof_c

endProc eftof_c

;---------------------------Public-Routine------------------------------;
; fraction_c
;
;   Get the fraction part of an EFLOAT number.
;
; Arguments:
;       IN  pEfIn   points to the EFLOAT number its fractional part is
;                   to be computed
;       OUT pEfOut  points to the EFLOAT number that stores the fractional
;                   part result
; Returns:
;       Nothing
; Calls:
;       dNormalize
; History:
;  14-Nov-1990 -by- Wendy Wu [wendywu]
; Wrote it
;-----------------------------------------------------------------------;

;!!!CR Does Andrew use this?  Is the result correct when a negative number
;!!!CR is passed in?

cProc   fraction_c,8,<       \
        pEfOut:  ptr EFLOAT, \
        pEfIn:   ptr EFLOAT  >

        mov     edx,pEfIn

        mov     eax,[edx].ef_lMant         ; EAX = mantissa
        mov     ecx,[edx].ef_lExp          ; ECX = exponent
        cmp     ecx,0
        jle     got_fractions           ; if (exp <= 1) return itself

        cmp     ecx,32
        jge     no_fraction

; shift off integer part

have_fraction:
        shl     eax,cl                  ; shift off the integer bits
        shr     eax,1                   ; make it positive
        cCall   dNormalize
        jz      no_fraction
        neg     ecx                     ; exp = 1 - left shift count
        inc     ecx

; We get here either because the number is too big, no fraction is stored
; in the mantissa or this number is an integer.

store_results:
        mov     edx,pEfOut
        mov     [edx].ef_lMant,eax
        mov     [edx].ef_lExp,ecx
        mov     eax,edx
        cRet    fraction_c

got_fractions:                          ; take care of negative fractions here
        or      eax,eax
        jge     store_results
        neg     ecx
        sar     eax,cl
        shr     eax,1                   ; make it positive
        neg     ecx
        inc     ecx
        jmp short   store_results

no_fraction:
        xor     eax,eax                 ; exp >= 32 return 0
        xor     ecx,ecx
        jmp     store_results

endProc fraction_c

;-----------------------------Public-Routine----------------------------;
; addff
;
;   Add two EFLOAT numbers together.
;
; Entry:
;       EDX = mant
;       EBX = exp
;       EAX = mant
;       ECX = exp
; Returns:
;       EAX = mant
;       ECX = exp
;       OF = 0
;       ZF = 1 if zero
; Error Returns:
;       OF = 1 if overflow
; Registers Destroyed:
;       EBX,EDX
; Calls:
;       dNormalize
; History:
;  14-Nov-1990 -by- Wendy Wu [wendywu]
; Wrote it
;-----------------------------------------------------------------------;

cProc   addff

        or      edx,edx                 ; early out if either one is 0
        jz      addff_exit
        or      eax,eax
        jz      addff_xchg_exit

        cmp     ecx,ebx
        jge     second_summand_larger
        xchg    eax,edx
        xchg    ecx,ebx

second_summand_larger:
        sub     ecx,ebx
        cmp     ecx,30                  ; only 30 bits of pre-adding precision
        jbe     first_summand_not_small ;
        add     ecx,ebx                 ; clear overflow flag
        jmp     addff_exit

first_summand_not_small:
        add     ebx,ecx                 ; restore the bigger exp in ebx
        sar     edx,cl                  ; shift the smaller number right by
                                        ; difference in exp bit
        sar     eax,1                   ; prevent overflow
;        adc     eax,0                   ; round the bigger number
        sar     edx,1                   ; prevent overflow
;        adc     edx,0                   ; round the smaller number

        add     eax,edx                 ; add mantissa together
        cCall   dNormalize
        jz      addff_exit

; sum's exponent = EBX - ECX + 1

        neg     ecx
        add     ecx,ebx
        inc     ecx                     ; compensate for the right shift

addff_exit:
        cRet    addff

addff_xchg_exit:
        mov     eax,edx
        mov     ecx,ebx
        cRet    addff

endProc addff

;---------------------------Public-Routine------------------------------;
; subff_c                                                               ;
;                                                                       ;
;   Subtract an EFLOAT number from another.  The result overwrites the  ;
;   subtrahend.                                                         ;
;                                                                       ;
; Arguments:                                                            ;
;       IN OUT pSub  points to the EFLOAT subtrahend                    ;
;       IN     pMin  points to the EFLOAT minuend                       ;
; Returns:                                                              ;
;       EAX = 1 if success                                              ;
; Error Returns:                                                        ;
;       EAX = 0 if overflow                                             ;
; Calls:                                                                ;
;       addff                                                           ;
; History:                                                              ;
;  Thu 19-Mar-1992 17:44:34 -by- Charles Whitmer [chuckwh]              ;
; Added 3 parameter entry point.  This gives us better C++ code.        ;
;                                                                       ;
;  14-Nov-1990 -by- Wendy Wu [wendywu]                                  ;
; Wrote it                                                              ;
;-----------------------------------------------------------------------;

cProc   subff_c,8,<         \
        uses    ebx,        \
        pSub:   ptr EFLOAT, \
        pMin:   ptr EFLOAT  >

        mov     ebx, pSub
        mov     edx, [ebx].ef_lMant
        mov     ebx, [ebx].ef_lExp

        mov     ecx, pMin
        mov     eax, [ecx].ef_lMant
        mov     ecx, [ecx].ef_lExp
        neg     eax

        cCall   addff

        mov     ebx,pSub
        mov     [ebx].ef_lMant,eax
        mov     [ebx].ef_lExp,ecx

        mov     eax,0
        setno   al

        cRet    subff_c

endProc subff_c

cProc   subff3_c,12,<        \
        uses    ebx,        \
        pRes:   ptr EFLOAT, \
        pSub:   ptr EFLOAT, \
        pMin:   ptr EFLOAT  >

        mov     ebx, pSub
        mov     edx, [ebx].ef_lMant
        mov     ebx, [ebx].ef_lExp

        mov     ecx, pMin
        mov     eax, [ecx].ef_lMant
        mov     ecx, [ecx].ef_lExp
        neg     eax

        cCall   addff

        mov     ebx,pRes
        jo      short @F
        mov     [ebx].ef_lMant,eax
        mov     [ebx].ef_lExp,ecx
@@:     mov     eax,ebx
        cRet    subff3_c
endProc subff3_c

;---------------------------Public-Routine------------------------------;
; addff_c                                                               ;
;                                                                       ;
;   Add two EFLOAT numbers together.  The result overwrites the first   ;
;   summand.                                                            ;
;                                                                       ;
; Arguments:                                                            ;
;       IN OUT pSum1  points to the first EFLOAT summand                ;
;       IN     pSum2  points to the second EFLOAT summand               ;
; Returns:                                                              ;
;       EAX = 1 if success                                              ;
; Error Returns:                                                        ;
;       EAX = 0 if overflow                                             ;
; Calls:                                                                ;
;       addff                                                           ;
; History:                                                              ;
;  Thu 19-Mar-1992 17:44:34 -by- Charles Whitmer [chuckwh]              ;
; Added 3 parameter entry point.  This gives us better C++ code.        ;
;                                                                       ;
;  14-Nov-1990 -by- Wendy Wu [wendywu]                                  ;
; Wrote it                                                              ;
;-----------------------------------------------------------------------;

cProc   addff_c,8,<         \
        uses    ebx,        \
        pSum1:  ptr EFLOAT, \
        pSum2:  ptr EFLOAT  >

        mov     ebx, pSum2
        mov     edx, [ebx].ef_lMant
        mov     ebx, [ebx].ef_lExp

        mov     ecx, pSum1
        mov     eax, [ecx].ef_lMant
        mov     ecx, [ecx].ef_lExp

        cCall   addff

        mov     ebx,pSum1
        mov     [ebx].ef_lMant,eax
        mov     [ebx].ef_lExp,ecx

        mov     eax,0
        setno   al

        cRet    addff_c
endProc addff_c

cProc   addff3_c,12,<        \
        uses    ebx,        \
        pRes:   ptr EFLOAT, \
        pSum1:  ptr EFLOAT, \
        pSum2:  ptr EFLOAT  >

        mov     ebx, pSum2
        mov     edx, [ebx].ef_lMant
        mov     ebx, [ebx].ef_lExp

        mov     ecx, pSum1
        mov     eax, [ecx].ef_lMant
        mov     ecx, [ecx].ef_lExp

        cCall   addff

        mov     ebx,pRes
        jo      short @F
        mov     [ebx].ef_lMant,eax
        mov     [ebx].ef_lExp,ecx
@@:     mov     eax,ebx
        cRet    addff3_c
endProc addff3_c

;-----------------------------Public-Routine----------------------------;
; mulff                                                                 ;
;                                                                       ;
;   Multiply two EFLOAT numbers together.                               ;
;                                                                       ;
; Entry:                                                                ;
;       EDX = first multiplicand's mant                                 ;
;       EBX = first multiplicand's exp                                  ;
;       EAX = second multiplicand's mant                                ;
;       ECX = second multiplicand's exp                                 ;
; Returns:                                                              ;
;       EAX = mant                                                      ;
;       ECX = exp                                                       ;
;       OF = 0                                                          ;
;       ZF = 1 if zero                                                  ;
; Error Returns:                                                        ;
;       OF = 1 if overflow                                              ;
; Registers Destroyed:                                                  ;
;       EDX,EBX                                                         ;
; Calls:                                                                ;
;       None                                                            ;
; History:                                                              ;
;  14-Nov-1990 -by- Wendy Wu [wendywu]                                  ;
; Wrote it                                                              ;
;-----------------------------------------------------------------------;

mul_shift_table label   byte            ; highest 4 bits
        db      0                       ; 0000 should have been early out
        db      2                       ; 0001
        db      1                       ; 0010
        db      1                       ; 0011

cProc   mulff

        add     ebx,ecx                 ; add exponent together
        jo      mul_exit

        xor     ecx,ecx
        imul    edx                     ; edx:eax = edx * eax

; the product of two mantissas is now in edx:eax. Since on entry
; to this function both mantissas were normalized the absolute value
; of this product is <= 7fffffff * 7fffffff = 3fffffff:00000001;
; The legal values of the most significant nibble in edx are 0, 1, 2, 3.

        or      edx,edx
        jz      mul_exit                ; eax == 0 if (edx == 0), so it's
                                        ; safe to early out here
        js      mul_neg

        shld    ecx,edx,4               ; normalize the result
        mov     cl,mul_shift_table[ecx] ; find the shift count from the table
        shld    edx,eax,cl
        shl     eax,cl

; now do the rounding. We should  add the most significant bit of eax to edx.
; Adding this extra bit to edx could result in the
; loss of normalization of edx which should then be restored by shr edx,1
; and adjusting the exponent accordingly.

        add     eax,80000000h
        adc     edx,0
        js      mul_restore_normalization

mul_store_result:
        neg     ecx
        mov     eax,edx                 ; return mantissa in eax
        add     ecx,ebx                 ; exponent = ebx - ecx

mul_exit:
        cRet    mulff

mul_restore_normalization:

        shr edx,1                       ; edx now normalized == 40000000h
        dec ecx                         ; adjust exponent
        jmp mul_store_result

; the result is negative:

mul_neg:

; We can't normalize a negative number.  e.g. the shift count for 1110
; can be either 1 or 2.

        neg     eax                     ; negate edx:eax
        adc     edx,0
        neg     edx

        shld    ecx,edx,4               ; normalize the result
        mov     cl,mul_shift_table[ecx] ; find the shift count from the table
        shld    edx,eax,cl
        shl     eax,cl

; do the rounding as in the positive case

        add     eax,80000000h
        adc     edx,0
        js      mul_restore_normalization_neg

; all the information is now in edx, including least significant bit

mul_store_result_neg:

        neg     edx                     ; restore the sign
        neg     ecx                     ; finish off as in the positive case
        add     ecx,ebx                 ; exponent = ebx - ecx
        mov     eax,edx                 ; return mantissa in eax

        cRet    mulff

mul_restore_normalization_neg:

        shr edx,1                       ; edx now normalized == 40000000h
        dec ecx                         ; adjust exponent
        jmp mul_store_result_neg

endProc mulff

;---------------------------Public-Routine------------------------------;
; mulff_c                                                               ;
;                                                                       ;
;   Multiply two EFLOAT numbers together.  The result overwrites the    ;
;   first multiplicand.                                                 ;
;                                                                       ;
; Arguments:                                                            ;
;       IN OUT pMult1  points to the first EFLOAT multiplicand.         ;
;       IN     pMult2  points to the second EFLOAT multiplicand.        ;
; Returns:                                                              ;
;       EAX = 1 if success                                              ;
; Error Returns:                                                        ;
;       EAX = 0 if overflow                                             ;
; Calls:                                                                ;
;       mulff                                                           ;
; History:                                                              ;
;  Thu 19-Mar-1992 17:44:34 -by- Charles Whitmer [chuckwh]              ;
; Added 3 parameter entry point.  This gives us better C++ code.        ;
;                                                                       ;
;  14-Nov-1990 -by- Wendy Wu [wendywu]                                  ;
; Wrote it                                                              ;
;-----------------------------------------------------------------------;

cProc   mulff_c,8,<             \
        uses    ebx,            \
        pMult1: ptr EFLOAT,     \
        pMult2: ptr EFLOAT      >

        mov     ebx,pMult2
        mov     eax,[ebx].ef_lMant
        mov     ecx,[ebx].ef_lExp
        mov     ebx,pMult1
        mov     edx,[ebx].ef_lMant
        mov     ebx,[ebx].ef_lExp

        cCall   mulff

        mov     ebx,pMult1
        mov     [ebx].ef_lMant,eax
        mov     [ebx].ef_lExp,ecx

        mov     eax,0
        setno   al

        cRet    mulff_c
endProc mulff_c

cProc   mulff3_c,12,<            \
        uses    ebx,            \
        pRes:   ptr EFLOAT,     \
        pMult1: ptr EFLOAT,     \
        pMult2: ptr EFLOAT      >

        mov     ebx,pMult2
        mov     eax,[ebx].ef_lMant
        mov     ecx,[ebx].ef_lExp
        mov     ebx,pMult1
        mov     edx,[ebx].ef_lMant
        mov     ebx,[ebx].ef_lExp

        cCall   mulff

        mov     ebx,pRes
        jo      short @F
        mov     [ebx].ef_lMant,eax
        mov     [ebx].ef_lExp,ecx
@@:     mov     eax,ebx
        cRet    mulff3_c
endProc mulff3_c

;---------------------------Private-Routine-----------------------------;
; divff                                                                 ;
;                                                                       ;
;   Divide an EFLOAT number by another.                                 ;
;                                                                       ;
; Entry:                                                                ;
;       EDX = dividend's mantissa                                       ;
;       EBX = dividend's exponent                                       ;
;       EAX = divisor's mantissa, should never be 0                     ;
;       ECX = divisor's exponent                                        ;
; Returns:                                                              ;
;       EAX = quotient's mantissa                                       ;
;       ECX = quotient's exponent                                       ;
;       OF = 0                                                          ;
;       ZF = 1 if zero                                                  ;
; Error Returns:                                                        ;
;       OF = 1 if overflow                                              ;
; Registers Destroyed:                                                  ;
;       EDX,EBX                                                         ;
; Calls:                                                                ;
;       dNormalize                                                      ;
; History:                                                              ;
;  14-Nov-1990 -by- Wendy Wu [wendywu]                                  ;
; Wrote it                                                              ;
;-----------------------------------------------------------------------;
;
;   cProc   divff
;
;           ;assert((eax != 0), "divff error: divide by 0")
;
;           sub     ebx,ecx                 ; subtract divisor's exp from dividend's
;           jo      divff_exit
;
;           mov     ecx,eax                 ; save divisor's mantissa
;           xor     eax,eax
;           shrd    eax,edx,2               ; prevent overflow, shift dividend
;           sar     edx,2                   ; right by 2
;
;           idiv    ecx
;           cCall   dNormalize
;           jz      divff_exit              ; eax = ecx = 0 if ZF = 1
;
;           neg     ecx
;           inc     ecx                     ; compensate for right shift by 2
;           inc     ecx
;           add     ecx,ebx                 ; add the exponent of the dividend
;
;   divff_exit:
;           cRet    divff
;   endProc divff
;
;---------------------------Public-Routine------------------------------;
; divff_c                                                               ;
;                                                                       ;
;   Divide an EFLOAT number by another.  The result overwrites the      ;
;   dividend.                                                           ;
;                                                                       ;
; Arguments:                                                            ;
;       IN OUT pDvdend  points to the EFLOAT dividend.                  ;
;       IN     pDvsor   points to the EFLOAT divisor.                   ;
; Returns:                                                              ;
;       EAX = 1 if success                                              ;
; Error Returns:                                                        ;
;       EAX = 0 if overflow or zero divisor                             ;
; Calls:                                                                ;
;       divff                                                           ;
; History:                                                              ;
;  Thu 19-Mar-1992 17:44:34 -by- Charles Whitmer [chuckwh]              ;
; Added 3 parameter entry point.  This gives us better C++ code.        ;
;                                                                       ;
;  14-Nov-1990 -by- Wendy Wu [wendywu]                                  ;
; Wrote it                                                              ;
;-----------------------------------------------------------------------;
;
;   cProc   divff_c,8,<          \
;           uses     ebx,        \
;           pDvdend: ptr EFLOAT, \
;           pDvsor:  ptr EFLOAT  >
;
;           mov     ebx,pDvsor
;           mov     eax,[ebx].ef_lMant
;           or      eax,eax
;           jz      divff_error
;
;           mov     ecx,[ebx].ef_lExp
;           mov     ebx,pDvdend
;           mov     edx,[ebx].ef_lMant
;           mov     ebx,[ebx].ef_lExp
;
;           cCall   divff
;
;           mov     edx,pDvdend
;           mov     [edx].ef_lMant,eax
;           mov     [edx].ef_lExp,ecx
;
;           mov     eax,0
;           setno   al
;
;           cRet    divff_c
;
;   divff_error:
;           xor     eax,eax
;           cRet    divff_c
;
;   endProc divff_c
;
;   cProc   divff_old3_c,12,<         \
;           uses     ebx,        \
;           pRes:    ptr EFLOAT, \
;           pDvdend: ptr EFLOAT, \
;           pDvsor:  ptr EFLOAT  >
;
;           mov     ebx,pDvsor
;           mov     eax,[ebx].ef_lMant
;           or      eax,eax
;           jz      short divff_old3_error
;
;           mov     ecx,[ebx].ef_lExp
;           mov     ebx,pDvdend
;           mov     edx,[ebx].ef_lMant
;           mov     ebx,[ebx].ef_lExp
;
;           cCall   divff
;
;           mov     edx,pRes
;           jo      short @F
;           mov     [edx].ef_lMant,eax
;           mov     [edx].ef_lExp,ecx
;   @@:     mov     eax,edx
;           cRet    divff_old3_c
;
;   divff_old3_error:
;           mov     eax,pRes
;           cRet    divff_old3_c
;   endProc divff_old3_c
;
;------------------------------Public-Routine------------------------------;
; divff3_c                                                                 ;
;                                                                          ;
; A newer concept for EFLOAT division.  This makes maximal use of the      ;
; assumption that the given numbers are normalized.  I think the older     ;
; method spends a lot of time in dNormalize for no reason.                 ;
;                                                                          ;
;  Fri 14-Jan-1994 -by- Bodin Dresevic [BodinD]                            ;
; update: added all the comments while trying to debug this routine        ;
;                                                                          ;
;  Sun 22-Mar-1992 02:04:09 -by- Charles Whitmer [chuckwh]                 ;
; Wrote it.                                                                ;
;--------------------------------------------------------------------------;

cProc   divff3_c,12,<         \
        uses     ebx esi,    \
        pRes:    ptr EFLOAT, \
        pNum:    ptr EFLOAT, \
        pDenom:  ptr EFLOAT  >

        mov     ebx,pNum
        mov     esi,[ebx].ef_lExp
        mov     ecx,[ebx].ef_lMant
        or      ecx,ecx
        jz      short divff3_zero
        mov     eax,ecx
        cdq
        xor     ecx,edx
        sub     ecx,edx             ; ecx = |MantN|
        mov     ebx,pDenom
        sub     esi,[ebx].ef_lExp   ; esi = ExpN - ExpD == expR
        jo      short divff3_error
        mov     eax,[ebx].ef_lMant
        mov     ebx,edx             ; save sgn(MantN) into ebx
        cdq
        xor     eax,edx
        sub     eax,edx             ; eax = |MantD|
        xor     ebx,edx             ; ebx = sgn(MantN) * sgn(MantD)
        mov     edx,ecx
        mov     ecx,eax
        add     ecx,ecx             ; ecx = 2 * |MantD|
        jz      short divff3_error
        xor     eax,eax             ; edx:eax = |MantN|:0, ecx = 2 * |MantD|
        div     ecx                 ; the result in eax, remainder in edx
        shr     ecx,1               ; ecx = |MantD|
        cmp     ecx,edx             ; if remainder <= |MantD| need roundoff bit
        sbb     edx,edx
        neg     edx                 ; edx = roundoff bit
        xor     ecx,ecx             ; ecx = 0, ecx will be used to store correction to ExpR
        or      eax,eax             ; eax = unnormalized |MantR|, may need to clear sign bit
        setns   cl                  ; cl = 1 iff sign bit in eax NOT set
        and     edx,ecx             ; fix roundoff bit
        xor     cl,1                ; cl = 1 iff sign bit in eax IS set
        shr     eax,cl              ; normalize eax, will set CF iff least significant bit is set in eax before shr
        adc     eax,edx             ; round the |MantR|, add CF if it is set
        inc     ecx                 ; because we divided by 2 * |MantD| above
        add     esi,ecx             ; adjust expR
        jo      short divff3_error
        xor     eax,ebx             ; restore the sign of MantR
        sub     eax,ebx             ; eax = MantR
        mov     ebx,pRes
        mov     [ebx].ef_lMant,eax
        mov     [ebx].ef_lExp,esi
        mov     eax,ebx
        cRet    divff3_c

divff3_zero:
        mov     eax,pRes
        mov     [eax].ef_lMant,ecx
        mov     [eax].ef_lExp,ecx
        cRet    divff3_c

divff3_error:
  if DBG
        push    offset MATH_DivideError
        call    DbgPrint
        add     esp,4
        int     3
  endif
        mov     eax,pRes
        cRet    divff3_c
endProc divff3_c

;------------------------------Public--Routine-----------------------------;
; void sqrtf2_c (pRes,pef)                                                 ;
;                                                                          ;
; Takes the square root of an EFLOAT                                       ;
;                                                                          ;
; History:                                                                 ;
;  Thu 19-Mar-1992 17:38:58 -by- Charles Whitmer [chuckwh]                 ;
; Added result pointer.  Removed 9 instructions from the calculation.      ;
; Doesn't change return value on error.                                    ;
;                                                                          ;
;   Tue 02-Apr-1991 11:45:09 -by- Kirk Olynyk [kirko]                      ;
; Uses Newton's method now.                                                ;
;                                                                          ;
;   Mon 25-Mar-1991 14:08:47 -by- Kirk Olynyk [kirko]                      ;
; Uses a loop instead of IREPT                                             ;
;                                                                          ;
;   Fri 01-Mar-1991 07:34:05 -by- Kirk Olynyk [kirko]                      ;
; Wrote it.                                                                ;
;--------------------------------------------------------------------------;

cProc   sqrtf2_c,8,<             \
        uses  esi edi ebx,       \
        pRes: ptr EFLOAT,        \
        pef:  ptr EFLOAT         >

        mov     esi,pef
        mov     edi,[esi].ef_lMant
        mov     ebx,[esi].ef_lExp          ; EDI:EBX = mant,exp

; quick out for zero

        mov     esi,pRes                ; ESI -> Result
        or      edi,edi
        js      short sqrtf_error
        jz      short sqrtf_early_out

; quick out for one

        mov     eax,ebx
        mov     edx,edi
        sub     eax,EXPONENT_OF_ONE
        sub     edx,MANTISSA_OF_ONE
        or      edx,eax
        jz      short sqrtf_early_out

; Calculate the exponent of the square root

        sar     ebx,1
        sbb     ecx,ecx             ; ECX = (exp is odd) ? FFFFFFFFh : 0h
        inc     ebx
        mov     [esi].ef_lExp,ebx      ; return the exponent

; The mantissa must be shifted. Calculate the shift factor
; CL = (exp is odd) ? 1 : 2

        add     cl,2

; Shift the mantissa, keep extra bits in ESI.

        xor     esi,esi             ; esi = 0
        shrd    esi,edi,cl
        shr     edi,cl              ; EDI = M / 2^shift_factor = P

; extract high and low word of the mantissa

        shld    ecx,edi,16          ; DI = lo word of P, CX = hi word of P

; recursion formula is x(n+1) = [x(n) + t/x(n)]/2, where we are trying to
; compute sqrt(t),  the value below has empirically proven to be a good guess for
; x(0) in our range of results [bodind]

; form zero'th guess for square root

        lea     ebx,[ecx+4000h]     ; BX:0000 = zeroth guess

; calculate 1'st guess to 16 bit accuracy

        mov     edx,ecx
        mov     eax,edi
        div     bx
        add     bx,ax
        rcr     bx,1                ; BX:0000 = 1'st guess

; calculate 2'nd guess to 16 bit accuracy

        mov     edx,ecx
        mov     eax,edi
        div     bx
        add     bx,ax
        rcr     bx,1                ; BX:0000 = 2'nd guess

; calculate 3'rd guess to 32 bit accuracy, division done with
; proper rounding [bodind]

        shl     ebx,16
        mov     edx,edi
        mov     eax,esi             ; recover the lost bits

; do division with  rounding, make sure that after adding 1/2 denom
; that carry bit if ehists is added properly to edx [bodind]

        mov     ecx,ebx
        shr     ecx,1
        add     eax,ecx
        adc     edx,0
        div     ebx

        add     ebx,eax
        rcr     ebx,1               ; EBX = 3'rd guess

        mov     esi,pRes            ; ESI -> to the result

; done except that maybe our result is not normalized properly

        or      ebx,ebx             ; too big a number, adjust mant and exp
        jns     short sqrtf_return_mantissa
        shr     ebx,1                         ; divide mantissa by 2
        inc     dword ptr [esi].ef_lExp       ; add one to the exponent

; return the mantissa

sqrtf_return_mantissa:

        mov     [esi].ef_lMant,ebx

sqrtf_error:
        mov     eax,esi
        cRet    sqrtf2_c

; Do early outs.

sqrtf_early_out:
        mov     [esi].ef_lMant,edi
        mov     [esi].ef_lExp,ebx
        mov     eax,esi
        cRet    sqrtf2_c
endProc sqrtf2_c

;------------------------------Public--Routine-----------------------------;
; VOID vEfToLfx(pefloat,plfx)                                              ;
;                                                                          ;
; Converts an EFLOAT to a 32.32 fix point number.                          ;
;                                                                          ;
; Warning:                                                                 ;
;   No checks are made to see if the EFLOAT can fit.                       ;
;                                                                          ;
; History:                                                                 ;
;  Tue 17-Mar-1992 00:32:48 -by- Charles Whitmer [chuckwh]                 ;
; Wrote it.                                                                ;
;--------------------------------------------------------------------------;

cProc    vEfToLfx,8,<                   \
    pefloat:    ptr EFLOAT,             \
    plfx:       ptr LARGE_INTEGER       >

; Load the EFLOAT.

    mov     ecx,pefloat
    mov     eax,[ecx].ef_lMant
    mov     ecx,[ecx].ef_lExp

; Sign extend into EDX.  The EFLOAT is now EDX.EAX * 2^ECX.

    cdq

; Decide about shifting.

    or      ecx,ecx
    jz      short saveit
    jl      short shift_right

; Shift it left.

    shld    edx,eax,cl
    shl     eax,cl
saveit:
    mov     ecx,plfx
    mov     [ecx].li_LowPart,eax
    mov     [ecx].li_HighPart,edx
    cRet    vEfToLfx

; Shift it right.

shift_right:
    neg     ecx
    shrd    eax,edx,cl
    sar     edx,cl
    mov     ecx,plfx
    mov     [ecx].li_LowPart,eax
    mov     [ecx].li_HighPart,edx
    cRet    vEfToLfx
endProc vEfToLfx

    end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\math\daytona\i386\xform.asm ===
page ,132
;------------------------------Module-Header----------------------------;
; Module Name: xform.asm                                                ;
;                                                                       ;
; The assembly version of xformer.cxx.  Contains the transform related  ;
; calculation routines.  This is the NT version of ChuckWh's            ;
; xformers.asm for PM.                                                  ;
;                                                                       ;
; Created: 13-Nov-1990 13:42:27                                         ;
; Author: Wendy Wu [wendywu]                                            ;
;                                                                       ;
; Copyright (c) 1990 Microsoft Corporation                              ;
;-----------------------------------------------------------------------;

        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include callconv.inc
        include gdii386.inc
        .list

        .code

EXTRNP  mulff,0
EXTRNP  addff,0

;-----------------------------------------------------------------------;
; MULEFBYDWORD
;
; Multiply an EFLOAT number by a 32-bit number.  The result is kept in
; the FIX type.  If the 32-bit number is a LONG integer, the EFLOAT is
; a "FIX number in EFLOAT type".  If the 32-bit is a FIX number, the
; EFLOAT is a "LONG integer in EFLOAT type".  Note that this macro can
; be invoked with eax and edx exchanged with the same result.
;
; Entry:
;       EDX = LONG integer      or             EDX = FIX number
;       EAX = EFLOAT.lMant                     EAX = EFLOAT.lMant
;       ECX = EFLOAT.lExp(already added by 4)  ECX = EFLOAT.lExp
; Returns:
;       EAX = product in FIX type
;
; Registers Destroyed:
;       ECX,EDX
;-----------------------------------------------------------------------;

; CR!!! If we can have a tight loop to check for overflow before we
; CR!!! do the conversion, it might be faster.  Not sure which way to
; CR!!! go.  Will have to decide at performance tuning time.

MULEFBYDWORD MACRO  err_out, NoRound
        LOCAL   shift31orfewer
	LOCAL	done
        neg     ecx
        imul    edx                 ; EDX.EAX
        add     ecx,32              ; If we shift EDX.EAX right by 32-exp
                                    ; then we get the final result in EAX

        jz 	short done	    ; no shift, we're done.
        jc 	short shift31orfewer
        js      err_out             ; overflow if 32-exp < 0

; we are here if ecx >= 32.  return 0 if ecx > 62.

        cmp     ecx,63		    
        jb      @F
        xor     eax,eax		    ; shift by too much, result will be zero
	jmp	short done
@@:
        shrd	eax, edx, 31
	sar	edx, 31
	sub	ecx, 31

shift31orfewer:                            

        shrd    eax,edx,cl          ; shift edx:eax right by cl bits
    IFB <NoRound>
	adc	eax, 0		    ; and round appropriately
	jo	err_out		    ; overflow?
    ENDIF

        sar     edx,cl              ; check for overflow
        adc     edx,0
	jnz	err_out

done:
ENDM

;-----------------------------Public-Routine----------------------------;
; lCvt (ef,ll)                                                          ;
;                                                                       ;
; A simple routine to scale a long by an EFLOAT.                        ;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
;   EFLOAT ef       The floating point multiplier.                      ;
;   LONG   ll       The long to multiply.                               ;
;                                                                       ;
; Entry:                                                                ;
;       None                                                            ;
; Returns:                                                              ;
;       EAX = product                                                   ;
; Error Returns:                                                        ;
;       None.                                                           ;
; Registers Destroyed:                                                  ;
;       ECX,EDX                                                         ;
; Calls:                                                                ;
;       None                                                            ;
; History:                                                              ;
;  Wed 26-May-1993 00:00:00 -by- Paul Butzi and Charles Whitmer
; changed to call MULEFBYDWORD, which we recently fixed
;
;  Wed 18-Mar-1992 07:31:13 -by- Charles Whitmer [chuckwh]              ;
; Added the simple shifting case.  I think we can call this case faster ;
; than we could recognize in C that a shift is required.                ;
;                                                                       ;
;  Thu 12-Mar-1992 20:35:03 -by- Charles Whitmer [chuckwh]              ;
; Created by pirating MULEFBYDWORD.                                     ;
;-----------------------------------------------------------------------;

lCvt_frame struc
pRet    dd      ?                   ; Return address
ef      db      size EFLOAT dup (?) ; EFLOAT multiplier
ll      dd      ?                   ; LONG multiplier
lCvt_frame ends

cvtargs equ (size lCvt_frame / 4 - 1)

cPublicProc lCvt,cvtargs
        mov     eax,dword ptr [esp].ef.ef_lMant
        mov     ecx,dword ptr [esp].ef.ef_lExp
	mov	edx, dword ptr [esp].ll
	MULEFBYDWORD lCvtNext
lCvtNext:
        stdRET  lCvt
stdENDP lCvt


;-----------------------------Public-Routine----------------------------;
; bCvtPts1
;
;   Apply the given transform matrix to a list of points.
;
; Arguments:
;       pmx       points to the matrix
;       pptl      points to the list of points
;       cptl      number of points in the list
;
; Entry:
;       None
; Returns:
;       EAX = 1
; Error Returns:
;       EAX = 0
; Registers Destroyed:
;       ECX,EDX
; Calls:
;       None
; History:
;  17-Dec-1992 -by- Wendy Wu [wendywu]
; Created.
;-----------------------------------------------------------------------;

cPublicProc bCvtPts1,3,<        \
        uses       ebx esi edi, \
        pmx:       ptr MATRIX,  \
        pptl:      ptr POINTL,  \
        cptl:      dword        >

        local   fxResult:dword

        mov     esi,pptl
        mov     ebx,pmx

        mov     ecx,[ebx].mx_flAccel
        and     ecx,XFORM_SCALE+XFORM_UNITY+XFORM_FORMAT_LTOFX
        jmp     accelerator_table_pts1[ecx*4]

.errnz (size POINTL) - 8

xform_non_units_ltofx_pts1::
        mov     edi,cptl

; ESI = points to the source array of points
; EDI = number of points in the array
; EBX = points to the matrix

        align   4
xform_non_units_ltofx_loop_pts1:

; compute x'

        mov     edx,[esi].ptl_x             ; get source x
        mov     ecx,[ebx].mx_efM11.ef_lExp
        mov     eax,[ebx].mx_efM11.ef_lMant
        MULEFBYDWORD overflow_pts1, 1       ; x*M11

        add     eax,[ebx].mx_fxDx           ; x*M11+Dx
        add     eax,8                       ; FXTOLROUND
        sar     eax,4

; compute y'

        mov     edx,[esi].ptl_y             ; get source y
        mov     [esi].ptl_x,eax             ; store x'
        mov     ecx,[ebx].mx_efM22.ef_lExp
        mov     eax,[ebx].mx_efM22.ef_lMant
        MULEFBYDWORD overflow_pts1, 1       ; y*M22

        add     eax,[ebx].mx_fxDy           ; y*M22+Dy
        add     eax,8                       ; FXTOLROUND
        sar     eax,4
        mov     [esi].ptl_y,eax             ; store y'
        add     esi,SIZE POINTL

        dec     edi
        jnz     xform_non_units_lTofx_loop_pts1
        mov     eax,1
        stdRET  bCvtPts1

        align   4
xform_units_ltofx_pts1::
        mov     eax,[ebx].mx_fxDx
        mov     edx,[ebx].mx_fxDy
        add     eax,8                       ; FXTOLROUND
        add     edx,8
        sar     eax,4
        sar     edx,4

        mov     ecx,cptl

; ESI = points to the array of points
; ECX = number of points in the array
; EAX = x translation
; EDX = y translation

        align   4
xform_units_ltofx_loop_pts1:
        add     [esi].ptl_x,eax                 ; x' = x + Dx
        add     [esi].ptl_y,edx                 ; y' = y + Dy
        add     esi,SIZE POINTL

        dec     ecx
        jnz short   xform_units_ltofx_loop_pts1
        mov     eax,1
        stdRET  bCvtPts1

xform_general_ltofx_pts1::
        mov     edi,cptl

; ESI = points to the source array of points
; EDI = number of points in the array
; EBX = points to the matrix

xform_general_ltofx_loop_pts1:

; compute x'

        mov     edx,[esi].ptl_x             ; get source x
        mov     ecx,[ebx].mx_efM11.ef_lExp
        mov     eax,[ebx].mx_efM11.ef_lMant
        MULEFBYDWORD overflow_pts1, 1       ; x * M11
        mov     fxResult,eax

        mov     edx,[esi].ptl_y             ; get source y
        mov     ecx,[ebx].mx_efM21.ef_lExp
        mov     eax,[ebx].mx_efM21.ef_lMant
        MULEFBYDWORD overflow_pts1, 1       ; y*M21

        add     eax,fxResult                ; x*M11 + y*M21
        add     eax,[ebx].mx_fxDx           ; x*M11 + y*M21 + Dx
        add     eax,8                       ; FXTOLROUND
        sar     eax,4

; compute y'

        mov     edx,[esi].ptl_x             ; get source x
        mov     [esi].ptl_x,eax             ; store x'

        mov     ecx,[ebx].mx_efM12.ef_lExp
        mov     eax,[ebx].mx_efM12.ef_lMant
        MULEFBYDWORD overflow_pts1, 1       ; x * M12
        mov     fxResult,eax

        mov     edx,[esi].ptl_y             ; get source y
        mov     ecx,[ebx].mx_efM22.ef_lExp
        mov     eax,[ebx].mx_efM22.ef_lMant
        MULEFBYDWORD overflow_pts1, 1       ; y * M22

        add     eax,fxResult                ; x*M12 + y*M22
        add     eax,[ebx].mx_fxDy           ; x*M12 + y*M22 + Dy
        add     eax,8                       ; FXTOLROUND
        sar     eax,4
        mov     [esi].ptl_y,eax             ; store y'

        add     esi,SIZE POINTL

        dec     edi
        jnz     xform_general_ltofx_loop_pts1
        mov     eax,1
        stdRET  bCvtPts1

xform_non_units_fxtol_pts1::
        mov     edi,cptl

; ESI = points to the source array of points
; EDI = number of points in the array
; EBX = points to the matrix

        align   4
xform_non_units_fxtol_loop_pts1:

; compute x'

        mov     edx,[esi].ptl_x             ; get source x
        mov     ecx,[ebx].mx_efM11.ef_lExp
        sal     edx,4                       ; LTOFX
        mov     eax,[ebx].mx_efM11.ef_lMant
        MULEFBYDWORD overflow_pts1          ; x*M11

        add     eax,[ebx].mx_fxDx           ; x*M11+Dx

; compute y'

        mov     edx,[esi].ptl_y             ; get source y
        mov     [esi].ptl_x,eax             ; store x'
        sal     edx,4                       ; LTOFX
        mov     ecx,[ebx].mx_efM22.ef_lExp
        mov     eax,[ebx].mx_efM22.ef_lMant
        MULEFBYDWORD overflow_pts1          ; y*M22

        add     eax,[ebx].mx_fxDy           ; y*M22+Dy
        mov     [esi].ptl_y,eax             ; store y'
        add     esi,SIZE POINTL

        dec     edi
        jnz     xform_non_units_fxtol_loop_pts1
        mov     eax,1
        stdRET  bCvtPts1

        align   4
xform_units_fxtol_pts1::
        mov     eax,[ebx].mx_fxDx
        mov     edx,[ebx].mx_fxDy

        mov     ecx,cptl

; ESI = points to the array of points
; ECX = number of points in the array
; EAX = x translation
; EDX = y translation

        align   4
xform_units_fxtol_loop_pts1:
        add     [esi].ptl_x,eax                 ; x' = x + Dx
        add     [esi].ptl_y,edx                 ; y' = y + Dy
        add     esi,SIZE POINTL

        dec     ecx
        jnz short   xform_units_fxtol_loop_pts1
        mov     eax,1
        stdRET  bCvtPts1


xform_general_fxtol_pts1::
        mov     edi,cptl

; ESI = points to the source array of points
; EDI = number of points in the array
; EBX = points to the matrix

xform_general_fxtol_loop_pts1:

; compute x'

        mov     edx,[esi].ptl_x             ; get source x
        mov     ecx,[ebx].mx_efM11.ef_lExp
        sal     edx,4                       ; LTOFX
        mov     eax,[ebx].mx_efM11.ef_lMant
        MULEFBYDWORD overflow_pts1          ; x * M11
        mov     fxResult,eax

        mov     edx,[esi].ptl_y             ; get source y
        mov     ecx,[ebx].mx_efM21.ef_lExp
        sal     edx,4                       ; LTOFX
        mov     eax,[ebx].mx_efM21.ef_lMant
        MULEFBYDWORD overflow_pts1          ; y*M21

        add     eax,fxResult                ; x*M11 + y*M21
        add     eax,[ebx].mx_fxDx           ; x*M11 + y*M21 + Dx

; compute y'

        mov     edx,[esi].ptl_x             ; get source x
        mov     [esi].ptl_x,eax             ; store x'

        sal     edx,4                       ; LTOFX
        mov     ecx,[ebx].mx_efM12.ef_lExp
        mov     eax,[ebx].mx_efM12.ef_lMant
        MULEFBYDWORD overflow_pts1          ; x * M12
        mov     fxResult,eax

        mov     edx,[esi].ptl_y             ; get source y
        mov     ecx,[ebx].mx_efM22.ef_lExp
        sal     edx,4                       ; LTOFX
        mov     eax,[ebx].mx_efM22.ef_lMant
        MULEFBYDWORD overflow_pts1          ; y * M22

        add     eax,fxResult                ; x*M12 + y*M22
        add     eax,[ebx].mx_fxDy           ; x*M12 + y*M22 + Dy
        mov     [esi].ptl_y,eax             ; store y'

        add     esi,SIZE POINTL

        dec     edi
        jnz     xform_general_fxtol_loop_pts1
        mov     eax,1
        stdRET  bCvtPts1

overflow_pts1:
        xor     eax,eax
        stdRET  bCvtPts1


ifdef   DOS_PLATFORM
.errnz XFORM_SCALE - 1
.errnz XFORM_UNITY - 2
.errnz XFORM_Y_NEG - 4
.errnz XFORM_FORMAT_LTOFX - 8

accelerator_table_pts1  label   dword                   ;   ltofx    -y   units scale
        dd      offset FLAT:xform_general_fxtol_pts1    ;     0       0     0     0
        dd      offset FLAT:xform_non_units_fxtol_pts1  ;     0       0     0     1
        dd      offset FLAT:xform_rip_pts               ;     0       0     1     0
        dd      offset FLAT:xform_units_fxtol_pts1      ;     0       0     1     1
        dd      offset FLAT:xform_rip_pts               ;     0       0     0     0
        dd      offset FLAT:xform_rip_pts               ;     0       0     0     1
        dd      offset FLAT:xform_rip_pts               ;     0       0     1     0
        dd      offset FLAT:xform_rip_pts               ;     0       0     1     1

        dd      offset FLAT:xform_general_ltofx_pts1    ;     1       0     0     0
        dd      offset FLAT:xform_non_units_ltofx_pts1  ;     1       0     0     1
        dd      offset FLAT:xform_rip_pts               ;     1       0     1     0
        dd      offset FLAT:xform_units_ltofx_pts1      ;     1       0     1     1
        dd      offset FLAT:xform_rip_pts               ;     1       1     0     0
        dd      offset FLAT:xform_rip_pts               ;     1       1     0     1
        dd      offset FLAT:xform_rip_pts               ;     1       1     1     0
        dd      offset FLAT:xform_rip_pts               ;     1       1     1     1

endif;  DOS_PLATFORM

stdENDP bCvtPts1


ifndef   DOS_PLATFORM
.errnz XFORM_SCALE - 1
.errnz XFORM_UNITY - 2
.errnz XFORM_Y_NEG - 4
.errnz XFORM_FORMAT_LTOFX - 8

accelerator_table_pts   label   dword       ;   ltofx    -y   units scale
        dd      xform_general_pts           ;     0       0     0     0
        dd      xform_non_units_pts         ;     0       0     0     1
        dd      xform_rip_pts               ;     0       0     1     0
        dd      xform_units_fxtol_pts       ;     0       0     1     1
        dd      xform_rip_pts               ;     0       1     0     0
        dd      xform_rip_pts               ;     0       1     0     1
        dd      xform_rip_pts               ;     0       1     1     0
        dd      xform_units_neg_y_fxtol_pts ;     0       1     1     1

        dd      xform_general_pts           ;     1       0     0     0
        dd      xform_non_units_pts         ;     1       0     0     1
        dd      xform_rip_pts               ;     1       0     1     0
        dd      xform_units_ltofx_pts       ;     1       0     1     1
        dd      xform_rip_pts               ;     1       1     0     0
        dd      xform_rip_pts               ;     1       1     0     1
        dd      xform_rip_pts               ;     1       1     1     0
        dd      xform_units_neg_y_ltofx_pts ;     1       1     1     1

accelerator_table_pts1  label   dword       ;   ltofx    -y   units scale
        dd      xform_general_fxtol_pts1    ;     0       x     0     0
        dd      xform_non_units_fxtol_pts1  ;     0       x     0     1
        dd      xform_rip_pts               ;     0       x     1     0
        dd      xform_units_fxtol_pts1      ;     0       x     1     1
        dd      xform_rip_pts               ;     0       x     0     0
        dd      xform_rip_pts               ;     0       x     0     1
        dd      xform_rip_pts               ;     0       x     1     0
        dd      xform_rip_pts               ;     0       x     1     1

        dd      xform_general_ltofx_pts1    ;     1       x     0     0
        dd      xform_non_units_ltofx_pts1  ;     1       x     0     1
        dd      xform_rip_pts               ;     1       x     1     0
        dd      xform_units_ltofx_pts1      ;     1       x     1     1
        dd      xform_rip_pts               ;     1       x     0     0
        dd      xform_rip_pts               ;     1       x     0     1
        dd      xform_rip_pts               ;     1       x     1     0
        dd      xform_rip_pts               ;     1       x     1     1

accelerator_table_vts   label   dword       ;    -y     units scale
        dd      xform_general_vts           ;     0       0     0
        dd      xform_non_units_vts         ;     0       0     1
        dd      xform_rip_vts               ;     0       1     0
        dd      xform_rip_vts               ;     0       1     1 handled by caller
        dd      xform_rip_vts               ;     1       0     0
        dd      xform_rip_vts               ;     1       0     1
        dd      xform_rip_vts               ;     1       1     0
        dd      xform_units_neg_y_ltofx_vts ;     1       1     1


endif;  DOS_PLATFORM

;-----------------------------Public-Routine----------------------------;
; bCvtPts
;
;   Apply the given transform matrix to a list of points.
;
; Arguments:
;       pmx       points to the matrix
;       pptlSrc   points to the source list of points
;       pptlDst   points to the dest list of points
;       cptl      number of points in the list
;       pptlSrc, pptlDst can both point to the same array of points
;
; Entry:
;       None
; Returns:
;       EAX = 1
; Error Returns:
;       EAX = 0
; Registers Destroyed:
;       ECX,EDX
; Calls:
;       None
; History:
;  13-Nov-1990 -by- Wendy Wu [wendywu]
; Created.
;-----------------------------------------------------------------------;

cPublicProc bCvtPts,4,<         \
        uses       ebx esi edi, \
        pmx:       ptr MATRIX,  \
        pptlSrc:   ptr POINTL,  \
        pptlDst:   ptr POINTL,  \
        cptl:      dword        >

        local   fxResult      :dword

        mov     esi,pptlSrc
        mov     edi,pptlDst
        mov     ebx,pmx

        mov     ecx,[ebx].mx_flAccel
        and     ecx,XFORM_SCALE+XFORM_UNITY+XFORM_Y_NEG+XFORM_FORMAT_LTOFX
        jmp     accelerator_table_pts[ecx*4]

.errnz (size POINTL) - 8

        align   4
xform_non_units_pts::

; ESI = points to the source array of points
; EDI = points to the destination array of points
; EBX = points to the matrix

        align   4
xform_non_units_loop_pts:

; compute x'

        mov     edx,[esi]                   ; get source x
        add     esi,4
        mov     ecx,[ebx].mx_efM11.ef_lExp
        mov     eax,[ebx].mx_efM11.ef_lMant
        MULEFBYDWORD overflow_pts           ; x*M11

        add     eax,[ebx].mx_fxDx           ; x*M11+Dx
        mov     [edi],eax                   ; store x'
        add     edi,4

; compute y'

        mov     edx,[esi]                   ; get source y
        add     esi,4
        mov     ecx,[ebx].mx_efM22.ef_lExp
        mov     eax,[ebx].mx_efM22.ef_lMant
        MULEFBYDWORD overflow_pts           ; y*M22

        add     eax,[ebx].mx_fxDy           ; y*M22+Dy
        mov     [edi],eax                   ; store y'
        add     edi,4

        dec     cptl
        jnz     xform_non_units_loop_pts
        mov     eax,1
        stdRET  bCvtPts

xform_rip_pts::
; should RIP here!!!

overflow_pts:
        xor     eax,eax
        stdRET  bCvtPts

        align   4
xform_units_ltofx_pts::
        mov     ecx,cptl
        mov     edx,[ebx].mx_fxDy
        mov     ebx,[ebx].mx_fxDx

; ESI = points to the source array of points
; EDI = points to the destination array of points
; ECX = number of points in the array
; EBX = x translation
; EDX = y translation

        align   4
xform_units_ltofx_loop_pts:
        mov     eax,[esi]
        add     esi,4
        sal     eax,4
        add     eax,ebx                     ; x' = x + Dx
        mov     [edi],eax                   ; store x'
        add     edi,4

        mov     eax,[esi]
        add     esi,4
        sal     eax,4
        add     eax,edx                     ; y' = y + Dy
        mov     [edi],eax                   ; store y'
        add     edi,4

        dec     ecx
        jnz short   xform_units_ltofx_loop_pts
        mov     eax,1
        stdRET  bCvtPts

        align   4
xform_units_neg_y_ltofx_pts::
        mov     ecx,cptl
        mov     edx,[ebx].mx_fxDy
        mov     ebx,[ebx].mx_fxDx

; ESI = points to the source array of points
; EDI = points to the destination array of points
; ECX = number of points in the array
; EBX = x translation
; EDX = y translation

        align   4
xform_units_neg_y_ltofx_loop_pts:
        mov     eax,[esi]
        add     esi,4
        sal     eax,4
        add     eax,ebx                     ; x' = x + Dx
        mov     [edi],eax                   ; store x'
        add     edi,4

        mov     eax,[esi]
        add     esi,4
        sal     eax,4
        neg     eax                         ; y' = -y + Dy
        add     eax,edx
        mov     [edi],eax                   ; store y'
        add     edi,4

        dec     ecx
        jnz short   xform_units_neg_y_ltofx_loop_pts
        mov     eax,1
        stdRET  bCvtPts

overflow1_pts:
        jmp     overflow_pts

        align   4
xform_units_fxtol_pts::
        mov     ecx,cptl
        mov     edx,[ebx].mx_fxDy
        mov     ebx,[ebx].mx_fxDx

; ESI = points to the source array of points
; EDI = points to the destination array of points
; ECX = number of points in the array
; EBX = x translation
; EDX = y translation

        align   4
xform_units_fxtol_loop_pts:
        mov     eax,[esi]
        add     esi,4
        add     eax,8                       ; FXTOLROUND()
        sar     eax,4
        add     eax,ebx                     ; x' = x + Dx
        mov     [edi],eax                   ; store x'
        add     edi,4

        mov     eax,[esi]
        add     esi,4
        add     eax,8                       ; FXTOLROUND()
        sar     eax,4
        add     eax,edx                     ; y' = y + Dy
        mov     [edi],eax                   ; store y'
        add     edi,4

        dec     ecx
        jnz short   xform_units_fxtol_loop_pts
        mov     eax,1
        stdRET  bCvtPts

        align   4
xform_units_neg_y_fxtol_pts::
        mov     ecx,cptl
        mov     edx,[ebx].mx_fxDy
        mov     ebx,[ebx].mx_fxDx

; ESI = points to the source array of points
; EDI = points to the destination array of points
; ECX = number of points in the array
; EBX = x translation
; EDX = y translation

        align   4
xform_units_neg_y_fxtol_loop_pts:
        mov     eax,[esi]
        add     esi,4
        add     eax,8                       ; FXTOLROUND()
        sar     eax,4
        add     eax,ebx                     ; x' = x + Dx
        mov     [edi],eax                   ; store x'
        add     edi,4

        mov     eax,[esi]
        add     esi,4
        neg     eax                         ; y' = -y
        add     eax,8                       ; FXTOLROUND()
        sar     eax,4
        add     eax,edx                     ; y' = -y + Dy
        mov     [edi],eax                   ; store y'
        add     edi,4

        dec     ecx
        jnz short   xform_units_neg_y_fxtol_loop_pts
        mov     eax,1
        stdRET  bCvtPts

overflow2_pts:
        jmp     overflow_pts

xform_general_pts::

; ESI = points to the source array of points
; EDI = points to the dest array of points
; EBX = points to the matrix

xform_general_loop_pts:

; compute x'

        mov     edx,[esi].ptl_x             ; get source x
        mov     ecx,[ebx].mx_efM11.ef_lExp
        mov     eax,[ebx].mx_efM11.ef_lMant
        MULEFBYDWORD overflow2_pts          ; x * M11
        mov     fxResult,eax

        mov     edx,[esi].ptl_y             ; get source y
        mov     ecx,[ebx].mx_efM21.ef_lExp
        mov     eax,[ebx].mx_efM21.ef_lMant
        MULEFBYDWORD overflow2_pts          ; y*M21

        add     eax,fxResult                ; x*M11 + y*M21
        add     eax,[ebx].mx_fxDx           ; x*M11 + y*M21 + Dx

; compute y'

        mov     edx,[esi].ptl_x             ; get source x
        mov     [edi].ptl_x,eax             ; store x'

        mov     ecx,[ebx].mx_efM12.ef_lExp
        mov     eax,[ebx].mx_efM12.ef_lMant
        MULEFBYDWORD overflow3_pts          ; x * M12
        mov     fxResult,eax

        mov     edx,[esi].ptl_y             ; get source y
        mov     ecx,[ebx].mx_efM22.ef_lExp
        mov     eax,[ebx].mx_efM22.ef_lMant
        MULEFBYDWORD overflow3_pts          ; y * M22

        add     eax,fxResult                ; x*M12 + y*M22
        add     eax,[ebx].mx_fxDy           ; x*M12 + y*M22 + Dy

        mov     [edi].ptl_y,eax             ; store y'

        add     esi,SIZE POINTL
        add     edi,SIZE POINTL

        dec     cptl
        jnz     xform_general_loop_pts
        mov     eax,1
        stdRET  bCvtPts

overflow3_pts:
        jmp     overflow_pts

ifdef   DOS_PLATFORM
.errnz XFORM_SCALE - 1
.errnz XFORM_UNITY - 2
.errnz XFORM_Y_NEG - 4
.errnz XFORM_FORMAT_LTOFX - 8

accelerator_table_pts   label   dword                   ; ltofx -y units simple
        dd      offset FLAT:xform_general_pts           ;   0    0   0     0
        dd      offset FLAT:xform_non_units_pts         ;   0    0   0     1
        dd      offset FLAT:xform_rip_pts               ;   0    0   1     0
        dd      offset FLAT:xform_units_fxtol_pts       ;   0    0   1     1
        dd      offset FLAT:xform_rip_pts               ;   0    1   0     0
        dd      offset FLAT:xform_rip_pts               ;   0    1   0     1
        dd      offset FLAT:xform_rip_pts               ;   0    1   1     0
        dd      offset FLAT:xform_units_neg_y_fxtol_pts ;   0    1   1     1

        dd      offset FLAT:xform_general_pts           ;   1    0   0     0
        dd      offset FLAT:xform_non_units_pts         ;   1    0   0     1
        dd      offset FLAT:xform_rip_pts               ;   1    0   1     0
        dd      offset FLAT:xform_units_ltofx_pts       ;   1    0   1     1
        dd      offset FLAT:xform_rip_pts               ;   1    1   0     0
        dd      offset FLAT:xform_rip_pts               ;   1    1   0     1
        dd      offset FLAT:xform_rip_pts               ;   1    1   1     0
        dd      offset FLAT:xform_units_neg_y_ltofx_pts ;   1    1   1     1
endif;  DOS_PLATFORM

stdENDP bCvtPts

;-----------------------------Public-Routine----------------------------;
; bCvtVts
;
;   Apply the given transform matrix to a list of vectors.
;
; Arguments:
;       pmx       points to the matrix
;       pvtlSrc   points to the source list of vectors
;       pvtlDst   points to the dest list of vectors
;       cvtl      number of vectors in the list
;       pvtlSrc, pvtlDst can both point to the same array of vectors
;
; Entry:
;       None
; Returns:
;       EAX = 1
; Error Returns:
;       EAX = 0
; Registers Destroyed:
;       ECX,EDX
; Calls:
;       None
; History:
;  28-Jan-1992 -by- Wendy Wu [wendywu]
; Created.
;-----------------------------------------------------------------------;

cPublicProc bCvtVts,4,<         \
        uses       ebx esi edi, \
        pmx:       ptr MATRIX,  \
        pvtlSrc:   ptr VECTORL, \
        pvtlDst:   ptr VECTORL, \
        cvtl:      dword        >

        local   fxResult      :dword

        mov     esi,pvtlSrc
        mov     edi,pvtlDst
        mov     ebx,pmx

        mov     ecx,[ebx].mx_flAccel
        and     ecx,XFORM_SCALE+XFORM_UNITY+XFORM_Y_NEG
        jmp     accelerator_table_vts[ecx*4]

.errnz (size POINTL) - 8

        align   4
xform_non_units_vts::

; ESI = points to the source array of vectors
; EDI = points to the destination array of vectors
; EBX = points to the matrix

xform_non_units_loop_vts:

        mov     edx,[esi]                   ; get source x
        add     esi,4
        mov     ecx,[ebx].mx_efM11.ef_lExp
        mov     eax,[ebx].mx_efM11.ef_lMant
        MULEFBYDWORD overflow_vts           ; x*M11
        mov     [edi],eax                   ; store x'
        add     edi,4

        mov     edx,[esi]                   ; get source y
        add     esi,4
        mov     ecx,[ebx].mx_efM22.ef_lExp
        mov     eax,[ebx].mx_efM22.ef_lMant
        MULEFBYDWORD overflow_vts           ; y*M22
        mov     [edi],eax                   ; store y'
        add     edi,4

        dec     cvtl
        jnz     xform_non_units_loop_vts
        mov     eax,1
        stdRET  bCvtVts

xform_rip_vts::
; should RIP here!!!

overflow_vts:
        xor     eax,eax
        stdRET  bCvtVts

        align   4
xform_units_neg_y_ltofx_vts::
        mov     ecx,cvtl

; ESI = points to the source array of vectors
; EDI = points to the destination array of vectors
; ECX = number of points in the array

        align   4
xform_units_neg_y_ltofx_loop_vts:
        mov     eax,[esi]
        add     esi,4
        sal     eax,4
        mov     [edi],eax                   ; store x'
        add     edi,4

        mov     eax,[esi]
        add     esi,4
        sal     eax,4
        neg     eax                         ; y' = -y + Dy
        mov     [edi],eax                   ; store y'
        add     edi,4

        dec     ecx
        jnz short   xform_units_neg_y_ltofx_loop_vts
        mov     eax,1
        stdRET  bCvtVts

overflow1_vts:
        jmp     overflow_vts

xform_general_vts::

; ESI = points to the source array of vectors
; EDI = points to the dest array of vectors
; EBX = points to the matrix

xform_general_loop_vts:

; compute x'

        mov     edx,[esi].vl_x              ; get source x
        mov     ecx,[ebx].mx_efM11.ef_lExp
        mov     eax,[ebx].mx_efM11.ef_lMant
        MULEFBYDWORD overflow1_vts          ; x * M11
        mov     fxResult,eax

        mov     edx,[esi].vl_y              ; get source y
        mov     ecx,[ebx].mx_efM21.ef_lExp
        mov     eax,[ebx].mx_efM21.ef_lMant
        MULEFBYDWORD overflow1_vts          ; y*M21

        add     eax,fxResult                ; x*M11 + y*M21

; compute y'

        mov     edx,[esi].vl_x              ; get source x
        mov     [edi].vl_x,eax              ; store x'

        mov     ecx,[ebx].mx_efM12.ef_lExp
        mov     eax,[ebx].mx_efM12.ef_lMant
        MULEFBYDWORD overflow2_vts          ; x * M12
        mov     fxResult,eax

        mov     edx,[esi].vl_y              ; get source y
        mov     ecx,[ebx].mx_efM22.ef_lExp
        mov     eax,[ebx].mx_efM22.ef_lMant
        MULEFBYDWORD overflow2_vts          ; y * M22

        add     eax,fxResult                ; x*M12 + y*M22

        mov     [edi].vl_y,eax              ; store y'

        add     esi,SIZE VECTORL
        add     edi,SIZE VECTORL

        dec     cvtl
        jnz     xform_general_loop_vts
        mov     eax,1
        stdRET  bCvtVts

overflow2_vts:
        jmp     overflow_vts

ifdef   DOS_PLATFORM
.errnz XFORM_SCALE - 1
.errnz XFORM_UNITY - 2
.errnz XFORM_Y_NEG - 4

accelerator_table_vts   label   dword                   ;   -y   units simple
        dd      offset FLAT:xform_general_vts           ;    0     0     0
        dd      offset FLAT:xform_non_units_vts         ;    0     0     1
        dd      offset FLAT:xform_rip_vts               ;    0     1     0
        dd      offset FLAT:xform_rip_vts               ;    0     1     1
        dd      offset FLAT:xform_rip_vts               ;    1     0     0
        dd      offset FLAT:xform_rip_vts               ;    1     0     1
        dd      offset FLAT:xform_rip_vts               ;    1     1     0
        dd      offset FLAT:xform_units_neg_y_ltofx_vts ;    1     1     1
endif;  DOS_PLATFORM

stdENDP bCvtVts

;-----------------------------Public-Routine----------------------------;
; bCvtVts_FlToFl
;
;   Apply the given transform matrix to a list of vectors.  The source
;   and dest vectors are of VECTORFL types.
;   The coefficients of the matrix are "LONG integers in EFLOAT type".
;
; Arguments:
;       pmx       points to the matrix
;       pvtflSrc  points to the source list of vectors
;       pvtflDest points to the dest list of vectors
;       cvtl      number of vectors in the list
;
;       ptflSrc, ptflDest can both point to the same array of vectors
;
; Entry:
;       None
; Returns:
;       EAX = 1
; Error Returns:
;       EAX = 0
; Registers Destroyed:
;       ECX,EDX
; Calls:
;       mulff, addff
; History:
;  13-Nov-1990 -by- Wendy Wu [wendywu]
; Created.
;-----------------------------------------------------------------------;

cPublicProc bCvtVts_FlToFl,4,<         \
        uses       ebx esi edi,        \
        pmx:       ptr MATRIX,         \
        pvtflSrc:  ptr VECTORFL,       \
        pvtflDest: ptr VECTORFL,       \
        cvtl:      dword               >

        local   lMantResult   :dword
        local   lExpResult    :dword

        mov     esi,pvtflSrc
        mov     edi,pmx

; ESI -> source array of vectors
; EDI -> matrix

convert_vectors_loop:

; compute x'

        mov     edx,[esi].vfl_x.ef_lMant    ; get x
        mov     ebx,[esi].vfl_x.ef_lExp

        mov     eax,[edi].mx_efM11.ef_lMant
        mov     ecx,[edi].mx_efM11.ef_lExp
        stdCall mulff                       ; x * M11

        mov     lMantResult,eax
        mov     lExpResult,ecx

        mov     edx,[esi].vfl_y.ef_lMant    ; get y
        mov     ebx,[esi].vfl_y.ef_lExp

        mov     eax,[edi].mx_efM21.ef_lMant
        mov     ecx,[edi].mx_efM21.ef_lExp
        stdCall mulff                       ; y * M21

        mov     edx,lMantResult
        mov     ebx,lExpResult
        stdCall addff                       ; x*M11 + y*M21

; compute y'

        mov     ebx,pvtflDest               ; get x before storing x'

        mov     edx,[esi].vfl_x.ef_lMant    ; x.lMant
        mov     [ebx].vfl_x.ef_lMant,eax

        mov     eax,[esi].vfl_x.ef_lExp     ; x.lExp
        mov     [ebx].vfl_x.ef_lExp,ecx
        mov     ebx,eax                     ; edx:ebx = x.lMant:x.lExp

        mov     eax,[edi].mx_efM12.ef_lMant
        mov     ecx,[edi].mx_efM12.ef_lExp
        stdCall mulff                       ; x * M12

        mov     lMantResult,eax
        mov     lExpResult,ecx

        mov     edx,[esi].vfl_y.ef_lMant    ; get y
        mov     ebx,[esi].vfl_y.ef_lExp

        mov     eax,[edi].mx_efM22.ef_lMant
        mov     ecx,[edi].mx_efM22.ef_lExp
        stdCall mulff                       ; y * M22

        mov     edx,lMantResult
        mov     ebx,lExpResult
        stdCall addff                       ; x*M12 + y*M22

        mov     ebx, pvtflDest
        mov     [ebx].vfl_y.ef_lMant,eax
        mov     [ebx].vfl_y.ef_lExp,ecx

        add     esi,SIZE VECTORFL
        add     pvtflDest,SIZE VECTORFL

        dec     cvtl
        jnz     convert_vectors_loop
        mov     eax,1
        stdRET  bCvtVts_FlToFl

overflow:
        xor     eax,eax
        stdRET  bCvtVts_FlToFl

stdENDP bCvtVts_FlToFl

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\math\daytona\ia64\xformer.cxx ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
// 	without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/******************************Module*Header*******************************\
* Module Name: xformer.cxx                                                 *
*                                                                          *
* Contains the transform calculation workhorse routines.                   *
*                                                                          *
* Created: 13-Nov-1990 11:06:09                                            *
* Author: Wendy Wu [wendywu]                                               *
*                                                                          *
* Copyright (c) 1990 Microsoft Corporation                                 *
\**************************************************************************/

extern "C" {

// needed until we cleanup the floating point stuff in ntgdistr.h
#define __CPLUSPLUS

    #include "engine.h"
};

#include "engine.hxx"
#include "xformobj.hxx"

/******************************Member*Function******************************\
* bCvtPts(PMATRIX pmx, PPOINTL pSrc, PPOINTL pDest, SIZE cPtl)              *
*                                                                           *
* Apply the given transform matrix to a list of points.                     *
*                                                                           *
* History:                                                                  *
*  13-Nov-1990 -by- Wendy Wu [wendywu]                                      *
* Wrote it.                                                                 *
\***************************************************************************/

BOOL bCvtPts(PMATRIX pmx, PPOINTL pSrc, PPOINTL pDest, SIZE_T cPtl)
{
    FIX     fxX, fxY;

    ASSERTGDI(((pmx->flAccel & XFORM_FORMAT_LTOL) == 0),
              "bCvtPts: transform wrong format\n");

    switch (pmx->flAccel &
            (XFORM_SCALE|XFORM_UNITY|XFORM_FORMAT_LTOFX))
    {
    case XFORM_SCALE|XFORM_UNITY|XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            pDest->x = LTOFX(pSrc->x) + pmx->fxDx;
            pDest->y = LTOFX(pSrc->y) + pmx->fxDy;
        }
        break;

    case XFORM_SCALE:
    case XFORM_SCALE|XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            EFLOAT x,y;

            x = pSrc->x;
            y = pSrc->y;

            x *= pmx->efM11;
            y *= pmx->efM22;

            x.bEfToL(fxX);              // convert result to long int
            y.bEfToL(fxY);

            pDest->x = fxX + pmx->fxDx;
            pDest->y = fxY + pmx->fxDy;
        }
        break;

    case 0:                             // transform not simple
    case XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            EFLOAT x,y,xTemp;

            x = pSrc->x;                // convert x, y to efloat
            y = pSrc->y;

            xTemp = (pmx->efM11 * x) + (pmx->efM21 * y);
            y = (pmx->efM12 * x) + (pmx->efM22 * y);

            xTemp.bEfToL(fxX);          // convert result to long int
            y.bEfToL(fxY);

            pDest->x = fxX + pmx->fxDx;
            pDest->y = fxY + pmx->fxDy;
        }
        break;

    case (XFORM_SCALE|XFORM_UNITY):
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            pDest->x = FXTOLROUND(pSrc->x) + pmx->fxDx;
            pDest->y = FXTOLROUND(pSrc->y) + pmx->fxDy;
        }
        break;

    default:
        RIP("bCvtPts: unknown flAccel\n");
    }
    return(TRUE);
}

/******************************Member*Function******************************\
* bCvtPts1(PMATRIX pmx, PPOINTL pptl, SIZE cPtl)
*
* Apply the given transform matrix to a list of points.
* The input and output points are of the type POINTL.
*
* History:
*  18-Dec-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\***************************************************************************/

BOOL bCvtPts1(PMATRIX pmx, PPOINTL pptl, SIZE_T cPtl)
{
    ASSERTGDI(((pmx->flAccel & XFORM_FORMAT_LTOL) == 0),
              "bCvtPts: transform wrong format\n");

    LONG   lx, ly;
    EFLOAT x, y;

    switch (pmx->flAccel &
            (XFORM_SCALE|XFORM_UNITY|XFORM_FORMAT_LTOFX))
    {
    case XFORM_SCALE|XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            x = pptl->x * pmx->efM11.e;
            y = pptl->y * pmx->efM22.e;

            x.bEfToLTruncate(lx);
            y.bEfToLTruncate(ly);

            pptl->x = FXTOLROUND(lx + pmx->fxDx);
            pptl->y = FXTOLROUND(ly + pmx->fxDy);
        }
        break;

    case XFORM_SCALE|XFORM_UNITY|XFORM_FORMAT_LTOFX:
        lx = FXTOLROUND(pmx->fxDx);
        ly = FXTOLROUND(pmx->fxDy);

        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            pptl->x += lx;
            pptl->y += ly;
        }
        break;

    case XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            x = pptl->x * pmx->efM11.e + pptl->y * pmx->efM21.e;
            y = pptl->x * pmx->efM12.e + pptl->y * pmx->efM22.e;

            x.bEfToLTruncate(lx);
            y.bEfToLTruncate(ly);

            pptl->x = FXTOLROUND(lx + pmx->fxDx);
            pptl->y = FXTOLROUND(ly + pmx->fxDy);
        }
        break;

    case XFORM_SCALE:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            x = LTOFX(pptl->x) * pmx->efM11.e;
            y = LTOFX(pptl->y) * pmx->efM22.e;

            x.bEfToL(pptl->x);
            y.bEfToL(pptl->y);

            pptl->x += pmx->fxDx;
            pptl->y += pmx->fxDy;
        }
        break;

    case XFORM_SCALE|XFORM_UNITY:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            pptl->x += pmx->fxDx;
            pptl->y += pmx->fxDy;
        }
        break;

    case 0:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            x = LTOFX(pptl->x) * pmx->efM11.e + LTOFX(pptl->y) * pmx->efM21.e;
            y = LTOFX(pptl->x) * pmx->efM12.e + LTOFX(pptl->y) * pmx->efM22.e;

            x.bEfToL(pptl->x);
            y.bEfToL(pptl->y);

            pptl->x += pmx->fxDx;
            pptl->y += pmx->fxDy;
        }
        break;

    default:
        RIP("bCvtPts: unknown flAccel\n");
    }
    return(TRUE);
}

/******************************Member*Function******************************\
* bCvtVts(PMATRIX pmx, PVECTORL pSrc, PVECTORL pDest, SIZE cPtl)            *
*                                                                           *
* Apply the given transform matrix to a list of vectors.                    *
*                                                                           *
* History:                                                                  *
*  13-Nov-1990 -by- Wendy Wu [wendywu]                                      *
* Wrote it.                                                                 *
\***************************************************************************/

BOOL bCvtVts(PMATRIX pmx, PVECTORL pSrc, PVECTORL pDest, SIZE_T cPtl)
{
    ASSERTGDI(((pmx->flAccel & XFORM_FORMAT_LTOL) == 0),
              "bCvtVts: transform wrong format\n");

    switch (pmx->flAccel &
            (XFORM_SCALE|XFORM_UNITY))
    {
    case XFORM_SCALE:
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            EFLOAT x,y;

            x = pSrc->x;
            y = pSrc->y;

            x *= pmx->efM11;
            y *= pmx->efM22;

            x.bEfToL(pDest->x);
            y.bEfToL(pDest->y);
        }
        break;

    case 0:                             // transform not simple
    case XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            EFLOAT x,y,xTemp;

            x = pSrc->x;                // convert x, y to efloat
            y = pSrc->y;

            xTemp = (pmx->efM11 * x) + (pmx->efM21 * y);
            y = (pmx->efM12 * x) + (pmx->efM22 * y);

            xTemp.bEfToL(pDest->x);
            y.bEfToL(pDest->y);
        }
        break;

    default:
        RIP("bCvtVts: unknown flAccel\n");
    }
    return(TRUE);
}

/******************************Member*Function******************************\
* bCvtVts_FlToFl(PMATRIX pmx, PVECTORFL pSrc, PVECTORFL pDest, SIZE cPts)   *
*                                                                           *
* Convert a list of vectors using the given matrix.                         *
*                                                                           *
* History:                                                                  *
*  13-Nov-1990 -by- Wendy Wu [wendywu]                                      *
* Wrote it.                                                                 *
\***************************************************************************/

BOOL bCvtVts_FlToFl(
MATRIX	 *pmx,
VECTORFL *pvtflSrc,
VECTORFL *pvtflDest,
SIZE_T	  cPts)
{
    for ( ; cPts > 0; cPts--, pvtflSrc++, pvtflDest++)
    {
        EFLOAT efXTemp;

        efXTemp = (pmx->efM11 * pvtflSrc->x) +
                  (pmx->efM21 * pvtflSrc->y);

        pvtflDest->y = (pmx->efM12 * pvtflSrc->x) +
                       (pmx->efM22 * pvtflSrc->y);

        pvtflDest->x = efXTemp;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\math\daytona\ia64\math.cxx ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
// 	without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/******************************Module*Header*******************************\
* Module Name: math.cxx                                                    *
*                                                                          *
* IEEE single precision floating point math routines.                      *
*                                                                          *
* Created: 03-Jan-1991 11:32:03                                            *
* Author: Wendy Wu [wendywu]                                               *
*                                                                          *
* Copyright (c) 1990 Microsoft Corporation                                 *
\**************************************************************************/

extern "C" {

// needed until we cleanup the floating point stuff in ntgdistr.h
#define __CPLUSPLUS

    #include "engine.h"
};

#include "engine.hxx"

extern "C" {
VOID vEfToLfx(EFLOAT *pefloat, LARGE_INTEGER *plfx);
LONG lCvtWithRound(FLOAT f, LONG l);
BOOL bFToL(FLOAT e, PLONG pl, LONG lType);
FLOAT eFraction(FLOAT e);
};


/******************************Public*Function*****************************\
* bFToL                                                                    *
*                                                                          *
* Converts an IEEE 747 float to a LONG. The form of the conversion is      *
* specified by the caller.                                                 *
*                                                                          *
*  Arguments                                                               *
*                                                                          *
*      e                    IEEE 747 32-bit float to be converted          *
*                                                                          *
*      pl                   pointer to where answer should be placed       *
*                                                                          *
*      lType                contains bits specifying the type of           *
*                           conversion to be done this can be any          *
*                           combination of the following bits:             *
*                                                                          *
*                           CV_TO_FIX   if this bit is set then            *
*                                       the answer should                  *
*                                       should be in the form              *
*                                       of a 28.4 fix point number         *
*                                       otherwise the answer is            *
*                                       to be interpreted as a 32-bit      *
*                                       LONG                               *
*                                                                          *
*                           CV_TRUNCATE if this bit is set then the        *
*                                       answer is floor(e)                 *
*                                       (if CV_TO_FIX is not set) or       *
*                                       floor(16 * e)                      *
*                                       (if CV_TO_FIX is set)              *
*                                                                          *
*  Theory                                                                  *
*                                                                          *
*  An IEEE 747 float is contained in 32 bits which for the                 *
*  purposes of this discussion I shall call "e". e is                      *
*  equivalent to                                                           *
*                                                                          *
*      e = (-1)^s * mu * 2^E                                               *
*                                                                          *
*  s is the sign bit that is contained in the 31'st bit of e.              *
*  mu is the mantissa and E is the exponetial. These are obtained          *
*  from e in the following way.                                            *
*                                                                          *
*      s = e & 0x80000000 ? -1 : 1                                         *
*                                                                          *
*      mu = M * 2^-23      // 2^23 <= M < 2^24                             *
*                                                                          *
*      M = 0x800000 | (0x7FFFFF & e)                                       *
*                                                                          *
*      E = ((0x7F800000 & e) * 2^-23) - 127                                *
*                                                                          *
*  Suppose the 32.32 Fix point number is Q, then the relation              *
*  between the float and the 32.32 is given by                             *
*                                                                          *
*      Q = e * 2^32 = s * M * 2^(E+9)                                      *
*                                                                          *
* History:                                                                 *
*  Tue 15-Aug-1995 10:36:31 by Kirk Olynyk [kirko]                         *
* Rewrote it                                                               *
*                                                                          *
*  03-Jan-1991 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL bFToL(FLOAT e, PLONG pl, LONG lType)
{
    LONGLONG Q;         // 32.32 repn of abs(e)
    LONG E;             // used to hold exponent then integer parts
    LONG le;            // bit identical to FLOAT argument e
    BOOL bRet = TRUE;   // return value

    le = *(LONG*)&e;                                    // get IEEE 747 bits
    E = (int) (((0x7f800000 & le) >> 23) - 127) + 9;    // E = exponent
    if (lType & CV_TO_FIX)                              // if (want FIX point)
        E += 4;                                         //     multiply by 16
    if (E > (63-23))                                    // if (overflow)
    {                                                   //     bail out
        bRet = FALSE;
    }
    else
    {
        Q = (LONGLONG) (0x800000 | (0x7FFFFF & le));    // abs val of mantissa
        Q = (E >= 0) ? Q << E : Q >> -E;                // account for exponent
        if (!(lType & CV_TRUNCATE))                     // if (rounding) then
            Q += 0x80000000;                            //     add 1/2
        E = (long) (Q >> 32);                           // E = abs(integer part)
        *pl = (le < 0) ? -E : E;                        // fix up sign
    }
    return(bRet);
};

/******************************Public*Function*****************************\
* eFraction                                                                *
*                                                                          *
* Get the fractional part of a given IEEE floating point number.           *
*                                                                          *
* History:                                                                 *
*  03-Jan-1991 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

FLOAT eFraction(FLOAT e)
{
    LONG lEf, lExp, l;

    lEf = (*((LONG *) &e));        // convert type EFLOAT to LONG

// if exponent < 0 then there's no integer part, just return itself

    if ((lExp = ((lEf >> 23) & 0xff) -127) < 0) return(e);

// if exponent >= 23 then we do not store the fraction, return 0

    if (lExp >= 23) return FLOAT(0);

// if 0 <= exponent < 23 then
// the integer part l is calculated as:
//     lMantissa = (lEf & 0x7fffff) | 0x800000;
//     l = lMantissa >> (23 - lExponent);

    l = ((lEf & 0x7fffff) | 0x800000) >> (23 - lExp);
    return(e - (FLOAT) l);
};

/******************************Public*Routine******************************\
* VOID EFLOAT::vSqrt();                                                    *
*                                                                          *
* Takes the square root of the IEEE float.                                 *
*                                                                          *
* Assumes that the number is positive.                                     *
*                                                                          *
* History:                                                                 *
*  Fri 01-Mar-1991 12:26:58 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID EFLOAT::vSqrt()
{
    int k;
    ULONG ulY;
    ULONG ulR;
    ULONG ulL;
    ULONG ulF         = *(ULONG*) &e;
    ULONG ulBiasedExp = ((ulF & 0x7F800000)>>23);

    ulL  = 0x7fffff & ulF;
    ulL |= 0x800000;                        // get back the implicit bit
    if ((ulBiasedExp += 127) & 1)
    {
        ulL <<= 8;
        ulBiasedExp -= 1;
    }
    else
    {
        ulL <<= 7;
    }
    ulBiasedExp >>= 1;

    for (ulY = 0, ulR = 0, k = 0; k < 24; k++)
    {
        ulY <<= 2;
        ulY |= (ulL & 0xC0000000)>>30;
        ulL <<= 2;
        ulR <<= 1;
        {
            ULONG ulT = ulR + ulR + 1;
            if (ulT <= ulY)
            {
                ulY -= ulT;
                ulR++;
            }
        }
    }
    ulF = ulR & 0x7fffff;
    ulF |= ulBiasedExp << 23;
    e = *(FLOAT*) &ulF;
}

/******************************Public*Routine******************************\
* vEfToLfx                                                                 *
*                                                                          *
* Converts an IEEE 747 float to a 32.32 fix point number                   *
*                                                                          *
*  Theory                                                                  *
*                                                                          *
*  An IEEE 747 float is contained in 32 bits which for the                 *
*  purposes of this discussion I shall call "e". e is                      *
*  equivalent to                                                           *
*                                                                          *
*      e = (-1)^s * mu * 2^E                                               *
*                                                                          *
*  s is the sign bit that is contained in the 31'st bit of e.              *
*  mu is the mantissa and E is the exponetial. These are obtained          *
*  from e in the following way.                                            *
*                                                                          *
*      s = e & 0x80000000 ? -1 : 1                                         *
*                                                                          *
*      mu = M * 2^-23      // 2^23 <= M < 2^24                             *
*                                                                          *
*      M = 0x800000 | (0x7FFFFF & e)                                       *
*                                                                          *
*      E = ((0x7F800000 & e) * 2^-23) - 127                                *
*                                                                          *
*  Suppose the 32.32 Fix point number is Q, then the relation              *
*  between the float and the 32.32 is given by                             *
*                                                                          *
*      Q = e * 2^32 = s * M * 2^(E+9)                                      *
*                                                                          *
*                                                                          *
* History:                                                                 *
*  Fri 15-Jul-1994 07:01:50 by Kirk Olynyk [kirko]                         *
* Made use of intrinsic 64 bit support                                     *
*  Wed 26-Jun-1991 16:07:49 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID
vEfToLfx(EFLOAT *pefloat, LARGE_INTEGER *plfx)
{
    LONGLONG Q;
    char E;
    LONG e;

    e = *(LONG*)pefloat;
    Q = (LONGLONG) (0x800000 | (0x7FFFFF & e));
    E = (char) (((0x7f800000 & e) >> 23) - 127) + 9;
    Q = (E >= 0) ? Q << E : Q >> -E;
    Q = (e < 0) ? -Q : Q;
    *(LONGLONG*)plfx = Q;
}

/******************************Public*Routine******************************\
* lCvtWithRound(FLOAT f, LONG l);                                          *
*                                                                          *
* Multiplies a float by a long, rounds the results and casts to a LONG     *
*                                                                          *
* History:                                                                 *
*  Wed 26-May-1993 15:07:00 by Gerrit van Wingerden [gerritv]              *
* Wrote it.                                                                *
\**************************************************************************/

LONG lCvtWithRound(FLOAT f, LONG l)
{

    LONG l_ = 0;
    bFToL(f * l, &l_, 0);
    return(l_);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\math\wow6432\i386\math.cxx ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
// 	without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/******************************Module*Header*******************************\
* Module Name: math.cxx                                                    *
*                                                                          *
* IEEE single precision floating point math routines.                      *
*                                                                          *
* Created: 03-Jan-1991 11:32:03                                            *
* Author: Wendy Wu [wendywu]                                               *
*                                                                          *
* Copyright (c) 1990 Microsoft Corporation                                 *
\**************************************************************************/

extern "C" {

// needed until we cleanup the floating point stuff in ntgdistr.h
#define __CPLUSPLUS

    #include "engine.h"
};

#include "engine.hxx"

extern "C" {
VOID vEfToLfx(EFLOAT *pefloat, LARGE_INTEGER *plfx);
LONG lCvtWithRound(FLOAT f, LONG l);
BOOL bFToL(FLOAT e, PLONG pl, LONG lType);
FLOAT eFraction(FLOAT e);
};


/******************************Public*Function*****************************\
* bFToL                                                                    *
*                                                                          *
* Converts an IEEE 747 float to a LONG. The form of the conversion is      *
* specified by the caller.                                                 *
*                                                                          *
*  Arguments                                                               *
*                                                                          *
*      e                    IEEE 747 32-bit float to be converted          *
*                                                                          *
*      pl                   pointer to where answer should be placed       *
*                                                                          *
*      lType                contains bits specifying the type of           *
*                           conversion to be done this can be any          *
*                           combination of the following bits:             *
*                                                                          *
*                           CV_TO_FIX   if this bit is set then            *
*                                       the answer should                  *
*                                       should be in the form              *
*                                       of a 28.4 fix point number         *
*                                       otherwise the answer is            *
*                                       to be interpreted as a 32-bit      *
*                                       LONG                               *
*                                                                          *
*                           CV_TRUNCATE if this bit is set then the        *
*                                       answer is floor(e)                 *
*                                       (if CV_TO_FIX is not set) or       *
*                                       floor(16 * e)                      *
*                                       (if CV_TO_FIX is set)              *
*                                                                          *
*  Theory                                                                  *
*                                                                          *
*  An IEEE 747 float is contained in 32 bits which for the                 *
*  purposes of this discussion I shall call "e". e is                      *
*  equivalent to                                                           *
*                                                                          *
*      e = (-1)^s * mu * 2^E                                               *
*                                                                          *
*  s is the sign bit that is contained in the 31'st bit of e.              *
*  mu is the mantissa and E is the exponetial. These are obtained          *
*  from e in the following way.                                            *
*                                                                          *
*      s = e & 0x80000000 ? -1 : 1                                         *
*                                                                          *
*      mu = M * 2^-23      // 2^23 <= M < 2^24                             *
*                                                                          *
*      M = 0x800000 | (0x7FFFFF & e)                                       *
*                                                                          *
*      E = ((0x7F800000 & e) * 2^-23) - 127                                *
*                                                                          *
*  Suppose the 32.32 Fix point number is Q, then the relation              *
*  between the float and the 32.32 is given by                             *
*                                                                          *
*      Q = e * 2^32 = s * M * 2^(E+9)                                      *
*                                                                          *
* History:                                                                 *
*  Tue 15-Aug-1995 10:36:31 by Kirk Olynyk [kirko]                         *
* Rewrote it                                                               *
*                                                                          *
*  03-Jan-1991 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL bFToL(FLOAT e, PLONG pl, LONG lType)
{
    LONGLONG Q;         // 32.32 repn of abs(e)
    LONG E;             // used to hold exponent then integer parts
    LONG le;            // bit identical to FLOAT argument e
    BOOL bRet = TRUE;   // return value

    le = *(LONG*)&e;                                    // get IEEE 747 bits
    E = (int) (((0x7f800000 & le) >> 23) - 127) + 9;    // E = exponent
    if (lType & CV_TO_FIX)                              // if (want FIX point)
        E += 4;                                         //     multiply by 16
    if (E > (63-23))                                    // if (overflow)
    {                                                   //     bail out
        bRet = FALSE;
    }
    else
    {
        Q = (LONGLONG) (0x800000 | (0x7FFFFF & le));    // abs val of mantissa
        Q = (E >= 0) ? Q << E : Q >> -E;                // account for exponent
        if (!(lType & CV_TRUNCATE))                     // if (rounding) then
            Q += 0x80000000;                            //     add 1/2
        E = (long) (Q >> 32);                           // E = abs(integer part)
        *pl = (le < 0) ? -E : E;                        // fix up sign
    }
    return(bRet);
};

/******************************Public*Function*****************************\
* eFraction                                                                *
*                                                                          *
* Get the fractional part of a given IEEE floating point number.           *
*                                                                          *
* History:                                                                 *
*  03-Jan-1991 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

FLOAT eFraction(FLOAT e)
{
    LONG lEf, lExp, l;

    lEf = (*((LONG *) &e));        // convert type EFLOAT to LONG

// if exponent < 0 then there's no integer part, just return itself

    if ((lExp = ((lEf >> 23) & 0xff) -127) < 0) return(e);

// if exponent >= 23 then we do not store the fraction, return 0

    if (lExp >= 23) return FLOAT(0);

// if 0 <= exponent < 23 then
// the integer part l is calculated as:
//     lMantissa = (lEf & 0x7fffff) | 0x800000;
//     l = lMantissa >> (23 - lExponent);

    l = ((lEf & 0x7fffff) | 0x800000) >> (23 - lExp);
    return(e - (FLOAT) l);
};

/******************************Public*Routine******************************\
* VOID EFLOAT::vSqrt();                                                    *
*                                                                          *
* Takes the square root of the IEEE float.                                 *
*                                                                          *
* Assumes that the number is positive.                                     *
*                                                                          *
* History:                                                                 *
*  Fri 01-Mar-1991 12:26:58 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID EFLOAT::vSqrt()
{
    int k;
    ULONG ulY;
    ULONG ulR;
    ULONG ulL;
    ULONG ulF         = *(ULONG*) &e;
    ULONG ulBiasedExp = ((ulF & 0x7F800000)>>23);

    ulL  = 0x7fffff & ulF;
    ulL |= 0x800000;                        // get back the implicit bit
    if ((ulBiasedExp += 127) & 1)
    {
        ulL <<= 8;
        ulBiasedExp -= 1;
    }
    else
    {
        ulL <<= 7;
    }
    ulBiasedExp >>= 1;

    for (ulY = 0, ulR = 0, k = 0; k < 24; k++)
    {
        ulY <<= 2;
        ulY |= (ulL & 0xC0000000)>>30;
        ulL <<= 2;
        ulR <<= 1;
        {
            ULONG ulT = ulR + ulR + 1;
            if (ulT <= ulY)
            {
                ulY -= ulT;
                ulR++;
            }
        }
    }
    ulF = ulR & 0x7fffff;
    ulF |= ulBiasedExp << 23;
    e = *(FLOAT*) &ulF;
}

/******************************Public*Routine******************************\
* vEfToLfx                                                                 *
*                                                                          *
* Converts an IEEE 747 float to a 32.32 fix point number                   *
*                                                                          *
*  Theory                                                                  *
*                                                                          *
*  An IEEE 747 float is contained in 32 bits which for the                 *
*  purposes of this discussion I shall call "e". e is                      *
*  equivalent to                                                           *
*                                                                          *
*      e = (-1)^s * mu * 2^E                                               *
*                                                                          *
*  s is the sign bit that is contained in the 31'st bit of e.              *
*  mu is the mantissa and E is the exponetial. These are obtained          *
*  from e in the following way.                                            *
*                                                                          *
*      s = e & 0x80000000 ? -1 : 1                                         *
*                                                                          *
*      mu = M * 2^-23      // 2^23 <= M < 2^24                             *
*                                                                          *
*      M = 0x800000 | (0x7FFFFF & e)                                       *
*                                                                          *
*      E = ((0x7F800000 & e) * 2^-23) - 127                                *
*                                                                          *
*  Suppose the 32.32 Fix point number is Q, then the relation              *
*  between the float and the 32.32 is given by                             *
*                                                                          *
*      Q = e * 2^32 = s * M * 2^(E+9)                                      *
*                                                                          *
*                                                                          *
* History:                                                                 *
*  Fri 15-Jul-1994 07:01:50 by Kirk Olynyk [kirko]                         *
* Made use of intrinsic 64 bit support                                     *
*  Wed 26-Jun-1991 16:07:49 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID
vEfToLfx(EFLOAT *pefloat, LARGE_INTEGER *plfx)
{
    LONGLONG Q;
    char E;
    LONG e;

    e = *(LONG*)pefloat;
    Q = (LONGLONG) (0x800000 | (0x7FFFFF & e));
    E = (char) (((0x7f800000 & e) >> 23) - 127) + 9;
    Q = (E >= 0) ? Q << E : Q >> -E;
    Q = (e < 0) ? -Q : Q;
    *(LONGLONG*)plfx = Q;
}

/******************************Public*Routine******************************\
* lCvtWithRound(FLOAT f, LONG l);                                          *
*                                                                          *
* Multiplies a float by a long, rounds the results and casts to a LONG     *
*                                                                          *
* History:                                                                 *
*  Wed 26-May-1993 15:07:00 by Gerrit van Wingerden [gerritv]              *
* Wrote it.                                                                *
\**************************************************************************/

LONG lCvtWithRound(FLOAT f, LONG l)
{

    LONG l_ = 0;
    bFToL(f * l, &l_, 0);
    return(l_);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\math\wow6432\i386\xformer.cxx ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
// 	without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/******************************Module*Header*******************************\
* Module Name: xformer.cxx                                                 *
*                                                                          *
* Contains the transform calculation workhorse routines.                   *
*                                                                          *
* Created: 13-Nov-1990 11:06:09                                            *
* Author: Wendy Wu [wendywu]                                               *
*                                                                          *
* Copyright (c) 1990 Microsoft Corporation                                 *
\**************************************************************************/

extern "C" {

// needed until we cleanup the floating point stuff in ntgdistr.h
#define __CPLUSPLUS

    #include "engine.h"
};

#include "engine.hxx"
#include "xformobj.hxx"

/******************************Member*Function******************************\
* bCvtPts(PMATRIX pmx, PPOINTL pSrc, PPOINTL pDest, SIZE cPtl)              *
*                                                                           *
* Apply the given transform matrix to a list of points.                     *
*                                                                           *
* History:                                                                  *
*  13-Nov-1990 -by- Wendy Wu [wendywu]                                      *
* Wrote it.                                                                 *
\***************************************************************************/

BOOL bCvtPts(PMATRIX pmx, PPOINTL pSrc, PPOINTL pDest, SIZE_T cPtl)
{
    FIX     fxX, fxY;

    ASSERTGDI(((pmx->flAccel & XFORM_FORMAT_LTOL) == 0),
              "bCvtPts: transform wrong format\n");

    switch (pmx->flAccel &
            (XFORM_SCALE|XFORM_UNITY|XFORM_FORMAT_LTOFX))
    {
    case XFORM_SCALE|XFORM_UNITY|XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            pDest->x = LTOFX(pSrc->x) + pmx->fxDx;
            pDest->y = LTOFX(pSrc->y) + pmx->fxDy;
        }
        break;

    case XFORM_SCALE:
    case XFORM_SCALE|XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            EFLOAT x,y;

            x = pSrc->x;
            y = pSrc->y;

            x *= pmx->efM11;
            y *= pmx->efM22;

            x.bEfToL(fxX);              // convert result to long int
            y.bEfToL(fxY);

            pDest->x = fxX + pmx->fxDx;
            pDest->y = fxY + pmx->fxDy;
        }
        break;

    case 0:                             // transform not simple
    case XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            EFLOAT x,y,xTemp;

            x = pSrc->x;                // convert x, y to efloat
            y = pSrc->y;

            xTemp = (pmx->efM11 * x) + (pmx->efM21 * y);
            y = (pmx->efM12 * x) + (pmx->efM22 * y);

            xTemp.bEfToL(fxX);          // convert result to long int
            y.bEfToL(fxY);

            pDest->x = fxX + pmx->fxDx;
            pDest->y = fxY + pmx->fxDy;
        }
        break;

    case (XFORM_SCALE|XFORM_UNITY):
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            pDest->x = FXTOLROUND(pSrc->x) + pmx->fxDx;
            pDest->y = FXTOLROUND(pSrc->y) + pmx->fxDy;
        }
        break;

    default:
        RIP("bCvtPts: unknown flAccel\n");
    }
    return(TRUE);
}

/******************************Member*Function******************************\
* bCvtPts1(PMATRIX pmx, PPOINTL pptl, SIZE cPtl)
*
* Apply the given transform matrix to a list of points.
* The input and output points are of the type POINTL.
*
* History:
*  18-Dec-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\***************************************************************************/

BOOL bCvtPts1(PMATRIX pmx, PPOINTL pptl, SIZE_T cPtl)
{
    ASSERTGDI(((pmx->flAccel & XFORM_FORMAT_LTOL) == 0),
              "bCvtPts: transform wrong format\n");

    LONG   lx, ly;
    EFLOAT x, y;

    switch (pmx->flAccel &
            (XFORM_SCALE|XFORM_UNITY|XFORM_FORMAT_LTOFX))
    {
    case XFORM_SCALE|XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            x = pptl->x * pmx->efM11.e;
            y = pptl->y * pmx->efM22.e;

            x.bEfToLTruncate(lx);
            y.bEfToLTruncate(ly);

            pptl->x = FXTOLROUND(lx + pmx->fxDx);
            pptl->y = FXTOLROUND(ly + pmx->fxDy);
        }
        break;

    case XFORM_SCALE|XFORM_UNITY|XFORM_FORMAT_LTOFX:
        lx = FXTOLROUND(pmx->fxDx);
        ly = FXTOLROUND(pmx->fxDy);

        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            pptl->x += lx;
            pptl->y += ly;
        }
        break;

    case XFORM_FORMAT_LTOFX:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            x = pptl->x * pmx->efM11.e + pptl->y * pmx->efM21.e;
            y = pptl->x * pmx->efM12.e + pptl->y * pmx->efM22.e;

            x.bEfToLTruncate(lx);
            y.bEfToLTruncate(ly);

            pptl->x = FXTOLROUND(lx + pmx->fxDx);
            pptl->y = FXTOLROUND(ly + pmx->fxDy);
        }
        break;

    case XFORM_SCALE:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            x = LTOFX(pptl->x) * pmx->efM11.e;
            y = LTOFX(pptl->y) * pmx->efM22.e;

            x.bEfToL(pptl->x);
            y.bEfToL(pptl->y);

            pptl->x += pmx->fxDx;
            pptl->y += pmx->fxDy;
        }
        break;

    case XFORM_SCALE|XFORM_UNITY:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            pptl->x += pmx->fxDx;
            pptl->y += pmx->fxDy;
        }
        break;

    case 0:
        for ( ; cPtl > 0; cPtl--, pptl++)
        {
            x = LTOFX(pptl->x) * pmx->efM11.e + LTOFX(pptl->y) * pmx->efM21.e;
            y = LTOFX(pptl->x) * pmx->efM12.e + LTOFX(pptl->y) * pmx->efM22.e;

            x.bEfToL(pptl->x);
            y.bEfToL(pptl->y);

            pptl->x += pmx->fxDx;
            pptl->y += pmx->fxDy;
        }
        break;

    default:
        RIP("bCvtPts: unknown flAccel\n");
    }
    return(TRUE);
}

/******************************Member*Function******************************\
* bCvtVts(PMATRIX pmx, PVECTORL pSrc, PVECTORL pDest, SIZE cPtl)            *
*                                                                           *
* Apply the given transform matrix to a list of vectors.                    *
*                                                                           *
* History:                                                                  *
*  13-Nov-1990 -by- Wendy Wu [wendywu]                                      *
* Wrote it.                                                                 *
\***************************************************************************/

BOOL bCvtVts(PMATRIX pmx, PVECTORL pSrc, PVECTORL pDest, SIZE_T cPtl)
{
    ASSERTGDI(((pmx->flAccel & XFORM_FORMAT_LTOL) == 0),
              "bCvtVts: transform wrong format\n");

    switch (pmx->flAccel &
            (XFORM_SCALE|XFORM_UNITY))
    {
    case XFORM_SCALE:
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            EFLOAT x,y;

            x = pSrc->x;
            y = pSrc->y;

            x *= pmx->efM11;
            y *= pmx->efM22;

            x.bEfToL(pDest->x);
            y.bEfToL(pDest->y);
        }
        break;

    case 0:                             // transform not simple
        for ( ; cPtl > 0; cPtl--, pSrc++, pDest++)
        {
            EFLOAT x,y,xTemp;

            x = pSrc->x;                // convert x, y to efloat
            y = pSrc->y;

            xTemp = (pmx->efM11 * x) + (pmx->efM21 * y);
            y = (pmx->efM12 * x) + (pmx->efM22 * y);

            xTemp.bEfToL(pDest->x);
            y.bEfToL(pDest->y);
        }
        break;

    default:
        RIP("bCvtVts: unknown flAccel\n");
    }
    return(TRUE);
}

/******************************Member*Function******************************\
* bCvtVts_FlToFl(PMATRIX pmx, PVECTORFL pSrc, PVECTORFL pDest, SIZE cPts)   *
*                                                                           *
* Convert a list of vectors using the given matrix.                         *
*                                                                           *
* History:                                                                  *
*  13-Nov-1990 -by- Wendy Wu [wendywu]                                      *
* Wrote it.                                                                 *
\***************************************************************************/

BOOL bCvtVts_FlToFl(
MATRIX	 *pmx,
VECTORFL *pvtflSrc,
VECTORFL *pvtflDest,
SIZE_T	  cPts)
{
    for ( ; cPts > 0; cPts--, pvtflSrc++, pvtflDest++)
    {
        EFLOAT efXTemp;

        efXTemp = (pmx->efM11 * pvtflSrc->x) +
                  (pmx->efM21 * pvtflSrc->y);

        pvtflDest->y = (pmx->efM12 * pvtflSrc->x) +
                       (pmx->efM22 * pvtflSrc->y);

        pvtflDest->x = efXTemp;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\math\wow6432\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\mf3216\apientry.c ===
/*****************************************************************************
 *
 * apientry.c - This module contains the API entry points for the
 *              Win32 to Win16 metafile converter.
 *
 * Date: 8/29/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/


#include "precomp.h"
#pragma hdrstop

BOOL     bMemUpdateCheckSum(PLOCALDC pLocalDC) ;
PLOCALDC pldcInitLocalDC(HDC hdcRef, INT iMapMode, DWORD flags) ;
VOID     vFreeLocalDC(PLOCALDC pLocalDC);


extern VOID __cdecl _cfltcvt_init(VOID) ;

// This critical section structure is shared by all the threads of a given
// process.

CRITICAL_SECTION CriticalSection ;

// Constant definition for internal static string(s).

BYTE    szDisplay[] = "DISPLAY" ;

/*****************************************************************************
 * Entry point for translation
 *****************************************************************************/
UINT ConvertEmfToWmf(PBYTE pMetafileBits, UINT cDest, PBYTE pDest,
                 INT iMapMode, HDC hdcRef, UINT flags)
{
BOOL        b ;
DWORD       lret = 0;
PLOCALDC    pLocalDC ;


        // We funnel through one exit to make sure we leave the
        // critical section.

        EnterCriticalSection(&CriticalSection) ;

        // Check the requested map mode and if it's valid

        if (iMapMode < MM_MIN || iMapMode > MM_MAX)
        {
            RIP("MF3216:ConvertEmfToWmf - Invalid MapMode\n") ;
            goto ErrorExit;
        }

        // Check for a reference DC.  If one is not supplied we fail.

        if (hdcRef == (HDC) 0)
        {
            RIP("MF3216:ConvertEmfToWmf - Invalid RefDC\n") ;
            goto ErrorExit;
        }

        // Check the validity of the flags.

        if ((flags & ~MF3216_INCLUDE_WIN32MF) != 0)
        {
            RIP("MF3216: ConvertEmfToWmf - Invalid flags\n") ;
            goto ErrorExit ;
        }

        // Allocate the LocalDC and initialize some of it's fields.

        pLocalDC = pldcInitLocalDC(hdcRef, iMapMode, flags) ;
        if (pLocalDC == (PLOCALDC) 0)
        {
            goto ErrorExit ;
        }

        // If pDest is NULL then we just return the size of the buffer required
        // to hold the Win16 metafile bits.

        if (pDest == (PBYTE) 0)
        {
            pLocalDC->flags |= SIZE_ONLY ;
            b = bParseWin32Metafile(pMetafileBits, pLocalDC) ;
            if (b == TRUE)
            {
                lret = pLocalDC->ulBytesEmitted ;
            }
            else
            {
                PUTS("MF3216: ConvertEmfToWmf - Size Only failed\n") ;
            }
        }
        else
        {

            // Put the user specified Win16 buffer pointer and buffer length
            // into the localDC.

            pLocalDC->pMf16Bits = pDest ;
            pLocalDC->cMf16Dest = cDest ;

            //  Translate the Win32 metafile to a Win16 metafile.

            b = bParseWin32Metafile(pMetafileBits, pLocalDC) ;
            if (b == TRUE)
            {
                // Update the Win16 metafile header.

                b = bUpdateMf16Header(pLocalDC) ;
                if (b == TRUE)
                {
                    // Only acknowledge that we have translated some bits
                    // if everything has gone well.

                    lret = pLocalDC->ulBytesEmitted ;

                    // If we're including the Win32 metafile then update the
                    // checksum field in the "Win32Comment header" record.

                    if (pLocalDC->flags & INCLUDE_W32MF_COMMENT)
                        bMemUpdateCheckSum(pLocalDC) ;
                }
            }
            else
            {
                PUTS("MF3216: ConvertEmfToWmf - Metafile conversion failed\n") ;
            }
        }

        // Free the LocalDC and its resources.

        vFreeLocalDC(pLocalDC);

ErrorExit:
        LeaveCriticalSection(&CriticalSection) ;

        return (lret) ;
}


/*****************************************************************************
 * pldcInitLocalDC - Initialize the Local DC.
 *****************************************************************************/
PLOCALDC pldcInitLocalDC(HDC hdcRef, INT iMapMode, DWORD flags)
{
PLOCALDC    pLocalDC;
PLOCALDC    pldcRet = (PLOCALDC) NULL;  // assume error

        // Allocate and initialize memory for the LocalDC.

        pLocalDC = (PLOCALDC) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                         sizeof(LOCALDC));
        if (!pLocalDC)
        {
            PUTS("MF3216:pldcInitLocalDC - LocalAlloc failure\n") ;
            return((PLOCALDC) NULL);
        }

        // Record the size of the DC.

        pLocalDC->nSize = sizeof(LOCALDC) ;

        // Set the LocalDC boolean that controls whether or not we include
        // the Win32 metafile as one or more comment records.

        if (flags & MF3216_INCLUDE_WIN32MF)
            pLocalDC->flags |= INCLUDE_W32MF_COMMENT ;

#if 0
        // Need to create a hdc for the display.
        // Initially this will be used by the bitblt translation code
        // to get a reasonable set of palette entries.
        // The reference DC only has a black & white palette.

        pLocalDC->hdcDisp = CreateDCA((LPCSTR)szDisplay, (LPCSTR)NULL, (LPCSTR)NULL, (CONST DEVMODEA *)NULL) ;
        if (pLocalDC->hdcDisp == (HDC) 0)
        {
            RIP("MF3216:pldcInitLocalDC - CreateDCA(hdcDisp) failed\n") ;
            goto pldcInitLocalDC_exit;
        }
#endif // 0

        //  Create the HelperDC.

        pLocalDC->hdcHelper = CreateICA((LPCSTR) szDisplay,
                                       (LPCSTR) NULL,
                                       (LPCSTR) NULL,
                                       (LPDEVMODEA) NULL) ;
        if (pLocalDC->hdcHelper == (HDC)0)
        {
            PUTS("MF3216: pldcInitLocalDC, Create Helper DC failed\n") ;
            goto pldcInitLocalDC_exit;
        }

        // Initialize the counters we need to keep for updating the header,
        // and keeping track of the object table.

        pLocalDC->nObjectHighWaterMark = -1;

        // Get the play-time device dimensions in millimeters and in pels.

        pLocalDC->cxPlayDevMM   = GetDeviceCaps(hdcRef, HORZSIZE) ;
        pLocalDC->cyPlayDevMM   = GetDeviceCaps(hdcRef, VERTSIZE) ;
        pLocalDC->cxPlayDevPels = GetDeviceCaps(hdcRef, HORZRES) ;
        pLocalDC->cyPlayDevPels = GetDeviceCaps(hdcRef, VERTRES) ;

        // Record the requested map mode and reference DC.

        pLocalDC->iMapMode = iMapMode ;
        pLocalDC->hdcRef   = hdcRef ;

        // Init Arc Direction.

        pLocalDC->iArcDirection = AD_COUNTERCLOCKWISE ;

        // Make current position invalid so that a moveto will be
        // emitted when it is first used.  See comments in DoMoveTo.

        pLocalDC->ptCP.x = MAXLONG ;
        pLocalDC->ptCP.y = MAXLONG ;

        // Default pen is a black pen.

        pLocalDC->lhpn32  = BLACK_PEN | ENHMETA_STOCK_OBJECT;

        // Default brush is a white brush.

        pLocalDC->lhbr32  = WHITE_BRUSH | ENHMETA_STOCK_OBJECT;

    // Default palette.

    pLocalDC->ihpal32 = DEFAULT_PALETTE | ENHMETA_STOCK_OBJECT;
    pLocalDC->ihpal16 = (DWORD) -1; // no W16 palette created yet

        pLocalDC->crBkColor = RGB(0xFF,0xFF,0xFF);

//      pLocalDC->pW16ObjHndlSlotStatus = NULL;
//      pLocalDC->cW16ObjHndlSlotStatus = 0;
//      pLocalDC->piW32ToW16ObjectMap = NULL;
//      pLocalDC->cW32ToW16ObjectMap = 0;
//      pLocalDC->crTextColor = RGB(0x0,0x0,0x0);
//      pLocalDC->iLevel = 0;
//      pLocalDC->pLocalDCSaved = NULL;
//      pLocalDC->ulBytesEmitted = 0;
//      pLocalDC->ulMaxRecord = 0;
//      pLocalDC->pW32hPal = NULL;

        // Set the advanced graphics mode in the helper DC.  This is needed
        // to notify the helper DC that rectangles and ellipses are
        // inclusive-inclusive etc., especially when rendering them in a path.
    // Also, the world transform can only be set in the advanced mode.

        (void) SetGraphicsMode(pLocalDC->hdcHelper, GM_ADVANCED);

        // We are golden.

        pldcRet = pLocalDC;

pldcInitLocalDC_exit:

        if (!pldcRet)
            vFreeLocalDC(pLocalDC);

        return(pldcRet) ;
}

/*****************************************************************************
 * vFreeLocalDC - Free the Local DC and its resources.
 *****************************************************************************/
VOID vFreeLocalDC(PLOCALDC pLocalDC)
{
    UINT i;

// Free the helper DCs.

    if (pLocalDC->hdcHelper)
        if (!DeleteDC(pLocalDC->hdcHelper))
            ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, DeleteDC failed");
#if 0
    if (pLocalDC->hdcDisp)
        if (!DeleteDC(pLocalDC->hdcDisp))
            ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, DeleteDC failed");
#endif // 0

// Free the storage for the object translation map.

    if (pLocalDC->piW32ToW16ObjectMap)
    {
#if 0
        for (i = 0 ; i < pLocalDC->cW32ToW16ObjectMap ; i++)
        {
            if (pLocalDC->piW32ToW16ObjectMap[i] != UNMAPPED)
                if (i > STOCK_LAST)
                    PUTS1("MF3216: vFreeLocalDC, object32 %ld is not freed\n", i - STOCK_LAST - 1);
                else
                    PUTS1("MF3216: vFreeLocalDC, stock object32 %ld is mapped\n",i);
        }
#endif // 0

        if (LocalFree(pLocalDC->piW32ToW16ObjectMap))
            ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, LocalFree failed");
    }

// Free the W32 palette handles.

    if (pLocalDC->pW32hPal)
    {
    for (i = 0; i < pLocalDC->cW32hPal; i++)
    {
        if (pLocalDC->pW32hPal[i])
                if (!DeleteObject(pLocalDC->pW32hPal[i]))
                    ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, delete palette failed");
    }

        if (LocalFree(pLocalDC->pW32hPal))
            ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, LocalFree failed");
    }

// Free the w32 handles in the pW16ObjHndlSlotStatus array.
// We free the handles after we have deleted the helper DC so that
// the w32 handles are not selected into any DC.

    if (pLocalDC->pW16ObjHndlSlotStatus)
    {
        for (i = 0 ; i < pLocalDC->cW16ObjHndlSlotStatus ; i++)
        {
#if 0
            if (pLocalDC->pW16ObjHndlSlotStatus[i].use
                != OPEN_AVAILABLE_SLOT)
                PUTS1("MF3216: vFreeLocalDC, object16 %ld is not freed\n", i);
#endif // 0

            if (pLocalDC->pW16ObjHndlSlotStatus[i].w32Handle)
            {
                ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[i].use
                          != OPEN_AVAILABLE_SLOT,
                          "MF3216: error in object handle table");

                if (!DeleteObject(pLocalDC->pW16ObjHndlSlotStatus[i].w32Handle))
                    ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, DeleteObject failed");
            }
        }

        if (LocalFree(pLocalDC->pW16ObjHndlSlotStatus))
            ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, LocalFree failed");
    }

// The DC level should be balanced.

    if (pLocalDC->pLocalDCSaved != NULL)
    {
    PLOCALDC pNext, pTmp;

        for (pNext = pLocalDC->pLocalDCSaved; pNext; )
    {
        PUTS("MF3216: vFreeLocalDC, unbalanced DC level\n");

        pTmp = pNext->pLocalDCSaved;
        if (LocalFree(pNext))
        ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, LocalFree failed");
        pNext = pTmp;
    }
    }

// Finally, free the LocalDC.

    if (LocalFree(pLocalDC))
        ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, LocalFree failed");
}


/***************************************************************************
 *  Handle emitting the Win32  metafile comment  record(s).
 **************************************************************************/
BOOL bHandleWin32Comment(PLOCALDC pLocalDC)
{
INT     i;
BOOL    b ;
META_ESCAPE_ENHANCED_METAFILE mfeEnhMF;

    // Win30 may have problems with large (over 8K) escape records.
    // We will limit the size of each Win32 Comment record to
    // MAX_WIN32_COMMENT_REC_SIZE.

    // Initialize the record header.

    mfeEnhMF.rdFunction = META_ESCAPE;
    mfeEnhMF.wEscape    = MFCOMMENT;
    mfeEnhMF.ident      = MFCOMMENT_IDENTIFIER;
    mfeEnhMF.iComment   = MFCOMMENT_ENHANCED_METAFILE;
    mfeEnhMF.nVersion   = ((PENHMETAHEADER) pLocalDC->pMf32Bits)->nVersion;
    mfeEnhMF.wChecksum  = 0;   // updated by bMemUpdateCheckSum
    mfeEnhMF.fFlags     = 0;
    mfeEnhMF.nCommentRecords
    = (pLocalDC->cMf32Bits + MAX_WIN32_COMMENT_REC_SIZE - 1)
      / MAX_WIN32_COMMENT_REC_SIZE;
    mfeEnhMF.cbEnhMetaFile = pLocalDC->cMf32Bits;

    mfeEnhMF.cbRemainder = pLocalDC->cMf32Bits;
    i = 0 ;
    while (mfeEnhMF.cbRemainder)
    {
    mfeEnhMF.cbCurrent = min(mfeEnhMF.cbRemainder, MAX_WIN32_COMMENT_REC_SIZE);
    mfeEnhMF.rdSize = (sizeof(mfeEnhMF) + mfeEnhMF.cbCurrent) / 2;
    mfeEnhMF.wCount = (WORD)(sizeof(mfeEnhMF) + mfeEnhMF.cbCurrent - sizeof(METARECORD_ESCAPE));
    mfeEnhMF.cbRemainder -= mfeEnhMF.cbCurrent;

    b = bEmitWin16EscapeEnhMetaFile(pLocalDC,
        (PMETARECORD_ESCAPE) &mfeEnhMF, &pLocalDC->pMf32Bits[i]);

    if (!b)
        break;
    i += mfeEnhMF.cbCurrent;
    }

    return(b) ;
}


/*****************************************************************************
 * bMemUpdateCheckSum - Update the checksum
 *****************************************************************************/
BOOL bMemUpdateCheckSum(PLOCALDC pLocalDC)
{
INT         i, k ;
PWORD       pword ;
WORD        CheckSum ;
PMETA_ESCAPE_ENHANCED_METAFILE pmfeEnhMF;


    // CheckSum the file.
    // Do a 16 bit checksum

    pword = (PWORD) pLocalDC->pMf16Bits ;
    k = pLocalDC->ulBytesEmitted / 2 ;

    CheckSum = 0 ;
    for (i = 0 ; i < k ; i++)
    CheckSum += pword[i] ;

    // Update the checksum record value with the real checksum.

    pmfeEnhMF = (PMETA_ESCAPE_ENHANCED_METAFILE)
            &pLocalDC->pMf16Bits[sizeof(METAHEADER)];

    ASSERTGDI(IS_META_ESCAPE_ENHANCED_METAFILE(pmfeEnhMF)
       && pmfeEnhMF->wChecksum  == 0
       && pmfeEnhMF->fFlags     == 0,
    "MF3216: bMemUpdateCheckSum: Bad pmfeEnhMF");

    pmfeEnhMF->wChecksum = -CheckSum;

#if DBG
    // Now test the checksum.  The checksum of the entire file
    // should be 0.

    CheckSum = 0 ;
    pword = (PWORD) pLocalDC->pMf16Bits ;
    for (i = 0 ; i < k ; i++)
    CheckSum += pword[i] ;

    if (CheckSum != 0)
    {
    RIP("MF3216: MemUpdateCheckSum, (CheckSum != 0)\n") ;
    }
#endif
    return (TRUE) ;
}


/******************************Public*Routine******************************\
* Mf3216DllInitialize                                                      *
*                                                                          *
* This is the init procedure for MF3216.DLL,                               *
* which is called each time a new                                          *
* process links to it.                                                     *
\**************************************************************************/

BOOL Mf3216DllInitialize(PVOID pvDllHandle, DWORD ulReason, PCONTEXT pcontext)
{



        NOTUSED(pvDllHandle) ;
        NOTUSED(pcontext) ;

        if ( ulReason == DLL_PROCESS_ATTACH )
        {
            // This does the critical section initialization for a single
            // process.  Each process does this.  The CriticalSection data
            // structure is one of the very few (if not the only one) data
            // structures in the data segment.

            InitializeCriticalSection(&CriticalSection) ;
        }
        else if ( ulReason == DLL_PROCESS_DETACH )
        {
            DeleteCriticalSection(&CriticalSection) ;
        }

        return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\mf3216\beziers.c ===
/*****************************************************************************
 *
 * beziers - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop

BOOL PolyBezierCommon(PLOCALDC pLocalDC, LPPOINT pptl, PBYTE pb, DWORD cptl, DWORD mrType) ;


/***************************************************************************
 *  PolyDraw  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPolyDraw
(
PLOCALDC pLocalDC,
LPPOINT pptl,
PBYTE   pb,
DWORD   cptl
)
{
        return(PolyBezierCommon(pLocalDC, pptl, pb, cptl, EMR_POLYDRAW));
}

/***************************************************************************
 *  PolyBezier  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPolyBezier
(
PLOCALDC pLocalDC,
LPPOINT pptl,
DWORD   cptl
)
{
        return(PolyBezierCommon(pLocalDC, pptl, (PBYTE) NULL, cptl, EMR_POLYBEZIER));
}

/***************************************************************************
 *  PolyBezierTo  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPolyBezierTo
(
PLOCALDC pLocalDC,
LPPOINT pptl,
DWORD   cptl
)
{
        return(PolyBezierCommon(pLocalDC, pptl, (PBYTE) NULL, cptl, EMR_POLYBEZIERTO));
}

/***************************************************************************
 *  PolyBezierCommon  - Common code for PolyDraw, PolyBezier and PolyBezierTo
 **************************************************************************/
BOOL PolyBezierCommon(PLOCALDC pLocalDC, LPPOINT pptl, PBYTE pb, DWORD cptl, DWORD mrType)
{
BOOL    b ;

// If we're recording the drawing order for a path
// then just pass the drawing order to the helper DC.
// Do not emit any Win16 drawing orders.

        if (pLocalDC->flags & RECORDING_PATH)
        {
            switch (mrType)
            {
                case EMR_POLYBEZIER:
                    b = PolyBezier(pLocalDC->hdcHelper, pptl, cptl) ;
                    break ;

                case EMR_POLYBEZIERTO:
                    b = PolyBezierTo(pLocalDC->hdcHelper, pptl, cptl) ;
                    break ;

                case EMR_POLYDRAW:
                    b = PolyDraw(pLocalDC->hdcHelper, pptl, pb, cptl) ;
                    break ;

		default:
                    b = FALSE;
	            RIP("MF3216: PolyBezierCommon, bad mrType\n") ;
                    break ;
            }

            ASSERTGDI(b, "MF3216: PolyBezierCommon, in path render failed\n") ;
            return (b) ;
        }

// Call the common curve renderer.

	return
	(
	    bRenderCurveWithPath(pLocalDC, pptl, pb, cptl,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0.0f, 0.0f, mrType)
	);
}


/***************************************************************************
 *  bRenderCurveWithPath - Renders a curve or area using the path api.
 *     The supported curves and areas are PolyDraw, PolyBezier, PolyBezierTo,
 *     AngleArc, Arc, Chord, Pie, Ellipse, Rectangle, and RoundRect.
 **************************************************************************/
BOOL bRenderCurveWithPath
(
    PLOCALDC pLocalDC,
    LPPOINT  pptl,
    PBYTE    pb,
    DWORD    cptl,
    INT      x1,
    INT      y1,
    INT      x2,
    INT      y2,
    INT      x3,
    INT      y3,
    INT      x4,
    INT      y4,
    DWORD    nRadius,
    FLOAT    eStartAngle,
    FLOAT    eSweepAngle,
    DWORD    mrType
)
{
    BOOL     b;
    INT      iPathType;

// We don't do curves in a path bracket here.  They should be
// taken care of by the caller.

    ASSERTGDI(!(pLocalDC->flags & RECORDING_PATH),
	"MF3216: bRenderCurveWithPath, cannot be in a path bracket\n");

// Save the helper DC first.
// This is to prevent us from accidentally deleteing the current path
// in the helper DC when we create another path to render the curve.
// E.g. BeginPath, Polyline, EndPath, PolyBezier, StrokePath.

    if (!SaveDC(pLocalDC->hdcHelper))
    {
	RIP("MF3216: bRenderCurveWithPath, SaveDC failed\n");
	return(FALSE);
    }

// Create the path for the curve and stroke it.
// Be careful not to modify the states of the LocalDC especially in
// DoRenderPath below.
// Note that BeginPath uses the previous current position.  So this
// code will work correctly in the case of PolyBezierTo, PolyDraw
// and AngleArc.

    // Begin the path.

    b = BeginPath(pLocalDC->hdcHelper);
    if (!b)
    {
	RIP("MF3216: bRenderCurveWithPath, BeginPath failed\n");
	goto exit_bRenderCurveWithPath;
    }

    // Do the curve.

    switch (mrType)
    {
	case EMR_POLYBEZIER:
	    iPathType = EMR_STROKEPATH;
	    b = PolyBezier(pLocalDC->hdcHelper, pptl, cptl);
	    break;

	case EMR_POLYBEZIERTO:
	    iPathType = EMR_STROKEPATH;
	    b = PolyBezierTo(pLocalDC->hdcHelper, pptl, cptl);
	    break;

	case EMR_POLYDRAW:
	    iPathType = EMR_STROKEPATH;
	    b = PolyDraw(pLocalDC->hdcHelper, pptl, pb, cptl);
	    break;

	case EMR_ANGLEARC:
	    iPathType = EMR_STROKEPATH;
	    b = AngleArc(pLocalDC->hdcHelper, x1, y1, nRadius, eStartAngle, eSweepAngle);
	    break;

	case EMR_ARC:
	    iPathType = EMR_STROKEPATH;
	    b = Arc(pLocalDC->hdcHelper, x1, y1, x2, y2, x3, y3, x4, y4);
	    break;

	case EMR_CHORD:
	    iPathType = EMR_STROKEANDFILLPATH;
	    b = Chord(pLocalDC->hdcHelper, x1, y1, x2, y2, x3, y3, x4, y4);
	    break;

	case EMR_PIE:
	    iPathType = EMR_STROKEANDFILLPATH;
	    b = Pie(pLocalDC->hdcHelper, x1, y1, x2, y2, x3, y3, x4, y4) ;
	    break;

	case EMR_ELLIPSE:
	    iPathType = EMR_STROKEANDFILLPATH;
	    b = Ellipse(pLocalDC->hdcHelper, x1, y1, x2, y2);
	    break;

	case EMR_RECTANGLE:
	    iPathType = EMR_STROKEANDFILLPATH;
	    b = Rectangle(pLocalDC->hdcHelper, x1, y1, x2, y2) ;
	    break;

	case EMR_ROUNDRECT:
	    iPathType = EMR_STROKEANDFILLPATH;
	    b = RoundRect(pLocalDC->hdcHelper, x1, y1, x2, y2, x3, y3) ;
	    break;

	default:
            b = FALSE;
	    RIP("MF3216: bRenderCurveWithPath, bad mrType");
	    break;
    }

    if (!b)
    {
	RIP("MF3216: bRenderCurveWithPath, render failed\n");
	goto exit_bRenderCurveWithPath;
    }

    // End the path

    b = EndPath(pLocalDC->hdcHelper);
    if (!b)
    {
	RIP("MF3216: bRenderCurveWithPath, EndPath failed\n");
	goto exit_bRenderCurveWithPath;
    }

    // Stroke or fill the path.

    b = DoRenderPath(pLocalDC, iPathType);
    if (!b)
    {
	RIP("MF3216: bRenderCurveWithPath, DoRenderPath failed\n");
	goto exit_bRenderCurveWithPath;
    }

exit_bRenderCurveWithPath:

// Restore the helper DC.

    if (!RestoreDC(pLocalDC->hdcHelper, -1))
	ASSERTGDI(FALSE, "MF3216: bRenderCurveWithPath, RestoreDC failed\n") ;

// If this is a PolyBezeirTo, PolyDraw or AngleArc, make the call to the
// helper DC to update its current position.

    if (b)
    {
	switch (mrType)
	{
	    case EMR_POLYBEZIER:
	    case EMR_ARC:
	    case EMR_CHORD:
	    case EMR_PIE:
	    case EMR_ELLIPSE:
	    case EMR_RECTANGLE:
	    case EMR_ROUNDRECT:	// no need to update the helper DC
		break ;

	    case EMR_POLYBEZIERTO:
		(void) PolyBezierTo(pLocalDC->hdcHelper, pptl, cptl) ;
		break ;

	    case EMR_POLYDRAW:
		(void) PolyDraw(pLocalDC->hdcHelper, pptl, pb, cptl) ;
		break ;

	    case EMR_ANGLEARC:
		(void) AngleArc(pLocalDC->hdcHelper, x1, y1, nRadius, eStartAngle, eSweepAngle);
		break ;

	    default:
		RIP("MF3216: bRenderCurveWithPath, bad mrType");
		break;
	}
    }

// Return the result.

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\mf3216\colors.c ===
/*****************************************************************************
 *
 * colors - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * History:
 *  Sep 1992	-by-	Hock San Lee	[hockl]
 * Complete rewrite.
 *
 *  The following implementation takes into account that all 16-bit metafile
 *  palette records reference the current palette.
 *
 *  CreatePalette
 *      Create a private copy of the logical palette in the converter but
 *      don't emit the 16-bit record.
 *
 *  SelectPalette
 *      Emit a CreatePalette record followed by a SelectPalette record.
 *      Then emit a 16-bit DeleteObject record to delete the previous palette.
 *      The selected logical palette can be queried from the private copy
 *      maintained by the converter.  You need to keep track of the current
 *      palette so that you can emit ResizePalette or SetPaletteEntries record
 *      if the palette identifies the current palette.  You also need to deal
 *      with the stock palette correctly here (you don't need to keep a
 *      private copy of the stock palette).  Don't delete the private copy
 *      of the logical palette here! (see DeleteObject below)
 *
 *  RealizePalette
 *      Just emit a 16-bit record.  This record always references the current
 *      palette in both 16 and 32-bit metafiles.
 *
 *  ResizePalette
 *      Update the private copy of the logical palette in the converter.
 *      Emit a 16-bit record only if the palette identifies the current palette.
 *
 *  SetPaletteEntries
 *      Update the private copy of the logical palette in the converter.
 *      Emit a 16-bit record only if the palette identifies the current palette.
 *
 *  DeleteObject
 *      Don't emit the 16-bit record for palettes since all palettes are
 *      deleted in SelectPalette above.  Similarly, don't emit palette delete
 *      records at the end of conversion.  However, you need to delete the
 *      private copy of the palette maintained by the converter here and at
 *      the end of conversion.
 *
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************
 *  SelectPalette  - Win32 to Win16 Metafile Converter Entry Point
 *
 *      Emit a CreatePalette record followed by a SelectPalette record.
 *      Then emit a 16-bit DeleteObject record to delete the previous palette.
 *      The selected logical palette can be queried from the private copy
 *      maintained by the converter.  You need to keep track of the current
 *      palette so that you can emit ResizePalette or SetPaletteEntries record
 *      if the palette identifies the current palette.  You also need to deal
 *      with the stock palette correctly here (you don't need to keep a
 *      private copy of the stock palette).  Don't delete the private copy
 *      of the logical palette here! (see DeleteObject below)
 *
 **************************************************************************/
BOOL WINAPI DoSelectPalette
(
PLOCALDC pLocalDC,
DWORD	 ihpal
)
{
BOOL	     b = FALSE;
WORD         cEntries;
LPLOGPALETTE lpLogPal = (LPLOGPALETTE) NULL;
HPALETTE     hpalW32;
INT	     ihW16, ihW32Norm;

	// No need to do anything if selecting the same palette.

	if (pLocalDC->ihpal32 == ihpal)
	    return(TRUE);

	// Validate the palette index.

	if ((ihpal != (ENHMETA_STOCK_OBJECT | DEFAULT_PALETTE))
	 && (ihpal >= pLocalDC->cW32hPal || !pLocalDC->pW32hPal[ihpal]))
	{
            RIP("MF3216: DoSelectPalette - ihpal invalid");
            goto error_exit;
	}

	// Get the W32 handle.

	if (ihpal == (ENHMETA_STOCK_OBJECT | DEFAULT_PALETTE))
	    hpalW32 = GetStockObject(DEFAULT_PALETTE) ;
	else
	    hpalW32 = pLocalDC->pW32hPal[ihpal];

        if(hpalW32 == 0)
        {
            RIP("MF3216: DoSelectPalette - hpalW32 == 0\n");
            goto error_exit;
        }
	// Emit a CreatePalette record.

	if (!GetObjectA(hpalW32, sizeof(WORD), &cEntries))
	{
	    RIP("MF3216: DoSelectPalette - GetObjectA failed\n");
            goto error_exit;
	}

	if (!(lpLogPal = (LPLOGPALETTE) LocalAlloc(
				LMEM_FIXED,
				sizeof(LOGPALETTE) - sizeof(PALETTEENTRY)
				 + sizeof(PALETTEENTRY) * cEntries)))
            goto error_exit;

	lpLogPal->palVersion    = 0x300;
        lpLogPal->palNumEntries = cEntries;

	GetPaletteEntries(hpalW32, 0, cEntries, lpLogPal->palPalEntry);

	// Allocate the W16 handle.

        ihW16 = iAllocateW16Handle(pLocalDC, ihpal, REALIZED_PALETTE);
        if (ihW16 == -1)
            goto error_exit;

	if (!bEmitWin16CreatePalette(pLocalDC, lpLogPal))
            goto error_exit;

	// Emit a SelectPalette record.

	if (!SelectPalette(pLocalDC->hdcHelper, hpalW32, TRUE))
	    goto error_exit;

	if (!bEmitWin16SelectPalette(pLocalDC, (WORD) ihW16))
	    goto error_exit;

	// Emit a DeleteObject record to delete the previous palette.

	if (pLocalDC->ihpal16 != -1)
	{
	    ihW32Norm = iNormalizeHandle(pLocalDC, pLocalDC->ihpal32);
	    if (ihW32Norm == -1)
		goto error_exit;

	    pLocalDC->pW16ObjHndlSlotStatus[pLocalDC->ihpal16].use
		= OPEN_AVAILABLE_SLOT;
	    pLocalDC->piW32ToW16ObjectMap[ihW32Norm]
		= UNMAPPED;

	    bEmitWin16DeleteObject(pLocalDC, (WORD) pLocalDC->ihpal16);
	}

	pLocalDC->ihpal32 = ihpal;
	pLocalDC->ihpal16 = ihW16;

	b = TRUE;

error_exit:

        if (lpLogPal)
	    LocalFree((HANDLE) lpLogPal);

	return(b);
}

/***************************************************************************
 *  ResizePalette  - Win32 to Win16 Metafile Converter Entry Point
 *
 *      Update the private copy of the logical palette in the converter.
 *      Emit a 16-bit record only if the palette identifies the current palette.
 *
 **************************************************************************/
BOOL WINAPI DoResizePalette
(
PLOCALDC  pLocalDC,
DWORD     ihpal,
DWORD     cEntries
)
{
	// Do not modify the default palette.

	if (ihpal == (ENHMETA_STOCK_OBJECT | DEFAULT_PALETTE))
	    return(TRUE);

	// Validate the palette index.

	if (ihpal >= pLocalDC->cW32hPal || !pLocalDC->pW32hPal[ihpal])
	{
            RIP("MF3216: DoResizePalette - ihpal invalid");
	    return(FALSE);
	}

	// Do it to the private palette.

	if (!ResizePalette(pLocalDC->pW32hPal[ihpal], cEntries))
	{
            RIP("MF3216: DoResizePalette - ResizePalette failed");
	    return(FALSE);
	}

	// Emit a 16-bit record only if the palette identifies the
	// current palette.

	if (pLocalDC->ihpal32 == ihpal)
            return(bEmitWin16ResizePalette(pLocalDC, (WORD) cEntries));

        return(TRUE);
}

/***************************************************************************
 *  SetPaletteEntries  - Win32 to Win16 Metafile Converter Entry Point
 *
 *      Update the private copy of the logical palette in the converter.
 *      Emit a 16-bit record only if the palette identifies the current palette.
 *
 **************************************************************************/
BOOL WINAPI DoSetPaletteEntries
(
PLOCALDC       pLocalDC,
DWORD 	       ihpal,
DWORD 	       iStart,
DWORD 	       cEntries,
LPPALETTEENTRY pPalEntries
)
{
	// Do not modify the default palette.

	if (ihpal == (ENHMETA_STOCK_OBJECT | DEFAULT_PALETTE))
	    return(TRUE);

	// Validate the palette index.

	if (ihpal >= pLocalDC->cW32hPal || !pLocalDC->pW32hPal[ihpal])
	{
            RIP("MF3216: DoSetPaletteEntries - ihpal invalid");
	    return(FALSE);
	}

	// Do it to the private palette.

	if (!SetPaletteEntries(pLocalDC->pW32hPal[ihpal], iStart, cEntries, pPalEntries))
	{
            RIP("MF3216: DoSetPaletteEntries - SetPaletteEntries failed");
	    return(FALSE);
	}

	// Emit a 16-bit record only if the palette identifies the
	// current palette.

	if (pLocalDC->ihpal32 == ihpal)
            return(bEmitWin16SetPaletteEntries(pLocalDC, iStart, cEntries, pPalEntries));

        return(TRUE);
}

/***************************************************************************
 *  RealizePalette  - Win32 to Win16 Metafile Converter Entry Point
 *
 *      Just emit a 16-bit record.  This record always references the current
 *      palette in both 16 and 32-bit metafiles.
 *
 **************************************************************************/
BOOL WINAPI DoRealizePalette
(
PLOCALDC pLocalDC
)
{
        // Emit the Win16 metafile drawing order.

        return(bEmitWin16RealizePalette(pLocalDC));
}

/***************************************************************************
 *  CreatePalette  - Win32 to Win16 Metafile Converter Entry Point
 *
 *      Create a private copy of the logical palette in the converter but
 *      don't emit the 16-bit record.
 *
 **************************************************************************/
BOOL WINAPI DoCreatePalette
(
PLOCALDC     pLocalDC,
DWORD        ihPal,
LPLOGPALETTE lpLogPal
)
{
	if (ihPal != (ENHMETA_STOCK_OBJECT | DEFAULT_PALETTE))
        {
            LOGPALETTE *lpLogPalNew;

        // Validate the palette index.

	    if (ihPal >= pLocalDC->cW32hPal || pLocalDC->pW32hPal[ihPal])
                return(FALSE);

        // Allocate size of log palette + 2 entries for black and white.

            lpLogPalNew = LocalAlloc(LMEM_FIXED, lpLogPal->palNumEntries * sizeof(DWORD) + (sizeof(LOGPALETTE) + sizeof(DWORD)));

            if (lpLogPalNew == NULL)
            {
                return(FALSE);
            }

            RtlMoveMemory(lpLogPalNew, lpLogPal, lpLogPal->palNumEntries * sizeof(DWORD) + (sizeof(LOGPALETTE) - sizeof(DWORD)));
            lpLogPalNew->palNumEntries += 2;
            lpLogPalNew->palPalEntry[lpLogPal->palNumEntries - 1].peRed   = 0;
            lpLogPalNew->palPalEntry[lpLogPal->palNumEntries - 1].peGreen = 0;
            lpLogPalNew->palPalEntry[lpLogPal->palNumEntries - 1].peBlue  = 0;
            lpLogPalNew->palPalEntry[lpLogPal->palNumEntries - 1].peFlags = 0;
            lpLogPalNew->palPalEntry[lpLogPal->palNumEntries - 2].peRed   = 0xff;
            lpLogPalNew->palPalEntry[lpLogPal->palNumEntries - 2].peGreen = 0xff;
            lpLogPalNew->palPalEntry[lpLogPal->palNumEntries - 2].peBlue  = 0xff;
            lpLogPalNew->palPalEntry[lpLogPal->palNumEntries - 2].peFlags = 0;

        // Create a private copy of the logical palette and keep it
        // in the converter palette table.

            pLocalDC->pW32hPal[ihPal] = CreatePalette(lpLogPalNew);
            LocalFree(lpLogPalNew);

            if (!(pLocalDC->pW32hPal[ihPal]))
            {
                RIP("MF3216: DoCreatePalette - CreatePalette failed\n") ;
                return(FALSE);
            }
        }

        return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\mf3216\entry.h ===
#ifndef _MF3216_ENTRY_
#define _MF3216_ENTRY_

BOOL APIENTRY DoSetArcDirection(PLOCALDC pLocalDC, INT iArcDirection) ;
BOOL APIENTRY DoGdiComment(PLOCALDC pLocalDC, PEMR pEMR);

BOOL APIENTRY DoAngleArc
(
     PLOCALDC pLocalDC,
     INT     x,
     INT     y,
     DWORD   ulRadius,
     FLOAT   eStartAngle,
     FLOAT   eSweepAngle
) ;


BOOL APIENTRY DoArcTo
(
     PLOCALDC pLocalDC,
     int x1,
     int y1,
     int x2,
     int y2,
     int x3,
     int y3,
     int x4,
     int y4
) ;

BOOL APIENTRY DoArc
(
     PLOCALDC pLocalDC,
     INT x1,
     INT y1,
     INT x2,
     INT y2,
     INT x3,
     INT y3,
     INT x4,
     INT y4
) ;

BOOL APIENTRY DoStretchBlt(
PLOCALDC     pLocalDC,
LONG         xDst,
LONG         yDst,
LONG         cxDst,
LONG         cyDst,
DWORD        rop,
LONG         xSrc,
LONG         ySrc,
LONG         cxSrc,
LONG         cySrc,
PXFORM       pxformSrc,
DWORD        iUsageSrc,
PBITMAPINFO  lpBitmapInfo,
DWORD        cbBitmapInfo,
LPBYTE       lpBits,
DWORD        cbBits
) ;

BOOL APIENTRY DoStretchDIBits
(
PLOCALDC     pLocalDC,
LONG         xDst,
LONG         yDst,
LONG         cxDst,
LONG         cyDst,
DWORD        rop,
LONG         xDib,
LONG         yDib,
LONG         cxDib,
LONG         cyDib,
DWORD        iUsage,
LPBITMAPINFO lpBitmapInfo,
DWORD        cbBitmapInfo,
LPBYTE       lpBits,
DWORD        cbBits
) ;

BOOL APIENTRY DoSetDIBitsToDevice
(
PLOCALDC     pLocalDC,
LONG         xDst,
LONG         yDst,
LONG         xDib,
LONG         yDib,
LONG         cxDib,
LONG         cyDib,
DWORD        iUsage,
DWORD        iStartScan,
DWORD        cScans,
LPBITMAPINFO lpBitmapInfo,
DWORD        cbBitmapInfo,
LPBYTE       lpBits,
DWORD        cbBits
);

BOOL APIENTRY DoChord
(
     PLOCALDC pLocalDC,
     INT x1,
     INT y1,
     INT x2,
     INT y2,
     INT x3,
     INT y3,
     INT x4,
     INT y4
) ;

BOOL APIENTRY DoEllipse
(
     PLOCALDC pLocalDC,
     INT x1,
     INT y1,
     INT x2,
     INT y2
) ;

BOOL APIENTRY DoExtCreateFont
(
    PLOCALDC  pLocalDC,
    INT       ihFont,
    PLOGFONTW plfw
) ;

BOOL APIENTRY DoExtFloodFill
(
     PLOCALDC pLocalDC,
     INT         x,
     INT         y,
     COLORREF    crColor,
     DWORD       iFillType
) ;

BOOL APIENTRY DoLineTo
(
     PLOCALDC  pLocalDC,
     LONG    x,
     LONG    y
) ;

BOOL APIENTRY DoMaskBlt
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop4,
 LONG         xSrc,
 LONG         ySrc,
 PXFORM       pxformSrc,
 DWORD        iUsageSrc,
 PBITMAPINFO  lpBitmapInfoSrc,
 DWORD        cbBitmapInfoSrc,
 LPBYTE       lpBitsSrc,
 DWORD        cbBitsSrc,
 LONG         xMask,
 LONG         yMask,
 DWORD        iUsageMask,
 PBITMAPINFO  lpBitmapInfoMask,
 DWORD        cbBitmapInfoMask,
 LPBYTE       lpBitsMask,
 DWORD        cbBitsMask
) ;

BOOL APIENTRY DoPlgBlt
(
    PLOCALDC	pLocalDC,
    PPOINTL	pptlDst,
    LONG	xSrc,
    LONG	ySrc,
    LONG	cxSrc,
    LONG	cySrc,
    PXFORM      pxformSrc,
    DWORD	iUsageSrc,
    PBITMAPINFO lpBitmapInfoSrc,
    DWORD       cbBitmapInfoSrc,
    LPBYTE      lpBitsSrc,
    DWORD       cbBitsSrc,
    LONG	xMask,
    LONG	yMask,
    DWORD       iUsageMask,
    PBITMAPINFO lpBitmapInfoMask,
    DWORD       cbBitmapInfoMask,
    LPBYTE      lpBitsMask,
    DWORD       cbBitsMask
) ;

BOOL APIENTRY DoMoveTo
(
     PLOCALDC pLocalDC,
     LONG    x,
     LONG    y
) ;


BOOL APIENTRY DoPie
(
     PLOCALDC pLocalDC,
     INT x1,
     INT y1,
     INT x2,
     INT y2,
     INT x3,
     INT y3,
     INT x4,
     INT y4
) ;

BOOL APIENTRY DoPolyBezier
(
     PLOCALDC pLocalDC,
     LPPOINT pptl,
     DWORD   cptl
) ;

BOOL APIENTRY DoPolyBezierTo
(
     PLOCALDC pLocalDC,
     LPPOINT pptl,
     DWORD   cptl
) ;

BOOL WINAPI DoPolyDraw
(
    PLOCALDC pLocalDC,
    LPPOINT pptl,
    PBYTE   pb,
    DWORD   cptl
) ;

BOOL APIENTRY DoPoly
(
     PLOCALDC pLocalDC,
     PPOINTL  pptl,
     DWORD    cptl,
     INT      mrType
) ;

BOOL APIENTRY DoPolylineTo
(
     PLOCALDC pLocalDC,
     PPOINTL pptl,
     DWORD   cptl
) ;

BOOL APIENTRY DoPolyPolygon
(
     PLOCALDC pLocalDC,
     PPOINTL pptl,
     PDWORD  pcptl,
     DWORD   cptl,
     DWORD   ccptl
) ;

BOOL APIENTRY DoPolyPolyline
(
     PLOCALDC pLocalDC,
     PPOINTL pptl,
     PDWORD  pcptl,
     DWORD   ccptl
) ;

BOOL APIENTRY DoRectangle
(
     PLOCALDC pLocalDC,
     INT    x1,
     INT    y1,
     INT    x2,
     INT    y2
) ;

BOOL APIENTRY DoRestoreDC
(
     PLOCALDC pLocalDC,
     INT nSavedDC
) ;

BOOL APIENTRY DoRoundRect
(
     PLOCALDC pLocalDC,
     INT x1,
     INT y1,
     INT x2,
     INT y2,
     INT x3,
     INT y3
) ;

BOOL APIENTRY DoSaveDC
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoSetPixel
(
     PLOCALDC pLocalDC,
     INT         x,
     INT         y,
     COLORREF    crColor
) ;

BOOL APIENTRY DoExtTextOut
(
     PLOCALDC pLocalDC,
     INT     x,                  // Initial x position
     INT     y,                  // Initial y position
     DWORD   flOpts,             // Options
     PRECTL  prcl,               // Clipping rectangle
     PWCH    awch,               // Wide Character array
     DWORD   cch,                // Character count
     PLONG   pDx,                // Character positioning
     DWORD   iGraphicsMode,	 // Graphics mode
     INT     mrType              // Either unicode or ANSI
) ;

BOOL APIENTRY DoBeginPath
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoEndPath
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoFlattenPath
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoAbortPath
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoCloseFigure
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoRenderPath
(
     PLOCALDC pLocalDC,
     INT      mrType
);

BOOL APIENTRY DoWidenPath
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoClipRect
(
 PLOCALDC pLocalDC,
 INT xLeft,
 INT yTop,
 INT xRight,
 INT yBottom,
 INT mrType
) ;

BOOL APIENTRY DoDrawRgn
(
 PLOCALDC  pLocalDC,
 INT       ihBrush,
 INT	   nWidth,
 INT       nHeight,
 INT       cRgnData,
 LPRGNDATA pRgnData,
 INT       mrType
) ;

BOOL APIENTRY DoOffsetClipRgn
(
     PLOCALDC pLocalDC,
     INT x,
     INT y
) ;

BOOL APIENTRY DoSetMetaRgn
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoSelectClipPath
(
     PLOCALDC pLocalDC,
     INT    iMode
) ;

BOOL APIENTRY DoExtSelectClipRgn
(
 PLOCALDC  pLocalDC,
 INT       cRgnData,
 LPRGNDATA pRgnData,
 INT       iMode
) ;

BOOL APIENTRY DoModifyWorldTransform
(
     PLOCALDC pLocalDC,
     PXFORM  pxf,
     DWORD   imode
) ;

BOOL APIENTRY DoSetMapMode
(
     PLOCALDC pLocalDC,
     DWORD   ulMapMode
) ;

BOOL WINAPI DoScaleWindowExt
(
 PLOCALDC pLocalDC,
 INT      Xnum,
 INT      Xdenom,
 INT      Ynum,
 INT      Ydenom
) ;

BOOL WINAPI DoScaleViewportExt
(
 PLOCALDC pLocalDC,
 INT      Xnum,
 INT      Xdenom,
 INT      Ynum,
 INT      Ydenom
) ;



BOOL APIENTRY DoSetViewportExt
(
     PLOCALDC pLocalDC,
     INT     x,
     INT     y
) ;

BOOL APIENTRY DoSetViewportOrg
(
     PLOCALDC pLocalDC,
     INT     x,
     INT     y
) ;

BOOL APIENTRY DoSetWindowExt
(
     PLOCALDC pLocalDC,
     INT     x,
     INT     y
) ;

BOOL APIENTRY DoSetWindowOrg
(
     PLOCALDC pLocalDC,
     INT     x,
     INT     y
) ;

BOOL APIENTRY DoSetWorldTransform
(
     PLOCALDC pLocalDC,
     PXFORM  pxf
) ;

BOOL APIENTRY DoDeleteObject
(
     PLOCALDC pLocalDC,
     INT hObject
) ;

BOOL APIENTRY DoSelectObject
(
     PLOCALDC pLocalDC,
     LONG   ihObject
) ;

BOOL APIENTRY DoSetBkColor
(
     PLOCALDC      pLocalDC,
     COLORREF    crColor
) ;

BOOL APIENTRY DoSetBkMode
(
     PLOCALDC pLocalDC,
     DWORD   iBkMode
) ;

BOOL APIENTRY DoSetMapperFlags
(
     PLOCALDC pLocalDC,
     DWORD   f
) ;

BOOL APIENTRY DoSetPolyFillMode
(
     PLOCALDC pLocalDC,
     DWORD   iPolyFillMode
) ;

BOOL APIENTRY DoSetRop2
(
     PLOCALDC pLocalDC,
     DWORD   rop
) ;

BOOL APIENTRY DoSetStretchBltMode
(
     PLOCALDC pLocalDC,
     DWORD   iStretchMode
) ;

BOOL APIENTRY DoSetTextAlign
(
     PLOCALDC pLocalDC,
     DWORD   fMode
) ;

BOOL APIENTRY DoSetTextColor
(
     PLOCALDC      pLocalDC,
     COLORREF    crColor
) ;

BOOL APIENTRY DoCreateBrushIndirect
(
     PLOCALDC      pLocalDC,
     INT         ihBrush,
     LPLOGBRUSH  lpLogBrush
) ;

BOOL WINAPI DoCreateDIBPatternBrush
(
    PLOCALDC    pLocalDC,
    DWORD       ihBrush,
    PBITMAPINFO pBitmapInfo,
    DWORD       cbBitmapInfo,
    PBYTE       pBits,
    DWORD       cbBits,
    DWORD       iUsage
) ;

BOOL WINAPI DoCreateMonoBrush
(
    PLOCALDC    pLocalDC,
    DWORD       ihBrush,
    PBITMAPINFO pBitmapInfo,
    DWORD       cbBitmapInfo,
    PBYTE       pBits,
    DWORD       cbBits,
    DWORD       iUsage
) ;


BOOL WINAPI DoCreatePen
(
    PLOCALDC    pLocalDC,
    INT         ihPen,
    PLOGPEN     pLogPen
) ;

BOOL WINAPI DoExtCreatePen
(
    PLOCALDC    pLocalDC,
    INT         ihPen,
    PEXTLOGPEN  pExtLogPen
) ;

BOOL APIENTRY DoCreatePalette
(
    PLOCALDC	 pLocalDC,
    DWORD        ihPal,
    LPLOGPALETTE lpLogPal
) ;

BOOL APIENTRY DoSelectPalette
(
    PLOCALDC	pLocalDC,
    DWORD 	ihpal
) ;

BOOL APIENTRY DoSetPaletteEntries
(
    PLOCALDC	   pLocalDC,
    DWORD	   ihPal,
    DWORD	   iStart,
    DWORD	   cEntries,
    LPPALETTEENTRY pPalEntries
);

BOOL APIENTRY DoResizePalette
(
    PLOCALDC    pLocalDC,
    DWORD       ihpal,
    DWORD       cEntries
) ;

BOOL APIENTRY DoRealizePalette
(
    PLOCALDC	pLocalDC
);

BOOL APIENTRY DoHeader
(
    PLOCALDC pLocalDC,
    PENHMETAHEADER pemfheader
) ;

BOOL APIENTRY DoEOF
(
    PLOCALDC  pLocalDC
) ;


#endif  // _MF3216_ENTRY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\mf3216\bitmaps.c ===
/*****************************************************************************
 *
 * bitmaps - Entry points for Win32 to Win 16 converter
 *
 * History:
 *  Sep 1992    -by-    Hock San Lee    [hockl]
 * Big rewrite.
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop

HDC hdcMakeCompatibleDC(LPXFORM lpxform);

HBITMAP CreateMonoDib(LPBITMAPINFO pbmi, CONST BYTE * pjBits, UINT iUsage);

BOOL bEmitBitmap(PLOCALDC pLocalDC, HBITMAP hbm,
        LONG xDst, LONG yDst, LONG cxDst, LONG cyDst,
        LONG xSrc, LONG ySrc, LONG cxSrc, LONG cySrc, DWORD rop);

#define ABS(A)      ((A) < 0 ? (-(A)) : (A))

BOOL APIENTRY DoStretchBltAlt
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop,
 LONG         xSrc,
 LONG         ySrc,
 LONG         cxSrc,
 LONG         cySrc,
 HDC          hdcSrc,
 HBITMAP      hbmSrc,
 PXFORM       pxformSrc
);

BOOL APIENTRY DoRotatedStretchBlt
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop,
 LONG         xSrc,
 LONG         ySrc,
 LONG         cxSrc,
 LONG         cySrc,
 PXFORM       pxformSrc,
 DWORD        iUsageSrc,
 PBITMAPINFO  lpBitmapInfo,
 DWORD        cbBitmapInfo,
 LPBYTE       lpBits
);

BOOL APIENTRY DoMaskBltNoSrc
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop4,
 PXFORM       pxformSrc,
 LONG         xMask,
 LONG         yMask,
 DWORD        iUsageMask,
 PBITMAPINFO  lpBitmapInfoMask,
 DWORD        cbBitmapInfoMask,
 LPBYTE       lpBitsMask,
 DWORD        cbBitsMask
);



/***************************************************************************
 * SetDIBitsToDevice - Win32 to Win16 Metafile Converter Entry Point
 *
 *  CR2: Notes...
 *      The xDib, yDib, cxDib, & cyDib are in device units.  These must be
 *      converted to logical units for the stretchblt.
 **************************************************************************/
BOOL APIENTRY DoSetDIBitsToDevice
(
PLOCALDC     pLocalDC,
LONG         xDst,
LONG         yDst,
LONG         xDib,
LONG         yDib,
LONG         cxDib,
LONG         cyDib,
DWORD        iUsage,
DWORD        iStartScan,
DWORD        cScans,
LPBITMAPINFO lpBitmapInfo,
DWORD        cbBitmapInfo,
LPBYTE       lpBits,
DWORD        cbBits
)
{
    BOOL    b ;
    LPBITMAPINFO pbmi;
    POINTL       ptlDst;
    RECTL        rclDst;
    LONG         height;

    b = FALSE;

    if (!cbBitmapInfo)
    return(FALSE);

    // Adjust the height of the bitmap we're going to Blt.

    pbmi = (LPBITMAPINFO) LocalAlloc(LMEM_FIXED, cbBitmapInfo);
    if (pbmi == (LPBITMAPINFO) NULL)
        goto dsdbd_exit;

    RtlCopyMemory(pbmi, lpBitmapInfo, cbBitmapInfo);
    pbmi->bmiHeader.biHeight = cScans;
    pbmi->bmiHeader.biSizeImage = cbBits;

// We will convert it into a StretchBlt call.  But first we have to
// transform the destination rectangle.  In SetDIBitsToDevice, the destination
// rectangle is in device units but in StretchBlt, it is in logical units.

// Transform the destination origin to the device units on the original device.

    ptlDst.x = xDst;
    ptlDst.y = yDst;
    if (!bXformRWorldToRDev(pLocalDC, &ptlDst, 1))
        goto dsdbd_exit;

// Transform the destination rectangle to record time world coordinates.

    rclDst.left   = ptlDst.x;
    rclDst.top    = ptlDst.y;
    rclDst.right  = ptlDst.x + cxDib;
    rclDst.bottom = ptlDst.y + cyDib;
    if (!bXformRDevToRWorld(pLocalDC, (PPOINTL) &rclDst, 2))
        goto dsdbd_exit;

    // WINBUG #99421 4-17-2000 bhouse Top-Down DIBs are not supported properly
    // We need to check for negative heights and adjust appropriately
    height = ABS(pbmi->bmiHeader.biHeight);

    b = DoStretchBlt
    (
        pLocalDC,
        rclDst.left,
        rclDst.top,
        rclDst.right - rclDst.left,
        rclDst.bottom - rclDst.top,
        SRCCOPY,
        xDib,
                    // dib to bitmap units
        height - yDib - cyDib + (LONG) iStartScan,
        cxDib,
        cyDib,
        &xformIdentity,     // source is in device units
        iUsage,
        pbmi,
        cbBitmapInfo,
        lpBits,
        cbBits
    );

dsdbd_exit:
    if (pbmi)
        LocalFree(pbmi);

    return(b);
}


/***************************************************************************
 * StretchDIBits - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL APIENTRY DoStretchDIBits
(
PLOCALDC     pLocalDC,
LONG         xDst,
LONG         yDst,
LONG         cxDst,
LONG         cyDst,
DWORD        rop,
LONG         xDib,
LONG         yDib,
LONG         cxDib,
LONG         cyDib,
DWORD        iUsage,
LPBITMAPINFO lpBitmapInfo,
DWORD        cbBitmapInfo,
LPBYTE       lpBits,
DWORD        cbBits
)
{
    BOOL    b ;
    LONG    height;

    // WINBUG #99421 4-17-2000 bhouse Top-Down DIBs are not supported properly
    // We need to check for negative heights and adjust appropriately
    height = ABS(lpBitmapInfo->bmiHeader.biHeight);

    b = DoStretchBlt
        (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        rop,
        xDib,
            ISSOURCEINROP3(rop)
                    // dib to bitmap units
          ? height  - yDib - cyDib
          : 0,
        cxDib,
        cyDib,
        &xformIdentity,     // source is in device units
        iUsage,
        lpBitmapInfo,
        cbBitmapInfo,
        lpBits,
        cbBits
        );

        return(b) ;
}


/***************************************************************************
 *  StretchBltAlt
 **************************************************************************/
BOOL APIENTRY DoStretchBltAlt
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop,
 LONG         xSrc,
 LONG         ySrc,
 LONG         cxSrc,
 LONG         cySrc,
 HDC          hdcSrc,
 HBITMAP      hbmSrc,
 PXFORM       pxformSrc
)
{
BITMAPINFOHEADER bmih;
DWORD            cbBitmapInfo;
LPBITMAPINFO     lpBitmapInfo;
DWORD            cbBits;
LPBYTE           lpBits;
BOOL         b;

    b = FALSE;
    lpBitmapInfo = (LPBITMAPINFO) NULL;
    lpBits       = (LPBYTE) NULL;

    if (!ISSOURCEINROP3(rop))
        return
        (
        DoStretchBlt
        (
            pLocalDC,
            xDst,
            yDst,
            cxDst,
            cyDst,
            rop,
            0,
            0,
            0,
            0,
            (PXFORM) NULL,
            0,
            (PBITMAPINFO) NULL,
            0,
            (LPBYTE) NULL,
            0
        )
        );

    bmih.biSize = sizeof(BITMAPINFOHEADER);
    bmih.biBitCount = 0;    // don't fill in color table
    bmih.biCompression = BI_RGB;

    if (!GetDIBits(hdcSrc,
               hbmSrc,
               0,
               0,
               (LPBYTE) NULL,
               (LPBITMAPINFO) &bmih,
               DIB_RGB_COLORS))
        goto dsba_exit;

    // Compute size of the bitmap info with color table.

    cbBitmapInfo= sizeof(BITMAPINFOHEADER);
    if (bmih.biBitCount == 16 || bmih.biBitCount == 32)
        cbBitmapInfo += 3 * sizeof(DWORD);
    else if (bmih.biClrUsed)
        cbBitmapInfo += bmih.biClrUsed * sizeof(RGBQUAD);
    else if (bmih.biBitCount < 16)
        cbBitmapInfo += (1 << bmih.biBitCount) * sizeof(RGBQUAD);

    // Compute size of the buffer required for bitmap bits.

    if (bmih.biSizeImage)
        cbBits = bmih.biSizeImage;
    else
            cbBits = CJSCAN(bmih.biWidth,bmih.biPlanes, bmih.biBitCount) *
                    ABS(bmih.biHeight);

    lpBitmapInfo = (LPBITMAPINFO) LocalAlloc(LMEM_FIXED, cbBitmapInfo);
    if (lpBitmapInfo == (LPBITMAPINFO) NULL)
        goto dsba_exit;

    lpBits = (LPBYTE) LocalAlloc(LMEM_FIXED, cbBits);
    if (lpBits == (LPBYTE) NULL)
        goto dsba_exit;

    // Get bitmap info and bits.

    *(PBITMAPINFOHEADER) lpBitmapInfo = bmih;

    if (!GetDIBits(hdcSrc,
               hbmSrc,
               0,
               (UINT) bmih.biHeight,
               lpBits,
               lpBitmapInfo,
               DIB_RGB_COLORS))
        goto dsba_exit;

    // Call DoStretchBlt.

    b = DoStretchBlt
        (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        rop,
        xSrc,
        ySrc,
        cxSrc,
        cySrc,
        pxformSrc,
        DIB_RGB_COLORS,
        lpBitmapInfo,
        cbBitmapInfo,
        lpBits,
        cbBits
        );

dsba_exit:
    if (lpBitmapInfo)
        LocalFree((HANDLE) lpBitmapInfo);
    if (lpBits)
        LocalFree((HANDLE) lpBits);

    return(b);
}


/***************************************************************************
 *  StretchBlt  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL APIENTRY DoStretchBlt
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop,
 LONG         xSrc,
 LONG         ySrc,
 LONG         cxSrc,
 LONG         cySrc,
 PXFORM       pxformSrc,
 DWORD        iUsageSrc,
 PBITMAPINFO  lpBitmapInfo,
 DWORD        cbBitmapInfo,
 LPBYTE       lpBits,
 DWORD        cbBits
)
{
BOOL    b;
RECTL   rclDst,
        rclSrc;

// Handle strange destination transform separately.

    if (pLocalDC->flags & STRANGE_XFORM)
        return
        (
        DoRotatedStretchBlt
        (
            pLocalDC,
            xDst,
            yDst,
            cxDst,
            cyDst,
            rop,
            xSrc,
            ySrc,
            cxSrc,
            cySrc,
            pxformSrc,
            iUsageSrc,
            lpBitmapInfo,
            cbBitmapInfo,
            lpBits
        )
        );

// Do stretchblt with a simple destination transform.

    // Translate the dest rectangle

    rclDst.left   = xDst;
    rclDst.top    = yDst;
    rclDst.right  = xDst + cxDst;
    rclDst.bottom = yDst + cyDst;
    if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) &rclDst, 2))
        return(FALSE);

// Handle stretchblt without source

    if (!ISSOURCEINROP3(rop))
    {
        // Emit the Win16 metafile record.

        b = bEmitWin16BitBltNoSrc(pLocalDC,
                      (SHORT) rclDst.left,
                      (SHORT) rclDst.top,
                      (SHORT) (rclDst.right - rclDst.left),
                      (SHORT) (rclDst.bottom - rclDst.top),
                      rop);
        return(b);
    }

// Handle stretchblt with source

        // Note: Both Win32 and Win16 DIB Bitmaps are DWord aligned.

        // Make sure the source xform is valid.
        // The source is not allowed to have a rotation or shear.

        if (bRotationTest(pxformSrc) == TRUE)
        {
            RIP("MF3216: DoStretchBlt - Invalid source xform\n");
            SetLastError(ERROR_INVALID_DATA);
        return(FALSE);
        }

    // Translate the source rectangle.  Win3.1 assumes that the
    // source rectangle is in bitmap units.

    rclSrc.left   = xSrc;
    rclSrc.top    = ySrc;
    rclSrc.right  = xSrc + cxSrc;
    rclSrc.bottom = ySrc + cySrc;
    if (!bXformWorkhorse((PPOINTL) &rclSrc, 2, pxformSrc))
        return(FALSE);

// The win3.1 StretchBlt metafile record only accepts win3.1 standard
// bitmap with DIB_RGB_COLORS usage.  If this is not the case, we have
// to convert it to a standard bitmap.

    if (iUsageSrc != DIB_RGB_COLORS
     || lpBitmapInfo->bmiHeader.biPlanes != 1
     || !(lpBitmapInfo->bmiHeader.biBitCount == 1
       || lpBitmapInfo->bmiHeader.biBitCount == 4
       || lpBitmapInfo->bmiHeader.biBitCount == 8
       || lpBitmapInfo->bmiHeader.biBitCount == 24)
     || lpBitmapInfo->bmiHeader.biCompression != BI_RGB)
    {
        HBITMAP hbmSrc;
        DWORD fdwInit;

        b = FALSE;
        hbmSrc = (HBITMAP) 0;

        if( ( lpBitmapInfo->bmiHeader.biCompression == BI_RGB ) ||
            ( lpBitmapInfo->bmiHeader.biCompression == BI_BITFIELDS ) )
        {
            fdwInit = CBM_INIT | CBM_CREATEDIB;
        }
        else
        {
            fdwInit = CBM_INIT;
        }

// Create the source bitmap.
// Use the helper DC in CreateDIBitmap so that the colors get bind correctly.

        if (!(hbmSrc = CreateDIBitmap(
                pLocalDC->hdcHelper,
                (LPBITMAPINFOHEADER) lpBitmapInfo,
                fdwInit,
                lpBits,
                lpBitmapInfo,
                (UINT) iUsageSrc)))
        goto dsb_internal_exit;

// Emit the bitmap.

        b = bEmitBitmap(pLocalDC,
                hbmSrc,
                rclDst.left,
                rclDst.top,
                rclDst.right - rclDst.left,
                rclDst.bottom - rclDst.top,
                rclSrc.left,
                rclSrc.top,
                rclSrc.right - rclSrc.left,
                rclSrc.bottom - rclSrc.top,
                rop);

    dsb_internal_exit:
        if (hbmSrc)
        DeleteObject(hbmSrc);
    }
    else
    {
// Handle the standard formats.

        // Emit a Win16 metafile record.

        // Recalculate size of bitmap info with color
        // table to trim any extra data that wouldn't
        // be skipped properly during playback.

        cbBitmapInfo = lpBitmapInfo->bmiHeader.biSize;

        if (lpBitmapInfo->bmiHeader.biClrUsed)
            cbBitmapInfo += lpBitmapInfo->bmiHeader.biClrUsed * sizeof(RGBQUAD);
        else if (lpBitmapInfo->bmiHeader.biBitCount < 16)
            cbBitmapInfo += (1 << lpBitmapInfo->bmiHeader.biBitCount) * sizeof(RGBQUAD);

        b = bEmitWin16StretchBlt(pLocalDC,
                (SHORT) rclDst.left,
                (SHORT) rclDst.top,
                (SHORT) (rclDst.right - rclDst.left),
                (SHORT) (rclDst.bottom - rclDst.top),
                (SHORT) rclSrc.left,
                (SHORT) rclSrc.top,
                (SHORT) (rclSrc.right - rclSrc.left),
                (SHORT) (rclSrc.bottom - rclSrc.top),
                rop,
                lpBitmapInfo,
                cbBitmapInfo,
                lpBits,
                cbBits);
    }

    return(b);
}

BOOL APIENTRY DoRotatedStretchBlt
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop,
 LONG         xSrc,
 LONG         ySrc,
 LONG         cxSrc,
 LONG         cySrc,
 PXFORM       pxformSrc,
 DWORD        iUsageSrc,
 PBITMAPINFO  lpBitmapInfo,
 DWORD        cbBitmapInfo,
 LPBYTE       lpBits
)
{
BOOL    b;
POINTL  aptlDst[4];
RECTL   rclBndDst;
HDC     hdcShadow, hdcSrc;
HBITMAP hbmShadow, hbmShadowOld, hbmSrc, hbmSrcOld;
PBITMAPINFO pbmiShadow;

    b = FALSE;
    hdcShadow = hdcSrc = (HDC) 0;
    hbmShadow = hbmShadowOld = hbmSrc = hbmSrcOld = (HBITMAP) 0;
    pbmiShadow = (PBITMAPINFO) NULL;

// First, compute the bounds of the destination rectangle.

    aptlDst[0].x = xDst;
    aptlDst[0].y = yDst;
    aptlDst[1].x = xDst + cxDst;
    aptlDst[1].y = yDst;
    aptlDst[2].x = xDst + cxDst;
    aptlDst[2].y = yDst + cyDst;
    aptlDst[3].x = xDst;
    aptlDst[3].y = yDst + cyDst;

    if (!bXformRWorldToPPage(pLocalDC, aptlDst, 4))
        goto drsb_exit;

    rclBndDst.left   = min(aptlDst[0].x,min(aptlDst[1].x,min(aptlDst[2].x,aptlDst[3].x)));
    rclBndDst.top    = min(aptlDst[0].y,min(aptlDst[1].y,min(aptlDst[2].y,aptlDst[3].y)));
    rclBndDst.right  = max(aptlDst[0].x,max(aptlDst[1].x,max(aptlDst[2].x,aptlDst[3].x)));
    rclBndDst.bottom = max(aptlDst[0].y,max(aptlDst[1].y,max(aptlDst[2].y,aptlDst[3].y)));

// Prepare the source if any.

    if (ISSOURCEINROP3(rop))
    {
// Create a compatible shadow DC with the destination transform.

        if (!(hdcShadow = hdcMakeCompatibleDC(&pLocalDC->xformRWorldToPPage)))
        goto drsb_exit;

// Create a shadow bitmap the size of the destination rectangle bounds.
// Use the helper DC in CreateDIBitmap so that the colors get bind correctly.

        pbmiShadow = (PBITMAPINFO) LocalAlloc(LMEM_FIXED, cbBitmapInfo);
        if (pbmiShadow == (PBITMAPINFO) NULL)
        goto drsb_exit;
        RtlCopyMemory(pbmiShadow, lpBitmapInfo, cbBitmapInfo);
        pbmiShadow->bmiHeader.biWidth  = rclBndDst.right - rclBndDst.left;
        pbmiShadow->bmiHeader.biHeight = rclBndDst.bottom - rclBndDst.top;
        pbmiShadow->bmiHeader.biSizeImage = 0;
        if (!(hbmShadow = CreateDIBitmap(pLocalDC->hdcHelper,
            (LPBITMAPINFOHEADER) pbmiShadow, CBM_CREATEDIB,
            (LPBYTE) NULL, pbmiShadow, iUsageSrc)))
        goto drsb_exit;

// Select the bitmap.

        if (!(hbmShadowOld = (HBITMAP) SelectObject(hdcShadow, hbmShadow)))
        goto drsb_exit;

// Create a compatible source DC with the given source transform.

        if (!(hdcSrc = hdcMakeCompatibleDC(pxformSrc)))
        goto drsb_exit;

// Create the source bitmap.
// Use the helper DC in CreateDIBitmap so that the colors get bind correctly.

        if (!(hbmSrc = CreateDIBitmap(pLocalDC->hdcHelper,
                (LPBITMAPINFOHEADER) lpBitmapInfo,
                CBM_INIT | CBM_CREATEDIB,
                lpBits,
                (LPBITMAPINFO) lpBitmapInfo,
                (UINT) iUsageSrc)))
        goto drsb_exit;

// Select the bitmap.

        if (!(hbmSrcOld = (HBITMAP) SelectObject(hdcSrc, hbmSrc)))
        goto drsb_exit;

// Set up the viewport origin of the shadow DC so that the destination
// rectangle will map into coordinates within the shadow bitmap.

        OffsetViewportOrgEx(hdcShadow, (int) -rclBndDst.left,
         (int) -rclBndDst.top, (LPPOINT) NULL);

// Stretch the source to the shadow.

        if (!StretchBlt
           (
               hdcShadow,
               (int) xDst,
               (int) yDst,
               (int) cxDst,
               (int) cyDst,
               hdcSrc,
               (int) xSrc,
               (int) ySrc,
               (int) cxSrc,
               (int) cySrc,
               SRCCOPY
           )
        )
        goto drsb_exit;

// Deselect the shadow bitmap.

        if (!SelectObject(hdcShadow, hbmShadowOld))
        goto drsb_exit;

    }

// Save the DC so that we can restore the clipping when we are done

    if (!DoSaveDC(pLocalDC))
        goto drsb_exit;

// Set up the clipping rectangle on the destination.

        if (!DoClipRect(pLocalDC, xDst, yDst,
                        xDst + cxDst, yDst + cyDst, EMR_INTERSECTCLIPRECT))
    {
            (void) DoRestoreDC(pLocalDC, -1);
        goto drsb_exit;
    }

// Blt the shadow to the destination.

    // Emit a Win16 metafile record.

    if (ISSOURCEINROP3(rop))
        b = bEmitBitmap(pLocalDC,
                hbmShadow,
                rclBndDst.left,
                rclBndDst.top,
                rclBndDst.right - rclBndDst.left,
                rclBndDst.bottom - rclBndDst.top,
                0,
                0,
                rclBndDst.right - rclBndDst.left,
                rclBndDst.bottom - rclBndDst.top,
                rop);
    else
        b = bEmitWin16BitBltNoSrc(pLocalDC,
                (SHORT) rclBndDst.left,
                (SHORT) rclBndDst.top,
                (SHORT) (rclBndDst.right - rclBndDst.left),
                (SHORT) (rclBndDst.bottom - rclBndDst.top),
                rop);

// Restore the clipping region.

        (void) DoRestoreDC(pLocalDC, -1);

// Cleanup

drsb_exit:

    if (hbmShadowOld)
        SelectObject(hdcShadow, hbmShadowOld);
    if (hbmShadow)
        DeleteObject(hbmShadow);
    if (hdcShadow)
        DeleteDC(hdcShadow);

    if (hbmSrcOld)
        SelectObject(hdcSrc, hbmSrcOld);
    if (hbmSrc)
        DeleteObject(hbmSrc);
    if (hdcSrc)
        DeleteDC(hdcSrc);

    if (pbmiShadow)
        LocalFree((HANDLE) pbmiShadow);
    return(b);
}

/*****************************************************************************
 * hdcMakeCompatibleDC
 *   Create a compatible DC with the given transform.
 ****************************************************************************/
HDC hdcMakeCompatibleDC(LPXFORM lpxform)
{
HDC     hdc;

    hdc = CreateCompatibleDC((HDC) 0);
    if(hdc == 0)
    {
        RIP("MF3216: hdcMakeCompatibleDC, CreateCompatibleDC failed\n");
        return (HDC)0;
    }

    // Must be in the advanced graphics mode to modify the world transform.

    SetGraphicsMode(hdc, GM_ADVANCED);

    // Set the transform.

    if (!SetWorldTransform(hdc, lpxform))
    {
    DeleteDC(hdc);
        RIP("MF3216: hdcMakeCompatibleDC, SetWorldTransform failed\n");
    return((HDC) 0);
    }

    return(hdc);
}

/***************************************************************************
 * bEmitBitmap
 **************************************************************************/
BOOL bEmitBitmap
(
PLOCALDC pLocalDC,
HBITMAP  hbm,
LONG     xDst,
LONG     yDst,
LONG     cxDst,
LONG     cyDst,
LONG     xSrc,
LONG     ySrc,
LONG     cxSrc,
LONG     cySrc,
DWORD    rop
)
{
BITMAPINFOHEADER bmih;
DWORD            cbBitmapInfo;
LPBITMAPINFO     lpBitmapInfo;
DWORD            cbBits;
LPBYTE           lpBits;
BOOL         b;

    b = FALSE;
    lpBitmapInfo = (LPBITMAPINFO) NULL;
    lpBits       = (LPBYTE) NULL;

    bmih.biSize = sizeof(BITMAPINFOHEADER);
    bmih.biBitCount = 0;    // don't fill in color table
    bmih.biCompression = BI_RGB;
    if (!GetDIBits(pLocalDC->hdcHelper, hbm, 0, 0,
               (LPBYTE) NULL, (LPBITMAPINFO) &bmih, DIB_RGB_COLORS))
        goto eb_exit;

    // Compute size of the bitmap info with color table.

    cbBitmapInfo= sizeof(BITMAPINFOHEADER);
    if (bmih.biPlanes != 1 || bmih.biBitCount == 16 || bmih.biBitCount == 32)
    {
        bmih.biPlanes       = 1;
        bmih.biBitCount     = 24;
        bmih.biCompression  = BI_RGB;
        bmih.biSizeImage    = 0;
        bmih.biClrUsed      = 0;
        bmih.biClrImportant = 0;
    }
    else if (bmih.biClrUsed)
        cbBitmapInfo += bmih.biClrUsed * sizeof(RGBQUAD);
    else if (bmih.biBitCount < 16)
        cbBitmapInfo += (1 << bmih.biBitCount) * sizeof(RGBQUAD);

    // Compute size of the buffer required for bitmap bits.

    if (bmih.biSizeImage)
        cbBits = bmih.biSizeImage;
    else
            cbBits = CJSCAN(bmih.biWidth,bmih.biPlanes, bmih.biBitCount) *
                    ABS(bmih.biHeight);

    lpBitmapInfo = (LPBITMAPINFO) LocalAlloc(LMEM_FIXED, cbBitmapInfo);
    if (lpBitmapInfo == (LPBITMAPINFO) NULL)
        goto eb_exit;

    lpBits = (LPBYTE) LocalAlloc(LMEM_FIXED, cbBits);
    if (lpBits == (LPBYTE) NULL)
        goto eb_exit;

    // Get bitmap info and bits.

    *(PBITMAPINFOHEADER) lpBitmapInfo = bmih;

    if (!GetDIBits(pLocalDC->hdcHelper,
               hbm,
               0,
               (UINT) ABS(bmih.biHeight),
               lpBits,
               lpBitmapInfo,
               DIB_RGB_COLORS))
        goto eb_exit;

    // Emit the metafile record.

    b = bEmitWin16StretchBlt(pLocalDC,
                (SHORT) xDst,
                (SHORT) yDst,
                (SHORT) cxDst,
                (SHORT) cyDst,
                (SHORT) xSrc,
                (SHORT) ySrc,
                (SHORT) cxSrc,
                (SHORT) cySrc,
                rop,
                lpBitmapInfo,
                cbBitmapInfo,
                lpBits,
                cbBits);
eb_exit:
    if (lpBitmapInfo)
        LocalFree((HANDLE) lpBitmapInfo);
    if (lpBits)
        LocalFree((HANDLE) lpBits);

    return(b);
}


/***************************************************************************
 *  MaskBlt  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL APIENTRY DoMaskBlt
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop4,
 LONG         xSrc,
 LONG         ySrc,
 PXFORM       pxformSrc,
 DWORD        iUsageSrc,
 PBITMAPINFO  lpBitmapInfoSrc,
 DWORD        cbBitmapInfoSrc,
 LPBYTE       lpBitsSrc,
 DWORD        cbBitsSrc,
 LONG         xMask,
 LONG         yMask,
 DWORD        iUsageMask,
 PBITMAPINFO  lpBitmapInfoMask,
 DWORD        cbBitmapInfoMask,
 LPBYTE       lpBitsMask,
 DWORD        cbBitsMask
)
{
    BOOL    b;
    DWORD   rop1;
    DWORD   rop0;
    HDC     hdcMask, hdcSrc;
    HBITMAP hbmMask, hbmMaskOld, hbmSrc, hbmSrcOld;
    RECTL   rclMask;

    b    = FALSE;
    hdcMask = hdcSrc = (HDC) 0;
    hbmMask = hbmMaskOld = hbmSrc = hbmSrcOld = (HBITMAP) 0;

    rop0 = rop4 >> 8;           // rop for 0's
    rop1 = rop4 & 0xFF0000;     // rop for 1's

// If no mask is given, the mask is assumed to contain all 1's.
// This is equivalent to a BitBlt using the low rop.

    if (!cbBitmapInfoMask)
    return
    (
        DoStretchBlt
        (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        rop1,
        xSrc,
        ySrc,
        cxDst,
        cyDst,
        pxformSrc,
        iUsageSrc,
        lpBitmapInfoSrc,
        cbBitmapInfoSrc,
        lpBitsSrc,
        cbBitsSrc
        )
    );

// Handle MaskBlt with no source bitmap.

    if (!ISSOURCEINROP3(rop4))
    return
    (
        DoMaskBltNoSrc
        (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        rop4,
        pxformSrc,
        xMask,
        yMask,
        iUsageMask,
        lpBitmapInfoMask,
        cbBitmapInfoMask,
        lpBitsMask,
        cbBitsMask
        )
    );

// Create a compatible mask DC.

    if (!(hdcMask = CreateCompatibleDC((HDC) 0)))
    goto dmb_exit;

// Must be in the advanced graphics mode to modify the world transform.

    SetGraphicsMode(hdcMask, GM_ADVANCED);

// Create the mask bitmap.
// Make it as big as the source and initialize it.

    // Create the mask bitmap as big as the source bitmap.

    if (!(hbmMask = CreateBitmap((int) lpBitmapInfoSrc->bmiHeader.biWidth,
             (int) lpBitmapInfoSrc->bmiHeader.biHeight,
             1, 1, (CONST VOID *) NULL)))
    goto dmb_exit;

    // Select the bitmap.

    if (!(hbmMaskOld = (HBITMAP) SelectObject(hdcMask, hbmMask)))
    goto dmb_exit;

    // Initialize the mask bitmap to 0's.

    if (!PatBlt(hdcMask,0,0,(int) lpBitmapInfoSrc->bmiHeader.biWidth,
        (int) lpBitmapInfoSrc->bmiHeader.biHeight,BLACKNESS))
    goto dmb_exit;

    // Compute the mask rectangle.
    // The mask bitmap is aligned against the source device rectangle.

    rclMask.left   = xSrc;
    rclMask.top    = ySrc;
    rclMask.right  = xSrc + cxDst;
    rclMask.bottom = ySrc + cyDst;
    if (!bXformWorkhorse((PPOINTL) &rclMask, 2, pxformSrc))
    goto dmb_exit;

    if (rclMask.left > rclMask.right)
    rclMask.left = rclMask.right /* + 1 */;// align the mask against the left edge

    if (rclMask.top > rclMask.bottom)
    rclMask.top = rclMask.bottom /* + 1 */;// align the mask against the top edge

    // Set the mask bits.

    if (!StretchDIBits(hdcMask,
           (int) rclMask.left - xMask,
           (int) rclMask.top  - yMask,
           (int) lpBitmapInfoMask->bmiHeader.biWidth,
           (int) lpBitmapInfoMask->bmiHeader.biHeight,
           (int) 0,
           (int) 0,
           (int) lpBitmapInfoMask->bmiHeader.biWidth,
           (int) lpBitmapInfoMask->bmiHeader.biHeight,
           (CONST VOID *) lpBitsMask,
           (LPBITMAPINFO) lpBitmapInfoMask,
           (UINT) iUsageMask,
           SRCCOPY))
    goto dmb_exit;

// Set the source transform in the mask DC.

    if (!SetWorldTransform(hdcMask, pxformSrc))
    goto dmb_exit;

// Create a compatible source DC with the given source transform.

    if (!(hdcSrc = hdcMakeCompatibleDC(pxformSrc)))
    goto dmb_exit;

// Create the source bitmap.
// We cannot use CBM_CREATEDIB option here because index 0 does not
// neccesarily contain black and index 15 or 255 does not have to be white.
// We need a compatible bitmap that contain the standard color table so
// that we can perform the following rop operations to emulate the maskblt.
// Gdi uses rgb colors to perform rop operations in dibs, not color indices!
// The helper DC is needed to create the compatible format bitmap.

    if (!(hbmSrc = CreateDIBitmap(pLocalDC->hdcHelper,
            (LPBITMAPINFOHEADER) lpBitmapInfoSrc,
            CBM_INIT,
            lpBitsSrc,
            (LPBITMAPINFO) lpBitmapInfoSrc,
            (UINT) iUsageSrc)))
    goto dmb_exit;

// Select the bitmap.

    if (!(hbmSrcOld = (HBITMAP) SelectObject(hdcSrc, hbmSrc)))
    goto dmb_exit;

// We need to handle the low rop (mask bit 1) and high rop (mask bit 0)
// separately.  For each rop, we need to go through two passes.
//
// For the low rop (mask bit 1), we use the following rop table:
//
//  P S D | R1  R2
//  ------+--------
//  0 0 0 | 0   x
//  0 0 1 | 1   x
//  0 1 0 | x   0
//  0 1 1 | x   1
//  1 0 0 | 0   x
//  1 0 1 | 1   x
//  1 1 0 | x   0
//  1 1 1 | x   1
//
// In the first pass, we AND the mask to the source bitmap to remove
// the mask 0 bits.  This is then used to get the result (R1) for the
// bitblt involving source 1's.
//
// In the second pass, we OR the NOT of the mask to the source bitmap
// to obtain the source 0 bits.  This is then used to get the result (R2)
// for the bitblt involving source 0's.

// AND the mask to the source bitmap to remove the mask 0 bits.

    if (!BitBlt(hdcSrc,
               (int) xSrc, (int) ySrc,
               (int) cxDst, (int) cyDst,
               hdcMask,
               (int) xSrc, (int) ySrc,
               SRCAND))
    goto dmb_exit;

// Get the result (R1) for the bits involving source 1's.

    if (!DoStretchBltAlt
     (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        (rop1 & 0xCC0000) | 0x220000,
        xSrc,
        ySrc,
        cxDst,
        cyDst,
        hdcSrc,
        hbmSrc,
        pxformSrc
     )
       )
    goto dmb_exit;

// OR the NOT of the mask to the source bitmap to obtain the source 0 bits.

    if (!BitBlt(hdcSrc,
               (int) xSrc, (int) ySrc,
               (int) cxDst, (int) cyDst,
               hdcMask,
               (int) xSrc, (int) ySrc,
               MERGEPAINT))
    goto dmb_exit;

// Get the result (R2) for the bitblt involving source 0's.

    if (!DoStretchBltAlt
     (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        (rop1 & 0x330000) | 0x880000,
        xSrc,
        ySrc,
        cxDst,
        cyDst,
        hdcSrc,
        hbmSrc,
        pxformSrc
     )
       )
    goto dmb_exit;

// For the high rop (mask bit 0), we use the following rop table:
//
//  P S D | R1  R2
//  ------+--------
//  0 0 0 | 0   x
//  0 0 1 | 1   x
//  0 1 0 | x   0
//  0 1 1 | x   1
//  1 0 0 | 0   x
//  1 0 1 | 1   x
//  1 1 0 | x   0
//  1 1 1 | x   1
//
// In the first pass, we AND the NOT of the mask to the source bitmap to remove
// the mask 1 bits.  This is then used to get the result (R1) for the
// bitblt involving source 1's.
//
// In the second pass, we OR the mask to the source bitmap
// to obtain the source 0 bits.  This is then used to get the result (R2)
// for the bitblt involving source 0's.

// Restore the source bits.

    if (!SelectObject(hdcSrc, hbmSrcOld))
    goto dmb_exit;

    if (!SetDIBits(pLocalDC->hdcHelper,
           hbmSrc,
           0,
           (UINT) lpBitmapInfoSrc->bmiHeader.biHeight,
           (CONST VOID *) lpBitsSrc,
           (LPBITMAPINFO) lpBitmapInfoSrc,
           (UINT) iUsageSrc))
    goto dmb_exit;

    if (!SelectObject(hdcSrc, hbmSrc))
    goto dmb_exit;

// AND the NOT of the mask to the source bitmap to remove the mask 1 bits.

    if (!BitBlt(hdcSrc,
               (int) xSrc, (int) ySrc,
               (int) cxDst, (int) cyDst,
               hdcMask,
               (int) xSrc, (int) ySrc,
               0x220326))       // DSna
    goto dmb_exit;

// Get the result (R1) for the bits involving source 1's.

    if (!DoStretchBltAlt
     (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        (rop0 & 0xCC0000) | 0x220000,
        xSrc,
        ySrc,
        cxDst,
        cyDst,
        hdcSrc,
        hbmSrc,
        pxformSrc
     )
       )
    goto dmb_exit;

// OR the mask to the source bitmap to obtain the source 0 bits.

    if (!BitBlt(hdcSrc,
               (int) xSrc, (int) ySrc,
               (int) cxDst, (int) cyDst,
               hdcMask,
               (int) xSrc, (int) ySrc,
               SRCPAINT))
    goto dmb_exit;

// Get the result (R2) for the bitblt involving source 0's.

    if (!DoStretchBltAlt
     (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        (rop0 & 0x330000) | 0x880000,
        xSrc,
        ySrc,
        cxDst,
        cyDst,
        hdcSrc,
        hbmSrc,
        pxformSrc
     )
       )
    goto dmb_exit;

    b = TRUE;

// Cleanup.

dmb_exit:

    if (hbmMaskOld)
    SelectObject(hdcMask, hbmMaskOld);
    if (hbmMask)
    DeleteObject(hbmMask);
    if (hdcMask)
    DeleteDC(hdcMask);

    if (hbmSrcOld)
    SelectObject(hdcSrc, hbmSrcOld);
    if (hbmSrc)
    DeleteObject(hbmSrc);
    if (hdcSrc)
    DeleteDC(hdcSrc);

    return(b);
}

/***************************************************************************
 *  MaskBltNoSrc
 **************************************************************************/
BOOL APIENTRY DoMaskBltNoSrc
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop4,
 PXFORM       pxformSrc,
 LONG         xMask,
 LONG         yMask,
 DWORD        iUsageMask,
 PBITMAPINFO  lpBitmapInfoMask,
 DWORD        cbBitmapInfoMask,
 LPBYTE       lpBitsMask,
 DWORD        cbBitsMask
)
{
    BOOL    b;
    DWORD   rop1;
    DWORD   rop0;
    HDC     hdcMask;
    HBITMAP hbmMask, hbmMaskOld;
    RECTL   rclMask;
    LONG    cxMask, cyMask;

    b    = FALSE;
    hdcMask = (HDC) 0;
    hbmMask = hbmMaskOld = (HBITMAP) 0;

    rop0 = rop4 >> 8;           // rop for 0's
    rop1 = rop4 & 0xFF0000;     // rop for 1's

// When no source bitmap is required in the rop4, the mask is used
// as the source in that the low rop is applied to the corresponding
// mask 1 bits and the high rop is applied to mask 0 bits.  The source
// transform is used to determine the mask rectangle to be used.

// Create a compatible mask DC.

    if (!(hdcMask = CreateCompatibleDC((HDC) 0)))
    goto dmbns_exit;

// Create the mask bitmap.

    if (!(hbmMask = CreateMonoDib(lpBitmapInfoMask, lpBitsMask, (UINT) iUsageMask)))
    goto dmbns_exit;

// Select the bitmap.

    if (!(hbmMaskOld = (HBITMAP) SelectObject(hdcMask, hbmMask)))
    goto dmbns_exit;

// Compute the mask extents.

    rclMask.left   = 0;
    rclMask.top    = 0;
    rclMask.right  = cxDst;
    rclMask.bottom = cyDst;
    if (!bXformWorkhorse((PPOINTL) &rclMask, 2, pxformSrc))
    goto dmbns_exit;

    cxMask = rclMask.right - rclMask.left;
    cyMask = rclMask.bottom - rclMask.top;

// Align the mask rectangle.

    if (cxMask < 0)
    xMask = xMask - cxMask + 1;
    if (cyMask < 0)
    yMask = yMask - cyMask + 1;

// We need to handle the low rop (mask bit 1) and high rop (mask bit 0)
// separately.
//
// For the low rop (mask bit 1), we use the following rop table:
//
//  P M D | R
//  ------+---
//  0 0 0 | 0
//  0 0 1 | 1
//  0 1 0 | x
//  0 1 1 | x
//  1 0 0 | 0
//  1 0 1 | 1
//  1 1 0 | x
//  1 1 1 | x
//
// The above rop will give us the result for bits that correspond to 1's
// in the mask bitmap.  The destination bits that correspond to the 0 mask
// bits will not be changed.  We effectively treat the mask as the source
// in the operation.

// Get the result (R) for the bits involving mask 1's.

    if (!DoStretchBltAlt
     (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        (rop1 & 0xCC0000) | 0x220000,
        xMask,
        yMask,
        cxMask,
        cyMask,
        hdcMask,
        hbmMask,
        &xformIdentity
     )
       )
    goto dmbns_exit;
#if 0
    DoStretchBlt
        (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        (rop1 & 0xCC0000) | 0x220000,
        xMask,
        yMask,
        cxMask,
        cyMask,
        &xformIdentity,
        iUsageMask,
        lpBitmapInfoMask,
        cbBitmapInfoMask,
        lpBitsMask,
        cbBitsMask
        )
#endif // 0

// For the high rop (mask bit 0), we use the following rop table:
//
//  P M D | R
//  ------+---
//  0 0 0 | x
//  0 0 1 | x
//  0 1 0 | 0
//  0 1 1 | 1
//  1 0 0 | x
//  1 0 1 | x
//  1 1 0 | 0
//  1 1 1 | 1
//
// The above rop will give us the result for bits that correspond to 0's
// in the mask bitmap.  The destination bits that correspond to the 1 mask
// bits will not be changed.  We effectively treat the mask as the source
// in the operation.

// Get the result (R) for the bits involving mask 0's.

    if (!DoStretchBltAlt
     (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        (rop0 & 0x330000) | 0x880000,
        xMask,
        yMask,
        cxMask,
        cyMask,
        hdcMask,
        hbmMask,
        &xformIdentity
     )
       )
    goto dmbns_exit;
#if 0
    DoStretchBlt
        (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        (rop0 & 0x330000) | 0x880000,
        xMask,
        yMask,
        cxMask,
        cyMask,
        &xformIdentity,
        iUsageMask,
        lpBitmapInfoMask,
        cbBitmapInfoMask,
        lpBitsMask,
        cbBitsMask
        )
#endif // 0

    b = TRUE;

// Cleanup.

dmbns_exit:

    if (hbmMaskOld)
    SelectObject(hdcMask, hbmMaskOld);
    if (hbmMask)
    DeleteObject(hbmMask);
    if (hdcMask)
    DeleteDC(hdcMask);

    return(b);
}


/***************************************************************************
 *  PlgBlt  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL APIENTRY DoPlgBlt
(
 PLOCALDC    pLocalDC,
 PPOINTL     pptlDst,
 LONG        xSrc,
 LONG        ySrc,
 LONG        cxSrc,
 LONG        cySrc,
 PXFORM      pxformSrc,
 DWORD       iUsageSrc,
 PBITMAPINFO lpBitmapInfoSrc,
 DWORD       cbBitmapInfoSrc,
 LPBYTE      lpBitsSrc,
 DWORD       cbBitsSrc,
 LONG        xMask,
 LONG        yMask,
 DWORD       iUsageMask,
 PBITMAPINFO lpBitmapInfoMask,
 DWORD       cbBitmapInfoMask,
 LPBYTE      lpBitsMask,
 DWORD       cbBitsMask
)
{
    BOOL    b, bMask;
    DWORD   rop4;
    HDC     hdcSrc, hdcSrcRDev;
    PBITMAPINFO pbmiSrcRDev, pbmiMaskRDev;
    LPBYTE  lpBitsSrcRDev, lpBitsMaskRDev;
    DWORD   cbBitsSrcRDev, cbBitsMaskRDev;
    HBITMAP hbmMask, hbmMaskRDev, hbmSrc, hbmSrcRDev, hbmSrcOld, hbmSrcRDevOld;
    RECTL   rclBndRDev;
    POINTL  aptlDst[4];
    POINT   ptMask;
    BITMAPINFOHEADER bmihMask;

// We are going to convert the PlgBlt into a MaskBlt.  This can be done
// by converting the source and mask bitmaps to the device space of the
// recording device and then maskblt the result.

    b      = FALSE;
    hdcSrc = hdcSrcRDev = (HDC) 0;
    hbmMask = hbmMaskRDev = hbmSrc = hbmSrcRDev = hbmSrcOld = hbmSrcRDevOld = (HBITMAP) 0;
    pbmiSrcRDev = pbmiMaskRDev = (PBITMAPINFO) NULL;
    lpBitsSrcRDev = lpBitsMaskRDev = (LPBYTE) NULL;
    bMask = (cbBitmapInfoMask != 0);

    rop4 = 0xAACC0000;          // rop for MaskBlt

// First, we transform the destination parallelogram to the device space
// of the recording device.  This device parallelogram is then used in
// plgblt'ing the source and mask bitmaps to the device space of the
// recording device.

    aptlDst[0] = pptlDst[0];
    aptlDst[1] = pptlDst[1];
    aptlDst[2] = pptlDst[2];
    aptlDst[3].x = aptlDst[1].x + aptlDst[2].x - aptlDst[0].x;
    aptlDst[3].y = aptlDst[1].y + aptlDst[2].y - aptlDst[0].y;

    if (!bXformRWorldToRDev(pLocalDC, aptlDst, 4))
    goto dpb_exit;

// Find the bounding rectangle of the parallelogram in the recording
// device space.  This rectangle is used as the basis of the MaskBlt call.

    rclBndRDev.left   = min(aptlDst[0].x,min(aptlDst[1].x,min(aptlDst[2].x,aptlDst[3].x)));
    rclBndRDev.top    = min(aptlDst[0].y,min(aptlDst[1].y,min(aptlDst[2].y,aptlDst[3].y)));
    rclBndRDev.right  = max(aptlDst[0].x,max(aptlDst[1].x,max(aptlDst[2].x,aptlDst[3].x)));
    rclBndRDev.bottom = max(aptlDst[0].y,max(aptlDst[1].y,max(aptlDst[2].y,aptlDst[3].y)));

// Offset the device parallelogram to the origin.

    aptlDst[0].x -= rclBndRDev.left; aptlDst[0].y -= rclBndRDev.top;
    aptlDst[1].x -= rclBndRDev.left; aptlDst[1].y -= rclBndRDev.top;
    aptlDst[2].x -= rclBndRDev.left; aptlDst[2].y -= rclBndRDev.top;
    aptlDst[3].x -= rclBndRDev.left; aptlDst[3].y -= rclBndRDev.top;

// Create the source bitmap in the recording device space for MaskBlt.
// The size of the source bitmap is that of rclBndRDev.
// The source image is then plgblt'd into the device parallelogram.
// PlgBlt always takes a source bitmap.

    // Create the original source.

    if (!(hdcSrc = hdcMakeCompatibleDC(pxformSrc)))
    goto dpb_exit;

    if (!(hbmSrc = CreateDIBitmap(hdcSrc,
            (LPBITMAPINFOHEADER) lpBitmapInfoSrc,
            CBM_INIT | CBM_CREATEDIB,
            lpBitsSrc,
            (LPBITMAPINFO) lpBitmapInfoSrc,
            (UINT) iUsageSrc)))
    goto dpb_exit;

    if (!(hbmSrcOld = (HBITMAP) SelectObject(hdcSrc, hbmSrc)))
    goto dpb_exit;

    // Create the source for MaskBlt.

    if (!(hdcSrcRDev = CreateCompatibleDC((HDC) 0)))
    goto dpb_exit;

    pbmiSrcRDev = (PBITMAPINFO) LocalAlloc(LMEM_FIXED, cbBitmapInfoSrc);
    if (pbmiSrcRDev == (PBITMAPINFO) NULL)
    goto dpb_exit;
    RtlCopyMemory(pbmiSrcRDev, lpBitmapInfoSrc, cbBitmapInfoSrc);
    pbmiSrcRDev->bmiHeader.biWidth  = rclBndRDev.right - rclBndRDev.left + 1;
    pbmiSrcRDev->bmiHeader.biHeight = rclBndRDev.bottom - rclBndRDev.top + 1;
    pbmiSrcRDev->bmiHeader.biSizeImage = 0;
    if (!(hbmSrcRDev = CreateDIBitmap(hdcSrcRDev, (LPBITMAPINFOHEADER) pbmiSrcRDev,
            CBM_CREATEDIB, (LPBYTE) NULL, pbmiSrcRDev, iUsageSrc)))
    goto dpb_exit;

    if (!(hbmSrcRDevOld = (HBITMAP) SelectObject(hdcSrcRDev, hbmSrcRDev)))
    goto dpb_exit;

    // PlgBlt the original source bitmap into the source bitmap for MaskBlt.

    if (!PlgBlt(hdcSrcRDev, (LPPOINT) aptlDst, hdcSrc, xSrc, ySrc, cxSrc, cySrc, (HBITMAP) NULL, 0, 0))
    goto dpb_exit;

// Retrieve the source bits for MaskBlt.

    // Get biSizeImage!

    if (!GetDIBits(hdcSrcRDev, hbmSrcRDev, 0, 0, (LPBYTE) NULL, pbmiSrcRDev, iUsageSrc))
    goto dpb_exit;

    // Compute size of the buffer required for source bits.

    if (pbmiSrcRDev->bmiHeader.biSizeImage)
    cbBitsSrcRDev = pbmiSrcRDev->bmiHeader.biSizeImage;
    else
        cbBitsSrcRDev = CJSCAN(pbmiSrcRDev->bmiHeader.biWidth,
                   pbmiSrcRDev->bmiHeader.biPlanes,
                   pbmiSrcRDev->bmiHeader.biBitCount)
             * ABS(pbmiSrcRDev->bmiHeader.biHeight);

    lpBitsSrcRDev = (LPBYTE) LocalAlloc(LMEM_FIXED, cbBitsSrcRDev);
    if (lpBitsSrcRDev == (LPBYTE) NULL)
    goto dpb_exit;

    // Get the source bits.

    if (!GetDIBits(hdcSrcRDev, hbmSrcRDev, 0, (UINT) pbmiSrcRDev->bmiHeader.biHeight,
           lpBitsSrcRDev, pbmiSrcRDev, iUsageSrc))
    goto dpb_exit;

// Create the mask bitmap in the recording device space for MaskBlt.
// The size of the mask bitmap is that of rclBndRDev.
// The mask image is then plgblt'd into the device parallelogram.
// If a mask is not given, create one that describes the parallelogram
// for the source.

    if (bMask)
    {
    // Create the original mask.

    if (!(hbmMask = CreateMonoDib(lpBitmapInfoMask, lpBitsMask, (UINT) iUsageMask)))
        goto dpb_exit;

    if (!SelectObject(hdcSrc, hbmMask))
        goto dpb_exit;
    }
    else
    {
    // Create a mask describing the original source bitmap.

    ASSERTGDI(sizeof(BITMAPINFOHEADER) == 0x28,
        "MF3216: DoPlgBlt, BITMAPINFOHEADER has changed!\n");

    iUsageMask       = DIB_PAL_INDICES;
    cbBitmapInfoMask = 0x28;
    lpBitmapInfoMask = (PBITMAPINFO) &bmihMask;

    bmihMask.biSize          = 0x28;
    bmihMask.biWidth         = lpBitmapInfoSrc->bmiHeader.biWidth;
    bmihMask.biHeight        = lpBitmapInfoSrc->bmiHeader.biHeight;
    bmihMask.biPlanes        = 1;
    bmihMask.biBitCount      = 1;
    bmihMask.biCompression   = BI_RGB;
    bmihMask.biSizeImage     = 0;
    bmihMask.biXPelsPerMeter = 0;
    bmihMask.biYPelsPerMeter = 0;
    bmihMask.biClrUsed       = 0;
    bmihMask.biClrImportant  = 0;

    if (!(hbmMask = CreateBitmap((int) bmihMask.biWidth,
             (int) bmihMask.biHeight, 1, 1, (CONST VOID *) NULL)))
        goto dpb_exit;

    if (!SelectObject(hdcSrc, hbmMask))
        goto dpb_exit;

    // Initialize the mask bitmap to 1's.

    if (!PatBlt(hdcSrc,0,0,(int)bmihMask.biWidth,(int)bmihMask.biHeight,WHITENESS))
        goto dpb_exit;
    }

    // Create the mask for MaskBlt.

    pbmiMaskRDev = (PBITMAPINFO) LocalAlloc(LMEM_FIXED, cbBitmapInfoMask);
    if (pbmiMaskRDev == (PBITMAPINFO) NULL)
    goto dpb_exit;
    RtlCopyMemory(pbmiMaskRDev, lpBitmapInfoMask, cbBitmapInfoMask);
    pbmiMaskRDev->bmiHeader.biWidth  = rclBndRDev.right - rclBndRDev.left + 1;
    pbmiMaskRDev->bmiHeader.biHeight = rclBndRDev.bottom - rclBndRDev.top + 1;
    pbmiMaskRDev->bmiHeader.biSizeImage = 0;
    pbmiMaskRDev->bmiHeader.biCompression = BI_RGB;
    if (!(hbmMaskRDev = CreateBitmap(pbmiMaskRDev->bmiHeader.biWidth,
        pbmiMaskRDev->bmiHeader.biHeight, 1, 1, (CONST VOID *) NULL)))
    goto dpb_exit;

    if (!SelectObject(hdcSrcRDev, hbmMaskRDev))
    goto dpb_exit;

    // Initialize the mask bitmap to 0's.

    if (!PatBlt(hdcSrcRDev,0,0,(int)pbmiMaskRDev->bmiHeader.biWidth,
        (int)pbmiMaskRDev->bmiHeader.biHeight,BLACKNESS))
    goto dpb_exit;

    // PlgBlt the original mask bitmap into the mask bitmap for MaskBlt.

    if (bMask)
    {
    ptMask.x = xMask;
    ptMask.y = yMask;
    if (!DPtoLP(hdcSrc, &ptMask, 1))
        goto dpb_exit;
    }
    else
    {
    ptMask.x = xSrc;
    ptMask.y = ySrc;
    }

    if (!PlgBlt(hdcSrcRDev, (LPPOINT) aptlDst, hdcSrc, ptMask.x, ptMask.y, cxSrc, cySrc, (HBITMAP) NULL, 0, 0))
    goto dpb_exit;

// Retrieve the mask bits for MaskBlt.

    // Compute size of the buffer required for mask bits.

    cbBitsMaskRDev = CJSCAN(pbmiMaskRDev->bmiHeader.biWidth,
                pbmiMaskRDev->bmiHeader.biPlanes,
                pbmiMaskRDev->bmiHeader.biBitCount)
              * ABS(pbmiMaskRDev->bmiHeader.biHeight);

    lpBitsMaskRDev = (LPBYTE) LocalAlloc(LMEM_FIXED, cbBitsMaskRDev);
    if (lpBitsMaskRDev == (LPBYTE) NULL)
    goto dpb_exit;

    // Get the mask bits.

    if (!GetDIBits(hdcSrcRDev, hbmMaskRDev, 0, (UINT) pbmiMaskRDev->bmiHeader.biHeight,
           lpBitsMaskRDev, pbmiMaskRDev, iUsageMask))
    goto dpb_exit;

// Prepare for the MaskBlt.
// The destination for the MaskBlt is rclBndRDev.  Since the extents for
// the destination and source share the same logical values in MaskBlt,
// we have to set the transform in the destination DC to identity.

    // Save the DC so that we can restore the transform when we are done

    if (!DoSaveDC(pLocalDC))
    goto dpb_exit;

    // Set the transforms to identity.

    if (!DoSetMapMode(pLocalDC, MM_TEXT)
     || !DoModifyWorldTransform(pLocalDC, (PXFORM) NULL, MWT_IDENTITY)
     || !DoSetWindowOrg(pLocalDC, 0, 0)
     || !DoSetViewportOrg(pLocalDC, 0, 0))
    goto dpb_restore_exit;

// Now do the MaskBlt.

    b = DoMaskBlt
    (
        pLocalDC,
        rclBndRDev.left,        // xDst
        rclBndRDev.top,     // yDst
        rclBndRDev.right - rclBndRDev.left + 1,
        rclBndRDev.bottom - rclBndRDev.top + 1,
        rop4,
        0,              // xSrc
        0,              // ySrc
        &xformIdentity,
        iUsageSrc,
        pbmiSrcRDev,
        cbBitmapInfoSrc,
        lpBitsSrcRDev,
        cbBitsSrcRDev,
        0,              // xMask
        0,              // yMask
        iUsageMask,
        pbmiMaskRDev,
        cbBitmapInfoMask,
        lpBitsMaskRDev,
        cbBitsMaskRDev
    );

// Restore the transforms.

dpb_restore_exit:

    (void) DoRestoreDC(pLocalDC, -1);

// Cleanup.

dpb_exit:

    if (hbmSrcOld)
    SelectObject(hdcSrc, hbmSrcOld);
    if (hbmSrcRDevOld)
    SelectObject(hdcSrcRDev, hbmSrcRDevOld);

    if (hbmSrc)
    DeleteObject(hbmSrc);
    if (hbmSrcRDev)
    DeleteObject(hbmSrcRDev);
    if (hbmMask)
    DeleteObject(hbmMask);
    if (hbmMaskRDev)
    DeleteObject(hbmMaskRDev);

    if (hdcSrc)
    DeleteDC(hdcSrc);
    if (hdcSrcRDev)
    DeleteDC(hdcSrcRDev);

    if (pbmiSrcRDev)
    LocalFree((HANDLE) pbmiSrcRDev);
    if (pbmiMaskRDev)
    LocalFree((HANDLE) pbmiMaskRDev);
    if (lpBitsSrcRDev)
    LocalFree((HANDLE) lpBitsSrcRDev);
    if (lpBitsMaskRDev)
    LocalFree((HANDLE) lpBitsMaskRDev);

    return(b);
}


/***************************************************************************
 *  SetPixel  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetPixel
(
 PLOCALDC    pLocalDC,
 int         x,
 int         y,
 COLORREF    crColor
)
{
POINTL  ptl ;
BOOL    b ;

    ptl.x = (LONG) x ;
    ptl.y = (LONG) y ;

    b = bXformRWorldToPPage(pLocalDC, &ptl, 1) ;
        if (b == FALSE)
            goto exit1 ;

    b = bEmitWin16SetPixel(pLocalDC, LOWORD(ptl.x), LOWORD(ptl.y), crColor) ;
exit1:
    return(b) ;
}


/***************************************************************************
 *  SetStretchBltMode  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetStretchBltMode
(
 PLOCALDC  pLocalDC,
 DWORD   iStretchMode
)
{
BOOL    b ;

        // Emit the Win16 metafile drawing order.

        b = bEmitWin16SetStretchBltMode(pLocalDC, LOWORD(iStretchMode)) ;

        return(b) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\mf3216\fonts.c ===
/*****************************************************************************
 *
 * fonts - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************
 *  ExtCreateFont  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoExtCreateFont
(
PLOCALDC  pLocalDC,
INT       ihFont,
PLOGFONTW plfw
)
{
BOOL    b ;
INT     ihW16 ;
WIN16LOGFONT Win16LogFont;

        b = FALSE;

	// Create a win16 logfont(a)

	Win16LogFont.lfHeight = (SHORT) iMagnitudeXform(pLocalDC, plfw->lfHeight, CY_MAG);
	if (plfw->lfHeight < 0)		// preserve sign
	    Win16LogFont.lfHeight = -Win16LogFont.lfHeight;
	Win16LogFont.lfWidth  = (SHORT) iMagnitudeXform(pLocalDC, plfw->lfWidth, CX_MAG);
	if (plfw->lfWidth < 0)		// preserve sign
	    Win16LogFont.lfWidth = -Win16LogFont.lfWidth;
	Win16LogFont.lfEscapement     = (SHORT) plfw->lfEscapement;
	Win16LogFont.lfOrientation    = (SHORT) plfw->lfOrientation;
	Win16LogFont.lfWeight         = (SHORT) plfw->lfWeight;
	Win16LogFont.lfItalic         = plfw->lfItalic;
	Win16LogFont.lfUnderline      = plfw->lfUnderline;
	Win16LogFont.lfStrikeOut      = plfw->lfStrikeOut;
	Win16LogFont.lfCharSet        = plfw->lfCharSet;
	Win16LogFont.lfOutPrecision   = plfw->lfOutPrecision;
	Win16LogFont.lfClipPrecision  = plfw->lfClipPrecision;
	Win16LogFont.lfQuality        = plfw->lfQuality;
	Win16LogFont.lfPitchAndFamily = plfw->lfPitchAndFamily;

        vUnicodeToAnsi((PCHAR) Win16LogFont.lfFaceName,
		       (PWCH)  plfw->lfFaceName,
		       LF_FACESIZE);

	// Allocate the W16 handle.

        ihW16 = iAllocateW16Handle(pLocalDC, ihFont, REALIZED_FONT) ;
        if (ihW16 == -1)
            goto error_exit ;

	// Create the w32 font and store it in the w16 slot table.
	// This font is needed by the helper DC for TextOut simulations.

        pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle
	    = CreateFontIndirectW(plfw);

        ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle != 0,
	    "MF3216: CreateFontIndirectW failed");

        // Emit the Win16 CreateFont metafile record.

        b = bEmitWin16CreateFontIndirect(pLocalDC, &Win16LogFont);

error_exit:
        return(b);
}

/***************************************************************************
 *  SetMapperFlags  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetMapperFlags
(
 PLOCALDC pLocalDC,
 DWORD   f
)
{
BOOL    b ;

	// Do it to the helper DC.

	SetMapperFlags(pLocalDC->hdcHelper, (DWORD) f);

        // Emit the Win16 metafile drawing order.

        b = bEmitWin16SetMapperFlags(pLocalDC, f) ;

        return(b) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\mf3216\emit.c ===
/*****************************************************************************
 *
 * emit - Emit routines for MF3216
 *
 * Date: 7/17/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 *  01-Feb-1992     -by-        c-jeffn
 *
 *      Major code cleanup from Code review 1.
 *
 * Copyright (c) 1991,92 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*----------------------------------------------------------------------------
 *  Emit (copy) nCount Bytes in pBuffer to the user supplied output buffer.
 *
 *  If this is a size only request, send the bits to the bit-bucket and
 *  just keep track of the size.
 *
 *  Note: ERROR_BUFFER_OVERFLOW flag is set in pLocalDC if output buffer
 *  is overrun.
 *---------------------------------------------------------------------------*/
BOOL bEmit(PLOCALDC pLocalDC, PVOID pBuffer, DWORD nCount)
{
BOOL    b ;
UINT    ulBytesEmitted ;

        b = TRUE ;

        // Test for a size only request.

        if (!(pLocalDC->flags & SIZE_ONLY))
        {
            ulBytesEmitted = pLocalDC->ulBytesEmitted ;
            if ((ulBytesEmitted + nCount) <= pLocalDC->cMf16Dest)
            {
                memcpy(&(pLocalDC->pMf16Bits[ulBytesEmitted]), pBuffer, nCount) ;
                b = TRUE ;
            }
            else
            {
                // Signal output buffer overflow error.

                pLocalDC->flags |= ERR_BUFFER_OVERFLOW;
                b = FALSE ;
                RIP("MF3216: bEmit, (pLocalDC->ulBytesEmitted + nCount) > cMf16Dest \n") ;
            }


        }

        // Update the local DC byte count

        pLocalDC->ulBytesEmitted += nCount ;

        return(b) ;

}



/*----------------------------------------------------------------------------
 * Update the max record size.  Used to update the metafile header.
 *---------------------------------------------------------------------------*/
VOID vUpdateMaxRecord(PLOCALDC pLocalDC, PMETARECORD pmr)
{

    if (pLocalDC->ulMaxRecord < pmr->rdSize)
        pLocalDC->ulMaxRecord = pmr->rdSize;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\mf3216\debug.h ===
/*************************************************************************\
* Module Name: debug.h
*
*   This module contains debug support definitions
*   The debug support is Win32 specific.  It does not use NT base functions.
*
* Created: 13-June-1991 9:50:00
* Author: Jeffrey Newman c-jeffn
*
* Copyright (c) Microsoft Corporation
\*************************************************************************/

#ifndef _DEBUG_
#define _DEBUG_

//Turn on firewalls unless we are told not to.

void DbgBreakPoint();
DWORD DbgPrint(PSZ Format, ...);

// Define the RIP and ASSERT macros.

#ifdef  RIP
#undef  RIP
#endif

#ifdef  ASSERTGDI
#undef  ASSERTGDI
#endif

#ifdef  PUTS
#undef  PUTS
#endif

#ifdef  USE
#undef  USE
#endif

#if DBG
#define RIP(x) {DbgPrint(x); DbgBreakPoint();}
#define ASSERTGDI(x,y) {if(!(x)) RIP(y)}
#define PUTS(x) DbgPrint(x)
#define PUTS1(x, p1) DbgPrint(x, p1)
#define USE(x)  x = x
#define NOTUSED(a) USE(a)
#else
#define RIP(x)
#define ASSERTGDI(x,y)
#define PUTS(x)
#define PUTS1(x, p1)
#define USE(x)
#define NOTUSED(a)
#endif  

#endif // _DEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\mf3216\conics.c ===
/*****************************************************************************
 *
 * conics - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


FLOAT   eRadsPerDegree = (FLOAT) (ePI / (FLOAT) 180.0) ;

BOOL bFindRadialEllipseIntersection(PLOCALDC pLocalDC,
                                    INT x1, INT y1, INT x2, INT y2,
                                    INT x3, INT y3, INT x4, INT y4,
                                    PPOINT pptStart, PPOINT pptEnd) ;

BOOL bIncIncToIncExcXform (PLOCALDC pLocalDC, PRECTL prcl) ;

VOID vDoArcReflection(PLOCALDC pLocalDC, PPOINTL pptl) ;


/***************************************************************************
 * DoSetArcDirection - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetArcDirection(PLOCALDC pLocalDC, INT iArcDirection)
{
        pLocalDC->iArcDirection = iArcDirection ;

        return(SetArcDirection(pLocalDC->hdcHelper, iArcDirection) != 0);
}


/***************************************************************************
 *  AngleArc  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoAngleArc
(
PLOCALDC pLocalDC,
int     x,
int     y,
DWORD   ulRadius,
FLOAT   eStartAngle,
FLOAT   eSweepAngle
)
{
BOOL    b ;
POINTL  aptl[4] ;
FLOAT   eEndAngle;
INT     iArcDirection;

// If we're recording the drawing orders for a path
// then just pass the drawing order to the helper DC.
// Do not emit any Win16 drawing orders.

        if (pLocalDC->flags & RECORDING_PATH)
        {
        b = AngleArc(pLocalDC->hdcHelper, x, y, ulRadius, eStartAngle, eSweepAngle) ;
            ASSERTGDI(b, "MF3216: DoAngleArc, in path render failed\n") ;
            return(b) ;
        }

// Do the transformations.
// And emit the Win16 drawing orders.

    if (pLocalDC->flags & STRANGE_XFORM
     || eSweepAngle >  360.0f   // more than one revolution
     || eSweepAngle < -360.0f
       )
        {
            b = bRenderCurveWithPath(pLocalDC, (LPPOINT) NULL, (PBYTE) NULL, 0,
            x, y, 0, 0, 0, 0, 0, 0,
            ulRadius, eStartAngle, eSweepAngle, EMR_ANGLEARC);

        return(b);
    }

// Calculate the ARC bounding box.

        aptl[0].x = x - ulRadius ;
        aptl[0].y = y - ulRadius ;
        aptl[1].x = x + ulRadius ;
        aptl[1].y = y + ulRadius ;

// Calculate the begin and end points for ARC from the
// eStartAngle and eSweepAngle.

        aptl[2].x = x + (LONG) ((double) (ulRadius) * cos(eStartAngle * eRadsPerDegree) + 0.5f) ;
        aptl[2].y = y - (LONG) ((double) (ulRadius) * sin(eStartAngle * eRadsPerDegree) + 0.5f) ;

        eEndAngle = eStartAngle + eSweepAngle ;

        aptl[3].x = x + (LONG) ((double) (ulRadius) * cos(eEndAngle * eRadsPerDegree) + 0.5f) ;
        aptl[3].y = y - (LONG) ((double) (ulRadius) * sin(eEndAngle * eRadsPerDegree) + 0.5f) ;

// If the endpoints are identical, we cannot represent the AngleArc as
// an ArcTo.  Use path to render it instead.

    if (aptl[2].x == aptl[3].x && aptl[2].y == aptl[3].y)
        {
            b = bRenderCurveWithPath(pLocalDC, (LPPOINT) NULL, (PBYTE) NULL, 0,
            x, y, 0, 0, 0, 0, 0, 0,
            ulRadius, eStartAngle, eSweepAngle, EMR_ANGLEARC);

        return(b);
    }

// At this point we have the same parameters that would apply to
// a standard ArcTo.  However, we still need to determine the arc
// direction to apply.  If the sweep angle is positive, it is counter-
// clockwise.  If the sweep angle is negative, it is clockwise.

// Save the current arc direction.

        iArcDirection = pLocalDC->iArcDirection;

// Prepare the arc direction for the ArcTo.

        (void) DoSetArcDirection
        (pLocalDC, eSweepAngle < 0.0f ? AD_CLOCKWISE : AD_COUNTERCLOCKWISE);

// Do the ArcTo.

        b = DoArcTo(pLocalDC, aptl[0].x, aptl[0].y, aptl[1].x, aptl[1].y,
                              aptl[2].x, aptl[2].y, aptl[3].x, aptl[3].y) ;

// Restore the current arc direction.

        (void) DoSetArcDirection(pLocalDC, iArcDirection);

        return (b) ;
}

/***************************************************************************
 *  Arc  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoArc
(
PLOCALDC pLocalDC,
int x1,
int y1,
int x2,
int y2,
int x3,
int y3,
int x4,
int y4
)
{
BOOL    b ;

        b = bConicCommon (pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4, EMR_ARC) ;

        return(b) ;
}

/***************************************************************************
 *  ArcTo  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoArcTo
(
PLOCALDC pLocalDC,
int x1,
int y1,
int x2,
int y2,
int x3,
int y3,
int x4,
int y4
)
{
BOOL    b ;
POINT   ptStart,
        ptEnd ;

    // If we're recording the drawing orders for a path
        // then just pass the drawing order to the helper DC.
        // Do not emit any Win16 drawing orders.

        if (pLocalDC->flags & RECORDING_PATH)
        {
            b = ArcTo(pLocalDC->hdcHelper, x1, y1, x2, y2, x3, y3, x4, y4) ;
            return(b) ;
        }


        b = bFindRadialEllipseIntersection(pLocalDC,
                                           x1, y1, x2, y2,
                                           x3, y3, x4, y4,
                                           &ptStart, &ptEnd) ;
        if (b == FALSE)
            return(b) ;

        b = DoLineTo(pLocalDC, ptStart.x, ptStart.y) ;
        if (b == FALSE)
            return(b) ;

        b = DoArc(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4) ;
        if (b == FALSE)
            return(b) ;

        b = DoMoveTo(pLocalDC, ptEnd.x, ptEnd.y) ;

        return(b) ;
}


/***************************************************************************
 *  Chord  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoChord
(
PLOCALDC pLocalDC,
int x1,
int y1,
int x2,
int y2,
int x3,
int y3,
int x4,
int y4
)
{
BOOL    b ;

        b = bConicCommon (pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4, EMR_CHORD) ;

        return(b) ;
}


/***************************************************************************
 *  Ellipse  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoEllipse
(
PLOCALDC pLocalDC,
int x1,
int y1,
int x2,
int y2
)
{
BOOL    b ;

        b = bConicCommon (pLocalDC, x1, y1, x2, y2, 0, 0, 0, 0, EMR_ELLIPSE) ;

        return(b) ;
}


/***************************************************************************
 *  Pie  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPie
(
PLOCALDC pLocalDC,
int x1,
int y1,
int x2,
int y2,
int x3,
int y3,
int x4,
int y4
)
{
BOOL    b ;

        b = bConicCommon (pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4, EMR_PIE) ;

        return(b) ;
}


/***************************************************************************
 * bConicCommon - The mother of all conic translations.
 *                They are Arc, Chord, Pie, Ellipse, Rectangle and RoundRect.
 **************************************************************************/
BOOL bConicCommon (PLOCALDC pLocalDC, INT x1, INT y1, INT x2, INT y2,
                                      INT x3, INT y3, INT x4, INT y4,
                                      DWORD mrType)
{
SHORT       sx1, sx2, sx3, sx4,
        sy1, sy2, sy3, sy4 ;
LONG        nPointls ;
POINTL      aptl[4] ;
BOOL        b ;

// If we're recording the drawing orders for a path
// then just pass the drawing order to the helper DC.
// Do not emit any Win16 drawing orders.

        if (pLocalDC->flags & RECORDING_PATH)
        {
            switch(mrType)
            {
                case EMR_ARC:
                    b = Arc(pLocalDC->hdcHelper, x1, y1, x2, y2,
                                                 x3, y3, x4, y4) ;
                    break ;

                case EMR_CHORD:
                    b = Chord(pLocalDC->hdcHelper, x1, y1, x2, y2,
                                                   x3, y3, x4, y4) ;
                    break ;

                case EMR_ELLIPSE:
                    b = Ellipse(pLocalDC->hdcHelper, x1, y1, x2, y2) ;
                    break ;

                case EMR_PIE:
                    b = Pie(pLocalDC->hdcHelper, x1, y1, x2, y2,
                                                 x3, y3, x4, y4) ;
                    break ;

                case EMR_RECTANGLE:
                    b = Rectangle(pLocalDC->hdcHelper, x1, y1, x2, y2) ;
                    break ;

                case EMR_ROUNDRECT:
                    b = RoundRect(pLocalDC->hdcHelper, x1, y1, x2, y2, x3, y3) ;
                    break ;

        default:
                    b = FALSE;
            RIP("MF3216: bConicCommon, bad mrType");
                    break ;
            }

            ASSERTGDI(b, "MF3216: bConicCommon, in path render failed\n") ;
            return(b) ;
        }

// Do the transformations.
// And emit the Win16 drawing orders.

    if (pLocalDC->flags & STRANGE_XFORM)
        {
            b = bRenderCurveWithPath(pLocalDC, (LPPOINT) NULL, (PBYTE) NULL, 0,
            x1, y1, x2, y2, x3, y3, x4, y4, 0, 0.0f, 0.0f, mrType);

        return(b);
    }

// Do the simple transform case.

        // Compute the number of points

        nPointls = (LONG) (sizeof(aptl) / sizeof(POINTL)) ;

        // Assign all the coordinates into an array for conversion.

        aptl[0].x = x1 ;
        aptl[0].y = y1 ;
        aptl[1].x = x2 ;
        aptl[1].y = y2 ;
        aptl[2].x = x3 ;
        aptl[2].y = y3 ;
        aptl[3].x = x4 ;
        aptl[3].y = y4 ;

        // Take care of the arc direction.

        switch (mrType)
        {
            case EMR_ARC:
            case EMR_CHORD:
            case EMR_PIE:
                vDoArcReflection(pLocalDC, &aptl[2]) ;
                break ;

            default:
                break ;
        }

        // Do the Record-time World to Play-time Page transformations.
        // The radial definitions need only a world to page xform,
        // and the ellipse definitions for roundrects only require
        // a magnitude transformation.

        if (mrType != EMR_ROUNDRECT)
        {
        b = bXformRWorldToPPage(pLocalDC, (PPOINTL) aptl, nPointls) ;
            if (!b)
                goto exit1 ;
        }
        else
        {
            /*
                For roundrects do a Record-time-World to Play-time-Page
                transform of the bounding box only.  Then a magnatude only
                transform of the corner ellipse definitions.
            */

        b = bXformRWorldToPPage(pLocalDC, (PPOINTL) aptl, 2) ;
            if (!b)
                goto exit1 ;

            aptl[2].x = iMagnitudeXform(pLocalDC, aptl[2].x, CX_MAG) ;
            aptl[2].y = iMagnitudeXform(pLocalDC, aptl[2].y, CY_MAG) ;
            aptl[3].x = iMagnitudeXform(pLocalDC, aptl[3].x, CX_MAG) ;
            aptl[3].y = iMagnitudeXform(pLocalDC, aptl[3].y, CY_MAG) ;
        }

        // The bounding boxes for
        // all the conics and rectangles that are handled by this
        // common routine are inclusive-inclusive, and they must
        // be transformed to the inclusive-exclusive Win16 form.

        b = bIncIncToIncExcXform(pLocalDC, (PRECTL) &aptl[0]) ;
    if (!b)
            goto exit1 ;

        // Assign the converted coordinates variables suited to
        // the Win16 metafile.

    sx1 = LOWORD(aptl[0].x) ;
    sy1 = LOWORD(aptl[0].y) ;
    sx2 = LOWORD(aptl[1].x) ;
    sy2 = LOWORD(aptl[1].y) ;
    sx3 = LOWORD(aptl[2].x) ;
    sy3 = LOWORD(aptl[2].y) ;
    sx4 = LOWORD(aptl[3].x) ;
    sy4 = LOWORD(aptl[3].y) ;

        // Emit the Win16 drawing orders to the Win16 metafile.

        switch(mrType)
        {
            case EMR_ARC:
                b = bEmitWin16Arc(pLocalDC, sx1, sy1, sx2, sy2,
                                            sx3, sy3, sx4, sy4) ;
                break ;

            case EMR_CHORD:
                b = bEmitWin16Chord(pLocalDC, sx1, sy1, sx2, sy2,
                                              sx3, sy3, sx4, sy4) ;
                break ;

            case EMR_ELLIPSE:
                b = bEmitWin16Ellipse(pLocalDC, sx1, sy1, sx2, sy2) ;
                break ;

            case EMR_PIE:
                b = bEmitWin16Pie(pLocalDC, sx1, sy1, sx2, sy2,
                                            sx3, sy3, sx4, sy4) ;
                break ;

            case EMR_RECTANGLE:
                b = bEmitWin16Rectangle(pLocalDC, sx1, sy1, sx2, sy2) ;
                break ;

            case EMR_ROUNDRECT:
                b = bEmitWin16RoundRect(pLocalDC, sx1, sy1, sx2, sy2, sx3, sy3) ;
                break ;

        default:
        RIP("MF3216: bConicCommon, bad mrType");
                break ;
        }

exit1:
        return (b) ;
}


/*****************************************************************************
 * vDoArcReflection - Test for an inversion in the RWorld to PPage matrix.
 *                    If one and only one is found then swap the start
 *                    and  end position for the conics.
 *****************************************************************************/
VOID vDoArcReflection(PLOCALDC pLocalDC, PPOINTL pptl)
{
FLOAT   eM11,
        eM22 ;
POINTL  ptl ;
BOOL    bFlip ;

    // Win16 assumes the counter-clockwise arc direction in the
    // device coordinates.  Win32 defines the arc direction in the
    // world coordinates.

    // Assume no flipping of start and end points.

    bFlip = FALSE ;

    // Account for current arc direction.

    if (pLocalDC->iArcDirection == AD_CLOCKWISE)
        bFlip = !bFlip;

        // If there is an inversion in the xform matrix then invert
        // the arc direction.

        eM11 = pLocalDC->xformRWorldToPPage.eM11 ;
        eM22 = pLocalDC->xformRWorldToPPage.eM22 ;

        if (  (eM11 < 0.0f && eM22 > 0.0f)
            ||(eM11 > 0.0f && eM22 < 0.0f)
           )
        bFlip = !bFlip;

        // If the REQUESTED Win16 mapmode is fixed, then invert the
    // arc direction.

        switch(pLocalDC->iMapMode)
        {
            case MM_LOMETRIC:
            case MM_HIMETRIC:
            case MM_LOENGLISH:
            case MM_HIENGLISH:
            case MM_TWIPS:
        bFlip = !bFlip;
                break ;
        }

    if (bFlip)
        SWAP(pptl[0], pptl[1], ptl);

        return ;
}


/*****************************************************************************
 * bIncIncToIncExcXform - Inclusize Inclusive To Inclusive Exclusize
 *                        transform in play time coordinate space.
 *****************************************************************************/
BOOL bIncIncToIncExcXform (PLOCALDC pLocalDC, PRECTL prcl)
{
LONG     l;

        // Convert the points from Playtime Page to Playtime Device space.

        if (!bXformPPageToPDev(pLocalDC, (PPOINTL) prcl, 2))
        return(FALSE);

    // Reorder the rectangle

    if (prcl->left > prcl->right)
        SWAP(prcl->left, prcl->right, l);

    if (prcl->top > prcl->bottom)
        SWAP(prcl->top, prcl->bottom, l);

        // Expand the right and bottom by one pixel.

        prcl->right++ ;
        prcl->bottom++ ;

        // Convert the points back to Playtime Page space

        return(bXformPDevToPPage(pLocalDC, (PPOINTL) prcl, 2));
}


/*****************************************************************************
 * bFindRadialEllipseIntersection - Calculate the intersection of a radial
 *                                   and an Ellipse.
 *
 *  Play the ArcTo into a path then query the path for the first and
 *  last points on the Arc.
 *****************************************************************************/
BOOL bFindRadialEllipseIntersection(PLOCALDC pLocalDC,
                                    INT x1, INT y1, INT x2, INT y2,
                                    INT x3, INT y3, INT x4, INT y4,
                                    LPPOINT pptStart, LPPOINT pptEnd)
{
BOOL    b;
POINT   ptCP;

    b = FALSE;          // assume failure

// Save the current position in the helper DC.

    if (!GetCurrentPositionEx(pLocalDC->hdcHelper, &ptCP))
        return(FALSE);

// Do an ArcTo with the same start radial line.

        if (!ArcTo(pLocalDC->hdcHelper, x1, y1, x2, y2, x3, y3, x3, y3))
        goto exit_bFindRadialEllipseIntersection;

// Get the start point of the arc.  It is the current position.

    if (!GetCurrentPositionEx(pLocalDC->hdcHelper, pptStart))
        goto exit_bFindRadialEllipseIntersection;

// Continue with the ArcTo with the same end radial line this time.

        if (!ArcTo(pLocalDC->hdcHelper, x1, y1, x2, y2, x4, y4, x4, y4))
        goto exit_bFindRadialEllipseIntersection;

// Get the end point of the arc.  It is the current position.

    if (!GetCurrentPositionEx(pLocalDC->hdcHelper, pptEnd))
        goto exit_bFindRadialEllipseIntersection;

// Everything is golden.

    b = TRUE;

exit_bFindRadialEllipseIntersection:

// Restore the current position in the helper DC.

    if (!MoveToEx(pLocalDC->hdcHelper, ptCP.x, ptCP.y, (LPPOINT) NULL))
        RIP("MF3216: bFindRadialEllipseIntersection, MoveToEx failed");

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\mf3216\handlers.c ===
/****************************************************************************
 *  Handlers.c - Handlers for the Win32 metafile  records
 *
 *  DATE:   11-Dec-1991
 *  Author: Jeffrey Newman (c-jeffn)
 *
 *  Copyright (c) Microsoft Inc. 1991
 ****************************************************************************/


#include "precomp.h"
#pragma hdrstop


// Max number of pointl's allowed on stack before explicit memory allocation.

#define MAX_STACK_POINTL	128

// Convert array of POINTSs to POINTLs.

#define POINTS_TO_POINTL(pptl, ppts, cpt)			\
    {								\
	DWORD i;						\
	for (i = 0; i < (cpt); i++)				\
	{							\
	    (pptl)[i].x = (LONG) (ppts)[i].x;			\
	    (pptl)[i].y = (LONG) (ppts)[i].y;			\
	}							\
    }


/**************************************************************************
 * Handler - NotImplemented
 *
 * The following 32-bit records have no equivalent 16-bit metafile records:
 *      SETBRUSHORGEX
 *
 *************************************************************************/
BOOL bHandleNotImplemented(PVOID pVoid, PLOCALDC pLocalDC)
{
PENHMETARECORD pemr ;
INT            iType ;

        NOTUSED(pLocalDC) ;

        pemr = (PENHMETARECORD) pVoid ;
        iType = pemr->iType ;

        if (iType != EMR_SETBRUSHORGEX
         && iType != EMR_SETCOLORADJUSTMENT
         && iType != EMR_SETMITERLIMIT
         && iType != EMR_SETICMMODE
         && iType != EMR_CREATECOLORSPACE
         && iType != EMR_SETCOLORSPACE
         && iType != EMR_DELETECOLORSPACE
         && iType != EMR_GLSRECORD
         && iType != EMR_GLSBOUNDEDRECORD
         && iType != EMR_PIXELFORMAT)
        {
            PUTS1("MF3216: bHandleNotImplemented - record not supported: %d\n", iType) ;
        }
        return(TRUE) ;
}


/**************************************************************************
 * Handler - GdiComment
 *************************************************************************/
BOOL bHandleGdiComment(PVOID pVoid, PLOCALDC pLocalDC)
{
	return(DoGdiComment(pLocalDC, (PEMR) pVoid));
}


/**************************************************************************
 * Handler - SetPaletteEntries
 *************************************************************************/
BOOL bHandleSetPaletteEntries(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	 b ;
PEMRSETPALETTEENTRIES pMfSetPaletteEntries ;
DWORD    ihPal, iStart, cEntries ;
PPALETTEENTRY   pPalEntry ;

	pMfSetPaletteEntries = (PEMRSETPALETTEENTRIES) pVoid ;

	// Now do the translation.

	ihPal     = pMfSetPaletteEntries->ihPal ;
        iStart    = pMfSetPaletteEntries->iStart ;
        cEntries  = pMfSetPaletteEntries->cEntries ;
        pPalEntry = pMfSetPaletteEntries->aPalEntries ;

	b = DoSetPaletteEntries(pLocalDC, ihPal, iStart, cEntries, pPalEntry) ;

        return (b) ;
}


/**************************************************************************
 * Handler - CreatePalette
 *************************************************************************/
BOOL bHandleCreatePalette(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	b ;
PEMRCREATEPALETTE pMfCreatePalette ;
LPLOGPALETTE     lpLogPal ;
DWORD   ihPal ;

	pMfCreatePalette = (PEMRCREATEPALETTE) pVoid ;

	// Now do the translation.

	ihPal    = pMfCreatePalette->ihPal ;
        lpLogPal = &pMfCreatePalette->lgpl ;

	b = DoCreatePalette(pLocalDC, ihPal, lpLogPal) ;

        return (b) ;
}


/**************************************************************************
 * Handler - RealizePalette
 *************************************************************************/
BOOL bHandleRealizePalette(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	 b ;

	NOTUSED(pVoid);

	// Now do the translation.

	b = DoRealizePalette(pLocalDC) ;

        return (b) ;
}


/**************************************************************************
 * Handler - ResizePalette
 *************************************************************************/
BOOL bHandleResizePalette(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	 b ;
PEMRRESIZEPALETTE pMfResizePalette ;
DWORD    ihPal, cEntries ;

	pMfResizePalette = (PEMRRESIZEPALETTE) pVoid ;

	// Now do the translation.

	ihPal    = pMfResizePalette->ihPal ;
        cEntries = pMfResizePalette->cEntries ;

	b = DoResizePalette(pLocalDC, ihPal, cEntries) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SelectPalette
 *************************************************************************/
BOOL bHandleSelectPalette(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	 b ;
PEMRSELECTPALETTE pMfSelectPalette ;
DWORD    ihPal ;

	pMfSelectPalette = (PEMRSELECTPALETTE) pVoid ;

	// Now do the translation.

	ihPal = pMfSelectPalette->ihPal ;

	b = DoSelectPalette(pLocalDC, ihPal) ;

        return (b) ;
}

/**************************************************************************
 * Handler - OffsetClipRgn
 *************************************************************************/
BOOL bHandleOffsetClipRgn(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	    b ;
PEMROFFSETCLIPRGN pMfOffsetClipRgn ;
INT	     x, y ;

	pMfOffsetClipRgn = (PEMROFFSETCLIPRGN) pVoid ;

	// Now do the translation.

	x = pMfOffsetClipRgn->ptlOffset.x ;
	y = pMfOffsetClipRgn->ptlOffset.y ;

	b = DoOffsetClipRgn(pLocalDC, x, y) ;

        return (b) ;
}

/**************************************************************************
 * Handler - ExtSelectClipRgn
 *************************************************************************/
BOOL bHandleExtSelectClipRgn(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	    b ;
PEMREXTSELECTCLIPRGN pMfExtSelectClipRgn ;
INT	     cbRgnData, iMode ;
LPRGNDATA    pRgnData ;

	pMfExtSelectClipRgn = (PEMREXTSELECTCLIPRGN) pVoid ;

	// Now do the translation.

	cbRgnData = pMfExtSelectClipRgn->cbRgnData ;
        pRgnData = (LPRGNDATA) pMfExtSelectClipRgn->RgnData;
        iMode    = pMfExtSelectClipRgn->iMode ;

	b = DoExtSelectClipRgn(pLocalDC, cbRgnData, pRgnData, iMode) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SetMetaRgn
 *************************************************************************/
BOOL bHandleSetMetaRgn(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;

        NOTUSED(pVoid) ;

        b = DoSetMetaRgn(pLocalDC) ;

        return(b) ;
}


/**************************************************************************
 * Handler - PaintRgn
 *************************************************************************/
BOOL bHandlePaintRgn(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	    b ;
PEMRPAINTRGN pMfPaintRgn ;
INT	     cbRgnData;
LPRGNDATA    pRgnData ;

	pMfPaintRgn = (PEMRPAINTRGN) pVoid ;

	// Now do the translation.

	cbRgnData  = pMfPaintRgn->cbRgnData ;
        pRgnData   = (LPRGNDATA) pMfPaintRgn->RgnData;

	b = DoDrawRgn(pLocalDC, 0, 0, 0, cbRgnData, pRgnData, EMR_PAINTRGN);

        return (b) ;
}

/**************************************************************************
 * Handler - InvertRgn
 *************************************************************************/
BOOL bHandleInvertRgn(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	    b ;
PEMRINVERTRGN pMfInvertRgn ;
INT	     cbRgnData;
LPRGNDATA    pRgnData ;

	pMfInvertRgn = (PEMRINVERTRGN) pVoid ;

	// Now do the translation.

	cbRgnData  = pMfInvertRgn->cbRgnData ;
        pRgnData   = (LPRGNDATA) pMfInvertRgn->RgnData;

	b = DoDrawRgn(pLocalDC, 0, 0, 0, cbRgnData, pRgnData, EMR_INVERTRGN);

        return (b) ;
}


/**************************************************************************
 * Handler - FrameRgn
 *************************************************************************/
BOOL bHandleFrameRgn(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	    b ;
PEMRFRAMERGN pMfFrameRgn ;
INT	    ihBrush,
	    cbRgnData,
	    nWidth,
	    nHeight ;
LPRGNDATA   pRgnData ;

	pMfFrameRgn = (PEMRFRAMERGN) pVoid ;

	// Now do the translation.

	ihBrush	   = pMfFrameRgn->ihBrush ;
	nWidth	   = pMfFrameRgn->szlStroke.cx ;
	nHeight	   = pMfFrameRgn->szlStroke.cy ;
	cbRgnData  = pMfFrameRgn->cbRgnData ;
        pRgnData   = (LPRGNDATA) pMfFrameRgn->RgnData;

	b = DoDrawRgn(pLocalDC, ihBrush, nWidth, nHeight, cbRgnData, pRgnData, EMR_FRAMERGN);

        return (b) ;
}

/**************************************************************************
 * Handler - FillRgn
 *************************************************************************/
BOOL bHandleFillRgn(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	    b ;
PEMRFILLRGN pMfFillRgn ;
INT	   ihBrush,
	   cbRgnData;
LPRGNDATA  pRgnData ;


        // Set up the pointer the Doer uses to reference the
        // the Win32 drawing order.  Also setup the drawing order specific
        // pointer.

	pMfFillRgn = (PEMRFILLRGN) pVoid ;

	// Now do the translation.

	ihBrush	   = pMfFillRgn->ihBrush ;
	cbRgnData  = pMfFillRgn->cbRgnData ;
        pRgnData   = (LPRGNDATA) pMfFillRgn->RgnData;

	b = DoDrawRgn(pLocalDC, ihBrush, 0, 0, cbRgnData, pRgnData, EMR_FILLRGN);

        return (b) ;
}


/**************************************************************************
 * Handler - IntersectClipRect
 *************************************************************************/
BOOL bHandleIntersectClipRect(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	    b ;
PEMRINTERSECTCLIPRECT pMfIntersectClipRect ;
INT xLeft, yTop, xRight, yBottom ;


	pMfIntersectClipRect = (PEMRINTERSECTCLIPRECT) pVoid ;

	// Now do the translation.
	xLeft	= pMfIntersectClipRect->rclClip.left ;
	yTop	= pMfIntersectClipRect->rclClip.top ;
	xRight	= pMfIntersectClipRect->rclClip.right ;
	yBottom = pMfIntersectClipRect->rclClip.bottom ;

	b = DoClipRect(pLocalDC, xLeft, yTop, xRight, yBottom, EMR_INTERSECTCLIPRECT) ;

        return (b) ;

}

/**************************************************************************
 * Handler - ExcludeClipRect
 *************************************************************************/
BOOL bHandleExcludeClipRect(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	    b ;
PEMREXCLUDECLIPRECT pMfExcludeClipRect ;
INT xLeft, yTop, xRight, yBottom ;


	pMfExcludeClipRect = (PEMREXCLUDECLIPRECT) pVoid ;

	// Now do the translation.
	xLeft	= pMfExcludeClipRect->rclClip.left ;
	yTop	= pMfExcludeClipRect->rclClip.top ;
	xRight	= pMfExcludeClipRect->rclClip.right ;
	yBottom = pMfExcludeClipRect->rclClip.bottom ;

	b = DoClipRect(pLocalDC, xLeft, yTop, xRight, yBottom, EMR_EXCLUDECLIPRECT) ;

        return (b) ;

}


/**************************************************************************
 * Handler - SetPixel
 *************************************************************************/
BOOL bHandleSetPixel(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	    b ;
PEMRSETPIXELV pMfSetPixel ;
INT	    x, y ;
COLORREF    crColor ;

	pMfSetPixel = (PEMRSETPIXELV) pVoid ;

        // Now do the translation.

	x	= (INT) pMfSetPixel->ptlPixel.x ;
	y	= (INT) pMfSetPixel->ptlPixel.y ;
	crColor = pMfSetPixel->crColor ;

	b = DoSetPixel(pLocalDC, x, y, crColor) ;

        return (b) ;
}


/**************************************************************************
 * Handler - ExtFloodFill
 *************************************************************************/
BOOL bHandleExtFloodFill(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL	        b ;
PEMREXTFLOODFILL pMfExtFloodFill ;
INT	        x, y ;
COLORREF        crColor ;
DWORD           iMode ;

	pMfExtFloodFill = (PEMREXTFLOODFILL) pVoid ;

        // Now do the translation.

	x	= (INT) pMfExtFloodFill->ptlStart.x ;
	y	= (INT) pMfExtFloodFill->ptlStart.y ;
	crColor = pMfExtFloodFill->crColor ;
	iMode   = pMfExtFloodFill->iMode ;

	b = DoExtFloodFill(pLocalDC, x, y, crColor, iMode) ;

        return (b) ;
}


/**************************************************************************
 * Handler - ModifyWorldTransform
 *************************************************************************/
BOOL bHandleModifyWorldTransform(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRMODIFYWORLDTRANSFORM pMfModifyWorldTransform ;
PXFORM  pxform ;
DWORD   iMode ;


        pMfModifyWorldTransform = (PEMRMODIFYWORLDTRANSFORM) pVoid ;

        // get a pointer to the xform matrix

        pxform = &pMfModifyWorldTransform->xform ;
        iMode  = pMfModifyWorldTransform->iMode ;

        // Now do the translation.

        b = DoModifyWorldTransform(pLocalDC, pxform, iMode) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SetWorldTransform
 *************************************************************************/
BOOL bHandleSetWorldTransform(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRSETWORLDTRANSFORM pMfSetWorldTransform ;
PXFORM  pxform ;


        pMfSetWorldTransform = (PEMRSETWORLDTRANSFORM) pVoid ;

        // get a pointer to the xform matrix

        pxform = &pMfSetWorldTransform->xform ;

        // Now do the translation.

        b = DoSetWorldTransform(pLocalDC, pxform) ;

        return (b) ;
}


/**************************************************************************
 * Handler - PolyBezierTo
 *************************************************************************/
BOOL bHandlePolyBezierTo(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRPOLYBEZIERTO pMfPolyBezierTo ;
DWORD   nCount ;
PPOINTL pptl ;

        pMfPolyBezierTo = (PEMRPOLYBEZIERTO) pVoid ;

        // Copy the BezierTo count and the polyBezierTo verticies to
        // the record.

        nCount = pMfPolyBezierTo->cptl ;
        pptl   = pMfPolyBezierTo->aptl ;

        // Now do the translation.

        b = DoPolyBezierTo(pLocalDC, (LPPOINT) pptl, nCount) ;

        return (b) ;
}


/**************************************************************************
 * Handler - PolyDraw
 *************************************************************************/
BOOL bHandlePolyDraw(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRPOLYDRAW pMfPolyDraw ;
DWORD   nCount ;
PPOINTL pptl ;
PBYTE   pb ;

        pMfPolyDraw = (PEMRPOLYDRAW) pVoid ;

        // Copy the Draw count and the polyDraw verticies to
        // the record.

        nCount = pMfPolyDraw->cptl ;
        pptl   = pMfPolyDraw->aptl ;
        pb     = (PBYTE) &pMfPolyDraw->aptl[nCount];

        // Now do the translation.

        b = DoPolyDraw(pLocalDC, (LPPOINT) pptl, pb, nCount) ;

        return (b) ;
}


/**************************************************************************
 * Handler - PolyBezier
 *************************************************************************/
BOOL bHandlePolyBezier(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRPOLYBEZIER pMfPolyBezier ;
DWORD   nCount ;
PPOINTL pptl ;

        pMfPolyBezier = (PEMRPOLYBEZIER) pVoid ;

        // Copy the Bezier count and the polyBezier verticies to
        // the record.

        nCount = pMfPolyBezier->cptl ;
        pptl   = pMfPolyBezier->aptl ;

        // Now do the translation.

        b = DoPolyBezier(pLocalDC, (LPPOINT) pptl, nCount) ;

        return (b) ;
}


/**************************************************************************
 * Handler - Begin Path
 *************************************************************************/
BOOL bHandleBeginPath(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;

        NOTUSED(pVoid) ;

        b = DoBeginPath(pLocalDC) ;

        return (b) ;
}

/**************************************************************************
 * Handler - End Path
 *************************************************************************/
BOOL bHandleEndPath(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;

        NOTUSED(pVoid) ;

        b = DoEndPath(pLocalDC) ;

        return (b) ;
}

/**************************************************************************
 * Handler - Flatten Path
 *************************************************************************/
BOOL bHandleFlattenPath(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;

        NOTUSED(pVoid) ;

        b = DoFlattenPath(pLocalDC) ;

        return (b) ;
}

/**************************************************************************
 * Handler - CloseFigure
 *************************************************************************/
BOOL bHandleCloseFigure(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;

        NOTUSED(pVoid) ;

        b = DoCloseFigure(pLocalDC) ;

        return (b) ;
}

/**************************************************************************
 * Handler - Abort Path
 *************************************************************************/
BOOL bHandleAbortPath(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;

        NOTUSED(pVoid) ;

        b = DoAbortPath(pLocalDC) ;

        return (b) ;
}

/**************************************************************************
 * Handler - Stroke Path
 *************************************************************************/
BOOL bHandleStrokePath(PVOID pVoid, PLOCALDC pLocalDC)
{
        NOTUSED(pVoid) ;

        return(DoRenderPath(pLocalDC, EMR_STROKEPATH));
}

/**************************************************************************
 * Handler - Fill Path
 *************************************************************************/
BOOL bHandleFillPath(PVOID pVoid, PLOCALDC pLocalDC)
{
        NOTUSED(pVoid) ;

        return(DoRenderPath(pLocalDC, EMR_FILLPATH));
}

/**************************************************************************
 * Handler - Stroke and Fill Path
 *************************************************************************/
BOOL bHandleStrokeAndFillPath(PVOID pVoid, PLOCALDC pLocalDC)
{
        NOTUSED(pVoid) ;

        return(DoRenderPath(pLocalDC, EMR_STROKEANDFILLPATH));
}

/**************************************************************************
 * Handler - Widen Path
 *************************************************************************/
BOOL bHandleWidenPath(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;

        NOTUSED(pVoid) ;

        b = DoWidenPath(pLocalDC) ;

        return(b) ;
}

/**************************************************************************
 * Handler - Select Clip Path
 *************************************************************************/
BOOL bHandleSelectClipPath(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRSELECTCLIPPATH   pMfSelectClipPath ;
INT     iMode ;

        pMfSelectClipPath = (PEMRSELECTCLIPPATH) pVoid ;

        iMode = (INT) pMfSelectClipPath->iMode ;

        b = DoSelectClipPath(pLocalDC, iMode) ;

        return(b) ;
}

/**************************************************************************
 * Handler - StretchDIBits
 *************************************************************************/
BOOL bHandleStretchDIBits(PVOID pVoid, PLOCALDC pLocalDC)
{
PEMRSTRETCHDIBITS pMfStretchDIBits ;

BOOL    b ;
LONG    xDest ;
LONG    yDest ;
LONG    xSrc ;
LONG    ySrc ;
LONG    cxSrc ;
LONG    cySrc ;
DWORD   offBmiSrc ;
DWORD   cbBmiSrc ;
DWORD   offBitsSrc ;
DWORD   cbBitsSrc ;
DWORD   iUsageSrc ;
DWORD   dwRop ;
LONG    cxDest ;
LONG    cyDest ;

LPBITMAPINFO    lpBitmapInfo ;
LPBYTE          lpBits ;

        pMfStretchDIBits = (PEMRSTRETCHDIBITS) pVoid ;

        xDest      = pMfStretchDIBits->xDest ;
        yDest      = pMfStretchDIBits->yDest ;
        xSrc       = pMfStretchDIBits->xSrc ;
        ySrc       = pMfStretchDIBits->ySrc ;
        cxSrc      = pMfStretchDIBits->cxSrc ;
        cySrc      = pMfStretchDIBits->cySrc ;
        offBmiSrc  = pMfStretchDIBits->offBmiSrc ;
        cbBmiSrc   = pMfStretchDIBits->cbBmiSrc ;
        offBitsSrc = pMfStretchDIBits->offBitsSrc ;
        cbBitsSrc  = pMfStretchDIBits->cbBitsSrc ;
        iUsageSrc  = pMfStretchDIBits->iUsageSrc ;
        dwRop      = pMfStretchDIBits->dwRop ;
        cxDest     = pMfStretchDIBits->cxDest ;
        cyDest     = pMfStretchDIBits->cyDest ;

        lpBitmapInfo = (LPBITMAPINFO) ((PBYTE) pMfStretchDIBits + offBmiSrc) ;
        lpBits = (PBYTE) pMfStretchDIBits + offBitsSrc ;

        b = DoStretchDIBits(pLocalDC,
                            xDest,
                            yDest,
                            cxDest,
                            cyDest,
                            dwRop,
                            xSrc,
                            ySrc,
                            cxSrc,
                            cySrc,
                            iUsageSrc,
                            lpBitmapInfo,
                            cbBmiSrc,
                            lpBits,
                            cbBitsSrc ) ;
        return(b) ;
}

/**************************************************************************
 * Handler - SetDIBitsToDevice
 *************************************************************************/
BOOL bHandleSetDIBitsToDevice(PVOID pVoid, PLOCALDC pLocalDC)
{
PEMRSETDIBITSTODEVICE pMfSetDIBitsToDevice ;

BOOL    b ;
LONG    xDest ;
LONG    yDest ;
LONG    xSrc ;
LONG    ySrc ;
LONG    cxSrc ;
LONG    cySrc ;
DWORD   offBmiSrc ;
DWORD   cbBmiSrc ;
DWORD   offBitsSrc ;
DWORD   cbBitsSrc ;
DWORD   iUsageSrc ;
DWORD   iStartScan ;
DWORD   cScans ;

LPBITMAPINFO    lpBitmapInfo ;
LPBYTE          lpBits ;

        pMfSetDIBitsToDevice = (PEMRSETDIBITSTODEVICE) pVoid ;

        xDest       = pMfSetDIBitsToDevice->xDest ;
        yDest       = pMfSetDIBitsToDevice->yDest ;
        xSrc        = pMfSetDIBitsToDevice->xSrc ;
        ySrc        = pMfSetDIBitsToDevice->ySrc ;
        cxSrc       = pMfSetDIBitsToDevice->cxSrc ;
        cySrc       = pMfSetDIBitsToDevice->cySrc ;
        offBmiSrc   = pMfSetDIBitsToDevice->offBmiSrc ;
        cbBmiSrc    = pMfSetDIBitsToDevice->cbBmiSrc ;
        offBitsSrc  = pMfSetDIBitsToDevice->offBitsSrc ;
        cbBitsSrc   = pMfSetDIBitsToDevice->cbBitsSrc ;
        iUsageSrc   = pMfSetDIBitsToDevice->iUsageSrc ;
        iStartScan  = pMfSetDIBitsToDevice->iStartScan ;
        cScans      = pMfSetDIBitsToDevice->cScans ;

        lpBitmapInfo = (LPBITMAPINFO) ((PBYTE) pMfSetDIBitsToDevice + offBmiSrc) ;
        lpBits = (PBYTE) pMfSetDIBitsToDevice + offBitsSrc ;

        b = DoSetDIBitsToDevice(pLocalDC,
                                xDest,
                                yDest,
                                xSrc,
                                ySrc,
                                cxSrc,
                                cySrc,
				iUsageSrc,
                                iStartScan,
                                cScans,
                                lpBitmapInfo,
                                cbBmiSrc,
                                lpBits,
				cbBitsSrc ) ;

        return(b) ;
}


/**************************************************************************
 * Handler - BitBlt
 *************************************************************************/
BOOL bHandleBitBlt(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL        b ;
PEMRBITBLT  pMfBitBlt ;
LONG        xDest ;
LONG        yDest ;
LONG        cxDest ;
LONG        cyDest ;
DWORD       dwRop ;
LONG        xSrc ;
LONG        ySrc ;
PXFORM      pxformSrc ;
COLORREF    crBkColorSrc ;
DWORD       iUsageSrc ;
DWORD       offBmiSrc ;
DWORD       cbBmiSrc ;
DWORD       offBitsSrc ;
DWORD       cbBitsSrc ;
PBITMAPINFO pbmi ;
LPBYTE      lpBits ;

        pMfBitBlt = (PEMRBITBLT) pVoid ;

        xDest        = pMfBitBlt->xDest ;
        yDest        = pMfBitBlt->yDest ;
        cxDest       = pMfBitBlt->cxDest ;
        cyDest       = pMfBitBlt->cyDest ;
        dwRop        = pMfBitBlt->dwRop ;
        xSrc         = pMfBitBlt->xSrc ;
        ySrc         = pMfBitBlt->ySrc ;
        pxformSrc    =&(pMfBitBlt->xformSrc) ;
        crBkColorSrc = pMfBitBlt->crBkColorSrc ;		// not used

        iUsageSrc    = pMfBitBlt->iUsageSrc ;
        offBmiSrc    = pMfBitBlt->offBmiSrc ;
        cbBmiSrc     = pMfBitBlt->cbBmiSrc ;
        offBitsSrc   = pMfBitBlt->offBitsSrc ;
        cbBitsSrc    = pMfBitBlt->cbBitsSrc ;

        lpBits = (PBYTE) pMfBitBlt + offBitsSrc ;
        pbmi   = (PBITMAPINFO) ((PBYTE) pMfBitBlt + offBmiSrc) ;

	b = DoStretchBlt(pLocalDC,
			xDest,
			yDest,
			cxDest,
			cyDest,
			dwRop,
			xSrc,
			ySrc,
			cxDest,
			cyDest,
			pxformSrc,
			iUsageSrc,
			pbmi,
			cbBmiSrc,
			lpBits,
			cbBitsSrc);

        return(b) ;
}


/**************************************************************************
 * Handler - StretchBlt
 *************************************************************************/
BOOL bHandleStretchBlt(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL        b ;
PEMRSTRETCHBLT   pMfStretchBlt ;
LONG        xDest ;
LONG        yDest ;
LONG        cxDest ;
LONG        cyDest ;
DWORD       dwRop ;
LONG        xSrc ;
LONG        ySrc ;
LONG        cxSrc ;
LONG        cySrc ;
PXFORM      pxformSrc ;
COLORREF    crBkColorSrc ;
DWORD       iUsageSrc ;
DWORD       offBmiSrc ;
DWORD       cbBmiSrc ;
DWORD       offBitsSrc ;
DWORD       cbBitsSrc ;
PBITMAPINFO pbmi ;
LPBYTE      lpBits ;

        pMfStretchBlt = (PEMRSTRETCHBLT) pVoid ;

        xDest          = pMfStretchBlt->xDest ;
        yDest          = pMfStretchBlt->yDest ;
        cxDest         = pMfStretchBlt->cxDest ;
        cyDest         = pMfStretchBlt->cyDest ;
        dwRop          = pMfStretchBlt->dwRop ;
        xSrc           = pMfStretchBlt->xSrc ;
        ySrc           = pMfStretchBlt->ySrc ;
        pxformSrc      =&(pMfStretchBlt->xformSrc) ;
        crBkColorSrc   = pMfStretchBlt->crBkColorSrc ;	// not used

        iUsageSrc      = pMfStretchBlt->iUsageSrc ;
        offBmiSrc      = pMfStretchBlt->offBmiSrc ;
        cbBmiSrc       = pMfStretchBlt->cbBmiSrc ;
        offBitsSrc     = pMfStretchBlt->offBitsSrc ;
        cbBitsSrc      = pMfStretchBlt->cbBitsSrc ;

        lpBits = (PBYTE) pMfStretchBlt + offBitsSrc ;
        pbmi   = (PBITMAPINFO) ((PBYTE) pMfStretchBlt + offBmiSrc) ;

        cxSrc          = pMfStretchBlt->cxSrc ;
        cySrc          = pMfStretchBlt->cySrc ;

	b = DoStretchBlt(pLocalDC,
			xDest,
			yDest,
			cxDest,
			cyDest,
			dwRop,
			xSrc,
			ySrc,
			cxSrc,
			cySrc,
			pxformSrc,
			iUsageSrc,
			pbmi,
			cbBmiSrc,
			lpBits,
			cbBitsSrc);

        return(b) ;
}


/**************************************************************************
 * Handler - MaskBlt
 *************************************************************************/
BOOL bHandleMaskBlt(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL        b ;
PEMRMASKBLT  pMfMaskBlt ;
LONG        xDest ;
LONG        yDest ;
LONG        cxDest ;
LONG        cyDest ;
DWORD       dwRop ;
LONG        xSrc ;
LONG        ySrc ;
PXFORM      pxformSrc ;
COLORREF    crBkColorSrc ;
DWORD       iUsageSrc ;
DWORD       offBmiSrc ;
DWORD       cbBmiSrc ;
DWORD       offBitsSrc ;
DWORD       cbBitsSrc ;
PBITMAPINFO pbmi ;
LPBYTE      lpBits ;
LONG        xMask ;
LONG        yMask ;
DWORD       iUsageMask ;
DWORD       offBmiMask ;
DWORD       cbBmiMask ;
DWORD       offBitsMask ;
DWORD       cbBitsMask ;
PBITMAPINFO pbmiMask ;
LPBYTE      lpMaskBits ;

        pMfMaskBlt   = (PEMRMASKBLT) pVoid ;

        xDest        = pMfMaskBlt->xDest ;
        yDest        = pMfMaskBlt->yDest ;
        cxDest       = pMfMaskBlt->cxDest ;
        cyDest       = pMfMaskBlt->cyDest ;
        dwRop        = pMfMaskBlt->dwRop ;
        xSrc         = pMfMaskBlt->xSrc ;
        ySrc         = pMfMaskBlt->ySrc ;
        pxformSrc    =&(pMfMaskBlt->xformSrc) ;
        crBkColorSrc = pMfMaskBlt->crBkColorSrc ;		// not used

        iUsageSrc    = pMfMaskBlt->iUsageSrc ;
        offBmiSrc    = pMfMaskBlt->offBmiSrc ;
        cbBmiSrc     = pMfMaskBlt->cbBmiSrc ;
        offBitsSrc   = pMfMaskBlt->offBitsSrc ;
        cbBitsSrc    = pMfMaskBlt->cbBitsSrc ;

        lpBits = (PBYTE) pMfMaskBlt + offBitsSrc ;
        pbmi   = (PBITMAPINFO) ((PBYTE) pMfMaskBlt + offBmiSrc) ;

        xMask        = pMfMaskBlt->xMask ;
        yMask        = pMfMaskBlt->yMask ;
        iUsageMask   = pMfMaskBlt->iUsageMask ;
        offBmiMask   = pMfMaskBlt->offBmiMask ;
        cbBmiMask    = pMfMaskBlt->cbBmiMask ;
        offBitsMask  = pMfMaskBlt->offBitsMask ;
        cbBitsMask   = pMfMaskBlt->cbBitsMask ;

        lpMaskBits = (PBYTE) pMfMaskBlt + offBitsMask ;
        pbmiMask   = (PBITMAPINFO) ((PBYTE) pMfMaskBlt + offBmiMask) ;

	b = DoMaskBlt(pLocalDC,
			xDest,
			yDest,
			cxDest,
			cyDest,
			dwRop,
			xSrc,
			ySrc,
			pxformSrc,
			iUsageSrc,
			pbmi,
			cbBmiSrc,
			lpBits,
			cbBitsSrc,
			xMask,
			yMask,
			iUsageMask,
			pbmiMask,
			cbBmiMask,
			lpMaskBits,
			cbBitsMask);

        return(b) ;
}


/**************************************************************************
 * Handler - PlgBlt
 *************************************************************************/
BOOL bHandlePlgBlt(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL        b ;
PEMRPLGBLT   pMfPlgBlt ;
PPOINTL     pptlDest ;
LONG        xSrc ;
LONG        ySrc ;
LONG        cxSrc ;
LONG        cySrc ;
PXFORM      pxformSrc ;
COLORREF    crBkColorSrc ;
DWORD       iUsageSrc ;
DWORD       offBmiSrc ;
DWORD       cbBmiSrc ;
DWORD       offBitsSrc ;
DWORD       cbBitsSrc ;
PBITMAPINFO pbmi ;
LPBYTE      lpBits ;
LONG        xMask ;
LONG        yMask ;
DWORD       iUsageMask ;
DWORD       offBmiMask ;
DWORD       cbBmiMask ;
DWORD       offBitsMask ;
DWORD       cbBitsMask ;
PBITMAPINFO pbmiMask ;
LPBYTE      lpMaskBits ;

        pMfPlgBlt    = (PEMRPLGBLT) pVoid ;

        pptlDest     = pMfPlgBlt->aptlDest ;
        xSrc         = pMfPlgBlt->xSrc ;
        ySrc         = pMfPlgBlt->ySrc ;
        cxSrc        = pMfPlgBlt->cxSrc ;
        cySrc        = pMfPlgBlt->cySrc ;
        pxformSrc    =&(pMfPlgBlt->xformSrc) ;
        crBkColorSrc = pMfPlgBlt->crBkColorSrc ;		// not used

        iUsageSrc    = pMfPlgBlt->iUsageSrc ;
        offBmiSrc    = pMfPlgBlt->offBmiSrc ;
        cbBmiSrc     = pMfPlgBlt->cbBmiSrc ;
        offBitsSrc   = pMfPlgBlt->offBitsSrc ;
        cbBitsSrc    = pMfPlgBlt->cbBitsSrc ;

        lpBits = (PBYTE) pMfPlgBlt + offBitsSrc ;
        pbmi   = (PBITMAPINFO) ((PBYTE) pMfPlgBlt + offBmiSrc) ;

        xMask        = pMfPlgBlt->xMask ;
        yMask        = pMfPlgBlt->yMask ;
        iUsageMask   = pMfPlgBlt->iUsageMask ;
        offBmiMask   = pMfPlgBlt->offBmiMask ;
        cbBmiMask    = pMfPlgBlt->cbBmiMask ;
        offBitsMask  = pMfPlgBlt->offBitsMask ;
        cbBitsMask   = pMfPlgBlt->cbBitsMask ;

        lpMaskBits = (PBYTE) pMfPlgBlt + offBitsMask ;
        pbmiMask   = (PBITMAPINFO) ((PBYTE) pMfPlgBlt + offBmiMask) ;

	b = DoPlgBlt(pLocalDC,
                        pptlDest,
			xSrc,
			ySrc,
			cxSrc,
			cySrc,
			pxformSrc,
			iUsageSrc,
			pbmi,
			cbBmiSrc,
			lpBits,
			cbBitsSrc,
			xMask,
			yMask,
			iUsageMask,
			pbmiMask,
			cbBmiMask,
			lpMaskBits,
			cbBitsMask);

        return(b) ;
}


/**************************************************************************
 * Handler - Save DC
 *************************************************************************/
BOOL bHandleSaveDC(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL        b ;

        NOTUSED(pVoid) ;

        b = DoSaveDC(pLocalDC) ;

        return(b) ;
}


/**************************************************************************
 * Handler - Restore DC
 *************************************************************************/
BOOL bHandleRestoreDC(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL            b ;
PEMRRESTOREDC   pMfRestoreDc ;
INT             nSavedDC ;

        pMfRestoreDc = (PEMRRESTOREDC) pVoid ;

        nSavedDC = (INT) pMfRestoreDc->iRelative ;

        b = DoRestoreDC(pLocalDC, nSavedDC) ;

        return(b) ;
}


/**************************************************************************
 * Handler - End of File
 *************************************************************************/
BOOL bHandleEOF(PVOID pVoid, PLOCALDC pLocalDC)
{

    NOTUSED(pVoid) ;

    DoEOF(pLocalDC) ;

    return (TRUE) ;
}

/**************************************************************************
 * Handler - Header
 *************************************************************************/
BOOL bHandleHeader(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PENHMETAHEADER pemfheader ;

	pemfheader = (PENHMETAHEADER) pVoid ;

	b = DoHeader(pLocalDC, pemfheader) ;

        return (b) ;
}

/**************************************************************************
 * Handler - ScaleWindowExtEx
 *************************************************************************/
BOOL bHandleScaleWindowExt(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRSCALEWINDOWEXTEX pMfScaleWindowExt ;
INT     Xnum,
        Xdenom,
        Ynum,
        Ydenom ;


        pMfScaleWindowExt = (PEMRSCALEWINDOWEXTEX) pVoid ;

        // Scale the MapMode Mode

        Xnum   = (INT) pMfScaleWindowExt->xNum ;
        Xdenom = (INT) pMfScaleWindowExt->xDenom ;
        Ynum   = (INT) pMfScaleWindowExt->yNum ;
        Ydenom = (INT) pMfScaleWindowExt->yDenom ;

        // Do the translation.

        b = DoScaleWindowExt(pLocalDC, Xnum, Xdenom, Ynum, Ydenom) ;

        return (b) ;
}


/**************************************************************************
 * Handler - ScaleViewportExtEx
 *************************************************************************/
BOOL bHandleScaleViewportExt(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRSCALEVIEWPORTEXTEX pMfScaleViewportExt ;
INT     Xnum,
        Xdenom,
        Ynum,
        Ydenom ;


        pMfScaleViewportExt = (PEMRSCALEVIEWPORTEXTEX) pVoid ;

        // Scale the MapMode Mode

        Xnum   = (INT) pMfScaleViewportExt->xNum ;
        Xdenom = (INT) pMfScaleViewportExt->xDenom ;
        Ynum   = (INT) pMfScaleViewportExt->yNum ;
        Ydenom = (INT) pMfScaleViewportExt->yDenom ;

        // Do the translation.

        b = DoScaleViewportExt(pLocalDC, Xnum, Xdenom, Ynum, Ydenom) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SetViewportExtEx
 *************************************************************************/
BOOL bHandleSetViewportExt(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRSETVIEWPORTEXTEX pMfSetViewportExt ;
LONG    x, y ;

        pMfSetViewportExt = (PEMRSETVIEWPORTEXTEX) pVoid ;

        // Set the MapMode Mode

        x = pMfSetViewportExt->szlExtent.cx ;
        y = pMfSetViewportExt->szlExtent.cy ;

        // Do the translation.

        b = DoSetViewportExt(pLocalDC, (INT) x, (INT) y) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SetViewportOrgEx
 *************************************************************************/
BOOL bHandleSetViewportOrg(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRSETVIEWPORTORGEX pMfSetViewportOrg ;
LONG    x, y ;

        pMfSetViewportOrg = (PEMRSETVIEWPORTORGEX) pVoid ;

        // Set the MapMode Mode

        x = pMfSetViewportOrg->ptlOrigin.x ;
        y = pMfSetViewportOrg->ptlOrigin.y ;

        // Do the translation.

        b = DoSetViewportOrg(pLocalDC, (INT) x, (INT) y) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SetWindowExtEx
 *************************************************************************/
BOOL bHandleSetWindowExt(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRSETWINDOWEXTEX pMfSetWindowExt ;
LONG    x, y ;

        pMfSetWindowExt = (PEMRSETWINDOWEXTEX) pVoid ;

        // Set the MapMode Mode

        x = pMfSetWindowExt->szlExtent.cx ;
        y = pMfSetWindowExt->szlExtent.cy ;

        // Do the translation.

        b = DoSetWindowExt(pLocalDC, (INT) x, (INT) y) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SetWindowOrgEx
 *************************************************************************/
BOOL bHandleSetWindowOrg(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRSETWINDOWORGEX pMfSetWindowOrg ;
LONG    x, y ;

        pMfSetWindowOrg = (PEMRSETWINDOWORGEX) pVoid ;

        // Set the MapMode Mode

        x = pMfSetWindowOrg->ptlOrigin.x ;
        y = pMfSetWindowOrg->ptlOrigin.y ;

        // Do the translation.

        b = DoSetWindowOrg(pLocalDC, (INT) x, (INT) y) ;

        return (b) ;
}

/**************************************************************************
 * Handler - SetMapMode
 *************************************************************************/
BOOL bHandleSetMapMode(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
DWORD   iMapMode ;
PEMRSETMAPMODE pMfSetMapMode ;

        pMfSetMapMode = (PEMRSETMAPMODE) pVoid ;

        // Set the MapMode Mode

        iMapMode = pMfSetMapMode->iMode ;

        // Do the translation.

        b = DoSetMapMode(pLocalDC, iMapMode) ;

        return (b) ;

}

/**************************************************************************
 * Handler - SetArcDirection
 *************************************************************************/
BOOL bHandleSetArcDirection(PVOID pVoid, PLOCALDC pLocalDC)
{
PEMRSETARCDIRECTION pMfSetArcDirection ;
INT             iArcDirection ;
BOOL            b ;


        pMfSetArcDirection = (PEMRSETARCDIRECTION) pVoid ;

        iArcDirection = (INT) pMfSetArcDirection->iArcDirection ;

        b = DoSetArcDirection(pLocalDC, iArcDirection) ;

        return (b) ;
}


/**************************************************************************
 * Handler - AngleArc
 *************************************************************************/
BOOL bHandleAngleArc(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRANGLEARC  pMfAngleArc ;
int     x, y;
DWORD   nRadius ;
FLOAT   eStartAngle,
        eSweepAngle ;

        pMfAngleArc = (PEMRANGLEARC) pVoid ;

        // Set the Arc center

        x  = (int) pMfAngleArc->ptlCenter.x ;
        y  = (int) pMfAngleArc->ptlCenter.y ;

        // Get the radius of the Arc

        nRadius = (INT) pMfAngleArc->nRadius ;

        // Set the start & sweep angles

        eStartAngle = pMfAngleArc->eStartAngle ;
        eSweepAngle = pMfAngleArc->eSweepAngle ;

        b = DoAngleArc(pLocalDC, x, y, nRadius, eStartAngle, eSweepAngle) ;

        return (b) ;
}


/**************************************************************************
 * Handler - ArcTo
 *************************************************************************/
BOOL bHandleArcTo(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRARCTO  pMfArcTo ;
INT     x1, x2, x3, x4,
        y1, y2, y3, y4 ;

        pMfArcTo = (PEMRARCTO) pVoid ;

        // Set up the ellipse box, this will be the same as the bounding
        // rectangle.

        x1 = (INT) pMfArcTo->rclBox.left ;
        y1 = (INT) pMfArcTo->rclBox.top ;
        x2 = (INT) pMfArcTo->rclBox.right ;
        y2 = (INT) pMfArcTo->rclBox.bottom ;

        // Set the start point.

        x3 = (INT) pMfArcTo->ptlStart.x ;
        y3 = (INT) pMfArcTo->ptlStart.y ;

        // Set the end point.

        x4 = (INT) pMfArcTo->ptlEnd.x ;
        y4 = (INT) pMfArcTo->ptlEnd.y ;

        b = DoArcTo(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4) ;

        return (b) ;
}


/**************************************************************************
 * Handler - Arc
 *************************************************************************/
BOOL bHandleArc(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRARC  pMfArc ;
INT     x1, x2, x3, x4,
        y1, y2, y3, y4 ;

        pMfArc = (PEMRARC) pVoid ;

        // Set up the ellipse box, this will be the same as the bounding
        // rectangle.

        x1 = (INT) pMfArc->rclBox.left ;
        y1 = (INT) pMfArc->rclBox.top ;
        x2 = (INT) pMfArc->rclBox.right ;
        y2 = (INT) pMfArc->rclBox.bottom ;

        // Set the start point.

        x3 = (INT) pMfArc->ptlStart.x ;
        y3 = (INT) pMfArc->ptlStart.y ;

        // Set the end point.

        x4 = (INT) pMfArc->ptlEnd.x ;
        y4 = (INT) pMfArc->ptlEnd.y ;

        b = DoArc(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4) ;

        return (b) ;
}


/**************************************************************************
 * Handler - Ellipse
 *************************************************************************/
BOOL bHandleEllipse(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
INT     x1, y1, x2, y2 ;
PEMRELLIPSE  pMfEllipse ;

        pMfEllipse = (PEMRELLIPSE) pVoid ;

        // Set up the ellipse box, this will be the same as the bounding
        // rectangle.

        x1 = (INT) pMfEllipse->rclBox.left ;
        y1 = (INT) pMfEllipse->rclBox.top ;
        x2 = (INT) pMfEllipse->rclBox.right ;
        y2 = (INT) pMfEllipse->rclBox.bottom ;

        // Do the Ellipse translation.

        b = DoEllipse(pLocalDC, x1, y1, x2, y2) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SelectObject
 *************************************************************************/
BOOL bHandleSelectObject(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRSELECTOBJECT pMfSelectObject ;
INT     ihObject ;

        pMfSelectObject = (PEMRSELECTOBJECT) pVoid ;

        // Get the Object (it's really a Long)

        ihObject = (INT) pMfSelectObject->ihObject ;

        // Do the translation

        b = DoSelectObject(pLocalDC, ihObject) ;

        return (b) ;
}


/**************************************************************************
 * Handler - DeleteObject
 *************************************************************************/
BOOL bHandleDeleteObject(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRDELETEOBJECT pMfDeleteObject ;
INT     ihObject ;


        pMfDeleteObject = (PEMRDELETEOBJECT) pVoid ;
        ihObject = (INT) pMfDeleteObject->ihObject ;
        b = DoDeleteObject(pLocalDC, ihObject) ;

        return(b) ;
}


/**************************************************************************
 * Handler - CreateBrushIndirect
 *************************************************************************/
BOOL bHandleCreateBrushIndirect(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRCREATEBRUSHINDIRECT  pMfCreateBrushIndirect ;
LOGBRUSH LogBrush ;
INT     ihBrush ;

        pMfCreateBrushIndirect = (PEMRCREATEBRUSHINDIRECT) pVoid ;

        // Get the Brush parameters.

        LogBrush.lbStyle = pMfCreateBrushIndirect->lb.lbStyle;
        LogBrush.lbColor = pMfCreateBrushIndirect->lb.lbColor;
        LogBrush.lbHatch = (ULONG_PTR)pMfCreateBrushIndirect->lb.lbHatch;

        ihBrush   = pMfCreateBrushIndirect->ihBrush ;

        // Do the translation.

        b = DoCreateBrushIndirect(pLocalDC, ihBrush, &LogBrush) ;

        return (b) ;
}

/**************************************************************************
 * Handler - CreateMonoBrush
 *************************************************************************/
BOOL bHandleCreateMonoBrush(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRCREATEMONOBRUSH  pMfCreateMonoBrush ;
DWORD   ihBrush ;
DWORD   iUsage ;
DWORD   offBmi ;
DWORD   cbBmi ;
DWORD   offBits ;
DWORD   cbBits ;

PBITMAPINFO pBmi ;
PBYTE       pBits ;

        pMfCreateMonoBrush = (PEMRCREATEMONOBRUSH) pVoid ;

        ihBrush     =    pMfCreateMonoBrush->ihBrush ;
        iUsage      =    pMfCreateMonoBrush->iUsage ;
        offBmi      =    pMfCreateMonoBrush->offBmi ;
        cbBmi       =    pMfCreateMonoBrush->cbBmi ;
        offBits     =    pMfCreateMonoBrush->offBits ;
        cbBits      =    pMfCreateMonoBrush->cbBits ;

        pBmi        = (PBITMAPINFO) ((PBYTE) pVoid + offBmi) ;
        pBits       = (PBYTE) pVoid + offBits ;

        b = DoCreateMonoBrush(pLocalDC, ihBrush,
                                    pBmi, cbBmi,
                                    pBits, cbBits,
                                    iUsage) ;
        return (b) ;
}

/**************************************************************************
 * Handler - CreateDIBPatternBrush
 *************************************************************************/
BOOL bHandleCreateDIBPatternBrush(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRCREATEDIBPATTERNBRUSHPT  pMfCreateDIBPatternBrush ;
DWORD   ihBrush ;
DWORD   iUsage ;
DWORD   offBmi ;
DWORD   cbBmi ;
DWORD   offBits ;
DWORD   cbBits ;

PBITMAPINFO pBmi ;
PBYTE       pBits ;

        pMfCreateDIBPatternBrush = (PEMRCREATEDIBPATTERNBRUSHPT) pVoid ;

        ihBrush     =    pMfCreateDIBPatternBrush->ihBrush ;
        iUsage      =    pMfCreateDIBPatternBrush->iUsage ;
        offBmi      =    pMfCreateDIBPatternBrush->offBmi ;
        cbBmi       =    pMfCreateDIBPatternBrush->cbBmi ;
        offBits     =    pMfCreateDIBPatternBrush->offBits ;
        cbBits      =    pMfCreateDIBPatternBrush->cbBits ;

        pBmi        = (PBITMAPINFO) ((PBYTE) pVoid + offBmi) ;
        pBits       = (PBYTE) pVoid + offBits ;

        b = DoCreateDIBPatternBrush(pLocalDC, ihBrush,
                                    pBmi, cbBmi,
                                    pBits, cbBits,
                                    iUsage) ;
        return (b) ;
}


/**************************************************************************
 * Handler - CreatePen
 *************************************************************************/
BOOL bHandleCreatePen(PVOID pVoid, PLOCALDC pLocalDC)
{
PEMRCREATEPEN pMfCreatePen ;
INT          ihPen ;
PLOGPEN      pLogPen ;
BOOL         b ;

        pMfCreatePen = (PEMRCREATEPEN) pVoid ;

        ihPen   = pMfCreatePen->ihPen ;
        pLogPen = &pMfCreatePen->lopn ;

        b = DoCreatePen(pLocalDC, ihPen, pLogPen) ;

        return(b) ;
}


/**************************************************************************
 * Handler - ExtCreatePen
 *************************************************************************/
BOOL bHandleExtCreatePen(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMREXTCREATEPEN     pMfExtCreatePen ;
PEXTLOGPEN          pExtLogPen ;
INT                 ihPen ;

        pMfExtCreatePen = (PEMREXTCREATEPEN) pVoid ;

        pExtLogPen = &pMfExtCreatePen->elp ;
        ihPen      = pMfExtCreatePen->ihPen ;

        b = DoExtCreatePen(pLocalDC, ihPen, pExtLogPen) ;

        return (b) ;
}


/**************************************************************************
 * Handler - MoveToEx
 *************************************************************************/
BOOL bHandleMoveTo(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRMOVETOEX pMfMoveTo ;
INT     x, y ;

        pMfMoveTo = (PEMRMOVETOEX) pVoid ;

        // Get the position.

        x = (INT) pMfMoveTo->ptl.x ;
        y = (INT) pMfMoveTo->ptl.y ;

        // Do the translation.

        b = DoMoveTo(pLocalDC, x, y) ;

        return (b) ;
}


/**************************************************************************
 * Handler - LineTo
 *************************************************************************/
BOOL bHandleLineTo(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRLINETO   pMfLineTo ;
INT     x, y ;

        pMfLineTo = (PEMRLINETO) pVoid ;

        // Get the new point.

        x = (INT) pMfLineTo->ptl.x ;
        y = (INT) pMfLineTo->ptl.y ;

        // Do the translation.

        b = DoLineTo(pLocalDC, x, y) ;

        return (b) ;
}


/**************************************************************************
 * Handler - Chord
 *************************************************************************/
BOOL bHandleChord(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRCHORD  pMfChord ;
INT     x1, x2, x3, x4,
        y1, y2, y3, y4 ;

        pMfChord = (PEMRCHORD) pVoid ;

        // Set the rectangle

        x1 = (INT) pMfChord->rclBox.left   ;
        y1 = (INT) pMfChord->rclBox.top    ;
        x2 = (INT) pMfChord->rclBox.right  ;
        y2 = (INT) pMfChord->rclBox.bottom ;

        // Set the start point.

        x3 = (INT) pMfChord->ptlStart.x ;
        y3 = (INT) pMfChord->ptlStart.y ;

        // Set the end point.

        x4 = (INT) pMfChord->ptlEnd.x ;
        y4 = (INT) pMfChord->ptlEnd.y ;

        // Do the translation

        b = DoChord(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4) ;

        return (b) ;
}


/**************************************************************************
 * Handler - Pie
 *************************************************************************/
BOOL bHandlePie(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRPIE  pMfPie ;
INT     x1, x2, x3, x4,
        y1, y2, y3, y4 ;

        pMfPie = (PEMRPIE) pVoid ;

        // Set up the ellipse box

        x1 = (INT) pMfPie->rclBox.left   ;
        y1 = (INT) pMfPie->rclBox.top    ;
        x2 = (INT) pMfPie->rclBox.right  ;
        y2 = (INT) pMfPie->rclBox.bottom ;

        // Set the start point.

        x3 = (INT) pMfPie->ptlStart.x ;
        y3 = (INT) pMfPie->ptlStart.y ;

        // Set the end point.

        x4 = (INT) pMfPie->ptlEnd.x ;
        y4 = (INT) pMfPie->ptlEnd.y ;

        // Do the Pie translation.

        b = DoPie(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4) ;

        return (b) ;
}


/**************************************************************************
 * Handler - Polyline
 *************************************************************************/
BOOL bHandlePolyline(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRPOLYLINE pMfPolyline ;
INT     nCount ;
PPOINTL pptl ;

        pMfPolyline = (PEMRPOLYLINE) pVoid ;

        // Copy the line count and the polyline verticies to
        // the record.

        nCount = (INT) pMfPolyline->cptl ;
        pptl = pMfPolyline->aptl ;

        // Now do the translation.

        b = DoPoly(pLocalDC, pptl, nCount, EMR_POLYLINE) ;

        return (b) ;
}


/**************************************************************************
 * Handler - PolylineTo
 *************************************************************************/
BOOL bHandlePolylineTo (PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRPOLYLINETO pMfPolylineTo ;
INT     nCount ;
PPOINTL pptl ;

        pMfPolylineTo = (PEMRPOLYLINETO) pVoid ;

        // Copy the line count and the polyline verticies to
        // the record.

        nCount = (INT) pMfPolylineTo->cptl ;
        pptl = pMfPolylineTo->aptl ;

        // Now do the translation.

        b = DoPolylineTo(pLocalDC, pptl, nCount) ;

        return (b) ;
}


/**************************************************************************
 * Handler - PolyBezier16,Polygon16,Polyline16,PolyBezierTo16,PolylineTo16
 *           PolyDraw16
 *************************************************************************/
BOOL bHandlePoly16 (PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL        b = FALSE;
PEMRPOLYLINE16 pMfPoly16 ;	// common structure for the poly16 records
PEMRPOLYDRAW16 pMfPolyDraw16 ;
POINTL      aptl[MAX_STACK_POINTL];
PPOINTL     pptl ;
INT         nCount ;
PBYTE       pb ;

// PolyDraw16 contains the structure of Poly16 followed by the byte array.

        pMfPoly16 = (PEMRPOLYLINE16) pVoid ;

        nCount = (INT) pMfPoly16->cpts ;

	if (nCount <= MAX_STACK_POINTL)
	    pptl = aptl;
	else if (!(pptl = (PPOINTL) LocalAlloc(LMEM_FIXED, nCount * sizeof(POINTL))))
	    return(b);

	POINTS_TO_POINTL(pptl, pMfPoly16->apts, (DWORD) nCount);

        // Now do the translation.

	switch (pMfPoly16->emr.iType)
	{
	    case EMR_POLYBEZIER16:
	        b = DoPolyBezier(pLocalDC, (LPPOINT) pptl, nCount) ;
	        break;

	    case EMR_POLYGON16:
	        b = DoPoly(pLocalDC, pptl, nCount, EMR_POLYGON) ;
	        break;

	    case EMR_POLYLINE16:
	        b = DoPoly(pLocalDC, pptl, nCount, EMR_POLYLINE) ;
	        break;

	    case EMR_POLYBEZIERTO16:
	        b = DoPolyBezierTo(pLocalDC, (LPPOINT) pptl, nCount) ;
	        break;

	    case EMR_POLYLINETO16:
	        b = DoPolylineTo(pLocalDC, pptl, nCount) ;
	        break;

	    case EMR_POLYDRAW16:
                pMfPolyDraw16 = (PEMRPOLYDRAW16) pVoid ;
                pb = (PBYTE) &pMfPolyDraw16->apts[nCount];
	        b = DoPolyDraw(pLocalDC, (LPPOINT) pptl, pb, nCount);
	        break;

	    default:
	        ASSERTGDI(FALSE, "Bad record type");
	        break;
	}

	if (nCount > MAX_STACK_POINTL)
	    if (LocalFree(pptl))
		ASSERTGDI(FALSE, "bHandlePoly16: LocalFree failed");

        return (b) ;
}


/**************************************************************************
 * Handler - PolyPolyline
 *************************************************************************/
BOOL bHandlePolyPolyline(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRPOLYPOLYLINE pMfPolyPolyline ;
PDWORD  pPolyCount ;
PPOINTL pptl ;
INT     nPolys ;

        pMfPolyPolyline = (PEMRPOLYPOLYLINE) pVoid ;

        // Copy the  Polycount count, the polycount array
        // and the polyline verticies to
        // the record.

        nPolys = (INT) pMfPolyPolyline->nPolys ;
        pPolyCount = pMfPolyPolyline->aPolyCounts ;
        pptl = (PPOINTL) &pMfPolyPolyline->aPolyCounts[nPolys] ;

        // Now do the translation.

        b = DoPolyPolyline(pLocalDC, pptl, pPolyCount, nPolys) ;

        return (b) ;
}


/**************************************************************************
 * Handler - PolyPolyline16,PolyPolygon16
 *************************************************************************/
BOOL bHandlePolyPoly16 (PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b = FALSE;
PEMRPOLYPOLYLINE16 pMfPolyPoly16 ;	// common structure for polypoly16 records
PDWORD  pPolyCount ;
POINTL  aptl[MAX_STACK_POINTL];
PPOINTL pptl ;
INT     nCount;
DWORD	cpts ;

        pMfPolyPoly16 = (PEMRPOLYPOLYLINE16) pVoid ;

        nCount = (INT) pMfPolyPoly16->nPolys ;
	cpts   = pMfPolyPoly16->cpts;
        pPolyCount = pMfPolyPoly16->aPolyCounts ;

	if (cpts <= MAX_STACK_POINTL)
	    pptl = aptl;
	else if (!(pptl = (PPOINTL) LocalAlloc(LMEM_FIXED, cpts * sizeof(POINTL))))
	    return(b);

	POINTS_TO_POINTL(pptl, (PPOINTS) &pMfPolyPoly16->aPolyCounts[nCount], cpts);

        // Now do the translation.

	switch (pMfPolyPoly16->emr.iType)
	{
	case EMR_POLYPOLYLINE16:
	    b = DoPolyPolyline(pLocalDC, pptl, pPolyCount, nCount) ;
	    break;
	case EMR_POLYPOLYGON16:
	    b = DoPolyPolygon(pLocalDC, pptl, pPolyCount, cpts, nCount) ;
	    break;
	default:
	    ASSERTGDI(FALSE, "Bad record type");
	    break;
	}

	if (cpts > MAX_STACK_POINTL)
	    if (LocalFree(pptl))
		ASSERTGDI(FALSE, "bHandlePolyPoly16: LocalFree failed");

        return (b) ;
}


/**************************************************************************
 * Handler - Polygon
 *************************************************************************/
BOOL bHandlePolygon (PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRPOLYGON pMfPolygon ;
PPOINTL pptl ;
INT     nCount ;

        pMfPolygon = (PEMRPOLYGON) pVoid ;

        // Copy the line count and the Polygon verticies to
        // the record.

        nCount = (INT) pMfPolygon->cptl ;
        pptl = pMfPolygon->aptl ;

        // Now do the translation.

        b = DoPoly(pLocalDC, pptl, nCount, EMR_POLYGON) ;

        return (b) ;
}


/**************************************************************************
 * Handler - PolyPolygon
 *************************************************************************/
BOOL bHandlePolyPolygon(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRPOLYPOLYGON pMfPolyPolygon ;
PDWORD  pPolyCount ;
PPOINTL pptl ;
DWORD	cptl ;
INT     nPolys ;

        pMfPolyPolygon = (PEMRPOLYPOLYGON) pVoid ;

        // Copy the  Polycount count, the polycount array
        // and the polygon verticies to
        // the record.

        nPolys = (INT) pMfPolyPolygon->nPolys ;
        pPolyCount = pMfPolyPolygon->aPolyCounts ;
        pptl = (PPOINTL) &pMfPolyPolygon->aPolyCounts[nPolys] ;
	cptl = pMfPolyPolygon->cptl ;

        // Now do the translation.

        b = DoPolyPolygon(pLocalDC, pptl, pPolyCount, cptl, nPolys) ;

        return (b) ;
}


/**************************************************************************
 * Handler - Rectangle
 *************************************************************************/
BOOL bHandleRectangle(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRRECTANGLE  pMfRectangle ;
INT     x1, y1, x2, y2 ;

        pMfRectangle = (PEMRRECTANGLE) pVoid ;

        // Set up the Rectangle box, this will be the same as the bounding
        // rectangle.

        x1 = (INT) pMfRectangle->rclBox.left   ;
        y1 = (INT) pMfRectangle->rclBox.top    ;
        x2 = (INT) pMfRectangle->rclBox.right  ;
        y2 = (INT) pMfRectangle->rclBox.bottom ;

        // Do the Rectangle translation.

        b = DoRectangle(pLocalDC, x1, y1, x2, y2) ;

        return (b) ;
}


/**************************************************************************
 * Handler - RoundRect
 *************************************************************************/
BOOL bHandleRoundRect (PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMRROUNDRECT  pMfRoundRect ;
INT     x1, y1, x2, y2, x3, y3 ;

        pMfRoundRect = (PEMRROUNDRECT) pVoid ;

        // Set up the RoundRect box, this will be the same as the bounding
        // RoundRect.

        x1 = (INT) pMfRoundRect->rclBox.left   ;
        y1 = (INT) pMfRoundRect->rclBox.top    ;
        x2 = (INT) pMfRoundRect->rclBox.right  ;
        y2 = (INT) pMfRoundRect->rclBox.bottom ;
        x3 = (INT) pMfRoundRect->szlCorner.cx ;
        y3 = (INT) pMfRoundRect->szlCorner.cy ;

        // Do the RoundRect translation.

        b = DoRoundRect(pLocalDC, x1, y1, x2, y2, x3, y3) ;

        return (b) ;
}


/**************************************************************************
 * Handler - ExtTextOut for both ANSI and UNICODE characters.
 **************************************************************************/
BOOL bHandleExtTextOut(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
PEMREXTTEXTOUTA  pMfExtTextOut ;	// same for both ansi and unicode
INT     x, y, nCount ;
DWORD   flOptions ;
PRECTL  pRectl ;
PLONG   pDx ;
PWCH    pwchar ;
DWORD   iGraphicsMode;

        pMfExtTextOut = (PEMREXTTEXTOUTA) pVoid ;

	ASSERTGDI(pMfExtTextOut->emr.iType == EMR_EXTTEXTOUTA
	       || pMfExtTextOut->emr.iType == EMR_EXTTEXTOUTW,
		  "MF3216: bHandleExtTextOut: bad record type");

        // Copy over the start position for the string.

        x = (INT) pMfExtTextOut->emrtext.ptlReference.x ;
        y = (INT) pMfExtTextOut->emrtext.ptlReference.y ;

        // Now copy over the Options flag, character count,
        // the clip/opaque rectangle, and the Ansi/Unicode string.

        flOptions = pMfExtTextOut->emrtext.fOptions  ;
        nCount    = (INT) pMfExtTextOut->emrtext.nChars ;
        pRectl    = &pMfExtTextOut->emrtext.rcl ;
        pwchar    = (PWCH) ((PBYTE) pMfExtTextOut + pMfExtTextOut->emrtext.offString);
        iGraphicsMode = pMfExtTextOut->iGraphicsMode;

        // Set up the spacing vector

        pDx = (PLONG) ((PBYTE) pMfExtTextOut + pMfExtTextOut->emrtext.offDx);

        // Now do the conversion.

        b = DoExtTextOut(pLocalDC, x, y, flOptions,
                         pRectl, pwchar, nCount, pDx, iGraphicsMode,
			 pMfExtTextOut->emr.iType);

        return (b) ;
}


/**************************************************************************
 * Handler - PolyTextOut for both ANSI and UNICODE characters.
 **************************************************************************/
BOOL bHandlePolyTextOut(PVOID pVoid, PLOCALDC pLocalDC)
{
PEMRPOLYTEXTOUTA pMfPolyTextOut;	// same for both ansi and unicode
PWCH    pwchar;
LONG    i;
DWORD   iType;
LONG    cStrings;
PEMRTEXT pemrtext;
PLONG   pDx ;
DWORD   iGraphicsMode;

        pMfPolyTextOut = (PEMRPOLYTEXTOUTA) pVoid ;

	ASSERTGDI(pMfPolyTextOut->emr.iType == EMR_POLYTEXTOUTA
	       || pMfPolyTextOut->emr.iType == EMR_POLYTEXTOUTW,
		  "MF3216: bHandlePolyTextOut: bad record type");

	iType  = pMfPolyTextOut->emr.iType == EMR_POLYTEXTOUTA
		 ? EMR_EXTTEXTOUTA
		 : EMR_EXTTEXTOUTW;
	cStrings = pMfPolyTextOut->cStrings;
        iGraphicsMode = pMfPolyTextOut->iGraphicsMode;

	// Convert to ExtTextOut

	for (i = 0; i < cStrings; i++)
	{
	    pemrtext = &pMfPolyTextOut->aemrtext[i];
	    pwchar = (PWCH) ((PBYTE) pMfPolyTextOut + pemrtext->offString);
	    pDx    = (PLONG) ((PBYTE) pMfPolyTextOut + pemrtext->offDx);

	    if (!DoExtTextOut(pLocalDC, pemrtext->ptlReference.x, pemrtext->ptlReference.y,
			pemrtext->fOptions, &pemrtext->rcl,
			pwchar, pemrtext->nChars, pDx, iGraphicsMode, iType))
		return(FALSE);
	}

	return(TRUE);
}


/**************************************************************************
 * Handler - ExtCreateFont
 *************************************************************************/
BOOL bHandleExtCreateFont(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b;
PEMREXTCREATEFONTINDIRECTW pMfExtCreateFontW;
PLOGFONTW plfw;
INT       ihFont;

        pMfExtCreateFontW = (PEMREXTCREATEFONTINDIRECTW) pVoid ;

        // Get the font parameters.

        ihFont = (INT) pMfExtCreateFontW->ihFont ;
        plfw  = &pMfExtCreateFontW->elfw.elfLogFont;

        // Do the translation.

        b = DoExtCreateFont(pLocalDC, ihFont, plfw);

        return (b) ;
}


/**************************************************************************
 * Handler - SetBkColor
 *************************************************************************/
BOOL bHandleSetBkColor(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL        b ;
PEMRSETBKCOLOR pMfSetBkColor ;

        pMfSetBkColor = (PEMRSETBKCOLOR) pVoid ;

        // Do the translation.

        b = DoSetBkColor(pLocalDC, pMfSetBkColor->crColor) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SetBkMode
 *************************************************************************/
BOOL bHandleSetBkMode(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
DWORD   iBkMode ;
PEMRSETBKMODE pMfSetBkMode ;

        pMfSetBkMode = (PEMRSETBKMODE) pVoid ;

        // Set the Background Mode variable

        iBkMode = pMfSetBkMode->iMode ;

        // Do the translation.

        b = DoSetBkMode(pLocalDC, iBkMode) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SetMapperFlags
 *************************************************************************/
BOOL bHandleSetMapperFlags(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
DWORD   f ;
PEMRSETMAPPERFLAGS pMfSetMapperFlags ;

        pMfSetMapperFlags = (PEMRSETMAPPERFLAGS) pVoid ;

        f = pMfSetMapperFlags->dwFlags ;

        // Do the translation.

        b = DoSetMapperFlags(pLocalDC, f) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SetPolyFillMode
 *************************************************************************/
BOOL bHandleSetPolyFillMode(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
INT     iPolyFillMode ;
PEMRSETPOLYFILLMODE pMfSetPolyFillMode ;

        pMfSetPolyFillMode = (PEMRSETPOLYFILLMODE) pVoid ;

        // Set the PolyFill Mode

        iPolyFillMode = (INT) pMfSetPolyFillMode->iMode ;

        // Do the translation.

        b = DoSetPolyFillMode(pLocalDC, iPolyFillMode) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SetRop2
 *************************************************************************/
BOOL bHandleSetRop2(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
DWORD   iDrawMode ;
PEMRSETROP2 pMfSetROP2 ;

        pMfSetROP2 = (PEMRSETROP2) pVoid ;

        // Set the Draw Mode

        iDrawMode = pMfSetROP2->iMode ;

        // Do the translation.

        b = DoSetRop2(pLocalDC, iDrawMode) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SetStretchBltMode
 *************************************************************************/
BOOL bHandleSetStretchBltMode(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
DWORD   iStretchMode ;
PEMRSETSTRETCHBLTMODE pMfSetStretchBltMode ;

        pMfSetStretchBltMode = (PEMRSETSTRETCHBLTMODE) pVoid ;

        // Set the StretchBlt Mode

        iStretchMode = pMfSetStretchBltMode->iMode ;

        // Do the translation.

        b = DoSetStretchBltMode(pLocalDC, iStretchMode) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SetTextAlign
 *************************************************************************/
BOOL bHandleSetTextAlign(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL    b ;
DWORD   fMode ;
PEMRSETTEXTALIGN pMfSetTextAlign ;

        pMfSetTextAlign = (PEMRSETTEXTALIGN) pVoid ;

        // Set the TextAlign Mode

        fMode = pMfSetTextAlign->iMode ;

        // Do the translation.

        b = DoSetTextAlign(pLocalDC, fMode) ;

        return (b) ;
}


/**************************************************************************
 * Handler - SetTextColor
 *************************************************************************/
BOOL bHandleSetTextColor(PVOID pVoid, PLOCALDC pLocalDC)
{
BOOL        b ;
PEMRSETTEXTCOLOR pMfSetTextColor ;

        pMfSetTextColor = (PEMRSETTEXTCOLOR) pVoid ;

        // Do the translation.

        b = DoSetTextColor(pLocalDC, pMfSetTextColor->crColor) ;

        return (b) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\mf3216\lines.c ===
/*****************************************************************************
 *
 * lines - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************
 *  PolylineTo  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPolylineTo
(
PLOCALDC pLocalDC,
PPOINTL pptl,
DWORD   cptl
)
{
BOOL    b ;

    // Handle path.

        if (pLocalDC->flags & RECORDING_PATH)
        return(PolylineTo(pLocalDC->hdcHelper, (LPPOINT) pptl, (DWORD) cptl));

    // Handle the trivial case.

    if (cptl == 0)
        return(TRUE);

        // This can be done by using a LineTo, PolyLine, & MoveTo.

        if (!DoLineTo(pLocalDC, pptl[0].x, pptl[0].y))
        return(FALSE);

    // If there is only one point, we are done.

    if (cptl == 1)
        return(TRUE);

        if (!DoPoly(pLocalDC, pptl, cptl, EMR_POLYLINE))
        return(FALSE);

        b = DoMoveTo(pLocalDC, pptl[cptl-1].x, pptl[cptl-1].y) ;
        return (b) ;
}


/***************************************************************************
 *  PolyPolyline  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPolyPolyline
(
PLOCALDC pLocalDC,
PPOINTL pptl,                       // -> to PolyPolyline points.
PDWORD  pcptl,                      // -> to PolyCounts
DWORD   ccptl                       // # of PolyCounts.
)
{
BOOL    b ;
UINT    i,
        iStart,
        nCount ;

    b = TRUE;       // just in case if there is no poly

        // Let polyline do the work.

        iStart = 0 ;
        for (i = 0 ; i < ccptl ; i++)
        {
            nCount = pcptl[i] ;
            b = DoPoly(pLocalDC, &pptl[iStart], nCount, EMR_POLYLINE) ;
            if (b == FALSE)
                break ;
            iStart += nCount ;
        }

        return(b) ;
}


/***************************************************************************
 *  LineTo  - Win32 to Win16 Metafile Converter Entry Point
 *
 *  See DoMoveTo() in misc.c for notes on the current position.
 **************************************************************************/
BOOL WINAPI DoLineTo
(
PLOCALDC  pLocalDC,
LONG    x,
LONG    y
)
{
BOOL    b ;
POINT   pt ;
POINT   ptCP;

        // Whether we are recording for a path or acutally emitting
        // a drawing order we must pass the drawing order to the helper DC
        // so the helper can maintain the current positon.
        // If we're recording the drawing orders for a path
        // then just pass the drawing order to the helper DC.
        // Do not emit any Win16 drawing orders.

        if (pLocalDC->flags & RECORDING_PATH)
        return(LineTo(pLocalDC->hdcHelper, (INT) x, (INT) y));

    // Update the current position in the converted metafile if
    // it is different from that of the helper DC.  See notes
    // in DoMoveTo().

    if (!GetCurrentPositionEx(pLocalDC->hdcHelper, &ptCP))
        return(FALSE);

    // Make sure that the converted metafile has the same CP as the
    // helper DC.

    if (!bValidateMetaFileCP(pLocalDC, ptCP.x, ptCP.y))
        return(FALSE);

    // Update the helper DC.

    if (!LineTo(pLocalDC->hdcHelper, (INT) x, (INT) y))
        return(FALSE);

        // Compute the new current position.

        pt.x = x ;
        pt.y = y ;
    if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) &pt, 1L))
        return(FALSE);

        // Update the mf16 current position to what it will be when this call
        // is finished.

        pLocalDC->ptCP = pt ;

        // Call the Win16 routine to emit the line to the metafile.

        b = bEmitWin16LineTo(pLocalDC, LOWORD(pt.x), LOWORD(pt.y)) ;
        return(b) ;
}

/***************************************************************************
 *  Polyline/Polygon  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPoly
(
PLOCALDC pLocalDC,
PPOINTL  pptl,
DWORD    cptl,
INT      mrType
)
{
BOOL    b ;
PPOINTL pptlBuff ;

        // If we're recording the drawing orders for a path
        // then just pass the drawing order to the helper DC.
        // Do not emit any Win16 drawing orders.

        if (pLocalDC->flags & RECORDING_PATH)
        {
        switch(mrType)
        {
        case EMR_POLYLINE:
        b = Polyline(pLocalDC->hdcHelper, (LPPOINT) pptl, (INT) cptl) ;
        break;
        case EMR_POLYGON:
        b = Polygon(pLocalDC->hdcHelper, (LPPOINT) pptl, (INT) cptl) ;
        break;
        }
            return(b) ;
        }

        // The Win16 poly record is limited to 64K points.
        // Need to check this limit.

        if (cptl > (DWORD) (WORD) MAXWORD)
    {
        b = FALSE;
            PUTS("MF3216: DoPoly, Too many point in poly array\n") ;
            SetLastError(ERROR_NOT_ENOUGH_MEMORY) ;
            goto exit1 ;
    }

        // Allocate a buffer to do the transformation in.
        // Then copy the points to this buffer.

        pptlBuff = (PPOINTL) LocalAlloc(LMEM_FIXED, cptl * sizeof(POINTL)) ;
        if (!pptlBuff)
        {
        b = FALSE;
            PUTS("MF3216: DoPoly, LocalAlloc failed\n") ;
            goto exit1 ;
        }

        RtlCopyMemory(pptlBuff, pptl, cptl * sizeof(POINTL)) ;

        // Do the transformations.

    b = bXformRWorldToPPage(pLocalDC, pptlBuff, cptl) ;
        if (b == FALSE)
            goto exit2 ;

        // Compress the POINTLs to POINTSs

        vCompressPoints(pptlBuff, cptl) ;

        // Call the Win16 routine to emit the poly to the metafile.

    b = bEmitWin16Poly(pLocalDC, (LPPOINTS) pptlBuff, (SHORT) cptl,
        (WORD) (mrType == EMR_POLYLINE ? META_POLYLINE : META_POLYGON)) ;

        // Free the memory used as the transform buffer.
exit2:
        if (LocalFree(pptlBuff))
        ASSERTGDI(FALSE, "MF3216: DoPoly, LocalFree failed");
exit1:
        return(b) ;
}


/***************************************************************************
 * vCompressPoints - Utility routine to compress the POINTLs to POINTSs.
 **************************************************************************/
VOID vCompressPoints(PVOID pBuff, LONG nCount)
{
PPOINTL pPointl ;
PPOINTS pPoints ;
INT     i ;

        pPointl = (PPOINTL) pBuff ;
        pPoints = (PPOINTS) pBuff ;

        for (i = 0 ; i < nCount ; i++)
        {
            pPoints[i].x = LOWORD(pPointl[i].x) ;
            pPoints[i].y = LOWORD(pPointl[i].y) ;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\mf3216\handlers.h ===
/****************************************************************************
 *  Handlers.h - Definitions for handlers.
 *
 *  DATE:   11-Dec-1991
 *  Author: Jeffrey Newman (c-jeffn)
 *
 *  Copyright (c) Microsoft Inc. 1991
 ****************************************************************************/

//  Following is a typedef for the Drawing Order Handler

typedef BOOL DOFN (PVOID, PLOCALDC) ;
typedef DOFN *PDOFN ;

DOFN bHandleHeader;
DOFN bHandleSetArcDirection;
DOFN bHandleArc;
DOFN bHandleArcTo;
DOFN bHandleAngleArc;
DOFN bHandleEllipse;
DOFN bHandleSelectObject;
DOFN bHandleDeleteObject;
DOFN bHandleCreateBrushIndirect;
DOFN bHandleCreateDIBPatternBrush;
DOFN bHandleCreateMonoBrush;
DOFN bHandleCreatePen;
DOFN bHandleExtCreatePen;
DOFN bHandleMoveTo;
DOFN bHandleLineTo;
DOFN bHandleChord;
DOFN bHandlePie;
DOFN bHandlePolyline;
DOFN bHandlePolylineTo ;
DOFN bHandlePolyPolyline;
DOFN bHandlePolygon ;
DOFN bHandlePolyPolygon;
DOFN bHandleRectangle;
DOFN bHandleRoundRect ;
DOFN bHandlePoly16 ;
DOFN bHandlePolyPoly16 ;

DOFN bHandleExtTextOut;
DOFN bHandlePolyTextOut;
DOFN bHandleExtCreateFont;
DOFN bHandleSetBkColor;
DOFN bHandleSetBkMode;
DOFN bHandleSetMapperFlags;
DOFN bHandleSetPolyFillMode;
DOFN bHandleSetRop2;
DOFN bHandleSetStretchBltMode;
DOFN bHandleSetTextAlign;
DOFN bHandleSetTextColor;

DOFN bHandleSelectPalette;
DOFN bHandleCreatePalette;
DOFN bHandleSetPaletteEntries;
DOFN bHandleResizePalette;
DOFN bHandleRealizePalette;

DOFN bHandleSetMapMode;

DOFN bHandleSetWindowOrg;
DOFN bHandleSetWindowExt;

DOFN bHandleSetViewportOrg;
DOFN bHandleSetViewportExt;

DOFN bHandleScaleViewportExt;
DOFN bHandleScaleWindowExt;

DOFN bHandleEOF;

DOFN bHandleSaveDC;
DOFN bHandleRestoreDC;

DOFN bHandleBitBlt;
DOFN bHandleStretchBlt;
DOFN bHandleMaskBlt;
DOFN bHandlePlgBlt;
DOFN bHandleSetDIBitsToDevice;
DOFN bHandleStretchDIBits;


DOFN bHandleBeginPath;
DOFN bHandleEndPath;
DOFN bHandleFlattenPath;
DOFN bHandleStrokePath;
DOFN bHandleFillPath;
DOFN bHandleStrokeAndFillPath;
DOFN bHandleWidenPath;
DOFN bHandleSelectClipPath;
DOFN bHandleCloseFigure;
DOFN bHandleAbortPath;

DOFN bHandlePolyBezier;
DOFN bHandlePolyBezierTo;
DOFN bHandlePolyDraw;

DOFN bHandleSetWorldTransform;
DOFN bHandleModifyWorldTransform;

DOFN bHandleSetPixel;

DOFN bHandleFillRgn;
DOFN bHandleFrameRgn;
DOFN bHandleInvertRgn;
DOFN bHandlePaintRgn;
DOFN bHandleExtSelectClipRgn;
DOFN bHandleOffsetClipRgn;

DOFN bHandleExcludeClipRect;
DOFN bHandleIntersectClipRect;
DOFN bHandleSetMetaRgn;

DOFN bHandleGdiComment;

DOFN bHandleExtFloodFill;
DOFN bHandleNotImplemented;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\mf3216\paths.c ===
/*****************************************************************************
 *
 * paths - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************
 *  BeginPath  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoBeginPath
(
PLOCALDC pLocalDC
)
{
BOOL    b ;

        // Set the global flag telling all all the geometric
        // rendering routines that we are accumulating drawing orders
        // for the path.

        pLocalDC->flags |= RECORDING_PATH ;

        // Tell the helper DC we are begining the path accumulation.

        b = BeginPath(pLocalDC->hdcHelper) ;

        ASSERTGDI((b == TRUE), "MF3216: DoBeginPath, BeginPath failed\n") ;

        return (b) ;
}

/***************************************************************************
 *  EndPath  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoEndPath
(
PLOCALDC pLocalDC
)
{
BOOL    b ;

        // Reset the global flag, turning off the path accumulation.

        pLocalDC->flags &= ~RECORDING_PATH ;

        b = EndPath(pLocalDC->hdcHelper) ;

        ASSERTGDI((b == TRUE), "MF3216: DoEndPath, EndPath failed\n") ;

        return (b) ;
}

/***************************************************************************
 *  WidenPath  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoWidenPath
(
PLOCALDC pLocalDC
)
{
BOOL    b ;

        b = WidenPath(pLocalDC->hdcHelper) ;

        ASSERTGDI((b == TRUE), "MF3216: DoWidenPath, WidenPath failed\n") ;

        return (b) ;
}

/***************************************************************************
 *  SelectClipPath  - Win32 to Win16 Metafile Converter Entry Point
 *
 * History:
 *  Tue Apr 07 17:05:37 1992  	-by-	Hock San Lee	[hockl]
 * Wrote it.
 **************************************************************************/

BOOL WINAPI DoSelectClipPath(PLOCALDC pLocalDC, INT iMode)
{
    // If there is no initial clip region and we are going to operate
    // on the initial clip region, we have to
    // create one.  Otherwise, GDI will create some random default
    // clipping region for us!

    if ((iMode == RGN_DIFF || iMode == RGN_XOR || iMode == RGN_OR)
     && bNoDCRgn(pLocalDC, DCRGN_CLIP))
    {
	BOOL   bRet;
	HRGN hrgnDefault;
	
	if (!(hrgnDefault = CreateRectRgn((int) (SHORT) MINSHORT,
					  (int) (SHORT) MINSHORT,
					  (int) (SHORT) MAXSHORT,
					  (int) (SHORT) MAXSHORT)))
	{
	    ASSERTGDI(FALSE, "MF3216: CreateRectRgn failed");
	    return(FALSE);
	}
	
	bRet = (ExtSelectClipRgn(pLocalDC->hdcHelper, hrgnDefault, RGN_COPY)
		!= ERROR);
	ASSERTGDI(bRet, "MF3216: ExtSelectClipRgn failed");
	
	if (!DeleteObject(hrgnDefault))
	    ASSERTGDI(FALSE, "MF3216: DeleteObject failed");
	
	if (!bRet)
	    return(FALSE);
    }

    // Do it to the helper DC.

    if (!SelectClipPath(pLocalDC->hdcHelper, iMode))
        return(FALSE);

    // Dump the clip region data.

    return(bDumpDCClipping(pLocalDC));
}


/***************************************************************************
 *  FlattenPath  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoFlattenPath
(
PLOCALDC pLocalDC
)
{
BOOL    b ;

        b = FlattenPath(pLocalDC->hdcHelper) ;

        ASSERTGDI((b == TRUE), "MF3216: DoFlattenPath, FlattenPath failed\n") ;

        return (b) ;
}

/***************************************************************************
 *  AbortPath  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoAbortPath
(
PLOCALDC pLocalDC
)
{
BOOL    b ;

        // Reset the global flag, turning off the path accumulation.

        pLocalDC->flags &= ~RECORDING_PATH ;

        b = AbortPath(pLocalDC->hdcHelper) ;

        ASSERTGDI((b == TRUE), "MF3216: DoAbortPath, AbortPath failed\n") ;

        return (b) ;
}

/***************************************************************************
 *  CloseFigure  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoCloseFigure
(
PLOCALDC pLocalDC
)
{
BOOL    b ;

        b = CloseFigure(pLocalDC->hdcHelper) ;

        ASSERTGDI((b == TRUE), "MF3216: DoCloseFigure, CloseFigure failed\n") ;

        return (b) ;
}

/***************************************************************************
 *  DoRenderPath  - Common code for StrokePath, FillPath and StrokeAndFillPath.
 **************************************************************************/

// Macro for copy a point in the path data.

#define MOVE_A_POINT(iDst, pjTypeDst, pptDst, iSrc, pjTypeSrc, pptSrc)	\
	{								\
	    pjTypeDst[iDst] = pjTypeSrc[iSrc];				\
	    pptDst[iDst]    = pptSrc[iSrc];				\
	}

BOOL WINAPI DoRenderPath(PLOCALDC pLocalDC, INT mrType)
{
    BOOL    b;
    PBYTE   pb    = (PBYTE) NULL;
    PBYTE   pbNew = (PBYTE) NULL;
    LPPOINT ppt, pptNew;
    LPBYTE  pjType, pjTypeNew;
    PDWORD  pPolyCount;
    INT     cpt, cptNew, cPolyCount;
    INT     i, j, jStart;
    LONG    lhpn32;

    b = FALSE;				// assume failure

// Flatten the path, to convert all the beziers into polylines.

    if (!FlattenPath(pLocalDC->hdcHelper))
    {
	RIP("MF3216: DoRendarPath, FlattenPath failed\n");
	goto exit_DoRenderPath;
    }

// Get the path data.

    // First get a count of the number of points.

    cpt = GetPath(pLocalDC->hdcHelper, (LPPOINT) NULL, (LPBYTE) NULL, 0);
    if (cpt == -1)
    {
	RIP("MF3216: DoRendarPath, GetPath failed\n");
	goto exit_DoRenderPath;
    }

    // Check for empty path.

    if (cpt == 0)
    {
	b = TRUE;
	goto exit_DoRenderPath;
    }

    // Allocate memory for the path data.
 
    if (!(pb = (PBYTE) LocalAlloc
		(
		    LMEM_FIXED,
		    cpt * (sizeof(POINT) + sizeof(BYTE))
		)
	 )
       )
    {
	RIP("MF3216: DoRendarPath, LocalAlloc failed\n");
	goto exit_DoRenderPath;
    }

    // Order of assignment is important for dword alignment.

    ppt    = (LPPOINT) pb;
    pjType = (LPBYTE) (ppt + cpt);

    // Finally, get the path data.

    if (GetPath(pLocalDC->hdcHelper, ppt, pjType, cpt) != cpt)
    {
	RIP("MF3216: DoRendarPath, GetPath failed\n");
	goto exit_DoRenderPath;
    }

// The path data is in record-time world coordinates.  They are the
// coordinates we will use in the PolyPoly rendering functions below.
//
// Since we have flattened the path, the path data should only contain
// the following types:
//
//   PT_MOVETO
//   PT_LINETO
//   (PT_LINETO | PT_CLOSEFIGURE)
//
// To simplify, we will close the figure explicitly by inserting points
// and removing the (PT_LINETO | PT_CLOSEFIGURE) type from the path data.
// At the same time, we will create the PolyPoly structure to prepare for
// the PolyPolygon or PolyPolyline call.
//
// Note that there cannot be more than one half (PT_LINETO | PT_CLOSEFIGURE)
// points since they are followed by the PT_MOVETO points (except for the
// last point).  In addition, the first point must be a PT_MOVETO.
//
// We will also remove the empty figure, i.e. consecutive PT_MOVETO, from
// the new path data in the process.

// First, allocate memory for the new path data.

    cptNew = cpt + cpt / 2;
    if (!(pbNew = (PBYTE) LocalAlloc
		    (
			LMEM_FIXED,
			cptNew * (sizeof(POINT) + sizeof(DWORD) + sizeof(BYTE))
		    )
	 )
       )
    {
	RIP("MF3216: DoRendarPath, LocalAlloc failed\n");
	goto exit_DoRenderPath;
    }

    // Order of assignment is important for dword alignment.

    pptNew     = (LPPOINT) pbNew;
    pPolyCount = (PDWORD) (pptNew + cptNew);
    pjTypeNew  = (LPBYTE) (pPolyCount + cptNew);

// Close the path explicitly.

    i = 0;
    j = 0;
    cPolyCount = 0;			// number of entries in PolyCount array
    while (i < cpt)
    {
	ASSERTGDI(pjType[i] == PT_MOVETO, "MF3216: DoRenderPath, bad pjType[]");

	// Copy everything upto the next closefigure or moveto.

	jStart = j;

	// copy the moveto
	MOVE_A_POINT(j, pjTypeNew, pptNew, i, pjType, ppt);
	i++; j++;

	if (i >= cpt)			// stop if the last point is a moveto
	{
	    j--;			// don't include the last moveto
	    break;
	}

	while (i < cpt)
	{
	    MOVE_A_POINT(j, pjTypeNew, pptNew, i, pjType, ppt);
	    i++; j++;

	    // look for closefigure and moveto
	    if (pjTypeNew[j - 1] != PT_LINETO)
		break;
	}

	if (pjTypeNew[j - 1] == PT_MOVETO)
	{
	    i--; j--;			// restart the next figure from moveto
	    if (j - jStart == 1)	// don't include consecutive moveto's
		j = jStart;		// ignore the first moveto
	    else
		pPolyCount[cPolyCount++] = j - jStart;	// add one poly
	}
	else if (pjTypeNew[j - 1] == PT_LINETO)
	{				// we have reached the end of path data
	    pPolyCount[cPolyCount++] = j - jStart;	// add one poly
	    break;
	}
	else if (pjTypeNew[j - 1] == (PT_LINETO | PT_CLOSEFIGURE))
	{
	    pjTypeNew[j - 1] = PT_LINETO;

	    // Insert a PT_LINETO to close the figure.

	    pjTypeNew[j] = PT_LINETO;
	    pptNew[j]    = pptNew[jStart];
	    j++;
	    pPolyCount[cPolyCount++] = j - jStart;	// add one poly
	}
	else
	{
	    ASSERTGDI(FALSE, "MF3216: DoRenderPath, unknown pjType[]");
	}
    } // while

    ASSERTGDI(j <= cptNew && cPolyCount <= cptNew,
	"MF3216: DoRenderPath, path data overrun");

    cptNew = j;

    // Check for empty path.

    if (cptNew == 0)
    {
	b = TRUE;
	goto exit_DoRenderPath;
    }

// Now we have a path data that consists of only PT_MOVETO and PT_LINETO.
// Furthermore, there is no "empty" figure, i.e. consecutive PT_MOVETO, in
// the path.  We can finally render the picture with PolyPolyline or
// PolyPolygon.

    if (mrType == EMR_STROKEPATH)
    {
// Do StrokePath.

	b = DoPolyPolyline(pLocalDC, (PPOINTL) pptNew, (PDWORD) pPolyCount,
		(DWORD) cPolyCount);
    }
    else
    {
// Do FillPath and StrokeAndFillPath.

	// If we are doing fill only, we need to select in a NULL pen.

	if (mrType == EMR_FILLPATH)
	{
	    lhpn32 = pLocalDC->lhpn32;	// remember the previous pen
	    if (!DoSelectObject(pLocalDC, ENHMETA_STOCK_OBJECT | NULL_PEN))
	    {
		ASSERTGDI(FALSE, "MF3216: DoRenderPath, DoSelectObject failed");
		goto exit_DoRenderPath;
	    }
	}

	// Do the PolyPolygon.

	b = DoPolyPolygon(pLocalDC, (PPOINTL) pptNew, (PDWORD) pPolyCount,
		(DWORD) cptNew, (DWORD) cPolyCount);

	// Restore the previous pen.

	if (mrType == EMR_FILLPATH)
	    if (!DoSelectObject(pLocalDC, lhpn32))
		ASSERTGDI(FALSE, "MF3216: DoRenderPath, DoSelectObject failed");
    }


exit_DoRenderPath:

// Since this call affects the path state and current position in the helper
// DC, we need to update the helper DC.

    switch(mrType)
    {
    case EMR_STROKEPATH:
	if (!StrokePath(pLocalDC->hdcHelper))
	    ASSERTGDI(FALSE, "MF3216: DoRenderPath, StrokePath failed");
	break;
    case EMR_FILLPATH:
	if (!FillPath(pLocalDC->hdcHelper))
	    ASSERTGDI(FALSE, "MF3216: DoRenderPath, FillPath failed");
	break;
    case EMR_STROKEANDFILLPATH:
	if (!StrokeAndFillPath(pLocalDC->hdcHelper))
	    ASSERTGDI(FALSE, "MF3216: DoRenderPath, StrokeAndFillPath failed");
	break;
    default:
	ASSERTGDI(FALSE, "MF3216: DoRenderPath, unknown mrType");
	break;
    }

    if (pbNew)
	if (LocalFree((HANDLE) pbNew))
	    RIP("MF3216: DoRendarPath, LocalFree failed\n");
    if (pb)
	if (LocalFree((HANDLE) pb))
	    RIP("MF3216: DoRendarPath, LocalFree failed\n");

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\mf3216\parser.c ===
/*****************************************************************************
 *
 * parser.cxx - Parser for the Win32 to Win16 metafile converter.
 *
 * Date: 8/13/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/


#include "precomp.h"
#pragma hdrstop

#define EMR_LAST_MF3216_SUPPORTED 97

BOOL bGetNextRecord(PLOCALDC pLocalDC, PENHMETARECORD *pemr) ;

// Call table for the translation entry points.

PDOFN pdofnDrawingOrders[] = {
        (PDOFN) NULL,
        bHandleHeader,                  // EMR_HEADER                       1
        bHandlePolyBezier,              // EMR_POLYBEZIER                   2
        bHandlePolygon,                 // EMR_POLYGON                      3
        bHandlePolyline,                // EMR_POLYLINE                     4
        bHandlePolyBezierTo,            // EMR_POLYBEZIERTO                 5
        bHandlePolylineTo,              // EMR_POLYLINETO                   6
        bHandlePolyPolyline,            // EMR_POLYPOLYLINE                 7
        bHandlePolyPolygon,             // EMR_POLYPOLYGON                  8
        bHandleSetWindowExt,            // EMR_SETWINDOWEXTEX               9
        bHandleSetWindowOrg,            // EMR_SETWINDOWORGEX               10
        bHandleSetViewportExt,          // EMR_SETVIEWPORTEXTEX             11
        bHandleSetViewportOrg,          // EMR_SETVIEWPORTORGEX             12
        bHandleNotImplemented,          // EMR_SETBRUSHORGEX                13
        bHandleEOF,                     // EMR_EOF                          14
        bHandleSetPixel,                // EMR_SETPIXELV                    15
        bHandleSetMapperFlags,          // EMR_SETMAPPERFLAGS               16
        bHandleSetMapMode,              // EMR_SETMAPMODE                   17
        bHandleSetBkMode,               // EMR_SETBKMODE                    18
        bHandleSetPolyFillMode,         // EMR_SETPOLYFILLMODE              19
        bHandleSetRop2,                 // EMR_SETROP2                      20
        bHandleSetStretchBltMode,       // EMR_SETSTRETCHBLTMODE            21
        bHandleSetTextAlign,            // EMR_SETTEXTALIGN                 22
        bHandleNotImplemented,          // EMR_SETCOLORADJUSTMENT           23
        bHandleSetTextColor,            // EMR_SETTEXTCOLOR                 24
        bHandleSetBkColor,              // EMR_SETBKCOLOR                   25
        bHandleOffsetClipRgn,           // EMR_OFFSETCLIPRGN                26
        bHandleMoveTo,                  // EMR_MOVETOEX                     27
        bHandleSetMetaRgn,              // EMR_SETMETARGN                   28
        bHandleExcludeClipRect,         // EMR_EXCLUDECLIPRECT              29
        bHandleIntersectClipRect,       // EMR_INTERSECTCLIPRECT            30
        bHandleScaleViewportExt,        // EMR_SCALEVIEWPORTEXTEX           31
        bHandleScaleWindowExt,          // EMR_SCALEWINDOWEXTEX             32
        bHandleSaveDC,                  // EMR_SAVEDC                       33
        bHandleRestoreDC,               // EMR_RESTOREDC                    34
        bHandleSetWorldTransform,       // EMR_SETWORLDTRANSFORM            35
        bHandleModifyWorldTransform,    // EMR_MODIFYWORLDTRANSFORM         36
        bHandleSelectObject,            // EMR_SELECTOBJECT                 37
        bHandleCreatePen,               // EMR_CREATEPEN                    38
        bHandleCreateBrushIndirect,     // EMR_CREATEBRUSHINDIRECT          39
        bHandleDeleteObject,            // EMR_DELETEOBJECT                 40
        bHandleAngleArc,                // EMR_ANGLEARC                     41
        bHandleEllipse,                 // EMR_ELLIPSE                      42
        bHandleRectangle,               // EMR_RECTANGLE                    43
        bHandleRoundRect,               // EMR_ROUNDRECT                    44
        bHandleArc,                     // EMR_ARC                          45
        bHandleChord,                   // EMR_CHORD                        46
        bHandlePie,                     // EMR_PIE                          47
        bHandleSelectPalette,           // EMR_SELECTPALETTE                48
        bHandleCreatePalette,           // EMR_CREATEPALETTE                49
        bHandleSetPaletteEntries,       // EMR_SETPALETTEENTRIES            50
        bHandleResizePalette,           // EMR_RESIZEPALETTE                51
        bHandleRealizePalette,          // EMR_REALIZEPALETTE               52
        bHandleExtFloodFill,            // EMR_EXTFLOODFILL                 53
        bHandleLineTo,                  // EMR_LINETO                       54
        bHandleArcTo,                   // EMR_ARCTO                        55
        bHandlePolyDraw,                // EMR_POLYDRAW                     56
        bHandleSetArcDirection,         // EMR_SETARCDIRECTION              57
        bHandleNotImplemented,          // EMR_SETMITERLIMIT                58
        bHandleBeginPath,               // EMR_BEGINPATH                    59
        bHandleEndPath,                 // EMR_ENDPATH                      60
        bHandleCloseFigure,             // EMR_CLOSEFIGURE                  61
        bHandleFillPath,                // EMR_FILLPATH                     62
        bHandleStrokeAndFillPath,       // EMR_STROKEANDFILLPATH            63
        bHandleStrokePath,              // EMR_STROKEPATH                   64
        bHandleFlattenPath,             // EMR_FLATTENPATH                  65
        bHandleWidenPath,               // EMR_WIDENPATH                    66
        bHandleSelectClipPath,          // EMR_SELECTCLIPPATH               67
        bHandleAbortPath,               // EMR_ABORTPATH                    68
        bHandleNotImplemented,          //                                  69
        bHandleGdiComment,              // EMR_GDICOMMENT                   70
        bHandleFillRgn,                 // EMR_FILLRGN                      71
        bHandleFrameRgn,                // EMR_FRAMERGN                     72
        bHandleInvertRgn,               // EMR_INVERTRGN                    73
        bHandlePaintRgn,                // EMR_PAINTRGN                     74
        bHandleExtSelectClipRgn,        // EMR_EXTSELECTCLIPRGN             75
        bHandleBitBlt,                  // EMR_BITBLT                       76
        bHandleStretchBlt,              // EMR_STRETCHBLT                   77
        bHandleMaskBlt,                 // EMR_MASKBLT                      78
        bHandlePlgBlt,                  // EMR_PLGBLT                       79
        bHandleSetDIBitsToDevice,       // EMR_SETDIBITSTODEVICE            80
        bHandleStretchDIBits,           // EMR_STRETCHDIBITS                81
        bHandleExtCreateFont,           // EMR_EXTCREATEFONTINDIRECTW       82
        bHandleExtTextOut,              // EMR_EXTTEXTOUTA                  83
        bHandleExtTextOut,              // EMR_EXTTEXTOUTW                  84
        bHandlePoly16,                  // EMR_POLYBEZIER16                 85
        bHandlePoly16,                  // EMR_POLYGON16                    86
        bHandlePoly16,                  // EMR_POLYLINE16                   87
        bHandlePoly16,                  // EMR_POLYBEZIERTO16               88
        bHandlePoly16,                  // EMR_POLYLINETO16                 89
        bHandlePolyPoly16,              // EMR_POLYPOLYLINE16               90
        bHandlePolyPoly16,              // EMR_POLYPOLYGON16                91
        bHandlePoly16,                  // EMR_POLYDRAW16                   92
        bHandleCreateMonoBrush,         // EMR_CREATEMONOBRUSH              93
        bHandleCreateDIBPatternBrush,   // EMR_CREATEDIBPATTERNBRUSHPT      94
        bHandleExtCreatePen,            // EMR_EXTCREATEPEN                 95
        bHandlePolyTextOut,             // EMR_POLYTEXTOUTA                 96
        bHandlePolyTextOut,             // EMR_POLYTEXTOUTW                 97
        bHandleNotImplemented,          // EMR_SETICMMODE                   98
        bHandleNotImplemented,          // EMR_CREATECOLORSPACE             99
        bHandleNotImplemented,          // EMR_SETCOLORSPACE               100
        bHandleNotImplemented,          // EMR_DELETECOLORSPACE            101
        bHandleNotImplemented,          // EMR_GLSRECORD                   102
        bHandleNotImplemented,          // EMR_GLSBOUNDEDRECORD            103
        bHandleNotImplemented,          // EMR_PIXELFORMAT                 104
        bHandleNotImplemented,          //                                 105
        bHandleNotImplemented,          //                                 106
        bHandleNotImplemented,          //                                 107
        bHandleNotImplemented,          //                                 108
        bHandleNotImplemented,          //                                 109
        bHandleNotImplemented,          //                                 110
        bHandleNotImplemented,          // EMR_COLORCORRECTPALETTE         111
        bHandleNotImplemented,          // EMR_ALPHABLEND                  112
        bHandleNotImplemented,          // EMR_ALPHADIBBLEND               113
        bHandleNotImplemented,          // EMR_TRANSPARENTIMAGE            114
        bHandleNotImplemented,          // EMR_TRANSPARENTDIBIMAGE         115
        bHandleNotImplemented           // EMR_GRADIENTFILL                116

} ;

#if DBG

PSZ         pszMfRecords[] = {
                        "NULL RECORD               ",
                        "EMR_HEADER                ",
                        "EMR_POLYBEZIER            ",
                        "EMR_POLYGON               ",
                        "EMR_POLYLINE              ",
                        "EMR_POLYBEZIERTO          ",
                        "EMR_POLYLINETO            ",
                        "EMR_POLYPOLYLINE          ",
                        "EMR_POLYPOLYGON           ",
                        "EMR_SETWINDOWEXTEX        ",
                        "EMR_SETWINDOWORGEX        ",
                        "EMR_SETVIEWPORTEXTEX      ",
                        "EMR_SETVIEWPORTORGEX      ",
                        "EMR_SETBRUSHORGEX         ",
                        "EMR_EOF                   ",
                        "EMR_SETPIXELV             ",
                        "EMR_SETMAPPERFLAGS        ",
                        "EMR_SETMAPMODE            ",
                        "EMR_SETBKMODE             ",
                        "EMR_SETPOLYFILLMODE       ",
                        "EMR_SETROP2               ",
                        "EMR_SETSTRETCHBLTMODE     ",
                        "EMR_SETTEXTALIGN          ",
                        "EMR_SETCOLORADJUSTMENT    ",
                        "EMR_SETTEXTCOLOR          ",
                        "EMR_SETBKCOLOR            ",
                        "EMR_OFFSETCLIPRGN         ",
                        "EMR_MOVETOEX              ",
                        "EMR_SETMETARGN            ",
                        "EMR_EXCLUDECLIPRECT       ",
                        "EMR_INTERSECTCLIPRECT     ",
                        "EMR_SCALEVIEWPORTEXTEX    ",
                        "EMR_SCALEWINDOWEXTEX      ",
                        "EMR_SAVEDC                ",
                        "EMR_RESTOREDC             ",
                        "EMR_SETWORLDTRANSFORM     ",
                        "EMR_MODIFYWORLDTRANSFORM  ",
                        "EMR_SELECTOBJECT          ",
                        "EMR_CREATEPEN             ",
                        "EMR_CREATEBRUSHINDIRECT   ",
                        "EMR_DELETEOBJECT          ",
                        "EMR_ANGLEARC              ",
                        "EMR_ELLIPSE               ",
                        "EMR_RECTANGLE             ",
                        "EMR_ROUNDRECT             ",
                        "EMR_ARC                   ",
                        "EMR_CHORD                 ",
                        "EMR_PIE                   ",
                        "EMR_SELECTPALETTE         ",
                        "EMR_CREATEPALETTE         ",
                        "EMR_SETPALETTEENTRIES     ",
                        "EMR_RESIZEPALETTE         ",
                        "EMR_REALIZEPALETTE        ",
                        "EMR_EXTFLOODFILL          ",
                        "EMR_LINETO                ",
                        "EMR_ARCTO                 ",
                        "EMR_POLYDRAW              ",
                        "EMR_SETARCDIRECTION       ",
                        "EMR_SETMITERLIMIT         ",
                        "EMR_BEGINPATH             ",
                        "EMR_ENDPATH               ",
                        "EMR_CLOSEFIGURE           ",
                        "EMR_FILLPATH              ",
                        "EMR_STROKEANDFILLPATH     ",
                        "EMR_STROKEPATH            ",
                        "EMR_FLATTENPATH           ",
                        "EMR_WIDENPATH             ",
                        "EMR_SELECTCLIPPATH        ",
                        "EMR_ABORTPATH             ",
                        "unknown record            ",
                        "EMR_GDICOMMENT            ",
                        "EMR_FILLRGN               ",
                        "EMR_FRAMERGN              ",
                        "EMR_INVERTRGN             ",
                        "EMR_PAINTRGN              ",
                        "EMR_EXTSELECTCLIPRGN      ",
                        "EMR_BITBLT                ",
                        "EMR_STRETCHBLT            ",
                        "EMR_MASKBLT               ",
                        "EMR_PLGBLT                ",
                        "EMR_SETDIBITSTODEVICE     ",
                        "EMR_STRETCHDIBITS         ",
                        "EMR_EXTCREATEFONTINDIRECTW",
                        "EMR_EXTTEXTOUTA           ",
                        "EMR_EXTTEXTOUTW           ",
                        "EMR_POLYBEZIER16          ",
                        "EMR_POLYGON16             ",
                        "EMR_POLYLINE16            ",
                        "EMR_POLYBEZIERTO16        ",
                        "EMR_POLYLINETO16          ",
                        "EMR_POLYPOLYLINE16        ",
                        "EMR_POLYPOLYGON16         ",
                        "EMR_POLYDRAW16            ",
                        "EMR_CREATEMONOBRUSH       ",
                        "EMR_CREATEDIBPATTERNBRUSHP",
                        "EMR_EXTCREATEPEN          ",
                        "EMR_POLYTEXTOUTA          ",
                        "EMR_POLYTEXTOUTW          ",
                        "EMR_SETICMMODE            ",
                        "EMR_CREATECOLORSPACE      ",
                        "EMR_SETCOLORSPACE         ",
                        "EMR_DELETECOLORSPACE      ",
                        "EMR_GLSRECORD             ",
                        "EMR_GLSBOUNDEDRECORD      ",
                        "EMR_PIXELFORMAT           ",
                        "105                       ",
                        "106                       ",
                        "107                       ",
                        "108                       ",
                        "109                       ",
                        "110                       ",
                        "EMR_COLORCORRECTPALETTE   ",
                        "EMR_ALPHABLEND            ",
                        "EMR_ALPHADIBBLEND         ",
                        "EMR_TRANSPARENTIMAGE      ",
                        "EMR_TRANSPARENTDIBIMAGE   ",
                        "EMR_GRADIENTFILL          "
};

#endif

/*****************************************************************************
 *  Parse the Win32 metafile.
 *
 *  The Win32 metafile is represented by the metafile bits pointed to
 *  by pMetafileBits.  The metafile bits may be obtained from a memory mapped
 *  file, or from some shared memory (from the clipboard).
 *****************************************************************************/
BOOL bParseWin32Metafile(PBYTE pMetafileBits, PLOCALDC pLocalDC)
{
INT         iType ;
PVOID       pVoid ;
PENHMETARECORD pemr ;
PENHMETAHEADER pMf32Header ;
DWORD       nFileSize ;
BOOL        bRet ;
INT         iRecordCount,
            iLastError ;

        bRet = TRUE ;

        // Get the file length from the header.
        // Test to make sure the first record is a Win32 Metafile header.

        pMf32Header = (PENHMETAHEADER) pMetafileBits ;
        if (   (pMf32Header->iType      != EMR_HEADER)
            || (pMf32Header->dSignature != ENHMETA_SIGNATURE)
           )
        {
            RIP("MF3216: bParseWin32Metafile, First Record not a Win32 Metafile Header\n") ;
            return(FALSE) ;
        }

        // Record a pointer to the beginning of the Win32 metafile and
        // it's length incase we need to emit the Win32 metafile  as  a comment
        // record(s).

        pLocalDC->pMf32Bits = (PBYTE) pMf32Header ;
        pLocalDC->cMf32Bits = pMf32Header->nBytes ;

        // Get the file size for the parser.

        nFileSize = pMf32Header->nBytes ;

        // Initialize pbCurrent, & pbEnd pointers into the
        // metafile bits.

        pLocalDC->pbCurrent = pMetafileBits ;
        pLocalDC->pbEnd   = pLocalDC->pbCurrent + nFileSize ;

        // Init the record count.

        iRecordCount = 0 ;

        // Go through the metafile bits.  Handle each record based on
        // it's type.  bGetNextRecord returns TRUE if pemr contains
        // a pointer to a record.

        while (bGetNextRecord(pLocalDC, &pemr))
        {

            iRecordCount++ ;

            // Set up a convienent point to the record.

            pVoid = (PVOID) pemr ;

            // Handle the record based on it's type.

            iType = (INT) pemr->iType ;

            // Check if the record type falls within the range of the
            // call table.  Eventually, all the record handlers  should
            // be in the call table.

            if (iType <= EMR_LAST_MF3216_SUPPORTED)
            {
                bRet = pdofnDrawingOrders[iType](pVoid, pLocalDC) ;
#if DBG
                if (bRet == FALSE)
                {
                    iLastError = GetLastError() ;
                    PUTS1("MF3216: Error on Win32 Metafile record #: %d\n", iRecordCount) ;
                    PUTS1("\tRecord type: %s\n", pszMfRecords[iType]) ;
                    PUTS1("\tLast Error Code: %08.8X\n", iLastError) ;
                }
#endif
#if 0
                if (bRet == FALSE)
                    break ;
#else
                // In ancient times (i.e., before NT4.0), someone explicitly
                // removed the code above which exits the loop if the handler
                // fails.  Possibly this was a compatibility fix in which
                // the app depended on the metafile conversion to continue
                // even in the event of a failure.
                //
                // Unfortunately, this fix also allows the parser to continue
                // even if the output buffer has run out of space.  To
                // minimize the change, we will explicitly look for this case
                // and break out of the loop if it happens.  (Refer to bEmit()
                // in emit.c to see where ERROR_BUFFER_OVERFLOW is set).

                if (pLocalDC->flags & ERR_BUFFER_OVERFLOW)
                    break ;
#endif
            }
            else
            {
                PUTS1("MF3216: bParseWin32Metafile - record not supported: %d\n", iType) ;
            }
        }
#if 0
        // Display some statictics

        if (bRet == TRUE)
        {
            PUTS1("MF3216: %d Win32 Metafile records processed\n",
                   iRecordCount) ;
        }
#endif
        return(bRet) ;
}

/*****************************************************************************
 * Get next record
 *
 *  This is a support routine for bParseWin32Metafile.
 *  It is assumed that pbCurrent, & pbEnd are initialized
 *  the first time this routine is called.
 *
 *  It returns TRUE if a valid pointer to record is returned in
 *  pemr.  If there are not more records FALSE is returned.
 *****************************************************************************/
BOOL bGetNextRecord(PLOCALDC pLocalDC, PENHMETARECORD *ppemr)
{
DWORD   nSize ;

        // Check for the end of buffer.
        // If this is the end return FALSE and set *ppemr to 0.

        if (pLocalDC->pbCurrent == pLocalDC->pbEnd)
        {
            *ppemr = (PENHMETARECORD) NULL ;
            return (FALSE) ;
        }

        // Well it's not the end of the buffer.
        // So, return a pointer to this record, update pbCurrent, and
        // return TRUE ;

        *ppemr = (PENHMETARECORD) pLocalDC->pbCurrent ;

        nSize = ((PENHMETARECORD) pLocalDC->pbCurrent)->nSize ;
        pLocalDC->pbCurrent += nSize ;

        return(TRUE) ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\mf3216\mf3216.h ===
/*****************************************************************************
 *
 *  MF3216.h - The include file for MF3216.  This will contain all
 *             the miscellaneous includes.
 *
 *  Author: Jeffrey Newman (c-jeffn)
 *
 *  Creation Date: 31-Jan-1992
 *
 ****************************************************************************/


#ifndef _MF3216_
#define _MF3216_

#include    <windows.h>

typedef struct _w16objhndlslotstatus {
    INT     use ;
    HANDLE  w32Handle ;
} W16OBJHNDLSLOTSTATUS ;

typedef W16OBJHNDLSLOTSTATUS *PW16OBJHNDLSLOTSTATUS ;


typedef struct _localDC {
    UINT    nSize ;                     // Size of this Local DC structure.
    DWORD   flags ;                     // Boolean controls.
    PBYTE   pMf32Bits ;                 // ptr to W32 metafile bits.
    UINT    cMf32Bits ;                 // count of W32 metafile size.
    PBYTE   pMf16Bits ;                 // ptr to user supplied out buffer
    UINT    cMf16Dest ;                 // length of user supplied buffer
    HDC     hdcHelper ;                 // Our helper DC.
    HDC     hdcRef ;                    // Reference DC.
    INT     iMapMode ;                  // User requested map mode.
    INT     cxPlayDevMM,
            cyPlayDevMM,
            cxPlayDevPels,
            cyPlayDevPels ;
    XFORM   xformRWorldToRDev,          // aka Metafile-World to Metafile-Device
            xformRDevToRWorld,          // aka Metafile-Device to Metafile-World
            xformRDevToPDev,            // aka Metafile-Device to Reference-Device
            xformPDevToPPage,           // aka Reference-Device to Reference-Logical
            xformPPageToPDev,           // aka Reference-Logical to Reference-Device
            xformRDevToPPage,           // aka Metafile-Device to Reference-Logical
            xformRWorldToPPage ;
    POINT   ptCP ;                      // Current position
    PBYTE   pbEnd ;                     // End of W32 metafile bits.
    METAHEADER  mf16Header ;            // The W16 metafile header.
    PINT    piW32ToW16ObjectMap ;
    UINT    cW16ObjHndlSlotStatus ;     // used in slot search
    UINT    cW32ToW16ObjectMap ;        // used in Normalize handle.
    PW16OBJHNDLSLOTSTATUS   pW16ObjHndlSlotStatus ;
    COLORREF crTextColor ;              // current text color - used by
                                        // ExtCreatePen.
    COLORREF crBkColor ;                // Current background color
    INT     iArcDirection ;             // Current arc direction in W32 metafile
    LONG    lhpn32;			// Currently selected pen.  Used in path and text
    LONG    lhbr32;			// Currently selected brush.  Used in text
    DWORD   ihpal32;			// Currently selected (i32) palette.
    DWORD   ihpal16;			// Currently selected (i16) palette.
    UINT    iLevel;			// Current DC save level.
    struct _localDC *pLocalDCSaved;     // Point to the saved DCs

// The following fields are not restored by RestoreDC!

    UINT    ulBytesEmitted ;            // Total bytes emitted so far.
    UINT    ulMaxRecord ;               // Max W16 record size.
    INT     nObjectHighWaterMark;       // Max slot index used so far.
    PBYTE   pbCurrent;                  // Current record in W32 metafile bits.
    DWORD   cW32hPal;			// Size of private W32 palette table.
    HPALETTE *pW32hPal;			// Private W32 palette table.

} LOCALDC ;

typedef LOCALDC *PLOCALDC ;

// Routines in apientry.c

BOOL bHandleWin32Comment(PLOCALDC pLocalDC);

// Routines in misc.c

BOOL bValidateMetaFileCP(PLOCALDC pLocalDC, LONG x, LONG y);

// Following are the bit definitions for the flags.

#define SIZE_ONLY               0x00000001
#define INCLUDE_W32MF_COMMENT   0x00000002
#define STRANGE_XFORM           0x00000004
#define RECORDING_PATH          0x00000008
#define ERR_BUFFER_OVERFLOW   0x80000000


// This define sets the size of each Win32 metafile comment record.
// The reason we do not just use a 64K record is due to a caution given
// to use about large escape records in Win3.0 by the GBU (MS Palo Alto).

#define MAX_WIN32_COMMENT_REC_SIZE  0x2000


// Function(s) used in parser.c

extern BOOL  bParseWin32Metafile(PBYTE pMetafileBits, PLOCALDC pLocalDC) ;

// Function definitions for preamble.

extern BOOL bUpdateMf16Header(PLOCALDC pLocalDC) ;

// Function definitions for the emitter.

extern BOOL bEmit(PLOCALDC pLocalDC, PVOID pBuffer, DWORD nCount) ;
extern VOID vUpdateMaxRecord(PLOCALDC pLocalDC, PMETARECORD pmr);

// Defines used in objects.c

#define OPEN_AVAILABLE_SLOT         1
#define REALIZED_BRUSH              2
#define REALIZED_PEN                3
#define REALIZED_BITMAP             4
#define REALIZED_PALETTE            5
#define REALIZED_REGION             6
#define REALIZED_FONT               7
#define REALIZED_OBJECT             8  // used by multiformats record
#define REALIZED_DUMMY              9  // used by multiformats record

#define UNMAPPED                    -1

// Routines in objects.c

extern BOOL bInitHandleTableManager(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header) ;
extern INT  iGetW16ObjectHandleSlot(PLOCALDC pLocalDC, INT iIntendedUse) ;
extern INT  iValidateHandle(PLOCALDC pLocalDC, INT ihW32) ;
extern INT  iAllocateW16Handle(PLOCALDC pLocalDC, INT ihW32, INT iIntendedUse) ;
extern BOOL bDeleteW16Object(PLOCALDC pLocalDC, INT ihW16) ;
extern INT  iNormalizeHandle(PLOCALDC pLocalDC, INT ihW32) ;

// Routines in text.c

VOID vUnicodeToAnsi(PCHAR pAnsi, PWCH pUnicode, DWORD cch) ;

// Routines in regions.c

BOOL bNoDCRgn(PLOCALDC pLocalDC, INT iType);
BOOL bDumpDCClipping(PLOCALDC pLocalDC);

// Defines used in bNoDCRgn().

#define DCRGN_CLIP     1
#define DCRGN_META     2

// Defines used in xforms.c

#define     CX_MAG  1
#define     CY_MAG  2

typedef struct
{
    FLOAT x;
    FLOAT y;
} POINTFL;
typedef POINTFL *PPOINTFL;

// Function definitions from xform

extern BOOL bInitXformMatrices(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header) ;

extern BOOL bXformRWorldToPPage(PLOCALDC pLocalDC, PPOINTL aptl, DWORD nCount) ;
extern BOOL bXformRWorldToRDev(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount) ;
extern BOOL bXformPDevToPPage(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount) ;
extern BOOL bXformPPageToPDev(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount) ;
extern BOOL bXformRDevToRWorld(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount) ;

extern INT  iMagnitudeXform (PLOCALDC pLocalDC, INT value, INT iType) ;

extern XFORM xformIdentity ;
extern BOOL  bRotationTest(PXFORM pxform) ;
extern INT   iMagXformWorkhorse (INT value, PXFORM pxform, INT iType) ;
extern BOOL  bXformWorkhorse(PPOINTL aptl, DWORD nCount, PXFORM pXform) ;
extern VOID  vXformWorkhorseFloat(PPOINTFL aptfl, UINT nCount, PXFORM pXform);
extern BOOL  bCoordinateOverflowTest(PLONG pCoordinates, INT nCount) ;


// Defines used in Conics

#define SWAP(x,y,t)        {t = x; x = y; y = t;}

#define ePI ((FLOAT)(((FLOAT) 22.0 / (FLOAT) 7.0 )))

// Exported support functions and defines for Conics & rectangles.

extern BOOL bConicCommon (PLOCALDC pLocalDC, INT x1, INT y1, INT x2, INT y2,
                                             INT x3, INT y3, INT x4, INT y4,
                                             DWORD mrType) ;

extern BOOL bRenderCurveWithPath
(
    PLOCALDC pLocalDC,
    LPPOINT  pptl,
    PBYTE    pb,
    DWORD    cptl,
    INT      x1,
    INT      y1,
    INT      x2,
    INT      y2,
    INT      x3,
    INT      y3,
    INT      x4,
    INT      y4,
    DWORD    nRadius,
    FLOAT    eStartAngle,
    FLOAT    eSweepAngle,
    DWORD    mrType
);

// Exported functions from lines.c

extern VOID vCompressPoints(PVOID pBuff, LONG nCount) ;


// Defines (macros) used in bitmaps.

// Check if a source is needed in a 3-way bitblt operation.
// This works on both rop and rop3.  We assume that a rop contains zero
// in the high byte.
//
// This is tested by comparing the rop result bits with source (column A
// below) vs. those without source (column B).  If the two cases are
// identical, then the effect of the rop does not depend on the source
// and we don't need a source device.  Recall the rop construction from
// input (pattern, source, target --> result):
//
//	P S T | R   A B 	mask for A = 0CCh
//	------+-------- 	mask for B =  33h
//	0 0 0 | x   0 x
//	0 0 1 | x   0 x
//	0 1 0 | x   x 0
//	0 1 1 | x   x 0
//	1 0 0 | x   0 x
//	1 0 1 | x   0 x
//	1 1 0 | x   x 0
//	1 1 1 | x   x 0

#define ISSOURCEINROP3(rop3)	\
	(((rop3) & 0xCCCC0000) != (((rop3) << 2) & 0xCCCC0000))


#define CJSCAN(width,planes,bits) ((((width)*(planes)*(bits)+31) & ~31) / 8)

#define MAX4(a, b, c, d)    max(max(max(a,b),c),d)
#define MIN4(a, b, c, d)    min(min(min(a,b),c),d)

#include "debug.h"

#endif  //_MF3216_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\mf3216\misc.c ===
/*****************************************************************************
 *
 * misc - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


BOOL WINAPI GetTransform(HDC hdc,DWORD iXform,LPXFORM pxform);

BOOL WINAPI DoGdiCommentMultiFormats
(
 PLOCALDC pLocalDC,
 PEMRGDICOMMENT_MULTIFORMATS pemr
);

/***************************************************************************
 *  ExtFloodFill  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoExtFloodFill
(
 PLOCALDC    pLocalDC,
 int         x,
 int         y,
 COLORREF    crColor,
 DWORD       iMode
)
{
POINTL	ptl ;
BOOL	b ;

	ptl.x = (LONG) x ;
	ptl.y = (LONG) y ;

	b = bXformRWorldToPPage(pLocalDC, &ptl, 1) ;
        if (b == FALSE)
            goto exit1 ;

	b = bEmitWin16ExtFloodFill(pLocalDC, LOWORD(ptl.x), LOWORD(ptl.y), crColor, LOWORD(iMode)) ;
exit1:
	return(b) ;

}

/***************************************************************************
 *  MoveToEx  - Win32 to Win16 Metafile Converter Entry Point
 *
 *  NOTE ON CURRENT POSITION
 *  ------------------------
 *  There are only three Win16 functions that use and update the
 *  current position (CP).  They are:
 *
 *      MoveTo
 *      LineTo
 *      (Ext)TextOut with TA_UPDATECP text alignment option
 *
 *  In Win32, CP is used in many more functions and has two
 *  interpretations based on the state of the current path.
 *  As a result, it is easier and more robust to rely on the
 *  helper DC to keep track of the CP than doing it in the
 *  converter.  To do this, we need to do the following:
 *
 *  1. The converter will update the CP in the helper DC in all
 *     records that modify the CP.
 *
 *  2. The converter will keep track of the CP in the converted
 *     metafile at all time.
 *
 *  3. In LineTo and (Ext)TextOut, the metafile CP is compared to
 *     that of the helper DC.  If they are different, a MoveTo record
 *     is emitted.  This is done in bValidateMetaFileCP().
 *
 *  4. The converter should emit a MoveTo record the first time the
 *     CP is used in the converted metafile.
 *
 *  - HockL  July 2, 1992
 **************************************************************************/
BOOL WINAPI DoMoveTo
(
PLOCALDC  pLocalDC,
LONG    x,
LONG    y
)
{
BOOL    b ;
POINTL  ptl ;

        // Whether we are recording for a path or acutally emitting
        // a drawing order we must pass the drawing order to the helper DC
        // so the helper can maintain the current positon.
        // If we're recording the drawing orders for a path
        // then just pass the drawing order to the helper DC.
        // Do not emit any Win16 drawing orders.

        b = MoveToEx(pLocalDC->hdcHelper, (INT) x, (INT) y, (LPPOINT) &ptl) ;
        if (pLocalDC->flags & RECORDING_PATH)
            return(b) ;

	// Update the CP in the converted metafile.

        b = bValidateMetaFileCP(pLocalDC, x, y) ;
        return(b) ;
}


/***************************************************************************
 *  bValidateMetaFiloeCP  - Update the current position in the converted
 *                          metafile.
 *
 *  x and y are assumed to be in the record time world coordinates.
 *
 **************************************************************************/
BOOL bValidateMetaFileCP(PLOCALDC pLocalDC, LONG x, LONG y)
{
BOOL    b ;
POINT   pt ;

        // Compute the new current position in the play time page coord.

        pt.x = x ;
        pt.y = y ;
	if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) &pt, 1L))
	    return(FALSE);

	// No need to emit the record if the converted metafile has
	// the same CP.

        if (pLocalDC->ptCP.x == pt.x && pLocalDC->ptCP.y == pt.y)
	    return(TRUE);

        // Call the Win16 routine to emit the move to the metafile.

        b = bEmitWin16MoveTo(pLocalDC, LOWORD(pt.x), LOWORD(pt.y)) ;

        // Update the mf16 current position.

        pLocalDC->ptCP = pt ;

        return(b) ;
}

/***************************************************************************
 *  SaveDC  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSaveDC
(
PLOCALDC pLocalDC
)
{
BOOL    b;
PLOCALDC pLocalDCNew;

    b = FALSE;

// Save the helper DC's state first

    if (!SaveDC(pLocalDC->hdcHelper))
    {
        RIP("MF3216: DoSaveDC, SaveDC failed\n");
        return(b);
    }

// Allocate some memory for the LocalDC.

    pLocalDCNew = (PLOCALDC) LocalAlloc(LMEM_FIXED, sizeof(LOCALDC));
    if (pLocalDCNew == (PLOCALDC) NULL)
    {
        RIP("MF3216: DoSaveDC, LocalAlloc failed\n");
        return(b);
    }

// Copy the data from the current LocalDC to the new one just allocated.

    *pLocalDCNew = *pLocalDC;

// Link in the new level.

    pLocalDC->pLocalDCSaved = pLocalDCNew;
    pLocalDC->iLevel++;

// Emit Win16 drawing order.

    b = bEmitWin16SaveDC(pLocalDC);

    return(b);
}

/***************************************************************************
 *  RestoreDC  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoRestoreDC
(
PLOCALDC pLocalDC,
int nSavedDC
)
{
BOOL     b;
INT      iLevel;
PLOCALDC pLocalDCNext;
PLOCALDC pLocalDCTmp;

    b = FALSE;

// First check to make sure this is a relative save level.

    if (nSavedDC > 0)
        return(b);

// Restore the helper DC's state first
// If we can restore the helper DC, we know that it is a balanced restore.
// Otherwise, we return an error.

    if (!RestoreDC(pLocalDC->hdcHelper, nSavedDC))
        return(b);

// Compute an absolute level.

    iLevel = pLocalDC->iLevel + nSavedDC;

// The helper DC should have caught bogus levels.

    ASSERTGDI((iLevel >= 0) && ((UINT) iLevel < pLocalDC->iLevel),
	"MF3216: DoRestoreDC, Bogus RestoreDC");

// Restore down to the level we want.

    pLocalDCNext = pLocalDC->pLocalDCSaved;
    while ((UINT) iLevel < pLocalDCNext->iLevel)
    {
	pLocalDCTmp = pLocalDCNext;
	pLocalDCNext = pLocalDCNext->pLocalDCSaved;
        if (LocalFree(pLocalDCTmp))
	    ASSERTGDI(FALSE, "MF3216: DoRestoreDC, LocalFree failed");
    }

// Restore the state of our local DC to that level.

    // keep some of the attributes in the current DC

    pLocalDCNext->ulBytesEmitted        = pLocalDC->ulBytesEmitted;
    pLocalDCNext->ulMaxRecord           = pLocalDC->ulMaxRecord;
    pLocalDCNext->nObjectHighWaterMark  = pLocalDC->nObjectHighWaterMark;
    pLocalDCNext->pbCurrent             = pLocalDC->pbCurrent;
    pLocalDCNext->cW16ObjHndlSlotStatus = pLocalDC->cW16ObjHndlSlotStatus;
    pLocalDCNext->pW16ObjHndlSlotStatus = pLocalDC->pW16ObjHndlSlotStatus;

    // now restore the other attributes

    *pLocalDC = *pLocalDCNext;

// Free the local copy of the DC.

    if (LocalFree(pLocalDCNext))
	ASSERTGDI(FALSE, "MF3216: DoRestoreDC, LocalFree failed");

// Emit the record to the Win16 metafile.

    b = bEmitWin16RestoreDC(pLocalDC, LOWORD(nSavedDC)) ;

    return (b) ;
}

/***************************************************************************
 *  SetRop2  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetRop2
(
PLOCALDC  pLocalDC,
DWORD   rop
)
{
BOOL    b ;

        // Emit the Win16 metafile drawing order.

        b = bEmitWin16SetROP2(pLocalDC, LOWORD(rop)) ;

        return(b) ;
}

/***************************************************************************
 *  SetBkMode  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetBkMode
(
PLOCALDC  pLocalDC,
DWORD   iBkMode
)
{
BOOL    b ;

	// Do it to the helper DC.  It needs this in a path bracket
	// if a text string is drawn.

	SetBkMode(pLocalDC->hdcHelper, (int) iBkMode);

        // Emit the Win16 metafile drawing order.

        b = bEmitWin16SetBkMode(pLocalDC, LOWORD(iBkMode)) ;

        return(b) ;
}

/***************************************************************************
 *  SetBkColor  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL APIENTRY DoSetBkColor
(
PLOCALDC    pLocalDC,
COLORREF    crColor
)
{
BOOL    b ;

        pLocalDC->crBkColor = crColor;	// used by brushes

        // Emit the Win16 metafile drawing order.

        b = bEmitWin16SetBkColor(pLocalDC, crColor) ;

        return(b) ;
}

/***************************************************************************
 *  GdiComment  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoGdiComment
(
 PLOCALDC   pLocalDC,
 PEMR       pemr
)
{
    BOOL    b;
    PEMRGDICOMMENT_PUBLIC pemrComment = (PEMRGDICOMMENT_PUBLIC) pemr;

// If it's not a public comment, just return TRUE.

    if (pemrComment->emr.nSize < sizeof(EMRGDICOMMENT_PUBLIC)
     || pemrComment->ident != GDICOMMENT_IDENTIFIER)
	return(TRUE);

// Handle public comments.
// A public comment consists of a public comment identifier,
// a comment type, plus any accompanying data.

    switch (pemrComment->iComment)
    {
    case GDICOMMENT_MULTIFORMATS:
	b = DoGdiCommentMultiFormats(pLocalDC, (PEMRGDICOMMENT_MULTIFORMATS) pemr);
	break;
    case GDICOMMENT_BEGINGROUP:
    case GDICOMMENT_ENDGROUP:
    case GDICOMMENT_WINDOWS_METAFILE:
    default:
	b = TRUE;
	break;
    }

    return(b) ;
}

BOOL WINAPI DoGdiCommentMultiFormats
(
 PLOCALDC pLocalDC,
 PEMRGDICOMMENT_MULTIFORMATS pemrcmf
)
{
    DWORD  i;
    DWORD  cSizeOld;
    int    iBase;
    XFORM  xformNew, xformScale;
    POINTL aptlFrame[4];
    RECTL  rclFrame;
    UINT   cbwmfNew;
    SIZEL  szlDeviceNew, szlMillimetersNew;
    BOOL   bRet      = FALSE;
    PBYTE  pbwmfNew  = (PBYTE) NULL;
    HDC    hdcemfNew = (HDC) 0;
    HENHMETAFILE   hemf    = (HENHMETAFILE) 0;
    HENHMETAFILE   hemfNew = (HENHMETAFILE) 0;
    PENHMETAHEADER pemfh;
    WIN16LOGBRUSH  Win16LogBrush;
    PMETARECORD    pmr;
#if DBG
    int    iSWO = 0;
    int    iSWE = 0;
#endif

// We will convert the enhanced metafile format only.
// Find the enhanced metafile data.

    for (i = 0; i < pemrcmf->nFormats; i++)
    {
	if (pemrcmf->aemrformat[i].dSignature == ENHMETA_SIGNATURE
	 && pemrcmf->aemrformat[i].nVersion   <= META_FORMAT_ENHANCED)
	    break;
    }

// If we cannot find a recognized format, return failure.

    if (i >= pemrcmf->nFormats)
    {
        PUTS("MF3216: DoGdiCommentMultiFormats - no recognized format found\n");
	goto dgcmf_exit;
    }

// Get the embedded enhanced metafile.

    hemf = SetEnhMetaFileBits((UINT) pemrcmf->aemrformat[i].cbData,
	    &((PBYTE) &pemrcmf->ident)[pemrcmf->aemrformat[i].offData]);
    if (!hemf)
	goto dgcmf_exit;

// Now the fun begins - we have to convert the enhanced metafile to
// Windows metafile.
// Since the multiformats record takes a logical rectangle, we have to
// set up a proper transform for the enhanced metafile.  We do it by
// creating a new enhanced metafile and playing the embedded metafile
// into the new metafile with the proper transform setup.
// In addition, the new metafile may have a different resolution than the
// metafile.  We need to take this into account when setting up
// the transform.

    // Get the world to device transform for the logical rectangle.

    if (!GetTransform(pLocalDC->hdcHelper, XFORM_WORLD_TO_DEVICE, &xformNew))
	goto dgcmf_exit;

    // Compute the device scales.

    szlDeviceNew.cx      = GetDeviceCaps(pLocalDC->hdcRef, HORZRES);
    szlDeviceNew.cy      = GetDeviceCaps(pLocalDC->hdcRef, VERTRES);
    szlMillimetersNew.cx = GetDeviceCaps(pLocalDC->hdcRef, HORZSIZE);
    szlMillimetersNew.cy = GetDeviceCaps(pLocalDC->hdcRef, VERTSIZE);
    pemfh = (PENHMETAHEADER) pLocalDC->pMf32Bits;

    xformScale.eM11 = ((FLOAT) szlDeviceNew.cx / (FLOAT) szlMillimetersNew.cx)
		    / ((FLOAT) pemfh->szlDevice.cx / (FLOAT) pemfh->szlMillimeters.cx);
    xformScale.eM12 = 0.0f;
    xformScale.eM21 = 0.0f;
    xformScale.eM22 = ((FLOAT) szlDeviceNew.cy / (FLOAT) szlMillimetersNew.cy)
		    / ((FLOAT) pemfh->szlDevice.cy / (FLOAT) pemfh->szlMillimeters.cy);
    xformScale.eDx  = 0.0f;
    xformScale.eDy  = 0.0f;

    // Compute the resulting transform to apply to the new metafile.

    if (!CombineTransform(&xformNew, &xformNew, &xformScale))
	goto dgcmf_exit;

// Create the new enhanced metafile.

    // Compute the new metafile frame.

    aptlFrame[0].x = pemrcmf->rclOutput.left;
    aptlFrame[0].y = pemrcmf->rclOutput.top;
    aptlFrame[1].x = pemrcmf->rclOutput.right;
    aptlFrame[1].y = pemrcmf->rclOutput.top;
    aptlFrame[2].x = pemrcmf->rclOutput.right;
    aptlFrame[2].y = pemrcmf->rclOutput.bottom;
    aptlFrame[3].x = pemrcmf->rclOutput.left;
    aptlFrame[3].y = pemrcmf->rclOutput.bottom;
    if (!bXformWorkhorse(aptlFrame, 4, &xformNew))
	goto dgcmf_exit;
    rclFrame.left   = MulDiv(100 * MIN4(aptlFrame[0].x, aptlFrame[1].x,
					aptlFrame[2].x, aptlFrame[3].x),
			     szlMillimetersNew.cx,
			     szlDeviceNew.cx);
    rclFrame.right  = MulDiv(100 * MAX4(aptlFrame[0].x, aptlFrame[1].x,
					aptlFrame[2].x, aptlFrame[3].x),
			     szlMillimetersNew.cx,
			     szlDeviceNew.cx);
    rclFrame.top    = MulDiv(100 * MIN4(aptlFrame[0].y, aptlFrame[1].y,
					aptlFrame[2].y, aptlFrame[3].y),
			     szlMillimetersNew.cy,
			     szlDeviceNew.cy);
    rclFrame.bottom = MulDiv(100 * MAX4(aptlFrame[0].y, aptlFrame[1].y,
					aptlFrame[2].y, aptlFrame[3].y),
			     szlMillimetersNew.cy,
			     szlDeviceNew.cy);

    hdcemfNew = CreateEnhMetaFile(pLocalDC->hdcRef, (LPCSTR) NULL,
		    (CONST RECT *) &rclFrame, (LPCSTR) NULL);
    if (!hdcemfNew)
	goto dgcmf_exit;

    if (!SetGraphicsMode(hdcemfNew, GM_ADVANCED))
	goto dgcmf_exit;

// Set up the transform in the new metafile.

    if (!SetWorldTransform(hdcemfNew, &xformNew))
	goto dgcmf_exit;

// Play the embedded metafile into the new metafile.
// This call ensures balanced level etc.

    (void) PlayEnhMetaFile(hdcemfNew, hemf, (LPRECT) &pemrcmf->rclOutput);

// Close the new metafile.

    hemfNew = CloseEnhMetaFile(hdcemfNew);
    hdcemfNew = (HDC) 0;		// used by clean up code below

// Convert the new enhanced metafile to windows metafile.

    if (!(cbwmfNew = GetWinMetaFileBits(hemfNew, 0, (LPBYTE) NULL,
			MM_ANISOTROPIC, pLocalDC->hdcRef)))
	goto dgcmf_exit;

    if (!(pbwmfNew = (PBYTE) LocalAlloc(LMEM_FIXED, cbwmfNew)))
	goto dgcmf_exit;

    if (cbwmfNew != GetWinMetaFileBits(hemfNew, cbwmfNew, pbwmfNew,
			MM_ANISOTROPIC, pLocalDC->hdcRef))
	goto dgcmf_exit;

// We now have the converted windows metafile.  We need to include it into
// our current data stream.  There are a few things to be aware of:
//
// 1. Expand the object handle slot table.  The converted metafile may
//    contain some undeleted objects.  These objects are likely
//    the "stock" objects in the converter.  As a result, we need to
//    expand the slot table by the number of object handles in the
//    converted metafile.
// 2. The object index must be changed to the current object index.
//    We are going to do this by the lazy method, i.e. we will elevate
//    the current object index base to one higher than the current max
//    object index in the current data stream.  This is because Windows uses
//    some an insane scheme for object index and this is the cheapest
//    method.  We elevate the object index base by filling up the empty
//    indexes with dummy objects that are freed when we are done.
// 3. Remove the now useless comments.
// 4. Skip header and eof.
// 5. Set up the transform to place the embedded metafile into the data
//    stream.  We know that the metafile bits returned by the converter
//    contains only a SetWindowOrg and a SetWindowExt record.
//    By implementation, we can simply remove both the SetWindowOrg and
//    SetWindowExt records from the data stream.  The window origin and
//    extents have been set up when we begin converting this enhanced
//    metafile.

    // Expand the object handle slot table.

    if (((PMETAHEADER) pbwmfNew)->mtNoObjects)
    {
        PW16OBJHNDLSLOTSTATUS pW16ObjHndlSlotStatusTmp;
	cSizeOld = (DWORD) pLocalDC->cW16ObjHndlSlotStatus;
        if (cSizeOld + ((PMETAHEADER)pbwmfNew)->mtNoObjects > (UINT) (WORD) MAXWORD)
	    goto dgcmf_exit;		// w16 handle index is only 16-bit

	pLocalDC->cW16ObjHndlSlotStatus += ((PMETAHEADER)pbwmfNew)->mtNoObjects;
	i = pLocalDC->cW16ObjHndlSlotStatus * sizeof(W16OBJHNDLSLOTSTATUS);
	pW16ObjHndlSlotStatusTmp = (PW16OBJHNDLSLOTSTATUS)
	    LocalReAlloc(pLocalDC->pW16ObjHndlSlotStatus, i, LMEM_MOVEABLE);
	if (pW16ObjHndlSlotStatusTmp == NULL)
        {
            pLocalDC->cW16ObjHndlSlotStatus -= ((PMETAHEADER)pbwmfNew)->mtNoObjects;
	    goto dgcmf_exit;
        }
        pLocalDC->pW16ObjHndlSlotStatus = pW16ObjHndlSlotStatusTmp;
        for (i = cSizeOld; i < pLocalDC->cW16ObjHndlSlotStatus; i++)
        {
            pLocalDC->pW16ObjHndlSlotStatus[i].use       = OPEN_AVAILABLE_SLOT;
            pLocalDC->pW16ObjHndlSlotStatus[i].w32Handle = 0 ;
        }
    }

    // Find the new base for the object index.

    for (iBase = pLocalDC->cW16ObjHndlSlotStatus - 1; iBase >= 0; iBase--)
    {
	if (pLocalDC->pW16ObjHndlSlotStatus[iBase].use != OPEN_AVAILABLE_SLOT)
	    break;
    }
    iBase++;

    // Fill up the object index table with dummy objects.

    Win16LogBrush.lbStyle = BS_SOLID;
    Win16LogBrush.lbColor = 0;
    Win16LogBrush.lbHatch = 0;

    for (i = 0; i < (DWORD) iBase; i++)
    {
	if (pLocalDC->pW16ObjHndlSlotStatus[i].use == OPEN_AVAILABLE_SLOT)
	{
	    if (!bEmitWin16CreateBrushIndirect(pLocalDC, &Win16LogBrush))
		goto dgcmf_exit;
	    pLocalDC->pW16ObjHndlSlotStatus[i].use = REALIZED_DUMMY;
	}
    }

    // Update the high water mark.

    if (iBase + ((PMETAHEADER) pbwmfNew)->mtNoObjects - 1 > pLocalDC->nObjectHighWaterMark)
	pLocalDC->nObjectHighWaterMark = iBase + ((PMETAHEADER) pbwmfNew)->mtNoObjects - 1;

    // Save DC states.

    if (!bEmitWin16SaveDC(pLocalDC))
	goto dgcmf_exit;

    // Enumerate the records and fix them up as necessary.

    for (pmr = (PMETARECORD) (pbwmfNew + sizeof(METAHEADER));
	 pmr->rdFunction != 0;
	 pmr = (PMETARECORD) ((PWORD) pmr + pmr->rdSize))
    {
	switch (pmr->rdFunction)
	{
	case META_SETWINDOWORG:
	    ASSERTGDI(++iSWO <= 1,
		"MF3216: DoGdiCommentMultiFormats - unexpected SWO record\n");
	    break;
	case META_SETWINDOWEXT:
	    ASSERTGDI(++iSWE <= 1,
		"MF3216: DoGdiCommentMultiFormats - unexpected SWE record\n");
	    break;

	case META_ESCAPE:
	    if (!IS_META_ESCAPE_ENHANCED_METAFILE((PMETA_ESCAPE_ENHANCED_METAFILE) pmr))
		goto default_alt;
	    break;

	case META_RESTOREDC:
	    ASSERTGDI((int)(SHORT)pmr->rdParm[0] < 0,
		"MF3216: DoGdiCommentMultiFormats - bogus RestoreDC record\n");
	    goto default_alt;

	case META_SELECTCLIPREGION:
	    if (pmr->rdParm[0] != 0)	// allow for default clipping!
	    {
		pmr->rdParm[0] += (WORD)iBase;
		pLocalDC->pW16ObjHndlSlotStatus[pmr->rdParm[0]].use = REALIZED_OBJECT;
	    }
	    goto default_alt;

	case META_FRAMEREGION:
	case META_FILLREGION:
	    pmr->rdParm[1] += (WORD)iBase;
	    pLocalDC->pW16ObjHndlSlotStatus[pmr->rdParm[1]].use = REALIZED_OBJECT;
	    // fall through
	case META_PAINTREGION:
	case META_INVERTREGION:
	case META_DELETEOBJECT:
	case META_SELECTPALETTE:
	case META_SELECTOBJECT:
	    pmr->rdParm[0] += (WORD)iBase;
	    if (pmr->rdFunction != META_DELETEOBJECT)
		pLocalDC->pW16ObjHndlSlotStatus[pmr->rdParm[0]].use = REALIZED_OBJECT;
	    else
		pLocalDC->pW16ObjHndlSlotStatus[pmr->rdParm[0]].use = OPEN_AVAILABLE_SLOT;
	    // fall through
	default:
	default_alt:
            if (!bEmit(pLocalDC, (PVOID) pmr, pmr->rdSize * sizeof(WORD)))
		goto dgcmf_exit;
	    vUpdateMaxRecord(pLocalDC, pmr);
	    break;
	}
    }

    // Restore DC states.

    if (!bEmitWin16RestoreDC(pLocalDC, (WORD) -1))
	goto dgcmf_exit;

    // Remove the dummy objects from the handle table.

    for (i = 0; i < (DWORD) iBase; i++)
    {
	if (pLocalDC->pW16ObjHndlSlotStatus[i].use == REALIZED_DUMMY)
	{
	    if (!bEmitWin16DeleteObject(pLocalDC, (WORD) i))
		goto dgcmf_exit;
	    pLocalDC->pW16ObjHndlSlotStatus[i].use = OPEN_AVAILABLE_SLOT;
	}
    }

    // Shrink the object handle slot table.

    if (((PMETAHEADER) pbwmfNew)->mtNoObjects)
    {
	DWORD cUndel = 0;		// number of objects not deleted
	DWORD iUndelMax = iBase - 1;	// the max undeleted object index

        for (i = iBase; i < pLocalDC->cW16ObjHndlSlotStatus; i++)
        {
            if (pLocalDC->pW16ObjHndlSlotStatus[i].use != OPEN_AVAILABLE_SLOT)
	    {
		cUndel++;
		iUndelMax = i;
	    }
        }

	pLocalDC->cW16ObjHndlSlotStatus = max(cSizeOld + cUndel, iUndelMax + 1);
    }

// Everything is golden.

    bRet = TRUE;

dgcmf_exit:

    if (pbwmfNew)
	if (LocalFree(pbwmfNew))
	    ASSERTGDI(FALSE, "MF3216: DoGdiCommentMultiFormats - LocalFree failed\n");

    if (hemf)
	DeleteEnhMetaFile(hemf);

    if (hdcemfNew)
	hemfNew = CloseEnhMetaFile(hdcemfNew);	// hemfNew will be deleted next

    if (hemfNew)
	DeleteEnhMetaFile(hemfNew);

    return(bRet);
}

/***************************************************************************
 *  EOF  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL APIENTRY DoEOF
(
PLOCALDC  pLocalDC
)
{
BOOL    b ;

        b = bEmitWin16EOF(pLocalDC) ;

        return(b) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\mf3216\precomp.h ===
#include "stddef.h"
#include "mf3216.h"
#include "wingdip.h"
#include "entry.h"
#include "win16api.h"
#include "..\client\mf16.h"
#include "..\client\metadef.h"
#include <math.h>
#include "handlers.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\mf3216\preamble.c ===
/*****************************************************************************
 *
 * Preamble - Preamble routines for MF3216
 *
 * Date: 7/18/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/


#include "precomp.h"
#pragma hdrstop

BOOL bSetWindowOrgAndExtToFrame(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header) ;

/*----------------------------------------------------------------------------
 *  DoHeader -  Emit the Win16 metafile header
 *---------------------------------------------------------------------------*/
BOOL APIENTRY DoHeader(PLOCALDC pLocalDC, PENHMETAHEADER pemfheader)
{
BOOL        b ;

        b = bInitHandleTableManager(pLocalDC, pemfheader) ;
        if (b == FALSE)
            goto error_exit ;

    b = bInitXformMatrices(pLocalDC, pemfheader) ;
        if (b == FALSE)
            goto error_exit ;

        // The metafile will always be memory based.

    pLocalDC->mf16Header.mtType    = MEMORYMETAFILE ;
    pLocalDC->mf16Header.mtVersion = 0x300 ;    // magic number for Win3.0
    pLocalDC->mf16Header.mtHeaderSize = sizeof (METAHEADER) / 2 ;

    // Init fields to 0.  They will be updated at the end of translation.

    pLocalDC->mf16Header.mtSize      = 0 ;
    pLocalDC->mf16Header.mtNoObjects = 0 ;
    pLocalDC->mf16Header.mtMaxRecord = 0 ;      // NOTE: We need a max record size.
    pLocalDC->mf16Header.mtNoParameters = 0 ;

    // Emit the MF16 metafile header to the metafile.

    b = bEmit(pLocalDC, &pLocalDC->mf16Header, sizeof(METAHEADER)) ;
        if (b == FALSE)
            goto error_exit ;

        if (pLocalDC->flags & INCLUDE_W32MF_COMMENT)
        {
            b = bHandleWin32Comment(pLocalDC) ;
            if (b == FALSE)
                goto error_exit ;
        }

    // Prepare the transform for the 16-bit metafile.  See comments in
    // xforms.c.

    // Emit the Win16 MapMode record

        b = bEmitWin16SetMapMode(pLocalDC, LOWORD(pLocalDC->iMapMode)) ;
        if (b == FALSE)
            goto error_exit ;

        // Set the Win16 metafile WindowExt to the size of the frame
        // in play-time device units.

        b = bSetWindowOrgAndExtToFrame(pLocalDC, pemfheader) ;
        if (b == FALSE)
        {
            RIP("MF3216: DoHeader, bSetWindowOrgAndExtToFrame failure\n") ;
            goto error_exit ;
        }

error_exit:
    return(b) ;
}



/*----------------------------------------------------------------------------
 * Calculate and Emit into the Win16 metafile a Window origin
 * and extent drawing order
 * that will set the Window Origin and Extent to the size of the picture  frame in
 * play-time-page (reference-logical) units.
 *---------------------------------------------------------------------------*/
BOOL bSetWindowOrgAndExtToFrame(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header)
{
FLOAT   ecxPpmmPlay,        // cx pixels per millimeter play
        ecyPpmmPlay,        // cy pixels per millimeter play
        ecx01PpmmPlay,      // cx pixels per .01 millimeter play
        ecy01PpmmPlay,      // cy pixels per .01 millimeter play
        ecxPelsFrame,       // cx play-time frame in device units
        ecyPelsFrame,       // cy play-time frame in device units
        exPelsFrame,        // x play-time frame in device units
        eyPelsFrame ;       // y play-time frame in device units

INT     cxFrame,            // cx Picture Frame
        cyFrame,            // cy Picture Frame
        xFrame,             // x Picture Frame
        yFrame ;            // y Picture Frame

SIZEL   szlFrame ;
POINTL  ptlFrame ;

        // Calculate the play-time (reference) pixels per millimeter.

        ecxPpmmPlay = (FLOAT) pLocalDC->cxPlayDevPels / (FLOAT) pLocalDC->cxPlayDevMM ;
        ecyPpmmPlay = (FLOAT) pLocalDC->cyPlayDevPels / (FLOAT) pLocalDC->cyPlayDevMM ;

        // Scale the pixels per millimeter to pixels per .01 millimeters.

        ecx01PpmmPlay = ecxPpmmPlay / 100.0f ;
        ecy01PpmmPlay = ecyPpmmPlay / 100.0f ;

        // Pickup the fram origin

        xFrame = pmf32header->rclFrame.left ;
        yFrame = pmf32header->rclFrame.top ;

        // Translate the frame origin to play-time-device units.

        exPelsFrame = ecx01PpmmPlay * (FLOAT) xFrame ;
        eyPelsFrame = ecy01PpmmPlay * (FLOAT) yFrame ;

        // Convert the Frame origin to play-time-page units.
        // (aka reference-logical units.)

        ptlFrame.x = (LONG) (exPelsFrame * pLocalDC->xformPDevToPPage.eM11 + 0.5f);
        ptlFrame.y = (LONG) (eyPelsFrame * pLocalDC->xformPDevToPPage.eM22 + 0.5f);
    if (!bCoordinateOverflowTest((PLONG) &ptlFrame, 2))
            return(FALSE);

        // Set the Window origin.

        if (!bEmitWin16SetWindowOrg(pLocalDC,
                    (SHORT) ptlFrame.x,
                    (SHORT) ptlFrame.y))
        {
            RIP("MF3216: bEmitWin16SetWindowOrg failed\n") ;
            return(FALSE);
        }

        // Calculate the Frame width and height.

        cxFrame = pmf32header->rclFrame.right - pmf32header->rclFrame.left ;
        cyFrame = pmf32header->rclFrame.bottom - pmf32header->rclFrame.top ;

        // Convert the frame width and height into play-time-device units.
        // (aka reference-device units.)

        ecxPelsFrame = ecx01PpmmPlay * (FLOAT) cxFrame ;
        ecyPelsFrame = ecy01PpmmPlay * (FLOAT) cyFrame ;

        // Translate the play-time device units into play-time-page units.
        // (aka reference-device to reference-logical units.)
    // This is an identity transform for MM_ANISOTROPIC mode.  For other
    // fixed mapping modes, the SetWindowExt record has no effect.

        szlFrame.cx = (LONG) (ecxPelsFrame + 0.5f);
        szlFrame.cy = (LONG) (ecyPelsFrame + 0.5f);
    if (!bCoordinateOverflowTest((PLONG) &szlFrame, 2))
            return(FALSE);

        // Set the Window Extent.

        if (!bEmitWin16SetWindowExt(pLocalDC,
                    (SHORT) szlFrame.cx,
                    (SHORT) szlFrame.cy))
        {
            RIP("MF3216: bEmitWin16SetWindowExt failed\n") ;
            return(FALSE);
        }

        return(TRUE);
}


/*----------------------------------------------------------------------------
 *  UpdateMf16Header - Update the metafile header with the:
 *             metafile size,
 *             number of objects,
 *             the max record size.
 *---------------------------------------------------------------------------*/
BOOL bUpdateMf16Header(PLOCALDC pLocalDC)
{
BOOL    b ;
INT     iCpTemp ;

    // Fill in the missing info in the Win16 metafile header.

    pLocalDC->mf16Header.mtSize      = pLocalDC->ulBytesEmitted / 2 ;
    pLocalDC->mf16Header.mtNoObjects = (WORD) (pLocalDC->nObjectHighWaterMark + 1) ;
    pLocalDC->mf16Header.mtMaxRecord = pLocalDC->ulMaxRecord ;

        // Reset the output buffer index to the beginning of the buffer.

        iCpTemp = pLocalDC->ulBytesEmitted ;
        pLocalDC->ulBytesEmitted = 0 ;

    // re-emit the Win16 metafile header.

    b = bEmit(pLocalDC, &pLocalDC->mf16Header, (DWORD) sizeof (pLocalDC->mf16Header)) ;

        pLocalDC->ulBytesEmitted = iCpTemp ;

    return (b) ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\mf3216\polygons.c ===
/*****************************************************************************
 *
 * polygons - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************
 *  PolyPolygon  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPolyPolygon
(
PLOCALDC pLocalDC,
PPOINTL pptl,
PDWORD  pcptl,
DWORD   cptl,
DWORD   ccptl
)
{
BOOL    b;
PWORD   pcptlBuff = (PWORD) NULL;
PPOINTL pptlBuff  = (PPOINTL) NULL;
PPOINTL pptlSrc, pptlDst;
DWORD   i, cptlMax, cptlNeed, cptli;

        // If we're recording the drawing orders for a path
        // then just pass the drawing order to the helper DC.
        // Do not emit any Win16 drawing orders.

        if (pLocalDC->flags & RECORDING_PATH)
        return(PolyPolygon(pLocalDC->hdcHelper, (LPPOINT) pptl, (LPINT) pcptl, (INT) ccptl));

        // NOTE: There is a semantic between the Win32 PolyPolygon and
        // the Win16 PolyPolygon.  Win32 will close each polygon, Win16
        // will not.  As a result, we have to insert points as necessary
    // to make the polygons closed.  We cannot use multiple polygons
    // to replace a single PolyPolygon because they are different if
    // the polygons overlap and the polyfill mode is winding.

        // If there are not verrics just return TRUE.

        if (ccptl == 0)
            return(TRUE) ;

    b = FALSE;          // assume failure

    // Compute the maximum size of the temporary point array required
    // to create closed PolyPolygon in win16.

    cptlMax = cptl + ccptl;

        // Allocate a buffer for the temporary point array.

        pptlBuff = (PPOINTL) LocalAlloc(LMEM_FIXED, cptlMax * sizeof(POINTL)) ;
        if (!pptlBuff)
        {
            PUTS("MF3216: DoPolyPolygon, LocalAlloc failed\n") ;
            goto exit;
        }

        // Allocate a buffer for the new polycount array and make a copy
    // of the old array.

        pcptlBuff = (PWORD) LocalAlloc(LMEM_FIXED, ccptl * sizeof(WORD)) ;
        if (!pcptlBuff)
        {
            PUTS("MF3216: DoPolyPolygon, LocalAlloc failed\n") ;
            goto exit;
        }

    for (i = 0; i < ccptl; i++)
        pcptlBuff[i] = (WORD) pcptl[i];

    // Insert the points and update the polycount as necessary.

    pptlDst = pptlBuff;
    pptlSrc = pptl;
    cptlNeed = cptl;
    for (i = 0; i < ccptl; i++)
    {
        cptli = pcptl[i];

        if (cptli < 2)
        goto exit;

        RtlCopyMemory(pptlDst, pptlSrc, cptli * sizeof(POINTL)) ;
        if (pptlDst[0].x != pptlDst[cptli - 1].x
         || pptlDst[0].y != pptlDst[cptli - 1].y)
        {
        pptlDst[cptli] = pptlDst[0];
        pptlDst++;
        cptlNeed++;
        pcptlBuff[i]++;
        }
        pptlSrc += cptli;
        pptlDst += cptli;
    }

        // The Win16 poly record is limited to 64K points.
        // Need to check this limit.

        if (cptlNeed > (DWORD) (WORD) MAXWORD)
    {
            PUTS("MF3216: DoPolyPolygon, Too many point in poly array\n") ;
            SetLastError(ERROR_NOT_ENOUGH_MEMORY) ;
            goto exit ;
    }

        // Do the transformations.

    if (!bXformRWorldToPPage(pLocalDC, pptlBuff, cptlNeed))
            goto exit;

        // Compress the POINTLs to POINTSs

        vCompressPoints(pptlBuff, cptlNeed) ;

        // Call the Win16 routine to emit the PolyPolygon to the metafile.

    b = bEmitWin16PolyPolygon(pLocalDC, (PPOINTS) pptlBuff,
        pcptlBuff, (WORD) cptlNeed, (WORD) ccptl);
exit:
        // Free the memory.

        if (pptlBuff)
            if (LocalFree(pptlBuff))
            ASSERTGDI(FALSE, "MF3216: DoPolyPolygon, LocalFree failed");

        if (pcptlBuff)
            if (LocalFree(pcptlBuff))
            ASSERTGDI(FALSE, "MF3216: DoPolyPolygon, LocalFree failed");

        return(b) ;
}

/***************************************************************************
 *  SetPolyFillMode  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetPolyFillMode
(
PLOCALDC  pLocalDC,
DWORD   iPolyFillMode
)
{
BOOL    b ;

        // Emit the Win16 metafile drawing order.

        b = bEmitWin16SetPolyFillMode(pLocalDC, LOWORD(iPolyFillMode)) ;

        return(b) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\mf3216\rects.c ===
/*****************************************************************************
 *
 * rects - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************
 *  Rectangle  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoRectangle
(
PLOCALDC pLocalDC,
int    x1,
int    y1,
int    x2,
int    y2
)
{
BOOL    b ;

        b = bConicCommon (pLocalDC, x1, y1, x2, y2, 0, 0, 0, 0, EMR_RECTANGLE) ;

        return(b) ;
}


/***************************************************************************
 *  RoundRect  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoRoundRect
(
PLOCALDC pLocalDC,
int x1,
int y1,
int x2,
int y2,
int x3,
int y3
)
{
BOOL    b ;

        b = bConicCommon (pLocalDC, x1, y1, x2, y2, x3, y3, 0, 0, EMR_ROUNDRECT);

        return(b) ;
}


/***************************************************************************
 *  IntersectClipRect/ExcludeClipRect - Win32 to Win16 Metafile Converter
 *  Entry Point
 **************************************************************************/

BOOL WINAPI DoClipRect
(
PLOCALDC pLocalDC,
INT xLeft,
INT yTop,
INT xRight,
INT yBottom,
INT mrType
)
{
BOOL    bNoClipRgn ;

	// Do it to the helper DC.

	// If there is no initial clip region, we have to
	// create one.  Otherwise, GDI will create some random default
	// clipping region for us!

	bNoClipRgn = bNoDCRgn(pLocalDC, DCRGN_CLIP);

	if (bNoClipRgn)
	{
	    BOOL bRet;
	    HRGN hrgnDefault;
	
	    if (!(hrgnDefault = CreateRectRgn((int) (SHORT) MINSHORT,
					      (int) (SHORT) MINSHORT,
					      (int) (SHORT) MAXSHORT,
					      (int) (SHORT) MAXSHORT)))
	    {
		ASSERTGDI(FALSE, "MF3216: CreateRectRgn failed");
	        return(FALSE);
	    }
	
	    bRet = (ExtSelectClipRgn(pLocalDC->hdcHelper, hrgnDefault, RGN_COPY)
		    != ERROR);
	    ASSERTGDI(bRet, "MF3216: ExtSelectClipRgn failed");
	
	    if (!DeleteObject(hrgnDefault))
		ASSERTGDI(FALSE, "MF3216: DeleteObject failed");
	
	    if (!bRet)
		return(FALSE);
	}

	switch(mrType)
	{
	case EMR_INTERSECTCLIPRECT:
	    if (!IntersectClipRect(pLocalDC->hdcHelper, xLeft, yTop, xRight, yBottom))
                return(FALSE);
	    break;

	case EMR_EXCLUDECLIPRECT:
	    if (!ExcludeClipRect(pLocalDC->hdcHelper, xLeft, yTop, xRight, yBottom))
                return(FALSE);
	    break;

	default:
	    ASSERTGDI(FALSE, "MF3216: DoClipRect, bad mrType\n");
	    break;
	}

	// Dump the clip region data.

	return(bDumpDCClipping(pLocalDC));

#if 0
// It's too much work to try to optimize it here!

	POINTL  aptl[2] ;

	// Dump the clip region data if there is a strange xform.

	if (pLocalDC->flags & STRANGE_XFORM || bNoClipRgn)
	    return(bDumpDCClipping(pLocalDC));

        // Do the simple case.
	// Are they inclusive-exclusive?!

        aptl[0].x = xLeft;
        aptl[0].y = yTop ;
        aptl[1].x = xRight;
        aptl[1].y = yBottom ;

	// Order the rectangle first, see EXFORMOBJ::bXform(ERECTL) in gre!

	if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) aptl, 2))
            return(FALSE);

        ASSERTGDI(bCoordinateOverflowTest((PLONG) aptl, 4), "MF3216: coord overflow");

	// Verify rectangle ordering and check off-by-1 error!

	if (mrType == EMR_INTERSECTCLIPRECT)
            return(bEmitWin16IntersectClipRect(pLocalDC,
                                               (SHORT) aptl[0].x,
                                               (SHORT) aptl[0].y,
                                               (SHORT) aptl[1].x,
                                               (SHORT) aptl[1].y));
	else
            return(bEmitWin16ExcludeClipRect(pLocalDC,
                                               (SHORT) aptl[0].x,
                                               (SHORT) aptl[0].y,
                                               (SHORT) aptl[1].x,
                                               (SHORT) aptl[1].y));
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\mf3216\text.c ===
/*****************************************************************************
 *
 * text - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop

__declspec(dllimport)
ULONG
__stdcall
RtlUnicodeToMultiByteN(
    PCHAR MultiByteString,
    ULONG MaxBytesInMultiByteString,
    PULONG BytesInMultiByteString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    );

ULONG
__stdcall
RtlUnicodeToMultiByteSize(
    PULONG BytesInMultiByteString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    );

DWORD GetCodePage(HDC hdc)
{
  DWORD FAR *lpSrc = UlongToPtr(GetTextCharsetInfo(hdc, 0, 0));
  CHARSETINFO csi;

  TranslateCharsetInfo(lpSrc, &csi, TCI_SRCCHARSET);

  return csi.ciACP;
}


/***************************************************************************
 *  ExtTextOut  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoExtTextOut
(
PLOCALDC pLocalDC,
INT     x,                  // Initial x position
INT     y,                  // Initial y position
DWORD   flOpts,             // Options
PRECTL  prcl,               // Clipping rectangle
PWCH    pwch,               // Character array
DWORD   cch,                // Character count
PLONG   pDx,                // Inter-Character spacing
DWORD   iGraphicsMode,      // Graphics mode
INT     mrType              // Either EMR_EXTTEXTOUTW (Unicode)
                //     or EMR_EXTTEXTOUTA (Ansi)
)
{
    INT     i;
    BOOL    b;
    RECTS   rcs;
    POINTL  ptlRef;
    UINT    fTextAlign;
    WORD    fsOpts;
    PCHAR   pch, pchAlloc;
    PPOINTL pptl;
    POINTL  ptlAdjust;
    BOOL    bAdjustAlignment;
    ULONG   nANSIChars;
    PCHAR   pDBCSBuffer = NULL;

    pptl     = (PPOINTL) NULL;
    fsOpts   = (WORD) flOpts;
    pchAlloc = (PCHAR) NULL;
    bAdjustAlignment = FALSE;
    b        = FALSE;       // assume failure

    ASSERTGDI(mrType == EMR_EXTTEXTOUTA || mrType == EMR_EXTTEXTOUTW,
    "MF3216: DoExtTextOut: bad record type");

// We do not handle the advanced graphics mode here except when
// we are in a path!

// If we're recording the drawing orders for a path
// then just pass the drawing order to the helper DC.
// Do not emit any Win16 drawing orders.

    if (pLocalDC->flags & RECORDING_PATH)
    {
    // The helper DC is in the advanced graphics mode.  We need to set
    // it to the compatible graphics mode temporarily if necessary.

    if (iGraphicsMode != GM_ADVANCED)
        SetGraphicsMode(pLocalDC->hdcHelper, iGraphicsMode);

    if (mrType == EMR_EXTTEXTOUTA)
        b = ExtTextOutA
        (
            pLocalDC->hdcHelper,
            (int)    x,
            (int)    y,
            (UINT)   flOpts,
            (LPRECT) prcl,
            (LPSTR)  pwch,
            (int)    cch,
            (LPINT)  pDx
        );
    else
        b = ExtTextOutW
        (
            pLocalDC->hdcHelper,
            (int)    x,
            (int)    y,
            (UINT)   flOpts,
            (LPRECT) prcl,
            (LPWSTR) pwch,
            (int)    cch,
            (LPINT)  pDx
        );

    // Restore the graphics mode.

    if (iGraphicsMode != GM_ADVANCED)
        SetGraphicsMode(pLocalDC->hdcHelper, GM_ADVANCED);

    return(b);
    }

// If the string uses the current position, make sure that the metafile
// has the same current position as that of the helper DC.

    fTextAlign = GetTextAlign(pLocalDC->hdcHelper);

    if (fTextAlign & TA_UPDATECP)
    {
    POINT   ptCP;

    // Update the current position in the converted metafile if
    // it is different from that of the helper DC.  See notes
    // in DoMoveTo().

    if (!GetCurrentPositionEx(pLocalDC->hdcHelper, &ptCP))
        goto exit_DoExtTextOut;

    // Make sure that the converted metafile has the same CP as the
    // helper DC.

    if (!bValidateMetaFileCP(pLocalDC, ptCP.x, ptCP.y))
        goto exit_DoExtTextOut;

    // Initialize the XY start position.

    x = ptCP.x;
    y = ptCP.y;
    }

// Transform the XY start position.

    ptlRef.x = x;
    ptlRef.y = y;

    if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) &ptlRef, 1))
    goto exit_DoExtTextOut;

// If we have an opaque/clipping rectangle, transform it.
// If we have a strange transform, we will do the rectangle at this time.

    if (fsOpts & (ETO_OPAQUE | ETO_CLIPPED))
    {
    RECTL rcl;

    rcl = *prcl ;

    if (!(pLocalDC->flags & STRANGE_XFORM))
    {
        if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) &rcl, 2))
        goto exit_DoExtTextOut;

        // The overflow test has been done in the xform.

        rcs.left   = (SHORT) rcl.left;
        rcs.top    = (SHORT) rcl.top;
        rcs.right  = (SHORT) rcl.right;
        rcs.bottom = (SHORT) rcl.bottom;
    }
    else
    {
            if (fsOpts & ETO_OPAQUE)
            {
        LONG     lhpn32;
        LONG     lhbr32;
        INT  ihW32Br;
        LOGBRUSH lbBkColor;

        // Remember the previous pen and brush

        lhpn32 = pLocalDC->lhpn32;
        lhbr32 = pLocalDC->lhbr32;

        if (DoSelectObject(pLocalDC, ENHMETA_STOCK_OBJECT | NULL_PEN))
        {
            lbBkColor.lbStyle = BS_SOLID;
            lbBkColor.lbColor = pLocalDC->crBkColor;
            lbBkColor.lbHatch = 0;

            // Get an unused W32 object index.

            ihW32Br = pLocalDC->cW32ToW16ObjectMap - (STOCK_LAST + 1) - 1;

                    if (DoCreateBrushIndirect(pLocalDC, ihW32Br, &lbBkColor))
            {
            if (DoSelectObject(pLocalDC, ihW32Br))
            {
                if (DoRectangle(pLocalDC, rcl.left, rcl.top, rcl.right, rcl.bottom))
                fsOpts &= ~ETO_OPAQUE;

                // Restore the previous brush.

                if (!DoSelectObject(pLocalDC, lhbr32))
                ASSERTGDI(FALSE,
                 "MF3216: DoExtTextOut, DoSelectObject failed");
            }
            if (!DoDeleteObject(pLocalDC, ihW32Br))
                ASSERTGDI(FALSE,
                "MF3216: DoExtTextOut, DoDeleteObject failed");
            }

            // Restore the previous pen.

            if (!DoSelectObject(pLocalDC, lhpn32))
            ASSERTGDI(FALSE,
                "MF3216: DoExtTextOut, DoSelectObject failed");
        }

        // Check if the rectangle is drawn.

        if (fsOpts & ETO_OPAQUE)
            goto exit_DoExtTextOut;
            }

            if (fsOpts & ETO_CLIPPED)
            {
        // Save the DC so that we can restore it when we are done

        if (!DoSaveDC(pLocalDC))
            goto exit_DoExtTextOut;

                fsOpts &= ~ETO_CLIPPED;     // need to restore dc

                if (!DoClipRect(pLocalDC, rcl.left, rcl.top,
                           rcl.right, rcl.bottom, EMR_INTERSECTCLIPRECT))
            goto exit_DoExtTextOut;
            }
    }
    }

// Convert the Unicode to Ansi.

    if (mrType == EMR_EXTTEXTOUTW)
    {
        DWORD dwCP;
        
//        RtlUnicodeToMultiByteSize(&nANSIChars, pwch, cch * sizeof(WORD));

        dwCP = GetCodePage(pLocalDC->hdcHelper);
        nANSIChars = WideCharToMultiByte(dwCP, 0, pwch, cch, NULL, 0, NULL, NULL);
        
        if (nANSIChars == cch)
        {
            pch = pchAlloc = (PCHAR) LocalAlloc(LMEM_FIXED, cch * sizeof(BYTE)) ;

            if (pch == (PCHAR) NULL)
            {
                RIP("MF3216: ExtTextOut, pch LocalAlloc failed\n") ;
                goto exit_DoExtTextOut;
            }

            WideCharToMultiByte(dwCP, 0, pwch, cch, pch, cch, NULL, NULL);
        }
        else
        {
        // DBCS char string

            UINT    cjBufferSize;

            // we want DX array on a DWORD boundary

            cjBufferSize = ((nANSIChars+3)/4) * 4 * (sizeof(char) + sizeof(LONG));
            pchAlloc = pDBCSBuffer = LocalAlloc(LMEM_FIXED, cjBufferSize);

            if (pDBCSBuffer)
            {
            // start munging passed in parameters

                mrType = EMR_EXTTEXTOUTA;

                WideCharToMultiByte(dwCP, 0, pwch, cch, pDBCSBuffer, nANSIChars, NULL, NULL);

                pwch = (PWCH) pDBCSBuffer;
                pch = (PCHAR) pwch;
                cch = nANSIChars;

                if (pDx)
                {
                    ULONG ii, jj;

                    PULONG pDxTmp = (PLONG) &pDBCSBuffer[((nANSIChars+3)/4)*4];

                    for(ii=jj=0; ii < nANSIChars; ii++, jj++)
                    {
                        pDxTmp[ii] = pDx[jj];

                        if(IsDBCSLeadByteEx(dwCP, pDBCSBuffer[ii]))
                        {
                            pDxTmp[++ii] = 0;
                        }
                    }

                    pDx = pDxTmp;
                }
            }
            else
            {
                goto exit_DoExtTextOut;
            }
        }
    }
    else
    {
        pch = (PCHAR) pwch ;
    }

// Transform the intercharacter spacing information.
// Allocate an array of (cch + 1) points to transform the points in,
// and copy the points to the array.
// ATTENTION: The following will not work if the current font has a vertical default
// baseline

    pptl = (PPOINTL) LocalAlloc(LMEM_FIXED, (cch + 1) * sizeof(POINTL));
    if (pptl == (PPOINTL) NULL)
    {
        RIP("MF3216: ExtTextOut, pptl LocalAlloc failed\n") ;
    goto exit_DoExtTextOut;
    }

    pptl[0].x = x;
    pptl[0].y = y;
    for (i = 1; i < (INT) cch + 1; i++)
    {
    pptl[i].x = pptl[i-1].x + pDx[i-1];
    pptl[i].y = y;
    }

// If there is no rotation or shear then we can
// output the characters as a string.
// On the other hand, if there is rotation or shear then we
// have to output each character independently.

    if (!(pLocalDC->flags & STRANGE_XFORM))
    {
    // Win31 does not do text alignment correctly in some transforms.
    // It performs alignment in device space but win32 does it in the
    // notional space.  As a result, a win32 TextOut call may produce
    // different output than a similar call in win31.  We cannot
    // convert this correctly since if we make it works on win31,
    // it will not work on wow!

    PSHORT pDx16;

    if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) pptl, (INT) cch + 1))
        goto exit_DoExtTextOut;

        // Convert it to the Dx array.  We do not need to compute it
    // as a vector since we have a scaling transform here.

    pDx16 = (PSHORT) pptl;
        for (i = 0; i < (INT) cch; i++)
            pDx16[i] = (SHORT) (pptl[i+1].x - pptl[i].x);

        // Emit the Win16 ExtTextOut metafile record.

        if (!bEmitWin16ExtTextOut(pLocalDC,
                                  (SHORT) ptlRef.x, (SHORT) ptlRef.y,
                                  fsOpts, &rcs, (PSTR) pch, (SHORT) cch,
                  (PWORD) pDx16))
        goto exit_DoExtTextOut;
    }
    else
    {
    // Deal with alignment in the world space.  We should really
    // do it in the notional space but with escapement and angles,
    // things gets complicated pretty easily.  We will try
    // our best to make it work in the common case.  We will not
    // worry about escapement and angles.

    ptlAdjust.x = 0;
        ptlAdjust.y = 0;

    switch (fTextAlign & (TA_LEFT | TA_RIGHT | TA_CENTER))
    {
    case TA_LEFT:           // default, no need to adjust x's
        break;
    case TA_RIGHT:          // shift the string by the string length
        bAdjustAlignment = TRUE;
        ptlAdjust.x = pptl[0].x - pptl[cch+1].x;
        break;
    case TA_CENTER:         // shift the string to the center
        bAdjustAlignment = TRUE;
        ptlAdjust.x = (pptl[0].x - pptl[cch+1].x) / 2;
        break;
    }

    // We will not adjust for the vertical alignment in the strange
    // transform case.  We cannot rotate the glyphs in any case.
#if 0
    switch (fTextAlign & (TA_TOP | TA_BOTTOM | TA_BASELINE))
    {
    case TA_TOP:            // default, no need to adjust y's
        break;
    case TA_BOTTOM:
        ptlAdjust.y = -logfont.height;
        break;
    case TA_BASELINE:
        ptlAdjust.y = -(logfont.height - logfont.baseline);
        break;
    }
#endif // 0

    // Adjust the character positions taking into account the alignment.

        for (i = 0; i < (INT) cch + 1; i++)
    {
        pptl[i].x += ptlAdjust.x;
        pptl[i].y += ptlAdjust.y;
    }

    if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) pptl, (INT) cch + 1))
        goto exit_DoExtTextOut;

    // Reset the alignment since it has been accounted for.

    if (bAdjustAlignment)
            if (!bEmitWin16SetTextAlign(pLocalDC,
                (WORD) ((fTextAlign & ~(TA_LEFT | TA_RIGHT | TA_CENTER)) | TA_LEFT)))
        goto exit_DoExtTextOut;

    // Output the characters one at a time.

        for (i = 0 ; i < (INT) cch ; i++)
        {
        ASSERTGDI(!(fsOpts & (ETO_OPAQUE | ETO_CLIPPED)),
        "mf3216: DoExtTextOut: rectangle not expected");

            if (!bEmitWin16ExtTextOut(pLocalDC,
                                      (SHORT) pptl[i].x, (SHORT) pptl[i].y,
                                      fsOpts, (PRECTS) NULL,
                                      (PSTR) &pch[i], 1, (PWORD) NULL))
            goto exit_DoExtTextOut;
        }
    }

// Everything is golden.

    b = TRUE;

// Cleanup and return.

exit_DoExtTextOut:

    // Restore the alignment.

    if (bAdjustAlignment)
        (void) bEmitWin16SetTextAlign(pLocalDC, (WORD) fTextAlign);

    if ((flOpts & ETO_CLIPPED) && !(fsOpts & ETO_CLIPPED))
        (void) DoRestoreDC(pLocalDC, -1);

    if (pchAlloc)
        LocalFree((HANDLE) pchAlloc);

    if (pptl)
        LocalFree((HANDLE) pptl);

// Update the current position if the call succeeds.

    if (b)
    {
    if (fTextAlign & TA_UPDATECP)
    {
        // Update the helper DC.

        if (mrType == EMR_EXTTEXTOUTA)
        ExtTextOutA
        (
            pLocalDC->hdcHelper,
            (int)    x,
            (int)    y,
            (UINT)   flOpts,
            (LPRECT) prcl,
            (LPSTR)  pwch,
            (int)    cch,
            (LPINT)  pDx
        );
        else
        ExtTextOutW
        (
            pLocalDC->hdcHelper,
            (int)    x,
            (int)    y,
            (UINT)   flOpts,
            (LPRECT) prcl,
            (LPWSTR) pwch,
            (int)    cch,
            (LPINT)  pDx
        );

        // Make the metafile CP invalid to force update
        // when it is used next time

            pLocalDC->ptCP.x = MAXLONG ;
            pLocalDC->ptCP.y = MAXLONG ;
    }
    }

    return(b);
}


/***************************************************************************
 *  SetTextAlign  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetTextAlign
(
PLOCALDC pLocalDC,
DWORD   fMode
)
{
BOOL    b ;

    // Do it to the helper DC.  It needs this in a path bracket
    // and to update current position correctly.

    SetTextAlign(pLocalDC->hdcHelper, (UINT) fMode);

        // Emit the Win16 metafile drawing order.

        b = bEmitWin16SetTextAlign(pLocalDC, LOWORD(fMode)) ;

        return(b) ;
}


/***************************************************************************
 *  SetTextColor  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetTextColor
(
PLOCALDC pLocalDC,
COLORREF    crColor
)
{
BOOL    b ;

        pLocalDC->crTextColor = crColor ;   // used by ExtCreatePen

        // Emit the Win16 metafile drawing order.

        b = bEmitWin16SetTextColor(pLocalDC, crColor) ;

        return(b) ;
}


/***************************************************************************
 *  UnicodeToAnsi - Unicode to ANSI conversion routine.
 **************************************************************************/
VOID vUnicodeToAnsi
(
    PCHAR   pAnsi,
    PWCH    pUnicode,
    DWORD   cch
)
{
    (void) RtlUnicodeToMultiByteN(pAnsi, cch, NULL, pUnicode, cch * sizeof(WCHAR));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\mf3216\objects.c ===
/*****************************************************************************
 *
 * objects - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *
 *
 *  14-Jan-1992
 *  Jeffrey Newman
 *
 *  CR1:    14-Jan-1992 -   this entire comment and the design that it
 *                          specifies.
 *
 *  The Object system in mf3216.
 *
 *  Overview
 *
 *      The Win32 objects (represented by object handle indicies) must be
 *      mapped to Win16 objects (also represented by object handle indices).
 *      Win32 uses stock objects, Win16 does not.  MF3216 uses a scheme
 *      for lazy stock object creation.  Through lazy stock object creation
 *      no unused objects will be emitted into the Win16 metafile.
 *
 *      Objects in a Win16 metafile are maintained in an Object Table. The
 *      object table is not recorded in the Win16 metafile.  It is created at
 *      play-time. Each entry in the Win16-Object-Table is called a slot.
 *      Slots are allocated one per object.  If an object is deleted then the
 *      slot becomes available for the next object created.  The first object-
 *      slot, starting from 0, in a linear search, that is available will be
 *      used to hold the next create object request.
 *
 *      Objects in either a Win32 or a Win16 metafile are represented as an
 *      index into the Object Table.  Every object created must occupy
 *      the same slot at play-time that it would have occupied at record-time.
 *
 *      Win32 objects have an object ID (index in the handle table) recorded
 *      with them.  Win16 objects do not.
 *
 *  Data Structures
 *
 *      There are two primary data structures used in the translation of
 *      Win32 objects to Win16 objects.  Both of them are dynamically
 *      allocated arrays.  The size of these arrays are determined by
 *      estimating the number of objects required in the Win16 metafile from
 *      the size of the handle table used in the Win32 metafile.  The size of
 *      the handle table is recorded in the Win32 metafile header.
 *
 *      The data structure piW16ObjectHandleSlotStatus is used to represent
 *      the status of the Win16 handle table as it would appear at any point
 *      during the Win16 metafile playback process.  A slot is either in
 *      use or free.
 *
 *      The data structure piW32ToW16ObjectMap is a translation table
 *      from the Win32 object indicies to the Win16 object indicies.
 *      The position in the array (aka the index into the array) is the
 *      Win32 handle.  The value in this entry is the Win16 slot number
 *      for the handle.
 *
 *      The first 16 entries in piW32ToW16ObjectMap array are used for the
 *      stock objects.
 *
 *  Support Routines
 *
 *          bInitHandleTableManager
 *
 *              1]  Allocate memory for pW16ObjHndlSlotStatus and
 *                  piW32ToW16ObjectMap arrays.
 *
 *              2]  Initialize pW16ObjHndlSlotStatus and
 *                  piW32ToW16ObjectMap to empty and UNMAPPED respectively.
 *
 *              3]  Returns a TRUE if there were no problems with the
 *                  initialization, FALSE if anything went wrong.
 *
 *              4]  It is expected that this routie will be called once from
 *                  the entry level routine when translation is first started.
 *
 *          iNormalizeHandle
 *
 *              1]  The idea behind this routine is to isolate the handling
 *                  of stock object handles to one place.
 *
 *              2]  Input will be a Win32 handle index, either stock or a
 *                  standard object.
 *
 *              3]  Output will be the index of the entry in the
 *                  piW32ToW16ObjectMap table that corresponds to the W32
 *                  handle.  If an error is detected -1 is returned.
 *
 *              4]  All the stock objects will be between the range of 0
 *                  and LAST_STOCK, and all the non-stock objects will be
 *                  greater than LAST_STOCK.
 *
 *          iGetW16ObjectHandleSlot
 *
 *              1]  This routine searches the pW16ObjHndlSlotStatus array
 *                  looking for the first available open slot.
 *
 *              2]  Mark the slot found as to its intended use.
 *
 *              3]  Returns the first open slot if found, else return -1.
 *
 *              4]  In essence this routine mimics the actions of the
 *                  Win16 play-time handle allocation system, in either
 *                  Win3.0 or Win3.1
 *
 *              5]  We also keep track of the max object count here.
 *
 *          iAllocateW16Handle
 *
 *              1]  This routine actually does the handle allocation.
 *
 *              2]  It sets the entry in pW16ObjHndlSlotStatus array
 *                  for the slot allocated by iGetW16ObjectHandleSlot to
 *                  an "in-use" status (for the intended use).
 *
 *              3]  It returns a ihW16 (an index handle to the Win16 handle
 *                  table, aka the Win16 handle slot number).
 *
 *          iValidateHandle
 *
 *              1]  This routine does a lot more than validate a Win32 handle.
 *                  It does some limited error checking on the Win32 handle,
 *                  to make sure its within a reasonable range.  Then if a
 *                  Win16 handle table slot has already been allocated for
 *                  this Win32 handle it will return the Win16 handle that
 *                  was previously allocated.  Alternatively, if a Win16
 *                  handle has not been previously allocated for a Win32
 *                  STOCK handle it will allocate a W16 handle and return the
 *                  Win16 handle.  This function is called by FillRgn, FrameRgn
 *                  and SelectObject to allow lazy allocation of stock objects.
 *
 *              2]  Input is a Win32 handle, either a stock or a non-stock
 *                  handle.
 *
 *              3]  Output is a Win16 handle, this is the value in the
 *                  Win32-index of the piW32ToW16ObjectMap.  If a stock object
 *                  does not exist, it will create one.
 *
 *              4]  If there is an error a -1 is returned.
 *
 *      Doer Routines
 *
 *              All the Doers return a bool.  TRUE if everything went OK.
 *              FALSE if there were any problems.
 *
 *              NOTE: The Doers that create an object actually must do
 *              quite a bit of work to translate the object's prameters.
 *              This is in addition to managing the handle table.  The
 *              work outlined below just deals with the management of the
 *              handle table.
 *
 *          DoSelectObject
 *
 *              1]  For stock objects this is the workhorse routine.
 *
 *              2]  For normal, non-stock, objects this routine will verify
 *                  that an object has been created for this Win32 object-index.
 *                  Then it will emit a Win16SelectObject metafile record.
 *
 *              3]  For stock objects things get a little more complicated.
 *                  First this routine must make sure a Win16 object has been
 *                  created for this stock object.  If a Win16 object has not
 *                  been created yet, then it will be. After a Win16 object
 *                  is created a Win16SelectObject record will be emitted for
 *                  the object.
 *
 *          DoDeleteObject
 *
 *              1]  The object handle is checked for reasonable limits.
 *                  We will also make sure that the Win16 slot has a handle
 *                  allocated to it.  If it does not then we will return an
 *                  error.
 *
 *              2]  If this is a stock object we fail and return an error.
 *
 *              3]  If this is a non-stock object we emit a Win16DeleteObject
 *                  record.  Then we set pW16ObjHndlSlotStatus to
 *                  indicate that this slot is available.  We also set
 *                  piW32ToW16ObjectMap to -1 (UNMAPPED).
 *
 *          DoCreatePen
 *          DoExtCreatePen
 *          DoCreateBrushIndirect
 *          DoCreateMonoBrush
 *          DoCreateDIBPatternBrush
 *          DoExtCreateFont
 *
 *              1]  Make sure the Win32 handle is not already being used
 *                  for something else.  If it is return an error.
 *
 *              2]  Validate the handle for this Object.  This will return
 *                  a Win16 object table index (actually a slot number).
 *                  We really don't care what the slot number is as long
 *                  as we got one.  DoDeleteObject and DoSelectObject always
 *                  refer to handles by their Win32 object indicies, and there
 *                  is no place else where used.
 *
 *              3]  Emit a Win16CreateObject metafile record.
 *
 *
 *      Special Routines
 *
 *          bCommonRegionCode
 *          Need to list the bitblt routines that use handles also
 *
 *              1]  These routines just need to create objects in the Win16
 *                  metafile.  There are no corresponding objects in the Win32
 *                  metafile.
 *
 *              2]  Allocate a Win16 handle.
 *
 *              3]  Use the object as needed.  This includes emitting a
 *                  region or bitmap object into the Win16 metafile.
 *
 *              4]  De-allocate the object.  This include emitting a
 *                  DeleteObject record.
 *
 * CR1
 * Paths require the current pen to selected into the helperDC.
 * In order to keep track of create, select, & delete of the pen
 * object we will add an extra field to the W16ObjectHandleSlotStatus
 * array entries.  This new field will contain either a NULL handle
 * or a valid Win32 handle.  Currently only pens need to be selected
 * into the helper DC for paths, so they are the only objects whose
 * W32 handle field is not NULL.
 *
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define ABS(A)      ((A) < 0 ? (-(A)) : (A))

//  Stock objects                          Name              Stock
//                                                           Object
//                                                             ID

LOGBRUSH    albStock[] = {
    {BS_SOLID, 0x0FFFFFF, 0},           // White Brush          0
    {BS_SOLID, 0x0C0C0C0, 0},           // Ligh Grey Brush      1
    {BS_SOLID, 0x0808080, 0},           // Grey Brush           2
    {BS_SOLID, 0x0404040, 0},           // Dark Grey Brush      3
    {BS_SOLID, 0x0000000, 0},           // Black Brush          4
    {BS_HOLLOW, 0x0000000, 0}           // Hollow Brush         5
} ;

LOGPEN      alpnStock[] = {
    {PS_SOLID,  0, 0, 0x0FFFFFF},       // White Pen            6
    {PS_SOLID,  0, 0, 0x0000000},       // Black Pen            7
    {PS_NULL,   0, 0, 0x0FFFFFF}        // Null Pen             8
} ;

// Internal function prototypes.

BOOL bCreateStockObject(PLOCALDC pLocalDC, INT ihw32Norm) ;
BOOL bCreateStockFont(PLOCALDC pLocalDC, INT ihW32) ;

/***************************************************************************
 * bInitHandleTableManager - Init the Handle Table Manager.
 *
 *      1]  Allocate memory for pW16ObjHndlSlotStatus and
 *          piW32ToW16ObjectMap arrays.
 *
 *      2]  Initialize pW16ObjHndlSlotStatus and
 *          piW32ToW16ObjectMap to empty and UNMAPPED respectively.
 *
 *      3]  Returns a TRUE if there were no problems with the
 *          initialization, FALSE if anything went wrong.
 *
 *      4]  It is expected that this routie will be called once from
 *          the entry level routine when translation is first started.
 *
 **************************************************************************/
BOOL bInitHandleTableManager(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header)
{
BOOL    b ;
UINT    i ;

        b = FALSE ;

        // The total number of handles required will be the stock handles
        // plus the handles used by the Win32 metafile plus one extra
        // for temporary brush used in opaque rectangle in textout.

        pLocalDC->cW32ToW16ObjectMap = pmf32header->nHandles + (STOCK_LAST + 1) + 1;

        // Allocate storage for the translation map.

        i = pLocalDC->cW32ToW16ObjectMap * sizeof(INT) ;
        pLocalDC->piW32ToW16ObjectMap = (PINT) LocalAlloc(LMEM_FIXED, i) ;
        if (pLocalDC->piW32ToW16ObjectMap == NULL)
            goto error_exit ;

        // Initialize the W32 to W16 object map to UNMAPPED (-1).
        // Since we never will have mapping to -1 we can test for
        // -1 in the map to make sure we are not double allocating a slot.

        for (i = 0 ; i < pLocalDC->cW32ToW16ObjectMap ; i++)
            pLocalDC->piW32ToW16ObjectMap[i] = UNMAPPED ;

        // Allocate storage for the slot status tables.
        // The number of Win16 object table slot may expand during conversion
        // due to temporary bitmaps and regions.  It is my educated guess
        // that we will never need more than 5 extra slots, because we
        // only use a slot for a very short time, then free it.  We are
        // allocating 256 extra slots in the name of robustness.
    // Note that the multi-format comment record may take up some
    // of these slots and increase the high water mark for object index.
    // We need to expand the table when required.

        pLocalDC->cW16ObjHndlSlotStatus = pLocalDC->cW32ToW16ObjectMap + 256 ;
        if (pLocalDC->cW16ObjHndlSlotStatus > (UINT) (WORD) MAXWORD)
            goto error_exit ;       // w16 handle index is only 16-bit

        i = pLocalDC->cW16ObjHndlSlotStatus * sizeof(W16OBJHNDLSLOTSTATUS) ;
        pLocalDC->pW16ObjHndlSlotStatus
        = (PW16OBJHNDLSLOTSTATUS) LocalAlloc(LMEM_FIXED, i) ;
        if (pLocalDC->pW16ObjHndlSlotStatus == NULL)
            goto error_exit ;

        // Initialize the W16ObjectHandleSlotStatus to a state where every
        // handle is available.

        for (i = 0 ; i < pLocalDC->cW16ObjHndlSlotStatus ; i++)
        {
            pLocalDC->pW16ObjHndlSlotStatus[i].use       = OPEN_AVAILABLE_SLOT ;
            pLocalDC->pW16ObjHndlSlotStatus[i].w32Handle = 0 ;
        }

    // Initialize the pW32hPal palette handle table.
    // This table is used to store the W32 palette handles created during
    // the conversion.

        pLocalDC->cW32hPal = pmf32header->nHandles;
    i = pLocalDC->cW32hPal * sizeof(HPALETTE);
        pLocalDC->pW32hPal = (HPALETTE *) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, i) ;
    if (pLocalDC->pW32hPal == NULL)
            goto error_exit ;

    b = TRUE;

error_exit:
    if (!b)
    {
            if (pLocalDC->piW32ToW16ObjectMap)
        {
        if (LocalFree(pLocalDC->piW32ToW16ObjectMap))
            ASSERTGDI(FALSE, "MF3216: LocalFree failed");
                pLocalDC->piW32ToW16ObjectMap = (PINT) NULL;
        }

        if (pLocalDC->pW16ObjHndlSlotStatus)
        {
            if (LocalFree(pLocalDC->pW16ObjHndlSlotStatus))
                ASSERTGDI(FALSE, "MF3216: LocalFree failed");
            pLocalDC->pW16ObjHndlSlotStatus = NULL;
        }
    }

    return(b) ;
}


/***************************************************************************
 * bDeleteW16Object - Delete a W16 Object.
 *
 *  This is the routine that is called to Delete a W16 Object that has
 *  no corresponding W32 object.  Region and Bitmaps are two examples.
 **************************************************************************/
BOOL bDeleteW16Object(PLOCALDC pLocalDC, INT ihW16)
{
BOOL    b ;

    ASSERTGDI
    (
            pLocalDC->pW16ObjHndlSlotStatus[ihW16].use != OPEN_AVAILABLE_SLOT,
        "MF3216: bDeleteW16Object, bad use value"
    );

        // Mark the W16 Slot just freed as available.

        pLocalDC->pW16ObjHndlSlotStatus[ihW16].use = OPEN_AVAILABLE_SLOT ;

        // Emit a Win16 DeleteOject record for the Object

        b = bEmitWin16DeleteObject(pLocalDC, LOWORD(ihW16)) ;

        return (b) ;
}


/***************************************************************************
 * iGetW16ObjectHandleSlot - return the first W16 open slot in the handle
 *                           table.
 *
 *      1]  This routine searches the pW16ObjHndlSlotStatus array
 *          looking for the first available open slot.
 *
 *      2]  Mark the slot found as to its intended use.
 *
 *      3]  Returns the first open slot if found, else return -1.
 *
 *      4]  In essence this routine mimics the actions of the
 *          Win16 play-time handle allocation system, in either
 *          Win3.0 or Win3.1
 *
 *      5]  We also keep track of the max object count here.
 *
 **************************************************************************/
INT iGetW16ObjectHandleSlot(PLOCALDC pLocalDC, INT iIntendedUse)
{
BOOL    b ;
UINT    i ;

        b = FALSE ;

        // Search for an available slot.

        for (i = 0 ; i < pLocalDC->cW16ObjHndlSlotStatus ; i++)
        {
            if (pLocalDC->pW16ObjHndlSlotStatus[i].use == OPEN_AVAILABLE_SLOT)
            {
                b = TRUE ;
                break ;
            }
        }

        // If a slot was found then mark its intended use.
        // Also set the W32 handle that may be associated with this
        // W16 handle to NULL. (Meaning no association at this time.)

        if (b)
        {
            ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[i].w32Handle == 0,
        "MF3216: iGetW16ObjectHandleSlot: w32Handle is not 0");

            pLocalDC->pW16ObjHndlSlotStatus[i].use       = iIntendedUse ;
            pLocalDC->pW16ObjHndlSlotStatus[i].w32Handle = 0 ;

        // Update the number of object counts.  This will be used
        // when we update the metafile header.

            if ((INT) i >= pLocalDC->nObjectHighWaterMark)
                pLocalDC->nObjectHighWaterMark = (INT) i;

            return((INT) i);
        }
        else
        {
            RIP("MF3216: iGetW16ObjectHandleSlot, Slot not found\n") ;
            return(-1) ;
        }
}


/***************************************************************************
 * iNormalizeHandle
 *
 *  CR1 - this entire routine is part of the handle system redesign.
 *
 *     1]  The idea behind this routine is to isolate the handling
 *         of stock object handles to one place.
 *
 *     2]  Input will be a Win32 handle index, either stock or a
 *         standard object.
 *
 *     3]  Output will be the index of the entry in the
 *         piW32ToW16ObjectMap table that corresponds to the W32
 *         handle.  If an error is detected -1 is returned.
 *
 *     4]  All the stock objects will be between the range of 0
 *         and LAST_STOCK, and all the non-stock objects will be
 *         greater than LAST_STOCK.
 *
 **************************************************************************/
INT iNormalizeHandle(PLOCALDC pLocalDC, INT ihW32)
{
INT     ihW32Norm ;

        if (ihW32 & ENHMETA_STOCK_OBJECT)
        {
            ihW32Norm = ihW32 & ~ENHMETA_STOCK_OBJECT ;
            if ((UINT) ihW32Norm > STOCK_LAST)
            {
                RIP("MF3216: iNormalizeHandle, bad stock object\n") ;
                ihW32Norm = -1 ;
            }
        }
        else
        {
            ihW32Norm = ihW32 + STOCK_LAST + 1 ;
            if ((UINT) ihW32Norm >= pLocalDC->cW32ToW16ObjectMap)
            {
                RIP("MF3216: iNormalizeHandle, bad standard object\n") ;
                ihW32Norm = -1 ;
            }
        }

        return(ihW32Norm) ;
}


/***************************************************************************
 * iAllocateW16Handle
 *
 *  CR1 - this entire routine is part of the handle system redesign.
 *        It is to be called from the object creation routines.
 *
 *     1]  This routine actually does the handle allocation.
 *
 *     2]  It sets the entry in pW16ObjHndlSlotStatus array
 *         for the slot allocated by iGetW16ObjectHandleSlot to
 *         an "in-use" status (for the intended use).
 *
 *     3]  It returns a ihW16 (an index handle to the Win16 handle
 *         table, aka the Win16 handle slot number).
 *
 **************************************************************************/
INT iAllocateW16Handle(PLOCALDC pLocalDC, INT ihW32, INT iIntendedUse)
{
INT     ihW32Norm,
        ihW16 ;

        // Assume the worst, set up for a failed return code.

        ihW16 = -1 ;

        // Normalize the handle.

        ihW32Norm = iNormalizeHandle(pLocalDC, ihW32) ;
        if (ihW32Norm == -1)
            goto error_exit ;

        // Check for double allocation of a Win32 handle index.
        // If we find a double allocation, this would indicate an error
        // in the Win32 metafile.
        // Error out on this due to the possibility of
        // a brush being used for a bitmap, or some other wrong use of a handle.

        if (pLocalDC->piW32ToW16ObjectMap[ihW32Norm] != UNMAPPED)
        {
            RIP("MF3216: iAllocateW16Handle, Double W32 handle allocation detected\n") ;
            goto error_exit ;
        }

        // Get a slot in the Win16 handle table.

        ihW16 = iGetW16ObjectHandleSlot(pLocalDC, iIntendedUse) ;
        if (ihW16 == -1)
            goto error_exit ;

        // Set the W32 to W16 slot mapping

        pLocalDC->piW32ToW16ObjectMap[ihW32Norm] = ihW16 ;

error_exit:
        return(ihW16) ;
}

/***************************************************************************
 * iValidateHandle
 *
 *  CR1 - this entire routine is part of the handle system redesign.
 *
 *     1]  This routine does a lot more than validate a Win32 handle.
 *         It does some limited error checking on the Win32 handle,
 *         to make sure its within a reasonable range.  Then if a
 *         Win16 handle table slot has already been allocated for
 *         this Win32 handle it will return the Win16 handle that
 *         was previously allocated.  Alternatively, if a Win16
 *         handle has not been previously allocated for a Win32
 *         STOCK handle it will allocate a W16 handle and return the
 *         Win16 handle.  This function is called by FillRgn, FrameRgn
 *         and SelectObject to allow lazy allocation of stock objects.
 *
 *     2]  Input is a Win32 handle, either a stock or a non-stock
 *         handle.
 *
 *     3]  Output is a Win16 handle, this is the value in the
 *         Win32-index of the piW32ToW16ObjectMap.  If a stock object
 *         does not exist, it will create one.
 *
 *     4]  If there is an error a -1 is returned.
 **************************************************************************/
INT iValidateHandle(PLOCALDC pLocalDC, INT ihW32)
{
INT     ihW32Norm,
        ihW16 ;

        // Assume the worst.

        ihW16 = -1 ;

        // NOTE: Normalizing the W32 handles takes care of checking
        // for a reasonable W32 handle value.

        ihW32Norm = iNormalizeHandle(pLocalDC, ihW32) ;
        if (ihW32Norm == -1)
            goto error_exit ;

        // Check the W32ToW16 map, to determine if this W32 handle has
        // already been allocated a W16 slot.

        ihW16 = pLocalDC->piW32ToW16ObjectMap[ihW32Norm] ;
        if (ihW16 == UNMAPPED)
        {
            // There is no mapping from W32 to W16.  This implies
            // that the object in question does not exist.  If this is
            // a stock object, then we will create the object at this time.
            // Alternatively, if this is a non-stock object then we have an
            // error condition.

            if ((DWORD) ihW32Norm <= STOCK_LAST)
            {
                if (bCreateStockObject(pLocalDC, ihW32))
                    ihW16 = pLocalDC->piW32ToW16ObjectMap[ihW32Norm] ;
        else
            ihW16 = -1 ;
            }
            else
            {
                RIP("MF3216: iValidateHandle - Unmapped Standard Object\n") ;
            ihW16 = -1 ;
            }
        }

error_exit:
        return (ihW16) ;
}


/***************************************************************************
 *  DoDeleteObject  - Win32 to Win16 Metafile Converter Entry Point
 *
 *  CR1 - Most of this routine was rewritten to conform to the new
 *        objects management system.
 *
 *      1]  The object handle is checked for reasonable limits.
 *          We will also make sure that the Win16 slot has a handle
 *          allocated to it.  If it does not then we will return an
 *          error.
 *
 *      2]  If this is a stock object we fail and return an error.
 *
 *      3]  If this is a non-stock object we emit a Win16DeleteObject
 *          record.  Then we set pW16ObjHndlSlotStatus to
 *          indicate that this slot is available.  We also set
 *          piW32ToW16ObjectMap to -1 (UNMAPPED).
 **************************************************************************/
BOOL WINAPI DoDeleteObject
(
PLOCALDC pLocalDC,
INT    ihObject
)
{
BOOL    b ;
INT     ihW16,
        ihW32Norm;

        // Assume the worst.

        b = FALSE ;

        // Normalize the W32 handle.

        ihW32Norm = iNormalizeHandle(pLocalDC, ihObject) ;
        if (ihW32Norm == -1)
            goto error_exit ;

        // Make sure we're not deleting a stock object.

        if ((DWORD) ihW32Norm <= STOCK_LAST)
        {
            PUTS("MF3216: DoDeleteObject, attempt to delete a stock object\n") ;
            return(TRUE);
        }

        // If this is a palette, then we do not delete the win16 object.
        // We do delete our local version of the palette.

    if (pLocalDC->pW32hPal && pLocalDC->pW32hPal[ihObject])
        {
        b = DeleteObject(pLocalDC->pW32hPal[ihObject]);
        pLocalDC->pW32hPal[ihObject] = 0;

            if (b == FALSE)
                RIP("MF3216: DoDeleteObject - DeleteObject (hPalette) failed\n") ;
            return (b) ;
        }

        // Map the ihW32 to a ihW16 (object handle table slot).

        ihW16 = pLocalDC->piW32ToW16ObjectMap[ihW32Norm] ;
        if (ihW16 == UNMAPPED)
        {
            RIP("MF3216: DoDeleteObject, attempt to delete a non-existent object\n");
            goto error_exit ;
        }

        // Make sure the object is one that we expect.
    // There is no region object or bitmap object in the enhanced metafiles.

        ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_BRUSH
           || pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_PEN
           || pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_FONT,
                 "MF3216: DoDeleteObject, Invalid Object Deletion\n") ;

        // If there was a Win32 handle associated with this Win16 handle
        // then the w32Handle field of the W16ObjHndlSlotStatus[ihW16]
        // entry in the handle slot status array will be non-null. If
        // it is non-null then we should delete the Win32 handle at this time.

        if (pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle != 0)
        {
            if (!DeleteObject(pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle))
        {
            ASSERTGDI(FALSE, "MF3216: DoDeleteObject, DeleteObject failed");
        }
            pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle = 0 ;
        }

        // Mark the slot as available.
        // And set the map entry for the W32ToW16 map to unmapped.

        pLocalDC->pW16ObjHndlSlotStatus[ihW16].use = OPEN_AVAILABLE_SLOT ;
        pLocalDC->piW32ToW16ObjectMap[ihW32Norm]   = UNMAPPED ;

        // Emit the delete drawing order.

        b = bEmitWin16DeleteObject(pLocalDC, LOWORD(ihW16)) ;

error_exit:
        return (b) ;
}

/***************************************************************************
 *  DoSelectObject  - Win32 to Win16 Metafile Converter Entry Point
 *
 *  CR1 - Major rewrite due to handle system redesign.
 *
 *  DoSelectObject
 *
 *      1]  For stock objects this is the workhorse routine.
 *
 *      2]  For normal, non-stock, objects this routine will verify
 *          that an object has been created for this Win32 object-index.
 *          Then it will emit a Win16SelectObject metafile record.
 *
 *      3]  For stock objects things get a little more complicated.
 *          First this routine must make sure a Win16 object has been
 *          created for this stock object.  If a Win16 object has not
 *          been created yet, then it will be. After a Win16 object
 *          is created a Win16SelectObject record will be emitted for
 *          the object.
 **************************************************************************/
BOOL WINAPI DoSelectObject
(
PLOCALDC pLocalDC,
LONG   ihObject
)
{
BOOL    b ;
INT     ihW16;

        // Assume the worst.

        b = FALSE ;

        // Make sure that the W16 object exists before we emit the
    // SelectObject record.  Stock objects may not have been created
    // and iValidateHandle will take care of creating them.

        ihW16 = iValidateHandle(pLocalDC, ihObject) ;
        if (ihW16 == -1)
            goto error_exit ;

        // Make sure the object is one that we expect.
    // There is no region object or bitmap object in the enhanced metafiles.

        ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_BRUSH
           || pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_PEN
           || pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_FONT,
                 "MF3216: DoSelectObject, Invalid Object Deletion\n") ;

    // Remember the currently selected pen.  This is used in path and text.

    if (pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_PEN)
        pLocalDC->lhpn32 = ihObject;

    // Remember the currently selected brush.  This is used in text.

    if (pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_BRUSH)
        pLocalDC->lhbr32 = ihObject;

        // If there was a Win32 handle associated with this Win16 handle
        // then the w32Handle field of the W16ObjHndlSlotStatus[ihW16]
        // entry in the handle slot status array will be non-null. If
        // it is non-null then we should select the W32 object into the
        // helper DC at this time.

        if (pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle != 0)
            SelectObject(pLocalDC->hdcHelper,
             pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle) ;

        b = bEmitWin16SelectObject(pLocalDC, LOWORD(ihW16)) ;

error_exit:
        return(b) ;
}


/***************************************************************************
 * bCreateStockObject
 **************************************************************************/
BOOL bCreateStockObject(PLOCALDC pLocalDC, INT ihW32)
{
BOOL        b ;
INT         i ;

        ASSERTGDI((ihW32 & ENHMETA_STOCK_OBJECT) != 0,
        "MF3216: bCreateStockObject, invalid stock handle");

        switch (ihW32 & ~ENHMETA_STOCK_OBJECT)
        {
            case WHITE_BRUSH:
            case LTGRAY_BRUSH:
            case GRAY_BRUSH:
            case DKGRAY_BRUSH:
            case BLACK_BRUSH:
            case NULL_BRUSH:
                b = DoCreateBrushIndirect(pLocalDC, ihW32, &albStock[ihW32 & ~ENHMETA_STOCK_OBJECT]) ;
                break ;

            case WHITE_PEN:
            case BLACK_PEN:
            case NULL_PEN:
                i = (ihW32 & ~ENHMETA_STOCK_OBJECT) - WHITE_PEN ;
                b = DoCreatePen(pLocalDC, ihW32, (PLOGPEN) &alpnStock[i]) ;
                break ;


            case OEM_FIXED_FONT:
            case ANSI_FIXED_FONT:
            case ANSI_VAR_FONT:
            case SYSTEM_FONT:
            case DEVICE_DEFAULT_FONT:
            case SYSTEM_FIXED_FONT:
                b = bCreateStockFont(pLocalDC, ihW32) ;
                break ;

            case DEFAULT_PALETTE:
            default:
        // Logical palettes are handled in DoSelectPalette and should
        // not get here.

                RIP("MF3216: bCreateStockObject - Invalid Stock Object\n") ;
                b =FALSE ;
                break ;
        }

        return (b) ;
}


/***************************************************************************
 * bCreateStockFont
 **************************************************************************/
BOOL bCreateStockFont(PLOCALDC pLocalDC, INT ihW32)
{
BOOL     b ;
INT      i ;
LOGFONTW LogFontW ;
HANDLE   hFont ;

        b = FALSE ;

        ASSERTGDI((ihW32 & ENHMETA_STOCK_OBJECT) != 0,
        "MF3216: bCreateStockObject, invalid stock handle");

        // Get a handle to this logfont.

        hFont = GetStockObject(ihW32 & ~ENHMETA_STOCK_OBJECT) ;
        if (hFont == (HANDLE) 0)
        {
            RIP("MF3216: bCreateStockFont, GetStockObject (font) failed\n") ;
            goto error_exit ;
        }

        // Get the logfont data.  Assume we get at least one char in the
    // facename string.

        i = GetObjectW(hFont, sizeof(LOGFONTW), &LogFontW) ;
        if (i <= (INT) offsetof(LOGFONTW,lfFaceName[0]))
        {
            PUTS("MF3216: bCreateStockFont - GetObjectW failed\n") ;
            goto error_exit ;
        }

    // Zero out the remaining logfont structure.

    for ( ; i < sizeof(LOGFONTW); i++)
        ((PBYTE) &LogFontW)[i] = 0;

        // Create a LogFont for this stock font in the Win16 metafile.

        b = DoExtCreateFont(pLocalDC,
                            ihW32,
                            &LogFontW);
error_exit:
        return (b) ;
}


/***************************************************************************
 *  CreateBrushIndirect  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoCreateBrushIndirect
(
PLOCALDC    pLocalDC,
INT         ihBrush,
LPLOGBRUSH  lpLogBrush
)
{
WIN16LOGBRUSH Win16LogBrush ;
BOOL          b ;
INT           ihW16 ;
LOGBRUSH      LogBrush ;

        b = FALSE ;

// Only 3 brush styles are allowed.

    if (lpLogBrush->lbStyle != BS_SOLID
     && lpLogBrush->lbStyle != BS_HATCHED
     && lpLogBrush->lbStyle != BS_HOLLOW)
            goto error_exit ;

// Make a copy of the logical brush.

        LogBrush = *lpLogBrush;

// The first 6 hatched styles map directly from Win32 to Win16.
// The remaining hatched brushes are simulated using DIB pattern
// brushes.  Note that the background color of a hatched brush
// is the current background color but that of a DIB pattern brush
// is given at create time!  We will use the current background color
// in the DIB pattern brush when it is created.  As a result, the
// output of these brushes may look different!

        if (LogBrush.lbStyle == BS_HATCHED)
        {
        switch (LogBrush.lbHatch)
        {
        case HS_HORIZONTAL:
        case HS_VERTICAL:
        case HS_FDIAGONAL:
        case HS_BDIAGONAL:
        case HS_CROSS:
        case HS_DIAGCROSS:
                break;

        default:
                RIP("MF3216: Unknown hatched pattern\n");
        LogBrush.lbStyle = BS_SOLID;
        break;
        }
        }

// Allocate the W16 handle.

        ihW16 = iAllocateW16Handle(pLocalDC, ihBrush, REALIZED_BRUSH);
        if (ihW16 == -1)
            goto error_exit ;

// Create the w32 brush and store it in the w16 slot table.
// This brush is needed by the helper DC for BitBlt simulations.

        pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle
        = CreateBrushIndirect(lpLogBrush) ;

        ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle != 0,
        "MF3216: CreateBrushIndirect failed");

// Assign all the Win32 brush attributes to Win16 brush attributes.

        Win16LogBrush.lbStyle = (WORD) LogBrush.lbStyle ;
        Win16LogBrush.lbColor = LogBrush.lbColor ;
        Win16LogBrush.lbHatch = (SHORT) LogBrush.lbHatch ;

// Call the Win16 routine to emit the brush to the metafile.

        b = bEmitWin16CreateBrushIndirect(pLocalDC, &Win16LogBrush) ;

error_exit:
        return(b) ;
}


/******************************Public*Routine******************************\
* CreateMonoDib
*
* This is the same as CreateBitmap except that the bits are assumed
* to be DWORD aligned and that the scans start from the bottom of the bitmap.
*
* This routine is temporary until CreateDIBitmap supports monochrome bitmaps
*
* History:
*  Wed Jul 01 11:02:24 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

HBITMAP CreateMonoDib
(
    LPBITMAPINFO pbmi,
    CONST BYTE * pjBits,
    UINT     iUsage
)
{
    HBITMAP hbm;

    ASSERTGDI(pbmi->bmiHeader.biPlanes == 1, "CreateMonoDib: bad biPlanes value");
    ASSERTGDI(pbmi->bmiHeader.biBitCount == 1, "CreateMonoDib: bad biBitCount value");

    hbm = CreateBitmap((int)  pbmi->bmiHeader.biWidth,
               (int)  pbmi->bmiHeader.biHeight,
               (UINT) 1,
               (UINT) 1,
               (CONST VOID *) NULL);
    if (!hbm)
    return(hbm);

    SetDIBits((HDC) 0, hbm, 0, (UINT) pbmi->bmiHeader.biHeight,
          (CONST VOID *) pjBits, pbmi, iUsage);

    return(hbm);
}


/***************************************************************************
 *  CreateMonoBrush  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoCreateMonoBrush
(
PLOCALDC    pLocalDC,
DWORD       ihBrush,
PBITMAPINFO pBitmapInfo,
DWORD       cbBitmapInfo,
PBYTE       pBits,
DWORD       cbBits,
DWORD       iUsage
)
{
BOOL        b ;
INT         ihW16;
DWORD       ul ;
BYTE        pbmi[sizeof(BITMAPINFOHEADER) + 2 * sizeof(RGBQUAD)];
HBITMAP     hbm;

        b = FALSE ;

// Need to make a copy of the bitmap info header,  for a few reasons
//  1] the memory mapped file is write protected.
//  2] the iUsage may be (is) use palatte indicies, and we need
//     use RGB colors.

        ((PBITMAPINFO) pbmi)->bmiHeader = pBitmapInfo->bmiHeader;

// Need to make sure the iUsage is DIB_RGB_COLORS
// and the palette is initialized to Black and White.

        ul = 0 ;
        ((PBITMAPINFO) pbmi)->bmiColors[0] = (*((RGBQUAD *) &(ul))) ;

        ul = 0x00ffffff ;
        ((PBITMAPINFO) pbmi)->bmiColors[1] = (*((RGBQUAD *) &(ul))) ;

// Allocate the W16 handle.

        ihW16 = iAllocateW16Handle(pLocalDC, ihBrush, REALIZED_BRUSH);
        if (ihW16 == -1)
            goto error_exit ;

// Create the w32 brush and store it in the w16 slot table.
// This brush is needed by the helper DC for BitBlt simulations.

    if ((hbm = CreateMonoDib
           (
               pBitmapInfo,
               (CONST BYTE *) pBits,
               (UINT) iUsage
           )
        )
       )
    {
        pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle
        = CreatePatternBrush(hbm);

        if (!DeleteObject(hbm))
        ASSERTGDI(FALSE, "MF3216: DoCreateMonoBrush, DeleteObject failed");
    }

        ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle != 0,
        "MF3216: CreatePatternBrush failed");

// Call the Win16 routine to emit the brush to the metafile.

        b = bEmitWin16CreateDIBPatternBrush(pLocalDC,
                                        (PBITMAPINFO) pbmi,
                                        sizeof(pbmi),
                                        pBits,
                                        cbBits,
                                        (WORD) DIB_RGB_COLORS,
                                        (WORD) BS_PATTERN  // Mono brush!
                       ) ;
error_exit:
        return(b) ;
}

/***************************************************************************
 *  CreateDIPatternBrush  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoCreateDIBPatternBrush
(
PLOCALDC    pLocalDC,
DWORD       ihBrush,
PBITMAPINFO pBitmapInfo,
DWORD       cbBitmapInfo,
PBYTE       pBits,
DWORD       cbBits,
DWORD       iUsage
)
{
BOOL    b;
INT     ihW16;
HBITMAP hbm;
PBYTE   pBits24;
DWORD   cbBits24;
BITMAPINFOHEADER bmih;

    hbm = (HBITMAP) 0;
    pBits24 = (PBYTE) NULL;
        b = FALSE ;

// Allocate the W16 handle.

        ihW16 = iAllocateW16Handle(pLocalDC, ihBrush, REALIZED_BRUSH);
        if (ihW16 == -1)
            goto error_exit ;

// Create the w32 brush and store it in the w16 slot table.
// We assume that the bitmap info is followed by the bits immediately,
// i.e. it is a packed dib.
// This brush is needed by the helper DC for BitBlt simulations.

        pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle
        = CreateDIBPatternBrushPt((LPVOID) pBitmapInfo, (UINT) iUsage);

        ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle != 0,
        "MF3216: CreateDIBPatternBrushPt failed");

// We need to convert new bitmap info formats to the win3 formats.

    if (pBitmapInfo->bmiHeader.biPlanes != 1
     || pBitmapInfo->bmiHeader.biBitCount == 16
     || pBitmapInfo->bmiHeader.biBitCount == 32)
    {
        if (!(hbm = CreateDIBitmap(pLocalDC->hdcHelper,
                (LPBITMAPINFOHEADER) pBitmapInfo,
                CBM_INIT | CBM_CREATEDIB,
                pBits,
                (LPBITMAPINFO) pBitmapInfo,
                (UINT) iUsage)))
                goto error_exit ;

        bmih = *(PBITMAPINFOHEADER) pBitmapInfo;
        bmih.biPlanes       = 1;
        bmih.biBitCount     = 24;
        bmih.biCompression  = BI_RGB;
        bmih.biSizeImage    = 0;
        bmih.biClrUsed      = 0;
        bmih.biClrImportant = 0;

            cbBits24 = CJSCAN(bmih.biWidth,bmih.biPlanes,bmih.biBitCount)
                * ABS(bmih.biHeight);

        pBits24 = (LPBYTE) LocalAlloc(LMEM_FIXED, cbBits24);
        if (pBits24 == (LPBYTE) NULL)
            goto error_exit;

        // Get bitmap info and bits in 24bpp.

        if (!GetDIBits(pLocalDC->hdcHelper,
               hbm,
               0,
               (UINT) bmih.biHeight,
               pBits24,
               (LPBITMAPINFO) &bmih,
               DIB_RGB_COLORS))
            goto error_exit;

            b = bEmitWin16CreateDIBPatternBrush(pLocalDC,
                                        (PBITMAPINFO) &bmih,
                                        sizeof(bmih),
                                        pBits24,
                                        cbBits24,
                                        (WORD) DIB_RGB_COLORS,
                                        (WORD) BS_DIBPATTERN
                       ) ;
    }
    else
    {

// Call the Win16 routine to emit the brush to the metafile.

            b = bEmitWin16CreateDIBPatternBrush(pLocalDC,
                                        pBitmapInfo,
                                        cbBitmapInfo,
                                        pBits,
                                        cbBits,
                                        (WORD) iUsage,
                                        (WORD) BS_DIBPATTERN
                       ) ;
    }

error_exit:
    if (hbm)
        DeleteObject(hbm);
    if (pBits24)
        LocalFree((HANDLE) pBits24);
        return(b) ;
}


/***************************************************************************
 * CreatePen  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoCreatePen
(
PLOCALDC    pLocalDC,
INT         ihPen,
PLOGPEN     pLogPen
)
{
EXTLOGPEN   ExtLogPen ;
BOOL        b ;

        ExtLogPen.elpPenStyle   = PS_GEOMETRIC | pLogPen->lopnStyle ;
        ExtLogPen.elpWidth      = (UINT) pLogPen->lopnWidth.x ;
        ExtLogPen.elpBrushStyle = BS_SOLID ;
        ExtLogPen.elpColor      = pLogPen->lopnColor ;
        ExtLogPen.elpNumEntries = 0 ;
        // ExtLogPen.elpHatch   = 0 ;
        // ExtLogPen.elpStyleEntry[0] = 0;

        b = DoExtCreatePen(pLocalDC, ihPen, &ExtLogPen) ;

        return (b) ;
}

/***************************************************************************
 *  ExtCreatePen  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoExtCreatePen
(
PLOCALDC    pLocalDC,
INT         ihPen,
PEXTLOGPEN  pExtLogPen
)
{
BOOL        b ;
WORD        iStyle ;
POINTS      ptsWidth ;
INT         ihW16 ;
UINT        iPenStyle ;
POINTL      ptlWidth ;
COLORREF    crColor ;

    b = FALSE;

    // Get pen style.

        iPenStyle = pExtLogPen->elpPenStyle & PS_STYLE_MASK ;
        switch(iPenStyle)
        {
            case PS_SOLID:
            case PS_DASH:
            case PS_DOT:
            case PS_DASHDOT:
            case PS_DASHDOTDOT:
            case PS_NULL:
            case PS_INSIDEFRAME:
                break ;

            case PS_ALTERNATE:
                iPenStyle = PS_DOT ;
                break ;

            case PS_USERSTYLE:
            default:
                // CR1: default to solid.
                iPenStyle = PS_SOLID ;
                break ;
        }

    // Get pen color.

        switch (pExtLogPen->elpBrushStyle)
        {
        case BS_SOLID:
        case BS_HATCHED:
            crColor   = pExtLogPen->elpColor ;
        break;

        // If the extended pen contains a hollow brush, then
        // we will emit a NULL pen.
        case BS_NULL:    // BS_HOLLOW is the same as BS_NULL
            iPenStyle = PS_NULL ;
            crColor   = 0 ;
        break;

        // Win3.x does not support pens with bitmap patterns.
        // So we will just use solid pens here.  Since we do not
        // know what pen color to use, we choose the text color.
        case BS_PATTERN:
        case BS_DIBPATTERN:
        case BS_DIBPATTERNPT:
            default:
            crColor   =  pLocalDC->crTextColor ;
        break;
        }

    // Get pen width.
    // If this is a cosmetic pen then the width is 0.

        ptlWidth.y = 0 ;
        if ((pExtLogPen->elpPenStyle & PS_TYPE_MASK) == PS_COSMETIC)
            ptlWidth.x = 0 ;
        else
            ptlWidth.x = pExtLogPen->elpWidth ;

    // Allocate the W16 handle.

        ihW16 = iAllocateW16Handle(pLocalDC, ihPen, REALIZED_PEN);
        if (ihW16 == -1)
            goto error_exit ;

        // This is where we need to create a pen for helper DC.
        // We do not select it into the helper DC at this time.

        pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle
        = CreatePen((int) iPenStyle, ptlWidth.x, crColor) ;

        ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle != 0,
        "MF3216: DoExtCreatePen, CreatePen failed");

    // Get pen width in play time page units.

        ptlWidth.x = (LONG) iMagnitudeXform(pLocalDC, (INT) ptlWidth.x, CX_MAG);

        // Set the Win16 pen attributes

        iStyle     = (WORD) iPenStyle  ;
        ptsWidth.x = (WORD) ptlWidth.x ;
        ptsWidth.y = (WORD) ptlWidth.y ;

        // Call the Win16 routine to emit the pen to the metafile.

        b = bEmitWin16CreatePen(pLocalDC, iStyle, &ptsWidth, crColor) ;

error_exit:
        return(b) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\mf3216\win16api.c ===
/****************************************************************************
 *
 *  Win16 Metafile emitter routines
 *
 *  Date:   7/19/91
 *  Author: Jeffrey Newman (c-jeffn)
 *
 ***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/****************************************************************************
 * bW16Emit0 - This is the base routine to emit a Win16 drawing order
 *             with 0 parameters.
 ***************************************************************************/
BOOL bW16Emit0
(
PLOCALDC   pLocalDC,
WORD       RecordID
)
{
BOOL	    b;
METARECORD0 mr;

	mr.rdSize     = sizeof(mr) / sizeof(WORD);
	mr.rdFunction = RecordID;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * bW16Emit1 - This is the base routine to emit a Win16 drawing order
 *             with 1 parameter.
 ***************************************************************************/
BOOL bW16Emit1
(
PLOCALDC   pLocalDC,
WORD       RecordID,
WORD       x1
)
{
BOOL	    b;
METARECORD1 mr;

	mr.rdSize     = sizeof(mr) / sizeof(WORD);
	mr.rdFunction = RecordID;
	mr.rdParm[0]  = x1;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * bW16Emit2 - This is the base routine to emit a Win16 drawing order
 *             with 2 parameters.
 ***************************************************************************/
BOOL bW16Emit2
(
PLOCALDC   pLocalDC,
WORD       RecordID,
WORD       x1,
WORD       x2
)
{
BOOL	    b;
METARECORD2 mr;

	mr.rdSize     = sizeof(mr) / sizeof(WORD);
	mr.rdFunction = RecordID;
	mr.rdParm[0]  = x2;
	mr.rdParm[1]  = x1;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * bW16Emit4 - This is the base routine to emit a Win16 drawing order
 *             with 4 parameters.
 ***************************************************************************/
BOOL bW16Emit4
(
PLOCALDC   pLocalDC,
WORD       RecordID,
WORD       x1,
WORD       x2,
WORD       x3,
WORD       x4
)
{
BOOL	    b;
METARECORD4 mr;

	mr.rdSize     = sizeof(mr) / sizeof(WORD);
	mr.rdFunction = RecordID;
	mr.rdParm[0]  = x4;
	mr.rdParm[1]  = x3;
	mr.rdParm[2]  = x2;
	mr.rdParm[3]  = x1;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * bW16Emit5 - This is the base routine to emit a Win16 drawing order
 *             with 5 parameters.
 ***************************************************************************/
BOOL bW16Emit5
(
PLOCALDC   pLocalDC,
WORD       RecordID,
WORD       x1,
WORD       x2,
WORD       x3,
WORD       x4,
WORD       x5
)
{
BOOL	    b;
METARECORD5 mr;

	mr.rdSize     = sizeof(mr) / sizeof(WORD);
	mr.rdFunction = RecordID;
	mr.rdParm[0]  = x5;
	mr.rdParm[1]  = x4;
	mr.rdParm[2]  = x3;
	mr.rdParm[3]  = x2;
	mr.rdParm[4]  = x1;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * bW16Emit6 - This is the base routine to emit a Win16 drawing order
 *             with 6 parameters.
 ***************************************************************************/
BOOL bW16Emit6
(
PLOCALDC   pLocalDC,
WORD       RecordID,
WORD       x1,
WORD       x2,
WORD       x3,
WORD       x4,
WORD       x5,
WORD       x6
)
{
BOOL	    b;
METARECORD6 mr;

	mr.rdSize     = sizeof(mr) / sizeof(WORD);
	mr.rdFunction = RecordID;
	mr.rdParm[0]  = x6;
	mr.rdParm[1]  = x5;
	mr.rdParm[2]  = x4;
	mr.rdParm[3]  = x3;
	mr.rdParm[4]  = x2;
	mr.rdParm[5]  = x1;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * bW16Emit8 - This is the base routine to emit a Win16 drawing order
 *             with 8 parameters.
 ***************************************************************************/
BOOL bW16Emit8
(
PLOCALDC   pLocalDC,
WORD       RecordID,
WORD       x1,
WORD       x2,
WORD       x3,
WORD       x4,
WORD       x5,
WORD       x6,
WORD       x7,
WORD       x8
)
{
BOOL	    b;
METARECORD8 mr;

	mr.rdSize     = sizeof(mr) / sizeof(WORD);
	mr.rdFunction = RecordID;
	mr.rdParm[0]  = x8;
	mr.rdParm[1]  = x7;
	mr.rdParm[2]  = x6;
	mr.rdParm[3]  = x5;
	mr.rdParm[4]  = x4;
	mr.rdParm[5]  = x3;
	mr.rdParm[6]  = x2;
	mr.rdParm[7]  = x1;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * bW16Emit9 - This is the base routine to emit a Win16 drawing order
 *             with 9 parameters.
 ***************************************************************************/
BOOL bW16Emit9
(
PLOCALDC   pLocalDC,
WORD       RecordID,
WORD       x1,
WORD       x2,
WORD       x3,
WORD       x4,
WORD       x5,
WORD       x6,
WORD       x7,
WORD       x8,
WORD       x9
)
{
BOOL	    b;
METARECORD9 mr;

	mr.rdSize     = sizeof(mr) / sizeof(WORD);
	mr.rdFunction = RecordID;
	mr.rdParm[0]  = x9;
	mr.rdParm[1]  = x8;
	mr.rdParm[2]  = x7;
	mr.rdParm[3]  = x6;
	mr.rdParm[4]  = x5;
	mr.rdParm[5]  = x4;
	mr.rdParm[6]  = x3;
	mr.rdParm[7]  = x2;
	mr.rdParm[8]  = x1;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * CreateFontIndirect - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16CreateFontIndirect
(
PLOCALDC       pLocalDC,
LPWIN16LOGFONT lpWin16LogFont
)
{
BOOL	b;
METARECORD_CREATEFONTINDIRECT mr;

	mr.rdSize     = sizeof(mr) / sizeof(WORD);
	mr.rdFunction = META_CREATEFONTINDIRECT;
	mr.lf16       = *lpWin16LogFont;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * Polyline/Polygon - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16Poly
(
PLOCALDC pLocalDC,
LPPOINTS ppt,
SHORT    cpt,
WORD     metaType
)
{
BOOL	b ;
WORD    nSize ;
METARECORD_POLY mr;

        // Caculate the size of the points array

        nSize = (WORD) (cpt * sizeof(POINTS));

        // Build up the header of the Win16 poly record

	mr.rdSize     = (sizeof(mr) + nSize) / sizeof(WORD);
	mr.rdFunction = metaType;
	mr.cpt        = cpt;

        // Emit the Header, then if it succeds emit the points.

        b = bEmit(pLocalDC, &mr, sizeof(mr));
        if (b)
        {
            b = bEmit(pLocalDC, ppt, nSize);
        }

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * PolyPolygon - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16PolyPolygon
(
PLOCALDC pLocalDC,
PPOINTS  ppt,
PWORD    pcpt,
WORD     cpt,
WORD     ccpt
)
{
BOOL	b ;
WORD    nSize ;
METARECORD_POLYPOLYGON mr;

        nSize  = cpt * sizeof(POINTS);
        nSize += ccpt * sizeof(WORD);
        nSize += sizeof(mr);

        // Build up the header of the Win16 polyline record

	mr.rdSize     = nSize / sizeof(WORD);
	mr.rdFunction = META_POLYPOLYGON;
	mr.ccpt       = ccpt;

        // Emit the Header, then if it succeds emit the Point counts,
        // then if it succeds emit the points.

        b = bEmit(pLocalDC, &mr, sizeof(mr));
        if (b)
        {
            b = bEmit(pLocalDC, pcpt, ccpt * sizeof(WORD));
            if (b)
            {
                b = bEmit(pLocalDC, ppt, cpt * sizeof(POINTS));
            }

        }

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * StretchBlt - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16StretchBlt
(
  PLOCALDC pLocalDC,
  SHORT    x,
  SHORT    y,
  SHORT    cx,
  SHORT    cy,
  SHORT    xSrc,
  SHORT    ySrc,
  SHORT    cxSrc,
  SHORT    cySrc,
  DWORD    rop,
  PBITMAPINFO lpbmi,
  DWORD       cbbmi,
  PBYTE    lpBits,
  DWORD    cbBits
)
{
BOOL	b ;
DWORD   nSize ;
METARECORD_DIBSTRETCHBLT mr;

        // Need to make real sure the plane count is 1,
        // otherwise this is not a DIB.

        if (lpbmi->bmiHeader.biPlanes != 1)
        {
            RIP("MF3216: bEmitWin16StretchBlt, Invalid biPlanes in DIB\n") ;
            return (FALSE) ;
        }

        // Create the static portion of the
        // Win 3.0 StretchBlt metafile record.

	nSize = sizeof(mr) + cbbmi + cbBits;

	mr.rdSize     = nSize / sizeof(WORD);
	mr.rdFunction = META_DIBSTRETCHBLT;
	mr.rop        = rop;
	mr.cySrc      = cySrc;
	mr.cxSrc      = cxSrc;
	mr.ySrc       = ySrc;
	mr.xSrc       = xSrc;
	mr.cy         = cy;
	mr.cx         = cx;
	mr.y          = y;
	mr.x          = x;

        b = bEmit(pLocalDC, &mr, sizeof(mr));
        if (b)
	{
	    // Emit the bitmap info

            b = bEmit(pLocalDC, lpbmi, cbbmi);
	    if (b)
	    {
	        // Emit the actual bits, if any.

                b = bEmit(pLocalDC, lpBits, cbBits);
	    }
	}

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * ExtTextOut - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16ExtTextOut
(
PLOCALDC pLocalDC,
SHORT    x,
SHORT    y,
WORD     fwOpts,
PRECTS   prcts,
PSTR     ach,
SHORT    nCount,
PWORD    lpDx
)
{
BOOL	b ;
DWORD   i, nBaseRecord ;
WORD    awRecord[11] ;


        // Calculate the size of the record

        i = ((WORD) nCount + 1) / 2 * 2;   // i = size of string in bytes
	if (lpDx)
            i += (WORD) nCount * sizeof(WORD); // add in size of Dx vector
        i += sizeof(awRecord);             // add in size of basic record
        if (!(fwOpts & (ETO_OPAQUE | ETO_CLIPPED)))
            i -= sizeof(RECTS);            // adjust for a rectangle being present
        i /= sizeof(WORD) ;                // change to word count

        // Set the record size, type,
        // x & y position, character count, and options.

        awRecord[0] = LOWORD(i) ;
        awRecord[1] = HIWORD(i) ;
        awRecord[2] = META_EXTTEXTOUT ;
        awRecord[3] = y ;
        awRecord[4] = x ;
        awRecord[5] = nCount ;
        awRecord[6] = fwOpts ;

        // Only if there is a opaque / clipping rectangle present
        // do we copy it over, other wise it is nonexistent.
        // We need to adjust the size of the Record emitted based upon
        // the existence of the opaque / clipping rectangle.

        nBaseRecord = 7 * sizeof(WORD) ;
        if (fwOpts & (ETO_OPAQUE | ETO_CLIPPED))
        {
            awRecord[7] = prcts->left ;
            awRecord[8] = prcts->top ;
            awRecord[9] = prcts->right ;
            awRecord[10] = prcts->bottom ;

            nBaseRecord += 4 * sizeof(WORD) ;
        }

        // Emit the record.

        b = bEmit(pLocalDC, awRecord, nBaseRecord) ;
        if (b)
        {
            // Emit the character string.

            i = ((WORD) nCount + 1) / 2 * 2 ;
            b = bEmit(pLocalDC, ach, i) ;
            if (b)
            {
		if (lpDx)
		{
                    // Emit the intercharacter spacing array

                    i = (WORD) (nCount * sizeof(WORD)) ;
                    b = bEmit(pLocalDC, lpDx, i) ;
                }
            }
        }

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) awRecord) ;

        return(b) ;
}

/****************************************************************************
 * Create Region - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16CreateRegion
(
PLOCALDC pLocalDC,
DWORD    cbRgn,
PVOID    pRgn
)
{
BOOL	    b;
METARECORD0 mr;

	mr.rdSize     = (sizeof(mr) + cbRgn) / sizeof(WORD);
	mr.rdFunction = META_CREATEREGION;

	// Emit the header.

        b = bEmit(pLocalDC, &mr, sizeof(mr));

	// Emit the region data.

	b = bEmit(pLocalDC, pRgn, cbRgn);

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * SetPaletteEntries - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16SetPaletteEntries
(
PLOCALDC       pLocalDC,
DWORD          iStart,
DWORD          cEntries,
LPPALETTEENTRY pPalEntries
)
{
BOOL	b ;
DWORD   cbPalEntries ;
METARECORD_SETPALENTRIES mr;

        cbPalEntries = cEntries * sizeof(PALETTEENTRY);

	mr.rdSize     = (sizeof(mr) + cbPalEntries) / sizeof(WORD);
	mr.rdFunction = META_SETPALENTRIES;
	mr.iStart     = (WORD) iStart;
	mr.cEntries   = (WORD) cEntries;

        // Emit the header.

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Emit the actual palette entries.

        b = bEmit(pLocalDC, pPalEntries, cbPalEntries) ;

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * CreatePalette - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16CreatePalette
(
PLOCALDC     pLocalDC,
LPLOGPALETTE lpLogPal
)
{
BOOL	b;
DWORD   cbLogPal;
METARECORD0 mr;

        cbLogPal  = sizeof(LOGPALETTE) - sizeof(PALETTEENTRY)
		    + lpLogPal->palNumEntries * sizeof(PALETTEENTRY) ;

	mr.rdSize     = (sizeof(mr) + cbLogPal) / sizeof(WORD);
	mr.rdFunction = META_CREATEPALETTE;

        // Emit the header.

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Emit the actual logpalette.

        b = bEmit(pLocalDC, lpLogPal, cbLogPal);

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return (b) ;
}

/****************************************************************************
 * CreateBrushIndirect - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16CreateBrushIndirect
(
PLOCALDC        pLocalDC,
LPWIN16LOGBRUSH lpLogBrush16
)
{
BOOL	b;
METARECORD_CREATEBRUSHINDIRECT mr;

	mr.rdSize     = sizeof(mr) / sizeof(WORD);
	mr.rdFunction = META_CREATEBRUSHINDIRECT;
	mr.lb16       = *lpLogBrush16;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * CreateDIPatternBrush - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16CreateDIBPatternBrush
(
PLOCALDC    pLocalDC,
PBITMAPINFO pBitmapInfo,
DWORD       cbBitmapInfo,
PBYTE       pBits,
DWORD       cbBits,
WORD        iUsage,
WORD        iType
)
{
BOOL	b ;
METARECORD_DIBCREATEPATTERNBRUSH mr;

	mr.rdSize     = (sizeof(mr) + cbBitmapInfo + cbBits + 1) / sizeof(WORD);
	mr.rdFunction = META_DIBCREATEPATTERNBRUSH;
	mr.iType      = iType;
	mr.iUsage     = iUsage;

// On NT, the packed DIB is dword aligned.  But on win3x, it is word aligned.
// Therefore, we emit the bitmap info followed by the bitmap bits in two
// separate stages.

        ASSERTGDI(cbBitmapInfo % 2 == 0,
	    "MF3216: bEmitWin16CreateDIBPatternBrush, bad bitmap info size");

        // Emit the static portion of the record.

        b = bEmit(pLocalDC, &mr, sizeof(mr));
        if (b == FALSE)
            goto error_exit ;

        // Emit the bitmap info.

        b = bEmit(pLocalDC, pBitmapInfo, cbBitmapInfo) ;
        if (b == FALSE)
            goto error_exit ;

        // Emit the bitmap bits.

        b = bEmit(pLocalDC, pBits, (cbBits + 1) / sizeof(WORD) * sizeof(WORD)) ;

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

error_exit:
        return(b);
}

/****************************************************************************
 * CreatePen - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16CreatePen
(
PLOCALDC pLocalDC,
WORD     iPenStyle,
PPOINTS  pptsWidth,
COLORREF crColor
)
{
BOOL	b;
METARECORD_CREATEPENINDIRECT mr;

	mr.rdSize     = sizeof(mr) / sizeof(WORD);
	mr.rdFunction = META_CREATEPENINDIRECT;
	mr.lopn16.lopnStyle = iPenStyle;
	mr.lopn16.lopnWidth = *pptsWidth;
	mr.lopn16.lopnColor = crColor;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

#if 0
/****************************************************************************
 * Escape - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16Escape
(
PLOCALDC pLocalDC,
SHORT    wEscape,
SHORT    wCount,
LPSTR    lpInData,
LPSTR    lpOutData
)
{
BOOL	b ;
METARECORD_ESCAPE mr;

        NOTUSED(lpOutData) ;

        // Init the type & length field of the metafile record.
        // Then emit the header of the escape record to the Win16 metafile.

	mr.rdSize     = (sizeof(mr) + (WORD) wCount) / sizeof(WORD);
	mr.rdFunction = META_ESCAPE;
	mr.wEscape    = wEscape;
	mr.wCount     = (WORD) wCount;

        b = bEmit(pLocalDC, &mr, sizeof(mr));
        if (b)
        {
            // Emit the actual data.
            b = bEmit(pLocalDC, lpInData, (DWORD) (WORD) wCount) ;
        }

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}
#endif // 0

/****************************************************************************
 * Escape - Win16 Metafile Emitter for enhanced metafile comment
 ***************************************************************************/
BOOL bEmitWin16EscapeEnhMetaFile
(
  PLOCALDC pLocalDC,
  PMETARECORD_ESCAPE pmfe,
  LPBYTE   lpEmfData
)
{
BOOL	b ;
PMETA_ESCAPE_ENHANCED_METAFILE pmfeEnhMF = (PMETA_ESCAPE_ENHANCED_METAFILE) pmfe;

        // Emit the header of the escape record to the Win16 metafile.

        b = bEmit(pLocalDC, (PVOID) pmfeEnhMF, sizeof(META_ESCAPE_ENHANCED_METAFILE));
        if (b)
        {
            // Emit the enhanced metafile data.
            b = bEmit(pLocalDC, lpEmfData, pmfeEnhMF->cbCurrent);
        }

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) pmfeEnhMF);

        return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\mf3216\xforms.c ===
/*****************************************************************************
 *
 * xforms - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *----------------------------------------------------------------------------
 *
 *   September 21, 1991
 *   Updated [20-Dec-1991]
 *
 *   Transformations in the Win32 to Win16 translator.
 *
 *   We are now supporting coordinate transformations from any
 *   map mode to any map mode.
 *
 *   Where:
 *        W    is the record-time-world to record-time-device xform.
 *             (aka metafile-world to metafile-device.)
 *        D    is the record-time device to play-time-device xform.
 *             (aka metafile-device to reference-device.)
 *        P    is the play-time-device to play-time-page xform.
 *             (aka reference-device to reference-logical (or page).)
 *
 *   W is the transformation defined by the world xform, map mode, window org,
 *   window extent, viewport org, and viewport extent in the
 *   Win32 metafile. This transform is also known as the world to
 *   device xform.
 *
 *   The normal composite xform is:
 *
 *         W D P
 *        ^ ^ ^ ^
 *        | | | +-  coordinate recorded in the win16 metafile.
 *        | | |     play-time-page coordinates (aka reference-logical)
 *        | | +---- play-time-device (reference-device) coordinates.
 *        | +------ record-time device (metafile-device) coordinates.
 *        +-------- world coordinates, recorded in Win32 metafile
 *
 *  The following comment is from Hockl's mail about transforms.
 *
 *   Message 11:
 *   From hockl Thu Dec 19 11:50:54 1991
 *   To: c-jeffn
 *   Cc: johnc
 *   Subject: Transform hints for the 32-16 converter
 *   Date: Thu Dec 19 11:46:40 1991
 *
 *   Here are some transform hints for the converter:
 *
 *   A. Issue the following records immediately following the 16-bit header
 *      record:
 *
 *      1. SetMapMode - use the given mapping mode, it is MM_ANISOTROPIC
 *         in most cases.
 *
 *      2. SetWindowOrg - use the upper left coordinates of the rclFrame.
 *         The coordinates are in the logical units of the reference DC.  So
 *         you have to convert .01mm to the reference device coordinates, then
 *         to the logical coordinates.  You can use the third transform
 *         defined in B.4 below to convert device coordinates to the logical
 *         coordinates of the reference device.  (Note the conversion formula
 *         for LPtoDP is defined as Dx = (Lx - xWO) * xVE/xWE + xVO and so on).
 *         This record is required to translate the converted picture to the
 *         origin (see comments in GetMetaFileBitsEx).
 *
 *      3. SetWindowExt - use the extents of the rclFrame.
 *      xExt = rclFrame.right - rclFrame.left;
 *      yExt = rclFrame.bottom - rclFrame.top;
 *         The extents are in the device units of the reference DC.  So
 *         you have to convert .01mm to the reference device units.
 *
 *      These three records should always be generated.  Note that
 *      SetWindowExt has no effect in all fixed mapping modes (e.g.
 *      MM_LOENGLISH and MM_TEXT) and will have no effect when the converted
 *      metafile is played.
 *
 *   B. Once you have issued the records, you need to use a xform helper DC
 *      to convert the coordinates of all drawing orders.  To do this, you
 *      need to do the following:
 *
 *      1. Create a xform helper DC.  This is a display info DC.
 *
 *      2. Call SetVirtualResolution to set the xform helper DC to that of
 *         the metafile.  Use the metafile header's szlDevice and
 *         szlMillimeters values to set the resolution.  This is to ensure
 *         that the help DC maps the logical coordinates to the device
 *         coordinates of the original metafile device.  If you reuse this
 *         helper DC in conversion, make sure you initialize the transforms
 *         using SetMapMode, ModifyWorldTransform, SetWindowOrgEx and
 *         SetViewportOrgEx.  You can use the same code in the
 *         CreateMetaFileEx function.
 *
 *      3. Once you have set up the xform helper DC, you should play all
 *         32-bit xform calls into the helper DC.  But never emit any
 *         xform records in the converter.  Everytime the xform is changed
 *         in the helper DC, you need to get the world to device xform
 *         (xformWDHelper) from the helper DC.  The xformWDHelper is used to
 *         convert the coordinates of the drawing orders subsequently.
 *         You can get it using the GetTransform(hdcHelper,XFORM_WORLD_TO_DEVICE)
 *         private API.
 *
 *      4. To convert drawing order coordinates, you pass them through three
 *         transforms.  The first is the xformWDHelper as computed above.  It
 *         converts all logical coordiates into the device coordinates of
 *         the original metafile device.  Note that this coordinates may
 *         be different from the conversion's reference device.  For example,
 *         the metafile may be created for a printer but the conversion is
 *         requested for the display.  The second transform therefore scales
 *         the coordinates from the metafile device to the reference device.
 *         The scaled coordinates are in MM_TEXT units.  So we need the third
 *         transform to convert the coordinates into the requested mapmode
 *         units.  For MM_TEXT, MM_ANISOTROPIC and MM_ISOTROPIC mapmode, this
 *         is the identity transform.  For the other mapmodes, this is a scale
 *         transform.  The scale transform maps the device units of the
 *         reference device to the logical units and can be computed using
 *         szlDevice, szlMillimeters of the reference device (not the metafile
 *         device!) and some predefined constants (to map millimeter to
 *         english, for example).  Note that in these fixed mapping modes, the
 *         y-axis goes in the opposite direction.  So make sure that the eM22
 *         component of the third transform is negative.  As you can see, the
 *         second and third transform never change in the duration of the
 *         conversion.  So you can combine them into one to optimize computation
 *         of the composite transform.  The composite transfom makes up of the
 *         three transforms and is used to convert drawing order coordinates
 *         into coordinates for the converted metafile.
 *
 *   C. To display a converted metafile in Windows 3.0, do the following before
 *      calling PlayMetaFile:
 *
 *      1. If the mapmode is MM_ANISOTROPIC, which is 99.9% of the time, call
 *         SetMapMode(MM_ANISOTROPIC), SetViewportOrigin and SetViewportExt.
 *         The viewport origin defines the upper left corner of the display area
 *         and the viewport origin defines the extent of the display area.  Both
 *         are in device units.
 *
 *      2. If the mapmode is MM_ISOTROPIC, which is strange, call
 *         SetMapMode(MM_ISOTROPIC), SetViewportOrigin and SetViewportExt.
 *         This is almost the same as C.1 above.
 *
 *      3. If the mapmode is others, the metafile has a fixed physical size
 *         and cannot be scaled easily without a lot of heck in the application.
 *         Call SetViewportOrigin to define the upper left corner of the display
 *         area.  The origin is in device coordinates.
 *
 *   I hope these steps are clear.  If you have any questions, feel free to
 *   give me a call.
 *
 *       HockL
 *
 *
 *
 ******************************************************************************/


#include "precomp.h"
#pragma hdrstop




BOOL WINAPI GetTransform(HDC hdc,DWORD iXform,LPXFORM pxform);
BOOL WINAPI SetVirtualResolution(HDC hdc,
                                   int cxDevice,
                                   int cyDevice,
                                   int cxMillimeters,
                                   int cyMillimeters);


BOOL bComputeCompositeXform(PLOCALDC pLocalDC) ;
VOID vInitRecDevToPlayDevXform(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header) ;


/*
    [19-Dec-1991]
    A note about transformations.

    We will map into any map mode (when the converter is complete).

    We will use a helper DC to compute our transformation matrices.

    All the Win32 APIs that effect transformations or map modes
    will be sent to a helper DC.  The helper DC will return a transform
    matrix that converts from World Coordinates to Device Coordinates.
    This transformation matrix is: xformRWorldToRDev.

    xformRWorldToRDev is combined with the xformRDevToPPage matrix to produce
    the xformRWorldToPPage matrix.  All coordinates are mapped through the
    xformRWorldToPPage matrix.
*/


XFORM   xformIdentity = {(FLOAT) 1.0,
                         (FLOAT) 0.0,
                         (FLOAT) 0.0,
                         (FLOAT) 1.0,
                         (FLOAT) 0.0,
                         (FLOAT) 0.0 } ;


/****************************************************************************
 *  Initialize all the matrices.
 ****************************************************************************/

// Units per millimeter array.  It must be in the order of MM_LOMETRIC,
// MM_HIMETRIC, MM_LOENGLISH, MM_HIENGLISH, MM_TWIPS.

FLOAT aeUnitsPerMM[5] = { 10.0f, 100.0f, 3.937f, 39.37f, 56.6928f };

BOOL bInitXformMatrices(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header)
{
    // Init xformRDevToPDev.

        vInitRecDevToPlayDevXform(pLocalDC, pmf32header) ;

    // Init xformPDevToPPage and xformPPageToPDev.
    // (aka reference-device to reference-logical) transform.

        switch(pLocalDC->iMapMode)
        {
            case MM_TEXT:
            case MM_ANISOTROPIC:
            case MM_ISOTROPIC:
                pLocalDC->xformPDevToPPage = xformIdentity ;
                pLocalDC->xformPPageToPDev = xformIdentity ;
                break ;

            case MM_LOMETRIC:
            case MM_HIMETRIC:
            case MM_LOENGLISH:
            case MM_HIENGLISH:
            case MM_TWIPS:
        {
        FLOAT exUnitsPerPel;
        FLOAT eyUnitsPerPel;

        // Compute units per pixel.

        exUnitsPerPel = (FLOAT) pLocalDC->cxPlayDevMM
                  / (FLOAT) pLocalDC->cxPlayDevPels
                  * aeUnitsPerMM[pLocalDC->iMapMode - MM_LOMETRIC];
        
        eyUnitsPerPel = (FLOAT) pLocalDC->cyPlayDevMM
                  / (FLOAT) pLocalDC->cyPlayDevPels
                  * aeUnitsPerMM[pLocalDC->iMapMode - MM_LOMETRIC];

                pLocalDC->xformPDevToPPage.eM11 = exUnitsPerPel;
                pLocalDC->xformPDevToPPage.eM12 = 0.0f;
                pLocalDC->xformPDevToPPage.eM21 = 0.0f;
                pLocalDC->xformPDevToPPage.eM22 = -eyUnitsPerPel;
                pLocalDC->xformPDevToPPage.eDx  = 0.0f;
                pLocalDC->xformPDevToPPage.eDy  = 0.0f;

                pLocalDC->xformPPageToPDev.eM11 = 1.0f / exUnitsPerPel;
                pLocalDC->xformPPageToPDev.eM12 = 0.0f;
                pLocalDC->xformPPageToPDev.eM21 = 0.0f;
                pLocalDC->xformPPageToPDev.eM22 = -1.0f / eyUnitsPerPel;
                pLocalDC->xformPPageToPDev.eDx  = 0.0f;
                pLocalDC->xformPPageToPDev.eDy  = 0.0f;
        }
            break ;
        }

    // Init xformRDevToPPage.
        // This xform is used in the SelectClipRegion code.

        if (!CombineTransform(&pLocalDC->xformRDevToPPage,
                              &pLocalDC->xformRDevToPDev,
                              &pLocalDC->xformPDevToPPage))
        {
            RIP("MF3216: InitXformMatrices, CombineTransform failed\n");
            return(FALSE);
        }

        // We are going to use the helper DC to compute the
        // Record-time-World to Record-time-Device transform.

        // Set the Helper DC virtual resolution to the Metafiles
        // resolution.

        if (!SetVirtualResolution(pLocalDC->hdcHelper,
                                 (INT) pmf32header->szlDevice.cx,
                                 (INT) pmf32header->szlDevice.cy,
                                 (INT) pmf32header->szlMillimeters.cx,
                                 (INT) pmf32header->szlMillimeters.cy))
        {
            RIP("MF3216: InitXformMatrices, SetVirtualResolution failed \n") ;
            return(FALSE);
        }

        // Init other matrices.

        return(bComputeCompositeXform(pLocalDC));
}

/****************************************************************************
 *  Initialize the Record-time to Play-time scalers. (xformRDevToPDev)
 ****************************************************************************/
VOID vInitRecDevToPlayDevXform(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header)
{
FLOAT   ecxRecDevPels,
        ecyRecDevPels,
        ecxRecDevMM,
        ecyRecDevMM,
        ecxPlayDevPels,
        ecyPlayDevPels,
        ecxPlayDevMM,
        ecyPlayDevMM,
        exMillsPerPelRec,
        eyMillsPerPelRec,
        exMillsPerPelPlay,
        eyMillsPerPelPlay ;


        // Pickup the physical dimensions of the record-time
        // device, both in pels and millimeters.
        // Converts them to floats

        ecxRecDevPels = (FLOAT) pmf32header->szlDevice.cx ;
        ecyRecDevPels = (FLOAT) pmf32header->szlDevice.cy ;
        ecxRecDevMM   = (FLOAT) pmf32header->szlMillimeters.cx ;
        ecyRecDevMM   = (FLOAT) pmf32header->szlMillimeters.cy ;

        // convert the Play-time device dimensions to floats.

        ecxPlayDevPels = (FLOAT) pLocalDC->cxPlayDevPels ;
        ecyPlayDevPels = (FLOAT) pLocalDC->cyPlayDevPels ;
        ecxPlayDevMM   = (FLOAT) pLocalDC->cxPlayDevMM ;
        ecyPlayDevMM   = (FLOAT) pLocalDC->cyPlayDevMM ;

        // Calucalte the pels per millimeter for both the record-time
        // and play-time devices.

        exMillsPerPelRec = ecxRecDevMM / ecxRecDevPels ;
        eyMillsPerPelRec = ecyRecDevMM / ecyRecDevPels ;

        exMillsPerPelPlay = ecxPlayDevMM / ecxPlayDevPels ;
        eyMillsPerPelPlay = ecyPlayDevMM / ecyPlayDevPels ;

        // Init the Record-time-device to the Play-time-device transform.
        // aka  the Metafile-device to the Reference-device transform.

        pLocalDC->xformRDevToPDev.eM11 = exMillsPerPelRec / exMillsPerPelPlay ;
        pLocalDC->xformRDevToPDev.eM12 = (FLOAT) 0.0 ;
        pLocalDC->xformRDevToPDev.eDx  = (FLOAT) 0.0 ;
        pLocalDC->xformRDevToPDev.eM21 = (FLOAT) 0.0 ;
        pLocalDC->xformRDevToPDev.eM22 = eyMillsPerPelRec / eyMillsPerPelPlay ;
        pLocalDC->xformRDevToPDev.eDy  = (FLOAT) 0.0 ;

        return;
}


#if 0
/***************************************************************************
 * vInvertMatrix - Invert a matrix
 **************************************************************************/
VOID vInvertMatrix(PXFORM pxformSrc, PINVERSMATRIX pinvxfm)
{
FLOAT   eM11, eM12, eM21, eM22, eDx, eDy,
        detA ;

        // dereference the matrix elements, just to make the rest of this
        // routine more readable.

        eM11 = pxformSrc->eM11 ;
        eM12 = pxformSrc->eM12 ;
        eM21 = pxformSrc->eM21 ;
        eM22 = pxformSrc->eM22 ;
        eDx  = pxformSrc->eDx ;
        eDy  = pxformSrc->eDy ;

        // First determine the determinant of the source matrix.

        detA = (eM11 * eM22) - (eM11 * eDy) ;

        pinvxfm->a1 = eM22 / detA ;
        pinvxfm->a2 = -(eM21 / detA) ;
        pinvxfm->a3 = ((eM21 * eDy) - (eDx * eM22)) / detA ;
        pinvxfm->b1 = -(eM12 / detA) ;
        pinvxfm->b2 = eM11 / detA ;
        pinvxfm->b3 = -(((eM11 * eDy) - (eDx * eM12)) / detA) ;
        pinvxfm->c1 = (FLOAT) 0.0 ;
        pinvxfm->c2 = (FLOAT) 0.0 ;
        pinvxfm->c3 = ((eM11 * eM22) - (eM21 * eM12)) / detA ;

        // This is just for testing.

        pinvxfm->a1 = pxformSrc->eM11 ;
        pinvxfm->a2 = pxformSrc->eM12 ;
        pinvxfm->a3 = (FLOAT) 0.0 ;
        pinvxfm->b1 = pxformSrc->eM21 ;
        pinvxfm->b2 = pxformSrc->eM22 ;
        pinvxfm->b3 = (FLOAT) 0.0 ;
        pinvxfm->c1 = pxformSrc->eDx ;
        pinvxfm->c2 = pxformSrc->eDy ;
        pinvxfm->c3 = (FLOAT) 1.0 ;

        return ;

}
#endif // 0


/***************************************************************************
 * XformPDevToPPage  - Do a transform on the array of points passed in.
 *
 *                     This does the play-time (reference) device to
 *                     play-time (reference) page (logical) transformation.
 **************************************************************************/
BOOL bXformPDevToPPage(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount)
{
BOOL    b ;

        b = bXformWorkhorse(aptl, nCount, &pLocalDC->xformPDevToPPage) ;

        return (b) ;
}


/***************************************************************************
 * XformPPageToPDev  - Do a transform on the array of points passed in.
 *
 *                     This does the play-time (reference) page (logical) to
 *                     play-time (reference) device transformation.
 **************************************************************************/
BOOL bXformPPageToPDev(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount)
{
BOOL    b ;

        b = bXformWorkhorse(aptl, nCount, &pLocalDC->xformPPageToPDev) ;

        return (b) ;
}


/***************************************************************************
 * XformRWorldToRDev  - Do a transform on the array of points passed in.
 *
 *                      This does the Record-time (metafile) world to
 *                      record-time device translation.
 **************************************************************************/
BOOL bXformRWorldToRDev(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount)
{
BOOL    b ;

        b = bXformWorkhorse(aptl, nCount, &pLocalDC->xformRWorldToRDev) ;

        return (b) ;
}


/***************************************************************************
 * XformRDevToRWorld  - Do a transform on the array of points passed in.
 *
 *                      This does the Record-device (metafile) world to
 *                      record-time world translation.
 **************************************************************************/
BOOL bXformRDevToRWorld(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount)
{
BOOL    b ;

        b = bXformWorkhorse(aptl, nCount, &pLocalDC->xformRDevToRWorld) ;

        return (b) ;
}


/***************************************************************************
 * XformRWorldToPPage - Do a transform on the array of points passed in.
 *
 *            This is the workhorse translation routine.
 *            This translates from record-time-world (aka metafile-world)
 *            to record-time-device (aka metafile-device)  then from
 *            record-time-device (aka metafile-device) to play-time-device
 *            (aka reference-device) then from play-time-device
 *            (aka reference-device) to play-time-page (reference-logical)
 *            space.
 **************************************************************************/
BOOL bXformRWorldToPPage(PLOCALDC pLocalDC, PPOINTL aptl, DWORD nCount)
{
BOOL    b ;

        b = bXformWorkhorse(aptl, nCount, &pLocalDC->xformRWorldToPPage) ;

        return (b) ;
}


/***************************************************************************
 * bXformWorkhorse - Transformation Workhorse.
 **************************************************************************/
BOOL bXformWorkhorse(PPOINTL aptl, DWORD nCount, PXFORM pXform)
{
INT     i ;
FLOAT   x, y ;
BOOL    b ;
FLOAT   fx, fy;

        for (i = 0 ; i < (INT) nCount ; i++)
        {
            x = (FLOAT) aptl[i].x ;
            y = (FLOAT) aptl[i].y ;
            fx = (x * pXform->eM11 + y * pXform->eM21 + pXform->eDx) ;
            fy = (x * pXform->eM12 + y * pXform->eM22 + pXform->eDy) ;
            aptl[i].x = (LONG) (fx + ((fx < 0.0) ? -0.5f : 0.5f)) ;
            aptl[i].y = (LONG) (fy + ((fy < 0.0) ? -0.5f : 0.5f)) ;
        }

        // Do the coordinate overflow detection.

        b = bCoordinateOverflowTest((PLONG) aptl, nCount * 2) ;

        return (b) ;
}

/***************************************************************************
 * vXformWorkhorseFloat - Transformation Workhorse.
 **************************************************************************/
VOID vXformWorkhorseFloat(PPOINTFL aptfl, UINT nCount, PXFORM pXform)
{
UINT    i ;
FLOAT   x, y ;

        for (i = 0 ; i < nCount ; i++)
        {
            x = aptfl[i].x ;
            y = aptfl[i].y ;
            aptfl[i].x = x * pXform->eM11 + y * pXform->eM21 + pXform->eDx;
            aptfl[i].y = x * pXform->eM12 + y * pXform->eM22 + pXform->eDy;
        }
}

/*****************************************************************************
 * iMagnitudeXform - Transform the magnitude of a number from
 *                   Record-time-World to Play-time-Page coordinate space.
 *****************************************************************************/
INT iMagnitudeXform (PLOCALDC pLocalDC, INT value, INT iType)
{
PXFORM  pxform ;
INT     iRet ;

        pxform = &(pLocalDC->xformRWorldToPPage) ;

        iRet = iMagXformWorkhorse (value, pxform, iType) ;

        return (iRet) ;
}

/*****************************************************************************
 * iMagXformWorkhorse - get the magnitude component of a translated vector
 *****************************************************************************/
INT iMagXformWorkhorse (INT value, PXFORM pxform, INT iType)
{
POINTFL aptfl[2] ;
FLOAT   x1, y1, x2, y2;
double  emag ;

// Create a vector, from (0,0) to the point.

        aptfl[0].x = 0.0f ;
        aptfl[0].y = 0.0f ;

        if (iType == CX_MAG)
        {
            aptfl[1].x = (FLOAT) value ;
            aptfl[1].y = 0.0f ;
        }
        else
        {
            aptfl[1].x = 0.0f ;
            aptfl[1].y = (FLOAT) value ;
        }

    vXformWorkhorseFloat(aptfl, 2, pxform);

// Now get the magnitude

        x1 = aptfl[0].x ;
        y1 = aptfl[0].y ;
        x2 = aptfl[1].x ;
        y2 = aptfl[1].y ;

        emag = sqrt((double) ((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1))) ;

        return((INT) (emag + (double) 0.5f));
}


/*****************************************************************************
 * bRotationTest -
 *        return -  TRUE if there is a rotation or shear in this xform
 *                  FALSE if there is none.
 *****************************************************************************/
BOOL bRotationTest(PXFORM pxform)
{
BOOL    b ;

        if (   (pxform->eM12 != (FLOAT) 0.0)
            || (pxform->eM21 != (FLOAT) 0.0)
           )
        {
            b = TRUE ;
        }
        else
        {
            b = FALSE ;
        }

        return(b) ;
}

/***************************************************************************
 *  SetMapMode  - Win32 to Win16 Metafile Converter Entry Point
 *
 *  All the map mode translations are done by the helper DC.
 *  The Helper DC always transforms to device, then we combine the
 *  MetafileWorldToDevice with the DeviceToPage transform.
 *  This becomes the Win32 to Win16 transform.
 *
 *  Some of the metafiles converted from Win16 to Win32 do not
 *  define a Viewport extent.  Since the Isotropic and AnIsotropic
 *  map modes are undefined if either the Viewport Extent or the Window
 *  Extent are undefined we will default the Viewport extent to the
 *  device extent in the Win32 metafile header.
 **************************************************************************/
BOOL WINAPI DoSetMapMode
(
 PLOCALDC  pLocalDC,
 DWORD   ulMapMode
)
{
BOOL    b ;


        if (!SetMapMode(pLocalDC->hdcHelper, ulMapMode))
    {
            ASSERTGDI(FALSE, "MF3216: DoSetMapMode failed\n");
        return(FALSE);
    }

        b = bComputeCompositeXform(pLocalDC) ;

        return (b) ;
}


/***************************************************************************
 *  ScaleWindowsExtEx  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoScaleWindowExt
(
 PLOCALDC pLocalDC,
 INT      Xnum,
 INT      Xdenom,
 INT      Ynum,
 INT      Ydenom
)
{
BOOL    b ;

        // Set the Windows extent

        if (!ScaleWindowExtEx(pLocalDC->hdcHelper,
                           Xnum, Xdenom,
                           Ynum, Ydenom,
                           (LPSIZE) 0))
    {
            ASSERTGDI(FALSE, "MF3216: DoScaleWindowExt failed\n");
        return(FALSE);
    }

        b = bComputeCompositeXform(pLocalDC) ;

        return (b) ;
}

/***************************************************************************
 *  ScaleViewportExtEx  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoScaleViewportExt
(
 PLOCALDC pLocalDC,
 INT      Xnum,
 INT      Xdenom,
 INT      Ynum,
 INT      Ydenom
)
{
BOOL    b ;

        // Set the viewport extent

        if (!ScaleViewportExtEx(pLocalDC->hdcHelper,
                           Xnum, Xdenom,
                           Ynum, Ydenom,
                           (LPSIZE) 0))
    {
            ASSERTGDI(FALSE, "MF3216: DoScaleViewportExt failed\n");
        return(FALSE);
    }

        b = bComputeCompositeXform(pLocalDC) ;

        return (b) ;
}

/***************************************************************************
 *  SetViewportExtEx  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetViewportExt
(
 PLOCALDC pLocalDC,
 int     x,
 int     y
)
{
BOOL    b ;

        // Set the viewport extent

        if (!SetViewportExtEx(pLocalDC->hdcHelper, x, y, (LPSIZE) 0))
    {
            ASSERTGDI(FALSE, "MF3216: DoSetViewportExt failed\n");
        return(FALSE);
    }

        b = bComputeCompositeXform(pLocalDC) ;

        return (b) ;
}

/***************************************************************************
 *  SetViewportOrgEx  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetViewportOrg
(
 PLOCALDC pLocalDC,
 int     x,
 int     y
)
{
BOOL    b ;

        // Set the viewport origin

        if (!SetViewportOrgEx(pLocalDC->hdcHelper, x, y, (LPPOINT) 0))
    {
            ASSERTGDI(FALSE, "MF3216: DoSetViewportOrg failed\n");
        return(FALSE);
    }

        b = bComputeCompositeXform(pLocalDC) ;

        return (b) ;
}

/***************************************************************************
 *  SetWindowExtEx  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetWindowExt
(
 PLOCALDC pLocalDC,
 int     x,
 int     y
)
{
BOOL    b ;

        // Set the window extent

        if (!SetWindowExtEx(pLocalDC->hdcHelper, x, y, (LPSIZE) 0))
    {
            ASSERTGDI(FALSE, "MF3216: DoSetWindowExt failed\n");
        return(FALSE);
    }

        b = bComputeCompositeXform(pLocalDC) ;

        return (b) ;
}

/***************************************************************************
 *  SetWindowOrgEx  - Win32 to Win16 Metafile Converter Entry Point
 *
 *  Since we will always record TWIPS in the Win16 metafile,
 *  we will transform the WindowOrg from the current MapMode to
 *  TWIPS. Then we will set the Dx and Dy elements of the Viewport
 *  transformation matrix.
 *
 **************************************************************************/
BOOL WINAPI DoSetWindowOrg
(
 PLOCALDC pLocalDC,
 int     x,
 int     y
)
{
BOOL    b ;

        // Set the window origin

        if (!SetWindowOrgEx(pLocalDC->hdcHelper, x, y, (LPPOINT) 0))
    {
            ASSERTGDI(FALSE, "MF3216: DoSetWindowOrg failed\n");
        return(FALSE);
    }

        b = bComputeCompositeXform(pLocalDC) ;

        return (b) ;
}

/***************************************************************************
 *  SetWorldTransform  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetWorldTransform
(
 PLOCALDC  pLocalDC,
 PXFORM  pxf
)
{
BOOL    b ;


        // Set the world xform in the helper DC.

        if (!SetWorldTransform(pLocalDC->hdcHelper, pxf))
    {
            ASSERTGDI(FALSE, "MF3216: DoSetWorldTransform failed\n");
        return(FALSE);
    }

        b = bComputeCompositeXform(pLocalDC) ;

        return (b) ;
}

/***************************************************************************
 *  ModifyWorldTransform  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoModifyWorldTransform
(
 PLOCALDC  pLocalDC,
 PXFORM  pxf,
 DWORD   imode
)
{
BOOL    b ;

        // Set the world xform in the helper DC.

        if (!ModifyWorldTransform(pLocalDC->hdcHelper, pxf, imode))
    {
            ASSERTGDI(FALSE, "MF3216: DoModifyWorldTransform failed\n");
        return(FALSE);
    }

        b = bComputeCompositeXform(pLocalDC) ;

        return (b) ;
}


/****************************************************************************
 * bComputeCompositeXform - Compute the composite Xforms.
 *
 * The following transforms are re-computed:
 *
 *  xformRWorldToRDev
 *  xformRDevToRWorld
 *  xformRWorldToPPage
 *
 ****************************************************************************/
BOOL bComputeCompositeXform(PLOCALDC pLocalDC)
{
BOOL    b ;

    // Recompute xformRWorldToRDev.
        // Get the record-time world to record-time device xform
        // from the helper DC

        b = GetTransform(pLocalDC->hdcHelper,
                         XFORM_WORLD_TO_DEVICE,
                         &pLocalDC->xformRWorldToRDev) ;
        if (b == FALSE)
        {
            RIP("MF3216: bComputeCompositeXform - GetTransform (RWorld to RDev) failed \n") ;
            goto error_exit ;
        }

    // Recompute xformRDevToRWorld.
        // Get the record-time-device to record-time-world xform

        b = GetTransform(pLocalDC->hdcHelper,
                         XFORM_DEVICE_TO_WORLD,
                         &pLocalDC->xformRDevToRWorld) ;
        if (b == FALSE)
        {
            RIP("MF3216: bComputeCompositeXform - GetTransform (RDev To RWorld) failed \n") ;
            goto error_exit ;
        }

    // Recompute xformRWorldToPPage.

        b = CombineTransform(&pLocalDC->xformRWorldToPPage,
                             &pLocalDC->xformRWorldToRDev,
                             &pLocalDC->xformRDevToPPage);
        if (b == FALSE)
        {
            RIP("MF3216: bComputeCompositeXform - CombineTransform failed\n");
            goto error_exit ;
        }

    // Recompute transform flags.

        if (pLocalDC->xformRWorldToRDev.eM12 != (FLOAT) 0.0
     || pLocalDC->xformRWorldToRDev.eM21 != (FLOAT) 0.0)
            pLocalDC->flags |= STRANGE_XFORM ;
        else
            pLocalDC->flags &= ~STRANGE_XFORM ;

error_exit:
        return(b) ;
}

/***************************************************************************
 *  bCoordinateOverflowTest - Test for 1 16 bit coordinate overflow
 *
 *  RETURNS:    FALSE if there is a coordinate overflow
 *              TRUE   if  there is no overflow.
 **************************************************************************/
BOOL bCoordinateOverflowTest(PLONG pCoordinates, INT nCount)
{
BOOL    b ;
INT     i, j ;

        b = TRUE ;
        for (i = 0 ; i < nCount ; i++)
        {

            j = pCoordinates[i] ;
            if (j < -32768 || j > 32767)
            {
                b = FALSE ;
                SetLastError(ERROR_ARITHMETIC_OVERFLOW);
                RIP("MF3216: bCoordinateOverflowTest, coordinate overflow\n") ;
                break ;
            }
        }

        return(b) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\mf3216\regions.c ===
/*****************************************************************************
 *
 * regions - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *
 * NOTES:
 *
        When there are no embedded metafiles we need to do the following:

            1]  Read the metafile data from the Win32 metafile.  This
                is done by the handler routines that in turn call these
                routines.

            2]  Translate the Win32 metafile data into Win16 metafile data.

                The region data for FillRgn, FrameRgn, InvertRgn, and PaintRgn
                are in record-time world coordinates. The region data for
                these region API's will have to be translated from record-time
                -world coordinates to play-time-page coordinates
                (XFORM_WORLD_TO_PAGE). The helperDC will be used for
                this transformation.

                The region data for SelectClipRgn and OffsetClipRgn are in
                record-time device coordinates.  The region data for these
                APIs will be translated from record-time-device coordinates
                to play-time-device coordinates.

            3]  Emit a Win16 create region metafile record.

            4]  Select the newly created region into the metafile.

            5]  Do the region function (FillRegion, FrameRegion, ...).
                This means emit a FillRegion or FrameRegion drawing order
                into the Win16 metafile.

            6]  Emit a Delete Region drawing order.

            7]  Clean up all the memory resources used.

        When there are embedded metafiles things get a little more  complicated.
        Most of the complications are hidden in PlayMetafile record processing.
        Items 1 thru 3 will be handled by the PlayMetafile Doer.

            1]  We need to keep the region from the previous DC level.
                This can be done by the helper DC (SaveDC).  We will have to
                do a GetClipRgn and a SelectMetaRgn.  A MetaRgn is the clip
                region from the previous level.

            2]  We will have to intersect any clip regions from the current
                level with any clip regions from the previous level. This can
                be done by the helper DC (using the hrgnMeta & ExtCombineRegion)

            3]  When we pop out from this level we will have to restore the
                previous saved region. This can be done by the helper DC.
                (RestoreDC).

        Since we do not know whether or not there will be an embedded metafile
        in the metafile we are currently processing we will always shadow
        the Clip Region call into the helper DC.


 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop




BOOL bEmitWin3Region(PLOCALDC pLocalDC, HRGN hrgn);

#define MIN_RGN_COORD16 -30000
#define MAX_RGN_COORD16  30000

/***************************************************************************
 * DoDrawRgn
 *
 *  CR1: This routine was added as part of the handle manager change.
 *       I noticed that almost all of the Region Rendering code was
 *       the same.
 **************************************************************************/
BOOL APIENTRY DoDrawRgn
(
 PLOCALDC  pLocalDC,
 INT       ihBrush,
 INT       nWidth,
 INT       nHeight,
 INT       cRgnData,
 LPRGNDATA pRgnData,
 INT       mrType
)
{
BOOL    b ;
HRGN    hrgn = (HRGN) 0;
INT     ihW16Rgn = -1,
        ihW16Brush = -1;

        b = FALSE ;

        // Translate the Win32 region data from Metafile-World to
        // Referencd-Page space.
        // This is done by ExtCreateRegion's xform.  The returned region
        // is transformed.

        hrgn = ExtCreateRegion(&pLocalDC->xformRWorldToPPage, cRgnData,
        (LPRGNDATA) pRgnData);
        if (!hrgn)
        {
            RIP("MF3216: DoDrawRgn, ExtCreateRegion failed\n") ;
            goto error_exit ;
        }

        // Allocate a handle for the region.
        // This is different from a normal handle allocation, because
        // there is no region handle in Win32.  We are using one of our
        // extra slots here.

        ihW16Rgn = iGetW16ObjectHandleSlot(pLocalDC, REALIZED_REGION) ;
        if (ihW16Rgn == -1)
            goto error_exit ;

        // Emit a Win16 create region record for the region.

    if (!bEmitWin3Region(pLocalDC, hrgn))
        {
            RIP("MF3216: DoDrawRgn, bEmitWin3Region failed\n") ;
            goto error_exit ;
    }

        // Translate the W32 Brush object index to a W16 Brush object index.

    if (ihBrush)
    {
        // Make sure that the W16 object exists.  Stock brushes may not
        // have been created and iValidateHandle will take care of creating
        // them.

            ihW16Brush = iValidateHandle(pLocalDC, ihBrush) ;
            if (ihW16Brush == -1)
                goto error_exit ;
    }

        // Emit the Region Record depending upon the function type.

        switch (mrType)
        {
            case EMR_FILLRGN:
                if(ihW16Brush == -1)
                    goto error_exit;
                b = bEmitWin16FillRgn(pLocalDC,
                                      LOWORD(ihW16Rgn),
                                      LOWORD(ihW16Brush)) ;
                break ;

            case EMR_FRAMERGN:
                nWidth  = iMagnitudeXform (pLocalDC, nWidth, CX_MAG) ;
                nHeight = iMagnitudeXform (pLocalDC, nHeight, CY_MAG) ;
                if(ihW16Brush == -1)
                    goto error_exit;

                b = bEmitWin16FrameRgn(pLocalDC,
                                       LOWORD(ihW16Rgn),
                                       LOWORD(ihW16Brush),
                                       LOWORD(nWidth),
                                       LOWORD(nHeight)) ;
                break ;

            case EMR_INVERTRGN:
                b = bEmitWin16InvertRgn(pLocalDC,
                                        LOWORD(ihW16Rgn)) ;
                break ;

            case EMR_PAINTRGN:
                b = bEmitWin16PaintRgn(pLocalDC,
                                       LOWORD(ihW16Rgn)) ;
                break ;

        default:
                RIP("MF3216: DoDrawRgn, unknown type\n") ;
                break ;
        }

error_exit:
        // Delete the W16 Region Object.

        if (ihW16Rgn != -1)
        bDeleteW16Object(pLocalDC, ihW16Rgn) ;

    if (hrgn)
        DeleteObject(hrgn) ;

        return(b) ;
}


/***************************************************************************
 *  ExtSelectClipRgn  - Win32 to Win16 Metafile Converter Entry Point
 *
 * History:
 *  Tue Apr 07 17:05:37 1992    -by-    Hock San Lee    [hockl]
 * Wrote it.
 **************************************************************************/

BOOL WINAPI DoExtSelectClipRgn
(
 PLOCALDC  pLocalDC,
 INT       cRgnData,
 LPRGNDATA pRgnData,
 INT       iMode
)
{
    HANDLE hrgn;
    BOOL   bRet;
    BOOL   bNoClipRgn ;

    bNoClipRgn = bNoDCRgn(pLocalDC, DCRGN_CLIP);

    // Do it to the helper DC.

    if (cRgnData == 0)      // default clipping
    {
    ASSERTGDI(iMode == RGN_COPY, "MF3216: DoExtSelectClipRgn: bad iMode\n");

    // No work if no previous clip region.

    if (bNoClipRgn)
        return(TRUE);

        bRet = (ExtSelectClipRgn(pLocalDC->hdcHelper, (HRGN)0, iMode) != ERROR);
    }
    else
    {

    // If there is no initial clip region and we are going to operate
    // on the initial clip region, we have to
    // create one.  Otherwise, GDI will create some random default
    // clipping region for us!

    if (bNoClipRgn
     && (iMode == RGN_DIFF || iMode == RGN_XOR || iMode == RGN_OR))
    {
        HRGN hrgnDefault;
    
        if (!(hrgnDefault = CreateRectRgn((int) (SHORT) MINSHORT,
                          (int) (SHORT) MINSHORT,
                          (int) (SHORT) MAXSHORT,
                          (int) (SHORT) MAXSHORT)))
        {
        ASSERTGDI(FALSE, "MF3216: CreateRectRgn failed");
            return(FALSE);
        }
    
        bRet = (ExtSelectClipRgn(pLocalDC->hdcHelper, hrgnDefault, RGN_COPY)
            != ERROR);
        ASSERTGDI(bRet, "MF3216: ExtSelectClipRgn failed");
    
        if (!DeleteObject(hrgnDefault))
        ASSERTGDI(FALSE, "MF3216: DeleteObject failed");
    
        if (!bRet)
        return(FALSE);
    }

        // Create a region from the region data passed in.

        if (!(hrgn = ExtCreateRegion((LPXFORM) NULL, cRgnData, pRgnData)))
        {
            RIP("MF3216: DoExtSelectClipRgn, Create region failed\n");
            return(FALSE);
        }

        bRet = (ExtSelectClipRgn(pLocalDC->hdcHelper, hrgn, iMode) != ERROR);

        ASSERTGDI(bRet, "MF3216: ExtSelectClipRgn failed\n");

        if (!DeleteObject(hrgn))
            RIP("MF3216: DeleteObject failed\n");
    }

    // dump the clip region data.

    if (bRet)
    return(bDumpDCClipping(pLocalDC));
    else
        return(FALSE);
}


/***************************************************************************
 *  SetMetaRgn  - Win32 to Win16 Metafile Converter Entry Point
 *
 * History:
 *  Tue Apr 07 17:05:37 1992    -by-    Hock San Lee    [hockl]
 * Wrote it.
 **************************************************************************/

BOOL WINAPI DoSetMetaRgn(PLOCALDC pLocalDC)
{
    // No work if the clip region does not exist.

    if (bNoDCRgn(pLocalDC, DCRGN_CLIP))
    return(TRUE);

    // Do it to the helper DC.

    if (!SetMetaRgn(pLocalDC->hdcHelper))
        return(FALSE);

    // Dump the clip region data.

    return(bDumpDCClipping(pLocalDC));
}


/***************************************************************************
 *  OffsetClipRgn  - Win32 to Win16 Metafile Converter Entry Point
 *
 * History:
 *  Tue Apr 07 17:05:37 1992    -by-    Hock San Lee    [hockl]
 * Wrote it.
 **************************************************************************/

BOOL WINAPI DoOffsetClipRgn(PLOCALDC pLocalDC, INT x, INT y)
{
    POINTL aptl[2];
    BOOL   b;

    // Do it to the helper DC.

    if (!OffsetClipRgn(pLocalDC->hdcHelper, x, y))
        return(FALSE);

    // Dump region if the meta region exists.
    // We don't offset the meta region!

    if (!bNoDCRgn(pLocalDC, DCRGN_META))
    return(bDumpDCClipping(pLocalDC));

    // Translate the record-time world offsets to play-time page offsets.

    aptl[0].x = 0;
    aptl[0].y = 0;
    aptl[1].x = x;
    aptl[1].y = y;

    if (!bXformRWorldToPPage(pLocalDC, aptl, 2))
        return(FALSE);

    aptl[1].x -= aptl[0].x;
    aptl[1].y -= aptl[0].y;

    b = bEmitWin16OffsetClipRgn(pLocalDC, (SHORT) aptl[1].x, (SHORT) aptl[1].y);
    ASSERTGDI(b, "MF3216: DoOffsetClipRgn, bEmitWin16OffsetClipRgn failed\n");

    return(b) ;
}


/***************************************************************************
 *  bNoDCRgn  - Return TRUE if the dc clip region does not exist.
 *                Otherwise, return FALSE.
 *  This is TEMPORARY only.  Get gdi to provide this functionality.
 **************************************************************************/

BOOL bNoDCRgn(PLOCALDC pLocalDC, INT iType)
{
    BOOL  bRet = FALSE;     // assume the dc region exists
    HRGN  hrgnTmp;

    ASSERTGDI(iType == DCRGN_CLIP || iType == DCRGN_META,
    "MF3216: bNoDCRgn, bad iType\n");

    if (!(hrgnTmp = CreateRectRgn(0, 0, 0, 0)))
    {
    ASSERTGDI(FALSE, "MF3216: bNoDCRgn, CreateRectRgn failed\n");
        return(bRet);
    }

    switch (GetRandomRgn(pLocalDC->hdcHelper,
             hrgnTmp,
             iType == DCRGN_CLIP ? 1 : 2
            )
       )
    {
    case -1:    // error
    ASSERTGDI(FALSE, "GetRandomRgn failed");
    break;
    case 0: // no dc region
    bRet = TRUE;
    break;
    case 1: // has dc region
    break;
    }

    if (!DeleteObject(hrgnTmp))
    ASSERTGDI(FALSE, "DeleteObject failed");

    return(bRet);
}

/***************************************************************************
 *  bDumpDCClipping - Dump the DC clipping regions.
 *
 * History:
 *  Tue Apr 07 17:05:37 1992    -by-    Hock San Lee    [hockl]
 * Wrote it.
 **************************************************************************/

BOOL bDumpDCClipping(PLOCALDC pLocalDC)
{
BOOL      bRet            = FALSE;      // assume failure
HRGN      hrgnRDev        = (HRGN) 0;
HRGN      hrgnPPage       = (HRGN) 0;
HRGN      hrgnPPageBounds = (HRGN) 0;
LPRGNDATA lprgnRDev       = (LPRGNDATA) NULL;
LPRGNDATA lprgnPPage      = (LPRGNDATA) NULL;
DWORD     cRgnData;
INT       i;
INT       nrcl;
PRECTL    prcl;
RECTL     rclPPage;

// Since clipping region is not scalable in Win30, we do not emit
// SelectClipRgn record.  Instead, we set the clipping to the default, i.e.
// no clipping, and then emit the scalable IntersectClipRect/ExcludeClipRect
// records to exclude clipping region.  This will allow the win30 metafiles
// to be scalable.

// First, emit a default clipping region.

    // On Win3.x, the META_SELECTCLIPREGION record only works if it has
    // a NULL handle.  The Win3x metafile driver does not translate the
    // region handle at playback time!

    if (!bW16Emit1(pLocalDC, META_SELECTCLIPREGION, 0))
        goto ddcc_exit;

// Now find the clip and meta regions to be excluded from the default
// clipping region.

    if (!(hrgnRDev = CreateRectRgn(0, 0, 0, 0)))
        goto ddcc_exit;

    switch (GetRandomRgn(pLocalDC->hdcHelper, hrgnRDev, 3)) // meta and clip
    {
    case -1:    // error
    ASSERTGDI(FALSE, "GetRandomRgn failed");
        goto ddcc_exit;
    case 0: // no clip region, we are done
    bRet = TRUE;
        goto ddcc_exit;
    case 1: // has clip region
    break;
    }

    // Get the clip region data.
    // First query the size of the buffer required to hold the clip region data.

    if (!(cRgnData = GetRegionData(hrgnRDev, 0, (LPRGNDATA) NULL)))
        goto ddcc_exit;

    // Allocate the memory for the clip region data buffer.

    if (!(lprgnRDev = (LPRGNDATA) LocalAlloc(LMEM_FIXED, cRgnData)))
        goto ddcc_exit;

    // Get clip region data.

    if (GetRegionData(hrgnRDev, cRgnData, lprgnRDev) != cRgnData)
        goto ddcc_exit;

    // Create the clip region in the playtime page space.

    if (!(hrgnPPage = ExtCreateRegion(&pLocalDC->xformRDevToPPage, cRgnData, lprgnRDev)))
        goto ddcc_exit;

    // Get the bounding box for the playtime clip region in page space.

    if (GetRgnBox(hrgnPPage, (LPRECT) &rclPPage) == ERROR)
        goto ddcc_exit;

    // Bound it to 16-bit.

    rclPPage.left   = max(MIN_RGN_COORD16,rclPPage.left);
    rclPPage.top    = max(MIN_RGN_COORD16,rclPPage.top);
    rclPPage.right  = min(MAX_RGN_COORD16,rclPPage.right);
    rclPPage.bottom = min(MAX_RGN_COORD16,rclPPage.bottom);

// Set the bounding box as the bounds for the clipping.

    if (!bEmitWin16IntersectClipRect(pLocalDC,
                     (SHORT) rclPPage.left,
                     (SHORT) rclPPage.top,
                     (SHORT) rclPPage.right,
                     (SHORT) rclPPage.bottom))
    goto ddcc_exit;

    // Create the bounding region.

    if (!(hrgnPPageBounds = CreateRectRgn(rclPPage.left,
                      rclPPage.top,
                      rclPPage.right,
                      rclPPage.bottom)))
        goto ddcc_exit;

    // Exclude the regions in playtime page space.

    if (CombineRgn(hrgnPPage, hrgnPPageBounds, hrgnPPage, RGN_DIFF) == ERROR)
        goto ddcc_exit;

// Finally, exclude the rectangles from the bounding box.

    if (!(cRgnData = GetRegionData(hrgnPPage, 0, (LPRGNDATA) NULL)))
        goto ddcc_exit;

    if (!(lprgnPPage = (LPRGNDATA) LocalAlloc(LMEM_FIXED, cRgnData)))
        goto ddcc_exit;

    if (GetRegionData(hrgnPPage, cRgnData, lprgnPPage) != cRgnData)
        goto ddcc_exit;

    // Get the number of rectangles in the transformed region.

    nrcl = lprgnPPage->rdh.nCount;
    prcl = (PRECTL) lprgnPPage->Buffer;

    // Emit a series of Exclude Clip Rectangle Metafile records.

    for (i = 0 ; i < nrcl; i++)
    {
    ASSERTGDI(prcl[i].left   >= MIN_RGN_COORD16
           && prcl[i].top    >= MIN_RGN_COORD16
           && prcl[i].right  <= MAX_RGN_COORD16
           && prcl[i].bottom <= MAX_RGN_COORD16,
        "MF3216: bad coord");

        if (!bEmitWin16ExcludeClipRect(pLocalDC,
                      (SHORT) prcl[i].left,
                      (SHORT) prcl[i].top,
                      (SHORT) prcl[i].right,
                      (SHORT) prcl[i].bottom))
        goto ddcc_exit;
    }

    bRet = TRUE;            // we are golden!

// Cleanup all the resources used.

ddcc_exit:

    if (hrgnRDev)
        DeleteObject(hrgnRDev);

    if (hrgnPPage)
        DeleteObject(hrgnPPage);

    if (hrgnPPageBounds)
        DeleteObject(hrgnPPageBounds);

    if (lprgnRDev)
        LocalFree(lprgnRDev);

    if (lprgnPPage)
        LocalFree(lprgnPPage);

    return(bRet) ;
}

/***************************************************************************
 * Emit a 16-bit CreateRegion record for the given region.
 *
 * This code is copied from the 16-bit metafile driver in gdi.
 *
 **************************************************************************/

WIN3REGION w3rgnEmpty =
{
    0,              // nextInChain
    6,              // ObjType
    0x2F6,          // ObjCount
    sizeof(WIN3REGION) - sizeof(SCAN) + 2,
                    // cbRegion
    0,              // cScans
    0,              // maxScan
    {0,0,0,0},      // rcBounding
    {0,0,0,{0,0},0} // aScans[]
};

BOOL bEmitWin3Region(PLOCALDC pLocalDC, HRGN hrgn)
{
/*
 * in win2, METACREATEREGION records contained an entire region object,
 * including the full header.  this header changed in win3.
 *
 * to remain compatible, the region records will be saved with the
 * win2 header.  here we save our region with a win2 header.
 */
    PWIN3REGION lpw3rgn;
    DWORD       cbNTRgnData;
    DWORD       curRectl;
    WORD        cScans;
    WORD        maxScanEntry;
    WORD        curScanEntry;
    DWORD       cbw3data;
    PRGNDATA    lprgn;
    LPRECT      lprc;
    PSCAN       lpScan;
    BOOL    bRet;

    ASSERTGDI(hrgn, "MF3216: bEmitWin3Region, hrgn is NULL");

    // Get the NT Region Data
    cbNTRgnData = GetRegionData(hrgn, 0, NULL);
    if (cbNTRgnData == 0)
    return(FALSE);

    lprgn = (PRGNDATA) LocalAlloc(LMEM_FIXED, cbNTRgnData);
    if (!lprgn)
    return(FALSE);

    cbNTRgnData = GetRegionData(hrgn, cbNTRgnData, lprgn);
    if (cbNTRgnData == 0)
    {
        LocalFree((HANDLE) lprgn);
    return(FALSE);
    }

    // Handle the empty region.

    if (!lprgn->rdh.nCount)
    {
    bRet = bEmitWin16CreateRegion(pLocalDC, sizeof(WIN3REGION) - sizeof(SCAN), (PVOID) &w3rgnEmpty);

    LocalFree((HANDLE)lprgn);
    return(bRet);
    }

    lprc = (LPRECT)lprgn->Buffer;

    // Create the Windows 3.x equivalent

    // worst case is one scan for each rect
    cbw3data = 2*sizeof(WIN3REGION) + (WORD)lprgn->rdh.nCount*sizeof(SCAN);

    lpw3rgn = (PWIN3REGION)LocalAlloc(LMEM_FIXED, cbw3data);
    if (!lpw3rgn)
    {
        LocalFree((HANDLE) lprgn);
    return(FALSE);
    }

    // Grab the bounding rect.
    lpw3rgn->rcBounding.left   = (SHORT)lprgn->rdh.rcBound.left;
    lpw3rgn->rcBounding.right  = (SHORT)lprgn->rdh.rcBound.right;
    lpw3rgn->rcBounding.top    = (SHORT)lprgn->rdh.rcBound.top;
    lpw3rgn->rcBounding.bottom = (SHORT)lprgn->rdh.rcBound.bottom;

    cbw3data = sizeof(WIN3REGION) - sizeof(SCAN) + 2;

    // visit all the rects
    curRectl     = 0;
    cScans       = 0;
    maxScanEntry = 0;
    lpScan       = lpw3rgn->aScans;

    while(curRectl < lprgn->rdh.nCount)
    {
    LPWORD  lpXEntry;
    DWORD   cbScan;

    curScanEntry = 0;       // Current X pair in this scan

    lpScan->scnPntTop    = (WORD)lprc[curRectl].top;
    lpScan->scnPntBottom = (WORD)lprc[curRectl].bottom;

    lpXEntry = (LPWORD) lpScan->scnPntsX;

    // handle rects on this scan
    do
    {
        lpXEntry[curScanEntry + 0] = (WORD)lprc[curRectl].left;
        lpXEntry[curScanEntry + 1] = (WORD)lprc[curRectl].right;
        curScanEntry += 2;
        curRectl++;
    } while ((curRectl < lprgn->rdh.nCount)
        && (lprc[curRectl-1].top    == lprc[curRectl].top)
        && (lprc[curRectl-1].bottom == lprc[curRectl].bottom)
           );

    lpScan->scnPntCnt      = curScanEntry;
    lpXEntry[curScanEntry] = curScanEntry;  // Count also follows Xs
    cScans++;

    if (curScanEntry > maxScanEntry)
        maxScanEntry = curScanEntry;

    // account for each new scan + each X1 X2 Entry but the first
    cbScan = sizeof(SCAN)-(sizeof(WORD)*2) + (curScanEntry*sizeof(WORD));
    cbw3data += cbScan;
    lpScan = (PSCAN)(((LPBYTE)lpScan) + cbScan);
    }

    // Initialize the header
    lpw3rgn->nextInChain = 0;
    lpw3rgn->ObjType = 6;           // old Windows OBJ_RGN identifier
    lpw3rgn->ObjCount= 0x2F6;       // any non-zero number
    lpw3rgn->cbRegion = (WORD)cbw3data;   // don't count type and next
    lpw3rgn->cScans = cScans;
    lpw3rgn->maxScan = maxScanEntry;

    bRet = bEmitWin16CreateRegion(pLocalDC, cbw3data-2, (PVOID) lpw3rgn);

    if (LocalFree((HANDLE)lprgn))
    ASSERTGDI(FALSE, "bEmitWin3Region: LocalFree(lprgn) Failed\n");
    if (LocalFree((HANDLE)lpw3rgn))
    ASSERTGDI(FALSE, "bEmitWin3Region: LocalFree(lpw3rgn) Failed\n");

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\mf3216\win16api.h ===
/****************************************************************************
 *
 *  Win16 Emitter Routines header file
 *
 *  Date:   7/18/91
 *  Author: Jeffrey Newman (c-jeffn)
 *
 ***************************************************************************/

#ifndef _WIN16_MF3216_
#define _WIN16_MF3216_

#pragma pack(1)

typedef struct tagRECTS {
    SHORT 	left;
    SHORT 	top;
    SHORT 	right;
    SHORT 	bottom;
} RECTS, *PRECTS;

typedef struct tagWIN16LOGPEN {
    WORD     lopnStyle;
    POINTS   lopnWidth;
    COLORREF lopnColor;
} WIN16LOGPEN, *LPWIN16LOGPEN;

typedef struct tagWIN16LOGBRUSH
  {
    WORD	lbStyle;
    DWORD	lbColor;
    SHORT       lbHatch;
  } WIN16LOGBRUSH, *LPWIN16LOGBRUSH;

typedef struct tagWIN16LOGFONT
{
    SHORT     lfHeight;
    SHORT     lfWidth;
    SHORT     lfEscapement;
    SHORT     lfOrientation;
    SHORT     lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    BYTE      lfFaceName[LF_FACESIZE];
} WIN16LOGFONT, *LPWIN16LOGFONT;

typedef struct tagMETARECORD0 {
    DWORD rdSize;
    WORD  rdFunction;
} METARECORD0;

// Define METARECORD1 through METARECORD9.

#define METARECORD_(n)				\
	typedef struct tagMETARECORD##n {	\
	    DWORD rdSize;			\
	    WORD  rdFunction;			\
	    WORD  rdParm[n];			\
	} METARECORD##n

METARECORD_(1);
METARECORD_(2);
METARECORD_(3);
METARECORD_(4);
METARECORD_(5);
METARECORD_(6);
METARECORD_(7);
METARECORD_(8);
METARECORD_(9);

typedef struct tagMETARECORD_CREATEFONTINDIRECT {
    DWORD rdSize;
    WORD  rdFunction;
    WIN16LOGFONT lf16;
} METARECORD_CREATEFONTINDIRECT;

typedef struct tagMETARECORD_CREATEPENINDIRECT {
    DWORD rdSize;
    WORD  rdFunction;
    WIN16LOGPEN lopn16;
} METARECORD_CREATEPENINDIRECT;

typedef struct tagMETARECORD_CREATEBRUSHINDIRECT {
    DWORD rdSize;
    WORD  rdFunction;
    WIN16LOGBRUSH lb16;
} METARECORD_CREATEBRUSHINDIRECT;

typedef struct tagMETARECORD_DIBCREATEPATTERNBRUSH {
    DWORD rdSize;
    WORD  rdFunction;
    WORD  iType;
    WORD  iUsage;
} METARECORD_DIBCREATEPATTERNBRUSH;

typedef struct tagMETARECORD_POLY {
    DWORD rdSize;
    WORD  rdFunction;
    WORD  cpt;
} METARECORD_POLY;

typedef struct tagMETARECORD_POLYPOLYGON {
    DWORD rdSize;
    WORD  rdFunction;
    WORD  ccpt;
} METARECORD_POLYPOLYGON;

typedef struct tagMETARECORD_DIBSTRETCHBLT {
    DWORD rdSize;
    WORD  rdFunction;
    DWORD rop;
    SHORT cySrc;
    SHORT cxSrc;
    SHORT ySrc;
    SHORT xSrc;
    SHORT cy;
    SHORT cx;
    SHORT y;
    SHORT x;
} METARECORD_DIBSTRETCHBLT;

typedef struct tagMETARECORD_SETPALENTRIES {
    DWORD rdSize;
    WORD  rdFunction;
    WORD  iStart;
    WORD  cEntries;
} METARECORD_SETPALENTRIES;

typedef struct tagMETARECORD_ESCAPE {
    DWORD rdSize;
    WORD  rdFunction;
    WORD  wEscape;
    WORD  wCount;
} METARECORD_ESCAPE, *PMETARECORD_ESCAPE;

#pragma pack()

#define bEmitWin16EOF(pLocalDC)                                            \
                   bW16Emit0(pLocalDC, 0)

#define bEmitWin16RealizePalette(pLocalDC)                                 \
                   bW16Emit0(pLocalDC, META_REALIZEPALETTE)

#define bEmitWin16SaveDC(pLocalDC)                                         \
                   bW16Emit0(pLocalDC, META_SAVEDC)

#define bEmitWin16SetTextAlign(pLocalDC, wFlags)                           \
                   bW16Emit1(pLocalDC, META_SETTEXTALIGN, wFlags)

#define bEmitWin16SetStretchBltMode(pLocalDC, iStretchMode)                \
                   bW16Emit1(pLocalDC, META_SETSTRETCHBLTMODE, iStretchMode)

#define bEmitWin16SetROP2(pLocalDC, nDrawMode)                             \
                   bW16Emit1(pLocalDC, META_SETROP2, nDrawMode)

#define bEmitWin16SetPolyFillMode(pLocalDC, iPolyFillMode)                 \
                   bW16Emit1(pLocalDC, META_SETPOLYFILLMODE, iPolyFillMode)

#define bEmitWin16SetBkMode(pLocalDC, iBkMode)                             \
                   bW16Emit1(pLocalDC, META_SETBKMODE, iBkMode)

#define bEmitWin16SelectPalette(pLocalDC, ihObject)                        \
                   bW16Emit1(pLocalDC, META_SELECTPALETTE, ihObject)

#define bEmitWin16SelectObject(pLocalDC, ihObject)                         \
                   bW16Emit1(pLocalDC, META_SELECTOBJECT, ihObject)

#define bEmitWin16DeleteObject(pLocalDC, ihObject)                         \
                   bW16Emit1(pLocalDC, META_DELETEOBJECT, ihObject)

#define bEmitWin16SetMapMode(pLocalDC, iMapMode)                           \
                   bW16Emit1(pLocalDC, META_SETMAPMODE, iMapMode)

#define bEmitWin16PaintRgn(pLocalDC, ihRgn)                                \
                   bW16Emit1(pLocalDC, META_PAINTREGION, ihRgn)

#define bEmitWin16InvertRgn(pLocalDC, ihRgn)                               \
                   bW16Emit1(pLocalDC, META_INVERTREGION, ihRgn)

#define bEmitWin16RestoreDC(pLocalDC, nSavedDC)                            \
                   bW16Emit1(pLocalDC, META_RESTOREDC, nSavedDC)

#define bEmitWin16ResizePalette(pLocalDC, cEntries) 	                   \
                   bW16Emit1(pLocalDC, META_RESIZEPALETTE, cEntries)

#define bEmitWin16SetTextColor(pLocalDC, crColor)                          \
                   bW16Emit2(pLocalDC, META_SETTEXTCOLOR,                  \
                             HIWORD(crColor), LOWORD(crColor))

#define bEmitWin16SetMapperFlags(pLocalDC, dwFlags)                        \
                   bW16Emit2(pLocalDC, META_SETMAPPERFLAGS,                \
                             HIWORD(dwFlags), LOWORD(dwFlags))

#define bEmitWin16SetBkColor(pLocalDC, crColor)                            \
                   bW16Emit2(pLocalDC, META_SETBKCOLOR,                    \
                             HIWORD(crColor), LOWORD(crColor))

#define bEmitWin16SetWindowOrg(pLocalDC, x, y)                             \
                   bW16Emit2(pLocalDC, META_SETWINDOWORG, x, y)

#define bEmitWin16SetWindowExt(pLocalDC, x, y)                             \
                   bW16Emit2(pLocalDC, META_SETWINDOWEXT, x, y)

#define bEmitWin16SetViewportOrg(pLocalDC, x, y)                           \
                   bW16Emit2(pLocalDC, META_SETVIEWPORTORG, x, y)

#define bEmitWin16SetViewportExt(pLocalDC, x, y)                           \
                   bW16Emit2(pLocalDC, META_SETVIEWPORTEXT, x, y)

#define bEmitWin16OffsetClipRgn(pLocalDC, x, y)                            \
                   bW16Emit2(pLocalDC, META_OFFSETCLIPRGN, x, y)

#define bEmitWin16FillRgn(pLocalDC, ihRgn, ihBrush)                        \
                   bW16Emit2(pLocalDC, META_FILLREGION, ihBrush, ihRgn)

#define bEmitWin16MoveTo(pLocalDC, x, y)                                   \
                   bW16Emit2(pLocalDC, META_MOVETO, x, y)

#define bEmitWin16LineTo(pLocalDC, x, y)                                   \
                   bW16Emit2(pLocalDC, META_LINETO, x, y)

#define bEmitWin16FrameRgn(pLocalDC, ihRgn, ihBrush, nWidth, nHeight)      \
                   bW16Emit4(pLocalDC, META_FRAMEREGION,                   \
                             nWidth, nHeight, ihBrush, ihRgn)

#define bEmitWin16ExcludeClipRect(pLocalDC, xLeft, yTop, xRight, yBottom)  \
                   bW16Emit4(pLocalDC, META_EXCLUDECLIPRECT,               \
                             xLeft, yTop, xRight, yBottom)

#define bEmitWin16IntersectClipRect(pLocalDC, xLeft, yTop, xRight, yBottom)\
                   bW16Emit4(pLocalDC, META_INTERSECTCLIPRECT,             \
                             xLeft, yTop, xRight, yBottom)

#define bEmitWin16SetPixel(pLocalDC, x, y, crColor)                        \
                   bW16Emit4(pLocalDC, META_SETPIXEL, x, y,                \
                             HIWORD(crColor), LOWORD(crColor))

#define bEmitWin16ExtFloodFill(pLocalDC, x, y, crColor, iMode)             \
                   bW16Emit5(pLocalDC, META_EXTFLOODFILL, x, y,            \
                             HIWORD(crColor), LOWORD(crColor), iMode)

#define bEmitWin16Rectangle(pLocalDC, x1, y1, x2, y2)                      \
                   bW16Emit4(pLocalDC, META_RECTANGLE, x1, y1, x2, y2)

#define bEmitWin16Ellipse(pLocalDC, x1, y1, x2, y2)                        \
                   bW16Emit4(pLocalDC, META_ELLIPSE, x1, y1, x2, y2)

#define bEmitWin16RoundRect(pLocalDC, x1, y1, x2, y2, x3, y3)              \
                   bW16Emit6(pLocalDC, META_ROUNDRECT, x1, y1, x2, y2, x3, y3)

#define bEmitWin16Arc(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4)            \
                   bW16Emit8(pLocalDC, META_ARC,                           \
                             x1, y1, x2, y2, x3, y3, x4, y4)

#define bEmitWin16Chord(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4)          \
                   bW16Emit8(pLocalDC, META_CHORD,                         \
                             x1, y1, x2, y2, x3, y3, x4, y4)

#define bEmitWin16Pie(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4)            \
                   bW16Emit8(pLocalDC, META_PIE,                           \
                             x1, y1, x2, y2, x3, y3, x4, y4)

#define bEmitWin16BitBltNoSrc(pLocalDC, x, y, cx, cy, rop)		   \
                   bW16Emit9(pLocalDC, META_DIBBITBLT,                     \
                             x, y, cx, cy, 0, 0, 0, HIWORD(rop), LOWORD(rop))

BOOL bW16Emit0
(
PLOCALDC pLocalDC,
WORD     RecordID
) ;

BOOL bW16Emit1
(
PLOCALDC pLocalDC,
WORD     RecordID,
WORD     x1
) ;

BOOL bW16Emit2
(
PLOCALDC pLocalDC,
WORD     RecordID,
WORD     x1,
WORD     x2
) ;

BOOL bW16Emit4
(
PLOCALDC pLocalDC,
WORD     RecordID,
WORD     x1,
WORD     x2,
WORD     x3,
WORD     x4
) ;

BOOL bW16Emit5
(
PLOCALDC pLocalDC,
WORD     RecordID,
WORD     x1,
WORD     x2,
WORD     x3,
WORD     x4,
WORD     x5
) ;

BOOL bW16Emit6
(
PLOCALDC pLocalDC,
WORD     RecordID,
WORD     x1,
WORD     x2,
WORD     x3,
WORD     x4,
WORD     x5,
WORD     x6
) ;

BOOL bW16Emit8
(
PLOCALDC pLocalDC,
WORD     RecordID,
WORD     x1,
WORD     x2,
WORD     x3,
WORD     x4,
WORD     x5,
WORD     x6,
WORD     x7,
WORD     x8
) ;

BOOL bW16Emit9
(
PLOCALDC pLocalDC,
WORD     RecordID,
WORD     x1,
WORD     x2,
WORD     x3,
WORD     x4,
WORD     x5,
WORD     x6,
WORD     x7,
WORD     x8,
WORD     x9
) ;

BOOL bEmitWin16CreateFontIndirect
(
  PLOCALDC pLocalDC,
  LPWIN16LOGFONT lpWin16LogFont
) ;

BOOL bEmitWin16Poly
(
  PLOCALDC pLocalDC,
  LPPOINTS ppt,
  SHORT    cpt,
  WORD     metaType
) ;

BOOL bEmitWin16PolyPolygon
(
  PLOCALDC pLocalDC,
  PPOINTS  ppt,
  PWORD    pcpt,
  WORD     cpt,
  WORD     ccpt
) ;

BOOL bEmitWin16StretchBlt
(
  PLOCALDC pLocalDC,
  SHORT    x,
  SHORT    y,
  SHORT    cx,
  SHORT    cy,
  SHORT    xSrc,
  SHORT    ySrc,
  SHORT    cxSrc,
  SHORT    cySrc,
  DWORD    rop,
  PBITMAPINFO lpbmi,
  DWORD       cbbmi,
  PBYTE    lpBits,
  DWORD    cbBits
) ;

BOOL bEmitWin16ExtTextOut
(
  PLOCALDC pLocalDC,
  SHORT    x,
  SHORT    y,
  WORD     fwOpts,
  PRECTS   prcts,
  PSTR     ach,
  SHORT    nCount,
  PWORD    lpDx
) ;

BOOL bEmitWin16CreateRegion
(
PLOCALDC pLocalDC,
DWORD    cbRgn,
PVOID    pRgn
) ;

BOOL bEmitWin16SetPaletteEntries
(
PLOCALDC        pLocalDC,
DWORD           iStart,
DWORD           cEntries,
LPPALETTEENTRY  pPalEntries
) ;

BOOL bEmitWin16CreatePalette
(
PLOCALDC     pLocalDC,
LPLOGPALETTE lpLogPal
) ;

BOOL bEmitWin16CreateBrushIndirect
(
  PLOCALDC        pLocalDC,
  LPWIN16LOGBRUSH lpLogBrush16
) ;

BOOL bEmitWin16CreateDIBPatternBrush
(
  PLOCALDC    pLocalDC,
  PBITMAPINFO pBitmapInfo,
  DWORD       cbBitmapInfo,
  PBYTE       pBits,
  DWORD       cbBits,
  WORD        iUsage,
  WORD        iType
) ;

BOOL bEmitWin16CreatePen
(
  PLOCALDC pLocalDC,
  WORD     iPenStyle,
  PPOINTS  pptsWidth,
  COLORREF crColor
) ;

BOOL bEmitWin16EscapeEnhMetaFile
(
  PLOCALDC pLocalDC,
  PMETARECORD_ESCAPE pmfeEnhMF,
  LPBYTE   lpEmfData
) ;
#endif // _WIN16_MF3216_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fontcmp\fontcmp.c ===
//************************************************************************//
//                                                                                                                                              
// Filename :  fontcmp.c                                                  
//                                                                         
// Description: This is the main file for the fontcmp application.        
//              This program is to compare two fonts for its various     
//              properties. The properties currently include the widths  
//              of the fonts.                                             
//                                                                         
// Program Model: Step 1: Add fonts from the input file.                  
//                Step 2: Create an array of sizes and styles.           
//                Step 3: Get the properties for two fonts for            
//                        corresponding sizes and styles.                
//
// Modified by: Tony Tsai 5/8/97 
//
// Created by:  Rajesh Munshi                                            
//                                                                       
// History:     Created on 03/28/97.                                      
//                                                                       
//************************************************************************//

#include <windows.h>
#include <stdio.h>
#include <winbase.h>
#include <wingdi.h>
#include <fcntl.h>
#include "fontcmp.h"

// Only support in NT 5, so mark it if you need it for NT 4.0
#define ABCWIDTH

WCHAR szShellFont[] = L"Micross.ttf";
CHAR szShellFontFace[] = "Microsoft Sans Serif";
WCHAR wszShellFontFace[] = L"Microsoft Sans Serif";

CHAR szMSSansSerif[] = "MS Sans Serif";
WCHAR wszMSSansSerif[] = L"MS Sans Serif";

WCHAR LargeFontFiles[] = L"fontsl.ini";
WCHAR SmallFontFiles[] = L"fontss.ini";

#ifdef ABCWIDTH
void VGetCharABCWidthsI();
#endif

//************************************************************************//
//                                                                        
// Function :  main                                                      
//                                                                        
// Parameters: number of arguments, arguments to FontLink.exe            
//                                                                        
// Thread safety: none.                                                   
//                                                                        
// Task performed:  This function calls routine to parse the parameters,  
//                  adds the fonts and then calls a routine to perform the
//                  the task of comparing character widths.               
//                                                                        
//************************************************************************//



INT __cdecl main (INT argc, CHAR *argv[])
{
    LPTSTR lpCmdLine;

    // Parse the command line:
    lpCmdLine = GetCommandLine();

    if (!bParseCommandLine(lpCmdLine))
        ExitProcess(0);

    if(!bGetNewShellFont())
        ExitProcess(0);

    if (!bAddFonts(lpszInputFile))
        ExitProcess(0);

    VCompareCharWidths();

    return TRUE;
}


BOOL    bGetNewShellFont()
{
    if (!AddFontResource(&szShellFont))
    {
        wprintf(TEXT("Error Occured while adding font %s.\n"), szShellFont);
        wprintf(TEXT("Error Code: %d\n"), GetLastError());
        return FALSE;
    }
    return TRUE;
}

//************************************************************************//
//                                                                        
// Function :  bParseCommandLine                                          
//                                                                        
// Parameters: pointer to the command line string                         
//                                                                        
// Thread safety: none.                                                   
//                                                                        
// Task performed:  The fontcmp programme should be called as             
//                            fontcmp <filename>                          
//                  Shows usage for other commandline styles.             
//                                                                        
//************************************************************************//

BOOL bParseCommandLine(LPTSTR lpCmdLine)
{
LPTSTR   lpS;
USHORT   i;                  
USHORT   num;
BOOL     bParse;

    lpS = lpCmdLine;

    // Get rid of the application exe name and then blank spaces 
    // from the command line.
    while (*lpS != TEXT(' ') && *lpS != TEXT('\0'))
        lpS++;

    while (*lpS == TEXT(' '))
        lpS++;

    if (*lpS == TEXT('?') || *lpS == TEXT('-'))
    {
        VDisplayProgramUsage();
        return FALSE;
    }

    lCharSet = 0;
    bParse = FALSE;
    num = 0;
    
    while (*lpS != TEXT('\0'))
    {
        i = (USHORT) *lpS++;
        // 0x0030 is L'0'
        // 0x0039 is L'9'
        if((i >= 0x0030) && (i <= 0x0039))
        {
            bParse = TRUE;
            num = num * 10 + (i - 0x0030);
        }
        else
        {
            if(bParse)
            {
                usCurrentCharSet[lCharSet++] = (BYTE)num;
                bParse = FALSE;
            }
            num = 0;
            while (*lpS == TEXT(' '))
                lpS++;
        }
    }

    if(bParse)
    {
        usCurrentCharSet[lCharSet++] = (BYTE)num;
        bParse = FALSE;
    }

    if (!lCharSet)
    {
        usCurrentCharSet[lCharSet++] = ANSI_CHARSET;
        usCurrentCharSet[lCharSet++] = RUSSIAN_CHARSET;
        usCurrentCharSet[lCharSet++] = GREEK_CHARSET;
        usCurrentCharSet[lCharSet++] = TURKISH_CHARSET;
        usCurrentCharSet[lCharSet++] = BALTIC_CHARSET;
        usCurrentCharSet[lCharSet++] = EASTEUROPE_CHARSET;
        usCurrentCharSet[lCharSet++] = HEBREW_CHARSET;
        usCurrentCharSet[lCharSet++] = THAI_CHARSET;
        usCurrentCharSet[lCharSet++] = ARABIC_CHARSET;
        usCurrentCharSet[lCharSet++] = VIETNAMESE_CHARSET;
    }
    
    return TRUE;

}


//************************************************************************//
//                                                                        
// Function :  bAddFonts                                                  
//                                                                        
// Parameters: name of the file that has the font names and path.         
//                                                                        
// Thread safety: none.                                                   
//                                                                        
// Task performed:  Open the file, and read the fontnames and paths.      
//                  Perform AddFontResource on the fonts.                 
//                                                                        
//************************************************************************//


BOOL bAddFonts(LPTSTR lpszInputFile)
{

FILE  *fpFontFile;
TCHAR lpszFontPath[MAX_PATH+1];
int   len;

HDC   dispDC;
INT  xRes;

    dispDC = CreateDC(L"DISPLAY", NULL, NULL, NULL);
    
    xRes = GetDeviceCaps(dispDC, LOGPIXELSX);

    DeleteDC(dispDC);

    if(xRes == 120)
        lpszInputFile = LargeFontFiles;
    else if(xRes == 96)
        lpszInputFile = SmallFontFiles;
    else
    {
        wprintf(L" Wrong Display Resolution %d , please contact YungT \n", xRes);
        return FALSE;
    }
    
    // We are using the unicode version of fopen here as the filename is 
    // specified as an unicode string but the file is read as ansi as it
    // is opened in the "r" mode and not the binary mode.
	if ((fpFontFile = _wfopen(lpszInputFile,TEXT("r"))) == NULL)
	{
        wprintf(TEXT("Error Occured while opening %s. FontCmp Aborted...\n"), lpszInputFile);
        return FALSE;
    }
    
    GetCurrentDirectory(MAX_PATH+1, lpszFontPath);
    len = wcslen(lpszFontPath);
    lpszFontPath[len] = L'\\';
    while (fwscanf(fpFontFile, TEXT("%s\n"), lpszFontPath+len+1))
    {
        if (!AddFontResource(lpszFontPath))
        {
            wprintf(TEXT("Error Occured while adding font %s.\n"), lpszFontPath);
            wprintf(TEXT("Error Code: %d\n"), GetLastError());
        }
    }

    if (fclose(fpFontFile))
    {
        wprintf(TEXT("Error Occured while closing %s.\n"), lpszInputFile);
        return FALSE;
    }

    return TRUE;

}


//************************************************************************//
//                                                                        
// Function :  VCompareCharWidths                                         
//                                                                        
// Parameters: none                                                       
//                                                                        
// Thread safety: none.                                                   
//                                                                        
// Task performed:  Vary the point sizes and the char sets fields in the  
//                  LOGFONT structure to create different fonts.          
//                  Get character widths for all the characters and write 
//                  to the output log file.                               
//                                                                        
//************************************************************************//

BYTE ucGetCharSet(BYTE i)
{
    
    switch (i)
    {
        case ANSI_CHARSET:
            lCharSetIndex = 0;           
            return ANSI_CHARSET;
        case RUSSIAN_CHARSET:
            lCharSetIndex = 1;           
            return RUSSIAN_CHARSET;
        case GREEK_CHARSET:
            lCharSetIndex = 2;           
            return GREEK_CHARSET;
        case TURKISH_CHARSET:
            lCharSetIndex = 3;           
            return TURKISH_CHARSET;
        case BALTIC_CHARSET:
            lCharSetIndex = 4;           
            return BALTIC_CHARSET;
        case EASTEUROPE_CHARSET:
            lCharSetIndex = 5;           
            return EASTEUROPE_CHARSET;
        case HEBREW_CHARSET:
            lCharSetIndex = 6;           
            return HEBREW_CHARSET;
        case THAI_CHARSET:
            lCharSetIndex = 7;           
            return THAI_CHARSET;
        case ARABIC_CHARSET:
            lCharSetIndex = 8;           
            return ARABIC_CHARSET;
        case VIETNAMESE_CHARSET:
            lCharSetIndex = 9;           
            return VIETNAMESE_CHARSET;
        default:
            break;
    }

    wprintf(TEXT("Wrong charset have been input, please re-run it\n"));

    ExitProcess(0);

//    return ANSI_CHARSET;
}

VOID VCompareCharWidths(VOID)
{
FILE     *fpOutputFile;
INT      i, j, k;
INT      piFont1Widths[CHARSET_SIZE];
INT      piFont2Widths[CHARSET_SIZE];
HDC      hdc;
FLOAT    flAvgFont1, flAvgFont2;
FLOAT    flAlphaAvgFont1, flAlphaAvgFont2;
INT      iFont1Dim, iFont2Dim, iFont3Dim, iFont4Dim;
BYTE     ucCharSet;   

	if ((fpOutputFile = _wfopen(TEXT("output.log"),TEXT("w"))) == NULL)
	{
        wprintf(TEXT("Error Occured while creating output.log FontCmp Aborted...\n"));
        return;
    }


    if (fwprintf(fpOutputFile, TEXT("\t %s \t \t %s\n"), wszMSSansSerif, wszShellFontFace) < 0)
    {
        wprintf(TEXT("Error Occured while writing to the file. FontCmp Aborted...\n"));
        fclose(fpOutputFile);
        return;
    }

#ifdef ABCWIDTH
    VGetCharABCWidthsI();  
#endif

    for (i = 0; i < lCharSet; i++)
    {
        for (j = 0; j < NUM_POINTS_SIZES; j++)
        {
            if ((hdc = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL )) == NULL)
            {
                wprintf(TEXT("Error Occured while creating DC. FontCmp Aborted...\n"));
                fclose(fpOutputFile);
                return;
            }
            ucCharSet = ucGetCharSet(usCurrentCharSet[i]);

            VGetCharWidths(hdc, ucCharSet, j, szMSSansSerif, &piFont1Widths[0], &iFont1Dim, &iFont3Dim);
            VGetCharWidths(hdc, ucCharSet, j, szShellFontFace, &piFont2Widths[0], &iFont2Dim, &iFont4Dim);
            

            if (fwprintf(fpOutputFile, TEXT("===== Point Size: %d CHARSET: %s =====\n"),
                        piPointSize[j], lplpszCharSet[lCharSetIndex]) < 0)
            {
                wprintf(TEXT("Error Occured while writing to the file. FontCmp Aborted...\n"));
                DeleteDC(hdc);
                fclose(fpOutputFile);
                return;
            }

            flAvgFont1 = flAvgFont2 = flAlphaAvgFont1 = flAlphaAvgFont2 = 0;

            if( ucCharSet == ANSI_CHARSET)
                k = 32;
            else
                k = 128;
                
            for (;k < CHARSET_SIZE; k++)
            {

                flAvgFont1 += piFont1Widths[k];
                flAvgFont2 += piFont2Widths[k];

                if (fwprintf(fpOutputFile, TEXT("[Char %d: %c] \t %d \t \t %d\n"), 
                    k, k, piFont1Widths[k], piFont2Widths[k]) < 0)
                {
                    wprintf(TEXT("Error Occured while writing to the file. FontCmp Aborted...\n"));
                    DeleteDC(hdc);
                    fclose(fpOutputFile);
                    return;
                }
            }            

            for (k = 0; k < ALPHABET_RANGE; k++)
            {             
                flAlphaAvgFont1 += piFont1Widths[UPPERCASE_START+k] + piFont1Widths[LOWERCASE_START+k];
                flAlphaAvgFont2 += piFont2Widths[UPPERCASE_START+k] + piFont2Widths[LOWERCASE_START+k];
            }

            if (fwprintf(fpOutputFile, TEXT("***** Avg Widths: %f %f =====\n***** Avg Alphabet [A-Za-z] Widths: %f %f =====\n***** Avg Dimensions: %d %d  =====\n***** Font Height: %d %d  =====\n\n"),
                        flAvgFont1/CHARSET_SIZE, flAvgFont2/CHARSET_SIZE, 
                        flAlphaAvgFont1/(2*ALPHABET_RANGE), flAlphaAvgFont2/(2*ALPHABET_RANGE),
                        iFont1Dim, iFont2Dim, iFont3Dim, iFont4Dim ) < 0)
            {
                wprintf(TEXT("Error Occured while writing to the file. FontCmp Aborted...\n"));
                DeleteDC(hdc);
                fclose(fpOutputFile);
                return;
            }

            if (!DeleteDC(hdc))
            {
                wprintf(TEXT("Error Occured while deleting DC.\n"));
            }
            
        }

    }


    if (fclose(fpOutputFile))
    {
        wprintf(TEXT("Error Occured while closing output.log\n"));
        return;
    }

}

#ifdef ABCWIDTH

ABC gABC[4096];

//************************************************************************//
//                                                                        
// Function :  VGetCharWidths                                             
//                                                                        
// Parameters: hdc, indices for point size and char set, font face name   
//             an array to store the character widths.                    
//                                                                        
// Thread safety: none.                                                   
//                                                                        
// Task performed:  Create the font with the input specifications.        
//                  Call GetCharWidth32() on the font.                    
//                                                                        
//************************************************************************//
void VGetCharABCWidthsI()
{
HDC         hdc;
FILE        *fpOutputFile;
LOGFONT     lf;
HFONT       hFont, hFontOld;
INT         iTemp, k;
TEXTMETRIC  tmFont;
LONG        xRes;
LONG        yRes;
CHAR        textFace[LF_FACESIZE];
UINT        i, j, lIndices, lThaiIndices;
WCHAR       wszThai[512], * pwszThai;
UINT        uThaiGlyphIndices[512];
BOOL        bThaiGlyph;

    if ((hdc = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL )) == NULL)
    {
        wprintf(TEXT("Error Occured while creating DC. FontCmp Aborted...\n"));
        return;
    } 

	if ((fpOutputFile = _wfopen(TEXT("ABC.log"),TEXT("w"))) == NULL)
	{
        wprintf(TEXT("Error Occured while creating output.log FontCmp Aborted...\n"));
        return;
    }

    fwprintf(fpOutputFile, TEXT("===== Glyph index      A   B  C Width =====\n"));

    memset(&lf, 0, sizeof(LOGFONT));

    lf.lfHeight = -MulDiv(8, GetDeviceCaps(hdc, LOGPIXELSY), 72); 
    lf.lfCharSet = 0;
    lstrcpy(lf.lfFaceName, szShellFontFace);

    hFont    = CreateFontIndirectA(&lf);
   
 
    if(hFontOld = SelectObject( hdc, hFont ))
    {
        
        GetTextFaceA(hdc, LF_FACESIZE, textFace);
        if(_strcmpi(lf.lfFaceName, textFace))
            printf("Error Text face name in DC %s. LogFont Face Name %s charset %d\n", textFace, lf.lfFaceName, lf.lfCharSet);
        
        // Thai Unicode range
        pwszThai = wszThai;
        for(i = 0x0e00; i <= 0x0e7f; i++)
            *pwszThai++ = (WCHAR) i;
        for(i = 0xf700; i <= 0xf7ff; i++)
            *pwszThai++ = (WCHAR) i;

        lThaiIndices = (UINT)GetGlyphIndices( hdc, wszThai, 384, uThaiGlyphIndices, 512);
        printf("how many Thai glyph indices %d\n", lThaiIndices);
        lIndices = (UINT)GetGlyphIndices( hdc, NULL, 0, NULL, 0);
        printf("how many glyph indices %d\n", lIndices);
        GetCharABCWidthsI( hdc, 0, (UINT) lIndices, NULL, gABC);
        for(i = 0; i < lIndices; i++)
        {
            // We could use the binary serch? But it is fine with linear search
            // No performance request
            bThaiGlyph = FALSE;
            for (j = 0; j < lThaiIndices; j ++)
            {
                if(i == uThaiGlyphIndices[j])
                {
                    bThaiGlyph = TRUE;
                    break;
                }
            }
            
            if(!bThaiGlyph && ((gABC[i].abcA < 0) || (gABC[i].abcC < 0)))
                fwprintf(fpOutputFile, TEXT("===== Glyph index %d    %d   %d  %d =====\n"), i, gABC[i].abcA, gABC[i].abcB, gABC[i].abcC);
        }
    }

    if (fclose(fpOutputFile))
    {
        wprintf(TEXT("Error Occured while closing output.log\n"));
        return;
    }
}

#endif

//************************************************************************//
//                                                                        
// Function :  VGetCharWidths                                             
//                                                                        
// Parameters: hdc, indices for point size and char set, font face name   
//             an array to store the character widths.                    
//                                                                        
// Thread safety: none.                                                   
//                                                                        
// Task performed:  Create the font with the input specifications.        
//                  Call GetCharWidth32() on the font.                    
//                                                                        
//************************************************************************//

VOID VGetCharWidths(HDC hdc, BYTE charset, INT m, CHAR *lpszFont, INT *piFontWidths, INT *pFontDim, INT *pFontHtDim)
{

LOGFONT lf;
HFONT hFont, hFontOld;
INT iTemp, k;
TEXTMETRIC tmFont;
// HDC     dispDC;
LONG xRes;
LONG yRes;
CHAR   textFace[LF_FACESIZE];
WCHAR   textFaceW[LF_FACESIZE];

    memset(&lf, 0, sizeof(LOGFONT));

    lf.lfHeight = -MulDiv(piPointSize[m], GetDeviceCaps(hdc, LOGPIXELSY), 72); 
    lf.lfCharSet = charset;
    lstrcpy(lf.lfFaceName, lpszFont);

    hFont    = CreateFontIndirectA(&lf);
   
    if(!hFont)
    {
        wprintf(TEXT("Error Occured while creating Font %s. Point size %d, charset %d\n"),lpszFont,piPointSize[m], lf.lfCharSet);
        return;
    }

  
    if(hFontOld = SelectObject( hdc, hFont ))
    {
        for( k = 0; k < 256; k++ ) piFontWidths[k] = 0;

        GetTextFaceA(hdc, LF_FACESIZE, textFace);
        GetTextFaceW(hdc, LF_FACESIZE, textFaceW);
        if(_strcmpi(lf.lfFaceName, textFace))
            printf("Error Text face name in DC %s. LogFont Face Name %s charset %d\n", textFace, lf.lfFaceName, lf.lfCharSet);
        
        if (!GetCharWidth32A(hdc, 0, CHARSET_SIZE-1, piFontWidths))
        {
            wprintf(TEXT("Error Occured while getting fonts width for Font %s \n"),textFaceW);
            wprintf(TEXT("Error code: %d\n"), GetLastError());
        }


       *pFontDim = GdiGetCharDimensions(hdc, &tmFont, pFontHtDim);
       GetTextMetrics(hdc, &tmFont);
//       *pFontDim = tmFont.tmAveCharWidth;
       *pFontHtDim = tmFont.tmHeight;

        SelectObject( hdc, hFontOld );
    }
    
    DeleteObject( hFont );

}


//************************************************************************//
//                                                                        
// Function :  VGetRidOfSlashN                                            
//                                                                        
// Parameters: fontface name                                              
//                                                                        
// Thread safety: none.                                                   
//                                                                        
// Task performed:  Replace the '\n' in the end of the string with a '\0' 
//                                                                        
//************************************************************************//


VOID VGetRidOfSlashN(LPTSTR lpszFontName)
{
INT i = 0;


    while (lpszFontName[i] != TEXT('\0') && lpszFontName[i] != TEXT('\n'))
        i++;

    lpszFontName[i] = TEXT('\0');

}



//************************************************************************//
//                                                                        
// Function :  VDisplayProgramUsage                                       
//                                                                        
// Parameters: none                                                       
//                                                                        
// Thread safety: none.                                                   
//                                                                        
// Task performed:  This function just does the simple task of printing   
//                  how the program should be run.                        
//                                                                        
//************************************************************************//

VOID VDisplayProgramUsage(VOID)
{

    wprintf(TEXT("Usage of FontCmp:\n"));
    wprintf(TEXT("    fontcmp \n"));
    wprintf(TEXT("    all the charset will be parsed, or you can type charset\n"));
    wprintf(TEXT("    fontcmp 0 177 178 161 162 163 222 238 204\n"));
    wprintf(TEXT("    0 ANSI chrset 177 HEBREW_CHARSET\n"));
    wprintf(TEXT("    178 ARABIC_CHARSET 161 GREEK_CHARSET\n"));
    wprintf(TEXT("    162 TURKISH_CHARSET 163 VIETNAMESE_CHARSET\n"));
    wprintf(TEXT("    204 RUSSIAN_CHARSET 222 THAI_CHARSET  \n"));
    wprintf(TEXT("    238 EASTEUROPEAN_CHARSET\n"));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fareast\kiwi\main.cxx ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>


void DoUsage()
{
	printf("Usage: kiwi inputfile\n");
}



typedef struct _TOKEN_ID {
	WCHAR *String;
	UINT Value;
} TOKEN_ID;


#define NO_MATCH					0
#define LOGFONT_W					1
#define LOGFONT_A                   2
#define GET_TEXT_EXTENT_POINT		3
#define GET_RESOLUTION				4
#define GET_TEXT_FACE               5
#define GET_TEXT_EXTENTEX_POINT     6
#define GET_CHAR_WIDTH              7
#define GET_CHAR_ABC_WIDTHS         8
#define GET_CHARACTER_PLACEMENT     9
#define GET_GLYPHOUTLINE            10
#define GET_KERNINGPAIRS            11


TOKEN_ID Tokens[] = { {L"[LOGFONTW]",LOGFONT_W},
					  {L"[LOGFONTA]",LOGFONT_A},
					  {L"[GETTEXTEXTENTPOINT]",GET_TEXT_EXTENT_POINT},
					  {L"[GETRESOLUTION]",GET_RESOLUTION},
		              {L"[GETTEXTFACE]",GET_TEXT_FACE},
					  {L"[GETTEXTEXTENTEXPOINT]",GET_TEXT_EXTENTEX_POINT},
					  {L"[GETCHARWIDTH]",GET_CHAR_WIDTH},
					  {L"[GETCHARABCWIDTHS]",GET_CHAR_ABC_WIDTHS},
                      {L"[GETCHARACTERPLACEMENT]",GET_CHARACTER_PLACEMENT},
					  {L"[GETGLYPHOUTLINE]",GET_GLYPHOUTLINE},
                      {L"[GETKERNINGPAIRS]",GET_KERNINGPAIRS}};


UINT StringToToken(WCHAR *String)
{
	int i;

	for(i = 0; i < sizeof(Tokens) / sizeof(TOKEN_ID); i++)
	{
		if(!wcsicmp(String,Tokens[i].String))
		{
			return(Tokens[i].Value);
		}
	}
	return(NO_MATCH);
}



void SkipComment(FILE *File)
{
	unsigned char Value;

	while(((Value = (unsigned char) getc(File)) == ' ') ||
		  (Value == 0x10));
	

	if(Value == ';')
	{
		while(!feof(File) && (Value = (unsigned char) getc(File)) && Value != 0xA);
	}
	else
	{
		ungetc(Value,File);
	}
}
			


BOOL ReadByteFromLine(FILE *File, PBYTE Result)
{
	ULONG Value;

	SkipComment(File);

	if(fscanf(File,"%d", &Value) != 1)
	{
		return(FALSE);
	}
	else
	{
		*Result = (BYTE) Value;
	}
	return(TRUE);
}

BOOL ReadIntFromLine(FILE *File, int *Result)
{
	INT Value;
	BOOL IsHex = FALSE;
	char HexCheck;

	SkipComment(File);

	while(!feof(File) && (((HexCheck = (char) getc(File)) == ' ') || 
			(HexCheck == 0xA) || (HexCheck == 0xD)));

	if(feof(File))
	{
		return(FALSE);
	}

	if(toupper(HexCheck) == 'X')
	{
		IsHex = TRUE;
	}
	else
	{
		ungetc(HexCheck,File);
	}

	if(fscanf(File,(IsHex) ? "%x" : "%d", &Value) != 1)
	{
		return(FALSE);
	}
	else
	{
		*Result = Value;
	}
	return(TRUE);
}
	
BOOL ReadUnicodeStringFromLine(FILE *File, WCHAR *ResultString)
{
	int Value;
	WCHAR *String = ResultString;

	SkipComment(File);

	while(!feof(File) && (((Value = (char) getc(File)) == ' ') || 
			(Value == 0xA) || (Value == 0xD)));

	if(feof(File))
	{
		return(FALSE);
	}

	// string is in the form \xxx\xxx where xxx are hex values for
	// unicode codepoints

	if(Value == '\\')
	{
		while(Value == '\\')
		{
			WCHAR CodePoint = 0;

			while(!feof(File) && (Value = getc(File)) && isxdigit(Value))
			{
				if(isdigit(Value))
				{
					Value = Value - '0';
				}
				else
				{
					Value = _toupper(Value);
					Value = Value - 'A' + 10;
				}

				CodePoint = CodePoint * 16 + Value;
			}
			*String++ = CodePoint;
		}
		*String++ = 0;		
	}
	else if(Value == '"')
	{
	// trying to match a string in the form "....."

		while(!feof(File) && (Value = getc(File)) && Value != '"')
		{
			*String++ = (WCHAR) Value;
		}
		*String++ = 0;
	} 
	else
	{
		ungetc(Value,File);
		while(!feof(File) && (Value = getc(File)) && Value != ' ' && 
			  Value != 0xA && Value != 0xD)
		{
			*String++ = (WCHAR) Value;
		}
		*String++ = 0;
		ungetc(Value,File);
	}

	return(wcslen(ResultString) != 0);
}

				
BOOL ReadStringFromLine(FILE *File, char *ResultString)
{
	WCHAR SignExtendedStringBuffer[255],*StringCounter;

	if(ReadUnicodeStringFromLine(File,SignExtendedStringBuffer))
	{
		StringCounter = SignExtendedStringBuffer;

		while(*StringCounter)
		{
			*ResultString++ = (char) *StringCounter++;
		}
		*ResultString = 0;
		return(TRUE);
	}

	return(FALSE);
}


BOOL DoLogfont(FILE *File, HFONT *CurrentFont, BOOL Unicode)
{
	LOGFONTW LogfontW;
	LOGFONTA LogfontA;
	LOGFONTW *Logfont;

	if(Unicode)
	{
		Logfont = &LogfontW;
	}
	else
	{
		Logfont = (LOGFONTW*) &LogfontA;
	}

	if(!ReadIntFromLine(File,(int*) &Logfont->lfHeight) ||
	   !ReadIntFromLine(File,(int*) &Logfont->lfWidth)  ||
	   !ReadIntFromLine(File,(int*) &Logfont->lfEscapement) ||
	   !ReadIntFromLine(File,(int*) &Logfont->lfOrientation) ||
	   !ReadIntFromLine(File,(int*) &Logfont->lfWeight) ||
	   !ReadByteFromLine(File,&Logfont->lfItalic) ||
	   !ReadByteFromLine(File,&Logfont->lfUnderline) ||
	   !ReadByteFromLine(File,&Logfont->lfStrikeOut) ||
	   !ReadByteFromLine(File,&Logfont->lfCharSet) ||
	   !ReadByteFromLine(File,&Logfont->lfOutPrecision) ||
	   !ReadByteFromLine(File,&Logfont->lfClipPrecision) ||
	   !ReadByteFromLine(File,&Logfont->lfQuality) ||
	   !ReadByteFromLine(File,&Logfont->lfPitchAndFamily))												   
	{
		return(FALSE);
	}

	if(Unicode)
	{
		if(!ReadUnicodeStringFromLine(File,(WCHAR*) LogfontW.lfFaceName))
		{
			return(FALSE);
		}
		*CurrentFont = CreateFontIndirectW(&LogfontW);
	}
	else
	{
		if(!ReadStringFromLine(File,(char*) LogfontA.lfFaceName))
		{
			return(FALSE);
		}
		*CurrentFont = CreateFontIndirectA(&LogfontA);
	}	

	return(TRUE);
}


BOOL DoGetTextExtentPoint(FILE *File, HDC CurrentDC)
{
	char StringBuffer[255];

	if(ReadStringFromLine(File,StringBuffer))
	{
		SIZE Size;

		GetTextExtentPointA(CurrentDC, 
							StringBuffer, 
							strlen(StringBuffer),
							&Size);

		printf("GetTextExtentPoint: %d %d\n", Size.cx, Size.cy);
		return(TRUE);
	}		
	return(FALSE);
}


BOOL DoGetTextExtentExPoint(FILE *File, HDC CurrentDC)
{
	char StringBuffer[255];
	int MaxExtent;

	if(ReadStringFromLine(File,StringBuffer) &&
	   ReadIntFromLine(File,&MaxExtent))
	{
		SIZE Size;
		INT Fit;
		INT *DxArray = (INT*) LocalAlloc(LMEM_FIXED, strlen(StringBuffer)*sizeof(INT));

		if(DxArray)
		{
			GetTextExtentExPointA(CurrentDC, 
								  StringBuffer, 
								  strlen(StringBuffer),
								  MaxExtent,
								  &Fit,
								  DxArray,
								  &Size);

			printf("GetTextExtentExPoint: %d %d %d { ", Size.cx, Size.cy, Fit);
		
			int i;

			for(i = 0; i < Fit; i++)
			{
				printf("%d ", DxArray[i]);
			}

			printf("}\n");

			LocalFree(DxArray);
			return(TRUE);
		}
		else
		{
			printf("GetTextExtentExPoint: out of memory\n");
		}

	}		
	return(FALSE);
}


BOOL DoGetCharWidth(FILE *File, HDC CurrentDC, BOOL ThirtyTwo)
{
	INT First, Last, Widths[256];

	if(ReadIntFromLine(File,&First) && 
	   ReadIntFromLine(File,&Last))
	{
		printf(ThirtyTwo ? "GetCharWidth32: " : "GetCharWidth: ");

		if((ThirtyTwo) ? GetCharWidth32(CurrentDC,First,Last,Widths) :
						 GetCharWidth(CurrentDC,First,Last,Widths))
		{
			INT i;

			for(i = 0; i < Last-First; i++)
			{
				printf("%d ", Widths[i]);
			}

			printf("\n");
		}
		else
		{
			printf("call failed\n");
		}
		return(TRUE);
	}
	return(FALSE);
}


BOOL DoGetKerningPairs(FILE *File, HDC CurrentDC)
{
	UINT NumPairs;
	
	NumPairs = GetKerningPairs(CurrentDC, 0, NULL);

	printf("GetKerningPairs: ");

	if(NumPairs)
	{
		
		KERNINGPAIR *KerningBuffer;
		
		KerningBuffer = (KERNINGPAIR*) LocalAlloc(LMEM_FIXED, sizeof(KERNINGPAIR) * NumPairs);

		if(KerningBuffer)
		{
			if(GetKerningPairs(CurrentDC, NumPairs, KerningBuffer) == NumPairs)
			{
				UINT j;
				
				printf("%d\n", NumPairs);

				for(j = 0; j < NumPairs; j++)
				{
					printf("(%x,%x,%x)\n", KerningBuffer[j].wFirst, KerningBuffer[j].wSecond, 
						   KerningBuffer[j].iKernAmount);
				}

				printf("\n");
			}
			else
			{	
				printf("failed\n");
			}
			LocalFree(KerningBuffer);
		}
		else
		{
			printf("mem alloc failed\n");
		}
	}
	else
	{
		printf("failed\n");
	}

	return(TRUE);
}

BOOL DoGetCharAbcWidths(FILE *File, HDC CurrentDC)
{
	INT First, Last;
	ABC AbcWidths[256];

	if(ReadIntFromLine(File,&First) && 
	   ReadIntFromLine(File,&Last))
	{
		printf("GetCharAbcWidth: ");

		if(GetCharABCWidths(CurrentDC,First,Last,AbcWidths))
		{
			INT i;

			for(i = 0; i < Last-First; i++)
			{
				printf("(%d %d %d) ", AbcWidths[i].abcA, AbcWidths[i].abcB, AbcWidths[i].abcC);
			}

			printf("\n");
		}
		else
		{
			printf("call failed\n");
		}
		return(TRUE);
	}
	return(FALSE);
}
					


BOOL DoGetCharacterPlacement(FILE *File, HDC CurrentDC)
{
	char StringBuffer[255];
	int MaxExtent;
	UINT Flags;

	if(ReadStringFromLine(File,StringBuffer) &&
	   ReadIntFromLine(File,&MaxExtent) &&
	   ReadIntFromLine(File,(INT*)&Flags))
	{
		GCP_RESULTSA Results;
		PVOID ResultsBuffer;
		UINT StringSize = strlen(StringBuffer);

		UINT BufferSize = ( sizeof(char) + // lpOutString
						    sizeof(UINT) + // lpOrder
							sizeof(INT)  + // lpDX
							sizeof(INT)  + // lpCaretPos
							sizeof(char) + // lpClass
							sizeof(WCHAR)   // lpGlyphs
							) * StringSize + sizeof(char); // extra char for null in lpOutString;

		ResultsBuffer = LocalAlloc(LPTR, BufferSize);

		if(ResultsBuffer)
		{
			int	i;
			DWORD ReturnValue;

			Results.lStructSize = sizeof(Results);
			Results.lpOutString = (LPSTR) ResultsBuffer;
			Results.lpOrder = (UINT*) &Results.lpOutString[StringSize+1];
			Results.lpDx = (INT*) &Results.lpOrder[StringSize];
			Results.lpCaretPos = &Results.lpDx[StringSize];
			Results.lpClass = (LPSTR) &Results.lpCaretPos[StringSize];
			Results.lpGlyphs = (WCHAR*) &Results.lpClass[StringSize];
			Results.nGlyphs = StringSize;


			// if the flags specify GCP_JUSTIFY_IN then read in the DX array

			if(Flags & GCP_JUSTIFYIN)
			{
				UINT j;

				for(j = 0; j < StringSize; j++)
				{
					if(!ReadIntFromLine(File,&Results.lpDx[j]))
					{
						LocalFree(ResultsBuffer);
						return(FALSE);
					}
				}
			}


			ReturnValue = GetCharacterPlacementA(CurrentDC, 
						 			             StringBuffer, 
								                 StringSize, 
								                 MaxExtent,
								                 &Results,
								                 Flags);

			printf("GetCharacterPlacement: %d %d %x\n", Results.nGlyphs, Results.nMaxFit, ReturnValue);

			if(ReturnValue)
			{
				printf("  lpOutString : %s\n", Results.lpOutString);
				printf("  lpOrder : ");

				for(i = 0; i < Results.nMaxFit; i++)
				{
					printf("%d ", Results.lpOrder[i]);
				}

				printf("\n  lpCaretPos : ");

				for(i = 0; i < Results.nMaxFit; i++)
				{
					printf("%d ", Results.lpCaretPos[i]);
				}

				printf("\n  lpClass : ");

				for(i = 0; i < Results.nMaxFit; i++)
				{
					printf("%d ", Results.lpClass[i]);
				}

				printf("\n  lpDx : ");

				for(i = 0; i < (int) Results.nGlyphs; i++)
				{
					printf("%d ", Results.lpDx[i]);
				}			
								
				printf("\n  lpGlyphs : ");

				for(i = 0; i < (int) Results.nGlyphs; i++)
				{
					printf("%d ", Results.lpGlyphs[i]);
				}
			}

			printf("\n");

			LocalFree(ResultsBuffer);
		}

		return(TRUE);
	}

	return(FALSE);
}


BOOL DoGetGlyphOutline(FILE *File, HDC CurrentDC)
{
	UINT Glyph;

	if(ReadIntFromLine(File,(INT*) &Glyph))
	{
		char OutlineBuffer[2048];
		int NumBytes;
		GLYPHMETRICS Metrics;
		MAT2 Matrix;

		memset((void*)&Matrix, 0, sizeof(Matrix));
		Matrix.eM11.value = Matrix.eM22.value = 1;

		printf("GetGlyphOutline: ");

		if(NumBytes = GetGlyphOutline(CurrentDC, Glyph, GGO_NATIVE, &Metrics,
									  2048, OutlineBuffer, &Matrix))
		{
			int i;

			for(i = 0; i < NumBytes; i++)
			{
				printf("%x ", OutlineBuffer[i]);
			}
			printf("\n");
		}
		else
		{
			printf("failed \n");
		}
		return(TRUE);
	}
	else
	{
		return(FALSE);
	}
}




void main(int argc, char *argv[])
{
	FILE *InputFile;

	if(argc < 2 || argc > 3)
	{
		DoUsage();
		exit;
	}
	
   	if((InputFile = fopen(argv[1], "r")) == (FILE*) -1)
	{
		printf("Unable to open file %s\n", argv[1]);
		exit;
	}
	
	HFONT CurrentFont = NULL;
	HFONT OldFont = NULL;
	HDC CurrentDC = CreateDC("Display", NULL, NULL, NULL);

	BOOL ValidInput = TRUE;

	do
	{
		WCHAR StringBuffer[255];
		

		if(!ReadUnicodeStringFromLine(InputFile,StringBuffer))
		{
			break;
		}

		switch(StringToToken(StringBuffer))
		{
		case LOGFONT_W:
			if(CurrentFont)
			{
				SelectObject(CurrentDC, OldFont);
				DeleteObject(CurrentFont);
			}
			
			if(ValidInput = DoLogfont(InputFile,&CurrentFont,TRUE))
			{
				OldFont = SelectObject(CurrentDC, CurrentFont);
			}
			break;	
		case LOGFONT_A:
			if(CurrentFont)
			{
				SelectObject(CurrentDC, OldFont);
				DeleteObject(CurrentFont);
			}
			
			if(ValidInput = DoLogfont(InputFile,&CurrentFont,FALSE))
			{
				OldFont = SelectObject(CurrentDC, CurrentFont);
			}
			break;	

		case GET_TEXT_EXTENT_POINT:
			ValidInput = DoGetTextExtentPoint(InputFile, CurrentDC);
			break;

		case GET_TEXT_EXTENTEX_POINT:
			ValidInput = DoGetTextExtentExPoint(InputFile, CurrentDC);
			break;

		case GET_TEXT_FACE:
			{
				char *TextFace;
				int Count,Count2;

				Count = GetTextFace(CurrentDC, 0, 0);

				if(Count && (TextFace = (char*) LocalAlloc(LMEM_FIXED,Count+1)))
				{	
					Count2 = GetTextFace(CurrentDC,Count,TextFace);					
					printf("%s %d %d\n", TextFace, Count, Count2);
					LocalFree(TextFace);
				}
				break;
			}				

		case GET_RESOLUTION:
			{
				DWORD Resolution;

				Resolution = GetDeviceCaps(CurrentDC, LOGPIXELSX);
				printf("%x ", Resolution);

				Resolution = GetDeviceCaps(CurrentDC, LOGPIXELSY);
				printf("%x\n", Resolution);
				break;
			}

		case GET_CHAR_WIDTH:
			ValidInput = DoGetCharWidth(InputFile, CurrentDC, FALSE);
			break;

		case GET_CHAR_ABC_WIDTHS:
			ValidInput = DoGetCharAbcWidths(InputFile, CurrentDC);
			break;

		case GET_CHARACTER_PLACEMENT:
			ValidInput = DoGetCharacterPlacement(InputFile, CurrentDC);
			break;

		case GET_GLYPHOUTLINE:
			ValidInput = DoGetGlyphOutline(InputFile, CurrentDC);
			break;

		case GET_KERNINGPAIRS:
			ValidInput = DoGetKerningPairs(InputFile, CurrentDC);
			break;

		case NO_MATCH:
			ValidInput = FALSE;
			break;

		}
	}while(ValidInput);


	if(!ValidInput)
	{
		printf("ERROR encountered in file\n");
	}

	fclose(InputFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fontcmp\fontcmp.h ===
#define NUM_POINTS_SIZES  6
// #define NUM_CHAR_SETS     6
#define CHARSET_SIZE      256

#define UPPERCASE_START   65
#define LOWERCASE_START   97
#define ALPHABET_RANGE    26

// Global Variables happily live here

TCHAR  lpszFont1[LF_FACESIZE+1];
TCHAR  lpszFont2[LF_FACESIZE+1];
TCHAR  lpszInputFile[MAX_PATH+1];


INT    piPointSize[NUM_POINTS_SIZES] = {8, 10, 12, 14, 18, 24};
//BYTE   pbCharSet[NUM_CHAR_SETS] =      {ANSI_CHARSET, RUSSIAN_CHARSET, GREEK_CHARSET,
//                                       TURKISH_CHARSET, BALTIC_CHARSET, EASTEUROPE_CHARSET};

// BYTE   pbCharSet[NUM_CHAR_SETS] =      {0, RUSSIAN_CHARSET, GREEK_CHARSET,
//                                       162, BALTIC_CHARSET, EASTEUROPE_CHARSET};

TCHAR*  lplpszCharSet[] = {
                           TEXT("ANSI_CHARSET"), TEXT("RUSSIAN_CHARSET"), 
                           TEXT("GREEK_CHARSET"),TEXT("TURKISH_CHARSET"), 
                           TEXT("BALTIC_CHARSET"), TEXT("EASTEUROPE_CHARSET"),
                           TEXT("HEBREW_CHARSET"), TEXT("THAI_CHARSET"), 
                           TEXT("ARABIC_CHARSET"), TEXT("VITANAMESE_CHARSET")
                          };


INT    lCharSetIndex; 
BYTE   usCurrentCharSet[32];
INT    lCharSet;

// Function Prototype definitions.
BOOL    bGetNewShellFont();

BOOL bParseCommandLine(LPTSTR lpszFileName);

BOOL bAddFonts(LPTSTR lpszInputFile);

VOID VCompareCharWidths(VOID);

VOID VDisplayProgramUsage(VOID);

VOID VGetCharWidths(HDC hdc, BYTE cs, INT j, CHAR *lpszFont1, INT *piFontWidths, INT *piFontDim, INT *piFontHtDim);

VOID VGetRidOfSlashN(LPTSTR lpszFontName);

INT  GdiGetCharDimensions(HDC hdc,TEXTMETRICW *lptm,LPINT lpcy);

BYTE ucGetCharSet(BYTE i);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\ansiset.h ===
void    DrawAnsiSet( HWND hwnd, HDC hdc );
LRESULT CALLBACK AnsiSetWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\ansiset.c ===
#include <windows.h>
#include <commdlg.h>

#include <malloc.h>
#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#include "fonttest.h"
#include "ansiset.h"

#include "dialogs.h"


//*****************************************************************************
//*************************   D R A W   ANSISET     ***************************
//*****************************************************************************

void DrawAnsiSet( HWND hwnd, HDC hdc )
{
   HFONT  hFont, hFontOld;
   TEXTMETRIC tm;
   LONG apdx[16];
   int i,j;
   UCHAR ach[16];
   WCHAR awc[16]; // to compute unicode equivalents;
   CHARSETINFO csi;
   LONG x,y;

   if (!isCharCodingUnicode)
   {
       TranslateCharsetInfo((DWORD*)elfdvA.elfEnumLogfontEx.elfLogFont.lfCharSet , &csi,TCI_SRCCHARSET);

       hFont    = CreateFontIndirectWrapperA( &elfdvA );
   }
   else
   {
       TranslateCharsetInfo((DWORD*)elfdvW.elfEnumLogfontEx.elfLogFont.lfCharSet , &csi,TCI_SRCCHARSET);

       hFont    = CreateFontIndirectWrapperW( &elfdvW );
   }

   if( !hFont )
   {
     dprintf( "Couldn't create font");
   }

   hFontOld = SelectObject( hdc, hFont );

   GetTextMetrics(hdc, &tm);

   for (i = 0; i < 16; i++)
   {
       apdx[i] = tm.tmMaxCharWidth;
       ach[i] = (UCHAR)i; // init the string
   }

   SetBkMode( hdc, iBkMode );
   SetBkColor( hdc, dwRGBBackground );
   SetTextColor( hdc, dwRGBText );
   SetTextAlign( hdc, TA_TOP | TA_LEFT );
   y = 0;
   x = 0;
   for (i = 0; i < 16; i++, y += tm.tmHeight)
   {

       ExtTextOut( hdc, x, y, 0, 0, ach, 16, apdx );

        MultiByteToWideChar(csi.ciACP, 0,
                            ach,16,
                            awc, 16*sizeof(WCHAR));

        dprintf("%04x|%04x|%04x|%04x|%04x|%04x|%04x|%04x|%04x|%04x|%04x|%04x|%04x|%04x|%04x|%04x|",
            awc[0] ,awc[1] ,awc[2] ,awc[3],
            awc[4] ,awc[5] ,awc[6] ,awc[7],
            awc[8] ,awc[9] ,awc[10],awc[11],
            awc[12],awc[13],awc[14],awc[15]);

   // update the string

       for (j = 0; j < 16; j++)
           ach[j] += 16;
   }

   SelectObject( hdc, hFontOld );
   DeleteObject( hFont );

   #if 0
   MoveToEx(hdc, xDC+cxDC/2-cxDC/150, yDC+cyDC/2          ,0);
   LineTo  (hdc, xDC+cxDC/2+cxDC/150, yDC+cyDC/2          );
   MoveToEx(hdc, xDC+cxDC/2,          yDC+cyDC/2-cxDC/150 ,0);
   LineTo  (hdc, xDC+cxDC/2,          yDC+cyDC/2+cxDC/150 );
   #endif
}


//*****************************************************************************
//*********************   AnsiSet   W N D   P R O C   ***********************
//*****************************************************************************

LRESULT CALLBACK AnsiSetWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam )
 {
  HDC         hdc;
  PAINTSTRUCT ps;
  HCURSOR     hCursor;


  switch( msg )
   {
//    case WM_CREATE:
//           return NULL;


    case WM_PAINT:
           hCursor = SetCursor( LoadCursor( NULL, MAKEINTRESOURCE(IDC_WAIT) ) );
           ShowCursor( TRUE );

           hdc = BeginPaint( hwnd, &ps );
           SetDCMapMode( hdc, wMappingMode );

           SetTextCharacterExtra( hdc, nCharExtra );

           DrawDCAxis( hwnd, hdc , TRUE);

           DrawAnsiSet( hwnd, hdc );

           CleanUpDC( hdc );

           SelectObject( hdc, GetStockObject( BLACK_PEN ) );
           EndPaint( hwnd, &ps );

           //dprintf( "  Finished drawing whirl" );

           ShowCursor( FALSE );
           SetCursor( hCursor );

           return 0;

    case WM_DESTROY:
           return 0;
   }


  return DefWindowProc( hwnd, msg, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fontcmp\makefile.inc ===
copyexe:
 if exist obj\i386\fontcmp.exe  copy obj\i386\fontcmp.exe   ..\..\bin\i386\fontcmp.exe
 if exist obj\mips\fontcmp.exe  copy obj\mips\fontcmp.exe   ..\..\bin\mips\fontcmp.exe
 if exist obj\alpha\fontcmp.exe copy obj\alpha\fontcmp.exe  ..\..\bin\alpha\fontcmp.exe
 if exist obj\ppc\fontcmp.exe   copy obj\ppc\fontcmp.exe    ..\..\bin\ppc\fontcmp.exe

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\enum.h ===
INT_PTR CALLBACK CreateFontDlgProcA( HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam );
INT_PTR CALLBACK CreateFontDlgProcW( HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam );
void    ShowEnumFonts( HWND hwnd );
void    ShowEnumFontFamilies( HWND hwnd );
void    ShowEnumFontFamiliesEx( HWND hwnd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\dialogs.h ===
#define IDB_ENUMFONTFAMILIES        100
#define IDD_LPSZFAMILY              101
#define IDD_ENUMERATE               103
#define IDB_CREATEFONT              200
#define IDD_NHEIGHT                 202
#define IDD_NWIDTH                  204
#define IDD_NESCAPEMENT             206
#define IDD_NORIENTATION            208
#define IDD_NWEIGHT                 210
#define IDD_ITALIC                  211
#define IDD_UNDERLINE               212
#define IDD_STRIKEOUT               213
#define IDD_CHARSET                 214
#define IDD_PRECISION               217
#define IDD_QUALITY                 221
#define IDD_CLIPPRECISION           219
#define IDD_PITCH                   223
#define IDD_FAMILY                  225
#define IDD_OUTPUTPRECISION         226
#define IDD_OK                      229
#define IDD_CANCEL                  230
#define IDD_LPFAMILY                228
#define IDD_PITCHANDFAMILY          232
#define IDB_ENUMFONTS               300
#define IDD_LPSZFACENAME            302
#define IDD_SCREENDC                303
#define IDD_PRINTERDC               304
#define IDB_FONTS                   307
#define IDD_LFHEIGHT                311
#define IDD_LFWIDTH                 313
#define IDD_LFESCAPAEMENT           315
#define IDD_LFORIENTATION           317
#define IDD_LFESCAPEMENT            318
#define IDD_LFWEIGHT                320
#define IDD_LFITALIC                322
#define IDD_LFUNDERLINE             324
#define IDD_LFSTRIKEOUT             326
#define IDD_LFCHARSET               328
#define IDD_LFOUTPRECISION          330
#define IDD_LFCLIPPRECISION         332
#define IDD_LFQUALITY               334
#define IDD_LFPITCHANDFAMILY        336
#define IDD_LFFACENAME              338
#define IDD_ELFFULLNAME             442
#define IDD_ELFSTYLE                444
#define IDD_ELFSCRIP                446
#define IDD_FONTS                   339
#define IDD_TMHEIGHT                341
#define IDD_TMASCENT                343
#define IDD_TMDESCENT               345
#define IDD_TMINTERNALLEADING       347
#define IDD_TMEXTERNALLEADING       349
#define IDD_TMAVECHARWIDTH          351
#define IDD_TMMAXCHARWIDTH          353
#define IDD_TMWIDTH                 355
#define IDD_TMITALIC                357
#define IDD_TMUNDERLINED            359
#define IDD_TMSTRUCKOUT             361
#define IDD_TMFIRSTCHAR             363
#define IDD_TMLASTCHAR              365
#define IDD_TMDEFAULTCHAR           367
#define IDD_TMBREAKCHAR             369
#define IDD_TMPITCHANDFAMILY        371
#define IDD_TMCHARSET               373
#define IDD_TMOVERHANG              375
#define IDD_TMDIGITIZEDASPECTX      377
#define IDD_TMDIGITIZEDASPECTY      379
#define IDD_NFONTTYPE               381
#define IDD_TMWEIGHT                382

#define IDD_NTMFLAGS                390
#define IDD_NTMSIZEEM               392
#define IDD_NTMCELLHEIGHT           394
#define IDD_NTMAVGWIDTH             396


#define IDD_USB0                    8390
#define IDD_USB1                    8392
#define IDD_USB2                    8394
#define IDD_USB3                    8396
#define IDD_CSB0                    8338
#define IDD_CSB1                    8340


#define IDD_TATOP                   402
#define IDD_TABASELINE              403
#define IDD_TABOTTOM                404
#define IDD_TALEFT                  406
#define IDD_TACENTER                407
#define IDD_TARIGHT                 408
#define IDD_TARTLREADING            409
#define IDD_STROKEPATH              416
#define IDD_FILLPATH				417
#define IDD_WINDINGFILL             418
#define IDD_ALTERNATEFILL           419
#define IDB_SETTEXTALIGN            400
#define IDD_CREATEFONT              383
#define IDB_MMANISOTROPIC           500
#define IDD_XWE                     503
#define IDD_YWE                     505
#define IDD_XWO                     507
#define IDD_YWO                     509
#define IDD_XVE                     513
#define IDD_YVE                     515
#define IDD_XVO                     517
#define IDD_YVO                     519
#define IDD_TRANSPARENT             411
#define IDD_OPAQUE                  412
#define IDB_TEXTOUTOPTIONS          600
#define IDD_M11                     702
#define IDD_EM21                    703
#define IDD_M21                     704
#define IDD_M12                     707
#define IDD_M22                     709
#define IDB_GGOMATRIX               700
#define IDB_CREATESCALABLEFONTRESOURCE 800
#define IDD_FHIDDEN                 802
#define IDD_LPSZRESOURCEFILE        804
#define IDD_LPSZFONTFILE            806
#define IDD_LPSZCURRENTPATH         808
#define IDB_ADDFONTRESOURCE         900
#define IDD_LPSZFILE                902
#define IDD_FLAG                    904
#define IDB_REMOVEFONTRESOURCE      1000
#define IDD_REMOVEFONTRESOURCE      1100
#define IDB_ADDFONTRESOURCEEX       1002
#define IDB_REMOVEFONTRESOURCEEX    1102
#define IDB_ADDFONTMEMRESOURCEEX    1010
#define IDB_REMOVEFONTMEMRESOURCEEX 1140
#define IDB_HMMFONT                 1141
#define IDD_PRIVATE                 1104
#define IDD_NOTENUM                 1106
#define IDC_NUMEDITAXES             1108
#define IDC_NUMAXES                 1110
#define	IDC_TAG                     1112
#define IDC_VALUE                   1114
#define	IDC_TAG1                    1116
#define	IDC_TAG2                    1118
#define	IDC_TAG3                    1120
#define	IDC_TAG4                    1122
#define IDC_TAGVALUE1               1124
#define IDC_TAGVALUE2               1126
#define IDC_TAGVALUE3               1128
#define IDC_TAGVALUE4               1130

#define IDD_CLIP_ENCAPSULATE        231
#define IDD_CLIP_LH_ANGLES          233
#define IDD_CLIP_TT_ALWAYS          234
#define IDD_PITCH_TT                235
#define IDB_GETFONTDATA             1200
#define IDD_DWTABLE                 1202
#define IDD_DWOFFSET                1204
#define IDD_DWCHUNK                 1206
#define IDD_DWSIZE                  1208
#define IDD_ETO_CLIPPED             602
#define IDD_ETO_OPAQUE              603

#define IDD_GGO_GLYPHINDEX          604
#define IDD_GGO_UNHINTED            605


#define IDB_GCP                     3300
#define IDD_LPDX                    3301
#define IDD_GI                      3302
#define IDD_MAXWIDTH                3303
#define IDD_SHADOW                  3304
#define IDD_GFLI                    3305
#define IDD_GCPDPRINTF              3306
#define IDD_JUSTIFY                 3307
#define IDD_KERNSTRING              3308
#define IDD_OUTSTRING               3309
#define IDD_LPCARET                 3310
#define IDD_LPORDER                 3311


#define IDB_GTEEXT                  4400
#define IDD_GTEEXT_MAXWIDTH         4401
#define IDD_NFIT                    4402

#define IDB_SETXTCHAR               5500
#define IDD_SETXTCHAR_NCHAREXT      5501

#define IDB_SETXTJUST               6600
#define IDD_SETXTJUST_NBKEXT        6601
#define IDD_SETXTJUST_NBKCNT        6602

#define IDB_CHOOSEFONTCHARSET       1400

#ifdef USERGETWVTPERF
#define IDB_GETWVTPERF              1600
#endif

// defined above
//#define IDD_CHARSET               1401

#define IDB_EUDCLOADLINKW           1500
#define IDB_EUDCUNLOADLINKW         1502
#define IDB_GETSTRINGBITMAPA        1504
#define IDB_GETSTRINGBITMAPW        1506

#define IDD_PRIORITY                1508
#define IDD_SYSTEM                  1510
#define IDD_USER                    1512
#define IDD_STRING                  1514


#define IDB_EDITSTRING			    1516
#define IDD_EDITSTRING				1517

#define IDB_EDITGLYPHINDEX          1521
#define IDD_STRGLYPHINDEX           1522
#define IDD_STRPDX                  1523
#define IDD_STRPDY                  1524
#define IDD_CHK_USEGLYPHINDEX       1526
#define IDD_CHK_USEPDX              1527
#define IDD_CHK_USEPDY              1528
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\fonttest.h ===
/******************************Module*Header*******************************\
* Module Name: fonttest.h
*
* Created: 08-Jun-1993 07:39:00
* Author: Kirk Olynyk [kirko]
*
\**************************************************************************/

#define IDM_FONTTESTMENU            1
#define IDI_FONTTESTICON            1

//-------------- File ---------------

#define IDM_DEBUG                 100
#define IDM_OPENLOG               101
#define IDM_CLOSELOG              102

#define IDM_CLEARSTRING           110
#define IDM_CLEARDEBUG            111
#define IDM_EDITSTRING			  112

#define IDM_EDITGLYPHINDEX        115

#define IDM_PRINT                 120
#define IDM_PRINTERSETUP          121


//---------- Program Mode -----------

#define IDM_GLYPHMODE             200
#define IDM_NATIVEMODE            201
#define IDM_BEZIERMODE            202
#define IDM_RINGSMODE             203
#define IDM_STRINGMODE            204
#define IDM_WATERFALLMODE         205
#define IDM_WHIRLMODE             206
#define IDM_ANSISETMODE           207
#define IDM_GLYPHSETMODE          208
#define IDM_WIDTHSMODE            209

#define IDM_GGOMATRIX             210

#define IDM_WRITEGLYPH            211
#define IDM_USEGLYPHINDEX         215

#define IDM_USEPRINTERDC          220


//---------- Mapping Mode -----------

#define IDM_MMHIENGLISH           300
#define IDM_MMLOENGLISH           301
#define IDM_MMHIMETRIC            302
#define IDM_MMLOMETRIC            303
#define IDM_MMTEXT                304
#define IDM_MMTWIPS               305
#define IDM_MMANISOTROPIC         310
#define IDM_MMISOTROPIC           311


//---------- New Stuff --------------

#define IDM_COMPATIBLE_MODE       312
#define IDM_ADVANCED_MODE         313
#define IDM_WORLD_TRANSFORM       314
#define IDM_EM11                  315
#define IDM_EM12                  316
#define IDM_EM21                  317
#define IDM_EM22                  318
#define IDM_EDX                   319
#define IDM_EDY                   320


//---------- Clipping Mode ----------

#define IDM_CLIPELLIPSE           351
#define IDM_CLIPPOLYGON           352
#define IDM_CLIPRECTANGLE         353


//--------------- APIs --------------

#define IDM_ENUMFONTS             400
#define IDM_ENUMFONTFAMILIES      401
#define IDM_ENUMFONTFAMILIESEX    402

#define IDM_GETOUTLINETEXTMETRICS 411
#define IDM_GETRASTERIZERCAPS     412
#define IDM_GETTEXTEXTENT         413
#define IDM_GETTEXTFACE           414
#define IDM_GETTEXTMETRICS        415
#define IDM_GETTEXTCHARSETINFO    416
#define IDM_GETFONTLANGUAGEINFO   417

#define IDM_GETCHARWIDTHINFO      440
#define IDM_GETWVTPERF            441
#define IDM_TEXTOUTPERF		      442
#define IDM_CHARWIDTHTEST         443
#define IDM_CHARWIDTHTESTALL      444
#define IDM_CLEARTYPEPERF		  445

#define IDM_GETFONTDATA           420
#define IDM_CREATESCALABLEFONTRESOURCE 421
#define IDM_ADDFONTRESOURCE       422
#define IDM_ADDFONTRESOURCEEX     424
#define IDM_REMOVEFONTRESOURCE    423
#define IDM_REMOVEFONTRESOURCEEX  425
#define IDM_ADDFONTMEMRESOURCEEX  426
#define IDM_REMOVEFONTMEMRESOURCEEX 427

#define IDM_GCP                    430
#define IDM_GTEEXT                 431
#define IDM_SETXTCHAR              432
#define IDM_SETXTJUST              433

// Font Escapes

#define IDM_GETEXTENDEDTEXTMETRICS 460
#define IDM_GETPAIRKERNTABLE       461

// index apis and other new apis for 5.0

#define IDM_GETUNICODERANGES       462
#define IDM_GETTEXTEXTENTI         463
#define IDM_GETCHARWIDTHI          464

// eudc apis

#define IDM_ENABLEEUDC             465
#define IDM_EUDCLOADLINKW          466 
#define IDM_EUDCUNLOADLINKW        467
#define IDM_GETEUDCTIMESTAMP       468
#define IDM_GETEUDCTIMESTAMPEXW    469
#define IDM_GETSTRINGBITMAPA       470
#define IDM_GETSTRINGBITMAPW       471
#define IDM_GETFONTASSOCSTATUS     472



//----------- Create Font -----------

#define IDM_CHOOSEFONTDIALOG      500
#define IDM_CREATEFONTDIALOG      501
#define IDM_USESTOCKFONT          502
#define IDM_CHOOSEFONTDIALOGEX    503

#define IDM_ANSIFIXEDFONT        5001
#define IDM_ANSIVARFONT          5002
#define IDM_DEVICEDEFAULTFONT    5003
#define IDM_OEMFIXEDFONT         5004
#define IDM_SYSTEMFONT           5005
#define IDM_SYSTEMFIXEDFONT      5006
#define IDM_DEFAULTGUIFONT       5007

#define IDM_SETTEXTCOLOR          510
#define IDM_SETBACKGROUNDCOLOR    511
#define IDM_SETTEXTOUTOPTIONS     512
#define IDM_UPDATECP              513

#define IDM_USEDEFAULTSPACING     520
#define IDM_USEWIDTHSPACING       521
#define IDM_USEABCSPACING         522
#define IDM_PDX                   523
#define IDM_PDXPDY                524
#define IDM_RANDOMPDXPDY          525

#define IDM_NOKERNING             530
#define IDM_APIKERNING            531
#define IDM_ESCAPEKERNING         532

#define IDM_SHOWLOGFONT           540


//----------- Text Mode -----------

#define IDM_CHARCODING_MBCS		  601
#define IDM_CHARCODING_UNICODE	  602

//----------- Background ----------

#define IDM_SETSOLIDBACKGROUND      701
#define IDM_SETSOLIDBACKGROUNDCOLOR 702
#define IDM_SETGRADIENTBACKGROUND   703
#define IDM_SETLEFTGRADIENTCOLOR    704
#define IDM_SETRIGHTGRADIENTCOLOR   705


#define IDM_ABOUT                 900
#define IDB_ABOUT                 910




HANDLE hInst;

HWND   hwndMain;
HWND   hwndDebug;
HWND   hwndGlyph;
HWND   hwndRings;
HWND   hwndString;
HWND   hwndWaterfall;
HWND   hwndWhirl;
HWND   hwndAnsiSet;
HWND   hwndGlyphSet;
HWND   hwndWidths;

int    cxScreen, cyScreen;
int    Margin;

int    cxDC, cyDC;
int    xDC,yDC;
int    cxDevice, cyDevice;

int    cxBorder;

#define MAX_TEXT     128
int    aDx[2*MAX_TEXT];     // allow space for both pdx,pdy

//char   szString[MAX_TEXT];
char   szStringA[MAX_TEXT];
WCHAR  szStringW[MAX_TEXT];

WORD   wszStringGlyphIndex[MAX_TEXT];
int    SizewszStringGlyph;
INT    intdx[2*MAX_TEXT];
LPINT  lpintdx;
int    sizePdx;

WORD   wTextAlign;
int    iBkMode;
DWORD  wETO;
int    nCharExtra;
int    nBreakExtra, nBreakCount;

BOOL   bStrokePath;
BOOL   bFillPath;
BOOL   bGCP;
BOOL   bGTEExt;
BOOL   bPdxPdy;

int    xWE, yWE, xWO, yWO;
int    xVE, yVE, xVO, yVO;

int    bAdvanced;
extern XFORM  xf;

UINT   wMode;

ENUMLOGFONTEXDVA elfdvA;
ENUMLOGFONTEXDVW elfdvW;
DWORD      dwRGB;
DWORD      dwRGBText;
// DWORD      dwRGBTextExt;
DWORD      dwRGBBackground;

// Drawing area background control
BOOL       isGradientBackground;
DWORD      dwRGBSolidBackgroundColor;
DWORD      dwRGBLeftBackgroundColor;
DWORD      dwRGBRightBackgroundColor;

DWORD      dwxFlags;
WORD       wRotate;


UINT       wMappingMode;
UINT       wSpacing;
UINT       wKerning;
WORD       wUpdateCP;
UINT       wUseGlyphIndex;
WORD       wUsePrinterDC;

UINT     wCharCoding;
BOOL	 isCharCodingUnicode;


INT_PTR  ShowDialogBox(DLGPROC, int, VOID*);
int  dprintf( char *fmt, ... );
int  dwprintf( wchar_t *fmt, ... );
void ClearDebug( void );

void  HandleChar( HWND hwnd, WPARAM wParam );

LPINT GetSpacing( HDC hdc, LPVOID lpszString );
void  MyExtTextOut( HDC hdc, int x, int y, DWORD wFlags, LPRECT lpRect, LPVOID lpszString, int cbString, LPINT lpdx );
BOOL  GenExtTextOut( HDC hdc, int x, int y, DWORD wFlags, LPRECT lpRect, LPVOID lpszString, int cbString, LPINT lpdx );

HDC   hdcCachedPrinter;  //return value from CreatePrinterDC
HDC   CreatePrinterDC( void );
void  SetDCMapMode( HDC hdc, UINT wMode );
void  DrawDCAxis( HWND hwnd, HDC hdc , BOOL bAxis );
HDC   CreateTestIC( void );
void  DeleteTestIC( HDC hdc );
void  CleanUpDC( HDC hdc );
void  ChangeMapMode( HWND hwnd, WPARAM wParam );
BOOL  fReadDesignVector (HWND hdlg, LPDESIGNVECTOR lpdv);

BOOL SyncszStringWith (int mode);
BOOL SyncStringAtoW (LPWSTR lpszStringW, LPSTR lpszStringA, int cch);
BOOL SyncStringWtoA (LPSTR lpszStringA, LPWSTR lpszStringW, int cch);
BOOL SyncElfdvAtoW (ENUMLOGFONTEXDVW *elfdv1, ENUMLOGFONTEXDVA *elfdv2);
BOOL SyncElfdvWtoA (ENUMLOGFONTEXDVA *elfdv1, ENUMLOGFONTEXDVW *elfdv2);

BOOL  (WINAPI *lpfnCreateScalableFontResource)(DWORD, LPCSTR, LPCSTR, LPCSTR);
int   (WINAPI *lpfnEnumFontFamilies )(HDC, LPCSTR, FONTENUMPROC, LPSTR);
int   (WINAPI *lpfnEnumFontFamiliesEx) (HDC, LPLOGFONT, FONTENUMPROC, LPSTR, DWORD);
BOOL  (WINAPI *lpfnGetCharABCWidthsA)(HDC, UINT, UINT, LPABC);
DWORD (WINAPI *lpfnGetFontData      )(HDC, DWORD, DWORD, void FAR*, DWORD);
DWORD (WINAPI *lpfnGetGlyphOutlineA )(HDC, UINT, UINT, LPGLYPHMETRICS, DWORD, LPVOID, LPMAT2);
//DWORD (WINAPI *lpfnGetOutlineTextMetrics)(HDC, UINT, LPOUTLINETEXTMETRIC);
DWORD (WINAPI *lpfnGetOutlineTextMetricsA)(HDC, UINT, LPVOID);
BOOL  (WINAPI *lpfnGetRasterizerCaps)(LPRASTERIZER_STATUS, int );
int   (WINAPI *lpfnGetTextCharsetInfo)(HDC, LPFONTSIGNATURE, DWORD);

// UNICODE
BOOL  (WINAPI *lpfnGetCharABCWidthsW)(HDC, UINT, UINT, LPABC);
DWORD (WINAPI *lpfnGetGlyphOutlineW )(HDC, UINT, UINT, LPGLYPHMETRICS, DWORD, LPVOID, LPMAT2);
DWORD (WINAPI *lpfnGetOutlineTextMetricsW)(HDC, UINT, LPVOID);

// END UNICODE

#define IDE_CHARSET                 3899
#define IDB_ENUMFONTFAMILIES        100
#define IDD_LPSZFAMILY              101
#define IDD_ENUMERATE               103
#define IDB_CREATEFONT              200
#define IDD_NHEIGHT                 202
#define IDD_NWIDTH                  204
#define IDD_NESCAPEMENT             206
#define IDD_NORIENTATION            208
#define IDD_NWEIGHT                 210
#define IDD_ITALIC                  211
#define IDD_UNDERLINE               212
#define IDD_STRIKEOUT               213
#define IDD_CHARSET                 214
#define IDD_PRECISION               217
#define IDD_QUALITY                 221
#define IDD_CLIPPRECISION           219
#define IDD_PITCH                   223
#define IDD_FAMILY                  225
#define IDD_OUTPUTPRECISION         226
#define IDD_OK                      229
#define IDD_CANCEL                  230
#define IDD_LPFAMILY                228
#define IDD_PITCHANDFAMILY          232
#define IDB_ENUMFONTS               300
#define IDD_LPSZFACENAME            302
#define IDD_SCREENDC                303
#define IDD_PRINTERDC               304
#define IDB_FONTS                   307
#define IDD_LFHEIGHT                311
#define IDD_LFWIDTH                 313
#define IDD_LFESCAPAEMENT           315
#define IDD_LFORIENTATION           317
#define IDD_LFESCAPEMENT            318
#define IDD_LFWEIGHT                320
#define IDD_LFITALIC                322
#define IDD_LFUNDERLINE             324
#define IDD_LFSTRIKEOUT             326
#define IDD_LFCHARSET               328
#define IDD_LFOUTPRECISION          330
#define IDD_LFCLIPPRECISION         332
#define IDD_LFQUALITY               334
#define IDD_LFPITCHANDFAMILY        336
#define IDD_LFFACENAME              338
#define IDD_ELFFULLNAME             442
#define IDD_ELFSTYLE                444
#define IDD_ELFSCRIPT               446
#define IDD_FONTS                   339
#define IDD_TMHEIGHT                341
#define IDD_TMASCENT                343
#define IDD_TMDESCENT               345
#define IDD_TMINTERNALLEADING       347
#define IDD_TMEXTERNALLEADING       349
#define IDD_TMAVECHARWIDTH          351
#define IDD_TMMAXCHARWIDTH          353
#define IDD_TMWIDTH                 355
#define IDD_TMITALIC                357
#define IDD_TMUNDERLINED            359
#define IDD_TMSTRUCKOUT             361
#define IDD_TMFIRSTCHAR             363
#define IDD_TMLASTCHAR              365
#define IDD_TMDEFAULTCHAR           367
#define IDD_TMBREAKCHAR             369
#define IDD_TMPITCHANDFAMILY        371
#define IDD_TMCHARSET               373
#define IDD_TMOVERHANG              375
#define IDD_TMDIGITIZEDASPECTX      377
#define IDD_TMDIGITIZEDASPECTY      379
#define IDD_NFONTTYPE               381
#define IDD_TMWEIGHT                382

#define IDD_NTMFLAGS                390
#define IDD_NTMSIZEEM               392
#define IDD_NTMCELLHEIGHT           394
#define IDD_NTMAVGWIDTH             396

#define IDD_USB0                    8390
#define IDD_USB1                    8392
#define IDD_USB2                    8394
#define IDD_USB3                    8396
#define IDD_CSB0                    8338
#define IDD_CSB1                    8340

#define IDD_TATOP                   402
#define IDD_TABASELINE              403
#define IDD_TABOTTOM                404
#define IDD_TALEFT                  406
#define IDD_TACENTER                407
#define IDD_TARIGHT                 408
#define IDD_STROKEPATH              416
#define IDD_FILLPATH				417
#define IDD_WINDINGFILL             418
#define IDD_ALTERNATEFILL           419
#define IDB_SETTEXTALIGN            400
#define IDD_CREATEFONT              383
#define IDB_MMANISOTROPIC           500
#define IDD_XWE                     503
#define IDD_YWE                     505
#define IDD_XWO                     507
#define IDD_YWO                     509
#define IDD_XVE                     513
#define IDD_YVE                     515
#define IDD_XVO                     517
#define IDD_YVO                     519
#define IDD_TRANSPARENT             411
#define IDD_OPAQUE                  412
#define IDB_TEXTOUTOPTIONS          600
#define IDD_M11                     702
#define IDD_EM21                    703
#define IDD_M21                     704
#define IDD_M12                     707
#define IDD_M22                     709
#define IDD_WCHAR                   710
#define IDB_GGOMATRIX               700

#define IDC_WVT_FILE_PATH           442
#define IDC_WVT_FILE_HANDLE         443
#define IDC_WVT_MEM_PTR             444
#define IDC_FONT_HINT               445
#define IDC_IS_CHECK_PERFORMED      446
#define IDC_CRYPTHASHDATA_ONLY      447
#define IDC_WVT_ONLY                448
#define IDC_EVERYTHING              449
#define IDC_WVT_ITERATIONS          450
#define IDC_STATIC2                 -2

#define IDB_CREATESCALABLEFONTRESOURCE 800
#define IDD_FHIDDEN                 802
#define IDD_LPSZRESOURCEFILE        804
#define IDD_LPSZFONTFILE            806
#define IDD_LPSZCURRENTPATH         808

#define IDB_ADDFONTRESOURCE         900
#define IDB_ADDFONTRESOURCEEX       1002
#define IDB_ADDFONTMEMRESOURCEEX    1010
#define IDD_LPSZFILE                902

#define IDB_REMOVEFONTRESOURCE      1000
#define IDD_REMOVEFONTRESOURCE      1100
#define IDB_REMOVEFONTMEMRESOURCEEX 1140
#define IDD_HMMFONT                 1141
#define IDD_CLIP_ENCAPSULATE        231
#define IDD_CLIP_LH_ANGLES          233
#define IDD_CLIP_TT_ALWAYS          234
#define IDD_PITCH_TT                235

#define IDB_GETFONTDATA             1200
#define IDD_DWTABLE                 1202
#define IDD_DWOFFSET                1204
#define IDD_DWCHUNK                 1206
#define IDD_DWSIZE                  1208
#define IDD_ETO_CLIPPED             602
#define IDD_ETO_OPAQUE              603

#define IDD_GGO_GLYPHINDEX          604
#define IDD_GGO_UNHINTED            605

#define IDB_SETWORLDTRANSFORM       1300
#define IDD_TEXT_EM11               1301
#define IDD_TEXT_EM12               1302
#define IDD_TEXT_EM21               1303
#define IDD_TEXT_EM22               1304
#define IDD_TEXT_EDX                1305
#define IDD_TEXT_EDY                1306
#define IDD_VALUE_EM11              1307
#define IDD_VALUE_EM12              1308
#define IDD_VALUE_EM21              1309
#define IDD_VALUE_EM22              1300
#define IDD_VALUE_EDX               1311
#define IDD_VALUE_EDY               1312

#define IDM_GCPCARET                1314

//flags used in FONTSIGNATURE structure
#define  CPB_LATIN1_ANSI            0X00000001
#define  CPB_LATIN2_EASTEU          0X00000002
#define  CPB_CYRILLIC_ANSI          0X00000004
#define  CPB_GREEK_ANSI             0X00000008
#define  CPB_TURKISH_ANSI           0X00000010
#define  CPB_HEBREW_ANSI            0X00000020
#define  CPB_ARABIC_ANSI            0X00000040
#define  CPB_BALTIC_ANSI            0X00000080

#define  CPB_THAI                   0X00010000
#define  CPB_JIS_JAPAN              0X00020000
#define  CPB_CHINESE_SIMP           0X00040000
#define  CPB_KOREAN_WANSUNG         0X00080000
#define  CPB_CHINESE_TRAD           0X00100000
#define  CPB_KOREAN_JOHAB           0X00200000

#define  CPB_MACINTOSH_CHARSET      0X20000000
#define  CPB_OEM_CHARSET            0X40000000
#define  CPB_SYMBOL_CHARSET         0X80000000

#define  CPB_IBM_GREEK              0X00010000
#define  CPB_MSDOS_RUSSIAN          0X00020000
#define  CPB_MSDOS_NORDIC           0X00040000
#define  CPB_ARABIC_OEM             0X00080000
#define  CPB_MSDOS_CANADIANFRE      0X00100000
#define  CPB_HEBREW_OEM             0X00200000
#define  CPB_MSDOS_ICELANDIC        0X00400000
#define  CPB_MSDOS_PORTUGUESE       0X00800000
#define  CPB_IBM_TURKISH            0X01000000
#define  CPB_IBM_CYRILLIC           0X02000000
#define  CPB_LATIN2_OEM             0X04000000
#define  CPB_BALTIC_OEM             0X08000000
#define  CPB_GREEK_OEM              0X10000000
#define  CPB_WE_LATIN1              0X40000000
#define  CPB_US_OEM                 0X80000000

//flag used in FONTSIGNATURE
#define  USB_BASIC_LATIN            0X00000001
#define  USB_LATIN1_SUPPLEMENT      0X00000002
#define  USB_LATIN_EXTENDEDA        0X00000004
#define  USB_LATIN_EXTENDEDB        0X00000008
#define  USB_IPA_EXTENSIONS         0X00000010
#define  USB_SPACE_MODIF_LETTER     0X00000020
#define  USB_COMB_DIACR_MARKS       0X00000040
#define  USB_BASIC_GREEK            0X00000080
#define  USB_GREEK_SYM_COPTIC       0X00000100
#define  USB_CYRILLIC               0X00000200
#define  USB_ARMENIAN               0X00000400
#define  USB_BASIC_HEBREW           0X00000800
#define  USB_HEBREW_EXTENDED        0X00001000
#define  USB_BASIC_ARABIC           0X00002000
#define  USB_ARABIC_EXTENDED        0X00004000
#define  USB_DEVANAGARI             0X00008000
#define  USB_BENGALI                0X00010000
#define  USB_GURMUKHI               0X00020000
#define  USB_GUJARATI               0X00040000
#define  USB_ORIYA                  0X00080000
#define  USB_TAMIL                  0X00100000
#define  USB_TELUGU                 0X00200000
#define  USB_KANNADA                0X00400000
#define  USB_MALAYALAM              0X00800000
#define  USB_THAI                   0X01000000
#define  USB_LAO                    0X02000000
#define  USB_BASIC_GEORGIAN         0X04000000
#define  USB_GEORGIAN_EXTENDED      0X08000000
#define  USB_HANGUL_JAMO            0X10000000
#define  USB_LATIN_EXT_ADD          0X20000000
#define  USB_GREEK_EXTENDED         0X40000000
#define  USB_GEN_PUNCTUATION        0X80000000


#define  USB_SUPER_SUBSCRIPTS       0X00000001
#define  USB_CURRENCY_SYMBOLS       0X00000002
#define  USB_COMB_DIACR_MARK_SYM    0X00000004
#define  USB_LETTERLIKE_SYMBOL      0X00000008
#define  USB_NUMBER_FORMS           0X00000010
#define  USB_ARROWS                 0X00000020
#define  USB_MATH_OPERATORS         0X00000040
#define  USB_MISC_TECHNICAL         0X00000080
#define  USB_CONTROL_PICTURE        0X00000100
#define  USB_OPT_CHAR_RECOGNITION   0X00000200
#define  USB_ENCLOSED_ALPHANUMERIC  0X00000400
#define  USB_BOX_DRAWING            0X00000800
#define  USB_BLOCK_ELEMENTS         0X00001000
#define  USB_GEOMETRIC_SHAPE        0X00002000
#define  USB_MISC_SYMBOLS           0X00004000
#define  USB_DINGBATS               0X00008000
#define  USB_CJK_SYM_PUNCTUATION    0X00010000
#define  USB_HIRAGANA               0X00020000
#define  USB_KATAKANA               0X00040000
#define  USB_BOPOMOFO               0X00080000
#define  USB_HANGUL_COMP_JAMO       0X00100000
#define  USB_CJK_MISCELLANEOUS      0X00200000
#define  USB_EN_CJK_LETTER_MONTH    0X00400000
#define  USB_CJK_COMPATIBILITY      0X00800000
#define  USB_HANGUL                 0X01000000

#define  USB_CJK_UNIFY_IDEOGRAPH    0X08000000
#define  USB_PRIVATE_USE_AREA       0X10000000
#define  USB_CJK_COMP_IDEOGRAPH     0X20000000
#define  USB_ALPHA_PRES_FORMS       0X40000000
#define  USB_ARABIC_PRES_FORMA      0X80000000


#define  USB_COMB_HALF_MARK         0X00000001
#define  USB_CJK_COMP_FORMS         0X00000002
#define  USB_SMALL_FORM_VARIANTS    0X00000004
#define  USB_ARABIC_PRES_FORMB      0X00000008
#define  USB_HALF_FULLWIDTH_FORM    0X00000010
#define  USB_SPECIALS               0X00000020


#define MoveTo(x,y,z) MoveToEx(x,y,z,NULL)

#define SetViewportExt(x,y,z)  SetViewportExtEx(x,y,z,NULL)
#define SetViewportExt(x,y,z)  SetViewportExtEx(x,y,z,NULL)
#define SetViewportOrg(x,y,z)  SetViewportOrgEx(x,y,z,NULL)
#define SetViewportOrg(x,y,z)  SetViewportOrgEx(x,y,z,NULL)
#define SetWindowExt(x,y,z)    SetWindowExtEx(x,y,z,NULL)
#define SetWindowExt(x,y,z)    SetWindowExtEx(x,y,z,NULL)
#define SetWindowOrg(x,y,z)    SetWindowOrgEx(x,y,z,NULL)
#define SetWindowOrg(x,y,z)    SetWindowOrgEx(x,y,z,NULL)

#define IDM_GETKERNINGPAIRS       450

#define IDC_GGO_BITMAP                  1002
#define IDC_GGO_NATIVE                  1003
#define IDC_GGO_BEZIER                  1009
#define IDC_GGO_METRICS                 1004
#define IDC_GGO_GRAY2_BITMAP            1005
#define IDC_GGO_GRAY4_BITMAP            1006
#define IDC_GGO_GRAY8_BITMAP            1007
#define IDC_GGO_GLYPH_INDEX             1008
#define IDC_GGO_UNHINTED                1009
#define IDC_STATIC                      -1

#define MAX_AXES                        6

#define IDD_DESIGNVEC                   6200
#define IDD_TEXT_DVRESERVED             6201
#define IDD_DVRESERVED                  6202
#define IDD_TEXT_DVNUMAXES              6203
#define IDD_DVNUMAXES                   6204
#define IDD_TAG                         6205
#define IDD_VALUE                       6206
#define IDD_TAG0                        6207
#define IDD_VALUE0                      6208
#define IDD_TAG1                        6209
#define IDD_VALUE1                      6210
#define IDD_TAG2                        6211
#define IDD_VALUE2                      6212
#define IDD_TAG3                        6213
#define IDD_VALUE3                      6214
#define IDD_TAG4                        6215
#define IDD_VALUE4                      6216
#define IDD_TAG5                        6217
#define IDD_VALUE5                      6218


#define IDD_AXESLIST                    6300
#define IDD_TEXT_AXLRESERVED            6301
#define IDD_AXLRESERVED                 6302
#define IDD_TEXT_AXLNUMAXES             6304
#define IDD_AXLNUMAXES                  6305
#define IDD_AXTAG                       6306
#define IDD_AXMINVAL                    6307
#define IDD_AXMAXVAL                    6308
#define IDD_AXDEFVAL                    6309
#define IDD_AXNAME                      6310

#define IDD_AXTAG0                      6315
#define IDD_AXMINVAL0                   6316
#define IDD_AXMAXVAL0                   6317
#define IDD_AXDEFVAL0                   6318
#define IDD_AXNAME0                     6319

#define IDD_AXTAG1                      6320
#define IDD_AXMINVAL1                   6321
#define IDD_AXMAXVAL1                   6322
#define IDD_AXDEFVAL1                   6323
#define IDD_AXNAME1                     6324

#define IDD_AXTAG2                      6325
#define IDD_AXMINVAL2                   6326
#define IDD_AXMAXVAL2                   6327
#define IDD_AXDEFVAL2                   6328
#define IDD_AXNAME2                     6329

#define IDD_AXTAG3                      6330
#define IDD_AXMINVAL3                   6331
#define IDD_AXMAXVAL3                   6332
#define IDD_AXDEFVAL3                   6333
#define IDD_AXNAME3                     6334

#define IDD_AXTAG4                      6335
#define IDD_AXMINVAL4                   6336
#define IDD_AXMAXVAL4                   6337
#define IDD_AXDEFVAL4                   6338
#define IDD_AXNAME4                     6339

#define IDD_AXTAG5                      6340
#define IDD_AXMINVAL5                   6341
#define IDD_AXMAXVAL5                   6342
#define IDD_AXDEFVAL5                   6343
#define IDD_AXNAME5                     6344


// New GUID for font files -- dchinn
// SIP v2.0 OTF Image == {6D875CC1-EF35-11d0-9438-00C04FD42C3B}
#define CRYPT_SUBJTYPE_FONT_IMAGE                                    \
            { 0x6d875cc1,                                           \
              0xef35,                                               \
              0x11d0,                                               \
              { 0x94, 0x38, 0x0, 0xc0, 0x4f, 0xd4, 0x2c, 0x3b }     \
            }


// Function prototypes for the GlyphSet functions.

void    DrawGlyphSet( HWND hwnd, HDC hdc );
LRESULT CALLBACK GlyphSetWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );
void    VDisplayGlyphs( HWND hwnd, HDC hdc, WORD wNumGlyphs);

HFONT   CreateFontIndirectWrapperA(ENUMLOGFONTEXDVA * pelfdv );
HFONT   CreateFontIndirectWrapperW(ENUMLOGFONTEXDVW * pelfdv );

#define IS_ANY_DBCS_CHARSET( CharSet )                 \
        (((CharSet) == SHIFTJIS_CHARSET)   ? TRUE :    \
        ((CharSet) == HANGEUL_CHARSET)     ? TRUE :    \
        ((CharSet) == CHINESEBIG5_CHARSET) ? TRUE :    \
        ((CharSet) == GB2312_CHARSET)      ? TRUE : FALSE )


// comment out this if you want to compile the app so as to run on win95

#define GI_API 1
#define EUDC_API 1
#define USERGETWVTPERF
//#define USERGETCHARWIDTH

//!!! to be removed when wingdi.w is checked in.

#ifndef CLEARTYPE_QUALITY
#define CLEARTYPE_QUALITY       5
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\fonttest.c ===
#include <windows.h>
#include <cderr.h>
#include <commdlg.h>

#include <direct.h>
#include <malloc.h>
#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

#include <wingdi.h>

#include "fonttest.h"

#include "enum.h"
#include "glyph.h"
#include "rings.h"
#include "stringw.h"
#include "waterfal.h"
#include "whirl.h"
#include "ansiset.h"
#include "widths.h"
#include "gcp.h"
#include "eudc.h"

#include "dialogs.h"

#ifdef USERGETWVTPERF
#include    <wincrypt.h>
#include    <wintrust.h>
#include    <softpub.h>
#endif

// new flag that for NT 5.0/IE 5.0 is used for testing purpose only
#define CF_MM_DESIGNVECTOR             0x02000000L

#define SZMAINCLASS      "FontTest"
#define SZRINGSCLASS     "Rings Class"
#define SZSTRINGCLASS    "String Class"
#define SZWATERFALLCLASS "Waterfall Class"
#define SZWHIRLCLASS     "Whirl Class"
#define SZWIDTHSCLASS    "Widths Class"
#define SZANSISET        "AnsiSet"
#define SZGLYPHSET       "GlyphSet"

#define SZDEBUGCLASS     "FontTest Debug"

#define ALTERNATE_FILL		1
#define WINDING_FILL		2

BOOL   bStrokePath=FALSE;
BOOL   bFillPath=FALSE;
int    fillMode = WINDING_FILL;

int     gTime;

void CALLBACK Mytimer(HWND hwnd, // handle of window for timer messages  
                      UINT uMsg, // WM_TIMER message 
                      UINT idEvent, // timer identifier 
                      DWORD dwTime  
)
{
    gTime++;
}

INT_PTR CALLBACK
SetWorldTransformDlgProc(
      HWND      hdlg
    , UINT      msg
    , WPARAM    wParam
    , LPARAM    lParam
    );


//----------  Escape Structures  -----------

typedef struct _EXTTEXTMETRIC
         {
          short etmSize;
          short etmPointSize;
          short etmOrientation;
          short etmMasterHeight;
          short etmMinScale;
          short etmMaxScale;
          short etmMasterUnits;
          short etmCapHeight;
          short etmXHeight;
          short etmLowerCaseAscent;
          short etmLowerCaseDescent;
          short etmSlant;
          short etmSuperscript;
          short etmSubscript;
          short etmSuperscriptSize;
          short etmSubscriptSize;
          short etmUnderlineOffset;
          short etmUnderlineWidth;
          short etmDoubleUpperUnderlineOffset;
          short etmDoubleLowerUnderlineOffset;
          short etmDoubleUpperUnderlineWidth;
          short etmDoubleLowerUnderlineWidth;
          short etmStrikeoutOffset;
          short etmStrikeoutWidth;
          short etmKernPairs;
          short etmKernTracks;
         } EXTTEXTMETRIC, FAR *LPEXTTEXTMETRIC;



typedef struct _KERNPAIR
         {
          WORD  wBoth;
          short sAmount;
         } KERNPAIR, FAR *LPKERNPAIR;


#ifdef  USERGETCHARWIDTH
typedef struct _CHWIDTHINFO
{
        LONG    lMaxNegA;
        LONG    lMaxNegC;
        LONG    lMinWidthD;
} CHWIDTHINFO, *PCHWIDTHINFO;


BOOL    GetCharWidthInfo(HDC hdc, PCHWIDTHINFO pChWidthInfo);

#endif


//------------------------------------------



HFONT    hFontDebug = NULL;

HWND     hwndMode;
UINT     wMappingMode = IDM_MMTEXT;
    
UINT     wUseGlyphIndex = 0;    

UINT	 wCharCoding = IDM_CHARCODING_MBCS;
BOOL	 isCharCodingUnicode = FALSE;

LPINT  lpintdx = NULL;
int    SizewszStringGlyph = 0;
int    sizePdx = 0;

BOOL     bClipEllipse;
BOOL     bClipPolygon;
BOOL     bClipRectangle;


PRINTDLG pdlg;                        // Print Setup Structure

LRESULT CALLBACK MainWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );



int (WINAPI *lpfnStartDoc )(HDC, DOCINFO FAR*);
int (WINAPI *lpfnStartPage)(HDC);
int (WINAPI *lpfnEndPage  )(HDC);
int (WINAPI *lpfnEndDoc   )(HDC);
int (WINAPI *lpfnAbortDoc )(HDC);

XFORM xf =
{
    (FLOAT) 1.0,
    (FLOAT) 0.0,
    (FLOAT) 0.0,
    (FLOAT) 1.0,
    (FLOAT) 0.0,
    (FLOAT) 0.0
};



//*****************************************************************************
//**************************   W I N   M A I N   ******************************
//*****************************************************************************

HANDLE  hInstance     = 0;
HANDLE  hPrevInstance = 0;
LPSTR   lpszCmdLine   = 0;
int     nCmdShow      = 0;

int __cdecl
main(
    int argc,
    char *argv[]
    )
 {
  MSG      msg;
  WNDCLASS wc;
  RECT     rcl;


//--------------------------  Register Main Class  ----------------------------

  hInstance   = GetModuleHandle(NULL);
  lpszCmdLine = argv[0];
  nCmdShow    = SW_SHOWNORMAL;

  hInst = hInstance;

  if( !hPrevInstance )
   {
    memset( &wc, 0, sizeof(wc) );

    wc.hCursor       = LoadCursor( NULL, IDC_SIZEWE );
    wc.hIcon         = LoadIcon( hInst, MAKEINTRESOURCE( IDI_FONTTESTICON ) );
    wc.lpszMenuName  = MAKEINTRESOURCE( IDM_FONTTESTMENU );
    wc.lpszClassName = SZMAINCLASS;
    wc.hbrBackground = GetStockObject( BLACK_BRUSH );
    wc.hInstance     = hInstance;
    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.lpfnWndProc   = MainWndProc;

    if( !RegisterClass( &wc ) ) return 1;
   }


//-------------------------  Register Glyph Class  ----------------------------

  if( !hPrevInstance )
   {
    memset( &wc, 0, sizeof(wc) );

    wc.hCursor       = LoadCursor( NULL, IDC_ARROW );
    wc.hIcon         = NULL;
    wc.lpszClassName = SZGLYPHCLASS;
    wc.hbrBackground = GetStockObject( DKGRAY_BRUSH );
    wc.hInstance     = hInstance;
    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.lpfnWndProc   = GlyphWndProc;

    if( !RegisterClass( &wc ) ) return 1;
   }


//-------------------------  Register Rings Class  ----------------------------

  if( !hPrevInstance )
   {
    memset( &wc, 0, sizeof(wc) );

    wc.hCursor       = LoadCursor( NULL, IDC_ARROW );
    wc.hIcon         = NULL;
    wc.lpszClassName = SZRINGSCLASS;
    wc.hbrBackground = GetStockObject( WHITE_BRUSH );
    wc.hInstance     = hInstance;
    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.lpfnWndProc   = RingsWndProc;

    if( !RegisterClass( &wc ) ) return 1;
   }


//------------------------  Register String Class  ----------------------------

  if( !hPrevInstance )
   {
    memset( &wc, 0, sizeof(wc) );

    wc.hCursor       = LoadCursor( NULL, IDC_ARROW );
    wc.hIcon         = NULL;
    wc.lpszClassName = SZSTRINGCLASS;
    wc.hbrBackground = GetStockObject( WHITE_BRUSH );
    wc.hInstance     = hInstance;
    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.lpfnWndProc   = StringWndProc;

    if( !RegisterClass( &wc ) ) return 1;
   }


//-----------------------  Register Waterfall Class  --------------------------

  if( !hPrevInstance )
   {
    memset( &wc, 0, sizeof(wc) );

    wc.hCursor       = LoadCursor( NULL, IDC_ARROW );
    wc.hIcon         = NULL;
    wc.lpszClassName = SZWATERFALLCLASS;
    wc.hbrBackground = GetStockObject( WHITE_BRUSH );
    wc.hInstance     = hInstance;
    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.lpfnWndProc   = WaterfallWndProc;

    if( !RegisterClass( &wc ) ) return 1;
   }


//-------------------------  Register Whirl Class  ----------------------------

  if( !hPrevInstance )
   {
    memset( &wc, 0, sizeof(wc) );

    wc.hCursor       = LoadCursor( NULL, IDC_ARROW );
    wc.hIcon         = NULL;
    wc.lpszClassName = SZWHIRLCLASS;
    wc.hbrBackground = GetStockObject( WHITE_BRUSH );
    wc.hInstance     = hInstance;
    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.lpfnWndProc   = WhirlWndProc;

    if( !RegisterClass( &wc ) ) return 1;
   }

//-------------------------  Register AnsiSet Class  ----------------------------

  if( !hPrevInstance )
   {
    memset( &wc, 0, sizeof(wc) );

    wc.hCursor       = LoadCursor( NULL, IDC_ARROW );
    wc.hIcon         = NULL;
    wc.lpszClassName = SZANSISET;
    wc.hbrBackground = GetStockObject( WHITE_BRUSH );
    wc.hInstance     = hInstance;
    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.lpfnWndProc   = AnsiSetWndProc;

    if( !RegisterClass( &wc ) ) return 1;
   }



//-------------------------  Register GlyphSet Class  ----------------------------

  if( !hPrevInstance )
   {
    memset( &wc, 0, sizeof(wc) );

    wc.hCursor       = LoadCursor( NULL, IDC_ARROW );
    wc.hIcon         = NULL;
    wc.lpszClassName = SZGLYPHSET;
    wc.hbrBackground = GetStockObject( WHITE_BRUSH );
    wc.hInstance     = hInstance;
    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.lpfnWndProc   = GlyphSetWndProc;

    if( !RegisterClass( &wc ) ) return 1;
   }




//------------------------  Register Widths Class  ----------------------------

  if( !hPrevInstance )
   {
    memset( &wc, 0, sizeof(wc) );

    wc.hCursor       = LoadCursor( NULL, IDC_ARROW );
    wc.hIcon         = NULL;
    wc.lpszClassName = SZWIDTHSCLASS;
    wc.hbrBackground = GetStockObject( WHITE_BRUSH );
    wc.hInstance     = hInstance;
    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.lpfnWndProc   = WidthsWndProc;

    if( !RegisterClass( &wc ) ) return 1;
   }


//------------------------  Create Main Window  -------------------------------

  hwndMain = CreateWindow( SZMAINCLASS,
                           SZMAINCLASS,
                           WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                           0,
                           0,
                           GetSystemMetrics( SM_CXSCREEN ),
                           GetSystemMetrics( SM_CYSCREEN ),
                           NULL,
                           NULL,
                           hInstance,
                           NULL );

  ShowWindow( hwndMain, nCmdShow );
  UpdateWindow( hwndMain );



  GetClientRect( hwndMain, &rcl );

  cxScreen = rcl.right;      //  GetSystemMetrics( SM_CXSCREEN );
  cyScreen = rcl.bottom;     //  GetSystemMetrics( SM_CYSCREEN );

  cxBorder = GetSystemMetrics( SM_CXFRAME );



  //--------  Create Debug Window in Right Third of Screen  -----------

  hwndDebug = CreateWindow( "LISTBOX",
                            "FontTest Debug Window",
                            WS_CHILD | WS_VISIBLE | WS_BORDER | WS_VSCROLL | WS_HSCROLL | LBS_NOINTEGRALHEIGHT,
                            2 * cxScreen / 3 + cxBorder -1 ,
                            0,
                            cxScreen / 3,
                            cyScreen,
                            hwndMain,
                            NULL,
                            hInst,
                            NULL );

  {
   HDC hdc;
   int lfHeight;


   hdc = CreateIC( "DISPLAY", NULL, NULL, NULL );
   lfHeight = -(10 * GetDeviceCaps( hdc, LOGPIXELSY )) / 72;
   DeleteDC( hdc );

   hFontDebug = CreateFont( lfHeight, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Courier" );

   SendMessage( hwndDebug,
                WM_SETFONT,
                (WPARAM) hFontDebug,
                FALSE );
  }

//  SendMessage( hwndDebug,
//               WM_SETFONT,
//               GetStockObject( SYSTEM_FIXED_FONT ),
//               FALSE );

  ShowWindow( hwndDebug, SW_SHOWNORMAL );
  UpdateWindow( hwndDebug );


  //--------  Create Glyph Window in Left 2/3 of Screen  -----------

  hwndGlyph = CreateWindow( SZGLYPHCLASS,
                            "FontTest Glyph Window",
                            WS_CHILD,
                            0,
                            0,
                            2 * cxScreen / 3 - 3,
                            cyScreen,
                            hwndMain,
                            NULL,
                            hInst,
                            NULL );


  ShowWindow( hwndGlyph, SW_HIDE );
  UpdateWindow( hwndGlyph );


  //--------  Create Rings Window in Left Half of Screen  -----------

  hwndRings = CreateWindow( SZRINGSCLASS,
                            "FontTest Rings Window",
                            WS_CHILD,
                            0,
                            0,
                            2 * cxScreen / 3 - 3,
                            cyScreen,
                            hwndMain,
                            NULL,
                            hInst,
                            NULL );


  ShowWindow( hwndRings, SW_HIDE );
  UpdateWindow( hwndRings );


  //--------  Create String Window in Left Half of Screen  ----------

  hwndString = CreateWindow( SZSTRINGCLASS,
                             "FontTest String Window",
                             WS_CHILD | WS_VISIBLE,
                             0,
                             0,
                             2 * cxScreen / 3 - 3,
                             cyScreen,
                             hwndMain,
                             NULL,
                             hInst,
                             NULL );


  ShowWindow( hwndString, SW_HIDE );
  UpdateWindow( hwndString );

  hwndMode = hwndString;


  //------  Create Waterfall Window in Left Half of Screen  ---------

  hwndWaterfall = CreateWindow( SZWATERFALLCLASS,
                                "FontTest Waterfall Window",
                                WS_CHILD,
                                0,
                                0,
                                2 * cxScreen / 3 - 3,
                                cyScreen,
                                hwndMain,
                                NULL,
                                hInst,
                                NULL );


  ShowWindow( hwndWaterfall, SW_HIDE );
  UpdateWindow( hwndWaterfall );


  //--------  Create Whirl Window in Left Half of Screen  -----------

  hwndWhirl = CreateWindow( SZWHIRLCLASS,
                            "FontTest Whirl Window",
                            WS_CHILD,
                            0,
                            0,
                            2 * cxScreen / 3 - 3,
                            cyScreen,
                            hwndMain,
                            NULL,
                            hInst,
                            NULL );


  ShowWindow( hwndWhirl, SW_HIDE );
  UpdateWindow( hwndWhirl );

  //--------  Create AnsiSet Window in Left Half of Screen  -----------

  hwndAnsiSet = CreateWindow( SZANSISET,
                            "FontTest AnsiSet Window",
                            WS_CHILD,
                            0,
                            0,
                            2 * cxScreen / 3 - 3,
                            cyScreen,
                            hwndMain,
                            NULL,
                            hInst,
                            NULL );


  ShowWindow( hwndAnsiSet, SW_HIDE );
  UpdateWindow( hwndAnsiSet );


    //--------  Create GlyphSet Window in Left Half of Screen  -----------

  hwndGlyphSet = CreateWindow( SZGLYPHSET,
                            "FontTest GlyphSet Window",
                            WS_CHILD,
                            0,
                            0,
                            2 * cxScreen / 3 - 3,
                            cyScreen,
                            hwndMain,
                            NULL,
                            hInst,
                            NULL );


  ShowWindow( hwndGlyphSet, SW_HIDE );
  UpdateWindow( hwndGlyphSet );



  //--------  Create Widths Window in Left Half of Screen  -----------

  hwndWidths = CreateWindow( SZWIDTHSCLASS,
                             "FontTest Widths Window",
                             WS_CHILD,
                             0,
                             0,
                             2 * cxScreen / 3 - 3,
                             cyScreen,
                             hwndMain,
                             NULL,
                             hInst,
                             NULL );


  ShowWindow( hwndWidths, SW_HIDE );
  UpdateWindow( hwndWidths );


//-----------------------  Process Messages  -------------------------

  while( GetMessage( &msg, NULL, 0, 0 ) )
   {
    TranslateMessage( &msg );
    DispatchMessage( &msg );
   }


  if( hFontDebug ) DeleteObject( hFontDebug );


  return (DWORD)msg.wParam;
 }


//*****************************************************************************
//*********************   S H O W   D I A L O G   B O X   *********************
//*****************************************************************************

INT_PTR ShowDialogBox(DLGPROC DialogProc, int iResource, LPVOID lpVoid )
 {
  INT_PTR     rc;
  DLGPROC lpProc;


  lpProc = MakeProcInstance( DialogProc, hInst );

  if( lpProc == NULL ) return -1;

  if (!isCharCodingUnicode)
  {
	  rc =
		DialogBoxParamA(
			hInst,
			(LPCSTR) MAKEINTRESOURCE( iResource ),
			hwndMain,
			lpProc,
			(LPARAM) lpVoid
			);
  }
  else
  {
	  rc =
		DialogBoxParamW(
			hInst,
			(LPCWSTR) MAKEINTRESOURCE( iResource ),
			hwndMain,
			lpProc,
			(LPARAM) lpVoid
			);
  }

  FreeProcInstance( lpProc );

  return rc;
 }


//*****************************************************************************
//****************************   D P R I N T F   ******************************
//*****************************************************************************

int Debugging = 1;
int iCount    = 0;

BOOL bLogging = FALSE;
char szLogFile[256];


int dprintf (char *fmt, ... )
 {
  int      ret;
  va_list  marker;
  static   char szBuffer[256];



  if( !Debugging ) return 0;

  va_start( marker, fmt );
  ret = vsprintf( szBuffer, fmt, marker );


//------------------------  Log to Debug List Box  ----------------------------

  if( hwndDebug != NULL )
   {
    SendMessage( hwndDebug,
                 LB_ADDSTRING,
                 0,
                 (LPARAM) (LPSTR) szBuffer );

    SendMessage(
        hwndDebug,
        LB_SETCURSEL,
        (WPARAM) iCount,
        0
        );
   }


//-----------------------------  Log to File  ---------------------------------

  if( bLogging )
   {
    int fh;


    fh = _lopen( szLogFile, OF_WRITE | OF_SHARE_COMPAT );
    if( fh == -1 )
      fh = _lcreat( szLogFile, 0 );
     else
      _llseek( fh, 0L, 2 );

    if( fh != -1 )
     {
      lstrcat( szBuffer, "\r\n" );
      _lwrite( fh, szBuffer, lstrlen(szBuffer) );
      _lclose( fh );
     }

   }

  iCount++;

  return ret;
 }

int dwprintf( wchar_t *fmt, ... )
 {
  int      ret;
  va_list  marker;
  static   WCHAR szBuffer[256];
  static   char  szBufferA[256];



  if( !Debugging ) return 0;

  va_start( marker, fmt );
  ret = vswprintf( szBuffer, fmt, marker );

  //MessageBoxW(NULL, szBuffer, NULL, MB_OK);


//------------------------  Log to Debug List Box  ----------------------------

  if( hwndDebug != NULL )
   {
    SendMessageW( hwndDebug,
                 LB_ADDSTRING,
                 0,
                 (LPARAM) (LPWSTR) szBuffer );

    SendMessage(
        hwndDebug,
        LB_SETCURSEL,
        (WPARAM) iCount,
        0
        );
   }


//-----------------------------  Log to File  ---------------------------------

  if( bLogging )
   {
    int fh;


    fh = _lopen( szLogFile, OF_WRITE | OF_SHARE_COMPAT );
    if( fh == -1 )
      fh = _lcreat( szLogFile, 0 );
     else
      _llseek( fh, 0L, 2 );

    if( fh != -1 )
     {
      lstrcatW( szBuffer, L"\r\n" );
      SyncStringWtoA(szBufferA, szBuffer, 256);
      _lwrite( fh, szBufferA, lstrlen(szBufferA) );
      _lclose( fh );
     }

   }

  iCount++;

  return ret;
 }


// calling dUpdateNow with FALSE prevents the debug listbox from updating
// on every string insertion.  calling dUpdateNow with TRUE turns on updating
// on string insertion and refreshes the display to show the current contents.

// Note: change TRUE to FALSE in InvalidateRect when listbox repaint bug is
// fixed.

void dUpdateNow( BOOL bUpdateNow )
 {
  /* make sure we want to do something first! */
  if( !Debugging || !hwndDebug )
   return;

  /* set listbox updating accordingly */
  SendMessage( hwndDebug, WM_SETREDRAW, bUpdateNow, 0L );

  /* if we are reenabling immediate updating force redraw of listbox */
  if( bUpdateNow ) {
   InvalidateRect(hwndDebug, NULL, FALSE);
   UpdateWindow(hwndDebug);
  }
 }

//*****************************************************************************
//***********************   C L E A R   D E B U G   ***************************
//*****************************************************************************

void ClearDebug( void )
 {
  iCount = 0;
  SendMessage( hwndDebug, LB_RESETCONTENT, 0, 0 );
 }


//*****************************************************************************
//******************   C R E A T E   P R I N T E R   D C   ********************
//*****************************************************************************

HDC CreatePrinterDC( void )
 {
  LPDEVNAMES lpDevNames;
  LPBYTE     lpDevMode;
  LPSTR      lpszDriver, lpszDevice, lpszOutput;


  if( hdcCachedPrinter ) return hdcCachedPrinter;

  lpDevNames = (LPDEVNAMES)GlobalLock( pdlg.hDevNames );
  lpDevMode  = (LPBYTE)    GlobalLock( pdlg.hDevMode );

  if (!lpDevNames || !lpDevMode)
      return NULL;

  lpszDriver = (LPSTR)lpDevNames+lpDevNames->wDriverOffset;
  lpszDevice = (LPSTR)lpDevNames+lpDevNames->wDeviceOffset;
  lpszOutput = (LPSTR)lpDevNames+lpDevNames->wOutputOffset;


  dprintf( "lpszDriver = '%Fs'", lpszDriver );
  dprintf( "lpszDevice = '%Fs'", lpszDevice );
  dprintf( "lpszOutput = '%Fs'", lpszOutput );

  hdcCachedPrinter = CreateDC( lpszDriver, lpszDevice, lpszOutput, (CONST DEVMODE*) lpDevMode );

  dprintf( "  hdc = 0x%.4X", hdcCachedPrinter );

  GlobalUnlock( pdlg.hDevNames );
  GlobalUnlock( pdlg.hDevMode );

  return hdcCachedPrinter;
 }


//*****************************************************************************
//********************   S E T   D C   M A P   M O D E   **********************
//*****************************************************************************

void SetDCMapMode( HDC hdc, UINT wMode )
 {
  char *psz;

  switch( wMode )
   {
    case IDM_MMHIENGLISH:   SetMapMode( hdc, MM_HIENGLISH ); psz = "MM_HIENGLISH"; break;
    case IDM_MMLOENGLISH:   SetMapMode( hdc, MM_LOENGLISH ); psz = "MM_LOENGLISH"; break;
    case IDM_MMHIMETRIC:    SetMapMode( hdc, MM_HIMETRIC  ); psz = "MM_HIMETRIC";  break;
    case IDM_MMLOMETRIC:    SetMapMode( hdc, MM_LOMETRIC  ); psz = "MM_LOMETRIC";  break;
    case IDM_MMTEXT:        SetMapMode( hdc, MM_TEXT      ); psz = "MM_TEXT";      break;
    case IDM_MMTWIPS:       SetMapMode( hdc, MM_TWIPS     ); psz = "MM_TWIPS";     break;

    case IDM_MMANISOTROPIC: SetMapMode( hdc, MM_ANISOTROPIC );

                            SetWindowOrgEx( hdc, xWO, yWO , 0);
                            SetWindowExtEx( hdc, xWE, yWE , 0);

                            SetViewportOrgEx( hdc, xVO, yVO , 0);
                            SetViewportExtEx( hdc, xVE, yVE , 0);

                            psz = "MM_ANISOTROPIC";
                            break;
   }
    if (bAdvanced)
    {
        SetGraphicsMode(hdc,GM_ADVANCED);
        SetWorldTransform(hdc,&xf);
    }
    else
    {
    // reset to unity before resetting compatible

        ModifyWorldTransform(hdc,NULL, MWT_IDENTITY);
        SetGraphicsMode(hdc,GM_COMPATIBLE);
    }



//  dprintf( "Set DC Map Mode to %s", psz );
 }


//*****************************************************************************
//********************   C R E A T E   T E S T   I C   ************************
//*****************************************************************************

HDC CreateTestIC( void )
 {
  HDC   hdc;
  POINT pt[2];

  if( wUsePrinterDC )
    hdc = CreatePrinterDC();
   else
    hdc = CreateDC( "DISPLAY", NULL, NULL, NULL );

  if( !hdc )
   {
    dprintf( "Error creating TestDC" );
    return NULL;
   }

  SetDCMapMode( hdc, wMappingMode );

  cxDevice = GetDeviceCaps( hdc, HORZRES );
  cyDevice = GetDeviceCaps( hdc, VERTRES );

  pt[0].x = cxDevice;
  pt[0].y = cyDevice;
  pt[1].x = 0;
  pt[1].y = 0;
  DPtoLP(hdc,&pt[0],2);

  cxDC = pt[0].x - pt[1].x;
  cyDC = pt[0].y - pt[1].y;

  return hdc;
 }


//*****************************************************************************
//********************   D E L E T E   T E S T   I C   ************************
//*****************************************************************************

void DeleteTestIC( HDC hdc )
 {
  if( hdc != hdcCachedPrinter ) DeleteDC( hdc );
 }


//*****************************************************************************
//**********************   D R A W   D C   A X I S   **************************
//*****************************************************************************

HRGN hrgnClipping;


void DrawDCAxis( HWND hwnd, HDC hdc, BOOL bAxis )
 {
  POINT ptl[2];
  RECT  rect;
  int   dx10, dy10, dx100, dy100;

  int   xClip1, yClip1, xClip2, yClip2;
  HRGN  hrgn;



//  dprintf( "Drawing DC Axis" );


//--------------------------  Figure out DC Size  -----------------------------

  if( hwnd )
    {
     GetClientRect( hwnd, &rect );
     ptl[0].x = rect.right;
     ptl[0].y = rect.bottom;
    }
   else
    {
     ptl[0].x = GetDeviceCaps( hdc, HORZRES );
     ptl[0].y = GetDeviceCaps( hdc, VERTRES );
    }

  cxDevice = ptl[0].x;
  cyDevice = ptl[0].y;

//  dprintf( "  cxDevice = %d", cxDevice );
//  dprintf( "  cyDevice = %d", cyDevice );

    ptl[1].x = 0;
    ptl[1].y = 0;

    DPtoLP(hdc,&ptl[0],2);

    if
    (
      (wMappingMode != IDM_MMTEXT)
      && (wMappingMode != IDM_MMANISOTROPIC)
      && !bAdvanced
    )
    {
     if( ptl[0].y < 0 ) ptl[0].y = -ptl[0].y;
     SetViewportOrgEx( hdc, 0, cyDevice , 0);  // Adjust Viewport Origin to Lower Left
    }

    cxDC = ptl[0].x - ptl[1].x;
    cyDC = ptl[0].y - ptl[1].y;

    xDC = ptl[1].x;
    yDC = ptl[1].y;

//  dprintf( "  cxDC     = %d", cxDC );
//  dprintf( "  cyDC     = %d", cyDC );

//----------------------  Draw background -------------------------------------

    //TODO: find out from Bodin how we should restrict drawing the background
    
    if(!bAxis || isGradientBackground)
    {
        TRIVERTEX   verticies[2];
        GRADIENT_RECT   rects[1];

        verticies[0].Blue = GetBValue(dwRGBLeftBackgroundColor) << 8;
        verticies[0].Red = GetRValue(dwRGBLeftBackgroundColor) << 8;
        verticies[0].Green = GetGValue(dwRGBLeftBackgroundColor) << 8;
        verticies[0].x = xDC;
        verticies[0].y = yDC;

        verticies[1].Blue = GetBValue(dwRGBRightBackgroundColor) << 8;
        verticies[1].Red = GetRValue(dwRGBRightBackgroundColor) << 8;
        verticies[1].Green = GetGValue(dwRGBRightBackgroundColor) << 8;
        verticies[1].x = xDC + cxDC;
        verticies[1].y = yDC + cyDC;

        rects[0].UpperLeft = 0;
        rects[0].LowerRight = 1;

#ifdef GI_API

        GradientFill(hdc, verticies, 2, rects, 1, GRADIENT_FILL_RECT_H);
#endif
    
    }
    if(!isGradientBackground)
    {
        HBRUSH  solidBrush = CreateSolidBrush(dwRGBSolidBackgroundColor);
        RECT    rect;

        rect.top = yDC;
        rect.left = xDC;
        rect.bottom = yDC + cyDC;
        rect.right = xDC + cxDC;
        
        if(solidBrush != NULL)
        {
            FillRect(hdc, &rect, solidBrush);
            DeleteObject(solidBrush);
        }
    }


//----------------------  Draw Reference Triangle (ugly)  ---------------------

    if (bAxis)
    {
        if (!bAdvanced)
        {
            dx10  = ptl[0].x / 10;
            dy10  = ptl[0].y / 10;
            dx100 = dx10 / 10;
            dy100 = dy10 / 10;

            MoveToEx( hdc, dx100,      dy100      ,0);
            LineTo( hdc, dx100+dx10, dy100      );
            LineTo( hdc, dx100,      dy100+dy10 );
            LineTo( hdc, dx100,      dy100      );
        }
        else
        {
            MoveToEx(hdc,0,0,0);
            LineTo(hdc,xDC + cxDC/2,yDC + cyDC/2);
        }
    }

//-------------------------  Create Clipping Region  --------------------------

  xClip1 = cxDevice/2 - cxDevice/4;
  yClip1 = cyDevice/2 - cyDevice/4;
  xClip2 = cxDevice/2 + cxDevice/4;
  yClip2 = cyDevice/2 + cyDevice/4;

//  dprintf( "Clip1: %d,%d", xClip1, yClip1 );
//  dprintf( "Clip2: %d,%d", xClip2, yClip2 );

  hrgnClipping = NULL;

  if( bClipEllipse )
   {
    hrgnClipping = CreateEllipticRgn( xClip1, yClip1, xClip2, yClip2 );
   }

  if( bClipPolygon )
   {
    POINT aptl[5];

    aptl[0].x = xClip1;
    aptl[0].y = cyDevice/2;
    aptl[1].x = cxDevice/2;
    aptl[1].y = yClip1;
    aptl[2].x = xClip2;
    aptl[2].y = cyDevice/2;
    aptl[3].x = cxDevice/2;
    aptl[3].y = yClip2;
    aptl[4].x = xClip1;
    aptl[4].y = cyDevice/2;


    hrgn = CreatePolygonRgn( (LPPOINT)aptl, 5, ALTERNATE );
    if( hrgnClipping )
      {
       CombineRgn( hrgnClipping, hrgnClipping, hrgn, RGN_XOR );
       DeleteObject( hrgn );
      }
     else
      hrgnClipping = hrgn;
   }

  if( bClipRectangle )
   {
    hrgn = CreateRectRgn( xClip1, yClip1, xClip2, yClip2 );
    if( hrgnClipping )
      {
       CombineRgn( hrgnClipping, hrgnClipping, hrgn, RGN_XOR );
       DeleteObject( hrgn );
      }
     else
      hrgnClipping = hrgn;
   }

  if( hrgnClipping )
   {
    int  rc;
    RECT r;


    r.top    = yDC;
    r.left   = xDC;
    r.right  = xDC + cxDC;
    r.bottom = yDC + cyDC;
    FillRect( hdc, &r, GetStockObject( LTGRAY_BRUSH ) );

//    dprintf( "Filling region white" );
    rc = FillRgn( hdc, hrgnClipping, GetStockObject( WHITE_BRUSH ) );
//    dprintf( "  rc = %d", rc );

//    dprintf( "Selecting clipping region into DC" );
    rc = SelectClipRgn( hdc, hrgnClipping );
//    dprintf( "  rc = %d", rc );
   }

 }


//*****************************************************************************
//***********************   C L E A N   U P   D C   ***************************
//*****************************************************************************

void CleanUpDC( HDC hdc )
 {
  if( hrgnClipping )
   {
    DeleteObject( hrgnClipping );
    hrgnClipping = NULL;
   }
 }


//*****************************************************************************
//***********************   H A N D L E   C H A R   ***************************
//*****************************************************************************

void HandleChar( HWND hwnd, WPARAM wParam )
 {
  int l;
  int i;
  char szBuffer[5*MAX_TEXT];

  if( wParam == '\b' )
  {
    if (!isCharCodingUnicode)
      szStringA[max(0,lstrlenA(szStringA)-1)] = '\0';
    else
      szStringW[max(0,lstrlenW(szStringW)-1)] = L'\0';
  }
   else
    {
     if (!isCharCodingUnicode)
         l = lstrlenA(szStringA);
     else
         l = lstrlenW(szStringW);

     if( l < MAX_TEXT-1 )
      {
         if (!isCharCodingUnicode)
         {
           szStringA[l]   = (char) wParam;
           szStringA[l+1] = '\0';
         }
         else
         {
           szStringW[l]   = (WCHAR) wParam;
           szStringW[l+1] = L'\0';
         }
      }
    }

  
   szBuffer[0] = 0;
   for (i=0; (UINT)i<wcslen(szStringW); i++)
			{
				sprintf(szBuffer, "%s|%04x", szBuffer, szStringW[i]);
			}
			dprintf( szBuffer );

  //dprintf("Added Character 0x%04x", wParam);
  if (!isCharCodingUnicode)
      SyncszStringWith(IDM_CHARCODING_UNICODE);
  else
      SyncszStringWith(IDM_CHARCODING_MBCS);

  InvalidateRect( hwnd, NULL, TRUE );
 }

//*****************************************************************************
//****************   S T R I N G   E D I T   D L G  P R O C   *****************
//*****************************************************************************

INT_PTR CALLBACK StringEditDlgProc( HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
	UINT i;
    CHAR szAchar[128];
	WCHAR szWchar[128];
	CHAR szBuffer[128];

    switch( msg ) {
    case WM_INITDIALOG:

        if (!isCharCodingUnicode)
            SetDlgItemTextA( hdlg, IDD_EDITSTRING, szStringA);
        else
            SetDlgItemTextW( hdlg, IDD_EDITSTRING, szStringW );
        return TRUE;

    case WM_COMMAND:

        switch( LOWORD( wParam ) ) {
        case IDOK:

			szWchar[0] = 0;
			szBuffer[0] = 0;

			// read the check buttons and the font filename
			if (!isCharCodingUnicode)
			{
				GetDlgItemTextA( hdlg, IDD_EDITSTRING, szAchar, sizeof(szAchar) );
				strcpy (szStringA, szAchar);
				SyncszStringWith(IDM_CHARCODING_UNICODE);
			}
			else
			{
				GetDlgItemTextW( hdlg, IDD_EDITSTRING, szWchar, sizeof(szWchar) );
				wcscpy (szStringW, szWchar);
				SyncszStringWith(IDM_CHARCODING_MBCS);
			}

			dprintf( "Input String: " );
			dprintf( szStringA );

			sprintf(szBuffer, "Unicode:  ");
			for (i=0; i<wcslen(szStringW); i++)
			{
				sprintf(szBuffer, "%s|%04x", szBuffer, szStringW[i]);
			}
			dprintf( szBuffer );

			sprintf(szBuffer, "ANSIMBCS: ");
			for (i=0; i<strlen(szStringA); i++)
			{
				sprintf(szBuffer, "%s|%02x", szBuffer, (UCHAR)szStringA[i]);
			}
			dprintf( szBuffer );

            EndDialog( hdlg, TRUE );
            return TRUE;

        case IDCANCEL:

            EndDialog( hdlg, FALSE );
            return TRUE;
        }
        break;

        case WM_CLOSE:

            EndDialog( hdlg, FALSE );
            return TRUE;
    }
    return FALSE;
}




















//*****************************************************************************
//****************   S T R I N G   E D I T   D L G  P R O C   *****************
//*****************************************************************************

INT_PTR CALLBACK GlyphIndexEditDlgProc( HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
	int i, j, cnt;
    CHAR szTemp[40];
	CHAR szBuffer[500];
    BOOL bUsePdx, bUsePdy, bGlyphIndex;
    HMENU hMenu;

    switch( msg ) {
    case WM_INITDIALOG:

        bUsePdx = (lpintdx != NULL);
        bUsePdy = (wETO & ETO_PDY);

        if (wUseGlyphIndex)
            SendDlgItemMessage( hdlg, IDD_CHK_USEGLYPHINDEX, BM_SETCHECK, 1, 0);
        if (bUsePdx)
            SendDlgItemMessage( hdlg, IDD_CHK_USEPDX, BM_SETCHECK, 1, 0);
        if (bUsePdy)
            SendDlgItemMessage( hdlg, IDD_CHK_USEPDY, BM_SETCHECK, 1, 0);

        // Glyph Indices
        {
            szBuffer[0] = 0;
            for (i=0; i<lstrlenW(wszStringGlyphIndex); i++)
                wsprintf(szBuffer, "%s%d,", szBuffer, (UINT)wszStringGlyphIndex[i]);
            SetDlgItemText( hdlg, IDD_STRGLYPHINDEX, szBuffer);
        }

        // Pdx
        {
            szBuffer[0] = 0;
            for (i=0; i<sizePdx; i++)
            {
                wsprintf(szBuffer, "%s%d,", szBuffer, intdx[i]);
                if (bUsePdy) i++;  // skip over y
            }
            SetDlgItemText( hdlg, IDD_STRPDX, szBuffer);
        }

        // Pdy
        if (bUsePdy)
        {
            szBuffer[0] = 0;
            for (i=1; i<sizePdx; i++)
            {
                wsprintf(szBuffer, "%s%d,", szBuffer, intdx[i]);
                i++;  // skip over x
            }
            SetDlgItemText( hdlg, IDD_STRPDY, szBuffer);
        }

        return TRUE;

    case WM_COMMAND:

        switch( LOWORD( wParam ) ) {
        case IDOK:

			szBuffer[0] = 0;

            bGlyphIndex = (0 != (BYTE)SendDlgItemMessage( hdlg, IDD_CHK_USEGLYPHINDEX, BM_GETCHECK, 0, 0));

            if (bGlyphIndex)
            {
                if (wUseGlyphIndex == 0) 
                    SendMessage(GetParent(hdlg), WM_COMMAND, IDM_USEGLYPHINDEX, 0);
                
                GetDlgItemText( hdlg, IDD_STRGLYPHINDEX, szBuffer, sizeof(szBuffer) );

                i = cnt = 0;
                while (szBuffer[i] != '\0')
                {
                    j = 0;
                    while ((szBuffer[i] != ',') && (szBuffer[i] != '\0'))
                    {
                        szTemp[j] = szBuffer[i];
                        i++; j++;
                    }
                    szTemp[j] = 0;
                    wszStringGlyphIndex[cnt] = (WORD)atoi(szTemp);
                    if (szBuffer[i] == '\0' || szBuffer[i+1] == '\0') break;
                    i++;
                    cnt++;
                }
            
                wszStringGlyphIndex[++cnt] = 0; 
                SizewszStringGlyph = cnt; 

                szBuffer[0] = 0;
			    sprintf(szBuffer, "Glyph Indices: ");
			    for (i=0; i<SizewszStringGlyph; i++)
			    {
				    sprintf(szBuffer, "%s|%d", szBuffer, (WORD)wszStringGlyphIndex[i]);
			    }
			    dprintf( szBuffer );
            }
            else
            {
                if (wUseGlyphIndex != 0) 
                    SendMessage(GetParent(hdlg), WM_COMMAND, IDM_USEGLYPHINDEX, 0);
            }

            bUsePdx = (0 != (BYTE)SendDlgItemMessage( hdlg, IDD_CHK_USEPDX, BM_GETCHECK, 0, 0));
            bUsePdy = (0 != (BYTE)SendDlgItemMessage( hdlg, IDD_CHK_USEPDY, BM_GETCHECK, 0, 0));

            if (bUsePdy && !bUsePdx)
            {
                MessageBox (hdlg, "You cannot specify pdy without specifying pdx", "Error", MB_OK);
                return FALSE;
            }

            if (bUsePdx)
            {
                bPdxPdy = TRUE;
                ZeroMemory(intdx, sizeof(intdx));
                lpintdx = intdx;

                // take care of pdx first
                {
                    // invoke handler for pdx now, but we may switch to pdxpdy later
                    SendMessage(GetParent(hdlg), WM_COMMAND, IDM_PDX, 0);    

                    GetDlgItemText( hdlg, IDD_STRPDX, szBuffer, sizeof(szBuffer) );

                    i = cnt = 0;
                    while (szBuffer[i] != '\0')
                    {
                        j = 0;
                        while ((szBuffer[i] != ',') && (szBuffer[i] != '\0'))
                        {
                            szTemp[j] = szBuffer[i];
                            i++; j++;
                        }
                        szTemp[j] = 0;
                        intdx[cnt] = atoi(szTemp);
                        if (szBuffer[i] == '\0' || szBuffer[i+1] == '\0') break;
                        i++;
                        cnt++;
                        // if (bUsePdy) cnt++;   // leave every other cell for y
                    }
                    sizePdx = cnt + 1;
                }

                if (bUsePdy)
                {
                    // invoke handler for pdxpdy now, this overrides earlier pdx setting 
                    SendMessage(GetParent(hdlg), WM_COMMAND, IDM_PDXPDY, 0);

                    GetDlgItemText( hdlg, IDD_STRPDY, szBuffer, sizeof(szBuffer) );

                    i = 0;
                    cnt = 1;
                    while (szBuffer[i] != '\0')
                    {
                        j = 0;
                        while ((szBuffer[i] != ',') && (szBuffer[i] != '\0'))
                        {
                            szTemp[j] = szBuffer[i];
                            i++; j++;
                        }
                        szTemp[j] = 0;
                        intdx[cnt] = atoi(szTemp);
                        if (szBuffer[i] == '\0' || szBuffer[i+1] == '\0') break;
                        i++;
                        cnt++;
                        cnt++;   // jump over x
                    }
                    sizePdx = max(sizePdx, cnt + 1);
                }
                else
                {
                    // wETO &= ~ETO_PDY;
                }
            }
            else
            {
                lpintdx = NULL;
                SendMessage(GetParent(hdlg), WM_COMMAND, IDM_USEDEFAULTSPACING, 0);
                dprintf("Spacing reset to default");
            }

            bPdxPdy = bUsePdx & bUsePdy;


            EndDialog( hdlg, TRUE );
            return TRUE;

        case IDCANCEL:

            EndDialog( hdlg, FALSE );
            return TRUE;
        }
        break;

        case WM_CLOSE:

            EndDialog( hdlg, FALSE );
            return TRUE;
    }
    return FALSE;
}


















//*****************************************************************************
//********   S E T   T E X T O U T   O P T I O N S   D L G   P R O C   ********
//*****************************************************************************

INT_PTR CALLBACK SetTextOutOptionsDlgProc( HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam )
 {
  switch( msg )
   {
    case WM_INITDIALOG:
              {
               WORD wId;


               switch( wTextAlign & 0x18 )
                {
                 case TA_TOP:      wId = IDD_TATOP;      break;
                 case TA_BASELINE: wId = IDD_TABASELINE; break;
                 case TA_BOTTOM:   wId = IDD_TABOTTOM;   break;
                 default:          wId = IDD_TABOTTOM;   break;
                }

               SendDlgItemMessage( hdlg, (int) wId, BM_SETCHECK, 1, 0 );

               switch( wTextAlign & 0x06 )
                {
                 case TA_LEFT:     wId = IDD_TALEFT;     break;
                 case TA_CENTER:   wId = IDD_TACENTER;   break;
                 case TA_RIGHT:    wId = IDD_TARIGHT;    break;
                 default:          wId = IDD_TALEFT;     break;
                }

               CheckDlgButton( hdlg, wId, 1 );

               CheckDlgButton( hdlg, IDD_TARTLREADING, (wTextAlign & 0x100? 1 : 0) );

               CheckDlgButton( hdlg, (iBkMode==TRANSPARENT ? IDD_TRANSPARENT:IDD_OPAQUE), 1 );

               CheckDlgButton( hdlg, IDD_ETO_CLIPPED, (wETO & ETO_CLIPPED ? 1 : 0) );
               CheckDlgButton( hdlg, IDD_ETO_OPAQUE,  (wETO & ETO_OPAQUE  ? 1 : 0) );

			   CheckDlgButton(hdlg, IDD_ALTERNATEFILL, ((fillMode == ALTERNATE_FILL) ? 1 : 0));
			   CheckDlgButton(hdlg, IDD_WINDINGFILL, ((fillMode == WINDING_FILL) ? 1 : 0));
			   EnableWindow(GetDlgItem(hdlg, IDD_ALTERNATEFILL), bFillPath);
			   EnableWindow(GetDlgItem(hdlg, IDD_WINDINGFILL), bFillPath);

               if (bStrokePath)
                CheckDlgButton( hdlg, IDD_STROKEPATH, 1);
			   if (bFillPath)
				CheckDlgButton( hdlg, IDD_FILLPATH, 1);
              }

              return TRUE;


    case WM_COMMAND:
              switch( LOWORD(wParam ) )
               {
                case IDOK:
                       if(       IsDlgButtonChecked( hdlg, IDD_TATOP      ) )
                         wTextAlign = TA_TOP;
                        else if( IsDlgButtonChecked( hdlg, IDD_TABASELINE ) )
                         wTextAlign = TA_BASELINE;
                        else if( IsDlgButtonChecked( hdlg, IDD_TABOTTOM   ) )
                         wTextAlign = TA_BOTTOM;
                        else
                         wTextAlign = TA_BOTTOM;

                       if(       IsDlgButtonChecked( hdlg, IDD_TALEFT     ) )
                         wTextAlign |= TA_LEFT;
                        else if( IsDlgButtonChecked( hdlg, IDD_TACENTER   ) )
                         wTextAlign |= TA_CENTER;
                        else if( IsDlgButtonChecked( hdlg, IDD_TARIGHT    ) )
                         wTextAlign |= TA_RIGHT;
                        else
                         wTextAlign |= TA_LEFT;

                       if(       IsDlgButtonChecked( hdlg, IDD_TARTLREADING  ) )
                         wTextAlign |= TA_RTLREADING;

                       if(       IsDlgButtonChecked( hdlg, IDD_TRANSPARENT ) )
                         iBkMode = TRANSPARENT;
                        else if( IsDlgButtonChecked( hdlg, IDD_OPAQUE      ) )
                         iBkMode = OPAQUE;
                        else
                         iBkMode = TRANSPARENT;

                       // wETO = 0;
                       if( IsDlgButtonChecked(hdlg, IDD_ETO_CLIPPED) ) 
                            wETO |= ETO_CLIPPED;
                       else wETO &= ~ETO_CLIPPED;

                       if( IsDlgButtonChecked(hdlg, IDD_ETO_OPAQUE ) ) 
                            wETO |= ETO_OPAQUE;
                       else wETO &= ~ETO_OPAQUE;

                       if( IsDlgButtonChecked(hdlg, IDD_STROKEPATH) )
                           bStrokePath = TRUE;
                       else
                           bStrokePath = FALSE;

                       if( IsDlgButtonChecked(hdlg, IDD_FILLPATH) )
                           bFillPath = TRUE;
                       else
                           bFillPath = FALSE;

					   if (IsDlgButtonChecked(hdlg, IDD_ALTERNATEFILL))
						   fillMode = ALTERNATE_FILL;
					   else
						   fillMode = WINDING_FILL;

                       EndDialog( hdlg, TRUE );
                       return TRUE;

				case IDD_FILLPATH:
                       if( IsDlgButtonChecked(hdlg, IDD_FILLPATH) )
					   {
						   EnableWindow(GetDlgItem(hdlg, IDD_ALTERNATEFILL), TRUE);
						   EnableWindow(GetDlgItem(hdlg, IDD_WINDINGFILL), TRUE);
					   }
					   else
					   {
						   EnableWindow(GetDlgItem(hdlg, IDD_ALTERNATEFILL), FALSE);
						   EnableWindow(GetDlgItem(hdlg, IDD_WINDINGFILL), FALSE);
					   }
					   return TRUE;

                case IDCANCEL:
                       EndDialog( hdlg, FALSE );
                       return TRUE;
               }

              break;


    case WM_CLOSE:
              EndDialog( hdlg, FALSE );
              return TRUE;

   }

  return FALSE;
 }


//*****************************************************************************
//****************   S H O W   R A S T E R I Z E R   C A P S   ****************
//*****************************************************************************

void ShowRasterizerCaps( void )
 {
  RASTERIZER_STATUS rs;


  dprintf( "Calling GetRasterizerCaps" );


  rs.nSize       = sizeof(rs);
  rs.wFlags      = 0;
  rs.nLanguageID = 0;

  if( !lpfnGetRasterizerCaps( &rs, sizeof(rs) ) )
   {
    dprintf( "  GetRasterizerCaps failed!" );
    return;
   }

  dprintf( "  rs.nSize       = %d",     rs.nSize       );
  dprintf( "  rs.wFlags      = 0x%.4X", rs.wFlags      );
  dprintf( "  rs.nLanguageID = %d",     rs.nLanguageID );

  dprintf( "GetRasterizerCaps done" );
 }


//*****************************************************************************
//**********   S H O W   E X T E N D E D   T E X T   M E T R I C S   **********
//*****************************************************************************

void ShowExtendedTextMetrics( HWND hwnd )
 {
  HDC    hdc;
  HFONT  hFont, hFontOld;
  WORD   wSize;
  int    wrc;
  EXTTEXTMETRIC etm;


  hdc = CreateTestIC();

  hFont    = CreateFontIndirectWrapperA( &elfdvA );
  hFontOld = SelectObject( hdc, hFont );

  SetTextAlign( hdc, wTextAlign );

  dprintf( "Getting size of Extended Text Metrics" );

  memset( &etm, 0, sizeof(etm) );
  wSize = sizeof(etm);

  wrc = ExtEscape( hdc, GETEXTENDEDTEXTMETRICS, 0, NULL, sizeof(EXTTEXTMETRIC), (char *)&etm);
  // wrc = Escape( hdc, GETEXTENDEDTEXTMETRICS, 0, NULL, &etm );
  dprintf( "  wrc = %d", wrc );

  dUpdateNow( FALSE );

  dprintf( "Extended Text Metrics" );
  dprintf( "  etmSize                = %d",     etm.etmSize );

  dprintf( "  etmSize                = %d",      etm.etmSize             );
  dprintf( "  etmPointSize           = %d",      etm.etmPointSize        );
  dprintf( "  etmOrientation         = %d",      etm.etmOrientation      );
  dprintf( "  etmMasterHeight        = %d",      etm.etmMasterHeight     );
  dprintf( "  etmMinScale            = %d",      etm.etmMinScale         );
  dprintf( "  etmMaxScale            = %d",      etm.etmMaxScale         );
  dprintf( "  etmMasterUnits         = %d",      etm.etmMasterUnits      );
  dprintf( "  etmCapHeight           = %d",      etm.etmCapHeight        );
  dprintf( "  etmXHeight             = %d",      etm.etmXHeight          );
  dprintf( "  etmLowerCaseAscent     = %d",      etm.etmLowerCaseAscent  );
  dprintf( "  etmLowerCaseDescent    = %d",      etm.etmLowerCaseDescent );
  dprintf( "  etmSlant               = %d",      etm.etmSlant            );
  dprintf( "  etmSuperscript         = %d",      etm.etmSuperscript      );
  dprintf( "  etmSubscript           = %d",      etm.etmSubscript        );
  dprintf( "  etmSuperscriptSize     = %d",      etm.etmSuperscriptSize  );
  dprintf( "  etmSubscriptSize       = %d",      etm.etmSubscriptSize    );
  dprintf( "  etmUnderlineOffset     = %d",      etm.etmUnderlineOffset  );
  dprintf( "  etmUnderlineWidth      = %d",      etm.etmUnderlineWidth   );
  dprintf( "  etmDoubleUpperUnderlineOffset %d", etm.etmDoubleUpperUnderlineOffset );
  dprintf( "  etmDoubleLowerUnderlineOffset %d", etm.etmDoubleLowerUnderlineOffset );
  dprintf( "  etmDoubleUpperUnderlineWidth  %d", etm.etmDoubleUpperUnderlineWidth );
  dprintf( "  etmDoubleLowerUnderlineWidth  %d", etm.etmDoubleLowerUnderlineWidth );
  dprintf( "  etmStrikeoutOffset     = %d",      etm.etmStrikeoutOffset  );
  dprintf( "  etmStrikeoutWidth      = %d",      etm.etmStrikeoutWidth   );
  dprintf( "  etmKernPairs           = %d",      etm.etmKernPairs        );
  dprintf( "  etmKernTracks          = %d",      etm.etmKernTracks       );

  dprintf( "  " );

  dUpdateNow( TRUE );

//Exit:
  SelectObject( hdc, hFontOld );
  DeleteObject( hFont );

  DeleteTestIC( hdc );
 }

/******************************Public*Routine******************************\
*
* ShowPairKerningTable
*
* Effects:
*
* Warnings:
*
* History:
*  29-Mar-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



void ShowPairKerningTable( HWND hwnd )
{
  HDC    hdc;
  HFONT  hFont, hFontOld;
  WORD   wSize;
  int    wrc;
  EXTTEXTMETRIC etm;
  KERNPAIR UNALIGNED *lpkp;
  WORD   j;


  hdc = CreateTestIC();

  hFont    = CreateFontIndirectWrapperA( &elfdvA );
  hFontOld = SelectObject( hdc, hFont );

  SetTextAlign( hdc, wTextAlign );

  dprintf( "Getting size of Extended Text Metrics" );

  memset( &etm, 0, sizeof(etm) );
  wSize = sizeof(etm);

  wrc = ExtEscape( hdc, GETEXTENDEDTEXTMETRICS, 0, NULL, sizeof(EXTTEXTMETRIC), (BYTE *)&etm);

  dprintf( "  wrc = %d", wrc );

  if (wrc > 0)
  {
    dprintf( "  etmKernPairs           = %d",      etm.etmKernPairs        );

    dprintf( "  " );

    if (etm.etmKernPairs)
    {
      wSize = etm.etmKernPairs * sizeof(KERNPAIR);
      if (lpkp = (LPKERNPAIR)malloc(wSize))
      {
        dprintf( "Calling ExtEscape for GETPAIRKERNTABLE" );
        wrc = ExtEscape( hdc, GETPAIRKERNTABLE, 0, NULL, wSize, (BYTE *)lpkp );
        dprintf( "  wrc = %d", wrc );

        if (wrc > 0)
        {
          dprintf( "  First     Second     Amount");
          dprintf( " =======   ========   ========");

          for (j = 0; j < etm.etmKernPairs; j++)
          {
            dprintf( "  %c=%x       %c=%x       %d",
                 lpkp[j].wBoth & 0x00FF,
                 lpkp[j].wBoth & 0x00FF,
                 lpkp[j].wBoth >> 8,
                 lpkp[j].wBoth >> 8,
                 lpkp[j].sAmount);
          }
        }

        free( lpkp );
      }
    }
  }

  dUpdateNow( TRUE );

//Exit:

  SelectObject( hdc, hFontOld );
  DeleteObject( hFont );

  DeleteTestIC( hdc );
}







//*****************************************************************************
//***********   S H O W   O U T L I N E   T E X T   M E T R I C S   ***********
//*****************************************************************************

void ShowOutlineTextMetrics( HWND hwnd )
 {
  HDC    hdc;
  HFONT  hFont, hFontOld;
  WORD   wrc;
  LPOUTLINETEXTMETRICA lpotm = NULL;
  LPOUTLINETEXTMETRICW lpotmW = NULL;



  hdc = CreateTestIC();

  if (!isCharCodingUnicode)
      hFont    = CreateFontIndirectWrapperA( &elfdvA );
  else
      hFont    = CreateFontIndirectWrapperW( &elfdvW );
  hFontOld = SelectObject( hdc, hFont );

  SetTextAlign( hdc, wTextAlign );

  dprintf( "Getting size of Outline Text Metrics" );

  if (!isCharCodingUnicode)
      wrc = (WORD)lpfnGetOutlineTextMetricsA( hdc, 0, NULL );
  else
      wrc = (WORD)lpfnGetOutlineTextMetricsW( hdc, 0, NULL );
  dprintf( "  wrc = %u", wrc );

  if( wrc == 0 ) goto Exit;

  if (!isCharCodingUnicode) 
  {
    lpotm = (LPOUTLINETEXTMETRIC) calloc( 1, wrc );
    dprintf( "  lpotm = %Fp", lpotm );
  }
  else
  {
    lpotmW = (LPOUTLINETEXTMETRICW) calloc( 1, wrc );
    dprintf( "  lpotmW = %Fp", lpotmW );
  }

  if( ((!isCharCodingUnicode) && (lpotm == NULL)) || 
      (( isCharCodingUnicode) && (lpotmW == NULL)) )
   {
    dprintf( "  Couldn't allocate OutlineTextMetrics structure" );
    goto Exit;
   }

  if (!isCharCodingUnicode) 
  {
    lpotm->otmSize = wrc;
    wrc = (WORD)lpfnGetOutlineTextMetricsA( hdc, wrc, lpotm );
  }
  else
  {
    lpotmW->otmSize = wrc;
    wrc = (WORD)lpfnGetOutlineTextMetricsW( hdc, wrc, lpotmW );
  }

  dprintf( "  wrc = %u", wrc );

  if( !wrc )
   {
    dprintf( "  Error getting outline text metrics" );
    goto Exit;
   }

  dUpdateNow( FALSE );

  if (!isCharCodingUnicode) 
  {
      dprintf( "Outline Text Metrics" );
      dprintf( "  otmSize                = %u",     lpotm->otmSize );
      dprintf( "  otmfsSelection         = 0x%.4X", lpotm->otmfsSelection );
      dprintf( "  otmfsType              = 0x%.4X", lpotm->otmfsType );
      dprintf( "  otmsCharSlopeRise      = %u",     lpotm->otmsCharSlopeRise );
      dprintf( "  otmsCharSlopeRun       = %u",     lpotm->otmsCharSlopeRun );
      dprintf( "  otmItalicAngle         = %d",     lpotm->otmItalicAngle );
      dprintf( "  otmEMSquare            = %u",     lpotm->otmEMSquare );
      dprintf( "  otmAscent              = %u",     lpotm->otmAscent );
      dprintf( "  otmDescent             = %d",     lpotm->otmDescent );
      dprintf( "  otmLineGap             = %u",     lpotm->otmLineGap );
      dprintf( "  otmsXHeight            = %u",     lpotm->otmsXHeight );
      dprintf( "  otmsCapEmHeight        = %u",     lpotm->otmsCapEmHeight );
      dprintf( "  otmrcFontBox           = (%d,%d)-(%d,%d)", lpotm->otmrcFontBox.left,
                                                       lpotm->otmrcFontBox.top,
                                                       lpotm->otmrcFontBox.right,
                                                       lpotm->otmrcFontBox.bottom );
      dprintf( "  otmMacAscent           = %u",     lpotm->otmMacAscent );
      dprintf( "  otmMacDescent          = %d",     lpotm->otmMacDescent );
      dprintf( "  otmMacLineGap          = %d",     lpotm->otmMacLineGap );
      dprintf( "  otmusMinimumPPEM       = %u",     lpotm->otmusMinimumPPEM );

      dprintf( "  otmptSubscriptSize     = (%d,%d)", lpotm->otmptSubscriptSize.x,     lpotm->otmptSubscriptSize.y     );
      dprintf( "  otmptSubscriptOffset   = (%d,%d)", lpotm->otmptSubscriptOffset.x,   lpotm->otmptSubscriptOffset.y   );
      dprintf( "  otmptSuperscriptSize   = (%d,%d)", lpotm->otmptSuperscriptSize.x,   lpotm->otmptSuperscriptSize.y   );
      dprintf( "  otmptSuperscriptOffset = (%d,%d)", lpotm->otmptSuperscriptOffset.x, lpotm->otmptSuperscriptOffset.y );

      dprintf( "  otmsStrikeoutSize      = %u",     lpotm->otmsStrikeoutSize      );
      dprintf( "  otmsStrikeoutPosition  = %u",     lpotm->otmsStrikeoutPosition  );
      dprintf( "  otmsUnderscoreSize     = %d",     lpotm->otmsUnderscoreSize     );
      dprintf( "  otmsUnderscorePosition = %d",     lpotm->otmsUnderscorePosition );

      dprintf( "  otmpFamilyName         = '%Fs'", (LPSTR)lpotm+(WORD)lpotm->otmpFamilyName );
      dprintf( "  otmpFaceName           = '%Fs'", (LPSTR)lpotm+(WORD)lpotm->otmpFaceName );
      dprintf( "  otmpStyleName          = '%Fs'", (LPSTR)lpotm+(WORD)lpotm->otmpStyleName );
      dprintf( "  otmpFullName           = '%Fs'", (LPSTR)lpotm+(WORD)lpotm->otmpFullName );

      dprintf( "    tmHeight           = %d", lpotm->otmTextMetrics.tmHeight           );
      dprintf( "    tmAscent           = %d", lpotm->otmTextMetrics.tmAscent           );
      dprintf( "    tmDescent          = %d", lpotm->otmTextMetrics.tmDescent          );
      dprintf( "    tmInternalLeading  = %d", lpotm->otmTextMetrics.tmInternalLeading  );
      dprintf( "    tmExternalLeading  = %d", lpotm->otmTextMetrics.tmExternalLeading  );
      dprintf( "    tmAveCharWidth     = %d", lpotm->otmTextMetrics.tmAveCharWidth     );
      dprintf( "    tmMaxCharWidth     = %d", lpotm->otmTextMetrics.tmMaxCharWidth     );
      dprintf( "    tmWeight           = %d", lpotm->otmTextMetrics.tmWeight           );
      dprintf( "    tmItalic           = %d", lpotm->otmTextMetrics.tmItalic           );
      dprintf( "    tmUnderlined       = %d", lpotm->otmTextMetrics.tmUnderlined       );
      dprintf( "    tmStruckOut        = %d", lpotm->otmTextMetrics.tmStruckOut        );
      dprintf( "    tmFirstChar        = %d", lpotm->otmTextMetrics.tmFirstChar        );
      dprintf( "    tmLastChar         = %d", lpotm->otmTextMetrics.tmLastChar         );
      dprintf( "    tmDefaultChar      = %d", lpotm->otmTextMetrics.tmDefaultChar      );
      dprintf( "    tmBreakChar        = %d", lpotm->otmTextMetrics.tmBreakChar        );
      dprintf( "    tmPitchAndFamily   = 0x%.2X", lpotm->otmTextMetrics.tmPitchAndFamily  );
      dprintf( "    tmCharSet          = %d", lpotm->otmTextMetrics.tmCharSet          );
      dprintf( "    tmOverhang         = %d", lpotm->otmTextMetrics.tmOverhang         );
      dprintf( "    tmDigitizedAspectX = %d", lpotm->otmTextMetrics.tmDigitizedAspectX );
      dprintf( "    tmDigitizedAspectY = %d", lpotm->otmTextMetrics.tmDigitizedAspectY );

      dprintf( "  " );
  }
  else
  {
      dprintf( "Outline Text Metrics W" );
      dprintf( "  otmSize                = %u",     lpotmW->otmSize );
      dprintf( "  otmfsSelection         = 0x%.4X", lpotmW->otmfsSelection );
      dprintf( "  otmfsType              = 0x%.4X", lpotmW->otmfsType );
      dprintf( "  otmsCharSlopeRise      = %u",     lpotmW->otmsCharSlopeRise );
      dprintf( "  otmsCharSlopeRun       = %u",     lpotmW->otmsCharSlopeRun );
      dprintf( "  otmItalicAngle         = %d",     lpotmW->otmItalicAngle );
      dprintf( "  otmEMSquare            = %u",     lpotmW->otmEMSquare );
      dprintf( "  otmAscent              = %u",     lpotmW->otmAscent );
      dprintf( "  otmDescent             = %d",     lpotmW->otmDescent );
      dprintf( "  otmLineGap             = %u",     lpotmW->otmLineGap );
      dprintf( "  otmsXHeight            = %u",     lpotmW->otmsXHeight );
      dprintf( "  otmsCapEmHeight        = %u",     lpotmW->otmsCapEmHeight );
      dprintf( "  otmrcFontBox           = (%d,%d)-(%d,%d)", lpotmW->otmrcFontBox.left,
                                                       lpotmW->otmrcFontBox.top,
                                                       lpotmW->otmrcFontBox.right,
                                                       lpotmW->otmrcFontBox.bottom );
      dprintf( "  otmMacAscent           = %u",     lpotmW->otmMacAscent );
      dprintf( "  otmMacDescent          = %d",     lpotmW->otmMacDescent );
      dprintf( "  otmMacLineGap          = %d",     lpotmW->otmMacLineGap );
      dprintf( "  otmusMinimumPPEM       = %u",     lpotmW->otmusMinimumPPEM );

      dprintf( "  otmptSubscriptSize     = (%d,%d)", lpotmW->otmptSubscriptSize.x,     lpotmW->otmptSubscriptSize.y     );
      dprintf( "  otmptSubscriptOffset   = (%d,%d)", lpotmW->otmptSubscriptOffset.x,   lpotmW->otmptSubscriptOffset.y   );
      dprintf( "  otmptSuperscriptSize   = (%d,%d)", lpotmW->otmptSuperscriptSize.x,   lpotmW->otmptSuperscriptSize.y   );
      dprintf( "  otmptSuperscriptOffset = (%d,%d)", lpotmW->otmptSuperscriptOffset.x, lpotmW->otmptSuperscriptOffset.y );

      dprintf( "  otmsStrikeoutSize      = %u",     lpotmW->otmsStrikeoutSize      );
      dprintf( "  otmsStrikeoutPosition  = %u",     lpotmW->otmsStrikeoutPosition  );
      dprintf( "  otmsUnderscoreSize     = %d",     lpotmW->otmsUnderscoreSize     );
      dprintf( "  otmsUnderscorePosition = %d",     lpotmW->otmsUnderscorePosition );

      dwprintf( L"  otmpFamilyName         = '%Fs'", (LPWSTR)((LPSTR)lpotmW+(WORD)lpotmW->otmpFamilyName) );
      dwprintf( L"  otmpFaceName           = '%Fs'", (LPWSTR)((LPSTR)lpotmW+(WORD)lpotmW->otmpFaceName)   );
      dwprintf( L"  otmpStyleName          = '%Fs'", (LPWSTR)((LPSTR)lpotmW+(WORD)lpotmW->otmpStyleName)  );
      dwprintf( L"  otmpFullName           = '%Fs'", (LPWSTR)((LPSTR)lpotmW+(WORD)lpotmW->otmpFullName)   );

      dprintf( "    tmHeight           = %d", lpotmW->otmTextMetrics.tmHeight           );
      dprintf( "    tmAscent           = %d", lpotmW->otmTextMetrics.tmAscent           );
      dprintf( "    tmDescent          = %d", lpotmW->otmTextMetrics.tmDescent          );
      dprintf( "    tmInternalLeading  = %d", lpotmW->otmTextMetrics.tmInternalLeading  );
      dprintf( "    tmExternalLeading  = %d", lpotmW->otmTextMetrics.tmExternalLeading  );
      dprintf( "    tmAveCharWidth     = %d", lpotmW->otmTextMetrics.tmAveCharWidth     );
      dprintf( "    tmMaxCharWidth     = %d", lpotmW->otmTextMetrics.tmMaxCharWidth     );
      dprintf( "    tmWeight           = %d", lpotmW->otmTextMetrics.tmWeight           );
      dprintf( "    tmItalic           = %d", lpotmW->otmTextMetrics.tmItalic           );
      dprintf( "    tmUnderlined       = %d", lpotmW->otmTextMetrics.tmUnderlined       );
      dprintf( "    tmStruckOut        = %d", lpotmW->otmTextMetrics.tmStruckOut        );
      dprintf( "    tmFirstChar        = %d", lpotmW->otmTextMetrics.tmFirstChar        );
      dprintf( "    tmLastChar         = %d", lpotmW->otmTextMetrics.tmLastChar         );
      dprintf( "    tmDefaultChar      = %d", lpotmW->otmTextMetrics.tmDefaultChar      );
      dprintf( "    tmBreakChar        = %d", lpotmW->otmTextMetrics.tmBreakChar        );
      dprintf( "    tmPitchAndFamily   = 0x%.2X", lpotmW->otmTextMetrics.tmPitchAndFamily  );
      dprintf( "    tmCharSet          = %d", lpotmW->otmTextMetrics.tmCharSet          );
      dprintf( "    tmOverhang         = %d", lpotmW->otmTextMetrics.tmOverhang         );
      dprintf( "    tmDigitizedAspectX = %d", lpotmW->otmTextMetrics.tmDigitizedAspectX );
      dprintf( "    tmDigitizedAspectY = %d", lpotmW->otmTextMetrics.tmDigitizedAspectY );

      dprintf( "  " );
  }

  dUpdateNow( TRUE );

Exit:
  if( lpotm ) free( lpotm );
  if( lpotmW) free( lpotm );

  SelectObject( hdc, hFontOld );
  DeleteObject( hFont );

  DeleteTestIC( hdc );
 }


//*****************************************************************************
//*******************   S H O W   T E X T   E X T E N T   *********************
//*****************************************************************************


DWORD GetCodePage(HDC hdc)
{
  DWORD FAR *lpSrc = UlongToPtr(GetTextCharsetInfo(hdc, 0, 0));
  CHARSETINFO csi;

  TranslateCharsetInfo(lpSrc, &csi, TCI_SRCCHARSET);

  return csi.ciACP;
}


void ShowTextExtent( HWND hwnd )
 {
  DWORD  dwrc;
  HDC    hdc;
  HFONT  hFont, hFontOld;
  ULONG  i;
  int    iSum;
  SIZE size;
  SIZE size32;
  ULONG len;


  int  cch = lstrlenA(szStringA);
  int  cwc = lstrlenW(szStringW);
  DWORD dwCP;

  hdc = CreateTestIC();

  if (!isCharCodingUnicode)
    hFont    = CreateFontIndirectWrapperA( &elfdvA );
  else
    hFont    = CreateFontIndirectWrapperW( &elfdvW );
  hFontOld = SelectObject( hdc, hFont );

  SetTextAlign( hdc, wTextAlign );

  dwCP = GetCodePage (hdc);

  if (!isCharCodingUnicode)
    dprintf("----string byte count cch=%ld", cch);
  else
    dprintf("----unicode count cwc=%ld", cwc);

  if (!isCharCodingUnicode)
  {
      dprintf( "Calling GetTextExtentPointA('%s', %ld)", szStringA, cch);
      if (GetTextExtentPoint  ( hdc, szStringA, cch, &size))
      {
        dwrc = (DWORD) (65536 * size.cy + size.cx);
        dprintf( "  dwrc = 0x%.8lX", dwrc );
        dprintf( "    width  = %d", (int)size.cx);
        dprintf( "    height = %d", (int)size.cy);
      }
      else
      {
        dprintf("GetTextExtentPointA failed");
      }

      dprintf( "Calling GetTextExtentPoint32A('%s', %ld)", szStringA, cch);
      if (GetTextExtentPoint32A( hdc, szStringA, cch, &size32))
      {
        dprintf( "    width  = %d", (int)size32.cx);
        dprintf( "    height = %d", (int)size32.cy);
      }
      else
      {
        dprintf("GetTextExtentPoint32A failed");
      }
  }
  else
  {
      dwprintf( L"Calling GetTextExtentPointW('%s', %ld)", szStringW, cwc);
      if (GetTextExtentPointW  ( hdc, szStringW, cwc, &size))
      {
        dprintf( "    width  = %d", (int)size.cx);
        dprintf( "    height = %d", (int)size.cy);
      }
      else
      {
        dprintf("GetTextExtentPointW failed");
      }

      dwprintf( L"Calling GetTextExtentPoint32W('%s', %ld)", szStringW, cwc);
      if (GetTextExtentPoint32W( hdc, szStringW, cwc, &size32))
      {
        dprintf( "    width  = %d", (int)size32.cx);
        dprintf( "    height = %d", (int)size32.cy);
      }
      else
      {
        dprintf("GetTextExtentPoint32W failed");
      }
  }

  dprintf("----printing individual widhts:----");

  // if ((cwc == cch) || (cwc == 0)) // if conversion to unicode failed
  {
    dprintf( " i   :   ch    :  width ");
    if (!isCharCodingUnicode)
        len = cch;
    else
        len = cwc;
    for (i = 0, iSum = 0; i < (ULONG)len; i++)
    {
      int iWidth;

      UINT u;

      if (!isCharCodingUnicode)
      {
         if (IsDBCSLeadByteEx(dwCP, szStringA[i]))
         {
             u = (UINT)(BYTE)szStringA[i];
             u <<= 8;
             u |= (UINT)(BYTE)szStringA[i+1];
             i++;
         }
         else
         {
             u = (UINT)(BYTE)szStringA[i];
         }

         GetCharWidthA(hdc, u, u, &iWidth);
      }
      else
      {
         u = (UINT)szStringW[i];
         GetCharWidthW(hdc, u, u, &iWidth);
      }

      dprintf( "%3.2d  : 0x%4.2x  : %3.2d",
                i,
                u,
                iWidth);

      iSum += iWidth;
    }
  }

  if (iSum != (int)size.cx)
  {
    dprintf("GetTextExtentPoint != Sum(CharWidths)");
    dprintf( "  GTE = %ld, Sum(CharWidths) = %ld", (int)size.cx, iSum );
  }
  else
  {
    dprintf("GetTextExtentPoint == Sum(CharWidths)");
  }


  SelectObject( hdc, hFontOld );
  DeleteObject( hFont );

  DeleteTestIC( hdc );
 
 }

//*****************************************************************************
//*******************   S H O W   T E X T   E X T E N T   *********************
//*****************************************************************************

void ShowTextExtentI( HWND hwnd )
 {
#ifdef GI_API
  DWORD  dwrc;
  HDC    hdc;
  HFONT  hFont, hFontOld;
  DWORD  ich, cch;
  SIZE size, size1;
  LPWORD pgi;
  DWORD  cwc;
  DWORD  dwCP;
  BYTE  *pch;
  WCHAR *pwc;

  hdc = CreateTestIC();

  hFont    = CreateFontIndirectWrapperA( &elfdvA );
  hFontOld = SelectObject( hdc, hFont );

  SetTextAlign( hdc, wTextAlign );

  dwCP = GetCodePage(hdc);

if (!isCharCodingUnicode)
{
  cch = (DWORD)lstrlenA(szStringA);

  pgi = (LPWORD)malloc(cch * sizeof(WORD));
  if (pgi)
  {
      dprintf( "Calling GetGlyphIndicesA('%s')", szStringA );
      if ((cwc = GetGlyphIndicesA(hdc, szStringA, cch, pgi, 0)) != GDI_ERROR)
      {

        dprintf( " ich :  str :  gi ");
        for (pch = szStringA, ich=0; ich<cwc; ich++, pch++)
        {
          USHORT us;

          if (IsDBCSLeadByteEx(dwCP, *pch))
          {
            us = (*pch << 8);
            pch++;
            us |= *pch;
          }
          else
          {
            us = *pch;
          }

          dprintf( "%3.2d  : 0x%3.2x  : %3.2d",
                    ich,
                    us,
                    pgi[ich]);
        }

        dprintf( "Calling GetTextExtentPointI('%s')", szStringA );

        GetTextExtentPointI(hdc, pgi, cwc, &size);

        dwrc = (DWORD) (65536 * size.cy + size.cx);

        GetTextExtentPoint(hdc, szStringA, cch, &size1);

        if ((size.cx != size1.cx) || (size.cy != size1.cy))
        {
            dprintf( "GetTextExtentPointI != GetTextExtentPointA problem!!!");
        }

        dprintf( "  dwrc = 0x%.8lX", dwrc );
        dprintf( "  height = %d", (int)HIWORD(dwrc) );
        dprintf( "  width  = %d", (int)LOWORD(dwrc) );
      }
      else
      {
          dprintf("GetGlyphIndicesA failed!!!");
      }

      free(pgi);
  }

}
else // unicode
{
  cwc = (DWORD)wcslen(szStringW);

  pgi = (LPWORD)malloc(cwc * sizeof(WORD));
  if (pgi)
  {
      dprintf( "Calling GetGlyphIndicesW('%w')", szStringW );
      if ((cwc = GetGlyphIndicesW(hdc, szStringW, cwc, pgi, 0)) != GDI_ERROR)
      {

        dprintf( " ich :  str :  gi ");
        for (pwc = szStringW, ich=0; ich<cwc; ich++, pwc++)
        {
          USHORT us = *pwc;

          dprintf( "%3.2d  : 0x%3.2x  : %3.2d",
                    ich,
                    us,
                    pgi[ich]);
        }

        dprintf( "Calling GetTextExtentPointI('%s')", szStringA );

        GetTextExtentPointI(hdc, pgi, cwc, &size);

        dwrc = (DWORD) (65536 * size.cy + size.cx);

        GetTextExtentPointW(hdc, szStringW, cwc, &size1);

        if ((size.cx != size1.cx) || (size.cy != size1.cy))
        {
            dprintf( "GetTextExtentPointI != GetTextExtentPointW problem!!!");
        }

        dprintf( "  dwrc = 0x%.8lX", dwrc );
        dprintf( "  height = %d", (int)HIWORD(dwrc) );
        dprintf( "  width  = %d", (int)LOWORD(dwrc) );
      }
      else
      {
          dprintf("GetGlyphIndicesW failed!!!");
      }

      free(pgi);
  }
}

  SelectObject( hdc, hFontOld );
  DeleteObject( hFont );

  DeleteTestIC( hdc );
#endif
 }


void ShowCharWidthI(HWND hwnd )
{
#ifdef GI_API

  HDC    hdc;
  HFONT  hFont, hFontOld;
  DWORD  ich, cch;
  SIZE size;
  LPWORD pgi = NULL;
  LPINT  pWidths;
  LPABC  pabc;
  INT    iTextExtent = 0;
  ABC    abc;
  INT    iWidth;

  DWORD  cwc;
  DWORD  dwCP;
  BYTE  *pch;
  WCHAR *pwc;

  hdc = CreateTestIC();

  hFont    = CreateFontIndirectWrapperA( &elfdvA );
  hFontOld = SelectObject( hdc, hFont );

  SetTextAlign( hdc, wTextAlign );

  if (!isCharCodingUnicode)
  {
    dwCP = GetCodePage(hdc);

    cch = (DWORD)lstrlen(szStringA);

    pabc = (LPABC)malloc(cch * (sizeof(ABC)+sizeof(int)+sizeof(WORD)));

    if (pabc)
    {
        pWidths = (LPINT)&pabc[cch];
        pgi = (LPWORD)&pWidths[cch];

        dprintf( "Calling GetGlyphIndicesA('%s')", szStringA );
        dprintf( "Calling GetCharWidthI");
        dprintf( "Calling GetCharABCWidthsI");

        if ((cwc = GetGlyphIndicesA(hdc, szStringA, cch, pgi, 0)) != GDI_ERROR)
        {

          if (GetCharWidthI(hdc, 0, cwc, pgi, pWidths))
          {
            if (GetCharABCWidthsI(hdc, 0, cwc, pgi, pabc))
            {
              dprintf( "ich  : str    :  gi  : width :  A  :  B  :  C  : A+B+C");
              for (pch = szStringA, ich=0; ich<cwc; ich++, pch++)
              {

                USHORT us;

                if (IsDBCSLeadByteEx(dwCP, *pch))
                {
                  us = (*pch << 8);
                  pch++;
                  us |= *pch;
                }
                else
                {
                  us = *pch;
                }

                dprintf( "%3.2d  : 0x%3.2x  : %3.2d : %3.2ld   : %3.2ld : %3.2ld : %3.2ld : %3.2ld",
                          ich,
                          us,
                          pgi[ich],
                          pWidths[ich],
                          pabc[ich].abcA,
                          pabc[ich].abcB,
                          pabc[ich].abcC,
                          pabc[ich].abcA + pabc[ich].abcB + pabc[ich].abcC
                          );
                iTextExtent += pWidths[ich];
              }

              dprintf( " ");
              dprintf( "Total             = %3.2ld", iTextExtent);

              dprintf( "Calling GetTextExtentPointI('%s')", szStringA );

              GetTextExtentPointI(hdc, pgi, cwc, &size);

              if ((int)size.cx != iTextExtent)
              {
                  dprintf( "GetTextExtentPointI.x != SUM(CharWidths)");
              }

              dprintf( "  height = %ld", size.cy);
              dprintf( "  width  = %ld", size.cx);

            // more consistency checking:

              for (pch = szStringA, ich=0; ich<cwc; ich++, pch++)
              {

                  UINT u;

                  if (IsDBCSLeadByteEx(dwCP, *pch))
                  {
                    u = (*pch << 8);
                    pch++;
                    u |= *pch;
                  }
                  else
                  {
                    u = *pch;
                  }

                  if (GetCharWidthA(hdc, u, u, &iWidth))
                  {
                      if (iWidth != pWidths[ich])
                      {
                         dprintf( "%ld: GetCharWidthA: %ld != GetCharWidthI %ld ", ich, iWidth, pWidths[ich]);
                      }
                  }
                  else
                  {
                      dprintf( "GetCharWidthA() failed on szStringA[%ld] =  %ld", ich, u);
                  }

                  if (GetCharWidthI(hdc, (UINT)pgi[ich],1,NULL, &iWidth))
                  {
                      if (iWidth != pWidths[ich])
                      {
                         dprintf( "%ld: GetCharWidthI: %ld != %ld ", ich, iWidth, pWidths[ich]);
                      }
                  }
                  else
                  {
                      dprintf( "GetCharWidthI() failed on szStringA[%ld] =  %ld", ich, szStringA[ich]);
                  }

                  if (GetCharABCWidthsA(hdc, u, u, &abc))
                  {
                      if (memcmp(&abc, &pabc[ich], sizeof(abc)))
                      {
                         dprintf( "%ld: GetCharABCWidthsA: != GetCharABCWidthsI ", ich);
                         dprintf( "     (%ld, %ld, %ld)    != (%ld, %ld, %ld)",
                                        abc.abcA ,
                                        abc.abcB ,
                                        abc.abcC ,
                                        pabc[ich].abcA,
                                        pabc[ich].abcB,
                                        pabc[ich].abcC
                                        );

                      }
                  }
              }
            }
            else
            {
              dprintf("GetCharABCWidthsI failed!!!");
            }

          }
          else
          {
              dprintf("GetCharWidthI failed!!!");
          }

        }
        else
        {
            dprintf("GetGlyphIndicesA failed!!!");
        }

      free(pabc);
    }
    else
    {
      dprintf("malloc failed");
    }

  }
  else // unicode
  {
    cwc = (DWORD)wcslen(szStringW);

    pabc = (LPABC)malloc(cwc * (sizeof(ABC)+sizeof(int)+sizeof(WORD)));

    if (pabc)
    {
        pWidths = (LPINT)&pabc[cwc];
        pgi = (LPWORD)&pWidths[cwc];

        dprintf( "Calling GetGlyphIndicesW('%w')", szStringW );
        dprintf( "Calling GetCharWidthI");
        dprintf( "Calling GetCharABCWidthsI");

        if ((cwc = GetGlyphIndicesW(hdc, szStringW, cwc, pgi, 0)) != GDI_ERROR)
        {
          if (GetCharWidthI(hdc, 0, cwc, pgi, pWidths))
          {
            if (GetCharABCWidthsI(hdc, 0, cwc, pgi, pabc))
            {
              dprintf( "ich  : str    :  gi  : width :  A  :  B  :  C  : A+B+C");
              for (pwc = szStringW, ich=0; ich<cwc; ich++, pwc++)
              {

                USHORT us = *pwc;

                dprintf( "%3.2d  : 0x%3.2x  : %3.2d : %3.2ld   : %3.2ld : %3.2ld : %3.2ld : %3.2ld",
                          ich,
                          us,
                          pgi[ich],
                          pWidths[ich],
                          pabc[ich].abcA,
                          pabc[ich].abcB,
                          pabc[ich].abcC,
                          pabc[ich].abcA + pabc[ich].abcB + pabc[ich].abcC
                          );
                iTextExtent += pWidths[ich];
              }

              dprintf( " ");
              dprintf( "Total             = %3.2ld", iTextExtent);

              dprintf( "Calling GetTextExtentPointI('%w')", szStringW );

              GetTextExtentPointI(hdc, pgi, cwc, &size);

              if ((int)size.cx != iTextExtent)
              {
                  dprintf( "GetTextExtentPointI.x != SUM(CharWidths)");
              }

              dprintf( "  height = %ld", size.cy);
              dprintf( "  width  = %ld", size.cx);

            // more consistency checking:

              for (pwc = szStringW, ich=0; ich<cwc; ich++, pwc++)
              {

                  UINT u = *pwc;

                  if (GetCharWidthW(hdc, u, u, &iWidth))
                  {
                      if (iWidth != pWidths[ich])
                      {
                         dprintf( "%ld: GetCharWidthW: %ld != GetCharWidthI %ld ", ich, iWidth, pWidths[ich]);
                      }
                  }
                  else
                  {
                      dprintf( "GetCharWidthW() failed on szStringW[%ld] =  %ld", ich, u);
                  }

                  if (GetCharWidthI(hdc, (UINT)pgi[ich],1,NULL, &iWidth))
                  {
                      if (iWidth != pWidths[ich])
                      {
                         dprintf( "%ld: GetCharWidthI: %ld != %ld ", ich, iWidth, pWidths[ich]);
                      }
                  }
                  else
                  {
                      dprintf( "GetCharWidthI() failed on szStringW[%ld] =  %ld", ich, szStringW[ich]);
                  }

                  if (GetCharABCWidthsW(hdc, u, u, &abc))
                  {
                      if (memcmp(&abc, &pabc[ich], sizeof(abc)))
                      {
                         dprintf( "%ld: GetCharABCWidthsW: != GetCharABCWidthsI ", ich);
                         dprintf( "     (%ld, %ld, %ld)    != (%ld, %ld, %ld)",
                                        abc.abcA ,
                                        abc.abcB ,
                                        abc.abcC ,
                                        pabc[ich].abcA,
                                        pabc[ich].abcB,
                                        pabc[ich].abcC
                                        );

                      }
                  }
              }
            }
            else
            {
              dprintf("GetCharABCWidthsI failed!!!");
            }

          }
          else
          {
              dprintf("GetCharWidthI failed!!!");
          }

        }
        else
        {
            dprintf("GetGlyphIndicesW failed!!!");
        }

      free(pabc);
    }
    else
    {
      dprintf("malloc failed");
    }
  }

  SelectObject( hdc, hFontOld );
  DeleteObject( hFont );

  DeleteTestIC( hdc );

#endif
}




void ShowFontUnicodeRanges(HWND hwnd)
{
#ifdef GI_API

  DWORD  dwrc;
  HDC    hdc;
  HFONT  hFont, hFontOld;
  GLYPHSET *pgs;
  DWORD iRun;

  hdc = CreateTestIC();

  hFont    = CreateFontIndirectWrapperA( &elfdvA );
  hFontOld = SelectObject( hdc, hFont );

  SetTextAlign( hdc, wTextAlign );

  dwrc = GetFontUnicodeRanges(hdc, NULL);

  if (dwrc)
  {
    if (pgs = (GLYPHSET *)malloc(dwrc))
    {
        DWORD dwrc1 = GetFontUnicodeRanges(hdc, pgs);
        if (dwrc1 && (dwrc == dwrc1))
        {
            dprintf("  GetFontUnicodeRanges");
            dprintf("    GLYPHSET.cbThis           = %ld",   pgs->cbThis);
            dprintf("    GLYPHSET.flAccel          = 0x%lx", pgs->flAccel);
            dprintf("    GLYPHSET.cGlyphsSupported = %ld",   pgs->cGlyphsSupported);
            dprintf("    GLYPHSET.cRanges          = %ld",   pgs->cRanges);
            dprintf("     range : [ wcLow,wcHigh] = [wcLow,wcHigh]");
            for (iRun = 0; iRun < pgs->cRanges; iRun++)
            {
                dprintf("     %.5ld : [0x%.4lx,0x%.4lx] = [%.5ld,%.5ld]",
                               iRun,
                               pgs->ranges[iRun].wcLow,
                               pgs->ranges[iRun].wcLow + pgs->ranges[iRun].cGlyphs - 1,
                               pgs->ranges[iRun].wcLow,
                               pgs->ranges[iRun].wcLow + pgs->ranges[iRun].cGlyphs - 1
                               );
            }

        }
    }
  }

  dprintf( "  dwrc = 0x%.8lX", dwrc );

  SelectObject( hdc, hFontOld );
  DeleteObject( hFont );

  DeleteTestIC( hdc );

#endif

}




//*****************************************************************************
//********************   S H O W   T E X T   F A C E   ************************
//*****************************************************************************

void ShowTextFace( HWND hwnd )
 {
  int    rc;
  HDC    hdc;
  HFONT  hFont, hFontOld;
  static char szFace[64];
  static WCHAR szFaceW[64];

			
  hdc = CreateTestIC();

  if (!isCharCodingUnicode)
    hFont    = CreateFontIndirectWrapperA( &elfdvA );
  else
    hFont    = CreateFontIndirectWrapperW( &elfdvW );


  hFontOld = SelectObject( hdc, hFont );

  SetTextAlign( hdc, wTextAlign );

  dprintf( "Calling GetTextFace" );
  szFace[0] = '\0';
  szFaceW[0] = L'\0';
  if (!isCharCodingUnicode)
    rc = GetTextFaceA( hdc, sizeof(szFace), szFace );
  else
    rc = GetTextFaceW( hdc, sizeof(szFaceW)/sizeof(WCHAR), szFaceW );
  dprintf( "  rc = %d", rc );

  if( rc ) 
  {
      if (!isCharCodingUnicode)
        dprintf( "  szFace = '%s'", szFace );
      else
        dwprintf( L"  szFaceW = '%s'", szFaceW );
  }

  SelectObject( hdc, hFontOld );
  DeleteObject( hFont );

  DeleteTestIC( hdc );
 }




//*****************************************************************************
//******************   S H O W   T E X T   CHARSETINFO   ********************
//*****************************************************************************

void ShowTextCharsetInfo(HWND hwnd)
 {
  HDC    hdc;
  HFONT  hFont, hFontOld;
  static FONTSIGNATURE fsig;
  int    iCharSet;


  hdc = CreateTestIC();


  if (!isCharCodingUnicode)
    hFont    = CreateFontIndirectWrapperA( &elfdvA );
  else
    hFont    = CreateFontIndirectWrapperW( &elfdvW );
  hFontOld = SelectObject( hdc, hFont );

  if( (iCharSet = GetTextCharsetInfo( hdc, &fsig, 0)) ==  DEFAULT_CHARSET)
  {
   dprintf( "  Error getting TextCharsetInfo" );
   goto Exit;
  }

  dUpdateNow( FALSE );

  dprintf( "GetTextCharsetInfo" );
  dprintf( "  rc                 = %ld",iCharSet);
  dprintf( "FONTSIGNATURE:" );

  dprintf( "  fsUsb[0]  = 0x%lx", fsig.fsUsb[0]);
  dprintf( "  fsUsb[1]  = 0x%lx", fsig.fsUsb[1]);
  dprintf( "  fsUsb[2]  = 0x%lx", fsig.fsUsb[2]);
  dprintf( "  fsUsb[3]  = 0x%lx", fsig.fsUsb[3]);
  dprintf( "  fsCsb[0]  = 0x%lx", fsig.fsCsb[0]);
  dprintf( "  fsCsb[1]  = 0x%lx", fsig.fsCsb[1]);

  dprintf( "  " );

//ANSI bitfields
  if ( fsig.fsCsb[0] != 0 )
     dprintf( " fsCsb[0]:");
  if (fsig.fsCsb[0] & CPB_LATIN1_ANSI)
     dprintf( "              %s", "Latin1  ANSI");
  if (fsig.fsCsb[0] & CPB_LATIN2_EASTEU)
     dprintf( "              %s", "Latin2 Eastern Europe");
  if (fsig.fsCsb[0] & CPB_CYRILLIC_ANSI)
     dprintf( "              %s", "Cyrillic  ANSI");
  if (fsig.fsCsb[0] & CPB_GREEK_ANSI)
     dprintf( "              %s", "Greek  ANSI");
  if (fsig.fsCsb[0] & CPB_TURKISH_ANSI)
     dprintf( "              %s", "Turkish  ANSI");
  if (fsig.fsCsb[0] & CPB_HEBREW_ANSI)
     dprintf( "              %s", "Hebrew  ANSI");
  if (fsig.fsCsb[0] & CPB_ARABIC_ANSI)
     dprintf( "              %s", "Arabic  ANSI");
  if (fsig.fsCsb[0] & CPB_BALTIC_ANSI)
     dprintf( "              %s", "Baltic  ANSI");


//ANSI & OEM  bitfields
  if (fsig.fsCsb[0] & CPB_THAI)
     dprintf( "              %s", "Thai");
  if (fsig.fsCsb[0] & CPB_JIS_JAPAN)
     dprintf( "              %s", "JIS/Japan");
  if (fsig.fsCsb[0] & CPB_CHINESE_SIMP)
     dprintf( "              %s", "Chinese Simplified");
  if (fsig.fsCsb[0] & CPB_KOREAN_WANSUNG)
     dprintf( "              %s", "Korean Wansung");
  if (fsig.fsCsb[0] & CPB_CHINESE_TRAD)
     dprintf( "              %s", "Chinese Traditional");
  if (fsig.fsCsb[0] & CPB_KOREAN_JOHAB)
     dprintf( "              %s", "Korean Johab");
  if (fsig.fsCsb[0] & CPB_MACINTOSH_CHARSET)
     dprintf( "              %s", "Macintosh Character Set");
  if (fsig.fsCsb[0] & CPB_OEM_CHARSET)
     dprintf( "              %s", "OEM Character Set");
  if (fsig.fsCsb[0] & CPB_SYMBOL_CHARSET)
     dprintf( "              %s", "Symbol Character Set");

  dprintf( "  ");

// OEM bitfields
  if ( fsig.fsCsb[1] != 0 )
     dprintf( "fsCsb[1]:");
  if (fsig.fsCsb[1] & CPB_IBM_GREEK)
     dprintf( "              %s", "IBM Greek");
  if (fsig.fsCsb[1] & CPB_MSDOS_RUSSIAN)
     dprintf( "              %s", "MS-DOS Russian");
  if (fsig.fsCsb[1] & CPB_MSDOS_NORDIC)
     dprintf( "              %s", "MS-DOS Nordic");
  if (fsig.fsCsb[1] & CPB_ARABIC_OEM)
     dprintf( "              %s", "Arabic OEM");
  if (fsig.fsCsb[1] & CPB_MSDOS_CANADIANFRE)
     dprintf( "              %s", "MS-DOS Canadian French");
  if (fsig.fsCsb[1] & CPB_HEBREW_OEM)
     dprintf( "              %s", "Hebrew OEM");
  if (fsig.fsCsb[1] & CPB_MSDOS_ICELANDIC)
     dprintf( "              %s", "MS-DOS Icelandic");
  if (fsig.fsCsb[1] & CPB_MSDOS_PORTUGUESE)
     dprintf( "              %s", "MS-DOS Portuguese");
  if (fsig.fsCsb[1] & CPB_IBM_TURKISH)
     dprintf( "              %s", "IBM Turkish");
  if (fsig.fsCsb[1] & CPB_IBM_CYRILLIC)
     dprintf( "              %s", "IBM Cyrillic");
  if (fsig.fsCsb[1] & CPB_LATIN2_OEM)
     dprintf( "              %s", "Latin2 OEM");
  if (fsig.fsCsb[1] & CPB_BALTIC_OEM)
     dprintf( "              %s", "Baltic OEM");
  if (fsig.fsCsb[1] & CPB_GREEK_OEM)
     dprintf( "              %s", "Greek OEM");
  if (fsig.fsCsb[1] & CPB_ARABIC_OEM)
     dprintf( "              %s", "Arabic OEM");
  if (fsig.fsCsb[1] & CPB_WE_LATIN1)
     dprintf( "              %s", "WE/Latin1");
  if (fsig.fsCsb[1] & CPB_US_OEM)
     dprintf( "              %s", "US OEM");

  dprintf( "  ");

// fsUsb[0] fields
  if ( fsig.fsUsb[0] != 0 )
     dprintf(" fsUsb[0]:");
  if (fsig.fsUsb[0] & USB_BASIC_LATIN)
     dprintf( "              %s", "Basic Latin");
  if (fsig.fsUsb[0] & USB_LATIN1_SUPPLEMENT)
     dprintf( "              %s", "Latin-1 Supplement");
  if (fsig.fsUsb[0] & USB_LATIN_EXTENDEDA)
     dprintf( "              %s", "Latin Extended-A");
  if (fsig.fsUsb[0] & USB_LATIN_EXTENDEDB)
     dprintf( "              %s", "Latin Extended-B");
  if (fsig.fsUsb[0] & USB_IPA_EXTENSIONS)
     dprintf( "              %s", "IPA Extensions");
  if (fsig.fsUsb[0] & USB_SPACE_MODIF_LETTER)
     dprintf( "              %s", "Spacing Modifier Letters");
  if (fsig.fsUsb[0] & USB_COMB_DIACR_MARKS)
     dprintf( "              %s", "Combining Diacritical Marks");
  if (fsig.fsUsb[0] & USB_BASIC_GREEK)
     dprintf( "              %s", "Basic Greek");
  if (fsig.fsUsb[0] & USB_GREEK_SYM_COPTIC)
     dprintf( "              %s", "Greek Symbols Marks");
  if (fsig.fsUsb[0] & USB_CYRILLIC)
     dprintf( "              %s", "Cyrillic");
  if (fsig.fsUsb[0] & USB_ARMENIAN)
     dprintf( "              %s", "Armenian");
  if (fsig.fsUsb[0] & USB_BASIC_HEBREW)
     dprintf( "              %s", "Basic Hebrew");
  if (fsig.fsUsb[0] & USB_HEBREW_EXTENDED)
     dprintf( "              %s", "Hebrew Extended");
  if (fsig.fsUsb[0] & USB_BASIC_ARABIC)
     dprintf( "              %s", "Basic Arabic");
  if (fsig.fsUsb[0] & USB_ARABIC_EXTENDED)
     dprintf( "              %s", "Arabic Extended");
  if (fsig.fsUsb[0] & USB_DEVANAGARI)
     dprintf( "              %s", "Devanagari");
  if (fsig.fsUsb[0] & USB_BENGALI)
     dprintf( "              %s", "Bengali");
  if (fsig.fsUsb[0] & USB_GURMUKHI)
     dprintf( "              %s", "Gurmukhi");
  if (fsig.fsUsb[0] & USB_GUJARATI)
     dprintf( "              %s", "Gujarati");
  if (fsig.fsUsb[0] & USB_ORIYA)
     dprintf( "              %s", "Oriya");
  if (fsig.fsUsb[0] & USB_TAMIL)
     dprintf( "              %s", "Tamil");
  if (fsig.fsUsb[0] & USB_TELUGU)
     dprintf( "              %s", "Telugu");
  if (fsig.fsUsb[0] & USB_KANNADA)
     dprintf( "              %s", "Kannada");
  if (fsig.fsUsb[0] & USB_MALAYALAM)
     dprintf( "              %s", "Malayalam");
  if (fsig.fsUsb[0] & USB_THAI)
     dprintf( "              %s", "Thai");
  if (fsig.fsUsb[0] & USB_LAO)
     dprintf( "              %s", "Lao");
  if (fsig.fsUsb[0] & USB_BASIC_GEORGIAN)
     dprintf( "              %s", "Basic Georgian");
  if (fsig.fsUsb[0] & USB_HANGUL_JAMO)
     dprintf( "              %s", "Hangul Jamo");
  if (fsig.fsUsb[0] & USB_LATIN_EXT_ADD)
     dprintf( "              %s", "Latin Extended Additional");
  if (fsig.fsUsb[0] & USB_GREEK_EXTENDED)
     dprintf( "              %s", "Greek Extended");
  if (fsig.fsUsb[0] & USB_GEN_PUNCTUATION)
     dprintf( "              %s", "General Punctuation");

  dprintf( "  ");

// fsUsb[1] fields
  if ( fsig.fsUsb[1] != 0)
     dprintf(" fsUsb[1]:");
  if (fsig.fsUsb[1] & USB_SUPER_SUBSCRIPTS)
     dprintf( "              %s", "Superscripts and Subscripts");
  if (fsig.fsUsb[1] & USB_CURRENCY_SYMBOLS)
     dprintf( "              %s", "Currency Symbols");
  if (fsig.fsUsb[1] & USB_COMB_DIACR_MARK_SYM)
     dprintf( "              %s", "Combining diacritical Marks For Symbols");
  if (fsig.fsUsb[1] & USB_LETTERLIKE_SYMBOL)
     dprintf( "              %s", "Letterlike Symbols");
  if (fsig.fsUsb[1] & USB_NUMBER_FORMS)
     dprintf( "              %s", "Number Forms");
  if (fsig.fsUsb[1] & USB_ARROWS)
     dprintf( "              %s", "Arrows");
  if (fsig.fsUsb[1] & USB_MATH_OPERATORS)
     dprintf( "              %s", "Mathematical Operators");
  if (fsig.fsUsb[1] & USB_MISC_TECHNICAL)
     dprintf( "              %s", "Miscellaneous Technical");
  if (fsig.fsUsb[1] & USB_CONTROL_PICTURE)
     dprintf( "              %s", "Control Pictures");
  if (fsig.fsUsb[1] & USB_OPT_CHAR_RECOGNITION)
     dprintf( "              %s", "Optical Character Recognition");
  if (fsig.fsUsb[1] & USB_ENCLOSED_ALPHANUMERIC)
     dprintf( "              %s", "Enclosed Alphanumerics");
  if (fsig.fsUsb[1] & USB_BOX_DRAWING)
     dprintf( "              %s", "Box Drawing");
  if (fsig.fsUsb[1] & USB_BLOCK_ELEMENTS)
     dprintf( "              %s", "Block Elements");
  if (fsig.fsUsb[1] & USB_GEOMETRIC_SHAPE)
     dprintf( "              %s", "Geometric Shape");
  if (fsig.fsUsb[1] & USB_MISC_SYMBOLS)
     dprintf( "              %s", "Geometric Shapes");
  if (fsig.fsUsb[1] & USB_DINGBATS)
     dprintf( "              %s", "Dingbats");
  if (fsig.fsUsb[1] & USB_CJK_SYM_PUNCTUATION)
     dprintf( "              %s", "CJK Symbols and Punctuation");
  if (fsig.fsUsb[1] & USB_HIRAGANA)
     dprintf( "              %s", "Hiragana");
  if (fsig.fsUsb[1] & USB_KATAKANA)
     dprintf( "              %s", "Katakana");
  if (fsig.fsUsb[1] & USB_BOPOMOFO)
     dprintf( "              %s", "Bopomofo");
  if (fsig.fsUsb[1] & USB_HANGUL_COMP_JAMO)
     dprintf( "              %s", "Hangul Compatibility Jamo");
  if (fsig.fsUsb[1] & USB_CJK_MISCELLANEOUS)
     dprintf( "              %s", "CJK Miscellaneous");
  if (fsig.fsUsb[1] & USB_EN_CJK_LETTER_MONTH)
     dprintf( "              %s", "Enclosed CJK letters And Months");
  if (fsig.fsUsb[1] & USB_CJK_COMPATIBILITY)
     dprintf( "              %s", "CJK Compatibility");
  if (fsig.fsUsb[1] & USB_HANGUL)
     dprintf( "              %s", "Hangul");

  if (fsig.fsUsb[1] & USB_CJK_UNIFY_IDEOGRAPH)
     dprintf( "              %s", "CJK Unified Ideographs");
  if (fsig.fsUsb[1] & USB_PRIVATE_USE_AREA)
     dprintf( "              %s", "Private Use Area");
  if (fsig.fsUsb[1] & USB_CJK_COMP_IDEOGRAPH)
     dprintf( "              %s", "CJK Compatibility Ideographs");
  if (fsig.fsUsb[1] & USB_ALPHA_PRES_FORMS)
     dprintf( "              %s", "Alphabetic Presentation Forms");
  if (fsig.fsUsb[1] & USB_ARABIC_PRES_FORMA)
     dprintf( "              %s", "Arabic Presentation Forms-A");

  dprintf( "  ");

// fsUsb[2] field
  if ( fsig.fsUsb[2] != 0 )
     dprintf(" fsUsb[2]:");
  if (fsig.fsUsb[2] & USB_COMB_HALF_MARK)
     dprintf( "              %s", "Combining Half Marks");
  if (fsig.fsUsb[2] & USB_CJK_COMP_FORMS)
     dprintf( "              %s", "CJK Compatibility Forms");
  if (fsig.fsUsb[2] & USB_SMALL_FORM_VARIANTS)
     dprintf( "              %s", "Small Form Variants");
  if (fsig.fsUsb[2] & USB_ARABIC_PRES_FORMB)
     dprintf( "              %s", "Arabic Presentation Forms-B");
  if (fsig.fsUsb[2] & USB_HALF_FULLWIDTH_FORM)
     dprintf( "              %s", "Halfwidth And Fullwidth Forms");
  if (fsig.fsUsb[2] & USB_SPECIALS)
     dprintf( "              %s", "Specials");


  dUpdateNow( TRUE );

Exit:
  SelectObject( hdc, hFontOld );
  DeleteObject( hFont );

  DeleteTestIC( hdc );
 }


typedef struct {
    char *Description;
    DWORD Flag;
} FLI_STRINGS;

FLI_STRINGS Test[] =
{
  {"GCP_DBCS", GCP_DBCS},
  {"GCP_DIACRITIC", GCP_DIACRITIC},
  {"GCP_GLYPHSHAPE", GCP_GLYPHSHAPE},
  {"GCP_KASIDHA", GCP_KASHIDA},
  {"GCP_LIGATE", GCP_LIGATE},
  {"GCP_USEKERNING", GCP_USEKERNING},
  {"GCP_REORDER", GCP_REORDER},
  {"FLI_GLYPHS", FLI_GLYPHS}
};



void ShowFontLanguageInfo(HWND hwnd)
 {
  HDC    hdc;
  HFONT  hFont, hFontOld;
  static FONTSIGNATURE fsig;
  int i;
  DWORD dwFLI;

  hdc = CreateTestIC();

  if (!isCharCodingUnicode)
    hFont    = CreateFontIndirectWrapperA( &elfdvA );
  else
    hFont    = CreateFontIndirectWrapperW( &elfdvW );
  hFontOld = SelectObject( hdc, hFont );



  if((dwFLI = GetFontLanguageInfo( hdc )) ==  GCP_ERROR)
  {
   dprintf( "  Error getting FontLanguageInfo" );
   goto Exit;
  }

  dUpdateNow( FALSE );

  dprintf("GetFontLanguageInfo rc = 0x%x", dwFLI);

  for( i = 0; i < sizeof(Test) / sizeof(FLI_STRINGS); i++)
  {
      if( dwFLI & Test[i].Flag )
      {
          dprintf( Test[i].Description );
      }
  }

  dprintf( "  " );
  dUpdateNow( TRUE );


Exit:
  SelectObject( hdc, hFontOld );
  DeleteObject( hFont );

  DeleteTestIC( hdc );
 }





//*****************************************************************************
//******************   S H O W   T E X T   M E T R I C S   ********************
//*****************************************************************************

void ShowTextMetrics( HWND hwnd )
 {
  HDC    hdc;
  HFONT  hFont, hFontOld;
  static TEXTMETRIC tm;
  static TEXTMETRICW tmW;
  BOOL isOK;
  BYTE   bFamilyInfo;

  hdc = CreateTestIC();

  if (!isCharCodingUnicode)
      hFont    = CreateFontIndirectWrapperA( &elfdvA );
  else
      hFont    = CreateFontIndirectWrapperW( &elfdvW );
  hFontOld = SelectObject( hdc, hFont );

  SetTextAlign( hdc, wTextAlign );

  if (!isCharCodingUnicode)
	isOK = GetTextMetricsA( hdc, &tm );
  else
    isOK = GetTextMetricsW( hdc, &tmW );

  if(!isOK)
   {
    dprintf( "  Error getting text metrics" );
    goto Exit;
   }

  dUpdateNow( FALSE );

  if (!isCharCodingUnicode)
  {
	  dprintf( "Text Metrics" );
	  dprintf( "  tmHeight           = %d", tm.tmHeight           );
	  dprintf( "  tmAscent           = %d", tm.tmAscent           );
	  dprintf( "  tmDescent          = %d", tm.tmDescent          );
	  dprintf( "  tmInternalLeading  = %d", tm.tmInternalLeading  );
	  dprintf( "  tmExternalLeading  = %d", tm.tmExternalLeading  );
	  dprintf( "  tmAveCharWidth     = %d", tm.tmAveCharWidth     );
	  dprintf( "  tmMaxCharWidth     = %d", tm.tmMaxCharWidth     );
	  dprintf( "  tmWeight           = %d", tm.tmWeight           );
	  dprintf( "  tmItalic           = %d", tm.tmItalic           );
	  dprintf( "  tmUnderlined       = %d", tm.tmUnderlined       );
	  dprintf( "  tmStruckOut        = %d", tm.tmStruckOut        );
	  dprintf( "  tmFirstChar        = %d", tm.tmFirstChar        );
	  dprintf( "  tmLastChar         = %d", tm.tmLastChar         );
	  dprintf( "  tmDefaultChar      = %d", tm.tmDefaultChar      );
	  dprintf( "  tmBreakChar        = %d", tm.tmBreakChar        );
	  dprintf( "  tmPitchAndFamily   = 0x%.2X", tm.tmPitchAndFamily  );
	  dprintf( "  tmCharSet          = %d", tm.tmCharSet          );
	  dprintf( "  tmOverhang         = %d", tm.tmOverhang         );
	  dprintf( "  tmDigitizedAspectX = %d", tm.tmDigitizedAspectX );
	  dprintf( "  tmDigitizedAspectY = %d", tm.tmDigitizedAspectY );

	  dprintf( "  " );
	  dprintf( "  Flags set for Pitch and Family:");

	  if (tm.tmPitchAndFamily & TMPF_FIXED_PITCH)
		  dprintf("        TMPF_FIXED_PITCH (meaning variable)");

	  if (tm.tmPitchAndFamily & TMPF_VECTOR)
		  dprintf("        TMPF_VECTOR");

	  if (tm.tmPitchAndFamily & TMPF_DEVICE)
		  dprintf("        TMPF_DEVICE");

	  if (tm.tmPitchAndFamily & TMPF_TRUETYPE)
		  dprintf("        TMPF_TRUETYPE");


	  bFamilyInfo = tm.tmPitchAndFamily & 0xF0;

	  switch(bFamilyInfo)
	  {
		case FF_ROMAN :
			dprintf("        FF_ROMAN");
			break;

		case FF_SWISS :
			dprintf("        FF_SWISS");
			break;

		case FF_MODERN :
			dprintf("        FF_MODERN");
			break;

		case FF_SCRIPT :
			dprintf("        FF_SCRIPT");
			break;

		case FF_DECORATIVE :
			dprintf("        FF_DECORATIVE");
			break;

		default :
			dprintf("        FF_UNKNOWN");
	  }
  }
  else
  {
	  dprintf( "Text Metrics" );
	  dprintf( "  tmHeight           = %d", tmW.tmHeight           );
	  dprintf( "  tmAscent           = %d", tmW.tmAscent           );
	  dprintf( "  tmDescent          = %d", tmW.tmDescent          );
	  dprintf( "  tmInternalLeading  = %d", tmW.tmInternalLeading  );
	  dprintf( "  tmExternalLeading  = %d", tmW.tmExternalLeading  );
	  dprintf( "  tmAveCharWidth     = %d", tmW.tmAveCharWidth     );
	  dprintf( "  tmMaxCharWidth     = %d", tmW.tmMaxCharWidth     );
	  dprintf( "  tmWeight           = %d", tmW.tmWeight           );
	  dprintf( "  tmItalic           = %d", tmW.tmItalic           );
	  dprintf( "  tmUnderlined       = %d", tmW.tmUnderlined       );
	  dprintf( "  tmStruckOut        = %d", tmW.tmStruckOut        );
	  dprintf( "  tmFirstChar        = %d", tmW.tmFirstChar        );
	  dprintf( "  tmLastChar         = %d", tmW.tmLastChar         );
	  dprintf( "  tmDefaultChar      = %d", tmW.tmDefaultChar      );
	  dprintf( "  tmBreakChar        = %d", tmW.tmBreakChar        );
	  dprintf( "  tmPitchAndFamily   = 0x%.2X", tmW.tmPitchAndFamily  );
	  dprintf( "  tmCharSet          = %d", tmW.tmCharSet          );
	  dprintf( "  tmOverhang         = %d", tmW.tmOverhang         );
	  dprintf( "  tmDigitizedAspectX = %d", tmW.tmDigitizedAspectX );
	  dprintf( "  tmDigitizedAspectY = %d", tmW.tmDigitizedAspectY );

	  dprintf( "  " );
	  dprintf( "  Flags set for Pitch and Family:");

	  if (tmW.tmPitchAndFamily & TMPF_FIXED_PITCH)
		  dprintf("        TMPF_FIXED_PITCH (meaning variable)");

	  if (tmW.tmPitchAndFamily & TMPF_VECTOR)
		  dprintf("        TMPF_VECTOR");

	  if (tmW.tmPitchAndFamily & TMPF_DEVICE)
		  dprintf("        TMPF_DEVICE");

	  if (tmW.tmPitchAndFamily & TMPF_TRUETYPE)
		  dprintf("        TMPF_TRUETYPE");


	  bFamilyInfo = tmW.tmPitchAndFamily & 0xF0;

	  switch(bFamilyInfo)
	  {
		case FF_ROMAN :
			dprintf("        FF_ROMAN");
			break;

		case FF_SWISS :
			dprintf("        FF_SWISS");
			break;

		case FF_MODERN :
			dprintf("        FF_MODERN");
			break;

		case FF_SCRIPT :
			dprintf("        FF_SCRIPT");
			break;

		case FF_DECORATIVE :
			dprintf("        FF_DECORATIVE");
			break;

		default :
			dprintf("        FF_UNKNOWN");
	  }
  }

  dUpdateNow( TRUE );

Exit:
  SelectObject( hdc, hFontOld );
  DeleteObject( hFont );

  DeleteTestIC( hdc );
 }


//*****************************************************************************
//******************   S H O W   CHAR    WIDTH   INFO      ********************
//*****************************************************************************

#ifdef  USERGETCHARWIDTH
void  ShowCharWidthInfo( HANDLE  hwnd )
{
   HDC    hdc;
   HFONT  hFont, hFontOld;
   CHWIDTHINFO  ChWidthInfo;

   hdc = CreateTestIC();

   hFont    = CreateFontIndirectWrapperA( &elfdvA );
   hFontOld = SelectObject( hdc, hFont );


   dUpdateNow( FALSE );

   if ( GetCharWidthInfo(hdc, &ChWidthInfo) )
   {
      dprintf( " Calling  GetCharWidthInfo ");
      dprintf( " lMaxNegA:     = %ld", ChWidthInfo.lMaxNegA );
      dprintf( " lMaxNegC:     = %ld", ChWidthInfo.lMaxNegC );
      dprintf( " lMinWidthD:   = %ld", ChWidthInfo.lMinWidthD );
      dprintf( "  ");
   }
   else {
      dprintf( "Error getting CharWidthInfo");
      dprintf( "  ");
   }

   dUpdateNow( TRUE );

   SelectObject( hdc, hFontOld );
   DeleteObject( hFont );

   DeleteTestIC( hdc );
}
#endif   //USERGETCHARWIDTH


//*****************************************************************************
//*********************   S H O W   GETKERNINGPAIRS   *************************
//*****************************************************************************

void GetKerningPairsDlgProc( HWND hwnd )
{
   HDC    hdc;
   HFONT  hFont, hFontOld;
   DWORD  nNumKernPairs, dwRet, i;
   LPKERNINGPAIR  lpKerningPairs;

   hdc = CreateTestIC();
   hFont = CreateFontIndirectWrapperA( &elfdvA );
   hFontOld = SelectObject( hdc, hFont );

   nNumKernPairs = GetKerningPairs(hdc, 0, NULL);

   dUpdateNow( FALSE );

   dprintf( "");
   dprintf( " GetKerningPairs:" );
   dprintf( "   total number of kerning pairs = %ld", nNumKernPairs);

   if (nNumKernPairs)
   {
     lpKerningPairs = (LPKERNINGPAIR) malloc(sizeof(KERNINGPAIR) * nNumKernPairs);
     dwRet = GetKerningPairs(hdc, nNumKernPairs, lpKerningPairs);

     dprintf( "  First     Second     Amount");
     dprintf( " =======   ========   ========");

     for(i=0; i<nNumKernPairs; i++)
     {
       dprintf( "  %c=%x       %c=%x       %d",
                 lpKerningPairs[i].wFirst,
                 lpKerningPairs[i].wFirst,
                 lpKerningPairs[i].wSecond,
                 lpKerningPairs[i].wSecond,
                 lpKerningPairs[i].iKernAmount);
     }
     free(lpKerningPairs);
   }

   dUpdateNow( TRUE );

   SelectObject( hdc, hFontOld );
   DeleteObject( hFont );

   DeleteTestIC( hdc );
}

void FlushFontCache(HDC    hdc)
{
    int i;
   HFONT  hFont, hFont1, hFontOld;
   int   oldHeight;

   if (!isCharCodingUnicode)
      hFont = CreateFontIndirectWrapperA( &elfdvA );
   else
      hFont = CreateFontIndirectWrapperW( &elfdvW );

   hFontOld = SelectObject( hdc, hFont );

   if (!isCharCodingUnicode)
   {
       oldHeight = elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight;
       elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight = -26;
       for (i = 0; i < 16; i++)
       {
            hFont = CreateFontIndirectWrapperA( &elfdvA );
            hFont1 = SelectObject( hdc, hFont );
            DeleteObject(hFont1);
            TextOutA(hdc,0,100,"0",1);
            elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight --;
       }
       elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight = oldHeight;
   }
   else
   {
       oldHeight = elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight;
       elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight = -26;
       for (i = 0; i < 16; i++)
       {
            hFont = CreateFontIndirectWrapperW( &elfdvW );
            hFont1 = SelectObject( hdc, hFont );
            DeleteObject(hFont1);
            TextOutW(hdc,0,100,L"0",1);
            elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight --;
       }
       elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight = oldHeight;
   }

   hFont = SelectObject( hdc, hFontOld );
   DeleteObject(hFont);
}

//*****************************************************************************
//****************    CharWidthTestForAntiAliasing     ************************
//*****************************************************************************

void CharWidthTestForAntiAliasing( HWND hwnd, LOGFONTA* lf )
{
    HDC    hdc, hdcAntiAliased;
    HFONT  hFont, hFontOld;
    HFONT  hFontAntiAliased, hFontOldAntiAliased;
    LOGFONTA lfAntiAliased, lfNormal;
    UINT   iSize, iRun, wUnicodePoint;
    INT    iCharWidthNormal, iCharWidthAntiAlias;
    ABC    abcCharWidthNormal, abcCharWidthAntiAlias;
    LPGLYPHSET lpgsFont = NULL;
    BOOL   fDiff = FALSE;
    INT    iPointSize;
#ifdef GI_API


    // vary the font point sizes
    for (iPointSize = 4; iPointSize <= 20; iPointSize++)
    {    
        dprintf(" Testing charwidths for font - %s (Size: %d)", lf->lfFaceName, iPointSize);

        // prepare logfont for a non-antialiased font.
        hdc = CreateTestIC();
        memcpy(&lfNormal, lf, sizeof(LOGFONTA));
        lfNormal.lfQuality = NONANTIALIASED_QUALITY;
        lfNormal.lfHeight = -MulDiv(iPointSize, GetDeviceCaps(hdc, LOGPIXELSY), 72);

        // create dc's.       
        hFont = CreateFontIndirectA(&lfNormal);
        hFontOld = SelectObject( hdc, hFont );

        // prepare logfont for an antialiased font.
        hdcAntiAliased = CreateTestIC();
        memcpy(&lfAntiAliased, lf, sizeof(LOGFONTA));
        lfAntiAliased.lfQuality = CLEARTYPE_QUALITY;
        lfAntiAliased.lfHeight = -MulDiv(iPointSize, GetDeviceCaps(hdcAntiAliased, LOGPIXELSY), 72);

        hdcAntiAliased = CreateTestIC();
        hFontAntiAliased = CreateFontIndirectA(&lfAntiAliased);
        hFontOldAntiAliased = SelectObject( hdcAntiAliased, hFontAntiAliased );


        // Get the size of the the GLYPHSET first.
        if (iSize = GetFontUnicodeRanges(hdc, NULL))
        {
            if (lpgsFont = GlobalAlloc(GPTR, iSize))
            {           
                if (GetFontUnicodeRanges(hdc, (LPGLYPHSET) lpgsFont))
                {               
                    for (iRun = 0; iRun < lpgsFont->cRanges; iRun++)
                    {
                        for (wUnicodePoint = lpgsFont->ranges[iRun].wcLow;
                             wUnicodePoint < lpgsFont->ranges[iRun].wcLow + (UINT) lpgsFont->ranges[iRun].cGlyphs;
                             wUnicodePoint ++)
                        {
                            // get char widths for two modes.
                            GetCharWidth32W(hdc, wUnicodePoint, wUnicodePoint, &iCharWidthNormal);
                            GetCharWidth32W(hdcAntiAliased, wUnicodePoint, wUnicodePoint, &iCharWidthAntiAlias);
                                                
                            // dprintf(" Char %x Widths: %d %d ", wUnicodePoint, iCharWidthNormal, iCharWidthAntiAlias);
                            if (iCharWidthNormal != iCharWidthAntiAlias)
                            {
                                fDiff = TRUE;
                                dprintf(" Mismatching widths: Char %x Widths - %d : %d ", wUnicodePoint, iCharWidthNormal, iCharWidthAntiAlias);
                            }         

                            // get char abc widths for two modes.
                            if (GetCharABCWidthsW(hdc, wUnicodePoint, wUnicodePoint, &abcCharWidthNormal))
                            {
                                GetCharABCWidthsW(hdcAntiAliased, wUnicodePoint, wUnicodePoint, &abcCharWidthAntiAlias);

                                iCharWidthNormal = abcCharWidthNormal.abcA + abcCharWidthNormal.abcB + abcCharWidthNormal.abcC;
                                iCharWidthAntiAlias = abcCharWidthAntiAlias.abcA + abcCharWidthAntiAlias.abcB + abcCharWidthAntiAlias.abcC;

                                if (iCharWidthNormal != iCharWidthAntiAlias)
                                {
                                    fDiff = TRUE;
                                    dprintf(" Mismatching widths: Char %x Widths - %d : %d ", wUnicodePoint, iCharWidthNormal, iCharWidthAntiAlias);

                                    //dprintf(" Mismatching widths: Char %x ABC Widths - (%d %d %d) (%d %d %d)", wUnicodePoint, 
                                    //     abcCharWidthNormal.abcA, abcCharWidthNormal.abcB,abcCharWidthNormal.abcC,
                                    //     abcCharWidthAntiAlias.abcA, abcCharWidthAntiAlias.abcB, abcCharWidthAntiAlias.abcC);
                                }
                            }      
                        }
                    }
               
                    if (!fDiff)
                        dprintf(" No char width differences found! ");
                
                }

                GlobalFree(lpgsFont);
            }
        }
    }

        
    // cleanup dc's
    SelectObject( hdc, hFontOld );
    DeleteObject( hFont );  
    DeleteTestIC( hdc );

    SelectObject( hdcAntiAliased, hFontOldAntiAliased );
    DeleteObject( hFontAntiAliased );  
    DeleteTestIC( hdcAntiAliased );

    return;
#endif

}


//*****************************************************************************
//******************    EnumFontFamProcExCharWidth    *************************
//*****************************************************************************

int CALLBACK EnumFontFamProcExCharWidth(ENUMLOGFONTEX *lpelfe, NEWTEXTMETRICEX *lpntme,  
                               int FontType, LPARAM lParam)
{
HWND hwnd = (HWND) lParam;


    CharWidthTestForAntiAliasing(hwnd, &(lpelfe->elfLogFont));

    // continue enumeration
    return TRUE;
}


//*****************************************************************************
//****************    CharWidthTestAllForAntiAliasing    **********************
//*****************************************************************************

void CharWidthTestAllForAntiAliasing( HWND hwnd )
{
LOGFONT lf;
HDC     hdc;


    hdc = CreateTestIC();

    lf.lfCharSet = ANSI_CHARSET;
    lstrcpy(lf.lfFaceName, TEXT(""));
    lf.lfPitchAndFamily = 0;

    EnumFontFamiliesEx(hdc, &lf, (FONTENUMPROC) EnumFontFamProcExCharWidth, (LPARAM) hwnd, 0);

    DeleteTestIC( hdc );
}



#ifdef GI_API




void TextOutPerformanceInternal( HWND hwnd, BYTE lfQuality )
{
   HDC    hdc;
   HFONT  hFontOld;
   DWORD  i, j;
   int   oldHeight;
  _int64 liStart;
  _int64 liTotal, liBigTotal;
  _int64 liFreq;
  _int64 liNow;
  ULONG  liDelta;
  BYTE   jOldQuality;
  char szTestStringA[63] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  WCHAR szTestStringW[63] = L"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

#define TestSizes   20
#define MinEmHeight 8
#define LoopCount   20



  HFONT  ahFont[TestSizes];

   hdc = CreateTestIC();
   if (!isCharCodingUnicode)
   {
     oldHeight = elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight;
     elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight = -9;

     jOldQuality = elfdvA.elfEnumLogfontEx.elfLogFont.lfQuality;
     elfdvA.elfEnumLogfontEx.elfLogFont.lfQuality = lfQuality;
   }
   else
   {
     oldHeight = elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight;
     elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight = -9;

     jOldQuality = elfdvW.elfEnumLogfontEx.elfLogFont.lfQuality;
     elfdvW.elfEnumLogfontEx.elfLogFont.lfQuality = lfQuality;
   }

   for (i = 0; i < TestSizes; i++)
   {
       if (!isCharCodingUnicode)
       {
           ahFont[i] = CreateFontIndirectWrapperA( &elfdvA );
           elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight --;
       }
       else
       {
           ahFont[i] = CreateFontIndirectWrapperW( &elfdvW );
           elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight --;
       }
   }

   hFontOld = SelectObject( hdc, ahFont[0] );

   QueryPerformanceFrequency((LARGE_INTEGER *) &liFreq);
   dUpdateNow( FALSE );
   liBigTotal = 0;

   dprintf( "");

   for (j = 0; j < 5; j++)
   {
       FlushFontCache(hdc);
       if (!isCharCodingUnicode)
       {
           QueryPerformanceCounter((LARGE_INTEGER *) &liStart);
           for (i = 0; i < TestSizes; i++)
           {
                SelectObject( hdc, ahFont[i] );


                TextOutA(hdc,0,100,szTestStringA,62);

           }
           QueryPerformanceCounter((LARGE_INTEGER *) &liNow);
       }
       else
       {
           QueryPerformanceCounter((LARGE_INTEGER *) &liStart);
           for (i = 0; i < TestSizes; i++)
           {
                SelectObject( hdc, ahFont[i] );


                TextOutW(hdc,0,100,szTestStringW,62);

           }
           QueryPerformanceCounter((LARGE_INTEGER *) &liNow);
       }
       liTotal = liNow - liStart;
       liBigTotal += liTotal;
       liDelta = (ULONG) ((liTotal * 1000) / liFreq);
       dprintf( " Time[%d] : %d millisec",j,liDelta );
   }


   if (!isCharCodingUnicode)
   {
       elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight = oldHeight;
       elfdvA.elfEnumLogfontEx.elfLogFont.lfQuality = jOldQuality;
   }
   else
   {
       elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight = oldHeight;
       elfdvW.elfEnumLogfontEx.elfLogFont.lfQuality = jOldQuality;
   }

    liDelta = (ULONG) ((liBigTotal * 1000) / liFreq);
   dprintf( " TextOutPerformance :" );
   dprintf( " TotalTime : %d millisec",liDelta );

   dUpdateNow( TRUE );

   SelectObject( hdc, hFontOld );

   for (i = 0; i < TestSizes; i++)
   {
       DeleteObject(ahFont[i]);
   }

   DeleteTestIC( hdc );
}



void TextOutPerformance( HWND hwnd)
{

    DWORD dwOldBatchLimit = GdiSetBatchLimit(1); // zero means default ie 20

    dprintf("  Monochrome Text:");
    TextOutPerformanceInternal(hwnd, NONANTIALIASED_QUALITY);

    dprintf("  ");
    dprintf("  AA/CT Text:");
    TextOutPerformanceInternal(hwnd, ANTIALIASED_QUALITY);

    GdiSetBatchLimit(dwOldBatchLimit); // zero means default ie 20


#if 0

// blend macros for cleartype

#define DIVIDE(A,B) ( ((A)+(B)/2) / (B) )

// blend macros for cleartype
// this is k/6, k = 0,1,...,6 in 12.20 format
// Why 12.20 ? well, we are tring to store 6*256 = 1536 = 600h.
// (the largest possible result of multiplying k*dB),
// this fits in eleven bits, so just to be safe we allow 12 bits for
// integer part and 20 bits for the fractional part.
// By using this we avoid doing divides by 6 in trasparent cases and
// in computation of ct lookup table

LONG alAlpha[7] =
{
0,
DIVIDE(1L << 20, 6),
DIVIDE(2L << 20, 6),
DIVIDE(3L << 20, 6),
DIVIDE(4L << 20, 6),
DIVIDE(5L << 20, 6),
DIVIDE(6L << 20, 6),
};

#define HALF20 (1L << 19)
// #define ROUND20(X) (((X) + HALF20) >> 20)
#define ROUND20(X) ((X) >> 20)
#define BLEND(k,B,dB) ((B) + ROUND20(alAlpha[k] * (dB)))
#define BLENDCT(k,F,B,dB) (ULONG)(((k) == 0) ? (B) : (((k) == 6) ? (F) : BLEND(k,B,dB)))

#define BLENDOLD(k,F,B) (ULONG)DIVIDE((k) * (F) + (6 - (k)) * (B), 6)


    LONG b,f;
    ULONG fnew, fold;
    BYTE k;

    ULONG ulTotal = 0, ulError = 0, ulPercent;

    dprintf("begin  !!!");
    for (f = 0; f < 256; f++)
    {
        for (b = 0; b < 256; b++)
        {
            for (k = 0; k <= 6; k++)
            {

                fold = BLENDOLD(k,f,b);
                fnew = BLEND(k, b, (f-b));

                if (fold > 256)
                    dprintf("fold > 256, k = %d, f = %d, b = %d, fold = %ld", k, f, b, fold);
                if (fnew > 256)
                    dprintf("fnew > 256, k = %d, f = %d, b = %d, fnew = %ld", k, f, b, fnew);

                if (fnew != fold)
                {
                    LONG diff = (LONG)fold - (LONG)fnew;
                    if (diff < 0)
                        diff = -diff;
                    if (diff > 1)
                    {
                        dprintf("fnew != fold, k: %d, f: %d, b: %d, fnew: 0x%lx, fold: 0x%lx, diff: 0x%lx", k, f, b, fnew, fold, diff);
                    }
                    ulError++;
                }
                ulTotal++;
            }
        }
    }
    ulPercent = DIVIDE(ulError * 100 , ulTotal);

    dprintf("done !!! ulTotal = %ld, ulError = %ld, wrong in %ld percent cases", ulTotal, ulError, ulPercent);

#endif
}



  char szTestStringA[63] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  WCHAR szTestStringW[63] = L"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

_int64 ClearTypePerformanceLoopA(HWND hwnd , HDC hdc)
{
  DWORD  i, j;
  int y;
  TEXTMETRIC tm;
  _int64 liStart;
  _int64 liNow;
  _int64 liTotal = 0;
  HFONT  hFont, hOldFont;
   for (i = 0; i < TestSizes; i++)
   {
        hFont = CreateFontIndirectWrapperA( &elfdvA );
        hOldFont = SelectObject( hdc, hFont );
        GetTextMetrics( hdc, &tm );

        y = 50;
        TextOutA(hdc,5,0,szTestStringA,62);
        DrawDCAxis( hwnd, hdc, FALSE);
        QueryPerformanceCounter((LARGE_INTEGER *) &liStart);
        for (j = 0; j < LoopCount; j++)
        {
            TextOutA(hdc,5, y,szTestStringA,62);
            y += tm.tmHeight;
        }

        QueryPerformanceCounter((LARGE_INTEGER *) &liNow);
        liTotal += (liNow - liStart);

        elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight --;
        SelectObject( hdc, hOldFont );
        DeleteObject(hFont);
   }
   return liTotal;
}

_int64 ClearTypePerformanceLoopW(HWND hwnd , HDC    hdc)
{
  DWORD  i, j;
  int y;
  TEXTMETRIC tm;
  _int64 liStart;
  _int64 liNow;
  _int64 liTotal = 0;
  HFONT  hFont, hOldFont;
   for (i = 0; i < TestSizes; i++)
   {
        hFont = CreateFontIndirectWrapperW( &elfdvW );
        hOldFont = SelectObject( hdc, hFont );
        GetTextMetrics( hdc, &tm );

        y = 50;
        TextOutW(hdc,5,0,szTestStringW,62);
        DrawDCAxis( hwnd, hdc, FALSE);
        QueryPerformanceCounter((LARGE_INTEGER *) &liStart);
        for (j = 0; j < LoopCount; j++)
        {
            TextOutW(hdc,5, y,szTestStringW,62);
            y += tm.tmHeight;
        }

        QueryPerformanceCounter((LARGE_INTEGER *) &liNow);
        liTotal += (liNow - liStart);

        elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight --;
        SelectObject( hdc, hOldFont );
        DeleteObject(hFont);
   }
   return liTotal;
}

void ClearTypePerformanceInternal( HWND hwnd, BYTE jQuality )
{
   HDC    hdc;
   int   oldHeight;
   BYTE  oldQuality;
  _int64 liTotal, liBigTotal;
  _int64 liFreq;
  ULONG  liDelta;
  BOOL       oldIsGradientBackground = isGradientBackground;


// hdc = CreateTestIC();
   hdc = GetDC(hwnd);


   if (!isCharCodingUnicode)
   {
     oldHeight = elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight;
     oldQuality = elfdvA.elfEnumLogfontEx.elfLogFont.lfQuality;
   }
   else
   {
     oldHeight = elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight;
     oldQuality = elfdvW.elfEnumLogfontEx.elfLogFont.lfQuality;
   }

   QueryPerformanceFrequency((LARGE_INTEGER *) &liFreq);
   dUpdateNow( FALSE );
   liBigTotal = 0;

   dprintf( "");

       if (!isCharCodingUnicode)
       {
           SetBkMode( hdc, OPAQUE );

           isGradientBackground = FALSE;

           elfdvA.elfEnumLogfontEx.elfLogFont.lfQuality =  jQuality;
           elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight = -MinEmHeight;

    