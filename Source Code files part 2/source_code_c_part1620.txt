                       MAKEWPARAM(cmd, 0), (LPARAM)0); \
                                }

#endif // __cplusplus

#else // !WIN32

// Some type definitions excluded from win31 sdk...
// Should these ever be defined for win31, GET RID OF THESE!
typedef float FLOAT;
typedef char TCHAR;

#define GET_WM_COMMAND_ID(wp, lp)       LOWORD(wp)
#define GET_WM_COMMAND_CMD(wp, lp)      HIWORD(lp)
#define GET_WM_COMMAND_HWND(wp, lp)     (HWND)LOWORD(lp)

#define GET_WINDOW_ID(hwnd)         (UINT)GetWindowWord(hwnd, GWW_ID)
#define GET_WINDOW_INSTANCE(hwnd)   (HINSTANCE)GetWindowWord(hwnd, \
                                        GWW_HINSTANCE)

#define LONG2POINT(l, pt)  ((pt).x = (int)LOWORD(l), (pt).y = (int)HIWORD(l))

#ifdef __cplusplus

#define NOTIFYPARENT(hwnd,code) { \
                                    UINT nID; \
                                    nID = GET_WINDOW_ID(hwnd); \
                                    (::SendMessage)(::GetParent(hwnd), \
                                        WM_COMMAND, nID, \
                                        MAKELPARAM(hwnd, code)); \
                                }

#define SENDCOMMAND(hwnd, cmd)  { \
                                    (::SendMessage)(hwnd,WM_COMMAND,cmd,0); \
                                }

#define POSTCOMMAND(hwnd, cmd)  { \
                                    (::PostMessage)(hwnd,WM_COMMAND,cmd,0); \
                                }

#else // !__cplusplus

#define NOTIFYPARENT(hwnd,code) { \
                                    UINT nID; \
                                    nID = GET_WINDOW_ID(hwnd); \
                                    SendMessage(GetParent(hwnd), WM_COMMAND, \
                                        nID, MAKELPARAM(hwnd, code)); \
                                }

#define SENDCOMMAND(hwnd, cmd)  { \
                                    SendMessage(hwnd, WM_COMMAND, cmd, 0); \
                                }

#define POSTCOMMAND(hwnd, cmd)  { \
                                    PostMessage(hwnd, WM_COMMAND, cmd, 0); \
                                }

#endif // __cplusplus

#endif // WIN32

#endif // _PORTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\remote.h ===
#ifndef _remote_h
#define _remote_h

//===============================================================================
// Class: CEnvCache
//
// This class caches the system environment variables for remote systems.  This
// cache is used to expand environment variables in the context of a remote system.
// 
// The values of the remote system environment variables are loaded from the
// remote system's registry.
//
//==============================================================================
class CEnvCache
{
public:
	
	CEnvCache();
	SCODE Lookup(LPCTSTR pszMachine, LPCTSTR pszName, CString& sResult);
	SCODE AddMachine(LPCTSTR pszMachine);


private:
	CMapStringToOb m_mapMachine;
	SCODE GetEnvironmentVars(LPCTSTR pszMachine, CMapStringToString* pmapVars);

};

SCODE RemoteExpandEnvStrings(LPCTSTR pszComputerName, CEnvCache& cache, CString& sValue);
SCODE MapPathToUNC(LPCTSTR pszMachineName, CString& sPath);




#endif //_remote_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\settings.cpp ===
//***********************************************************************
// settings.cpp
//
// This file contains the implementation of the "Settings" dialog class.
//
//
// Author: SEA
//
// History:
//      Febuary-1996     Larry A. French
//          Modified the code to fix various problems.  Regrettably, this
//          file still contains a fair amount of legacy code that I didn't
//          have time to fully rewrite.  Also, I did not have time to go 
//          though and fully comment the code.
//
//
// Copyright (C) 1995, 1996 Microsoft Corporation.  All rights reserved.
//
//************************************************************************



// settings.cpp : implementation file
//

#include "stdafx.h"
#include "eventrap.h"
#include "settings.h"
#include "globals.h"
#include "trapreg.h"

// This macro handles comparing bool values for the cases where TRUE can be and
// non-zero value.
#define BOOLS_ARE_DIFFERENT(b1, b2) ((b1 & !b2) || (!b1 & b2)) 


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

UINT _thrRun(CTrapSettingsDlg *trapDlg)
{
    return trapDlg->thrRun();
}

/////////////////////////////////////////////////////////////////////////////
// CTrapSettingsDlg dialog

UINT CTrapSettingsDlg::thrRun()
{
    HANDLE hEvents[2];
    DWORD retCode;
    CRegistryKey regkey;
    CRegistryValue regval;
    BOOL bThrottleIsTripped = FALSE;

    hEvents[0] = (HANDLE)m_evRegNotification;
    hEvents[1] = (HANDLE)m_evTermination;
    
    if (!g_reg.m_regkeySnmp.GetSubKey(SZ_REGKEY_PARAMETERS, regkey))
        return 0;

    do
    {
        m_evRegNotification.SetEvent();

        if (RegNotifyChangeKeyValue(
                regkey.m_hkeyOpen,
                TRUE,
                REG_NOTIFY_CHANGE_LAST_SET | REG_NOTIFY_CHANGE_NAME,
                (HANDLE)m_evRegNotification,
                TRUE) == ERROR_SUCCESS)
        {
            if (regkey.GetValue(SZ_REGKEY_PARAMS_THRESHOLD, regval) && 
                *(DWORD*)regval.m_pData == THROTTLE_TRIPPED)
                PostMessage(WM_UIREQUEST, UICMD_ENABLE_RESET, TRUE);
            else
                PostMessage(WM_UIREQUEST, UICMD_ENABLE_RESET, FALSE);
        }
    } while(WaitForMultipleObjects(2, hEvents, FALSE, INFINITE) == WAIT_OBJECT_0);

    regkey.Close();

    return 0;
}

CTrapSettingsDlg::CTrapSettingsDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CTrapSettingsDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CTrapSettingsDlg)
	m_bLimitMsgLength = FALSE;
	//}}AFX_DATA_INIT
}


#define I_MAX_LONG 0x7fffffffL
#define I_MIN_TRAPCOUNT 2
#define I_MAX_TRAPCOUNT 9999999

#define I_MIN_SECONDS   1
#define I_MAX_SECONDS   9999999

#define I_MIN_MESSAGE_LENGTH 400
#define I_MAX_MESSAGE_LENGTH 0x7fff




SCODE CTrapSettingsDlg::GetMessageLength(LONG* pnChars)
{
    CString sValue;

	CButton* pbtnLimit = (CButton*)GetDlgItem(IDC_LIMITMSGLNGTH);
    BOOL bLimitEnabled = (pbtnLimit->GetCheck() == 1) ? TRUE : FALSE;
        

    m_edtMessageLength.GetWindowText(sValue);
    SCODE sc;
    LONG nChars = _ttol(sValue);
    sc = AsciiToLong(sValue, &nChars);
    if (FAILED(sc))
    {
        // They shouldn't have garbage in this edit control even if
        // they haven't selected a message limit.  Let the user fix it.
        AfxMessageBox(IDS_ERR_SETTINGS_MESSAGELENGTH_NOT_INT);
        m_edtMessageLength.SetFocus();
        m_edtMessageLength.SetSel(0, -1);
        return E_FAIL;
    }


    if (bLimitEnabled)
    {
        if (nChars < I_MIN_MESSAGE_LENGTH || nChars > I_MAX_MESSAGE_LENGTH)
        {
            if (pbtnLimit->GetCheck() == 1)
            {
                CString sError;
                CString sRangeMessage;
                sError.LoadString(IDS_SETTINGS_MESSAGE_LENGTH_RANGE);
                GenerateRangeMessage(sRangeMessage, I_MIN_MESSAGE_LENGTH, I_MAX_MESSAGE_LENGTH);
                sError += sRangeMessage;
                AfxMessageBox(sError);
                sValue.Format(_T("%u"),nChars);
                m_edtMessageLength.SetWindowText(sValue);
                m_edtMessageLength.SetFocus();
                m_edtMessageLength.SetSel(0, -1);
                return E_FAIL;
            }
        }
    }
    *pnChars = nChars;
    return S_OK;
}

SCODE CTrapSettingsDlg::GetTrapsPerSecond(LONG* pnTraps, LONG* pnSeconds)
{
    CString sSeconds;
    CString sTraps;
    CString sError;
    CString sRangeMessage;
    LONG nTraps;
    LONG nSeconds;
    SCODE sc;

    // First make sure that the trap count and seconds fields don't have garbage in them.
    // If a non-integer value is specified, force the user to fix it regardless of whether
    // or not the throttle is enabled.
    m_edtTrapCount.GetWindowText(sTraps);
    sc = AsciiToLong(sTraps, &nTraps);
    if (FAILED(sc))
    {
        AfxMessageBox(IDS_ERR_SETTINGS_TRAPCOUNT_NOT_INT);
        m_edtTrapCount.SetFocus();
        m_edtTrapCount.SetSel(0, -1);
        return E_FAIL;
    }

    m_edtSeconds.GetWindowText(sSeconds);
    sc = AsciiToLong(sSeconds, &nSeconds);
    if (FAILED(sc))
    {
        AfxMessageBox(IDS_ERR_SETTINGS_TRAPSECONDS_NOT_INT);
        m_edtSeconds.SetFocus();
        m_edtSeconds.SetSel(0, -1);
        return E_FAIL;
    }

    BOOL bThrottleEnabled;
    if (GetCheckedRadioButton(IDC_RADIO_ENABLE, IDC_RADIO_DISABLE) == IDC_RADIO_ENABLE)
        bThrottleEnabled = TRUE;
    else
        bThrottleEnabled = FALSE;

    if (bThrottleEnabled)
    {
        if  (nTraps < I_MIN_TRAPCOUNT || nTraps > I_MAX_TRAPCOUNT)
        {
            sError.LoadString(IDS_ERR_SETTINGS_TRAPCOUNT_RANGE);
            GenerateRangeMessage(sRangeMessage, I_MIN_TRAPCOUNT, I_MAX_TRAPCOUNT);
            sError += sRangeMessage;
            AfxMessageBox(sError);
            sTraps.Format(_T("%u"), nTraps);
            m_edtTrapCount.SetWindowText(sTraps);
            m_edtTrapCount.SetFocus();
            m_edtTrapCount.SetSel(0, -1);
            return E_FAIL;
        }
    
        if (nSeconds < I_MIN_SECONDS || nSeconds > I_MAX_SECONDS)
        {
            sError.LoadString(IDS_SETTINGS_TRAPSECONDS_RANGE);
            GenerateRangeMessage(sRangeMessage, I_MIN_SECONDS, I_MAX_SECONDS);
            sError += sRangeMessage;
            AfxMessageBox(sError);
            sSeconds.Format(_T("%u"),nSeconds);
            m_edtSeconds.SetWindowText(sSeconds);
            m_edtSeconds.SetFocus();
            m_edtSeconds.SetSel(0, -1);
            return E_FAIL;
        }
    }
    

    *pnTraps = nTraps;
    *pnSeconds = nSeconds;

    return S_OK;
}

void CTrapSettingsDlg::TerminateBackgroundThread()
{
    if (m_pthRegNotification)
    {
	    m_evTermination.SetEvent();
        WaitForSingleObject(m_pthRegNotification->m_hThread, INFINITE);
    }
}

void CTrapSettingsDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTrapSettingsDlg)
	DDX_Control(pDX, IDC_STAT_TRAP_LENGTH, m_statTrapLength);
	DDX_Control(pDX, IDC_EDIT_MESSAGELENGTH, m_edtMessageLength);
	DDX_Control(pDX, IDC_EDIT_TRAP_SECONDS, m_edtSeconds);
	DDX_Control(pDX, IDC_EDIT_TRAP_COUNT, m_edtTrapCount);
	DDX_Control(pDX, IDC_MSGLENGTHSPN, m_spinMessageLength);
	DDX_Control(pDX, IDC_BUTTON_RESET, m_btnResetThrottle);
	DDX_Check(pDX, IDC_LIMITMSGLNGTH, m_bLimitMsgLength);
	//}}AFX_DATA_MAP


    CString sValue;
    if (pDX->m_bSaveAndValidate) {
        // Saving the value trapsize, seconds, and trapcount is handled by 
        // CTrapSettingsDlg::OnOK so that it can set the focus back to the
        // offending item if the value is out of range. If the data transfer
        // fails here, the focus is always set back to the dialog and not
        // the offending item (is there a way around this?)
    }
    else {

        m_spinMessageLength.SetRange(I_MIN_MESSAGE_LENGTH, I_MAX_MESSAGE_LENGTH);
        m_spinMessageLength.SetPos(g_reg.m_params.m_trapsize.m_dwMaxTrapSize);

        DecString(sValue, g_reg.m_params.m_throttle.m_nSeconds);
        m_edtSeconds.SetWindowText(sValue);

        DecString(sValue, g_reg.m_params.m_throttle.m_nTraps);
        m_edtTrapCount.SetWindowText(sValue);


    }            
}


BEGIN_MESSAGE_MAP(CTrapSettingsDlg, CDialog)
	//{{AFX_MSG_MAP(CTrapSettingsDlg)
	ON_BN_CLICKED(IDC_LIMITMSGLNGTH, OnLimitMessageLength)
	ON_BN_CLICKED(IDC_RADIO_DISABLE, OnRadioDisable)
	ON_BN_CLICKED(IDC_RADIO_ENABLE, OnRadioEable)
	ON_BN_CLICKED(IDC_BUTTON_RESET, OnButtonReset)
	ON_COMMAND(ID_HELP, OnHelp)
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	ON_WM_CLOSE()
    ON_MESSAGE(WM_UIREQUEST, OnUIRequest)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTrapSettingsDlg message handlers

LRESULT CTrapSettingsDlg::OnUIRequest(WPARAM cmd, LPARAM lParam)
{
    switch(cmd)
    {
    case UICMD_ENABLE_RESET:
        m_btnResetThrottle.EnableWindow((BOOL)lParam);
        break;
    default:
        break;
    }

    return (LRESULT)0;
}

void CTrapSettingsDlg::OnLimitMessageLength() 
{
	// The LimitMsgLength checkbox was clicked.
	// Enable/disable the edit control.

	// Get the controls.
    CButton* pbtnLimitBox = (CButton*) GetDlgItem(IDC_LIMITMSGLNGTH);
    CButton *pRadio1 = (CButton*)GetDlgItem(IDC_RADIO1);
    CButton *pRadio2 = (CButton*)GetDlgItem(IDC_RADIO2);
	
	// It's checked; enable
	if (pbtnLimitBox->GetCheck() == 1)
    {
        m_edtMessageLength.EnableWindow();
		pRadio1->EnableWindow();
		pRadio2->EnableWindow();
        GetDlgItem(IDC_STATIC_BYTES)->EnableWindow();
        m_statTrapLength.EnableWindow();
    }
	// Disable
	else
    {
        m_edtMessageLength.EnableWindow(FALSE);
		pRadio1->EnableWindow(FALSE);
		pRadio2->EnableWindow(FALSE);
        GetDlgItem(IDC_STATIC_BYTES)->EnableWindow(FALSE);
        m_statTrapLength.EnableWindow(FALSE);
    }
}


BOOL CTrapSettingsDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

    CButton *pRadio1 = (CButton*)GetDlgItem(IDC_RADIO1);
    CButton *pRadio2 = (CButton*)GetDlgItem(IDC_RADIO2);
	

    m_statTrapLength.EnableWindow(m_bLimitMsgLength);


    m_edtMessageLength.EnableWindow(m_bLimitMsgLength);
	if (m_bLimitMsgLength)
    {
		pRadio1->EnableWindow();
		pRadio2->EnableWindow();
        GetDlgItem(IDC_STATIC_BYTES)->EnableWindow();
    }
	// Disable
	else
    {
		pRadio1->EnableWindow(FALSE);
		pRadio2->EnableWindow(FALSE);
        GetDlgItem(IDC_STATIC_BYTES)->EnableWindow(FALSE);
    }



    if (m_bTrimMessagesFirst)
        CheckRadioButton(IDC_RADIO1, IDC_RADIO2, IDC_RADIO2);
    else
        CheckRadioButton(IDC_RADIO1, IDC_RADIO2, IDC_RADIO1);

    if (m_bThrottleEnabled) 
        CheckRadioButton(IDC_RADIO_ENABLE, IDC_RADIO_DISABLE, IDC_RADIO_ENABLE);
    else
        CheckRadioButton(IDC_RADIO_ENABLE, IDC_RADIO_DISABLE, IDC_RADIO_DISABLE);

    EnableThrottleWindows(m_bThrottleEnabled);

    m_pthRegNotification = AfxBeginThread((AFX_THREADPROC)_thrRun, this);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}



void CTrapSettingsDlg::OnOK() 
{

    LONG nchMessageLength;
    LONG nTraps;
    LONG nSeconds;
    SCODE sc = GetMessageLength(&nchMessageLength);
    if (FAILED(sc))
    {
        return;
    }

    sc = GetTrapsPerSecond(&nTraps, &nSeconds);
    if (FAILED(sc))
    {
        return;
    }


    // Pull various values off of the dialog and store them into member variables.
    // Note that there are other member variables that are set directly
    // as a response to user input.
    //===========================================================================
    m_bTrimMessagesFirst = (GetCheckedRadioButton(IDC_RADIO1, IDC_RADIO2) == IDC_RADIO2);
    m_bThrottleEnabled = (GetCheckedRadioButton(IDC_RADIO_ENABLE, IDC_RADIO_DISABLE) == IDC_RADIO_ENABLE);


    if (g_reg.m_params.m_trapsize.m_dwMaxTrapSize != (DWORD) nchMessageLength) {
        g_reg.SetDirty(TRUE);
        g_reg.m_params.m_trapsize.m_dwMaxTrapSize = nchMessageLength;
    }

    if(g_reg.m_params.m_throttle.m_nSeconds != nSeconds) {
        g_reg.SetDirty(TRUE);
        g_reg.m_params.m_throttle.m_nSeconds = nSeconds;
    }

    if (g_reg.m_params.m_throttle.m_nTraps != nTraps) {
        g_reg.SetDirty(TRUE);
        g_reg.m_params.m_throttle.m_nTraps = nTraps;
    }

    TerminateBackgroundThread();
	CDialog::OnOK();
}




BOOL CTrapSettingsDlg::EditSettings()
{
    m_bLimitMsgLength = g_reg.m_params.m_trapsize.m_bTrimFlag;
    m_bTrimMessagesFirst = g_reg.m_params.m_trapsize.m_bTrimMessages;
    m_bThrottleEnabled = g_reg.m_params.m_throttle.m_bIsEnabled;


    // Save the data.
    if (DoModal() == IDOK)
    {
        if (BOOLS_ARE_DIFFERENT(g_reg.m_params.m_trapsize.m_bTrimFlag, m_bLimitMsgLength)) {
            g_reg.m_params.m_trapsize.m_bTrimFlag = m_bLimitMsgLength;
            g_reg.SetDirty(TRUE);
        }

        if (BOOLS_ARE_DIFFERENT(g_reg.m_params.m_trapsize.m_bTrimMessages, m_bTrimMessagesFirst)) {
            g_reg.m_params.m_trapsize.m_bTrimMessages = m_bTrimMessagesFirst;
            g_reg.SetDirty(TRUE);
        }

        if (BOOLS_ARE_DIFFERENT(g_reg.m_params.m_throttle.m_bIsEnabled, m_bThrottleEnabled)) {
            g_reg.m_params.m_throttle.m_bIsEnabled = m_bThrottleEnabled;
            g_reg.SetDirty(TRUE);
        }
                
        return TRUE;
    }
    else {
        return FALSE;
    }

}




void CTrapSettingsDlg::OnRadioDisable() 
{
    EnableThrottleWindows(FALSE);
}

void CTrapSettingsDlg::OnRadioEable() 
{
    EnableThrottleWindows(TRUE);
}

void CTrapSettingsDlg::EnableThrottleWindows(BOOL bEnableThrottle)
{
    m_edtSeconds.EnableWindow(bEnableThrottle);
    GetDlgItem(IDC_STATIC_MSG)->EnableWindow(bEnableThrottle);
    GetDlgItem(IDC_STATIC_NTRAPS)->EnableWindow(bEnableThrottle);
    GetDlgItem(IDC_STATIC_INTERVAL)->EnableWindow(bEnableThrottle);
    m_edtTrapCount.EnableWindow(bEnableThrottle);
}


//****************************************************************
// CTrapSettingsDlg::OnButtonReset
//
// Reset the extension agent so that it starts sending traps again.
// The extension agent will stop sending traps if the throttle limit
// is exceeded (more than x number of traps per second are set).
//
// Parameters:
//      None.
//
// Returns.
//      Nothing.
//
//*****************************************************************
void CTrapSettingsDlg::OnButtonReset() 
{
    if (SUCCEEDED(g_reg.m_params.ResetExtensionAgent())) {
        m_btnResetThrottle.EnableWindow(FALSE);
    }
}

BOOL CTrapSettingsDlg::OnHelpInfo(HELPINFO *pHelpInfo) 
{
    if (pHelpInfo->iContextType == HELPINFO_WINDOW &&
        pHelpInfo->iCtrlId != IDC_STATIC_MSG &&
        pHelpInfo->iCtrlId != IDC_STATIC_BYTES)
	{
        ::WinHelp ((HWND)pHelpInfo->hItemHandle,
                   AfxGetApp()->m_pszHelpFilePath,
                   HELP_WM_HELP,
                   (ULONG_PTR)g_aHelpIDs_IDD_SETTINGSDLG);
	}
	
	return TRUE;
}

void CTrapSettingsDlg::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    if (this == pWnd)
		return;

    ::WinHelp (pWnd->m_hWnd,
		       AfxGetApp()->m_pszHelpFilePath,
		       HELP_CONTEXTMENU,
		       (ULONG_PTR)g_aHelpIDs_IDD_SETTINGSDLG);
}

void CTrapSettingsDlg::OnClose() 
{
    TerminateBackgroundThread();
	CDialog::OnClose();
}

void CTrapSettingsDlg::OnCancel() 
{
    TerminateBackgroundThread();
	CDialog::OnCancel();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\settings.h ===
// settings.h : header file
//

#ifndef SETTINGS_H
#define	SETTINGS_H

/////////////////////////////////////////////////////////////////////////////
// CTrapSettingsDlg dialog
class CTrapSettingsDlg;
class CEventArray;

// this message is posted by background threads to the UI thread, requesting
// changes in the UI. wParam identifies the UI command (from the #defines below),
// lParam identifies the actual parameters of the command.
#define WM_UIREQUEST (WM_USER + 13)

// the 'enable' state of the 'Reset' button should be changed to the state indicated
// in lParam.
#define UICMD_ENABLE_RESET 1

UINT _thrRun(CTrapSettingsDlg *trapDlg);

class CTrapSettingsDlg : public CDialog
{
// Construction
public:
    UINT thrRun();

	CTrapSettingsDlg(CWnd* pParent = NULL);   // standard constructor
    BOOL EditSettings();

// Dialog Data
	//{{AFX_DATA(CTrapSettingsDlg)
	enum { IDD = IDD_SETTINGSDLG };
	CStatic	m_statTrapLength;
	CEdit	m_edtMessageLength;
	CEdit	m_edtSeconds;
	CEdit	m_edtTrapCount;
	CSpinButtonCtrl	m_spinMessageLength;
	CButton	m_btnResetThrottle;
	BOOL	m_bLimitMsgLength;
	//}}AFX_DATA

    BOOL m_bTrimMessagesFirst;
    BOOL m_bThrottleEnabled;

    CWinThread*     m_pthRegNotification;
    CEvent          m_evTermination;
    CEvent          m_evRegNotification;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTrapSettingsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CTrapSettingsDlg)
	afx_msg void OnLimitMessageLength();
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnRadioDisable();
	afx_msg void OnRadioEable();
	afx_msg void OnButtonReset();
	afx_msg BOOL OnHelpInfo(HELPINFO*);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnClose();
    afx_msg LRESULT OnUIRequest(WPARAM cmd, LPARAM lParam);
	virtual void OnCancel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    void EnableThrottleWindows(BOOL bEnableThrottle);
    SCODE GetTrapsPerSecond(LONG* pnTraps, LONG* pnSeconds);
    SCODE GetMessageLength(LONG* pnChars);
    void TerminateBackgroundThread();
};

#endif //SETTINGS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\regkey.h ===
//****************************************************************************
//
//  Copyright (c) 1995,  Microsoft Corp.
//
//  File:  REGKEY.H
//
//  Definitions for registry management classes
//
//  History:
//      Scott V. Walker, SEA  10/5/94
//
//****************************************************************************
#ifndef _REGKEY_H_
#define _REGKEY_H_

#include <tchar.h>



//****************************************************************************
//
//  CLASS:  CRegistryValue
//
//****************************************************************************
class CRegistryValue : public CObject
{
    DECLARE_DYNAMIC(CRegistryValue)

public:
    CString m_sName;
    DWORD m_dwType;
    DWORD m_dwDataLength;
    LPBYTE m_pData;

public:
    CRegistryValue();
    CRegistryValue(LPCTSTR pszName, DWORD dwType, DWORD dwDataLength,
        LPBYTE pData);
    ~CRegistryValue();

    void Set(LPCTSTR pszName, DWORD dwType, DWORD dwDataLength,
        LPBYTE pData);
    void Get(CString &sName, DWORD &dwType, DWORD &dwDataLength,
        LPBYTE pData = NULL);
    void Empty();
    const CRegistryValue& operator=(CRegistryValue &other);
};

//****************************************************************************
//
//  CLASS:  CRegistryKey
//
//****************************************************************************
class CRegistryKey : public CObject
{
    DECLARE_DYNAMIC(CRegistryKey)

public:
    CString m_sComputer;    // Name of computer we're connected to
    HKEY m_hkeyConnect;     // Handle to current connection key (or NULL)
    HKEY m_hkeyRemote;      // Handle to remote connection key (or NULL)
    BOOL m_bConnected;      // TRUE if currently connected
    BOOL m_bLocal;          // TRUE if connected to the local computer

    HKEY m_hkeyOpen;        // Handle to currently open key (or NULL)
    BOOL m_bOpen;           // TRUE if currently open
    CString m_sFullName;    // Full path name of currently open key
    CString m_sKeyName;     // Name of currently open key
    REGSAM m_Sam;           // Security access mask we opened with

    BOOL m_bDirty;          // TRUE if there are changes pending in this key

    CString m_sClass;       // Class name of key
    DWORD m_dwSubKeys;      // Number of subkeys in this key
    DWORD m_dwMaxSubKey;    // Longest subkey name length
    DWORD m_dwMaxClass;     // Longest class string length
    DWORD m_dwValues;       // Number of value entries in current key
    DWORD m_dwMaxValueName; // Longest value name length
    DWORD m_dwMaxValueData; // Longest value data length
    DWORD m_dwSecurityDescriptor;   // Security descriptor length

    FILETIME m_ftLastWriteTime; // Last modification date for key or values

    LONG m_lResult;         // Last return value from a registry API

public:
    CRegistryKey();
    ~CRegistryKey();

    void Initialize();
    LONG Connect(LPCTSTR pszComputer = NULL,
        HKEY hkey = HKEY_LOCAL_MACHINE);
    LONG Disconnect(BOOL bForce = FALSE);
    LONG Open(LPCTSTR pszKeyName, REGSAM samDesired = KEY_ALL_ACCESS);
    LONG Create(LPCTSTR pszKeyName, DWORD &dwDisposition,
        LPCTSTR pszClass = NULL, REGSAM samDesired = KEY_ALL_ACCESS,
        LPSECURITY_ATTRIBUTES lpSecAttr = NULL);
    LONG Close(BOOL bForce = FALSE);
    CStringArray* EnumValues();
    CStringArray* EnumSubKeys();
    BOOL GetValue(LPCTSTR pszValue, CRegistryValue &regval);
    BOOL SetValue(CRegistryValue &regval);
    BOOL GetSubKey(LPCTSTR pszSubKey, CRegistryKey &regkey);
    BOOL CreateSubKey(LPCTSTR pszSubKey, CRegistryKey &regkey,
        LPCTSTR pszClass = NULL, LPSECURITY_ATTRIBUTES lpSecAttr = NULL, BOOL bIsVolatile = FALSE);
    BOOL DeleteSubKey(LPCTSTR pszSubKey);	
};



class CEventTrapRegistry
{
public:
	CEventTrapRegistry();
	~CEventTrapRegistry();
};

extern BOOL g_bLostConnection;

#endif // _REGKEY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by eventrap.rc
//
#define ID_PROPERTIES                   3
#define ID_ADD                          4
#define ID_REMOVE                       5
#define ID_SETTINGS                     6
#define ID_BUTTON_EXPORT                7
#define IDC_APPLY                       8
#define IDS_NOT_TRAPPING                15
#define IDS_IS_TRAPPING                 16
#define IDS_MULTIPLE_SEL                17
#define IDS_MSG_TEXTNOTFOUND            20
#define IDS_MSG_SELECTEVENT             21
#define IDS_MSG_DELETEEVENT             22
#define IDS_COLHDR_TYPE                 23
#define IDS_CANTCONNECT                 24
#define IDS_ALREADYTRAPPING             28
#define IDS_SOMETRAPPING                29
#define IDS_EVENT_SEV_SUCCESS           33
#define IDS_EVENT_SEV_INFORMATIONAL     34
#define IDS_EVENT_SEV_WARNING           35
#define IDS_EVENT_SEV_ERROR             36
#define IDS_LcSource_TITLE_EVENT_ID     37
#define IDS_LcSource_TITLE_TRAPPING     38
#define IDS_LcSource_TITLE_DESCRIPTION  39
#define IDS_LcSource_TITLE_SEVERITY     40
#define IDS_LcEvents_TITLE_LOG          41
#define IDS_LcEvents_TITLE_SOURCE       42
#define IDS_LcEvents_TITLE_ID           43
#define IDS_LcEvents_TITLE_SEVERITY     44
#define IDS_LcEvents_TITLE_COUNT        45
#define IDS_LcEvents_TITLE_TIME         46
#define IDS_LcEvents_TITLE_DESCRIPTION  47
#define IDS_TITLE_EDIT_BUTTON           48
#define IDS_TITLE_VIEW_BUTTON           49
#define IDS_ERR_REGISTRY_CORRUPTED      50
#define IDS_ERR_NOT_INSTALLED           51
#define IDS_WARNING_CANT_READ_CONFIG    53
#define IDS_WARNING_NO_MESSAGE_SELECTED 54
#define IDS_ERR_INVALID_ARGUMENT        56
#define IDS_EXPORT_DIALOG_TITLE         57
#define IDS_EXPORT_DEFAULT_FILENAME     63
#define IDS_EXPORT_CNF_FILTER           67
#define IDS_ERR_CANT_CREATE_FILE        68
#define IDS_WARNING_CANT_WRITE_CONFIG   69
#define IDS_ERR_PROP_TIME1              71
#define IDS_ERR_PROP_TIME2              72
#define IDS_ERR_PROP_TIME_LESS_THAN_TWO 73
#define IDS_RANGE_MESSAGE_PREFIX        76
#define IDS_RANGE_VALUE_SEPARATOR       77
#define IDS_SENTENCE_TERMINATOR         78
#define IDS_ERR_SETTINGS_MESSAGELENGTH_NOT_INT 79
#define IDS_SETTINGS_MESSAGE_LENGTH_RANGE 80
#define IDS_ERR_SETTINGS_TRAPSECONDS_NOT_INT 81
#define IDS_SETTINGS_TRAPSECONDS_RANGE  82
#define IDS_ERR_SETTINGS_TRAPCOUNT_NOT_INT 83
#define IDS_ERR_SETTINGS_TRAPCOUNT_RANGE 84
#define IDS_ERR_REGISTRY_BUSY           85
#define IDS_CONFIGTYPE_DEFAULT          86
#define IDS_CONFIGTYPE_CUSTOM           87
#define IDS_CONFIGTYPE_DEFAULT_PENDING  88
#define IDS_ERR_REG_NO_ACCESS           89
#define IDS_ERR_REG_NO_READ_ACCESS      90
#define IDS_ERR_RANGE                   91
#define IDS_ERROR_NOT_RESPONDING        92
#define IDS_ERR_LOAD_MESSAGE_FILE_FAILED 93
#define IDS_ERR_MESSAGE_NOT_FOUND       94
#define IDR_MAINICON                    128
#define IDD_EVNTTRAPDLG                 129
#define IDD_SETTINGSDLG                 131
#define IDD_PROPERTIESDLG               133
#define IDD_EVENTFINDDLG                134
#define IDB_FOLDERCLOSE                 137
#define IDB_FOLDEROPEN                  138
#define IDC_CURSOR1                     139
#define IDD_ABOUTBOX                    142
#define IDD_SAVE_PROGRESS               144
#define IDD_LOAD_PROGRESS               145
#define IDR_CTXMENUS                    152
#define IDC_PROGRESS                    1000
#define IDC_LIMITMSGLNGTH               1012
#define IDC_EDIT_MESSAGELENGTH          1013
#define IDC_MSGLENGTHSPN                1015
#define ID_FIND                         1022
#define IDC_FIND_OK                     1023
#define IDC_FIND_CANCEL                 1024
#define IDC_EVENTCOUNT                  1025
#define IDC_EVENTCOUNTSPN               1026
#define IDC_WITHINTIME                  1027
#define IDC_TIMEINTRVLSPN               1030
#define IDC_DESCRIPTION                 1031
#define ID_STAT_SOURCE                  1033
#define ID_STAT_LOG                     1035
#define ID_STAT_EVENTID                 1036
#define IDC_EVENTLIST                   1046
#define IDC_TIMEINTERVAL                1048
#define IDC_RADIO1                      1054
#define IDC_RADIO2                      1055
#define ID_VIEW                         1069
#define IDC_TV_SOURCES                  1070
#define IDC_LV_SOURCES                  1071
#define IDC_STAT_LABEL1                 1073
#define IDC_STAT_LABEL2                 1074
#define IDC_EDIT_TRAP_COUNT             1075
#define IDC_STAT_LABEL0                 1075
#define IDC_EDIT_TRAP_SECONDS           1076
#define IDC_RADIO_ENABLE                1077
#define IDC_RADIO_DISABLE               1078
#define IDC_BUTTON_RESET                1079
#define IDC_EDIT_FIND_WHAT              1083
#define IDC_CHECK_MATCH_WHOLEWORD       1084
#define IDC_CHECK_MATCH_CASE            1085
#define IDC_RADIO_SEARCH_SOURCES        1086
#define IDC_RADIO_SEARCH_DESCRIPTIONS   1087
#define IDC_EDIT_ENTERPRISEOID          1097
#define IDC_STAT_GRP_CONFIG_TYPE        1098
#define IDC_RADIO_CUSTOM                1099
#define IDC_RADIO_DEFAULT               1100
#define IDC_STAT_TRAP_LENGTH            1101
#define IDC_EDIT_FULL_EVENT_ID          1103
#define IDC_STATIC_MSG                  1105
#define IDC_STATIC_NTRAPS               1106
#define IDC_STATIC_INTERVAL             1107
#define IDC_STATIC_BYTES                1108
#define IDC_DEFAULT                     1109
#define ID_SOURCE_LABEL                 1110
#define ID_LOG_LABEL                    1111
#define ID_EVENTID_LABEL                1112
#define ID_THRESHOLD_LABEL              1113
#define ID_OID_LABEL                    1115
#define ID_TRAPID_LABEL                 1116
#define IDD_NULL                        -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        168
#define _APS_NEXT_COMMAND_VALUE         32776
#define _APS_NEXT_CONTROL_VALUE         1121
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\source.h ===
#ifndef _source_h
#define _source_h

#include "evntfind.h"

class CTcSource;
class CLcSource;
class CMessage;
class CEventFindDlg;
class CXMessageArray;
class CXEventSource;
class CEventTrapDlg;

class CSource
{
public:
	CSource();	
    ~CSource();
    SCODE Create(CEventTrapDlg* pdlgEventTrap);
	SCODE CreateWindowEpilogue();
	BOOL Find(BOOL bSearchTree, CString sText, BOOL bWholeWord, BOOL bMatchCase);
    void OnFind(CWnd* pwndParent);
    void GetSelectedMessages(CXMessageArray& aMessages);
    void NotifyTrappingChange(CXEventSource* pEventSource, DWORD dwId, BOOL bIsTrapping);
	void NotifyTcSelChanged();
    CXEventSource* m_pEventSource;

private:
	CLcSource* m_plcSource;
	CTcSource* m_ptcSource;
    CEventTrapDlg* m_pdlgEventTrap;

    friend class CEventFindDlg;
    CEventFindDlg* m_pdlgFind;
};


#endif _source_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\source.cpp ===
//******************************************************************
// source.cpp
//
// This is file contains the implementation of the CSource class.  
//
// The CSource class acts as a container class for the message source,
// which is composed of the source tree control and the message list.
//
// Author: Larry A. French
//
// History:
//      20-Febuary-1996     Larry A. French
//          Wrote it.
//
//
// Copyright (C) 1995, 1996 Microsoft Corporation.  All rights reserved.
//******************************************************************
#include "stdafx.h"
#include "regkey.h"
#include "source.h"
#include "utils.h"
#include "globals.h"

#include "tcsource.h"
#include "lcsource.h"
#include "evntfind.h"
#include "trapdlg.h"




CSource::CSource()
{
    m_pEventSource = NULL;
    m_ptcSource = NULL;
    m_plcSource = NULL;
    m_pdlgEventTrap = NULL;
    m_pdlgFind = NULL;
}


CSource::~CSource()
{
    delete m_pdlgFind;
}

SCODE CSource::Create(CEventTrapDlg* pdlgEventTrap)
{
	m_ptcSource = &pdlgEventTrap->m_tcSource;
	m_ptcSource->m_pSource = this;

	m_plcSource = &pdlgEventTrap->m_lcSource;
	m_plcSource->m_pSource = this;

    m_pdlgEventTrap = pdlgEventTrap;

    return S_OK;
}



//***************************************************************************
// CSource::NotifyTcSelChanged
//
// This method returns an array of pointers to the messages currently selected
// in the CLcEvents list control.  These pointers are owned by g_aEventLogs and
// the caller should not delete them.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//***************************************************************************
void CSource::GetSelectedMessages(CXMessageArray& aMessages)
{
    m_plcSource->GetSelectedMessages(aMessages);
}



//***************************************************************************
// CSource::NotifyTcSelChanged
//
// This method is called when the selection changes in the event-source tree
// control (CTcSource).  When the selection changes, the message list must
// be updated.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//***************************************************************************
void CSource::NotifyTcSelChanged()
{
	m_pEventSource = m_ptcSource->GetSelectedEventSource();
	m_plcSource->SetEventSource(m_pEventSource);
    m_pdlgEventTrap->NotifySourceSelChanged();
}




//***************************************************************************
//
//  CSource::CreateWindowEpilogue()
//
//  This method is called after a window has been created for this list
//  control.  Final initialization is done here.
//
//  Parameters:
//		None.
//
//  Returns:
//		SCODE
//			S_OK if the initialization was successful, otherwise E_FAIL.
//
//  Status:
//      
//***************************************************************************
SCODE CSource::CreateWindowEpilogue()
{
	SCODE scTc = m_ptcSource->CreateWindowEpilogue();
	SCODE scLc = m_plcSource->CreateWindowEpilogue();

	if (FAILED(scTc) || FAILED(scLc)) {
		return E_FAIL;
	}
	
	return S_OK;
}



//******************************************************************
// CSource::Find
//
// Find the specified event source.  This is done by searching either
// the tree or the list control depending on the bSearchTree parameter.
//
// Parameters:
//		BOOL bSearchTree
//			TRUE if the tree should be searched, otherwise the list control
//			is searched.
//
//		CString& sText
//			A string containing the text to search for.
//
//		BOOL bWholeWord
//			TRUE if this is a "whole word" search.  False if it
//			is OK to match a partial word.
//
//		BOOL bMatchCase
//			TRUE if a case-sensitive comparison should be used.
//
// Returns:
//		BOOL
//			TRUE if the string was found, FALSE otherwise.  If the specified
//			text is found, then the selection is set on the corresponding
//			item, the item is scrolled into view and the focus
//			is set on the item.
//
//******************************************************************
BOOL CSource::Find(BOOL bSearchTree, CString sText, BOOL bWholeWord, BOOL bMatchCase)
{
    
	if (bSearchTree) 
		return m_ptcSource->Find(sText, bWholeWord, bMatchCase);
	else 
		return m_plcSource->Find(sText, bWholeWord, bMatchCase);
}




//************************************************************************
// CSource::OnFind
//
// This method is called when the "Find" button in the CEventTrap dialog
// is clicked. 
//
// Parameters:
//      CWnd* pwndParent
//          Pointer to the parent window of the "find" dialog.  This happens
//          to be the CEventTrapDialog.
//
// Returns:
//      Nothing.
//
//*************************************************************************
void CSource::OnFind(CWnd* pwndParent)
{
    if (m_pdlgFind == NULL) {
        m_pdlgFind = new CEventFindDlg(pwndParent);
        m_pdlgFind->Create(this, IDD_EVENTFINDDLG, pwndParent);
    }


    m_pdlgFind->BringWindowToTop();
}



//*************************************************************************
// CSource::NotifyTrappingChange
//
// This method is called when an event is added or removed from the
// event list.  This CSource message source container must be notified
// so that the corresponding method can be marked as trapped or not
// trapped in the CLcSource list control.
//
// Parameters:
//      CXEventSource* pEventSource
//          Pointer to the event's event-source
//
//      DWORD dwId
//          The event's ID
//
//      BOOL bIsTrapping
//          TRUE if the event is being trapped, FALSE if not.,
//
// Returns:
//      Nothing.
//*************************************************************************
void CSource::NotifyTrappingChange(CXEventSource* pEventSource, DWORD dwId, BOOL bIsTrapping)
{
    if (pEventSource == m_pEventSource) {
        m_plcSource->NotifyTrappingChange(dwId, bIsTrapping);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\remote.cpp ===
//***********************************************************************
// remote.cpp
//
// This file contains code required to expand environment variables in the
// context of a remote machine. It does this by reading the environment variables
// from the remote machine's registry and caching them here.
//
// This file also contains code required to map local paths read out of the
// remote machine's registry into UNC paths such that c:\foo will be mapped
// to \\machine\c$\foo
//
// Author: Larry A. French
//
// History:
//      19-April-1996     Larry A. French
//          Wrote it.
//
// Copyright (C) 1995, 1996 Microsoft Corporation.  All rights reserved.
//
//************************************************************************


#include "stdafx.h"
#include "remote.h"
#include "trapreg.h"
#include "regkey.h"




CEnvCache::CEnvCache()
{
}


//*****************************************************************
// CEnvCache::GetEnvironmentVars
//
// Read the system environment variables for the remote machine out
// of its registry.
//
// Parameters:
//    LPCTSTR pszMachine
//          Pointer to the remote machine's name.
//
//    CMapStringToString* pmapVars
//          This string to string map is where the environment variables
//          for the machine are returned.
//
// Returns:
//    SCODE
//          S_OK if everything was successful, otherwise E_FAIL.
//
//****************************************************************
SCODE CEnvCache::GetEnvironmentVars(LPCTSTR pszMachine, CMapStringToString* pmapVars)
{
    CRegistryKey regkey;        // SYSTEM\CurrentControlSet\Services\EventLogs
    CRegistryValue regval;

    static TCHAR* apszNames1[] = {
        _T("SourcePath"),
        _T("SystemRoot")
    };

    if (regkey.Connect(pszMachine) != ERROR_SUCCESS) {
        goto CONNECT_FAILURE;
    }


    // First pick up the values for the SourcePath and SystemRoot environment variables and anything elese in
    // apszNames1.
    LONG nEntries;
    LONG iEntry;
    if (regkey.Open(_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"), KEY_READ ) == ERROR_SUCCESS) {
        nEntries = sizeof(apszNames1) / sizeof(TCHAR*);
        for (iEntry=0; iEntry<nEntries; ++iEntry) {
            if (regkey.GetValue(apszNames1[iEntry], regval)) {
                pmapVars->SetAt(apszNames1[iEntry], (LPCTSTR) regval.m_pData);
            }
        }
        regkey.Close();
    }

    // Now get the rest of the environment variables.
    if (regkey.Open(_T("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment"), KEY_READ ) == ERROR_SUCCESS) {
        CStringArray* pasValues = regkey.EnumValues();
        if (pasValues != NULL) {
            nEntries = (LONG)pasValues->GetSize();
            for (iEntry=0; iEntry< nEntries; ++iEntry) {
                CString sValueName =  pasValues->GetAt(iEntry);
                if (regkey.GetValue(sValueName, regval)) {
                    pmapVars->SetAt(sValueName, (LPCTSTR) regval.m_pData);
                }
            }
        }
        regkey.Close();
    }
    return S_OK;

CONNECT_FAILURE:
	return E_FAIL;
}


SCODE CEnvCache::AddMachine(LPCTSTR pszMachine)
{
	CMapStringToString* pmapVars;
	if (m_mapMachine.Lookup(pszMachine, (CObject*&) pmapVars)) {
		// The machine already has an entry, so don't add another
		return E_FAIL;
	}

	pmapVars = new CMapStringToString;
	m_mapMachine.SetAt(pszMachine, pmapVars);

	SCODE sc = GetEnvironmentVars(pszMachine, pmapVars);

	return sc;
}


//******************************************************************
// CEnvCache::Lookup
//
// Lookup an environment variable on the specified machine.
//
// Parameters:
//		LPCTSTR pszMachineName
//			Pointer to the machine name string.
//
//		LPCTSTR pszName
//			Pointer to the name of the environment variable to lookup.
//
//		CString& sValue
//			This is a reference to the place where the environment varaible's
//			value is returned.
//
//
// Returns:
//		SCODE
//			S_OK if the environment variable was found.
//			E_FAIL if the environment varaible was not found.
//
//*******************************************************************
SCODE CEnvCache::Lookup(LPCTSTR pszMachineName, LPCTSTR pszName, CString& sResult)
{
	SCODE sc;
	CMapStringToString* pmapVars;
	// Get a pointer to the machine's cached map of environment variable values.
	// If the map hasn't been loaded yet, do so now and try to get its map again.
	if (!m_mapMachine.Lookup(pszMachineName, (CObject*&) pmapVars)) {
		sc = AddMachine(pszMachineName);
		if (FAILED(sc)) {
			return sc;
		}
		if (!m_mapMachine.Lookup(pszMachineName, (CObject*&) pmapVars)) {
			ASSERT(FALSE);
		}
	}

	// Look for the variable name in the environment name map
	if (pmapVars->Lookup(pszName, sResult)) {
		return S_OK;
	}
	else {
		return E_FAIL;
	}
}



//****************************************************************
// RemoteExpandEnvStrings
//
// Epand a string that may contain environment variables in the
// context of a remote machine.
//
// Parameters:
//		LPCTSTR pszComputerName
//			A pointer to the name of the remote machine.
//
//		CEnvCache& cache
//			The environment variable cache for all machines.  Note: the
//			cached values for a particular machine are loaded when there
//			is a reference to the machine.
//
//		CString& sValue
//			The string to expand.  This string is expanded in-place such
//			that on return, the string will contain the expanded values.
//
// Returns:
//		SCODE
//			S_OK if all strings were expanded
//
//******************************************************************
SCODE RemoteExpandEnvStrings(LPCTSTR pszComputerName, CEnvCache& cache, CString& sValue)
{
	SCODE sc = S_OK;
    LPCTSTR psz = sValue;
	TCHAR ch;
	CString sEnvVarName;
	CString sEnvVarValue;
	CString sResult;
	LPCTSTR pszPercent = NULL;
    while (ch = *psz++) {
        if (ch == _T('%')) {
			pszPercent = psz - 1;

			sEnvVarName = _T("");
            while (ch = *psz) {
				++psz;
                if (ch == _T('%')) {
					SCODE sc;
					sc = cache.Lookup(pszComputerName, sEnvVarName, sEnvVarValue);
					if (SUCCEEDED(sc)) {
						sResult += sEnvVarValue;
						pszPercent = NULL;
					}
					else {
						// If any environment variable is not found, then fail.
						sc = E_FAIL;
					}
					break;
                }
                if (iswspace(ch) || ch==_T(';')) {
                    break;
                }
                sEnvVarName += ch;
            }

			if (pszPercent != NULL) {
				// Control comes here if the opening percent was not matched by a closing
				// percent.
				while(pszPercent < psz) {
					sResult += *pszPercent++;
				}
			}

        }
		else {
			sResult += ch;
		}
    }

	sValue = sResult;		
	return sc;
	
}


//************************************************************
// SplitComplexPath
//
// Split a complex path consisting of several semicolon separated
// paths into separate paths and return them in a string array.
//
// Parameters:
//		LPCTSTR pszComplexPath
//			Pointer to the path that may or may not be composed of
//			several semicolon separated paths.
//
//		CStringArray& saPath
//			The place to return the split paths.
//
// Returns:
//		The individual paths are returned via saPath
//
//*************************************************************
void SplitComplexPath(LPCTSTR pszComplexPath, CStringArray& saPath)
{
	CString sPath;
	while (*pszComplexPath) {
		sPath.Empty();
		while (isspace(*pszComplexPath))  {
			++pszComplexPath;
		}

		while (*pszComplexPath &&
			   (*pszComplexPath != _T(';'))) {
			sPath += *pszComplexPath++;
		}

		if (!sPath.IsEmpty()) {
			saPath.Add(sPath);
		}

		if (*pszComplexPath==_T(';')) {
			++pszComplexPath;
		}
	}
}



//**************************************************************************
// MapPathToUNC
//
// Map a path to the UNC equivallent. Note that this method assumes that
// for each path containing a drive letter that the target machine will have
// the path shared out.  For example, if the path contains a "c:\foodir" prefix, then
// then you can get to "foodir" bygenerating the "\\machine\c$\foodir" path.
//
// Parameters:
//		LPCTSTR pszMachineName
//			Pointer to the machine name.
//
//		CString& sPath
//			Pointer to the path to map.  Upon return, this string will contain
//			the mapped path.
//
// Returns:
//		SCODE
//			S_OK if successful
//			E_FAIL if something went wrong.
//
//**************************************************************************
SCODE MapPathToUNC(LPCTSTR pszMachineName, CString& sPath)
{
	CStringArray saPaths;
	SplitComplexPath(sPath, saPaths);
	sPath.Empty();
	
	
	LPCTSTR pszPath = sPath.GetBuffer(sPath.GetLength() + 1);
	LONG nPaths = (LONG)saPaths.GetSize();
	SCODE sc = S_OK;
	for (LONG iPath=0; iPath < nPaths; ++iPath) {
		pszPath = saPaths[iPath];

		if (isalpha(pszPath[0]) && pszPath[1]==_T(':')) {
			CString sResult;
			sResult += _T("\\\\");
			sResult += pszMachineName;
			sResult += _T('\\');
			sResult += pszPath[0];		// Drive letter
			sResult += _T("$\\");		
			pszPath += 2;
			if (pszPath[0]==_T('\\')) {
				++pszPath;
			}
			sResult += pszPath;
			saPaths[iPath] = sResult;
		}
		else {
			sc = E_FAIL;
		}
		sPath += saPaths[iPath];
		if (iPath < nPaths - 1) {
			sPath += _T("; ");
		}
	}
	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxcmn.h>         // MFC common control classes
#include <afxmt.h>          // MFC multi threading classes

#include "resource.h"
#include "ewhelparr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\tcsource.h ===
#ifndef _tcsource_h
#define _tcsource_h


/////////////////////////////////////////////////////////////////////////////
// CTcSource window

class CXEventSource;

class CTcSource : public CTreeCtrl
{
// Construction
public:
	CTcSource();
	SCODE CreateWindowEpilogue();
	CXEventSource* GetSelectedEventSource();
	void SelChanged() { m_pSource->NotifyTcSelChanged(); }
	BOOL Find(CString& sText, BOOL bWholeWord, BOOL bMatchCase);

// Attributes
public:
	

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTcSource)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CTcSource();

	// Generated message map functions
protected:
	//{{AFX_MSG(CTcSource)
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

private:
	void LoadImageList();
	SCODE LoadTreeFromRegistry();
	CImageList m_ImageList;	

	friend class CSource;
	CSource* m_pSource;
};

#endif //_tcsource_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\trapdlg.cpp ===
//******************************************************************
// trapdlg.cpp
//
// This is the source file for eventrap's main dialog.
//
// Author: Larry A. French
//
// History:
//      December-1995       SEA - Wrote it
//          SEA - wrote it.
//
//      20-Febuary-1996     Larry A. French
//          Totally rewrote it to fix the spagetti code and huge
//          methods.  The original author seemed to have little or
//          no ability to form meaningful abstractions.
//
//
// Copyright (C) 1995, 1996 Microsoft Corporation.  All rights reserved.
//******************************************************************

#include "stdafx.h"
#include "Eventrap.h"
#include "trapdlg.h"
#include "evntprop.h"
#include "settings.h"
#include "busy.h"
#include "trapreg.h"
#include "globals.h"
#include "evntfind.h"
#include "export.h"
#include "dlgsavep.h"

//#include "smsalloc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//{{AFX_MSG(CAboutDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};



CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg message handlers

BOOL CAboutDlg::OnInitDialog()
{
	CDialog::OnInitDialog();
	CenterWindow();
	
	// TODO: Add extra about dlg initialization here
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}


/////////////////////////////////////////////////////////////////////////////
// CEventTrapDlg dialog

CEventTrapDlg::CEventTrapDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CEventTrapDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CEventTrapDlg)
	//}}AFX_DATA_INIT


    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINICON);

    m_source.Create(this);
	m_bExtendedView = FALSE;
    m_bSaveInProgress = FALSE;
}

CEventTrapDlg::~CEventTrapDlg()
{
    PostQuitMessage(0);
}

void CEventTrapDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CEventTrapDlg)
	DDX_Control(pDX, IDC_APPLY, m_btnApply);
	DDX_Control(pDX, ID_BUTTON_EXPORT, m_btnExport);
	DDX_Control(pDX, IDC_EVENTLIST, m_lcEvents);
	DDX_Control(pDX, IDC_TV_SOURCES, m_tcSource);
    DDX_Control(pDX, IDC_STAT_LABEL0, m_statLabel0);
	DDX_Control(pDX, IDC_STAT_LABEL1, m_statLabel1);
	DDX_Control(pDX, IDC_STAT_LABEL2, m_statLabel2);
    DDX_Control(pDX, IDC_LV_SOURCES, m_lcSource);
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDCANCEL, m_btnCancel);
	DDX_Control(pDX, ID_SETTINGS, m_btnSettings);
	DDX_Control(pDX, ID_PROPERTIES, m_btnProps);
	DDX_Control(pDX, ID_VIEW, m_btnView);
	DDX_Control(pDX, ID_REMOVE, m_btnRemove);
	DDX_Control(pDX, ID_ADD, m_btnAdd);
	DDX_Control(pDX, ID_FIND, m_btnFind);
	DDX_Control(pDX, IDC_STAT_GRP_CONFIG_TYPE, m_btnConfigTypeBox);
    DDX_Control(pDX, IDC_RADIO_CUSTOM, m_btnConfigTypeCustom);
    DDX_Control(pDX, IDC_RADIO_DEFAULT, m_btnConfigTypeDefault);
	//}}AFX_DATA_MAP

}

BEGIN_MESSAGE_MAP(CEventTrapDlg, CDialog)
    //{{AFX_MSG_MAP(CEventTrapDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_DESTROY()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
    ON_BN_CLICKED(ID_ADD, OnAdd)
    ON_BN_CLICKED(ID_PROPERTIES, OnProperties)
    ON_BN_CLICKED(ID_SETTINGS, OnSettings)
	ON_NOTIFY(NM_DBLCLK, IDC_EVENTLIST, OnDblclkEventlist)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_EVENTLIST, OnColumnclickEventlist)
	ON_WM_SIZE()
	ON_BN_CLICKED(ID_VIEW, OnView)
	ON_BN_CLICKED(ID_REMOVE, OnRemove)
	ON_BN_CLICKED(ID_FIND, OnFind)
	ON_NOTIFY(TVN_SELCHANGED, IDC_TV_SOURCES, OnSelchangedTvSources)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_LV_SOURCES, OnColumnclickLvSources)
	ON_NOTIFY(NM_DBLCLK, IDC_LV_SOURCES, OnDblclkLvSources)
	ON_BN_CLICKED(ID_BUTTON_EXPORT, OnButtonExport)
	ON_NOTIFY(LVN_KEYDOWN, IDC_EVENTLIST, OnKeydownEventlist)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_EVENTLIST, OnItemchangedEventlist)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_LV_SOURCES, OnItemchangedLvSources)
	ON_BN_CLICKED(IDC_RADIO_CUSTOM, OnRadioCustom)
	ON_BN_CLICKED(IDC_RADIO_DEFAULT, OnRadioDefault)
	ON_WM_DRAWITEM()
	ON_COMMAND(ID_HELP, OnHelp)
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	ON_BN_CLICKED(IDC_APPLY, OnApply)
	ON_BN_CLICKED(IDC_DEFAULT, OnDefault)
	ON_NOTIFY(TVN_ITEMEXPANDED, IDC_TV_SOURCES, OnTvSourcesExpanded)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEventTrapDlg message handlers

void CEventTrapDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
/*
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
*/
	CDialog::OnSysCommand(nID, lParam);
    m_lcEvents.SetFocus();

}

void CEventTrapDlg::OnDestroy()
{
	CDialog::OnDestroy();
}


// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.
void CEventTrapDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CEventTrapDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}


//*************************************************************************
// CEventTrapDlg::OnInitDialog
//
// Initialize the dialog.
//

// Parameters:
//      None.
//
// Returns:
//      BOOL
//          TRUE if Windows should set the focus to the first control
//          in the dialog box.  FALSE if the focus has already been set
//          and Windows should leave it alone.
//
//*************************************************************************
BOOL CEventTrapDlg::OnInitDialog()
{
    CBusy busy;
    CDialog::OnInitDialog();
	CenterWindow();

//    VERIFY(m_lcSource.SubclassDlgItem(IDC_LV_SOURCES, this));


    SetIcon(m_hIcon, TRUE);
    SetIcon(m_hIcon, FALSE);

    m_layout.Initialize(this);

    // Layout the dialog view for the small (non-extended) view
    m_bExtendedView = FALSE;
    m_layout.LayoutView(FALSE);

    // The registry class is keeping a pointer to the 'Apply' pointer in order to
    // enable disable it according to the 'dirty' state.
    g_reg.SetApplyButton(&m_btnApply);

    // Step the progress indicator for loading the configuration.
    // Note that if you add more steps here, you must modify
    // CTrapReg::CTrapReg to account for these extra steps.
    //=========================================================
    g_reg.m_pdlgLoadProgress->StepProgress();
    ++g_reg.m_nLoadSteps;

    CString sText;
    sText.LoadString(IDS_TITLE_EDIT_BUTTON);
    m_btnView.SetWindowText(sText);

    // Notify the message source container and the events list control
    // that this dialog has been initialized so that they can initialize
    // their windows and so on.  Note that this must be called after the
    // g_reg.m_aEventLogs is deserialized because information contained therein
    // will be displayed
	m_source.CreateWindowEpilogue();
    g_reg.m_pdlgLoadProgress->StepProgress();
    ++g_reg.m_nLoadSteps;


    m_lcEvents.CreateWindowEpilogue();			
    g_reg.m_pdlgLoadProgress->StepProgress();
    ++g_reg.m_nLoadSteps;


    m_lcEvents.AddEvents(m_source, g_reg.m_aEventLogs);
    g_reg.m_pdlgLoadProgress->StepProgress();
    ++g_reg.m_nLoadSteps;


    m_sExportTitle.LoadString(IDS_EXPORT_DEFAULT_FILENAME);

    CheckEventlistSelection();
    m_btnAdd.EnableWindow(FALSE);

    if ((g_reg.GetConfigType() == CONFIG_TYPE_CUSTOM)) {
        CheckRadioButton(IDC_RADIO_CUSTOM, IDC_RADIO_DEFAULT, IDC_RADIO_CUSTOM);
    }
    else {
        CheckRadioButton(IDC_RADIO_CUSTOM, IDC_RADIO_DEFAULT, IDC_RADIO_DEFAULT);
    }


    if ((g_reg.GetConfigType() == CONFIG_TYPE_CUSTOM) && !g_reg.m_bRegIsReadOnly) {
        m_btnView.EnableWindow(TRUE);
    }
    else {
        m_btnView.EnableWindow(FALSE);
    }


    // If eventrap will be used without the SMS Admin UI, then we want to hide the
    // configuration type group box because it it meaningless if SMS will not be
    // distributing jobs containing the default configuration.
    if (!g_reg.m_bShowConfigTypeBox) {
    	m_btnConfigTypeBox.ShowWindow(SW_HIDE);
        m_btnConfigTypeCustom.ShowWindow(SW_HIDE);
        m_btnConfigTypeDefault.ShowWindow(SW_HIDE);
    }


    // Now that we know what the configuration type is, we can update the
    // dialog's title.  But first we will save the default dialog title so
    // that we can use it as the base that will be extended with an optional
    // machine name and configuration type.
    GetWindowText(m_sBaseDialogCaption);
    UpdateDialogTitle();

    delete g_reg.m_pdlgLoadProgress;
    g_reg.m_pdlgLoadProgress = NULL;

    // initially, once the registry gets loaded, the dirty state is 'false'
    g_reg.SetDirty(FALSE);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


//*************************************************************************
// CEventTrapDlg::OnAdd
//
// Add the messages that are currently selected in the message source list
// to the event list.
//
// The event list is the list control in the upper part of the dialog box.
// The message source list is the list control in the lower-right side of
// the dialog box.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//*************************************************************************
void CEventTrapDlg::OnAdd()
{
    CBusy busy;

    // Get an array containing the selected messages
    CXMessageArray aMessages;
    m_source.GetSelectedMessages(aMessages);
    if (aMessages.GetSize() == 0) {
        AfxMessageBox(IDS_WARNING_NO_MESSAGE_SELECTED);
        m_lcEvents.SetFocus();
        return;
    }

    // Create a set of events corresponding to the messages.
    CXEventArray aEvents;
    CXEventArray aEventsAlreadyTrapped;
    LONG nMessages = aMessages.GetSize();
    m_lcEvents.UpdateWindow();

    aEvents.RemoveAll();
    for (LONG iMessage = 0; iMessage < nMessages; ++iMessage) {
        CXMessage* pMessage = aMessages[iMessage];
        CXEvent* pEvent;
        pEvent = pMessage->m_pEventSource->FindEvent(pMessage->m_dwId);
        if (pEvent == NULL) {
            CXEvent* pEvent = new CXEvent(pMessage);
            aEvents.Add(pEvent);
        }
        else {
            aEventsAlreadyTrapped.Add(pEvent);
        }
    }

    if (aEvents.GetSize() > 0) {
        // Now we need to ask the user for the "settings" for these events.
        CEventPropertiesDlg dlg;
        if (!dlg.EditEventProperties(aEvents)) {
            aEvents.DeleteAll();
            m_lcEvents.SetFocus();
            return;
        }

        m_lcEvents.AddEvents(m_source, aEvents);

        aEvents.RemoveAll();
        g_reg.SetDirty(TRUE);
    }

    if (aEventsAlreadyTrapped.GetSize() > 0) {
        m_lcEvents.SelectEvents(aEventsAlreadyTrapped);
        aEventsAlreadyTrapped.RemoveAll();
        if (nMessages == aEventsAlreadyTrapped.GetSize()) {
            AfxMessageBox(IDS_ALREADYTRAPPING);
        }
        else {
            AfxMessageBox(IDS_SOMETRAPPING);
        }
    }
    m_lcEvents.SetFocus();

}








//*************************************************************************
// CEventTrapDlg::OnProperties
//
// Edit the properties of the selected events in the event-list.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//*************************************************************************
void CEventTrapDlg::OnProperties()
{
    CXEventArray aEvents;
    m_lcEvents.GetSelectedEvents(aEvents);

    // Nothing selected.
    if (aEvents.GetSize() == 0)
    {
        CString sMsg;
        sMsg.LoadString(IDS_MSG_SELECTEVENT);
        MessageBox(sMsg, NULL, MB_ICONEXCLAMATION);
    }
    else {
        // Put up the dialog to edit the event properties.
        CEventPropertiesDlg dlg;
        if (dlg.EditEventProperties(aEvents)) {
            m_lcEvents.RefreshEvents(aEvents);
        }
    }
    m_lcEvents.SetFocus();
}



//*************************************************************************
// CEventTrapDlg::OnSettings
//
// Edit the global settings.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//*************************************************************************
void CEventTrapDlg::OnSettings()
{
    // Setup and load the dialog.
    CTrapSettingsDlg dlg(this);
    dlg.EditSettings();
    m_lcEvents.SetFocus();
}



//*************************************************************************
// CEventTrapDlg::OnRemove
//
// Remove the events currently selected in the CLcEvents list control.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//*************************************************************************
void CEventTrapDlg::OnRemove()
{
    // If nothing was selected, warn the user.
    CString sText;
    if (!m_lcEvents.HasSelection()) {
        sText.LoadString(IDS_MSG_SELECTEVENT);
        MessageBox(sText, NULL, MB_ICONEXCLAMATION);
        return;  // Nothing to do.
    }

    // Make sure the user wants to delete these items.
    sText.LoadString(IDS_MSG_DELETEEVENT);
    if (MessageBox(sText, NULL, MB_ICONQUESTION | MB_OKCANCEL) != IDOK)
        return;

    // We must notify the source control that the events are deleted
    // so that the trapping flag can be updated.
    CBusy busy;
    m_lcEvents.DeleteSelectedEvents(m_source);
    g_reg.SetDirty(TRUE);

    // All of the selected events were removed, so now there is no selection
    // and the export and properties buttons should be disabled.
    m_btnProps.EnableWindow(FALSE);
    m_btnExport.EnableWindow(FALSE);
    m_btnRemove.EnableWindow(FALSE);
    m_lcEvents.SetFocus();
}




//*********************************************************************
// CEventTrapDlg::OnOK
//
// This method is called when the "OK" button is clicked.  All we
// have to do is save the current configuration.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//********************************************************************
void CEventTrapDlg::OnOK()
{
    CBusy busy;

    // Set the save in progress flag so that we aren't interrupted in the
    // middle of writing to the registry.
    m_bSaveInProgress = TRUE;

    // Clear the "lost connection" flag so that the user can attempt to save
    // again.
    SCODE sc = g_reg.Serialize();
    if ((sc == S_SAVE_CANCELED) || FAILED(sc)) {
        // Control comes here if the user elected to cancel the save.  We clear
        // the m_bSaveInProgress dialog so that the user can cancel out of this
        // application altogether if he or she chooses to do so.
        m_bSaveInProgress = FALSE;
        return;
    }

    CDialog::OnOK();
    delete this;
}

//*********************************************************************
// CEventTrapDlg::OnApply
//
// This method is called when the "Apply" button is clicked.  All we
// have to do is save the current configuration.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//********************************************************************
void CEventTrapDlg::OnApply()
{
    CBusy busy;

    // Set the save in progress flag so that we aren't interrupted in the
    // middle of writing to the registry.
    m_bSaveInProgress = TRUE;

    // Clear the "lost connection" flag so that the user can attempt to save
    // again.
    SCODE sc = g_reg.Serialize();

    // Control comes here if the user elected to cancel the save.  We clear
    // the m_bSaveInProgress dialog so that the user can cancel out of this
    // application altogether if he or she chooses to do so.
    m_bSaveInProgress = FALSE;
}


//********************************************************************
// CEventTrapDlg::OnDblclkEventlist
//
// This method is called when the user double clicks an item within
// the event-list.  This is equivallent to clicking the "Properties"
// button.
//
// Parameters:
//      NMHDR* pNMHDR
//
//      LRESULT* pResult
//
// Returns:
//      Nothing.
//******************************************************************
void CEventTrapDlg::OnDblclkEventlist(NMHDR* pNMHDR, LRESULT* pResult)
{
    OnProperties();
	*pResult = 0;
}





//************************************************************************
// CEventTrapDlg::OnColumnclickEventlist
//
// This method is called when the user click a column header in the
// eventlist.  When this occurs, the event list must be resorted
// according to the criteria for that column.
//
// Ideally, this method would be a member of the CLcEvents class, but the
// class wizard and MFC wouldn't let me do it (MFC4.0 and VC++4.0 do let
// you do it).
//
// Parameters:
//      See the MFC documentation.
//
// Returns:
//      Nothing.
//
//***********************************************************************
void CEventTrapDlg::OnColumnclickEventlist(NMHDR* pNMHDR, LRESULT* pResult)
{
    CBusy busy;

	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    ASSERT(pNMListView->iSubItem < ICOL_LcEvents_MAX);

    // First flip the sort order for the column and then do the sort.
    g_abLcEventsSortAscending[pNMListView->iSubItem] = ! g_abLcEventsSortAscending[pNMListView->iSubItem];
    m_lcEvents.SortItems(pNMListView->iSubItem);
	*pResult = 0;
}




//************************************************************************
// CEventTrapDlg::OnSize
//
// This method is called when the trap dialog changes sizes.  When this
// occurs, the dialog layout must be recalculated because the dialog is
// laid out dynamically.
//
// Parameters:
//      See the MFC documentation.
//
// Returns:
//      Nothing.
//
//************************************************************************
void CEventTrapDlg::OnSize(UINT nType, int cx, int cy)
{
	CDialog::OnSize(nType, cx, cy);
	if (!::IsWindow(m_btnOK.m_hWnd)) {
		return;
	}

	m_layout.LayoutAndRedraw(m_bExtendedView, cx, cy);
}






//*********************************************************************
// CEventTrapDlg::OnView
//
// This method is called when the user clicks the View/Edit button.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//*********************************************************************
void CEventTrapDlg::OnView()
{
    // Flip the normal/extended view type and redo the dialog layout
    // to reflect the change.
	m_bExtendedView = !m_bExtendedView;	
    m_layout.LayoutView(m_bExtendedView);

    // Flip the title of the View/Edit button to the other state.
    CString sText;
    sText.LoadString(m_bExtendedView ? IDS_TITLE_VIEW_BUTTON : IDS_TITLE_EDIT_BUTTON);
    m_btnView.SetWindowText(sText);
    if (m_bExtendedView)
        m_tcSource.SetFocus();
    else
        m_lcEvents.SetFocus();
}




//********************************************************************
// CEventTrapDlg::OnFind
//
// This method is called when the user clicks the "Find" button.  Pass
// the notification onto the CSource object.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//********************************************************************
void CEventTrapDlg::OnFind()
{
    m_source.OnFind(this);	
}


//********************************************************************
// CEventTrapDlg::OnSelchangedTvSources
//
// This method is changed when the message source treeview selection
// changes.  Ideally, this method would be part of the CTcSource class,
// but MFC3.0 doesn't allow this (or at least you can't do it through
// the VC++ class wizard).  So, the message needs to be passed along
// to the CTcSource class.
//
// Parameters:
//      See the MFC documentation.
//
// Returns:
//      Nothing.
//
//********************************************************************
void CEventTrapDlg::OnSelchangedTvSources(NMHDR* pNMHDR, LRESULT* pResult)
{
	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;

	
    // We update the window so that the old selection will be unhighlighted
    // immediately. This is useful if it takes a long time to complete
    // the selection change.  Without the update, the user may get the impression
    // that there is a multiple selection.
    m_tcSource.UpdateWindow();
   	m_tcSource.SelChanged();
	*pResult = 0;
}



//*******************************************************************
// CEventTrapDlg::OnColumnclickLvSources
//
// This method is called when a column is clicked in the message source
// listview. When this occurs, the messages must be resorted according
// to the sorting criteria for the clicked column.
//
// Parameters:
//      See the MFC documentation.
//
// Returns:
//      Nothing.
//
//******************************************************************
void CEventTrapDlg::OnColumnclickLvSources(NMHDR* pNMHDR, LRESULT* pResult)
{
    CBusy busy;

	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    ASSERT(pNMListView->iSubItem < ICOL_LcSource_MAX);

    // First flip the sort order for the column and then do the sort.
    g_abLcSourceSortAscending[pNMListView->iSubItem] = ! g_abLcSourceSortAscending[pNMListView->iSubItem];
	m_lcSource.SortItems(pNMListView->iSubItem);
	*pResult = 0;

}


//*******************************************************************
// CEventTrapDlg::OnDblclkLvSources
//
// This method is called when the user double clicks a message in the
// source list.  This is equivallent to clicking the "Add" button.
//
// Parameters:
//      See the MFC documentation.
//
// Returns:
//      Nothing.
//
//*******************************************************************
void CEventTrapDlg::OnDblclkLvSources(NMHDR* pNMHDR, LRESULT* pResult)
{
	OnAdd();
	*pResult = 0;
}



//********************************************************************
// CEventTrapDlg::OnButtonExport
//
// This method is called when the "Export" button is clicked. This is
// where events can be exported by writing a trap-text or trap tool
// files corresponding to the selected events.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//********************************************************************
void CEventTrapDlg::OnButtonExport()
{
    CXEventArray aEvents;
    m_lcEvents.GetSelectedEvents(aEvents);

    // Nothing selected.
    if (aEvents.GetSize() == 0)
    {
        AfxMessageBox(IDS_MSG_SELECTEVENT, MB_ICONEXCLAMATION);
    }
    else {
        m_dlgExport.DoModal(aEvents);
    }


    m_lcEvents.SetFocus();
}



//*******************************************************************
// CEventTrapDlg::OnCancel
//
// This method is called when the cancel button is clicked.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//*******************************************************************
void CEventTrapDlg::OnCancel()
{
    if (m_bSaveInProgress) {
        return;
    }

	CDialog::OnCancel();
    delete this;
}



//********************************************************************
// CEventTrapDlg::CheckEventlistSelection
//
// Check to see if any events are currently selected in the event
// list. If no events are selected, then the buttons that operate on
// events are disabled.  If at least one event is selected  then the
// buttons that operate on events are enabled.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//*******************************************************************
void CEventTrapDlg::CheckEventlistSelection()
{
    LONG nSelected = m_lcEvents.GetSelectedCount();
    if (nSelected > 0) {
        m_btnProps.EnableWindow(TRUE);
        m_btnExport.EnableWindow(TRUE);
        m_btnRemove.EnableWindow(TRUE);
    }
    else {
        m_btnProps.EnableWindow(FALSE);
        m_btnExport.EnableWindow(FALSE);
        m_btnRemove.EnableWindow(FALSE);
    }

}



//********************************************************************
// CEventTrapDlg::CheckSourcelistSelection
//
// Check to see if any messages are currently selected in the message
// source list. If no messages are selected, then the "Add" button needs
// to be disabled.  If one or more messages are selected, then the "Add"
// button is enabled, allowing the user to add the message to the event
// list.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//*******************************************************************
void CEventTrapDlg::CheckSourcelistSelection()
{
    LONG nSelected = m_lcSource.GetSelectedCount();
    if (nSelected > 0) {
        m_btnAdd.EnableWindow(TRUE);
    }
    else {
        m_btnAdd.EnableWindow(FALSE);
    }
}



//********************************************************************
// CEventTrapDlg::OnKeydownEventlist
//
// This method is called when a keydown message is sent to the
// event list.  There are reasons why we monitor keydown events here:
//
//      1. To delete the selected event when the user hits the delete key.
//
// Parameters:
//      See the MFC documentation.
//
// Returns:
//      Nothing.
//
//********************************************************************
void CEventTrapDlg::OnKeydownEventlist(NMHDR* pNMHDR, LRESULT* pResult)
{

    #define VKEY_DELETE 46
	LV_KEYDOWN* pLVKeyDow = (LV_KEYDOWN*)pNMHDR;

    // Check to see if the delete key was entered.  If so, delete the
    // selected event.  Note that events can be deleted only if this
    // is a "Custom" configuration.
    if (pLVKeyDow->wVKey == VKEY_DELETE) {
        if (g_reg.GetConfigType() == CONFIG_TYPE_CUSTOM) {
            if (pLVKeyDow->wVKey == VKEY_DELETE) {
                OnRemove();
            }
        	*pResult = 0;

        } else {
            MessageBeep(MB_ICONQUESTION);
        }
    }

}



//***************************************************************************
// CEventTrapDlg::OnItemchangedEventlist
//
// This method is called when an item changes in the event list.  When this
// occurs, various buttons may have to be enabled or disabled depending on
// whether or not anything is selected.
//
// Parameters:
//      Please see the MFC documentation.
//
// Returns:
//      Nothing.
//
//**************************************************************************
void CEventTrapDlg::OnItemchangedEventlist(NMHDR* pNMHDR, LRESULT* pResult)
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here
    CheckEventlistSelection();
	
	*pResult = 0;
}



//***********************************************************************
// CEventTrapDlg::OnItemchangedLvSources
//
// This method is called when an item in the message source list changes.
// When this occurs, buttons such as "Add" and "Remove" may have to
// be enabled or disabled depending on whether or not anything is selected
// in the list.
//
// Parameters:
//      NMHDR* pNMHDR
//
//      LRESULT* pResult
//
// Returns:
//      Nothing.
//
//***********************************************************************

void CEventTrapDlg::OnItemchangedLvSources(NMHDR* pNMHDR, LRESULT* pResult)
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    CheckSourcelistSelection();
	*pResult = 0;
}


//*********************************************************************
// CEventTrapDlg::NotifySourceSelChanged
//
// This method is called when the selection changes in the message source
// list.  When this occurs, buttons such as "Add" and "Remove" may have
// to be enabled or disabled depending on whether or not anything is
// selected in the list.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//*********************************************************************
void CEventTrapDlg::NotifySourceSelChanged()
{
    CheckSourcelistSelection();
}



//*********************************************************************
// CEventTrapDlg::OnRadioCustom
//
// This method is called when the "Custom" radio button in the
// "Configuration Type" groupbox is clicked. When the user selects
// the custom configuration type, he or she is allowed to edit the
// current configuration.  Also the registry will be marked so that
// the next time SMS distributes an "Event to Trap" configuration job,
// the current configuration will not be replaced with the default configuration.
//
// There are three possible configuration states: custom, default, and
// default pending.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//**********************************************************************
void CEventTrapDlg::OnRadioCustom()
{
    CheckRadioButton(IDC_RADIO_CUSTOM, IDC_RADIO_DEFAULT, IDC_RADIO_CUSTOM);
    if (!g_reg.m_bRegIsReadOnly) {
        m_btnView.EnableWindow(TRUE);
    }
    g_reg.SetConfigType(CONFIG_TYPE_CUSTOM);
    UpdateDialogTitle();
}


//*********************************************************************
// CEventTrapDlg::OnRadioDefault
//
// This method is called when the "Default" radio button in the
// "Configuration Type" groupbox is clicked. When the user selects
// the default configuration, he or she is prevented from editing the
// current configuration.  Also the registry will be marked so that
// the next time SMS distributes an "Event to Trap" configuration job,
// the current configuration will be replaced with the default configuration.
//
// There are three possible configuration states: custom, default, and
// default pending.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//**********************************************************************
void CEventTrapDlg::OnRadioDefault()
{
    CheckRadioButton(IDC_RADIO_CUSTOM, IDC_RADIO_DEFAULT, IDC_RADIO_DEFAULT);

    // When the "Default" configuration is slected, the user is not allowed
    // to edit the event list, so if the extended dialog view is currently
    // being displayed, it is flipped back to the non-extended state and
    // the edit button is disabled.
    if (m_bExtendedView) {
        OnView();
    }
    m_btnView.EnableWindow(FALSE);

    // Mark the registry with the current config type so that when the
    // SMS event to trap job comes, it knows that it can overwrite the
    // current settings.
    g_reg.SetConfigType(CONFIG_TYPE_DEFAULT);

    // Update the dialog title to indicate the configuration state.
    UpdateDialogTitle();
}



//**********************************************************************
// CEventTrapDlg::UpdateDialogTitle
//
// This method updates the dialog's title.  The format of the title is
//
//      Event to Trap Translator - Machine Name - [configuration type]
//
// If the registry of the local machine is being edited, then the
// machine name is omitted.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//**********************************************************************
void CEventTrapDlg::UpdateDialogTitle()
{
    // Map the configuration type to a string-table resource id.
    LONG idsConfigType;
    switch(g_reg.GetConfigType()) {
    case CONFIG_TYPE_CUSTOM:
        idsConfigType = IDS_CONFIGTYPE_CUSTOM;
        break;
    case CONFIG_TYPE_DEFAULT:
        idsConfigType = IDS_CONFIGTYPE_DEFAULT;
        break;
    case CONFIG_TYPE_DEFAULT_PENDING:
        idsConfigType = IDS_CONFIGTYPE_DEFAULT_PENDING;
        break;
    default:
        ASSERT(FALSE);
        break;
    }

    CString sConfigType;
    sConfigType.LoadString(idsConfigType);

    CString sCaption = m_sBaseDialogCaption;
    if (!g_reg.m_sComputerName.IsEmpty()) {
        sCaption = sCaption + _T(" - ") + g_reg.m_sComputerName;
    }
    sCaption = sCaption + _T(" - [") + sConfigType + _T(']');
    SetWindowText(sCaption);

}

void CEventTrapDlg::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	// TODO: Add your message handler code here and/or call default
	
	CDialog::OnDrawItem(nIDCtl, lpDrawItemStruct);
}

BOOL CEventTrapDlg::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if (pHelpInfo->iContextType == HELPINFO_WINDOW)
	{
        ::WinHelp ((HWND)pHelpInfo->hItemHandle,
                   AfxGetApp()->m_pszHelpFilePath,
                   HELP_WM_HELP,
                   (ULONG_PTR)g_aHelpIDs_IDD_EVNTTRAPDLG);
	}
	
	return TRUE;
}

void CEventTrapDlg::OnContextMenu(CWnd* pWnd, CPoint point)
{
	CMenu contextMenus;

    if (this == pWnd)
		return;

	contextMenus.LoadMenu(IDR_CTXMENUS);

	if (pWnd->m_hWnd == m_lcEvents.m_hWnd)
	{
		CMenu * pMenuLcEvents;

		pMenuLcEvents = contextMenus.GetSubMenu(0);

		if (pMenuLcEvents != NULL)
		{

			if (!m_lcEvents.HasSelection())
			{
				pMenuLcEvents->EnableMenuItem(0, MF_GRAYED | MF_BYPOSITION);
				pMenuLcEvents->EnableMenuItem(3, MF_GRAYED | MF_BYPOSITION);
				pMenuLcEvents->EnableMenuItem(5, MF_GRAYED | MF_BYPOSITION);
			}

			pMenuLcEvents->TrackPopupMenu(
				TPM_LEFTALIGN | TPM_LEFTBUTTON,
				point.x,
				point.y,
				this,
				NULL);
		}
	}
	else if (pWnd->m_hWnd == m_lcSource.m_hWnd)
	{
		CMenu *pMenuLcSource;

		pMenuLcSource = contextMenus.GetSubMenu(1);

		if (pMenuLcSource != NULL)
		{
			if (m_lcSource.GetNextItem(-1, LVNI_SELECTED) == -1)
			{
				pMenuLcSource->EnableMenuItem(0, MF_GRAYED | MF_BYPOSITION);
			}

			pMenuLcSource->TrackPopupMenu(
				TPM_LEFTALIGN | TPM_LEFTBUTTON,
				point.x,
				point.y,
				this,
				NULL);
		}
	}
	else
	{
	   ::WinHelp (pWnd->m_hWnd,
              AfxGetApp()->m_pszHelpFilePath,
              HELP_CONTEXTMENU,
              (ULONG_PTR)g_aHelpIDs_IDD_EVNTTRAPDLG);
	}
}

void CEventTrapDlg::OnDefault()
{
	HTREEITEM hti;
	DWORD ctrlID = GetFocus()->GetDlgCtrlID();

	switch(ctrlID)
	{
	case IDC_EVENTLIST:
		if (m_lcEvents.HasSelection())
			OnProperties();
		else
			OnSettings();
		break;
	case IDC_TV_SOURCES:
		hti = m_tcSource.GetSelectedItem();
		if (hti != NULL)
			m_tcSource.Expand(hti, TVE_TOGGLE);
		break;
	case IDC_LV_SOURCES:
		OnAdd();
		m_lcSource.SetFocus();
		break;
	case IDC_RADIO_CUSTOM:
		OnRadioDefault();
		m_btnConfigTypeDefault.SetFocus();
		break;
	case IDC_RADIO_DEFAULT:
		OnRadioCustom();
		m_btnConfigTypeCustom.SetFocus();
		break;
	default:
		OnOK();
	}
}

void CEventTrapDlg::OnTvSourcesExpanded(NMHDR* pNMHDR, LRESULT* pResult)
{
	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    INT          nImage = (pNMTreeView->itemNew.state & TVIS_EXPANDED) ?
                                1 : // node is expanded -> 'open' folder icon is the second in the list
                                0 ; // node is contracted -> 'close' folder icon is the first in the list
	// TODO: Add your control notification handler code here

    m_tcSource.SetItemImage(pNMTreeView->itemNew.hItem, nImage, nImage);

	*pResult = 0;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\utils.h ===
#ifndef _utils_h
#define _utils_h


void MapEventToSeverity(DWORD dwEvent, CString& sResult);
extern LONG FindWholeWord(LPCTSTR pszTemplate, LPCTSTR pszText);
extern LONG FindSubstring(LPCTSTR pszTemplate, LPCTSTR pszText);
extern void DecString(CString& sValue, int iValue);
extern void DecString(CString& sValue, long lValue);
extern void DecString(CString& sValue, DWORD dwValue);

extern void GenerateRangeMessage(CString& sMessage, LONG nMin, LONG nMax);
extern SCODE GetThousandSeparator(TCHAR* pch);
extern BOOL IsDecimalInteger(LPCTSTR pszValue);
extern SCODE AsciiToLong(LPCTSTR pszValue, LONG* plResult);


//-------------------------------------------------------
// Class: CList
//
// Description:
//    This class implements a circularly linked list.
//
// Methods:
//-------------------------------------------------------
// CList::CList(void* pValue)
//
// Construct a node and associate the pointer value
// with it.  The pointer is declared to be type
// void* so that this class is as generic as possible.
//
// Input:
//    pValue = Pointer to the value to associate with this node
//
// Returns: Nothing
//
//-------------------------------------------------------
// void Link(CList*& pndHead)
//
// Add this node to the end of the list pointed to by
// pndHead.  If pndHead is NULL, then set pndHead to
// the address of this node.
//
// Input:
//    pndHead = A reference to the head node pointer
//
// Returns: Nothing
//
//-------------------------------------------------------
// void Unlink(CList*& pndHead)
//
// Unlink this node from the list it is on.  If this node
// is the only element on the list, set the value of pndHead
// to NULL to indicate that the list is empty.
//
// Input:
//    pndHead = A reference to the head node pointer.
//
// Returns: nothing
//
//-------------------------------------------------------
// CList* Next()
//
// Return a pointer to the next node in the list.
//
// Input: None
//
// Returns: A pointer to the next node on the list
//
//-------------------------------------------------------
// CList* Prev()
//
// Return a pointer to the previous node in the list.
//
// Input: None
//
// Returns: A pointer to the previous node on the list.
//
//-------------------------------------------------------
// void* Value()
//
// Return the "value pointer" attached to this node.
//
// Input: None
//
// Returns: The node's value.
//
//--------------------------------------------------------
class CList
{
public:
    CList();
    void Link(CList*& pndHead);
	void Unlink(CList*& pndHead);
	CList* Next() {return m_pndNext;}
	CList* Prev() {return m_pndPrev;}
private:
    CList* m_pndPrev;
	CList* m_pndNext;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\trapreg.h ===
#ifndef _trapreg_h
#define _trapreg_h

#include "regkey.h"
#include "utils.h"

#define MAX_TRAP_SIZE       4096
#define THRESHOLD_COUNT     500
#define THRESHOLD_TIME      300


// Values for the SNMP_EVENTS\Parameters\Threshold flag
#define THROTTLE_RESET 0
#define THROTTLE_TRIPPED 1

// Values for the SNMP_EVENTS\Parameters\ThresholdEnabled flag
#define THROTTLE_DISABLED 0
#define THROTTLE_ENABLED 1

//***************************************************************************
// REGISTRY KEYS
//
// The following strings are registry keys. They should not be internationalized,
// so they are not in the string table.
//
//****************************************************************************
#define SZ_REGKEY_MICROSOFT _T("SOFTWARE\\Microsoft")
#define SZ_REGKEY_SOURCE_EVENTLOG _T("SYSTEM\\CurrentControlSet\\Services\\EventLog")
#define SZ_REGKEY_SNMP_EVENTS  _T("SOFTWARE\\Microsoft\\SNMP_EVENTS")

// These are subkeys under \SOFTWARE\Microsoft\SNMP_EVENTS
#define SZ_REGKEY_EVENTLOG _T("EventLog")
#define SZ_REGKEY_SOURCES _T("EventLog\\Sources")
#define SZ_REGKEY_CURRENTLY_OPEN _T("CurrentlyOpen")

#define SZ_REGKEY_SOURCE_ENTERPRISE_OID _T("EnterpriseOID")
#define SZ_REGKEY_SOURCE_APPEND _T("Append")

#define SZ_REGKEY_PARAMETERS _T("EventLog\\Parameters")
#define SZ_REGKEY_PARAMS _T("Parameters")
#define SZ_REGKEY_PARAMS_BASE_ENTERPRISE_OID _T("BaseEnterpriseOID")
#define SZ_REGKEY_PARAMS_TRIMFLAG _T("TrimFlag")
#define SZ_REGKEY_PARAMS_MAXTRAP_SIZE _T("MaxTrapSize")
#define SZ_REGKEY_PARAMS_TRIM_MESSAGE _T("TrimMessage")
#define SZ_REGKEY_PARAMS_THRESHOLD _T("Threshold")
#define SZ_REGKEY_PARAMS_THRESHOLDENABLED _T("ThresholdEnabled")
#define SZ_REGKEY_PARAMS_THRESHOLDCOUNT _T("ThresholdCount")
#define SZ_REGKEY_PARAMS_THRESHOLDTIME _T("ThresholdTime")

#define SZ_REGKEY_EVENT_COUNT _T("Count")
#define SZ_REGKEY_EVENT_TIME _T("Time")
#define SZ_REGKEY_EVENT_FULLID _T("FullID")
#define SZ_REGKEY_SOURCE_EVENT_MESSAGE_FILE _T("EventMessageFile")
#define SZ_NAME_REGVAL_TRANSLATOR_ENABLED _T("TranslatorEnabled")
#define SZ_NAME_REGVAL_REVISIONCOUNT _T("RevisionCount")
#define SZ_NAME_REGVAL_CONFIGTYPE _T("ConfigurationType")

#define SZ_REGVAL_YES "YES"
#define SZ_REGVAL_NO "NO"

//**********************************************************************
// The number of load steps that are performed in CTrapDlg::OnInitDialog
// This is the number of steps that will be reserved in the progress
// indicator for OnInitDialog
//*********************************************************************
#define LOAD_STEPS_IN_TRAPDLG 5

// 11 setup steps plus 10 steps for the four known event logs
#define LOAD_SETUP_STEP_COUNT 11
#define LOAD_LOG_ARRAY_STEP_COUNT 40
#define LOAD_STEP_COUNT (LOAD_SETUP_STEP_COUNT + LOAD_LOG_ARRAY_STEP_COUNT + LOAD_STEPS_IN_TRAPDLG)

class CDlgSaveProgress;
class CRegistryKey;
class CXEventSource;
class CBaseArray : public CObArray
{
public:
    CBaseArray() {}
    ~CBaseArray() {}
    void DeleteAll();
};

class CXEventSource;
class CXEventLog;

//The registry is made up of logs, that contain sources, that contain events
class CXMessage : public CObject
{
public:
    CXMessage(CXEventSource* pEventSource);
    CXEventSource*  m_pEventSource;
    DWORD           m_dwId;
    CString         m_sText;

    CXMessage& operator=(CXMessage& message);
    DWORD GetShortId() {return LOWORD(m_dwId); }
    void GetShortId(CString& sText);
    void GetSeverity(CString& sSeverity);
    void IsTrapping(CString& sIsTrapping);
    void SetAndCleanText(PMESSAGE_RESOURCE_ENTRY pEntry);
};



class CXMessageArray : private CBaseArray
{
public:
    CXMessageArray();
    ~CXMessageArray() {}
    void Initialize(CXEventSource* pEventSource) {m_pEventSource = pEventSource; }
	CXMessage* GetAt(int nIndex) {return (CXMessage*) CBaseArray::GetAt(nIndex); }
	CXMessage* operator[](int nIndex) {return (CXMessage*) CBaseArray::GetAt(nIndex); }
	void Add(CXMessage* pMessage) { CBaseArray::Add(pMessage); }	
	void RemoveAll() {CBaseArray::RemoveAll(); }
	void DeleteAll() {CBaseArray::DeleteAll(); }
    LONG GetSize() {return (LONG)CBaseArray::GetSize(); }
    SCODE LoadMessages();

    CXMessage* FindMessage(DWORD dwId);
    CXEventSource*  m_pEventSource;

private:
    BOOL m_bDidLoadMessages;
    SCODE GetNextPath(CString& sPathlist, CString& sPath);
};


class CXEvent : public CObject
{
public:
    CXEvent(CXEventSource* pEventSource);
    CXEvent(CXMessage* pMessage);
    ~CXEvent();
    CXEventSource*  m_pEventSource;
    DWORD           m_dwCount;
    DWORD           m_dwTimeInterval;
    CXMessage       m_message;

    SCODE Deserialize(CRegistryKey& regkeyParent, CString& sName);
    SCODE Serialize(CRegistryKey& regkeyParent);

    void GetName(CString& sText) {DecString(sText, m_message.m_dwId); }
    void GetCount(CString& sText);
    void GetTimeInterval(CString& sText);
};


class CXEventArray : public CBaseArray
{
public:
    ~CXEventArray() {}
	CXEvent* GetAt(int nIndex) {return (CXEvent*) CBaseArray::GetAt(nIndex); }
	CXEvent* operator[](int nIndex) {return (CXEvent*) CBaseArray::GetAt(nIndex); }
//	void Add(CXEvent* pEvent) { CBaseArray::Add(pEvent); }	
	void Add(CXEvent* pEvent);
	void RemoveAll() {CBaseArray::RemoveAll(); }
	void DeleteAll() {CBaseArray::DeleteAll(); }
    LONG GetSize() {return (LONG)CBaseArray::GetSize(); }

    SCODE Deserialize(CXEventSource* pEventSource);
    SCODE Serialize(CRegistryKey& regkeyParent);

    CXEvent* FindEvent(DWORD dwId);
    SCODE RemoveEvent(CXEvent* pEvent);
};


class CXEventSource  : public CObject
{
public:
    CXEventSource(CXEventLog* pEventLog, CString& sName);
    ~CXEventSource();

    // Public data members
    CXEventLog*      m_pEventLog;
	CString 	     m_sName;
    CXEventArray     m_aEvents;
    CXMessageArray   m_aMessages;
    CString          m_sLibPath;

    CXMessage* FindMessage(DWORD dwId) {return m_aMessages.FindMessage(dwId); }
    CXEvent* FindEvent(DWORD dwId) {return m_aEvents.FindEvent(dwId); }
    CXEventSource* FindEventSource(CString& sEventSource);

    SCODE Deserialize(CRegistryKey& regkeyParent);
    SCODE Serialize(CRegistryKey& regkeyParent);
    void GetEnterpriseOID(CString& sEnterpriseOID, BOOL bGetFullID=FALSE);
    SCODE LoadMessages() {return m_aMessages.LoadMessages(); }

private:
    SCODE GetLibPath(CRegistryKey& regkey);
};

// CObArray is declared a private base type to ensure strong typing.
class CXEventSourceArray : private CBaseArray
{
public:
    // Base array functionality public member functions.
    ~CXEventSourceArray() {DeleteAll(); }
	CXEventSource* GetAt(int nIndex) {return (CXEventSource*) CBaseArray::GetAt(nIndex); }
	CXEventSource* operator[](int nIndex) {return (CXEventSource*) CBaseArray::GetAt(nIndex); }
	void Add(CXEventSource* pEventSource) { CBaseArray::Add(pEventSource); }	
	void RemoveAll() {CBaseArray::RemoveAll(); }
	void DeleteAll() {CBaseArray::DeleteAll(); }
    LONG GetSize() {return (LONG)CBaseArray::GetSize(); }


    // Public members specific to CXEventSourceArray
    CXEventSource* FindEventSource(CString& sSource);
    LONG FindEvent(CString& sLog, CString& sSource, DWORD dwEventId);


    SCODE Deserialize(CXEventLog* pEventLog);
    SCODE Serialize(CRegistryKey& regkey);
};




class CXEventLog : public CObject
{
public:
    CXEventLog(CString& sName) {m_sName = sName;}
    CXEventSourceArray m_aEventSources;
    CString m_sName;


    SCODE Deserialize();
    SCODE Serialize(CRegistryKey& regkey);
    CXEventSource* FindEventSource(CString& sEventSource);
};

inline CXEventSource* CXEventLog::FindEventSource(CString& sEventSource)
{
    return m_aEventSources.FindEventSource(sEventSource);
}


class CXEventLogArray : private CBaseArray
{
public:
    // Base array functionality public member functions.
    CXEventLogArray() {}
    ~CXEventLogArray() {DeleteAll(); }
	CXEventLog* GetAt(int nIndex) {return (CXEventLog*) CBaseArray::GetAt(nIndex); }
	CXEventLog* operator[](int nIndex) {return (CXEventLog*) CBaseArray::GetAt(nIndex); }
	void Add(CXEventLog* pEventLog) { CBaseArray::Add(pEventLog); }	
	void RemoveAll() {CBaseArray::RemoveAll(); }
	void DeleteAll() {CBaseArray::DeleteAll(); }
    LONG GetSize() {return (LONG)CBaseArray::GetSize(); }


    SCODE Deserialize();
    SCODE Serialize();

    CXEventSource* FindEventSource(CString& sLog, CString& sEventSource);
};



class CTraps
{
public:
    CXEventLogArray m_aEventLogs;
    SCODE Serialize();
    SCODE Deserialize();
};


class CTrapParams
{
public:
    CTrapParams();
    SCODE Serialize();
    SCODE Deserialize();
    SCODE ResetExtensionAgent();
    BOOL ThrottleIsTripped();

    CString m_sBaseEnterpriseOID;
    CString m_sSupportedView;
    CString m_sTracefileName;
    DWORD   m_dwTraceLevel;

    // Data members for the "limit" section of the settings dialog
    struct {
        BOOL    m_bTrimFlag;            // Limit trap length
        BOOL    m_bTrimMessages;        // Trim messages first
        DWORD   m_dwMaxTrapSize;        // Trap length (bytes)
    }m_trapsize;

    // Data members for the "throttle" section of the settings dialog
    struct {
        long m_nTraps;
        long m_nSeconds;
        BOOL m_bIsEnabled;
    }m_throttle;
};

class CTrapReg
{
public:
    CTrapReg();
    ~CTrapReg();
    SCODE Connect(LPCTSTR pszComputerName, BOOL bIsReconnecting = FALSE);
    SCODE Serialize();
    SCODE Deserialize();
    SCODE LockRegistry();
    void UnlockRegistry();
    SCODE SetConfigType(DWORD dwConfigType);
    DWORD GetConfigType() {return m_dwConfigType; }
    void SetApplyButton(CButton *pbtnApply) { m_pbtnApply = pbtnApply; }
    void SetDirty(BOOL bDirty);

    inline BOOL SourceHasTraps(CString& sSource);

    // Public data members.
    CRegistryKey m_regkeySource;        // SYSTEM\CurrentControlSet\Services\EventLogs
    CRegistryKey m_regkeySnmp;          // SOFTWARE\Microsoft\SNMP_EVENTS
    CRegistryKey m_regkeyEventLog;
    CXEventLogArray m_aEventLogs;
    CTrapParams m_params;
    CDlgSaveProgress* m_pdlgSaveProgress;
    CDlgSaveProgress* m_pdlgLoadProgress;
    LONG m_nLoadStepsPerSource;
    LONG m_nLoadStepsPerLog;
    LONG m_nLoadSteps;
    BOOL m_bShowConfigTypeBox;
    BOOL m_bRegIsReadOnly;
    BOOL m_bIsDirty;
    BOOL m_bSomeMessageWasNotFound;
    CString m_sComputerName;
    CButton *m_pbtnApply;

private:
    LONG GetSaveProgressStepCount();
    SCODE BuildSourceHasTrapsMap();
    BOOL m_bNeedToCloseKeys;
    CMapStringToPtr m_mapSourceHasTraps;
    BOOL m_bDidLockRegistry;
    DWORD m_dwConfigType;
};




extern CTrapReg g_trapreg;

enum {
    CONFIG_TYPE_DEFAULT = 0,
    CONFIG_TYPE_CUSTOM,
    CONFIG_TYPE_DEFAULT_PENDING
};


// Error failure values.
enum
{
    E_REGKEY_NOT_FOUND = -1000,
    E_REG_CANT_CONNECT,
    E_REGKEY_NOT_INSTALLED,
    E_REGKEY_CANT_OPEN,
    E_REGKEY_NO_CREATE,
    E_REG_NOT_INSTALLED,
    E_REGKEY_LOST_CONNECTION,
    E_ACCESS_DENIED,
    E_MESSAGE_NOT_FOUND


};

// Success status codes
enum
{
    S_NO_EVENTS = 1000,
    S_NO_SOURCES,
    S_SAVE_CANCELED,
    S_LOAD_CANCELED
};


//*******************************************************************
// CTrapReg::SourceHasTraps
//
// Check to see if traps have been configured for the specified event
// source.
//
// Parameters:
//      CString& sEventSource
//          The name of the event source.
//
// Returns:
//      TRUE if the event source has traps, FALSE otherwise.
//
//********************************************************************
inline BOOL CTrapReg::SourceHasTraps(CString& sEventSource)
{
    LPVOID pVoid;
	CString tmp(sEventSource);
	tmp.MakeUpper();
    return m_mapSourceHasTraps.Lookup(tmp, pVoid);
}


#endif //_trapreg_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\tcsource.cpp ===
#include "stdafx.h"
#include "source.h"
#include "tcsource.h"
#include "regkey.h"
#include "utils.h"
#include "globals.h"
#include "trapreg.h"


/////////////////////////////////////////////////////////////////////////////
// CTcSource

CTcSource::CTcSource()
{
}

CTcSource::~CTcSource()
{
}


BEGIN_MESSAGE_MAP(CTcSource, CTreeCtrl)
	//{{AFX_MSG_MAP(CTcSource)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTcSource message handlers



void CTcSource::LoadImageList()
{
    m_ImageList.Create(16, 16, ILC_COLOR | ILC_MASK, 2, 0);

	CBitmap* pFolder;

    pFolder = new CBitmap;
    pFolder->LoadBitmap(IDB_FOLDERCLOSE);
    m_ImageList.Add(pFolder, (COLORREF)0xff00ff);
	delete pFolder;

    pFolder = new CBitmap;
    pFolder->LoadBitmap(IDB_FOLDEROPEN);
    m_ImageList.Add(pFolder, (COLORREF)0xff00ff);

	delete pFolder;

    SetImageList(&m_ImageList, TVSIL_NORMAL);	
}	

SCODE CTcSource::LoadTreeFromRegistry()
{
    TV_INSERTSTRUCT TreeCtrlItem;
    TreeCtrlItem.hInsertAfter = TVI_LAST;

	// Iterate through each of the event logs and add each log to the tree.
	LONG nLogs = g_reg.m_aEventLogs.GetSize();
    for (LONG iLog=0; iLog < nLogs; ++iLog)
    {
        CXEventLog* pEventLog = g_reg.m_aEventLogs[iLog];

        TreeCtrlItem.hParent = TVI_ROOT;
        TreeCtrlItem.item.pszText = (LPTSTR)(LPCTSTR)pEventLog->m_sName;
        TreeCtrlItem.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
        TreeCtrlItem.item.iImage = 0;
        TreeCtrlItem.item.iSelectedImage = 0;
        TreeCtrlItem.item.lParam = (LPARAM) pEventLog;
        
        HTREEITEM htiParent = InsertItem(&TreeCtrlItem);

        TreeCtrlItem.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
        TreeCtrlItem.hParent = htiParent;
        TreeCtrlItem.item.iImage = 0;
        TreeCtrlItem.item.iSelectedImage = 1;

        // Insert each source as a child.
        LONG nSources = pEventLog->m_aEventSources.GetSize();
        for (LONG iSource = 0; iSource < nSources; ++iSource) {
            CXEventSource* pEventSource = pEventLog->m_aEventSources.GetAt(iSource);
            TreeCtrlItem.item.pszText = (LPTSTR)(LPCTSTR)pEventSource->m_sName;
            TreeCtrlItem.item.lParam = (LPARAM) pEventSource;
            InsertItem(&TreeCtrlItem);
        }
    }
    SortChildren(NULL);
	return S_OK;
}



SCODE CTcSource::CreateWindowEpilogue()
{
	LoadImageList();
	LoadTreeFromRegistry();
	return S_OK;
}


//******************************************************************
// CTcSource::GetSelectedEventSource
//
// Get name of the event source and log for the currently selected
// event source. 
//
// Parameters:
// 		CString& sLog
//			This is where the event log name is returned.
//
// 		CString& sEventSource
//			This is where the name of the event source (application)
//			is returned.
//
// Returns:
//		SCODE
//			S_OK if an event source was selected and the log and event source
//			names are returned.
//
//			E_FAIL if no event source was selected.  The log and event source
//			names are returned as empty when this occurs.
//
//******************************************************************
CXEventSource* CTcSource::GetSelectedEventSource()
{
    HTREEITEM htiParent, htiSelected; 

    // Get the selected item.
    htiSelected = GetSelectedItem();
    if (htiSelected == NULL)
        return NULL;

	// If the selected item is an event source (application), then
	// its parent should be the log.  To get the log name, we must
	// get the parent name.
    htiParent = GetParentItem(htiSelected);
    if (htiParent == NULL)
        return NULL;

	// The application name is the selected item.
    TV_ITEM tvi;
    tvi.hItem = htiSelected;
    tvi.mask = TVIF_HANDLE | TVIF_PARAM;    
    if (GetItem(&tvi) == FALSE)
        return NULL;
    return (CXEventSource*) (void*) tvi.lParam;
}





//******************************************************************
// CTcSource::Find
//
// Find the specified event source in the tree.
//
// Parameters:
//		CString& sText
//			A string containing the text to search for.
//
//		BOOL bWholeWord
//			TRUE if this is a "whole word" search.  False if it
//			is OK to match a partial word.
//
//		BOOL bMatchCase
//			TRUE if a case-sensitive comparison should be used.
//
// Returns:
//		BOOL
//			TRUE if the string was found, FALSE otherwise.  If the specified
//			text is found, then the selection is set on the corresponding
//			tree item.
//
//******************************************************************
BOOL CTcSource::Find(CString& sText, BOOL bWholeWord, BOOL bMatchCase)
{    
    // Search the source tree for sText. We are only looking at the source
    // names, not the types.
                                
    HTREEITEM hCurrentItem, hStartItem, hSourceItem, hRootItem;
    TV_ITEM tvItem;
    CString sSource;
    TCHAR szBuffer[256];
    BOOL bItemFound = FALSE, bCompleteLoop = FALSE;

    // Get the selected item and keep track of it.
    hCurrentItem = GetSelectedItem();
    if (hCurrentItem == NULL)
    {
        // Nothing selected; get the root.
        hCurrentItem = GetRootItem();
        if (hCurrentItem == NULL)
            return FALSE; 
    }    
    hStartItem = hCurrentItem;

    // Loop until we find a match or we are back where we started.
    while (!bItemFound && !bCompleteLoop)
    {
         hSourceItem = NULL;

        // Get the next item.
        
        // Current item is root; get the first child.
        hRootItem = GetParentItem(hCurrentItem);
        if (hRootItem == NULL)
            hSourceItem = GetChildItem(hCurrentItem);
                
        // Current item is a source; get the next sibling.
        else
        {
            hSourceItem = GetNextItem(hCurrentItem, TVGN_NEXT);
            // No sibling; get the parent and set it as the current item.
            if (hSourceItem == NULL)
            {
                 hRootItem = GetParentItem(hCurrentItem);
                if (hRootItem == NULL)
                    return FALSE;  // No parent; something is wrong.
                hCurrentItem = hRootItem;
            }
        }

        // We have a source; get it and compare.
        if (hSourceItem != NULL)
        {
            hCurrentItem = hSourceItem;

            tvItem.mask = TVIF_HANDLE | TVIF_TEXT;
            tvItem.hItem = hSourceItem;
            tvItem.pszText = szBuffer;
            tvItem.cchTextMax = 256;
            if (GetItem(&tvItem) == FALSE)
                return FALSE; // Something is wrong.
            sSource = szBuffer;

            // Compare the whole word.
            if (bWholeWord)
            {
                int nRetVal;

                // No case compare.
                if (bMatchCase)
                    nRetVal = sSource.Compare(sText);
                // Case compare
                else
                    nRetVal = sSource.CompareNoCase(sText);                    

                if (nRetVal == 0)
                    bItemFound = TRUE;
            }

            // Look for a substring.
            else
            {
                // Make everything upper.
                if (!bMatchCase)
                {
                    sSource.MakeUpper();
                    sText.MakeUpper();
                }

                if (sSource.Find(sText) >= 0)
                    bItemFound = TRUE;
            }
        }        

        // Get the next root.
        else
        {    
            hRootItem = GetNextItem(hCurrentItem, TVGN_NEXT);
            // No more roots in the tree; go to the top of the tree.
            if (hRootItem == NULL)
                hCurrentItem = GetRootItem();
            else
                hCurrentItem = hRootItem;
        }

        if (hCurrentItem == hStartItem)
            bCompleteLoop = TRUE;
    }

    // Found a match; select it.
    if (bItemFound)
    {
        SelectItem(hCurrentItem);
        EnsureVisible(hCurrentItem);
        SetFocus();
        return TRUE;
    }

    return FALSE;            
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\trapdlg.h ===
//******************************************************************
// trapdlg.h
//
// This is the header file for the main dialog for eventrap.
//
// Author: Larry A. French
//
// History:
//      December-1995       SEA - Wrote it
//          SEA - wrote it.
//
//      20-Febuary-1996     Larry A. French
//          Totally rewrote it to fix the spagetti code and huge
//          methods.  The original author seemed to have little or
//          no ability to form meaningful abstractions.
//
//
// Copyright (C) 1995, 1996 Microsoft Corporation.  All rights reserved.
//******************************************************************

#ifndef TRAPDLG_H
#define TRAPDLG_H

#include "regkey.h"
#include "source.h"         // The message source container
#include "tcsource.h"       // The message source tree control
#include "lcsource.h"       // The message source list control
#include "lcevents.h"
#include "trapreg.h"
#include "layout.h"
#include "export.h"


class CMainLayout;
class CExtendedLayout;




/////////////////////////////////////////////////////////////////////////////
// CEventTrapDlg dialog

class CEventTrapDlg : public CDialog
{
// Construction
public:
	CEventTrapDlg(CWnd* pParent = NULL);   // standard constructor
	~CEventTrapDlg();

    BOOL IsExtendedView() {return m_bExtendedView; }
    void NotifySourceSelChanged();

	CSource     m_source;           // The message source


// Dialog Data
	//{{AFX_DATA(CEventTrapDlg)
	enum { IDD = IDD_EVNTTRAPDLG };
	CButton	m_btnApply;
	CButton	m_btnExport;
	CLcEvents	m_lcEvents;
	CTcSource	m_tcSource;
    CStatic m_statLabel0;
    CStatic	m_statLabel1;
	CStatic	m_statLabel2;
	CLcSource m_lcSource;
	CButton	m_btnOK;
	CButton	m_btnCancel;
	CButton	m_btnSettings;
	CButton	m_btnProps;
	CButton	m_btnView;
	CButton	m_btnRemove;
	CButton	m_btnAdd;
	CButton	m_btnFind;
	CButton	m_btnConfigTypeBox;
    CButton m_btnConfigTypeCustom;
    CButton m_btnConfigTypeDefault;
	//}}AFX_DATA



// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEventTrapDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CEventTrapDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnDestroy();
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnAdd();
	afx_msg void OnProperties();
	afx_msg void OnSettings();
	virtual void OnOK();
	afx_msg void OnDblclkEventlist(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnclickEventlist(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnView();
	afx_msg void OnRemove();
	afx_msg void OnFind();
	afx_msg void OnSelchangedTvSources(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnclickLvSources(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclkLvSources(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnButtonExport();
	virtual void OnCancel();
	afx_msg void OnKeydownEventlist(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemchangedEventlist(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemchangedLvSources(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnRadioCustom();
	afx_msg void OnRadioDefault();
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg BOOL OnHelpInfo(HELPINFO*);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnApply();
	afx_msg void OnDefault();
	afx_msg void OnTvSourcesExpanded(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

protected:
    HICON m_hIcon;

private:
    void CheckEventlistSelection();
    void CheckSourcelistSelection();
    void UpdateDialogTitle();


    BOOL m_bSaveInProgress;
	BOOL m_bExtendedView;
    CLayout m_layout;
    CString m_sExportTitle;
    CDlgExport m_dlgExport;
    CString m_sBaseDialogCaption;
};


#endif //TRAPDLG_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\utils.cpp ===
#include "stdafx.h"
#include "utils.h"
#include "globals.h"
#include "trapreg.h"

//***************************************************************************
//
//  MapEventToSeverity
//
//  Extract the severity field from the event ID and convert it to a
//  string equivallent.
//
//  Parameters:
//		DWORD dwEvent
//			The full event ID
//
//		CString& sResult
//			The severity code string is returned here.
//
//  Returns:
//		The severity code string is returned via sResult.
//
//  Status:
//
//***************************************************************************
void MapEventToSeverity(DWORD dwEvent, CString& sResult)
{
	//
	//  Values are 32 bit event ID values layed out as follows:
	//
	//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
	//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
	//  +---+-+-+-----------------------+-------------------------------+
	//  |Sev|C|R|     Facility          |               Code            |
	//  +---+-+-+-----------------------+-------------------------------+
	//
	//  where
	//
	//      Sev - is the severity code
	//
	//          00 - Success
	//          01 - Informational
	//          10 - Warning
	//          11 - Error
	//
	//      C - is the Customer code flag
	//
	//      R - is a reserved bit
	//
	//      Facility - is the facility code
	//
	//      Code - is the facility's status code
	//
	//
	// Define the facility codes

	static UINT auiResource[4] =
		{IDS_EVENT_SEV_SUCCESS,
		 IDS_EVENT_SEV_INFORMATIONAL,
		 IDS_EVENT_SEV_WARNING,
		 IDS_EVENT_SEV_ERROR
		 };
	
	int iSeverity = (dwEvent >> 30) & 3;
	sResult.LoadString(auiResource[iSeverity]);
}




//********************************************************************************
// FindSubstring
//
// Find a substring in some text and return an index to the starting
// position of the string if it is found.
//
// Parameters:
//		LPCSTR pszTemplate
//			Pointer to the string to find.
//
//		LPCSTR pszText
//			Pointer to the text that will be searched
//			for the template string.
//
// Returns:
//		An index to the location of the substring within the text if it
//		is found, otherwise -1.
//
//********************************************************************************
LONG FindSubstring(LPCTSTR pszTemplate, LPCTSTR pszText)
{
	if (*pszTemplate == 0) {
		// An empty template string matches anything, so return zero.
		// This should never really happen since it doesn't make much
		// sense to search for nothing.
		return 0;
	}

	LPCTSTR pszTextStart = pszText;
	while (*pszText) {
		// Iterate through the character positions in the text
		// and return the index to the starting char in the string
		// if it is found.
		LPCTSTR pch1 = pszTemplate;
		LPCTSTR pch2 = pszText;

        while (*pch1 && (*pch1 == *pch2))
        {
			++pch1;
			++pch2;
		}

		if (*pch1 == 0) {
			// We reached the end of the template string, so there
			// must have been a match.
			return (LONG)(pszText - pszTextStart);
		}

		++pszText;
	}
	// Failed to find the substring
	return -1;
}


//********************************************************************************
// FindWholeWord
//
// Find a whole word in some text and return an index to the starting
// position of the whole word if it is found.  Whole word means the
// specified template string followed by a whitespace or end of string.
//
// Parameters:
//		LPCSTR pszTemplate
//			Pointer to the "whole word" string to find.
//
//		LPCSTR pszText
//			Pointer to the text that will be searched
//			for the template string.
//
// Returns:
//		An index to the location of the "whole word" substring within the text if it
//		is found, otherwise -1.
//
//********************************************************************************
LONG FindWholeWord(LPCTSTR pszTemplate, LPCTSTR pszText)
{
	if (*pszTemplate == 0) {
		// An empty search string matches anything, so return the index
		// of the first character.
		return 0;
	}


	// Iterate through each character position checking for a whole-word
	// match at each position.
	LONG nchTemplate = _tcslen(pszTemplate);
	LPCTSTR pszTextStart = pszText;
	LPCTSTR pchTextLimit = pszText + (_tcslen(pszText) - nchTemplate);
	while (pszText <= pchTextLimit) {

		// Check to see if the word is contained anywhere within the text
		INT iPos = FindSubstring(pszTemplate, pszText);
		if (iPos == -1) {
			return -1;
		}

		// Point at the location of the template string within the text
		pszText += iPos;

		// Get the prefix character
		INT ichPrefix;
		if (pszText == pszTextStart) {
			// Beginning of line counts as white space.
			ichPrefix = _T(' ');
		}
		else {
			ichPrefix = *(pszText - 1);
		}

		// Get the suffix character.
		INT ichSuffix = pszText[nchTemplate];
		if (ichSuffix == 0) {
			// End of line counts as whitespace
			ichSuffix = _T(' ');
		}

		// To match a whole word, the word must be bounded on either side
		// by whitespace.
		if (isspace(ichPrefix) && isspace(ichSuffix)) {
			return (LONG)(pszText - pszTextStart);
		}

		// Bump the text pointer to the next position so we don't do the
		// same thing all over again.
		++pszText;
	}
	return -1;
}
	

void DecString(CString& sValue, int iValue)
{
    // 32 bytes should be enough to hold any value
    TCHAR szValue[32];
    _itot(iValue, szValue, 10);
    sValue = szValue;
}


void DecString(CString& sValue, long lValue)
{
    // 32 bytes should be enough to hold any value
    TCHAR szValue[32];
    _ltot(lValue, szValue, 10);
    sValue = szValue;
}


void DecString(CString& sValue, DWORD dwValue)
{
    TCHAR szValue[32];
    _ultot(dwValue, szValue, 10);
    sValue = szValue;
}




CList::CList()
{
    m_pndPrev = this;
	m_pndNext = this;
}

void CList::Link(CList*& pndHead)
{
    if (pndHead == NULL)
        pndHead = this;
    else
    {

        m_pndNext = pndHead;
	    m_pndPrev = pndHead->m_pndPrev;
	    m_pndPrev->m_pndNext = this;
	    m_pndNext->m_pndPrev = this;
	}
}

void CList::Unlink(CList*& pndHead)
{
    if (pndHead == this)
	{
	    if (m_pndNext == this)
		    pndHead = NULL;
		else
	        pndHead = m_pndNext;
	}
	
    m_pndPrev->m_pndNext = m_pndNext;
	m_pndNext->m_pndPrev = m_pndPrev;
}




//***************************************************************
// GetFormattedValue
//
// Convert a value to ASCII and insert thousand separator characters
// into resulting value string.
//
// Parameters:
//      CString& sValueDst
//          The place to return the converted value.
//
//      LONG lValue
//          The value to convert.
//
//*****************************************************************
void GetFormattedValue(CString& sValueDst, LONG lValue)
{
    CString sValueSrc;
    DecString(sValueSrc, lValue);

    LONG nch = sValueSrc.GetLength();
    LPCTSTR pszSrc = sValueSrc;

    // Get a buffer as large as the source string plus the largest number of commas
    // plus one for the sign, one for the null terminator plus one character for slop.
    LPTSTR pszDst = sValueDst.GetBuffer(nch + nch / 3 + 3);

    // Copy any leading sign character.
    if ((*pszSrc == _T('+')) || (*pszSrc == _T('-'))) {
        *pszDst++ = *pszSrc++;
        --nch;
    }

    // Now copy the rest of the number and insert thousand separator characters in
    // the appropriate positions.
    LONG nchInitial = nch;
    while (nch > 0) {
        if ((nch % 3) == 0) {
            if (nch != nchInitial) {
                *pszDst++ = g_chThousandSep;
            }
        }
        *pszDst++ = *pszSrc++;
        --nch;
    }
    *pszDst = _T('\0');

    sValueDst.ReleaseBuffer();
}




//**************************************************************
// GenerateRangeMessage
//
// Generate a message indicating that the user should enter a value
// between some numbers nMin and nMax.
//
// Parameters:
//      CString& sMessage
//          The place to return the message.
//
//      LONG nMin
//          The minimum valid value in the range.
//
//      LONG nMax
//          The maximum valid value in the range.
//
//****************************************************************
void GenerateRangeMessage(CString& sMessage, LONG nMin, LONG nMax)
{
    CString sText;

    sMessage.LoadString(IDS_RANGE_MESSAGE_PREFIX);
    sMessage += _T(' ');

    GetFormattedValue(sText, nMin);
    sMessage += sText;
    sMessage += _T(' ');

    sText.LoadString(IDS_RANGE_VALUE_SEPARATOR);
    sMessage += sText;
    sMessage += _T(' ');


    GetFormattedValue(sText, nMax);
    sMessage += sText;

    sText.LoadString(IDS_SENTENCE_TERMINATOR);
    sMessage += sText;
}



//***************************************************************************
// GetThousandSeparator
//
// Get the thousand separator character for the current locale.
//
// Parameters:
//      TCHAR* pchThousandSep
//          Pointer to the place to return the thousand separator character.
//
// Returns:
//      SCODE
//          S_OK if the thousand separator was returned.
//          E_FAIL if the thousand separator was not returned.
//
//**************************************************************************
SCODE GetThousandSeparator(TCHAR* pchThousandSep)
{
// Digit + separator + 3 digits + decimal + two digits + null terminator  + 4 slop
#define MAX_CHARS_THOUSAND 12
    CString sValue;
    LPTSTR pszValue = sValue.GetBuffer(MAX_CHARS_THOUSAND);

    GetNumberFormat(NULL, 0, _T("1000"), NULL, pszValue, MAX_CHARS_THOUSAND);
    sValue.ReleaseBuffer();

    TCHAR ch = sValue[1];
    if (isdigit(ch)) {
        return E_FAIL;
    }
    *pchThousandSep = ch;
    return S_OK;
}



//***********************************************************************
// IsDecimalInteger
//
// This function tests a string to see whether or not it contains a
// valid integer expression.
//
// Parameters:
//      LPCTSTR pszValue
//          Pointer to the string to test.
//
// Returns:
//      BOOL
//          TRUE = The string contained a valid integer expression.
//          FALSE = The string did not contain a valid integer expression.
//
//***********************************************************************
BOOL IsDecimalInteger(LPCTSTR pszValue)
{
    // Accept leading white space
    while (iswspace(*pszValue)) {
        ++pszValue;
    }

    // Accept a leading plus or minus sign
    if ((*pszValue == _T('+'))  ||  (*pszValue == _T('-'))) {
        ++pszValue;
    }

    // Skip a string of consecutive digits with embedded thousand separators
    BOOL bSawThousandSep = FALSE;
    LONG nDigits = 0;
    while (TRUE) {
        if (*pszValue == g_chThousandSep) {
            if (nDigits > 3) {
                return FALSE;
            }

            bSawThousandSep = TRUE;
            nDigits = 0;
        }
        else if (isdigit(*pszValue)) {
            ++nDigits;
        }
        else {
            break;
        }
        ++pszValue;
    }

    if (bSawThousandSep && nDigits != 3) {
        // If a thousand separater was encountered, then there must be
        // three digits to the right of the last thousand separator.
        return FALSE;
    }


    // Accept trailing whitespace
    if (iswspace(*pszValue)) {
        ++pszValue;
    }


    if (*pszValue == _T('\0')) {
        // We reached the end of the string, so it must have been a decimal integer.
        return TRUE;
    }
    else {
        // We did not rech the end of the string, so it couldn't have been a valid
        // decimal integer value.
        return FALSE;
    }
}


//***************************************************************************
// AsciiToLong
//
// This function first validates a string to make sure that it is a properly
// formatted integer expression, and then converts it to a long.  Any embedded
// characters, such as the thousand separator, are stripped out before the
// conversion is done.
//
//
// Parameters:
//      LPCTSTR pszValue
//          Pointer to the string value to convert.
//
//      LONG* plResult
//          Pointer to the place to store the result.
//
// Returns:
//      SCODE
//          S_OK = The string contained a valid integer and the converted
//                 value was returned via plResult.
//          E_FAIL = The string did not contain a properly formatted integer
//                   expression.
//
//
//**************************************************************************
SCODE AsciiToLong(LPCTSTR pszValue, LONG* plResult)
{
    if (!IsDecimalInteger(pszValue)) {
        return E_FAIL;
    }


    // Strip out any superfluous characters, such as the thousand separator
    // before converting from ascii to long.
    CString sStrippedValue;
    LPTSTR pszDst = sStrippedValue.GetBuffer(_tcslen(pszValue) + 1);
    TCHAR ch;
    while (ch = *pszValue++) {
        if (isdigit(ch) || ch==_T('+') || ch==_T('-')) {
            *pszDst++ = ch;
        }
    }
    *pszDst = 0;
    sStrippedValue.ReleaseBuffer();

    *plResult = _ttol(sStrippedValue);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpevnt\evntwin\trapreg.cpp ===
//***********************************************************************
// trapreg.cpp
//
// This file contains the implementation of the classes for the objects
// that are read from the registry, manipulated and written back to the
// registry.
//
// Author: Larry A. French
//
// History:
//      20-Febuary-1996     Larry A. French
//          Totally rewrote it to fix the spagetti code and huge
//          methods.  The original author seemed to have little or
//          no ability to form meaningful abstractions.
//
//
// Copyright (C) 1995, 1996 Microsoft Corporation.  All rights reserved.
//
//************************************************************************
//
// Some of the interesting class implementations contained here are:
//
// CTrapReg
//      This is the container class for the registry information.  It is
//      composed of the configuration "parameters" and an EventLog array.
//
// CXEventLogArray
//      This class implements an array of CXEventLog objects, where the
//      event logs are "application", "security", "system" and so on.
//
// CXEventLog
//      This class implements a single event log.  All information
//      relevent to an event log can be accesssed through this class.
//
// CXEventSourceArray
//      Each event log contains an event source array.  The event source
//      represents an application that can generate an Event.
//
// CXEventSource
//      An eventsource represents an application that can generate some
//      number of event-log events.  The event source contains a CXEventArray
//      and CXMessageArray.  The CXEventArray contains all the events
//      that will be converted to traps.  The CXMessageArray contains all the
//      possible messages that a particular event source can generate.
//
// CXMessageArray
//      This class implements an array of CXMessage objects.
//
// CXMessage
//      This class contains all the information relevent to a message
//      that a message source can generate.
//
//
// CXEventArray
//      This class implements an array of CXEvent objects.
//
// CXEvent
//      This class represents an event that the user has selected to be
//      converted to a trap.  The event contains a message plus some
//      additional information.
//
//**************************************************************************
// The Registry:
//
// These classes are loaded from the registry and written back to the
// registry when the user clicks OK.  To understand the format of the
// registry, use the registry editor while looking though the "Serialize"
// and "Deserialize" member function for each of these classes.
//**************************************************************************


#include "stdafx.h"
#include "trapreg.h"
#include "regkey.h"
#include "busy.h"
#include "utils.h"
#include "globals.h"
#include "utils.h"
#include "dlgsavep.h"
#include "remote.h"

///////////////////////////////////////////////////////////////////
// Class: CBaseArray
//
// This class extends the CObArray class by adding the DeleteAll
// method.
//
//////////////////////////////////////////////////////////////////

//****************************************************************
// CBaseArray::DeleteAll
//
// Delete all the objects contained in this array.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//****************************************************************
void CBaseArray::DeleteAll()
{
    LONG nObjects = (LONG)GetSize();
    for (LONG iObject = nObjects-1; iObject >= 0; --iObject) {
        CObject* pObject = GetAt(iObject);
        delete pObject;
    }

    RemoveAll();
}


/////////////////////////////////////////////////////////////////////////////////////
// Class: CTrapReg
//
// This is the container class for all the registry information for eventrap.exe.
//
////////////////////////////////////////////////////////////////////////////////////
CTrapReg::CTrapReg() : m_pdlgLoadProgress(FALSE), m_pbtnApply(FALSE)
{
    m_bNeedToCloseKeys = FALSE;
    m_pdlgSaveProgress = NULL;
    m_pdlgLoadProgress = NULL;
    m_bDidLockRegistry = FALSE;
    m_bRegIsReadOnly = FALSE;
    SetDirty(FALSE);
    m_nLoadSteps = LOAD_STEPS_IN_TRAPDLG;

    m_bShowConfigTypeBox = TRUE;
    m_dwConfigType = CONFIG_TYPE_CUSTOM;
}

CTrapReg::~CTrapReg()
{
    delete m_pdlgSaveProgress;
    delete m_pdlgLoadProgress;


    if (!g_bLostConnection) {
        if (m_bDidLockRegistry) {
            UnlockRegistry();
        }

        if (m_bNeedToCloseKeys) {
            m_regkeySource.Close();
            m_regkeySnmp.Close();
            m_regkeyEventLog.Close();
        }
    }
}




//*********************************************************************************
// CTrapReg::SetConfigType
//
// Set the configuration type to CONFIG_TYPE_CUSTOM or CONFIG_TYPE_DEFAULT
// When the configuration type is changed, the change is reflected in the
// registry immediately so that the config tool can know whether or not it
// should update the event to trap configuration.
//
// Parameters:
//      DWORD dwConfigType
//          This parameter must be CONFIG_TYPE_CUSTOM or CONFIG_TYPE_DEFAULT.
//
// Returns:
//      SCODE
//          S_OK if the configuration type was set, otherwise E_FAIL.
//
//*********************************************************************************
SCODE CTrapReg::SetConfigType(DWORD dwConfigType)
{
    ASSERT(dwConfigType==CONFIG_TYPE_CUSTOM || dwConfigType==CONFIG_TYPE_DEFAULT_PENDING);
    if (dwConfigType != m_dwConfigType) {
        SetDirty(TRUE);
    }
    m_dwConfigType = dwConfigType;
    return S_OK;
}





//*********************************************************************************
// CTrapReg::LockRegistry
//
// Lock the registry to prevent two concurrent edits of the event-to-trap configuration
// information.
//
// Parameters:
//      None.
//
// Returns:
//      SCODE
//          S_OK if successful.
//          E_FAIL if the configuration information was already locked.
//          E_REGKEY_NO_CREATE if the "CurrentlyOpen" registry key can't
//          be created.
//
//**********************************************************************************
SCODE CTrapReg::LockRegistry()
{
    if (g_bLostConnection) {
        return E_REGKEY_LOST_CONNECTION;
    }

    CRegistryKey regkey;
    if (m_regkeyEventLog.GetSubKey(SZ_REGKEY_CURRENTLY_OPEN, regkey)) {
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }

        if (AfxMessageBox(IDS_ERR_REGISTRY_BUSY, MB_YESNO | MB_ICONSTOP | MB_DEFBUTTON2) == IDNO)
        {
            regkey.Close();
            return E_FAIL;
        }
    }


    // Create the "CurrentlyOpen" key as a volatile key so that it will disappear the next
    // time the machine is restarted in the event that the application that locked the
    // event-to-trap configuration crashed before it could clear this lock.
    if (!m_regkeyEventLog.CreateSubKey(SZ_REGKEY_CURRENTLY_OPEN, regkey, NULL, NULL, TRUE)) {
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }

        AfxMessageBox(IDS_WARNING_CANT_WRITE_CONFIG, MB_OK | MB_ICONSTOP);
        return E_REGKEY_NO_CREATE;
    }
    regkey.Close();
    m_bDidLockRegistry = TRUE;
    return S_OK;
}



//***********************************************************************
// CTrapReg::UnlockRegistry
//
// Unlock the event-to-trap configuration so that others can edit it.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//***********************************************************************
void CTrapReg::UnlockRegistry()
{
    m_regkeyEventLog.DeleteSubKey(SZ_REGKEY_CURRENTLY_OPEN);
}




 	

//***********************************************************************
// CTrapReg::Connect
//
// Connect to a registry.  The registry may exist on a remote computer.
//
// Parameters:
//      LPCTSTR pszComputerName
//          The computer who's registry you want to edit.  An empty string
//          specifies a request to connect to the local machine.
//
// Returns:
//      SCODE
//          S_OK if the connection was made.
//          E_FAIL if an error occurred.  In this event, the appropriate
//          error message boxes will have already been displayed.
//
//***********************************************************************
SCODE CTrapReg::Connect(LPCTSTR pszComputerName, BOOL bIsReconnecting)
{
    SCODE sc;

    g_bLostConnection = FALSE;

    if (pszComputerName) {
        m_sComputerName = pszComputerName;
    }

    // There are eight steps here, plus there are three initial steps in
    // CTrapReg::Deserialize.  After that the step count will be reset
    // and then stepped again for each log where each log will have
    // ten sub-steps.
    if (!bIsReconnecting) {
        m_pdlgLoadProgress->SetStepCount(LOAD_STEP_COUNT);
    }

    CRegistryValue regval;
    CRegistryKey regkeyEventLog;


    if (m_regkeySource.Connect(pszComputerName) != ERROR_SUCCESS) {
        if (m_regkeySource.m_lResult == ERROR_ACCESS_DENIED) {
            AfxMessageBox(IDS_ERR_REG_NO_ACCESS, MB_OK | MB_ICONSTOP);
            return E_ACCESS_DENIED;
        }
        goto CONNECT_FAILURE;
    }

    if (!bIsReconnecting) {
        if (m_pdlgLoadProgress->StepProgress()) {
            return S_LOAD_CANCELED;
        }
        ++m_nLoadSteps;
    }

    if (m_regkeySnmp.Connect(pszComputerName) != ERROR_SUCCESS) {
        if (m_regkeySnmp.m_lResult == ERROR_ACCESS_DENIED) {
            AfxMessageBox(IDS_ERR_REG_NO_ACCESS, MB_OK | MB_ICONSTOP);
            return E_ACCESS_DENIED;
        }
        goto CONNECT_FAILURE;
    }
    if (!bIsReconnecting) {
        if (m_pdlgLoadProgress->StepProgress()) {
            return S_LOAD_CANCELED;
        }
        ++m_nLoadSteps;
    }


    // SOFTWARE\\Microsoft\\SNMP_EVENTS
    if (m_regkeySnmp.Open(SZ_REGKEY_SNMP_EVENTS, KEY_READ | KEY_WRITE | KEY_CREATE_SUB_KEY) != ERROR_SUCCESS) {
        if (m_regkeySnmp.Open(SZ_REGKEY_SNMP_EVENTS, KEY_READ) == ERROR_SUCCESS) {
            m_bRegIsReadOnly = TRUE;
        }
        else {
            // At this point we know the SNMP_EVENTS key could not be opened.  This
            // could either be because we don't have access to the registry or we
            // weren't installed yet. We now check to see if we can access the
            // registry at all.
            CRegistryKey regkeyMicrosoft;
            if (regkeyMicrosoft.Open(SZ_REGKEY_MICROSOFT, KEY_READ) == ERROR_SUCCESS) {
                regkeyMicrosoft.Close();
                AfxMessageBox(IDS_ERR_NOT_INSTALLED, MB_OK | MB_ICONSTOP);
            }
            else {
                // We couldn't even access SOFTWARE\Microsoft, so we know that
                // we don't have access to the registry.
                AfxMessageBox(IDS_ERR_REG_NO_ACCESS, MB_OK | MB_ICONSTOP);
                return E_ACCESS_DENIED;
            }
        }
        return E_FAIL;

    }
    if (!bIsReconnecting) {
        if (m_pdlgLoadProgress->StepProgress()) {
            return S_LOAD_CANCELED;
        }
        ++m_nLoadSteps;
    }


    //  SYSTEM\\CurrentControlSet\\Services\\EventLog
    if (m_regkeySource.Open(SZ_REGKEY_SOURCE_EVENTLOG, KEY_ENUMERATE_SUB_KEYS | KEY_READ | KEY_QUERY_VALUE ) != ERROR_SUCCESS) {
        m_regkeySnmp.Close();
        AfxMessageBox(IDS_ERR_REG_NO_ACCESS, MB_OK | MB_ICONSTOP);
        return E_ACCESS_DENIED;
    }

    if (!bIsReconnecting) {
        if (m_pdlgLoadProgress->StepProgress()) {
            return S_LOAD_CANCELED;
        }
        ++m_nLoadSteps;
    }



    if (!m_regkeySnmp.GetSubKey(SZ_REGKEY_EVENTLOG, m_regkeyEventLog)) {
        if (m_regkeySnmp.m_lResult == ERROR_ACCESS_DENIED) {
            AfxMessageBox(IDS_ERR_REG_NO_ACCESS, MB_OK | MB_ICONSTOP);
            sc = E_ACCESS_DENIED;
        }
        else {
            AfxMessageBox(IDS_WARNING_CANT_READ_CONFIG, MB_OK | MB_ICONSTOP);
            sc = E_REGKEY_NOT_FOUND;
        }
        m_regkeySnmp.Close();
        m_regkeySource.Close();
        return sc;
    }

    if (!bIsReconnecting) {
        if (m_pdlgLoadProgress->StepProgress()) {
            return S_LOAD_CANCELED;
        }
        ++m_nLoadSteps;
    }

    m_bNeedToCloseKeys = TRUE;

    sc = LockRegistry();

    if (FAILED(sc)) {
        if (sc == E_REGKEY_LOST_CONNECTION) {
            return sc;
        }
        else {
            return E_REGKEY_NO_CREATE;
        }
    }
    if (!bIsReconnecting) {
        if (m_pdlgLoadProgress->StepProgress()) {
            return S_LOAD_CANCELED;
        }
        ++m_nLoadSteps;
    }

    if (!bIsReconnecting) {
        if (m_pdlgLoadProgress->StepProgress()) {
            return S_LOAD_CANCELED;
        }
        ++m_nLoadSteps;
    }

    m_bShowConfigTypeBox = TRUE;

    if (FAILED(sc)) {
        if (sc == E_ACCESS_DENIED) {
            AfxMessageBox(IDS_ERR_REG_NO_ACCESS, MB_OK | MB_ICONSTOP);
            return E_ACCESS_DENIED;
        }
        else {
            goto CONNECT_FAILURE;
        }
    }
    if (!bIsReconnecting) {
        if (m_pdlgLoadProgress->StepProgress()) {
            return S_LOAD_CANCELED;
        }
        ++m_nLoadSteps;
    }

    return S_OK;

CONNECT_FAILURE:
        CString sMessage;
        sMessage.LoadString(IDS_CANTCONNECT);
        if (pszComputerName != NULL) {
            sMessage += pszComputerName;
        }
        AfxMessageBox((LPCTSTR) sMessage, MB_OK | MB_ICONSTOP);
        return E_FAIL;
}


//****************************************************************************
// CTrapReg::BuildSourceHasTrapsMap
//
// This method fills the m_mapEventSources CMapStringToPtr object with the
// names of all the event sources that actually have events configured for them.
// When this map is used later, we only need to know whether or not a particular
// entry exists in the map, so the value associated with each entry is irrelevant.
//
// Why do we need m_mapEventSources?  The reason is that we need a quick way to
// determine whether or not a particular source has events configured for it.
// This is used when all the event sources are being enumerated and we need to know
// whether or not to load the messages for the event source (an expensive operation).
// If a particular event source has events configured for it, then we need to load
// the messages so that the message text can be displayed.  This is because the
// event configuration stored in the registry only contains the event id and not the
// message text.
//
// Parameters:
//      None.
//
// Returns:
//      SCODE
//          S_OK if successful, otherwise E_FAIL.
//
//******************************************************************************
SCODE CTrapReg::BuildSourceHasTrapsMap()
{


    CRegistryKey regkey;
    if (!g_reg.m_regkeySnmp.GetSubKey(SZ_REGKEY_SOURCES, regkey)) {
        // For a fresh installation, there is no source subkey.
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }
        return S_OK;
    }

    CStringArray* pasEventSources = regkey.EnumSubKeys();
    regkey.Close();

    if (pasEventSources == NULL) {
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }
        return S_OK;
    }

    CString sEventSource;
    LONG nEventSources = (LONG)pasEventSources->GetSize();
    for (LONG iEventSource = 0; iEventSource < nEventSources; ++iEventSource) {
        sEventSource = pasEventSources->GetAt(iEventSource);
		sEventSource.MakeUpper();
        m_mapSourceHasTraps.SetAt(sEventSource, NULL);
    }
    delete pasEventSources;
    return S_OK;
}


//**************************************************************************
// CTrapReg::Deserialize
//
// Read all the registry information (not including the event source messages) that
// is required by eventrap.exe into this object.  Reading the messages for most
// event sources is delayed until the user actually requests it by selecting
// an event source in the event source tree control.  If an event source has
// events that are being mapped into traps, then the messages for that event
// source are loaded because an event description in the registry does not contain
// the message text.
//
// Parameters:
//      None.
//
// Returns:
//      SCODE
//          S_OK if successful.
//          E_FAIL if a failure was detected. In the event of a failure, all
//          of the appropriate message boxes will have been displayed.
//
//***************************************************************************
SCODE CTrapReg::Deserialize()
{
    m_bSomeMessageWasNotFound = FALSE;
    SetDirty(FALSE);

    // Get the value for the configuration type.
    CRegistryValue regval;
    if (m_regkeyEventLog.GetValue(SZ_NAME_REGVAL_CONFIGTYPE, regval)) {
        m_dwConfigType = *(DWORD*)regval.m_pData;
    }
    else {
        if (g_bLostConnection) {
            AfxMessageBox(IDS_ERROR_NOT_RESPONDING);
            return E_REGKEY_LOST_CONNECTION;
        }

        // If the config type value doesn't exist, assume a custom configuration.
        // This can happen because the setup program doesn't necessarily create
        // this value.
        m_dwConfigType = CONFIG_TYPE_CUSTOM;
    }
    if (m_pdlgLoadProgress->StepProgress()) {
        return S_LOAD_CANCELED;
    }
    ++m_nLoadSteps;


    SCODE sc = BuildSourceHasTrapsMap();
    if (SUCCEEDED(sc)) {
        if (m_pdlgLoadProgress->StepProgress()) {
            return S_LOAD_CANCELED;
        }
        ++m_nLoadSteps;

        // Load the event log list, the current event list and so on.
        sc = m_params.Deserialize();
        if (sc == S_LOAD_CANCELED) {
            return sc;
        }

        if (SUCCEEDED(sc)) {
            if (m_pdlgLoadProgress->StepProgress()) {
                return S_LOAD_CANCELED;
            }
            ++m_nLoadSteps;

            sc = m_aEventLogs.Deserialize();
            if (sc == S_LOAD_CANCELED) {
                return sc;
            }

            if (SUCCEEDED(sc)) {
                if (m_nLoadSteps < LOAD_STEP_COUNT) {
                    if (m_pdlgLoadProgress->StepProgress(LOAD_STEP_COUNT - m_nLoadSteps)) {
                        return S_LOAD_CANCELED;
                    }
                }
            }
        }
    }


    if (FAILED(sc)) {
        if (sc == E_REGKEY_LOST_CONNECTION) {
            AfxMessageBox(IDS_ERROR_NOT_RESPONDING);
        }
        else {
            AfxMessageBox(IDS_WARNING_CANT_READ_CONFIG);
        }

    }
    return sc;
}



//**************************************************************************
// CTrapReg::GetSaveProgressStepCount
//
// Get the number of steps for the save progress dialog.  The number of steps
// is the number of events that will be written to SNMP_EVENTS\EventLog in
// the registry.
//
// Parameters:
//      None.
//
// Returns:
//      The number of steps to use for the save progress dialog.
//
//*************************************************************************
LONG CTrapReg::GetSaveProgressStepCount()
{
    LONG nSteps = 0;
    LONG nEventLogs = m_aEventLogs.GetSize();
    for (LONG iEventLog = 0; iEventLog < nEventLogs; ++iEventLog) {
        CXEventLog* pEventLog = m_aEventLogs[iEventLog];

        LONG nEventSources = pEventLog->m_aEventSources.GetSize();
        for (LONG iEventSource = 0; iEventSource < nEventSources; ++iEventSource) {
            CXEventSource* pEventSource = pEventLog->m_aEventSources.GetAt(iEventSource);
            nSteps += pEventSource->m_aEvents.GetSize();
        }
    }
    return nSteps;
}


//**************************************************************************
// CTrapReg::Serialize
//
// Write eventrap's current configuration out to the registry.
//
// Parameters:
//      None.
//
// Returns:
//      SCODE
//          S_OK if successful.
//          E_FAIL if a failure was detected.  In the event of a failure, all
//          of the appropriate message boxes will have been displayed.
//
//***************************************************************************
SCODE CTrapReg::Serialize()
{
    SCODE sc;
    if (g_bLostConnection) {
        sc = Connect(m_sComputerName, TRUE);
        if (FAILED(sc)) {
            if (g_bLostConnection) {
                AfxMessageBox(IDS_ERROR_NOT_RESPONDING);
                return E_REGKEY_LOST_CONNECTION;
            }
            return S_SAVE_CANCELED;
        }
    }

    if (!m_bIsDirty) {
        // The configuration state was not changed, so there is nothing to do.
        return S_OK;
    }

    LONG nProgressSteps = GetSaveProgressStepCount();
    if (nProgressSteps > 0) {
        m_pdlgSaveProgress = new CDlgSaveProgress;
        m_pdlgSaveProgress->Create(IDD_SAVE_PROGRESS);

        m_pdlgSaveProgress->SetStepCount( nProgressSteps );
    }

    CRegistryValue regval;
    regval.Set(SZ_NAME_REGVAL_CONFIGTYPE, REG_DWORD, sizeof(DWORD), (LPBYTE)&m_dwConfigType);
    if (!m_regkeyEventLog.SetValue(regval)) {
        if (g_bLostConnection) {
            AfxMessageBox(IDS_ERROR_NOT_RESPONDING);
            sc = E_REGKEY_LOST_CONNECTION;
        }
        else {
            AfxMessageBox(IDS_WARNING_CANT_WRITE_CONFIG);
            sc = S_SAVE_CANCELED;
        }
    }
    else {
        sc = m_aEventLogs.Serialize();
        if (sc != S_SAVE_CANCELED) {

            if (SUCCEEDED(sc)) {
                sc = m_params.Serialize();
            }

            if (sc != S_SAVE_CANCELED)
                SetDirty(FALSE);

            if (FAILED(sc)) {
                if (g_bLostConnection) {
                    AfxMessageBox(IDS_ERROR_NOT_RESPONDING);
                }
                else {
                    AfxMessageBox(IDS_WARNING_CANT_WRITE_CONFIG);
                }
            }
        }
    }

    delete m_pdlgSaveProgress;
    m_pdlgSaveProgress = NULL;
    return sc;
}


void CTrapReg::SetDirty(BOOL bDirty)
{
    m_bIsDirty = bDirty;
    if (m_pbtnApply)
    {
        m_pbtnApply->EnableWindow(m_bIsDirty);
    }
}


///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
// Class: CTrapParams
//
// This class represents the information stored in the
// SNMP_EVENTS\EventLog\Parameters registry key.
//
// Question:  Why is it that the horizontal space in the gap between
// the lines at the top of this header appears to be very irregular?
//////////////////////////////////////////////////////////////////


//****************************************************************
// CTrapParams::CTrapParams
//
// Constructor for CTrapParams.
//
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//****************************************************************
CTrapParams::CTrapParams()
{
    m_trapsize.m_bTrimFlag = TRUE;
    m_trapsize.m_dwMaxTrapSize = 4096;
    m_trapsize.m_bTrimMessages = FALSE;
}



//********************************************************************
// CTrapParams::Deserialize
//
// Read the contents of this CTrapParams object from the registry.
//
// Parameters:
//      None.
//
// Returns:
//      SCODE
//          S_OK if successful.
//          E_FAIL if there was a problem reading the required information
//          from the registry.
//********************************************************************
SCODE CTrapParams::Deserialize()
{
    CRegistryKey regkeyParams;
    if (!g_reg.m_regkeySnmp.GetSubKey(SZ_REGKEY_PARAMETERS, regkeyParams)) {
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }
        else {
            return E_REGKEY_NOT_FOUND;
        }
    }


    CRegistryValue regval;

    // !!!CR: There is no longer any reason to load the BASE OID
    if (!regkeyParams.GetValue(SZ_REGKEY_PARAMS_BASE_ENTERPRISE_OID, regval))
        goto REGISTRY_FAILURE;
    m_sBaseEnterpriseOID = (LPCTSTR)regval.m_pData;

    if (!regkeyParams.GetValue(SZ_REGKEY_PARAMS_TRIMFLAG, regval))
        m_trapsize.m_bTrimFlag = FALSE;
    else
        m_trapsize.m_bTrimFlag = (*(DWORD*)regval.m_pData == 1);

    if (!regkeyParams.GetValue(SZ_REGKEY_PARAMS_MAXTRAP_SIZE, regval))
        m_trapsize.m_dwMaxTrapSize = MAX_TRAP_SIZE;
    else
        m_trapsize.m_dwMaxTrapSize = *(DWORD*)regval.m_pData;

    if (!regkeyParams.GetValue(SZ_REGKEY_PARAMS_TRIM_MESSAGE, regval))
        m_trapsize.m_bTrimMessages = TRUE;
    else
        m_trapsize.m_bTrimMessages = (*(DWORD*)regval.m_pData) != 0;


    if (!regkeyParams.GetValue(SZ_REGKEY_PARAMS_THRESHOLDENABLED, regval))
        m_throttle.m_bIsEnabled = TRUE;
    else
        m_throttle.m_bIsEnabled = (*(DWORD*)regval.m_pData) != THROTTLE_DISABLED;


    // Threshold trap count.
    if (!regkeyParams.GetValue(SZ_REGKEY_PARAMS_THRESHOLDCOUNT, regval) ||
        *(DWORD*)regval.m_pData < 2)
        m_throttle.m_nTraps = THRESHOLD_COUNT;
    else
        m_throttle.m_nTraps = *(DWORD*)regval.m_pData;

    // Threshold time in seconds
    if (!regkeyParams.GetValue(SZ_REGKEY_PARAMS_THRESHOLDTIME, regval))
        m_throttle.m_nSeconds = THRESHOLD_TIME;
    else
        m_throttle.m_nSeconds = *(DWORD*)regval.m_pData;


    if (regkeyParams.Close() != ERROR_SUCCESS) {
        goto REGISTRY_FAILURE;
    }
    return S_OK;

REGISTRY_FAILURE:
    if (g_bLostConnection) {
        return E_REGKEY_LOST_CONNECTION;
    }
    else {
        return E_FAIL;
    }
}

//****************************************************************
// CTrapParams::Serialize
//
// Write SNMP_EVENTS\EventLog\Parameters information to the
// registry.
//
// Parameters:
//      None.
//
// Returns:
//      S_OK if everything went OK.
//      E_REGKEY_NOT_FOUND if an expected registry key was missing.
//*****************************************************************
SCODE CTrapParams::Serialize()
{
    if (g_bLostConnection) {
        return E_REGKEY_LOST_CONNECTION;
    }


    // Open the Parameters key.
    // Create simply opens the key if already present.
    CRegistryKey regkey;
    if (!g_reg.m_regkeySnmp.CreateSubKey(SZ_REGKEY_PARAMETERS, regkey)) {
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }
        else {
            return E_REGKEY_NOT_FOUND;
        }
    }

    CRegistryValue regval;

    // Save the Message Length and the TrimMessage.
    DWORD dwTrim;
    if (m_trapsize.m_bTrimFlag)
        dwTrim = 1;
    else
        dwTrim = 0;
    regval.Set(SZ_REGKEY_PARAMS_TRIMFLAG, REG_DWORD, sizeof(DWORD), (LPBYTE)&dwTrim);
    regkey.SetValue(regval);
    if (g_bLostConnection) {
        return E_REGKEY_LOST_CONNECTION;
    }

    if (m_trapsize.m_bTrimFlag)
    {
        // Save the maximum trap size
        regval.Set(SZ_REGKEY_PARAMS_MAXTRAP_SIZE, REG_DWORD, sizeof(DWORD), (LPBYTE)&m_trapsize.m_dwMaxTrapSize);
        regkey.SetValue(regval);
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }


        // Save the trim message length
        DWORD dwTrimMessages = m_trapsize.m_bTrimMessages;
        regval.Set(SZ_REGKEY_PARAMS_TRIM_MESSAGE, REG_DWORD, sizeof(DWORD), (LPBYTE)&dwTrimMessages);
        regkey.SetValue(regval);
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }
    }

    // Threshold enabled flag
    DWORD dwValue = (m_throttle.m_bIsEnabled ? THROTTLE_ENABLED : THROTTLE_DISABLED);
    regval.Set(SZ_REGKEY_PARAMS_THRESHOLDENABLED, REG_DWORD, sizeof(DWORD), (LPBYTE)&dwValue);
    regkey.SetValue(regval);
    if (g_bLostConnection) {
        return E_REGKEY_LOST_CONNECTION;
    }

    // If throttle is not enabled, do not write the ThresholdCount and ThresholdTime parameters
    if (m_throttle.m_bIsEnabled)
    {
        // Threshold trap count.
        regval.Set(SZ_REGKEY_PARAMS_THRESHOLDCOUNT, REG_DWORD, sizeof(DWORD), (LPBYTE)&m_throttle.m_nTraps);
        regkey.SetValue(regval);
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }

        // Threshold time in seconds
        regval.Set(SZ_REGKEY_PARAMS_THRESHOLDTIME, REG_DWORD, sizeof(DWORD), (LPBYTE)&m_throttle.m_nSeconds);
        regkey.SetValue(regval);
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }
    }

    regkey.Close();
    if (g_bLostConnection) {
        return E_REGKEY_LOST_CONNECTION;
    }
    return S_OK;
}




//*******************************************************************
// CTrapParams::ResetExtensionAgent
//
// Reset the extension agent.  This is done by setting the "Threshold"
// parameter to zero in the registry.  The extension agent monitors this
// value and will reset itself when a zero is written there.
//
// The user may want to reset the extension agent if its throttle limit
// has been tripped.
//
// Parameters:
//      None.
//
// Returns:
//      SCODE
//          S_OK if successful.  E_FAIL if the extension agent could not
//          be reset.  If a failure occurs, the appropriate message box
//          is displayed.
//
//*********************************************************************
SCODE CTrapParams::ResetExtensionAgent()
{
    CRegistryKey regkey;
    if (!g_reg.m_regkeySnmp.GetSubKey(SZ_REGKEY_PARAMETERS, regkey)) {
        return E_REGKEY_NOT_FOUND;
    }
    CRegistryValue regval;

    // Set the "Threshold" value under the Parameters key to zero to reset
    // the extension agent.
    DWORD dwValue = THROTTLE_RESET;
    SCODE sc = S_OK;
    regval.Set(SZ_REGKEY_PARAMS_THRESHOLD, REG_DWORD, sizeof(DWORD), (LPBYTE)&dwValue);
    if (!regkey.SetValue(regval)) {
        AfxMessageBox(IDS_WARNING_CANT_WRITE_CONFIG);
        sc = E_FAIL;
    }

    regkey.Close();
    return sc;
}

//***********************************************************************
// CTrapParams::ThrottleIsTripped
//
// Check the registry to determine whether or not the extension agent
// throttle was tripped.
//
// Parameters:
//      None.
//
// Returns:
//      TRUE if the extension agent's throttle was tripped, FALSE otherwise.
//
//************************************************************************
BOOL CTrapParams::ThrottleIsTripped()
{
    CRegistryKey regkey;
    if (!g_reg.m_regkeySnmp.GetSubKey(SZ_REGKEY_PARAMETERS, regkey)) {
        return FALSE;
    }
    CRegistryValue regval;

    // SNMP_EVENTS\Parameters\Threshold value
    BOOL bThrottleIsTripped = FALSE;
    if (regkey.GetValue(SZ_REGKEY_PARAMS_THRESHOLD, regval)) {
        if (*(DWORD*)regval.m_pData == THROTTLE_TRIPPED) {
            bThrottleIsTripped = TRUE;
        }
    }

    regkey.Close();
    return bThrottleIsTripped;
}


///////////////////////////////////////////////////////////////////
// Class: CXEventLogArray
//
// This class implements an array of CXEventLog objects.
//
//////////////////////////////////////////////////////////////////


//****************************************************************
// CXEventLogArray::Deserialize
//
// Examine the registry find all the event logs and load all the
// relevent information for all the event logs into this array.
//
// Parameters:
//      None.
//
// Returns:
//      S_OK if successful.
//      E_FAIL if a failure was detected.
//
//****************************************************************
SCODE CXEventLogArray::Deserialize()
{
    if (g_bLostConnection) {
        return E_REGKEY_LOST_CONNECTION;
    }

    CStringArray* pasEventLogs = g_reg.m_regkeySource.EnumSubKeys();
    // Prefix bug 445192
    if (pasEventLogs == NULL)
        return E_FAIL;
    SCODE sc = S_OK;

    // Iterate through all the event log names and create each log.
	LONG nEventLogs = (LONG)pasEventLogs->GetSize();
    if (nEventLogs > 0) {
        g_reg.m_nLoadStepsPerLog = LOAD_LOG_ARRAY_STEP_COUNT / nEventLogs;
    }
    LONG nUnusedSteps = LOAD_LOG_ARRAY_STEP_COUNT -  (nEventLogs * g_reg.m_nLoadStepsPerLog);

    for (LONG iEventLog=0; iEventLog < nEventLogs; ++iEventLog)
    {
        CString sEventLog = pasEventLogs->GetAt(iEventLog);
        CXEventLog* pEventLog = new CXEventLog(sEventLog);
        sc = pEventLog->Deserialize();
        if ((sc==S_LOAD_CANCELED) || FAILED(sc)) {
            delete pEventLog;
            break;
        }
        else if (sc == S_NO_SOURCES) {
            delete pEventLog;
            sc = S_OK;
        }
        else {
            Add(pEventLog);
        }
    }
    delete pasEventLogs;
    if (g_reg.m_pdlgLoadProgress->StepProgress(nUnusedSteps)) {
        sc = S_LOAD_CANCELED;
    }

    return sc;
}


//****************************************************************
// CXEventLogArray::Serialize
//
// Write the current configuration of all the EventLogs out to the
// registry.  Only those logs and sources that actually have events
// are written.
//
// Parameters:
//      None.
//
// Returns:
//      S_OK if successful.
//      E_FAIL if a failure was detected.
//
//****************************************************************
SCODE CXEventLogArray::Serialize()
{
    if (g_bLostConnection) {
        return E_REGKEY_LOST_CONNECTION;
    }

    // This is where the eventlog stuff should be cleaned up.

    CRegistryKey regkey;
    if (!g_reg.m_regkeySnmp.CreateSubKey(SZ_REGKEY_EVENTLOG, regkey)) {
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }
        else {
            return E_REGKEY_NOT_FOUND;
        }
    }
    regkey.Close();


    if (!g_reg.m_regkeySnmp.CreateSubKey(SZ_REGKEY_SOURCES, regkey)) {
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }
        else {
            return E_REGKEY_NOT_FOUND;
        }
    }

    // Delete the keys for the sources and events for which we no longer
    // trap. I'm going to be lazy and just delete them all.
    // !!!CR: It could potentially save a lot of time if this was made smarter
    // !!!CR: so that it only replaced items that had been deleted.
    LONG nEventSources, iEventSource;
    CStringArray* pasEventSources = regkey.EnumSubKeys();
    nEventSources = (LONG)pasEventSources->GetSize();
    for (iEventSource=0; iEventSource<nEventSources; iEventSource++)
    {
        CString sSource;
        sSource = pasEventSources->GetAt(iEventSource);
        regkey.DeleteSubKey(sSource);
    }
    delete pasEventSources;


    SCODE sc = S_OK;
    LONG nEventLogs = GetSize();
    for (LONG iEventLog = 0; iEventLog < nEventLogs; ++iEventLog) {
        sc = GetAt(iEventLog)->Serialize(regkey);
        if (sc == S_SAVE_CANCELED) {
            break;
        }
        else if (g_bLostConnection) {
            sc = E_REGKEY_LOST_CONNECTION;
            break;
        }
    }
    regkey.Close();

    return sc;
}



//****************************************************************
// CXEventLogArray::FindEventSource
//
// Given the name of an event log and the name of the event source
// within the event log, return a pointer to the requested CXEventSource.
//
// Parameters:
//      CString& sLog
//          The name of the event log.
//
//      CString& sEventSource
//          The name of the event source.
//
// Returns:
//      CXEventSource*
//          A pointer to the requested event source if it was found.  NULL
//          if no such event source exists.
//
//****************************************************************
CXEventSource* CXEventLogArray::FindEventSource(CString& sLog, CString& sEventSource)
{
    LONG nLogs = GetSize();
    for (LONG iLog = 0; iLog < nLogs; ++iLog) {
        CXEventLog* pEventLog = GetAt(iLog);
        if (pEventLog->m_sName.CompareNoCase(sLog) == 0) {
            return pEventLog->FindEventSource(sEventSource);
        }
    }
    return NULL;
}





///////////////////////////////////////////////////////////////////
// Class: CXEventLog
//
// This class contains all the information for a particular event log.
//
//////////////////////////////////////////////////////////////////


//************************************************************************
// CXEventLog::Deserialize
//
// Load the contents of this EventLog object from the registry.
//
// Parameters:
//      g_reg is a global parameter.
//
// Returns:
//      SCODE
//          S_OK or S_NO_SOURCES if successful.  E_FAIL if there was
//          a failure of any kind.
//
//************************************************************************
SCODE CXEventLog::Deserialize()
{
    return m_aEventSources.Deserialize(this);
}


//************************************************************************
// CXEventLog::Serialize
//
// Write the current configuration for this log to the registry.
//
// Parameters:
//      CRegistryKey& regkey
//          This registry key points to SOFTWARE\Microsoft\SNMP_EVENTS\EventLog
//
// Returns:
//      SCODE
//          S_OK or S_SAVE_CANCELED if successful.  E_FAIL for an error condition.
//          a failure of any kind.
//
//************************************************************************
SCODE CXEventLog::Serialize(CRegistryKey& regkey)
{
    return m_aEventSources.Serialize(regkey);
}







///////////////////////////////////////////////////////////////////
// Class: CXEventSourceArray
//
// This class implements an array of CXEventSource pointers and
// related methods.
//
//////////////////////////////////////////////////////////////////



//*************************************************************************
// CXEventSourceArray::Deserialize
//
// Load all the information pertaining to the event sources associated with
// the given event log.  This information is loaded from the registry.
//
// Parameters:
//      CXEventLog* pEventLog
//          Pointer to the event log.  The sources associated with this
//          event log are loaded into this object.
//
// Returns:
//      SCODE
//          S_OK or S_NO_SOURCES if successful.  E_FAIL if there was
//          a failure of any kind.
//*************************************************************************
SCODE CXEventSourceArray::Deserialize(CXEventLog* pEventLog)
{

	// Get the registry entry for this log.  This registry key will be
	// used to enumerate the event sources for this log.
    CRegistryKey regkey;
    if (!g_reg.m_regkeySource.GetSubKey(pEventLog->m_sName, regkey)) {
        if (g_reg.m_pdlgLoadProgress->StepProgress(g_reg.m_nLoadStepsPerLog)) {
            return S_LOAD_CANCELED;
        }
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }
        else {
            return E_FAIL;
        }
    }


    SCODE sc = S_OK;

	// Enumerate the event sources for this log.
    CStringArray* pasSources = regkey.EnumSubKeys();
    if (pasSources == NULL) {
        regkey.Close();
        if (g_reg.m_pdlgLoadProgress->StepProgress(g_reg.m_nLoadStepsPerLog)) {
            return S_LOAD_CANCELED;
        }
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }
        else {
            return E_FAIL;
        }
    }


	// Iterate though all the event sources and add them as a sub-item
	// under the log.
	LONG nEventSources = (LONG)pasSources->GetSize();
    LONG nScaledStepSize = 0;
    g_reg.m_nLoadStepsPerSource = 0;
    if (nEventSources > 0) {
        nScaledStepSize = (g_reg.m_nLoadStepsPerLog * 1000) / nEventSources;
        g_reg.m_nLoadStepsPerSource = g_reg.m_nLoadStepsPerLog / nEventSources;
    }
    LONG nLoadSteps = 0;
    LONG nProgress = 0;


    // Set the load progress step count.  Since we don't know how many events are saved
    // for each event source, we will assume some small number for LOAD_STEPS_FOR_SOURCE
    // and divide the actual number of steps up as evenly as possible once we know the actual
    // event count.
    for (LONG iEventSource=0; iEventSource< nEventSources; ++iEventSource)
    {
        nProgress += nScaledStepSize;
        g_reg.m_nLoadStepsPerSource = nProgress / 1000;
        if (g_reg.m_nLoadStepsPerSource > 0) {
            nProgress -= g_reg.m_nLoadStepsPerSource * 1000;
            nLoadSteps += g_reg.m_nLoadStepsPerSource;
        }

        CString sEventSource = pasSources->GetAt(iEventSource);
        CXEventSource* pEventSource = new CXEventSource(pEventLog, sEventSource);
        sc = pEventSource->Deserialize(regkey);
        if ((sc==S_LOAD_CANCELED) || FAILED(sc)) {
            delete pEventSource;
            break;
        }
        else if (sc == S_NO_EVENTS) {
            // If there are no events, then this is not a valid event source.
            delete pEventSource;
            sc = S_OK;
        }
        else {
            Add(pEventSource);
        }
    }
	delete pasSources;
    if (SUCCEEDED(sc)) {
        // We only close the registry key if we succeeded to avoid hanging if we loose
        // a remote connection.
        regkey.Close();
        if (GetSize() == 0) {
            sc = S_NO_SOURCES;
        }
    }
    if (nLoadSteps < g_reg.m_nLoadStepsPerLog) {
        if (g_reg.m_pdlgLoadProgress->StepProgress(g_reg.m_nLoadStepsPerLog - nLoadSteps)) {
            return S_LOAD_CANCELED;
        }
        g_reg.m_nLoadSteps += g_reg.m_nLoadStepsPerLog - nLoadSteps;
    }
    return sc;
}


//************************************************************************
// CXEventSourceArray::Serialize
//
// Write the current configuration for this event source array to the registry.
//
// Parameters:
//      CRegistryKey& regkey
//          This registry key points to SOFTWARE\Microsoft\SNMP_EVENTS\EventLog\Sources
//
// Returns:
//      SCODE
//          S_OK or S_SAVE_CANCELED if successful.  E_FAIL for an error condition.
//          a failure of any kind.
//
//************************************************************************
SCODE CXEventSourceArray::Serialize(CRegistryKey& regkey)
{
    // Write the subkeys under SNMP_EVENTS\EventLog
    SCODE sc = S_OK;
    LONG nEventSources = GetSize();
    for (LONG iEventSource = 0; iEventSource < nEventSources; ++iEventSource) {
        SCODE scTemp = GetAt(iEventSource)->Serialize(regkey);
        if (g_bLostConnection) {
            sc = E_REGKEY_LOST_CONNECTION;
            break;
        }
        if (FAILED(scTemp)) {
            sc = E_FAIL;
            break;
        }
        if (scTemp == S_SAVE_CANCELED) {
            sc = S_SAVE_CANCELED;
            break;
        }
    }
    return sc;
}


//************************************************************************
// CXEventSourceArray::FindEventSource
//
// Given an event source name, find the specified event source in this
// event source array.
//
// Parameters:
//      CString& sEventSource
//          The name of the event source to search for.
//
// Returns:
//      CXEventSource*
//          Pointer to the event source if it is found, otherwise NULL.
//
//***********************************************************************
CXEventSource* CXEventSourceArray::FindEventSource(CString& sEventSource)
{
    LONG nSources = GetSize();
    for (LONG iSource = 0; iSource < nSources; ++iSource) {
        CXEventSource* pEventSource = GetAt(iSource);
        if (pEventSource->m_sName.CompareNoCase(sEventSource)==0) {
            return pEventSource;
        }
    }
    return NULL;
}


///////////////////////////////////////////////////////////////////
// Class: CXEventSource
//
// This class implements an an event source object.  An event source
// corresponds to an application that can generate events.  The
// event sources are enumerated from the registry in
// "SYSTEM\CurrentControlSet\Services\EventLogs" under each particular
// eventlog found there.
//
// An event source has an array of messages and an array of events
// associated with it.
//
// The message array comes from the message .DLL file(s) pointed to by
// the "EventMessageFile" value attached to the source's key in the registry.
// The message array is read-only in the sense that it is loaded from the
// registry and never written back to it.
//
// The event array comes from SNMP_EVENTS\EventLog\<source-subkey>.  These
// events are loaded when the configuration program starts up and written
// back out when the user clicks "OK".  Note that the events stored in the
// registry contain the event ID, but not the message text.  The message text
// for an event is found by searching the message array in the CXEventSource
// object for the event's ID.
//
//////////////////////////////////////////////////////////////////

//*************************************************************************
// CXEventSource::CXEventSource
//
// Construct the CXEventSource object.
//
// Parameters:
//      CXEventLog* pEventLog
//          Pointer to the event log that contains this event source.
//
//      CString& sName
//          The name of this event source.
//
// Returns:
//      Nothing.
//
//*************************************************************************
CXEventSource::CXEventSource(CXEventLog* pEventLog, CString& sName)
{
    m_pEventLog = pEventLog;
    m_sName = sName;
    m_aMessages.Initialize(this);
}




//************************************************************************
// CXEventSource::~CXEventSource
//
// Destroy thus event source object.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//************************************************************************
CXEventSource::~CXEventSource()
{
    // We must explicitly delete the contents of the event array and message
    // array.  Note that this is different behavior from the CXEventLogArray
    // and CXEventSourceArray.  This is because it was useful to create
    // message and event arrays as temporary containers for a set of pointers.
    // Thus, there were situations where you did not want to delete the
    // objects contained in these arrays when the arrays were destroyed.
    m_aEvents.DeleteAll();
    m_aMessages.DeleteAll();
}


//**********************************************************************
// CXEventSource::Deserialize
//
// Load this event source from the registry given the registry key
// for the event log that contains this source.
//
// Parameters:
//      CRegistryKey& regkeyLog
//          An open registry key for the event log containing this
//          event source.  This key points to somewhere in
//          SYSTEM\CurrentControlSet\Services\EventLog
//
// Returns:
//      SCODE
//          S_OK = the source has events and no errors were encountered.
//          S_NO_EVENTS = the source has no events and no errors were encountered.
//          E_FAIL = an condition was encountered.
//
//***********************************************************************
SCODE CXEventSource::Deserialize(CRegistryKey& regkeyLog)
{
    CRegistryKey regkeySource;
    if (!regkeyLog.GetSubKey(m_sName, regkeySource)) {
        if (g_reg.m_pdlgLoadProgress->StepProgress(g_reg.m_nLoadStepsPerSource)) {
            return S_LOAD_CANCELED;
        }
        g_reg.m_nLoadSteps += g_reg.m_nLoadStepsPerSource;
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }
        else {
            return E_FAIL;
        }
    }

    SCODE sc = E_FAIL;
    if (SUCCEEDED(GetLibPath(regkeySource))) {
        sc = m_aEvents.Deserialize(this);
    }
    else {
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }

        if (g_reg.m_pdlgLoadProgress->StepProgress(g_reg.m_nLoadStepsPerSource)) {
            return S_LOAD_CANCELED;
        }
        g_reg.m_nLoadSteps += g_reg.m_nLoadStepsPerSource;
        sc = S_NO_EVENTS;
    }


    regkeySource.Close();
    if (g_bLostConnection) {
        return E_REGKEY_LOST_CONNECTION;
    }

    // Delay deserializing the messages for this source until they are
    // needed.
    return sc;
}


#if 0
//*************************************************************************
// CXEventSource::GetLibPath
//
// Get the path the the EventMessageFile for this event source.
//
// Parameters:
//      CRegistryKey& regkeySource
//          An open registry key corresponding to this source in
//          SYSTEM\CurrentControlSet\Services\EventLog\<event log>
//
// Returns:
//      SCODE
//          S_OK if successful, otherwise E_FAIL.
//
//*************************************************************************
SCODE CXEventSource::GetLibPath(CRegistryKey& regkeySource)
{
    CRegistryValue regval;
    if (!regkeySource.GetValue(SZ_REGKEY_SOURCE_EVENT_MESSAGE_FILE, regval))
        return E_FAIL;

	TCHAR szLibPath[MAX_STRING];
    if (ExpandEnvironmentStrings((LPCTSTR)regval.m_pData, szLibPath, sizeof(szLibPath)) == 0)
        return E_FAIL;

    m_sLibPath = szLibPath;
    return S_OK;
}
#else
//*************************************************************************
// CXEventSource::GetLibPath
//
// Get the path the the EventMessageFile for this event source.
//
// Parameters:
//      CRegistryKey& regkeySource
//          An open registry key corresponding to this source in
//          SYSTEM\CurrentControlSet\Services\EventLog\<event log>
//
// Returns:
//      SCODE
//          S_OK if successful, otherwise E_FAIL.
//
//*************************************************************************
SCODE CXEventSource::GetLibPath(CRegistryKey& regkeySource)
{
    static CEnvCache cache;



    CRegistryValue regval;
    if (!regkeySource.GetValue(SZ_REGKEY_SOURCE_EVENT_MESSAGE_FILE, regval))
        return E_FAIL;

    SCODE sc = S_OK;
    if (g_reg.m_sComputerName.IsEmpty()) {
        // Editing the local computer computer's registry, so the local environment
        // variables are in effect.

    	TCHAR szLibPath[MAX_STRING];
        if (ExpandEnvironmentStrings((LPCTSTR)regval.m_pData, szLibPath, sizeof(szLibPath)/sizeof(szLibPath[0])))  {
            m_sLibPath = szLibPath;
        }
        else {
            sc = E_FAIL;
        }
    }
    else {
        // Editing a remote computer's registry, so the remote environment strings are in
        // effect.  Also, file paths must be mapped to the UNC path for the machine.  For
        // example, C:Foo will be mapped to \\Machine\C$\Foo
        m_sLibPath = regval.m_pData;
        sc = RemoteExpandEnvStrings(g_reg.m_sComputerName, cache, m_sLibPath);
        if (SUCCEEDED(sc)) {
            sc = MapPathToUNC(g_reg.m_sComputerName, m_sLibPath);
        }
    }

    return S_OK;
}

#endif



//************************************************************************
// CXEventSource::Serialize
//
// Write the configuration information for this event source to the registry.
//
// Parameters:
//      CRegistryKey& regkeyParent
//          An open registry key pointing to SNMP_EVENTS\EventLog\Sources
//
// Returns:
//      SCODE
//          S_OK if successful.
//          S_SAVE_CANCELED if no errors, but the user canceled the save.
//
//************************************************************************
SCODE CXEventSource::Serialize(CRegistryKey& regkeyParent)
{
    if (g_bLostConnection) {
        return E_REGKEY_LOST_CONNECTION;
    }

    SCODE sc = S_OK;
    if (m_aEvents.GetSize() > 0) {
        CRegistryKey regkey;
        if (!regkeyParent.CreateSubKey(m_sName, regkey)) {
            if (g_bLostConnection) {
                return E_REGKEY_LOST_CONNECTION;
            }
            else {
                return E_REGKEY_NOT_FOUND;
            }
        }

        CString sEnterpriseOID;
        GetEnterpriseOID(sEnterpriseOID);
        CRegistryValue regval;


        regval.Set(SZ_REGKEY_SOURCE_ENTERPRISE_OID,
                   REG_SZ, (sEnterpriseOID.GetLength() + 1) * sizeof(TCHAR),
                   (LPBYTE)(LPCTSTR)sEnterpriseOID);
        regkey.SetValue(regval);


        DWORD dwAppend = 1;
        regval.Set(SZ_REGKEY_SOURCE_APPEND, REG_DWORD, sizeof(DWORD), (LPBYTE) &dwAppend);
        regkey.SetValue(regval);

        sc = m_aEvents.Serialize(regkey);
        regkey.Close();
    }

    if (g_bLostConnection) {
        return E_REGKEY_LOST_CONNECTION;
    }
    return sc;
}


//*******************************************************************
// CXEventSource::GetEnterpriseOID
//
// Get the enterprise OID for this event source.  The enterprise OID
// is composed of a prefix and suffix string concatenated together.  The
// prefix string is an ASCII decimal value for the length of the suffix
// string.  The suffix string is composed by separating each character of
// the name of this source by a "." character.
//
// Parameters:
//      CString& sEnterpriseOID
//          A reference to the string where the enterprise OID for this
//          source will be returned.
//
// Returns:
//      The enterprise OID in via the sEnterpriseOID reference.
//
//********************************************************************
void CXEventSource::GetEnterpriseOID(CString& sEnterpriseOID, BOOL bGetFullID)
{
    CString sValue;


    // Form the prefix string in sEnterpriseOID and compute the length
    // of the prefix and suffix strings.
    DecString(sValue, m_sName.GetLength());
    if (bGetFullID) {
        sEnterpriseOID = g_reg.m_params.m_sBaseEnterpriseOID + _T('.') + sValue;
    }
    else {
        sEnterpriseOID = sValue;
    }

    // Append the suffix string to the prefix string by getting a pointer to
    // the sEnterpriseOID buffer and allocating enough space to hold the
    // combined strings.
    LPCTSTR pszSrc = m_sName;

    // Append the suffix by copying it to the destination buffer and inserting the
    // "." separator characters as we go.
    LONG iCh;
    while (iCh = *pszSrc++) {
        switch(sizeof(TCHAR)) {
        case 1:
            iCh &= 0x0ff;
            break;
        case 2:
            iCh &= 0x0ffffL;
            break;
        default:
            ASSERT(FALSE);
            break;
        }

        DecString(sValue, iCh);
        sEnterpriseOID += _T('.');
        sEnterpriseOID += sValue;
    }
}






///////////////////////////////////////////////////////////////////
// Class: CXEventArray
//
// This class implements an array of pointers to CXEvent objects.
// The events contained in this array correspond to the events that
// the user has configured in the main dialog.  Don't confuse events
// with messages.  Events are the subset of the messages that the
// user has selected to be translated into traps.
//
// For further information on how this CXEventArray fits into the
// scheme of things, please see the CXEventSource class header.
//////////////////////////////////////////////////////////////////


//************************************************************************
// CXEventArray::Deserialize
//
// Read an array of events from the registry for the given
// source.
//
// Parameters:
//      CXEventSource* pEventSource
//          Pointer to the event source who's events should be read.
//
// Returns:
//      SCODE
//          S_OK if successful.
//          E_FAIL if an error occurs.
//
//************************************************************************
SCODE CXEventArray::Deserialize(CXEventSource* pEventSource)
{
    if (!g_reg.SourceHasTraps(pEventSource->m_sName)) {
        if (g_reg.m_pdlgLoadProgress->StepProgress(g_reg.m_nLoadStepsPerSource)) {
            return S_LOAD_CANCELED;
        }
        g_reg.m_nLoadSteps += g_reg.m_nLoadStepsPerSource;
        return S_OK;
    }

    // Control comes here if we know that there are events configured
    // for the event source that this event array is part of.  We now
    // need to load the events for this source by enumerating them
    // from SNMP_EVENTS\EventLog\<event source>

    CString sKey;
    sKey = sKey + SZ_REGKEY_SOURCES + _T("\\") + pEventSource->m_sName;
    CRegistryKey regkey;
    if (!g_reg.m_regkeySnmp.GetSubKey(sKey, regkey)) {
        if (g_reg.m_pdlgLoadProgress->StepProgress(g_reg.m_nLoadStepsPerSource)) {
            return S_LOAD_CANCELED;
        }
        g_reg.m_nLoadSteps += g_reg.m_nLoadStepsPerSource;
        return S_OK;
    }


	// Enumerate the events for this source
    CStringArray* pasEvents = regkey.EnumSubKeys();
    if (pasEvents == NULL) {
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }

        regkey.Close();
        if (g_reg.m_pdlgLoadProgress->StepProgress(g_reg.m_nLoadStepsPerSource)) {
            return S_LOAD_CANCELED;
        }
        g_reg.m_nLoadSteps += g_reg.m_nLoadStepsPerSource;

        return E_FAIL;
    }



	// Iterate though all the events and add them as a sub-item
	// under the event source.
	LONG nEvents = (LONG)pasEvents->GetSize();
    LONG nStepsDone = 0;
    LONG nEventsPerStep = 0;
    if (g_reg.m_nLoadStepsPerSource > 0) {
        nEventsPerStep = nEvents / g_reg.m_nLoadStepsPerSource;
    }

    for (LONG iEvent=0; iEvent< nEvents; ++iEvent)
    {
        CString sEvent = pasEvents->GetAt(iEvent);
        CXEvent* pEvent = new CXEvent(pEventSource);
        SCODE sc = pEvent->Deserialize(regkey, sEvent);
        if (sc == E_MESSAGE_NOT_FOUND) {
            delete pEvent;
            if (!g_reg.m_bSomeMessageWasNotFound) {
                AfxMessageBox(IDS_ERR_MESSAGE_NOT_FOUND, MB_OK | MB_ICONEXCLAMATION);
                g_reg.m_bSomeMessageWasNotFound = TRUE;
                g_reg.SetDirty(TRUE);
            }

            continue;
        }


        if ((sc == S_LOAD_CANCELED) || FAILED(sc) ) {
            delete pEvent;
            delete pasEvents;
            return sc;
        }

        if (nEventsPerStep > 0) {
            if ((iEvent % nEventsPerStep) == (nEventsPerStep - 1)) {
                if (g_reg.m_pdlgLoadProgress->StepProgress()) {
                    delete pasEvents;
                    return S_LOAD_CANCELED;
                }
                ++g_reg.m_nLoadSteps;
                ++nStepsDone;
            }
        }
    }
	delete pasEvents;
    regkey.Close();
    if (nStepsDone < g_reg.m_nLoadStepsPerSource) {
        if (g_reg.m_pdlgLoadProgress->StepProgress(g_reg.m_nLoadStepsPerSource - nStepsDone)) {
            return S_LOAD_CANCELED;
        }
        g_reg.m_nLoadSteps += g_reg.m_nLoadStepsPerSource - nStepsDone;
    }
    return S_OK;
}


//************************************************************************
// CXEventArray::Serialize
//
// Write the current configuration for the events contained in this array
// out to the registry.
//
// Parameters:
//      CRegistryKey& regkeyParent
//          An open registry key for the source that owns these events.
//          The source key is located in SNMP_EVENTS\EventLogs\<source-key>
//
// Returns:
//      SCODE
//          S_OK = All events saved without errors.
//          S_SAVE_CANCELED = No errors, but the user canceled the save.
//          E_FAIL = An error occurs.
//
//************************************************************************
SCODE CXEventArray::Serialize(CRegistryKey& regkeyParent)
{
    SCODE sc = S_OK;
    LONG nEvents = GetSize();
    for (LONG iEvent = 0; iEvent < nEvents; ++iEvent) {
        SCODE scTemp = GetAt(iEvent)->Serialize(regkeyParent);
        if (scTemp == S_SAVE_CANCELED) {
            sc = S_SAVE_CANCELED;
            break;
        }

        if (FAILED(scTemp)) {
            if (g_bLostConnection) {
                sc = E_REGKEY_LOST_CONNECTION;
            }
            else {
                sc = E_FAIL;
            }
            break;
        }
    }
    return sc;
}


//***********************************************************************
// CXEventArray::Add
//
// Add an event pointer to this array.  Note that there is no assumption
// that the array owns the pointer.  Someone must explicitly call the DeleteAll
// member to delete the pointers stored in this array.
//
// Parameters:
//      CXEvent* pEvent
//          Pointer to the event to add to this array.
//
// Returns:
//      Nothing.
//
//***********************************************************************
void CXEventArray::Add(CXEvent* pEvent)
{
    CBaseArray::Add(pEvent);
}	



//***********************************************************************
// CXEventArray::FindEvent
//
// Given an event id, find the corresponding event in this array.
//
// Note that this array should never contain duplicate events.
//
// Parameters:
//      DWORD dwId
//          The event ID.
//
// Returns:
//      CXEvent*
//          A pointer to the desired event.  NULL if the event was
//          not found.
//
//***********************************************************************
CXEvent* CXEventArray::FindEvent(DWORD dwId)
{
    LONG nEvents = GetSize();
    for (LONG iEvent=0; iEvent < nEvents; ++iEvent) {
        CXEvent* pEvent = GetAt(iEvent);
        if (pEvent->m_message.m_dwId == dwId) {
            return pEvent;
        }
    }
    return NULL;
}



//***********************************************************************
// CXEventArray::FindEvent
//
// Given an event pointer, remove the event from this array.
//
// Parameters:
//      CXEvent* pEventRemove
//          A pointer to the event to remove.
//
// Returns:
//      SCODE
//          S_OK if the event was removed.
//          E_FAIL if the event was not found in this array.
//
//***********************************************************************
SCODE CXEventArray::RemoveEvent(CXEvent* pEventRemove)
{
    // Iterate through the event array to search for the specified event.
    LONG nEvents = GetSize();
    for (LONG iEvent=0; iEvent < nEvents; ++iEvent) {
        CXEvent* pEvent = GetAt(iEvent);
        if (pEvent == pEventRemove) {
            RemoveAt(iEvent);
            return S_OK;
        }
    }
    return E_FAIL;
}




///////////////////////////////////////////////////////////////////
// Class: CXEvent
//
// This class implements an event.  Events are the subset of the
// messages that the user selects to be translated into traps.
// Events, and not messages, are what the user configures.
//
// For further information on how this class fits into the
// scheme of things, please see the CXEventSource class header.
//////////////////////////////////////////////////////////////////

//*********************************************************************
// CXEvent::CXEvent
//
// Construct the event.
//
// Parameters:
//      CXEventSource* pEventSource
//          Pointer to the event source that has the potential to generate
//          this event.
//
// Returns:
//      Nothing.
//
//*********************************************************************
CXEvent::CXEvent(CXEventSource* pEventSource) : m_message(pEventSource)
{
    m_dwCount = 0;
    m_dwTimeInterval = 0;
    m_pEventSource = pEventSource;
    m_pEventSource->m_aEvents.Add(this);
}



//**********************************************************************
// CXEvent::CXEvent
//
// Construct an event.  This form of the constructor creates an event
// directly from a CXMessage object.  This is possible because the
// CXMessage object contains a back-pointer to its source.
//
// Parameters:
//      CXMessage* pMessage
//          Pointer to the message that is used as the event template.
//
// Returns:
//      Nothing.
//**********************************************************************
CXEvent::CXEvent(CXMessage* pMessage) : m_message(pMessage->m_pEventSource)
{
    m_pEventSource = pMessage->m_pEventSource;
    m_message = *pMessage;
    m_dwCount = 0;
    m_dwTimeInterval = 0;
    m_pEventSource->m_aEvents.Add(this);
}


//**********************************************************************
// CXEvent::~CXEvent
//
// Destroy this event.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//**********************************************************************
CXEvent::~CXEvent()
{
    // Remove this event from the source
    m_pEventSource->m_aEvents.RemoveEvent(this);
}


//**********************************************************************
// CXEvent::Deserialize
//
// Read this event from the registry.
//
// Parameters:
//      CRegistryKey& regkeyParent
//          An open registry key pointing to the event source in
//          SNMP_EVENTS\EventLog
//
//      CString& sName
//          The name of the event to load.
//
// Returns:
//      SCODE
//          S_OK if successful.
//          E_FAIL if an error occurred.
//
//*********************************************************************
SCODE CXEvent::Deserialize(CRegistryKey& regkeyParent, CString& sName)
{
    CRegistryKey regkey;
    if (!regkeyParent.GetSubKey(sName, regkey)) {
        return E_FAIL;
    }

    SCODE sc = E_FAIL;
    CRegistryValue regval;

    // Get the count and time interval.
    m_dwCount = 0;
    m_dwTimeInterval = 0;
    if (regkey.GetValue(SZ_REGKEY_EVENT_COUNT, regval))  {
        m_dwCount = *(DWORD*)regval.m_pData;
        if (regkey.GetValue(SZ_REGKEY_EVENT_TIME, regval))  {
            m_dwTimeInterval = *(DWORD*)regval.m_pData;
        }
    }


    if (regkey.GetValue(SZ_REGKEY_EVENT_FULLID, regval))   {
        DWORD dwFullId = *(DWORD*)regval.m_pData;

        CXMessage* pMessage = m_pEventSource->FindMessage(dwFullId);
        if (pMessage == NULL) {
            sc = E_MESSAGE_NOT_FOUND;
        }
        else {
            m_message = *pMessage;
            sc = S_OK;
        }
    }

    regkey.Close();
    return sc;
}



//**********************************************************************
// CXEvent::Deserialize
//
// Write the configuration for this event to the registry.
//
// Parameters:
//      CRegistryKey& regkeyParent
//          An open registry key pointing to the event source in
//          SNMP_EVENTS\EventLog
//
// Returns:
//      SCODE
//          S_OK = the event was successful written out.
//          S_SAVE_CANCELED = no errors, but the user canceled the save.
//          E_FAIL = if an error occurred.
//
//*********************************************************************
SCODE CXEvent::Serialize(CRegistryKey& regkeyParent)
{
    if (g_reg.m_pdlgSaveProgress) {
        if (g_reg.m_pdlgSaveProgress->StepProgress()) {
            return S_SAVE_CANCELED;
        }
    }


    CRegistryKey regkey;

    CString sName;
    GetName(sName);
    if (!regkeyParent.CreateSubKey(sName, regkey)) {
        return E_REGKEY_NO_CREATE;
    }

    CRegistryValue regval;
    if (m_dwCount > 0) {
        regval.Set(SZ_REGKEY_EVENT_COUNT, REG_DWORD, sizeof(DWORD), (LPBYTE) &m_dwCount);
        regkey.SetValue(regval);

        if (m_dwTimeInterval > 0) {
            regval.Set(SZ_REGKEY_EVENT_TIME, REG_DWORD, sizeof(DWORD), (LPBYTE) &m_dwTimeInterval);
            regkey.SetValue(regval);
        }
    }

    regval.Set(SZ_REGKEY_EVENT_FULLID, REG_DWORD, sizeof(DWORD), (LPBYTE) &m_message.m_dwId);
    regkey.SetValue(regval);
    regkey.Close();
    return S_OK;
}


//*************************************************************************
// CXEvent::GetCount
//
// Get the ASCII decimal value for the m_dwCount member.
//
// Using this method to do the conversion ensures that the count value is
// presented to the user in a consistent form throughout the program.
//
// Parameters:
//      CString& sText
//          This is where the count value is returned.
//
// Returns:
//      The ASCII value for the count is returned via sText.
//
// Note: m_dwCount and m_dwTimeInterval work together.  A trap is sent only if
// m_dwCount events are registered withing m_dwTimeInterval seconds.
//*************************************************************************
void CXEvent::GetCount(CString& sText)
{
    DecString(sText, (long) m_dwCount);
}



//*************************************************************************
// CXEvent::GetTimeInterval
//
// Get the ASCII decimal value for the m_dwTimeInterval member.
//
// Using this method to do the conversion ensures that the time-interval value is
// presented to the user in a consistent form throughout the program.
//
// Parameters:
//      CString& sText
//          This is where the count value is returned.
//
// Returns:
//      The ASCII value for the count is returned via sText.
//
// Note: m_dwCount and m_dwTimeInterval work together.  A trap is sent only if
// m_dwCount events are registered withing m_dwTimeInterval seconds.
//*************************************************************************
void CXEvent::GetTimeInterval(CString& sText)
{
    DecString(sText, (long) m_dwTimeInterval);
}






///////////////////////////////////////////////////////////////////
// Class: CXMessage
//
// This class implements a message.  Each event source has some
// number of messages associated with it.  A user may select some
// subset of the messages to be converted into "events".  The user
// configures events, not messages.
//
// For further information on how this class fits into the
// scheme of things, please see the CXEventSource class header.
//////////////////////////////////////////////////////////////////


CXMessage::CXMessage(CXEventSource* pEventSource)
{
    m_pEventSource = pEventSource;
}


CXMessage& CXMessage::operator=(CXMessage& message)
{
    m_pEventSource = message.m_pEventSource;
    m_dwId = message.m_dwId;
    m_sText = message.m_sText;
    return *this;
}



//***************************************************************************
//
//  CMessage::GetSeverity
//
//  Get the severity level of the event.  This is the human-readable string
//	corresponding to the top two bits of the event ID.
//
//  Parameters:
//		CString& sSeverity
//			A reference to the place to return the severity string.
//
//  Returns:
//		Nothing.
//
//  Status:
//
//***************************************************************************
void CXMessage::GetSeverity(CString& sSeverity)
{
	MapEventToSeverity(m_dwId, sSeverity);
}



//***************************************************************************
//
//  CMessage::GetTrappingString
//
//  This method returns the trapping string "yes" if the event is being
//	trapped and "no" if its not being trapped.
//
//  Parameters:
//		CString& sTrapping
//			A reference to the place to return the trapping string.
//
//  Returns:
//		Nothing.
//
//  Status:
//
//***************************************************************************
void CXMessage::IsTrapping(CString& sIsTrapping)
{
    CXEvent* pEvent = m_pEventSource->FindEvent(m_dwId);
    sIsTrapping.LoadString( pEvent != NULL ? IDS_IS_TRAPPING : IDS_NOT_TRAPPING);
}


//****************************************************************************
//
// CMessage::SetAndCleanText
//
// Set the m_sText data member to a cleaned up version of a source string.
// The text is cleaned by converting all funny whitespace characters such
// as carriage return, tabs and so on to ordinary space characters.  All
// leading space is stripped from the beginning of the string.
//
//****************************************************************************
void CXMessage::SetAndCleanText(PMESSAGE_RESOURCE_ENTRY pEntry)
{
    BOOL    bIsLeadingSpace = TRUE;
    USHORT  i;

    if (pEntry->Flags == 0x00000)   // ANSI char set
    {
        CHAR *pszSrc = (CHAR *)pEntry->Text;
        CHAR chSrc;
        LPTSTR pszDst = m_sText.GetBuffer(strlen(pszSrc) + 1);

        for (i=0; i<pEntry->Length && *pszSrc; i++, pszSrc++)
        {
            chSrc = *pszSrc;
            if (chSrc >= 0x09 && chSrc <= 0x0d)
                chSrc = ' ';
            if (chSrc == ' ' && bIsLeadingSpace)
                    continue;

            *pszDst++ = (TCHAR)chSrc;
            if (bIsLeadingSpace)    // testing only is less costly
                bIsLeadingSpace = FALSE;
        }
        *pszDst = _T('\0');
    }
    else    // UNICODE char set
    {
        wchar_t *pwszSrc = (wchar_t *)pEntry->Text;
        wchar_t wchSrc;
        LPTSTR pszDst = m_sText.GetBuffer(wcslen(pwszSrc) + 1);

        for (i=0; i<pEntry->Length/sizeof(wchar_t) && *pwszSrc; i++, pwszSrc++)
        {
            wchSrc = *pwszSrc;
            if (wchSrc >= (wchar_t)0x09 && wchSrc <= (wchar_t)0x0d)
                wchSrc = (wchar_t)' ';
            if (wchSrc == (wchar_t)' ' && bIsLeadingSpace)
                continue;

            *pszDst++ = (TCHAR)wchSrc;
            if (bIsLeadingSpace)    // testing only is less costly
                bIsLeadingSpace = FALSE;
        }
        *pszDst = _T('\0');
    }

    m_sText.ReleaseBuffer();
}



//****************************************************************************
// CXMessage::GetShortId
//
// This method returns the message's "short ID" that users see for events and
// messages.  The short ID is the ASCII decimal value for the low-order 16 bits
// of the message ID.
//
// Using this method to do the conversion ensures that the short-ID value is
// presented to the user in a consistent form throughout the program.
//
// Parameters:
//      CString& sShortId
//          This is where the ID string is returned.
//
// Returns:
//      The message ID string is returned via sShortId
//
//****************************************************************************
void CXMessage::GetShortId(CString& sShortId)
{
    TCHAR szBuffer[MAX_STRING];
    _ltot((LONG) LOWORD(m_dwId), szBuffer, 10);
    sShortId = szBuffer;
}



///////////////////////////////////////////////////////////////////
// Class: CXMessageArray
//
// This class implements an array of pointers to CXMessage objects.
//
// For further information on how this CXMessageArray fits into the
// scheme of things, please see the CXEventSource class header.
//////////////////////////////////////////////////////////////////


//****************************************************************
// CXMessageArray::CXMessageArray
//
// Constructor.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//****************************************************************
CXMessageArray::CXMessageArray()
{
    m_bDidLoadMessages = FALSE;
    m_pEventSource = NULL;
}




//*******************************************************************
// CXMessageArray::FindMessage
//
// Search this array for a message given its ID.
//
// Parameters:
//      DWORD dwId
//          The full message ID
//
// Returns:
//      CXMessage*
//          Pointer to the message if it was found.  NULL if it was
//          not found.
//
// Note:
//      Duplicate messages are not allowed in the array, but no code
//      enforces this for the sake of efficiency.
//
//*******************************************************************
CXMessage* CXMessageArray::FindMessage(DWORD dwId)
{
    if (!m_bDidLoadMessages) {
        if (FAILED(LoadMessages())) {
            return NULL;
        }
    }

    LONG nMessages = GetSize();
    for (LONG iMessage = 0; iMessage < nMessages; ++iMessage) {
        CXMessage* pMessage = GetAt(iMessage);
        if (pMessage->m_dwId == dwId) {
            return pMessage;
        }
    }

    return NULL;
}





//****************************************************************************
//
// XProcessMsgTable
//
// This function processes a the message table contained in a message .DLL file
// and adds all the messages it contains to the given CXMessageArray object.
//
// Parameters:
//      HANDLE hModule
//          The module handle for the .DLL file.
//
//      LPCTSTR lpszType
//          Ignored.
//
//      LPTSTR lpszName
//          The name of the module.
//
//      LONG lParam
//          A pointer to a CXMessageArray object where the messages will be
//          stored.
//
// Returns:
//      BOOL
//          Always returns TRUE.
//
//
//****************************************************************************
static BOOL CALLBACK XProcessMsgTable(HANDLE hModule, LPCTSTR lpszType,
    LPTSTR lpszName, LONG_PTR lParam)
{
    CXMessageArray* paMessages = (CXMessageArray*)(LPVOID) (LONG_PTR)lParam;

    // Found a message table.  Process it!
    HRSRC hResource = FindResource((HINSTANCE)hModule, lpszName,
        RT_MESSAGETABLE);
    if (hResource == NULL)
        return TRUE;

    HGLOBAL hMem = LoadResource((HINSTANCE)hModule, hResource);
    if (hMem == NULL)
        return TRUE;

    PMESSAGE_RESOURCE_DATA pMsgTable = (PMESSAGE_RESOURCE_DATA)::LockResource(hMem);
    if (pMsgTable == NULL)
        return TRUE;

    ULONG ulBlock, ulId, ulOffset;

    for (ulBlock=0; ulBlock<pMsgTable->NumberOfBlocks; ulBlock++)
    {
        ulOffset = pMsgTable->Blocks[ulBlock].OffsetToEntries;
        for (ulId = pMsgTable->Blocks[ulBlock].LowId;
            ulId <= pMsgTable->Blocks[ulBlock].HighId; ulId++)

        {
            PMESSAGE_RESOURCE_ENTRY pEntry =
                (PMESSAGE_RESOURCE_ENTRY)((ULONG_PTR)pMsgTable + ulOffset);
            CXMessage *pMessage = new CXMessage(paMessages->m_pEventSource);
            pMessage->m_dwId = (DWORD) ulId;
            pMessage->SetAndCleanText(pEntry);
            paMessages->Add(pMessage);
            ulOffset += pEntry->Length;
        }
    }

    return TRUE;
}


//****************************************************************************
// CXMessageArray::LoadMessages
//
// Load the messages from the message .DLL file(s) for the source into this
// message array.
//
// Parameters:
//      None.
//
// Returns:
//      SCODE
//          S_OK if successful.
//          E_FAIL if an error occurs.
//
//*****************************************************************************
SCODE CXMessageArray::LoadMessages()
{
    ASSERT(m_pEventSource != NULL);
    if (m_bDidLoadMessages) {
        return S_OK;
    }


    CBusy busy;
    CString sLibPathList = m_pEventSource->m_sLibPath;
    CString sLibPath;

	while (GetNextPath(sLibPathList, sLibPath) != E_FAIL) {

	    // Load the library and get a list of all the messages.
	    HINSTANCE hInstMsgFile = LoadLibraryEx((LPCTSTR) sLibPath, NULL,
	        LOAD_LIBRARY_AS_DATAFILE);
	    if (hInstMsgFile == NULL) {
            TCHAR szMessage[MAX_STRING];
            CString sFormat;
            sFormat.LoadString(IDS_ERR_LOAD_MESSAGE_FILE_FAILED);
            _stprintf(szMessage, (LPCTSTR) sFormat, (LPCTSTR) sLibPath);
            AfxMessageBox(szMessage, MB_OK | MB_ICONSTOP);
			continue;
		}

	    EnumResourceNames(hInstMsgFile, RT_MESSAGETABLE,
	        (ENUMRESNAMEPROC)XProcessMsgTable, (LONG_PTR) this);

        GetLastError();

	    FreeLibrary(hInstMsgFile);
	}


    m_bDidLoadMessages = TRUE;
    return S_OK;
}


//**************************************************************
// CXMessageArray::GetNextPath
//
// This function extracts the next path element from a list
// of semi-colon separated paths.  It also removes the extracted
// element and the semi-colon from the path list.
//
// Paramters:
//		CString& sPathlist
//			A reference to a string consisting of one or more paths separated
//			by semi-colons.
//
//		CString& sPath
//			A reference to the place where the extracted path string
//			will be returned.
//
// Returns:
//		SCODE
//			S_OK if a path was extracted, E_FAIL otherwise.
//
//		The path is returned via sPath.  sPathlist is updated
//		so that sPath and the trailing semi-colon is removed
//
//**************************************************************
SCODE CXMessageArray::GetNextPath(CString& sPathlist, CString& sPath)
{
	CString sPathTemp;

	sPath.Empty();
	while (sPath.IsEmpty() && !sPathlist.IsEmpty()) {
		// Copy the next path from the sPathlist to sPath and
		// remove it from sPathlist
		INT ich = sPathlist.Find(_T(';'));
		if (ich == -1) {
			sPathTemp = sPathlist;
			sPathlist = _T("");
		}
		else {
			sPathTemp = sPathlist.Left(ich);
			sPathlist = sPathlist.Right( sPathlist.GetLength() - (ich + 1));
		}

		// Trim any leading or trailing space characters from
		// the path.

		// Find the first non-space character
		LPTSTR pszStart = sPathTemp.GetBuffer(sPathTemp.GetLength() + 1);
		while (*pszStart) {
			if (!_istspace(*pszStart)) {
				break;
			}			
			++pszStart;
		}
        // here, pszStart either points to the 1st non-space character or a string
        // of zero length

        // Find the first non-space character in reverse direction
        LPTSTR pszEnd = pszStart + _tcslen(pszStart); // point to the null character
        if (pszStart != pszEnd)
        {
            pszEnd--; // point to the last character
            while (_istspace(*pszEnd))
            {
                pszEnd--;
            }
            // here, pszEnd points to the first non-space character in reverse direction
            pszEnd++;
            *pszEnd = _T('\0');
        }

		sPath = pszStart;
		sPathTemp.ReleaseBuffer();
	}
	
	if (sPath.IsEmpty()) {
		return E_FAIL;
	}
	else {
		return S_OK;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpmib\dllmain.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

Abstract:

Revision history:

--*/

#include <snmp.h>
#include <snmpexts.h>
#include "mibentry.h"

SnmpTfxHandle   g_tfxHandle;
PSNMP_MGMTVARS  ge_pMgmtVars;

BOOL
SnmpExtensionInit(
    IN     DWORD                 uptimeReference,
       OUT HANDLE *              lpPollForTrapEvent,
       OUT AsnObjectIdentifier * lpFirstSupportedView)
{
    g_tfxHandle = SnmpTfxOpen(1,&view_snmp);

    if (g_tfxHandle == NULL)
        return FALSE;

    *lpFirstSupportedView = view_snmp.viewOid;
    *lpPollForTrapEvent = NULL;

    return TRUE;    
}

// the SNMP master agent calls this function immediately after SnmpExtensionInit
// in order to provide a pointer to the internal service management information.
// No mutex protection is needed so far, as there is no concurrency in writing the
// buffer pointed by this parameter.
BOOL
SnmpExtensionMonitor(
    IN  LPVOID                  pAgentMgmtVars)
{
    ge_pMgmtVars = (PSNMP_MGMTVARS)pAgentMgmtVars;
    return TRUE;
}

BOOL 
SnmpExtensionQuery(
    IN     BYTE                 requestType,
    IN OUT RFC1157VarBindList * variableBindings,
       OUT AsnInteger *         errorStatus,
       OUT AsnInteger *         errorIndex)
{
    // forward to framework
    return SnmpTfxQuery(
                g_tfxHandle,
                requestType,
                variableBindings,
                errorStatus,
                errorIndex);
}

BOOL 
SnmpExtensionTrap(
    OUT AsnObjectIdentifier *enterprise,
    OUT AsnInteger *genericTrap,
    OUT AsnInteger *specificTrap,
    OUT AsnTimeticks *timeStamp,
    OUT RFC1157VarBindList *variableBindings)
{
    // no traps
    return FALSE;
}


BOOL WINAPI
DllMain(
    HINSTANCE       hInstDLL,
    DWORD           fdwReason,
    LPVOID          pReserved)
{
    
    switch ( fdwReason )
    {
    case DLL_PROCESS_ATTACH :
        DisableThreadLibraryCalls( hInstDLL );
        break;

    case DLL_PROCESS_DETACH :
        break;

    default :
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpmib\mibentry.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

Abstract:

Revision History:

--*/

#include "snmpmgmt.h"

#ifndef _MIBENTRY_H_
#define _MIBENTRY_H_

extern SnmpMibView view_snmp;

#endif // _MIBENTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpmib\mibfuncs.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

Abstract:

Revision history:

--*/

#include <snmp.h>
#include <snmpexts.h>
#include "mibfuncs.h"

extern PSNMP_MGMTVARS   ge_pMgmtVars;

UINT
snmpMibGetHandler(
        UINT     actionId,
        AsnAny  *objectArray,
        UINT    *errorIndex)
{
    int i, j, k;

    if (ge_pMgmtVars == NULL)
        return MIB_S_ENTRY_NOT_FOUND;

    // get the number of AsnAny structures we have in the MIB's data buffer
    // and be careful not too scan further (it might be that there are more
    // management variables than objects supported by the MIB).
    k = sizeof(SNMPMIB_MGMTVARS) / sizeof(AsnAny);

    for (i = 0; k != 0 && i < NC_MAX_COUNT; i++, k--)
    {
        if (objectArray[i].asnType == ge_pMgmtVars->AsnCounterPool[i].asnType)
        {
            objectArray[i].asnValue = ge_pMgmtVars->AsnCounterPool[i].asnValue;
        }
    }

    for (j = 0; k != 0 && j < NI_MAX_COUNT; j++, k--)
    {
        if (objectArray[i + j].asnType == ge_pMgmtVars->AsnIntegerPool[j].asnType)
        {
            objectArray[i + j].asnValue = ge_pMgmtVars->AsnIntegerPool[j].asnValue;
        }
    }

    return MIB_S_SUCCESS;
}


UINT
snmpMibSetHandler(
        UINT     actionId,
        AsnAny  *objectArray,
        UINT    *errorIndex)
{
    // this function is called only for one object: snmpEnableAuthenTraps
    ge_pMgmtVars->AsnIntegerPool[IsnmpEnableAuthenTraps].asnValue = objectArray[NC_MAX_COUNT + IsnmpEnableAuthenTraps].asnValue;

    return MIB_S_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpmib\mibentry.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

Abstract:

Revision history:

--*/
#include <snmp.h>
#include <snmpexts.h>
#include "mibentry.h"
#include "mibfuncs.h"

//-----------------------------------
// OID definitions
//-----------------------------------
static UINT ids_snmp[] = {1,3,6,1,2,1,11};

static UINT ids_snmpInPkts[]                = { 1,0};
static UINT ids_snmpOutPkts[]               = { 2,0};
static UINT ids_snmpInBadVersions[]         = { 3,0};
static UINT ids_snmpInBadCommunityNames[]   = { 4,0};
static UINT ids_snmpInBadCommunityUses[]    = { 5,0};
static UINT ids_snmpInASNParseErrs[]        = { 6,0};
static UINT ids_snmpInTooBigs[]             = { 8,0};
static UINT ids_snmpInNoSuchNames[]         = { 9,0};
static UINT ids_snmpInBadValues[]           = {10,0};
static UINT ids_snmpInReadOnlys[]           = {11,0};
static UINT ids_snmpInGenErrs[]             = {12,0};
static UINT ids_snmpInTotalReqVars[]        = {13,0};
static UINT ids_snmpInTotalSetVars[]        = {14,0};
static UINT ids_snmpInGetRequests[]         = {15,0};
static UINT ids_snmpInGetNexts[]            = {16,0};
static UINT ids_snmpInSetRequests[]         = {17,0};
static UINT ids_snmpInGetResponses[]        = {18,0};
static UINT ids_snmpInTraps[]               = {19,0};
static UINT ids_snmpOutTooBigs[]            = {20,0};
static UINT ids_snmpOutNoSuchNames[]        = {21,0};
static UINT ids_snmpOutBadValues[]          = {22,0};
static UINT ids_snmpOutGenErrs[]            = {24,0};
static UINT ids_snmpOutGetRequests[]        = {25,0};
static UINT ids_snmpOutGetNexts[]           = {26,0};
static UINT ids_snmpOutSetRequests[]        = {27,0};
static UINT ids_snmpOutGetResponses[]       = {28,0};
static UINT ids_snmpOutTraps[]              = {29,0};
static UINT ids_snmpEnableAuthenTraps[]     = {30,0};

//-----------------------------------
// Views description
//-----------------------------------
SnmpMibEntry mib_snmp[] = {
    MIB_COUNTER(snmpInPkts),
    MIB_COUNTER(snmpOutPkts),
    MIB_COUNTER(snmpInBadVersions),
    MIB_COUNTER(snmpInBadCommunityNames),
    MIB_COUNTER(snmpInBadCommunityUses),
    MIB_COUNTER(snmpInASNParseErrs),
    MIB_COUNTER(snmpInTooBigs),
    MIB_COUNTER(snmpInNoSuchNames),
    MIB_COUNTER(snmpInBadValues),
    MIB_COUNTER(snmpInReadOnlys),
    MIB_COUNTER(snmpInGenErrs),
    MIB_COUNTER(snmpInTotalReqVars),
    MIB_COUNTER(snmpInTotalSetVars),
    MIB_COUNTER(snmpInGetRequests),
    MIB_COUNTER(snmpInGetNexts),
    MIB_COUNTER(snmpInSetRequests),
    MIB_COUNTER(snmpInGetResponses),
    MIB_COUNTER(snmpInTraps),
    MIB_COUNTER(snmpOutTooBigs),
    MIB_COUNTER(snmpOutNoSuchNames),
    MIB_COUNTER(snmpOutBadValues),
    MIB_COUNTER(snmpOutGenErrs),
    MIB_COUNTER(snmpOutGetRequests),
    MIB_COUNTER(snmpOutGetNexts),
    MIB_COUNTER(snmpOutSetRequests),
    MIB_COUNTER(snmpOutGetResponses),
    MIB_COUNTER(snmpOutTraps),
    MIB_INTEGER_RW(snmpEnableAuthenTraps),
    MIB_END()
};

//------------------------------------
// Views supported by this MIB
//------------------------------------
SnmpMibView view_snmp = { 
    MIB_VERSION,
    MIB_VIEW_NORMAL,
    MIB_OID(ids_snmp),
    MIB_ENTRIES(mib_snmp),
    {NULL,0}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\subagent\snmpmib\mibfuncs.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

Abstract:

Revision history:

--*/

#include "snmpmgmt.h"

#ifndef _MIBFUNCS_H_
#define _MIBFUNCS_H_

// SNMPMIB_MGMTVARS is a structure mapped onto the management
// variables defined at the master agent layer. It is another
// view on the memory space covered by the (PSNMP_MGMTVARS)pMibVariables
// defined below.
// !!!When modifying this structure, make sure to check the code in
// snmpMibGetHandler!!! - this structure is scanned based on the assumption it
// contains AsnAny objects only!!!
typedef struct
{
    AsnAny  snmpInPkts;
    AsnAny  snmpOutPkts;
    AsnAny  snmpInBadVersions;
    AsnAny  snmpInBadCommunityNames;
    AsnAny  snmpInBadCommunityUses;
    AsnAny  snmpInASNParseErrs;
    AsnAny  snmpInTooBigs;
    AsnAny  snmpInNoSuchNames;
    AsnAny  snmpInBadValues;
    AsnAny  snmpInReadOnlys;
    AsnAny  snmpInGenErrs;
    AsnAny  snmpInTotalReqVars;
    AsnAny  snmpInTotalSetVars;
    AsnAny  snmpInGetRequests;
    AsnAny  snmpInGetNexts;
    AsnAny  snmpInSetRequests;
    AsnAny  snmpInGetResponses;
    AsnAny  snmpInTraps;
    AsnAny  snmpOutTooBigs;
    AsnAny  snmpOutNoSuchNames;
    AsnAny  snmpOutBadValues;
    AsnAny  snmpOutGenErrs;
    AsnAny  snmpOutGetRequests;
    AsnAny  snmpOutGetNexts;
    AsnAny  snmpOutSetRequests;
    AsnAny  snmpOutGetResponses;
    AsnAny  snmpOutTraps;
    AsnAny  snmpEnableAuthenTraps;
} SNMPMIB_MGMTVARS;


// function handling all the GETs of this MIB
UINT
snmpMibGetHandler(
        UINT actionId,
        AsnAny *objectArray,
        UINT *errorIndex);

// function handling all the SETs of this MIB
UINT
snmpMibSetHandler(
        UINT actionId,
        AsnAny *objectArray,
        UINT *errorIndex);

//----------------------------------------------------------
//  definitions on which rely all the macros from mibentry.c
//----------------------------------------------------------
PSNMP_MGMTVARS  pMibVariables;          // obtained from the SNMP agent in SnmpExtensionMonitor()

#define gf_snmpInPkts                   snmpMibGetHandler
#define gf_snmpOutPkts                  snmpMibGetHandler
#define gf_snmpInBadVersions            snmpMibGetHandler
#define gf_snmpInBadCommunityNames      snmpMibGetHandler
#define gf_snmpInBadCommunityUses       snmpMibGetHandler
#define gf_snmpInASNParseErrs           snmpMibGetHandler
#define gf_snmpInTooBigs                snmpMibGetHandler
#define gf_snmpInNoSuchNames            snmpMibGetHandler
#define gf_snmpInBadValues              snmpMibGetHandler
#define gf_snmpInReadOnlys              snmpMibGetHandler
#define gf_snmpInGenErrs                snmpMibGetHandler
#define gf_snmpInTotalReqVars           snmpMibGetHandler
#define gf_snmpInTotalSetVars           snmpMibGetHandler
#define gf_snmpInGetRequests            snmpMibGetHandler
#define gf_snmpInGetNexts               snmpMibGetHandler
#define gf_snmpInSetRequests            snmpMibGetHandler
#define gf_snmpInGetResponses           snmpMibGetHandler
#define gf_snmpInTraps                  snmpMibGetHandler
#define gf_snmpOutTooBigs               snmpMibGetHandler
#define gf_snmpOutNoSuchNames           snmpMibGetHandler
#define gf_snmpOutBadValues             snmpMibGetHandler
#define gf_snmpOutGenErrs               snmpMibGetHandler
#define gf_snmpOutGetRequests           snmpMibGetHandler
#define gf_snmpOutGetNexts              snmpMibGetHandler
#define gf_snmpOutSetRequests           snmpMibGetHandler
#define gf_snmpOutGetResponses          snmpMibGetHandler
#define gf_snmpOutTraps                 snmpMibGetHandler
#define gf_snmpEnableAuthenTraps        snmpMibGetHandler

#define sf_snmpEnableAuthenTraps        snmpMibSetHandler

#define gb_snmpInPkts                   SNMPMIB_MGMTVARS
#define gb_snmpOutPkts                  SNMPMIB_MGMTVARS
#define gb_snmpInBadVersions            SNMPMIB_MGMTVARS
#define gb_snmpInBadCommunityNames      SNMPMIB_MGMTVARS
#define gb_snmpInBadCommunityUses       SNMPMIB_MGMTVARS
#define gb_snmpInASNParseErrs           SNMPMIB_MGMTVARS
#define gb_snmpInTooBigs                SNMPMIB_MGMTVARS
#define gb_snmpInNoSuchNames            SNMPMIB_MGMTVARS
#define gb_snmpInBadValues              SNMPMIB_MGMTVARS
#define gb_snmpInReadOnlys              SNMPMIB_MGMTVARS
#define gb_snmpInGenErrs                SNMPMIB_MGMTVARS
#define gb_snmpInTotalReqVars           SNMPMIB_MGMTVARS
#define gb_snmpInTotalSetVars           SNMPMIB_MGMTVARS
#define gb_snmpInGetRequests            SNMPMIB_MGMTVARS
#define gb_snmpInGetNexts               SNMPMIB_MGMTVARS
#define gb_snmpInSetRequests            SNMPMIB_MGMTVARS
#define gb_snmpInGetResponses           SNMPMIB_MGMTVARS
#define gb_snmpInTraps                  SNMPMIB_MGMTVARS
#define gb_snmpOutTooBigs               SNMPMIB_MGMTVARS
#define gb_snmpOutNoSuchNames           SNMPMIB_MGMTVARS
#define gb_snmpOutBadValues             SNMPMIB_MGMTVARS
#define gb_snmpOutGenErrs               SNMPMIB_MGMTVARS
#define gb_snmpOutGetRequests           SNMPMIB_MGMTVARS
#define gb_snmpOutGetNexts              SNMPMIB_MGMTVARS
#define gb_snmpOutSetRequests           SNMPMIB_MGMTVARS
#define gb_snmpOutGetResponses          SNMPMIB_MGMTVARS
#define gb_snmpOutTraps                 SNMPMIB_MGMTVARS
#define gb_snmpEnableAuthenTraps        SNMPMIB_MGMTVARS

#define sb_snmpEnableAuthenTraps        SNMPMIB_MGMTVARS

#endif // _MIBFUNCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\samples\wshsmple\wshsmple.c ===
/*++

Copyright (c) 1992 - 1996 Microsoft Corporation

Module Name:

    WshSmple.c

Abstract:

    This module contains necessary routines for the Windows Sockets
    Helper DLL.  This DLL provides the transport-specific support necessary
    for the Windows Sockets DLL to use TCP/IP as a transport.

Revision History:

        Added WinSock 2 support.

--*/

#define UNICODE
#include "wshsmple.h"
#include <tdi.h>

#include <winsock2.h>
#include <ws2tcpip.h>
#include <wsahelp.h>

#include <tdiinfo.h>

#include <smpletcp.h>

#include <nspapi.h>
#include <nspapip.h>

///////////////////////////////////////////////////
#define TCP_NAME L"TCP/IP"
#define UDP_NAME L"UDP/IP"

#define IS_DGRAM_SOCK(type)  (((type) == SOCK_DGRAM) || ((type) == SOCK_RAW))

//
// Define valid flags for WSHOpenSocket2().
//

#define VALID_TCP_FLAGS         (WSA_FLAG_OVERLAPPED)

#define VALID_UDP_FLAGS         (WSA_FLAG_OVERLAPPED |          \
                                 WSA_FLAG_MULTIPOINT_C_LEAF |   \
                                 WSA_FLAG_MULTIPOINT_D_LEAF)

//
// Buffer management constants for GetTcpipInterfaceList().
//

#define MAX_FAST_ENTITY_BUFFER ( sizeof(TDIEntityID) * 10 )
#define MAX_FAST_ADDRESS_BUFFER ( sizeof(IPAddrEntry) * 4 )


//
// Structure and variables to define the triples supported by TCP/IP. The
// first entry of each array is considered the canonical triple for
// that socket type; the other entries are synonyms for the first.
//

typedef struct _MAPPING_TRIPLE {
    INT AddressFamily;
    INT SocketType;
    INT Protocol;
} MAPPING_TRIPLE, *PMAPPING_TRIPLE;

MAPPING_TRIPLE TcpMappingTriples[] = { AF_INET,   SOCK_STREAM, IPPROTO_TCP,
                                       AF_INET,   SOCK_STREAM, 0,
                                       AF_INET,   0,           IPPROTO_TCP,
                                       AF_UNSPEC, 0,           IPPROTO_TCP,
                                       AF_UNSPEC, SOCK_STREAM, IPPROTO_TCP };

MAPPING_TRIPLE UdpMappingTriples[] = { AF_INET,   SOCK_DGRAM,  IPPROTO_UDP,
                                       AF_INET,   SOCK_DGRAM,  0,
                                       AF_INET,   0,           IPPROTO_UDP,
                                       AF_UNSPEC, 0,           IPPROTO_UDP,
                                       AF_UNSPEC, SOCK_DGRAM,  IPPROTO_UDP };

MAPPING_TRIPLE RawMappingTriples[] = { AF_INET,   SOCK_RAW,    0 };

//
// Winsock 2 WSAPROTOCOL_INFO structures for all supported protocols.
//

#define WINSOCK_SPI_VERSION 2
#define UDP_MESSAGE_SIZE    (65535-68)

WSAPROTOCOL_INFOW Winsock2Protocols[] =
    {
        //
        // TCP
        //

        {
            XP1_GUARANTEED_DELIVERY                 // dwServiceFlags1
                | XP1_GUARANTEED_ORDER
                | XP1_GRACEFUL_CLOSE
                | XP1_EXPEDITED_DATA
                | XP1_IFS_HANDLES,
            0,                                      // dwServiceFlags2
            0,                                      // dwServiceFlags3
            0,                                      // dwServiceFlags4
            PFL_MATCHES_PROTOCOL_ZERO,              // dwProviderFlags
            {                                       // gProviderId
                0, 0, 0,
                { 0, 0, 0, 0, 0, 0, 0, 0 }
            },
            0,                                      // dwCatalogEntryId
            {                                       // ProtocolChain
                BASE_PROTOCOL,                          // ChainLen
                { 0, 0, 0, 0, 0, 0, 0 }                 // ChainEntries
            },
            WINSOCK_SPI_VERSION,                    // iVersion
            AF_INET,                                // iAddressFamily
            sizeof(SOCKADDR_IN),                    // iMaxSockAddr
            sizeof(SOCKADDR_IN),                    // iMinSockAddr
            SOCK_STREAM,                            // iSocketType
            IPPROTO_TCP,                            // iProtocol
            0,                                      // iProtocolMaxOffset
            BIGENDIAN,                              // iNetworkByteOrder
            SECURITY_PROTOCOL_NONE,                 // iSecurityScheme
            0,                                      // dwMessageSize
            0,                                      // dwProviderReserved
            L"MSAFD Tcpip [TCP/IP]"                 // szProtocol
        },

        //
        // UDP
        //

        {
            XP1_CONNECTIONLESS                      // dwServiceFlags1
                | XP1_MESSAGE_ORIENTED
                | XP1_SUPPORT_BROADCAST
                | XP1_SUPPORT_MULTIPOINT
                | XP1_IFS_HANDLES,
            0,                                      // dwServiceFlags2
            0,                                      // dwServiceFlags3
            0,                                      // dwServiceFlags4
            PFL_MATCHES_PROTOCOL_ZERO,              // dwProviderFlags
            {                                       // gProviderId
                0, 0, 0,
                { 0, 0, 0, 0, 0, 0, 0, 0 }
            },
            0,                                      // dwCatalogEntryId
            {                                       // ProtocolChain
                BASE_PROTOCOL,                          // ChainLen
                { 0, 0, 0, 0, 0, 0, 0 }                 // ChainEntries
            },
            WINSOCK_SPI_VERSION,                    // iVersion
            AF_INET,                                // iAddressFamily
            sizeof(SOCKADDR_IN),                    // iMaxSockAddr
            sizeof(SOCKADDR_IN),                    // iMinSockAddr
            SOCK_DGRAM,                             // iSocketType
            IPPROTO_UDP,                            // iProtocol
            0,                                      // iProtocolMaxOffset
            BIGENDIAN,                              // iNetworkByteOrder
            SECURITY_PROTOCOL_NONE,                 // iSecurityScheme
            UDP_MESSAGE_SIZE,                       // dwMessageSize
            0,                                      // dwProviderReserved
            L"MSAFD Tcpip [UDP/IP]"                 // szProtocol
        },

        //
        // RAW
        //

        {
            XP1_CONNECTIONLESS                      // dwServiceFlags1
                | XP1_MESSAGE_ORIENTED
                | XP1_SUPPORT_BROADCAST
                | XP1_SUPPORT_MULTIPOINT
                | XP1_IFS_HANDLES,
            0,                                      // dwServiceFlags2
            0,                                      // dwServiceFlags3
            0,                                      // dwServiceFlags4
            PFL_MATCHES_PROTOCOL_ZERO               // dwProviderFlags
                | PFL_HIDDEN,
            {                                       // gProviderId
                0, 0, 0,
                { 0, 0, 0, 0, 0, 0, 0, 0 }
            },
            0,                                      // dwCatalogEntryId
            {                                       // ProtocolChain
                BASE_PROTOCOL,                          // ChainLen
                { 0, 0, 0, 0, 0, 0, 0 }                 // ChainEntries
            },
            WINSOCK_SPI_VERSION,                    // iVersion
            AF_INET,                                // iAddressFamily
            sizeof(SOCKADDR_IN),                    // iMaxSockAddr
            sizeof(SOCKADDR_IN),                    // iMinSockAddr
            SOCK_RAW,                               // iSocketType
            0,                                      // iProtocol
            255,                                    // iProtocolMaxOffset
            BIGENDIAN,                              // iNetworkByteOrder
            SECURITY_PROTOCOL_NONE,                 // iSecurityScheme
            UDP_MESSAGE_SIZE,                       // dwMessageSize
            0,                                      // dwProviderReserved
            L"MSAFD Tcpip [RAW/IP]"                 // szProtocol
        }

    };

#define NUM_WINSOCK2_PROTOCOLS  \
            ( sizeof(Winsock2Protocols) / sizeof(Winsock2Protocols[0]) )

//
// The GUID identifying this provider.
//

GUID TcpipProviderGuid = { /* e70f1aa0-ab8b-11cf-8ca3-00805f48a192 */
    0xe70f1aa0,
    0xab8b,
    0x11cf,
    {0x8c, 0xa3, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}
    };

#define TL_INSTANCE 0

//
// Forward declarations of internal routines.
//

INT
SetTdiInformation (
    IN HANDLE TdiConnectionObjectHandle,
    IN ULONG Entity,
    IN ULONG Class,
    IN ULONG Type,
    IN ULONG Id,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN BOOLEAN WaitForCompletion
    );

BOOLEAN
IsTripleInList (
    IN PMAPPING_TRIPLE List,
    IN ULONG ListLength,
    IN INT AddressFamily,
    IN INT SocketType,
    IN INT Protocol
    );

ULONG
MyInetAddr(
    IN LPWSTR String,
    OUT LPWSTR * Terminator
    );

NTSTATUS
GetTcpipInterfaceList(
    IN LPVOID OutputBuffer,
    IN DWORD OutputBufferLength,
    OUT LPDWORD NumberOfBytesReturned
    );

//
// The socket context structure for this DLL.  Each open TCP/IP socket
// will have one of these context structures, which is used to maintain
// information about the socket.
//

typedef struct _WSHTCPIP_SOCKET_CONTEXT {
    INT     AddressFamily;
    INT     SocketType;
    INT     Protocol;
    INT     ReceiveBufferSize;
    DWORD   Flags;
    INT     MulticastTtl;
    UCHAR   IpTtl;
    UCHAR   IpTos;
    UCHAR   IpDontFragment;
    UCHAR   IpOptionsLength;
    UCHAR  *IpOptions;
    ULONG   MulticastInterface;
    BOOLEAN MulticastLoopback;
    BOOLEAN KeepAlive;
    BOOLEAN DontRoute;
    BOOLEAN NoDelay;
    BOOLEAN BsdUrgent;
    BOOLEAN MultipointLeaf;
    BOOLEAN UdpNoChecksum;
    BOOLEAN Reserved3;
    IN_ADDR MultipointTarget;
    HANDLE MultipointRootTdiAddressHandle;

} WSHTCPIP_SOCKET_CONTEXT, *PWSHTCPIP_SOCKET_CONTEXT;

#define DEFAULT_RECEIVE_BUFFER_SIZE 8192
#define DEFAULT_MULTICAST_TTL 1
#define DEFAULT_MULTICAST_INTERFACE INADDR_ANY
#define DEFAULT_MULTICAST_LOOPBACK TRUE

#define DEFAULT_IP_TTL 32
#define DEFAULT_IP_TOS 0

BOOLEAN
DllInitialize (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PVOID Context OPTIONAL
    )
{

    switch ( Reason ) {

    case DLL_PROCESS_ATTACH:

        //
        // We don't need to receive thread attach and detach
        // notifications, so disable them to help application
        // performance.
        //

        DisableThreadLibraryCalls( DllHandle );

        return TRUE;

    case DLL_THREAD_ATTACH:

        break;

    case DLL_PROCESS_DETACH:

        break;

    case DLL_THREAD_DETACH:

        break;
    }

    return TRUE;

} // SockInitialize

INT
WSHGetSockaddrType (
    IN PSOCKADDR Sockaddr,
    IN DWORD SockaddrLength,
    OUT PSOCKADDR_INFO SockaddrInfo
    )

/*++

Routine Description:

    This routine parses a sockaddr to determine the type of the
    machine address and endpoint address portions of the sockaddr.
    This is called by the winsock DLL whenever it needs to interpret
    a sockaddr.

Arguments:

    Sockaddr - a pointer to the sockaddr structure to evaluate.

    SockaddrLength - the number of bytes in the sockaddr structure.

    SockaddrInfo - a pointer to a structure that will receive information
        about the specified sockaddr.


Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    UNALIGNED SOCKADDR_IN *sockaddr = (PSOCKADDR_IN)Sockaddr;
    ULONG i;

    //
    // Make sure that the address family is correct.
    //

    if ( sockaddr->sin_family != AF_INET ) {
        return WSAEAFNOSUPPORT;
    }

    //
    // Make sure that the length is correct.
    //

    if ( SockaddrLength < sizeof(SOCKADDR_IN) ) {
        return WSAEFAULT;
    }

    //
    // The address passed the tests, looks like a good address.
    // Determine the type of the address portion of the sockaddr.
    //

    if ( sockaddr->sin_addr.s_addr == INADDR_ANY ) {
        SockaddrInfo->AddressInfo = SockaddrAddressInfoWildcard;
    } else if ( sockaddr->sin_addr.s_addr == INADDR_BROADCAST ) {
        SockaddrInfo->AddressInfo = SockaddrAddressInfoBroadcast;
    } else if ( sockaddr->sin_addr.s_addr == INADDR_LOOPBACK ) {
        SockaddrInfo->AddressInfo = SockaddrAddressInfoLoopback;
    } else {
        SockaddrInfo->AddressInfo = SockaddrAddressInfoNormal;
    }

    //
    // Determine the type of the port (endpoint) in the sockaddr.
    //

    if ( sockaddr->sin_port == 0 ) {
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoWildcard;
    } else if ( ntohs( sockaddr->sin_port ) < 2000 ) {
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoReserved;
    } else {
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoNormal;
    }

    //
    // Zero out the sin_zero part of the address.  We silently allow
    // nonzero values in this field.
    //

    for ( i = 0; i < sizeof(sockaddr->sin_zero); i++ ) {
        sockaddr->sin_zero[i] = 0;
    }

    return NO_ERROR;

} // WSHGetSockaddrType


INT
WSHGetSocketInformation (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    OUT PCHAR OptionValue,
    OUT PINT OptionLength
    )

/*++

Routine Description:

    This routine retrieves information about a socket for those socket
    options supported in this helper DLL.  The options supported here
    are SO_KEEPALIVE, SO_DONTROUTE, and TCP_EXPEDITED_1122.  This routine is
    called by the winsock DLL when a level/option name combination is
    passed to getsockopt() that the winsock DLL does not understand.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're getting
        information.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    Level - the level parameter passed to getsockopt().

    OptionName - the optname parameter passed to getsockopt().

    OptionValue - the optval parameter passed to getsockopt().

    OptionLength - the optlen parameter passed to getsockopt().

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHTCPIP_SOCKET_CONTEXT context = HelperDllSocketContext;

    UNREFERENCED_PARAMETER( SocketHandle );
    UNREFERENCED_PARAMETER( TdiAddressObjectHandle );
    UNREFERENCED_PARAMETER( TdiConnectionObjectHandle );

    //
    // Check if this is an internal request for context information.
    //

    if ( Level == SOL_INTERNAL && OptionName == SO_CONTEXT ) {

        //
        // The Windows Sockets DLL is requesting context information
        // from us.  If an output buffer was not supplied, the Windows
        // Sockets DLL is just requesting the size of our context
        // information.
        //

        if ( OptionValue != NULL ) {

            //
            // Make sure that the buffer is sufficient to hold all the
            // context information.
            //

            if ( *OptionLength < sizeof(*context) ) {
                return WSAEFAULT;
            }

            //
            // Copy in the context information.
            //

            CopyMemory( OptionValue, context, sizeof(*context) );
        }

        *OptionLength = sizeof(*context);

        return NO_ERROR;
    }

    //
    // The only other levels we support here are SOL_SOCKET,
    // IPPROTO_TCP, IPPROTO_UDP, and IPPROTO_IP.
    //

    if ( Level != SOL_SOCKET &&
         Level != IPPROTO_TCP &&
         Level != IPPROTO_UDP &&
         Level != IPPROTO_IP ) {
        return WSAEINVAL;
    }

    //
    // Make sure that the output buffer is sufficiently large.
    //

    if ( *OptionLength < sizeof(int) ) {
        return WSAEFAULT;
    }

    //
    // Handle TCP-level options.
    //

    if ( Level == IPPROTO_TCP ) {

        if ( IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        switch ( OptionName ) {

        case TCP_NODELAY:

            ZeroMemory( OptionValue, *OptionLength );

            *OptionValue = context->NoDelay;
            *OptionLength = sizeof(int);
            break;

        case TCP_EXPEDITED_1122:

            ZeroMemory( OptionValue, *OptionLength );

            *OptionValue = !context->BsdUrgent;
            *OptionLength = sizeof(int);
            break;

        default:

            return WSAEINVAL;
        }

        return NO_ERROR;
    }

    //
    // Handle UDP-level options.
    //

    if ( Level == IPPROTO_UDP ) {

        switch ( OptionName ) {

        case UDP_NOCHECKSUM :

            //
            // This option is only valid for datagram sockets.
            //
            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }

            ZeroMemory( OptionValue, *OptionLength );

            *OptionValue = context->UdpNoChecksum;
            *OptionLength = sizeof(int);
            break;

        default :

            return WSAEINVAL;
        }

        return NO_ERROR;
    }

    //
    // Handle IP-level options.
    //

    if ( Level == IPPROTO_IP ) {


        //
        // Act based on the specific option.
        //
        switch ( OptionName ) {

        case IP_TTL:
            ZeroMemory( OptionValue, *OptionLength );

            *OptionValue = (int) context->IpTtl;
            *OptionLength = sizeof(int);

            return NO_ERROR;

        case IP_TOS:
            ZeroMemory( OptionValue, *OptionLength );

            *OptionValue = (int) context->IpTos;
            *OptionLength = sizeof(int);

            return NO_ERROR;

        case IP_DONTFRAGMENT:
            ZeroMemory( OptionValue, *OptionLength );

            *OptionValue = (int) context->IpDontFragment;
            *OptionLength = sizeof(int);

            return NO_ERROR;

        case IP_OPTIONS:
            if ( *OptionLength < context->IpOptionsLength ) {
                return WSAEINVAL;
            }

            ZeroMemory( OptionValue, *OptionLength );

            if (context->IpOptions != NULL) {
                MoveMemory(
                    OptionValue,
                    context->IpOptions,
                    context->IpOptionsLength
                    );
            }

            *OptionLength = context->IpOptionsLength;

            return NO_ERROR;

        default:
            //
            // No match, fall through.
            //
            break;
        }

        //
        // The following IP options are only valid on datagram sockets.
        //

        if ( !IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        //
        // Act based on the specific option.
        //
        switch ( OptionName ) {

        case IP_MULTICAST_TTL:

            ZeroMemory( OptionValue, *OptionLength );

            *OptionValue = (char)context->MulticastTtl;
            *OptionLength = sizeof(int);

            return NO_ERROR;

        case IP_MULTICAST_IF:

            *(PULONG)OptionValue = context->MulticastInterface;
            *OptionLength = sizeof(int);

            return NO_ERROR;

        case IP_MULTICAST_LOOP:

            ZeroMemory( OptionValue, *OptionLength );

            *OptionValue = context->MulticastLoopback;
            *OptionLength = sizeof(int);

            return NO_ERROR;

        default:

            return WSAENOPROTOOPT;
        }
    }

    //
    // Handle socket-level options.
    //

    switch ( OptionName ) {

    case SO_KEEPALIVE:

        if ( IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        ZeroMemory( OptionValue, *OptionLength );

        *OptionValue = context->KeepAlive;
        *OptionLength = sizeof(int);

        break;

    case SO_DONTROUTE:

        ZeroMemory( OptionValue, *OptionLength );

        *OptionValue = context->DontRoute;
        *OptionLength = sizeof(int);

        break;

    default:

        return WSAENOPROTOOPT;
    }

    return NO_ERROR;

} // WSHGetSocketInformation


INT
WSHGetWildcardSockaddr (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    )

/*++

Routine Description:

    This routine returns a wildcard socket address.  A wildcard address
    is one which will bind the socket to an endpoint of the transport's
    choosing.  For TCP/IP, a wildcard address has IP address ==
    0.0.0.0 and port = 0.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket() for the socket for which we need a wildcard
        address.

    Sockaddr - points to a buffer which will receive the wildcard socket
        address.

    SockaddrLength - receives the length of the wioldcard sockaddr.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    if ( *SockaddrLength < sizeof(SOCKADDR_IN) ) {
        return WSAEFAULT;
    }

    *SockaddrLength = sizeof(SOCKADDR_IN);

    //
    // Just zero out the address and set the family to AF_INET--this is
    // a wildcard address for TCP/IP.
    //

    ZeroMemory( Sockaddr, sizeof(SOCKADDR_IN) );

    Sockaddr->sa_family = AF_INET;

    return NO_ERROR;

} // WSAGetWildcardSockaddr


DWORD
WSHGetWinsockMapping (
    OUT PWINSOCK_MAPPING Mapping,
    IN DWORD MappingLength
    )

/*++

Routine Description:

    Returns the list of address family/socket type/protocol triples
    supported by this helper DLL.

Arguments:

    Mapping - receives a pointer to a WINSOCK_MAPPING structure that
        describes the triples supported here.

    MappingLength - the length, in bytes, of the passed-in Mapping buffer.

Return Value:

    DWORD - the length, in bytes, of a WINSOCK_MAPPING structure for this
        helper DLL.  If the passed-in buffer is too small, the return
        value will indicate the size of a buffer needed to contain
        the WINSOCK_MAPPING structure.

--*/

{
    DWORD mappingLength;

    mappingLength = sizeof(WINSOCK_MAPPING) - sizeof(MAPPING_TRIPLE) +
                        sizeof(TcpMappingTriples) + sizeof(UdpMappingTriples)
                        + sizeof(RawMappingTriples);

    //
    // If the passed-in buffer is too small, return the length needed
    // now without writing to the buffer.  The caller should allocate
    // enough memory and call this routine again.
    //

    if ( mappingLength > MappingLength ) {
        return mappingLength;
    }

    //
    // Fill in the output mapping buffer with the list of triples
    // supported in this helper DLL.
    //

    Mapping->Rows = sizeof(TcpMappingTriples) / sizeof(TcpMappingTriples[0])
                     + sizeof(UdpMappingTriples) / sizeof(UdpMappingTriples[0])
                     + sizeof(RawMappingTriples) / sizeof(RawMappingTriples[0]);
    Mapping->Columns = sizeof(MAPPING_TRIPLE) / sizeof(DWORD);
    MoveMemory(
        Mapping->Mapping,
        TcpMappingTriples,
        sizeof(TcpMappingTriples)
        );
    MoveMemory(
        (PCHAR)Mapping->Mapping + sizeof(TcpMappingTriples),
        UdpMappingTriples,
        sizeof(UdpMappingTriples)
        );
    MoveMemory(
        (PCHAR)Mapping->Mapping + sizeof(TcpMappingTriples)
                                + sizeof(UdpMappingTriples),
        RawMappingTriples,
        sizeof(RawMappingTriples)
        );

    //
    // Return the number of bytes we wrote.
    //

    return mappingLength;

} // WSHGetWinsockMapping


INT
WSHOpenSocket (
    IN OUT PINT AddressFamily,
    IN OUT PINT SocketType,
    IN OUT PINT Protocol,
    OUT PUNICODE_STRING TransportDeviceName,
    OUT PVOID *HelperDllSocketContext,
    OUT PDWORD NotificationEvents
    )
{
    return WSHOpenSocket2(
               AddressFamily,
               SocketType,
               Protocol,
               0,           // Group
               0,           // Flags
               TransportDeviceName,
               HelperDllSocketContext,
               NotificationEvents
               );

} // WSHOpenSocket


INT
WSHOpenSocket2 (
    IN OUT PINT AddressFamily,
    IN OUT PINT SocketType,
    IN OUT PINT Protocol,
    IN GROUP Group,
    IN DWORD Flags,
    OUT PUNICODE_STRING TransportDeviceName,
    OUT PVOID *HelperDllSocketContext,
    OUT PDWORD NotificationEvents
    )

/*++

Routine Description:

    Does the necessary work for this helper DLL to open a socket and is
    called by the winsock DLL in the socket() routine.  This routine
    verifies that the specified triple is valid, determines the NT
    device name of the TDI provider that will support that triple,
    allocates space to hold the socket's context block, and
    canonicalizes the triple.

Arguments:

    AddressFamily - on input, the address family specified in the
        socket() call.  On output, the canonicalized value for the
        address family.

    SocketType - on input, the socket type specified in the socket()
        call.  On output, the canonicalized value for the socket type.

    Protocol - on input, the protocol specified in the socket() call.
        On output, the canonicalized value for the protocol.

    Group - Identifies the group for the new socket.

    Flags - Zero or more WSA_FLAG_* flags as passed into WSASocket().

    TransportDeviceName - receives the name of the TDI provider that
        will support the specified triple.

    HelperDllSocketContext - receives a context pointer that the winsock
        DLL will return to this helper DLL on future calls involving
        this socket.

    NotificationEvents - receives a bitmask of those state transitions
        this helper DLL should be notified on.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHTCPIP_SOCKET_CONTEXT context;

    //
    // Determine whether this is to be a TCP, UDP, or RAW socket.
    //

    if ( IsTripleInList(
             TcpMappingTriples,
             sizeof(TcpMappingTriples) / sizeof(TcpMappingTriples[0]),
             *AddressFamily,
             *SocketType,
             *Protocol ) ) {

        //
        // It's a TCP socket. Check the flags.
        //

        if( ( Flags & ~VALID_TCP_FLAGS ) != 0 ) {

            return WSAEINVAL;

        }

        //
        // Return the canonical form of a TCP socket triple.
        //

        *AddressFamily = TcpMappingTriples[0].AddressFamily;
        *SocketType = TcpMappingTriples[0].SocketType;
        *Protocol = TcpMappingTriples[0].Protocol;

        //
        // Indicate the name of the TDI device that will service
        // SOCK_STREAM sockets in the internet address family.
        //

        RtlInitUnicodeString( TransportDeviceName, DD_TCP_DEVICE_NAME );

    } else if ( IsTripleInList(
                    UdpMappingTriples,
                    sizeof(UdpMappingTriples) / sizeof(UdpMappingTriples[0]),
                    *AddressFamily,
                    *SocketType,
                    *Protocol ) ) {

        //
        // It's a UDP socket. Check the flags & group ID.
        //

        if( ( Flags & ~VALID_UDP_FLAGS ) != 0 ||
            Group == SG_CONSTRAINED_GROUP ) {

            return WSAEINVAL;

        }

        //
        // Return the canonical form of a UDP socket triple.
        //

        *AddressFamily = UdpMappingTriples[0].AddressFamily;
        *SocketType = UdpMappingTriples[0].SocketType;
        *Protocol = UdpMappingTriples[0].Protocol;

        //
        // Indicate the name of the TDI device that will service
        // SOCK_DGRAM sockets in the internet address family.
        //

        RtlInitUnicodeString( TransportDeviceName, DD_UDP_DEVICE_NAME );

    } else if ( IsTripleInList(
                    RawMappingTriples,
                    sizeof(RawMappingTriples) / sizeof(RawMappingTriples[0]),
                    *AddressFamily,
                    *SocketType,
                    *Protocol ) )
    {
        UNICODE_STRING  unicodeString;
        NTSTATUS        status;


        //
        // There is no canonicalization to be done for SOCK_RAW.
        //

        if (*Protocol < 0 || *Protocol > 255) {
            return(WSAEINVAL);
        }

        //
        // Indicate the name of the TDI device that will service
        // SOCK_RAW sockets in the internet address family.
        //
        RtlInitUnicodeString(&unicodeString, DD_RAW_IP_DEVICE_NAME);
        RtlInitUnicodeString(TransportDeviceName, NULL);

        TransportDeviceName->MaximumLength = unicodeString.Length +
                                                 (4 * sizeof(WCHAR) +
                                                 sizeof(UNICODE_NULL));

        TransportDeviceName->Buffer = HeapAlloc(GetProcessHeap(), 0,
                                          TransportDeviceName->MaximumLength
                                          );

        if (TransportDeviceName->Buffer == NULL) {
            return(WSAENOBUFS);
        }

        //
        // Append the device name.
        //
        status = RtlAppendUnicodeStringToString(
                     TransportDeviceName,
                     &unicodeString
                     );

        ASSERT(NT_SUCCESS(status));

        //
        // Append a separator.
        //
        TransportDeviceName->Buffer[TransportDeviceName->Length/sizeof(WCHAR)] =
                                                      OBJ_NAME_PATH_SEPARATOR;

        TransportDeviceName->Length += sizeof(WCHAR);

        TransportDeviceName->Buffer[TransportDeviceName->Length/sizeof(WCHAR)] =
                                                      UNICODE_NULL;

        //
        // Append the protocol number.
        //
        unicodeString.Buffer = TransportDeviceName->Buffer +
                                 (TransportDeviceName->Length / sizeof(WCHAR));
        unicodeString.Length = 0;
        unicodeString.MaximumLength = TransportDeviceName->MaximumLength -
                                           TransportDeviceName->Length;

        status = RtlIntegerToUnicodeString(
                     (ULONG) *Protocol,
                     10,
                     &unicodeString
                     );

        TransportDeviceName->Length += unicodeString.Length;

        ASSERT(NT_SUCCESS(status));

    } else {

        //
        // This should never happen if the registry information about this
        // helper DLL is correct.  If somehow this did happen, just return
        // an error.
        //

        return WSAEINVAL;
    }

    //
    // Allocate context for this socket.  The Windows Sockets DLL will
    // return this value to us when it asks us to get/set socket options.
    //

    context = HeapAlloc(GetProcessHeap(), 0, sizeof(*context) );
    if ( context == NULL ) {
        return WSAENOBUFS;
    }

    //
    // Initialize the context for the socket.
    //

    context->AddressFamily = *AddressFamily;
    context->SocketType = *SocketType;
    context->Protocol = *Protocol;
    context->ReceiveBufferSize = DEFAULT_RECEIVE_BUFFER_SIZE;
    context->Flags = Flags;
    context->MulticastTtl = DEFAULT_MULTICAST_TTL;
    context->MulticastInterface = DEFAULT_MULTICAST_INTERFACE;
    context->MulticastLoopback = DEFAULT_MULTICAST_LOOPBACK;
    context->KeepAlive = FALSE;
    context->DontRoute = FALSE;
    context->NoDelay = FALSE;
    context->BsdUrgent = TRUE;
    context->IpDontFragment = FALSE;
    context->IpTtl = DEFAULT_IP_TTL;
    context->IpTos = DEFAULT_IP_TOS;
    context->IpOptionsLength = 0;
    context->IpOptions = NULL;
    context->MultipointLeaf = FALSE;
    context->UdpNoChecksum = FALSE;
    context->Reserved3 = FALSE;
    context->MultipointRootTdiAddressHandle = NULL;

    //
    // Tell the Windows Sockets DLL which state transitions we're
    // interested in being notified of.  The only times we need to be
    // called is after a connect has completed so that we can turn on
    // the sending of keepalives if SO_KEEPALIVE was set before the
    // socket was connected, when the socket is closed so that we can
    // free context information, and when a connect fails so that we
    // can, if appropriate, dial in to the network that will support the
    // connect attempt.
    //

    *NotificationEvents =
        WSH_NOTIFY_CONNECT | WSH_NOTIFY_CLOSE | WSH_NOTIFY_CONNECT_ERROR;

    if (*SocketType == SOCK_RAW) {
        *NotificationEvents |= WSH_NOTIFY_BIND;
    }

    //
    // Everything worked, return success.
    //

    *HelperDllSocketContext = context;
    return NO_ERROR;

} // WSHOpenSocket


INT
WSHNotify (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD NotifyEvent
    )

/*++

Routine Description:

    This routine is called by the winsock DLL after a state transition
    of the socket.  Only state transitions returned in the
    NotificationEvents parameter of WSHOpenSocket() are notified here.
    This routine allows a winsock helper DLL to track the state of
    socket and perform necessary actions corresponding to state
    transitions.

Arguments:

    HelperDllSocketContext - the context pointer given to the winsock
        DLL by WSHOpenSocket().

    SocketHandle - the handle for the socket.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    NotifyEvent - indicates the state transition for which we're being
        called.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHTCPIP_SOCKET_CONTEXT context = HelperDllSocketContext;
    INT err;

    //
    // We should only be called after a connect() completes or when the
    // socket is being closed.
    //

    if ( NotifyEvent == WSH_NOTIFY_CONNECT ) {

        ULONG true = TRUE;
        ULONG false = FALSE;

        //
        // If a connection-object option was set on the socket before
        // it was connected, set the option for real now.
        //

        if ( context->KeepAlive ) {
            err = SetTdiInformation(
                      TdiConnectionObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_CONNECTION,
                      TCP_SOCKET_KEEPALIVE,
                      &true,
                      sizeof(true),
                      FALSE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->NoDelay ) {
            err = SetTdiInformation(
                      TdiConnectionObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_CONNECTION,
                      TCP_SOCKET_NODELAY,
                      &true,
                      sizeof(true),
                      FALSE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->ReceiveBufferSize != DEFAULT_RECEIVE_BUFFER_SIZE ) {
            err = SetTdiInformation(
                      TdiConnectionObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_CONNECTION,
                      TCP_SOCKET_WINDOW,
                      &context->ReceiveBufferSize,
                      sizeof(context->ReceiveBufferSize),
                      TRUE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( !context->BsdUrgent ) {
            err = SetTdiInformation(
                      TdiConnectionObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_CONNECTION,
                      TCP_SOCKET_BSDURGENT,
                      &false,
                      sizeof(false),
                      FALSE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

    } else if ( NotifyEvent == WSH_NOTIFY_CLOSE ) {

        //
        // If this is a multipoint leaf, then remove the multipoint target
        // from the session.
        //

        if( context->MultipointLeaf &&
            context->MultipointRootTdiAddressHandle != NULL ) {

            struct ip_mreq req;

            req.imr_multiaddr = context->MultipointTarget;
            req.imr_interface.s_addr = 0;

            SetTdiInformation(
                context->MultipointRootTdiAddressHandle,
                CL_TL_ENTITY,
                INFO_CLASS_PROTOCOL,
                INFO_TYPE_ADDRESS_OBJECT,
                AO_OPTION_DEL_MCAST,
                &req,
                sizeof(req),
                TRUE
                );

        }

        //
        // Free the socket context.
        //

        if (context->IpOptions != NULL) {
            HeapFree(GetProcessHeap(), 0,
                context->IpOptions
                );
        }

        HeapFree(GetProcessHeap(), 0, context );

    } else if ( NotifyEvent == WSH_NOTIFY_CONNECT_ERROR ) {

        //
        // Return WSATRY_AGAIN to get wsock32 to attempt the connect
        // again.  Any other return code is ignored.
        //

    } else if ( NotifyEvent == WSH_NOTIFY_BIND ) {
        ULONG true = TRUE;

        if ( context->IpDontFragment ) {
            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_IP_DONTFRAGMENT,
                      &true,
                      sizeof(true),
                      FALSE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->IpTtl != DEFAULT_IP_TTL ) {
            int value = (int) context->IpTtl;

            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_TTL,
                      &value,
                      sizeof(int),
                      FALSE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->IpTtl != DEFAULT_IP_TOS ) {
            int value = (int) context->IpTos;

            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_TOS,
                      &value,
                      sizeof(int),
                      FALSE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if (context->IpOptionsLength > 0 ) {
            err = SetTdiInformation(
                        TdiAddressObjectHandle,
                        CO_TL_ENTITY,
                        INFO_CLASS_PROTOCOL,
                        INFO_TYPE_ADDRESS_OBJECT,
                        AO_OPTION_IPOPTIONS,
                        context->IpOptions,
                        context->IpOptionsLength,
                        TRUE
                        );

            if ( err != NO_ERROR ) {
                //
                // Since the set failed, free the options.
                //
                HeapFree(GetProcessHeap(), 0, context->IpOptions);
                context->IpOptions = NULL;
                context->IpOptionsLength = 0;
                return err;
            }
        }

        if( context->UdpNoChecksum ) {
            ULONG flag = FALSE;

            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CL_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_XSUM,
                      &flag,
                      sizeof(flag),
                      TRUE
                      );

            if( err != NO_ERROR ) {
                return err;
            }
        }
    } else {
        return WSAEINVAL;
    }

    return NO_ERROR;

} // WSHNotify


INT
WSHSetSocketInformation (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    IN PCHAR OptionValue,
    IN INT OptionLength
    )

/*++

Routine Description:

    This routine sets information about a socket for those socket
    options supported in this helper DLL.  The options supported here
    are SO_KEEPALIVE, SO_DONTROUTE, and TCP_EXPEDITED_1122.  This routine is
    called by the winsock DLL when a level/option name combination is
    passed to setsockopt() that the winsock DLL does not understand.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're getting
        information.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    Level - the level parameter passed to setsockopt().

    OptionName - the optname parameter passed to setsockopt().

    OptionValue - the optval parameter passed to setsockopt().

    OptionLength - the optlen parameter passed to setsockopt().

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHTCPIP_SOCKET_CONTEXT context = HelperDllSocketContext;
    INT error;
    INT optionValue;

    UNREFERENCED_PARAMETER( SocketHandle );
    UNREFERENCED_PARAMETER( TdiAddressObjectHandle );
    UNREFERENCED_PARAMETER( TdiConnectionObjectHandle );

    //
    // Check if this is an internal request for context information.
    //

    if ( Level == SOL_INTERNAL && OptionName == SO_CONTEXT ) {

        //
        // The Windows Sockets DLL is requesting that we set context
        // information for a new socket.  If the new socket was
        // accept()'ed, then we have already been notified of the socket
        // and HelperDllSocketContext will be valid.  If the new socket
        // was inherited or duped into this process, then this is our
        // first notification of the socket and HelperDllSocketContext
        // will be equal to NULL.
        //
        // Insure that the context information being passed to us is
        // sufficiently large.
        //

        if ( OptionLength < sizeof(*context) ) {
            return WSAEINVAL;
        }

        if ( HelperDllSocketContext == NULL ) {

            //
            // This is our notification that a socket handle was
            // inherited or duped into this process.  Allocate a context
            // structure for the new socket.
            //

            context = HeapAlloc(GetProcessHeap(), 0, sizeof(*context) );
            if ( context == NULL ) {
                return WSAENOBUFS;
            }

            //
            // Copy over information into the context block.
            //

            CopyMemory( context, OptionValue, sizeof(*context) );

            //
            // Tell the Windows Sockets DLL where our context information is
            // stored so that it can return the context pointer in future
            // calls.
            //

            *(PWSHTCPIP_SOCKET_CONTEXT *)OptionValue = context;

            return NO_ERROR;

        } else {

            PWSHTCPIP_SOCKET_CONTEXT parentContext;
            INT one = 1;
            INT zero = 0;

            //
            // The socket was accept()'ed and it needs to have the same
            // properties as it's parent.  The OptionValue buffer
            // contains the context information of this socket's parent.
            //

            parentContext = (PWSHTCPIP_SOCKET_CONTEXT)OptionValue;

            ASSERT( context->AddressFamily == parentContext->AddressFamily );
            ASSERT( context->SocketType == parentContext->SocketType );
            ASSERT( context->Protocol == parentContext->Protocol );

            //
            // Turn on in the child any options that have been set in
            // the parent.
            //

            if ( parentContext->KeepAlive ) {

                error = WSHSetSocketInformation(
                            HelperDllSocketContext,
                            SocketHandle,
                            TdiAddressObjectHandle,
                            TdiConnectionObjectHandle,
                            SOL_SOCKET,
                            SO_KEEPALIVE,
                            (PCHAR)&one,
                            sizeof(one)
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            if ( parentContext->DontRoute ) {

                error = WSHSetSocketInformation(
                            HelperDllSocketContext,
                            SocketHandle,
                            TdiAddressObjectHandle,
                            TdiConnectionObjectHandle,
                            SOL_SOCKET,
                            SO_DONTROUTE,
                            (PCHAR)&one,
                            sizeof(one)
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            if ( parentContext->NoDelay ) {

                error = WSHSetSocketInformation(
                            HelperDllSocketContext,
                            SocketHandle,
                            TdiAddressObjectHandle,
                            TdiConnectionObjectHandle,
                            IPPROTO_TCP,
                            TCP_NODELAY,
                            (PCHAR)&one,
                            sizeof(one)
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            if ( parentContext->ReceiveBufferSize != DEFAULT_RECEIVE_BUFFER_SIZE ) {

                error = WSHSetSocketInformation(
                            HelperDllSocketContext,
                            SocketHandle,
                            TdiAddressObjectHandle,
                            TdiConnectionObjectHandle,
                            SOL_SOCKET,
                            SO_RCVBUF,
                            (PCHAR)&parentContext->ReceiveBufferSize,
                            sizeof(parentContext->ReceiveBufferSize)
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            if ( !parentContext->BsdUrgent ) {

                error = WSHSetSocketInformation(
                            HelperDllSocketContext,
                            SocketHandle,
                            TdiAddressObjectHandle,
                            TdiConnectionObjectHandle,
                            IPPROTO_TCP,
                            TCP_EXPEDITED_1122,
                            (PCHAR)&one,
                            sizeof(one)
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            return NO_ERROR;
        }
    }

    //
    // The only other levels we support here are SOL_SOCKET,
    // IPPROTO_TCP, IPPROTO_UDP, and IPPROTO_IP.
    //

    if ( Level != SOL_SOCKET &&
         Level != IPPROTO_TCP &&
         Level != IPPROTO_UDP &&
         Level != IPPROTO_IP ) {
        return WSAEINVAL;
    }

    //
    // Make sure that the option length is sufficient.
    //

    if ( OptionLength < sizeof(int) ) {
        return WSAEFAULT;
    }

    optionValue = *(INT UNALIGNED *)OptionValue;

    //
    // Handle TCP-level options.
    //

    if ( Level == IPPROTO_TCP && OptionName == TCP_NODELAY ) {

        if ( IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        //
        // Atempt to turn on or off Nagle's algorithm, as necessary.
        //

        if ( !context->NoDelay && optionValue != 0 ) {

            optionValue = TRUE;

            //
            // NoDelay is currently off and the application wants to
            // turn it on.  If the TDI connection object handle is NULL,
            // then the socket is not yet connected.  In this case we'll
            // just remember that the no delay option was set and
            // actually turn them on in WSHNotify() after a connect()
            // has completed on the socket.
            //

            if ( TdiConnectionObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiConnectionObjectHandle,
                            CO_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_CONNECTION,
                            TCP_SOCKET_NODELAY,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            //
            // Remember that no delay is enabled for this socket.
            //

            context->NoDelay = TRUE;

        } else if ( context->NoDelay && optionValue == 0 ) {

            //
            // No delay is currently enabled and the application wants
            // to turn it off.  If the TDI connection object is NULL,
            // the socket is not yet connected.  In this case we'll just
            // remember that nodelay is disabled.
            //

            if ( TdiConnectionObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiConnectionObjectHandle,
                            CO_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_CONNECTION,
                            TCP_SOCKET_NODELAY,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            //
            // Remember that no delay is disabled for this socket.
            //

            context->NoDelay = FALSE;
        }

        return NO_ERROR;
    }

    if ( Level == IPPROTO_TCP && OptionName == TCP_EXPEDITED_1122 ) {

        if ( IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        //
        // Atempt to turn on or off BSD-style urgent data semantics as
        // necessary.
        //

        if ( !context->BsdUrgent && optionValue == 0 ) {

            optionValue = TRUE;

            //
            // BsdUrgent is currently off and the application wants to
            // turn it on.  If the TDI connection object handle is NULL,
            // then the socket is not yet connected.  In this case we'll
            // just remember that the no delay option was set and
            // actually turn them on in WSHNotify() after a connect()
            // has completed on the socket.
            //

            if ( TdiConnectionObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiConnectionObjectHandle,
                            CO_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_CONNECTION,
                            TCP_SOCKET_BSDURGENT,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            //
            // Remember that no delay is enabled for this socket.
            //

            context->BsdUrgent = TRUE;

        } else if ( context->BsdUrgent && optionValue != 0 ) {

            //
            // No delay is currently enabled and the application wants
            // to turn it off.  If the TDI connection object is NULL,
            // the socket is not yet connected.  In this case we'll just
            // remember that BsdUrgent is disabled.
            //

            if ( TdiConnectionObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiConnectionObjectHandle,
                            CO_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_CONNECTION,
                            TCP_SOCKET_BSDURGENT,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            //
            // Remember that BSD urgent is disabled for this socket.
            //

            context->BsdUrgent = FALSE;
        }

        return NO_ERROR;
    }

    //
    // Handle UDP-level options.
    //

    if ( Level == IPPROTO_UDP ) {

        switch ( OptionName ) {

        case UDP_NOCHECKSUM :

            //
            // This option is only valid for datagram sockets.
            //
            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }

            if( TdiAddressObjectHandle != NULL ) {

                ULONG flag;

                //
                // Note that the incoming flag is TRUE if XSUM should
                // be *disabled*, but the flag we pass to TDI is TRUE
                // if it should be *enabled*, so we must negate the flag.
                //

                flag = (ULONG)!optionValue;

                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_XSUM,
                            &flag,
                            sizeof(flag),
                            TRUE
                            );
                if( error != NO_ERROR ) {
                    return error;
                }

            }

            context->UdpNoChecksum = !!optionValue;
            break;

        default :

            return WSAEINVAL;
        }

        return NO_ERROR;
    }

    //
    // Handle IP-level options.
    //

    if ( Level == IPPROTO_IP ) {

        //
        // Act based on the specific option.
        //
        switch ( OptionName ) {

        case IP_TTL:

            //
            // An attempt to change the unicast TTL sent on
            // this socket.  It is illegal to set this to a value
            // greater than 255.
            //
            if ( optionValue > 255 || optionValue < 0 ) {
                return WSAEINVAL;
            }

            //
            // If we have a TDI address object, set this option to
            // the address object.  If we don't have a TDI address
            // object then we'll have to wait until after the socket
            // is bound.
            //

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_TTL,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            context->IpTtl = (uchar) optionValue;

            return NO_ERROR;

        case IP_TOS:
            //
            // An attempt to change the Type Of Service of packets sent on
            // this socket.  It is illegal to set this to a value
            // greater than 255.
            //

            if ( optionValue > 255 || optionValue < 0 ) {
                return WSAEINVAL;
            }

            //
            // If we have a TDI address object, set this option to
            // the address object.  If we don't have a TDI address
            // object then we'll have to wait until after the socket
            // is bound.
            //

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_TOS,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            context->IpTos = (uchar) optionValue;

            return NO_ERROR;

        case IP_MULTICAST_TTL:

            //
            // This option is only valid for datagram sockets.
            //
            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }

            //
            // An attempt to change the TTL on multicasts sent on
            // this socket.  It is illegal to set this to a value
            // greater than 255.
            //

            if ( optionValue > 255 || optionValue < 0 ) {
                return WSAEINVAL;
            }

            //
            // If we have a TDI address object, set this option to
            // the address object.  If we don't have a TDI address
            // object then we'll have to wait until after the socket
            // is bound.
            //

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_MCASTTTL,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }

            } else {
                return WSAEINVAL;
            }

            context->MulticastTtl = optionValue;

            return NO_ERROR;

        case IP_MULTICAST_IF:

            //
            // This option is only valid for datagram sockets.
            //
            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }

            //
            // If we have a TDI address object, set this option to
            // the address object.  If we don't have a TDI address
            // object then we'll have to wait until after the socket
            // is bound.
            //

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_MCASTIF,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }

            } else {
                return WSAEINVAL;
            }

            context->MulticastInterface = optionValue;

            return NO_ERROR;

        case IP_MULTICAST_LOOP:

            //
            // This option is only valid for datagram sockets.
            //
            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }

            //
            // Not currently supported as a settable option.
            //

            return WSAENOPROTOOPT;

        case IP_ADD_MEMBERSHIP:
        case IP_DROP_MEMBERSHIP:

            //
            // This option is only valid for datagram sockets.
            //
            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }

            //
            // Make sure that the option buffer is large enough.
            //

            if ( OptionLength < sizeof(struct ip_mreq) ) {
                return WSAEINVAL;
            }

            //
            // If we have a TDI address object, set this option to
            // the address object.  If we don't have a TDI address
            // object then we'll have to wait until after the socket
            // is bound.
            //

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            OptionName == IP_ADD_MEMBERSHIP ?
                                AO_OPTION_ADD_MCAST : AO_OPTION_DEL_MCAST,
                            OptionValue,
                            OptionLength,
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }

            } else {
                return WSAEINVAL;
            }

            context->MulticastInterface = optionValue;

            return NO_ERROR;

        default:
            //
            // No match, fall through.
            //
            break;
        }

        if ( OptionName == IP_OPTIONS ) {
            PUCHAR temp = NULL;


            //
            // Setting IP options.
            //
            if (OptionLength < 0 || OptionLength > MAX_OPT_SIZE) {
                return WSAEINVAL;
            }

            //
            // Make sure we can get memory if we need it.
            //
            if ( context->IpOptionsLength < OptionLength ) {
                temp = HeapAlloc(GetProcessHeap(), 0,
                           OptionLength
                           );

                if (temp == NULL) {
                    return WSAENOBUFS;
                }
            }


            //
            // Try to set these options. If the TDI address object handle
            // is NULL, then the socket is not yet bound.  In this case we'll
            // just remember options and actually set them in WSHNotify()
            // after a bind has completed on the socket.
            //

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CO_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_IPOPTIONS,
                            OptionValue,
                            OptionLength,
                            TRUE
                            );

                if ( error != NO_ERROR ) {
                    if (temp != NULL) {
                        HeapFree(GetProcessHeap(), 0, temp );
                    }
                    return error;
                }
            }

            //
            // They were successfully set. Copy them.
            //
            if (temp != NULL ) {
                if ( context->IpOptions != NULL ) {
                    HeapFree(GetProcessHeap(), 0, context->IpOptions );
                }
                context->IpOptions = temp;
            }

            MoveMemory(context->IpOptions, OptionValue, OptionLength);
            context->IpOptionsLength = (UCHAR)OptionLength;

            return NO_ERROR;
        }

        if ( OptionName == IP_DONTFRAGMENT ) {

            //
            // Attempt to turn on or off the DF bit in the IP header.
            //
            if ( !context->IpDontFragment && optionValue != 0 ) {

                optionValue = TRUE;

                //
                // DF is currently off and the application wants to
                // turn it on.  If the TDI address object handle is NULL,
                // then the socket is not yet bound.  In this case we'll
                // just remember that the header inclusion option was set and
                // actually turn it on in WSHNotify() after a bind
                // has completed on the socket.
                //

                if ( TdiAddressObjectHandle != NULL ) {
                    error = SetTdiInformation(
                                TdiAddressObjectHandle,
                                CO_TL_ENTITY,
                                INFO_CLASS_PROTOCOL,
                                INFO_TYPE_ADDRESS_OBJECT,
                                AO_OPTION_IP_DONTFRAGMENT,
                                &optionValue,
                                sizeof(optionValue),
                                TRUE
                                );
                    if ( error != NO_ERROR ) {
                        return error;
                    }
                }

                //
                // Remember that header inclusion is enabled for this socket.
                //

                context->IpDontFragment = TRUE;

            } else if ( context->IpDontFragment && optionValue == 0 ) {

                //
                // The DF flag is currently set and the application wants
                // to turn it off.  If the TDI address object is NULL,
                // the socket is not yet bound.  In this case we'll just
                // remember that the flag is turned off.
                //

                if ( TdiAddressObjectHandle != NULL ) {
                    error = SetTdiInformation(
                                TdiAddressObjectHandle,
                                CO_TL_ENTITY,
                                INFO_CLASS_PROTOCOL,
                                INFO_TYPE_ADDRESS_OBJECT,
                                AO_OPTION_IP_DONTFRAGMENT,
                                &optionValue,
                                sizeof(optionValue),
                                TRUE
                                );
                    if ( error != NO_ERROR ) {
                        return error;
                    }
                }

                //
                // Remember that DF flag is not set for this socket.
                //

                context->IpDontFragment = FALSE;
            }

            return NO_ERROR;
        }

        //
        // We don't support this option.
        //
        return WSAENOPROTOOPT;
    }

    //
    // Handle socket-level options.
    //

    switch ( OptionName ) {

    case SO_KEEPALIVE:

        //
        // Atempt to turn on or off keepalive sending, as necessary.
        //

        if ( IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        if ( !context->KeepAlive && optionValue != 0 ) {

            optionValue = TRUE;

            //
            // Keepalives are currently off and the application wants to
            // turn them on.  If the TDI connection object handle is
            // NULL, then the socket is not yet connected.  In this case
            // we'll just remember that the keepalive option was set and
            // actually turn them on in WSHNotify() after a connect()
            // has completed on the socket.
            //

            if ( TdiConnectionObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiConnectionObjectHandle,
                            CO_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_CONNECTION,
                            TCP_SOCKET_KEEPALIVE,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            //
            // Remember that keepalives are enabled for this socket.
            //

            context->KeepAlive = TRUE;

        } else if ( context->KeepAlive && optionValue == 0 ) {

            //
            // Keepalives are currently enabled and the application
            // wants to turn them off.  If the TDI connection object is
            // NULL, the socket is not yet connected.  In this case
            // we'll just remember that keepalives are disabled.
            //

            if ( TdiConnectionObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiConnectionObjectHandle,
                            CO_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_CONNECTION,
                            TCP_SOCKET_KEEPALIVE,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            //
            // Remember that keepalives are disabled for this socket.
            //

            context->KeepAlive = FALSE;
        }

        break;

    case SO_DONTROUTE:

        //
        // We don't really support SO_DONTROUTE.  Just remember that the
        // option was set or unset.
        //

        if ( optionValue != 0 ) {
            context->DontRoute = TRUE;
        } else if ( optionValue == 0 ) {
            context->DontRoute = FALSE;
        }

        break;

    case SO_RCVBUF:

        //
        // If the receive buffer size is being changed, tell TCP about
        // it.  Do nothing if this is a datagram.
        //

        if ( context->ReceiveBufferSize == optionValue ||
                 IS_DGRAM_SOCK(context->SocketType)
           ) {
            break;
        }

        if ( TdiConnectionObjectHandle != NULL ) {
            error = SetTdiInformation(
                        TdiConnectionObjectHandle,
                        CO_TL_ENTITY,
                        INFO_CLASS_PROTOCOL,
                        INFO_TYPE_CONNECTION,
                        TCP_SOCKET_WINDOW,
                        &optionValue,
                        sizeof(optionValue),
                        TRUE
                        );
            if ( error != NO_ERROR ) {
                return error;
            }
        }

        context->ReceiveBufferSize = optionValue;

        break;

    default:

        return WSAENOPROTOOPT;
    }

    return NO_ERROR;

} // WSHSetSocketInformation


INT
WSHEnumProtocols (
    IN LPINT lpiProtocols,
    IN LPWSTR lpTransportKeyName,
    IN OUT LPVOID lpProtocolBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Enumerates the protocols supported by this helper.

Arguments:

    lpiProtocols - Pointer to a NULL-terminated array of protocol
        identifiers. Only protocols specified in this array will
        be returned by this function. If this pointer is NULL,
        all protocols are returned.

    lpTransportKeyName -

    lpProtocolBuffer - Pointer to a buffer to fill with PROTOCOL_INFO
        structures.

    lpdwBufferLength - Pointer to a variable that, on input, contains
        the size of lpProtocolBuffer. On output, this value will be
        updated with the size of the data actually written to the buffer.

Return Value:

    INT - The number of protocols returned if successful, -1 if not.

--*/

{
    DWORD bytesRequired;
    PPROTOCOL_INFO tcpProtocolInfo;
    PPROTOCOL_INFO udpProtocolInfo;
    BOOL useTcp = FALSE;
    BOOL useUdp = FALSE;
    DWORD i;

    lpTransportKeyName;         // Avoid compiler warnings.

    //
    // Make sure that the caller cares about TCP and/or UDP.
    //

    if ( ARGUMENT_PRESENT( lpiProtocols ) ) {

        for ( i = 0; lpiProtocols[i] != 0; i++ ) {
            if ( lpiProtocols[i] == IPPROTO_TCP ) {
                useTcp = TRUE;
            }
            if ( lpiProtocols[i] == IPPROTO_UDP ) {
                useUdp = TRUE;
            }
        }

    } else {

        useTcp = TRUE;
        useUdp = TRUE;
    }

    if ( !useTcp && !useUdp ) {
        *lpdwBufferLength = 0;
        return 0;
    }

    //
    // Make sure that the caller has specified a sufficiently large
    // buffer.
    //

    bytesRequired = (sizeof(PROTOCOL_INFO) * 2) +
                        ( (wcslen( TCP_NAME ) + 1) * sizeof(WCHAR)) +
                        ( (wcslen( UDP_NAME ) + 1) * sizeof(WCHAR));

    if ( bytesRequired > *lpdwBufferLength ) {
        *lpdwBufferLength = bytesRequired;
        return -1;
    }

    //
    // Fill in TCP info, if requested.
    //

    if ( useTcp ) {

        tcpProtocolInfo = lpProtocolBuffer;

        tcpProtocolInfo->dwServiceFlags = XP_GUARANTEED_DELIVERY |
                                              XP_GUARANTEED_ORDER |
                                              XP_GRACEFUL_CLOSE |
                                              XP_EXPEDITED_DATA |
                                              XP_FRAGMENTATION;
        tcpProtocolInfo->iAddressFamily = AF_INET;
        tcpProtocolInfo->iMaxSockAddr = sizeof(SOCKADDR_IN);
        tcpProtocolInfo->iMinSockAddr = sizeof(SOCKADDR_IN);
        tcpProtocolInfo->iSocketType = SOCK_STREAM;
        tcpProtocolInfo->iProtocol = IPPROTO_TCP;
        tcpProtocolInfo->dwMessageSize = 0;
        tcpProtocolInfo->lpProtocol = (LPWSTR)
            ( (PBYTE)lpProtocolBuffer + *lpdwBufferLength -
                ( (wcslen( TCP_NAME ) + 1) * sizeof(WCHAR) ) );
        wcscpy( tcpProtocolInfo->lpProtocol, TCP_NAME );

        udpProtocolInfo = tcpProtocolInfo + 1;
        udpProtocolInfo->lpProtocol = (LPWSTR)
            ( (PBYTE)tcpProtocolInfo->lpProtocol -
                ( (wcslen( UDP_NAME ) + 1) * sizeof(WCHAR) ) );

    } else {

        udpProtocolInfo = lpProtocolBuffer;
        udpProtocolInfo->lpProtocol = (LPWSTR)
            ( (PBYTE)lpProtocolBuffer + *lpdwBufferLength -
                ( (wcslen( UDP_NAME ) + 1) * sizeof(WCHAR) ) );
    }

    //
    // Fill in UDP info, if requested.
    //

    if ( useUdp ) {

        udpProtocolInfo->dwServiceFlags = XP_CONNECTIONLESS |
                                              XP_MESSAGE_ORIENTED |
                                              XP_SUPPORTS_BROADCAST |
                                              XP_SUPPORTS_MULTICAST |
                                              XP_FRAGMENTATION;
        udpProtocolInfo->iAddressFamily = AF_INET;
        udpProtocolInfo->iMaxSockAddr = sizeof(SOCKADDR_IN);
        udpProtocolInfo->iMinSockAddr = sizeof(SOCKADDR_IN);
        udpProtocolInfo->iSocketType = SOCK_DGRAM;
        udpProtocolInfo->iProtocol = IPPROTO_UDP;
        udpProtocolInfo->dwMessageSize = UDP_MESSAGE_SIZE;
        wcscpy( udpProtocolInfo->lpProtocol, UDP_NAME );
    }

    *lpdwBufferLength = bytesRequired;

    return (useTcp && useUdp) ? 2 : 1;

} // WSHEnumProtocols



BOOLEAN
IsTripleInList (
    IN PMAPPING_TRIPLE List,
    IN ULONG ListLength,
    IN INT AddressFamily,
    IN INT SocketType,
    IN INT Protocol
    )

/*++

Routine Description:

    Determines whether the specified triple has an exact match in the
    list of triples.

Arguments:

    List - a list of triples (address family/socket type/protocol) to
        search.

    ListLength - the number of triples in the list.

    AddressFamily - the address family to look for in the list.

    SocketType - the socket type to look for in the list.

    Protocol - the protocol to look for in the list.

Return Value:

    BOOLEAN - TRUE if the triple was found in the list, false if not.

--*/

{
    ULONG i;

    //
    // Walk through the list searching for an exact match.
    //

    for ( i = 0; i < ListLength; i++ ) {

        //
        // If all three elements of the triple match, return indicating
        // that the triple did exist in the list.
        //

        if ( AddressFamily == List[i].AddressFamily &&
             SocketType == List[i].SocketType &&
             ( (Protocol == List[i].Protocol) || (SocketType == SOCK_RAW) )
           ) {
            return TRUE;
        }
    }

    //
    // The triple was not found in the list.
    //

    return FALSE;

} // IsTripleInList


INT
SetTdiInformation (
    IN HANDLE TdiConnectionObjectHandle,
    IN ULONG Entity,
    IN ULONG Class,
    IN ULONG Type,
    IN ULONG Id,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN BOOLEAN WaitForCompletion
    )

/*++

Routine Description:

    Performs a TDI action to the TCP/IP driver.  A TDI action translates
    into a streams T_OPTMGMT_REQ.

Arguments:

    TdiConnectionObjectHandle - a TDI connection object on which to perform
        the TDI action.

    Entity - value to put in the tei_entity field of the TDIObjectID
        structure.

    Class - value to put in the toi_class field of the TDIObjectID
        structure.

    Type - value to put in the toi_type field of the TDIObjectID
        structure.

    Id - value to put in the toi_id field of the TDIObjectID structure.

    Value - a pointer to a buffer to set as the information.

    ValueLength - the length of the buffer.

    WaitForCompletion - TRUE if we should wait for the TDI action to
        complete, FALSE if we're at APC level and cannot do a wait.

Return Value:

    INT - NO_ERROR, or a Windows Sockets error code.

--*/

{
    BOOL status;
    PTCP_REQUEST_SET_INFORMATION_EX setInfoEx;
    OVERLAPPED overlap;
    LPOVERLAPPED poverlap;
    static OVERLAPPED ignore_overlap;

    DWORD dwReturn;

    setInfoEx = HeapAlloc (GetProcessHeap (), 
                            0,
                            sizeof (*setInfoEx) + ValueLength);


    if (setInfoEx==NULL) {
        return WSAENOBUFS;
    }
    //
    // Initialize the TDI information buffers.
    //

    setInfoEx->ID.toi_entity.tei_entity = Entity;
    setInfoEx->ID.toi_entity.tei_instance = TL_INSTANCE;
    setInfoEx->ID.toi_class = Class;
    setInfoEx->ID.toi_type = Type;
    setInfoEx->ID.toi_id = Id;

    CopyMemory( setInfoEx->Buffer, Value, ValueLength );
    setInfoEx->BufferSize = ValueLength;

    //
    // If we need to wait for completion of the operation, create an
    // event to wait on.  If we can't wait for completion because we
    // are being called at APC level, we'll use an APC routine to
    // free the heap we allocated above.
    //

    if ( WaitForCompletion ) {

        ZeroMemory ( &overlap, sizeof(OVERLAPPED));
        overlap.hEvent = CreateEventW(
                        NULL,
                        FALSE,
                        FALSE,
                        NULL
                        );

        if (overlap.hEvent == NULL) {

            return WSAENOBUFS;
        }
        poverlap = &overlap;

    } else {
        poverlap = &ignore_overlap;
    }

    //
    // Make the actual TDI action call.  The Streams TDI mapper will
    // translate this into a TPI option management request for us and
    // give it to TCP/IP.
    //

    status = DeviceIoControl(
                 TdiConnectionObjectHandle,
                 IOCTL_TCP_SET_INFORMATION_EX,
                 setInfoEx,
                 sizeof(*setInfoEx) + ValueLength,
                 NULL,
                 0,
                 &dwReturn,	
                 poverlap
                 );	

    {
        C_ASSERT ((IOCTL_TCP_SET_INFORMATION_EX & 3)==METHOD_BUFFERED);
    }
    HeapFree (GetProcessHeap (), 0, setInfoEx);
 
    //
    // If the call pended and we were supposed to wait for completion,
    // then wait.
    //

    if ( status == FALSE && 
            ERROR_IO_PENDING == GetLastError() && 
            WaitForCompletion ) {
        status = GetOverlappedResult (TdiConnectionObjectHandle,
                                        poverlap,
                                        &dwReturn,
                                        TRUE);
    }

    if ( WaitForCompletion ) {
        CloseHandle ( overlap.hEvent );
    }

    if ( !status ) {
        return WSAENOBUFS;
    }

    return NO_ERROR;

} // SetTdiInformation


INT
WINAPI
WSHJoinLeaf (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN PVOID LeafHelperDllSocketContext,
    IN SOCKET LeafSocketHandle,
    IN PSOCKADDR Sockaddr,
    IN DWORD SockaddrLength,
    IN LPWSABUF CallerData,
    IN LPWSABUF CalleeData,
    IN LPQOS SocketQOS,
    IN LPQOS GroupQOS,
    IN DWORD Flags
    )

/*++

Routine Description:

    Performs the protocol-dependent portion of creating a multicast
    socket.

Arguments:

    The following four parameters correspond to the socket passed into
    the WSAJoinLeaf() API:

    HelperDllSocketContext - The context pointer returned from
        WSHOpenSocket().

    SocketHandle - The handle of the socket used to establish the
        multicast "session".

    TdiAddressObjectHandle - The TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - The TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    The next two parameters correspond to the newly created socket that
    identifies the multicast "session":

    LeafHelperDllSocketContext - The context pointer returned from
        WSHOpenSocket().

    LeafSocketHandle - The handle of the socket that identifies the
        multicast "session".

    Sockaddr - The name of the peer to which the socket is to be joined.

    SockaddrLength - The length of Sockaddr.

    CallerData - Pointer to user data to be transferred to the peer
        during multipoint session establishment.

    CalleeData - Pointer to user data to be transferred back from
        the peer during multipoint session establishment.

    SocketQOS - Pointer to the flowspecs for SocketHandle, one in each
        direction.

    GroupQOS - Pointer to the flowspecs for the socket group, if any.

    Flags - Flags to indicate if the socket is acting as sender,
        receiver, or both.

Return Value:

    INT - 0 if successful, a WinSock error code if not.

--*/

{

    struct ip_mreq req;
    INT err;
    PWSHTCPIP_SOCKET_CONTEXT context;

    //
    // Quick sanity checks.
    //

    if( HelperDllSocketContext == NULL ||
        SocketHandle == INVALID_SOCKET ||
        TdiAddressObjectHandle == NULL ||
        LeafHelperDllSocketContext == NULL ||
        LeafSocketHandle == INVALID_SOCKET ||
        Sockaddr == NULL ||
        Sockaddr->sa_family != AF_INET ||
        SockaddrLength < sizeof(SOCKADDR_IN) ||
        ( CallerData != NULL && CallerData->len > 0 ) ||
        ( CalleeData != NULL && CalleeData->len > 0 ) ||
        SocketQOS != NULL ||
        GroupQOS != NULL ) {

        return WSAEINVAL;

    }

    //
    // Add membership.
    //

    req.imr_multiaddr = ((LPSOCKADDR_IN)Sockaddr)->sin_addr;
    req.imr_interface.s_addr = 0;

    err = SetTdiInformation(
              TdiAddressObjectHandle,
              CL_TL_ENTITY,
              INFO_CLASS_PROTOCOL,
              INFO_TYPE_ADDRESS_OBJECT,
              AO_OPTION_ADD_MCAST,
              &req,
              sizeof(req),
              TRUE
              );

    if( err == NO_ERROR ) {

        //
        // Record this fact in the leaf socket so we can drop membership
        // when the leaf socket is closed.
        //

        context = LeafHelperDllSocketContext;

        context->MultipointLeaf = TRUE;
        context->MultipointTarget = req.imr_multiaddr;
        context->MultipointRootTdiAddressHandle = TdiAddressObjectHandle;

    }

    return err;

} // WSHJoinLeaf


INT
WINAPI
WSHGetBroadcastSockaddr (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    )

/*++

Routine Description:

    This routine returns a broadcast socket address.  A broadcast address
    may be used as a destination for the sendto() API to send a datagram
    to all interested clients.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket() for the socket for which we need a broadcast
        address.

    Sockaddr - points to a buffer which will receive the broadcast socket
        address.

    SockaddrLength - receives the length of the broadcast sockaddr.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{

    LPSOCKADDR_IN addr;

    if( *SockaddrLength < sizeof(SOCKADDR_IN) ) {

        return WSAEFAULT;

    }

    *SockaddrLength = sizeof(SOCKADDR_IN);

    //
    // Build the broadcast address.
    //

    addr = (LPSOCKADDR_IN)Sockaddr;

    ZeroMemory(
        addr,
        sizeof(*addr)
        );

    addr->sin_family = AF_INET;
    addr->sin_addr.s_addr = htonl( INADDR_BROADCAST );

    return NO_ERROR;

} // WSAGetBroadcastSockaddr


INT
WINAPI
WSHGetWSAProtocolInfo (
    IN LPWSTR ProviderName,
    OUT LPWSAPROTOCOL_INFOW * ProtocolInfo,
    OUT LPDWORD ProtocolInfoEntries
    )

/*++

Routine Description:

    Retrieves a pointer to the WSAPROTOCOL_INFOW structure(s) describing
    the protocol(s) supported by this helper.

Arguments:

    ProviderName - Contains the name of the provider, such as "TcpIp".

    ProtocolInfo - Receives a pointer to the WSAPROTOCOL_INFOW array.

    ProtocolInfoEntries - Receives the number of entries in the array.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    if( ProviderName == NULL ||
        ProtocolInfo == NULL ||
        ProtocolInfoEntries == NULL ) {

        return WSAEFAULT;

    }

    if( _wcsicmp( ProviderName, L"TcpIp" ) == 0 ) {

        *ProtocolInfo = Winsock2Protocols;
        *ProtocolInfoEntries = NUM_WINSOCK2_PROTOCOLS;

        return NO_ERROR;

    }

    return WSAEINVAL;

} // WSHGetWSAProtocolInfo


INT
WINAPI
WSHAddressToString (
    IN LPSOCKADDR Address,
    IN INT AddressLength,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    OUT LPWSTR AddressString,
    IN OUT LPDWORD AddressStringLength
    )

/*++

Routine Description:

    Converts a SOCKADDR to a human-readable form.

Arguments:

    Address - The SOCKADDR to convert.

    AddressLength - The length of Address.

    ProtocolInfo - The WSAPROTOCOL_INFOW for a particular provider.

    AddressString - Receives the formatted address string.

    AddressStringLength - On input, contains the length of AddressString.
        On output, contains the number of characters actually written
        to AddressString.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    WCHAR string[32];
    INT length;
    LPSOCKADDR_IN addr;

    //
    // Quick sanity checks.
    //

    if( Address == NULL ||
        AddressLength < sizeof(SOCKADDR_IN) ||
        AddressString == NULL ||
        AddressStringLength == NULL ) {

        return WSAEFAULT;

    }

    addr = (LPSOCKADDR_IN)Address;

    if( addr->sin_family != AF_INET ) {

        return WSA_INVALID_PARAMETER;

    }

    //
    // Do the converstion.
    //

    length = wsprintfW(
                 string,
                 L"%d.%d.%d.%d",
                 ( addr->sin_addr.s_addr >>  0 ) & 0xFF,
                 ( addr->sin_addr.s_addr >>  8 ) & 0xFF,
                 ( addr->sin_addr.s_addr >> 16 ) & 0xFF,
                 ( addr->sin_addr.s_addr >> 24 ) & 0xFF
                 );

    if( addr->sin_port != 0 ) {

        length += wsprintfW(
                      string + length,
                      L":%u",
                      ntohs( addr->sin_port )
                      );

    }

    length++;   // account for terminator

    if( *AddressStringLength < (DWORD)length ) {

        return WSAEFAULT;

    }

    *AddressStringLength = (DWORD)length;

    CopyMemory(
        AddressString,
        string,
        length * sizeof(WCHAR)
        );

    return NO_ERROR;

} // WSHAddressToString


INT
WINAPI
WSHStringToAddress (
    IN LPWSTR AddressString,
    IN DWORD AddressFamily,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    OUT LPSOCKADDR Address,
    IN OUT LPINT AddressLength
    )

/*++

Routine Description:

    Fills in a SOCKADDR structure by parsing a human-readable string.

Arguments:

    AddressString - Points to the zero-terminated human-readable string.

    AddressFamily - The address family to which the string belongs.

    ProtocolInfo - The WSAPROTOCOL_INFOW for a particular provider.

    Address - Receives the SOCKADDR structure.

    AddressLength - On input, contains the length of Address. On output,
        contains the number of bytes actually written to Address.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{
    LPWSTR terminator;
    ULONG ipAddress;
    USHORT port;
    LPSOCKADDR_IN addr;

    //
    // Quick sanity checks.
    //

    if( AddressString == NULL ||
        Address == NULL ||
        AddressLength == NULL ||
        *AddressLength < sizeof(SOCKADDR_IN) ) {

        return WSAEFAULT;

    }

    if( AddressFamily != AF_INET ) {

        return WSA_INVALID_PARAMETER;

    }

    //
    // Convert it.
    //

    ipAddress = MyInetAddr( AddressString, &terminator );

    if( ipAddress == INADDR_NONE ) {
        return WSA_INVALID_PARAMETER;
    }

    if( *terminator == L':' ) {
        WCHAR ch;
        USHORT base;

        terminator++;

        port = 0;
        base = 10;

        if( *terminator == L'0' ) {
            base = 8;
            terminator++;

            if( *terminator == L'x' ) {
                base = 16;
                terminator++;
            }
        }

        while( ch = *terminator++ ) {
            if( iswdigit(ch) ) {
                port = ( port * base ) + ( ch - L'0' );
            } else if( base == 16 && iswxdigit(ch) ) {
                port = ( port << 4 );
                port += ch + 10 - ( iswlower(ch) ? L'a' : L'A' );
            } else {
                return WSA_INVALID_PARAMETER;
            }
        }

    } else {
        port = 0;
    }

    //
    // Build the address.
    //

    ZeroMemory(
        Address,
        sizeof(SOCKADDR_IN)
        );

    addr = (LPSOCKADDR_IN)Address;
    *AddressLength = sizeof(SOCKADDR_IN);

    addr->sin_family = AF_INET;
    addr->sin_port = port;
    addr->sin_addr.s_addr = ipAddress;

    return NO_ERROR;

} // WSHStringToAddress


INT
WINAPI
WSHGetProviderGuid (
    IN LPWSTR ProviderName,
    OUT LPGUID ProviderGuid
    )

/*++

Routine Description:

    Returns the GUID identifying the protocols supported by this helper.

Arguments:

    ProviderName - Contains the name of the provider, such as "TcpIp".

    ProviderGuid - Points to a buffer that receives the provider's GUID.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    if( ProviderName == NULL ||
        ProviderGuid == NULL ) {

        return WSAEFAULT;

    }

    if( _wcsicmp( ProviderName, L"TcpIp" ) == 0 ) {

        CopyMemory(
            ProviderGuid,
            &TcpipProviderGuid,
            sizeof(GUID)
            );

        return NO_ERROR;

    }

    return WSAEINVAL;

} // WSHGetProviderGuid

ULONG
MyInetAddr(
    IN LPWSTR String,
    OUT LPWSTR * Terminator
    )

/*++

Routine Description:

    This function interprets the character string specified by the cp
    parameter.  This string represents a numeric Internet address
    expressed in the Internet standard ".'' notation.  The value
    returned is a number suitable for use as an Internet address.  All
    Internet addresses are returned in network order (bytes ordered from
    left to right).

    Internet Addresses

    Values specified using the "." notation take one of the following
    forms:

    a.b.c.d   a.b.c     a.b  a

    When four parts are specified, each is interpreted as a byte of data
    and assigned, from left to right, to the four bytes of an Internet
    address.  Note that when an Internet address is viewed as a 32-bit
    integer quantity on the Intel architecture, the bytes referred to
    above appear as "d.c.b.a''.  That is, the bytes on an Intel
    processor are ordered from right to left.

    Note: The following notations are only used by Berkeley, and nowhere
    else on the Internet.  In the interests of compatibility with their
    software, they are supported as specified.

    When a three part address is specified, the last part is interpreted
    as a 16-bit quantity and placed in the right most two bytes of the
    network address.  This makes the three part address format
    convenient for specifying Class B network addresses as
    "128.net.host''.

    When a two part address is specified, the last part is interpreted
    as a 24-bit quantity and placed in the right most three bytes of the
    network address.  This makes the two part address format convenient
    for specifying Class A network addresses as "net.host''.

    When only one part is given, the value is stored directly in the
    network address without any byte rearrangement.

Arguments:

    String - A character string representing a number expressed in the
        Internet standard "." notation.

    Terminator - Receives a pointer to the character that terminated
        the conversion.

Return Value:

    If no error occurs, inet_addr() returns an in_addr structure
    containing a suitable binary representation of the Internet address
    given.  Otherwise, it returns the value INADDR_NONE.

--*/

{
        ULONG val, base;
        WCHAR c;
        ULONG parts[4], *pp = parts;

again:
        /*
         * Collect number up to ``.''.
         * Values are specified as for C:
         * 0x=hex, 0=octal, other=decimal.
         */
        val = 0; base = 10;
        if (*String == L'0') {
                base = 8, String++;
                if (*String == L'x' || *String == L'X')
                        base = 16, String++;
        }

        while (c = *String) {
                if (iswdigit(c)) {
                        val = (val * base) + (c - L'0');
                        String++;
                        continue;
                }
                if (base == 16 && iswxdigit(c)) {
                        val = (val << 4) + (c + 10 - (islower(c) ? L'a' : L'A'));
                        String++;
                        continue;
                }
                break;
        }
        if (*String == L'.') {
                /*
                 * Internet format:
                 *      a.b.c.d
                 *      a.b.c   (with c treated as 16-bits)
                 *      a.b     (with b treated as 24 bits)
                 */
                /* GSS - next line was corrected on 8/5/89, was 'parts + 4' */
                if (pp >= parts + 3) {
                        *Terminator = String;
                        return ((ULONG) -1);
                }
                *pp++ = val, String++;
                goto again;
        }
        /*
         * Check for trailing characters.
         */
        if (*String && !iswspace(*String) && (*String != L':')) {
                *Terminator = String;
                return (INADDR_NONE);
        }
        *pp++ = val;
        /*
         * Concoct the address according to
         * the number of parts specified.
         */
        switch (pp - parts) {

        case 1:                         /* a -- 32 bits */
                val = parts[0];
                break;

        case 2:                         /* a.b -- 8.24 bits */
                if ((parts[0] > 0xff) || (parts[1] > 0xffffff)) {
                    *Terminator = String;
                    return(INADDR_NONE);
                }
                val = (parts[0] << 24) | (parts[1] & 0xffffff);
                break;

        case 3:                         /* a.b.c -- 8.8.16 bits */
                if ((parts[0] > 0xff) || (parts[1] > 0xff) ||
                    (parts[2] > 0xffff)) {
                    *Terminator = String;
                    return(INADDR_NONE);
                }
                val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
                        (parts[2] & 0xffff);
                break;

        case 4:                         /* a.b.c.d -- 8.8.8.8 bits */
                if ((parts[0] > 0xff) || (parts[1] > 0xff) ||
                    (parts[2] > 0xff) || (parts[3] > 0xff)) {
                    *Terminator = String;
                    return(INADDR_NONE);
                }
                val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
                      ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);
                break;

        default:
                *Terminator = String;
                return (INADDR_NONE);
        }

        val = htonl(val);
        *Terminator = String;
        return (val);
}

INT
WINAPI
WSHIoctl (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD IoControlCode,
    IN LPVOID InputBuffer,
    IN DWORD InputBufferLength,
    IN LPVOID OutputBuffer,
    IN DWORD OutputBufferLength,
    OUT LPDWORD NumberOfBytesReturned,
    IN LPWSAOVERLAPPED Overlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine,
    OUT LPBOOL NeedsCompletion
    )

/*++

Routine Description:

    Performs queries & controls on the socket. This is basically an
    "escape hatch" for IOCTLs not supported by MSAFD.DLL. Any unknown
    IOCTLs are routed to the socket's helper DLL for protocol-specific
    processing.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're controlling.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    IoControlCode - Control code of the operation to perform.

    InputBuffer - Address of the input buffer.

    InputBufferLength - The length of InputBuffer.

    OutputBuffer - Address of the output buffer.

    OutputBufferLength - The length of OutputBuffer.

    NumberOfBytesReturned - Receives the number of bytes actually written
        to the output buffer.

    Overlapped - Pointer to a WSAOVERLAPPED structure for overlapped
        operations.

    CompletionRoutine - Pointer to a completion routine to call when
        the operation is completed.

    NeedsCompletion - WSAIoctl() can be overlapped, with all the gory
        details that involves, such as setting events, queuing completion
        routines, and posting to IO completion ports. Since the majority
        of the IOCTL codes can be completed quickly "in-line", MSAFD.DLL
        can optionally perform the overlapped completion of the operation.

        Setting *NeedsCompletion to TRUE (the default) causes MSAFD.DLL
        to handle all of the IO completion details iff this is an
        overlapped operation on an overlapped socket.

        Setting *NeedsCompletion to FALSE tells MSAFD.DLL to take no
        further action because the helper DLL will perform any necessary
        IO completion.

        Note that if a helper performs its own IO completion, the helper
        is responsible for maintaining the "overlapped" mode of the socket
        at socket creation time and NOT performing overlapped IO completion
        on non-overlapped sockets.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    INT err;
    NTSTATUS status;

    //
    // Quick sanity checks.
    //

    if( HelperDllSocketContext == NULL ||
        SocketHandle == INVALID_SOCKET ||
        NumberOfBytesReturned == NULL ||
        NeedsCompletion == NULL ) {

        return WSAEINVAL;

    }

    *NeedsCompletion = TRUE;

    switch( IoControlCode ) {

    case SIO_MULTIPOINT_LOOPBACK :
        err = WSHSetSocketInformation(
                  HelperDllSocketContext,
                  SocketHandle,
                  TdiAddressObjectHandle,
                  TdiConnectionObjectHandle,
                  IPPROTO_IP,
                  IP_MULTICAST_LOOP,
                  (PCHAR)InputBuffer,
                  (INT)InputBufferLength
                  );
        break;

    case SIO_MULTICAST_SCOPE :
        err = WSHSetSocketInformation(
                  HelperDllSocketContext,
                  SocketHandle,
                  TdiAddressObjectHandle,
                  TdiConnectionObjectHandle,
                  IPPROTO_IP,
                  IP_MULTICAST_TTL,
                  (PCHAR)InputBuffer,
                  (INT)InputBufferLength
                  );
        break;

    case SIO_GET_INTERFACE_LIST :
        status = GetTcpipInterfaceList(
                     OutputBuffer,
                     OutputBufferLength,
                     NumberOfBytesReturned
                     );

        if( NT_SUCCESS(status) ) {
            err = NO_ERROR;
        } else if( status == STATUS_BUFFER_TOO_SMALL ) {
            err = WSAENOBUFS;
        } else {
            err = WSAENOPROTOOPT;   // SWAG
        }
        break;

    default :
        err = WSAEINVAL;
        break;
    }

    return err;

}   // WSHIoctl


NTSTATUS
GetTcpipInterfaceList(
    IN LPVOID OutputBuffer,
    IN DWORD OutputBufferLength,
    OUT LPDWORD NumberOfBytesReturned
    )

/*++

Routine Description:

    This routine queries the INTERFACE_INFO array for all supported
    IP interfaces in the system. This is a helper routine for handling
    the SIO_GET_INTERFACE_LIST IOCTL.

Arguments:

    OutputBuffer - Points to a buffer that will receive the INTERFACE_INFO
        array.

    OutputBufferLength - The length of OutputBuffer.

    NumberOfBytesReturned - Receives the number of bytes actually written
        to OutputBuffer.

Return Value:

    NTSTATUS - The completion status.

--*/

{

    NTSTATUS status;
    HANDLE deviceHandle;
    TCP_REQUEST_QUERY_INFORMATION_EX tcpRequest;
    TDIObjectID objectId;
    IPSNMPInfo snmpInfo;
    IPInterfaceInfo * interfaceInfo;
    IFEntry * ifentry;
    IPAddrEntry * addressBuffer;
    IPAddrEntry * addressScan;
    TDIEntityID * entityBuffer;
    TDIEntityID * entityScan;
    ULONG i, j;
    ULONG entityCount;
    ULONG entityBufferLength;
    ULONG entityType;
    ULONG addressBufferLength;
    LPINTERFACE_INFO outputInterfaceInfo;
    DWORD outputBytesRemaining;
    LPSOCKADDR_IN sockaddr;
    CHAR fastAddressBuffer[MAX_FAST_ADDRESS_BUFFER];
    CHAR fastEntityBuffer[MAX_FAST_ENTITY_BUFFER];
    CHAR ifentryBuffer[sizeof(IFEntry) + MAX_IFDESCR_LEN];
    CHAR interfaceInfoBuffer[sizeof(IPInterfaceInfo) + MAX_PHYSADDR_SIZE];
    DWORD dwReturn;	


    //
    // Setup locals so we know how to cleanup on exit.
    //

    deviceHandle = NULL;
    addressBuffer = NULL;
    entityBuffer = (PVOID)fastEntityBuffer;
    entityBufferLength = sizeof(fastEntityBuffer);
    interfaceInfo = NULL;

    outputInterfaceInfo = OutputBuffer;
    outputBytesRemaining = OutputBufferLength;

    //
    // Open a handle to the TCP/IP device.
    //

    deviceHandle = CreateFile (
                     DD_TCP_DEVICE_NAME,
                     GENERIC_READ | GENERIC_WRITE,
                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                     NULL,
                     OPEN_EXISTING,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL
                     );
                     

    if( INVALID_HANDLE_VALUE == deviceHandle ) {

        goto exit;

    }

    //
    // Get the entities supported by the TCP device.
    //

    ZeroMemory(
        &tcpRequest,
        sizeof(tcpRequest)
        );

    tcpRequest.ID.toi_entity.tei_entity = GENERIC_ENTITY;
    tcpRequest.ID.toi_entity.tei_instance = 0;
    tcpRequest.ID.toi_class = INFO_CLASS_GENERIC;
    tcpRequest.ID.toi_type = INFO_TYPE_PROVIDER;
    tcpRequest.ID.toi_id = ENTITY_LIST_ID;

    for( ; ; ) {

        status = DeviceIoControl(
                     deviceHandle,
                     IOCTL_TCP_QUERY_INFORMATION_EX,
                     &tcpRequest,
                     sizeof(tcpRequest),
                     entityBuffer,
                     entityBufferLength,
                     &dwReturn,	
                     NULL        // Overlapped
                     );	

        if( NT_SUCCESS(status) ) {

            break;

        }

        if( status != STATUS_BUFFER_TOO_SMALL ) {

            goto exit;

        }

        if( entityBuffer != (PVOID)fastEntityBuffer ) {

            HeapFree(GetProcessHeap(), 0,
                entityBuffer
                );

        }

        entityBuffer = HeapAlloc(GetProcessHeap(), 0,
                           entityBufferLength
                           );

        if( entityBuffer == NULL ) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit;

        }

    }

    entityCount = entityBufferLength / sizeof(*entityBuffer);

    //
    // Scan the entities looking for IP.
    //

    for( i = 0, entityScan = entityBuffer ;
         i < entityCount ;
         i++, entityScan++ ) {

        if( entityScan->tei_entity != CL_NL_ENTITY ) {

            continue;

        }

        ZeroMemory(
            &tcpRequest,
            sizeof(tcpRequest)
            );

        objectId.toi_entity = *entityScan;
        objectId.toi_class = INFO_CLASS_GENERIC;
        objectId.toi_type = INFO_TYPE_PROVIDER;
        objectId.toi_id = ENTITY_TYPE_ID;

        tcpRequest.ID = objectId;

        status = DeviceIoControl(
                     deviceHandle,
                     IOCTL_TCP_QUERY_INFORMATION_EX,
                     &tcpRequest,
                     sizeof(tcpRequest),
                     &entityType,
                     sizeof(entityType),
                     &dwReturn,	
                     NULL        // Overlapped
                     );	

        if( !NT_SUCCESS(status) ) {

            goto exit;

        }

        if( entityType != CL_NL_IP ) {

            continue;

        }

        //
        // OK, we found an IP entity. Now lookup its addresses.
        // Start by querying the number of addresses supported by
        // this interface.
        //

        ZeroMemory(
            &tcpRequest,
            sizeof(tcpRequest)
            );

        objectId.toi_class = INFO_CLASS_PROTOCOL;
        objectId.toi_id = IP_MIB_STATS_ID;

        tcpRequest.ID = objectId;

        status = DeviceIoControl(
                     deviceHandle,
                     IOCTL_TCP_QUERY_INFORMATION_EX,
                     &tcpRequest,
                     sizeof(tcpRequest),
                     &snmpInfo,
                     sizeof(snmpInfo),
                     &dwReturn,	
                     NULL        // Overlapped
                     );	

        if( !NT_SUCCESS(status) ) {

         goto exit;

        }

        if( snmpInfo.ipsi_numaddr <= 0 ) {

            continue;

        }

        //
        // This interface has addresses. Cool. Allocate a temporary
        // buffer so we can query them.
        //

        addressBufferLength = snmpInfo.ipsi_numaddr * sizeof(*addressBuffer);

        if( addressBufferLength <= sizeof(fastAddressBuffer) ) {

            addressBuffer = (PVOID)fastAddressBuffer;

        } else {

            addressBuffer = HeapAlloc(GetProcessHeap(), 0,
                                addressBufferLength
                                );

            if( addressBuffer == NULL ) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                goto exit;

            }

        }

        ZeroMemory(
            &tcpRequest,
            sizeof(tcpRequest)
            );

        objectId.toi_id = IP_MIB_ADDRTABLE_ENTRY_ID;

        tcpRequest.ID = objectId;

        status = DeviceIoControl(
                     deviceHandle,
                     IOCTL_TCP_QUERY_INFORMATION_EX,
                     &tcpRequest,
                     sizeof(tcpRequest),
                     addressBuffer,
                     addressBufferLength,
                     &dwReturn,	
                     NULL        // Overlapped
                     );	

        if( !NT_SUCCESS(status) ) {

            goto exit;

        }

        //
        // Try to get the IFEntry info so we can tell if the interface
        // is "up".
        //

        ifentry = (PVOID)ifentryBuffer;

        ZeroMemory(
            ifentryBuffer,
            sizeof(ifentryBuffer)
            );

        ZeroMemory(
            &tcpRequest,
            sizeof(tcpRequest)
            );

        addressScan = (IPAddrEntry *) addressBuffer;

        CopyMemory(
            &tcpRequest.Context,
            &addressScan->iae_addr,
            sizeof(addressScan->iae_addr)
            );

        objectId.toi_id = IF_MIB_STATS_ID;

        tcpRequest.ID = objectId;
        tcpRequest.ID.toi_entity.tei_entity = IF_ENTITY;

        status = DeviceIoControl(
                     deviceHandle,
                     IOCTL_TCP_QUERY_INFORMATION_EX,
                     &tcpRequest,
                     sizeof(tcpRequest),
                     ifentry,
                     sizeof(ifentryBuffer),
                     &dwReturn,	
                     NULL        // Overlapped
                     );	

        if( !NT_SUCCESS(status ) ) {

            ifentry->if_adminstatus = 0;

        }

        //
        // Now scan the list
        //

        for( j = 0, addressScan = addressBuffer ;
             j < snmpInfo.ipsi_numaddr ;
             j++, addressScan++ ) {

            //
            // Skip any entries that don't have IP addresses yet.
            //

            if( addressScan->iae_addr == 0 ) {

                continue;

            }

            //
            // If the output buffer is full, fail the request now.
            //

            if( outputBytesRemaining <= sizeof(*outputInterfaceInfo) ) {

                status = STATUS_BUFFER_TOO_SMALL;
                goto exit;

            }

            //
            // Setup the output structure.
            //

            ZeroMemory(
                outputInterfaceInfo,
                sizeof(*outputInterfaceInfo)
                );

            outputInterfaceInfo->iiFlags = IFF_MULTICAST;

            sockaddr = (LPSOCKADDR_IN)&outputInterfaceInfo->iiAddress;
            sockaddr->sin_addr.s_addr = addressScan->iae_addr;
            if( sockaddr->sin_addr.s_addr == htonl( INADDR_LOOPBACK ) ) {

                outputInterfaceInfo->iiFlags |= IFF_LOOPBACK;

            }

            sockaddr = (LPSOCKADDR_IN)&outputInterfaceInfo->iiNetmask;
            sockaddr->sin_addr.s_addr = addressScan->iae_mask;

            if( addressScan->iae_bcastaddr != 0 ) {

                outputInterfaceInfo->iiFlags |= IFF_BROADCAST;
                sockaddr = (LPSOCKADDR_IN)&outputInterfaceInfo->iiBroadcastAddress;
                sockaddr->sin_addr.s_addr = htonl( INADDR_BROADCAST );

            }

            //
            // for now just assume they're
            // all "up".
            //

//            if( ifentry->if_adminstatus == IF_STATUS_UP )
            {

                outputInterfaceInfo->iiFlags |= IFF_UP;

            }

            //
            // Get the IP interface info for this interface so we can
            // determine if it's "point-to-point".
            //

            interfaceInfo = (PVOID)interfaceInfoBuffer;

            ZeroMemory(
                interfaceInfoBuffer,
                sizeof(interfaceInfoBuffer)
                );

            ZeroMemory(
                &tcpRequest,
                sizeof(tcpRequest)
                );

            CopyMemory(
                &tcpRequest.Context,
                &addressScan->iae_addr,
                sizeof(addressScan->iae_addr)
                );

            objectId.toi_id = IP_INTFC_INFO_ID;

            tcpRequest.ID = objectId;

            status = DeviceIoControl(
                         deviceHandle,
                         IOCTL_TCP_QUERY_INFORMATION_EX,
                         &tcpRequest,
                         sizeof(tcpRequest),
                         interfaceInfo,
                         sizeof(interfaceInfoBuffer),
                         &dwReturn,	
                         NULL        // Overlapped
                         );	

            if( NT_SUCCESS(status) ) {

                if( interfaceInfo->iii_flags & IP_INTFC_FLAG_P2P ) {

                    outputInterfaceInfo->iiFlags |= IFF_POINTTOPOINT;

                }

            } else {

                //
                // Print something informative here, then press on.
                //

            }

            //
            // Advance to the next output structure.
            //

            outputInterfaceInfo++;
            outputBytesRemaining -= sizeof(*outputInterfaceInfo);

        }

        //
        // Free the temporary buffer.
        //

        if( addressBuffer != (PVOID)fastAddressBuffer ) {

            HeapFree(GetProcessHeap(), 0,
                addressBuffer
                );

        }

        addressBuffer = NULL;

    }

    //
    // Success!
    //

    *NumberOfBytesReturned = OutputBufferLength - outputBytesRemaining;
    status = STATUS_SUCCESS;

exit:

    if( addressBuffer != (PVOID)fastAddressBuffer &&
        addressBuffer != NULL ) {

        HeapFree(GetProcessHeap(), 0,
            addressBuffer
            );

    }

    if( entityBuffer != (PVOID)fastEntityBuffer &&
        entityBuffer != NULL ) {

        HeapFree(GetProcessHeap(), 0,
            entityBuffer
            );

    }

    if( deviceHandle != NULL ) {

        CloseHandle ( deviceHandle );

    }

    return status;

}   // GetTcpipInterfaceList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\sockreg\local.h ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    local.h

Abstract:

    Common header file for all sockutil modules.

Author:

    David Treadwell (davidtr) 5-06-92

Revision History:

--*/

#ifndef _LOCAL_
#define _LOCAL_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>

#include <stdio.h>

#endif // _LOCAL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\samples\wshsmple\smpletcp.h ===
/********************************************************************/
/**               Copyright(c) Microsoft Corp., 1990-1998          **/
/********************************************************************/
//
//  This file contains public definitions exported to transport layer and
//  application software.
//

//
// IP type definitions.
//
typedef unsigned long   IPAddr;     // An IP address.

//
// The ip_option_information structure describes the options to be
// included in the header of an IP packet. The TTL, TOS, and Flags
// values are carried in specific fields in the header. The OptionsData
// bytes are carried in the options area following the standard IP header.
// With the exception of source route options, this data must be in the
// format to be transmitted on the wire as specified in RFC 791. A source
// route option should contain the full route - first hop thru final
// destination - in the route data. The first hop will be pulled out of the
// data and the option will be reformatted accordingly. Otherwise, the route
// option should be formatted as specified in RFC 791.
//
struct ip_option_information {
    unsigned char      Ttl;             // Time To Live
    unsigned char      Tos;             // Type Of Service
    unsigned char      Flags;           // IP header flags
    unsigned char      OptionsSize;     // Size in bytes of options data
    unsigned char FAR *OptionsData;     // Pointer to options data
}; /* ip_option_information */

#define MAX_OPT_SIZE    40         // Maximum length of IP options in bytes

#define TCP_SOCKET_NODELAY      1
#define TCP_SOCKET_KEEPALIVE    2
#define TCP_SOCKET_OOBINLINE    3
#define TCP_SOCKET_BSDURGENT    4
#define TCP_SOCKET_ATMARK       5
#define TCP_SOCKET_WINDOW       6

#define AO_OPTION_TTL              1
#define AO_OPTION_MCASTTTL         2
#define AO_OPTION_MCASTIF          3
#define AO_OPTION_XSUM             4
#define AO_OPTION_IPOPTIONS        5
#define AO_OPTION_ADD_MCAST        6
#define AO_OPTION_DEL_MCAST        7
#define AO_OPTION_TOS              8
#define AO_OPTION_IP_DONTFRAGMENT  9

typedef struct IPSNMPInfo {
	ulong		ipsi_forwarding;
	ulong		ipsi_defaultttl;
	ulong		ipsi_inreceives;
	ulong		ipsi_inhdrerrors;
	ulong		ipsi_inaddrerrors;
	ulong		ipsi_forwdatagrams;
	ulong		ipsi_inunknownprotos;
	ulong		ipsi_indiscards;
	ulong		ipsi_indelivers;												
	ulong		ipsi_outrequests;
	ulong		ipsi_routingdiscards;
	ulong		ipsi_outdiscards;
	ulong		ipsi_outnoroutes;
	ulong		ipsi_reasmtimeout;
	ulong		ipsi_reasmreqds;
	ulong		ipsi_reasmoks;
	ulong		ipsi_reasmfails;
	ulong		ipsi_fragoks;
	ulong		ipsi_fragfails;
	ulong		ipsi_fragcreates;
	ulong		ipsi_numif;
	ulong		ipsi_numaddr;
	ulong		ipsi_numroutes;
} IPSNMPInfo;

typedef struct IPAddrEntry {
	ulong		iae_addr;
	ulong		iae_index;
	ulong		iae_mask;
	ulong		iae_bcastaddr;
	ulong		iae_reasmsize;
	ushort		iae_context;
	ushort		iae_pad;
} IPAddrEntry;

#define	IP_MIB_STATS_ID					1
#define	IP_MIB_ADDRTABLE_ENTRY_ID		0x102
#define IP_INTFC_FLAG_P2P   1

typedef struct IPInterfaceInfo {
    ulong       iii_flags;
    ulong       iii_mtu;
    ulong       iii_speed;
    ulong       iii_addrlength;
    uchar       iii_addr[1];
} IPInterfaceInfo;

#define	IF_MIB_STATS_ID		1
#define	MAX_PHYSADDR_SIZE	8
#define	MAX_IFDESCR_LEN			256

typedef struct IFEntry {
	ulong			if_index;
	ulong			if_type;
	ulong			if_mtu;
	ulong			if_speed;
	ulong			if_physaddrlen;
	uchar			if_physaddr[MAX_PHYSADDR_SIZE];
	ulong			if_adminstatus;
	ulong			if_operstatus;
	ulong			if_lastchange;
	ulong			if_inoctets;
	ulong			if_inucastpkts;
	ulong			if_innucastpkts;
	ulong			if_indiscards;
	ulong			if_inerrors;
	ulong			if_inunknownprotos;
	ulong			if_outoctets;
	ulong			if_outucastpkts;
	ulong			if_outnucastpkts;
	ulong			if_outdiscards;
	ulong			if_outerrors;
	ulong			if_outqlen;
	ulong			if_descrlen;
	uchar			if_descr[1];
} IFEntry;

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to CreateFile when accessing the device.
//
#define DD_TCP_DEVICE_NAME      L"\\Device\\Tcp"
#define DD_UDP_DEVICE_NAME      L"\\Device\\Udp"
#define DD_RAW_IP_DEVICE_NAME   L"\\Device\\RawIp"

#define FSCTL_TCP_BASE     FILE_DEVICE_NETWORK

#define _TCP_CTL_CODE(function, method, access) \
            CTL_CODE(FSCTL_TCP_BASE, function, method, access)

#define IOCTL_TCP_QUERY_INFORMATION_EX  \
            _TCP_CTL_CODE(0, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_TCP_SET_INFORMATION_EX  \
            _TCP_CTL_CODE(1, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IP_INTFC_INFO_ID                0x103
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\sockreg\sockreg.c ===
//
//  Determine which -- if any -- of these routines are in use
//      in sockets project and dump remainder (hopefully whole directory)
//      this is ancient stuff, most of which has long been superceded
//  They are actually still used.
//

#include "local.h"

#define malloc(x)   RtlAllocateHeap( RtlProcessHeap(), 0, (x) )
#define free(p)     RtlFreeHeap( RtlProcessHeap(), 0, (p) )


#define WORK_BUFFER_SIZE  1024

char VTCPPARM[] = "\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcp\\VParameters";
char NTCPPARM[] = "\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcp\\Parameters";
char TCPPARM[] = "\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcpip\\Parameters";
char TTCPPARM[] = "\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Transient";

#ifdef TRACE
void
UnicodePrint(
    PUNICODE_STRING  UnicodeString
    )

/*++

Routine Description:

    Print a unicode string.

Arguments:

    UnicodeString - pointer to the string.

Return Value:

    None.

--*/
{
    ANSI_STRING ansiString;
    PUCHAR      tempbuffer = (PUCHAR) malloc(WORK_BUFFER_SIZE);

    ansiString.MaximumLength = WORK_BUFFER_SIZE;
    ansiString.Length = 0L;
    ansiString.Buffer = tempbuffer;

    RtlUnicodeStringToAnsiString(&ansiString,
                                 UnicodeString,
                                 FALSE);
    printf("%s", ansiString.Buffer);
    free(tempbuffer);
    return;
}
#endif


NTSTATUS
SockOpenKey(
    PHANDLE HandlePtr,
    PUCHAR  KeyName
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS          status;
    STRING            keyString;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING    unicodeKeyName;

    RtlInitString(&keyString,
                  KeyName);

    (VOID)RtlAnsiStringToUnicodeString(&unicodeKeyName,
                                       &keyString,
                                       TRUE);

#ifdef TRACE
    printf("SockOpenKey = ");
    UnicodePrint(&unicodeKeyName);
    printf("\n");
#endif

    memset(&objectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));
    InitializeObjectAttributes(&objectAttributes,
                               &unicodeKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtOpenKey(HandlePtr,
                       KEY_READ,
                       &objectAttributes);

    RtlFreeUnicodeString(&unicodeKeyName);

#ifdef TRACE
    if (!NT_SUCCESS(status)) {
        printf("Failed NtOpenKey for %s => %x\n",
               KeyName,
               status);
    }
#endif

    return status;
}

NTSTATUS
SockOpenKeyEx(
    PHANDLE HandlePtr,
    PUCHAR  KeyName1,
    PUCHAR  KeyName2,
    PUCHAR  KeyName3
    )

{
    NTSTATUS          status;

    status = SockOpenKey(HandlePtr, KeyName1);
    if (NT_SUCCESS(status) || (KeyName2 == NULL && KeyName3 == NULL)) {
        return status;
    }

    status = SockOpenKey(HandlePtr, KeyName2);
    if (NT_SUCCESS(status) || KeyName3 == NULL) {
        return status;
    }

    return SockOpenKey(HandlePtr, KeyName3);
}



NTSTATUS
SockGetSingleValue(
    HANDLE KeyHandle,
    PUCHAR ValueName,
    PUCHAR ValueData,
    PULONG ValueType,
    ULONG  ValueLength
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS                    status;
    ULONG                       resultLength;
    PKEY_VALUE_FULL_INFORMATION keyValueFullInformation;
    UNICODE_STRING              uValueName;
    ANSI_STRING                 aValueName;
    UNICODE_STRING              uValueData;
    ANSI_STRING                 aValueData;


#ifdef TRACE
   printf("SockGetSingleValue: %s\n", ValueName);
#endif
    if ((keyValueFullInformation =
            (PKEY_VALUE_FULL_INFORMATION)malloc(WORK_BUFFER_SIZE)) == NULL) {
        return(STATUS_NO_MEMORY);
    }


    RtlZeroMemory(keyValueFullInformation, WORK_BUFFER_SIZE);

    uValueName.Length = 0L;
    uValueName.MaximumLength = WORK_BUFFER_SIZE;

    if ((uValueName.Buffer = (PWSTR)malloc(WORK_BUFFER_SIZE)) == NULL) {
        free(keyValueFullInformation);
        return(STATUS_NO_MEMORY);
    }

    aValueName.MaximumLength = WORK_BUFFER_SIZE;
    aValueName.Length = (USHORT) strlen(ValueName);
    aValueName.Buffer = (PCHAR)ValueName;

    RtlAnsiStringToUnicodeString(&uValueName,
                                 &aValueName,
                                 FALSE);

    status = NtQueryValueKey(KeyHandle,
                             &uValueName,
                             KeyValueFullInformation,
                             keyValueFullInformation,
                             WORK_BUFFER_SIZE,
                             &resultLength);

    if (!NT_SUCCESS(status)) {
        free(uValueName.Buffer);
        free(keyValueFullInformation);
        return status;
    }

    *ValueType = keyValueFullInformation->Type;

    if (*ValueType != REG_DWORD && *ValueType != REG_BINARY) {

        aValueData.Length = 0L;

        if (*ValueType == REG_EXPAND_SZ) {

            aValueData.Buffer = (PVOID)uValueName.Buffer;
            aValueData.MaximumLength = WORK_BUFFER_SIZE;

        } else {

            free(uValueName.Buffer);
            aValueData.Buffer = (PCHAR)ValueData;
            aValueData.MaximumLength = (USHORT)ValueLength;

        }

        uValueData.Length = (USHORT)keyValueFullInformation->DataLength;
        uValueData.MaximumLength = (USHORT)keyValueFullInformation->DataLength;
        uValueData.Buffer = (PWSTR)((PCHAR)keyValueFullInformation +
                                      keyValueFullInformation->DataOffset);

        RtlUnicodeStringToAnsiString(&aValueData,
                                     &uValueData,
                                     FALSE);

        if (*ValueType == REG_EXPAND_SZ) {
            resultLength = ExpandEnvironmentStringsA(
                                 aValueData.Buffer,
                                 ValueData,
                                 ValueLength);
            free(aValueData.Buffer);
        }

    } else {
        *((PULONG)ValueData) = *((PULONG)((PCHAR)keyValueFullInformation +
                                 keyValueFullInformation->DataOffset));
        free(uValueName.Buffer);
    }

    free(keyValueFullInformation);
    return status;
}

NTSTATUS
SockSetSingleValue(
    HANDLE KeyHandle,
    PUCHAR ValueName,
    PUCHAR ValueData,
    ULONG  ValueType,
    ULONG  ValueLength
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS                    status;
    UNICODE_STRING              uValueName;
    ANSI_STRING                 aValueName;
    UNICODE_STRING              uData;
    ANSI_STRING                 aData;
    BOOL                        fallocatedUdata = FALSE;

#ifdef TRACE
   printf("SockSetSingleValue: %s\n", ValueName);
#endif

    uValueName.Length = 0L;
    uValueName.MaximumLength = WORK_BUFFER_SIZE;

    //
    // Convert the key name to unicode.
    //

    if ((uValueName.Buffer = (PWSTR)malloc(WORK_BUFFER_SIZE)) == NULL) {
        return(STATUS_NO_MEMORY);
    } else {
        aValueName.MaximumLength = WORK_BUFFER_SIZE;
        aValueName.Length = (USHORT) strlen(ValueName);
        aValueName.Buffer = (PCHAR)ValueName;

        RtlAnsiStringToUnicodeString(&uValueName,
                                     &aValueName,
                                     FALSE);
    }

    if ( ValueType == REG_SZ || ValueType == REG_MULTI_SZ ) {

        if ((uData.Buffer = (PWSTR)malloc(WORK_BUFFER_SIZE)) == NULL)
        {
            free( uValueName.Buffer );
            return(STATUS_NO_MEMORY);
        }
        fallocatedUdata = TRUE;
        uData.MaximumLength = WORK_BUFFER_SIZE;

        //
        // Need to convert the value data from ASCII to unicode
        // before writing it to the registry
        //

        aData.Length = (USHORT)ValueLength;
        aData.MaximumLength = aData.Length;
        aData.Buffer = ValueData;

        RtlAnsiStringToUnicodeString(&uData,
                                     &aData,
                                     FALSE);
    } else {
        uData.Buffer = (PWCHAR)ValueData;
        uData.Length = (USHORT)ValueLength;
    }

    status = NtSetValueKey(KeyHandle,
                           &uValueName,
                           0,
                           ValueType,
                           uData.Buffer,
                           uData.Length );

    if ( fallocatedUdata )
    {
        free( uData.Buffer );
    }
    free(uValueName.Buffer);

    return status;
}



FILE *
SockOpenNetworkDataBase(
    IN  char *Database,
    OUT char *Pathname,
    IN  int   PathnameLen,
    IN  char *OpenFlags
    )
{
    PUCHAR     temp;
    HANDLE     myKey;
    NTSTATUS   status;
    ULONG      myType;

    //
    // Try to open both TCP/IP parameters keys, both old stack and new
    // stack.
    //

    status = SockOpenKeyEx(&myKey, VTCPPARM, NTCPPARM, TCPPARM);
    if (!NT_SUCCESS(status)) {
        SetLastError( ERROR_CANTOPEN );
        return(NULL);
    }

    if ((temp=malloc(WORK_BUFFER_SIZE))==NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        NtClose(myKey);
        return(NULL);
    }

    status = SockGetSingleValue(myKey, "DatabasePath", temp, &myType, WORK_BUFFER_SIZE);
    NtClose(myKey);

    if (!NT_SUCCESS(status)) {
        SetLastError( ERROR_CANTREAD );
        free(temp);
        return(NULL);
    }

    if ( ((int) (strlen(temp) + strlen(Database) + 2)) > PathnameLen) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        free(temp);
        return(NULL);
    }

    strcpy(Pathname, temp);
    strcat(Pathname, "\\");
    strcat(Pathname, Database);

    free(temp);
    return(fopen(Pathname, OpenFlags));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\samples\wshsmple\wshsmple.h ===
/********************************************************************/
/**               Copyright(c) Microsoft Corp., 1990-1998          **/
/********************************************************************/

#include <excpt.h>
#include <bugcodes.h>
#include <ntiologc.h>
#include <devioctl.h>
#include <windows.h>
typedef LONG NTSTATUS;
typedef NTSTATUS *PNTSTATUS;

///// From NTDEF.h ////
//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

//
// Determine if an argument is present by testing the value of the pointer
// to the argument value.
//

#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)(ArgumentPointer) != (CHAR *)(NULL) )

//
// Unicode strings are counted 16-bit character strings. If they are
// NULL terminated, Length does not include trailing NULL.
//
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
#define UNICODE_NULL ((WCHAR)0) // winnt

typedef UNICODE_STRING *PUNICODE_STRING;


//// From NTDDK.H /////
//
// Define the base asynchronous I/O argument types
//

#define OBJ_NAME_PATH_SEPARATOR ((WCHAR)L'\\')

#if DBG
NTSYSAPI
VOID
NTAPI
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#define ASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, msg )

#else
#define ASSERT( exp )
#define ASSERTMSG( msg, exp )
#endif // DBG

NTSYSAPI
VOID
NTAPI
RtlInitUnicodeString(
    PUNICODE_STRING DestinationString,
    PCWSTR SourceString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeStringToString (
    PUNICODE_STRING Destination,
    PUNICODE_STRING Source
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlIntegerToUnicodeString (
    ULONG Value,
    ULONG Base,
    PUNICODE_STRING String
    );


///////////////////
// From NTSTATUS.H

//
// MessageId: STATUS_BUFFER_TOO_SMALL
//
// MessageText:
//
//  {Buffer Too Small}
//  The buffer is too small to contain the entry.  No information has been
//  written to the buffer.
//
#define STATUS_BUFFER_TOO_SMALL          ((NTSTATUS)0xC0000023L)

//
// MessageId: STATUS_INSUFFICIENT_RESOURCES
//
// MessageText:
//
//  Insufficient system resources exist to complete the API.
//
#define STATUS_INSUFFICIENT_RESOURCES    ((NTSTATUS)0xC000009AL)     // ntsubauth

//
// The success status codes 0 - 63 are reserved for wait completion status.
//
#define STATUS_SUCCESS                          ((NTSTATUS)0x00000000L) // ntsubauth
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\inc\dt_dll.h ===
/*++

Copyright (c) 1995 Intel Corp

File Name:

    dt_dll.h

Abstract:

    This header describes the interface to the WinSock 2 debug/trace
    DLL.  Please see the design spec for more information.

Author:

    Michael A. Grafton

--*/

#ifndef _DT_DLL_H
#define _DT_DLL_H

#include "warnoff.h"
#include <windows.h>


//
// This type defines a pointer to the Pre/PostApiNotify functions
//

typedef BOOL (WINAPIV * LPFNWSANOTIFY)(
    IN  INT    NotificationCode,
    OUT LPVOID ReturnCode,
    IN  LPSTR  LibraryName,
    ...);

//
// Function prototypes for Pre/PostApiNotify
//

BOOL WINAPIV
WSAPreApiNotify(
    IN  INT    NotificationCode,
    OUT LPVOID ReturnCode,
    IN  LPSTR  LibraryName,
    ...);

BOOL WINAPIV
WSAPostApiNotify(
    IN  INT    NotificationCode,
    OUT LPVOID ReturnCode,
    IN  LPSTR  LibraryName,
    ...);

//
// Pointer to an exception notification function.
//

typedef
VOID
(WINAPI * LPFNWSAEXCEPTIONNOTIFY)(
    IN LPEXCEPTION_POINTERS ExceptionPointers
    );

//
// Function prototype for exception notify.
//

VOID
WINAPI
WSAExceptionNotify(
    IN LPEXCEPTION_POINTERS ExceptionPointers
    );


//
// API function codes for Pre/PostApiNotify functions.  Note:  These must start
// at  1  or more and be fairly densely assigned.  Small gaps can be tolerated.
// Note  that  a  "MAX_DTCODE"  definition  should  be updated if new codes are
// added.
//

#define DTCODE_accept 1
#define DTCODE_bind 2
#define DTCODE_closesocket 3
#define DTCODE_connect 4
#define DTCODE_getpeername 5
#define DTCODE_getsockname 6
#define DTCODE_getsockopt 7
#define DTCODE_htonl 8
#define DTCODE_htons 9
#define DTCODE_ioctlsocket 10
#define DTCODE_listen 11
#define DTCODE_ntohl 12
#define DTCODE_ntohs 13
#define DTCODE_recv 14
#define DTCODE_recvfrom 15
#define DTCODE_select 16
#define DTCODE_send 17
#define DTCODE_sendto 18
#define DTCODE_setsockopt 19
#define DTCODE_shutdown 20
#define DTCODE_socket 21
#define DTCODE_WSAAccept 22
#define DTCODE_WSAAsyncSelect 23
#define DTCODE_WSACancelBlockingCall 24
#define DTCODE_WSACleanup 25
#define DTCODE_WSACloseEvent 26
#define DTCODE_WSAConnect 27
#define DTCODE_WSACreateEvent 28
#define DTCODE_WSADuplicateSocketA 29
#define DTCODE_WSAEnumNetworkEvents 30
#define DTCODE_WSAEnumProtocolsA 31
#define DTCODE_WSAEventSelect 32
#define DTCODE_WSAGetLastError 33
#define DTCODE_WSAGetOverlappedResult 34
#define DTCODE_WSAGetQOSByName 35
#define DTCODE_WSAHtonl 36
#define DTCODE_WSAHtons 37
#define DTCODE_WSAIoctl 38
#define DTCODE_WSAIsBlocking 39
#define DTCODE_WSAJoinLeaf 40
#define DTCODE_WSANtohl 41
#define DTCODE_WSANtohs 42
#define DTCODE_WSARecv 43
#define DTCODE_WSARecvDisconnect 44
#define DTCODE_WSARecvFrom 45
#define DTCODE_WSAResetEvent 46
#define DTCODE_WSASend 47
#define DTCODE_WSASendDisconnect 48
#define DTCODE_WSASendTo 49
#define DTCODE_WSASetBlockingHook 50
#define DTCODE_WSASetEvent 51
#define DTCODE_WSASetLastError 52
#define DTCODE_WSASocketA 53
#define DTCODE_WSAStartup 54
#define DTCODE_WSAUnhookBlockingHook 55
#define DTCODE_WSAWaitForMultipleEvents 56
#define DTCODE_gethostbyaddr 57
#define DTCODE_gethostbyname 58
#define DTCODE_gethostname 59
#define DTCODE_getprotobyname 60
#define DTCODE_getprotobynumber 61
#define DTCODE_getservbyname 62
#define DTCODE_getservbyport 63
#define DTCODE_inet_addr 64
#define DTCODE_inet_ntoa 65
#define DTCODE_WSAAsyncGetHostByAddr 66
#define DTCODE_WSAAsyncGetHostByName 67
#define DTCODE_WSAAsyncGetProtoByName 68
#define DTCODE_WSAAsyncGetProtoByNumber 69
#define DTCODE_WSAAsyncGetServByName 70
#define DTCODE_WSAAsyncGetServByPort 71
#define DTCODE_WSACancelAsyncRequest 72
#define DTCODE_WSPAccept 73
#define DTCODE_WSPAsyncSelect 74
#define DTCODE_WSPBind 75
#define DTCODE_WSPCancelBlockingCall 76
#define DTCODE_WSPCleanup 77
#define DTCODE_WSPCloseSocket 78
#define DTCODE_WSPConnect 79
#define DTCODE_WSPDuplicateSocket 80
#define DTCODE_WSPEnumNetworkEvents 81
#define DTCODE_WSPEventSelect 82
#define DTCODE_WSPGetOverlappedResult 83
#define DTCODE_WSPGetPeerName 84
// The  WSPGetProcTable  function  has  been removed, but the code numbers have
// been kept the same.
// #define DTCODE_WSPGetProcTable 85
#define DTCODE_WSPGetSockName 86
#define DTCODE_WSPGetSockOpt 87
#define DTCODE_WSPGetQOSByName 88
#define DTCODE_WSPIoctl 89
#define DTCODE_WSPJoinLeaf 90
#define DTCODE_WSPListen 91
#define DTCODE_WSPRecv 92
#define DTCODE_WSPRecvDisconnect 93
#define DTCODE_WSPRecvFrom 94
#define DTCODE_WSPSelect 95
#define DTCODE_WSPSend 96
#define DTCODE_WSPSendDisconnect 97
#define DTCODE_WSPSendTo 98
#define DTCODE_WSPSetSockOpt 99
#define DTCODE_WSPShutdown 100
#define DTCODE_WSPSocket 101
#define DTCODE_WSPStartup 102
#define DTCODE_WPUCloseEvent 103
#define DTCODE_WPUCloseSocketHandle 104
#define DTCODE_WPUCreateEvent 105
#define DTCODE_WPUCreateSocketHandle 106
#define DTCODE_WSCDeinstallProvider 107
#define DTCODE_WSCInstallProvider 108
#define DTCODE_WPUModifyIFSHandle 109
#define DTCODE_WPUQueryBlockingCallback 110
#define DTCODE_WPUQuerySocketHandleContext 111
#define DTCODE_WPUQueueApc 112
#define DTCODE_WPUResetEvent 113
#define DTCODE_WPUSetEvent 114
#define DTCODE_WSCEnumProtocols 115
#define DTCODE_WPUGetProviderPath 116
#define DTCODE_WPUPostMessage 117
#define DTCODE_WPUFDIsSet 118
#define DTCODE_WSADuplicateSocketW 119
#define DTCODE_WSAEnumProtocolsW 120
#define DTCODE_WSASocketW 121
#define DTCODE___WSAFDIsSet 122
#define DTCODE_WSAAddressToStringA 123
#define DTCODE_WSAAddressToStringW 124
#define DTCODE_WSAStringToAddressA 125
#define DTCODE_WSAStringToAddressW 126
#define DTCODE_WSALookupServiceBeginA 127
#define DTCODE_WSALookupServiceBeginW 128
#define DTCODE_WSALookupServiceNextA 129
#define DTCODE_WSALookupServiceNextW 130
#define DTCODE_WSALookupServiceEnd 131
//
// WSAGetAddressByName[AW] have been removed.
//
// #define DTCODE_WSAGetAddressByNameA 132
// #define DTCODE_WSAGetAddressByNameW 133
#define DTCODE_WSAInstallServiceClassA 134
#define DTCODE_WSAInstallServiceClassW 135
#define DTCODE_WSASetServiceA 136
#define DTCODE_WSASetServiceW 137
#define DTCODE_WSARemoveServiceClass 138
#define DTCODE_WSAGetServiceClassInfoA 139
#define DTCODE_WSAGetServiceClassInfoW 140
#define DTCODE_WSAEnumNameSpaceProvidersA 141
#define DTCODE_WSAEnumNameSpaceProvidersW 142
#define DTCODE_WSAGetServiceClassNameByClassIdA 143
#define DTCODE_WSAGetServiceClassNameByClassIdW 144
#define DTCODE_NSPAddressToString 145
#define DTCODE_NSPStringToAddress 146
#define DTCODE_NSPLookupServiceBegin 147
#define DTCODE_NSPLookupServiceNext 148
#define DTCODE_NSPLookupServiceEnd 149
#define DTCODE_NSPGetAddressByName 150
#define DTCODE_NSPInstallServiceClass 151
#define DTCODE_NSPSetService 152
#define DTCODE_NSPRemoveServiceClass 153
#define DTCODE_NSPGetServiceClassInfo 154
#define DTCODE_NSPEnumNameSpaceProviders 155
#define DTCODE_NSPGetServiceClassNameByClassId 156
#define DTCODE_WSCGetProviderPath 157
#define DTCODE_WSCInstallNameSpace 158
#define DTCODE_WSCUnInstallNameSpace 159
#define DTCODE_WSCEnableNSProvider 160
#define DTCODE_WSPAddressToString 161
#define DTCODE_WSPStringToAddress 162
#define DTCODE_WSANSPIoctl 163
#define DTCODE_NSPIoctl 164
#define DTCODE_WPUCompleteOverlappedRequest 165
#define DTCODE_WSAProviderConfigChange 166
#define DTCODE_WSCWriteProviderOrder 167
#define DTCODE_WSCWriteNameSpaceOrder 168
#define DTCODE_WSCUpdateProvider 169
#define DTCODE_getaddrinfo 170
#define DTCODE_getnameinfo 171
#define DTCODE_freeaddrinfo 172
#define DTCODE_NSPStartup 173
#define DTCODE_WPUOpenCurrentThread 174
#define DTCODE_WPUCloseThread 175
#ifdef _WIN64
#define DTCODE_WSCEnumProtocols32 176
#define DTCODE_WSCInstallProvider64_32 177
#define DTCODE_WSCDeinstallProvider32 178
#define DTCODE_WSCGetProviderPath32 179
#define DTCODE_WSCUpdateProvider32 180
#define DTCODE_WSCWriteProviderOrder32 181
#define DTCODE_WSCEnumNameSpaceProviders32 182
#define DTCODE_WSCInstallNameSpace32 183
#define DTCODE_WSCUnInstallNameSpace32 184
#define DTCODE_WSCEnableNSProvider32 185
#define DTCODE_WSCWriteNameSpaceOrder32 186
#endif // WIN64
#define MAX_DTCODE DTCODE_WPUCloseThread

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\inc\resolve.h ===
/******************************************************************
 *
 *  SpiderTCP BIND
 *
 *  Copyright 1990  Spider Systems Limited
 *
 *  RESOLV.H
 *
 ******************************************************************/

/*
 *   /usr/projects/tcp/SCCS.rel3/rel/src/include/0/s.resolv.h
 *  @(#)resolv.h    5.3
 *
 *  Last delta created  14:05:35 3/4/91
 *  This file extracted 11:19:25 3/8/91
 *
 *  Modifications:
 *
 *      GSS 20 Jul 90   New File
 */

/*
 * Copyright (c) 1983, 1987, 1989 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that: (1) source distributions retain this entire copyright
 * notice and comment, and (2) distributions including binaries display
 * the following acknowledgement:  ``This product includes software
 * developed by the University of California, Berkeley and its contributors''
 * in the documentation or other materials provided with the distribution
 * and in all advertising materials mentioning features or use of this
 * software. Neither the name of the University nor the names of its
 * contributors may be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *  @(#)resolv.h    5.10 (Berkeley) 6/1/90
 */

#ifndef _RESOLV_INCLUDED
#define _RESOLV_INCLUDED

/*
 * Global defines and variables for resolver stub.
 */
#define MAXNS            8  /* max # name servers we'll track per list */
#define MAXNSLIST        4  /* max # name servers lists we'll track */
#define MAXDFLSRCH       3  /* # default domain levels to try */
#define MAXDNSRCH        6  /* max # domains in search path */
#define LOCALDOMAINPARTS 2  /* min levels in name that is "local" */
#define RES_TIMEOUT      5  /* min. seconds between retries */

typedef struct _ADDR_LIST {
    u_long ServerCount;
    u_long Servers[MAXNS];

} ADDR_LIST, FAR * LPADDR_LIST;

struct state {
    long       options;             /* option flags - see below. */
    int        retrans;             /* retransmition time interval */
    u_short    retry;               /* number of times to retransmit */
    u_short    id;                  /* current packet id */
    ADDR_LIST  nslist[MAXNSLIST];   /* the server lists */
    char       defdname[MAXDNAME];  /* default domain */
    char      *dnsrch[MAXDNSRCH+1]; /* components of domain to search */
};

/*
 * Resolver options
 */
#define RES_INIT        0x0001      /* address initialized */
#define RES_DEBUG       0x0002      /* print debug messages */
#define RES_AAONLY      0x0004      /* authoritative answers only */
#define RES_USEVC       0x0008      /* use virtual circuit */
#define RES_PRIMARY     0x0010      /* query primary server only */
#define RES_IGNTC       0x0020      /* ignore trucation errors */
#define RES_RECURSE     0x0040      /* recursion desired */
#define RES_DEFNAMES    0x0080      /* use default domain name */
#define RES_STAYOPEN    0x0100      /* Keep TCP socket open */
#define RES_DNSRCH      0x0200      /* search up local domain tree */

#define RES_DEFAULT (RES_RECURSE | RES_DEFNAMES | RES_DNSRCH)


//
// Resolver function prototypes
//

int
dn_expand(
    IN  unsigned char *msg,
    IN  unsigned char *eomorig,
    IN  unsigned char *comp_dn,
    OUT unsigned char *exp_dn,
    IN  int            length
    );

int
dn_comp(
    IN      unsigned char  *exp_dn,
    OUT     unsigned char  *comp_dn,
    IN      int             length,
    IN      unsigned char **dnptrs,     OPTIONAL
    IN OUT  unsigned char **lastdnptr   OPTIONAL
    );

int
res_init(
    void
    );

int
res_send(
    IN  char *buf,
    IN  int buflen,
    OUT char *answer,
    IN  int anslen
    );

int
res_query(
    IN  char          *name,      /* domain name */
    IN  int            class,     /* class of query */
    IN  int            type,      /* type of query */
    OUT unsigned char *answer,    /* buffer to put answer */
    IN  int            anslen     /* size of answer buffer */
    );

int
res_search(
    IN  char           *name,     /* domain name */
    IN  int            class,     /* class of query */
    IN  int            type,      /* type of query */
    OUT unsigned char *answer,    /* buffer to put answer */
    IN  int            anslen     /* size of answer */
    );

int
res_mkquery(
    IN  int          op,             // opcode of query
    IN  char        *dname,          // domain name
    IN  int          class,                  // class of query
    IN  int          type,               // type of query
    IN  char        *data,    OPTIONAL       // resource record data
    IN  int          datalen, OPTIONAL       // length of data
    IN  struct rrec *newrr,   OPTIONAL       // new rr for modify or append
    OUT char        *buf,            // buffer to put query
    IN  int          buflen                  // size of buffer
    );

#endif    // _RESOLV_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\inc\osdef.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    osdef.h

Abstract:

    This file contains miscellaneous operating system specific definitions.

Author:

    Keith Moore keithmo@microsoft.com   03-OCT-1995

Revision History:


--*/

#ifndef _OSDEF_
#define _OSDEF_


#include <ntverp.h>



//
// Winsock configuration registry root key name (lives under HKLM).
//

#define WINSOCK_REGISTRY_ROOT \
    "System\\CurrentControlSet\\Services\\WinSock2\\Parameters"


//
// Registry version info.
//

#define WINSOCK_REGISTRY_VERSION_NAME "WinSock_Registry_Version"
#define WINSOCK_REGISTRY_VERSION_VALUE "2.0"

#define WINSOCK_CURRENT_PROTOCOL_CATALOG_NAME "Current_Protocol_Catalog"
#define WINSOCK_CURRENT_NAMESPACE_CATALOG_NAME "Current_NameSpace_Catalog"


//
// Enable tracing on debug builds.
//

#if DBG
#define DEBUG_TRACING
#define TRACING
#define BUILD_TAG_STRING    "Windows NT " VER_PRODUCTVERSION_STR
#endif


#endif  // _OSDEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\inc\ws2help.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ws2help.h

Abstract:

    Contains declarations for the interface to the OS-specific
    WinSock 2.0 helper routines.

Author:

    Keith Moore (keithmo)        19-Jun-1995

Revision History:

--*/

#ifndef _WS2HELP_H_
#define _WS2HELP_H_


#if defined __cplusplus
extern "C" {
#endif


#if !defined(_WS2HELP_)
#define WS2HELPAPI DECLSPEC_IMPORT
#else
#define WS2HELPAPI
#endif


//
//  APC functions.
//

WS2HELPAPI
DWORD
WINAPI
WahOpenApcHelper(
    OUT LPHANDLE HelperHandle
    );

WS2HELPAPI
DWORD
WINAPI
WahCloseApcHelper(
    IN HANDLE HelperHandle
    );

WS2HELPAPI
DWORD
WINAPI
WahOpenCurrentThread(
    IN  HANDLE HelperHandle,
    OUT LPWSATHREADID ThreadId
    );

WS2HELPAPI
DWORD
WINAPI
WahCloseThread(
    IN HANDLE HelperHandle,
    IN LPWSATHREADID ThreadId
    );

WS2HELPAPI
DWORD
WINAPI
WahQueueUserApc(
    IN HANDLE HelperHandle,
    IN LPWSATHREADID ThreadId,
    IN LPWSAUSERAPC ApcRoutine,
    IN ULONG_PTR ApcContext OPTIONAL
    );

//
// Context functions.
//

typedef struct _CONTEXT_TABLE FAR * LPCONTEXT_TABLE;

#define WAH_CONTEXT_FLAG_SERIALIZE  0x00000001

WS2HELPAPI
DWORD
WINAPI
WahCreateContextTable(
    LPCONTEXT_TABLE FAR * Table,
    DWORD Flags
    );

WS2HELPAPI
DWORD
WINAPI
WahDestroyContextTable(
    LPCONTEXT_TABLE Table
    );

WS2HELPAPI
DWORD
WINAPI
WahSetContext(
    LPCONTEXT_TABLE Table,
    SOCKET Socket,
    LPVOID Context
    );

WS2HELPAPI
DWORD
WINAPI
WahGetContext(
    LPCONTEXT_TABLE Table,
    SOCKET Socket,
    LPVOID FAR * Context
    );

WS2HELPAPI
DWORD
WINAPI
WahRemoveContext(
    LPCONTEXT_TABLE Table,
    SOCKET Socket
    );

WS2HELPAPI
DWORD
WINAPI
WahRemoveContextEx(
    LPCONTEXT_TABLE Table,
    SOCKET Socket,
    LPVOID Context
    );

// Handle function

WS2HELPAPI
DWORD
WINAPI
WahOpenHandleHelper(
    OUT LPHANDLE HelperHandle
    );

WS2HELPAPI
DWORD
WINAPI
WahCloseHandleHelper(
    IN HANDLE HelperHandle
    );


WS2HELPAPI
DWORD
WINAPI
WahCreateSocketHandle(
    IN HANDLE           HelperHandle,
    OUT SOCKET          *s
    );

WS2HELPAPI
DWORD
WINAPI
WahCloseSocketHandle(
    IN HANDLE           HelperHandle,
    IN SOCKET           s
    );

WS2HELPAPI
DWORD
WINAPI
WahCompleteRequest(
    IN HANDLE              HelperHandle,
    IN SOCKET              s,
    IN LPWSAOVERLAPPED     lpOverlapped,
    IN DWORD               dwError,
    IN DWORD               cbTransferred
    );

WS2HELPAPI
DWORD
WINAPI
WahEnableNonIFSHandleSupport (
    VOID
    );

WS2HELPAPI
DWORD
WINAPI
WahDisableNonIFSHandleSupport (
    VOID
    );


// Notification handle functions

WS2HELPAPI
DWORD
WINAPI
WahOpenNotificationHandleHelper(
    OUT LPHANDLE HelperHandle
    );

WS2HELPAPI
DWORD
WINAPI
WahCloseNotificationHandleHelper(
    IN HANDLE HelperHandle
    );

WS2HELPAPI
DWORD
WINAPI
WahCreateNotificationHandle(
    IN HANDLE           HelperHandle,
    OUT HANDLE          *h
    );

WS2HELPAPI
DWORD
WINAPI
WahWaitForNotification(
    IN HANDLE           HelperHandle,
    IN HANDLE           h,
    IN LPWSAOVERLAPPED  lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );

WS2HELPAPI
DWORD
WINAPI
WahNotifyAllProcesses (
    IN HANDLE           HelperHandle
    );


//
// New handle -> context lookup functions
//
typedef struct _WSHANDLE_CONTEXT {
    LONG        RefCount;   // Context reference count
    HANDLE      Handle;     // Handle that corresponds to context
} WSHANDLE_CONTEXT, FAR * LPWSHANDLE_CONTEXT;

WS2HELPAPI
DWORD
WINAPI
WahCreateHandleContextTable(
    LPCONTEXT_TABLE FAR * Table
    );

WS2HELPAPI
DWORD
WINAPI
WahDestroyHandleContextTable(
    LPCONTEXT_TABLE Table
    );

WS2HELPAPI
LPWSHANDLE_CONTEXT
WINAPI
WahReferenceContextByHandle(
    LPCONTEXT_TABLE Table,
    HANDLE          Handle
    );

WS2HELPAPI
LPWSHANDLE_CONTEXT
WINAPI
WahInsertHandleContext(
    LPCONTEXT_TABLE     Table,
    LPWSHANDLE_CONTEXT  HContext
    );

WS2HELPAPI
DWORD
WINAPI
WahRemoveHandleContext(
    LPCONTEXT_TABLE     Table,
    LPWSHANDLE_CONTEXT  HContext
    );


typedef
BOOL
(WINAPI * LPFN_CONTEXT_ENUMERATOR)(
    LPVOID              EnumCtx,
    LPWSHANDLE_CONTEXT  HContext
    );

WS2HELPAPI
BOOL
WINAPI
WahEnumerateHandleContexts(
    LPCONTEXT_TABLE         Table,
    LPFN_CONTEXT_ENUMERATOR Enumerator,
    LPVOID                  EnumCtx
    );

#define WahReferenceHandleContext(_ctx)  InterlockedIncrement(&(_ctx)->RefCount)
#define WahDereferenceHandleContext(_ctx)  InterlockedDecrement(&(_ctx)->RefCount)

#if defined __cplusplus
}   // extern "C"
#endif


#endif // _WS2HELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\util\sockeye\resource.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    resource.h

NOTE from Testing: 
  If these values are changed, it will very likely break test automation. Please advise the test
  team if these values are altered. (peterje)

Abstract:

    Resource header file for the TAPI Browser util

Author:

    Dan Knudson (DanKn)    23-Oct-1994

Revision History:

--*/


//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by TB.RC
//
#define IDR_MENU1                       101
#define IDD_DIALOG1                     102
#define IDD_DIALOG2                     103
#define IDD_DIALOG3                     104
#define IDD_DIALOG4                     105
#define IDD_DIALOG5                     106
#define IDD_DIALOG6                     107
#define IDI_ICON1                       108
#define IDR_ACCELERATOR1                109
#define IDC_LIST1                       1000
#define IDC_LIST2                       1001
#define IDC_COMBO1                      1002
#define IDC_EDIT1                       1003
#define IDC_CLEAR                       1004
#define IDC_STATIC1                     1005
#define IDC_BUTTON1                     1006
#define IDC_BUTTON2                     1007
#define IDC_BUTTON3                     1008
#define IDC_BUTTON4                     1009
#define IDC_BUTTON5                     1010
#define IDC_BUTTON6                     1011
#define IDC_BUTTON7                     1012
#define IDC_BUTTON8                     1013
#define IDC_BUTTON9                     1014
#define IDC_BUTTON10                    1015
#define IDC_BUTTON11                    1016
#define IDC_BUTTON12                    1017
#define IDC_BUTTON13                    1018
#define IDC_BUTTON14                    1019
#define IDC_BUTTON15                    1020
#define IDC_BUTTON16                    1021
#define IDC_BUTTON17                    1022
#define IDC_BUTTON18                    1023
#define IDC_TB_HELP                     1024
#define IDC_F1HELP                      1025
#define IDC_PREVCTRL                    1026
#define IDC_NEXTCTRL                    1027
#define IDC_ENTER                       1028
#define IDC_LIST3                       1029
#define IDM_DEFAULTVALUES               40001
#define IDM_ABOUT                       40002
#define IDM_USAGE                       40003
#define IDM_DUMPPARAMS                  40004
#define IDM_LOGSTRUCTDWORD              40005
#define IDM_LOGSTRUCTALLFIELD           40006
#define IDM_LOGSTRUCTNONZEROFIELD       40007
#define IDM_LOGSTRUCTNONE               40008
#define IDM_USERBUTTONS                 40009
#define IDM_LOGFILE                     40010
#define IDM_CLEAR                       40011
#define IDM_PARAMS                      40012
#define IDM_EXIT                        40013
#define IDM_TIMESTAMP                   40018
#define IDM_NOHANDLECHK                 40019

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        110
#define _APS_NEXT_COMMAND_VALUE         40020
#define _APS_NEXT_CONTROL_VALUE         1029
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\util\sockeye\vars.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1996  Microsoft Corporation

Module Name:

    vars.h

Abstract:

    Header file for the winsock browser util globals

Author:

    Dan Knudson (DanKn)    29-Jul-1996

Revision History:

--*/


#ifdef WIN32
#define my_far
#else
#define my_far _far
#endif

extern FILE        *hLogFile;
extern HANDLE      ghInst;
extern HWND        ghwndMain, ghwndEdit, ghwndList1, ghwndList2, ghwndList3;
extern BOOL        bShowParams;
extern BOOL        gbDisableHandleChecking;
extern LPBYTE      pBigBuf;
extern DWORD       dwBigBufSize;
extern BOOL        bDumpParams;
extern BOOL        gbWideStringParams;
extern BOOL        bTimeStamp;
extern DWORD       dwDumpStructsFlags;

extern BOOL        gbWideStringParams;

extern DWORD       aUserButtonFuncs[MAX_USER_BUTTONS];
extern char        aUserButtonsText[MAX_USER_BUTTONS][MAX_USER_BUTTON_TEXT_SIZE];

extern char my_far szTab[];

extern char        aAscii[];
extern BYTE        aHex[];

extern LOOKUP      aAddressFamilies[];
extern LOOKUP      aIoctlCmds[];
extern LOOKUP      aJLFlags[];
extern LOOKUP      aNameSpaces[];
extern LOOKUP      aNetworkByteOrders[];
extern LOOKUP      aNetworkEvents[];
extern LOOKUP      aProperties[];
extern LOOKUP      aProtocols[];
extern LOOKUP      aProviderFlags[];
extern LOOKUP      aQOSServiceTypes[];
extern LOOKUP      aRecvFlags[];
extern LOOKUP      aResDisplayTypes[];
extern LOOKUP      aResFlags[];
extern LOOKUP      aSendFlags[];
extern LOOKUP      aWSASendAndRecvFlags[];
extern LOOKUP      aShutdownOps[];
extern LOOKUP      aSocketTypes[];
extern LOOKUP      aSockOptLevels[];
extern LOOKUP      aSockOpts[];
extern LOOKUP      aServiceFlags[];
extern LOOKUP      aServiceOps[];
extern LOOKUP      aSvcFlags[];
extern LOOKUP      aWSAFlags[];
extern LOOKUP      aWSAIoctlCmds[];
extern LOOKUP      aWSARecvFlags[];
extern LOOKUP      aWSASendFlags[];
extern LOOKUP      aWSAErrors[];
extern char        *aFuncNames[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\util\sockeye\sockeye.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sockeye.h

Abstract:

    Header file for the winsock browser util

Author:

    Dan Knudson (DanKn)    29-Jul-1996

Revision History:

--*/


#include "windows.h"
#include "winsock2.h"
#include "ws2spi.h"


//
// Symbolic constants
//

#define DS_NONZEROFIELDS            0x00000001
#define DS_ZEROFIELDS               0x00000002
#define DS_BYTEDUMP                 0x00000004

#define WT_SOCKET                   1

#define PT_DWORD                    1
#define PT_FLAGS                    2
#define PT_POINTER                  3
#define PT_STRING                   4
#define PT_ORDINAL                  5
#define PT_WSAPROTOCOLINFO          6
#define PT_QOS                      7
#define PT_PTRNOEDIT                8

#define FT_DWORD                    1
#define FT_FLAGS                    2
#define FT_ORD                      3
#define FT_SIZE                     4
#define FT_OFFSET                   5

#define MAX_STRING_PARAM_SIZE       96

#define MAX_USER_BUTTONS            6

#define MAX_USER_BUTTON_TEXT_SIZE   8

#define TABSIZE                     4

#define WM_ASYNCREQUESTCOMPLETED    WM_USER+0x55
#define WM_NETWORKEVENT             WM_USER+0x56


//
//
//

typedef LONG (WSAAPI *PFN0)(void);
typedef LONG (WSAAPI *PFN1)(ULONG_PTR);
typedef LONG (WSAAPI *PFN2)(ULONG_PTR, ULONG_PTR);
typedef LONG (WSAAPI *PFN3)(ULONG_PTR, ULONG_PTR, ULONG_PTR);
typedef LONG (WSAAPI *PFN4)(ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR);
typedef LONG (WSAAPI *PFN5)(ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                            ULONG_PTR);
typedef LONG (WSAAPI *PFN6)(ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                            ULONG_PTR, ULONG_PTR);
typedef LONG (WSAAPI *PFN7)(ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                            ULONG_PTR, ULONG_PTR, ULONG_PTR);
typedef LONG (WSAAPI *PFN8)(ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                            ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR);
typedef LONG (WSAAPI *PFN9)(ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                            ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                            ULONG_PTR);
typedef LONG (WSAAPI *PFN10)(ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                             ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                             ULONG_PTR, ULONG_PTR);
typedef LONG (WSAAPI *PFN12)(ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                             ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR,
                             ULONG_PTR, ULONG_PTR, ULONG_PTR, ULONG_PTR);

typedef struct _MYSOCKET
{
    SOCKET      Sock;

    BOOL        bWSASocket;

    DWORD       dwAddressFamily;

    DWORD       dwSocketType;

    DWORD       dwFlags;

} MYSOCKET, *PMYSOCKET;


typedef struct _LOOKUP
{
    DWORD       dwVal;

    char       *lpszVal;

} LOOKUP, *PLOOKUP;


typedef enum
{
    ws_accept,
    ws_bind,
    ws_closesocket,
    ws_connect,
    ws_gethostbyaddr,
    ws_gethostbyname,
    ws_gethostname,
    ws_getpeername,
    ws_getprotobyname,
    ws_getprotobynumber,
    ws_getservbyname,
    ws_getservbyport,
    ws_getsockname,
    ws_getsockopt,
    ws_htonl,
    ws_htons,
    ws_inet_addr,
    ws_inet_ntoa,
    ws_ioctlsocket,
    ws_listen,
    ws_ntohl,
    ws_ntohs,
    ws_recv,
    ws_recvfrom,
    ws_select,
    ws_send,
    ws_sendto,
    ws_setsockopt,
    ws_shutdown,
    ws_socket,
    ws_WSAAccept,
    ws_WSAAddressToStringA,
    ws_WSAAddressToStringW,
    ws_WSAAsyncGetHostByAddr,
    ws_WSAAsyncGetHostByName,
    ws_WSAAsyncGetProtoByName,
    ws_WSAAsyncGetProtoByNumber,
    ws_WSAAsyncGetServByName,
    ws_WSAAsyncGetServByPort,
    ws_WSAAsyncSelect,
    ws_WSACancelAsyncRequest,
//    ws_WSACancelBlockingCall,
    ws_WSACleanup,
    ws_WSACloseEvent,
    ws_WSAConnect,
    ws_WSACreateEvent,
    ws_WSADuplicateSocketA,
    ws_WSADuplicateSocketW,
    ws_WSAEnumNameSpaceProvidersA,
    ws_WSAEnumNameSpaceProvidersW,
    ws_WSAEnumNetworkEvents,
    ws_WSAEnumProtocolsA,
    ws_WSAEnumProtocolsW,
    ws_WSAEventSelect,
    ws_WSAGetLastError,
    ws_WSAGetOverlappedResult,
    ws_WSAGetQOSByName,
    ws_WSAGetServiceClassInfoA,
    ws_WSAGetServiceClassInfoW,
    ws_WSAGetServiceClassNameByClassIdA,
    ws_WSAGetServiceClassNameByClassIdW,
    ws_WSAHtonl,
    ws_WSAHtons,
    ws_WSAInstallServiceClassA,
    ws_WSAInstallServiceClassW,
    ws_WSAIoctl,
//    ws_WSAIsBlocking,
    ws_WSAJoinLeaf,
    ws_WSALookupServiceBeginA,
    ws_WSALookupServiceBeginW,
    ws_WSALookupServiceEnd,
    ws_WSALookupServiceNextA,
    ws_WSALookupServiceNextW,
    ws_WSANtohl,
    ws_WSANtohs,
    ws_WSARecv,
    ws_WSARecvDisconnect,
    ws_WSARecvFrom,
    ws_WSARemoveServiceClass,
    ws_WSAResetEvent,
    ws_WSASend,
    ws_WSASendDisconnect,
    ws_WSASendTo,
//    ws_WSASetBlockingHook,
    ws_WSASetEvent,
    ws_WSASetLastError,
    ws_WSASetServiceA,
    ws_WSASetServiceW,
    ws_WSASocketA,
    ws_WSASocketW,
    ws_WSAStartup,
    ws_WSAStringToAddressA,
    ws_WSAStringToAddressW,
//    ws_WSAUnhookBlockingHook,
    ws_WSAWaitForMultipleEvents,

    ws_WSCEnumProtocols,
    ws_WSCGetProviderPath,

    ws_EnumProtocolsA,
    ws_EnumProtocolsW,
    ws_GetAddressByNameA,
    ws_GetAddressByNameW,
    ws_GetNameByTypeA,
    ws_GetNameByTypeW,
    ws_GetServiceA,
    ws_GetServiceW,
    ws_GetTypeByNameA,
    ws_GetTypeByNameW,
    ws_SetServiceA,
    ws_SetServiceW,

//    CloseHandl,
//    DumpBuffer,

    MiscBegin,

    DefValues,
    WSAProtoInfo,
    ws_QOS

} FUNC_INDEX;


typedef struct _MYOVERLAPPED
{
    WSAOVERLAPPED   WSAOverlapped;

    FUNC_INDEX      FuncIndex;

    DWORD           dwFuncSpecific1;

} MYOVERLAPPED, *PMYOVERLAPPED;


typedef struct _FUNC_PARAM
{
    char far    *szName;

    DWORD       dwType;

    ULONG_PTR   dwValue;

    union
    {
        LPVOID      pLookup;

        char far    *buf;

        LPVOID      ptr;

        ULONG_PTR   dwDefValue;

    } u;

} FUNC_PARAM, *PFUNC_PARAM;


typedef struct _FUNC_PARAM_HEADER
{
    DWORD       dwNumParams;

    FUNC_INDEX  FuncIndex;

    PFUNC_PARAM aParams;

    union
    {
        PFN0    pfn0;
        PFN1    pfn1;
        PFN2    pfn2;
        PFN3    pfn3;
        PFN4    pfn4;
        PFN5    pfn5;
        PFN6    pfn6;
        PFN7    pfn7;
        PFN8    pfn8;
        PFN9    pfn9;
        PFN10   pfn10;
        PFN12   pfn12;

    } u;

} FUNC_PARAM_HEADER, *PFUNC_PARAM_HEADER;


typedef struct _STRUCT_FIELD
{
    char far    *szName;

    DWORD       dwType;

    DWORD       dwValue;

    LPVOID      pLookup;

} STRUCT_FIELD, *PSTRUCT_FIELD;


typedef struct _STRUCT_FIELD_HEADER
{
    LPVOID      pStruct;

    char far    *szName;

    DWORD       dwNumFields;

    PSTRUCT_FIELD   aFields;

} STRUCT_FIELD_HEADER, *PSTRUCT_FIELD_HEADER;


typedef struct _ASYNC_REQUEST_INFO
{
    HANDLE      hRequest;

    char FAR    *pszFuncName;

    FUNC_INDEX  FuncIndex;

    struct _ASYNC_REQUEST_INFO *pPrev;

    struct _ASYNC_REQUEST_INFO *pNext;

} ASYNC_REQUEST_INFO, *PASYNC_REQUEST_INFO;


//
// Func prototypes
//

INT_PTR
CALLBACK
MainWndProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
    );

void
FAR
ShowStr(
    LPCSTR format,
    ...
    );

INT_PTR
CALLBACK
ParamsDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
CALLBACK
AboutDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
CALLBACK
IconDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

LONG
DoFunc(
    PFUNC_PARAM_HEADER pHeader
    );

BOOL
LetUserMungeParams(
    PFUNC_PARAM_HEADER pParamsHeader
    );

void
ShowLineFuncResult(
    LPSTR lpFuncName,
    LONG  lResult
    );

void
FuncDriver(
    FUNC_INDEX funcIndex
    );

INT_PTR
CALLBACK
UserButtonsDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

void
FAR
ShowHostEnt(
    struct hostent  *phe
    );

void
FAR
ShowProtoEnt(
    struct protoent *ppe
    );

void
FAR
ShowServEnt(
    struct servent  *pse
    );

void
PASCAL
QueueAsyncRequestInfo(
    PASYNC_REQUEST_INFO pAsyncReqInfo
    );

PASYNC_REQUEST_INFO
PASCAL
DequeueAsyncRequestInfo(
    HANDLE  hRequest
    );

void
PASCAL
ShowBytes(
    DWORD   dwSize,
    LPVOID  lp,
    DWORD   dwNumTabs
    );

void
PASCAL
ShowFlags(
    DWORD       dwValue,
    char FAR    *pszValueName,
    PLOOKUP     pLookup
    );

void
UpdateResults(
    BOOL bBegin
    );

LPSTR
PASCAL
GetStringFromOrdinalValue(
    DWORD   dwValue,
    PLOOKUP pLookup
    );

VOID
PASCAL
ShowProtoInfo(
    LPWSAPROTOCOL_INFOA pInfo,
    DWORD               dwIndex,
    BOOL                bAscii
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\util\sockeye\sockeye.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sockeye.c

Abstract:

    Contains UI support for winsock browser util.

Author:

    Dan Knudson (DanKn)    29-Jul-1996

Revision History:

--*/


#include "sockeye.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <time.h>
#include <string.h>
#include <ctype.h>
#include <io.h>
#include <commdlg.h>
#include "resource.h"
#include "vars.h"
#include "nspapi.h"


int                 giCurrNumStartups = 0;
HWND                hwndEdit2, ghwndModal;
char                gszEnterAs[32];
PASYNC_REQUEST_INFO gpAsyncReqInfoList = NULL;
PMYSOCKET           gpSelectedSocket;
MYSOCKET            gNullSocket;
LRESULT             glCurrentSelection;
WSAPROTOCOL_INFOA   gWSAProtocolInfoA;
WSAPROTOCOL_INFOW   gWSAProtocolInfoW;
HFONT               ghFixedFont;
WSAEVENT            ghSelectedEvent;
INT                 giSelectedEventIndex;
WSAPROTOCOL_INFOW   gDupSockProtoInfo;


char                gszSocket[] = "socket";
char                gszSockEye[] = "SockEye";
char                gszUnknown[] = "unknown";
char                gszProtocol[] = "Protocol";
char                gszHostName[] = "HostName";
char                gszSendFlags[] = "SendFlags";
char                gszRecvFlags[] = "RecvFlags";
char                gszXxxSUCCESS[] = "%s SUCCESS";
char                gszSocketType[] = "SocketType";
char                gszPortNumber[] = "PortNumber";
char                gszServiceName[] = "ServiceName";
char                gszIoctlCommand[] = "IoctlCommand";
char                gszProtocolName[] = "ProtocolName";
char                gszUnknownError[] = "unknown error";
char                gszAddressFamily[] = "AddressFamily";
char                gszWSASocketFlags[] = "WSASocketFlags";
char                gszProtocolNumber[] = "ProtocolNumber";

DWORD               gdwDefPortNum;
DWORD               gdwDefProtocol;
DWORD               gdwDefProtoNum;
DWORD               gdwDefIoctlCmd;
DWORD               gdwDefSendFlags;
DWORD               gdwDefRecvFlags;
DWORD               gdwDefAddrFamily;
DWORD               gdwDefSocketType;
DWORD               gdwDefWSASocketFlags;
char                gszDefHostName[MAX_STRING_PARAM_SIZE];
char                gszDefProtoName[MAX_STRING_PARAM_SIZE];
char                gszDefServName[MAX_STRING_PARAM_SIZE];


char *
PASCAL
GetTimeStamp(
    void
    );

void
ShowStructByField(
    PSTRUCT_FIELD_HEADER    pHeader,
    BOOL    bSubStructure
    );

VOID
PASCAL
ShowGUID(
    char    *pszProlog,
    GUID    *pGuid
    );

void
FAR
PASCAL
FuncDriver(
    FUNC_INDEX funcIndex
    );


int
WINAPI
WinMain(
    HINSTANCE   hInstance,
    HINSTANCE   hPrevInstance,
    LPSTR       lpCmdLine,
    int         nCmdShow
    )
{
    MSG     msg;
    HWND    hwnd;
    DWORD   i;
    HACCEL  hAccel;


    ghInst = hInstance;

    ZeroMemory (&gNullSocket, sizeof (MYSOCKET));
    ZeroMemory (&gWSAProtocolInfoA, sizeof (WSAPROTOCOL_INFOA));
    ZeroMemory (&gWSAProtocolInfoW, sizeof (WSAPROTOCOL_INFOW));

    {
        DWORD d = 0x76543210;


        wsprintf(
            gszEnterAs,
            "Ex: enter x%x as %02x%02x%02x%02x",
            d,
            (DWORD) *((LPBYTE) &d),
            (DWORD) *(((LPBYTE) &d) + 1),
            (DWORD) *(((LPBYTE) &d) + 2),
            (DWORD) *(((LPBYTE) &d) + 3)
            );
    }

    hwnd = CreateDialog(
        ghInst,
        (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG1),
        (HWND)NULL,
        (DLGPROC) MainWndProc
        );

    hwndEdit2 = CreateWindow ("edit", "", 0, 0, 0, 0, 0, NULL, NULL, ghInst, NULL);

    if (!hwndEdit2)
    {
        MessageBox (NULL, "err creating edit ctl", "", MB_OK);
    }

    hAccel = LoadAccelerators(
        ghInst,
        (LPCSTR)MAKEINTRESOURCE(IDR_ACCELERATOR1)
        );

    while (GetMessage (&msg, NULL, 0, 0))
    {
        if (hAccel==NULL || !TranslateAccelerator (hwnd, hAccel, &msg))
        {
            TranslateMessage (&msg);
            DispatchMessage (&msg);
        }
    }

    DestroyWindow (hwndEdit2);

    return 0;
}


LPVOID
PASCAL
MyAlloc(
    SIZE_T   dwSize
    )
{
    LPVOID  p;


    if (!(p = LocalAlloc (LPTR, dwSize)))
    {
        ShowStr ("LocalAlloc (LPTR, x%x) failed, error=%d", GetLastError());
    }

    return p;
}


void
PASCAL
MyFree(
    LPVOID  p
    )
{
    if (p)
    {
        LocalFree (p);
    }
}


void
GetCurrentSelections(
    void
    )
{
    LRESULT   lSel = SendMessage (ghwndList1, LB_GETCURSEL, 0, 0);
    LRESULT   lSelCount = SendMessage (ghwndList3, LB_GETSELCOUNT, 0, 0);


    if ((lSel = SendMessage (ghwndList1, LB_GETCURSEL, 0, 0)) != LB_ERR)
    {
        glCurrentSelection = lSel;
        gpSelectedSocket = (PMYSOCKET) SendMessage(
            ghwndList1,
            LB_GETITEMDATA,
            (WPARAM) lSel,
            0
            );
    }
    else
    {
        gpSelectedSocket = &gNullSocket;
    }

    if (lSelCount == 0  ||  lSelCount == LB_ERR)
    {
        ghSelectedEvent = NULL;
    }
    else
    {
        SendMessage(
            ghwndList3,
            LB_GETSELITEMS,
            1,
            (LPARAM) &giSelectedEventIndex
            );

        ghSelectedEvent = (WSAEVENT) SendMessage(
            ghwndList3,
            LB_GETITEMDATA,
            giSelectedEventIndex,
            0
            );
    }
}


BOOL
LetUserMungeParams(
    PFUNC_PARAM_HEADER pParamsHeader
    )
{
    if (!bShowParams)
    {
        return TRUE;
    }

    return (DialogBoxParam(
        ghInst,
        (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG2),
        ghwndModal,
        (DLGPROC) ParamsDlgProc,
        (LPARAM) pParamsHeader
        ) ? TRUE : FALSE);
}


INT_PTR
CALLBACK
MainWndProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    static HICON  hIcon;
    static HMENU  hMenu;
    static int    icyButton, icyBorder;
    static HFONT  hFont, hFont2;
    static int    iMaxEditTextLength;
    static HANDLE hTimerEvent;

    #define TIMER_ID      55
    #define TIMER_TIMEOUT 2000

    int  i;

    static LONG cxList1, cxList2, cxWnd, xCapture, cxVScroll, lCaptureFlags = 0;
    static int cyWnd;

    typedef struct _XXX
    {
        DWORD   dwMenuID;

        DWORD   dwFlags;

    } XXX, *PXXX;

    static XXX aXxx[] =
    {
        { IDM_LOGSTRUCTDWORD        ,DS_BYTEDUMP },
        { IDM_LOGSTRUCTALLFIELD     ,DS_NONZEROFIELDS|DS_ZEROFIELDS },
        { IDM_LOGSTRUCTNONZEROFIELD ,DS_NONZEROFIELDS },
        { IDM_LOGSTRUCTNONE         ,0 }
    };

    switch (msg)
    {
    case WM_INITDIALOG:
    {
        RECT    rect;
        char    buf[64];
        DWORD   dwInitialized;

        wsprintf(
            buf,
            "WinSock API Browser (ProcessID=x%x)",
            GetCurrentProcessId()
            );

        SetWindowText (hwnd, buf);

        ghwndMain  = ghwndModal = hwnd;
        ghwndList1 = GetDlgItem (hwnd, IDC_LIST1);
        ghwndList2 = GetDlgItem (hwnd, IDC_LIST2);
        ghwndList3 = GetDlgItem (hwnd, IDC_LIST3);
        ghwndEdit  = GetDlgItem (hwnd, IDC_EDIT1);
        hMenu      = GetMenu (hwnd);
        hIcon      = LoadIcon (ghInst, MAKEINTRESOURCE(IDI_ICON1));

        icyBorder = GetSystemMetrics (SM_CYFRAME);
        cxVScroll = 2*GetSystemMetrics (SM_CXVSCROLL);

        GetWindowRect (GetDlgItem (hwnd, IDC_BUTTON1), &rect);
        icyButton = (rect.bottom - rect.top) + icyBorder + 3;

        for (i = 0; aFuncNames[i]; i++)
        {
            SendMessage(
                ghwndList2,
                LB_INSERTSTRING,
                (WPARAM) -1,
                (LPARAM) aFuncNames[i]
                );
        }

//        SendMessage (ghwndList2, LB_SETCURSEL, (WPARAM) lInitialize, 0);


        //
        // Read in defaults from ini file
        //

        {
            typedef struct _DEF_VALUE
            {
                char far *lpszEntry;
                char far *lpszDefValue;
                LPVOID   lp;

            } DEF_VALUE;

            DEF_VALUE aDefVals[] =
            {
                { "BufSize",            "100",  &dwBigBufSize },
                { "UserButton1",        "500",  aUserButtonFuncs },
                { "UserButton2",        "500",  aUserButtonFuncs + 1 },
                { "UserButton3",        "500",  aUserButtonFuncs + 2 },
                { "UserButton4",        "500",  aUserButtonFuncs + 3 },
                { "UserButton5",        "500",  aUserButtonFuncs + 4 },
                { "UserButton6",        "500",  aUserButtonFuncs + 5 },
                { "Initialized",        "0",    &dwInitialized },
                { gszAddressFamily,     "2",    &gdwDefAddrFamily },
                { gszSocketType,        "2",    &gdwDefSocketType },
                { gszProtocol,          "0",    &gdwDefProtocol },
                { gszProtocolNumber,    "0",    &gdwDefProtoNum },
                { gszPortNumber,        "0",    &gdwDefPortNum },
                { gszIoctlCommand,      "0",    &gdwDefIoctlCmd },
                { gszSendFlags,         "0",    &gdwDefSendFlags },
                { gszRecvFlags,         "0",    &gdwDefRecvFlags },
                { gszWSASocketFlags,    "0",    &gdwDefWSASocketFlags },
                { NULL, NULL, NULL },
                { gszHostName,          "HostName",     gszDefHostName },
                { gszProtocolName,      "ProtoName",    gszDefProtoName },
                { gszServiceName,       "ServiceName",  gszDefServName },
                { NULL, NULL, NULL },
                { "UserButton1Text",    "", &aUserButtonsText[0] },
                { "UserButton2Text",    "", &aUserButtonsText[1] },
                { "UserButton3Text",    "", &aUserButtonsText[2] },
                { "UserButton4Text",    "", &aUserButtonsText[3] },
                { "UserButton5Text",    "", &aUserButtonsText[4] },
                { "UserButton6Text",    "", &aUserButtonsText[5] },
                { NULL, NULL, NULL }
            };

            int i, j;

            for (i = 0; aDefVals[i].lpszEntry; i++)
            {
                GetProfileString(
                    gszSockEye,
                    aDefVals[i].lpszEntry,
                    aDefVals[i].lpszDefValue,
                    buf,
                    15
                    );

                sscanf (buf, "%lx", aDefVals[i].lp);
            }

            i++;

            for (; aDefVals[i].lpszEntry; i++)
            {
                GetProfileString(
                    gszSockEye,
                    aDefVals[i].lpszEntry,
                    aDefVals[i].lpszDefValue,
                    (LPSTR) aDefVals[i].lp,
                    MAX_STRING_PARAM_SIZE - 1
                    );
            }

            i++;

            for (j = i; aDefVals[i].lpszEntry; i++)
            {
                GetProfileString(
                    gszSockEye,
                    aDefVals[i].lpszEntry,
                    aDefVals[i].lpszDefValue,
                    (LPSTR) aDefVals[i].lp,
                    MAX_USER_BUTTON_TEXT_SIZE - 1
                    );

                SetDlgItemText(
                    hwnd,
                    IDC_BUTTON7 + (i - j),
                    (LPCSTR)aDefVals[i].lp
                    );
            }

            if (dwInitialized == 0)
            {
                //
                // If here assume this is first time user had started
                // app, so post a msg that will automatically bring up
                // the hlp dlg
                //

                PostMessage (hwnd, WM_COMMAND, IDM_USAGE, 0);
            }
        }

        pBigBuf = MyAlloc (dwBigBufSize);

        {
            //HFONT hFontMenu = SendMessage (hMenu, WM_GETFONT, 0, 0);

            hFont = CreateFont(
                13, 5, 0, 0, 400, 0, 0, 0, 0, 1, 2, 1, 34, "MS Sans Serif"
                );
            ghFixedFont =
            hFont2 = CreateFont(
                13, 8, 0, 0, 400, 0, 0, 0, 0, 1, 2, 1, 49, "Courier"
                );

            for (i = 0; i < 12; i++)
            {
                SendDlgItemMessage(
                    hwnd,
                    IDC_BUTTON1 + i,
                    WM_SETFONT,
                    (WPARAM) hFont,
                    0
                    );
            }

            SendDlgItemMessage (hwnd, IDM_PARAMS, WM_SETFONT,(WPARAM) hFont,0);
            SendMessage (ghwndList1, WM_SETFONT, (WPARAM) hFont, 0);
            SendMessage (ghwndList2, WM_SETFONT, (WPARAM) hFont, 0);
            SendMessage (ghwndList3, WM_SETFONT, (WPARAM) hFont, 0);
            SendMessage (ghwndEdit, WM_SETFONT, (WPARAM) hFont2, 0);
        }

        GetProfileString(
            gszSockEye,
            "ControlRatios",
            "20, 20, 100",
            buf,
            63
            );

        sscanf (buf, "%ld,%ld,%ld", &cxList2, &cxList1, &cxWnd);

        GetProfileString(
            gszSockEye,
            "Position",
            "max",
            buf,
            63
            );

        if (strcmp (buf, "max") == 0)
        {
            ShowWindow (hwnd, SW_SHOWMAXIMIZED);
        }
        else
        {
            int left = 100, top = 100, right = 600, bottom = 400;


            sscanf (buf, "%d,%d,%d,%d", &left, &top, &right, &bottom);


            //
            // Check to see if wnd pos is wacky, if so reset to reasonable vals
            //

            if (left < 0 ||
                left >= (GetSystemMetrics (SM_CXSCREEN) - 32) ||
                top < 0 ||
                top >= (GetSystemMetrics (SM_CYSCREEN) - 32))
            {
                left = top = 100;
                right = 600;
                bottom = 400;
            }

            SetWindowPos(
                hwnd,
                HWND_TOP,
                left,
                top,
                right - left,
                bottom - top,
                SWP_SHOWWINDOW
                );

            GetClientRect (hwnd, &rect);

            SendMessage(
                hwnd,
                WM_SIZE,
                0,
                MAKELONG((rect.right-rect.left),(rect.bottom-rect.top))
                );

            ShowWindow (hwnd, SW_SHOW);
        }

        iMaxEditTextLength = ((GetVersion() & 0x80000000) ?
            29998 :  // we're on win95, and edit controls are 16-bit
            0x20000  // were on NT, and have real 32-bit edit controls
            );

        hTimerEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
        SetTimer (hwnd, TIMER_ID, TIMER_TIMEOUT, NULL);

        break;
    }
    case WM_COMMAND:
    {
        FUNC_INDEX funcIndex;
        BOOL bShowParamsSave = bShowParams;

        switch (LOWORD((DWORD)wParam))
        {
        case IDC_EDIT1:

#ifdef WIN32
            if (HIWORD(wParam) == EN_CHANGE)
#else
            if (HIWORD(lParam) == EN_CHANGE)
#endif
            {
                //
                // Watch to see if the edit control is full, & if so
                // purge the top half of the text to make room for more
                //

                int length = GetWindowTextLength (ghwndEdit);


//                if (length > iMaxEditTextLength)
                if (length > 29998)
                {
#ifdef WIN32
                    SendMessage(
                        ghwndEdit,
                        EM_SETSEL,
                        (WPARAM) 0,
                        (LPARAM) 10000
                        );
#else
                    SendMessage(
                        ghwndEdit,
                        EM_SETSEL,
                        (WPARAM) 1,
                        (LPARAM) MAKELONG (0, 10000)
                        );
#endif

                    SendMessage(
                        ghwndEdit,
                        EM_REPLACESEL,
                        0,
                        (LPARAM) (char far *) ""
                        );

#ifdef WIN32
                    SendMessage(
                        ghwndEdit,
                        EM_SETSEL,
                        (WPARAM)0xfffffffd,
                        (LPARAM)0xfffffffe
                        );
#else
                    SendMessage(
                        ghwndEdit,
                        EM_SETSEL,
                        (WPARAM)1,
                        (LPARAM) MAKELONG (0xfffd, 0xfffe)
                        );
#endif
                }
            }
            break;

        case IDC_BUTTON1:

            FuncDriver (ws_WSAStartup);
            break;

        case IDC_BUTTON2:

            FuncDriver (ws_WSACleanup);
            break;

        case IDC_BUTTON3:

            FuncDriver (ws_socket);
            break;

        case IDC_BUTTON4:

            FuncDriver (ws_WSASocketA);
            break;

        case IDC_BUTTON5:

            GetCurrentSelections();
            FuncDriver (ws_closesocket);
            break;

        case IDC_BUTTON6:
        case IDM_CLEAR:

            SetWindowText (ghwndEdit, "");
            break;


        case IDM_PARAMS:

            bShowParams = (bShowParams ? FALSE : TRUE);

            if (bShowParams)
            {
                CheckMenuItem(
                    hMenu,
                    IDM_PARAMS,
                    MF_BYCOMMAND | MF_CHECKED
                    );

                CheckDlgButton (hwnd, IDM_PARAMS, 1);
            }
            else
            {
                CheckMenuItem(
                    hMenu,
                    IDM_PARAMS,
                    MF_BYCOMMAND | MF_UNCHECKED
                    );

                CheckDlgButton (hwnd, IDM_PARAMS, 0);
            }

            break;

        case IDC_BUTTON7:
        case IDC_BUTTON8:
        case IDC_BUTTON9:
        case IDC_BUTTON10:
        case IDC_BUTTON11:
        case IDC_BUTTON12:
        {
            DWORD i = (DWORD) (LOWORD((DWORD)wParam)) - IDC_BUTTON7;


            if (aUserButtonFuncs[i] >= MiscBegin)
            {
                //
                // Hot button func id is bogus, so bring
                // up hot button init dlg
                //

                DialogBoxParam(
                    ghInst,
                    (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG3),
                    (HWND) hwnd,
                    (DLGPROC) UserButtonsDlgProc,
                    (LPARAM) &i
                    );
            }
            else
            {
                //
                // Invoke the user button's corresponding func
                //

                GetCurrentSelections ();
                FuncDriver ((FUNC_INDEX) aUserButtonFuncs[i]);
            }

            break;
        }
        case IDC_PREVCTRL:
        {
            HWND hwndPrev = GetNextWindow (GetFocus (), GW_HWNDPREV);

            if (!hwndPrev)
            {
                hwndPrev = ghwndList2;
            }

            SetFocus (hwndPrev);
            break;
        }
        case IDC_NEXTCTRL:
        {
            HWND hwndNext = GetNextWindow (GetFocus (), GW_HWNDNEXT);

            if (!hwndNext)
            {
                hwndNext = GetDlgItem (hwnd, IDM_PARAMS);
            }

            SetFocus (hwndNext);
            break;
        }
        case IDC_ENTER:
        {
            if (GetFocus() != ghwndEdit)
            {
                GetCurrentSelections ();
                FuncDriver(
                    (FUNC_INDEX)SendMessage(
                        ghwndList2,
                        LB_GETCURSEL,
                        0,
                        0
                        ));
            }
            else
            {
                // Send the edit ctrl a cr/lf
            }

            break;
        }
        case IDC_LIST1:

#ifdef WIN32
            switch (HIWORD(wParam))
#else
            switch (HIWORD(lParam))
#endif
            {
            case LBN_DBLCLK:
            {
/*
                LONG lSel = SendMessage (ghwndList1, LB_GETCURSEL, 0, 0);
                PMYWIDGET pWidget;


                pWidget = (PMYWIDGET) SendMessage(
                    ghwndList1,
                    LB_GETITEMDATA,
                    (WPARAM) lSel,
                    0
                    );

                bShowParams = FALSE;

//                UpdateResults (TRUE);

                switch (pWidget->dwType)
                {
                }

//                UpdateResults (FALSE);

                bShowParams = bShowParamsSave;
*/
                break;
            }
            } // switch

            break;

        case IDC_LIST2:

#ifdef WIN32
            if (HIWORD(wParam) == LBN_DBLCLK)
#else
            if (HIWORD(lParam) == LBN_DBLCLK)
#endif
            {
                GetCurrentSelections ();
                FuncDriver(
                    (FUNC_INDEX)SendMessage(
                        ghwndList2,
                        LB_GETCURSEL,
                        0,
                        0
                        ));
            }

            break;

        case IDM_EXIT:
        {
            PostMessage (hwnd, WM_CLOSE, 0, 0);
            break;
        }
        case IDM_DEFAULTVALUES:
        {
            char szHostName[MAX_STRING_PARAM_SIZE],
                 szProtoName[MAX_STRING_PARAM_SIZE],
                 szServName[MAX_STRING_PARAM_SIZE];
            FUNC_PARAM params[] =
            {
                { "Buffer size",     PT_DWORD,   (ULONG_PTR) dwBigBufSize, NULL },
                { gszAddressFamily,  PT_ORDINAL, (ULONG_PTR) gdwDefAddrFamily, aAddressFamilies },
                { gszSocketType,     PT_ORDINAL, (ULONG_PTR) gdwDefSocketType, aSocketTypes },
                { gszProtocol,       PT_ORDINAL, (ULONG_PTR) gdwDefProtocol, aProtocols },
                { gszProtocolNumber, PT_DWORD,   (ULONG_PTR) gdwDefProtoNum, NULL },
                { gszPortNumber,     PT_DWORD,   (ULONG_PTR) gdwDefPortNum, NULL },
                { gszIoctlCommand,   PT_ORDINAL, (ULONG_PTR) gdwDefIoctlCmd, aWSAIoctlCmds },
                { gszHostName,       PT_STRING,  (ULONG_PTR) szHostName, szHostName },
                { gszProtocolName,   PT_STRING,  (ULONG_PTR) szProtoName, szProtoName },
                { gszServiceName,    PT_STRING,  (ULONG_PTR) szServName, szServName },
                { gszSendFlags,      PT_FLAGS,   (ULONG_PTR) aWSASendFlags, aWSASendFlags },
                { gszRecvFlags,      PT_FLAGS,   (ULONG_PTR) aWSARecvFlags, aWSARecvFlags },
                { gszWSASocketFlags, PT_FLAGS,   (ULONG_PTR) aWSAFlags, aWSAFlags }
            };
            FUNC_PARAM_HEADER paramsHeader =
                { 13, DefValues, params, NULL };
            BOOL bShowParamsSave = bShowParams;


            bShowParams = TRUE;

            lstrcpyA (szHostName, gszDefHostName);
            lstrcpyA (szProtoName, gszDefProtoName);
            lstrcpyA (szServName, gszDefServName);

            if (LetUserMungeParams (&paramsHeader))
            {
                if (params[0].dwValue != dwBigBufSize)
                {
                    LPVOID pTmpBigBuf = MyAlloc (params[0].dwValue);

                    if (pTmpBigBuf)
                    {
                        MyFree (pBigBuf);
                        pBigBuf = pTmpBigBuf;
                        dwBigBufSize = (DWORD) params[0].dwValue;
                    }
                }

                gdwDefAddrFamily = (DWORD) params[1].dwValue;
                gdwDefSocketType = (DWORD) params[2].dwValue;
                gdwDefProtocol   = (DWORD) params[3].dwValue;
                gdwDefProtoNum   = (DWORD) params[4].dwValue;
                gdwDefPortNum    = (DWORD) params[5].dwValue;
                gdwDefIoctlCmd   = (DWORD) params[6].dwValue;

                if (params[7].dwValue == (ULONG_PTR) szHostName)
                {
                    lstrcpyA (gszDefHostName, szHostName);
                }

                if (params[8].dwValue == (ULONG_PTR) szProtoName)
                {
                    lstrcpyA (gszDefProtoName, szProtoName);
                }

                if (params[9].dwValue == (ULONG_PTR) szServName)
                {
                    lstrcpyA (gszDefServName, szServName);
                }

                gdwDefSendFlags      = (DWORD) params[10].dwValue;
                gdwDefRecvFlags      = (DWORD) params[11].dwValue;
                gdwDefWSASocketFlags = (DWORD) params[12].dwValue;
            }

            bShowParams = bShowParamsSave;

            break;
        }
        case IDM_USERBUTTONS:

            DialogBoxParam(
                ghInst,
                (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG3),
                (HWND) hwnd,
                (DLGPROC) UserButtonsDlgProc,
                (LPARAM) NULL
                );

            break;

        case IDM_DUMPPARAMS:

            bDumpParams = (bDumpParams ? FALSE : TRUE);

            CheckMenuItem(
                hMenu,
                IDM_DUMPPARAMS,
                MF_BYCOMMAND | (bDumpParams ? MF_CHECKED : MF_UNCHECKED)
                );

            break;

        case IDM_LOGSTRUCTDWORD:
        case IDM_LOGSTRUCTALLFIELD:
        case IDM_LOGSTRUCTNONZEROFIELD:
        case IDM_LOGSTRUCTNONE:

            for (i = 0; aXxx[i].dwFlags != dwDumpStructsFlags; i++);

            CheckMenuItem(
                hMenu,
                aXxx[i].dwMenuID,
                MF_BYCOMMAND | MF_UNCHECKED
                );

            for (i = 0; aXxx[i].dwMenuID != LOWORD((DWORD)wParam); i++);

            CheckMenuItem(
                hMenu,
                aXxx[i].dwMenuID,
                MF_BYCOMMAND | MF_CHECKED
                );

            dwDumpStructsFlags = aXxx[i].dwFlags;

            break;

        case IDM_TIMESTAMP:

            bTimeStamp = (bTimeStamp ? FALSE : TRUE);

            CheckMenuItem(
                hMenu,
                IDM_TIMESTAMP,
                MF_BYCOMMAND | (bTimeStamp ? MF_CHECKED : MF_UNCHECKED)
                );

            break;

        case IDM_LOGFILE:
        {
            if (hLogFile)
            {
                fclose (hLogFile);
                hLogFile = (FILE *) NULL;
                CheckMenuItem(
                    hMenu,
                    IDM_LOGFILE,
                    MF_BYCOMMAND | MF_UNCHECKED
                    );
            }
            else
            {
                OPENFILENAME ofn;
                char szDirName[256] = ".\\";
                char szFile[256] = "sockeye.log\0";
                char szFileTitle[256] = "";
                static char *szFilter =
                    "Log files (*.log)\0*.log\0All files (*.*)\0*.*\0\0";


                ofn.lStructSize       = sizeof(OPENFILENAME);
                ofn.hwndOwner         = hwnd;
                ofn.lpstrFilter       = szFilter;
                ofn.lpstrCustomFilter = (LPSTR) NULL;
                ofn.nMaxCustFilter    = 0L;
                ofn.nFilterIndex      = 1;
                ofn.lpstrFile         = szFile;
                ofn.nMaxFile          = sizeof(szFile);
                ofn.lpstrFileTitle    = szFileTitle;
                ofn.nMaxFileTitle     = sizeof(szFileTitle);
                ofn.lpstrInitialDir   = szDirName;
                ofn.lpstrTitle        = (LPSTR) NULL;
                ofn.Flags             = 0L;
                ofn.nFileOffset       = 0;
                ofn.nFileExtension    = 0;
                ofn.lpstrDefExt       = "LOG";

                if (!GetOpenFileName(&ofn))
                {
                    return 0L;
                }

                if ((hLogFile = fopen (szFile, "at")) == (FILE *) NULL)
                {
                    MessageBox(
                        hwnd,
                        "Error creating log file",
                        gszSockEye,
                        MB_OK
                        );
                }
                else
                {
                    struct tm *newtime;
                    time_t aclock;


                    time (&aclock);
                    newtime = localtime (&aclock);
                    fprintf(
                        hLogFile,
                        "\n---Log opened: %s\n",
                        asctime (newtime)
                        );

                    CheckMenuItem(
                        hMenu,
                        IDM_LOGFILE,
                        MF_BYCOMMAND | MF_CHECKED
                        );
                }
            }
            break;
        }
        case IDM_USAGE:
        {
            static char szUsage[] =
                "ABSTRACT:\r\n"                                           \
                "    SockEye (the WinSock API Browser) allows a user "    \
                "to interactively call into the Windows Sockets "         \
                "API, modify parameters, and inspect all returned "       \
                "information.\r\n"                                        \
                "\r\n"                                                    \

                "GETTING STARTED:\r\n"                                    \
                "1. Press the 'Startup' button to initialize WinSock\r\n" \
                "2. Double-click on items in the left-most window "       \
                "to invoke the corresponding API. (Check the Params "     \
                "checkbox in the upper left corner to change "            \
                "parameters.)\r\n"                                        \
                "*  Press the 'Cleanup' button to shutdown WinSock\r\n"   \
                "\r\n"                                                    \

                "MORE INFO:\r\n"                                          \
                "*  Choose 'Options/Default values...' to modify "        \
                "default parameter values\r\n"                            \
                "*  Choose 'Options/Record log file' to save all "        \
                "output to a file.\r\n"                                   \
                "*  All parameter values in hexadecimal unless "          \
                "specified (strings displayed by contents, not "          \
                "pointer value).\r\n"                                     \
                "*  Choose 'Options/User buttons...' or press "           \
                "one of the buttons on right side of toolbar to "         \
                "create a personal hot-link between a button and a "      \
                "particular function.";


            DialogBoxParam(
                ghInst,
                (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG6),
                (HWND)hwnd,
                (DLGPROC) AboutDlgProc,
                (LPARAM) szUsage
                );

            break;
        }
        case IDM_NOHANDLECHK:

            gbDisableHandleChecking = (gbDisableHandleChecking ? 0 : 1);

            CheckMenuItem(
                hMenu,
                IDM_NOHANDLECHK,
                MF_BYCOMMAND |
                    (gbDisableHandleChecking ? MF_CHECKED : MF_UNCHECKED)
                );

            break;

        case IDM_ABOUT:
        {
            DialogBoxParam(
                ghInst,
                (LPCSTR)MAKEINTRESOURCE(IDD_DIALOG4),
                (HWND)hwnd,
                (DLGPROC) AboutDlgProc,
                0
                );

            break;
        }
        } // switch

        break;
    }
    case WM_ASYNCREQUESTCOMPLETED:
    {
        PASYNC_REQUEST_INFO pAsyncReqInfo;


        if ((pAsyncReqInfo = DequeueAsyncRequestInfo ((HANDLE) wParam)))
        {
            if (WSAGETASYNCERROR(lParam) == 0)
            {
                ShowStr(
                    "Request x%x (%s) completed successfully",
                    pAsyncReqInfo->hRequest,
                    aFuncNames[pAsyncReqInfo->FuncIndex]
                    );

                switch (pAsyncReqInfo->FuncIndex)
                {
                case ws_WSAAsyncGetHostByAddr:
                case ws_WSAAsyncGetHostByName:

                    ShowHostEnt ((struct hostent *) (pAsyncReqInfo + 1));
                    break;

                case ws_WSAAsyncGetProtoByName:
                case ws_WSAAsyncGetProtoByNumber:

                    ShowProtoEnt ((struct protoent *) (pAsyncReqInfo + 1));
                    break;

                case ws_WSAAsyncGetServByName:
                case ws_WSAAsyncGetServByPort:

                    ShowServEnt ((struct servent *) (pAsyncReqInfo + 1));
                    break;
                }
            }
            else
            {
                char FAR *pszError;


                for(
                    i = 0;
                    WSAGETASYNCERROR(lParam) != aWSAErrors[i].dwVal  &&
                        aWSAErrors[i].lpszVal;
                    i++
                    );

                pszError = (aWSAErrors[i].lpszVal ? aWSAErrors[i].lpszVal :
                    gszUnknownError);

                ShowStr(
                    "Request x%x (%s) completed unsuccessfully: %s (%d)",
                    pAsyncReqInfo->hRequest,
                    aFuncNames[pAsyncReqInfo->FuncIndex],
                    pszError,
                    (DWORD) WSAGETASYNCERROR(lParam)
                    );
            }

            MyFree (pAsyncReqInfo);
        }
        else
        {
        }

        break;
    }
    case WM_NETWORKEVENT:

// case WM_NETWORKEVENT: format info
        ShowStr ("WM_NETWORKEVENT: wParam=x%x, lParam=x%x", wParam ,lParam);
        break;

#ifdef WIN32
    case WM_CTLCOLORBTN:

        SetBkColor ((HDC) wParam, RGB (192,192,192));
        return (INT_PTR) GetStockObject (LTGRAY_BRUSH);
#else
    case WM_CTLCOLOR:
    {
        if (HIWORD(lParam) == CTLCOLOR_BTN)
        {
            SetBkColor ((HDC) wParam, RGB (192,192,192));
            return (INT_PTR) GetStockObject (LTGRAY_BRUSH);
        }
        break;
    }
#endif

    case WM_MOUSEMOVE:
    {
        LONG x = (LONG)((short)LOWORD(lParam));
        int y = (int)((short)HIWORD(lParam));


        if ((y > icyButton  &&  (x < (cxList2 + icyBorder)  ||
                x > (cxList2 + icyBorder + cxList1)))  ||
            lCaptureFlags)
        {
            SetCursor (LoadCursor (NULL, MAKEINTRESOURCE(IDC_SIZEWE)));
        }

        if (lCaptureFlags == 1)
        {
            int cxList2New;


            x = (x > (cxList1 + cxList2 - cxVScroll) ?
                    (cxList1 + cxList2 - cxVScroll) : x);
            x = (x < cxVScroll ? cxVScroll : x);

            cxList2New = (int) (cxList2 + x - xCapture);

            SetWindowPos(
                ghwndList2,
                GetNextWindow (ghwndList2, GW_HWNDPREV),
                0,
                icyButton,
                cxList2New,
                cyWnd,
                SWP_SHOWWINDOW
                );

            SetWindowPos(
                ghwndList3,
                GetNextWindow (ghwndList3, GW_HWNDPREV),
                cxList2New + icyBorder,
                icyButton + (cyWnd - icyBorder) / 2 + icyBorder,
                (int) (cxList1 - (x - xCapture)),
                (cyWnd - icyBorder) / 2,
                SWP_SHOWWINDOW
                );

            SetWindowPos(
                ghwndList1,
                GetNextWindow (ghwndList1, GW_HWNDPREV),
                cxList2New + icyBorder,
                icyButton,
                (int) (cxList1 - (x - xCapture)),
                (cyWnd - icyBorder) / 2,
                SWP_SHOWWINDOW
                );

        }
        else if (lCaptureFlags == 2)
        {
            int cxList1New;


            x = (x < (cxList2 + cxVScroll) ?  (cxList2 + cxVScroll) : x);
            x = (x > (cxWnd - cxVScroll) ?  (cxWnd - cxVScroll) : x);

            cxList1New = (int) (cxList1 + x - xCapture);

            SetWindowPos(
                ghwndList1,
                GetNextWindow (ghwndList1, GW_HWNDPREV),
                (int) cxList2 + icyBorder,
                icyButton,
                cxList1New,
                (cyWnd - icyBorder) / 2,
                SWP_SHOWWINDOW
                );

            SetWindowPos(
                ghwndList3,
                GetNextWindow (ghwndList3, GW_HWNDPREV),
                (int) cxList2 + icyBorder,
                icyButton + (cyWnd - icyBorder) / 2 + icyBorder,
                cxList1New,
                (cyWnd - icyBorder) / 2,
                SWP_SHOWWINDOW
                );

            SetWindowPos(
                ghwndEdit,
                GetNextWindow (ghwndEdit, GW_HWNDPREV),
                (int) (cxList1New + cxList2) + 2*icyBorder,
                icyButton,
                (int)cxWnd - (cxList1New + (int)cxList2 + 2*icyBorder),
                cyWnd,
                SWP_SHOWWINDOW
                );
        }

        break;
    }
    case WM_LBUTTONDOWN:
    {
        if ((int)((short)HIWORD(lParam)) > icyButton)
        {
            xCapture = (LONG)LOWORD(lParam);

            if (xCapture > (cxList2 + icyBorder)  &&
                xCapture < (cxList2 + icyBorder + cxList1))
            {
                break;
            }

            SetCapture (hwnd);

            lCaptureFlags = ((xCapture < cxList1 + cxList2) ? 1 : 2);
        }

        break;
    }
    case WM_LBUTTONUP:
    {
        if (lCaptureFlags)
        {
            POINT p;
            LONG  x;
            RECT  rect = { 0, icyButton, 2000, 2000 };

            GetCursorPos (&p);
            MapWindowPoints (HWND_DESKTOP, hwnd, &p, 1);
            x = (LONG) p.x;

            ReleaseCapture();

            if (lCaptureFlags == 1)
            {
                x = (x < cxVScroll ? cxVScroll : x);
                x = (x > (cxList1 + cxList2 - cxVScroll) ?
                    (cxList1 + cxList2 - cxVScroll) : x);

                cxList2 = cxList2 + (x - xCapture);
                cxList1 = cxList1 - (x - xCapture);

                rect.right = (int) (cxList1 + cxList2) + icyBorder;
            }
            else
            {
                x = (x < (cxList2 + cxVScroll) ?
                    (cxList2 + cxVScroll) : x);
                x = (x > (cxWnd - cxVScroll) ?
                    (cxWnd - cxVScroll) : x);

                cxList1 = cxList1 + (x - xCapture);

                rect.left = (int)cxList2 + icyBorder;
            }

            lCaptureFlags = 0;

            InvalidateRect (hwnd, &rect, TRUE);
        }

        break;
    }
    case WM_SIZE:
    {
        if (wParam != SIZE_MINIMIZED)
        {
            LONG width = (LONG)LOWORD(lParam);


            //
            // Adjust globals based on new size
            //

            cxWnd = (cxWnd ? cxWnd : 1); // avoid div by 0

            cxList1 = (cxList1 * width) / cxWnd;
            cxList2 = (cxList2 * width) / cxWnd;
            cxWnd = width;
            cyWnd = ((int)HIWORD(lParam)) - icyButton;


            //
            // Now reposition the child windows
            //

            SetWindowPos(
                ghwndList2,
                GetNextWindow (ghwndList2, GW_HWNDPREV),
                0,
                icyButton,
                (int) cxList2,
                cyWnd,
                SWP_SHOWWINDOW
                );

            SetWindowPos(
                ghwndList1,
                GetNextWindow (ghwndList1, GW_HWNDPREV),
                (int) cxList2 + icyBorder,
                icyButton,
                (int) cxList1,
                (cyWnd - icyBorder) / 2,
                SWP_SHOWWINDOW
                );

            SetWindowPos(
                ghwndList3,
                GetNextWindow (ghwndList3, GW_HWNDPREV),
                (int) cxList2 + icyBorder,
                icyButton + (cyWnd - icyBorder) / 2 + icyBorder,
                (int) cxList1,
                (cyWnd - icyBorder) / 2,
                SWP_SHOWWINDOW
                );

            SetWindowPos(
                ghwndEdit,
                GetNextWindow (ghwndEdit, GW_HWNDPREV),
                (int) (cxList1 + cxList2) + 2*icyBorder,
                icyButton,
                (int)width - ((int)(cxList1 + cxList2) + 2*icyBorder),
                cyWnd,
                SWP_SHOWWINDOW
                );

            InvalidateRect (hwnd, NULL, TRUE);
        }

        break;
    }
    case WM_PAINT:
    {
        PAINTSTRUCT ps;


        BeginPaint (hwnd, &ps);

        if (IsIconic (hwnd))
        {
            DrawIcon (ps.hdc, 0, 0, hIcon);
        }
        else
        {
            FillRect (ps.hdc, &ps.rcPaint, GetStockObject (LTGRAY_BRUSH));
#ifdef WIN32
            MoveToEx (ps.hdc, 0, 0, NULL);
#else
            MoveTo (ps.hdc, 0, 0);
#endif
            LineTo (ps.hdc, 5000, 0);

#ifdef WIN32
            MoveToEx (ps.hdc, 0, icyButton - 4, NULL);
#else
            MoveTo (ps.hdc, 0, icyButton - 4);
#endif
            LineTo (ps.hdc, 5000, icyButton - 4);
        }

        EndPaint (hwnd, &ps);

        break;
    }
    case WM_TIMER:

        //
        // Enter alterable wait state to cause any queued APCs to fire
        // (might be able to use SleepEx() instead)
        //

        WaitForSingleObjectEx (hTimerEvent, 0, TRUE);
        break;

    case WM_CLOSE:
    {
        BOOL bAutoShutdown = FALSE;
        RECT rect;


        //
        //
        //

        KillTimer (hwnd, TIMER_ID);
        CloseHandle (hTimerEvent);

        //
        // Give user chance to cancel and auto-shutdown any init instances
        //

        if (giCurrNumStartups > 0)
        {
            int iResult;


            if ((iResult = MessageBox(
                    hwnd,
                    "Cleanup existing Startup instances? (recommended)",
                    "SockEye closing",
                    MB_YESNOCANCEL

                    )) == IDYES)
            {
                bShowParams = FALSE;

                while (giCurrNumStartups > 0)
                {
                    FuncDriver (ws_WSACleanup);
                }
            }
            else if (iResult == IDCANCEL)
            {
                break;
            }
        }


        //
        // Save defaults in ini file
        //

        {
            char buf[32];
            typedef struct _DEF_VALUE2
            {
                char far    *lpszEntry;
                ULONG_PTR   dwValue;

            } DEF_VALUE2;

            DEF_VALUE2 aDefVals[] =
            {
                { "BufSize",            dwBigBufSize },
                { "UserButton1",        aUserButtonFuncs[0] },
                { "UserButton2",        aUserButtonFuncs[1] },
                { "UserButton3",        aUserButtonFuncs[2] },
                { "UserButton4",        aUserButtonFuncs[3] },
                { "UserButton5",        aUserButtonFuncs[4] },
                { "UserButton6",        aUserButtonFuncs[5] },
                { "Initialized",        1 },
                { gszAddressFamily,     gdwDefAddrFamily },
                { gszSocketType,        gdwDefSocketType },
                { gszProtocol,          gdwDefProtocol },
                { gszProtocolNumber,    gdwDefProtoNum },
                { gszPortNumber,        gdwDefPortNum },
                { gszIoctlCommand,      gdwDefIoctlCmd },
                { gszSendFlags,         gdwDefSendFlags },
                { gszRecvFlags,         gdwDefRecvFlags },
                { gszWSASocketFlags,    gdwDefWSASocketFlags },
                { NULL, 0 },
                { gszHostName,          (ULONG_PTR) gszDefHostName },
                { gszProtocolName,      (ULONG_PTR) gszDefProtoName },
                { gszServiceName,       (ULONG_PTR) gszDefServName },
                { "UserButton1Text",    (ULONG_PTR) &aUserButtonsText[0] },
                { "UserButton2Text",    (ULONG_PTR) &aUserButtonsText[1] },
                { "UserButton3Text",    (ULONG_PTR) &aUserButtonsText[2] },
                { "UserButton4Text",    (ULONG_PTR) &aUserButtonsText[3] },
                { "UserButton5Text",    (ULONG_PTR) &aUserButtonsText[4] },
                { "UserButton6Text",    (ULONG_PTR) &aUserButtonsText[5] },
                { NULL, 0 }
            };

            int i;

            for (i = 0; aDefVals[i].lpszEntry; i++)
            {
                sprintf (buf, "%lx", aDefVals[i].dwValue);

                WriteProfileString(
                    gszSockEye,
                    aDefVals[i].lpszEntry,
                    buf
                    );
            }

            i++;

            for (; aDefVals[i].lpszEntry; i++)
            {
                WriteProfileString(
                    gszSockEye,
                    aDefVals[i].lpszEntry,
                    (LPCSTR) aDefVals[i].dwValue
                    );
            }


            //
            // Save the window dimensions (if iconic then don't bother)
            //

            if (!IsIconic (hwnd))
            {
                if (IsZoomed (hwnd))
                {
                    strcpy (buf, "max");
                }
                else
                {
                    GetWindowRect (hwnd, &rect);

                    sprintf(
                        buf,
                        "%d,%d,%d,%d",
                        rect.left,
                        rect.top,
                        rect.right,
                        rect.bottom
                        );
                }

                WriteProfileString(
                    gszSockEye,
                    "Position",
                    (LPCSTR) buf
                    );

                sprintf (buf, "%ld,%ld,%ld", cxList2, cxList1, cxWnd);

                WriteProfileString(
                    gszSockEye,
                    "ControlRatios",
                    (LPCSTR) buf
                    );
            }
        }

        if (hLogFile)
        {
            fclose (hLogFile);
        }
        DestroyIcon (hIcon);
        MyFree (pBigBuf);
        DeleteObject (hFont);
        DeleteObject (hFont2);
        PostQuitMessage (0);
        break;

    }
    } //switch

    return FALSE;
}


INT_PTR
CALLBACK
AboutDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (msg)
    {
    case WM_INITDIALOG:

        if (lParam)
        {
            SetDlgItemText (hwnd, IDC_EDIT1, (LPCSTR) lParam);
        }

        break;

    case WM_COMMAND:

        switch (LOWORD(wParam))
        {
        case IDOK:

            EndDialog (hwnd, 0);
            break;
        }
        break;

#ifdef WIN32
    case WM_CTLCOLORSTATIC:

        SetBkColor ((HDC) wParam, RGB (192,192,192));
        return (INT_PTR) GetStockObject (LTGRAY_BRUSH);
#else
    case WM_CTLCOLOR:
    {
        if (HIWORD(lParam) == CTLCOLOR_STATIC)
        {
            SetBkColor ((HDC) wParam, RGB (192,192,192));
            return (INT_PTR) GetStockObject (LTGRAY_BRUSH);
        }
        break;
    }
#endif
    case WM_PAINT:
    {
        PAINTSTRUCT ps;

        BeginPaint (hwnd, &ps);
        FillRect (ps.hdc, &ps.rcPaint, GetStockObject (LTGRAY_BRUSH));
        EndPaint (hwnd, &ps);

        break;
    }
    }

    return FALSE;
}


void
FAR
ShowStr(
    LPCSTR format,
    ...
    )
{
    char buf[256];
    va_list ap;


    va_start(ap, format);
    vsprintf (buf, format, ap);

    if (hLogFile)
    {
        fprintf (hLogFile, "%s\n", buf);
    }

    strcat (buf, "\r\n");


    //
    // Insert text at end
    //

#ifdef WIN32
    SendMessage (ghwndEdit, EM_SETSEL, (WPARAM)0xfffffffd, (LPARAM)0xfffffffe);
#else
    SendMessage(
        ghwndEdit,
        EM_SETSEL,
        (WPARAM)0,
        (LPARAM) MAKELONG(0xfffd,0xfffe)
        );
#endif

    SendMessage (ghwndEdit, EM_REPLACESEL, 0, (LPARAM) buf);


#ifdef WIN32

    //
    // Scroll to end of text
    //

    SendMessage (ghwndEdit, EM_SCROLLCARET, 0, 0);
#endif

    va_end(ap);
}


INT_PTR
CALLBACK
ParamsDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DWORD  i;

    typedef struct _DLG_INST_DATA
    {
        PFUNC_PARAM_HEADER pParamsHeader;

        LRESULT lLastSel;

        char szComboText[MAX_STRING_PARAM_SIZE];

    } DLG_INST_DATA, *PDLG_INST_DATA;

    PDLG_INST_DATA pDlgInstData = (PDLG_INST_DATA)
        GetWindowLongPtr (hwnd, DWLP_USER);

    static int icxList2, icyList2, icyEdit1;


    switch (msg)
    {
    case WM_INITDIALOG:
    {
        //
        // Alloc a dlg instance data struct, init it, & save a ptr to it
        //

        pDlgInstData = (PDLG_INST_DATA) MyAlloc (sizeof(DLG_INST_DATA));

        if (pDlgInstData == NULL) {
            EndDialog(hwnd, 0);
            return (FALSE);
        }

        pDlgInstData->pParamsHeader = (PFUNC_PARAM_HEADER) lParam;
        pDlgInstData->lLastSel = -1;

        SetWindowLongPtr (hwnd, DWLP_USER, (LPARAM) pDlgInstData);


        //
        // Stick all the param names in the listbox, & for each PT_DWORD
        // param save it's default value
        //

        for (i = 0; i < pDlgInstData->pParamsHeader->dwNumParams; i++)
        {
            SendDlgItemMessage(
                hwnd,
                IDC_LIST1,
                LB_INSERTSTRING,
                (WPARAM) -1,
                (LPARAM) pDlgInstData->pParamsHeader->aParams[i].szName
                );

            if (pDlgInstData->pParamsHeader->aParams[i].dwType == PT_DWORD)
            {
                pDlgInstData->pParamsHeader->aParams[i].u.dwDefValue = (ULONG_PTR)
                    pDlgInstData->pParamsHeader->aParams[i].dwValue;
            }
        }


        //
        // Set the dlg title as appropriate
        //

// help        if (pDlgInstData->pParamsHeader->FuncIndex == DefValues)
// help        {
// help            EnableWindow (GetDlgItem (hwnd, IDC_TB_HELP), FALSE);
// help        }

        SetWindowText(
            hwnd,
            aFuncNames[pDlgInstData->pParamsHeader->FuncIndex]
            );


        //
        // Limit the max text length for the combobox's edit field
        // (NOTE: A combobox ctrl actually has two child windows: a
        // edit ctrl & a listbox.  We need to get the hwnd of the
        // child edit ctrl & send it the LIMITTEXT msg.)
        //

        {
            HWND hwndChild =
                GetWindow (GetDlgItem (hwnd, IDC_COMBO1), GW_CHILD);


            while (hwndChild)
            {
                char buf[8];


                GetClassName (hwndChild, buf, 7);

                if (_stricmp (buf, "edit") == 0)
                {
                    break;
                }

                hwndChild = GetWindow (hwndChild, GW_HWNDNEXT);
            }

            SendMessage(
                hwndChild,
                EM_LIMITTEXT,
                (WPARAM) (gbWideStringParams ?
                    (MAX_STRING_PARAM_SIZE/2 - 1) : MAX_STRING_PARAM_SIZE - 1),
                0
                );
        }

        {
            RECT    rect;


            GetWindowRect (GetDlgItem (hwnd, IDC_LIST2), &rect);

            SetWindowPos(
                GetDlgItem (hwnd, IDC_LIST2),
                NULL,
                0,
                0,
                0,
                0,
                SWP_NOMOVE | SWP_NOZORDER
                );

            icxList2 = rect.right - rect.left;
            icyList2 = rect.bottom - rect.top;

            GetWindowRect (GetDlgItem (hwnd, 58), &rect);

            icyEdit1 = icyList2 - (rect.bottom - rect.top);
        }

        SendDlgItemMessage(
            hwnd,
            IDC_EDIT1,
            WM_SETFONT,
            (WPARAM) ghFixedFont,
            0
            );

        break;
    }
    case WM_COMMAND:
    {
        LRESULT   lLastSel      = pDlgInstData->lLastSel;
        char far *lpszComboText = pDlgInstData->szComboText;
        PFUNC_PARAM_HEADER pParamsHeader = pDlgInstData->pParamsHeader;


        switch (LOWORD(wParam))
        {
        case IDC_EDIT1:
        {
            if (HIWORD(wParam) == EN_CHANGE)
            {
                //
                // Don't allow the user to enter characters other than
                // 0-9, a-f, or A-F in the edit control (do this by
                // hiliting other letters and cutting them).
                //

                HWND    hwndEdit = GetDlgItem (hwnd, IDC_EDIT1);
                DWORD   dwLength, j;
                BYTE   *p;


                dwLength = (DWORD) GetWindowTextLength (hwndEdit);

                if (dwLength  &&  (p = MyAlloc (dwLength + 1)))
                {
                    GetWindowText (hwndEdit, p, dwLength + 1);

                    for (i = j = 0; i < dwLength ; i++, j++)
                    {
                        if (aHex[p[i]] == 255)
                        {
                            SendMessage(
                                hwndEdit,
                                EM_SETSEL,
                                (WPARAM) j,
                                (LPARAM) j + 1  // 0xfffffffe
                                );

                            SendMessage (hwndEdit, EM_REPLACESEL, 0, (LPARAM) "");
                            SendMessage (hwndEdit, EM_SCROLLCARET, 0, 0);

                            j--;
                        }
                    }

                    MyFree (p);
                }
            }

            break;
        }
        case IDOK:

// if gbWideStringParams convert ascii -> unicode

            if (lLastSel != -1)
            {
                //
                // Save val of currently selected param
                //

                char buf[MAX_STRING_PARAM_SIZE];


                i = GetDlgItemText (hwnd, IDC_COMBO1, buf, MAX_STRING_PARAM_SIZE-1);

                switch (pParamsHeader->aParams[lLastSel].dwType)
                {
                case PT_STRING:
                {
                    LRESULT lComboSel;


                    lComboSel = SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_GETCURSEL,
                        0,
                        0
                        );

                    if (lComboSel == 0) // "NULL pointer"
                    {
                        pParamsHeader->aParams[lLastSel].dwValue = 0;
                    }
                    else if (lComboSel == 2) // "Invalid string pointer"
                    {
                        pParamsHeader->aParams[lLastSel].dwValue = (ULONG_PTR)
                            -1;
                    }
                    else // "Valid string pointer"
                    {
                        strncpy(
                            pParamsHeader->aParams[lLastSel].u.buf,
                            buf,
                            MAX_STRING_PARAM_SIZE - 1
                            );

                        pParamsHeader->aParams[lLastSel].u.buf[MAX_STRING_PARAM_SIZE-1] = 0;

                        pParamsHeader->aParams[lLastSel].dwValue = (ULONG_PTR)
                            pParamsHeader->aParams[lLastSel].u.buf;
                    }

                    break;
                }
                case PT_POINTER:
                {
                    //
                    // If there is any text in the "Buffer byte editor"
                    // window then retrieve it, convert it to hexadecimal,
                    // and copy it to the buffer
                    //

                    DWORD     dwLength;
                    BYTE     *p, *p2,
                             *pBuf = pParamsHeader->aParams[lLastSel].u.ptr;
                    HWND      hwndEdit = GetDlgItem (hwnd,IDC_EDIT1);


                    dwLength = (DWORD) GetWindowTextLength (hwndEdit);

                    if (dwLength  &&  (p = MyAlloc (dwLength + 1)))
                    {
                        GetWindowText (hwndEdit, p, dwLength + 1);
                        SetWindowText (hwndEdit, "");

                        p2 = p;

                        p[dwLength] = (BYTE) '0';
                        dwLength = (dwLength + 1) & 0xfffffffe;

                        for (i = 0; i < dwLength; i++, i++)
                        {
                            BYTE b;

                            b = aHex[*p] << 4;
                            p++;

                            b |= aHex[*p];
                            p++;

                            *pBuf = b;
                            pBuf++;
                        }

                        MyFree (p2);
                    }

                    // fall thru to code below
                }
                case PT_DWORD:
                case PT_FLAGS:
                case PT_ORDINAL:
                case PT_WSAPROTOCOLINFO:
                case PT_QOS:
                case PT_PTRNOEDIT:
                {
                    if (!sscanf(
                            buf,
                            "%08lx",
                            &pParamsHeader->aParams[lLastSel].dwValue
                            ))
                    {
                        //
                        // Default to 0
                        //

                        pParamsHeader->aParams[lLastSel].dwValue = 0;
                    }

                    break;
                }
                } // switch
            }


            //
            // Convert any unicode string params as appropriate
            //

            if (gbWideStringParams)
            {
                DWORD       dwNumParams = pParamsHeader->dwNumParams, i;
                PFUNC_PARAM pParam = pParamsHeader->aParams;


                for (i = 0; i < dwNumParams; i++)
                {
                    if (pParam->dwType == PT_STRING &&
                        pParam->dwValue != 0 &&
                        pParam->dwValue != 0xffffffff)
                    {
                        int    len = lstrlenA ((char *) pParam->dwValue) + 1;
                        WCHAR  buf[MAX_STRING_PARAM_SIZE/2];


                        MultiByteToWideChar(
                            GetACP(),
                            MB_PRECOMPOSED,
                            (LPCSTR) pParam->dwValue,
                            (len > MAX_STRING_PARAM_SIZE/2 ?
                                MAX_STRING_PARAM_SIZE/2 - 1 : -1),
                            buf,
                            MAX_STRING_PARAM_SIZE/2
                            );

                         buf[MAX_STRING_PARAM_SIZE/2 - 1] = 0;

                         lstrcpyW ((WCHAR *) pParam->dwValue, buf);
                    }

                    pParam++;
                }
            }

            MyFree (pDlgInstData);
            EndDialog (hwnd, TRUE);
            break;

        case IDCANCEL:

            MyFree (pDlgInstData);
            EndDialog (hwnd, FALSE);
            break;

        case IDC_LIST1:

#ifdef WIN32
            if (HIWORD(wParam) == LBN_SELCHANGE)
#else
            if (HIWORD(lParam) == LBN_SELCHANGE)
#endif
            {
                char buf[MAX_STRING_PARAM_SIZE] = "";
                LPCSTR lpstr = buf;
                LRESULT lSel =
                    SendDlgItemMessage (hwnd, IDC_LIST1, LB_GETCURSEL, 0, 0);


                if (lLastSel != -1)
                {
                    //
                    // Save the old param value
                    //

                    i = GetDlgItemText(
                        hwnd,
                        IDC_COMBO1,
                        buf,
                        MAX_STRING_PARAM_SIZE - 1
                        );

                    switch (pParamsHeader->aParams[lLastSel].dwType)
                    {
                    case PT_STRING:
                    {
                        LRESULT lComboSel;


                        lComboSel = SendDlgItemMessage(
                            hwnd,
                            IDC_COMBO1,
                            CB_GETCURSEL,
                            0,
                            0
                            );

                        if (lComboSel == 0) // "NULL pointer"
                        {
                            pParamsHeader->aParams[lLastSel].dwValue = (DWORD)0;
                        }
                        else if (lComboSel == 2) // "Invalid string pointer"
                        {
                            pParamsHeader->aParams[lLastSel].dwValue = (DWORD)
                                0xffffffff;
                        }
                        else // "Valid string pointer" or no sel
                        {
                            strncpy(
                                pParamsHeader->aParams[lLastSel].u.buf,
                                buf,
                                MAX_STRING_PARAM_SIZE - 1
                                );

                            pParamsHeader->aParams[lLastSel].u.buf[MAX_STRING_PARAM_SIZE - 1] = 0;

                            pParamsHeader->aParams[lLastSel].dwValue = (ULONG_PTR)
                                pParamsHeader->aParams[lLastSel].u.buf;
                        }

                        break;
                    }
                    case PT_POINTER:
                    {
                        //
                        // If there is any text in the "Buffer byte editor"
                        // window then retrieve it, convert it to hexadecimal,
                        // and copy it to the buffer
                        //

                        DWORD     dwLength;
                        BYTE     *p, *p2,
                                 *pBuf = pParamsHeader->aParams[lLastSel].u.ptr;
                        HWND      hwndEdit = GetDlgItem (hwnd,IDC_EDIT1);


                        dwLength = (DWORD) GetWindowTextLength (hwndEdit);

                        if (dwLength  &&  (p = MyAlloc (dwLength + 1)))
                        {
                            GetWindowText (hwndEdit, p, dwLength + 1);
                            SetWindowText (hwndEdit, "");

                            p2 = p;

                            p[dwLength] = (BYTE) '0';
                            dwLength = (dwLength + 1) & 0xfffffffe;

                            for (i = 0; i < dwLength; i+= 2)
                            {
                                BYTE b;

                                b = aHex[*p] << 4;
                                p++;

                                b |= aHex[*p];
                                p++;

                                *pBuf = b;
                                pBuf++;
                            }

                            MyFree (p2);
                        }

                        // fall thru to code below
                    }
                    case PT_DWORD:
                    case PT_FLAGS:
                    case PT_ORDINAL:
                    case PT_WSAPROTOCOLINFO:
                    case PT_QOS:
                    case PT_PTRNOEDIT:
                    {
                        if (!sscanf(
                                buf,
                                "%08lx",
                                &pParamsHeader->aParams[lLastSel].dwValue
                                ))
                        {
                            //
                            // Default to 0
                            //

                            pParamsHeader->aParams[lLastSel].dwValue = 0;
                        }

                        break;
                    }
                    } // switch
                }

                SendDlgItemMessage (hwnd, IDC_LIST2, LB_RESETCONTENT, 0, 0);
                SendDlgItemMessage (hwnd, IDC_COMBO1, CB_RESETCONTENT, 0, 0);

                {
                    int         icxL2, icyL2, icxE1, icyE1;
                    char FAR   *pszS1, *pszS2;
                    static char szBitFlags[] = "Bit flags:";
                    static char szOrdinalValues[] = "Ordinal values:";
                    static char szBufByteEdit[] =
                                    "Buffer byte editor (use 0-9, a-f, A-F)";

                    switch (pParamsHeader->aParams[lSel].dwType)
                    {
                    case PT_DWORD:
                    case PT_STRING:
                    case PT_WSAPROTOCOLINFO:
                    case PT_QOS:
                    case PT_PTRNOEDIT:

                        icxL2 = icyL2 = icxE1 = icxE1 = 0;
                        pszS1 = pszS2 = NULL;
                        break;

                    case PT_FLAGS:

                        icxL2 = icxList2;
                        icyL2 = icyList2;
                        icxE1 = icyE1 = 0;
                        pszS1 = szBitFlags;
                        pszS2 = NULL;
                        break;

                    case PT_POINTER:

                        icxL2 = icyL2 = 0;
                        icxE1 = icxList2;
                        icyE1 = icyEdit1;;
                        pszS1 = szBufByteEdit;
                        pszS2 = gszEnterAs;
                        break;

                    case PT_ORDINAL:

                        icxL2 = icxList2;
                        icyL2 = icyList2;
                        icxE1 = icyE1 = 0;
                        pszS1 = szOrdinalValues;
                        pszS2 = NULL;
                        break;
                    }

                    SetWindowPos(
                        GetDlgItem (hwnd, IDC_LIST2),
                        NULL,
                        0,
                        0,
                        icxL2,
                        icyL2,
                        SWP_NOMOVE | SWP_NOZORDER
                        );

                    SetWindowPos(
                        GetDlgItem (hwnd, IDC_EDIT1),
                        NULL,
                        0,
                        0,
                        icxE1,
                        icyE1,
                        SWP_NOMOVE | SWP_NOZORDER
                        );

                    SetDlgItemText (hwnd, 57, pszS1);
                    SetDlgItemText (hwnd, 58, pszS2);
                }

                switch (pParamsHeader->aParams[lSel].dwType)
                {
                case PT_STRING:
                {
                    char * aszOptions[] =
                    {
                        "NULL pointer",
                        "Valid string pointer",
                        "Invalid string pointer"
                    };


                    for (i = 0; i < 3; i++)
                    {
                        SendDlgItemMessage(
                            hwnd,
                            IDC_COMBO1,
                            CB_INSERTSTRING,
                            (WPARAM) -1,
                            (LPARAM) aszOptions[i]
                            );
                    }

                    if (pParamsHeader->aParams[lSel].dwValue == 0)
                    {
                        i = 0;
                        buf[0] = 0;
                    }
                    else if (pParamsHeader->aParams[lSel].dwValue != 0xffffffff)
                    {
                        i = 1;
                        lpstr = (LPCSTR) pParamsHeader->aParams[lSel].dwValue;
                    }
                    else
                    {
                        i = 2;
                        buf[0] = 0;
                    }

                    SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_SETCURSEL,
                        (WPARAM) i,
                        0
                        );

                    break;
                }
                case PT_POINTER:
                case PT_WSAPROTOCOLINFO:
                case PT_QOS:
                case PT_PTRNOEDIT:
                {
                    SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) "00000000"
                        );

                    sprintf(
                        buf,
                        "%08lx (valid pointer)",
                        pParamsHeader->aParams[lSel].u.dwDefValue
                        );

                    SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) buf
                        );

                    SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) "ffffffff"
                        );

                    sprintf(
                        buf,
                        "%08lx",
                        pParamsHeader->aParams[lSel].dwValue
                        );

                    break;
                }
                case PT_DWORD:
                {
                    SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) "0000000"
                        );

                    if (pParamsHeader->aParams[lSel].u.dwDefValue)
                    {
                        //
                        // Add the default val string to the combo
                        //

                        sprintf(
                            buf,
                            "%08lx",
                            pParamsHeader->aParams[lSel].u.dwDefValue
                            );

                        SendDlgItemMessage(
                            hwnd,
                            IDC_COMBO1,
                            CB_INSERTSTRING,
                            (WPARAM) -1,
                            (LPARAM) buf
                            );
                    }

                    SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) "ffffffff"
                        );

                    sprintf(
                        buf,
                        "%08lx",
                        pParamsHeader->aParams[lSel].dwValue
                        );

                    break;
                }
                case PT_FLAGS:
                {
                    //
                    // Stick the bit flag strings in the list box
                    //

                    PLOOKUP pLookup = (PLOOKUP)
                        pParamsHeader->aParams[lSel].u.pLookup;

                    for (i = 0; pLookup[i].dwVal != 0xffffffff; i++)
                    {
                        SendDlgItemMessage(
                            hwnd,
                            IDC_LIST2,
                            LB_INSERTSTRING,
                            (WPARAM) -1,
                            (LPARAM) pLookup[i].lpszVal
                            );

                        if (pParamsHeader->aParams[lSel].dwValue &
                            pLookup[i].dwVal)
                        {
                            SendDlgItemMessage(
                                hwnd,
                                IDC_LIST2,
                                LB_SETSEL,
                                (WPARAM) TRUE,
                                (LPARAM) MAKELPARAM((WORD)i,0)
                                );
                        }
                    }

                    SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) "select none"
                        );

                    SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) "select all"
                        );

                    sprintf(
                        buf,
                        "%08lx",
                        pParamsHeader->aParams[lSel].dwValue
                        );

                    break;
                }
                case PT_ORDINAL:
                {
                    //
                    // Stick the bit flag strings in the list box
                    //

                    HWND hwndList2 = GetDlgItem (hwnd, IDC_LIST2);
                    PLOOKUP pLookup = (PLOOKUP)
                        pParamsHeader->aParams[lSel].u.pLookup;

                    for (i = 0; pLookup[i].dwVal != 0xffffffff; i++)
                    {
                        SendMessage(
                            hwndList2,
                            LB_INSERTSTRING,
                            (WPARAM) -1,
                            (LPARAM) pLookup[i].lpszVal
                            );

                        if (pParamsHeader->aParams[lSel].dwValue ==
                            pLookup[i].dwVal)
                        {
                            SendMessage(
                                hwndList2,
                                LB_SETSEL,
                                (WPARAM) TRUE,
                                (LPARAM) MAKELPARAM((WORD)i,0)
                                );
                        }
                    }

                    SendDlgItemMessage(
                        hwnd,
                        IDC_COMBO1,
                        CB_INSERTSTRING,
                        (WPARAM) -1,
                        (LPARAM) (char far *) "select none"
                        );

                    wsprintf(
                        buf,
                        "%08lx",
                        pParamsHeader->aParams[lSel].dwValue
                        );

                    break;
                }
                } //switch

                SetDlgItemText (hwnd, IDC_COMBO1, lpstr);

                pDlgInstData->lLastSel = lSel;
            }
            break;

        case IDC_LIST2:

#ifdef WIN32
            if (HIWORD(wParam) == LBN_SELCHANGE)
#else
            if (HIWORD(lParam) == LBN_SELCHANGE)
#endif
            {
                PLOOKUP pLookup = (PLOOKUP)
                    pParamsHeader->aParams[lLastSel].u.pLookup;
                char buf[16];
                DWORD dwValue = 0;
                int far *ai;
                LONG i;
                LRESULT lSelCount =
                    SendDlgItemMessage (hwnd, IDC_LIST2, LB_GETSELCOUNT, 0, 0);


                if (lSelCount)
                {
                    ai = (int far *) MyAlloc ((size_t)lSelCount * sizeof(int));

                    SendDlgItemMessage(
                        hwnd,
                        IDC_LIST2,
                        LB_GETSELITEMS,
                        (WPARAM) lSelCount,
                        (LPARAM) ai
                        );

                    if (pParamsHeader->aParams[lLastSel].dwType == PT_FLAGS)
                    {
                        for (i = 0; i < lSelCount; i++)
                        {
                            dwValue |= pLookup[ai[i]].dwVal;
                        }
                    }
                    else // if (.dwType == PT_ORDINAL)
                    {
                        if (lSelCount == 1)
                        {
                            dwValue = pLookup[ai[0]].dwVal;
                        }
                        else if (lSelCount == 2)
                        {
                            //
                            // Figure out which item we need to de-select,
                            // since we're doing ords & only want 1 item
                            // selected at a time
                            //

                            GetDlgItemText (hwnd, IDC_COMBO1, buf, 16);

                            if (sscanf (buf, "%lx", &dwValue))
                            {
                                if (pLookup[ai[0]].dwVal == dwValue)
                                {
                                    SendDlgItemMessage(
                                        hwnd,
                                        IDC_LIST2,
                                        LB_SETSEL,
                                        0,
                                        (LPARAM) ai[0]
                                        );

                                    dwValue = pLookup[ai[1]].dwVal;
                                }
                                else
                                {
                                    SendDlgItemMessage(
                                        hwnd,
                                        IDC_LIST2,
                                        LB_SETSEL,
                                        0,
                                        (LPARAM) ai[1]
                                        );

                                    dwValue = pLookup[ai[0]].dwVal;
                                }
                            }
                            else
                            {
                                // de-select items???

                                dwValue = 0;
                            }
                        }
                    }

                    MyFree (ai);
                }

                sprintf (buf, "%08lx", dwValue);
                SetDlgItemText (hwnd, IDC_COMBO1, buf);
            }
            break;

        case IDC_COMBO1:

#ifdef WIN32
            switch (HIWORD(wParam))
#else
            switch (HIWORD(lParam))
#endif
            {
            case CBN_SELCHANGE:
            {
                LRESULT lSel =
                    SendDlgItemMessage (hwnd, IDC_COMBO1, CB_GETCURSEL, 0, 0);


                switch (pParamsHeader->aParams[lLastSel].dwType)
                {
                case PT_POINTER:
                case PT_PTRNOEDIT:
                {
                    if (lSel == 1)
                    {
                        //
                        // Strip off the "(valid pointer)" in the edit ctrl
                        //

                        wsprintf(
                            lpszComboText,
                            "%08lx",
                            pParamsHeader->aParams[lLastSel].u.ptr
                            );

                        PostMessage (hwnd, WM_USER+55, 0, 0);
                    }

                    break;
                }
                case PT_FLAGS:
                {
                    BOOL bSelect = (lSel ? TRUE : FALSE);

                    SendDlgItemMessage(
                        hwnd,
                        IDC_LIST2,
                        LB_SETSEL,
                        (WPARAM) bSelect,
                        (LPARAM) -1
                        );

                    if (bSelect)
                    {
                        PLOOKUP pLookup = (PLOOKUP)
                            pParamsHeader->aParams[lLastSel].u.pLookup;
                        DWORD dwValue = 0;
                        int far *ai;
                        LONG i;
                        LRESULT lSelCount =
                            SendDlgItemMessage (hwnd, IDC_LIST2, LB_GETSELCOUNT, 0, 0);


                        if (lSelCount)
                        {
                            ai = (int far *) MyAlloc ((size_t)lSelCount * sizeof(int));

                            SendDlgItemMessage(
                                hwnd,
                                IDC_LIST2,
                                LB_GETSELITEMS,
                                (WPARAM) lSelCount,
                                (LPARAM) ai
                                );

                            for (i = 0; i < lSelCount; i++)
                            {
                                dwValue |= pLookup[ai[i]].dwVal;
                            }

                            MyFree (ai);
                        }

                        sprintf (lpszComboText, "%08lx", dwValue);

                    }
                    else
                    {
                        strcpy (lpszComboText, "00000000");
                    }

                    PostMessage (hwnd, WM_USER+55, 0, 0);

                    break;
                }
                case PT_STRING:

                    if (lSel == 1)
                    {
                        strncpy(
                            lpszComboText,
                            pParamsHeader->aParams[lLastSel].u.buf,
                            MAX_STRING_PARAM_SIZE
                            );

                        lpszComboText[MAX_STRING_PARAM_SIZE-1] = 0;
                    }
                    else
                    {
                        lpszComboText[0] = 0;
                    }

                    PostMessage (hwnd, WM_USER+55, 0, 0);

                    break;

                case PT_DWORD:

                    break;

                case PT_ORDINAL:

                    //
                    // The only option here is "select none"
                    //

                    strcpy (lpszComboText, "00000000");
                    PostMessage (hwnd, WM_USER+55, 0, 0);
                    break;

                case PT_WSAPROTOCOLINFO:
                {
                    if (lSel == 1)
                    {
                        LPWSAPROTOCOL_INFOA  pInfo = (gbWideStringParams ?
                                                (LPWSAPROTOCOL_INFOA)
                                                    &gWSAProtocolInfoW :
                                                &gWSAProtocolInfoA);
                        char szProtocol[MAX_STRING_PARAM_SIZE];
                        FUNC_PARAM params[] =
                        {
                            { "dwServiceFlags1",    PT_FLAGS,   (ULONG_PTR) pInfo->dwServiceFlags1, aServiceFlags },
                            { "dwServiceFlags2",    PT_DWORD,   (ULONG_PTR) pInfo->dwServiceFlags2, NULL },
                            { "dwServiceFlags3",    PT_DWORD,   (ULONG_PTR) pInfo->dwServiceFlags3, NULL },
                            { "dwServiceFlags4",    PT_DWORD,   (ULONG_PTR) pInfo->dwServiceFlags4, NULL },
                            { "dwProviderFlags1",   PT_FLAGS,   (ULONG_PTR) pInfo->dwProviderFlags, aProviderFlags },
                            { "ProviderID.Data1",   PT_DWORD,   (ULONG_PTR) pInfo->ProviderId.Data1, NULL },
                            { "ProviderID.Data2",   PT_DWORD,   (ULONG_PTR) pInfo->ProviderId.Data2, NULL },
                            { "ProviderID.Data3",   PT_DWORD,   (ULONG_PTR) pInfo->ProviderId.Data3, NULL },
                            { "ProviderID.Data4[0-3]",PT_DWORD, *((LPDWORD) pInfo->ProviderId.Data4), NULL },
                            { "ProviderID.Data4[4-7]",PT_DWORD, *((LPDWORD) &pInfo->ProviderId.Data4[4]), NULL },
                            { "dwCatalogEntryId",   PT_DWORD,   (ULONG_PTR) pInfo->dwCatalogEntryId, NULL },
                            { "ProtoChain.Len",     PT_DWORD,   (ULONG_PTR) pInfo->ProtocolChain.ChainLen, NULL },
                            { "ProtoChain.Entry0",  PT_DWORD,   (ULONG_PTR) pInfo->ProtocolChain.ChainEntries[0], NULL },
                            { "ProtoChain.Entry1",  PT_DWORD,   (ULONG_PTR) pInfo->ProtocolChain.ChainEntries[1], NULL },
                            { "ProtoChain.Entry2",  PT_DWORD,   (ULONG_PTR) pInfo->ProtocolChain.ChainEntries[2], NULL },
                            { "ProtoChain.Entry3",  PT_DWORD,   (ULONG_PTR) pInfo->ProtocolChain.ChainEntries[3], NULL },
                            { "ProtoChain.Entry4",  PT_DWORD,   (ULONG_PTR) pInfo->ProtocolChain.ChainEntries[4], NULL },
                            { "ProtoChain.Entry5",  PT_DWORD,   (ULONG_PTR) pInfo->ProtocolChain.ChainEntries[5], NULL },
                            { "ProtoChain.Entry6",  PT_DWORD,   (ULONG_PTR) pInfo->ProtocolChain.ChainEntries[6], NULL },
                            { "iVersion",           PT_DWORD,   (ULONG_PTR) pInfo->iVersion, NULL },
                            { "iAddressFamily",     PT_ORDINAL, (ULONG_PTR) pInfo->iAddressFamily, aAddressFamilies },
                            { "iMaxSockAddr",       PT_DWORD,   (ULONG_PTR) pInfo->iMaxSockAddr, NULL },
                            { "iMinSockAddr",       PT_DWORD,   (ULONG_PTR) pInfo->iMinSockAddr, NULL },
                            { "iSocketType",        PT_FLAGS,   (ULONG_PTR) pInfo->iSocketType, aSocketTypes },
                            { "iProtocol",          PT_DWORD,   (ULONG_PTR) pInfo->iProtocol, NULL }, // ought be flags?
                            { "iProtocolMaxOffset", PT_DWORD,   (ULONG_PTR) pInfo->iProtocolMaxOffset, NULL },
                            { "iNetworkByteOrder",  PT_ORDINAL, (ULONG_PTR) pInfo->iNetworkByteOrder, aNetworkByteOrders },
                            { "iSecurityScheme",    PT_DWORD,   (ULONG_PTR) pInfo->iSecurityScheme, NULL },
                            { "dwMessageSize",      PT_DWORD,   (ULONG_PTR) pInfo->dwMessageSize, NULL },
                            { "dwProviderReserved", PT_DWORD,   (ULONG_PTR) pInfo->dwProviderReserved, NULL },
                            { "szProtocol",         PT_STRING,  (ULONG_PTR) szProtocol, szProtocol }
                        };
                        FUNC_PARAM_HEADER paramsHeader =
                            { 31, WSAProtoInfo, params, NULL };


                        //
                        // Set "ghwndModal" so this Params dlg will
                        // be modal to the existing Params dlg
                        //

                        ghwndModal = hwnd;

                        if (gbWideStringParams)
                        {
                            //
                            // Convert from unicode to ascii show text not
                            // clipped after 1st char (it's an ascii window)
                            //

                            WideCharToMultiByte(
                                GetACP(),
                                0,
                                (LPWSTR) pInfo->szProtocol,
                                lstrlenW ((LPWSTR) pInfo->szProtocol) + 1,
                                szProtocol,
                                MAX_STRING_PARAM_SIZE,
                                NULL,
                                NULL
                                );
                        }
                        else
                        {
                            lstrcpyA (szProtocol, pInfo->szProtocol);
                        }


                        if (LetUserMungeParams (&paramsHeader))
                        {
                            //
                            // Save the new params
                            //

                            pInfo->dwServiceFlags1    = (DWORD)
                                params[0].dwValue;
                            pInfo->dwServiceFlags2    = (DWORD)
                                params[1].dwValue;
                            pInfo->dwServiceFlags3    = (DWORD)
                                params[2].dwValue;
                            pInfo->dwServiceFlags4    = (DWORD)
                                params[3].dwValue;
                            pInfo->dwProviderFlags    = (DWORD)
                                params[4].dwValue;
                            pInfo->ProviderId.Data1   = (DWORD)
                                params[5].dwValue;
                            pInfo->ProviderId.Data2   = (unsigned short)
                                LOWORD(params[6].dwValue);
                            pInfo->ProviderId.Data3   = (unsigned short)
                                LOWORD(params[7].dwValue);
                            *((LPDWORD) pInfo->ProviderId.Data4) = (DWORD)
                                params[8].dwValue;
                            *((LPDWORD) &pInfo->ProviderId.Data4[4]) = (DWORD)
                                params[9].dwValue;
                            pInfo->dwCatalogEntryId   = (DWORD)
                                params[10].dwValue;
                            pInfo->ProtocolChain.ChainLen = (DWORD)
                                params[11].dwValue;
                            pInfo->ProtocolChain.ChainEntries[0] = (DWORD)
                                params[12].dwValue;
                            pInfo->ProtocolChain.ChainEntries[1] = (DWORD)
                                params[13].dwValue;
                            pInfo->ProtocolChain.ChainEntries[2] = (DWORD)
                                params[14].dwValue;
                            pInfo->ProtocolChain.ChainEntries[3] = (DWORD)
                                params[15].dwValue;
                            pInfo->ProtocolChain.ChainEntries[4] = (DWORD)
                                params[16].dwValue;
                            pInfo->ProtocolChain.ChainEntries[5] = (DWORD)
                                params[17].dwValue;
                            pInfo->ProtocolChain.ChainEntries[6] = (DWORD)
                                params[18].dwValue;
                            pInfo->iVersion           = (int)
                                params[19].dwValue;
                            pInfo->iAddressFamily     = (int)
                                params[20].dwValue;
                            pInfo->iMaxSockAddr       = (int)
                                params[21].dwValue;
                            pInfo->iMinSockAddr       = (int)
                                params[22].dwValue;
                            pInfo->iSocketType        = (int)
                                params[23].dwValue;
                            pInfo->iProtocol          = (int)
                                params[24].dwValue;
                            pInfo->iProtocolMaxOffset = (int)
                                params[25].dwValue;
                            pInfo->iNetworkByteOrder  = (int)
                                params[26].dwValue;
                            pInfo->iSecurityScheme    = (int)
                                params[27].dwValue;
                            pInfo->dwMessageSize      = (DWORD)
                                params[28].dwValue;
                            pInfo->dwProviderReserved = (DWORD)
                                params[29].dwValue;

                            if (params[30].dwValue == (ULONG_PTR) szProtocol)
                            {
                                if (gbWideStringParams)
                                {
                                    lstrcpyW(
                                        (WCHAR *) pInfo->szProtocol,
                                        (WCHAR *) szProtocol
                                        );
                                }
                                else
                                {
                                    lstrcpyA (pInfo->szProtocol, szProtocol);
                                }
                            }
                        }


                        //
                        // Now reset ghwndModal to what it was initially
                        //

                        ghwndModal = ghwndMain;


                        //
                        // Strip off the "(valid pointer)" in the edit ctrl
                        //

                        wsprintf (lpszComboText, "%08lx", pInfo);
                        PostMessage (hwnd, WM_USER+55, 0, 0);

                        pParamsHeader->aParams[lLastSel].dwValue = (ULONG_PTR) pInfo;
                    }

                    break;
                }
                case PT_QOS:
                {
                    if (lSel == 1)
                    {
                        LPQOS   pQOS = (LPQOS)
                                    pParamsHeader->aParams[lLastSel].u.ptr;
                        FUNC_PARAM params[] =
                        {
                            { "Send.TokenRate",            PT_DWORD,   (ULONG_PTR) pQOS->SendingFlowspec.TokenRate, NULL },
                            { "Send.TokenBucketSize",      PT_DWORD,   (ULONG_PTR) pQOS->SendingFlowspec.TokenBucketSize, NULL },
                            { "Send.PeakBandwidth",        PT_DWORD,   (ULONG_PTR) pQOS->SendingFlowspec.PeakBandwidth, NULL },
                            { "Send.Latency",              PT_DWORD,   (ULONG_PTR) pQOS->SendingFlowspec.Latency, NULL },
                            { "Send.DelayVariation",       PT_DWORD,   (ULONG_PTR) pQOS->SendingFlowspec.DelayVariation, NULL },
                            { "Send.ServiceType",          PT_ORDINAL, (ULONG_PTR) pQOS->SendingFlowspec.ServiceType, aQOSServiceTypes },
                            { "Send.MaxSduSize",           PT_DWORD,   (ULONG_PTR) pQOS->SendingFlowspec.MaxSduSize, NULL },
                            { "Send.MinimumPolicedSize",   PT_DWORD,   (ULONG_PTR) pQOS->SendingFlowspec.MinimumPolicedSize, NULL },

                            { "Recv.TokenRate",            PT_DWORD,   (ULONG_PTR) pQOS->ReceivingFlowspec.TokenRate, NULL },
                            { "Recv.TokenBucketSize",      PT_DWORD,   (ULONG_PTR) pQOS->ReceivingFlowspec.TokenBucketSize, NULL },
                            { "Recv.PeakBandwidth",        PT_DWORD,   (ULONG_PTR) pQOS->ReceivingFlowspec.PeakBandwidth, NULL },
                            { "Recv.Latency",              PT_DWORD,   (ULONG_PTR) pQOS->ReceivingFlowspec.Latency, NULL },
                            { "Recv.DelayVariation",       PT_DWORD,   (ULONG_PTR) pQOS->ReceivingFlowspec.DelayVariation, NULL },
                            { "Recv.ServiceType",          PT_ORDINAL, (ULONG_PTR) pQOS->ReceivingFlowspec.ServiceType, aQOSServiceTypes },
                            { "Recv.MaxSduSize",           PT_DWORD,   (ULONG_PTR) pQOS->ReceivingFlowspec.MaxSduSize, NULL },
                            { "Recv.MinimumPolicedSize",   PT_DWORD,   (ULONG_PTR) pQOS->ReceivingFlowspec.MinimumPolicedSize, NULL },

                            { "ProviderSpecific.len",      PT_DWORD,   (ULONG_PTR) pQOS->ProviderSpecific.len, NULL },
                            { "ProviderSpecific.buf",      PT_POINTER, (ULONG_PTR) pQOS->ProviderSpecific.buf, pQOS+1 }
                        };
                        FUNC_PARAM_HEADER paramsHeader =
                            { 18, ws_QOS, params, NULL };


                        //
                        // Set "ghwndModal" so this Params dlg will
                        // be modal to the existing Params dlg
                        //

                        ghwndModal = hwnd;

                        if (LetUserMungeParams (&paramsHeader))
                        {
                            //
                            // Save the params
                            //

                            for (i = 0; i < 17; i++)
                            {
                                *(((LPDWORD) pQOS) + i) = (DWORD)
                                    params[i].dwValue;
                            }
                        }


                        //
                        // Now reset ghwndModal to what it was initially
                        //

                        ghwndModal = ghwndMain;


                        //
                        // Strip off the "(valid pointer)" in the edit ctrl
                        //

                        wsprintf (lpszComboText, "%08lx", pQOS);
                        PostMessage (hwnd, WM_USER+55, 0, 0);

                        pParamsHeader->aParams[lLastSel].dwValue =
                            (ULONG_PTR) pQOS;
                    }

                    break;
                }
                } // switch

                break;
            }
            case CBN_EDITCHANGE:
            {
                //
                // If user entered text in the edit field then copy the
                // text to our buffer
                //

                if (pParamsHeader->aParams[lLastSel].dwType == PT_STRING)
                {
                    char buf[MAX_STRING_PARAM_SIZE];


                    GetDlgItemText(
                        hwnd,
                        IDC_COMBO1,
                        buf,
                        MAX_STRING_PARAM_SIZE
                        );

                    strncpy(
                        pParamsHeader->aParams[lLastSel].u.buf,
                        buf,
                        MAX_STRING_PARAM_SIZE
                        );

                    pParamsHeader->aParams[lLastSel].u.buf
                        [MAX_STRING_PARAM_SIZE-1] = 0;
                }
                break;
            }
            } // switch

        } // switch

        break;
    }
    case WM_USER+55:

        SetDlgItemText (hwnd, IDC_COMBO1, pDlgInstData->szComboText);
        break;

#ifdef WIN32
    case WM_CTLCOLORSTATIC:

        SetBkColor ((HDC) wParam, RGB (192,192,192));
        return (INT_PTR) GetStockObject (LTGRAY_BRUSH);
#else
    case WM_CTLCOLOR:
    {
        if (HIWORD(lParam) == CTLCOLOR_STATIC)
        {
            SetBkColor ((HDC) wParam, RGB (192,192,192));
            return (INT_PTR) GetStockObject (LTGRAY_BRUSH);
        }
        break;
    }
#endif
    case WM_PAINT:
    {
        PAINTSTRUCT ps;

        BeginPaint (hwnd, &ps);
        FillRect (ps.hdc, &ps.rcPaint, GetStockObject (LTGRAY_BRUSH));
        EndPaint (hwnd, &ps);

        break;
    }
    } // switch

    return FALSE;
}


INT_PTR
CALLBACK
UserButtonsDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static int iButtonIndex;

    switch (msg)
    {
    case WM_INITDIALOG:
    {
        int i;
        char buf[32];

        if (lParam)
        {
            //
            // The dlg was invoked because someone pressed a user button
            // that was uninitialized, so only allow chgs on this button
            //

            iButtonIndex = *((int *) lParam);

            _itoa (iButtonIndex + 1, buf, 10);

            SendDlgItemMessage(
                hwnd,
                IDC_LIST1,
                LB_INSERTSTRING,
                (WPARAM) -1,
                (LPARAM) buf
                );
        }
        else
        {
            //
            // The dlg was invoked because the user chose a menuitem,
            // so allow chgs on all buttons
            //

            iButtonIndex = MAX_USER_BUTTONS;

            for (i = 1; i <= MAX_USER_BUTTONS; i++)
            {
                _itoa (i, buf, 10);

                SendDlgItemMessage(
                    hwnd,
                    IDC_LIST1,
                    LB_INSERTSTRING,
                    (WPARAM) -1,
                    (LPARAM) buf
                    );
            }

        }

        SendDlgItemMessage(
            hwnd,
            IDC_LIST1,
            LB_SETCURSEL,
            (WPARAM) 0,
            0
            );

        for (i = 0; aFuncNames[i]; i++)
        {
            SendDlgItemMessage(
                hwnd,
                IDC_LIST2,
                LB_INSERTSTRING,
                (WPARAM) -1,
                (LPARAM) aFuncNames[i]
                );
        }

        SendDlgItemMessage(
            hwnd,
            IDC_LIST2,
            LB_INSERTSTRING,
            (WPARAM) -1,
            (LPARAM) "<none>"
            );

        if (!lParam)
        {
#ifdef WIN32
            wParam = (WPARAM) MAKELONG (0, LBN_SELCHANGE);
#else
            lParam = (LPARAM) MAKELONG (0, LBN_SELCHANGE);
#endif
            goto IDC_LIST1_selchange;
        }

        break;
    }
    case WM_COMMAND:

        switch (LOWORD(wParam))
        {
        case IDOK:
        {
            LRESULT lFuncSel;


            lFuncSel = SendDlgItemMessage(hwnd, IDC_LIST2, LB_GETCURSEL, 0, 0);

            if (lFuncSel == LB_ERR)
            {
                MessageBox (hwnd, "Select a function", "", MB_OK);
                break;
            }

            if (iButtonIndex == MAX_USER_BUTTONS)
            {
                iButtonIndex = (int) SendDlgItemMessage(
                    hwnd,
                    IDC_LIST1,
                    LB_GETCURSEL,
                    0,
                    0
                    );
            }

            aUserButtonFuncs[iButtonIndex] = (DWORD) lFuncSel;

            if (lFuncSel == MiscBegin)
            {
                //
                // User selected "<none>" option so nullify string
                //

                aUserButtonsText[iButtonIndex][0] = 0;
            }
            else
            {
                GetDlgItemText(
                    hwnd,
                    IDC_EDIT1,
                    (LPSTR) &aUserButtonsText[iButtonIndex],
                    MAX_USER_BUTTON_TEXT_SIZE - 1
                    );

                aUserButtonsText[iButtonIndex][MAX_USER_BUTTON_TEXT_SIZE - 1] =
                    0;
            }

            SetDlgItemText(
                ghwndMain,
                IDC_BUTTON7 + iButtonIndex,
                (LPSTR) &aUserButtonsText[iButtonIndex]
                );

            // Fall thru to IDCANCEL code
        }
        case IDCANCEL:

            EndDialog (hwnd, FALSE);
            break;

        case IDC_LIST1:

IDC_LIST1_selchange:

#ifdef WIN32
            if (HIWORD(wParam) == LBN_SELCHANGE)
#else
            if (HIWORD(lParam) == LBN_SELCHANGE)
#endif
            {
                LRESULT lButtonSel =
                    SendDlgItemMessage(hwnd, IDC_LIST1, LB_GETCURSEL, 0, 0);


                SendDlgItemMessage(
                    hwnd,
                    IDC_LIST2,
                    LB_SETCURSEL,
                    (WPARAM) aUserButtonFuncs[lButtonSel],
                    0
                    );

                SetDlgItemText(
                    hwnd,
                    IDC_EDIT1,
                    aUserButtonsText[lButtonSel]
                    );
            }
            break;

        } // switch

        break;

#ifdef WIN32
    case WM_CTLCOLORSTATIC:

        SetBkColor ((HDC) wParam, RGB (192,192,192));
        return (INT_PTR) GetStockObject (LTGRAY_BRUSH);
#else
    case WM_CTLCOLOR:
    {
        if (HIWORD(lParam) == CTLCOLOR_STATIC)
        {
            SetBkColor ((HDC) wParam, RGB (192,192,192));
            return (INT_PTR) GetStockObject (LTGRAY_BRUSH);
        }
        break;
    }
#endif
    case WM_PAINT:
    {
        PAINTSTRUCT ps;

        BeginPaint (hwnd, &ps);
        FillRect (ps.hdc, &ps.rcPaint, GetStockObject (LTGRAY_BRUSH));
        EndPaint (hwnd, &ps);

        break;
    }
    } // switch

    return FALSE;
}


int
CALLBACK
ConditionProc(
    LPWSABUF    lpCallerId,
    LPWSABUF    lpCallerData,
    LPQOS       lpSQOS,
    LPQOS       lpGQOS,
    LPWSABUF    lpCalleeId,
    LPWSABUF    lpCalleeData,
    GROUP FAR   *g,
    DWORD       dwCallbackData
    )
{
    ShowStr ("ConditionProc: enter");

    return 0;
}


void
CALLBACK
CompletionProc(
    DWORD           dwError,
    DWORD           cbTransferred,
    LPWSAOVERLAPPED pOverlapped,
    DWORD           dwFlags
    )
{
    ShowStr ("CompletionProc: enter");
    ShowStr ("  dwError=%ld", dwError);
    ShowStr ("  cbTransferred=%ld", cbTransferred);
    ShowStr ("  pOverlapped=x%x", pOverlapped);
    ShowStr ("  dwFlags=%d (x%x)", dwFlags, dwFlags);

    MyFree (pOverlapped);
}


DWORD
PASCAL
ShowError(
    FUNC_INDEX  funcIndex,
    int         iResult
    )
{
    DWORD   i, dwError = (iResult == 0 ? (DWORD) WSAGetLastError() : iResult);


    for(
        i = 0;
        (dwError != aWSAErrors[i].dwVal  &&  aWSAErrors[i].lpszVal);
        i++
        );

    ShowStr(
        "%s error: %s (%d)",
        aFuncNames[funcIndex],
        (aWSAErrors[i].lpszVal ? aWSAErrors[i].lpszVal : gszUnknownError),
        dwError
        );

    return dwError;
}


void
PASCAL
ShowUnknownError(
    FUNC_INDEX  funcIndex,
    int         iResult
    )
{
     ShowStr(
         "%s returned unrecognized error (%d)",
         aFuncNames[funcIndex],
         iResult
         );
}


void
FAR
PASCAL
FuncDriver(
    FUNC_INDEX funcIndex
    )
{
    int i, j, k;


    //
    // Determine if we're doing a ascii or a unicode op
    //

    gbWideStringParams =
        ((aFuncNames[funcIndex])[strlen (aFuncNames[funcIndex]) - 1] == 'W' ?
            TRUE : FALSE);


    //
    // Zero the global buf so the user doesn't see extraneous stuff
    //

    ZeroMemory (pBigBuf, dwBigBufSize);


    //
    // The big switch statement...
    //

    switch (funcIndex)
    {
    case ws_accept:
    {
        int iLength;
        struct sockaddr sa;
        FUNC_PARAM params[] =
        {
            { gszSocket,        PT_DWORD,       (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "lpAddress",      PT_PTRNOEDIT,   (ULONG_PTR) &sa, &sa },
            { "lpiAddrLength",  PT_PTRNOEDIT,   (ULONG_PTR) &iLength, &iLength },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            SOCKET s;


            if ((s = accept(
                    (SOCKET) params[0].dwValue,
                    (struct sockaddr FAR *) params[1].dwValue,
                    (int FAR *) params[2].dwValue

                    )) != INVALID_SOCKET)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr ("  returned socket=x%x", s);

                if (params[1].dwValue)
                {
                    ShowStr ("  lpAddress=x%x", params[1].dwValue);

                    ShowStr(
                        "  ->sa_family=%d, %s",
                        sa.sa_family,
                        GetStringFromOrdinalValue(
                            (DWORD) sa.sa_family,
                            aAddressFamilies
                            )
                        );

                    ShowStr ("  ->sa_data=");
                    ShowBytes (14, sa.sa_data, 1);
                }
            }
            else
            {
                ShowError (funcIndex, 0);
            }
        }

        break;
    }
    case ws_bind:
    {
        FUNC_PARAM params[] =
        {
            { gszSocket,        PT_DWORD,       (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "lpName",         PT_PTRNOEDIT,   (ULONG_PTR) pBigBuf, pBigBuf },
            { "  ->sa_family",  PT_ORDINAL,     (ULONG_PTR) gdwDefAddrFamily, aAddressFamilies },
            { "  ->sa_data",    PT_POINTER,     (ULONG_PTR) (pBigBuf + 2), pBigBuf + 2 },
            { "namelen",        PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            *((u_short *) pBigBuf) = LOWORD(params[2].dwValue);

            if ((i = bind(
                    (SOCKET) params[0].dwValue,
                    (struct sockaddr FAR *) params[1].dwValue,
                    (int) params[4].dwValue

                    )) == 0)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
            }
            else if (i == SOCKET_ERROR)
            {
                ShowError (funcIndex, 0);
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }
        }

        break;
    }
    case ws_closesocket:
    {
        FUNC_PARAM params[] =
        {
            { gszSocket,    PT_DWORD,   (ULONG_PTR) gpSelectedSocket->Sock, NULL },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if ((i = closesocket ((SOCKET) params[0].dwValue)) == 0)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);

                if ((SOCKET) params[0].dwValue != gpSelectedSocket->Sock)
                {
                    //
                    // The user overrode the selected widget, so make sure
                    // we don't delete the wrong string from the list box
                    //

                    int         iNumItems;
                    PMYSOCKET   ps;


                    iNumItems = (int) SendMessage(
                        ghwndList1,
                        LB_GETCOUNT,
                        0,
                        0
                        );

                    for (i = 0; i < iNumItems; i++)
                    {
                        ps = (PMYSOCKET) SendMessage(
                            ghwndList1,
                            LB_GETITEMDATA,
                            i,
                            0
                            );

                        if ((SOCKET) params[0].dwValue == ps->Sock)
                        {
                            glCurrentSelection = (LONG) i;
                            gpSelectedSocket = ps;
                            break;
                        }
                    }

                    if (i == iNumItems)
                    {
                        ShowStr(
                            "Strange, couldn't find socket=x%x in list",
                            params[0].dwValue
                            );

                        break;
                    }
                }

                SendMessage(
                    ghwndList1,
                    LB_DELETESTRING,
                    glCurrentSelection,
                    0
                    );

                MyFree (gpSelectedSocket);
            }
            else if (i == SOCKET_ERROR)
            {
                ShowError (funcIndex, 0);
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }
        }

        break;
    }
    case ws_connect:
    {
        FUNC_PARAM params[] =
        {
            { gszSocket,        PT_DWORD,       (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "lpName",         PT_PTRNOEDIT,   (ULONG_PTR) pBigBuf, pBigBuf },
            { "  ->sa_family",  PT_ORDINAL,     (ULONG_PTR) gdwDefAddrFamily, aAddressFamilies },
            { "  ->sa_data",    PT_POINTER,     (ULONG_PTR) (pBigBuf + 2), pBigBuf + 2 },
            { "namelen",        PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            *((u_short *) pBigBuf) = LOWORD(params[2].dwValue);

            if ((i = connect(
                    (SOCKET) params[0].dwValue,
                    (struct sockaddr FAR *) params[1].dwValue,
                    (int) params[4].dwValue

                    )) == 0)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
            }
            else if (i == SOCKET_ERROR)
            {
                ShowError (funcIndex, 0);
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }
        }

        break;
    }
    case ws_gethostbyaddr:
    {
        char szAddress[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { "addr",   PT_POINTER, (ULONG_PTR) pBigBuf, pBigBuf },
            { "len",    PT_DWORD,   (ULONG_PTR) dwBigBufSize, NULL },
            { "type",   PT_ORDINAL, (ULONG_PTR) gdwDefAddrFamily, aAddressFamilies },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, NULL };


        lstrcpy (szAddress, "xxx");

        if (LetUserMungeParams (&paramsHeader))
        {
            struct hostent  *phe;


            // note: WinSock owns the returned ptr, don't free/munge it

            if ((phe = gethostbyaddr(
                    (char FAR *) params[0].dwValue,
                    (int) params[1].dwValue,
                    (int) params[2].dwValue
                    )))
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowHostEnt (phe);
            }
            else
            {
                ShowError (funcIndex, 0);
            }
        }

        break;
    }
    case ws_gethostbyname:
    {
        char szHostName[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { "name",   PT_STRING,  (ULONG_PTR) szHostName, szHostName }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, NULL };


        lstrcpyA (szHostName, gszDefHostName);

        if (LetUserMungeParams (&paramsHeader))
        {
            struct hostent  *phe;


            // note: WinSock owns the returned ptr, don't free/munge it

            if ((phe = gethostbyname ((char FAR *) params[0].dwValue)))
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowHostEnt (phe);
            }
            else
            {
                ShowError (funcIndex, 0);
            }
        }

        break;
    }
    case ws_gethostname:
    {
        char szName[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { "name",   PT_POINTER,  (ULONG_PTR) szName, szName },
            { "namelen",PT_DWORD,    (ULONG_PTR) MAX_STRING_PARAM_SIZE, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if ((i = gethostname(
                    (char FAR *) params[0].dwValue,
                    (int) params[1].dwValue

                    )) == 0)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr ("  name=%s", (char FAR *) params[0].dwValue);
            }
            else if (i == SOCKET_ERROR)
            {
                ShowError (funcIndex, 0);
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }
        }

        break;
    }
    case ws_getpeername:
    case ws_getsockname:
    {
        int     iNameLen = dwBigBufSize;
        FUNC_PARAM params[] =
        {
            { gszSocket,        PT_DWORD,       (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "lpName",         PT_PTRNOEDIT,   (ULONG_PTR) pBigBuf, pBigBuf },
            { "lpiNameLength",  PT_PTRNOEDIT,   (ULONG_PTR) &iNameLen, &iNameLen },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if (funcIndex == ws_getpeername)
            {
                i = getpeername(
                    (SOCKET) params[0].dwValue,
                    (struct sockaddr FAR *) params[1].dwValue,
                    (int *) params[2].dwValue
                    );
            }
            else
            {
                i = getsockname(
                    (SOCKET) params[0].dwValue,
                    (struct sockaddr FAR *) params[1].dwValue,
                    (int *) params[2].dwValue
                    );
            }

            if (i == 0)
            {
                DWORD dwAddressFamily = (DWORD)
                          *((u_short *) params[1].dwValue);


                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);

                ShowStr ("  *lpNameLength=x%x", *((int *) params[2].dwValue));
                ShowStr ("  lpName=x%x", params[1].dwValue);

                ShowStr(
                    "    ->AddressFamiliy=%d, %s",
                    dwAddressFamily,
                    GetStringFromOrdinalValue(
                        dwAddressFamily,
                        aAddressFamilies
                        )
                    );

                ShowStr ("    ->Data=");
                ShowBytes(
                    *((int *) params[2].dwValue) - sizeof (u_short),
                    (LPBYTE) params[1].dwValue + 2,
                    1
                    );
            }
            else if (i == SOCKET_ERROR)
            {
                ShowError (funcIndex, 0);
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }
        }

        break;
    }
    case ws_getprotobyname:
    {
        char szProtoName[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { "name",   PT_STRING,  (ULONG_PTR) szProtoName, szProtoName },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, NULL };


        lstrcpyA (szProtoName, gszDefProtoName);

        if (LetUserMungeParams (&paramsHeader))
        {
            struct protoent *ppe;


            // note: WinSock owns the returned ptr, don't free/munge it

            if ((ppe = getprotobyname ((char FAR *) params[0].dwValue)))
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowProtoEnt (ppe);
            }
            else
            {
                ShowError (funcIndex, 0);
            }
        }

        break;
    }
    case ws_getprotobynumber:
    {
        FUNC_PARAM params[] =
        {
            { "number", PT_DWORD,   (ULONG_PTR) gdwDefPortNum, NULL },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            struct protoent *ppe;


            // note: WinSock owns the returned ptr, don't free/munge it

            if ((ppe = getprotobynumber ((int) params[0].dwValue)))
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowProtoEnt (ppe);
            }
            else
            {
                ShowError (funcIndex, 0);
            }
        }

        break;
    }
    case ws_getservbyname:
    {
        char szServName[MAX_STRING_PARAM_SIZE];
        char szProtoName[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { "serviceName",    PT_STRING,  (ULONG_PTR) szServName, szServName },
            { "protoName",      PT_STRING,  (ULONG_PTR) 0, szProtoName },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, NULL };


        lstrcpyA (szServName, gszDefServName);
        lstrcpyA (szProtoName, gszDefProtoName);

        if (LetUserMungeParams (&paramsHeader))
        {
            struct servent *pse;


            // note: WinSock owns the returned ptr, don't free/munge it

            if ((pse = getservbyname(
                    (char FAR *) params[0].dwValue,
                    (char FAR *) params[1].dwValue
                    )))
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowServEnt (pse);
            }
            else
            {
                ShowError (funcIndex, 0);
            }
        }

        break;
    }
    case ws_getservbyport:
    {
        char szProtoName[MAX_STRING_PARAM_SIZE];
        FUNC_PARAM params[] =
        {
            { "port",       PT_DWORD,   (ULONG_PTR) gdwDefPortNum, NULL },
            { "protoName",  PT_STRING,  (ULONG_PTR) 0, szProtoName },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, NULL };


        lstrcpyA (szProtoName, gszDefProtoName);

        if (LetUserMungeParams (&paramsHeader))
        {
            struct servent *pse;


            // note: WinSock owns the returned ptr, don't free/munge it

            if ((pse = getservbyport(
                    (int) params[0].dwValue,
                    (char FAR *) params[1].dwValue
                    )))
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowServEnt (pse);
            }
            else
            {
                ShowError (funcIndex, 0);
            }
        }

        break;
    }
    case ws_getsockopt:
    {
        int iOptionBufLength = dwBigBufSize;
        FUNC_PARAM params[] =
        {
            { gszSocket,            PT_DWORD,       (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "iLevel",             PT_ORDINAL,     (ULONG_PTR) 0, aSockOptLevels },
            { "iOptionName",        PT_ORDINAL,     (ULONG_PTR) 0, aSockOpts },
            { "lpOptionBuf",        PT_PTRNOEDIT,   (ULONG_PTR) pBigBuf, pBigBuf },
            { "lpiOptionBufLength", PT_POINTER,     (ULONG_PTR) &iOptionBufLength, &iOptionBufLength },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if ((i = getsockopt(
                    (SOCKET) params[0].dwValue,
                    (int) params[1].dwValue,
                    (int) params[2].dwValue,
                    (char FAR *) params[3].dwValue,
                    (int FAR *) params[4].dwValue

                    )) == 0)
            {
// getockopt: format returned OptionBuf data

                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);

                ShowStr(
                    "  Level/OptionName=%d/%d, %s/%s",
                    params[1].dwValue,
                    params[2].dwValue,
                    GetStringFromOrdinalValue(
                        (DWORD) params[1].dwValue,
                        aSockOptLevels
                        ),
                    GetStringFromOrdinalValue(
                        (DWORD) params[2].dwValue,
                        aSockOpts
                        )
                    );

                ShowStr(
                    "  *lpiOptionBufLength=x%x",
                    *((int *) params[4].dwValue)
                    );
                ShowStr ("  *lpOptionBuf=");
                ShowBytes(
                    (DWORD) *((int *) params[4].dwValue),
                    (LPVOID) params[3].dwValue,
                    1
                    );
            }
            else if (i == SOCKET_ERROR)
            {
                 ShowError (funcIndex, 0);
            }
            else
            {
                 ShowUnknownError (funcIndex, i);
            }
        }

        break;
    }
    case ws_htonl:
    {
        FUNC_PARAM params[] =
        {
            { "hostLong", PT_DWORD,   (ULONG_PTR) 0x12345678, NULL },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
            ShowStr ("  hostLong=x%x", params[0].dwValue);
            ShowStr ("  networkLong=x%x", htonl ((u_long) params[0].dwValue));
        }

        break;
    }
    case ws_htons:
    {
        FUNC_PARAM params[] =
        {
            { "hostShort", PT_DWORD,   (ULONG_PTR) 0x1234, NULL },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
            ShowStr ("  hostShort=x%x", (DWORD) LOWORD(params[0].dwValue));
            ShowStr(
                "  networkShort=x%x",
                (DWORD) htons ((u_short) LOWORD(params[0].dwValue))
                );
        }

        break;
    }
    case ws_inet_addr:
    {
        char szInetAddr[MAX_STRING_PARAM_SIZE] = "1.2.3.4";
        FUNC_PARAM params[] =
        {
            { "szInternetAddress",   PT_STRING,  (ULONG_PTR) szInetAddr, szInetAddr },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            unsigned long l = inet_addr ((char FAR *) params[0].dwValue);


            if (l != INADDR_NONE)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr ("  ulInternetAddress=x%x", l);
            }
            else
            {
                ShowStr ("inet_addr error: INADDR_NONE");
            }
        }

        break;
    }
    case ws_inet_ntoa:
    {
        FUNC_PARAM params[] =
        {
            { "ulInternetAddress",   PT_DWORD,  (ULONG_PTR) 0x04030201, NULL },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            char FAR *pszInetAddr;
            struct in_addr ia;


            CopyMemory (&ia, &params[0].dwValue, sizeof (DWORD));

            if ((pszInetAddr = inet_ntoa (ia)))
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr ("  pszInternetAddress=x%x", pszInetAddr);
                ShowStr ("  szInternetAddress=%s", pszInetAddr);
            }
            else
            {
                ShowStr ("inet_ntoa error: returned NULL");
            }
        }

        break;
    }
    case ws_ioctlsocket:
    {
        FUNC_PARAM params[] =
        {
            { gszSocket,    PT_DWORD,   (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "lCommand",   PT_ORDINAL, (ULONG_PTR) 0, aIoctlCmds },
            { "lpData",     PT_POINTER, (ULONG_PTR) pBigBuf, pBigBuf }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if ((i = ioctlsocket(
                    (SOCKET) params[0].dwValue,
                    (long) params[1].dwValue,
                    (u_long FAR *) params[2].dwValue

                    )) == 0)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);

                ShowStr(
                    "  lCommand=%d, %s",
                    params[1].dwValue,
                    GetStringFromOrdinalValue(
                        (DWORD) params[1].dwValue,
                        aIoctlCmds
                        )
                    );

                ShowStr ("  *lpData=");
                ShowBytes (16, (LPVOID) params[2].dwValue, 1);
            }
            else if (i == SOCKET_ERROR)
            {
                ShowError (funcIndex, 0);
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }
        }

        break;
    }
    case ws_listen:
    {
        FUNC_PARAM params[] =
        {
            { gszSocket,    PT_DWORD,   (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "iBacklog",   PT_DWORD,   (ULONG_PTR) 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if ((i = listen(
                    (SOCKET) params[0].dwValue,
                    (int) params[1].dwValue

                    )) == 0)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
            }
            else if (i == SOCKET_ERROR)
            {
                ShowError (funcIndex, 0);
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }
        }

        break;
    }
    case ws_ntohl:
    {
        FUNC_PARAM params[] =
        {
            { "networkLong", PT_DWORD,  (ULONG_PTR) 0x12345678, NULL },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
            ShowStr ("  networkLong=x%x", params[0].dwValue);
            ShowStr ("  hostLong=x%x", ntohl ((u_long) params[0].dwValue));
        }

        break;
    }
    case ws_ntohs:
    {
        FUNC_PARAM params[] =
        {
            { "networkShort", PT_DWORD, (ULONG_PTR) 0x1234, NULL },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
            ShowStr ("  networkShort=x%x",(DWORD) LOWORD(params[0].dwValue));
            ShowStr(
                "  hostShort=x%x",
                (DWORD) ntohs ((u_short) LOWORD(params[0].dwValue))
                );
        }

        break;
    }
    case ws_recv:
    {
        FUNC_PARAM params[] =
        {
            { gszSocket,    PT_DWORD,       (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "lpBuf",      PT_PTRNOEDIT,   (ULONG_PTR) pBigBuf, pBigBuf },
            { "iBufLength", PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            { "iRecvFlags", PT_FLAGS,       (ULONG_PTR) gdwDefRecvFlags, aRecvFlags },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if ((i = recv(
                    (SOCKET) params[0].dwValue,
                    (char FAR *) params[1].dwValue,
                    (int) params[2].dwValue,
                    (int) params[3].dwValue

                    )) != SOCKET_ERROR)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr ("  NumByteReceived=x%x", i);
                ShowStr ("  *pBuf=");
                ShowBytes (i, (LPVOID) params[1].dwValue, 1);
            }
            else
            {
                ShowError (funcIndex, 0);
            }
        }

        break;
    }
    case ws_recvfrom:
    {
        int    iSrcAddrLen;
        struct sockaddr FAR *pSrcAddr = MyAlloc (dwBigBufSize);
        FUNC_PARAM params[] =
        {
            { gszSocket,            PT_DWORD,       (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "lpBuf",              PT_PTRNOEDIT,   (ULONG_PTR) pBigBuf, pBigBuf },
            { "iBufLength",         PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            { "iRecvFlags",         PT_FLAGS,       (ULONG_PTR) gdwDefRecvFlags, aRecvFlags },
            { "lpSourceAddr",       PT_PTRNOEDIT,   (ULONG_PTR) pSrcAddr, pSrcAddr },
            { "lpiSourceAddrLength",PT_POINTER,     (ULONG_PTR) &iSrcAddrLen, &iSrcAddrLen },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, NULL };


        if (!pSrcAddr)
        {
            break;
        }

        if (LetUserMungeParams (&paramsHeader))
        {
            if ((i = recvfrom(
                    (SOCKET) params[0].dwValue,
                    (char FAR *) params[1].dwValue,
                    (int) params[2].dwValue,
                    (int) params[3].dwValue,
                    (struct sockaddr FAR *) params[4].dwValue,
                    (int FAR *) params[5].dwValue

                    )) != SOCKET_ERROR)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr ("  NumByteReceived=x%x", i);
                ShowStr ("  *pBuf=");
                ShowBytes (i, (LPVOID) params[1].dwValue, 1);
                ShowStr(
                    "  *lpiSourceAddrLength=%d",
                    (DWORD) *((int *) params[5].dwValue)
                    );
                ShowStr ("  *lpSourceAddr=");
                ShowBytes(
                    *((int *) params[5].dwValue),
                    (LPVOID) params[4].dwValue,
                    1
                    );
            }
            else
            {
                ShowError (funcIndex, 0);
            }
        }

        MyFree (pSrcAddr);

        break;
    }
    case ws_select:

// case ws_select:
        break;

    case ws_send:
    {
        FUNC_PARAM params[] =
        {
            { gszSocket,    PT_DWORD,   (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "lpBuf",      PT_POINTER, (ULONG_PTR) pBigBuf, pBigBuf },
            { "iBufLength", PT_DWORD,   (ULONG_PTR) dwBigBufSize, NULL },
            { "iSendFlags", PT_FLAGS,   (ULONG_PTR) gdwDefSendFlags, aSendFlags },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if ((i = send(
                    (SOCKET) params[0].dwValue,
                    (char FAR *) params[1].dwValue,
                    (int) params[2].dwValue,
                    (int) params[3].dwValue

                    )) != SOCKET_ERROR)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr ("  NumBytesSent=x%x", i);
            }
            else
            {
                ShowError (funcIndex, 0);
            }
        }

        break;
    }
    case ws_sendto:
    {
        int    iTargetAddrLen;
        struct sockaddr FAR *pTargetAddr = MyAlloc (dwBigBufSize);
        FUNC_PARAM params[] =
        {
            { gszSocket,            PT_DWORD,   (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "lpBuf",              PT_POINTER, (ULONG_PTR) pBigBuf, pBigBuf },
            { "iBufLength",         PT_DWORD,   (ULONG_PTR) dwBigBufSize, NULL },
            { "iSendFlags",         PT_FLAGS,   (ULONG_PTR) gdwDefSendFlags, aSendFlags },
            { "lpTargetAddr",       PT_POINTER, (ULONG_PTR) pTargetAddr, pTargetAddr },
            { "iTargetAddrLength",  PT_DWORD,   (ULONG_PTR) dwBigBufSize, NULL },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if ((i = sendto(
                    (SOCKET) params[0].dwValue,
                    (char FAR *) params[1].dwValue,
                    (int) params[2].dwValue,
                    (int) params[3].dwValue,
                    (struct sockaddr FAR *) params[4].dwValue,
                    (int) params[5].dwValue

                    )) != SOCKET_ERROR)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr ("  NumBytesSent=x%x", i);
            }
            else
            {
                ShowError (funcIndex, 0);
            }
        }

        break;
    }
    case ws_setsockopt:
    {
        int iOptionBufLength = dwBigBufSize;
        FUNC_PARAM params[] =
        {
            { gszSocket,            PT_DWORD,   (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "iLevel",             PT_ORDINAL, (ULONG_PTR) 0, aSockOptLevels },
            { "iOptionName",        PT_ORDINAL, (ULONG_PTR) 0, aSockOpts },
            { "lpOptionBuf",        PT_POINTER, (ULONG_PTR) pBigBuf, pBigBuf },
            { "iOptionBufLength",   PT_DWORD,   (ULONG_PTR) dwBigBufSize, NULL },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if ((i = setsockopt(
                    (SOCKET) params[0].dwValue,
                    (int) params[1].dwValue,
                    (int) params[2].dwValue,
                    (char FAR *) params[3].dwValue,
                    (int) params[4].dwValue

                    )) == 0)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
            }
            else if (i == SOCKET_ERROR)
            {
                 ShowError (funcIndex, 0);
            }
            else
            {
                 ShowUnknownError (funcIndex, i);
            }
        }

        break;
    }
    case ws_shutdown:
    {
        FUNC_PARAM params[] =
        {
            { gszSocket,    PT_DWORD,   (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "iHow",       PT_ORDINAL, (ULONG_PTR) 0, aShutdownOps },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if ((i = shutdown(
                    (SOCKET) params[0].dwValue,
                    (int) params[1].dwValue

                    )) == 0)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
            }
            else if (i == SOCKET_ERROR)
            {
                 ShowError (funcIndex, 0);
            }
            else
            {
                 ShowUnknownError (funcIndex, i);
            }
        }

        break;
    }
    case ws_socket:
    {
        FUNC_PARAM params[] =
        {
            { "address family", PT_ORDINAL, (ULONG_PTR) gdwDefAddrFamily, aAddressFamilies },
            { "socket type",    PT_ORDINAL, (ULONG_PTR) gdwDefSocketType, aSocketTypes },
            { "protocol",       PT_DWORD,   (ULONG_PTR) gdwDefProtocol, aProtocols },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            PMYSOCKET pSocket;


            if (!(pSocket = MyAlloc (sizeof (MYSOCKET))))
            {
                break;
            }

            if ((pSocket->Sock = socket(
                    (int) params[0].dwValue,
                    (int) params[1].dwValue,
                    (int) params[2].dwValue

                    )) != INVALID_SOCKET)
            {
                char        buf[128];
                LRESULT     index;


                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);

                pSocket->dwAddressFamily = (DWORD) params[0].dwValue;
                pSocket->dwSocketType = (DWORD) params[1].dwValue;

                wsprintf(
                    buf,
                    "Socket=x%x (%s %s)",
                    pSocket->Sock,
                    GetStringFromOrdinalValue(
                        pSocket->dwAddressFamily,
                        aAddressFamilies
                        ),
                    GetStringFromOrdinalValue(
                        pSocket->dwSocketType,
                        aSocketTypes
                        )
                    );

                index = SendMessage(
                    ghwndList1,
                    LB_ADDSTRING,
                    0,
                    (LPARAM) buf
                    );

                SendMessage(
                    ghwndList1,
                    LB_SETITEMDATA,
                    index,
                    (LPARAM) pSocket
                    );
            }
            else
            {
                ShowError (funcIndex, 0);
                MyFree (pSocket);
            }
        }

        break;
    }
    case ws_WSAAccept:
    {
        int iAddrLen = dwBigBufSize;
        FUNC_PARAM params[] =
        {
            { gszSocket,            PT_DWORD,       (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "lpAddr",             PT_PTRNOEDIT,   (ULONG_PTR) pBigBuf, pBigBuf },
            { "lpiAddrLen",         PT_DWORD,       (ULONG_PTR) &iAddrLen, &iAddrLen },
            { "lpfnCondition",      PT_DWORD,       (ULONG_PTR) ConditionProc, ConditionProc },
            { "dwCallbackData",     PT_DWORD,       (ULONG_PTR) 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            SOCKET s;


            if ((s = WSAAccept(
                    (SOCKET) params[0].dwValue,
                    (struct sockaddr FAR *) params[1].dwValue,
                    (LPINT) params[2].dwValue,
                    (LPCONDITIONPROC) params[3].dwValue,
                    params[4].dwValue

                    )) != INVALID_SOCKET)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr ("  returned socket=x%x", s);

                if (params[1].dwValue  &&
                    params[2].dwValue  &&
                    *((LPINT) params[2].dwValue))
                {
                    struct sockaddr FAR *pSockAddr = (struct sockaddr FAR *)
                                            params[1].dwValue;


                    ShowStr(
                        "  lpAddr->AddressFamily=%d, %s",
                        (DWORD) pSockAddr->sa_family,
                        GetStringFromOrdinalValue(
                            (DWORD) pSockAddr->sa_family,
                            aAddressFamilies
                            )
                        );

                    ShowStr (  "lpAddr->sa_data=");
                    ShowBytes(
                        *((LPINT) params[2].dwValue) - sizeof (u_short),
                        pSockAddr->sa_data,
                        1
                        );
                }
            }
            else
            {
                 ShowError (funcIndex, 0);
            }
        }

        break;
    }
    case ws_WSAAddressToStringA:
    case ws_WSAAddressToStringW:
    {
        DWORD   dwAddrStrLen = dwBigBufSize;
        LPSTR   pszAddrStr = MyAlloc (dwBigBufSize);
        LPWSAPROTOCOL_INFOA pProtoInfo = (funcIndex == ws_WSAAddressToStringA ?
                                &gWSAProtocolInfoA :
                                (LPWSAPROTOCOL_INFOA) &gWSAProtocolInfoW);
        FUNC_PARAM params[] =
        {
            { "lpsaAddress",    PT_PTRNOEDIT,       (ULONG_PTR) pBigBuf, pBigBuf },
            { "  ->sa_family",  PT_ORDINAL,         (ULONG_PTR) gdwDefAddrFamily, aAddressFamilies },
            { "  ->sa_data",    PT_POINTER,         (ULONG_PTR) (pBigBuf + 2), pBigBuf + 2},
            { "dwAddressLength", PT_DWORD,          (ULONG_PTR) dwBigBufSize, NULL },
            { "lpProtocolInfo", PT_WSAPROTOCOLINFO, (ULONG_PTR) pProtoInfo, pProtoInfo },
            { "lpszAddressString", PT_POINTER,      (ULONG_PTR) pszAddrStr, pszAddrStr },
            { "lpdwAddressStringLength",PT_POINTER, (ULONG_PTR) &dwAddrStrLen, &dwAddrStrLen }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 7, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            LPSOCKADDR pSockAddr = (LPSOCKADDR) params[0].dwValue;

            if (!IsBadWritePtr (pSockAddr, sizeof (WORD)))
            {
                pSockAddr->sa_family = (short) params[1].dwValue;
            }

            if (funcIndex == ws_WSAAddressToStringA)
            {
                i = WSAAddressToStringA(
                    (LPSOCKADDR) params[0].dwValue,
                    (DWORD) params[3].dwValue,
                    (LPWSAPROTOCOL_INFOA) params[4].dwValue,
                    (LPSTR) params[5].dwValue,
                    (LPDWORD) params[6].dwValue
                    );
            }
            else
            {
                i = WSAAddressToStringW(
                    (LPSOCKADDR) params[0].dwValue,
                    (DWORD) params[3].dwValue,
                    (LPWSAPROTOCOL_INFOW) params[4].dwValue,
                    (LPWSTR) params[5].dwValue,
                    (LPDWORD) params[6].dwValue
                    );
            }

            if (i == 0)
            {
                DWORD dwLength = *((LPDWORD) params[6].dwValue);


                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr ("  *lpdwAddressStringLength=x%x", dwLength);

                ShowStr ("  *lpszAddressString=");
                ShowBytes(
                    (funcIndex == ws_WSAAddressToStringA ?
                        dwLength : dwLength * sizeof(WCHAR)),
                    (LPVOID) params[5].dwValue,
                    1
                    );
            }
            else if (i == SOCKET_ERROR)
            {
                 ShowError (funcIndex, 0);
            }
            else
            {
                 ShowUnknownError (funcIndex, i);
            }
        }

        break;
    }
    case ws_WSAAsyncGetHostByAddr:
    {
        PASYNC_REQUEST_INFO pAsyncReqInfo;


        if ((pAsyncReqInfo = MyAlloc(
                sizeof (ASYNC_REQUEST_INFO) + dwBigBufSize
                )))
        {
            char szHostAddr[MAX_STRING_PARAM_SIZE] = "1.2.3.4";
            FUNC_PARAM params[] =
            {
                { "hwnd",   PT_DWORD,       (ULONG_PTR) ghwndMain, NULL },
                { "wMsg",   PT_DWORD,       (ULONG_PTR) WM_ASYNCREQUESTCOMPLETED, NULL },
                { "addr",   PT_POINTER,     (ULONG_PTR) pBigBuf, pBigBuf },
                { "len",    PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
                { "type",   PT_ORDINAL,     (ULONG_PTR) gdwDefAddrFamily, aAddressFamilies },
                { "buf",    PT_PTRNOEDIT,   (ULONG_PTR) (pAsyncReqInfo+1), pAsyncReqInfo + 1 },
                { "buflen", PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            };
            FUNC_PARAM_HEADER paramsHeader =
                { 7, funcIndex, params, NULL };


            if (LetUserMungeParams (&paramsHeader))
            {
                if ((pAsyncReqInfo->hRequest = WSAAsyncGetHostByAddr(
                        (HWND) params[0].dwValue,
                        (unsigned int) params[1].dwValue,
                        (char FAR *) params[2].dwValue,
                        (int) params[3].dwValue,
                        (int) params[4].dwValue,
                        (char FAR *) params[5].dwValue,
                        (int) params[6].dwValue
                        )))
                {
                    ShowStr(
                        "%s returned hRequest=x%x",
                        aFuncNames[funcIndex],
                        pAsyncReqInfo->hRequest
                        );

                    pAsyncReqInfo->pszFuncName = aFuncNames[funcIndex];
                    pAsyncReqInfo->FuncIndex = funcIndex;
                    QueueAsyncRequestInfo (pAsyncReqInfo);
                    break;
                }
                else
                {
                    ShowError (funcIndex, 0);
                }
            }

            MyFree (pAsyncReqInfo);
        }

        break;
    }
    case ws_WSAAsyncGetHostByName:
    {
        PASYNC_REQUEST_INFO pAsyncReqInfo;


        if ((pAsyncReqInfo = MyAlloc(
                sizeof (ASYNC_REQUEST_INFO) + dwBigBufSize
                )))
        {
            char szHostName[MAX_STRING_PARAM_SIZE];
            FUNC_PARAM params[] =
            {
                { "hwnd",   PT_DWORD,       (ULONG_PTR) ghwndMain, NULL },
                { "wMsg",   PT_DWORD,       (ULONG_PTR) WM_ASYNCREQUESTCOMPLETED, NULL },
                { "name",   PT_STRING,      (ULONG_PTR) szHostName, szHostName },
                { "buf",    PT_PTRNOEDIT,   (ULONG_PTR) (pAsyncReqInfo+1), pAsyncReqInfo + 1 },
                { "buflen", PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            };
            FUNC_PARAM_HEADER paramsHeader =
                { 5, funcIndex, params, NULL };


            lstrcpyA (szHostName, gszDefHostName);

            if (LetUserMungeParams (&paramsHeader))
            {
                if ((pAsyncReqInfo->hRequest = WSAAsyncGetHostByName(
                        (HWND) params[0].dwValue,
                        (unsigned int) params[1].dwValue,
                        (char FAR *) params[2].dwValue,
                        (char FAR *) params[3].dwValue,
                        (int) params[4].dwValue
                        )))
                {
                    ShowStr(
                        "%s returned hRequest=x%x",
                        aFuncNames[funcIndex],
                        pAsyncReqInfo->hRequest
                        );

                    pAsyncReqInfo->pszFuncName = aFuncNames[funcIndex];
                    pAsyncReqInfo->FuncIndex = funcIndex;
                    QueueAsyncRequestInfo (pAsyncReqInfo);
                    break;
                }
                else
                {
                    ShowError (funcIndex, 0);
                }
            }

            MyFree (pAsyncReqInfo);
        }

        break;
    }
    case ws_WSAAsyncGetProtoByName:
    {
        PASYNC_REQUEST_INFO pAsyncReqInfo;


        if ((pAsyncReqInfo = MyAlloc(
                sizeof (ASYNC_REQUEST_INFO) + dwBigBufSize
                )))
        {
            char szProtoName[MAX_STRING_PARAM_SIZE];
            FUNC_PARAM params[] =
            {
                { "hwnd",   PT_DWORD,       (ULONG_PTR) ghwndMain, NULL },
                { "wMsg",   PT_DWORD,       (ULONG_PTR) WM_ASYNCREQUESTCOMPLETED, NULL },
                { "name",   PT_STRING,      (ULONG_PTR) szProtoName, szProtoName },
                { "buf",    PT_PTRNOEDIT,   (ULONG_PTR) (pAsyncReqInfo+1), pAsyncReqInfo + 1 },
                { "buflen", PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            };
            FUNC_PARAM_HEADER paramsHeader =
                { 5, funcIndex, params, NULL };


            lstrcpyA (szProtoName, gszDefProtoName);

            if (LetUserMungeParams (&paramsHeader))
            {
                if ((pAsyncReqInfo->hRequest = WSAAsyncGetProtoByName(
                        (HWND) params[0].dwValue,
                        (unsigned int) params[1].dwValue,
                        (char FAR *) params[2].dwValue,
                        (char FAR *) params[3].dwValue,
                        (int) params[4].dwValue
                        )))
                {
                    ShowStr(
                        "%s returned hRequest=x%x",
                        aFuncNames[funcIndex],
                        pAsyncReqInfo->hRequest
                        );

                    pAsyncReqInfo->pszFuncName = aFuncNames[funcIndex];
                    pAsyncReqInfo->FuncIndex = funcIndex;
                    QueueAsyncRequestInfo (pAsyncReqInfo);
                    break;
                }
                else
                {
                    ShowError (funcIndex, 0);
                }
            }

            MyFree (pAsyncReqInfo);
        }

        break;
    }
    case ws_WSAAsyncGetProtoByNumber:
    {
        PASYNC_REQUEST_INFO pAsyncReqInfo;


        if ((pAsyncReqInfo = MyAlloc(
                sizeof (ASYNC_REQUEST_INFO) + dwBigBufSize
                )))
        {
            FUNC_PARAM params[] =
            {
                { "hwnd",   PT_DWORD,       (ULONG_PTR) ghwndMain, NULL },
                { "wMsg",   PT_DWORD,       (ULONG_PTR) WM_ASYNCREQUESTCOMPLETED, NULL },
                { "number", PT_DWORD,       (ULONG_PTR) gdwDefProtoNum, NULL },
                { "buf",    PT_PTRNOEDIT,   (ULONG_PTR) (pAsyncReqInfo+1), pAsyncReqInfo + 1 },
                { "buflen", PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            };
            FUNC_PARAM_HEADER paramsHeader =
                { 5, funcIndex, params, NULL };


            if (LetUserMungeParams (&paramsHeader))
            {
                if ((pAsyncReqInfo->hRequest = WSAAsyncGetProtoByNumber(
                        (HWND) params[0].dwValue,
                        (unsigned int) params[1].dwValue,
                        (int) params[2].dwValue,
                        (char FAR *) params[3].dwValue,
                        (int) params[4].dwValue
                        )))
                {
                    ShowStr(
                        "%s returned hRequest=x%x",
                        aFuncNames[funcIndex],
                        pAsyncReqInfo->hRequest
                        );

                    pAsyncReqInfo->pszFuncName = aFuncNames[funcIndex];
                    pAsyncReqInfo->FuncIndex = funcIndex;
                    QueueAsyncRequestInfo (pAsyncReqInfo);
                    break;
                }
                else
                {
                    ShowError (funcIndex, 0);
                }
            }

            MyFree (pAsyncReqInfo);
        }

        break;
    }
    case ws_WSAAsyncGetServByName:
    {
        PASYNC_REQUEST_INFO pAsyncReqInfo;


        if ((pAsyncReqInfo = MyAlloc(
                sizeof (ASYNC_REQUEST_INFO) + dwBigBufSize
                )))
        {
            char szServName[MAX_STRING_PARAM_SIZE];
            char szProtoName[MAX_STRING_PARAM_SIZE];
            FUNC_PARAM params[] =
            {
                { "hwnd",   PT_DWORD,       (ULONG_PTR) ghwndMain, NULL },
                { "wMsg",   PT_DWORD,       (ULONG_PTR) WM_ASYNCREQUESTCOMPLETED, NULL },
                { "name",   PT_STRING,      (ULONG_PTR) szServName, szServName },
                { "proto",  PT_STRING,      (ULONG_PTR) 0, szProtoName },
                { "buf",    PT_PTRNOEDIT,   (ULONG_PTR) (pAsyncReqInfo+1), pAsyncReqInfo + 1 },
                { "buflen", PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            };
            FUNC_PARAM_HEADER paramsHeader =
                { 6, funcIndex, params, NULL };


            lstrcpyA (szServName, gszDefServName);
            lstrcpyA (szProtoName, gszDefProtoName);

            if (LetUserMungeParams (&paramsHeader))
            {
                if ((pAsyncReqInfo->hRequest = WSAAsyncGetServByName(
                        (HWND) params[0].dwValue,
                        (unsigned int) params[1].dwValue,
                        (char FAR *) params[2].dwValue,
                        (char FAR *) params[3].dwValue,
                        (char FAR *) params[4].dwValue,
                        (int) params[5].dwValue
                        )))
                {
                    ShowStr(
                        "%s returned hRequest=x%x",
                        aFuncNames[funcIndex],
                        pAsyncReqInfo->hRequest
                        );

                    pAsyncReqInfo->pszFuncName = aFuncNames[funcIndex];
                    pAsyncReqInfo->FuncIndex = funcIndex;
                    QueueAsyncRequestInfo (pAsyncReqInfo);
                    break;
                }
                else
                {
                    ShowError (funcIndex, 0);
                }
            }

            MyFree (pAsyncReqInfo);
        }

        break;
    }
    case ws_WSAAsyncGetServByPort:
    {
        PASYNC_REQUEST_INFO pAsyncReqInfo;


        if ((pAsyncReqInfo = MyAlloc(
                sizeof (ASYNC_REQUEST_INFO) + dwBigBufSize
                )))
        {
            char szProtoName[MAX_STRING_PARAM_SIZE];
            FUNC_PARAM params[] =
            {
                { "hwnd",   PT_DWORD,       (ULONG_PTR) ghwndMain, NULL },
                { "wMsg",   PT_DWORD,       (ULONG_PTR) WM_ASYNCREQUESTCOMPLETED, NULL },
                { "port",   PT_DWORD,       (ULONG_PTR) gdwDefPortNum, NULL },
                { "proto",  PT_STRING,      (ULONG_PTR) 0, szProtoName },
                { "buf",    PT_PTRNOEDIT,   (ULONG_PTR) (pAsyncReqInfo+1), pAsyncReqInfo + 1 },
                { "buflen", PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            };
            FUNC_PARAM_HEADER paramsHeader =
                { 6, funcIndex, params, NULL };


            lstrcpyA (szProtoName, gszDefProtoName);

            if (LetUserMungeParams (&paramsHeader))
            {
                if ((pAsyncReqInfo->hRequest = WSAAsyncGetServByPort(
                        (HWND) params[0].dwValue,
                        (unsigned int) params[1].dwValue,
                        (int) params[2].dwValue,
                        (char FAR *) params[3].dwValue,
                        (char FAR *) params[4].dwValue,
                        (int) params[5].dwValue
                        )))
                {
                    ShowStr(
                        "%s returned hRequest=x%x",
                        aFuncNames[funcIndex],
                        pAsyncReqInfo->hRequest
                        );

                    pAsyncReqInfo->pszFuncName = aFuncNames[funcIndex];
                    pAsyncReqInfo->FuncIndex = funcIndex;
                    QueueAsyncRequestInfo (pAsyncReqInfo);
                    break;
                }
                else
                {
                    ShowError (funcIndex, 0);
                }
            }

            MyFree (pAsyncReqInfo);
        }

        break;
    }
    case ws_WSAAsyncSelect:
    {
        FUNC_PARAM params[] =
        {
            { gszSocket,    PT_DWORD,   (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "hwnd",       PT_DWORD,   (ULONG_PTR) ghwndMain, ghwndMain },
            { "msg",        PT_DWORD,   (ULONG_PTR) WM_NETWORKEVENT, NULL },
            { "lEvent",     PT_FLAGS,   (ULONG_PTR) 0, aNetworkEvents }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if ((i = WSAAsyncSelect(
                    (SOCKET) params[0].dwValue,
                    (HWND) params[1].dwValue,
                    (unsigned int) params[2].dwValue,
                    (long) params[3].dwValue

                    )) == 0)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
            }
            else if (i == SOCKET_ERROR)
            {
                 ShowError (funcIndex, 0);
            }
            else
            {
                 ShowUnknownError (funcIndex, i);
            }
        }

        break;
    }
    case ws_WSACancelAsyncRequest:
    {
        FUNC_PARAM params[] =
        {
            { "hRequest",   PT_DWORD,   (ULONG_PTR) (gpAsyncReqInfoList ? gpAsyncReqInfoList->hRequest : NULL), NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if ((i = WSACancelAsyncRequest ((HANDLE) params[0].dwValue)) == 0)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
            }
            else if (i == SOCKET_ERROR)
            {
                 ShowError (funcIndex, 0);
            }
            else
            {
                 ShowUnknownError (funcIndex, i);
            }
        }

        break;
    }
//    case ws_WSACancelBlockingCall: not implemented in ws 2
//
//        break;

    case ws_WSACleanup:
    {
        FUNC_PARAM_HEADER paramsHeader =
            { 0, funcIndex, NULL, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if (WSACleanup() == 0)
            {
                char szButtonText[32];


                wsprintf (szButtonText, "Startup (%d)", --giCurrNumStartups);
                SetDlgItemText (ghwndMain, IDC_BUTTON1, szButtonText);

                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);

                if (giCurrNumStartups == 0)
                {
                    int iNumItems;


                    iNumItems = (int) SendMessage(
                        ghwndList1,
                        LB_GETCOUNT,
                        0,
                        0
                        );

                    for (i = 0; i < iNumItems; i++)
                    {
                        PMYSOCKET pSocket;


                        pSocket = (PMYSOCKET) SendMessage(
                            ghwndList1,
                            LB_GETITEMDATA,
                            0,
                            0
                            );

                        SendMessage (ghwndList1, LB_DELETESTRING, 0, 0);

                        closesocket (pSocket->Sock);

                        MyFree (pSocket);
                    }
                }
            }
            else
            {
                ShowError (funcIndex, 0);
            }
        }

        break;
    }
    case ws_WSACloseEvent:
    {
        FUNC_PARAM params[] =
        {
            { "hEvent",   PT_DWORD,   (ULONG_PTR) ghSelectedEvent, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if (WSACloseEvent ((WSAEVENT) params[0].dwValue) == TRUE)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);

                if ((WSAEVENT) params[0].dwValue != ghSelectedEvent)
                {
                    //
                    // The user overrode the selected widget, so make sure
                    // we don't delete the wrong string from the list box
                    //

                    int         iNumItems;
                    WSAEVENT    hEvent;


                    iNumItems = (int) SendMessage(
                        ghwndList3,
                        LB_GETCOUNT,
                        0,
                        0
                        );

                    for (i = 0; i < iNumItems; i++)
                    {
                        hEvent = (WSAEVENT) SendMessage(
                            ghwndList3,
                            LB_GETITEMDATA,
                            i,
                            0
                            );

                        if ((WSAEVENT) params[0].dwValue == hEvent)
                        {
                            giSelectedEventIndex = (int) i;
                            break;
                        }
                    }

                    if (i == iNumItems)
                    {
                        ShowStr(
                            "Strange, couldn't find that hEvent=x%x in list",
                            params[0].dwValue
                            );

                        break;
                    }
                }

                SendMessage(
                    ghwndList3,
                    LB_DELETESTRING,
                    (WPARAM) giSelectedEventIndex,
                    0
                    );
            }
            else
            {
                 ShowError (funcIndex, 0);
            }
        }

        break;
    }
    case ws_WSAConnect:
    {
        LPBYTE      pBuf = MyAlloc (5 * dwBigBufSize + 2 * sizeof (QOS));
        LPSOCKADDR  pSA = (LPSOCKADDR) pBuf;
        LPBYTE      pCallerBuf = pBuf + dwBigBufSize,
                    pCalleeBuf = pBuf + 2 * dwBigBufSize;
        LPQOS       pSQOS = (LPQOS) (pBuf + 3 * dwBigBufSize),
                    pGQOS = (LPQOS) (pBuf + 4 * dwBigBufSize + sizeof (QOS));
        WSABUF      callerData, calleeData;
        FUNC_PARAM params[] =
        {
            { gszSocket,        PT_DWORD,       (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "name",           PT_PTRNOEDIT,   (ULONG_PTR) pSA, pSA },
            { "  ->sa_family",  PT_ORDINAL,     (ULONG_PTR) gdwDefAddrFamily, aAddressFamilies },
            { "  ->sa_data",    PT_POINTER,     (ULONG_PTR) &pSA->sa_data, &pSA->sa_data },
            { "namelen",        PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            { "lpCallerData",   PT_PTRNOEDIT,   (ULONG_PTR) &callerData, &callerData },
            { "  ->len",        PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            { "  ->buf",        PT_POINTER,     (ULONG_PTR) pCallerBuf, pCallerBuf },
            { "lpCalleeData",   PT_PTRNOEDIT,   (ULONG_PTR) &calleeData, &calleeData },
            { "  ->len",        PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            { "  ->buf",        PT_POINTER,     (ULONG_PTR) pCalleeBuf, pCalleeBuf },
            { "lpSQOS",         PT_QOS,         (ULONG_PTR) pSQOS, pSQOS },
            { "lpGQOS",         PT_QOS,         (ULONG_PTR) pGQOS, pGQOS },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 13, funcIndex, params, NULL };


        if (!pBuf)
        {
            break;
        }

        ZeroMemory (pSQOS, sizeof (QOS));
        pSQOS->ProviderSpecific.len = dwBigBufSize;

        ZeroMemory (pGQOS, sizeof (QOS));
        pGQOS->ProviderSpecific.len = dwBigBufSize;

        if (LetUserMungeParams (&paramsHeader))
        {
            pSA->sa_family = (u_short) LOWORD(params[2].dwValue);
            callerData.len = (DWORD) params[6].dwValue;
            calleeData.len = (DWORD) params[9].dwValue;

            if ((i = WSAConnect(
                (SOCKET) params[0].dwValue,
                (LPSOCKADDR) params[1].dwValue,
                (int) params[4].dwValue,
                (LPWSABUF) params[5].dwValue,
                (LPWSABUF) params[8].dwValue,
                (LPQOS) params[11].dwValue,
                (LPQOS) params[12].dwValue

                )) == 0)
            {
                LPWSABUF pCalleeData = (LPWSABUF) params[8].dwValue;


                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr ("  lpCalleeData->len=x%x", pCalleeData->len);

                if (pCalleeData->len)
                {
                    ShowStr ("  lpCalleeData->buf=x%x", pCalleeData->buf);
                    ShowBytes (pCalleeData->len, pCalleeData->buf, 2);
                }
            }
            else if (i == SOCKET_ERROR)
            {
                ShowError (funcIndex, 0);
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }

        }

        MyFree (pBuf);

        break;
    }
    case ws_WSACreateEvent:
    {
        FUNC_PARAM_HEADER paramsHeader =
            { 0, funcIndex, NULL, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            WSAEVENT    wsaEvent;

            if ((wsaEvent = WSACreateEvent ()) != WSA_INVALID_EVENT)
            {
                char    buf[20];
                LRESULT index;


                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr ("  wsaEvent=x%x", wsaEvent);

                wsprintf (buf, "hEvent=x%x", wsaEvent);

                index = SendMessage(
                    ghwndList3,
                    LB_ADDSTRING,
                    0,
                    (LPARAM) buf
                    );

                SendMessage(
                    ghwndList3,
                    LB_SETITEMDATA,
                    (WPARAM) index,
                    (LPARAM) wsaEvent
                    );
            }
            else
            {
                 ShowError (funcIndex, 0);
            }
        }

        break;
    }
    case ws_WSADuplicateSocketA:
    case ws_WSADuplicateSocketW:
    {
        LPWSAPROTOCOL_INFOA pProtoInfo = (gbWideStringParams ?
                                &gWSAProtocolInfoA :
                                (LPWSAPROTOCOL_INFOA) &gWSAProtocolInfoW);
        FUNC_PARAM params[] =
        {
            { gszSocket,        PT_DWORD,       (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "hTargetProcess", PT_DWORD,       (ULONG_PTR) 0, NULL },
            { "lpProtocolInfo", PT_PTRNOEDIT,   (ULONG_PTR) pProtoInfo, pProtoInfo}
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if (gbWideStringParams)
            {
                i = WSADuplicateSocketW(
                    (SOCKET) params[0].dwValue,
                    (DWORD) params[1].dwValue,
                    (LPWSAPROTOCOL_INFOW) params[2].dwValue
                    );
            }
            else
            {
                i = WSADuplicateSocketA(
                    (SOCKET) params[0].dwValue,
                    (DWORD) params[1].dwValue,
                    (LPWSAPROTOCOL_INFOA) params[2].dwValue
                    );
            }

            if (i == 0)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr ("  lpProtocolInfo=x%x", params[2].dwValue);
                ShowProtoInfo(
                    (LPWSAPROTOCOL_INFOA) params[2].dwValue,
                    0xffffffff,
                    !gbWideStringParams
                    );
            }
            else if (i == SOCKET_ERROR)
            {
                ShowError (funcIndex, 0);
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }
        }

        break;
    }
    case ws_WSAEnumNameSpaceProvidersA:
    case ws_WSAEnumNameSpaceProvidersW:
    {
        DWORD dwSize = dwBigBufSize;
        FUNC_PARAM params[] =
        {
            { "lpdwBufferLength",   PT_POINTER,     (ULONG_PTR) &dwSize, &dwSize },
            { "lpNSPBuffer",        PT_PTRNOEDIT,   (ULONG_PTR) pBigBuf, pBigBuf }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if (funcIndex == ws_WSAEnumNameSpaceProvidersA)
            {
                i = WSAEnumNameSpaceProvidersA(
                    (LPDWORD) params[0].dwValue,
                    (LPWSANAMESPACE_INFOA) params[1].dwValue
                    );
            }
            else
            {
                i = WSAEnumNameSpaceProvidersW(
                    (LPDWORD) params[0].dwValue,
                    (LPWSANAMESPACE_INFOW) params[1].dwValue
                    );
            }

            if (i != SOCKET_ERROR)
            {
                LPWSANAMESPACE_INFOA    pInfo = (LPWSANAMESPACE_INFOA)
                                            params[1].dwValue;


                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);

                ShowStr(
                    "  *lpdwBufferLength=x%x",
                    *((LPDWORD) params[0].dwValue)
                    );

                for (j = 0; j < i; j++, pInfo++)
                {
                    char szNSInfoN[16];


                    wsprintf (szNSInfoN, "  nsInfo[%d].", j);

                    ShowStr ("%sNSProviderId=", szNSInfoN);
                    ShowStr(
                        "    %x %x %x %02x%02x%02x%02x%02x%02x%02x%02x",
                        pInfo->NSProviderId.Data1,
                        pInfo->NSProviderId.Data2,
                        pInfo->NSProviderId.Data3,
                        (DWORD) pInfo->NSProviderId.Data4[0],
                        (DWORD) pInfo->NSProviderId.Data4[1],
                        (DWORD) pInfo->NSProviderId.Data4[2],
                        (DWORD) pInfo->NSProviderId.Data4[3],
                        (DWORD) pInfo->NSProviderId.Data4[4],
                        (DWORD) pInfo->NSProviderId.Data4[5],
                        (DWORD) pInfo->NSProviderId.Data4[6],
                        (DWORD) pInfo->NSProviderId.Data4[7]
                        );

                    ShowStr(
                        "%sdwNameSpace=%d, %s",
                        szNSInfoN,
                        pInfo->dwNameSpace,
                        GetStringFromOrdinalValue(
                            pInfo->dwNameSpace,
                            aNameSpaces
                            )
                        );

                    ShowStr(
                        "%sfActive=%s",
                        szNSInfoN,
                        (pInfo->fActive ? "TRUE" : "FALSE")
                        );

                    ShowStr ("%sdwVersion=x%x", szNSInfoN, pInfo->dwVersion);

                    ShowStr(
                        (funcIndex == ws_WSAEnumNameSpaceProvidersA ?
                            "%slpszIdentifier=%s" : "%slpszIdentifier=%ws"),
                        szNSInfoN,
                        pInfo->lpszIdentifier
                        );
                }
            }
            else
            {
                 ShowError (funcIndex, 0);

                 if (WSAGetLastError() == WSAEFAULT)
                 {
                    ShowStr(
                        "  *lpdwBufferLength=x%x",
                        *((LPDWORD) params[0].dwValue)
                        );
                 }
            }
        }

        break;
    }
    case ws_WSAEnumNetworkEvents:
    {
        WSANETWORKEVENTS netEvents;
        FUNC_PARAM params[] =
        {
            { gszSocket,            PT_DWORD,       (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "hEvent",             PT_DWORD,       (ULONG_PTR) ghSelectedEvent, NULL },
            { "lpNetworkEvents",    PT_PTRNOEDIT,   (ULONG_PTR) &netEvents, &netEvents }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if ((i = WSAEnumNetworkEvents(
                    (SOCKET) params[0].dwValue,
                    (WSAEVENT) params[1].dwValue,
                    (LPWSANETWORKEVENTS) params[2].dwValue

                    )) == 0)
            {
                LPWSANETWORKEVENTS  pNetEvents = (LPWSANETWORKEVENTS)
                                        params[2].dwValue;

                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr ("  lpNetworkEvents=x%x", pNetEvents);
                ShowStr(
                    "    ->lNetworkEvents=x%x",
                    pNetEvents->lNetworkEvents
                    );

                ShowStr(
                    "    ->iErrorCode[READ]=x%x",
                    pNetEvents->iErrorCode[FD_READ_BIT]
                    );

                ShowStr(
                    "    ->iErrorCode[WRITE]=x%x",
                    pNetEvents->iErrorCode[FD_WRITE_BIT]
                    );

                ShowStr(
                    "    ->iErrorCode[OOB]=x%x",
                    pNetEvents->iErrorCode[FD_OOB_BIT]
                    );

                ShowStr(
                    "    ->iErrorCode[ACCEPT]=x%x",
                    pNetEvents->iErrorCode[FD_ACCEPT_BIT]
                    );

                ShowStr(
                    "    ->iErrorCode[CONNECT]=x%x",
                    pNetEvents->iErrorCode[FD_CONNECT_BIT]
                    );

                ShowStr(
                    "    ->iErrorCode[CLOSE]=x%x",
                    pNetEvents->iErrorCode[FD_CLOSE_BIT]
                    );

                ShowStr(
                    "    ->iErrorCode[QOS]=x%x",
                    pNetEvents->iErrorCode[FD_QOS_BIT]
                    );

                ShowStr(
                    "    ->iErrorCode[GROUP_QOS]=x%x",
                    pNetEvents->iErrorCode[FD_GROUP_QOS_BIT]
                    );

            }
            else if (i == SOCKET_ERROR)
            {
                ShowError (funcIndex, 0);
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }
        }

        break;
    }
    case ws_WSAEnumProtocolsA:
    case ws_WSAEnumProtocolsW:
    {
        int aProtocols[32];
        DWORD dwSize = dwBigBufSize;
        FUNC_PARAM params[] =
        {
            { "lpiProtocols",       PT_POINTER,     (ULONG_PTR) NULL, aProtocols },
            { "lpProtocolBuffer",   PT_PTRNOEDIT,   (ULONG_PTR) pBigBuf, pBigBuf },
            { "lpdwBufferLength",   PT_POINTER,     (ULONG_PTR) &dwSize, &dwSize }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if (funcIndex == ws_WSAEnumProtocolsA)
            {
                i = WSAEnumProtocolsA(
                    (LPINT) params[0].dwValue,
                    (LPWSAPROTOCOL_INFOA) params[1].dwValue,
                    (LPDWORD) params[2].dwValue
                    );
            }
            else
            {
                i = WSAEnumProtocolsW(
                    (LPINT) params[0].dwValue,
                    (LPWSAPROTOCOL_INFOW) params[1].dwValue,
                    (LPDWORD) params[2].dwValue
                    );
            }

            if (i != SOCKET_ERROR)
            {
                LPWSAPROTOCOL_INFOA pInfo = (LPWSAPROTOCOL_INFOA)
                                        params[1].dwValue;


                UpdateResults (TRUE);

                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);

                ShowStr ("%s SUCCESS (result=%d)", aFuncNames[funcIndex], i);

                ShowStr(
                    "  *lpdwBufferLength=x%x",
                    *((LPDWORD) params[2].dwValue)
                    );

                for (j = 0; j < i; j++)
                {
                    if (funcIndex == ws_WSAEnumProtocolsA)
                    {
                        ShowProtoInfo (pInfo, j, TRUE);

                        pInfo++;
                    }
                    else
                    {
                        ShowProtoInfo (pInfo, j, FALSE);

                        pInfo = (LPWSAPROTOCOL_INFOA)
                            (((LPBYTE) pInfo) + sizeof (WSAPROTOCOL_INFOW));

                    }
                }

                UpdateResults (FALSE);
            }
            else
            {
                 if (ShowError (funcIndex, 0) == WSAENOBUFS)
                 {
                     dwSize = *((LPDWORD) params[2].dwValue);

                     ShowStr ("  *lpdwBufferLength=%d (x%lx)", dwSize, dwSize);
                 }
            }
        }

        break;
    }
    case ws_WSAEventSelect:
    {
        WSAPROTOCOL_INFOW   info;
        FUNC_PARAM params[] =
        {
            { gszSocket,        PT_DWORD,   (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "hEvent",         PT_DWORD,   (ULONG_PTR) ghSelectedEvent, NULL },
            { "lNetworkEvents", PT_FLAGS,   (ULONG_PTR) 0, aNetworkEvents }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if ((i = WSAEventSelect(
                    (SOCKET) params[0].dwValue,
                    (WSAEVENT) params[1].dwValue,
                    (long) params[2].dwValue

                    )) == 0)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
            }
            else if (i == SOCKET_ERROR)
            {
                ShowError (funcIndex, 0);
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }
        }

        break;
    }
    case ws_WSAGetLastError:
    {
        FUNC_PARAM_HEADER paramsHeader =
            { 0, funcIndex, NULL, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            WSAEVENT    wsaEvent;

            i = (DWORD) WSAGetLastError ();
            ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);

            ShowStr(
                "  LastError=%d, %s",
                i,
                GetStringFromOrdinalValue (i, aWSAErrors)
                );
        }

        break;
    }
    case ws_WSAGetOverlappedResult:
    {
        DWORD   cbTransfer = 0, dwFlags = 0;
        FUNC_PARAM params[] =
        {
            { gszSocket,        PT_DWORD,       (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "lpOverlapped",   PT_DWORD,       (ULONG_PTR) 0, NULL },
            { "lpcbTransfer",   PT_PTRNOEDIT,   (ULONG_PTR) &cbTransfer, &cbTransfer },
            { "fWait",          PT_DWORD,       (ULONG_PTR) 0, NULL },
            { "lpdwFlags",      PT_PTRNOEDIT,   (ULONG_PTR) &dwFlags, &dwFlags }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if (WSAGetOverlappedResult(
                    (SOCKET) params[0].dwValue,
                    (LPWSAOVERLAPPED)  params[1].dwValue,
                    (LPDWORD)  params[2].dwValue,
                    (BOOL)  params[3].dwValue,
                    (LPDWORD)  params[4].dwValue

                    ) == TRUE)
            {
                PMYOVERLAPPED pOverlapped = (PMYOVERLAPPED) params[1].dwValue;


                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr(
                    "  Overlapped %s completed",
                    aFuncNames[pOverlapped->FuncIndex]
                    );

                ShowStr(
                    "  *lpcbTransfer=x%x",
                    *((LPDWORD)  params[2].dwValue)
                    );

                ShowFlags(
                    *((LPDWORD)  params[4].dwValue),
                    "  *lpdwFlags=",
                    aWSASendAndRecvFlags
                    );

                switch (pOverlapped->FuncIndex)
                {
                case ws_WSAIoctl:

                    if (*((LPDWORD)  params[2].dwValue))
                    {
                        ShowStr ("  lpvOUTBuffer=x%x", (pOverlapped + 1));
                        ShowBytes(
                            *((LPDWORD)  params[2].dwValue),
                            (pOverlapped + 1),
                            2
                            );
                    }

                    break;

                case ws_WSARecv:
                case ws_WSARecvFrom:
                {
                    LPWSABUF    pWSABuf = (LPWSABUF) (pOverlapped + 1);


                    for (i = 0; i < (int) pOverlapped->dwFuncSpecific1; i++)
                    {
                        ShowStr ("  wsaBuf[0].buf=x%x", pWSABuf->buf);
                        ShowBytes (pWSABuf->len, pWSABuf->buf, 2);
                        pWSABuf++;
                    }

                    break;
                }
                }

                MyFree (pOverlapped);
            }
            else
            {
                ShowError (funcIndex, 0);
            }
        }

// MyFree (pOverlapped); as appropriate

        break;
    }
    case ws_WSAGetQOSByName:
    {
        LPQOS       pQOS = (LPQOS) pBigBuf;
        LPWSABUF    pQOSName = (LPWSABUF)
                        MyAlloc (dwBigBufSize + sizeof (WSABUF));
        FUNC_PARAM params[] =
        {
            { gszSocket,    PT_DWORD,       (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "lpQOSName",  PT_PTRNOEDIT,   (ULONG_PTR) pQOSName, pQOSName },
            { "  ->len",    PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            { "  ->buf",    PT_POINTER,     (ULONG_PTR) (pQOSName+1), (pQOSName+1) },
            { "lpQOS",      PT_PTRNOEDIT,   (ULONG_PTR) pQOS, pQOS }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, NULL };

        if (!pQOSName)
        {
            break;
        }

        if (LetUserMungeParams (&paramsHeader))
        {
            pQOSName->len = (u_long) params[2].dwValue;
            pQOSName->buf = (char FAR *) params[3].dwValue;

            if (WSAGetQOSByName(
                    (SOCKET) params[0].dwValue,
                    (LPWSABUF) params[1].dwValue,
                    (LPQOS) params[4].dwValue

                    ) == TRUE)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr ("  lpQOS=x%x", pQOS);

                ShowStr(
                    "    ->SendingFlowspec.TokenRate=x%x",
                    pQOS->SendingFlowspec.TokenRate
                    );
                ShowStr(
                    "    ->SendingFlowspec.TokenBucketSize=x%x",
                    pQOS->SendingFlowspec.TokenBucketSize
                    );
                ShowStr(
                    "    ->SendingFlowspec.PeakBandwidth=x%x",
                    pQOS->SendingFlowspec.PeakBandwidth
                    );
                ShowStr(
                    "    ->SendingFlowspec.Latency=x%x",
                    pQOS->SendingFlowspec.Latency
                    );
                ShowStr(
                    "    ->SendingFlowspec.DelayVariation=x%x",
                    pQOS->SendingFlowspec.DelayVariation
                    );
                ShowStr(
                    "    ->SendingFlowspec.ServiceType=%s (x%x)",
                    GetStringFromOrdinalValue(
                        (DWORD) pQOS->SendingFlowspec.ServiceType,
                        aQOSServiceTypes
                        ),
                    (DWORD) pQOS->SendingFlowspec.ServiceType
                    );
                ShowStr(
                    "    ->SendingFlowspec.MaxSduSize=x%x",
                    pQOS->SendingFlowspec.MaxSduSize
                    );
                ShowStr(
                    "    ->SendingFlowspec.MinimumPolicedSize=x%x",
                    pQOS->SendingFlowspec.MinimumPolicedSize
                    );

                ShowStr(
                    "    ->ReceivingFlowspec.TokenRate=x%x",
                    pQOS->ReceivingFlowspec.TokenRate
                    );
                ShowStr(
                    "    ->ReceivingFlowspec.TokenBucketSize=x%x",
                    pQOS->ReceivingFlowspec.TokenBucketSize
                    );
                ShowStr(
                    "    ->ReceivingFlowspec.PeakBandwidth=x%x",
                    pQOS->ReceivingFlowspec.PeakBandwidth
                    );
                ShowStr(
                    "    ->ReceivingFlowspec.Latency=x%x",
                    pQOS->ReceivingFlowspec.Latency
                    );
                ShowStr(
                    "    ->ReceivingFlowspec.DelayVariation=x%x",
                    pQOS->ReceivingFlowspec.DelayVariation
                    );
                ShowStr(
                    "    ->ReceivingFlowspec.ServiceType=%s (x%x)",
                    GetStringFromOrdinalValue(
                        (DWORD) pQOS->ReceivingFlowspec.ServiceType,
                        aQOSServiceTypes
                        ),
                    (DWORD) pQOS->SendingFlowspec.ServiceType
                    );
                ShowStr(
                    "    ->ReceivingFlowspec.MaxSduSize=x%x",
                    pQOS->ReceivingFlowspec.MaxSduSize
                    );
                ShowStr(
                    "    ->ReceivingFlowspec.MinimumPolicedSize=x%x",
                    pQOS->ReceivingFlowspec.MinimumPolicedSize
                    );

                ShowStr(
                    "    ->ProviderSpecific.len=x%x",
                    pQOS->ProviderSpecific.len
                    );

                if (pQOS->ProviderSpecific.len)
                {
                    ShowStr(
                        "    ->ProviderSpecific.buf=x%x",
                        pQOS->ProviderSpecific.buf
                        );

                    ShowBytes(
                        pQOS->ProviderSpecific.len,
                        pQOS->ProviderSpecific.buf,
                        3
                        );
                }
            }
            else
            {
                ShowError (funcIndex, 0);
            }
        }

        MyFree (pQOSName);

        break;
    }
    case ws_WSAGetServiceClassInfoA:
    case ws_WSAGetServiceClassInfoW:
    {
        DWORD   dwSize = dwBigBufSize;
        GUID    ProviderId, ServiceClassId;
        FUNC_PARAM params[] =
        {
            { "lpProviderId",       PT_POINTER,     (ULONG_PTR) &ProviderId, &ProviderId },
            { "lpServiceClassId",   PT_POINTER,     (ULONG_PTR) &ServiceClassId, &ServiceClassId },
            { "lpdwBufSize",        PT_POINTER,     (ULONG_PTR) &dwSize, &dwSize },
            { "lpServiceClassInfo", PT_PTRNOEDIT,   (ULONG_PTR) pBigBuf, pBigBuf }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if (funcIndex == ws_WSAGetServiceClassInfoA)
            {
                i = WSAGetServiceClassInfoA(
                    (LPGUID) params[0].dwValue,
                    (LPGUID) params[1].dwValue,
                    (LPDWORD) params[2].dwValue,
                    (LPWSASERVICECLASSINFOA) params[3].dwValue
                    );
            }
            else
            {
                i = WSAGetServiceClassInfoW(
                    (LPGUID) params[0].dwValue,
                    (LPGUID) params[1].dwValue,
                    (LPDWORD) params[2].dwValue,
                    (LPWSASERVICECLASSINFOW) params[3].dwValue
                    );
            }

            if (i == 0)
            {
                LPWSANSCLASSINFOA       pClassInfo;
                LPWSASERVICECLASSINFOA  pInfo = (LPWSASERVICECLASSINFOA)
                                            params[3].dwValue;


                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr ("  lpServiceClassInfo=x%x", pInfo);
                ShowStr(
                    "    ->lpServiceClassId=%x %x %x %02x%02x%02x%02x%02x%02x%02x%02x",
                    pInfo->lpServiceClassId->Data1,
                    pInfo->lpServiceClassId->Data2,
                    pInfo->lpServiceClassId->Data3,
                    (DWORD) pInfo->lpServiceClassId->Data4[0],
                    (DWORD) pInfo->lpServiceClassId->Data4[1],
                    (DWORD) pInfo->lpServiceClassId->Data4[2],
                    (DWORD) pInfo->lpServiceClassId->Data4[3],
                    (DWORD) pInfo->lpServiceClassId->Data4[4],
                    (DWORD) pInfo->lpServiceClassId->Data4[5],
                    (DWORD) pInfo->lpServiceClassId->Data4[6],
                    (DWORD) pInfo->lpServiceClassId->Data4[7]
                    );

                ShowStr(
                    (funcIndex == ws_WSAGetServiceClassInfoA ?
                        "    ->lpszServiceClassName=%s" :
                        "    ->lpszServiceClassName=%ws"),
                    pInfo->lpszServiceClassName
                    );

                ShowStr ("    ->dwCount=%d", pInfo->dwCount);

                pClassInfo = pInfo->lpClassInfos;

                for (i = 0; i < (int) pInfo->dwCount; i++, pClassInfo++)
                {
                    char szClassInfoN[32];


                    wsprintf (szClassInfoN, "    ->ClassInfos[%d].", i);

                    ShowStr(
                        (funcIndex == ws_WSAGetServiceClassInfoA ?
                            "%s.lpszName=%s" :
                            "%s.lpszName=%ws"),
                         szClassInfoN,
                         pClassInfo->lpszName
                         );

                    ShowStr(
                        "%sdwNameSpace=%d, %s",
                        szClassInfoN,
                        pClassInfo->dwNameSpace,
                        GetStringFromOrdinalValue(
                            pClassInfo->dwNameSpace,
                            aNameSpaces
                            )
                        );

                    ShowStr(
                        "%sdwValueType=%d",
                        szClassInfoN,
                        pClassInfo->dwValueType
                        ); // supposed to be flags?

                    ShowStr(
                        "%sdwValueSize=%d",
                        szClassInfoN,
                        pClassInfo->dwValueSize
                        );

                    ShowStr(
                        "%slpValue=x%x",
                        szClassInfoN,
                        pClassInfo->lpValue
                        );

                    ShowBytes(
                        pClassInfo->dwValueSize,
                        pClassInfo->lpValue,
                        3
                        );
                }
            }
            else if (i == SOCKET_ERROR)
            {
                ShowError (funcIndex, 0);
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }
        }

        break;
    }
    case ws_WSAGetServiceClassNameByClassIdA:
    case ws_WSAGetServiceClassNameByClassIdW:
    {
        DWORD   dwLength = dwBigBufSize;
        GUID    guid[2];
        FUNC_PARAM params[] =
        {
            { "lpServiceClassId",   PT_POINTER,     (ULONG_PTR) guid, guid },
            { "lpServiceClassName", PT_PTRNOEDIT,   (ULONG_PTR) pBigBuf, pBigBuf },
            { "lpdwBufferLength",   PT_POINTER,     (ULONG_PTR) &dwLength, &dwLength }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if (funcIndex == ws_WSAGetServiceClassNameByClassIdA)
            {
                i = WSAGetServiceClassNameByClassIdA(
                    (LPGUID) params[0].dwValue,
                    (LPSTR) params[1].dwValue,
                    (LPDWORD) params[2].dwValue
                    );
            }
            else
            {
                i = WSAGetServiceClassNameByClassIdW(
                    (LPGUID) params[0].dwValue,
                    (LPWSTR) params[1].dwValue,
                    (LPDWORD) params[2].dwValue
                    );
            }

            if (i == 0)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr(
                    "  *lpdwBufferLength=x%x",
                    *((LPDWORD) params[2].dwValue)
                    );
                if (funcIndex == ws_WSAGetServiceClassNameByClassIdA)
                {
                    ShowStr ("  *lpServiceClassName=%s", params[1].dwValue);
                }
                else
                {
                    ShowStr ("  *lpServiceClassName=%ws", params[1].dwValue);
                }
            }
            else if (i == SOCKET_ERROR)
            {
                ShowError (funcIndex, 0);
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }
        }

        break;
    }
    case ws_WSAHtonl:
    {
        u_long  ulNetLong;
        FUNC_PARAM params[] =
        {
            { gszSocket,    PT_DWORD,       (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "hostLong",   PT_DWORD,       (ULONG_PTR) 0, NULL },
            { "lpNetLong",  PT_PTRNOEDIT,   (ULONG_PTR) &ulNetLong, &ulNetLong }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if ((i = WSAHtonl(
                    (SOCKET) params[0].dwValue,
                    (u_long) params[1].dwValue,
                    (u_long *) params[2].dwValue

                    )) == 0)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr ("  hostLong=x%x", params[1].dwValue);
                ShowStr ("  *lpNetLong=x%x", *((u_long *) params[2].dwValue));
            }
            else if (i == SOCKET_ERROR)
            {
                ShowError (funcIndex, 0);
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }
        }

        break;
    }
    case ws_WSAHtons:
    {
        u_short usNetShort;
        FUNC_PARAM params[] =
        {
            { gszSocket,    PT_DWORD,       (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "hostShort",  PT_DWORD,       (ULONG_PTR) 0, NULL },
            { "lpNetShort", PT_PTRNOEDIT,   (ULONG_PTR) &usNetShort, &usNetShort }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if ((i = WSAHtons(
                    (SOCKET) params[0].dwValue,
                    (u_short) params[1].dwValue,
                    (u_short *) params[2].dwValue

                    )) == 0)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr ("  hostShort=x%x", (DWORD) LOWORD(params[1].dwValue));
                ShowStr(
                    "  *lpNetShort=x%x",
                    (DWORD) *((u_short *) params[2].dwValue)
                    );
            }
            else if (i == SOCKET_ERROR)
            {
                ShowError (funcIndex, 0);
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }
        }

        break;
    }
    case ws_WSAInstallServiceClassA:
    case ws_WSAInstallServiceClassW:

// case ws_WSAInstallServiceClassA:/W
        break;

    case ws_WSAIoctl:
    {
        DWORD           cbBytesRet = 0;
        PMYOVERLAPPED   pOverlapped = MyAlloc (sizeof (MYOVERLAPPED) + dwBigBufSize);
        FUNC_PARAM params[] =
        {
            { gszSocket,                PT_DWORD,       (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "dwIoControlCode",        PT_ORDINAL,     (ULONG_PTR) 0, aWSAIoctlCmds },
            { "lpvInBuffer",            PT_POINTER,     (ULONG_PTR) (pOverlapped+1), (pOverlapped+1) },
            { "cbInBuffer",             PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            { "lpvOutBuffer",           PT_PTRNOEDIT,   (ULONG_PTR) (pOverlapped+1), (pOverlapped+1) },
            { "cbOutBuffer",            PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            { "lpcbBytesReturned",      PT_PTRNOEDIT,   (ULONG_PTR) &cbBytesRet, &cbBytesRet },
            { "lpOverlapped",           PT_PTRNOEDIT,   (ULONG_PTR) 0, pOverlapped },
            { "  ->hEvent",             PT_DWORD,       (ULONG_PTR) ghSelectedEvent, NULL },
            { "lpfnCompletionProc",     PT_PTRNOEDIT,   (ULONG_PTR) 0, CompletionProc }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 10, funcIndex, params, NULL };


        if (!pOverlapped)
        {
            break;
        }

        if (LetUserMungeParams (&paramsHeader))
        {
            pOverlapped->WSAOverlapped.hEvent = (WSAEVENT) params[8].dwValue;
            pOverlapped->FuncIndex = funcIndex;
            pOverlapped->dwFuncSpecific1 = (DWORD) params[5].dwValue;

            if ((i = WSAIoctl(
                    (SOCKET) params[0].dwValue,
                    (DWORD) params[1].dwValue,
                    (LPVOID) params[2].dwValue,
                    (DWORD) params[3].dwValue,
                    (LPVOID) params[4].dwValue,
                    (DWORD) params[5].dwValue,
                    (LPDWORD) params[6].dwValue,
                    (LPWSAOVERLAPPED) params[7].dwValue,
                    (LPWSAOVERLAPPED_COMPLETION_ROUTINE) params[9].dwValue

                    )) == 0)
            {
                cbBytesRet = *((LPDWORD) params[6].dwValue);

                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr ("  bytesReturned=x%x", cbBytesRet);
                ShowStr ("  *lpvOutBuffer=");
                ShowBytes (cbBytesRet, pOverlapped+1, 2);
            }
            else if (i == SOCKET_ERROR)
            {
                if (ShowError (funcIndex, 0) == WSA_IO_PENDING)
                {
                    ShowStr ("  lpOverlapped=x%x", params[7].dwValue);
                    break;
                }
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }

            if (i == 0  &&  params[9].dwValue)
            {
                // Let CompletionProc free overlapped struct
            }
            else
            {
                MyFree (pOverlapped);
            }
        }

        break;
    }
//    case ws_WSAIsBlocking:  not implemented in ws 2
//
//        break;

    case ws_WSAJoinLeaf:
    {
        LPBYTE      pBuf = MyAlloc (5 * dwBigBufSize + 2 * sizeof (QOS));
        LPSOCKADDR  pSA = (LPSOCKADDR) pBuf;
        LPBYTE      pCallerBuf = pBuf + dwBigBufSize,
                    pCalleeBuf = pBuf + 2 * dwBigBufSize;
        LPQOS       pSQOS = (LPQOS) (pBuf + 3 * dwBigBufSize),
                    pGQOS = (LPQOS) (pBuf + 4 * dwBigBufSize + sizeof (QOS));
        WSABUF      callerData, calleeData;
        FUNC_PARAM params[] =
        {
            { gszSocket,        PT_DWORD,       (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "name",           PT_PTRNOEDIT,   (ULONG_PTR) pSA, pSA },
            { "  ->sa_family",  PT_ORDINAL,     (ULONG_PTR) gdwDefAddrFamily, aAddressFamilies },
            { "  ->sa_data",    PT_POINTER,     (ULONG_PTR) &pSA->sa_data, &pSA->sa_data },
            { "namelen",        PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            { "lpCallerData",   PT_PTRNOEDIT,   (ULONG_PTR) &callerData, &callerData },
            { "  ->len",        PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            { "  ->buf",        PT_POINTER,     (ULONG_PTR) pCallerBuf, pCallerBuf },
            { "lpCalleeData",   PT_PTRNOEDIT,   (ULONG_PTR) &calleeData, &calleeData },
            { "  ->len",        PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            { "  ->buf",        PT_POINTER,     (ULONG_PTR) pCalleeBuf, pCalleeBuf },
            { "lpSQOS",         PT_QOS,         (ULONG_PTR) pSQOS, pSQOS },
            { "lpGQOS",         PT_QOS,         (ULONG_PTR) pGQOS, pGQOS },
            { "dwFlags",        PT_ORDINAL,     (ULONG_PTR) 0, aJLFlags }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 14, funcIndex, params, NULL };


        if (!pBuf)
        {
            break;
        }

        ZeroMemory (pSQOS, sizeof (QOS));
        pSQOS->ProviderSpecific.len = dwBigBufSize;

        ZeroMemory (pGQOS, sizeof (QOS));
        pGQOS->ProviderSpecific.len = dwBigBufSize;

        if (LetUserMungeParams (&paramsHeader))
        {
            pSA->sa_family = (u_short) LOWORD(params[2].dwValue);
            callerData.len = (DWORD) params[6].dwValue;
            calleeData.len = (DWORD) params[9].dwValue;

            if ((i = (int)WSAJoinLeaf(
                (SOCKET) params[0].dwValue,
                (LPSOCKADDR) params[1].dwValue,
                (int) params[4].dwValue,
                (LPWSABUF) params[5].dwValue,
                (LPWSABUF) params[8].dwValue,
                (LPQOS) params[11].dwValue,
                (LPQOS) params[12].dwValue,
                (DWORD) params[13].dwValue

                )) == 0)
            {
                LPWSABUF pCalleeData = (LPWSABUF) params[8].dwValue;


                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr ("  lpCalleeData->len=x%x", pCalleeData->len);

                if (pCalleeData->len)
                {
                    ShowStr ("  lpCalleeData->buf=x%x", pCalleeData->buf);
                    ShowBytes (pCalleeData->len, pCalleeData->buf, 2);
                }
            }
            else if (i == SOCKET_ERROR)
            {
                ShowError (funcIndex, 0);
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }

        }

        MyFree (pBuf);

        break;
    }
    case ws_WSALookupServiceBeginA:
    case ws_WSALookupServiceBeginW:

// case ws_WSALookupServiceBeginA:/W
        break;

    case ws_WSALookupServiceEnd:
    {
        u_long  ulHostLong;
        FUNC_PARAM params[] =
        {
            { "hLookup",    PT_DWORD,   (DWORD) 0, NULL },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if ((i = WSALookupServiceEnd ((HANDLE) params[0].dwValue)) == 0)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
            }
            else if (i == SOCKET_ERROR)
            {
                ShowError (funcIndex, 0);
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }
        }

        break;
    }
    case ws_WSALookupServiceNextA:
    case ws_WSALookupServiceNextW:
    {
        DWORD   dwLength = dwBigBufSize;
        FUNC_PARAM params[] =
        {
            { "hLookup",            PT_DWORD,       (ULONG_PTR) 0, NULL },
            { "dwControlFlags",     PT_DWORD,       (ULONG_PTR) 0, NULL }, // flags
            { "lpdwBufferLength",   PT_POINTER,     (ULONG_PTR) &dwLength, &dwLength },
            { "lpqsResults",        PT_PTRNOEDIT,   (ULONG_PTR) pBigBuf, pBigBuf }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if (funcIndex == ws_WSALookupServiceNextA)
            {
                i = WSALookupServiceNextA(
                    (HANDLE) params[0].dwValue,
                    (DWORD) params[1].dwValue,
                    (LPDWORD) params[2].dwValue,
                    (LPWSAQUERYSETA) params[3].dwValue
                    );
            }
            else
            {
                i = WSALookupServiceNextW(
                    (HANDLE) params[0].dwValue,
                    (DWORD) params[1].dwValue,
                    (LPDWORD) params[2].dwValue,
                    (LPWSAQUERYSETW) params[3].dwValue
                    );
            }

            if (i  == 0)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                // show query/set results
            }
            else if (i == SOCKET_ERROR)
            {
                ShowError (funcIndex, 0);
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }
        }

        break;
    }
    case ws_WSANtohl:
    {
        u_long  ulHostLong;
        FUNC_PARAM params[] =
        {
            { gszSocket,    PT_DWORD,       (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "netLong",    PT_DWORD,       (ULONG_PTR) 0, NULL },
            { "lpHostLong", PT_PTRNOEDIT,   (ULONG_PTR) &ulHostLong, &ulHostLong }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if ((i = WSANtohl(
                    (SOCKET) params[0].dwValue,
                    (u_long) params[1].dwValue,
                    (u_long *) params[2].dwValue

                    )) == 0)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr ("  netLong=x%x", params[1].dwValue);
                ShowStr ("  *lpHostLong=x%x", *((u_long *) params[2].dwValue));
            }
            else if (i == SOCKET_ERROR)
            {
                ShowError (funcIndex, 0);
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }
        }

        break;
    }
    case ws_WSANtohs:
    {
        u_short usHostShort;
        FUNC_PARAM params[] =
        {
            { gszSocket,        PT_DWORD,       (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "netShort",       PT_DWORD,       (ULONG_PTR) 0, NULL },
            { "lpHostShort",    PT_PTRNOEDIT,   (ULONG_PTR) &usHostShort, &usHostShort }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if ((i = WSANtohs(
                    (SOCKET) params[0].dwValue,
                    (u_short) params[1].dwValue,
                    (u_short *) params[2].dwValue

                    )) == 0)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr ("  netShort=x%x", (DWORD) LOWORD(params[1].dwValue));
                ShowStr(
                    "  *lpHostShort=x%x",
                    (DWORD) *((u_short *) params[2].dwValue)
                    );
            }
            else if (i == SOCKET_ERROR)
            {
                ShowError (funcIndex, 0);
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }
        }

        break;
    }
    case ws_WSARecv:
    {
        PMYOVERLAPPED   pOverlapped = MyAlloc(
                            sizeof (MYOVERLAPPED) +
                            2 * sizeof (WSABUF) +
                            2 * dwBigBufSize
                            );
        LPWSABUF        lpBuffers = (LPWSABUF) (pOverlapped + 1);
        LPBYTE          pBuf0 = (LPBYTE) (lpBuffers + 2),
                        pBuf1 = pBuf0 + dwBigBufSize;
        DWORD           dwNumBytesRecvd, dwFlags;
        FUNC_PARAM params[] =
        {
            { gszSocket,            PT_DWORD,       (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "lpBuffers",          PT_PTRNOEDIT,   (ULONG_PTR) lpBuffers, lpBuffers },
            { "  buf[0].len",       PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            { "  buf[0].buf",       PT_PTRNOEDIT,   (ULONG_PTR) pBuf0, pBuf0 },
            { "  buf[1].len",       PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            { "  buf[1].buf",       PT_PTRNOEDIT,   (ULONG_PTR) pBuf1, pBuf1 },
            { "dwBufferCount",      PT_DWORD,       (ULONG_PTR) 2, NULL },
            { "lpdwNumBytesRecvd",  PT_PTRNOEDIT,   (ULONG_PTR) &dwNumBytesRecvd, &dwNumBytesRecvd },
            { "lpdwFlags",          PT_POINTER,     (ULONG_PTR) &dwFlags, &dwFlags },
            { "  ->dwFlags",        PT_FLAGS,       (ULONG_PTR) gdwDefRecvFlags, aWSARecvFlags },
            { "lpOverlapped",       PT_PTRNOEDIT,   (ULONG_PTR) 0, pOverlapped },
            { "  ->hEvent",         PT_DWORD,       (ULONG_PTR) ghSelectedEvent, NULL },
            { "lpfnCompletionProc", PT_PTRNOEDIT,   (ULONG_PTR) 0, CompletionProc }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 13, funcIndex, params, NULL };


        if (!pOverlapped)
        {
            break;
        }

        if (LetUserMungeParams (&paramsHeader))
        {
            pOverlapped->WSAOverlapped.hEvent = (WSAEVENT) params[10].dwValue;
            pOverlapped->FuncIndex = funcIndex;
            pOverlapped->dwFuncSpecific1 = (DWORD) params[6].dwValue; // bufCount

            dwFlags = (DWORD) params[9].dwValue;

            if ((i = WSARecv(
                    (SOCKET) params[0].dwValue,
                    (LPWSABUF) params[1].dwValue,
                    (DWORD) params[6].dwValue,
                    (LPDWORD) params[7].dwValue,
                    (LPDWORD) params[8].dwValue,
                    (LPWSAOVERLAPPED) params[10].dwValue,
                    (LPWSAOVERLAPPED_COMPLETION_ROUTINE) params[12].dwValue

                    )) == 0)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr(
                    "  *lpdwNumBytesRecvd=x%x",
                    *((LPDWORD) params[7].dwValue)
                    );
                ShowFlags(
                    *((LPDWORD) params[8].dwValue),
                    "  *lpdwFlags",
                    aWSASendFlags
                    );
            }
            else if (i == SOCKET_ERROR)
            {
                if (ShowError (funcIndex, 0) == WSA_IO_PENDING)
                {
                    ShowStr ("  lpOverlapped=x%x", params[10].dwValue);
                    break;
                }
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }
        }

        MyFree (pOverlapped);

        break;
    }
    case ws_WSARecvDisconnect:
    {
        FUNC_PARAM params[] =
        {
            { gszSocket,                    PT_DWORD,       (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "lpInboundDisconnectData",    PT_PTRNOEDIT,   (ULONG_PTR) pBigBuf, pBigBuf },
            { "  ->len",                    PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            { "  ->buf",                    PT_POINTER,     (ULONG_PTR) (pBigBuf + sizeof (u_long)), (pBigBuf + sizeof (u_long)) }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if ((i = WSARecvDisconnect(
                    (SOCKET) params[0].dwValue,
                    (LPWSABUF) params[1].dwValue

                    )) == 0)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
            }
            else if (i == SOCKET_ERROR)
            {
                ShowError (funcIndex, 0);
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }
        }

        break;
    }
    case ws_WSARecvFrom:
    {
        PMYOVERLAPPED   pOverlapped = MyAlloc(
                            sizeof (MYOVERLAPPED) +
                            2 * sizeof (WSABUF) +
                            2 * dwBigBufSize
                            );
        LPWSABUF        lpBuffers = (LPWSABUF) (pOverlapped + 1);
        LPBYTE          pBuf0 = (LPBYTE) (lpBuffers + 2),
                        pBuf1 = pBuf0 + dwBigBufSize;
        DWORD           dwNumBytesSent, dwFlags;
        LPSOCKADDR      psa = (LPSOCKADDR) pBigBuf;
        FUNC_PARAM params[] =
        {
            { gszSocket,            PT_DWORD,       (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "lpBuffers",          PT_PTRNOEDIT,   (ULONG_PTR) lpBuffers, lpBuffers },
            { "  buf[0].len",       PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            { "  buf[0].buf",       PT_PTRNOEDIT,   (ULONG_PTR) pBuf0, pBuf0 },
            { "  buf[1].len",       PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            { "  buf[1].buf",       PT_PTRNOEDIT,   (ULONG_PTR) pBuf1, pBuf1 },
            { "dwBufferCount",      PT_DWORD,       (ULONG_PTR) 2, NULL },
            { "lpdwNumBytesRecvd",  PT_PTRNOEDIT,   (ULONG_PTR) &dwNumBytesSent, &dwNumBytesSent },
            { "lpdwFlags",          PT_POINTER,     (ULONG_PTR) &dwFlags, &dwFlags },
            { "  ->dwFlags",        PT_FLAGS,       (ULONG_PTR) gdwDefRecvFlags, aWSARecvFlags },
            { "lpTo",               PT_PTRNOEDIT,   (ULONG_PTR) psa, psa },
            { "  ->sa_family",      PT_ORDINAL,     (ULONG_PTR) gdwDefAddrFamily, aAddressFamilies },
            { "  ->sa_data",        PT_POINTER,     (ULONG_PTR) psa->sa_data, psa->sa_data },
            { "iToLen",             PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            { "lpOverlapped",       PT_PTRNOEDIT,   (ULONG_PTR) 0, pOverlapped },
            { "  ->hEvent",         PT_DWORD,       (ULONG_PTR) ghSelectedEvent, NULL },
            { "lpfnCompletionProc", PT_PTRNOEDIT,   (ULONG_PTR) 0, CompletionProc }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 17, funcIndex, params, NULL };


        if (!pOverlapped)
        {
            break;
        }

        if (LetUserMungeParams (&paramsHeader))
        {
            pOverlapped->WSAOverlapped.hEvent = (WSAEVENT) params[14].dwValue;
            pOverlapped->FuncIndex = funcIndex;
            pOverlapped->dwFuncSpecific1 = (DWORD) params[6].dwValue; // bufCount

            dwFlags = (DWORD) params[9].dwValue;

            psa->sa_family = (u_short) LOWORD(params[11].dwValue);

            if ((i = WSASendTo(
                    (SOCKET) params[0].dwValue,
                    (LPWSABUF) params[1].dwValue,
                    (DWORD) params[6].dwValue,
                    (LPDWORD) params[7].dwValue,
                    (DWORD) params[8].dwValue,
                    (LPSOCKADDR) params[10].dwValue,
                    (int) params[13].dwValue,
                    (LPWSAOVERLAPPED) params[14].dwValue,
                    (LPWSAOVERLAPPED_COMPLETION_ROUTINE) params[16].dwValue

                    )) == 0)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr(
                    "  *lpdwNumBytesSent=x%x",
                    *((LPDWORD) params[7].dwValue)
                    );
                ShowFlags(
                    *((LPDWORD) params[8].dwValue),
                    "  *lpdwNumBytesSent=x%x",
                    aWSAFlags
                    );
            }
            else if (i == SOCKET_ERROR)
            {
                if (ShowError (funcIndex, 0) == WSA_IO_PENDING)
                {
                    ShowStr ("  lpOverlapped=x%x", params[14].dwValue);
                    break;
                }
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }
        }

        MyFree (pOverlapped);

        break;
    }
    case ws_WSARemoveServiceClass:
    {
        GUID guid[2]; // add padding to keep dumb user from hosing stack
        FUNC_PARAM params[] =
        {
            { "lpServiceClassId",    PT_POINTER, (ULONG_PTR) guid, guid },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if ((i = WSARemoveServiceClass ((LPGUID) params[0].dwValue)) == 0)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
            }
            else if (i == SOCKET_ERROR)
            {
                ShowError (funcIndex, 0);
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }
        }

        break;
    }
    case ws_WSAResetEvent:
    {
        FUNC_PARAM params[] =
        {
            { "hEvent",   PT_DWORD,   (ULONG_PTR) ghSelectedEvent, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if (WSAResetEvent ((WSAEVENT) params[0].dwValue) == TRUE)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
            }
            else
            {
                 ShowError (funcIndex, 0);
            }
        }

        break;
    }
    case ws_WSASend:
    {
        PMYOVERLAPPED   pOverlapped = MyAlloc(
                            sizeof (MYOVERLAPPED) +
                            2 * sizeof (WSABUF) +
                            2 * dwBigBufSize
                            );
        LPWSABUF        lpBuffers = (LPWSABUF) (pOverlapped + 1);
        LPBYTE          pBuf0 = (LPBYTE) (lpBuffers + 2),
                        pBuf1 = pBuf0 + dwBigBufSize;
        DWORD           dwNumBytesSent;
        FUNC_PARAM params[] =
        {
            { gszSocket,            PT_DWORD,       (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "lpBuffers",          PT_PTRNOEDIT,   (ULONG_PTR) lpBuffers, lpBuffers },
            { "  buf[0].len",       PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            { "  buf[0].buf",       PT_POINTER,     (ULONG_PTR) pBuf0, pBuf0 },
            { "  buf[1].len",       PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            { "  buf[1].buf",       PT_POINTER,     (ULONG_PTR) pBuf1, pBuf1 },
            { "dwBufferCount",      PT_DWORD,       (ULONG_PTR) 2, NULL },
            { "lpdwNumBytesSent",   PT_PTRNOEDIT,   (ULONG_PTR) &dwNumBytesSent, &dwNumBytesSent },
            { "dwFlags",            PT_FLAGS,       (ULONG_PTR) gdwDefSendFlags, aWSASendFlags },
            { "lpOverlapped",       PT_PTRNOEDIT,   (ULONG_PTR) 0, pOverlapped },
            { "  ->hEvent",         PT_DWORD,       (ULONG_PTR) ghSelectedEvent, NULL },
            { "lpfnCompletionProc", PT_PTRNOEDIT,   (ULONG_PTR) 0, CompletionProc }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 12, funcIndex, params, NULL };


        if (!pOverlapped)
        {
            break;
        }

        if (LetUserMungeParams (&paramsHeader))
        {
            pOverlapped->WSAOverlapped.hEvent = (WSAEVENT) params[10].dwValue;
            pOverlapped->FuncIndex = funcIndex;
            pOverlapped->dwFuncSpecific1 = (DWORD) params[6].dwValue; // bufCount

            if ((i = WSASend(
                    (SOCKET) params[0].dwValue,
                    (LPWSABUF) params[1].dwValue,
                    (DWORD) params[6].dwValue,
                    (LPDWORD) params[7].dwValue,
                    (DWORD) params[8].dwValue,
                    (LPWSAOVERLAPPED) params[9].dwValue,
                    (LPWSAOVERLAPPED_COMPLETION_ROUTINE) params[11].dwValue

                    )) == 0)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr(
                    "  *lpdwNumBytesSent=x%x",
                    *((LPDWORD) params[7].dwValue)
                    );
            }
            else if (i == SOCKET_ERROR)
            {
                if (ShowError (funcIndex, 0) == WSA_IO_PENDING)
                {
                    ShowStr ("  lpOverlapped=x%x", params[9].dwValue);
                    break;
                }
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }
        }

        MyFree (pOverlapped);

        break;
    }
    case ws_WSASendDisconnect:
    {
        FUNC_PARAM params[] =
        {
            { gszSocket,                    PT_DWORD,       (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "lpOutboundDisconnectData",   PT_PTRNOEDIT,   (ULONG_PTR) pBigBuf, pBigBuf },
            { "  ->len",                    PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            { "  ->buf",                    PT_POINTER,     (ULONG_PTR) (pBigBuf + sizeof (u_long)), (pBigBuf + sizeof (u_long)) }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if ((i = WSASendDisconnect(
                    (SOCKET) params[0].dwValue,
                    (LPWSABUF) params[1].dwValue

                    )) == 0)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
            }
            else if (i == SOCKET_ERROR)
            {
                ShowError (funcIndex, 0);
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }
        }

        break;
    }
    case ws_WSASendTo:
    {
        PMYOVERLAPPED   pOverlapped = MyAlloc(
                            sizeof (MYOVERLAPPED) +
                            2 * sizeof (WSABUF) +
                            2 * dwBigBufSize
                            );
        LPWSABUF        lpBuffers = (LPWSABUF) (pOverlapped + 1);
        LPBYTE          pBuf0 = (LPBYTE) (lpBuffers + 2),
                        pBuf1 = pBuf0 + dwBigBufSize;
        DWORD           dwNumBytesSent;
        LPSOCKADDR      psa = (LPSOCKADDR) pBigBuf;
        FUNC_PARAM params[] =
        {
            { gszSocket,            PT_DWORD,       (ULONG_PTR) gpSelectedSocket->Sock, NULL },
            { "lpBuffers",          PT_PTRNOEDIT,   (ULONG_PTR) lpBuffers, lpBuffers },
            { "  buf[0].len",       PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            { "  buf[0].buf",       PT_POINTER,     (ULONG_PTR) pBuf0, pBuf0 },
            { "  buf[1].len",       PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            { "  buf[1].buf",       PT_POINTER,     (ULONG_PTR) pBuf1, pBuf1 },
            { "dwBufferCount",      PT_DWORD,       (ULONG_PTR) 2, NULL },
            { "lpdwNumBytesSent",   PT_PTRNOEDIT,   (ULONG_PTR) &dwNumBytesSent, &dwNumBytesSent },
            { "dwFlags",            PT_FLAGS,       (ULONG_PTR) gdwDefSendFlags, aWSASendFlags },
            { "lpTo",               PT_PTRNOEDIT,   (ULONG_PTR) psa, psa },
            { "  ->sa_family",      PT_ORDINAL,     (ULONG_PTR) gdwDefAddrFamily, aAddressFamilies },
            { "  ->sa_data",        PT_POINTER,     (ULONG_PTR) psa->sa_data, psa->sa_data },
            { "iToLen",             PT_DWORD,       (ULONG_PTR) dwBigBufSize, NULL },
            { "lpOverlapped",       PT_PTRNOEDIT,   (ULONG_PTR) 0, pOverlapped },
            { "  ->hEvent",         PT_DWORD,       (ULONG_PTR) ghSelectedEvent, NULL },
            { "lpfnCompletionProc", PT_PTRNOEDIT,   (ULONG_PTR) 0, CompletionProc }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 16, funcIndex, params, NULL };


        if (!pOverlapped)
        {
            break;
        }

        if (LetUserMungeParams (&paramsHeader))
        {
            pOverlapped->WSAOverlapped.hEvent = (WSAEVENT) params[14].dwValue;
            pOverlapped->FuncIndex = funcIndex;
            pOverlapped->dwFuncSpecific1 = (DWORD) params[6].dwValue; // bufCount

            psa->sa_family = (u_short) LOWORD(params[10].dwValue);

            if ((i = WSASendTo(
                    (SOCKET) params[0].dwValue,
                    (LPWSABUF) params[1].dwValue,
                    (DWORD) params[6].dwValue,
                    (LPDWORD) params[7].dwValue,
                    (DWORD) params[8].dwValue,
                    (LPSOCKADDR) params[9].dwValue,
                    (int) params[12].dwValue,
                    (LPWSAOVERLAPPED) params[13].dwValue,
                    (LPWSAOVERLAPPED_COMPLETION_ROUTINE) params[15].dwValue

                    )) == 0)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr(
                    "  *lpdwNumBytesSent=x%x",
                    *((LPDWORD) params[7].dwValue)
                    );
            }
            else if (i == SOCKET_ERROR)
            {
                if (ShowError (funcIndex, 0) == WSA_IO_PENDING)
                {
                    ShowStr ("  lpOverlapped=x%x", params[13].dwValue);
                    break;
                }
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }
        }

        MyFree (pOverlapped);

        break;
    }
//    case ws_WSASetBlockingHook: not implemented in ws 2
//
//        break;

    case ws_WSASetEvent:
    {
        FUNC_PARAM params[] =
        {
            { "hEvent",   PT_DWORD,   (ULONG_PTR) ghSelectedEvent, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if (WSASetEvent ((WSAEVENT) params[0].dwValue) == TRUE)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
            }
            else
            {
                 ShowError (funcIndex, 0);
            }
        }

        break;
    }
    case ws_WSASetLastError:
    {
        FUNC_PARAM params[] =
        {
            { "iError",   PT_DWORD,   (ULONG_PTR) 0, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 1, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            WSASetLastError ((int) params[0].dwValue);
            ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
        }

        break;
    }
    case ws_WSASetServiceA:
    case ws_WSASetServiceW:

// case ws_WSASetServiceA:/W
        break;

    case ws_WSASocketA:
    case ws_WSASocketW:
    {
        FUNC_PARAM params[] =
        {
            { "address family", PT_ORDINAL, (ULONG_PTR) gdwDefAddrFamily, aAddressFamilies },
            { "socket type",    PT_ORDINAL, (ULONG_PTR) gdwDefSocketType, aSocketTypes },
            { "protocol",       PT_DWORD,   (ULONG_PTR) gdwDefProtocol, aProtocols },
            { "protocol info",  PT_WSAPROTOCOLINFO, 0, (gbWideStringParams ?
                (LPVOID) &gWSAProtocolInfoW : (LPVOID) &gWSAProtocolInfoA) },
            { "group",          PT_DWORD,   (ULONG_PTR) 0, NULL },
            { "flags",          PT_FLAGS,   (ULONG_PTR) gdwDefWSASocketFlags, aWSAFlags },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            PMYSOCKET pSocket;


            if (!(pSocket = MyAlloc (sizeof (MYSOCKET))))
            {
                break;
            }

            if (gbWideStringParams)
            {
                pSocket->Sock = WSASocketW(
                    (int) params[0].dwValue,
                    (int) params[1].dwValue,
                    (int) params[2].dwValue,
                    (LPWSAPROTOCOL_INFOW) params[3].dwValue,
                    (GROUP) params[4].dwValue,
                    (DWORD) params[5].dwValue
                    );
            }
            else
            {
                pSocket->Sock = WSASocketA(
                    (int) params[0].dwValue,
                    (int) params[1].dwValue,
                    (int) params[2].dwValue,
                    (LPWSAPROTOCOL_INFOA) params[3].dwValue,
                    (GROUP) params[4].dwValue,
                    (DWORD) params[5].dwValue
                    );
            }

            if (pSocket->Sock != INVALID_SOCKET)
            {
                char        buf[128];
                LRESULT     index;


                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);

                pSocket->bWSASocket      = TRUE;
                pSocket->dwAddressFamily = (DWORD) params[0].dwValue;
                pSocket->dwSocketType    = (DWORD) params[1].dwValue;
                pSocket->dwFlags         = (DWORD) params[5].dwValue;

                wsprintf(
                    buf,
                    "WSASocket=x%x (%s %s%s)",
                    pSocket->Sock,
                    GetStringFromOrdinalValue (pSocket->dwAddressFamily, aAddressFamilies),
                    GetStringFromOrdinalValue (pSocket->dwSocketType, aSocketTypes),
                    (pSocket->dwFlags & WSA_FLAG_OVERLAPPED ?
                        " OVERLAPPED" : "")
                    );

                index = SendMessage(
                    ghwndList1,
                    LB_ADDSTRING,
                    0,
                    (LPARAM) buf
                    );

                SendMessage(
                    ghwndList1,
                    LB_SETITEMDATA,
                    index,
                    (LPARAM) pSocket
                    );
            }
            else
            {
                ShowError (funcIndex, 0);
                MyFree (pSocket);
            }
        }

        break;
    }
    case ws_WSAStartup:
    {
        WSADATA wsaData;
        FUNC_PARAM params[] =
        {
            { "wVersionRequested",  PT_DWORD,       (ULONG_PTR) 0x101, NULL },
            { "lpWSAData",          PT_PTRNOEDIT,   (ULONG_PTR) &wsaData, &wsaData },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if ((i = WSAStartup(
                    LOWORD(params[0].dwValue),
                    (LPWSADATA) params[1].dwValue

                    )) == 0)
            {
                char szButtonText[32];
                LPWSADATA pWSAData = (LPWSADATA) params[1].dwValue;


                wsprintf (szButtonText, "Startup (%d)", ++giCurrNumStartups);
                SetDlgItemText (ghwndMain, IDC_BUTTON1, szButtonText);

                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr ("  wVersion=x%x", (DWORD) pWSAData->wVersion);
                ShowStr ("  wHighVersion=x%x", (DWORD) pWSAData->wHighVersion);
                ShowStr ("  szDescription=%s", pWSAData->szDescription);
                ShowStr ("  szSystemStatus=%s", pWSAData->szSystemStatus);
                ShowStr ("  iMaxSockets=%d", (DWORD) pWSAData->iMaxSockets);
                ShowStr ("  iMaxUdpDg=%d", (DWORD) pWSAData->iMaxUdpDg);
                //  ignored for 2.0+  ShowStr ("  ", pWSAData->lpVendorInfo);
            }
            else
            {
                ShowError (funcIndex, i);
            }
        }

        break;
    }
    case ws_WSAStringToAddressA:
    case ws_WSAStringToAddressW:
    {
        INT  iAddrLen = (INT) dwBigBufSize;
        char szAddrString[MAX_STRING_PARAM_SIZE] = "";
        LPWSAPROTOCOL_INFOA pInfo = (funcIndex == ws_WSAStringToAddressA ?
                                &gWSAProtocolInfoA :
                                (LPWSAPROTOCOL_INFOA) &gWSAProtocolInfoW);
        FUNC_PARAM params[] =
        {
            { "lpszAddressString",  PT_STRING,  (ULONG_PTR) szAddrString, szAddrString },
            { "iAddressFamily",     PT_ORDINAL, (ULONG_PTR) gdwDefAddrFamily, aAddressFamilies },
            { "lpProtocolInfo",     PT_WSAPROTOCOLINFO, (ULONG_PTR) pInfo, pInfo },
            { "lpAddress",          PT_POINTER, (ULONG_PTR) pBigBuf, pBigBuf },
            { "lpAddressLength",    PT_POINTER, (ULONG_PTR) &iAddrLen, &iAddrLen }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 5, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            if (funcIndex == ws_WSAStringToAddressA)
            {
                i = WSAStringToAddressA(
                    (LPSTR) params[0].dwValue,
                    (INT) params[1].dwValue,
                    (LPWSAPROTOCOL_INFOA) params[2].dwValue,
                    (LPSOCKADDR) params[3].dwValue,
                    (LPINT) params[4].dwValue
                    );
            }
            else
            {
                i = WSAStringToAddressW(
                    (LPWSTR) params[0].dwValue,
                    (INT) params[1].dwValue,
                    (LPWSAPROTOCOL_INFOW) params[2].dwValue,
                    (LPSOCKADDR) params[3].dwValue,
                    (LPINT) params[4].dwValue
                    );
            }

            if (i == 0)
            {
                LPSOCKADDR pSockAddr = (LPSOCKADDR) params[3].dwValue;


                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);

                ShowStr(
                    "  *lpAddressLength=x%x",
                    *((LPINT) params[4].dwValue)
                    );

                ShowStr ("  lpAddress=x%x", params[3].dwValue);

                ShowStr(
                    "    ->sa_family=%d, %s",
                    (DWORD) pSockAddr->sa_family,
                    GetStringFromOrdinalValue(
                        (DWORD) pSockAddr->sa_family,
                        aAddressFamilies
                        )
                    );

                ShowStr ("    ->sa_data=");
                ShowBytes (14, pSockAddr->sa_data, 3);
            }
            else if (i == SOCKET_ERROR)
            {
                ShowError (funcIndex, 0);
            }
            else
            {
                ShowUnknownError (funcIndex, i);
            }
        }

        break;
    }
//    case ws_WSAUnhookBlockingHook:
//
//        break;

    case ws_WSAWaitForMultipleEvents:

// case ws_WSAWaitForMultipleEvents:
        break;

    case ws_WSCEnumProtocols:
    {
        int aProtocols[32], iErrno;
        DWORD dwSize = dwBigBufSize;
        FUNC_PARAM params[] =
        {
            { "lpiProtocols",       PT_POINTER,     (ULONG_PTR) NULL, aProtocols },
            { "lpProtocolBuffer",   PT_PTRNOEDIT,   (ULONG_PTR) pBigBuf, pBigBuf },
            { "lpdwBufferLength",   PT_POINTER,     (ULONG_PTR) &dwSize, &dwSize },
            { "lpErrno",            PT_POINTER,     (ULONG_PTR) &iErrno, &iErrno }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, NULL };


        if (LetUserMungeParams (&paramsHeader))
        {
            i = WSCEnumProtocols(
                (LPINT) params[0].dwValue,
                (LPWSAPROTOCOL_INFOW) params[1].dwValue,
                (LPDWORD) params[2].dwValue,
                (LPINT) params[3].dwValue
                );

            if (i != SOCKET_ERROR)
            {
                LPWSAPROTOCOL_INFOW pInfo = (LPWSAPROTOCOL_INFOW)
                                        params[1].dwValue;


                UpdateResults (TRUE);

                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);

                ShowStr(
                    "  *lpdwBufferLength=x%x",
                    *((LPDWORD) params[2].dwValue)
                    );

                for (j = 0; j < i; j++)
                {
                    ShowProtoInfo ((LPWSAPROTOCOL_INFOA) pInfo, j, FALSE);

                    pInfo++;
                }

                UpdateResults (FALSE);
            }
            else
            {
                ShowError (funcIndex, iErrno);
                if (iErrno == WSAENOBUFS)
                {
                    ShowStr(
                        "  *lpdwBufferLength=x%x",
                        *((LPDWORD) params[2].dwValue)
                        );
                }
            }
        }

        break;
    }
    case ws_WSCGetProviderPath:
    {
        GUID guid[2];
        INT iPathLen = dwBigBufSize, iErrno = 0;
        FUNC_PARAM params[] =
        {
            { "lpProviderId",           PT_POINTER,  (ULONG_PTR) guid, guid },
            { "lpszProviderDllPath",    PT_PTRNOEDIT,(ULONG_PTR) pBigBuf, pBigBuf },
            { "lpProviderDllPathLen",   PT_POINTER,  (ULONG_PTR) &iPathLen, &iPathLen },
            { "lpErrno",                PT_PTRNOEDIT,(ULONG_PTR) &iErrno, &iErrno }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 4, funcIndex, params, NULL };

        if (LetUserMungeParams (&paramsHeader))
        {
            if ((i = WSCGetProviderPath(
                    (LPGUID) params[0].dwValue,
                    (LPWSTR) params[1].dwValue,
                    (LPINT)  params[2].dwValue,
                    (LPINT)  params[3].dwValue

                    )) == 0)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr ("*lpszProviderDllPath='%ws'", params[1].dwValue);
                ShowStr ("*lpProviderDllPathLen=%d", *((LPINT)params[2].dwValue));
            }
            else
            {
                ShowError (funcIndex, iErrno);
            }
        }

        break;
    }
    case ws_EnumProtocolsA:
    case ws_EnumProtocolsW:
    {
        INT aiProtocols[32];
        DWORD dwBufSize = dwBigBufSize;
        FUNC_PARAM params[] =
        {
            { "lpiProtocols",       PT_POINTER,  (ULONG_PTR) NULL, aiProtocols },
            { "lpProtocolBuffer",   PT_PTRNOEDIT,(ULONG_PTR) pBigBuf, pBigBuf },
            { "lpdwBufferLength",   PT_POINTER,  (ULONG_PTR) &dwBufSize, &dwBufSize }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, NULL };

        if (LetUserMungeParams (&paramsHeader))
        {
            i = (funcIndex == ws_EnumProtocolsA ?

                EnumProtocolsA(
                    (LPINT)   params[0].dwValue,
                    (LPVOID)  params[1].dwValue,
                    (LPDWORD) params[2].dwValue
                    ) :

                EnumProtocolsW(
                    (LPINT)   params[0].dwValue,
                    (LPVOID)  params[1].dwValue,
                    (LPDWORD) params[2].dwValue
                    ));

            if (i >= 0)
            {
                char            szProtoInfoN[20], buf[36];
                PROTOCOL_INFO   *pInfo;

                UpdateResults (TRUE);

                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr ("iResult=%d", i);
                ShowStr(
                    "*lpdwBufferLength=x%x",
                    *((LPDWORD) params[2].dwValue)
                    );

                for(
                    j = 0, pInfo = (PROTOCOL_INFO *) params[1].dwValue;
                    j < i;
                    j++, pInfo++
                    )
                {
                    wsprintf (szProtoInfoN, "  protoInfo[%d].", j);

                    wsprintf (buf, "%sdwServiceFlags", szProtoInfoN);
                    ShowFlags (pInfo->dwServiceFlags, buf, aServiceFlags);

                    ShowStr(
                        "%siAddressFamily=%d, %s",
                        szProtoInfoN,
                        (DWORD) pInfo->iAddressFamily,
                        GetStringFromOrdinalValue(
                            (DWORD) pInfo->iAddressFamily,
                            aAddressFamilies
                            )
                        );

                    ShowStr(
                        "%siMaxSockAddr=%d",
                        szProtoInfoN,
                        (DWORD) pInfo->iMaxSockAddr
                        );

                    ShowStr(
                        "%siMinSockAddr=%d",
                        szProtoInfoN,
                        (DWORD) pInfo->iMinSockAddr
                        );

                    ShowStr(
                        "%siSocketType=%d, %s",
                        szProtoInfoN,
                        (DWORD) pInfo->iSocketType,
                        GetStringFromOrdinalValue(
                            (DWORD) pInfo->iSocketType,
                            aSocketTypes
                            )
                        );

                    ShowStr(
                        "%siProtocol=%d (x%x)", // ought to be flags???
                        szProtoInfoN,
                        (DWORD) pInfo->iProtocol,
                        (DWORD) pInfo->iProtocol
                        );

                    ShowStr(
                        "%sdwMessageSize=x%x",
                        szProtoInfoN,
                        (DWORD) pInfo->dwMessageSize
                        );

                    ShowStr(
                        "%slpProtocol=x%x",
                        szProtoInfoN,
                        pInfo->lpProtocol
                        );


                    if (funcIndex == ws_EnumProtocolsA)
                    {
                        ShowStr(
                            "%s*lpProtocol=%s",
                            szProtoInfoN,
                            pInfo->lpProtocol
                            );

                        ShowBytes(
                            (lstrlenA (pInfo->lpProtocol) + 1) * sizeof(CHAR),
                            pInfo->lpProtocol,
                            2
                            );
                    }
                    else
                    {
                        ShowStr(
                            "%s*lpProtocol=%ws",
                            szProtoInfoN,
                            pInfo->lpProtocol
                            );

                        ShowBytes(
                            (lstrlenW ((WCHAR *) pInfo->lpProtocol) + 1)
                                * sizeof(WCHAR),
                            pInfo->lpProtocol,
                            2
                            );
                    }
                }

                UpdateResults (FALSE);
            }
            else
            {
                if (ShowError (funcIndex, 0) == ERROR_INSUFFICIENT_BUFFER)
                {
                    ShowStr(
                        "*lpdwBufferLength=x%x",
                        *((LPDWORD) params[2].dwValue)
                        );
                }
            }
        }

        break;
    }
    case ws_GetAddressByNameA:
    case ws_GetAddressByNameW:
    {
        GUID    guid[2];
        WCHAR   szSvcName[MAX_STRING_PARAM_SIZE] = L"";
        INT     aiProtocols[32];
        char    *pBigBuf2 = (char *) LocalAlloc (LPTR, dwBigBufSize);
        DWORD   dwCsaddrBufLen = dwBigBufSize, dwAliasBufLen = dwBigBufSize;
        FUNC_PARAM params[] =
        {
            { "dwNameSpace",        PT_ORDINAL,  (ULONG_PTR) 0, aNameSpaces },
            { "lpServiceType",      PT_POINTER,  (ULONG_PTR) guid, guid },
            { "lpServiceName",      PT_STRING,   (ULONG_PTR) NULL, szSvcName },
            { "lpiProtocols",       PT_POINTER,  (ULONG_PTR) NULL, aiProtocols },
            { "dwResolution",       PT_FLAGS,    (ULONG_PTR) 0, aResFlags },
            { "lpServiceAsyncInfo", PT_DWORD,    (ULONG_PTR) 0, 0 },
            { "lpCsaddrBuffer",     PT_PTRNOEDIT,(ULONG_PTR) pBigBuf, pBigBuf },
            { "lpdwCsaddrBufLen",   PT_POINTER,  (ULONG_PTR) &dwCsaddrBufLen, &dwCsaddrBufLen },
            { "lpAliasBuf",         PT_PTRNOEDIT,(ULONG_PTR) pBigBuf2, pBigBuf2 },
            { "lpdwAliasBufLen",    PT_POINTER,  (ULONG_PTR) &dwAliasBufLen, &dwAliasBufLen }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 10, funcIndex, params, NULL };

        if (LetUserMungeParams (&paramsHeader))
        {
            i = (funcIndex == ws_GetAddressByNameA ?

                GetAddressByNameA(
                    (DWORD)   params[0].dwValue,
                    (LPGUID)  params[1].dwValue,
                    (LPSTR)   params[2].dwValue,
                    (LPINT)   params[3].dwValue,
                    (DWORD)   params[4].dwValue,
                    (LPSERVICE_ASYNC_INFO) params[5].dwValue,
                    (LPVOID)  params[6].dwValue,
                    (LPDWORD) params[7].dwValue,
                    (LPSTR)   params[8].dwValue,
                    (LPDWORD) params[9].dwValue
                    ) :

                GetAddressByNameW(
                    (DWORD)   params[0].dwValue,
                    (LPGUID)  params[1].dwValue,
                    (LPWSTR)  params[2].dwValue,
                    (LPINT)   params[3].dwValue,
                    (DWORD)   params[4].dwValue,
                    (LPSERVICE_ASYNC_INFO) params[5].dwValue,
                    (LPVOID)  params[6].dwValue,
                    (LPDWORD) params[7].dwValue,
                    (LPWSTR)  params[8].dwValue,
                    (LPDWORD) params[9].dwValue

                    ));

            if (i >= 0)
            {
                char        szAddrInfoN[20];
                CSADDR_INFO *pInfo;


                UpdateResults (TRUE);

                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr ("iResult=%d", i);

                ShowStr(
                    "*lpdwCsaddrBufLen=x%x",
                    *((LPDWORD) params[7].dwValue)
                    );

                for(
                    j = 0, pInfo = (CSADDR_INFO *) params[6].dwValue;
                    j < i;
                    j++, pInfo++
                    )
                {
                    wsprintf (szAddrInfoN, "  addrInfo[%d].", j);

                    ShowStr(
                        "%sLocalAddr.lpSockaddr=x%x",
                        szAddrInfoN,
                        pInfo->LocalAddr.lpSockaddr
                        );

                    ShowBytes(
                        pInfo->LocalAddr.iSockaddrLength,
                        pInfo->LocalAddr.lpSockaddr,
                        2
                        );

                    ShowStr(
                        "%sLocalAddr.iSockaddrLen=%d (x%x)",
                        szAddrInfoN,
                        pInfo->LocalAddr.iSockaddrLength,
                        pInfo->LocalAddr.iSockaddrLength
                        );

                    ShowStr(
                        "%sRemoteAddr.lpSockaddr=x%x",
                        szAddrInfoN,
                        pInfo->RemoteAddr.lpSockaddr
                        );

                    ShowBytes(
                        pInfo->RemoteAddr.iSockaddrLength,
                        pInfo->RemoteAddr.lpSockaddr,
                        2
                        );

                    ShowStr(
                        "%sRemoteAddr.iSockaddrLen=%d (x%x)",
                        szAddrInfoN,
                        pInfo->RemoteAddr.iSockaddrLength,
                        pInfo->RemoteAddr.iSockaddrLength
                        );

                    ShowStr(
                        "%siSocketType=%d, %s",
                        szAddrInfoN,
                        (DWORD) pInfo->iSocketType,
                        GetStringFromOrdinalValue(
                            (DWORD) pInfo->iSocketType,
                            aSocketTypes
                            )
                        );

                    ShowStr(
                        "%siProtocol=%d (x%x)", // ought to be flags???
                        szAddrInfoN,
                        (DWORD) pInfo->iProtocol,
                        (DWORD) pInfo->iProtocol
                        );
                }

                UpdateResults (FALSE);
            }
            else
            {
                if (ShowError (funcIndex, 0) == ERROR_INSUFFICIENT_BUFFER)
                {
                    ShowStr(
                        "*lpdwCsaddrBufLen=x%x",
                        *((LPDWORD) params[7].dwValue)
                        );
                }
            }
        }

        LocalFree (pBigBuf2);

        break;
    }
    case ws_GetNameByTypeA:
    case ws_GetNameByTypeW:
    {
        GUID    guid[2];
        FUNC_PARAM params[] =
        {
            { "lpServiceType",  PT_POINTER,  (ULONG_PTR) guid, guid },
            { "lpServiceName",  PT_PTRNOEDIT,(ULONG_PTR) pBigBuf, pBigBuf },
            { "dwNameLength",   PT_DWORD,    (ULONG_PTR) dwBigBufSize, NULL }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 3, funcIndex, params, NULL };

        if (LetUserMungeParams (&paramsHeader))
        {
            i = (funcIndex == ws_GetNameByTypeA ?

                GetNameByTypeA(
                    (LPGUID) params[0].dwValue,
                    (LPSTR)  params[1].dwValue,
                    (DWORD)  params[2].dwValue
                    ) :

                GetNameByTypeW(
                    (LPGUID) params[0].dwValue,
                    (LPWSTR)  params[1].dwValue,
                    (DWORD)  params[2].dwValue
                    ));

            if (i != SOCKET_ERROR)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);

                if (funcIndex == ws_GetNameByTypeA)
                {
                    ShowStr ("*lpServiceName=%s", (char *) params[1].dwValue);
                }
                else
                {
                    ShowStr ("*lpServiceName=%ws", (char *) params[1].dwValue);
                }
            }
            else
            {
                ShowError (funcIndex, 0);
            }
        }

        break;
    }
    case ws_GetServiceA:
    case ws_GetServiceW:
    {
        GUID    guid[2];
        WCHAR   szSvcName[MAX_STRING_PARAM_SIZE] = L"";
        DWORD dwBufSize = dwBigBufSize;
        FUNC_PARAM params[] =
        {
            { "dwNameSpace",    PT_ORDINAL,   (ULONG_PTR) 0, aNameSpaces },
            { "lpGuid",         PT_POINTER,   (ULONG_PTR) guid, guid },
            { "lpServiceName",  PT_STRING,    (ULONG_PTR) szSvcName, szSvcName },
            { "dwProperties",   PT_FLAGS,     (ULONG_PTR) 0, aProperties },
            { "lpBuffer",       PT_PTRNOEDIT, (ULONG_PTR) pBigBuf, pBigBuf },
            { "lpdwBufLen",     PT_POINTER,   (ULONG_PTR) &dwBufSize, &dwBufSize },
            { "lpSvcAsyncInfo", PT_DWORD,     (ULONG_PTR) 0, 0 }

        };
        FUNC_PARAM_HEADER paramsHeader =
            { 7, funcIndex, params, NULL };

        if (LetUserMungeParams (&paramsHeader))
        {
            i = (funcIndex == ws_GetServiceA ?

                GetServiceA(
                    (DWORD)   params[0].dwValue,
                    (LPGUID)  params[1].dwValue,
                    (LPSTR)   params[2].dwValue,
                    (DWORD)   params[3].dwValue,
                    (LPVOID)  params[4].dwValue,
                    (LPDWORD) params[5].dwValue,
                    (LPSERVICE_ASYNC_INFO) params[6].dwValue
                    ) :

                GetServiceW(
                    (DWORD)   params[0].dwValue,
                    (LPGUID)  params[1].dwValue,
                    (LPWSTR)   params[2].dwValue,
                    (DWORD)   params[3].dwValue,
                    (LPVOID)  params[4].dwValue,
                    (LPDWORD) params[5].dwValue,
                    (LPSERVICE_ASYNC_INFO) params[6].dwValue
                    ));

            if (i >= 0)
            {
                char            szSvcInfoN[20], buf[36];
                SERVICE_INFO    *pInfo;
                SERVICE_ADDRESS *pAddr;

                UpdateResults (TRUE);

                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowStr ("iResult=%d", i);
                ShowStr(
                    "*lpdwBufLen=x%x",
                    *((LPDWORD) params[5].dwValue)
                    );

                for(
                    j = 0, pInfo = (SERVICE_INFO *) params[4].dwValue;
                    j < i;
                    j++, pInfo++
                    )
                {
                    wsprintf (szSvcInfoN, "  svcInfo[%d].", j);

                    wsprintf (buf, "lpServiceType=");

                    ShowGUID (buf, pInfo->lpServiceType);

                    ShowStr(
                        (funcIndex == ws_GetServiceA ?
                            "%slpServiceName=%s" : "%slpServiceName=%ws"),
                        szSvcInfoN,
                        pInfo->lpServiceName
                        );

                    ShowStr(
                        (funcIndex == ws_GetServiceA ?
                            "%slpComment=%s" : "%slpComment=%ws"),
                        szSvcInfoN,
                        pInfo->lpServiceName
                        );

                    ShowStr(
                        (funcIndex == ws_GetServiceA ?
                            "%slpLocale=%s" : "%slpLocale=%ws"),
                        szSvcInfoN,
                        pInfo->lpLocale
                        );

                    ShowStr(
                        "%sdwDisplayHint=%d, %s",
                        szSvcInfoN,
                        (DWORD) pInfo->dwDisplayHint,
                        GetStringFromOrdinalValue(
                            (DWORD) pInfo->dwDisplayHint,
                            aResDisplayTypes
                            )
                        );

                    ShowStr ("%sdwVersion=x%x", szSvcInfoN, pInfo->dwVersion);

                    ShowStr ("%sdwTime=x%x", szSvcInfoN, pInfo->dwTime);

                    ShowStr(
                        (funcIndex == ws_GetServiceA ?
                            "%slpMachineName=%s" : "%slpMachineName=%ws"),
                        szSvcInfoN,
                        pInfo->lpMachineName
                        );

                    ShowStr(
                        "%slpServiceAddress.dwAddressCount=%d (x%x)",
                        szSvcInfoN,
                        pInfo->lpServiceAddress->dwAddressCount,
                        pInfo->lpServiceAddress->dwAddressCount
                        );

                    for(
                        k = 0, pAddr = pInfo->lpServiceAddress->Addresses;
                        k < (int) pInfo->lpServiceAddress->dwAddressCount;
                        k++, pAddr++
                        )
                    {
                    }

                    ShowStr(
                        "%sServiceSpecificInfo.cbSize=%d (x%x)",
                        szSvcInfoN,
                        pInfo->ServiceSpecificInfo.cbSize,
                        pInfo->ServiceSpecificInfo.cbSize
                        );

                    ShowBytes(
                        pInfo->ServiceSpecificInfo.cbSize,
                        pInfo->ServiceSpecificInfo.pBlobData,
                        2
                        );
                }

                UpdateResults (FALSE);
            }
            else
            {
                if (ShowError (funcIndex, i) == ERROR_INSUFFICIENT_BUFFER)
                {
                    ShowStr(
                        "*lpdwBufLen=x%x",
                        *((LPDWORD) params[5].dwValue)
                        );
                }
            }
        }

        break;
    }
    case ws_GetTypeByNameA:
    case ws_GetTypeByNameW:
    {
        GUID    guid[2];
        WCHAR   szSvcName[MAX_STRING_PARAM_SIZE] = L"";
        FUNC_PARAM params[] =
        {
            { "lpServiceName",  PT_PTRNOEDIT,(ULONG_PTR) szSvcName, szSvcName },
            { "lpServiceType",  PT_POINTER,  (ULONG_PTR) guid, guid }
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 2, funcIndex, params, NULL };

        if (LetUserMungeParams (&paramsHeader))
        {
            i = (funcIndex == ws_GetTypeByNameA ?

                GetTypeByNameA(
                    (LPSTR)  params[0].dwValue,
                    (LPGUID) params[1].dwValue
                    ) :

                GetTypeByNameW(
                    (LPWSTR) params[0].dwValue,
                    (LPGUID) params[1].dwValue
                    ));

            if (i != SOCKET_ERROR)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
                ShowGUID ("*lpServiceType=", (LPGUID) params[1].dwValue);
            }
            else
            {
                ShowError (funcIndex, 0);
            }
        }

        break;
    }
    case ws_SetServiceA:
    case ws_SetServiceW:
    {
        DWORD dwStatusFlags;
        FUNC_PARAM params[] =
        {
            { "dwNameSpace",        PT_ORDINAL,     (ULONG_PTR) 0, aNameSpaces },
            { "dwOperation",        PT_ORDINAL,     (ULONG_PTR) 0, aServiceOps },
            { "dwFlags",            PT_FLAGS,       (ULONG_PTR) 0, aSvcFlags },
            { "lpServiceInfo",      PT_POINTER,     (ULONG_PTR) pBigBuf, pBigBuf },
            { "lpServiceAsnycInfo", PT_DWORD,       (ULONG_PTR) 0, NULL },
            { "lpdwStatusFlags",    PT_PTRNOEDIT,   (ULONG_PTR) &dwStatusFlags, &dwStatusFlags },
        };
        FUNC_PARAM_HEADER paramsHeader =
            { 6, funcIndex, params, NULL };

        if (LetUserMungeParams (&paramsHeader))
        {
            i = (funcIndex == ws_SetServiceA ?

                SetServiceA(
                    (DWORD) params[0].dwValue,
                    (DWORD) params[1].dwValue,
                    (DWORD) params[2].dwValue,
                    (LPSERVICE_INFOA) params[3].dwValue,
                    (LPSERVICE_ASYNC_INFO) params[4].dwValue,
                    (LPDWORD) params[5].dwValue
                    ) :

                SetServiceW(
                    (DWORD) params[0].dwValue,
                    (DWORD) params[1].dwValue,
                    (DWORD) params[2].dwValue,
                    (LPSERVICE_INFOW) params[3].dwValue,
                    (LPSERVICE_ASYNC_INFO) params[4].dwValue,
                    (LPDWORD) params[5].dwValue
                    ));

            if (i != SOCKET_ERROR)
            {
                ShowStr (gszXxxSUCCESS, aFuncNames[funcIndex]);
            }
            else
            {
                ShowError (funcIndex, 0);
            }
        }

        break;
      }
//    case CloseHandl:
//
//        break;

//    case DumpBuffer:
//
//        break;

    }
}


void
FAR
ShowHostEnt(
    struct hostent  *phe
    )
{
    DWORD   i, j;


    ShowStr ("  pHostEnt=x%x", phe);
    ShowStr ("  ->h_name=%s", phe->h_name);

    for (i = 0; *(phe->h_aliases + i); i++)
    {
        ShowStr ("  ->h_aliases[%d]=%s", i, *(phe->h_aliases + i));
    }

    ShowStr ("  ->h_addrtype=%x", (DWORD) phe->h_addrtype);
    ShowStr ("  ->h_length=%x", (DWORD) phe->h_length);

    for (i = 0; *(phe->h_addr_list + i); i++)
    {
        char far *pAddr = *(phe->h_addr_list + i);

        if (phe->h_addrtype == AF_INET)
        {
            ShowStr ("  ->h_addr_list[%d]=", i);
            ShowBytes (sizeof (DWORD) + lstrlenA (pAddr+4), pAddr, 2);
        }
        else
        {
            ShowStr ("  ->h_addr_list[%d]=%s", i, *(phe->h_addr_list + i));
        }
    }
}


void
FAR
ShowProtoEnt(
    struct protoent *ppe
    )
{
    DWORD   i;


    ShowStr ("  pProtoEnt=x%x", ppe);
    ShowStr ("  ->p_name=%s", ppe->p_name);

    for (i = 0; *(ppe->p_aliases + i); i++)
    {
        ShowStr ("  ->p_aliases[%d]=%s", i, *(ppe->p_aliases + i));
    }

    ShowStr ("  ->p_proto=%x", (DWORD) ppe->p_proto);
}


void
FAR
ShowServEnt(
    struct servent  *pse
    )
{
    DWORD   i;


    ShowStr ("  pServEnt=x%x", pse);
    ShowStr ("  ->s_name=%s", pse->s_name);

    for (i = 0; *(pse->s_aliases + i); i++)
    {
        ShowStr ("  ->s_aliases[%d]=%s", i, *(pse->s_aliases + i));
    }

    ShowStr ("  ->s_port=%d (x%x)", (DWORD) pse->s_port, (DWORD) pse->s_port);
    ShowStr ("  ->s_proto=%s", pse->s_proto);
}


void
PASCAL
QueueAsyncRequestInfo(
    PASYNC_REQUEST_INFO pAsyncReqInfo
    )
{
    pAsyncReqInfo->pNext = gpAsyncReqInfoList;
    gpAsyncReqInfoList = pAsyncReqInfo;
}


PASYNC_REQUEST_INFO
PASCAL
DequeueAsyncRequestInfo(
    HANDLE  hRequest
    )
{
    PASYNC_REQUEST_INFO  pAsyncReqInfo;


    for(
        pAsyncReqInfo = gpAsyncReqInfoList;
        pAsyncReqInfo  &&  pAsyncReqInfo->hRequest != hRequest;
        pAsyncReqInfo = pAsyncReqInfo->pNext
        );

    if (pAsyncReqInfo)
    {
        if (pAsyncReqInfo->pPrev)
        {
            pAsyncReqInfo->pPrev->pNext = pAsyncReqInfo->pNext;
        }
        else
        {
            gpAsyncReqInfoList = pAsyncReqInfo->pNext;
        }

        if (pAsyncReqInfo->pNext)
        {
            pAsyncReqInfo->pNext->pPrev = pAsyncReqInfo->pPrev;
        }
    }

    return pAsyncReqInfo;
}


void
PASCAL
ShowModBytes(
    DWORD               dwSize,
    unsigned char far  *lpc,
    char               *pszTab,
    char               *buf
    )
{
    DWORD   dwSize2 = dwSize, i, j, k;


    strcpy (buf, pszTab);

    k = strlen (buf);

    for (i = 8; i < 36; i += 9)
    {
        buf[k + i] = ' ';

        for (j = 2; j < 9; j += 2)
        {
            char buf2[8] = "xx";

            if (dwSize2)
            {
                sprintf (buf2, "%02x", (int) (*lpc));
                dwSize2--;
            }

            buf[k + i - j]     = buf2[0];
            buf[k + i - j + 1] = buf2[1];

            lpc++;
        }
    }

    k += 37;

    buf[k - 1] = ' ';

    lpc -= 16;

    for (i = 0; i < dwSize; i++)
    {
        buf[k + i] = aAscii[*(lpc+i)];
    }

    buf[k + i] = 0;

    ShowStr (buf);
}


void
UpdateResults(
    BOOL bBegin
    )
{
    //
    // In order to maximize speed, minimize flash, & have the
    // latest info in the edit control scrolled into view we
    // shrink the window down and hide it. Later, when all the
    // text has been inserted in the edit control, we show
    // the window (since window must be visible in order to
    // scroll caret into view), then tell it to scroll the caret
    // (at this point the window is still 1x1 so the painting
    // overhead is 0), and finally restore the control to it's
    // full size. In doing so we have zero flash and only 1 real
    // complete paint. Also put up the hourglass for warm fuzzies.
    //

    static RECT    rect;
    static HCURSOR hCurSave;
    static int     iNumBegins = 0;


    if (bBegin)
    {
        iNumBegins++;

        if (iNumBegins > 1)
        {
            return;
        }

        hCurSave = SetCursor (LoadCursor ((HINSTANCE)NULL, IDC_WAIT));
        GetWindowRect (ghwndEdit, &rect);
        SetWindowPos(
            ghwndEdit,
            (HWND) NULL,
            0,
            0,
            1,
            1,
            SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOREDRAW |
                SWP_NOZORDER | SWP_HIDEWINDOW
            );
    }
    else
    {
        iNumBegins--;

        if (iNumBegins > 0)
        {
            return;
        }

        //
        // Do control restoration as described above
        //

        ShowWindow (ghwndEdit, SW_SHOW);
#ifdef WIN32
        SendMessage (ghwndEdit, EM_SCROLLCARET, 0, 0);
#else
        SendMessage(
            ghwndEdit,
            EM_SETSEL,
            (WPARAM)0,
            (LPARAM) MAKELONG(0xfffd,0xfffe)
            );
#endif
        SetWindowPos(
            ghwndEdit,
            (HWND) NULL,
            0,
            0,
            rect.right - rect.left,
            rect.bottom - rect.top,
            SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER
            );
        SetCursor (hCurSave);
    }
}


void
PASCAL
ShowBytes(
    DWORD   dwSize,
    LPVOID  lp,
    DWORD   dwNumTabs
    )
{
    char    tabBuf[17] = "";
    char    buf[80];
    DWORD   i, j, k, dwNumDWORDs, dwMod4 = (DWORD)(((ULONG_PTR) lp) % 4);
    LPDWORD lpdw;
    unsigned char far *lpc = (unsigned char far *) lp;


    UpdateResults (TRUE);


    for (i = 0; i < dwNumTabs; i++)
    {
        strcat (tabBuf, szTab);
    }


    //
    // Special case for unaligned pointers (will fault on ppc/mips)
    //

    if (dwMod4)
    {
        DWORD   dwNumUnalignedBytes = 4 - dwMod4,
                dwNumBytesToShow = (dwNumUnalignedBytes > dwSize ?
                    dwSize : dwNumUnalignedBytes);


        ShowModBytes (dwNumBytesToShow, lpc, tabBuf, buf);
        lpc += dwNumUnalignedBytes;
        lpdw = (LPDWORD) lpc;
        dwSize -= dwNumBytesToShow;
    }
    else
    {
        lpdw = (LPDWORD) lp;
    }


    //
    // Dump full lines of four DWORDs in hex & corresponding ASCII
    //

    if (dwSize >= (4*sizeof(DWORD)))
    {
        dwNumDWORDs = dwSize / 4; // adjust from numBytes to num DWORDs

        for (i = 0; i < (dwNumDWORDs - (dwNumDWORDs%4)); i += 4)
        {
            sprintf (
                buf,
                "%s%08lx %08lx %08lx %08lx  ",
                tabBuf,
                *lpdw,
                *(lpdw+1),
                *(lpdw+2),
                *(lpdw+3)
                );

            k = strlen (buf);

            for (j = 0; j < 16; j++)
            {
                buf[k + j] = aAscii[*(lpc + j)];
            }

            buf[k + j] = 0;

            ShowStr (buf);
            lpdw += 4;
            lpc += 16;
        }
    }


    //
    // Special case for remaining bytes to dump (0 < n < 16)
    //

    if ((dwSize %= 16))
    {
        ShowModBytes (dwSize, lpc, tabBuf, buf);
    }


    UpdateResults (FALSE);
}


void
PASCAL
ShowFlags(
    DWORD       dwValue,
    char FAR    *pszValueName,
    PLOOKUP     pLookup
    )
{
    char     buf[80];
    DWORD    i;


    wsprintf (buf, "%s=x%lx, ", pszValueName, dwValue);

    for (i = 0; dwValue  &&  pLookup[i].lpszVal; i++)
    {
        if (dwValue & pLookup[i].dwVal)
        {
            if (buf[0] == 0)
            {
                lstrcpyA (buf, "    ");
            }

            lstrcatA (buf, pLookup[i].lpszVal);
            lstrcat (buf, " ");
            dwValue &= ~pLookup[i].dwVal;

            if (lstrlen (buf) > 50)
            {
                //
                // We don't want strings getting so long that
                // they're going offscreen, so break them up.
                //

                ShowStr (buf);
                buf[0] = 0;
            }
        }
    }

    if (dwValue)
    {
        lstrcat (buf, "<unknown flag(s)>");
    }

    if (buf[0])
    {
        ShowStr (buf);
    }
}


LPSTR
PASCAL
GetStringFromOrdinalValue(
    DWORD   dwValue,
    PLOOKUP pLookup
    )
{
    DWORD i;


    for (i = 0; pLookup[i].lpszVal  &&  dwValue != pLookup[i].dwVal; i++);
    return (pLookup[i].lpszVal ? pLookup[i].lpszVal : gszUnknown);
}


VOID
PASCAL
ShowGUID(
    char    *pszProlog,
    GUID    *pGuid
    )
{
    ShowStr(
        "%s%08x %04x %04x %02x%02x%02x%02x%02x%02x%02x%02x",
        (ULONG_PTR) pszProlog,
        (DWORD) pGuid->Data1,
        (DWORD) pGuid->Data2,
        (DWORD) pGuid->Data3,
        (DWORD) pGuid->Data4[0],
        (DWORD) pGuid->Data4[1],
        (DWORD) pGuid->Data4[2],
        (DWORD) pGuid->Data4[3],
        (DWORD) pGuid->Data4[4],
        (DWORD) pGuid->Data4[5],
        (DWORD) pGuid->Data4[6],
        (DWORD) pGuid->Data4[7]
        );

    //
    // Dump the GUID in a form that can be copied & pasted into other
    // API params
    //

    {
        LPBYTE p = (LPBYTE) pGuid;


        ShowStr(
            "    (%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x)",
            (DWORD) *p,
            (DWORD) *(p + 1),
            (DWORD) *(p + 2),
            (DWORD) *(p + 3),
            (DWORD) *(p + 4),
            (DWORD) *(p + 5),
            (DWORD) *(p + 6),
            (DWORD) *(p + 7),
            (DWORD) *(p + 8),
            (DWORD) *(p + 9),
            (DWORD) *(p + 10),
            (DWORD) *(p + 11),
            (DWORD) *(p + 12),
            (DWORD) *(p + 13),
            (DWORD) *(p + 14),
            (DWORD) *(p + 15)
            );
    }
}


VOID
PASCAL
ShowProtoInfo(
    LPWSAPROTOCOL_INFOA pInfo,
    DWORD               dwIndex,
    BOOL                bAscii
    )
{
    char szProtoInfoN[20], buf[40];


    if (dwIndex == 0xffffffff)
    {
        wsprintf (szProtoInfoN, "  protoInfo");
    }
    else
    {
        wsprintf (szProtoInfoN, "  protoInfo[%d].", dwIndex);
    }

    wsprintf (buf, "%sdwServiceFlags", szProtoInfoN);
    ShowFlags (pInfo->dwServiceFlags1, buf, aServiceFlags);

    ShowStr(
        "%sdwServiceFlags2=x%x",
        szProtoInfoN,
        pInfo->dwServiceFlags2
        );

    ShowStr(
        "%sdwServiceFlags3=x%x",
        szProtoInfoN,
        pInfo->dwServiceFlags3
        );

    ShowStr(
        "%sdwServiceFlags4=x%x",
        szProtoInfoN,
        pInfo->dwServiceFlags4
        );

    wsprintf (buf, "%sdwProviderFlags", szProtoInfoN);
    ShowFlags (pInfo->dwProviderFlags, buf, aProviderFlags);

    wsprintf (buf, "%sProviderId=", szProtoInfoN);
    ShowGUID (buf, &pInfo->ProviderId);

    ShowStr(
        "%sdwCatalogEntryId=x%x",
        szProtoInfoN,
        pInfo->dwCatalogEntryId
        );

    ShowStr(
        "%sProtocolChain.ChainLen=x%x",
        szProtoInfoN,
        (DWORD) pInfo->ProtocolChain.ChainLen
        );

    ShowStr(
        "%sProtocolChain.ChainEntries=",
        szProtoInfoN
        );

    ShowBytes(
        sizeof (DWORD) * MAX_PROTOCOL_CHAIN,
        pInfo->ProtocolChain.ChainEntries,
        2
        );

    ShowStr(
        "%siVersion=x%x",
        szProtoInfoN,
        (DWORD) pInfo->iVersion
        );

    ShowStr(
        "%siAddressFamily=%d, %s",
        szProtoInfoN,
        (DWORD) pInfo->iAddressFamily,
        GetStringFromOrdinalValue(
            (DWORD) pInfo->iAddressFamily,
            aAddressFamilies
            )
        );

    ShowStr(
        "%siMaxSockAddr=%d",
        szProtoInfoN,
        (DWORD) pInfo->iMaxSockAddr
        );

    ShowStr(
        "%siMinSockAddr=%d",
        szProtoInfoN,
        (DWORD) pInfo->iMinSockAddr
        );

    ShowStr(
        "%siSocketType=%d, %s",
        szProtoInfoN,
        (DWORD) pInfo->iSocketType,
        GetStringFromOrdinalValue(
            (DWORD) pInfo->iSocketType,
            aSocketTypes
            )
        );

    ShowStr(
        "%siProtocol=%d (x%x)", // ought to be flags???
        szProtoInfoN,
        (DWORD) pInfo->iProtocol,
        (DWORD) pInfo->iProtocol
        );

    ShowStr(
        "%siProtocolMaxOffset=%d",
        szProtoInfoN,
        (DWORD) pInfo->iProtocolMaxOffset
        );

    ShowStr(
        "%siNetworkByteOrder=%d, %s",
        szProtoInfoN,
        (DWORD) pInfo->iNetworkByteOrder,
        GetStringFromOrdinalValue(
            (DWORD) pInfo->iNetworkByteOrder,
            aNetworkByteOrders
            )
        );

    ShowStr(
        "%siSecurityScheme=x%x",
        szProtoInfoN,
        (DWORD) pInfo->iSecurityScheme
        );

    ShowStr(
        "%sdwMessageSize=x%x",
        szProtoInfoN,
        (DWORD) pInfo->dwMessageSize
        );

    ShowStr(
        "%sdwProviderReserved=x%x",
        szProtoInfoN,
        (DWORD) pInfo->dwMessageSize
        );

    if (bAscii)
    {
        ShowStr(
            "%sszProtocol=%s",
            szProtoInfoN,
            pInfo->szProtocol
            );

        ShowBytes(
            (lstrlenA (pInfo->szProtocol) + 1) * sizeof(CHAR),
            pInfo->szProtocol,
            2
            );
    }
    else
    {
        ShowStr(
            "%sszProtocol=%ws",
            szProtoInfoN,
            pInfo->szProtocol
            );

        ShowBytes(
            (lstrlenW (((LPWSAPROTOCOL_INFOW) pInfo)->szProtocol) + 1)
                * sizeof(WCHAR),
            pInfo->szProtocol,
            2
            );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\util\sockeye\vars.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1996  Microsoft Corporation

Module Name:

    vars.c

Abstract:

    Globals for winsock browser util.

Author:

    Dan Knudson (DanKn)    29-Jul-1996

Revision History:

--*/


#include <stdio.h>
#include "sockeye.h"
#include "wsipx.h"
#include "nspapi.h"

#ifdef WIN32
#define my_far
#else
#define my_far _far
#endif


FILE        *hLogFile = (FILE *) NULL;
HANDLE      ghInst;
HWND        ghwndMain, ghwndEdit, ghwndList1, ghwndList2, ghwndList3;
BOOL        bShowParams = FALSE;
BOOL        gbDisableHandleChecking;
LPBYTE      pBigBuf;
DWORD       dwBigBufSize;
BOOL        bDumpParams = FALSE;
BOOL        gbWideStringParams;
BOOL        bTimeStamp;
DWORD       dwDumpStructsFlags;

DWORD       aUserButtonFuncs[MAX_USER_BUTTONS];
char        aUserButtonsText[MAX_USER_BUTTONS][MAX_USER_BUTTON_TEXT_SIZE];

char my_far szTab[] = "  ";

char aAscii[] =
{
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
     48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
     64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
     80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
     96, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111,
    112,113,114,115,116,117,118,119,120,121,122,123,124,125,126, 46,

     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
     46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46
};


BYTE aHex[] =
{
    255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
    255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
    255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
      0,  1,  2,  3,  4,  5,  6,  7,  8,  9,255,255,255,255,255,255,
    255, 10, 11, 12, 13, 14, 15,255,255,255,255,255,255,255,255,255,
    255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
    255, 10, 11, 12, 13, 14, 15,255,255,255,255,255,255,255,255,255,
    255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
};

LOOKUP aAddressFamilies[] =
{
     { AF_UNSPEC                    ,"AF_UNSPEC"                },
     { AF_UNIX                      ,"AF_UNIX"                  },
     { AF_INET                      ,"AF_INET"                  },
     { AF_IMPLINK                   ,"AF_IMPLINK"               },
     { AF_PUP                       ,"AF_PUP"                   },
     { AF_CHAOS                     ,"AF_CHAOS"                 },
     { AF_NS                        ,"AF_NS (AF_IPX)"           },
     { AF_ISO                       ,"AF_ISO (AF_OSI)"          },
     { AF_ECMA                      ,"AF_ECMA"                  },
     { AF_DATAKIT                   ,"AF_DATAKIT"               },
     { AF_CCITT                     ,"AF_CCITT"                 },
     { AF_SNA                       ,"AF_SNA"                   },
     { AF_DECnet                    ,"AF_DECnet"                },
     { AF_DLI                       ,"AF_DLI"                   },
     { AF_LAT                       ,"AF_LAT"                   },
     { AF_HYLINK                    ,"AF_HYLINK"                },
     { AF_APPLETALK                 ,"AF_APPLETALK"             },
     { AF_NETBIOS                   ,"AF_NETBIOS"               },
     { AF_VOICEVIEW                 ,"AF_VOICEVIEW"             },
     { AF_FIREFOX                   ,"AF_FIREFOX"               },
     { AF_UNKNOWN1                  ,"AF_UNKNOWN1"              },
     { AF_BAN                       ,"AF_BAN"                   },
     { AF_ATM                       ,"AF_ATM"                   },
     { AF_INET6                     ,"AF_INET6"                 },
     { 0xffffffff                   ,NULL                       }
};

LOOKUP aIoctlCmds[] =
{
     { FIONBIO                      ,"FIONBIO"                  },
     { FIONREAD                     ,"FIONREAD"                 },
     { SIOCATMARK                   ,"SIOCATMARK"               },
     { 0xffffffff                   ,NULL                       }
};

LOOKUP aJLFlags[] =
{
     { JL_SENDER_ONLY               ,"JL_SENDER_ONLY"           },
     { JL_RECEIVER_ONLY             ,"JL_RECEIVER_ONLY"         },
     { JL_BOTH                      ,"JL_BOTH"                  },
     { 0xffffffff                   ,NULL                       }
};

LOOKUP aNameSpaces[] =
{
     { NS_ALL                       ,"NS_ALL"                   },
     { NS_SAP                       ,"NS_SAP"                   },
     { NS_NDS                       ,"NS_NDS"                   },
     { NS_PEER_BROWSE               ,"NS_PEER_BROWSE"           },
     { NS_TCPIP_LOCAL               ,"NS_TCPIP_LOCAL"           },
     { NS_TCPIP_HOSTS               ,"NS_TCPIP_HOSTS"           },
     { NS_DNS                       ,"NS_DNS"                   },
     { NS_NETBT                     ,"NS_NETBT"                 },
     { NS_WINS                      ,"NS_WINS"                  },
     { NS_NBP                       ,"NS_NBP"                   },
     { NS_MS                        ,"NS_MS"                    },
     { NS_STDA                      ,"NS_STDA"                  },
     { NS_NTDS                      ,"NS_NTDS"                 },
     { NS_X500                      ,"NS_X500"                  },
     { NS_NIS                       ,"NS_NIS"                   },
     { NS_NISPLUS                   ,"NS_NISPLUS"               },
     { NS_WRQ                       ,"NS_WRQ"                   },
     { 0xffffffff                   ,NULL                       }
};

LOOKUP aNetworkByteOrders[] =
{
     { BIGENDIAN                    ,"BIGENDIAN"                },
     { LITTLEENDIAN                 ,"LITTLEENDIAN"             },
     { 0xffffffff                   ,NULL                       }
};

LOOKUP aNetworkEvents[] =
{
     { FD_READ                      ,"FD_READ"                  },
     { FD_WRITE                     ,"FD_WRITE"                 },
     { FD_OOB                       ,"FD_OOB"                   },
     { FD_ACCEPT                    ,"FD_ACCEPT"                },
     { FD_CONNECT                   ,"FD_CONNECT"               },
     { FD_CLOSE                     ,"FD_CLOSE"                 },
     { FD_QOS                       ,"FD_QOS"                   },
     { FD_GROUP_QOS                 ,"FD_GROUP_QOS"             },
     { 0xffffffff                   ,NULL                       }
};

LOOKUP aProperties[] =
{
     { PROP_COMMENT                 ,"PROP_COMMENT     "        },
     { PROP_LOCALE                  ,"PROP_LOCALE      "        },
     { PROP_DISPLAY_HINT            ,"PROP_DISPLAY_HINT"        },
     { PROP_VERSION                 ,"PROP_VERSION     "        },
     { PROP_START_TIME              ,"PROP_START_TIME  "        },
     { PROP_MACHINE                 ,"PROP_MACHINE     "        },
     { PROP_ADDRESSES               ,"PROP_ADDRESSES   "        },
     { PROP_SD                      ,"PROP_SD          "        },
     { PROP_ALL                     ,"PROP_ALL         "        },
     { 0xffffffff                   ,NULL                       }
};

LOOKUP aProtocols[] =
{
     { IPPROTO_IP                   ,"IPPROTO_IP"               },
     { IPPROTO_ICMP                 ,"IPPROTO_ICMP"             },
     { IPPROTO_IGMP                 ,"IPPROTO_IGMP"             },
     { IPPROTO_GGP                  ,"IPPROTO_GGP"              },
     { IPPROTO_TCP                  ,"IPPROTO_TCP"              },
     { IPPROTO_PUP                  ,"IPPROTO_PUP"              },
     { IPPROTO_UDP                  ,"IPPROTO_UDP"              },
     { IPPROTO_IDP                  ,"IPPROTO_IDP"              },
     { IPPROTO_ND                   ,"IPPROTO_ND"               },
     { IPPROTO_RAW                  ,"IPPROTO_RAW"              },
     { IPPROTO_MAX                  ,"IPPROTO_MAX"              },
     { NSPROTO_IPX                  ,"NSPROTO_IPX"              },
     { NSPROTO_SPX                  ,"NSPROTO_SPX"              },
     { NSPROTO_SPXII                ,"NSPROTO_SPXII"            },
     { 0xffffffff                   ,NULL                       }
};

LOOKUP aProviderFlags[] =
{
     { PFL_MULTIPLE_PROTO_ENTRIES   ,"MULTIPLE_PROTO_ENTRIES"   },
     { PFL_RECOMMENDED_PROTO_ENTRY  ,"RECOMMENDED_PROTO_ENTRY"  },
     { PFL_HIDDEN                   ,"HIDDEN"                   },
     { PFL_MATCHES_PROTOCOL_ZERO    ,"MATCHES_PROTOCOL_ZERO"    },
     { 0xffffffff                   ,NULL                       }
};

LOOKUP aQOSServiceTypes[] =
{
     { SERVICETYPE_NOTRAFFIC            ,"NOTRAFFIC"            },
     { SERVICETYPE_BESTEFFORT           ,"BESTEFFORT"           },
     { SERVICETYPE_CONTROLLEDLOAD       ,"CONTROLLEDLOAD"       },
     { SERVICETYPE_GUARANTEED           ,"GUARANTEED"           },
     { SERVICETYPE_NETWORK_UNAVAILABLE  ,"NETWORK_UNAVAILABLE"  },
     { SERVICETYPE_GENERAL_INFORMATION  ,"GENERAL_INFORMATION"  },
     { SERVICETYPE_NOCHANGE             ,"NOCHANGE"             },
     { 0xffffffff                       ,NULL                   }
};

LOOKUP aRecvFlags[] =
{
     { MSG_PEEK                     ,"MSG_PEEK"                 },
     { MSG_OOB                      ,"MSG_OOB"                  },
     { 0xffffffff                   ,NULL                       }
};

LOOKUP aResDisplayTypes[] =
{
     { RESOURCEDISPLAYTYPE_GENERIC      ,"RESOURCEDISPLAYTYPE_GENERIC"      },
     { RESOURCEDISPLAYTYPE_DOMAIN       ,"RESOURCEDISPLAYTYPE_DOMAIN"       },
     { RESOURCEDISPLAYTYPE_SERVER       ,"RESOURCEDISPLAYTYPE_SERVER"       },
     { RESOURCEDISPLAYTYPE_SHARE        ,"RESOURCEDISPLAYTYPE_SHARE"        },
     { RESOURCEDISPLAYTYPE_FILE         ,"RESOURCEDISPLAYTYPE_FILE"         },
     { RESOURCEDISPLAYTYPE_GROUP        ,"RESOURCEDISPLAYTYPE_GROUP"        },
     { RESOURCEDISPLAYTYPE_NETWORK      ,"RESOURCEDISPLAYTYPE_NETWORK"      },
     { RESOURCEDISPLAYTYPE_ROOT         ,"RESOURCEDISPLAYTYPE_ROOT"         },
     { RESOURCEDISPLAYTYPE_SHAREADMIN   ,"RESOURCEDISPLAYTYPE_SHAREADMIN"   },
     { RESOURCEDISPLAYTYPE_DIRECTORY    ,"RESOURCEDISPLAYTYPE_DIRECTORY"    },
     { RESOURCEDISPLAYTYPE_TREE         ,"RESOURCEDISPLAYTYPE_TREE"         },
     { RESOURCEDISPLAYTYPE_NDSCONTAINER ,"RESOURCEDISPLAYTYPE_NDSCONTAINER" },
     { 0xffffffff                       ,NULL                               }
};

LOOKUP aResFlags[] =
{
     { RES_SERVICE                  ,"RES_SERVICE"              },
     { RES_FIND_MULTIPLE            ,"RES_FIND_MULTIPLE"        },
     { RES_SOFT_SEARCH              ,"RES_SOFT_SEARCH"          },
     { 0xffffffff                   ,NULL                       }
};

LOOKUP aSendFlags[] =
{
     { MSG_DONTROUTE                ,"MSG_DONTROUTE"            },
     { MSG_OOB                      ,"MSG_OOB"                  },
     { 0xffffffff                   ,NULL                       }
};

LOOKUP aShutdownOps[] =
{
     { SD_RECEIVE                   ,"SD_RECEIVE"               },
     { SD_SEND                      ,"SD_SEND"                  },
     { SD_BOTH                      ,"SD_BOTH"                  },
     { 0xffffffff                   ,NULL                       }
};

LOOKUP aSocketTypes[] =
{
     { SOCK_STREAM                  ,"SOCK_STREAM"              },
     { SOCK_DGRAM                   ,"SOCK_DGRAM"               },
     { SOCK_RAW                     ,"SOCK_RAW"                 },
     { SOCK_RDM                     ,"SOCK_RDM"                 },
     { SOCK_SEQPACKET               ,"SOCK_SEQPACKET"           },
     { 0xffffffff                   ,NULL                       }
};

LOOKUP aSockOptLevels[] =
{
     { SOL_SOCKET                   ,"SOL_SOCKET"               },
     { IPPROTO_TCP                  ,"IPPROTO_TCP"              },
     { 0xffffffff                   ,NULL                       }
};

LOOKUP aSockOpts[] =
{
     { SO_ACCEPTCONN                ,"SO_ACCEPTCONN"            },
     { SO_BROADCAST                 ,"SO_BROADCAST"             },
     { SO_DEBUG                     ,"SO_DEBUG"                 },
     { (DWORD) SO_DONTLINGER        ,"SO_DONTLINGER"            },
     { SO_DONTROUTE                 ,"SO_DONTROUTE"             },
     { SO_ERROR                     ,"SO_ERROR"                 },
     { SO_GROUP_ID                  ,"SO_GROUP_ID"              },
     { SO_GROUP_PRIORITY            ,"SO_GROUP_PRIORITY"        },
     { SO_KEEPALIVE                 ,"SO_KEEPALIVE"             },
     { SO_LINGER                    ,"SO_LINGER"                },
     { SO_MAX_MSG_SIZE              ,"SO_MAX_MSG_SIZE"          },
     { SO_OOBINLINE                 ,"SO_OOBINLINE"             },
     { SO_PROTOCOL_INFO             ,"SO_PROTOCOL_INFO"         },
     { SO_RCVBUF                    ,"SO_RCVBUF"                },
     { SO_REUSEADDR                 ,"SO_REUSEADDR"             },
     { SO_SNDBUF                    ,"SO_SNDBUF"                },
     { SO_TYPE                      ,"SO_TYPE"                  },
     { PVD_CONFIG                   ,"PVD_CONFIG"               },

     { TCP_NODELAY                  ,"TCP_NODELAY"              },
     { 0xffffffff                   ,NULL                       }
};

LOOKUP aServiceFlags[] =
{
     { XP1_CONNECTIONLESS           ,"CONNECTIONLESS"           },
     { XP1_GUARANTEED_DELIVERY      ,"GUARANTEED_DELIVERY"      },
     { XP1_GUARANTEED_ORDER         ,"GUARANTEED_ORDER"         },
     { XP1_MESSAGE_ORIENTED         ,"MESSAGE_ORIENTED"         },
     { XP1_PSEUDO_STREAM            ,"PSEUDO_STREAM"            },
     { XP1_GRACEFUL_CLOSE           ,"GRACEFUL_CLOSE"           },
     { XP1_EXPEDITED_DATA           ,"EXPEDITED_DATA"           },
     { XP1_CONNECT_DATA             ,"CONNECT_DATA"             },
     { XP1_DISCONNECT_DATA          ,"DISCONNECT_DATA"          },
     { XP1_SUPPORT_BROADCAST        ,"SUPPORT_BROADCAST"        },
     { XP1_SUPPORT_MULTIPOINT       ,"SUPPORT_MULTIPOINT"       },
     { XP1_MULTIPOINT_CONTROL_PLANE ,"MULTIPOINT_CONTROL_PLANE" },
     { XP1_MULTIPOINT_DATA_PLANE    ,"MULTIPOINT_DATA_PLANE"    },
     { XP1_QOS_SUPPORTED            ,"QOS_SUPPORTED"            },
     { XP1_INTERRUPT                ,"INTERRUPT"                },
     { XP1_UNI_SEND                 ,"UNI_SEND"                 },
     { XP1_UNI_RECV                 ,"UNI_RECV"                 },
     { XP1_IFS_HANDLES              ,"IFS_HANDLES"              },
     { XP1_PARTIAL_MESSAGE          ,"PARTIAL_MESSAGE"          },
     { 0xffffffff                   ,NULL                       }
};

LOOKUP aServiceOps[] =
{
     { SERVICE_REGISTER             ,"SERVICE_REGISTER"         },
     { SERVICE_DEREGISTER           ,"SERVICE_DEREGISTER"       },
     { SERVICE_FLUSH                ,"SERVICE_FLUSH"            },
     { SERVICE_ADD_TYPE             ,"SERVICE_ADD_TYPE"         },
     { SERVICE_DELETE_TYPE          ,"SERVICE_DELETE_TYPE"      },
     { 0xffffffff                   ,NULL                       }
};

LOOKUP aSvcFlags[] =
{
     { SERVICE_FLAG_DEFER           ,"SERVICE_FLAG_DEFER"       },
     { SERVICE_FLAG_HARD            ,"SERVICE_FLAG_HARD"        },
     { 0xffffffff                   ,NULL                       }
};

LOOKUP aWSAFlags[] =
{
     { WSA_FLAG_OVERLAPPED          ,"OVERLAPPED"               },
     { WSA_FLAG_MULTIPOINT_C_ROOT   ,"MULTIPOINT_C_ROOT"        },
     { WSA_FLAG_MULTIPOINT_C_LEAF   ,"MULTIPOINT_C_LEAF"        },
     { WSA_FLAG_MULTIPOINT_D_ROOT   ,"MULTIPOINT_D_ROOT"        },
     { WSA_FLAG_MULTIPOINT_D_LEAF   ,"MULTIPOINT_D_LEAF"        },
     { 0xffffffff                   ,NULL                       }
};

LOOKUP aWSAIoctlCmds[] =
{
     { FIONBIO                      ,"FIONBIO"                  },
     { FIONREAD                     ,"FIONREAD"                 },
     { SIOCATMARK                   ,"SIOCATMARK"               },
     { SIO_ASSOCIATE_HANDLE         ,"SIO_ASSOCIATE_HANDLE"     },
     { SIO_ENABLE_CIRCULAR_QUEUEING ,"SIO_ENABLE_CIRCULAR_QUEUEING" },
     { SIO_FIND_ROUTE               ,"SIO_FIND_ROUTE"           },
     { SIO_FLUSH                    ,"SIO_FLUSH"                },
     { SIO_GET_BROADCAST_ADDRESS    ,"SIO_GET_BROADCAST_ADDRESS" },
     { SIO_GET_EXTENSION_FUNCTION_POINTER
                                    ,"SIO_GET_EXTENSION_FUNCTION_POINTER" },
     { SIO_GET_QOS                  ,"SIO_GET_QOS"              },
     { SIO_GET_GROUP_QOS            ,"SIO_GET_GROUP_QOS"        },
     { SIO_MULTIPOINT_LOOPBACK      ,"SIO_MULTIPOINT_LOOPBACK"  },
     { SIO_MULTICAST_SCOPE          ,"SIO_MULTICAST_SCOPE"      },
     { SIO_SET_QOS                  ,"SIO_SET_QOS"              },
     { SIO_SET_GROUP_QOS            ,"SIO_SET_GROUP_QOS"        },
     { SIO_TRANSLATE_HANDLE         ,"SIO_TRANSLATE_HANDLE"     },
     { 0xffffffff                   ,NULL                       }
};

LOOKUP aWSARecvFlags[] =
{
     { MSG_PEEK                     ,"MSG_PEEK"                 },
     { MSG_OOB                      ,"MSG_OOB"                  },
     { MSG_PARTIAL                  ,"MSG_PARTIAL"              },
     { 0xffffffff                   ,NULL                       }
};

LOOKUP aWSASendFlags[] =
{
     { MSG_DONTROUTE                ,"MSG_DONTROUTE"            },
     { MSG_OOB                      ,"MSG_OOB"                  },
     { MSG_PARTIAL                  ,"MSG_PARTIAL"              },
     { 0xffffffff                   ,NULL                       }
};

LOOKUP aWSASendAndRecvFlags[] =
{
     { MSG_PEEK                     ,"MSG_PEEK"                 },
     { MSG_DONTROUTE                ,"MSG_DONTROUTE"            },
     { MSG_OOB                      ,"MSG_OOB"                  },
     { MSG_PARTIAL                  ,"MSG_PARTIAL"              },
     { 0xffffffff                   ,NULL                       }
};

LOOKUP aWSAErrors[] =
{
    { WSAEINTR                      ,"WSAEINTR"                 },
    { WSAEBADF                      ,"WSAEBADF"                 },
    { WSAEACCES                     ,"WSAEACCES"                },
    { WSAEFAULT                     ,"WSAEFAULT"                },
    { WSAEINVAL                     ,"WSAEINVAL"                },
    { WSAEMFILE                     ,"WSAEMFILE"                },

    { WSAEWOULDBLOCK                ,"WSAEWOULDBLOCK"           },
    { WSAEINPROGRESS                ,"WSAEINPROGRESS"           },
    { WSAEALREADY                   ,"WSAEALREADY"              },
    { WSAENOTSOCK                   ,"WSAENOTSOCK"              },
    { WSAEDESTADDRREQ               ,"WSAEDESTADDRREQ"          },
    { WSAEMSGSIZE                   ,"WSAEMSGSIZE"              },
    { WSAEPROTOTYPE                 ,"WSAEPROTOTYPE"            },
    { WSAENOPROTOOPT                ,"WSAENOPROTOOPT"           },
    { WSAEPROTONOSUPPORT            ,"WSAEPROTONOSUPPORT"       },
    { WSAESOCKTNOSUPPORT            ,"WSAESOCKTNOSUPPORT"       },
    { WSAEOPNOTSUPP                 ,"WSAEOPNOTSUPP"            },
    { WSAEPFNOSUPPORT               ,"WSAEPFNOSUPPORT"          },
    { WSAEAFNOSUPPORT               ,"WSAEAFNOSUPPORT"          },
    { WSAEADDRINUSE                 ,"WSAEADDRINUSE"            },
    { WSAEADDRNOTAVAIL              ,"WSAEADDRNOTAVAIL"         },
    { WSAENETDOWN                   ,"WSAENETDOWN"              },
    { WSAENETUNREACH                ,"WSAENETUNREACH"           },
    { WSAENETRESET                  ,"WSAENETRESET"             },
    { WSAECONNABORTED               ,"WSAECONNABORTED"          },
    { WSAECONNRESET                 ,"WSAECONNRESET"            },
    { WSAENOBUFS                    ,"WSAENOBUFS"               },
    { WSAEISCONN                    ,"WSAEISCONN"               },
    { WSAENOTCONN                   ,"WSAENOTCONN"              },
    { WSAESHUTDOWN                  ,"WSAESHUTDOWN"             },
    { WSAETOOMANYREFS               ,"WSAETOOMANYREFS"          },
    { WSAETIMEDOUT                  ,"WSAETIMEDOUT"             },
    { WSAECONNREFUSED               ,"WSAECONNREFUSED"          },
    { WSAELOOP                      ,"WSAELOOP"                 },
    { WSAENAMETOOLONG               ,"WSAENAMETOOLONG"          },
    { WSAEHOSTDOWN                  ,"WSAEHOSTDOWN"             },
    { WSAEHOSTUNREACH               ,"WSAEHOSTUNREACH"          },
    { WSAENOTEMPTY                  ,"WSAENOTEMPTY"             },
    { WSAEPROCLIM                   ,"WSAEPROCLIM"              },
    { WSAEUSERS                     ,"WSAEUSERS"                },
    { WSAEDQUOT                     ,"WSAEDQUOT"                },
    { WSAESTALE                     ,"WSAESTALE"                },
    { WSAEREMOTE                    ,"WSAEREMOTE"               },

    { WSASYSNOTREADY                ,"WSASYSNOTREADY"           },
    { WSAVERNOTSUPPORTED            ,"WSAVERNOTSUPPORTED"       },
    { WSANOTINITIALISED             ,"WSANOTINITIALISED"        },
    { WSAEDISCON                    ,"WSAEDISCON"               },
    { WSAENOMORE                    ,"WSAENOMORE"               },
    { WSAECANCELLED                 ,"WSAECANCELLED"            },
    { WSAEINVALIDPROCTABLE          ,"WSAEINVALIDPROCTABLE"     },
    { WSAEINVALIDPROVIDER           ,"WSAEINVALIDPROVIDER"      },
    { WSAEPROVIDERFAILEDINIT        ,"WSAEPROVIDERFAILEDINIT"   },
    { WSASYSCALLFAILURE             ,"WSASYSCALLFAILURE"        },
    { WSASERVICE_NOT_FOUND          ,"WSASERVICE_NOT_FOUND"     },
    { WSATYPE_NOT_FOUND             ,"WSATYPE_NOT_FOUND"        },
    { WSA_E_NO_MORE                 ,"WSA_E_NO_MORE"            },
    { WSA_E_CANCELLED               ,"WSA_E_CANCELLED"          },
    { WSAEREFUSED                   ,"WSAEREFUSED"              },

    { WSAHOST_NOT_FOUND             ,"WSAHOST_NOT_FOUND"        },
    { WSATRY_AGAIN                  ,"WSATRY_AGAIN"             },
    { WSANO_RECOVERY                ,"WSANO_RECOVERY"           },
    { WSANO_DATA                    ,"WSANO_DATA"               },
#ifdef WIN32
    { WSA_IO_PENDING                ,"WSA_IO_PENDING"           },
    { WSA_IO_INCOMPLETE             ,"WSA_IO_INCOMPLETE"        },
    { WSA_INVALID_HANDLE            ,"WSA_INVALID_HANDLE"       },
    { WSA_INVALID_PARAMETER         ,"WSA_INVALID_PARAMETER"    },
    { WSA_NOT_ENOUGH_MEMORY         ,"WSA_NOT_ENOUGH_MEMORY"    },
    { WSA_OPERATION_ABORTED         ,"WSA_OPERATION_ABORTED"    },

    { 0                             ,"WSA_INVALID_EVENT"        },
    { WSA_MAXIMUM_WAIT_EVENTS       ,"WSA_MAXIMUM_WAIT_EVENTS"  },
    { WSA_WAIT_FAILED               ,"WSA_WAIT_FAILED"          },
//    { WSA_WAIT_EVENT_0              ,"WSA_WAIT_EVENT_0"         },
    { WSA_WAIT_IO_COMPLETION        ,"WSA_WAIT_IO_COMPLETION"   },
    { WSA_WAIT_TIMEOUT              ,"WSA_WAIT_TIMEOUT"         },
    { WSA_INFINITE                  ,"WSA_INFINITE"             },
#else /* WIN16 */
    { WSA_IO_PENDING                ,"WSA_IO_PENDING"           },
    { WSA_IO_INCOMPLETE             ,"WSA_IO_INCOMPLETE"        },
    { WSA_INVALID_HANDLE            ,"WSA_INVALID_HANDLE"       },
    { WSA_INVALID_PARAMETER         ,"WSA_INVALID_PARAMETER"    },
    { WSA_NOT_ENOUGH_MEMORY         ,"WSA_NOT_ENOUGH_MEMORY"    },
    { WSA_OPERATION_ABORTED         ,"WSA_OPERATION_ABORTED"    },
                                    ,"
    { (DWORD) WSA_INVALID_EVENT     ,"WSA_INVALID_EVENT"        },
    { WSA_MAXIMUM_WAIT_EVENTS       ,"WSA_MAXIMUM_WAIT_EVENTS"  },
    { WSA_WAIT_FAILED               ,"WSA_WAIT_FAILED"          },
//    { WSA_WAIT_EVENT_0              ,"WSA_WAIT_EVENT_0"         },
    { WSA_WAIT_TIMEOUT              ,"WSA_WAIT_TIMEOUT"         },
    { WSA_INFINITE                  ,"WSA_INFINITE"             },

    { ERROR_INSUFFICIENT_BUFFER,    ,"ERROR_INSUFFICIENT_BUFFER" },

#endif
    { 0                             ,NULL                       }
};


char *aFuncNames[] =
{
    "accept",
    "bind",
    "closesocket",
    "connect",
    "gethostbyaddr",
    "gethostbyname",
    "gethostname",
    "getpeername",
    "getprotobyname",
    "getprotobynumber",
    "getservbyname",
    "getservbyport",
    "getsockname",
    "getsockopt",
    "htonl",
    "htons",
    "inet_addr",
    "inet_ntoa",
    "ioctlsocket",
    "listen",
    "ntohl",
    "ntohs",
    "recv",
    "recvfrom",
    "//select",
    "send",
    "sendto",
    "setsockopt",
    "shutdown",
    "socket",
    "WSAAccept",
    "WSAAddressToStringA",
    "WSAAddressToStringW",
    "WSAAsyncGetHostByAddr",
    "WSAAsyncGetHostByName",
    "WSAAsyncGetProtoByName",
    "WSAAsyncGetProtoByNumber",
    "WSAAsyncGetServByName",
    "WSAAsyncGetServByPort",
    "WSAAsyncSelect",
    "WSACancelAsyncRequest",
//    "WSACancelBlockingCall",
    "WSACleanup",
    "WSACloseEvent",
    "WSAConnect",
    "WSACreateEvent",
    "WSADuplicateSocketA",
    "WSADuplicateSocketW",
    "WSAEnumNameSpaceProvidersA",
    "WSAEnumNameSpaceProvidersW",
    "WSAEnumNetworkEvents",
    "WSAEnumProtocolsA",
    "WSAEnumProtocolsW",
    "WSAEventSelect",
    "WSAGetLastError",
    "WSAGetOverlappedResult",
    "WSAGetQOSByName",
    "WSAGetServiceClassInfoA",
    "WSAGetServiceClassInfoW",
    "WSAGetServiceClassNameByClassIdA",
    "WSAGetServiceClassNameByClassIdW",
    "WSAHtonl",
    "WSAHtons",
    "//WSAInstallServiceClassA",
    "//WSAInstallServiceClassW",
    "WSAIoctl",
//    "WSAIsBlocking",
    "WSAJoinLeaf",
    "//WSALookupServiceBeginA",
    "//WSALookupServiceBeginW",
    "WSALookupServiceEnd",
    "WSALookupServiceNextA",
    "WSALookupServiceNextW",
    "WSANtohl",
    "WSANtohs",
    "WSARecv",
    "WSARecvDisconnect",
    "WSARecvFrom",
    "WSARemoveServiceClass",
    "WSAResetEvent",
    "WSASend",
    "WSASendDisconnect",
    "WSASendTo",
//    "WSASetBlockingHook",
    "WSASetEvent",
    "WSASetLastError",
    "//WSASetServiceA",
    "//WSASetServiceW",
    "WSASocketA",
    "WSASocketW",
    "WSAStartup",
    "WSAStringToAddressA",
    "WSAStringToAddressW",
//    "WSAUnhookBlockingHook",
    "//WSAWaitForMultipleEvents",

    "WSCEnumProtocols",
    "WSCGetProviderPath",

    "EnumProtocolsA",
    "EnumProtocolsW",
    "GetAddressByNameA",
    "GetAddressByNameW",
    "GetNameByTypeA",
    "GetNameByTypeW",
    "GetServiceA",
    "GetServiceW",
    "GetTypeByNameA",
    "GetTypeByNameW",
    "SetServiceA",
    "SetServiceW",

//    "Close handle (comm, etc)",
//    "Dump buffer contents",
    NULL,
    "Default values",
    "WSAPROTOCOL_INFO",
    "QOS",
    NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\util\sporder\exe\globals.h ===
#include <commctrl.h>


//
// Global variables
//

extern HINSTANCE ghInst;
extern int listTabs[];
extern int gNumRows;


//
// Function prototypes
//

LRESULT CALLBACK EnumDlgProc     (HWND, UINT, WPARAM, LPPROPSHEETPAGE);
LRESULT CALLBACK SortDlgProc     (HWND, UINT, WPARAM, LPPROPSHEETPAGE);
INT_PTR CALLBACK MoreInfoDlgProc (HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK RNRDlgProc      (HWND, UINT, WPARAM, LPARAM);

int CatReadRegistry    (HWND);
int CatDoMoreInfo      (HWND, int);
int CatDoWriteEntries  (HWND);
int CatCheckRegErrCode (HWND, LONG, LPTSTR);
int CatDoUpDown        (HWND, WPARAM);
BOOL CatGetIndex (LPTSTR, LPINT, LPINT);


//
// Constant defines
//

#define DID_HEADERCTL  501
#define DID_LISTCTL    502
#define DID_UP         503
#define DID_DOWN       504
#define DID_MORE       505

#define DID_ENUM       700
#define DID_WSAENUM    701

#define TOTAL_TABS 10

#define MAX_STR 256


//
// Helpful macros
//

//
// In the context of a dialog box with a child listbox id==DID_LISTCTL...
//
#define ADDSTRING(x)   SendMessage (GetDlgItem (hwnd, DID_LISTCTL), LB_ADDSTRING, 0 ,(LPARAM) x)
#define HWNDLISTCTL    GetDlgItem (hwnd, DID_LISTCTL)

#define ASSERT(X,Y) if (!X) MessageBox (NULL, Y, TEXT("ASSERT"), MB_OK);

#define XBORDER   GetSystemMetrics (SM_CXSIZEFRAME) *3/2
#define YBORDER   GetSystemMetrics (SM_CYSIZEFRAME) *3/2
#define HDRHEIGHT GetSystemMetrics (SM_CYMENU)


//
// Simple debug output routine that becomes no-op when ndef DEBUG
//

#ifdef DEBUG
#else
#endif

#if DBG

#define DBGOUT(arg) DbgPrint arg

void
_cdecl
DbgPrint(
    PTCH Format,
    ...
    );

#else

#define DBGOUT(arg)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\util\sporder\exe\catentry.c ===
/*++

Copyright (c) 1995-1996 Microsoft Corporation

Module Name:

    catentry

Abstract:

    Read & write the relevant registry entries.

Author:

    Steve Firebaugh (stevefir)         14-Jan-1995

Revision History:

--*/


#include <windows.h>
#include <commdlg.h>
#include <winsock2.h>
#include <nspapi.h>
#include <stdio.h>

#include "ws2spi.h"
#include "sporder.h"
#include "globals.h"




#define MAX_ENTRIES 1000 // hack, make dynamic
WSAPROTOCOL_INFOW ProtoInfo[MAX_ENTRIES];

//
//  keep track of the total number of entries in the list box;
//

int gNumRows = 0;





int CatReadRegistry (HWND hwnd)
/*++

  Called once when the dialog first comes up.  Read the registry and fill
   the listbox with all of the entries.

--*/
{
    TCHAR szOutput[MAX_STR];
    TCHAR szInput[MAX_STR];
    TCHAR szBuffer[MAX_STR];
    LONG r;
    INT iIndex;
    DWORD dwSize;

    //
    // set a tab stop far off of the screen, so that we can store the original
    //  index there, and it will stay glued to the string even as the user
    //  reorders them (unless we are building a debug).
    //


#ifndef DEBUG
    {
    int iTab;

    iTab = 300;
    SendMessage (HWNDLISTCTL, LB_SETTABSTOPS, 1, (LPARAM) &iTab);
    }
#endif

    dwSize = sizeof (ProtoInfo);
    gNumRows = WSCEnumProtocols (NULL, ProtoInfo, &dwSize, &r);
    if (gNumRows==SOCKET_ERROR) {
        CatCheckRegErrCode (hwnd, r, TEXT("WSCEnumProtocols"));
        return FALSE;
    }

    for (iIndex = 0; iIndex<gNumRows ;iIndex++) {
        //
        // Now format a string for display in the list box.  Notice that
        //  we sneak an index in to the far right (not visible) to track
        //  the string's initial position (for purposes of mapping it to
        //  the gdwCatEntries later) regardless of re-ordering.
        //

        wsprintf (szBuffer,
                  TEXT("%ws \t%d \t%d"),
                  &ProtoInfo[iIndex].szProtocol,
                  iIndex,
                  ProtoInfo[iIndex].dwCatalogEntryId);
        ADDSTRING(szBuffer);




    } // end for

    return TRUE;
}



int CatDoMoreInfo (HWND hwnd, int iSelection)
/*++

  Given a dialog handle, and an index into our global array of catalog entries,
   fill a listbox with all of the information that we know about it.

--*/
{
    TCHAR szBuffer[MAX_STR];
    WCHAR szDllName[MAX_PATH];
    int iTab;
    int r;
    DWORD dwSize;
    BYTE pb[16];

    //
    // pick an arbitraty tab number that is far enough to the right to clear
    //  most of the long strings.
    //

    iTab = 90;
    SendMessage (HWNDLISTCTL, LB_SETTABSTOPS, 1, (LPARAM) &iTab);

    dwSize = sizeof (szDllName);
    if (WSCGetProviderPath (&ProtoInfo[iSelection].ProviderId, 
                                szDllName, 
                                &dwSize, 
                                &r)==SOCKET_ERROR) {
        CatCheckRegErrCode (hwnd, r, TEXT("WSCGetProviderPath"));
        return FALSE;
    }

    wsprintf (szBuffer, TEXT("LibraryPath \t%ls"), szDllName);       ADDSTRING (szBuffer);

    wsprintf (szBuffer, TEXT("dwServiceFlags1 \t0x%x"), ProtoInfo[iSelection].dwServiceFlags1);       ADDSTRING (szBuffer);
    wsprintf (szBuffer, TEXT("dwServiceFlags2 \t0x%x"), ProtoInfo[iSelection].dwServiceFlags2);       ADDSTRING (szBuffer);
    wsprintf (szBuffer, TEXT("dwServiceFlags3 \t0x%x"), ProtoInfo[iSelection].dwServiceFlags3);       ADDSTRING (szBuffer);
    wsprintf (szBuffer, TEXT("dwServiceFlags4 \t0x%x"), ProtoInfo[iSelection].dwServiceFlags4);       ADDSTRING (szBuffer);
    wsprintf (szBuffer, TEXT("dwProviderFlags \t0x%x"), ProtoInfo[iSelection].dwProviderFlags);       ADDSTRING (szBuffer);

    //
    // format GUID for display.  do byte swapping to match expected format
    //

    memcpy (pb, (PBYTE) &(ProtoInfo[iSelection].ProviderId), sizeof (GUID));

    wsprintf (szBuffer,
              TEXT("ProviderId \t%02x%02x%02x%02x - %02x%02x - %02x%02x - %02x%02x - %02x%02x%02x%02x%02x%02x"),
              (BYTE)pb[3],
              (BYTE)pb[2],
              (BYTE)pb[1],
              (BYTE)pb[0],
              (BYTE)pb[5],
              (BYTE)pb[4],
              (BYTE)pb[7],
              (BYTE)pb[6],
              (BYTE)pb[8],
              (BYTE)pb[9],
              (BYTE)pb[10],
              (BYTE)pb[11],
              (BYTE)pb[12],
              (BYTE)pb[13],
              (BYTE)pb[14],
              (BYTE)pb[15] );
              ADDSTRING (szBuffer);

    wsprintf (szBuffer, TEXT("dwCatalogEntryId \t0x%x"), ProtoInfo[iSelection].dwCatalogEntryId);       ADDSTRING (szBuffer);
    wsprintf (szBuffer, TEXT("ProtocolChain.ChainLen \t%d"), ProtoInfo[iSelection].ProtocolChain.ChainLen); ADDSTRING (szBuffer);

    wsprintf (szBuffer, TEXT("iVersion       \t0x%x"), ProtoInfo[iSelection].iVersion);       ADDSTRING (szBuffer);
    wsprintf (szBuffer, TEXT("iAddressFamily \t0x%x"), ProtoInfo[iSelection].iAddressFamily); ADDSTRING (szBuffer);
    wsprintf (szBuffer, TEXT("iMaxSockAddr   \t0x%x"), ProtoInfo[iSelection].iMaxSockAddr);   ADDSTRING (szBuffer);
    wsprintf (szBuffer, TEXT("iMinSockAddr   \t0x%x"), ProtoInfo[iSelection].iMinSockAddr);   ADDSTRING (szBuffer);
    wsprintf (szBuffer, TEXT("iSocketType    \t0x%x"), ProtoInfo[iSelection].iSocketType);    ADDSTRING (szBuffer);
    wsprintf (szBuffer, TEXT("iProtocol      \t0x%x"), ProtoInfo[iSelection].iProtocol);      ADDSTRING (szBuffer);
    wsprintf (szBuffer, TEXT("iProtocolMaxOffset \t0x%x"), ProtoInfo[iSelection].iProtocolMaxOffset);      ADDSTRING (szBuffer);

    wsprintf (szBuffer, TEXT("iNetworkByteOrder      \t0x%x"), ProtoInfo[iSelection].iNetworkByteOrder);      ADDSTRING (szBuffer);
    wsprintf (szBuffer, TEXT("iSecurityScheme      \t0x%x"), ProtoInfo[iSelection].iSecurityScheme);      ADDSTRING (szBuffer);
    wsprintf (szBuffer, TEXT("dwMessageSize      \t0x%x"), ProtoInfo[iSelection].dwMessageSize);      ADDSTRING (szBuffer);
    wsprintf (szBuffer, TEXT("dwProviderReserved      \t0x%x"), ProtoInfo[iSelection].dwProviderReserved);      ADDSTRING (szBuffer);

    wsprintf (szBuffer, TEXT("szProtocol \t%ws"), &ProtoInfo[iSelection].szProtocol);       ADDSTRING (szBuffer);

    return TRUE;
}



int  CatDoWriteEntries (HWND hwnd)
/*++

  Here we step through all of the entries in the list box, check to see if
   it is out of order, and if it is, write data to the registry key in that
   position.

--*/
{
    TCHAR szBuffer[MAX_STR];
    int iRegKey;
    int iIndex;
    int iCatID;

    LONG r;

    DWORD lpdwCatID[MAX_ENTRIES];

    //
    // Step through all of the registry keys (catalog entries).
    //  and build array of catalog IDs to be passed to function in sporder.dll
    //

    for (iRegKey = 0; iRegKey < gNumRows; iRegKey++ ) {

        SendMessage (HWNDLISTCTL, LB_GETTEXT, iRegKey, (LPARAM) szBuffer);

        ASSERT (CatGetIndex (szBuffer, &iIndex, &iCatID),
                TEXT("CatDoWriteEntries, CatGetIndex failed."));

        //
        // build array of CatalogIDs
        //

        lpdwCatID[iRegKey] = iCatID;

    } // for


    r = WSCWriteProviderOrder (lpdwCatID, gNumRows);
    CatCheckRegErrCode (hwnd, r, TEXT("WSCWriteProviderOrder"));
    return r;
}






int CatCheckRegErrCode (HWND hwnd, LONG r, LPTSTR lpstr)
/*++

  Centralize checking the return code for Registry functions.
   Here we report the error if any with as helpful a message as we can.

--*/
{
    static TCHAR szTitle[] = TEXT("Registry error in service provider tool.");
    TCHAR szBuffer[MAX_STR];

    switch (r) {
        case ERROR_SUCCESS: return TRUE;
        break;

        case ERROR_ACCESS_DENIED : {
            lstrcpy (szBuffer, TEXT("ERROR_ACCESS_DENIED\n"));
            lstrcat (szBuffer, TEXT("You do not have the necessary privilege to call:\n"));
            lstrcat (szBuffer, lpstr);
            lstrcat (szBuffer, TEXT("\nLogon as Administrator."));

            MessageBox (hwnd, szBuffer, szTitle, MB_ICONSTOP | MB_OK);
            return FALSE;
        } break;

        //
        // As Keith & Intel change the registry format, they rename keys
        //  to avoid backward compatibility problems.  If we can't find
        //  the registry key, it is likely this EXE old and running against
        //  a new (incompatible) version of ws2.
        //

        case ERROR_FILE_NOT_FOUND : {
            lstrcpy (szBuffer, TEXT("ERROR_FILE_NOT_FOUND\n"));
            lstrcat (szBuffer, TEXT("You probably need an updated version of this tool.\n"));
            lstrcat (szBuffer, lpstr);

            MessageBox (hwnd, szBuffer, szTitle, MB_ICONSTOP | MB_OK);
            return FALSE;
        } break;


        case WSAEINVAL: {
            lstrcpy (szBuffer, TEXT("WinSock2 Registry format doesn't match \n"));
            lstrcat (szBuffer, TEXT("sporder [exe/dll]. You need updated tools. \n"));
            lstrcat (szBuffer, lpstr);

            MessageBox (hwnd, szBuffer, szTitle, MB_ICONSTOP | MB_OK);
            return FALSE;
        } break;


        default: {
            FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM,
                           NULL,
                           r,
                           GetUserDefaultLangID(),
                           szBuffer,
                           sizeof (szBuffer),
                           0);

            lstrcat (szBuffer, TEXT("\n"));
            lstrcat (szBuffer, lpstr);
            MessageBox (hwnd, szBuffer, szTitle, MB_ICONSTOP | MB_OK);
            return FALSE;
        } break;

    }
    return TRUE;
}



int CatDoUpDown (HWND hwnd, WPARAM wParam)
/*++

  Given a dialog handle, and an up/down identifier, remove the entry, and
   reinsert it either one position up or down.

--*/
{
    TCHAR szBuffer[MAX_STR];
    DWORD iSelection;

    iSelection = (DWORD)SendMessage (HWNDLISTCTL, LB_GETCURSEL, 0, 0);

    if (iSelection != LB_ERR) {

        //
        // Read the current selecte string, delete the current selection, ...
        //

        SendMessage (HWNDLISTCTL, LB_GETTEXT, iSelection, (LPARAM)szBuffer);
        SendMessage (HWNDLISTCTL, LB_DELETESTRING, iSelection, 0);

        //
        // Adjust the position up or down by one, and make sure we are
        //  still clipped to within the valid range.
        //

        if (wParam == DID_UP) iSelection--;
        else iSelection++;

        if ((int) iSelection < 0) iSelection = 0 ;
        if ((int) iSelection >= gNumRows) iSelection = gNumRows-1 ;

        //
        // Re-insert the string and restore the selection
        //

        SendMessage (HWNDLISTCTL, LB_INSERTSTRING, iSelection, (LPARAM)szBuffer);
        SendMessage (HWNDLISTCTL, LB_SETCURSEL, iSelection, 0);
    }
    return TRUE;
}




BOOL CatGetIndex (LPTSTR szBuffer, LPINT lpIndex, LPINT lpCatID)
/*++

  The original index is stored after a tab stop, hidden from view far off
   screen to the right.  Parse the string for the tab stop, and read the
   next value.  The catalog ID is stored to the right of the index.


--*/
{
    int r;
    TCHAR *p;

    //
    // To get the index, start at the begining of the string, parse
    //  it for tokens based on tab as a separator, and take the
    //  second one.
    //

#ifdef UNICODE
    p = wcstok (szBuffer, TEXT("\t"));
    p = wcstok (NULL, TEXT("\t"));
    r = swscanf (p, TEXT("%d"), lpIndex);
    ASSERT((r == 1), TEXT("#1 ASSERT r == 1"))
    p = wcstok (NULL, TEXT("\t"));
    r = swscanf (p, TEXT("%d"), lpCatID);
    ASSERT((r == 1), TEXT("#2 ASSERT r == 1"))
#else
    p = strtok (szBuffer, TEXT("\t"));
    p = strtok (NULL, TEXT("\t"));
    r = sscanf (p, TEXT("%d"), lpIndex);
    ASSERT((r == 1), TEXT("#1 ASSERT r == 1"))
    p = strtok (NULL, TEXT("\t"));
    r = sscanf (p, TEXT("%d"), lpCatID);
    ASSERT((r == 1), TEXT("#2 ASSERT r == 1"))
#endif

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\util\sporder\exe\main.c ===
/*++

Copyright (c) 1995-1996 Microsoft Corporation

Module Name:

    main

Abstract:

    Trivial WinMain() function, creates tabbed dialog "property pages"
    and then creates the dialog... interesting code is in dialog procedures.

Author:

    Steve Firebaugh (stevefir)         31-Dec-1995

Revision History:

    SPORDER.EXE, DLL, & LIB were shipped in Win32 SDK along with NT4.

Comments:

    Code is generally ready to be compiled with UNICODE defined, however,
     we do not make use of this because EXE and DLL must also work on
     Windows 95.

--*/


#include <windows.h>
#include <winsock2.h>
#include <commctrl.h>
#include "globals.h"


HINSTANCE ghInst;


int
APIENTRY
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow
    )
{

    PROPSHEETPAGE psp[3];
    PROPSHEETHEADER psh;
    WSADATA WSAData;
    int iTab = 0;
    int r;
    DWORD dwWait;
    HANDLE hMutex;
    TCHAR pszMutextName[] = TEXT("sporder.exe");


    DBGOUT((TEXT("checked build.\n")));

    //
    // It is possible that we will have multiple instances running at the
    //  same time... what we really want is the first to finish before the
    //  second really gets going... for that reason, wait here on mutex
    //

    hMutex = CreateMutex (NULL, FALSE, pszMutextName);
    hMutex = OpenMutex (SYNCHRONIZE, FALSE, pszMutextName);
    dwWait = WaitForSingleObject (hMutex, 0);
    if (dwWait == WAIT_TIMEOUT)
    {
        OutputDebugString (TEXT("WaitForSingleObject, WAIT_TIMEOUT\n"));
        return TRUE;
    }

    //
    // Do global initializations.
    //

    ghInst = hInstance;
    InitCommonControls();
    memset (psp, 0, sizeof (psp));
    memset (&psh, 0, sizeof (psh));


    if (WSAStartup(MAKEWORD (2,2),&WSAData) == SOCKET_ERROR) {
      OutputDebugString (TEXT("WSAStartup failed\n"));
      return -1;
    }


    psp[iTab].dwSize = sizeof(PROPSHEETPAGE);
    psp[iTab].dwFlags = PSP_USETITLE;
    psp[iTab].hInstance = ghInst;
    psp[iTab].pszTemplate = TEXT("WS2SPDlg");
    psp[iTab].pszIcon = TEXT("");
    psp[iTab].pfnDlgProc = (DLGPROC) SortDlgProc;
    psp[iTab].pszTitle = TEXT("Service Providers");
    psp[iTab].lParam = 0;
    iTab++;


    psp[iTab].dwSize = sizeof(PROPSHEETPAGE);
    psp[iTab].dwFlags = PSP_USETITLE;
    psp[iTab].hInstance = ghInst;
    psp[iTab].pszTemplate = TEXT("RNRSPDlg");
    psp[iTab].pszIcon = TEXT("");
    psp[iTab].pfnDlgProc = RNRDlgProc;
    psp[iTab].pszTitle = TEXT("Name Resolution ");
    psp[iTab].lParam = 0;
    iTab++;

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE ; // | PSH_NOAPPLYNOW  ; // | PSH_HASHELP ;
    psh.hwndParent = NULL;
    psh.hInstance = ghInst;
    psh.pszIcon = TEXT("");
    psh.pszCaption = TEXT("Windows Sockets Configuration");
    psh.nPages = iTab;
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

    //
    // Finally display the dialog with the property sheets.
    //

//
// Sundown: Possible truncation here from INT_PTR to int in the return value.
//          However, WinMain returns an exit value which is still a 32bit value.
//

    r = (int)PropertySheet(&psh);

    //
    // Cleanup sockets, release mutex, and close handle
    //

    WSACleanup ();
    ReleaseMutex (hMutex);
    CloseHandle (hMutex);

    return r;
}


#if DBG
void
_cdecl
DbgPrint(
    PTCH Format,
    ...
    )
/*++

  Write debug output messages if compiled with DEBUG

--*/
{
    TCHAR buffer[MAX_PATH];

    va_list marker;
    va_start (marker,Format);
    wvsprintf (buffer,Format, marker);
    OutputDebugString (TEXT("SPORDER.EXE: "));
    OutputDebugString (buffer);

    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\util\sporder\exe\sporder.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sporder.h

Abstract:

    This header prototypes the 32-Bit Windows functions that are used
    to change the order or WinSock2 transport service providers and
    name space providers.

Revision History:

--*/



int
WSPAPI
WSCWriteProviderOrder (
    IN LPDWORD lpwdCatalogEntryId,
    IN DWORD dwNumberOfEntries
    );
/*++

Routine Description:

    Reorder existing WinSock2 service providers.  The order of the service
    providers determines their priority in being selected for use.  The
    sporder.exe tool will show you the installed provider and their ordering,
    Alternately, WSAEnumProtocols(), in conjunction with this function,
    will allow you to write your own tool.

Arguments:

    lpwdCatalogEntryId  [in]
      An array of CatalogEntryId elements as found in the WSAPROTOCOL_INFO
      structure.  The order of the CatalogEntryId elements is the new
      priority ordering for the service providers.

    dwNumberOfEntries  [in]
      The number of elements in the lpwdCatalogEntryId array.


Return Value:

    ERROR_SUCCESS   - the service providers have been reordered.
    WSAEINVAL       - input parameters were bad, no action was taken.
    ERROR_BUSY      - the routine is being called by another thread or process.
    any registry error code


Comments:

    Here are scenarios in which the WSCWriteProviderOrder function may fail:

      The dwNumberOfEntries is not equal to the number of registered service
      providers.

      The lpwdCatalogEntryId contains an invalid catalog ID.

      The lpwdCatalogEntryId does not contain all valid catalog IDs exactly
      1 time.

      The routine is not able to access the registry for some reason
      (e.g. inadequate user persmissions)

      Another process (or thread) is currently calling the routine.

--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\util\sporder\dll\dllmain.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dllmain.c

Abstract:

    Main module for sporder.dll...  the 32-Bit Windows functions that are
    used to change the order or WinSock2 transport service providers and
    name space providers.

Revision History:

--*/

#include <windows.h>
#include <ws2spi.h>
#include <string.h>

#include "sporder.h"

#define MAX_ENTRIES 1000 // hack, make dynamic
void
_cdecl
MyDbgPrint(
    PSTR Format,
    ...
    )
{
    va_list arglist;
    char    OutputBuffer[1024];

    va_start (arglist, Format);
    wvsprintf (OutputBuffer, Format, arglist);
    va_end (arglist);
    OutputDebugString (OutputBuffer);
}

#if DBG
#define DBGOUT(args)    MyDbgPrint args
#else
#define DBGOUT(args)
#endif


typedef struct {
    GUID    ProviderId;
    char    DisplayString[MAX_PATH];
    DWORD   Enabled;
    char    LibraryPath[MAX_PATH];
    DWORD   StoresServiceClassInfo;
    DWORD   SupportedNameSpace;
    DWORD   Version;
} NSP_ITEM;

NSP_ITEM garNspCat[MAX_ENTRIES];
//
// hack, structure copied from winsock2\dll\winsock2\dcatitem.cpp.
//  code should eventually be common.
//

typedef struct {
    char            LibraryPath[MAX_PATH];
    // The unexpanded path where the provider DLL is found.

    WSAPROTOCOL_INFOW   ProtoInfo;
    // The  protocol information.  Note that if the WSAPROTOCOL_INFOW structure
    // is  ever changed to a non-flat structure (i.e., containing pointers)
    // then  this  type  definition  will  have  to  be changed, since this
    // structure must be strictly flat.

} PACKED_CAT_ITEM;

PACKED_CAT_ITEM garPackCat[MAX_ENTRIES];
DWORD garcbData[MAX_ENTRIES];


//
// When we first enumerate and read the child registry keys, store all of
//  those names for later use.
//

TCHAR pszKeyNames[MAX_ENTRIES][MAX_PATH];


//
// The name of the registry keys that we are interested in.
//

TCHAR pszBaseKey[]=                TEXT("SYSTEM\\CurrentControlSet\\Services\\WinSock2\\Parameters");
TCHAR pszProtocolCatalog[]=        TEXT("Protocol_Catalog9");
TCHAR pszNameSpaceCatalog[]=       TEXT("NameSpace_Catalog5");
TCHAR pszCurrentProtocolCatalog[]= TEXT("Current_Protocol_Catalog");
TCHAR pszCurrentNameSpaceCatalog[]=TEXT("Current_NameSpace_Catalog");
TCHAR pszCatalogEntries[]=         TEXT("Catalog_Entries");

TCHAR pszDisplayString[]=          TEXT("DisplayString");
TCHAR pszEnabled[]=                TEXT("Enabled");
TCHAR pszLibraryPath[]=            TEXT("LibraryPath");
TCHAR pszProviderId[]=             TEXT("ProviderId");
TCHAR pszStoresServiceClassInfo[]= TEXT("StoresServiceClassInfo");
TCHAR pszSupportedNameSpace[]=     TEXT("SupportedNameSpace");
TCHAR pszVersion[]=                TEXT("Version");

#define WS2_SZ_KEYNAME TEXT("PackedCatalogItem")


BOOL
WINAPI
DllMain (
    HANDLE hDLL,
    DWORD dwReason,
    LPVOID lpReserved)
/*++

    Obligatory main() routine for DLL.

--*/

{
    return TRUE;
}

int
WSPAPI
WSCWriteProviderOrder (
    IN LPDWORD lpwdCatalogEntryId,
    IN DWORD dwNumberOfEntries)
/*++

Routine Description:

    Reorder existing WinSock2 service providers.  The order of the service
    providers determines their priority in being selected for use.  The
    sporder.exe tool will show you the installed provider and their ordering,
    Alternately, WSAEnumProtocols(), in conjunction with this function,
    will allow you to write your own tool.

Arguments:

    lpwdCatalogEntryId  [in]
      An array of CatalogEntryId elements as found in the WSAPROTOCOL_INFO
      structure.  The order of the CatalogEntryId elements is the new
      priority ordering for the service providers.

    dwNumberOfEntries  [in]
      The number of elements in the lpwdCatalogEntryId array.


Return Value:

    ERROR_SUCCESS   - the service providers have been reordered.
    WSAEINVAL       - input parameters were bad, no action was taken.
    WSATRY_AGAIN    - the routine is being called by another thread or process.
    any registry error code


Comments:

    Here are scenarios in which the WSCWriteProviderOrder function may fail:

      The dwNumberOfEntries is not equal to the number of registered service
      providers.

      The lpwdCatalogEntryId contains an invalid catalog ID.

      The lpwdCatalogEntryId does not contain all valid catalog IDs exactly
      1 time.

      The routine is not able to access the registry for some reason
      (e.g. inadequate user persmissions)

      Another process (or thread) is currently calling the routine.


--*/
{
    int  iIndex;
    int  iNumRegCatEntries;
    int  iWPOReturn;
    DWORD i,j;
    LONG r;
    HKEY hKey;
    HKEY hSubKey;
    DWORD dwBytes;
    DWORD dwType;
    TCHAR pszBuffer[MAX_PATH];
    TCHAR pszFinalKey[MAX_PATH];
    DWORD dwMapping[MAX_ENTRIES];
    DWORD dwDummy[MAX_ENTRIES];
    DWORD dwWait;
    HANDLE hMutex;
    static char pszMutextName[] = TEXT("sporder.dll");
    HMODULE hWS2_32;


    //
    // If WS2_32 is loaded (it is if it was used to load catalog 
    // in the first place), then try to use it to reoder entries.
    // Otherwise, use old hackish way of writing to the registry directly.
    //
    hWS2_32 = GetModuleHandle (TEXT ("WS2_32.DLL"));
    if (hWS2_32!=NULL) {
        LPWSCWRITEPROVIDERORDER  lpWSCWriteProviderOrder;
        lpWSCWriteProviderOrder = 
                (LPWSCWRITEPROVIDERORDER)GetProcAddress (
                                            hWS2_32,
                                            "WSCWriteProviderOrder");
        if (lpWSCWriteProviderOrder!=NULL) {
            //MyDbgPrint ("SPORDER: calling ws2_32!WSCWriteProviderOrder...\n");
            iWPOReturn = lpWSCWriteProviderOrder (
                                    lpwdCatalogEntryId,
                                    dwNumberOfEntries
                                    );

            return iWPOReturn;
        }
    }


    //
    // Set function return code equal to success
    //  (assume the best and wait to be proven otherwise)
    //

    iWPOReturn = ERROR_SUCCESS;

    //
    // Make sure that we can handle a request of this size.
    //  Hack, this code needs to be replaced by dynamic memory allocation.
    //

    if (dwNumberOfEntries > MAX_ENTRIES) {
        return WSA_NOT_ENOUGH_MEMORY;
    }

    //
    // Protect the code that modifies the registry with a mutex.
    //

    hMutex = CreateMutexA (NULL, FALSE, pszMutextName);
    if (hMutex==NULL) {
        return WSASYSCALLFAILURE;
    }

    dwWait = WaitForSingleObject (hMutex, 0);
    if (dwWait == WAIT_TIMEOUT)
    {
        DBGOUT((TEXT("WaitForSingleObject, WAIT_TIMEOUT\n")));
        iWPOReturn = WSATRY_AGAIN;
        goto closeMutex;
    }


    //
    // read catentry format & return error if mismatch
    //

    r = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      pszBaseKey,
                      0,
                      KEY_QUERY_VALUE,
                      &hKey);

    if (r != ERROR_SUCCESS)
    {
        DBGOUT((TEXT("RegOpenKeyEx, pszBaseKey, failed \n")));
        iWPOReturn = r;
        goto releaseMutex;
    }

    //
    // Read the current registry storage format being used by WinSock2.
    //  Compare with expected value, and return failure if wrong format.
    //

    dwBytes = sizeof (pszBuffer);
    r = RegQueryValueEx (hKey,
                       pszCurrentProtocolCatalog,
                       NULL,
                       &dwType,
                       (LPVOID) pszBuffer,
                       &dwBytes);

    RegCloseKey (hKey);

    if (r != ERROR_SUCCESS)
    {
        DBGOUT((TEXT("RegQueryValueEx, pszCurrentProtocolCatalog, failed \n")));
        iWPOReturn = r;
        goto releaseMutex;
    }

    if (lstrcmp (pszProtocolCatalog, pszBuffer) != 0)
    {
        DBGOUT((TEXT("Wrong reg. format \n")));
        iWPOReturn = WSAEINVAL;
        goto releaseMutex;
    }


    //
    // Build the final registry key that has the actual catalogs in it
    //  pszBaseKey + \ + pszCurrentProtocolCatalog + \ + pszCatalogEntries
    //  and open it for enumeration
    //

    lstrcpy (pszFinalKey, pszBaseKey);
    lstrcat (pszFinalKey, TEXT("\\"));
    lstrcat (pszFinalKey, pszProtocolCatalog);
    lstrcat (pszFinalKey, TEXT("\\"));
    lstrcat (pszFinalKey, pszCatalogEntries);

    DBGOUT((pszFinalKey));
    DBGOUT((TEXT("\n")));

    r = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      pszFinalKey,
                      0,
                      KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                      &hKey);

    if (r != ERROR_SUCCESS)
    {
        DBGOUT((TEXT("RegOpenKeyEx failed \n")));
        iWPOReturn = r;
        goto releaseMutex;
    }


    //
    // The initial open succeeded, now enumerate registry keys
    //  until we don't get any more back
    //

    for (iIndex = 0; ;iIndex++)
    {
        TCHAR    pszSubKey[MAX_PATH];
        TCHAR    szFinalPlusSubKey[MAX_PATH];
        FILETIME ftDummy;
        DWORD    dwSize;

        if (iIndex>=MAX_ENTRIES) {
            DBGOUT((TEXT("iIndex>=MAX_ENTRIES\n")));
            iWPOReturn = WSAEINVAL;
            goto releaseMutex;
        }


        dwSize = MAX_PATH;
        pszSubKey[0]=0;
        r=RegEnumKeyEx (hKey,
                         iIndex,
                         pszSubKey,
                         &dwSize,
                         NULL,
                         NULL,
                         NULL,
                         &ftDummy);

        //
        // Once we have all of the keys, we'll get return code: no_more_items.
        //  close the handle, and exit for loop.
        //

        if (r == ERROR_NO_MORE_ITEMS)
        {
            iNumRegCatEntries = iIndex;
            RegCloseKey(hKey);
            break; // exit for loop
        }


        //
        // Check for other, unexpected error conditions
        //

        if (r != ERROR_SUCCESS)
        {
            DBGOUT((TEXT("Unexpected Error \n")));
            iWPOReturn = r;
            goto releaseMutex;
        }


        //
        // Build up the complete name of the subkey, store it away in
        //  pszKeyNames for future use, and then open the key.
        //

        lstrcpy (szFinalPlusSubKey, pszFinalKey);
        lstrcat (szFinalPlusSubKey, TEXT("\\"));
        lstrcat (szFinalPlusSubKey, pszSubKey);

        lstrcpy (&pszKeyNames[iIndex][0],szFinalPlusSubKey);
        r = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                           szFinalPlusSubKey,
                           0,
                           KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                           &hSubKey);

        if (r != ERROR_SUCCESS)
        {
            DBGOUT((TEXT("RegOpenKeyEx, Badly formated subkey \n")));
            iWPOReturn = r;
            goto releaseMutex;
        }


        //
        // Finally, read the binary catalog entry data into our global array.
        //

        dwBytes = sizeof (PACKED_CAT_ITEM);
        dwType = REG_BINARY;
        r = RegQueryValueEx (hSubKey,
                           WS2_SZ_KEYNAME,
                           NULL,
                           &dwType,
                           (LPVOID) &garPackCat[iIndex],
                           &dwBytes);
        garcbData[iIndex]=dwBytes;


        if (r != ERROR_SUCCESS)
        {
            DBGOUT((TEXT("RegQueryValueEx failed \n")));
            iWPOReturn = r;
            goto releaseMutex;
        }

        RegCloseKey(hSubKey);

    } // end for


    //
    // compare dwNumberOfEntries w/ actual number & fail if wrong
    //

    if (iNumRegCatEntries != (int) dwNumberOfEntries)
    {
        DBGOUT((TEXT("iNumRegCatEntries != dwNumberOfEntries \n")));
        iWPOReturn = WSAEINVAL;
        goto releaseMutex;
    }


    //
    // verify that array passed in has same entries as actual list,
    //  and construct index mapping at the same time.  index mapping says
    //  that entry dwMapping[i] should be written to key number i.
    //
    // for array validation:
    //   step through actual list of catalog entries,
    //    set dummy to -1 if match
    //   check that dummy array is all -1 and fail if not true.
    //

    ZeroMemory (dwDummy, dwNumberOfEntries * sizeof (DWORD));
    ZeroMemory (dwMapping, dwNumberOfEntries * sizeof (DWORD));

    for (i = 0; i < dwNumberOfEntries ;i++)
    {
        for (j = 0; j< dwNumberOfEntries ;j++)
        {
            if (garPackCat[i].ProtoInfo.dwCatalogEntryId ==
                    lpwdCatalogEntryId[j])
            {
                  dwDummy[j] = (DWORD)-1;
                  dwMapping[j] = i;
            }
        }
    }

    for (j = 0; j< dwNumberOfEntries ;j++)
    {
        if (dwDummy[j] != (DWORD)-1)
        {
            iWPOReturn = WSAEINVAL;
            goto releaseMutex;
        }
    }

    //
    // Finally, all parameter validation is complete,
    //  and we've read all of the catalog entries.
    //
    // step through array passed in
    //  and if not equal, lookup pre-read entry, and write as registry key
    //

    for (i = 0; i < dwNumberOfEntries ;i++)
    {
        if (dwMapping[i] != i)
        {
            r = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      &pszKeyNames[i][0],
                      0,
                      KEY_SET_VALUE,
                      &hKey);

            if (r != ERROR_SUCCESS)
            {
                DBGOUT((TEXT("RegOpenKeyEx, KEY_SET_VALUE failed \n")));
                iWPOReturn = r;
                goto releaseMutex;
            }

            r = RegSetValueEx (hKey,
                               WS2_SZ_KEYNAME,
                               0,
                               REG_BINARY,
                               (LPVOID) &garPackCat[dwMapping[i]],
                               garcbData[i]);

            if (r != ERROR_SUCCESS)
            {
                DBGOUT((TEXT("RegSetValueEx failed \n")));
                iWPOReturn = r;
                goto releaseMutex;
            }

            RegCloseKey(hKey);

            DBGOUT((TEXT("wrote entry %d in location %d \n"), dwMapping[i], i));
        }
    }


    //
    // Release Mutex, close handle, and return.
    //  Notice that this function MUST return only from here at the
    //  end so that we are certain to release the mutex.
    //

releaseMutex:
    ReleaseMutex (hMutex);
closeMutex:
    CloseHandle (hMutex);

    return iWPOReturn;
}


LONG
ReadNamspaceRegistry(
    HKEY hKey,
    NSP_ITEM *pItem
)
{
    LONG r;
    HKEY hSubKey;
    DWORD dwBytes;
    DWORD dwType;

    dwBytes = sizeof(pItem->DisplayString);
    r = RegQueryValueEx(hKey,
                        pszDisplayString,
                        NULL,
                        &dwType,
                        (LPVOID) &pItem->DisplayString,
                        &dwBytes);

    if (r != ERROR_SUCCESS) {
        DBGOUT((TEXT("RegQueryValueEx, pszDisplayString, failed \n")));
        return r;
    }

    dwBytes = sizeof(pItem->Enabled);
    r = RegQueryValueEx(hKey,
                        pszEnabled,
                        NULL,
                        &dwType,
                        (LPVOID) &pItem->Enabled,
                        &dwBytes);

    if (r != ERROR_SUCCESS) {
        DBGOUT((TEXT("RegQueryValueEx, pszEnabled, failed \n")));
        return r;
    }

    dwBytes = sizeof(pItem->LibraryPath);
    r = RegQueryValueEx(hKey,
                        pszLibraryPath,
                        NULL,
                        &dwType,
                        (LPVOID) &pItem->LibraryPath,
                        &dwBytes);

    if (r != ERROR_SUCCESS) {
        DBGOUT((TEXT("RegQueryValueEx, pszLibraryPath, failed \n")));
        return r;
    }


    dwBytes = sizeof(pItem->ProviderId);
    r = RegQueryValueEx(hKey,
                        pszProviderId,
                        NULL,
                        &dwType,
                        (LPVOID) &pItem->ProviderId,
                        &dwBytes);

    if (r != ERROR_SUCCESS) {
        DBGOUT((TEXT("RegQueryValueEx, pszProviderId, failed \n")));
        return r;
    }

    dwBytes = sizeof(pItem->StoresServiceClassInfo);
    r = RegQueryValueEx(hKey,
                        pszStoresServiceClassInfo,
                        NULL,
                        &dwType,
                        (LPVOID) &pItem->StoresServiceClassInfo,
                        &dwBytes);

    if (r != ERROR_SUCCESS) {
        DBGOUT((TEXT("RegQueryValueEx, pszStoresServiceClassInfo, failed \n")));
        return r;
    }

    dwBytes = sizeof(pItem->SupportedNameSpace);
    r = RegQueryValueEx(hKey,
                        pszSupportedNameSpace,
                        NULL,
                        &dwType,
                        (LPVOID) &pItem->SupportedNameSpace,
                        &dwBytes);

    if (r != ERROR_SUCCESS) {
        DBGOUT((TEXT("RegQueryValueEx, pszSupportedNameSpace, failed \n")));
        return r;
    }

    dwBytes = sizeof(pItem->Version);
    r = RegQueryValueEx(hKey,
                        pszVersion,
                        NULL,
                        &dwType,
                        (LPVOID) &pItem->Version,
                        &dwBytes);

    if (r != ERROR_SUCCESS) {
        DBGOUT((TEXT("RegQueryValueEx, pszVersion, failed \n")));
        return r;
    }

    return ERROR_SUCCESS;
}

#define GUIDEQUAL(Guid1, Guid2)                     \
       ( (Guid1)->Data1 == (Guid2)->Data1 &&        \
         (Guid1)->Data2 == (Guid2)->Data2 &&        \
         (Guid1)->Data3 == (Guid2)->Data3 &&        \
         (Guid1)->Data4[0] == (Guid2)->Data4[0] &&  \
         (Guid1)->Data4[1] == (Guid2)->Data4[1] &&  \
         (Guid1)->Data4[2] == (Guid2)->Data4[2] &&  \
         (Guid1)->Data4[3] == (Guid2)->Data4[3] &&  \
         (Guid1)->Data4[4] == (Guid2)->Data4[4] &&  \
         (Guid1)->Data4[5] == (Guid2)->Data4[5] &&  \
         (Guid1)->Data4[6] == (Guid2)->Data4[6] &&  \
         (Guid1)->Data4[7] == (Guid2)->Data4[7] )


LONG
WriteNameSpaceRegistry(
    HKEY hKey,
    NSP_ITEM *pItem
)
{
    LONG r;
    HKEY hSubKey;

    r = RegSetValueEx (hKey,
                       pszDisplayString,
                       0,
                       REG_SZ,
                       (LPVOID) &pItem->DisplayString,
                       lstrlen(pItem->DisplayString) + 1);

    if (r != ERROR_SUCCESS) {
        DBGOUT((TEXT("RegSetValueEx failed \n")));
        return r;
    }

    r = RegSetValueEx (hKey,
                       pszEnabled,
                       0,
                       REG_DWORD,
                       (LPVOID) &pItem->Enabled,
                       sizeof(DWORD));

    if (r != ERROR_SUCCESS) {
        DBGOUT((TEXT("RegSetValueEx failed \n")));
        return r;
    }

    r = RegSetValueEx (hKey,
                       pszLibraryPath,
                       0,
                       REG_SZ,
                       (LPVOID) &pItem->LibraryPath,
                       lstrlen(pItem->LibraryPath) + 1);

    if (r != ERROR_SUCCESS) {
        DBGOUT((TEXT("RegSetValueEx failed \n")));
        return r;
    }

    r = RegSetValueEx (hKey,
                       pszProviderId,
                       0,
                       REG_BINARY,
                       (LPVOID) &pItem->ProviderId,
                       sizeof(pItem->ProviderId));

    if (r != ERROR_SUCCESS) {
        DBGOUT((TEXT("RegSetValueEx failed \n")));
        return r;
    }

    r = RegSetValueEx (hKey,
                       pszStoresServiceClassInfo,
                       0,
                       REG_DWORD,
                       (LPVOID) &pItem->StoresServiceClassInfo,
                       sizeof(DWORD));

    if (r != ERROR_SUCCESS) {
        DBGOUT((TEXT("RegSetValueEx failed \n")));
        return r;
    }

    r = RegSetValueEx (hKey,
                       pszSupportedNameSpace,
                       0,
                       REG_DWORD,
                       (LPVOID) &pItem->SupportedNameSpace,
                       sizeof(DWORD));

    if (r != ERROR_SUCCESS) {
        DBGOUT((TEXT("RegSetValueEx failed \n")));
        return r;
    }

    r = RegSetValueEx (hKey,
                       pszVersion,
                       0,
                       REG_DWORD,
                       (LPVOID) &pItem->Version,
                       sizeof(DWORD));

    if (r != ERROR_SUCCESS) {
        DBGOUT((TEXT("RegSetValueEx failed \n")));
        return r;
    }

    return r;
}


int
WSPAPI
WSCWriteNameSpaceOrder (
    IN LPGUID lpProviderId,
    IN DWORD dwNumberOfEntries)
/*++


--*/
{
    int  iIndex;
    int  iNumRegCatEntries;
    int  iWPOReturn;
    DWORD i,j;
    LONG r;
    HKEY hKey;
    HKEY hSubKey;
    DWORD dwBytes;
    DWORD dwType;
    TCHAR pszBuffer[MAX_PATH];
    TCHAR pszFinalKey[MAX_PATH];
    DWORD dwMapping[MAX_ENTRIES];
    DWORD dwDummy[MAX_ENTRIES];
    DWORD dwWait;
    HANDLE hMutex;
    static char pszMutextName[] = TEXT("sporder.dll");
    HMODULE hWS2_32;


    //
    // If WS2_32 is loaded (it is if it was used to load catalog 
    // in the first place), then try to use it to reoder entries.
    // Otherwise, use old hackish way of writing to the registry directly.
    //
    hWS2_32 = GetModuleHandle (TEXT ("WS2_32.DLL"));
    if (hWS2_32!=NULL) {
        LPWSCWRITENAMESPACEORDER lpWSCWriteNameSpaceOrder;
        lpWSCWriteNameSpaceOrder =
                (LPWSCWRITENAMESPACEORDER)GetProcAddress (
                                            hWS2_32,
                                            "WSCWriteNameSpaceOrder");
        if (lpWSCWriteNameSpaceOrder!=NULL) {
            //MyDbgPrint ("SPORDER: calling ws2_32!WSCWriteNameSpaceOrder...\n");
            iWPOReturn = lpWSCWriteNameSpaceOrder (
                                    lpProviderId,
                                    dwNumberOfEntries
                                    );

            return iWPOReturn;
        }
    }
    //
    // Set function return code equal to success
    //  (assume the best and wait to be proven otherwise)
    //

    iWPOReturn = ERROR_SUCCESS;

    //
    // Make sure that we can handle a request of this size.
    //  Hack, this code needs to be replaced by dynamic memory allocation.
    //

    if ( dwNumberOfEntries > MAX_ENTRIES)
        return WSA_NOT_ENOUGH_MEMORY;

    //
    // Protect the code that modifies the registry with a mutex.
    //

    hMutex = CreateMutexA (NULL, FALSE, pszMutextName);
    if (hMutex==NULL) {
        return WSASYSCALLFAILURE;
    }

    dwWait = WaitForSingleObject (hMutex, 0);
    if (dwWait == WAIT_TIMEOUT)
    {
        DBGOUT((TEXT("WaitForSingleObject, WAIT_TIMEOUT\n")));
        iWPOReturn = ERROR_BUSY;
        goto closeMutex;
    }


    //
    // read catentry format & return error if mismatch
    //

    r = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      pszBaseKey,
                      0,
                      KEY_QUERY_VALUE,
                      &hKey);

    if (r != ERROR_SUCCESS)
    {
        DBGOUT((TEXT("RegOpenKeyEx, pszBaseKey, failed \n")));
        iWPOReturn = r;
        goto releaseMutex;
    }

    //
    // Read the current registry storage format being used by WinSock2.
    //  Compare with expected value, and return failure if wrong format.
    //

    dwBytes = sizeof (pszBuffer);
    r = RegQueryValueEx (hKey,
                       pszCurrentNameSpaceCatalog,
                       NULL,
                       &dwType,
                       (LPVOID) pszBuffer,
                       &dwBytes);

    RegCloseKey (hKey);

    if (r != ERROR_SUCCESS)
    {
        DBGOUT((TEXT("RegQueryValueEx, pszCurrentNameSpaceCatalog, failed \n")));
        iWPOReturn = r;
        goto releaseMutex;
    }

    if (lstrcmp (pszNameSpaceCatalog, pszBuffer) != 0)
    {
        DBGOUT((TEXT("Wrong reg. format \n")));
        iWPOReturn = WSAEINVAL;
        goto releaseMutex;
    }


    //
    // Build the final registry key that has the actual catalogs in it
    //  pszBaseKey + \ + pszCurrentNameSpaceCatalog + \ + pszCatalogEntries
    //  and open it for enumeration
    //

    lstrcpy (pszFinalKey, pszBaseKey);
    lstrcat (pszFinalKey, TEXT("\\"));
    lstrcat (pszFinalKey, pszNameSpaceCatalog);
    lstrcat (pszFinalKey, TEXT("\\"));
    lstrcat (pszFinalKey, pszCatalogEntries);

    DBGOUT((pszFinalKey));
    DBGOUT((TEXT("\n")));

    r = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      pszFinalKey,
                      0,
                      KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                      &hKey);

    if (r != ERROR_SUCCESS)
    {
        DBGOUT((TEXT("RegOpenKeyEx failed \n")));
        iWPOReturn = r;
        goto releaseMutex;
    }


    //
    // The initial open succeeded, now enumerate registry keys
    //  until we don't get any more back
    //

    for (iIndex = 0; ;iIndex++)
    {
        TCHAR    pszSubKey[MAX_PATH];
        TCHAR    szFinalPlusSubKey[MAX_PATH];
        FILETIME ftDummy;
        DWORD    dwSize;

        if (iIndex>=MAX_ENTRIES) {
            DBGOUT((TEXT("iIndex>=MAX_ENTRIES\n")));
            iWPOReturn = WSAEINVAL;
            goto releaseMutex;
        }

        dwSize = MAX_PATH;
        pszSubKey[0]=0;
        r=RegEnumKeyEx (hKey,
                         iIndex,
                         pszSubKey,
                         &dwSize,
                         NULL,
                         NULL,
                         NULL,
                         &ftDummy);

        //
        // Once we have all of the keys, we'll get return code: no_more_items.
        //  close the handle, and exit for loop.
        //

        if (r == ERROR_NO_MORE_ITEMS)
        {
            iNumRegCatEntries = iIndex;
            RegCloseKey(hKey);
            break; // exit for loop
        }


        //
        // Check for other, unexpected error conditions
        //

        if (r != ERROR_SUCCESS)
        {
            DBGOUT((TEXT("Unexpected Error \n")));
            iWPOReturn = r;
            goto releaseMutex;
        }


        //
        // Build up the complete name of the subkey, store it away in
        //  pszKeyNames for future use, and then open the key.
        //

        lstrcpy (szFinalPlusSubKey, pszFinalKey);
        lstrcat (szFinalPlusSubKey, TEXT("\\"));
        lstrcat (szFinalPlusSubKey, pszSubKey);

        lstrcpy (&pszKeyNames[iIndex][0],szFinalPlusSubKey);
        r = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                           szFinalPlusSubKey,
                           0,
                           KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                           &hSubKey);

        if (r != ERROR_SUCCESS)
        {
            DBGOUT((TEXT("RegOpenKeyEx, Badly formated subkey \n")));
            iWPOReturn = r;
            goto releaseMutex;
        }


        //
        // Finally, read the binary catalog entry data into our global array.
        //

        dwBytes = sizeof (PACKED_CAT_ITEM);
        dwType = REG_BINARY;
        r = ReadNamspaceRegistry (hSubKey,
                                  &garNspCat[iIndex]);

        if (r != ERROR_SUCCESS)
        {
            DBGOUT((TEXT("ReadNamspaceRegistry failed \n")));
            iWPOReturn = r;
            goto releaseMutex;
        }

        RegCloseKey(hSubKey);

    } // end for


    //
    // compare dwNumberOfEntries w/ actual number & fail if wrong
    //

    if (iNumRegCatEntries != (int) dwNumberOfEntries)
    {
        DBGOUT((TEXT("iNumRegCatEntries != dwNumberOfEntries \n")));
        iWPOReturn = WSAEINVAL;
        goto releaseMutex;
    }


    //
    // verify that array passed in has same entries as actual list,
    //  and construct index mapping at the same time.  index mapping says
    //  that entry dwMapping[i] should be written to key number i.
    //
    // for array validation:
    //   step through actual list of catalog entries,
    //    set dummy to -1 if match
    //   check that dummy array is all -1 and fail if not true.
    //

    ZeroMemory (dwDummy, dwNumberOfEntries * sizeof (DWORD));
    ZeroMemory (dwMapping, dwNumberOfEntries * sizeof (DWORD));

    for (i = 0; i < dwNumberOfEntries ;i++)
    {
        for (j = 0; j< dwNumberOfEntries ;j++)
        {
            if (GUIDEQUAL(&garNspCat[i].ProviderId, &lpProviderId[j]))
            {
                  dwDummy[j] = (DWORD)-1;
                  dwMapping[j] = i;
            }
        }
    }

    for (j = 0; j< dwNumberOfEntries ;j++)
    {
        if (dwDummy[j] != (DWORD)-1)
        {
            iWPOReturn = WSAEINVAL;
            goto releaseMutex;
        }
    }

    //
    // Finally, all parameter validation is complete,
    //  and we've read all of the catalog entries.
    //
    // step through array passed in
    //  and if not equal, lookup pre-read entry, and write as registry key
    //

    for (i = 0; i < dwNumberOfEntries ;i++)
    {
        if (dwMapping[i] != i)
        {
            r = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      &pszKeyNames[i][0],
                      0,
                      KEY_SET_VALUE,
                      &hKey);

            if (r != ERROR_SUCCESS)
            {
                DBGOUT((TEXT("RegOpenKeyEx, KEY_SET_VALUE failed \n")));
                iWPOReturn = r;
                goto releaseMutex;
            }

            r = WriteNameSpaceRegistry(hKey, &garNspCat[dwMapping[i]]);


            if (r != ERROR_SUCCESS)
            {
                DBGOUT((TEXT("RegSetValueEx failed \n")));
                iWPOReturn = r;
                goto releaseMutex;
            }

            RegCloseKey(hKey);

            DBGOUT((TEXT("wrote entry %d in location %d \n"), dwMapping[i], i));
        }
    }


    //
    // Release Mutex, close handle, and return.
    //  Notice that this function MUST return only from here at the
    //  end so that we are certain to release the mutex.
    //

releaseMutex:
    ReleaseMutex (hMutex);
closeMutex:
    CloseHandle (hMutex);

    return iWPOReturn;
}



#if DBG
void
_cdecl
DbgPrint(
    PTCH Format,
    ...
    )
/*++

  Write debug output messages if compiled with DEBUG

--*/
{
    TCHAR buffer[MAX_PATH];

    va_list marker;
    va_start (marker,Format);
    wvsprintf (buffer,Format, marker);
    OutputDebugString (TEXT("SPORDER: "));
    OutputDebugString (buffer);

    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\util\sporder\exe\dlgproc.c ===
/*++

Copyright (c) 1995-1996 Microsoft Corporation

Module Name:

    dlgproc

Abstract:

    The dialog procedures for the different tabs in the main dialog.

Author:

    Steve Firebaugh (stevefir)         31-Dec-1995

Revision History:

--*/


#include <windows.h>
#include <commdlg.h>
#include <winsock2.h>
#include <nspapi.h>
#include "globals.h"


//
// Keep a dirty bit for the ordering of the service providers.  Set it if
//  the order changes, clear it if we push apply.
//

int gDirty = FALSE;



LRESULT CALLBACK SortDlgProc(HWND hwnd,
                             UINT message,
                             WPARAM wParam,
                             LPPROPSHEETPAGE ppsp)
/*++

  This is the main dialog proc for the window that lists all of the service
   providers and lets the user push them up and down.

  Uses GLOBAL:  gNumRows

--*/
{
    int iSelection;

    switch (message) {

      case WM_INITDIALOG:
          CatReadRegistry (hwnd);
          SendMessage (GetDlgItem (hwnd, DID_LISTCTL), LB_SETCURSEL, 0, 0);
          return FALSE;
      break;


      case WM_NOTIFY: {
          NMHDR * pnmhdr;
          pnmhdr = (NMHDR *) ppsp;

          if (pnmhdr->code == PSN_APPLY) {
              if (gDirty)
                  if ( IDYES == MessageBox (hwnd,
                                        TEXT("This operation may change the behavior of the networking components on your system.\nDo you wish to continue?"),
                                        TEXT("Warning:"),
                                        MB_ICONWARNING | MB_YESNO)) {
                      CatDoWriteEntries (hwnd);
                      gDirty = FALSE;
                  }

          }



      } break;


      case WM_COMMAND:
        switch (LOWORD (wParam)) {

          //
          // On the up & down buttons, screen out the no-ops (up on top row,
          //  or down on bottom), reorder the catalog entries, and set the
          //  dirty bit.
          //

          case DID_UP: {
              iSelection = (int)SendMessage (HWNDLISTCTL, LB_GETCURSEL, 0, 0);
              if (iSelection ==  0) return FALSE;

              CatDoUpDown (hwnd, LOWORD (wParam));
              SendMessage (GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0);
              gDirty = TRUE;
          } break;


          case DID_DOWN: {
              iSelection = (int)SendMessage (HWNDLISTCTL, LB_GETCURSEL, 0, 0);
              if (iSelection ==  (gNumRows-1)) return FALSE;

              CatDoUpDown (hwnd, LOWORD (wParam));
              SendMessage (GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0);
              gDirty = TRUE;
          } break;

          //
          // If the listbox is double clicked, re-send the message as if it
          //  was a more-info button press.  If it is a selection change, then
          //  set the state of the buttons appropriately.
          //

          case DID_LISTCTL:
              if (HIWORD (wParam) == LBN_DBLCLK)
                  SendMessage (hwnd, WM_COMMAND, DID_MORE, 0);
              else if (HIWORD (wParam) == LBN_SELCHANGE) {

              // here we can enable/disable buttons...
              //  not implemented yet

              }

          break;

          //
          // If they request more information, figure out which item is selected,
          //  then map that to an index value from the initial ordering.  Finally
          //  popup a dialog that will show the information from the catalog at
          //  that index.
          //

          case DID_MORE: {
              int iIndex;
              int notUsed;
              TCHAR szBuffer[MAX_STR];

              iSelection = (int)SendMessage (HWNDLISTCTL, LB_GETCURSEL, 0, 0);

              if (iSelection != LB_ERR) {

                  //
                  // Dig the chosen string out of the listbox, find the original
                  //  index hidden in it, and popup the more information dialog
                  //  for the appropriate entry.
                  //

                  SendMessage (HWNDLISTCTL, LB_GETTEXT, iSelection, (LPARAM) szBuffer);

                  ASSERT (CatGetIndex (szBuffer, &iIndex, &notUsed),
                          TEXT("SortDlgProc, CatGetIndex failed."));

                  DialogBoxParam (ghInst,
                                  TEXT("MoreInfoDlg"),
                                  hwnd,
                                  MoreInfoDlgProc,
                                  iIndex);

              }
          } break;
        }
      break; // WM_COMMAND
    } // end switch
    return FALSE;
}


INT_PTR CALLBACK MoreInfoDlgProc(HWND hwnd,
                              UINT message,
                              WPARAM wParam,
                              LPARAM lParam)
/*++

  This is the window proc for the simple "more info" dialog.  All that we
   do here is fill our listbox with interesting info on wm_initdialog, and
   then wait to be dismissed.

--*/
{

  switch (message) {

    case WM_INITDIALOG:
       CatDoMoreInfo (hwnd, (int) lParam);
    break;


    case WM_COMMAND:
      if (wParam == IDCANCEL)
        EndDialog (hwnd, FALSE);

      if (wParam == IDOK)
        EndDialog (hwnd, TRUE);
    break;

    case WM_SYSCOMMAND:
      if (wParam == SC_CLOSE)
        EndDialog (hwnd, TRUE);
    break;


  } // end switch
  return FALSE;
}



INT_PTR CALLBACK RNRDlgProc(HWND hwnd,
                            UINT message,
                            WPARAM wParam,
                            LPARAM lParam)
/*++

  For this version, simply list the installed providers.

--*/
{

  switch (message) {

    case WM_INITDIALOG: {

    //
    // at init time, query all of the installed name space providers
    //  and put their identifier in the listbox.  Notice. that this
    //  function assumes WSAStartup has already been called.
    //

#define MAX_NAMESPACE 100  // hack, arbitrary value, should be dynamic
      WSANAMESPACE_INFO  arnspBuf[MAX_NAMESPACE];
      DWORD dwBufLen;
      int   i, r;
      int   iTab = 50;

      SendMessage (HWNDLISTCTL, LB_SETTABSTOPS, 1, (LPARAM) &iTab);

      //
      // Call the WinSock2 name space enumeration function with enough
      //  free space such that we expect to get all of the information.
      //

      dwBufLen = sizeof (arnspBuf);
      r = WSAEnumNameSpaceProviders(&dwBufLen, arnspBuf);
      if ( r == SOCKET_ERROR) {
        DBGOUT((TEXT("WSAEnumNameSpaceProviders failed w/ %d\n"), WSAGetLastError()));
        return (INT_PTR)-1;
      }


      //
      // WSAEnumNameSpaceProviders succeeded so write results to listbox
      //

      for (i = 0; i< r; i++) {
        ADDSTRING(arnspBuf[i].lpszIdentifier);
      }

    } break;

  } // end switch
  return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\util\ws2inst\precomp.h ===
#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include <windows.h>
#include <winsock2.h>
#include <ws2spi.h>
#include <rpc.h>

#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>


#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\util\ws2inst\ws2inst.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    ws2inst.c

Abstract:

    This is a temporary WinSock 2 transport & namespace service provider
    installation utility.

    The command line arguments for this utility are:

        ws2inst operation file.ini [options]

    Where operation is one of the following:

        install - Installs the service provider[s] specified in the
            .INI file.

        remove - Removes the service provider[s] specified in the .INI
            file.

    And options may be one or more of the following:

        -t - Install/remove transport provider only.

        -n - Install/remove namespace provider only.

        -b - Install/remove transport and namespace providers (default).

        -e - Ignore errors.

    The layout of the .INI file is:

        [WinSock 2 Transport Service Providers]
        ProviderCount = N
        Provider0 = Transport_Provider_0_Section_Name
        Provider1 = Transport_Provider_1_Section_Name
        Provider2 = Transport_Provider_2_Section_Name
                        .
                        .
                        .
        ProviderN-1 = Transport_Provider_N-1_Section_Name

        [Transport_Provider_X_Section_Name]
        ProviderName = Provider_Name
        ProviderPath = Path_To_Providers_Dll
        ProviderId = Provider_Guid
        ProtocolCount = M

        [Transport_Provider_X_Section_Name Protocol M]
        dwServiceFlags1 = x
        dwServiceFlags2 = x
        dwServiceFlags3 = x
        dwServiceFlags4 = x
        dwProviderFlags = x
        iVersion = x
        iAddressFamily = x
        iMaxSockAddr = x
        iMinSockAddr = x
        iSocketType = x
        iProtocol = x
        iProtocolMaxOffset = x
        iNetworkByteOrder = x
        iSecurityScheme = x
        dwMessageSize = x
        dwProviderReserved = x
        szProtocol = Protocol_Name

        [WinSock 2 Name Space Providers]
        ProviderCount = N
        Provider0 = Name_Space_Provider_0_Section_Name
        Provider1 = Name_Space_Provider_1_Section_Name
        Provider2 = Name_Space_Provider_2_Section_Name
                        .
                        .
                        .
        ProviderN-1 = Name_Space_Provider_N-1_Section_Name

        [Name_Space_Provider_X_Section_Name]
        ProviderName = Provider_Name
        ProviderPath = Path_To_Providers_DLL
        ProviderId = Provider_Guid
        NameSpaceId = Name_Space_ID

Author:

    Keith Moore (keithmo)       17-Jun-1996

Revision History:

--*/


#include "precomp.h"


//
// Private constants.
//

#define MAX_INIFILE_LINE        256
#define TRANSPORT_SECTION_NAME  TEXT("WinSock 2 Transport Service Providers")
#define NAMESPACE_SECTION_NAME  TEXT("WinSock 2 Name Space Providers")

#define OPTION_FLAG_TRANSPORT       0x00000001
#define OPTION_FLAG_NAMESPACE       0x00000002
#define OPTION_FLAG_BOTH            0x00000003  // transport and namespace
#define OPTION_FLAG_IGNORE_ERRORS   0x00000004


//
// Private types.
//

typedef
BOOL
(CALLBACK * LPFN_ENUM_SECTION_CALLBACK)(
    LPTSTR IniFile,
    LPTSTR ProviderSectionName,
    DWORD Context
    );


//
// Private prototypes.
//

VOID
Usage(
    VOID
    );

VOID
InstallFromIniFile(
    LPTSTR IniFile,
    DWORD Options
    );

VOID
RemoveFromIniFile(
    LPTSTR IniFile,
    DWORD Options
    );

VOID
EnumProviderSections(
    LPTSTR IniFile,
    LPTSTR SectionName,
    LPFN_ENUM_SECTION_CALLBACK Callback,
    DWORD Context
    );

BOOL
InstallTransportProviderCallback(
    LPTSTR IniFile,
    LPTSTR SectionName,
    DWORD Context
    );

BOOL
RemoveTransportProviderCallback(
    LPTSTR IniFile,
    LPTSTR SectionName,
    DWORD Context
    );

BOOL
InstallNameSpaceProviderCallback(
    LPTSTR IniFile,
    LPTSTR SectionName,
    DWORD Context
    );

BOOL
RemoveNameSpaceProviderCallback(
    LPTSTR IniFile,
    LPTSTR SectionName,
    DWORD Context
    );


//
// Public functions.
//


INT
__cdecl
_tmain(
    INT argc,
    LPTSTR argv[]
    )

/*++

Routine Description:

    Main program entrypoint.

Arguments:

    argc - Number of command line arguments.

    argv - Array of pointers to command line arguments.

Return Value:

    INT - Completion status.

--*/

{

    LPTSTR opCode;
    LPTSTR iniFile;
    LPTSTR arg;
    DWORD options;
    INT i;

    //
    // Interpret the command line arguments.
    //

    if( argc < 3 ) {

        Usage();
        return 1;

    }

    opCode = argv[1];
    iniFile = argv[2];
    options = 0;

    for( i = 3 ; i < argc ; i++ ) {

        arg = argv[i];

        if( *arg != TEXT('-') ) {

            Usage();
            return 1;

        }

        arg++;

        while( *arg != TEXT('\0') ) {

            switch( *arg++ ) {

            case TEXT('t') :
            case TEXT('T') :
                options |= OPTION_FLAG_TRANSPORT;
                break;

            case TEXT('n') :
            case TEXT('N') :
                options |= OPTION_FLAG_NAMESPACE;
                break;

            case TEXT('b') :
            case TEXT('B') :
                options |= OPTION_FLAG_BOTH;
                break;

            case TEXT('e') :
            case TEXT('E') :
                options |= OPTION_FLAG_IGNORE_ERRORS;
                break;

            default :
                Usage();
                return 1;

            }

        }

    }

    //
    // Default == install transports and namespaces.
    //

    if( ( options & ( OPTION_FLAG_BOTH ) ) == 0 ) {

        options |= OPTION_FLAG_BOTH;

    }

    if( _tcsicmp( opCode, TEXT("install") ) == 0 ) {

        InstallFromIniFile(
            iniFile,
            options
            );

    } else if( _tcsicmp( opCode, TEXT("remove") ) == 0 ) {

        RemoveFromIniFile(
            iniFile,
            options
            );

    } else {

        Usage();
        return 1;

    }

    return 0;

}   // main


//
// Private functions.
//


VOID
Usage(
    VOID
    )

/*++

Routine Description:

    Displays this utility's proper command line parameters.

Arguments:

    None.

Return Value:

    None.

--*/

{

    _ftprintf(
        stderr,
        TEXT("WS2INST 0.03 by Keith Moore %hs\n")
        TEXT("use: WS2INST Operation file.ini [Options]\n")
        TEXT("where Operation may be one of the following:\n")
        TEXT("    install - Installs service providers specified in .INI file\n")
        TEXT("    remove - Removes service providers specified in .INI file\n")
        TEXT("and Options may be one or more of the following:\n")
        TEXT("    -t - Install/remove transport providers only\n")
        TEXT("    -n - Install/remove namespace providers only\n")
        TEXT("    -b - Install/remove both (default)\n")
        TEXT("    -i - Ignore errors\n"),
        __DATE__
        );

}   // Usage


VOID
InstallFromIniFile(
    LPTSTR IniFile,
    DWORD Options
    )

/*++

Routine Description:

    Installs transports and/or namespace providers specified in the
    given .INI file.

Arguments:

    IniFile - The .INI file describing the providers to install.

    Options - Behaviour control options (OPTION_FLAG_*).

Return Value:

    None.

--*/

{

    //
    // Let the user know what we're up to.
    //

    _tprintf(
        TEXT("Installing from %s\n"),
        IniFile
        );

    //
    // Install transport providers if so requested.
    //

    if( Options & OPTION_FLAG_TRANSPORT ) {

        EnumProviderSections(
            IniFile,
            TRANSPORT_SECTION_NAME,
            InstallTransportProviderCallback,
            Options
            );

    }

    //
    // Install namespace providers if so requested.
    //

    if( Options & OPTION_FLAG_NAMESPACE ) {

        EnumProviderSections(
            IniFile,
            NAMESPACE_SECTION_NAME,
            InstallNameSpaceProviderCallback,
            Options
            );

    }

}   // InstallFromIniFile


VOID
RemoveFromIniFile(
    LPTSTR IniFile,
    DWORD Options
    )

/*++

Routine Description:

    Removes transports and/or namespace providers specified in the
    given .INI file.

Arguments:

    IniFile - The .INI file describing the providers to remove.

    Options - Behaviour control options (OPTION_FLAG_*).

Return Value:

    None.

--*/

{

    //
    // Let the user know what we're up to.
    //

    _tprintf(
        TEXT("Removing from %s\n"),
        IniFile
        );

    //
    // Remove transport providers if so requested.
    //

    if( Options & OPTION_FLAG_TRANSPORT ) {

        EnumProviderSections(
            IniFile,
            TRANSPORT_SECTION_NAME,
            RemoveTransportProviderCallback,
            Options
            );

    }

    //
    // Remove namespace providers if so requested.
    //

    if( Options & OPTION_FLAG_NAMESPACE ) {

        EnumProviderSections(
            IniFile,
            NAMESPACE_SECTION_NAME,
            RemoveNameSpaceProviderCallback,
            Options
            );

    }

}   // RemoveFromIniFile


VOID
EnumProviderSections(
    LPTSTR IniFile,
    LPTSTR SectionName,
    LPFN_ENUM_SECTION_CALLBACK Callback,
    DWORD Context
    )

/*++

Routine Description:

    Enumerates the provider sections in the specified .INI file. The
    sections must be in the following format:

        [section_name]
        ProviderCount=N
        Provider0=provider_0_name
        Provider1=provider_1_name
        Provider2=provider_2_name
                .
                .
                .
        ProviderN-1=provider_N-1_name

Arguments:

    IniFile - The .INI file containing the sections to enumerate.

    SectionName - The name of the section to enumerate.

    Callback - Pointer to a callback routine. The callback is invoked
        once for each section. The prototype for the callback is:

            BOOL
            CALLBACK
            EnumSectionProc(
                LPTSTR IniFile,
                LPTSTR ProviderSectionName,
                DWORD Context
                );

        Where:

            IniFile - The .INI filename passed into EnumProviderSections().

            ProviderSectionName - The name of the current section.

            Context - The context value passed into EnumProviderSections().

        If the callback routine returns FALSE, then the enumeration is
        aborted. If the callback routine returns TRUE, then the enumeration
        is continued.

    Context - An uninterpreted context value passed to the callback function.

Return Value:

    None.

--*/

{

    TCHAR providerSectionName[MAX_INIFILE_LINE];
    TCHAR keyName[MAX_INIFILE_LINE];
    DWORD length;
    UINT providerCount;
    UINT i;
    BOOL result;

    //
    // Get the provider count.
    //

    providerCount = GetPrivateProfileInt(
                        SectionName,
                        TEXT("ProviderCount"),
                        0,
                        IniFile
                        );

    if( providerCount == 0 ) {

        return;

    }

    //
    // Do that enumeration thang.
    //

    for( i = 0 ; i < providerCount ; i++ ) {

        wsprintf(
            keyName,
            TEXT("Provider%u"),
            i
            );

        length = GetPrivateProfileString(
                     SectionName,
                     keyName,
                     TEXT(""),
                     providerSectionName,
                     sizeof(providerSectionName) / sizeof(providerSectionName[0]),
                     IniFile
                     );

        if( length > 0 ) {

            result = (Callback)(
                         IniFile,
                         providerSectionName,
                         Context
                         );

            if( !result ) {

                break;

            }

        }

    }

}   // EnumProviderSections


BOOL
InstallTransportProviderCallback(
    LPTSTR IniFile,
    LPTSTR SectionName,
    DWORD Context
    )

/*++

Routine Description:

    Callback routine for EnumProviderSections() that installs the
    transport service provider described by the given .INI file section.

Arguments:

    IniFile - The name of the .INI file describing the transport provider.

    SectionName - The name of the .INI file section for this provider.

    Context - Actually contains behaviour control options (OPTION_FLAG_*).

Return Value:

    BOOL - TRUE if successful, FALSE otherwise.

--*/

{

    TCHAR providerName[MAX_INIFILE_LINE];
    TCHAR providerPath[MAX_INIFILE_LINE];
    TCHAR providerIdString[MAX_INIFILE_LINE];
    TCHAR protocolSectionName[MAX_INIFILE_LINE];
    UINT protocolCount;
    UINT i;
    DWORD length;
    LPWSAPROTOCOL_INFO protocolInfo;
    INT result;
    INT error;
    GUID providerId;
    RPC_STATUS status;
    BOOL ignoreErrors;

    //
    // Let the user know what we're up to.
    //

    _tprintf(
        TEXT("Installing %s\n"),
        SectionName
        );

    //
    // Determine if we should ignore errors. If so, then this routine
    // will always return TRUE.
    //

    ignoreErrors = ( ( Context & OPTION_FLAG_IGNORE_ERRORS ) != 0 );

    //
    // Read the fixed information.
    //

    length = GetPrivateProfileString(
                 SectionName,
                 TEXT("ProviderName"),
                 TEXT(""),
                 providerName,
                 sizeof(providerName) / sizeof(providerName[0]),
                 IniFile
                 );

    if( length == 0 ) {

        _tprintf(
            TEXT("ERROR: missing ProviderName key\n")
            );

        return ignoreErrors;

    }

    length = GetPrivateProfileString(
                 SectionName,
                 TEXT("ProviderPath"),
                 TEXT(""),
                 providerPath,
                 sizeof(providerPath) / sizeof(providerPath[0]),
                 IniFile
                 );

    if( length == 0 ) {

        _tprintf(
            TEXT("ERROR: missing ProviderPath key\n")
            );

        return ignoreErrors;

    }

    protocolCount = GetPrivateProfileInt(
                        SectionName,
                        TEXT("ProtocolCount"),
                        0,
                        IniFile
                        );

    if( protocolCount == 0 ) {

        _tprintf(
            TEXT("ERROR: missing ProtocolCount key\n")
            );

        return ignoreErrors;

    }

    length = GetPrivateProfileString(
                 SectionName,
                 TEXT("ProviderId"),
                 TEXT(""),
                 providerIdString,
                 sizeof(providerIdString) / sizeof(providerIdString[0]),
                 IniFile
                 );

    if( length == 0 ) {

        _tprintf(
            TEXT("ERROR: missing ProviderId key\n")
            );

        return ignoreErrors;

    }

    //
    // Build the GUID.
    //

    status = UuidFromString(
                 providerIdString,
                 &providerId
                 );

    if( status != RPC_S_OK ) {

        _tprintf(
            TEXT("ERROR: invalid ProviderId %s\n"),
            providerIdString
            );

        return ignoreErrors;

    }

    //
    // Allocate the space for the protocol info structures.
    //

    protocolInfo = malloc( protocolCount * sizeof(*protocolInfo) );

    if( protocolInfo == NULL ) {

        _tprintf(
            TEXT("ERROR: out of memory\n")
            );

        return ignoreErrors;

    }

    //
    // Enumerate the protocols.
    //

    for( i = 0 ; i < protocolCount ; i++ ) {

        //
        // Build the section name for this protocol.
        //

        wsprintf(
            protocolSectionName,
            TEXT("%s Protocol %u"),
            SectionName,
            i
            );

        //
        // Read the individual protocol info.
        //

        protocolInfo[i].dwServiceFlags1 = (DWORD)GetPrivateProfileInt(
                                              protocolSectionName,
                                              TEXT("dwServiceFlags1"),
                                              0,
                                              IniFile
                                              );

        protocolInfo[i].dwServiceFlags2 = (DWORD)GetPrivateProfileInt(
                                              protocolSectionName,
                                              TEXT("dwServiceFlags2"),
                                              0,
                                              IniFile
                                              );

        protocolInfo[i].dwServiceFlags3 = (DWORD)GetPrivateProfileInt(
                                              protocolSectionName,
                                              TEXT("dwServiceFlags3"),
                                              0,
                                              IniFile
                                              );

        protocolInfo[i].dwServiceFlags4 = (DWORD)GetPrivateProfileInt(
                                              protocolSectionName,
                                              TEXT("dwServiceFlags4"),
                                              0,
                                              IniFile
                                              );

        protocolInfo[i].dwProviderFlags = (DWORD)GetPrivateProfileInt(
                                              protocolSectionName,
                                              TEXT("dwProviderFlags"),
                                              0,
                                              IniFile
                                              );

        protocolInfo[i].iVersion = (DWORD)GetPrivateProfileInt(
                                       protocolSectionName,
                                       TEXT("iVersion"),
                                       0,
                                       IniFile
                                       );

        protocolInfo[i].iAddressFamily = (DWORD)GetPrivateProfileInt(
                                              protocolSectionName,
                                              TEXT("iAddressFamily"),
                                              0,
                                              IniFile
                                              );

        protocolInfo[i].iMaxSockAddr = (DWORD)GetPrivateProfileInt(
                                           protocolSectionName,
                                           TEXT("iMaxSockAddr"),
                                           0,
                                           IniFile
                                           );

        protocolInfo[i].iMinSockAddr = (DWORD)GetPrivateProfileInt(
                                           protocolSectionName,
                                           TEXT("iMinSockAddr"),
                                           0,
                                           IniFile
                                           );

        protocolInfo[i].iSocketType = (DWORD)GetPrivateProfileInt(
                                          protocolSectionName,
                                          TEXT("iSocketType"),
                                          0,
                                          IniFile
                                          );

        protocolInfo[i].iProtocol = (DWORD)GetPrivateProfileInt(
                                        protocolSectionName,
                                        TEXT("iProtocol"),
                                        0,
                                        IniFile
                                        );

        protocolInfo[i].iProtocolMaxOffset = (DWORD)GetPrivateProfileInt(
                                                 protocolSectionName,
                                                 TEXT("iProtocolMaxOffset"),
                                                 0,
                                                 IniFile
                                                 );

        protocolInfo[i].iNetworkByteOrder = (DWORD)GetPrivateProfileInt(
                                                protocolSectionName,
                                                TEXT("iNetworkByteOrder"),
                                                0,
                                                IniFile
                                                );

        protocolInfo[i].iSecurityScheme = (DWORD)GetPrivateProfileInt(
                                              protocolSectionName,
                                              TEXT("iSecurityScheme"),
                                              0,
                                              IniFile
                                              );

        protocolInfo[i].dwMessageSize = (DWORD)GetPrivateProfileInt(
                                            protocolSectionName,
                                            TEXT("dwMessageSize"),
                                            0,
                                            IniFile
                                            );

        protocolInfo[i].dwProviderReserved = (DWORD)GetPrivateProfileInt(
                                                 protocolSectionName,
                                                 TEXT("dwProviderReserved"),
                                                 0,
                                                 IniFile
                                                 );

        length = GetPrivateProfileString(
                     protocolSectionName,
                     TEXT("szProtocol"),
                     TEXT(""),
                     protocolInfo[i].szProtocol,
                     sizeof(protocolInfo[i].szProtocol) / sizeof(protocolInfo[i].szProtocol[0]),
                     IniFile
                     );

        if( length == 0 ) {

            _tprintf(
                TEXT("ERROR: missing szProtocol key\n")
                );

            free( protocolInfo );
            return ignoreErrors;

        }

    }

    //
    // OK, we've got the protocol data, now just ask WS2_32.DLL to
    // install 'em.
    //

    result = WSCInstallProvider(
                 &providerId,
                 providerPath,
                 protocolInfo,
                 (DWORD)protocolCount,
                 &error
                 );

    free( protocolInfo );

    if( result == SOCKET_ERROR ) {

        _tprintf(
            TEXT("Cannot install %s, error %d\n"),
            providerName,
            error
            );

        return ignoreErrors;

    }

    return TRUE;

}   // InstallTransportProviderCallback


BOOL
RemoveTransportProviderCallback(
    LPTSTR IniFile,
    LPTSTR SectionName,
    DWORD Context
    )

/*++

Routine Description:

    Callback routine for EnumProviderSections() that removes the
    transport service provider described by the given .INI file section.

Arguments:

    IniFile - The name of the .INI file describing the transport provider.

    SectionName - The name of the .INI file section for this provider.

    Context - Actually contains behaviour control options (OPTION_FLAG_*).

Return Value:

    BOOL - TRUE if successful, FALSE otherwise.

--*/

{


    TCHAR providerName[MAX_INIFILE_LINE];
    TCHAR providerIdString[MAX_INIFILE_LINE];
    DWORD length;
    INT result;
    INT error;
    GUID providerId;
    RPC_STATUS status;
    BOOL ignoreErrors;

    //
    // Let the user know what we're up to.
    //

    _tprintf(
        TEXT("Removing %s\n"),
        SectionName
        );

    //
    // Determine if we should ignore errors. If so, then this routine
    // will always return TRUE.
    //

    ignoreErrors = ( ( Context & OPTION_FLAG_IGNORE_ERRORS ) != 0 );

    //
    // Read the provider name & ID.
    //

    length = GetPrivateProfileString(
                 SectionName,
                 TEXT("ProviderName"),
                 TEXT(""),
                 providerName,
                 sizeof(providerName) / sizeof(providerName[0]),
                 IniFile
                 );

    if( length == 0 ) {

        _tprintf(
            TEXT("ERROR: missing ProviderName key\n")
            );

        return ignoreErrors;

    }

    length = GetPrivateProfileString(
                     SectionName,
                     TEXT("ProviderId"),
                     TEXT(""),
                     providerIdString,
                     sizeof(providerIdString) / sizeof(providerIdString[0]),
                     IniFile
                     );

    if( length == 0 ) {

        _tprintf(
            TEXT("ERROR: missing ProviderId key\n")
            );

        return ignoreErrors;

    }

    //
    // Build the GUID.
    //

    status = UuidFromString(
                 providerIdString,
                 &providerId
                 );

    if( status != RPC_S_OK ) {

        _tprintf(
            TEXT("ERROR: invalid ProviderId %s\n"),
            providerIdString
            );

        return ignoreErrors;

    }

    //
    // Remove it.
    //

    result = WSCDeinstallProvider(
                 &providerId,
                 &error
                 );

    if( result == SOCKET_ERROR ) {

        _tprintf(
            TEXT("Cannot remove %s, error %d\n"),
            providerName,
            error
            );

        return ignoreErrors;

    }

    return TRUE;

}   // RemoveTransportProviderCallback


BOOL
InstallNameSpaceProviderCallback(
    LPTSTR IniFile,
    LPTSTR SectionName,
    DWORD Context
    )

/*++

Routine Description:

    Callback routine for EnumProviderSections() that installs the
    namespace service provider described by the given .INI file section.

Arguments:

    IniFile - The name of the .INI file describing the namespace provider.

    SectionName - The name of the .INI file section for this provider.

    Context - Actually contains behaviour control options (OPTION_FLAG_*).

Return Value:

    BOOL - TRUE if successful, FALSE otherwise.

--*/

{

    TCHAR providerName[MAX_INIFILE_LINE];
    TCHAR providerPath[MAX_INIFILE_LINE];
    TCHAR providerIdString[MAX_INIFILE_LINE];
    UINT i;
    DWORD length;
    INT result;
    INT error;
    GUID providerId;
    DWORD nameSpaceId;
    RPC_STATUS status;
    BOOL ignoreErrors;

    //
    // Let the user know what we're up to.
    //

    _tprintf(
        TEXT("Installing %s\n"),
        SectionName
        );

    //
    // Determine if we should ignore errors. If so, then this routine
    // will always return TRUE.
    //

    ignoreErrors = ( ( Context & OPTION_FLAG_IGNORE_ERRORS ) != 0 );

    //
    // Read the fixed information.
    //

    length = GetPrivateProfileString(
                 SectionName,
                 TEXT("ProviderName"),
                 TEXT(""),
                 providerName,
                 sizeof(providerName) / sizeof(providerName[0]),
                 IniFile
                 );

    if( length == 0 ) {

        _tprintf(
            TEXT("ERROR: missing ProviderName key\n")
            );

        return ignoreErrors;

    }

    length = GetPrivateProfileString(
                 SectionName,
                 TEXT("ProviderPath"),
                 TEXT(""),
                 providerPath,
                 sizeof(providerPath) / sizeof(providerPath[0]),
                 IniFile
                 );

    if( length == 0 ) {

        _tprintf(
            TEXT("ERROR: missing ProviderPath key\n")
            );

        return ignoreErrors;

    }

    length = GetPrivateProfileString(
                 SectionName,
                 TEXT("ProviderId"),
                 TEXT(""),
                 providerIdString,
                 sizeof(providerIdString) / sizeof(providerIdString[0]),
                 IniFile
                 );

    if( length == 0 ) {

        _tprintf(
            TEXT("ERROR: missing ProviderId key\n")
            );

        return ignoreErrors;

    }

    //
    // Build the GUID.
    //

    status = UuidFromString(
                 providerIdString,
                 &providerId
                 );

    if( status != RPC_S_OK ) {

        _tprintf(
            TEXT("ERROR: invalid ProviderId %s\n"),
            providerIdString
            );

        return ignoreErrors;

    }

    nameSpaceId = GetPrivateProfileInt(
                      SectionName,
                      TEXT("NameSpaceId"),
                      0,
                      IniFile
                      );

    if( nameSpaceId == 0 ) {

        _tprintf(
            TEXT("ERROR: missing NameSpaceId key\n")
            );

        return ignoreErrors;

    }

    //
    // Install it.
    //

    result = WSCInstallNameSpace(
                 providerName,
                 providerPath,
                 nameSpaceId,
                 2,
                 &providerId
                 );

    if( result == SOCKET_ERROR ) {

        error = GetLastError();

        _tprintf(
            TEXT("Cannot install %s, error %d\n"),
            providerName,
            error
            );

        return ignoreErrors;

    }

    return TRUE;

}   // InstallNameSpaceProviderCallback


BOOL
RemoveNameSpaceProviderCallback(
    LPTSTR IniFile,
    LPTSTR SectionName,
    DWORD Context
    )

/*++

Routine Description:

    Callback routine for EnumProviderSections() that removes the
    namespace service provider described by the given .INI file section.

Arguments:

    IniFile - The name of the .INI file describing the namespace provider.

    SectionName - The name of the .INI file section for this provider.

    Context - Actually contains behaviour control options (OPTION_FLAG_*).

Return Value:

    BOOL - TRUE if successful, FALSE otherwise.

--*/

{


    TCHAR providerName[MAX_INIFILE_LINE];
    TCHAR providerIdString[MAX_INIFILE_LINE];
    DWORD length;
    INT result;
    INT error;
    GUID providerId;
    RPC_STATUS status;
    BOOL ignoreErrors;

    //
    // Let the user know what we're up to.
    //

    _tprintf(
        TEXT("Removing %s\n"),
        SectionName
        );

    //
    // Determine if we should ignore errors. If so, then this routine
    // will always return TRUE.
    //

    ignoreErrors = ( ( Context & OPTION_FLAG_IGNORE_ERRORS ) != 0 );

    //
    // Read the provider name & ID.
    //

    length = GetPrivateProfileString(
                 SectionName,
                 TEXT("ProviderName"),
                 TEXT(""),
                 providerName,
                 sizeof(providerName) / sizeof(providerName[0]),
                 IniFile
                 );

    if( length == 0 ) {

        _tprintf(
            TEXT("ERROR: missing ProviderName key\n")
            );

        return ignoreErrors;

    }

    length = GetPrivateProfileString(
                     SectionName,
                     TEXT("ProviderId"),
                     TEXT(""),
                     providerIdString,
                     sizeof(providerIdString) / sizeof(providerIdString[0]),
                     IniFile
                     );

    if( length == 0 ) {

        _tprintf(
            TEXT("ERROR: missing ProviderId key\n")
            );

        return ignoreErrors;

    }

    //
    // Build the GUID.
    //

    status = UuidFromString(
                 providerIdString,
                 &providerId
                 );

    if( status != RPC_S_OK ) {

        _tprintf(
            TEXT("ERROR: invalid ProviderId %s\n"),
            providerIdString
            );

        return ignoreErrors;

    }

    //
    // Remove it.
    //

    result = WSCUnInstallNameSpace(
                 &providerId
                 );

    if( result == SOCKET_ERROR ) {

        error = GetLastError();

        _tprintf(
            TEXT("Cannot remove %s, error %d\n"),
            providerName,
            error
            );

        return ignoreErrors;

    }

    return TRUE;

}   // RemoveNameSpaceProviderCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\ws2help\resource.h ===
#define WS2IFSL_SERVICE_DISPLAY_NAME_STR    1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\ws2help\precomp.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Master include file for the WinSock 2.0 helper DLL.

Author:

    Keith Moore (keithmo)       08-Nov-1995

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdio.h>
#include <malloc.h>


#define INCL_WINSOCK_API_TYPEDEFS 1
#include <winsock2.h>
#include <windows.h>
#include <tchar.h>
#include <ws2spi.h>
#include <ws2help.h>


#include <tdi.h>
#include <afd.h>

#if DBG
#define DBG_FAILURES        0x80000000
#define DBG_PROCESS         0x40000000
#define DBG_SOCKET          0x20000000
#define DBG_COMPLETE        0x10000000
#define DBG_APC_THREAD      0x08000000
#define DBG_WINSOCK_APC     0x04000000
#define DBG_REQUEST			0x02000000
#define DBG_CANCEL          0x01000000
#define DBG_DRIVER_READ		0x00800000
#define DBG_DRIVER_WRITE	0x00400000
#define DBG_DRIVER_SEND		0x00200000
#define DBG_DRIVER_RECV		0x00100000
#define DBG_SERVICE         0x00080000
#define DBG_NOTIFY          0x00040000

#define WS2IFSL_DEBUG_KEY   "System\\CurrentControlSet\\Services\\Ws2IFSL\\Parameters\\ProcessDebug"
extern DWORD       PID;
extern ULONG       DbgLevel;
extern VOID        ReadDbgInfo (VOID);

#define WshPrint(COMPONENT,ARGS)	\
	do {						    \
		if (DbgLevel&COMPONENT){    \
			DbgPrint ARGS;		    \
		}						    \
	} while (0)
//
// Define an assert that actually works even on a free build.
//

#define WS_ASSERT(exp)                                              \
        ((exp)                                                      \
            ? 0                                                     \
            : (DbgPrint( "\n*** Assertion failed: %s\n"             \
                        "***   Source File: %s, line %ld\n\n",      \
                    #exp,__FILE__, __LINE__), DbgBreakPoint()))     \



#else
#define WshPrint(COMPONENT,ARGS) do {NOTHING;} while (0)
#define WS_ASSERT(exp)
#endif

#undef ASSERT
#define ASSERT WS_ASSERT

extern HINSTANCE            LibraryHdl;
extern PSECURITY_DESCRIPTOR pSDPipe;
extern CRITICAL_SECTION     StartupSyncronization;
extern BOOL                 Ws2helpInitialized;
extern HANDLE               ghWriterEvent;
DWORD
Ws2helpInitialize (
    VOID
    );

#define ENTER_WS2HELP_API()                                         \
    (Ws2helpInitialized ? 0 : Ws2helpInitialize())

VOID
NewCtxInit (
    VOID
    );

#include <ws2ifsl.h>

#define ALLOC_MEM(cb)       (LPVOID)GlobalAlloc(                    \
                                GPTR,                               \
                                (cb)                                \
                                )

#define REALLOC_MEM(p,cb)   (LPVOID)GlobalReAlloc(                  \
                                (HGLOBAL)(p),                       \
                                (cb),                               \
                                (GMEM_MOVEABLE | GMEM_ZEROINIT)     \
                                )

#define FREE_MEM(p)         (VOID)GlobalFree(                       \
                                (HGLOBAL)(p)                        \
                                )

#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\inc\ws2ifsl.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    WS2IFSL.H

Abstract:

    This module defines interface for Winsock2 IFS transport layer driver.

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:

    Vadim Eydelman (VadimE)    Oct-1997, rewrite to properly handle IRP
                                        cancellation
--*/

#ifndef _WS2IFSL_
#define _WS2IFSL_

// Macro to align address data in the output buffer
#define ADDR_ALIGN(sz)  (((sz)+1)&(~3))

// Parameters for IOCTL_WS2IFSL_RETRIEVE_DRV_REQ
typedef struct _WS2IFSL_RTRV_PARAMS {
    IN ULONG                    UniqueId;       // Unique ID
    OUT PVOID                   DllContext;     // Context associated by dll
                                                // with the socket file.
	OUT ULONG				    RequestType;    // Request type
#define WS2IFSL_REQUEST_READ            0
#define WS2IFSL_REQUEST_WRITE           1
#define WS2IFSL_REQUEST_SENDTO          2
#define WS2IFSL_REQUEST_RECV            3
#define WS2IFSL_REQUEST_RECVFROM        4
#define WS2IFSL_REQUEST_QUERYHANDLE     5
    OUT ULONG                   DataLen;        // Length of data/buffer
    OUT ULONG                   AddrLen;        // Length of addr/buffer
    OUT ULONG                   Flags;          // Flags
} WS2IFSL_RTRV_PARAMS, *PWS2IFSL_RTRV_PARAMS;

// Parameters for IOCTL_WS2IFSL_COMPLETE_DRV_REQ
typedef struct _WS2IFSL_CMPL_PARAMS {
    IN HANDLE                   SocketHdl;      // Handle of socket object
    IN ULONG                    UniqueId;       // Unique ID
    IN ULONG                    DataLen;        // Length of data to copy/report
    IN ULONG                    AddrLen;        // Length of addr to copy and report
    IN NTSTATUS                 Status;         // Completion status
} WS2IFSL_CMPL_PARAMS, *PWS2IFSL_CMPL_PARAMS;

// Parameters for IOCTL_WS2IFSL_COMPLETE_DRV_CAN
typedef struct _WS2IFSL_CNCL_PARAMS {
    IN ULONG                    UniqueId;       // Unique ID
} WS2IFSL_CNCL_PARAMS, *PWS2IFSL_CNCL_PARAMS;

// Socket context parameters
typedef struct _WS2IFSL_SOCKET_CTX {
	PVOID					DllContext;     // Context value to be associated
                                            // with the socket
	HANDLE					ProcessFile;    // Process file handle for the
                                            // current process
} WS2IFSL_SOCKET_CTX, *PWS2IFSL_SOCKET_CTX;

// Process context parameters
typedef struct _WS2IFSL_PROCESS_CTX {
    HANDLE                  ApcThread;      // Thread to queue APC's to
    PPS_APC_ROUTINE         RequestRoutine; // APC routine to pass requests
    PPS_APC_ROUTINE         CancelRoutine;  // APC routine to pass cancel
    PVOID                   ApcContext;     // Apc routine context
    ULONG                   DbgLevel;       // Used only in debug builds,
                                            // (0 on free DLL builds and ignored
                                            // by the free driver)
} WS2IFSL_PROCESS_CTX, *PWS2IFSL_PROCESS_CTX;



// WS2IFSL device name
#define WS2IFSL_DEVICE_NAME    L"\\Device\\WS2IFSL"
#define WS2IFSL_SOCKET_FILE_NAME    WS2IFSL_DEVICE_NAME L"\\NifsSct"
#define WS2IFSL_PROCESS_FILE_NAME   WS2IFSL_DEVICE_NAME L"\\NifsPvd"

// Extended attribute names for the WS2IFSL files (note that size of the
// string (including terminating NULL) is carefully chosen to ensure 
// quad word alignment of the attribute value):
//  Socket file
#define WS2IFSL_SOCKET_EA_NAME          "NifsSct"
#define WS2IFSL_SOCKET_EA_NAME_LENGTH   (sizeof(WS2IFSL_SOCKET_EA_NAME)-1)
#define WS2IFSL_SOCKET_EA_VALUE_LENGTH  (sizeof(WS2IFSL_SOCKET_CTX))
#define WS2IFSL_SOCKET_EA_VALUE_OFFSET                                      \
               (FIELD_OFFSET(FILE_FULL_EA_INFORMATION,                      \
                        EaName[WS2IFSL_SOCKET_EA_NAME_LENGTH+1]))           
#define GET_WS2IFSL_SOCKET_EA_VALUE(eaInfo)                                 \
                ((PWS2IFSL_SOCKET_CTX)(                                     \
                    (PUCHAR)eaInfo +WS2IFSL_SOCKET_EA_VALUE_OFFSET))
#define WS2IFSL_SOCKET_EA_INFO_LENGTH                                       \
                (WS2IFSL_SOCKET_EA_VALUE_OFFSET+WS2IFSL_SOCKET_EA_VALUE_LENGTH)

//  Process file
#define WS2IFSL_PROCESS_EA_NAME         "NifsPvd"
#define WS2IFSL_PROCESS_EA_NAME_LENGTH  (sizeof(WS2IFSL_PROCESS_EA_NAME)-1)
#define WS2IFSL_PROCESS_EA_VALUE_LENGTH (sizeof(WS2IFSL_PROCESS_CTX))
#define WS2IFSL_PROCESS_EA_VALUE_OFFSET                                     \
               (FIELD_OFFSET(FILE_FULL_EA_INFORMATION,                      \
                        EaName[WS2IFSL_PROCESS_EA_NAME_LENGTH+1]))           
#define GET_WS2IFSL_PROCESS_EA_VALUE(eaInfo)                                \
                ((PWS2IFSL_PROCESS_CTX)(                                    \
                    (PUCHAR)eaInfo +WS2IFSL_PROCESS_EA_VALUE_OFFSET))
#define WS2IFSL_PROCESS_EA_INFO_LENGTH                                      \
                (WS2IFSL_PROCESS_EA_VALUE_OFFSET+WS2IFSL_PROCESS_EA_VALUE_LENGTH)

// All WS2IFSL IOCTL are private and should be out of range
// reserved by Microsoft for public codes
#define WS2IFSL_IOCTL_PROCESS_BASE       0x00000800
#define WS2IFSL_IOCTL_SOCKET_BASE        0x00000810

// Choice of device type implies access priviliges
#define FILE_DEVICE_WS2IFSL     FILE_DEVICE_NAMED_PIPE

// Macro that simplifies definition of WS2IFSL control codes
#define IOCTL_WS2IFSL(File,Function,Method)             \
            CTL_CODE (                                  \
	            FILE_DEVICE_WS2IFSL,                    \
                WS2IFSL_IOCTL_##File##_BASE+Function,   \
                Method,                                 \
                FILE_ANY_ACCESS)



/*
 *  IOCTL:      RETRIEVE_DRV_REQ
 *  File:       Process
 *  Purpose:    Retreive request to be executed by the DLL
 *  Paremeters: InputBuffer         - WS2IFSL_RTRV_PARAMS
 *              InputBufferLength   - sizeof (WS2IFSL_RTRV_PARAMS)
 *              OutputBuffer        - buffer for request
 *              OutputBufferLength  - size of the buffer
 *  Returns:    
 *              STATUS_SUCCESS      - driver request copied ok, no more
 *                                      requests pending
 *              STATUS_MORE_ENTRIES - driver request copied ok, another
 *                                      one is pending.
 *              STATUS_CANCELLED    - request was cancelled
 *              STATUS_NOT_IMPLEMENTED - opretion was performed on file
 *                                      that is not WS2IFSL process file
 *              STATUS_INVALID_PARAMETER - one of the parameters is invalid
 *              STATUS_NOT_IMPLEMENTED - opretion was performed on file
 *                                      that is not WS2IFSL process file
 */
#define IOCTL_WS2IFSL_RETRIEVE_DRV_REQ  IOCTL_WS2IFSL (PROCESS,0,METHOD_NEITHER)

/*
 *  IOCTL:      COMPLETE_DRV_CAN
 *  File:       Process
 *  Purpose:    Completes cancel request executed by the DLL
 *  Paremeters: InputBuffer         - WS2IFSL_CNCL_PARAMS
 *              InputBufferLength   - sizeof (WS2IFSL_CNCL_PARAMS)
 *              OutputBuffer        - NULL
 *              OutputBufferLength  - 0
 *  Returns:    
 *              STATUS_SUCCESS      - driver completed copied ok, no more
 *                                      requests pending.
 *              STATUS_MORE_ENTRIES - driver request completed ok, another
 *                                      one is pending.
 *              STATUS_INVALID_PARAMETER - one of the parameters is invalid
 *              STATUS_NOT_IMPLEMENTED - opretion was performed on file
 *                                      that is not WS2IFSL process file
 */
#define IOCTL_WS2IFSL_COMPLETE_DRV_CAN  IOCTL_WS2IFSL (PROCESS,1,METHOD_NEITHER)

/*
 *  IOCTL:      COMPLETE_DRV_REQ
 *  File:       Socket
 *  Purpose:    Completes request retrived from driver.
 *  Paremeters: InputBuffer         - WS2IFSL_CMPL_PARAMS
 *              InputBufferLength   - sizeof (WS2IFSL_CMPL_PARAMS)
 *              OutputBuffer        - buffer for request
 *              OutputBufferLength  - size of the buffer
 *
 *  Returns:    STATUS_SUCCESS - operation completed OK.
 *              STATUS_CANCELLED - operation was cancelled already.
 *              STATUS_NOT_IMPLEMENTED - opretion was performed on file
 *                                      that is not WS2IFSL process file
 *              STATUS_INVALID_PARAMETER - size of input buffer is invalid
 */
#define IOCTL_WS2IFSL_COMPLETE_DRV_REQ  IOCTL_WS2IFSL (PROCESS,2,METHOD_NEITHER)

/*
 *  IOCTL:      SET_SOCKET_CONTEXT
 *  File:       Socket
 *  Purpose:    Sets socket process context and associates context value
 *              with the socket (passed as a parameter to the APC routine).
 *  Paremeters: InputBuffer         - PWS2IFSL_SOCKET_CTX, socket context
 *                                      parameters
 *              InputBufferLength   - sizeof(WS2IFSL_SOCKET_CTX)
 *              OutputBuffer        - not used (NULL)
 *              OutputBufferLength  - not used (0)
 *  Returns:    STATUS_SUCCESS      - socket context established OK
 *              STATUS_INSUFFICIENT_RESOURCES - not enough resouces to
 *                                      perform the operation
 *              STATUS_INVALID_PARAMETER - size if input buffer ProcessFile
 *                                      parameter are invalid
 *              STATUS_NOT_IMPLEMENTED - opretion was performed on file
 *                                      that is not WS2IFSL socket file
 */
#define IOCTL_WS2IFSL_SET_SOCKET_CONTEXT    IOCTL_WS2IFSL (SOCKET,0,METHOD_NEITHER)


/*
 *  IOCTL:      COMPLETE_PVD_REQ
 *  File:       Socket
 *  Purpose:    Completes asynchronous requests for providers.
 *  Paremeters: InputBuffer         - PIO_STATUS_INFORMATION, status information
 *                                      for the request being completed
 *              InputBufferLength   - sizeof(IO_STATUS_INFORMATION)
 *              OutputBuffer        - NULL
 *              OutputBufferLength  - 0
 *  Returns:    Status field of IO_STATUS_INFORMATION structure.
 *              STATUS_NOT_IMPLEMENTED - opretion was performed on file
 *                                      that is not WS2IFSL socket file
 *              STATUS_INVALID_PARAMETER - size of input buffer is invalid
 */
#define IOCTL_WS2IFSL_COMPLETE_PVD_REQ  IOCTL_WS2IFSL (SOCKET,1,METHOD_NEITHER)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\ws2help\context.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    context.c

Abstract:

    This module implements functions for creating and manipulating context
    tables. Context tables are used in WinSock 2.0 for associating 32-bit
    context values with socket handles.

Author:

    Keith Moore (keithmo)       08-Nov-1995

Revision History:

--*/


#include "precomp.h"


//
//  Private constants.
//

//
// INITIAL_ARRAY_ENTRIES is the initial number of lookup array entries
// in a newly created context table.
//
// ARRAY_GROWTH_DELTA is the growth delta used when growing the lookup
// array.
//

#define INITIAL_ARRAY_ENTRIES   256
#define ARRAY_GROWTH_DELTA      256

//
// TABLE_TO_LOCK() returns a pointer to a CONTEXT_TABLE's CRITICAL_SECTION
// object. This macro is only valid if the WAH_CONTEXT_FLAG_SERIALIZE bit
// is set in the Flags DWORD.
//

#define TABLE_TO_LOCK(t)        ((LPCRITICAL_SECTION)((t) + 1))

//
// LOCK_TABLE locks a CONTEXT_TABLE, if the CONTEXT_TABLE is serialized.
//
// UNLOCK_TABLE unlocks a CONTEXT_TABLE, if the CONTEXT_TABLE is serialized.
//

#define LOCK_TABLE(t)                                           \
            if( (t)->Flags & WAH_CONTEXT_FLAG_SERIALIZE ) {     \
                EnterCriticalSection( TABLE_TO_LOCK(t) );       \
            } else

#define UNLOCK_TABLE(t)                                         \
            if( (t)->Flags & WAH_CONTEXT_FLAG_SERIALIZE ) {     \
                LeaveCriticalSection( TABLE_TO_LOCK(t) );       \
            } else

//
// Map a SOCKET to a KEY.
//

#ifdef CHICAGO
#define SOCKET_TO_KEY(s)        ((DWORD)(s))
#else
#define SOCKET_TO_KEY(s)        ((DWORD)(s) >> 2)
#endif


//
//  Private types.
//

typedef struct _CONTEXT_TABLE {

    DWORD Flags;
    DWORD LookupArraySize;
    LPVOID * LookupArray;

} CONTEXT_TABLE;


//
//  Public functions.
//


DWORD
WINAPI
WahCreateContextTable(
    LPCONTEXT_TABLE * Table,
    DWORD Flags
    )

/*++

Routine Description:

    Creates a new context table.

Arguments:

    Table - If successful, receives a pointer to the newly created context
        table.

    Flags - Flags to control the tables behaviour.

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/

{

    DWORD newTableSize;
    LPCONTEXT_TABLE newTable;

    //
    // Create the new context table.
    //

    newTableSize = sizeof(*newTable);

    if( Flags & WAH_CONTEXT_FLAG_SERIALIZE ) {

        newTableSize += sizeof(CRITICAL_SECTION);

    }

    newTable = ALLOC_MEM( newTableSize );

    if( newTable != NULL ) {

        //
        // Initialize it.
        //

        if( Flags & WAH_CONTEXT_FLAG_SERIALIZE ) {

            InitializeCriticalSection( TABLE_TO_LOCK( newTable ) );

        }

        newTable->Flags = Flags;
        newTable->LookupArraySize = INITIAL_ARRAY_ENTRIES;

        newTable->LookupArray = ALLOC_MEM( INITIAL_ARRAY_ENTRIES * sizeof(LPVOID) );

        if( newTable->LookupArray != NULL ) {

            //
            // Success!
            //

            *Table = newTable;
            return NO_ERROR;

        }

        //
        // Allocated the CONTEXT_TABLE, but could not allocate the
        // lookup array. Bummer.
        //

        FREE_MEM( newTable );
        newTable = NULL;

    }

    *Table = newTable;
    return ERROR_NOT_ENOUGH_MEMORY;

}   // WahCreateContextTable


DWORD
WINAPI
WahDestroyContextTable(
    LPCONTEXT_TABLE Table
    )

/*++

Routine Description:

    Destroys an existing context table.

Arguments:

    Table - A pointer to the table to destroy.

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/

{

    //
    // Delete the context table's critical section if necessary.
    //

    if( Table->Flags & WAH_CONTEXT_FLAG_SERIALIZE ) {

        DeleteCriticalSection( TABLE_TO_LOCK( Table ) );

    }

    //
    // Free the resources.
    //

    FREE_MEM( Table->LookupArray );
    FREE_MEM( Table );

    //
    // Success!
    //

    return NO_ERROR;

}   // WahDestroyContextTable


DWORD
WINAPI
WahSetContext(
    LPCONTEXT_TABLE Table,
    SOCKET Socket,
    LPVOID Context
    )

/*++

Routine Description:

    Associates the given context with the given key.

Arguments:

    Table - The table to contain the new context.

    Socket - The key to index the new context.

    Context - The new context.

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/

{

    DWORD newLookupArraySize;
    LPVOID * newLookupArray;
    DWORD key = SOCKET_TO_KEY( Socket );

    //
    // Acquire the lock protecting the context table.
    //

    LOCK_TABLE( Table );

    //
    // Determine if we can do this without growing the lookup array.
    //

    if( Table->LookupArraySize > key ) {

        Table->LookupArray[key] = Context;
        UNLOCK_TABLE( Table );
        return NO_ERROR;

    }

    //
    // We'll need to grow the lookup array first.
    //

    newLookupArraySize = Table->LookupArraySize +
        ARRAY_GROWTH_DELTA *
            ( ( ( key - Table->LookupArraySize ) / ARRAY_GROWTH_DELTA ) + 1 );

    newLookupArray = REALLOC_MEM(
                         Table->LookupArray,
                         newLookupArraySize * sizeof(LPVOID)
                         );

    if( newLookupArray != NULL ) {

        Table->LookupArray = newLookupArray;
        Table->LookupArraySize = newLookupArraySize;
        Table->LookupArray[key] = Context;
        UNLOCK_TABLE( Table );
        return NO_ERROR;

    }

    //
    // Error growing the lookup array.
    //

    UNLOCK_TABLE( Table );
    return ERROR_NOT_ENOUGH_MEMORY;

}   // WahSetContext


DWORD
WINAPI
WahGetContext(
    LPCONTEXT_TABLE Table,
    SOCKET Socket,
    LPVOID * Context
    )

/*++

Routine Description:

    Retrieves the context associated with the given key.

Arguments:

    Table - The table to use for the context lookup.

    Socket - The key to lookup.

    Context - If successful, receives the context value.

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/

{

    DWORD key = SOCKET_TO_KEY( Socket );

    //
    // Acquire the lock protecting the context table.
    //

    LOCK_TABLE( Table );

    //
    // Validate the key before indexing into the lookup array.
    //

    if( key < Table->LookupArraySize ) {

        *Context = Table->LookupArray[key];

        if( *Context != NULL ) {

            UNLOCK_TABLE( Table );
            return NO_ERROR;

        }

    }

    //
    // Invalid key.
    //

    UNLOCK_TABLE( Table );

    return ERROR_INVALID_PARAMETER;

}   // WahGetContext


DWORD
WINAPI
WahRemoveContextEx(
    LPCONTEXT_TABLE Table,
    SOCKET Socket,
    LPVOID Context
    )

/*++

Routine Description:

    Removes a context association from the given table.

Arguments:

    Table - The table to remove the context from.

    Socket - The key to remove.

    Context - the context that should be in the table

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/

{

    DWORD key = SOCKET_TO_KEY( Socket );
    DWORD err;

    //
    // Acquire the lock protecting the context table.
    //

    LOCK_TABLE( Table );

    //
    // Validate the key before indexing into the lookup array.
    //

    if( key < Table->LookupArraySize ) {

        if( !Context || ( Table->LookupArray[key] == Context ) ) {

            Table->LookupArray[key] = NULL;
            err = NO_ERROR;

        } else {

            if( Table->LookupArray[key] ) {

                err = ERROR_FILE_EXISTS;

            } else {

                err = ERROR_DEV_NOT_EXIST;

            }

        }

    } else {

        err = ERROR_INVALID_PARAMETER;

    }

    //
    // Cleanup and return
    //

    UNLOCK_TABLE( Table );
    return err;

}   // WahRemoveContextEx


DWORD
WINAPI
WahRemoveContext(
    LPCONTEXT_TABLE Table,
    SOCKET Socket
    )
{

    return WahRemoveContextEx( Table, Socket, NULL );

}   // WahRemoveContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\ws2help\sources.inc ===
TARGETNAME=ws2help
TARGETTYPE=DYNLINK

TARGETLIBS=\
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SDK_LIB_PATH)\kernel32.lib

INCLUDES=..\;..\..\inc;..\..\..\inc

C_DEFINES=$(C_DEFINES) -D_WS2HELP_

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\ws2help\nt\newctx.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    newctx.h

Abstract:

    This module implements functions for creating and manipulating context
    tables. Context tables are used in WinSock 2.0 for associating 32-bit
    context values with socket handles.

Author:

    Vadim Eyldeman (VadimE)       11-Nov-1997

Revision History:

--*/

#define _RW_LOCK_       1
//
// Private data types
//

// Handle -> context hash table
typedef struct _CTX_HASH_TABLE {
    ULONG                   NumBuckets; // Size of the table
                                        // Have to keep size we the table
                                        // to be able to atomically replace
                                        // the whole thing when expansion
                                        // is required
    LPWSHANDLE_CONTEXT      Buckets[1]; // Hash buckets with context ptr
} CTX_HASH_TABLE, FAR * LPCTX_HASH_TABLE;

typedef volatile LONG VOLCTR;
typedef VOLCTR *PVOLCTR;

   

// Handle -> context lookup table
typedef struct _CTX_LOOKUP_TABLE {
    volatile LPCTX_HASH_TABLE HashTable;// Pointer to current hash table
                                        // Replaced atomically on table
                                        // expansion
#ifdef _RW_LOCK_                        // Lock that protects the table
    VOLCTR                  EnterCounter;// Counter of number of readers
                                        // that entered the table combined
                                        // with the index if exit counter to use.
    VOLCTR                  ExitCounter[2];// Corresponding exit counters
    LONG					SpinCount;	// Number of times spin before resorting
										// to context switch while waiting for
										// readers to go away
    BOOL                    ExpansionInProgress;// Flag that indicates that
                                        // table expansion is in progress
                                        // and writer lock must be acquired
                                        // before any modifications (event
                                        // atomic can be made)
#ifdef _PERF_DEBUG_
	LONG					WriterWaits;
	LONG					FailedSpins;
    LONG                    FailedSwitches;
    LONG                    CompletedWaits;
#define RecordWriterWait(tbl)	    (tbl)->WriterWaits += 1
#define RecordFailedSpin(tbl)	    (tbl)->FailedSpins += 1
#define RecordFailedSwitch(tbl)	    (tbl)->FailedSwitches += 1
#define RecordCompletedWait(tbl)    (tbl)->CompletedWaits += 1
#else
#define RecordWriterWait(tbl)
#define RecordFailedSpin(tbl)
#define RecordFailedSwitch(tbl)
#define RecordCompletedWait(tbl)
#endif
#endif //_RW_LOCK_
    CRITICAL_SECTION        WriterLock;
} CTX_LOOKUP_TABLE, FAR * LPCTX_LOOKUP_TABLE;

// Handle -> context table
struct _CONTEXT_TABLE {
    ULONG               HandleToIndexMask;// Mask used to dispatch between
                                        // several hash tables
    CTX_LOOKUP_TABLE    Tables[1];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\ws2help\nt\handle.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    handle.c

Abstract:

    This module implements the socket handle helper functions for the WinSock 2.0
    helper library.

Author:
    Vadim Eydelman (VadimE)


Revision History:

--*/


#include "precomp.h"
#include "resource.h"
#include "osdef.h"
#include "mswsock.h"

//
//  Private constants.
//

#define FAKE_HELPER_HANDLE      ((HANDLE)'MKC ')
#define WS2IFSL_SERVICE_NAME    TEXT ("WS2IFSL")
#define WS2IFSL_SERVICE_PATH    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\WS2IFSL"

// Extended overlapped structure
typedef struct _OVERLAPPED_CTX {
    OVERLAPPED      ovlp;
#define SocketFile ovlp.hEvent
    HANDLE          ProcessFile;
	ULONG			UniqueId;
    ULONG           BufferLen;
	INT				FromLen;
    union {
	    CHAR			Buffer[1];
        SOCKET          Handle;
    };
} OVERLAPPED_CTX, *POVERLAPPED_CTX;

typedef struct _HANDLE_HELPER_CTX {
	HANDLE				ProcessFile;
	HANDLE				ThreadHdl;
	HANDLE				LibraryHdl;
} HANDLE_HELPER_CTX, *PHANDLE_HELPER_CTX;


/* Private Prototypes */ 
VOID
DoSocketRequest (
    PVOID   Context1,
    PVOID   Context2,
    PVOID   Context3
    );

NTSTATUS
DoSocketCancel (
    PVOID   Context1,
    PVOID   Context2,
    PVOID   Context3
    );

DWORD WINAPI
ApcThread (
    PVOID   param
    );

VOID CALLBACK
ExitThreadApc (
    ULONG_PTR   param
    );

void CALLBACK
WinsockApc (
    IN DWORD dwError,
    IN DWORD cbTransferred,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN DWORD dwFlags
    );

NTSTATUS
WsErrorToNtStatus (
    IN DWORD Error
    );

DWORD
DemandStartWS2IFSL (
    VOID
    );

DWORD
AllowServiceDemandStart (
    SC_HANDLE hService
    );


/* Private Globals */
BOOL                    Ws2helpInitialized = FALSE;
CRITICAL_SECTION        StartupSyncronization;

/* Our module handle: we keep a reference to it to make sure that
    in is not unloaded while our thread is executing */
HINSTANCE   LibraryHdl;

/* Winsock2 entry points that we call
*/
LPFN_WSASEND                pWSASend=NULL;
LPFN_WSARECV                pWSARecv=NULL;
LPFN_WSASENDTO              pWSASendTo=NULL;
LPFN_WSARECVFROM            pWSARecvFrom=NULL;
LPFN_WSAGETLASTERROR        pWSAGetLastError=NULL;
LPFN_WSACANCELBLOCKINGCALL  pWSACancelBlockingCall = NULL;
LPFN_WSASETBLOCKINGHOOK     pWSASetBlockingHook = NULL;
LPFN_SELECT                 pSelect = NULL;
LPFN_WSASTARTUP             pWSAStartup = NULL;
LPFN_WSACLEANUP             pWSACleanup = NULL;
LPFN_GETSOCKOPT             pGetSockOpt = NULL;
LPFN_WSAIOCTL               pWSAIoctl = NULL;

#if DBG
DWORD       PID=0;
ULONG       DbgLevel = DBG_FAILURES;
#endif


/* Public Functions */


BOOL WINAPI DllMain(
    IN HINSTANCE hinstDll,
    IN DWORD fdwReason,
    LPVOID lpvReserved
    )
{


    switch (fdwReason) {

    case DLL_PROCESS_ATTACH:
        LibraryHdl = hinstDll;
        DisableThreadLibraryCalls (hinstDll);
        __try {
            InitializeCriticalSection (&StartupSyncronization);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            WshPrint(DBG_FAILURES, ("ws2help-DllMain: Failed to initialize"
                                    " startup critical section, excpt: %lx\n",
                                    GetExceptionCode ()));
            LibraryHdl = NULL;
            return FALSE;
        }
        break;


    case DLL_PROCESS_DETACH:

        if (LibraryHdl==NULL)
            break;

        // The calling process is detaching
        // the DLL from its address space.
        //
        // Note that lpvReserved will be NULL if the detach is due to
        // a FreeLibrary() call, and non-NULL if the detach is due to
        // process cleanup.
        //

        if (lpvReserved==NULL) {
            //
            // Free security descriptor if it was allocated
            //
            if (pSDPipe!=NULL)
                FREE_MEM (pSDPipe);
            if (ghWriterEvent!=NULL) {
                CloseHandle (ghWriterEvent);
            }
            DeleteCriticalSection (&StartupSyncronization);
            Ws2helpInitialized = FALSE;
        }
        break;
    }

    return(TRUE);
}


DWORD
WINAPI
WahOpenHandleHelper(
    OUT LPHANDLE HelperHandle
    )
/*++

Routine Description:

    This routine opens WinSock 2.0 handle helper

Arguments:

    HelperHandle - Points to buffer ion which to return handle.


Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/
{
	PFILE_FULL_EA_INFORMATION	fileEa = alloca(WS2IFSL_PROCESS_EA_INFO_LENGTH);
    OBJECT_ATTRIBUTES   fileAttr;
    UNICODE_STRING      fileName;
    NTSTATUS            status;
    IO_STATUS_BLOCK     ioStatus;
    DWORD               apcThreadId;
    DWORD               rc;
    HINSTANCE           hWS2_32;
	PHANDLE_HELPER_CTX	hCtx;

    rc = ENTER_WS2HELP_API();
    if (rc!=0)
        return rc;

    if (HelperHandle==NULL)
        return ERROR_INVALID_PARAMETER;

    hWS2_32 = GetModuleHandle (TEXT ("WS2_32.DLL"));
    if (hWS2_32==NULL)
        return WSASYSCALLFAILURE;



    if (((pGetSockOpt=(LPFN_GETSOCKOPT)GetProcAddress (hWS2_32, "getsockopt"))==NULL)
            || ((pSelect=(LPFN_SELECT)GetProcAddress (hWS2_32, "select"))==NULL)
            || ((pWSACancelBlockingCall=(LPFN_WSACANCELBLOCKINGCALL)GetProcAddress (hWS2_32, "WSACancelBlockingCall"))==NULL)
            || ((pWSACleanup=(LPFN_WSACLEANUP)GetProcAddress (hWS2_32, "WSACleanup"))==NULL)
            || ((pWSAGetLastError=(LPFN_WSAGETLASTERROR)GetProcAddress (hWS2_32, "WSAGetLastError"))==NULL)
            || ((pWSASetBlockingHook=(LPFN_WSASETBLOCKINGHOOK)GetProcAddress (hWS2_32, "WSASetBlockingHook"))==NULL)
            || ((pWSARecv=(LPFN_WSARECV)GetProcAddress (hWS2_32, "WSARecv"))==NULL)
            || ((pWSASend=(LPFN_WSASEND)GetProcAddress (hWS2_32, "WSASend"))==NULL)
            || ((pWSASendTo=(LPFN_WSASENDTO)GetProcAddress (hWS2_32, "WSASendTo"))==NULL)
            || ((pWSAStartup=(LPFN_WSASTARTUP)GetProcAddress (hWS2_32, "WSAStartup"))==NULL)
            || ((pWSARecvFrom=(LPFN_WSARECVFROM)GetProcAddress (hWS2_32, "WSARecvFrom"))==NULL)
            || ((pWSAIoctl=(LPFN_WSAIOCTL)GetProcAddress(hWS2_32, "WSAIoctl"))==NULL) )
        return WSASYSCALLFAILURE;

        // Create file used to communicate with the driver
    hCtx = (PHANDLE_HELPER_CTX) ALLOC_MEM (sizeof (*hCtx));
    if (hCtx!=NULL) {

        /* Create thread in which to execute file system requests */
		hCtx->ThreadHdl = CreateThread (NULL,
                            0,
                            ApcThread,
                            hCtx,
                            CREATE_SUSPENDED,
                            &apcThreadId);
		if (hCtx->ThreadHdl!=NULL) {

			RtlInitUnicodeString (&fileName, WS2IFSL_PROCESS_FILE_NAME);
			InitializeObjectAttributes (&fileAttr,
								&fileName,
								0,                  // Attributes
								NULL,               // Root directory
								NULL);              // Security descriptor
			fileEa->NextEntryOffset = 0;
			fileEa->Flags = 0;
			fileEa->EaNameLength = WS2IFSL_PROCESS_EA_NAME_LENGTH;
			fileEa->EaValueLength = WS2IFSL_PROCESS_EA_VALUE_LENGTH;
			strcpy (fileEa->EaName, WS2IFSL_PROCESS_EA_NAME);
			GET_WS2IFSL_PROCESS_EA_VALUE (fileEa)->ApcThread = hCtx->ThreadHdl;
			GET_WS2IFSL_PROCESS_EA_VALUE (fileEa)->RequestRoutine = DoSocketRequest;
			GET_WS2IFSL_PROCESS_EA_VALUE (fileEa)->CancelRoutine = DoSocketCancel;
			GET_WS2IFSL_PROCESS_EA_VALUE (fileEa)->ApcContext = hCtx;
#if DBG
		    GET_WS2IFSL_PROCESS_EA_VALUE (fileEa)->DbgLevel = DbgLevel;
#else
			GET_WS2IFSL_PROCESS_EA_VALUE (fileEa)->DbgLevel = 0;
#endif


			status = NtCreateFile (&hCtx->ProcessFile,
								 FILE_ALL_ACCESS,
								 &fileAttr,
								 &ioStatus,
								 NULL,              // Allocation size
								 FILE_ATTRIBUTE_NORMAL,
								 0,                 // ShareAccess
								 FILE_OPEN_IF,      // Create disposition
								 0,                 // Create options
								 fileEa,
								 WS2IFSL_PROCESS_EA_INFO_LENGTH);

            if (status==STATUS_OBJECT_NAME_NOT_FOUND ||
                    status==STATUS_OBJECT_PATH_NOT_FOUND) {
                //
                // Driver is probably not loaded, attempt to start it.
                //
                rc = DemandStartWS2IFSL ();
                if (rc==0) {
			        status = NtCreateFile (&hCtx->ProcessFile,
								         FILE_ALL_ACCESS,
								         &fileAttr,
								         &ioStatus,
								         NULL,              // Allocation size
								         FILE_ATTRIBUTE_NORMAL,
								         0,                 // ShareAccess
								         FILE_OPEN_IF,      // Create disposition
								         0,                 // Create options
								         fileEa,
								         WS2IFSL_PROCESS_EA_INFO_LENGTH);
                }
                else {
                    goto StartFailed;
                }
            }

			if (NT_SUCCESS (status)) {
                ResumeThread (hCtx->ThreadHdl);
				*HelperHandle = (HANDLE)hCtx;
				WshPrint (DBG_PROCESS,
					("WS2HELP-%lx WahOpenHandleHelper: Opened handle %p\n",
							PID, hCtx));
				return NO_ERROR;

			}
		    else { 
			    WshPrint (DBG_PROCESS|DBG_FAILURES,
				    ("WS2HELP-%lx WahOpenHandleHelper: Could not create process file, status %lx\n",
				    PID, status));
			    rc = RtlNtStatusToDosError (status);
		    
            }
        StartFailed:
            hCtx->ProcessFile = NULL;
            ResumeThread (hCtx->ThreadHdl);
        }
		else {// if (ApcThreadHdl!=NULL)
			rc = GetLastError ();
			WshPrint (DBG_PROCESS|DBG_FAILURES,
				("WS2HELP-%lx WahOpenHandleHelper: Could not create APC thread, rc=%ld\n",
						PID, rc));
		}
		FREE_MEM (hCtx);
    }
    else {
        WshPrint (DBG_PROCESS|DBG_FAILURES,
            ("WS2HELP-%lx WahOpenHandleHelper: Could allocate helper context\n", PID));
        rc = GetLastError ();
    }


    return rc;
}


DWORD
WINAPI
WahCloseHandleHelper(
    IN HANDLE HelperHandle
    )
/*++

Routine Description:

    This function closes the WinSock 2.0 handle helper.

Arguments:

    HelperHandle - The handle to close.

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/

{
	PHANDLE_HELPER_CTX	hCtx;
    DWORD               rc;

    rc = ENTER_WS2HELP_API();
    if (rc!=0)
        return rc;

    if (HelperHandle==NULL)
        return ERROR_INVALID_PARAMETER;

	hCtx = (PHANDLE_HELPER_CTX)HelperHandle;

        /* Queue APC that exits the thread */
    if (QueueUserAPC (ExitThreadApc, hCtx->ThreadHdl, (ULONG_PTR)hCtx)) {
		WshPrint (DBG_PROCESS, 
			("WS2HELP-%lx WahCloseHandleHelper: Queued close APC.\n", PID));
		return NO_ERROR;
	}
	else {
		WshPrint (DBG_PROCESS|DBG_FAILURES,
			("WS2HELP-%lx WahCloseHandleHelper: Failed to queue close APC.\n", PID));
		return ERROR_GEN_FAILURE;
	}
}


DWORD
WINAPI
WahCreateSocketHandle(
    IN HANDLE           HelperHandle,
    OUT SOCKET          *s
    )
/*++

Routine Description:

    This function creates IFS socket handle for service provider that
    cannot do it by itself.

Arguments:

    HelperHandle - The handle of WinSock 2.0 handle helper.
    S            - buffer to return created socket handle

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/
{
	PFILE_FULL_EA_INFORMATION	fileEa = alloca(WS2IFSL_SOCKET_EA_INFO_LENGTH);
    OBJECT_ATTRIBUTES           fileAttr;
    UNICODE_STRING              fileName;
    NTSTATUS                    status;
    IO_STATUS_BLOCK             ioStatus;
    DWORD                       error;
    DWORD                       count;
    INT                         openType;
    DWORD                       crOptions;
	PHANDLE_HELPER_CTX			hCtx = (PHANDLE_HELPER_CTX)HelperHandle;
    
    error = ENTER_WS2HELP_API();
    if (error!=0)
        return error;

    if ((HelperHandle==NULL) || (s==NULL))
        return ERROR_INVALID_PARAMETER;

    count = sizeof (openType);
    if ((pGetSockOpt (INVALID_SOCKET, SOL_SOCKET, SO_OPENTYPE, (PCHAR)&openType, &count)==0)
        && (openType!=0)) {
        crOptions = FILE_SYNCHRONOUS_IO_NONALERT;
    }
    else
        crOptions = 0;

    // Create file handle on the driver device
    RtlInitUnicodeString (&fileName, WS2IFSL_SOCKET_FILE_NAME);
    InitializeObjectAttributes (&fileAttr,
                        &fileName,
                        0,                  // Attributes
                        NULL,               // Root directory
                        NULL);              // Security descriptor
    fileEa->NextEntryOffset = 0;
    fileEa->Flags = 0;
    fileEa->EaNameLength = WS2IFSL_SOCKET_EA_NAME_LENGTH;
    fileEa->EaValueLength = WS2IFSL_SOCKET_EA_VALUE_LENGTH;
    strcpy (fileEa->EaName, WS2IFSL_SOCKET_EA_NAME);
        // Supply the context (can't actually supply the handle
        // until it is opened
    GET_WS2IFSL_SOCKET_EA_VALUE (fileEa)->ProcessFile = hCtx->ProcessFile;
    GET_WS2IFSL_SOCKET_EA_VALUE (fileEa)->DllContext = NULL;

    status = NtCreateFile ((HANDLE *)s,
                         FILE_ALL_ACCESS,
                         &fileAttr,
                         &ioStatus,
                         NULL,              // Allocation size
                         FILE_ATTRIBUTE_NORMAL,
                         0,                 // ShareAccess
                         FILE_OPEN_IF,      // Create disposition
                         crOptions,         // Create options
                         fileEa,
                         WS2IFSL_SOCKET_EA_INFO_LENGTH);
    if (NT_SUCCESS (status)) {
            // Now set the actual context
        GET_WS2IFSL_SOCKET_EA_VALUE (fileEa)->DllContext = (HANDLE)*s;
        if (DeviceIoControl (
                        (HANDLE)*s,                         // File Handle
                        IOCTL_WS2IFSL_SET_SOCKET_CONTEXT,   // Control Code
                        GET_WS2IFSL_SOCKET_EA_VALUE (fileEa),// InBuffer
                        sizeof (WS2IFSL_SOCKET_CTX),         // InBufferLength
                        NULL,                               // OutBuffer
                        0,                                  // OutBufferLength
                        &count,                             // BytesReturned
                        NULL)) {                              // Overlapped
            WshPrint (DBG_SOCKET,
                ("WS2HELP-%lx WahCreateSocketHandle: Handle %p\n", PID,  *s));
            error = NO_ERROR;
        }
        else {
            error = GetLastError ();
            NtClose ((HANDLE)*s);
            WshPrint (DBG_SOCKET|DBG_FAILURES,
                ("WS2HELP-%lx WahCreateSocketHandle: Could not set context, rc=%ld\n",
                            PID, error));
            *s = 0;
        }
    }
    else { // if (NtCreateFile succeded)
        error = RtlNtStatusToDosError (status);
        WshPrint (DBG_SOCKET|DBG_FAILURES,
                ("WS2HELP-%lx WahCreateSocketHandle: Could create file, rc=%ld\n",
                        PID, error));
    }

    return error;
}



DWORD
WINAPI
WahCloseSocketHandle(
    IN HANDLE           HelperHandle,
    IN SOCKET           s
    )
/*++

Routine Description:

    This function destroyes IFS socket handle created by WahCreateSocketHandle

Arguments:

    HelperHandle - The handle of WinSock 2.0 handle helper.
    s            - socket handle to close

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/
{
	PHANDLE_HELPER_CTX		hCtx = (PHANDLE_HELPER_CTX)HelperHandle;
	NTSTATUS				status;
    DWORD                   rc;

    rc = ENTER_WS2HELP_API();
    if (rc!=0)
        return rc;

    if ((HelperHandle==NULL)
            || (s==0)
            || (s==INVALID_SOCKET))
        return ERROR_INVALID_PARAMETER;

    WshPrint (DBG_SOCKET,
            ("WS2HELP-%lx WahCloseSocketHandle: Handle %p\n", PID, s));
    status = NtClose ((HANDLE)s);
	if (NT_SUCCESS (status))
		return NO_ERROR;
	else
		return RtlNtStatusToDosError (status);
}

DWORD
WINAPI
WahCompleteRequest(
    IN HANDLE              HelperHandle,
    IN SOCKET              s,
    IN LPWSAOVERLAPPED     lpOverlapped,
    IN DWORD               dwError,
    IN DWORD               cbTransferred
    )
/*++

Routine Description:

    This function simmulates completion of overlapped IO request
    on socket handle created by WasCreateSocketHandle

Arguments:

    HelperHandle - The handle of WinSock 2.0 handle helper.
    s            - socket handle to complete request on
    lpOverlapped - pointer to overlapped structure
    dwError      - WinSock 2.0 error code for opreation being completed
    cbTransferred- number of bytes transferred to/from user buffers as the
                    result of the operation being completed

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/
{
    IO_STATUS_BLOCK			IoStatus;
    NTSTATUS				status;
	PHANDLE_HELPER_CTX		hCtx = (PHANDLE_HELPER_CTX)HelperHandle;
    DWORD                   rc;
    
    rc = ENTER_WS2HELP_API();
    if (rc!=0)
        return rc;

    if ((HelperHandle==NULL)
		    || (lpOverlapped==NULL)
            || (s==INVALID_SOCKET)
            || (s==0))
        return ERROR_INVALID_PARAMETER;

        // Setup IO_STATUS block to be used by the driver to complete the
        // operation
    IoStatus.Status = WsErrorToNtStatus (dwError);
    IoStatus.Information = cbTransferred;
        // Call the driver to complete
    status = NtDeviceIoControlFile ((HANDLE)s,
                    lpOverlapped->hEvent,
                    NULL,
                    ((ULONG_PTR)lpOverlapped->hEvent&1) ? NULL : lpOverlapped,
                    (PIO_STATUS_BLOCK)lpOverlapped,
                    IOCTL_WS2IFSL_COMPLETE_PVD_REQ,
                    &IoStatus,
                    sizeof (IO_STATUS_BLOCK),
                    NULL,
                    0);
		// Be carefull not to touch overlapped after NtDeviceIoControlFile
    if (NT_SUCCESS(status) || (status==IoStatus.Status)) {
        WshPrint (DBG_COMPLETE,
            ("WS2HELP-%lx WahCompleteRequest: Handle %p, status %lx, info %ld\n",
                PID, s, IoStatus.Status, IoStatus.Information));
        return NO_ERROR;
    }
    else {
        WshPrint (DBG_COMPLETE|DBG_FAILURES,
            ("WS2HELP-%lx WahCompleteRequest: Failed on handle %p, status %lx\n",
                PID, s, status));
        return ERROR_INVALID_HANDLE;
    }
}


DWORD
WINAPI
WahEnableNonIFSHandleSupport (
    VOID
    )
/*++

Routine Description:

    This function installs and starts Winsock2 Installable File System Layer
    driver to provide socket handles for Non-IFS handle transport service 
    providers.
Arguments:

    None

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/
{
    SC_HANDLE   hSCManager, hWS2IFSL;
    DWORD       rc=0;
    TCHAR       WS2IFSL_DISPLAY_NAME[256];

    rc = ENTER_WS2HELP_API();
    if (rc!=0)
        return rc;

    //
    // Get display string for Winsock2 non-IFS handle helper service name
    // (localizable)
    //
    // Use exception handler because of delayload option we
    // use for user32.dll (for hydra compat).
    //
    __try {
        rc = LoadString (LibraryHdl, WS2IFSL_SERVICE_DISPLAY_NAME_STR,
                        WS2IFSL_DISPLAY_NAME, sizeof (WS2IFSL_DISPLAY_NAME));
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        rc = 0;
    }
    if (rc==0) {
        rc = GetLastError ();
        if (rc==0)
            rc = ERROR_NOT_ENOUGH_MEMORY;
        WshPrint (DBG_SERVICE|DBG_FAILURES,
            ("WS2HELP-%lx WahEnableNonIFSHandleSupport:"
             " Could not load service display string, err: %ld\n",
            PID, rc));
        return rc;
    }

    rc = 0;

    //
    // Open service database on the local computer
    //

    hSCManager = OpenSCManager (
                        NULL,
                        SERVICES_ACTIVE_DATABASE,
                        SC_MANAGER_CREATE_SERVICE
                        );
    if (hSCManager==NULL) {
        rc = GetLastError ();
        WshPrint (DBG_SERVICE|DBG_FAILURES,
            ("WS2HELP-%lx WahEnableNonIFSHandleSupport: Could not open SC, err: %ld\n",
            PID, rc));
        return rc;
    }




    //
    // Create Winsock2 non-IFS handle helper service
    //

    hWS2IFSL = CreateService (
                    hSCManager,
                    WS2IFSL_SERVICE_NAME,
                    WS2IFSL_DISPLAY_NAME,
                    SERVICE_ALL_ACCESS,
                    SERVICE_KERNEL_DRIVER,
                    SERVICE_AUTO_START,
                    SERVICE_ERROR_NORMAL,
                    TEXT ("\\SystemRoot\\System32\\drivers\\ws2ifsl.sys"),
                    TEXT ("PNP_TDI"),   // load group
                    NULL,               // Tag ID
                    NULL,               // Dependencies
                    NULL,               // Start name
                    NULL                // Password
                    );
    if (hWS2IFSL==NULL) {
        //
        // Failure, check if service already exists
        //
        rc = GetLastError ();
        if (rc!=ERROR_SERVICE_EXISTS) {
            //
            // Some other failure, bail out
            //
            WshPrint (DBG_SERVICE|DBG_FAILURES,
                ("WS2HELP-%lx WahEnableNonIFSHandleSupport: Could not create service, err: %ld\n",
                PID, rc));
            CloseServiceHandle (hSCManager);
            return rc;
        }

        rc = 0;

        //
        // Open existing service
        //
        hWS2IFSL = OpenService (
                    hSCManager,
                    WS2IFSL_SERVICE_NAME,
                    SERVICE_ALL_ACCESS);
        if (hWS2IFSL==NULL) {
            //
            // Could not open, bail out
            //
            rc = GetLastError ();
            WshPrint (DBG_SERVICE|DBG_FAILURES,
                ("WS2HELP-%lx WahEnableNonIFSHandleSupport: Could not open service, err: %ld\n",
                PID, rc));
            CloseServiceHandle (hSCManager);
            return rc;
        }
    }

    rc = AllowServiceDemandStart (hWS2IFSL);
    if (rc==0) {
        if (ChangeServiceConfig (hWS2IFSL,
                    SERVICE_KERNEL_DRIVER,
                    SERVICE_DEMAND_START,
                    SERVICE_ERROR_NORMAL,
                    TEXT ("\\SystemRoot\\System32\\drivers\\ws2ifsl.sys"),
                                            // lpBinaryPathName 
                    NULL,                   // load group
                    NULL,                   // Tag ID
                    NULL,                   // Dependencies
                    NULL,                   // Start name
                    NULL,                   // Password
                    WS2IFSL_DISPLAY_NAME    // Display name
                    )) {
            WshPrint (DBG_SERVICE,
                ("WS2HELP-%lx WahEnableNonIFSHandleSupport: Configured service.\n",
                PID));
        }
        else {
            //
            // Could set config, bail out
            //
            rc = GetLastError ();
            WshPrint (DBG_SERVICE|DBG_FAILURES,
                ("WS2HELP-%lx WahEnableNonIFSHandleSupport: Could not enable service, err: %ld\n",
                PID, rc));
        }
    }
    //
    // Success, cleanup open handles
    //
    CloseServiceHandle (hWS2IFSL);
    CloseServiceHandle (hSCManager);
    return rc;
}

DWORD
WINAPI
WahDisableNonIFSHandleSupport (
    VOID
    )
/*++

Routine Description:

    This function deinstalls Winsock2 Installable File System Layer
    driver to provide socket handles for Non-IFS handle transport service 
    providers.
Arguments:

    None

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/
{
    SC_HANDLE   hSCManager, hWS2IFSL;
    DWORD       rc=0;

    rc = ENTER_WS2HELP_API();
    if (rc!=0)
        return rc;

    //
    // Open service database on the local computer
    //

    hSCManager = OpenSCManager (
                        NULL,
                        SERVICES_ACTIVE_DATABASE,
                        SC_MANAGER_CREATE_SERVICE
                        );
    if (hSCManager==NULL) {
        rc = GetLastError ();
        WshPrint (DBG_SERVICE|DBG_FAILURES,
            ("WS2HELP-%lx WahDisableNonIFSHandleSupport: Could not open SC, err: %ld\n",
            PID, rc));
        return rc;
    }

    //
    // Open service itself
    //

    hWS2IFSL = OpenService (
                hSCManager,
                WS2IFSL_SERVICE_NAME,
                SERVICE_ALL_ACCESS);
    if (hWS2IFSL==NULL) {
        rc = GetLastError ();
        WshPrint (DBG_SERVICE|DBG_FAILURES,
            ("WS2HELP-%lx WahDisableNonIFSHandleSupport: Could open service, err: %ld\n",
            PID, rc));
        CloseServiceHandle (hSCManager);
        return rc;
    }

    //
    // Just disable the service, so it won't start on reboot.
    //
    // Deleting service is dangerous because this will require
    // a reboot before it can be installed again and we are
    // working towards no-reboot system
    //
    // Stopping is even worse, because it will go into uncontrollable
    // (STOP_PENDING) state until all handles to it are closed so
    // we won't be able to start it until reboot if some service is
    // holding its handles.
    // 

    if (ChangeServiceConfig (hWS2IFSL,
                SERVICE_NO_CHANGE,  // dwServiceType 
                SERVICE_DISABLED,   // dwStartType
                SERVICE_NO_CHANGE,  // dwErrorControl 
                NULL,               // lpBinaryPathName 
                NULL,               // load group
                NULL,               // Tag ID
                NULL,               // Dependencies
                NULL,               // Start name
                NULL,               // Password
                NULL                // Display name
                )) {
        rc = 0;
        WshPrint (DBG_SERVICE,
            ("WS2HELP-%lx WahDisableNonIFSHandleSupport: Disabled service.\n",
            PID));
    }
    else {
        rc = GetLastError ();
        WshPrint (DBG_SERVICE|DBG_FAILURES,
            ("WS2HELP-%lx WahDisableNonIFSHandleSupport: Could not disable service, err: %ld\n",
            PID, GetLastError ()));
    }

    CloseServiceHandle (hWS2IFSL);
    CloseServiceHandle (hSCManager);
    return rc;
}




DWORD WINAPI
ApcThread (
    PVOID   param
    )
/*++

Routine Description:

    This is a thread which is used by the driver to execute 
    IO system requests
Arguments:

    param   - handle helper context
Return Value:

    0

--*/
{
    NTSTATUS                    status;
	DWORD						rc;
	PHANDLE_HELPER_CTX			hCtx = (PHANDLE_HELPER_CTX)param;
	TCHAR						ModuleName[MAX_PATH];
    LARGE_INTEGER               Timeout;

    //
    // Could not open the file, just clean-up.
    //
    if (hCtx->ProcessFile==NULL)
        return -1;

    Timeout.QuadPart = 0x8000000000000000i64;

    // Increment our module reference count
    // so it does not go away while this thread is
    // running

	rc = GetModuleFileName (LibraryHdl,
							ModuleName,
							sizeof(ModuleName)/sizeof(ModuleName[0]));
	ASSERT (rc>0);

    hCtx->LibraryHdl = LoadLibrary (ModuleName);
    ASSERT (hCtx->LibraryHdl!=NULL);

    WshPrint (DBG_APC_THREAD,
        ("WS2HELP-%lx ApcThread: Initialization completed\n", PID));
            // Wait alertably to let APC's execute
    while (TRUE) {
        status = NtDelayExecution (TRUE, &Timeout);
        if (!NT_SUCCESS (status)) {
            //
            // Sleep for 3 seconds
            //
            LARGE_INTEGER   Timeout2;
            Timeout2.QuadPart = - (3i64*1000i64*1000i64*10i64);
            NtDelayExecution (FALSE, &Timeout2);
        }
    }
    // We should never get here, the thread terminates
    // from the ExitApc
    ASSERT (FALSE);
	return 0;
}

VOID CALLBACK
ExitThreadApc (
    ULONG_PTR   param
    )
/*++

Routine Description:

    This APC routine is used to terminate APC thread
Arguments:

    param   - exit code for thread
Return Value:

    Exit code for thread

--*/
{
	PHANDLE_HELPER_CTX	hCtx = (PHANDLE_HELPER_CTX)param;
    HINSTANCE libraryHdl = hCtx->LibraryHdl;
    
        // Close the file
    NtClose (hCtx->ProcessFile);
	CloseHandle (hCtx->ThreadHdl);
    WshPrint (DBG_APC_THREAD, ("WS2HELP-%lx ExitThreadApc: Exiting, ctx: %p\n", PID));
    (*pWSACleanup) ();
	FREE_MEM (hCtx);
    FreeLibraryAndExitThread (libraryHdl, 0);
}


void CALLBACK
WinsockApc(
    IN DWORD dwError,
    IN DWORD cbTransferred,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN DWORD dwFlags
    )
/*++

Routine Description:

    This APC routine is executed upon completion of WinSock 2.0 call
Arguments:

    dwError         - WinSock2.0 return code
    cbTransferred   - number of buffers transferred to/from user buffers
    lpOverlapped    - overlapped structure associated with the request
                      (it is actually our extended structure: OVERLAPPED_CTX_
    dwFlags         - flags associated with the request (ignored)
Return Value:

    None
--*/
{
	POVERLAPPED_CTX		ctx = CONTAINING_RECORD (lpOverlapped,
													OVERLAPPED_CTX,
													ovlp);
    IO_STATUS_BLOCK		ioStatus;
	WS2IFSL_CMPL_PARAMS	params;
	NTSTATUS			status;

        // Setup status block for the driver
    params.SocketHdl = ctx->SocketFile;
	params.UniqueId = ctx->UniqueId;
    params.DataLen = cbTransferred;
	params.AddrLen = (ULONG)ctx->FromLen;
    params.Status = WsErrorToNtStatus (dwError);

	status = NtDeviceIoControlFile (
					ctx->ProcessFile,	// Handle
					NULL,				// Event
					NULL,				// Apc
					NULL,				// ApcContext
					&ioStatus,			// IoStatus
					IOCTL_WS2IFSL_COMPLETE_DRV_REQ, // IoctlCode
					&params,			// InputBuffer
					sizeof(params),		// InputBufferLength,
					ctx->Buffer,		// OutputBuffer
					ctx->BufferLen      // OutputBufferLength,
					);

    WshPrint (DBG_WINSOCK_APC,
        ("WS2HELP-%lx WinsockApc: Socket %p, id %ld, err %ld, cb %ld, addrlen %ld\n",
            PID, ctx->SocketFile, ctx->UniqueId,
			dwError, cbTransferred, ctx->FromLen));
    FREE_MEM (ctx);
}

VOID
DoSocketRequest (
    PVOID   PvCtx,
    PVOID   PvRequestId,
    PVOID   PvBufferLength
    )
/*++

Routine Description:

	Executes socket request for the ws2ifsl driver

Arguments:

Return Value:

    None
--*/
{
	IO_STATUS_BLOCK		ioStatus;
	NTSTATUS			status;
	WS2IFSL_RTRV_PARAMS	params;
	POVERLAPPED_CTX		ctx;
    PHANDLE_HELPER_CTX	hCtx = PvCtx;

    WshPrint (DBG_REQUEST,
		("WS2HELP-%lx DoSocketRequest: id %ld, buflen %ld\n",
        PID, PtrToUlong(PvRequestId), PtrToUlong(PvBufferLength)));

	params.UniqueId = PtrToUlong (PvRequestId);
	ctx = (POVERLAPPED_CTX)ALLOC_MEM (FIELD_OFFSET(
										OVERLAPPED_CTX,
										Buffer[PtrToUlong(PvBufferLength)]));

	if (ctx!=NULL) {
        ctx->ProcessFile = hCtx->ProcessFile;
			// Use extension field to save driver context
		ctx->UniqueId = PtrToUlong (PvRequestId);
        ctx->BufferLen = PtrToUlong (PvBufferLength);

		status = NtDeviceIoControlFile (
						ctx->ProcessFile,   // Handle
						NULL,				// Event
						NULL,				// Apc
						NULL,				// ApcContext
						&ioStatus,			// IoStatus
						IOCTL_WS2IFSL_RETRIEVE_DRV_REQ, // IoctlCode
						&params,			// InputBuffer
						sizeof(params),		// InputBufferLength,
						ctx->Buffer,		// OutputBuffer
						ctx->BufferLen	// OutputBufferLength,
						);
	}
	else {
		status = NtDeviceIoControlFile (
						hCtx->ProcessFile,	// Handle
						NULL,				// Event
						NULL,				// Apc
						NULL,				// ApcContext
						&ioStatus,			// IoStatus
						IOCTL_WS2IFSL_RETRIEVE_DRV_REQ, // IoctlCode
						&params,			// InputBuffer
						sizeof(params),		// InputBufferLength,
						NULL,				// OutputBuffer
						0					// OutputBufferLength,
						);
		ASSERT (!NT_SUCCESS (status));
	}

	if (NT_SUCCESS(status)) {
		DWORD           error, count, flags;
		WSABUF          buf;

		ASSERT (ctx!=NULL);

		// Use hEvent to save socket context (handle)
		ctx->SocketFile = params.DllContext;
		ctx->FromLen = 0;
            
            // Setup request parameters and execute asynchronously
        switch (params.RequestType) {
        case WS2IFSL_REQUEST_READ:
            flags = 0;
            buf.buf = ctx->Buffer;
            buf.len = params.DataLen;
            if ((pWSARecv ((SOCKET)ctx->SocketFile,
                        &buf,
                        1,
                        &count,
                        &flags,
                        &ctx->ovlp,
                        WinsockApc)!=SOCKET_ERROR)
			           || ((error=pWSAGetLastError ())==WSA_IO_PENDING)) {
		        WshPrint (DBG_DRIVER_READ,
                    ("WS2HELP-%lx DoSocketRequest: Read - socket %p, ctx %p,"
					" id %ld, len %ld\n",
                    PID, ctx->SocketFile, ctx, 
					ctx->UniqueId,
					params.DataLen));
                return;
            }
            break;
        case WS2IFSL_REQUEST_WRITE:
			buf.buf = ctx->Buffer;
			buf.len = params.DataLen;
            if ((pWSASend ((SOCKET)ctx->SocketFile,
                        &buf,
                        1,
                        &count,
                        0,
                        &ctx->ovlp,
                        WinsockApc)!=SOCKET_ERROR)
                   || ((error=pWSAGetLastError ())==WSA_IO_PENDING)) {
	            WshPrint (DBG_DRIVER_WRITE,
					("WS2HELP-%lx DoSocketRequest: Write - socket %p, ctx %p,"
					" id %ld, len %ld\n",
                    PID, ctx->SocketFile, ctx, 
					ctx->UniqueId,
					params.DataLen));
                return;
            }
            break;
        case WS2IFSL_REQUEST_SENDTO:
			buf.buf = ctx->Buffer;
			buf.len = params.DataLen;
            if ((pWSASendTo ((SOCKET)ctx->SocketFile,
                        &buf,
                        1,
                        &count,
                        0,
						(const struct sockaddr FAR *)
							&ctx->Buffer[ADDR_ALIGN(params.DataLen)],
                        params.AddrLen,
                        &ctx->ovlp,
                        WinsockApc)!=SOCKET_ERROR)
                   || ((error=pWSAGetLastError ())==WSA_IO_PENDING)) {
                WshPrint (DBG_DRIVER_SEND,
					("WS2HELP-%lx DoSocketRequest: SendTo - socket %p, ctx %p,"
					" id %ld, len %ld, addrlen %ld\n",
                    PID, ctx->SocketFile, ctx, 
					ctx->UniqueId,
					params.DataLen, params.AddrLen));
                return;
            }
            break;
        case WS2IFSL_REQUEST_RECVFROM:
			buf.buf = ctx->Buffer;
			buf.len = params.DataLen;
			flags = params.Flags;
			ctx->FromLen = (INT)params.AddrLen;
            if ((pWSARecvFrom ((SOCKET)ctx->SocketFile,
                        &buf,
                        1,
                        &count,
                        &flags,
						(struct sockaddr FAR *)
							&ctx->Buffer[ADDR_ALIGN(params.DataLen)],
                        &ctx->FromLen,
                        &ctx->ovlp,
                        WinsockApc)!=SOCKET_ERROR)
                   || ((error=pWSAGetLastError ())==WSA_IO_PENDING)) {
                WshPrint (DBG_DRIVER_RECV,
					("WS2HELP-%lx DoSocketRequest: RecvFrom - socket %p, ctx %p,"
					" id %ld, len %ld, addrlen %ld, flags %lx\n",
                    PID, ctx->SocketFile, ctx, 
					ctx->UniqueId,
					params.DataLen, params.AddrLen, params.Flags));
                return;
            }
            break;
        case WS2IFSL_REQUEST_RECV:
			buf.buf = ctx->Buffer;
			buf.len = params.DataLen;
			flags = params.Flags;
            if ((pWSARecv ((SOCKET)ctx->SocketFile,
                        &buf,
                        1,
                        &count,
                        &flags,
                        &ctx->ovlp,
                        WinsockApc)!=SOCKET_ERROR)
                   || ((error=pWSAGetLastError ())==WSA_IO_PENDING)) {
                WshPrint (DBG_DRIVER_RECV,
					("WS2HELP-%lx DoSocketRequest: Recv - socket %p, ctx %p,"
					" id %ld, len %ld, flags %lx\n",
                    PID, ctx->SocketFile, ctx, 
					ctx->UniqueId,
					params.DataLen, params.Flags));
                return;
            }
            break;
        case WS2IFSL_REQUEST_QUERYHANDLE:
            ASSERT (params.DataLen==sizeof (SOCKET));
            if ((pWSAIoctl ((SOCKET)ctx->SocketFile,
                            SIO_QUERY_TARGET_PNP_HANDLE,
                            NULL,
                            0,
                            &ctx->Handle,
                            sizeof (ctx->Handle),
                            &count,
                            &ctx->ovlp,
                            WinsockApc)!=SOCKET_ERROR)
                   || ((error=pWSAGetLastError ())==WSA_IO_PENDING)) {
                WshPrint (DBG_CANCEL,
					("WS2HELP-%lx DoSocketRequest: PnP - socket %p, ctx %p,"
					" id %ld\n",
                    PID, ctx->SocketFile, ctx, 
					ctx->UniqueId));
                return;
            }
            break;
        default:
            ASSERT (FALSE);
        }
		// The Winsock request failed (no APC is going to executed, call it here)
        WinsockApc (error, 0, &ctx->ovlp, 0);
	}

}



INT_PTR
CancelHook (
    void
    )
/*++

Routine Description:

    This is blocking hook that cancels the current request
Arguments:

Return Value:
    FALSE   - to stop polling

--*/
{
    BOOL    res;
    res = pWSACancelBlockingCall ();
    WshPrint (DBG_CANCEL,
        ("WS2HELP-%lx CancelHook: %s\n", PID, res ? "succeded" : "failed"));
    return FALSE;
}


NTSTATUS
DoSocketCancel (
    PVOID   PvCtx,
    PVOID   PvRequestId,
    PVOID   PvDllContext
    )
/*++

Routine Description:
    Hack to attempt to cancel request in progress.
    This works with MSAFD, but may (actully will) not work with
    any other provider which is likely to implement select differently.
    Our hope here that by cancelling select we will also cancel any
    other outstanding requests on a socket handle.

Arguments:

Return Value:

    None
--*/
{
    FARPROC				oldHook;
    int					res;
    fd_set				set;
    struct timeval		timeout;
	IO_STATUS_BLOCK		ioStatus;
	NTSTATUS			status;
	WS2IFSL_CNCL_PARAMS	params;
	SOCKET				s = (SOCKET)PvDllContext;
    WORD                wVersionRequested;
    WSADATA             wsaData;
    DWORD               rc;
    PHANDLE_HELPER_CTX	hCtx = PvCtx;

    WshPrint (DBG_CANCEL, ("WS2HELP-%lx DoSocketCancel: Socket %p, id %d\n",
        PID, PvDllContext, PtrToUlong (PvRequestId)));
    //
    // Request 1.1 so that blocking hooks are supported
    //
    wVersionRequested = MAKEWORD(1, 1);
    if ((rc =(*pWSAStartup) (wVersionRequested, &wsaData))==NO_ERROR) {

        oldHook = pWSASetBlockingHook (CancelHook);
        if (oldHook!=NULL) {

            FD_ZERO (&set);
            FD_SET (s, &set);
            timeout.tv_sec = 10;
            timeout.tv_usec = 0;
            res = pSelect (1, NULL, NULL, &set, &timeout);
            WshPrint (DBG_CANCEL, 
                ("WS2HELP-%lx CancelApc: Done on socket id %ld (res %ld)\n",
                PID, PtrToUlong(PvRequestId), res));
            pWSASetBlockingHook (oldHook);
        }
        else {
            rc = pWSAGetLastError ();
            WshPrint (DBG_CANCEL|DBG_FAILURES,
                ("WS2HELP-%lx DoSocketCancel: Could not install blocking hook, err - %ld\n",
                PID, rc));
        }
        (*pWSACleanup)();
    }
    else {
        WshPrint (DBG_CANCEL|DBG_FAILURES,
            ("WS2HELP-%lx DoSocketCancel: Could not get version 1.1, rc - %ld\n",
            PID, rc));
    }

	params.UniqueId = PtrToUlong (PvRequestId);

	status = NtDeviceIoControlFile (
					hCtx->ProcessFile,  // Handle
					NULL,				// Event
					NULL,				// Apc
					NULL,				// ApcContext
					&ioStatus,			// IoStatus
					IOCTL_WS2IFSL_COMPLETE_DRV_CAN, // IoctlCode
					&params,			// InputBuffer
					sizeof(params),		// InputBufferLength,
					NULL,				// OutputBuffer
					0					// OutputBufferLength,
					);
	ASSERT (NT_SUCCESS (status));


    WshPrint (DBG_CANCEL, 
        ("WS2HELP-%lx CancelApc: Completed on socket %p, id %ld (status %lx)\n",
        PID, s, params.UniqueId, status));

	return status;
}






NTSTATUS
WsErrorToNtStatus (
    DWORD   dwError
    )
/*++

Routine Description:

    This function maps WinSock 2.0 error code to NTSTATUS value
Arguments:

    dwError         - WinSock2.0 return code
    
Return Value:

    NTSTATUS corresponding to dwError
--*/
{
    // Macro that validates that our winsock error array indeces are
    // in sync with winsock2.h defines
#define MAPWSERROR(line,Error,Status)   Status
    // WinSock2.0 error to NTSTATUS MAP
static const NTSTATUS WSAEMap[]= {
    MAPWSERROR (0,      0,                  STATUS_UNSUCCESSFUL),
    MAPWSERROR (1,      1,                  STATUS_UNSUCCESSFUL),
    MAPWSERROR (2,      2,                  STATUS_UNSUCCESSFUL),
    MAPWSERROR (3,      3,                  STATUS_UNSUCCESSFUL),
    MAPWSERROR (4,      WSAEINTR,           STATUS_USER_APC),
    MAPWSERROR (5,      5,                  STATUS_UNSUCCESSFUL),
    MAPWSERROR (6,      6,                  STATUS_UNSUCCESSFUL),
    MAPWSERROR (7,      7,                  STATUS_UNSUCCESSFUL),
    MAPWSERROR (8,      8,                  STATUS_UNSUCCESSFUL),
    MAPWSERROR (9,      WSAEBADF,           STATUS_INVALID_PARAMETER),
    MAPWSERROR (10,     10,                 STATUS_UNSUCCESSFUL),     
    MAPWSERROR (11,     11,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (12,     12,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (13,     WSAEACCES,          STATUS_ACCESS_DENIED),
    MAPWSERROR (14,     WSAEFAULT,          STATUS_ACCESS_VIOLATION),
    MAPWSERROR (15,     15,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (16,     16,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (17,     17,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (18,     18,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (19,     19,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (20,     20,                 STATUS_UNSUCCESSFUL),      
    MAPWSERROR (21,     21,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (22,     WSAEINVAL,          STATUS_INVALID_PARAMETER),
    MAPWSERROR (23,     23,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (24,     WSAEMFILE,          STATUS_TOO_MANY_ADDRESSES),
    MAPWSERROR (25,     25,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (26,     26,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (27,     27,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (28,     28,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (29,     29,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (30,     30,                 STATUS_UNSUCCESSFUL),      
    MAPWSERROR (31,     31,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (32,     32,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (33,     33,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (34,     34,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (35,     WSAEWOULDBLOCK,     STATUS_MORE_PROCESSING_REQUIRED),          
    MAPWSERROR (36,     WSAEINPROGRESS,     STATUS_DEVICE_BUSY),
    MAPWSERROR (37,     WSAEALREADY,        STATUS_UNSUCCESSFUL),
    MAPWSERROR (38,     WSAENOTSOCK,        STATUS_INVALID_HANDLE),
    MAPWSERROR (39,     WSAEDESTADDRREQ,    STATUS_INVALID_PARAMETER),
    MAPWSERROR (40,     WSAEMSGSIZE,        STATUS_BUFFER_OVERFLOW),
    MAPWSERROR (41,     WSAEPROTOTYPE,      STATUS_INVALID_PARAMETER),
    MAPWSERROR (42,     WSAENOPROTOOPT,     STATUS_NOT_SUPPORTED),
    MAPWSERROR (43,     WSAEPROTONOSUPPORT, STATUS_NOT_SUPPORTED),
    MAPWSERROR (44,     WSAESOCKTNOSUPPORT, STATUS_NOT_SUPPORTED),
    MAPWSERROR (45,     WSAEOPNOTSUPP,      STATUS_NOT_SUPPORTED),
    MAPWSERROR (46,     WSAEPFNOSUPPORT,    STATUS_NOT_SUPPORTED),
    MAPWSERROR (47,     WSAEAFNOSUPPORT,    STATUS_NOT_SUPPORTED),
    MAPWSERROR (48,     WSAEADDRINUSE,      STATUS_ADDRESS_ALREADY_EXISTS),
    MAPWSERROR (49,     WSAEADDRNOTAVAIL,   STATUS_INVALID_ADDRESS_COMPONENT),
    MAPWSERROR (50,     WSAENETDOWN,        STATUS_UNEXPECTED_NETWORK_ERROR),
    MAPWSERROR (51,     WSAENETUNREACH,     STATUS_NETWORK_UNREACHABLE),
    MAPWSERROR (52,     WSAENETRESET,       STATUS_CONNECTION_RESET),
    MAPWSERROR (53,     WSAECONNABORTED,    STATUS_CONNECTION_ABORTED),
    MAPWSERROR (54,     WSAECONNRESET,      STATUS_CONNECTION_RESET),      
    MAPWSERROR (55,     WSAENOBUFS,         STATUS_INSUFFICIENT_RESOURCES),
    MAPWSERROR (56,     WSAEISCONN,         STATUS_CONNECTION_ACTIVE),
    MAPWSERROR (57,     WSAENOTCONN,        STATUS_INVALID_CONNECTION),
    MAPWSERROR (58,     WSAESHUTDOWN,       STATUS_INVALID_CONNECTION),
    MAPWSERROR (59,     WSAETOOMANYREFS,    STATUS_UNSUCCESSFUL),
    MAPWSERROR (60,     WSAETIMEDOUT,       STATUS_IO_TIMEOUT),
    MAPWSERROR (61,     WSAECONNREFUSED,    STATUS_CONNECTION_REFUSED),
    MAPWSERROR (62,     WSAELOOP,           STATUS_UNSUCCESSFUL),
    MAPWSERROR (63,     WSAENAMETOOLONG,    STATUS_NAME_TOO_LONG),
    MAPWSERROR (64,     WSAEHOSTDOWN,       STATUS_HOST_UNREACHABLE),
    MAPWSERROR (65,     WSAEHOSTUNREACH,    STATUS_HOST_UNREACHABLE),
    MAPWSERROR (66,     WSAENOTEMPTY,       STATUS_UNSUCCESSFUL),
    MAPWSERROR (67,     WSAEPROCLIM,        STATUS_INSUFFICIENT_RESOURCES),
    MAPWSERROR (68,     WSAEUSERS,          STATUS_UNSUCCESSFUL),
    MAPWSERROR (69,     WSAEDQUOT,          STATUS_INSUFFICIENT_RESOURCES),
    MAPWSERROR (70,     WSAESTALE,          STATUS_UNSUCCESSFUL),
    MAPWSERROR (71,     WSAEREMOTE,         STATUS_UNSUCCESSFUL),
    MAPWSERROR (72,     72,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (73,     73,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (74,     74,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (75,     75,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (76,     76,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (77,     77,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (78,     78,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (79,     79,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (80,     80,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (81,     81,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (82,     82,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (83,     83,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (84,     84,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (85,     85,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (86,     86,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (87,     87,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (88,     88,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (89,     89,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (90,     90,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (91,     WSASYSNOTREADY,     STATUS_MISSING_SYSTEMFILE),
    MAPWSERROR (92,     WSAVERNOTSUPPORTED, STATUS_UNSUCCESSFUL),
    MAPWSERROR (93,     WSANOTINITIALISED,  STATUS_APP_INIT_FAILURE),
    MAPWSERROR (94,     94,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (95,     95,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (96,     96,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (97,     97,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (98,     98,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (99,     99,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (100,    100,                STATUS_UNSUCCESSFUL),
    MAPWSERROR (101,    WSAEDISCON,         STATUS_GRACEFUL_DISCONNECT),
    MAPWSERROR (102,    WSAENOMORE,         STATUS_NO_MORE_ENTRIES),
    MAPWSERROR (103,    WSAECANCELLED,      STATUS_CANCELLED),
    MAPWSERROR (104,    WSAEINVALIDPROCTABLE,STATUS_UNSUCCESSFUL),
    MAPWSERROR (105,    WSAEINVALIDPROVIDER,STATUS_UNSUCCESSFUL),
    MAPWSERROR (106,    WSAEPROVIDERFAILEDINIT,STATUS_UNSUCCESSFUL),
    MAPWSERROR (107,    WSASYSCALLFAILURE,  STATUS_UNSUCCESSFUL),
    MAPWSERROR (108,    WSASERVICE_NOT_FOUND,STATUS_INVALID_SYSTEM_SERVICE),
    MAPWSERROR (109,    WSATYPE_NOT_FOUND,  STATUS_UNSUCCESSFUL),
    MAPWSERROR (110,    WSA_E_NO_MORE,      STATUS_NO_MORE_ENTRIES),
    MAPWSERROR (111,    WSA_E_CANCELLED,    STATUS_CANCELLED),
    MAPWSERROR (112,    WSAEREFUSED,        STATUS_CONNECTION_REFUSED)
    };
        // This is most likely code
    if (dwError==NO_ERROR)
        return NO_ERROR;
        // Process winsock codes
    else if ((dwError>=WSABASEERR) 
            && (dwError<WSABASEERR+sizeof(WSAEMap)/sizeof(WSAEMap[0])))
        return WSAEMap[dwError-WSABASEERR];
        // Process system specific codes
    else {
        switch (dwError) {
        case WSA_IO_PENDING:
        case WSA_IO_INCOMPLETE:
            return STATUS_UNSUCCESSFUL;
        case WSA_INVALID_HANDLE:
            return STATUS_INVALID_HANDLE;
        case WSA_INVALID_PARAMETER:
            return STATUS_INVALID_PARAMETER;
        case WSA_NOT_ENOUGH_MEMORY:
            return STATUS_INSUFFICIENT_RESOURCES;
        case WSA_OPERATION_ABORTED:  
            return STATUS_CANCELLED;
        default:
            return STATUS_UNSUCCESSFUL;
        }
    }

}


DWORD
AllowServiceDemandStart (
    SC_HANDLE hService
    )
/*++

Routine Description:

    Add the SERVICE_START right to Authenticated users with respect to this service. 

Arguments:

    hService - The service in question.

Notes:

    This code assumes that the Authenticated users SID is present in the DACL of the
    service (documented in MSDN)

Return Value:

    NO_ERROR, if successful.

    Win32 error code, on failure.

--*/
{
    int i;
    PSID pSid;
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_WORLD_SID_AUTHORITY;
    DWORD rc;
    DWORD sdSz;
    PSECURITY_DESCRIPTOR pSD;
    PACL pDacl, pNewDacl;
    BOOL bDaclPresent, bDaclDefaulted, bAceFound;
    PACCESS_ALLOWED_ACE pAce;


    //
    // Initialize locals for error cleanup below.
    //
    pSid = NULL;
    pSD = NULL;
    pNewDacl = NULL;
    bDaclDefaulted = FALSE;

    if (!AllocateAndInitializeSid (&sia,
            1,
            SECURITY_WORLD_RID,
            0,0,0,0,0,0,0,
            &pSid
            )) {
        rc = GetLastError ();
        WshPrint (DBG_SERVICE|DBG_FAILURES,
            ("WS2HELP-%lx AllowServiceDemandStart:"
            " Failed to allocate SID, err: %ld\n",
            PID, rc));
        goto cleanup;
    }

    //
    // Figure out how much buffer is needed for holding the service's
    // Security Descriptor (SD).
    //
    // NOTE: We pass &pSD instead of pSD because this parameter should
    //       not be NULL. For this call to QueryServiceObjectSecurity()
    //       we just need to pass some non-zero and valid buffer.
    //
    sdSz = 0;
    if (!QueryServiceObjectSecurity(
                  hService,                     // Handle of the service
                  DACL_SECURITY_INFORMATION,    // Type of info requested
                  &pSD,                         // Address of Security descriptor
                  0,                            // Size of SD buffer
                  &sdSz                           // Size of buffer needed
                  )) {
        rc = GetLastError ();
        if (rc!=ERROR_INSUFFICIENT_BUFFER && sdSz!=0) {
            WshPrint (DBG_SERVICE|DBG_FAILURES,
                ("WS2HELP-%lx AllowServiceDemandStart:"
                " Failed to get service DACL size info, err: %ld\n",
                PID, rc));
            goto cleanup;
        }
    }

    //
    // Allocate the SD
    //
    pSD = (PSECURITY_DESCRIPTOR) ALLOC_MEM (sdSz);
    if (pSD==NULL) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        WshPrint (DBG_SERVICE|DBG_FAILURES,
            ("WS2HELP-%lx AllowServiceDemandStart:"
            " Failed to allocate memory (%d bytes) for service sd, err: %ld\n",
            PID, sdSz, rc));
        goto cleanup;
    }


    //
    // Now, we are ready to get the service's SD.
    //
    if (!QueryServiceObjectSecurity(
                  hService,                     // Handle of the service
                  DACL_SECURITY_INFORMATION,    // Type of info requested
                  pSD,                          // Address of Security descriptor
                  sdSz,                           // Size of SD buffer
                  &sdSz                           // Size of buffer needed
                  )) {
        rc = GetLastError ();
        WshPrint (DBG_SERVICE|DBG_FAILURES,
            ("WS2HELP-%lx AllowServiceDemandStart:"
            " Failed to get service DACL info, err: %ld\n",
            PID, rc));
        goto cleanup;
    }

    //
    // Get the DACL from SD, if present.
    //
    if (!GetSecurityDescriptorDacl(
                  pSD,                  // Address of SD
                  &bDaclPresent,        // Address of flag for presence of DACL
                  &pDacl,               // Address of pointer to DACL
                  &bDaclDefaulted       // Address of flag that indicates if
                  )) {                   // DACL was defaulted.
        rc = GetLastError ();
        WshPrint (DBG_SERVICE|DBG_FAILURES,
            ("WS2HELP-%lx AllowServiceDemandStart:"
            " Failed to get DACL from service sd, err: %ld\n",
            PID, rc));
        goto cleanup;
    }

    //
    // Find the ACE in the ACL and update it's Mask.
    // If we can't find one, we'll have to add our own
    //
    bAceFound = FALSE;
    if (bDaclPresent && pDacl!=NULL) {
        for (i = 0; i < pDacl->AceCount; i++) {
            if (!GetAce(pDacl,              // pointer to ACL
                          i,                // index of ACE to retrieve
                          (LPVOID*) &pAce   // pointer to pointer to ACE
                          )) {
                rc = GetLastError ();
                WshPrint (DBG_SERVICE|DBG_FAILURES,
                    ("WS2HELP-%lx AllowServiceDemandStart:"
                    " Failed to get ACE # %d from DACL, err: %ld\n",
                    PID, i, rc));
                goto cleanup;
            }

            if (pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE && 
                    EqualSid(pSid, &(pAce->SidStart))) {
                pAce->Mask |= SERVICE_START|SERVICE_QUERY_STATUS;
                bAceFound = TRUE;
                break;
            }
        } // for ()
    }

    if (!bAceFound) {
        //
        // Could not find the ACE, add our own ace to DACL
        //
        ACL_SIZE_INFORMATION szInfo;
        ACL_REVISION_INFORMATION revInfo;
        SECURITY_DESCRIPTOR_CONTROL control;
        DWORD sdRev;

        if (!GetSecurityDescriptorControl (pSD, &control, &sdRev)) {
            rc = GetLastError ();
            WshPrint (DBG_SERVICE|DBG_FAILURES,
                ("WS2HELP-%lx AllowServiceDemandStart:"
                " Failed to get SD control/revision info, err: %ld\n",
                PID, rc));
            goto cleanup;
        }

        //
        // Convert service security descriptor to absolute format.
        //
        if (control & SE_SELF_RELATIVE) {
            DWORD absSz = sdSz;
            if (!MakeAbsoluteSD2 (pSD, &absSz)) {
                PSECURITY_DESCRIPTOR pAbsSd;
                rc = GetLastError ();
                if (rc!=ERROR_INSUFFICIENT_BUFFER) {
                    WshPrint (DBG_SERVICE|DBG_FAILURES,
                        ("WS2HELP-%lx AllowServiceDemandStart:"
                        " Failed convert service sd to absolute format (for size), err: %ld\n",
                        PID, rc));
                    goto cleanup;
                }

                pAbsSd = (PSECURITY_DESCRIPTOR) ALLOC_MEM (absSz);
                if (pAbsSd==NULL) {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                    WshPrint (DBG_SERVICE|DBG_FAILURES,
                        ("WS2HELP-%lx AllowServiceDemandStart:"
                        " Failed to allocate memory (%d bytes) for absolute service sd, err: %ld\n",
                        PID, absSz, rc));
                    goto cleanup;
                }

                CopyMemory (pAbsSd, pSD, sdSz);
                FREE_MEM (pSD);
                sdSz = absSz;
                pSD = pAbsSd;

                if (!MakeAbsoluteSD2 (pSD, &sdSz)) {
                    rc = GetLastError ();
                    WshPrint (DBG_SERVICE|DBG_FAILURES,
                        ("WS2HELP-%lx AllowServiceDemandStart:"
                        " Failed convert service sd to absolute format (reallocated), err: %ld\n",
                        PID, rc));
                    goto cleanup;
                }
            }
        }

        if (bDaclPresent && pDacl!=NULL) {
            //
            // Read old DACL info to move it to new DACL
            //
            if (!GetAclInformation (pDacl, &szInfo, sizeof (szInfo), AclSizeInformation) ||
                !GetAclInformation (pDacl, &revInfo, sizeof (revInfo), AclRevisionInformation) ) {
                rc = GetLastError ();
                WshPrint (DBG_SERVICE|DBG_FAILURES,
                    ("WS2HELP-%lx AllowServiceDemandStart:"
                    " Failed to get DACL size/revision info, err: %ld\n",
                    PID, rc));
                goto cleanup;
            }
        }
        else {
            //
            // Need to created DACL from scratch
            //
            szInfo.AclBytesInUse = sizeof (ACL);
            revInfo.AclRevision = ACL_REVISION;
        }

        //
        // Allocate and initialize DACL
        //
        szInfo.AclBytesInUse += FIELD_OFFSET (ACCESS_ALLOWED_ACE, SidStart) +
                                GetLengthSid (pSid);
        pNewDacl = ALLOC_MEM (szInfo.AclBytesInUse);
        if (pNewDacl==NULL) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            WshPrint (DBG_SERVICE|DBG_FAILURES,
                ("WS2HELP-%lx AllowServiceDemandStart:"
                " Failed to get allocate new DACL (%d bytes), err: %ld\n",
                PID, szInfo.AclBytesInUse, rc));
            goto cleanup;
        }

        if (!InitializeAcl (pNewDacl, szInfo.AclBytesInUse, revInfo.AclRevision)) {
            rc = GetLastError ();
            WshPrint (DBG_SERVICE|DBG_FAILURES,
                ("WS2HELP-%lx AllowServiceDemandStart:"
                " Failed to initialize new DACL (rev %d), err: %ld\n",
                PID, revInfo.AclRevision, rc));
            goto cleanup;
        }

        //
        // Add ace allowing starting the service
        //
        if (!AddAccessAllowedAce (pNewDacl, revInfo.AclRevision, SERVICE_START|SERVICE_QUERY_STATUS, pSid)) {
            rc = GetLastError ();
            WshPrint (DBG_SERVICE|DBG_FAILURES,
                ("WS2HELP-%lx AllowServiceDemandStart:"
                " Could not add ace to new DACL , err: %ld\n",
                PID, rc));
            goto cleanup;
        }

        //
        // If old dacl existed, move ACE's from it to new DACL
        //
        if (bDaclPresent && pDacl!=NULL) {
            //
            // Get ACE list from old DACL
            // Must succeed since we did it above.
            //
            GetAce (pDacl, 0, (LPVOID *)&pAce);

            //
            // Add them right after ours
            //
            if (!AddAce (pNewDacl, 
                            revInfo.AclRevision,
                            1,
                            pAce, 
                            pDacl->AclSize-sizeof(ACL))) {
                rc = GetLastError ();
                WshPrint (DBG_SERVICE|DBG_FAILURES,
                    ("WS2HELP-%lx AllowServiceDemandStart:"
                    " Could move ACE's to new DACL , err: %ld\n",
                    PID, rc));
                goto cleanup;
            }
        }

        

        //
        // Set new DACL into security decriptor.
        //
        if (!SetSecurityDescriptorDacl(pSD,     // SD
                                        TRUE,   // DACL presence
                                        pNewDacl,  // DACL
                                        bDaclDefaulted // default DACL
                                        )) {
            rc = GetLastError ();
            WshPrint (DBG_SERVICE|DBG_FAILURES,
                ("WS2HELP-%lx AllowServiceDemandStart:"
                " Could not set new DACL in sd, err: %ld\n",
                PID, rc));
            goto cleanup;
        }
    }

    //
    // Set the new SD on the service handle
    //
    if (!SetServiceObjectSecurity(
                hService,                   // Handle to the service.
                DACL_SECURITY_INFORMATION,  // Type of info being set
                pSD                         // Address of the new SD
                )) {
        rc = GetLastError ();
        WshPrint (DBG_SERVICE|DBG_FAILURES,
            ("WS2HELP-%lx AllowServiceDemandStart:"
            " Failed to set service DACL info, err: %ld\n",
            PID, rc));
        goto cleanup;
    }

    rc = 0;


cleanup:
    //
    // Cleanup
    //
    if (pSid) {
        FreeSid(pSid);
    }

    if (pSD) {
        FREE_MEM (pSD);
    }

    if (pNewDacl) {
        FREE_MEM (pNewDacl);
    }

    return rc;
}

DWORD
DemandStartWS2IFSL (
    VOID
    )
{
    SC_HANDLE   hSCManager, hService;
    INT         err;
    NTSTATUS    status;

    WshPrint (DBG_SERVICE,
        ("WS2HELP-%lx DemandStartWS2IFSL: Attempting to start ...\n", PID));

    //
    // First attempt to load driver directly in the current process.
    // This is much faster that communicate to SC over RPC, especially
    // during boot when SC is not fully initialized or busy.
    //
    status = RtlImpersonateSelf (SecurityImpersonation);
    if (NT_SUCCESS (status)) {
        BOOLEAN wasEnabled;
        status =
            RtlAdjustPrivilege(
                SE_LOAD_DRIVER_PRIVILEGE,
                TRUE,
                TRUE,
                &wasEnabled
                );
        if (NT_SUCCESS (status)) {
            UNICODE_STRING  servicePath;

            RtlInitUnicodeString (&servicePath, WS2IFSL_SERVICE_PATH);
            status = NtLoadDriver (&servicePath);
            if (!wasEnabled) {
#if DBG
                NTSTATUS status2 =
#endif
                RtlAdjustPrivilege(
                    SE_LOAD_DRIVER_PRIVILEGE,
                    TRUE,
                    TRUE,
                    &wasEnabled
                    );
                ASSERT (NT_SUCCESS (status2));
            }
        }
        else {
            WshPrint (DBG_SERVICE|DBG_FAILURES,
                    ("WS2HELP-%lx DemandStartWS2IFSL: Failed to get load driver privilige, status: 0x%lx.\n",
                    PID, status));
        }

        RevertToSelf ();

        if (NT_SUCCESS (status)) {
            WshPrint (DBG_SERVICE,
                    ("WS2HELP-%lx DemandStartWS2IFSL: Loaded driver OK.\n",
                    PID));
            return NO_ERROR;
        }
        else {
            WshPrint (DBG_SERVICE|DBG_FAILURES,
                    ("WS2HELP-%lx DemandStartWS2IFSL: Failed to load driver, status: 0x%lx.\n",
                    PID, status));
        }
    }
    else {
        WshPrint (DBG_SERVICE|DBG_FAILURES,
                ("WS2HELP-%lx DemandStartWS2IFSL: Failed to impersonate self, status: 0x%lx.\n",
                PID, status));
    }

    //
    // Open service database on the local computer
    //
    hSCManager = OpenSCManager (
                        NULL,
                        SERVICES_ACTIVE_DATABASE,
                        SC_MANAGER_CONNECT|SC_MANAGER_ENUMERATE_SERVICE
                        );
    if (hSCManager!=NULL) {

        //
        // Open service itself
        //

        hService = OpenService (
                    hSCManager,
                    WS2IFSL_SERVICE_NAME,
                    SERVICE_START | SERVICE_QUERY_STATUS);
        if (hService!=NULL) {

            //
            // Go ahead, try start the service
            //
            if (!StartService (hService, 0, NULL)) {
                //
                // Check if it is already running
                //
                err = GetLastError ();
                if (err!=ERROR_SERVICE_ALREADY_RUNNING) {
                    //
                    // Could not start it, bail out
                    //
                    WshPrint (DBG_SERVICE|DBG_FAILURES,
                            ("WS2HELP-%lx DemandStartWS2IFSL: Could not start service, err: %ld\n",
                            PID, err));
                    goto cleanup;
                }
                else {
                    WshPrint (DBG_SERVICE,
                            ("WS2HELP-%lx DemandStartWS2IFSL: Service is already running, err: %ld\n",
                        PID, err));
                }
            }
            else {
                do {
                    SERVICE_STATUS status;
                    if (!QueryServiceStatus(hService, &status)) {
                        err = GetLastError ();
                        WshPrint (DBG_SERVICE|DBG_FAILURES,
                            ("WS2HELP-%lx DemandStartWS2IFSL: Could not query service status, err: %ld\n",
                            PID, err));
                        //
                        // Ignore the error here.
                        //
                        break;
                    }

                    if (status.dwCurrentState != SERVICE_START_PENDING) {
                        if (status.dwCurrentState==SERVICE_RUNNING) {
                            WshPrint (DBG_SERVICE,
                                        ("WS2HELP-%lx DemandStartWS2IFSL: Service has been started.\n",
                                        PID));
                            break;
                        }
                        else {
                            WshPrint (DBG_SERVICE|DBG_FAILURES,
                                        ("WS2HELP-%lx DemandStartWS2IFSL: Failed to start service, status: %ld\n",
                                        PID, status.dwCurrentState));
                            err = WSAENETDOWN;
                            goto cleanup;
                        }
                    }
                    //
                    // Yield to another thread on current processor.
                    // If no threads are ready to run on current processor,
                    // we'll have to sleep to avoid consuming too much CPU
                    // in what would look almost like busy wait.
                    //
                    if (!SwitchToThread()) {
                        Sleep (10);
                    }
                }
                while (TRUE);
            }
            err = NO_ERROR;
        cleanup:
            CloseServiceHandle (hService);
        }
        else {
            err = GetLastError ();
            WshPrint (DBG_SERVICE|DBG_FAILURES,
                        ("WS2HELP-%lx DemandStartWS2IFSL: Could open service, err: %ld\n",
                        PID, err));
        }

        CloseServiceHandle (hSCManager);
    }
    else {

        err = GetLastError ();
        WshPrint (DBG_SERVICE|DBG_FAILURES,
                    ("WS2HELP-%lx DemandStartWS2IFSL: Could not open SC, err: %ld\n",
                    PID, err));
    }

    switch (err) {
    case NO_ERROR:
    case WSAENETDOWN:
    case ERROR_NOT_ENOUGH_MEMORY:
        {
            C_ASSERT (ERROR_NOT_ENOUGH_MEMORY==WSA_NOT_ENOUGH_MEMORY);
        }
        break;
    case ERROR_ACCESS_DENIED:
        err = WSAEACCES;
        break;
    default:
        err = WSASYSNOTREADY;
    }
    return err;
}




DWORD
Ws2helpInitialize (
    VOID
    ) {
    EnterCriticalSection (&StartupSyncronization);
    if (!Ws2helpInitialized) {
        NewCtxInit ();
#if DBG
        //ReadDbgInfo ();
#endif
        Ws2helpInitialized = TRUE;
    }
    LeaveCriticalSection (&StartupSyncronization);

    return 0;
}

#if DBG
VOID
ReadDbgInfo (
    VOID
    ) {
    TCHAR                       ProcessFilePath[MAX_PATH+1];
    LPTSTR                      pProcessFileName;
    HKEY                        hDebugKey;
    DWORD                       sz, rc, level;

    PID = GetCurrentProcessId ();
    if (GetModuleFileName (NULL, ProcessFilePath, sizeof (ProcessFilePath))>0) {
        pProcessFileName = _tcsrchr (ProcessFilePath, '\\');
        if (pProcessFileName!=NULL)
            pProcessFileName += 1;
        else
            pProcessFileName = ProcessFilePath;
    }
    else
        DbgPrint ("WS2HELP-%lx ReadDbgInfo: Could not get process name, err=%ld.\n",
                                                PID, GetLastError ());
    if ((rc=RegOpenKeyExA (HKEY_LOCAL_MACHINE,
            WS2IFSL_DEBUG_KEY,
            0,
            KEY_QUERY_VALUE,
            &hDebugKey))==NO_ERROR) {
        sz = sizeof (DbgLevel);
        if (RegQueryValueEx (hDebugKey,
                TEXT("DbgLevel"),
                NULL,
                NULL, 
                (LPBYTE)&level,
                &sz)==0)
			DbgLevel = level;

        sz = sizeof (DbgLevel);
        if (RegQueryValueEx (hDebugKey,
                pProcessFileName,
                NULL,
                NULL, 
                (LPBYTE)&level,
                &sz)==0)
			DbgLevel = level;
        RegCloseKey (hDebugKey);
        DbgPrint ("WS2HELP-%lx ReadDbgInfo: DbgLevel set to %lx.\n",
                   PID, DbgLevel);
        
    }
    else if (rc!=ERROR_FILE_NOT_FOUND)
        DbgPrint ("WS2HELP-%lx ReadDbgInfo: Could not open dbg key (%s), err=%ld.\n",
                   PID, WS2IFSL_DEBUG_KEY, rc);
}


#endif //DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\ws2help\nt\newctx.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    newctx.c

Abstract:

    This module implements functions for creating and manipulating context
    tables. Context tables are used in WinSock 2.0 for associating 32-bit
    context values with socket handles.

Author:

    Vadim Eyldeman (VadimE)       11-Nov-1997

Revision History:

--*/


#include "precomp.h"
#include "newctx.h"


//
// Private contstants
//

//
// Min & max allowable values for number of handle lookup tables
// (must be some number == 2**N for optimal performance)
//
#define MIN_HANDLE_BUCKETS_WKS 0x8
#define MAX_HANDLE_BUCKETS_WKS 0x20
#define MIN_HANDLE_BUCKETS_SRV 0x20
#define MAX_HANDLE_BUCKETS_SRV 0x100

//
// Default & maximum spin count values (for critical section creation)
//

#define DEF_SPIN_COUNT 2000
#define MAX_SPIN_COUNT 8000


//
// Private globals
//

// Prime numbers used for closed hashing
ULONG const SockPrimes[] =
{
    31, 61, 127, 257, 521, 1031, 2053, 4099, 8191,
    16381, 32749, 65537, 131071, 261983, 
    0xFFFFFFFF  // Indicates end of the table, next number must be computed
                // on the fly.
};

DWORD   gdwSpinCount=0;     // Spin count used in critical sections
ULONG   gHandleToIndexMask; // Actual mask is currently the same for
                            // all tables in this DLL.
HANDLE  ghWriterEvent;      // Event for writer to wait on for readers
                            // if spinning and simple sleep fail.

//
// Table access macros.
//
// This uses property of Win NT handles which have two low order bits 0-ed
#define TABLE_FROM_HANDLE(_h,_tbls) \
            (&(_tbls)->Tables[((((ULONG_PTR)_h) >> 2) & (_tbls)->HandleToIndexMask)])

// Hash function (no need to shift as we use prime numbers)
#define HASH_BUCKET_FROM_HANDLE(_h,_hash) \
            ((_hash)->Buckets[(((ULONG_PTR)_h) % (_hash)->NumBuckets)])


//
// RW_LOCK macros
//

//VOID
//AcquireTableReaderLock (
//  IN  LPCTX_LOOKUP_TABLE     tbl,
//  OUT LONG                   idx
//  );
/*++
*******************************************************************
Routine Description:
    Acquires reader access to table
Arguments:
    tbl - table to lock
    idx - idx of the exit counter to release.
Return Value:
    NONE
*******************************************************************
--*/
#ifdef _RW_LOCK_

#define AcquireTableReaderLock(tbl,idx)                                 \
            idx = (InterlockedExchangeAdd ((LPLONG)&(tbl)->EnterCounter,2) & 1)

#else  //_RW_LOCK_

#define AcquireTableReaderLock(tbl,idx)                             \
            idx = (EnterCriticalSection(&tbl->WriterLock),0)

#endif //_RW_LOCK_

//VOID
//ReleaseTableReaderLock (
//  IN  LPCTX_LOOKUP_TABLE     tbl
//  IN  LONG                   idx
//  );
/*++
*******************************************************************
Routine Description:
    Releases reader access to table
Arguments:
    lock - pointer to lock
    idx - index of the counter to release 
Return Value:
    None
*******************************************************************
--*/
#ifdef _RW_LOCK_

#define ReleaseTableReaderLock(tbl,idx)						                \
    /* Increment the exit counter to let the writer determine when all */   \
    /* the readers that incremented enter counter are gone */               \
    if (InterlockedExchangeAdd((LPLONG)&(tbl)->ExitCounter[idx],2)==idx){   \
        /* When writer needs a signal, it changes the counter, so that */   \
        /* last reader decrements the counting part to 0 and index part */  \
        /* corresponds to another counter */                                \
        BOOL    res;                                                        \
        ASSERT (ghWriterEvent!=NULL);                                       \
        res = PulseEvent (ghWriterEvent);                                   \
        ASSERT (res);                                                       \
    }


#else  //_RW_LOCK_

#define ReleaseTableReaderLock(tbl,idx)                             \
            LeaveCriticalSection (&(tbl)->WriterLock)

#endif //_RW_LOCK_


//VOID
//AcquireTableWriterLock (
//  IN  LPCTX_LOOKUP_TABLE  tbl
//  );
/*++
*******************************************************************
Routine Description:
    Acquires writer access to table
Arguments:
    tbl - table to lock
Return Value:
    None
*******************************************************************
--*/
#define AcquireTableWriterLock(tbl) EnterCriticalSection(&(tbl)->WriterLock)

//VOID
//ReleaseTableWriterLock (
//  IN  LPCTX_LOOKUP_TABLE  tbl
//  );
/*++
*******************************************************************
Routine Description:
    Releases writer access to table
Arguments:
    tbl - table to lock
Return Value:
    None
*******************************************************************
--*/
#define ReleaseTableWriterLock(tbl) LeaveCriticalSection(&(tbl)->WriterLock)


//VOID
//WaitForAllReaders (
//  IN  LPSOCK_LOOKUP_TABLE    tbl
//  );
/*++
*******************************************************************
Routine Description:
    Waits for all readers that are in process of accessing the table
Arguments:
    tbl - table
Return Value:
    None
*******************************************************************
--*/
#ifdef _RW_LOCK_

//
// Execute long wait (context switch requred) for readers
// Extra function call won't make much difference here.
//

VOID
DoWaitForReaders (
    LPCTX_LOOKUP_TABLE  Tbl,
    LONG                Ctr,
    LONG                Idx
    )
{

	/* Force context switch to let the reader(s) go */
    SwitchToThread ();
    if (Tbl->ExitCounter[Idx]!=Ctr) {
        RecordFailedSwitch (Tbl);
        /* If we failed we must be dealing with lower priority thread */ 
        /* waiting to execute on another  processor, wait on event to */
        /* let it proceed */
        if (ghWriterEvent==NULL) {
            /* Need to allocate a manual reset event */
            HANDLE  hEvent;
#if DBG || EVENT_CREATION_FAILURE_COUNT
            static long count = 0;
#ifndef EVENT_CREATION_FAILURE_COUNT
#define EVENT_CREATION_FAILURE_COUNT 0
#endif
            static long failure_rate = EVENT_CREATION_FAILURE_COUNT;
            if (count<failure_rate) {
                hEvent = NULL;
                count += 1;
            }
            else
#endif
                hEvent = CreateEvent (NULL, TRUE, FALSE, NULL);

            if (hEvent!=NULL) {
                /* Make sure someone else did not do it too*/
                if (InterlockedCompareExchangePointer (
                                    (PVOID *)&ghWriterEvent,
                                    hEvent,
                                    NULL)!=NULL) {
                    /* Event is already there, free ours */
                    CloseHandle (hEvent);
                }
            }
            else {
                /* Could not allocate event, will have to */
                /* use sleep to preempt ourselves */
                if (Ctr!=Tbl->ExitCounter[Idx]) {
                    Sleep (10);
		        }
                return;
            }
        }
        /* Substract the enter count from the counter to make it 0 when all */
        /* the readers are gone and add the value of the index, so */
        /* that the last reader notices and signals us. */
        Ctr = 0-Ctr+Idx;
        if (InterlockedExchangeAdd((LPLONG)&Tbl->ExitCounter[Idx], Ctr)!=Idx) {
            do {
                DWORD rc;
                /* We can't just wait forever because readers */
                /* pulse the event, we may miss it (can't set */
                /* because event is shared) */
                rc = WaitForSingleObject (ghWriterEvent, 10);   
                ASSERT (rc==WAIT_OBJECT_0 || rc==WAIT_TIMEOUT);
                RecordCompletedWait (Tbl);
            }
            while (Tbl->ExitCounter[Idx]!=Idx);
        }
    }                                                           
}


#define WaitForAllReaders(tbl)         {                            \
    LONG    idx = (tbl)->EnterCounter&1;                            \
    LONG    ctr;                                                    \
    /* Initialize the other exit counter with opposite index.*/     \
    (tbl)->ExitCounter[idx^1] = idx;                                \
    /* Read the enter counter and exit counter index and */         \
    /* reinitialize it with other exit counter index. */            \
    ctr = InterlockedExchange ((LPLONG)&(tbl)->EnterCounter,idx^1)^1;\
    /* Check if old exit counter has reached the same value */      \
    if (ctr!=(tbl)->ExitCounter[idx]) {                             \
        /* Some readers remain, we'll have to wait for them*/       \
		RecordWriterWait(tbl);										\
		/* Spin in case reader is executing on another processor */ \
        /* (SpinCount can only be non-zero on MP machines) */       \
		if ((tbl)->SpinCount) {							            \
			LONG spinCtr = (tbl)->SpinCount;			            \
			while (ctr!=(tbl)->ExitCounter[idx]) {		            \
				if (--spinCtr<=0) {                                 \
					RecordFailedSpin(tbl);							\
					break;											\
				}													\
			}														\
		}															\
        if (ctr!=(tbl)->ExitCounter[idx]) {                         \
            /* Still someone there, we'll have to context switch */ \
            DoWaitForReaders (tbl,ctr,idx);                         \
        }                                                           \
	}																\
}

#else //_RW_LOCK_

#define WaitForAllReaders(tbl)         {                            \
}

#endif //_RW_LOCK_

//
// Function called during DLL initialization to peek up
// system parameters and initialize globals
//
VOID
NewCtxInit (
    VOID
    ) {
    ULONG           numLookupTables;
    NT_PRODUCT_TYPE productType;
    HKEY            hKey;
    ULONG           dwDataSize, dwDataType, dwBitMask;
	SYSTEM_INFO		sysInfo;


    productType = NtProductWinNt;

    if (!RtlGetNtProductType (&productType)) {
        productType = NtProductWinNt;
    }

	GetSystemInfo (&sysInfo);

    //
    // Spin only on MP machines.
    //
	if (sysInfo.dwNumberOfProcessors>1) {
        gdwSpinCount = DEF_SPIN_COUNT;
    }
    else {
        gdwSpinCount = 0;
    }
    //
    // Determine the # of lookup table entries or "handle buckets".
    // This number will vary depending on whether the platform is NT
    // Server or not. Allow configuration of this value via registry,
    // and make sure that the # of buckets is reasonable given the
    // platform, and that it is some value == 2**N so our handle->lock
    // mapping scheme is optimal.
    //
    // Also retrieve the spin count for use in calling
    // InitializeCriticalSectionAndSpinCount()
    //


    numLookupTables = ( productType==NtProductWinNt ?
        MIN_HANDLE_BUCKETS_WKS : MIN_HANDLE_BUCKETS_SRV );

    if (RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("System\\CurrentControlSet\\Services\\Winsock2\\Parameters"),
            0,
            KEY_QUERY_VALUE,
            &hKey

            ) == ERROR_SUCCESS) {

        dwDataSize = sizeof (numLookupTables);
        RegQueryValueEx(
            hKey,
            TEXT("Ws2_32NumHandleBuckets"),
            0,
            &dwDataType,
            (LPBYTE) &numLookupTables,
            &dwDataSize
            );

		if (sysInfo.dwNumberOfProcessors>1) {
			// Spinning only makes sense on multiprocessor machines
			dwDataSize = sizeof (gdwSpinCount);
			RegQueryValueEx(
				hKey,
				TEXT("Ws2_32SpinCount"),
				0,
				&dwDataType,
				(LPBYTE) &gdwSpinCount,
				&dwDataSize
				);
		}

        RegCloseKey (hKey);
    }

    // Make sure the number is power of 2 and whithin the limits
    for(
        dwBitMask = MAX_HANDLE_BUCKETS_SRV;
        (dwBitMask & numLookupTables) == 0;
        dwBitMask >>= 1
        );
    numLookupTables = dwBitMask;

    if ( productType==NtProductWinNt ) {

        if ( numLookupTables > MAX_HANDLE_BUCKETS_WKS ) {

            numLookupTables = MAX_HANDLE_BUCKETS_WKS;

        }
        else if ( numLookupTables < MIN_HANDLE_BUCKETS_WKS ){

            numLookupTables = MIN_HANDLE_BUCKETS_WKS;
        }
    }
    else {

        if ( numLookupTables > MAX_HANDLE_BUCKETS_SRV ) {

            numLookupTables = MAX_HANDLE_BUCKETS_SRV;

        }
        else if ( numLookupTables < MIN_HANDLE_BUCKETS_SRV ){

            numLookupTables = MIN_HANDLE_BUCKETS_SRV;
        }
    }
    if (gdwSpinCount>MAX_SPIN_COUNT) {
        gdwSpinCount = MAX_SPIN_COUNT;
    }

    gHandleToIndexMask = numLookupTables - 1;
}


WS2HELPAPI
DWORD
WINAPI
WahCreateHandleContextTable(
    OUT LPCONTEXT_TABLE FAR * Table
    ) 
/*++

Routine Description:

    Creates handle -> context lookup table

Arguments:

    Table   -   Returns pointer to the created table


Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/

{
    INT     return_code = ERROR_SUCCESS;
    ULONG   i;

    return_code = ENTER_WS2HELP_API ();
    if (return_code!=0)
        return return_code;


    //
    // Allocate & initialize the handle lookup table
    //

    *Table = ALLOC_MEM (FIELD_OFFSET (struct _CONTEXT_TABLE,
                            Tables[gHandleToIndexMask+1]));

    if ( *Table == NULL ) {

        return WSA_NOT_ENOUGH_MEMORY;
    }

    (*Table)->HandleToIndexMask = gHandleToIndexMask;

    for ( i = 0; i <= gHandleToIndexMask; i++ ) {

        (*Table)->Tables[i].HashTable = NULL;
#ifdef _RW_LOCK_
        (*Table)->Tables[i].EnterCounter = 0;
        (*Table)->Tables[i].ExitCounter[0] = 1;
        (*Table)->Tables[i].ExitCounter[1] = 0;
        (*Table)->Tables[i].ExpansionInProgress = FALSE;
        (*Table)->Tables[i].SpinCount = gdwSpinCount;
#ifdef _PERF_DEBUG_
        (*Table)->Tables[i].WriterWaits = 0;
        (*Table)->Tables[i].FailedSpins = 0;
        (*Table)->Tables[i].FailedSwitches = 0;
        (*Table)->Tables[i].CompletedWaits = 0;
#endif
#endif //_RW_LOCK_
        __try {

            InitializeCriticalSectionAndSpinCount (
                &(*Table)->Tables[i].WriterLock,
                gdwSpinCount
                );
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            goto Cleanup;
        }
    }

    return ERROR_SUCCESS;

Cleanup:
    while (i-- > 0) {
        DeleteCriticalSection (&(*Table)->Tables[i].WriterLock);
    }
    FREE_MEM (*Table);
    return WSA_NOT_ENOUGH_MEMORY;
}

WS2HELPAPI
DWORD
WINAPI
WahDestroyHandleContextTable(
    LPCONTEXT_TABLE Table
    )
/*++

Routine Description:

    Destroys handle -> context lookup table

Arguments:

    Table   -   Supplies pointer to the table to destory


Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/
{
    ULONG i;

//  Valid table pointer required anyway.
//    return_code = ENTER_WS2HELP_API ();
//    if (return_code!=0)
//        return return_code;

    if (Table!=NULL) {

        for ( i = 0; i <= Table->HandleToIndexMask; i++ ) {
			
            if ( Table->Tables[i].HashTable != NULL) {

                FREE_MEM (Table->Tables[i].HashTable);
            }

            DeleteCriticalSection (&Table->Tables[i].WriterLock);
        }

        FREE_MEM (Table);
        return ERROR_SUCCESS;
    }
    else {
        return ERROR_INVALID_PARAMETER;
    }

}

WS2HELPAPI
LPWSHANDLE_CONTEXT
WINAPI
WahReferenceContextByHandle(
    LPCONTEXT_TABLE Table,
    HANDLE          Handle
    )
/*++

Routine Description:

    Looks up context for the handle in the table

Arguments:

    Table   -   Supplies pointer to the table in which to lookup

    Handle  -   Supplies WinNT object handle to find context for


Return Value:

    REFERENCED context for the handle if found, 
    NULL if it does not exist

--*/
{
    LPWSHANDLE_CONTEXT  ctx;
    LPCTX_LOOKUP_TABLE  table = TABLE_FROM_HANDLE(Handle,Table);
    LPCTX_HASH_TABLE    hash;
    LONG                idx;

//  Valid table pointer required anyway.
//    return_code = ENTER_WS2HELP_API ();
//    if (return_code!=0)
//        return return_code;

    // Take the lock
    AcquireTableReaderLock (table, idx);
    hash = table->HashTable;

    // Make sure that context exists and for the right handle
    if ((hash!=NULL)
            && ((ctx=HASH_BUCKET_FROM_HANDLE(
                                        Handle,
                                        hash))!=NULL)
            && (ctx->Handle==Handle)) {
        WahReferenceHandleContext(ctx);
    }
    else {
        ctx = NULL;
    }
    ReleaseTableReaderLock (table, idx);

    return ctx;
}

WS2HELPAPI
LPWSHANDLE_CONTEXT
WINAPI
WahInsertHandleContext(
    LPCONTEXT_TABLE     Table,
    LPWSHANDLE_CONTEXT  HContext
    )
/*++

Routine Description:

    Inserts context for the handle in the table.

Arguments:

    Table   -   Supplies pointer to the table into which to insert

    HContext -  Supplies handle context to insert which contains
                handle value and internally\externally used
                reference count


Return Value:
    NULL    -   context could not be inserted because of allocation failure
    HContext -  context was successfully inserted into empty cell
    other context - HContext replaced another context which is returned to
                    the caller

--*/
{
    LPWSHANDLE_CONTEXT  *pBucket, oldContext;
    LONG                idx;
    LPCTX_HASH_TABLE    hash, newHashTable;
    ULONG               newNumHashBuckets, i;
    LPCTX_LOOKUP_TABLE  table = TABLE_FROM_HANDLE(HContext->Handle,Table);

//  Valid table pointer required anyway.
//    return_code = ENTER_WS2HELP_API ();
//    if (return_code!=0)
//        return return_code;

    do {
#ifdef _RW_LOCK_
		AcquireTableReaderLock(table, idx);
        hash = table->HashTable;
		//
		// First make sure we have already initialized hash table
        // and it is not being expanded at the moment
		//
        if (!table->ExpansionInProgress && (hash!=NULL)) {
            pBucket = &HASH_BUCKET_FROM_HANDLE(HContext->Handle,hash);
			//
			// Try to insert handle context into the table
			//
            if (InterlockedCompareExchangePointer (
							(PVOID *)pBucket,
							HContext,
							NULL)==NULL) {
			    //
			    // If bucket was empty and thus we succeded, get out.
			    //
			    ReleaseTableReaderLock(table,idx);
                oldContext = HContext;
                break;
            }
            else {
                //
                // Another context for the same handle exists or collision 
                // in hash value, need to go the long way with the exclusive lock
                // held (we will either need to replace the context or expand
                // the table, in both cases we need to make sure that no-one
                // can be still looking at the table or the context after
                // we return.
                //
            }
        }
        else {
			//
			// Table is empty, need to create one
			//
		}

	    ReleaseTableReaderLock(table,idx);
#endif //_RW_LOCK_

        //
        // Acquire writer lock for table expansion operation.
        //
		AcquireTableWriterLock (table);

        //
        // Make sure no-one is trying to modify the table
        //
#ifdef _RW_LOCK_
        table->ExpansionInProgress = TRUE;
#endif //_RW_LOCK_
        WaitForAllReaders (table);

        do {
            hash = table->HashTable;
            if (hash!=NULL) {

                //
                // First check if we can succeed with the current table
                // We use the same logic as above, except we now have full
                // control of the table, so no need for interlocked operations
                //

                pBucket = &HASH_BUCKET_FROM_HANDLE (HContext->Handle, hash);
                if (*pBucket==NULL) {
                    oldContext = HContext;
                    *pBucket = HContext;
                    break;
                }
                else if ((*pBucket)->Handle==HContext->Handle) {
                    oldContext = *pBucket;
                    *pBucket = HContext;
                    break;
                }


                //
                // We in fact have to resort to table expansion
                // Remember the table size to know where to start
                //
                newNumHashBuckets = hash->NumBuckets;
            }
            else {
                //
                // Table was in fact empty, we 'll have to build one
                //
                newNumHashBuckets = 0;
            }

			//
			// Actual table expansion loop
			//
		TryAgain:

            //
            // Find the next prime number.
            //
            for (i = 0; newNumHashBuckets>=SockPrimes[i]; i++)
                ;

            if (SockPrimes[i]!=0xFFFFFFFF) {
                newNumHashBuckets = SockPrimes[i];
            }
            else {
                //
                // Reached the end of precomputed primes, simply
                // double the size of the table (we are getting
                // real big now, any mapping should do).
                //
                newNumHashBuckets *= 2;
            }


            newHashTable = (LPCTX_HASH_TABLE) ALLOC_MEM(
                        FIELD_OFFSET (
                                CTX_HASH_TABLE,
                                Buckets[newNumHashBuckets])
                        );
            if (newHashTable!=NULL) {
                newHashTable->NumBuckets = newNumHashBuckets;

                ZeroMemory(
                    newHashTable->Buckets,
                    newNumHashBuckets * sizeof (newHashTable->Buckets[0])
                );

                //
                // Well, first insert the new object, that's why we are
                // there in the first place.
                //

                HASH_BUCKET_FROM_HANDLE(HContext->Handle, newHashTable) = HContext;

                if (hash!=NULL) {
                    //
                    // The previous table wasn't empty, we need to
                    // move all the entries.  Note that we have
                    // already freezed all the table modifications
                    // above.
                    //

                    for (i=0 ; i<hash->NumBuckets; i++) {

                        if (hash->Buckets[i] != NULL) {

                            pBucket = &HASH_BUCKET_FROM_HANDLE(
                                hash->Buckets[i]->Handle,
                                newHashTable
                                );

                            if (*pBucket == NULL) {

                                *pBucket = hash->Buckets[i];

                            } else {
                                ASSERT ((*pBucket)->Handle!=hash->Buckets[i]->Handle);
                                FREE_MEM (newHashTable);

                                //
                                // Collision *after* we expanded, goto next size table
                                //
                                goto TryAgain;
                            }
                        }
                    }
                    //
                    // Table was successfully moved, safe to destroy
                    // the old one except we need to wait while no-one
                    // is accessing it.
                    //
                    table->HashTable = newHashTable;
                    WaitForAllReaders (table);
                    FREE_MEM( hash );
                }
                else {
                    //
                    // That's our hash table now.
                    //
                    table->HashTable = newHashTable;
                }
                oldContext = HContext;
            }
            else {

                oldContext = NULL;
            }
        }
        while (0);

        //
        // Set or restore the hash table before releasing the lock
        //
#ifdef _RW_LOCK_
        table->ExpansionInProgress = FALSE;
#endif //_RW_LOCK_
		ReleaseTableWriterLock(table);
        break;
	}
	while (1);

    return oldContext;
}

WS2HELPAPI
DWORD
WINAPI
WahRemoveHandleContext(
    LPCONTEXT_TABLE     Table,
    LPWSHANDLE_CONTEXT  HContext
    )
/*++

Routine Description:

    Removes context for the handle from the table

Arguments:

    Table   -   Supplies pointer to the table from which to remove

    HContext -  Supplies handle context to insert which contains
                handle value and internally\externally used
                reference count


Return Value:

    NO_ERROR - success, ERROR_INVALID_PARAMETER context did not exist
    in the table
--*/
{
    LPWSHANDLE_CONTEXT  *pBucket;
    LPCTX_LOOKUP_TABLE  table = TABLE_FROM_HANDLE(HContext->Handle,Table);
    LPCTX_HASH_TABLE    hash;
    DWORD               rc = NO_ERROR;

//  Valid table pointer required anyway.
//    return_code = ENTER_WS2HELP_API ();
//    if (return_code!=0)
//        return return_code;

    AcquireTableWriterLock(table);
    hash = table->HashTable;
    pBucket = &HASH_BUCKET_FROM_HANDLE(HContext->Handle,hash);
    if ((hash!=NULL)
            // Use interlocked operation to make sure we won't remove
            // another context.
            && (InterlockedCompareExchangePointer (
                        (PVOID *)pBucket,
                        NULL,
                        HContext)==HContext)) {
            // Wait for all who might be trying to access this block,
            // so that the caller can free it.
        WaitForAllReaders (table);
    }
    else {
        rc = ERROR_INVALID_PARAMETER;
    }
    ReleaseTableWriterLock(table);
    return rc;
}


WS2HELPAPI
BOOL
WINAPI
WahEnumerateHandleContexts(
    LPCONTEXT_TABLE         Table,
    LPFN_CONTEXT_ENUMERATOR Enumerator,
    LPVOID                  EnumCtx
    ) 
/*++

Routine Description:

    Calls specified enumeration procedure for all contexts in the table
    untill enumeration function returns FALSE.
    While enumeration is performed the table is completely locked
    for any modifications (read access is still allowed).  It is OK to
    call table modification procedures from inside the enumeration
    function (modification lock allows for recursion).

Arguments:

    Table   -   Supplies pointer to the table to enumerate

    Enumerator  - pointer to enumeration function defined as follows:
        typedef 
            BOOL  
            (WINAPI * LPFN_CONTEXT_ENUMERATOR)(
                LPVOID              EnumCtx,    // Enumeration context
                LPWSHANDLE_CONTEXT  HContext    // Handle context
                );

    EnumCtx - context to pass to enumeration function

Return Value:

    Returns result returned by the enumeration function

--*/
{
    ULONG               i,j;
    LPWSHANDLE_CONTEXT  hContext;
    BOOL                res = TRUE;


//  Valid table pointer required anyway.
//    return_code = ENTER_WS2HELP_API ();
//    if (return_code!=0)
//        return return_code;

    for (i = 0; i <= Table->HandleToIndexMask; i++)
    {
        LPCTX_LOOKUP_TABLE  table = &Table->Tables[i];
        LPCTX_HASH_TABLE    hash;


        AcquireTableWriterLock(table);
#ifdef _RW_LOCK_
        table->ExpansionInProgress = TRUE;
#endif //_RW_LOCK_
        WaitForAllReaders (table);
        hash = table->HashTable;

        if (hash!=NULL) {
            for (j=0; j<hash->NumBuckets; j++) {
                hContext = hash->Buckets[j];
                if (hContext==NULL)
                    continue;

                res = Enumerator (EnumCtx, hContext);
                if (!res)
                    break;
            }
        }
#ifdef _RW_LOCK_
        table->ExpansionInProgress = FALSE;
#endif //_RW_LOCK_
		ReleaseTableWriterLock(table);
        if (!res)
            break;
    }
    return res;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\ws2help\nt\whcperf.c ===
#include "precomp.h"
#include "newctx.h"
#include <stdlib.h>

LPCONTEXT_TABLE     gContextTable = NULL;
LPWSHANDLE_CONTEXT  gHandleContexts = NULL;
UINT                gNumHandles = 0;
UINT                gWRratio = 0;
LONG                gInserts = 0;
LONG                gInsertTime = 0;
LONG                gRemoves = 0;
LONG                gRemoveTime = 0;
LONG                gLookups = 0;
LONG                gLookupTime = 0;
DWORD				gNumProcessors;
LONG                gInteropSpins;

HANDLE              gSemaphore, gEvent;
volatile BOOL       gRun;
LONG                gNumThreads;

DWORD
StressThread (
    PVOID   param
    );


#define USAGE(x)    \
    "Usage:\n"\
    "   %s <num_threads> <num_handles> <write_access_%%> <time_to_run> <spins\n"\
    "   where\n"\
    "       <num_threads>   - number of threads (1-64);\n"\
    "       <num_handles>   - number of handles;\n"\
    "       <write_access_%%>  - percentage of write accesses (0-100);\n"\
    "       <time_to_run>   - time to run in sec;\n"\
    "       <spins>          - number of spins between operations.\n"\
    ,x


int _cdecl
main (
    int argc,
    CHAR **argv
    )
{
    LONG    TimeToRun, RunTime;
    HANDLE  Threads[MAXIMUM_WAIT_OBJECTS];
    DWORD   id, rc;
    UINT    err, i;
    UINT    numThreads;
    ULONG   rnd = NtGetTickCount ();
    ULONG   resolution;
    NTSTATUS status;
    LPWSHANDLE_CONTEXT  ctx;
	SYSTEM_INFO	info;

    if (argc<6) {
        printf (USAGE(argv[0]));
        return 1;
    }

	GetSystemInfo (&info);
	gNumProcessors = info.dwNumberOfProcessors;

    gNumThreads = atoi(argv[1]);
    if ((gNumThreads==0)||(gNumThreads>MAXIMUM_WAIT_OBJECTS)) {
        printf (USAGE(argv[0]));
        return 1;
    }

    gNumHandles = atoi(argv[2]);
    if (gNumHandles==0) {
        printf (USAGE(argv[0]));
        return 1;
    }


    gWRratio = atoi(argv[3]);
    if (gWRratio>100) {
        printf (USAGE(argv[0]));
        return 1;
    }

    TimeToRun = atoi(argv[4]);
    if (TimeToRun==0) {
        printf (USAGE(argv[0]));
        return 1;
    }

    gInteropSpins = atoi(argv[5]);

    gSemaphore = CreateSemaphore (NULL, 0, gNumThreads, NULL);
    if (gSemaphore==NULL) {
        printf ("Failed to create semaphore, err: %ld.\n", GetLastError ());
        return 1;
    }

    gEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
    if (gEvent==NULL) {
        printf ("Failed to create event, err: %ld.\n", GetLastError ());
        return 1;
    }

    //
    // Set timer resolution to 0.5 msec.
    //
    status = NtSetTimerResolution (5000, TRUE, &resolution);
    if (!NT_SUCCESS (status)) {
        printf ("Failed to set timer resolution, status: %lx\n", status);
        return 1;
    }
    printf ("Timer resolution is set @ %ld usec\n", resolution/10);


    err = WahCreateHandleContextTable (&gContextTable);
    if (err!=NO_ERROR) {
        printf ("Failed to create context table, err: %ld.\n", err);
        return 1;
    }

    gHandleContexts = (LPWSHANDLE_CONTEXT)
                            GlobalAlloc (
                                    GPTR,
                                    sizeof (WSHANDLE_CONTEXT)*gNumHandles
                                    );
    if (gHandleContexts==NULL) {
        printf ("Failed to allocate table of handle contexts, gle: %ld.\n",
                            GetLastError ());
        return 1;
    }

    for (i=0, ctx=gHandleContexts; i<gNumHandles; ) {

        ctx->RefCount = 1;
        do {
            ctx->Handle = (HANDLE)((((ULONGLONG)RtlRandom (&rnd)*(ULONGLONG)gNumHandles*(ULONGLONG)20)
                                        /((ULONGLONG)MAXLONG))
                                    &(~((ULONGLONG)3)));
        }
        while (WahReferenceContextByHandle (gContextTable, ctx->Handle)!=NULL);

        if (WahInsertHandleContext (gContextTable, ctx)!=ctx) {
            printf ("Failed to insert handle %p into the table.\n", ctx->Handle);
            return 1;
        }
        if ((i%128)==0) printf ("Handles created: %8.8ld\r", i);
        i++; ctx++;
    }
    printf ("Handles created: %8.8ld\n", i);

	if (!SetPriorityClass (GetCurrentProcess (), HIGH_PRIORITY_CLASS)) {
		printf ("Failed to set high priority class for the process, err: %ld.\n",
						GetLastError ());
		return 1;
	}

    numThreads = gNumThreads;
    for (i=0; i<numThreads; i++) {
        Threads[i] = CreateThread (NULL,
                                0,
                                StressThread,
                                (PVOID)i,
                                0,
                                &id
                                );
        if (Threads[i]==NULL) {
            printf ("Failed to create thread %ld, gle: %ld.\n",
                        i, GetLastError ());
            return 1;
        }
    }

    while (numThreads>0) {
        rc = WaitForSingleObject (gSemaphore, INFINITE);
        if (rc!=WAIT_OBJECT_0) {
            printf ("Failed wait for semaphore, res: %ld, err: %ld.\n", rc, GetLastError ());
            return 1;
        }
        numThreads -= 1;
        printf ("Threads to start: %8.8ld\r", numThreads);
    }
    printf ("\n");
    printf ("Starting...\n");
    RunTime = NtGetTickCount ();
    gRun = TRUE;
    rc = SignalObjectAndWait (gEvent, gSemaphore, TimeToRun*1000, FALSE);
    if (rc!=WAIT_TIMEOUT) {
        printf ("Wait for non-signaled semaphore returned: %ld, err: %ld.\n", rc, GetLastError ());
        return 1;
    }
    RunTime = NtGetTickCount()-RunTime;
    gRun = FALSE;
    
    printf ("Done, waiting for %ld threads to terminate...\n", gNumThreads);

    rc = WaitForMultipleObjects (gNumThreads, Threads, TRUE, INFINITE);


    printf ("Number of inserts    : %8.8lu.\n", gInserts);
    printf ("Inserts per ms       : %8.8lu.\n", gInserts/gInsertTime);
    printf ("Number of removes    : %8.8lu.\n", gRemoves);
    printf ("Removes per ms       : %8.8lu.\n", gRemoves/gRemoveTime);
    printf ("Number of lookups    : %8.8lu.\n", gLookups);
    printf ("Lookups per ms       : %8.8lu.\n", gLookups/gLookupTime);
    printf ("Running time         : %8.8lu.\n", RunTime);
    printf ("Total thread time    : %8.8lu.\n", gInsertTime+gRemoveTime+gLookupTime);
#ifdef _PERF_DEBUG_
    {
        LONG    ContentionCount = 0;
#ifdef _RW_LOCK_
        LONG    WriterWaits = 0;
        LONG    FailedSpins = 0;
        LONG    FailedSwitches = 0;
        LONG    CompletedWaits = 0;
#endif

        for ( i = 0; i <= gContextTable->HandleToIndexMask; i++ ) {

#ifdef _RW_LOCK_
            WriterWaits += gContextTable->Tables[i].WriterWaits;
            FailedSpins += gContextTable->Tables[i].FailedSpins;
            FailedSwitches += gContextTable->Tables[i].FailedSwitches;
            CompletedWaits += gContextTable->Tables[i].CompletedWaits;
#endif
            if (gContextTable->Tables[i].WriterLock.DebugInfo!=NULL)
                ContentionCount += gContextTable->Tables[i].WriterLock.DebugInfo->ContentionCount;
        }

#ifdef _RW_LOCK_
        printf ("Writer waits: %ld\n", WriterWaits);
        printf ("Failed spins: %ld\n", FailedSpins);
        printf ("Failed switches: %ld\n", FailedSwitches);
        printf ("Completed waits: %ld\n", CompletedWaits);
#endif
        printf ("Contention count: %ld\n", ContentionCount);
    }
#endif
	WahDestroyHandleContextTable (gContextTable);
    return 0;
}


DWORD
StressThread (
    PVOID   param
    )
{
    ULONG               idx;
    ULONG               rnd = NtGetTickCount ();
    LPWSHANDLE_CONTEXT  ctx;
    ULONG               RunTime;
	ULONGLONG			cTime, eTime, kTime1, kTime2, uTime1, uTime2;
	LONG                lInserts = 0, lInsertTime = 0;
	LONG                lRemoves = 0, lRemoveTime = 0;
	LONG                lLookups = 0, lLookupTime = 0;
    LONG                Spin;
    DWORD               rc;

	if (!SetThreadAffinityMask (GetCurrentThread (),
						1<<(PtrToUlong(param)%gNumProcessors))) {
		printf ("Failed to set thread's %ld affinity mask, err: %ld.\n",
					PtrToUlong(param), GetLastError ());
		ExitProcess (1);
	}

    rc = SignalObjectAndWait (gSemaphore, gEvent, INFINITE, FALSE);
    if (rc!=WAIT_OBJECT_0) {
        printf ("Wait for start event in thread %ld returned: %ld, err: %ld\n",
                         PtrToUlong(param), rc, GetLastError ());
        ExitProcess (1);
    }
	GetThreadTimes (GetCurrentThread (), (LPFILETIME)&cTime,
											(LPFILETIME)&eTime,
											(LPFILETIME)&kTime1,
											(LPFILETIME)&uTime1);
    RunTime = NtGetTickCount ();

    while (gRun) {
        idx = (ULONG)(((ULONGLONG)RtlRandom (&rnd)*(ULONGLONG)gNumHandles)/(ULONGLONG)MAXLONG);
        ctx = &gHandleContexts[idx];
        if ( (ULONG)(((ULONGLONG)rnd*(ULONGLONG)100)/(ULONGLONG)MAXLONG) < gWRratio) {
            lRemoveTime -= NtGetTickCount ();
            if (WahRemoveHandleContext (gContextTable, ctx)==NO_ERROR) {
                lRemoveTime += NtGetTickCount ();

                Spin = gInteropSpins;
                while (Spin--);

                ctx->RefCount = 1;
                lInsertTime -= NtGetTickCount ();
                WahInsertHandleContext (gContextTable, ctx);
                lInsertTime += NtGetTickCount ();
                lInserts += 1;
            }
            else {
                lRemoveTime += NtGetTickCount ();
            }
            lRemoves += 1;

        }
        else {
            lLookupTime -= NtGetTickCount ();
            WahReferenceContextByHandle (gContextTable, ctx->Handle);
            lLookupTime += NtGetTickCount ();
            lLookups += 1;
        }

        Spin = gInteropSpins;
        while (Spin--);
    }
	GetThreadTimes (GetCurrentThread (), (LPFILETIME)&cTime,
											(LPFILETIME)&eTime,
											(LPFILETIME)&kTime2,
											(LPFILETIME)&uTime2);
    //printf ("Thread %d ran for %lu ms, kernel mode: %lu, user mode: %lu.\n",
    //				param,
	//			NtGetTickCount ()-RunTime,
	//			(ULONG)((kTime2-kTime1)/(ULONGLONG)10000),
	//			(ULONG)((uTime2-uTime1)/(ULONGLONG)10000)
	//			);

	InterlockedExchangeAdd (&gInserts, lInserts);
	InterlockedExchangeAdd (&gInsertTime, lInsertTime);
	InterlockedExchangeAdd (&gRemoves, lRemoves);
	InterlockedExchangeAdd (&gRemoveTime, lRemoveTime);
	InterlockedExchangeAdd (&gLookups, lLookups);
	InterlockedExchangeAdd (&gLookupTime, lLookupTime);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\ws2help\nt\apc.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    apc.c

Abstract:

    This module implements the APC helper functions for the WinSock 2.0
    helper library.

Author:

    Keith Moore (keithmo)       20-Jun-1995

Revision History:

--*/


#include "precomp.h"


//
//  Private constants.
//

#define FAKE_HELPER_HANDLE  ((HANDLE)'MKC ')


//
//  Public functions.
//


DWORD
WINAPI
WahOpenApcHelper(
    OUT LPHANDLE HelperHandle
    )

/*++

Routine Description:

    This routine opens the WinSock 2.0 APC helper device.

Arguments:

    HelperHandle - Points to a HANDLE that will receive an open handle
        to the APC helper device.

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/

{
    DWORD   rc;

    rc = ENTER_WS2HELP_API ();
    if (rc!=0)
        return rc;

    //
    //  Validate parameters.
    //

    if( HelperHandle == NULL ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    //  Just return a fake handle.
    //

    *HelperHandle = FAKE_HELPER_HANDLE;

    return NO_ERROR;

}   // WahOpenApcHelper


DWORD
WINAPI
WahCloseApcHelper(
    IN HANDLE HelperHandle
    )

/*++

Routine Description:

    This function closes the WinSock 2.0 APC helper device.

Arguments:

    HelperHandle - The handle to close.

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/

{
    DWORD   rc;

    rc = ENTER_WS2HELP_API ();
    if (rc!=0)
        return rc;

    //
    //  Validate parameters.
    //

    if( HelperHandle != FAKE_HELPER_HANDLE ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    //  Nothing to do.
    //

    return NO_ERROR;

}   // WahCloseApcHelper


DWORD
WINAPI
WahOpenCurrentThread(
    IN  HANDLE HelperHandle,
    OUT LPWSATHREADID ThreadId
    )

/*++

Routine Description:

    This function opens a handle to the current thread.

Arguments:

    HelperHandle - An open handle to the APC helper device.

    ThreadId - Points to a WSATHREADID structure that will receive
        an open handle to the current thread and an (optional) OS-
        dependent thread identifier.

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/

{

    HANDLE currentProcess;
    HANDLE currentThread;
    DWORD  rc;


    rc = ENTER_WS2HELP_API ();
    if (rc!=0)
        return rc;

    //
    //  Validate parameters.
    //

    if( ( HelperHandle != FAKE_HELPER_HANDLE ) ||
        ( ThreadId == NULL ) ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    //  Grab the current process & thread handles.
    //

    currentProcess = GetCurrentProcess();
    currentThread = GetCurrentThread();

    //
    //  Duplicate the current thread pseudo handle.
    //

    if( DuplicateHandle(
            currentProcess,                         // hSourceProcessHandle
            currentThread,                          // hSourceHandle
            currentProcess,                         // hTargetProcessHandle
            &ThreadId->ThreadHandle,                // lpTargetHandle
            0,                                      // dwDesiredAttributes
            FALSE,                                  // bInheritHandle
            DUPLICATE_SAME_ACCESS                   // dwOptions
            ) ) {

        //
        //  The NT implementation of the APC helper does not really
        //  need the OS-dependent thread identifier, but we'll store
        //  the current thread ID in the structure just for completeness.
        //

        ThreadId->Reserved = GetCurrentThreadId ();

        return NO_ERROR;

    }

    return GetLastError();

}   // WahOpenCurrentThread


DWORD
WINAPI
WahCloseThread(
    IN HANDLE HelperHandle,
    IN LPWSATHREADID ThreadId
    )

/*++

Routine Description:

    This routine closes an open thread handle.

Arguments:

    HelperHandle - An open handle to the APC helper device.

    ThreadId - Points to a WSATHREADID structure initialized by a
        previous call to WahOpenCurrentThread().

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/

{

    DWORD  rc;


    rc = ENTER_WS2HELP_API ();
    if (rc!=0)
        return rc;

    //
    //  Validate parameters.
    //

    if( ( HelperHandle != FAKE_HELPER_HANDLE ) ||
        ( ThreadId == NULL ) ||
        ( ThreadId->ThreadHandle == NULL ) ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    //  Close the handle.
    //

    if( CloseHandle( ThreadId->ThreadHandle ) ) {

        //
        //  Clear the fields in case the client tries something.
        //

        ThreadId->ThreadHandle = NULL;
        ThreadId->Reserved = 0;

        return NO_ERROR;

    }

    return GetLastError();

}   // WahCloseThread


DWORD
WINAPI
WahQueueUserApc(
    IN HANDLE HelperHandle,
    IN LPWSATHREADID ThreadId,
    IN LPWSAUSERAPC ApcRoutine,
    IN ULONG_PTR ApcContext OPTIONAL
    )

/*++

Routine Description:

    This routine queues a user-mode APC for the specified thread.

Arguments:

    HelperHandle - An open handle to the APC helper device.

    ThreadId - Points to a WSATHREADID structure initialized by a
        previous call to WahOpenCurrentThread().

    ApcRoutine - Points to the APC code to execute when the specified
        thread enters an alertable wait.

    ApcContext - An uninterpreted context value to pass to the APC routine.

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/

{
    DWORD  rc;


    rc = ENTER_WS2HELP_API ();
    if (rc!=0)
        return rc;


    //
    //  Validate parameters.
    //

    if( ( HelperHandle != FAKE_HELPER_HANDLE ) ||
        ( ThreadId == NULL ) ||
        ( ThreadId->ThreadHandle == NULL ) ||
        ( ApcRoutine == NULL ) ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    //  Queue the APC.
    //

    if( QueueUserAPC(
            (PAPCFUNC)ApcRoutine,                   // pfnAPC
            ThreadId->ThreadHandle,                 // hThread
            ApcContext                              // dwData
            ) ) {

        //
        //  Success.
        //

        return NO_ERROR;

    }

    return GetLastError();

}   // WahQueueUserApc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\ws2help\nt\notify.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    notify.c

Abstract:

    This module implements the notification handle helper functions for the WinSock 2.0
    helper library.

Author:
    Vadim Eydelman (VadimE)


Revision History:

--*/
#include "precomp.h"
#include "osdef.h"
#include <accctrl.h>
#include <aclapi.h>

//
//  Private constants.
//
#define FAKE_NOTIFICATION_HELPER_HANDLE     ((HANDLE)'VD  ')
#define WS2_PIPE_BASE           L"\\Device\\NamedPipe\\"
#define WS2_PIPE_FORMAT         L"Winsock2\\CatalogChangeListener-%x-%x"
#define WS2_PIPE_WILDCARD       L"WINSOCK2\\CATALOGCHANGELISTENER-*-*"

/* Private Prototypes */
VOID
PipeListenApc (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );

DWORD
GetWinsockRootSecurityDescriptor (
    OUT PSECURITY_DESCRIPTOR    *pDescr
    );

DWORD
BuildPipeSecurityDescriptor (
    IN  PSECURITY_DESCRIPTOR    pBaseDescr,
    OUT PSECURITY_DESCRIPTOR    *pDescr
    );


// Current pipe number (to avoid unnecessary collisions during
// pipe creation)
LONG PipeSerialNumber = 0;

// Security descriptor that we use to grant write permissions to pipe
// to only those who have write permisions to registry key with
// winsock catalog
PSECURITY_DESCRIPTOR        pSDPipe = NULL;

#if DBG
VOID        DumpSid (PSID pSid, LPSTR AccessType);
#endif


DWORD
WINAPI
WahOpenNotificationHandleHelper(
    OUT LPHANDLE HelperHandle
    )
/*++

Routine Description:

    This routine opens WinSock 2.0 notification handle helper device

Arguments:

    HelperHandle - Points to buffer ion which to return handle.


Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/
{
    DWORD   rc;
    rc = ENTER_WS2HELP_API ();
    if (rc!=0)
        return rc;

    //
    //  Validate parameters.
    //

    if( HelperHandle == NULL ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    //  Just return a fake handle.
    //

    *HelperHandle = FAKE_NOTIFICATION_HELPER_HANDLE;

    return NO_ERROR;

}   // WahOpenNotificationHandleHelper

DWORD
WINAPI
WahCloseNotificationHandleHelper(
    IN HANDLE HelperHandle
    )

/*++

Routine Description:

    This function closes the WinSock 2.0 notification helper device.

Arguments:

    HelperHandle - The handle to close.

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/

{
    DWORD   rc;

    rc = ENTER_WS2HELP_API ();
    if (rc!=0)
        return rc;

    //
    //  Validate parameters.
    //

    if( HelperHandle != FAKE_NOTIFICATION_HELPER_HANDLE ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    //  Nothing to do.
    //

    return NO_ERROR;

}   // WahCloseNotificationHandleHelper

DWORD
WINAPI
WahCreateNotificationHandle(
    IN HANDLE           HelperHandle,
    OUT HANDLE          *h
    )
/*++

Routine Description:

    This function creates notificaion handle to receive asyncronous
    interprocess notifications.

Arguments:

    HelperHandle - The handle of WinSock 2.0 handle helper.
    h            - buffer to return created notification handle

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/
{
    WCHAR               name[MAX_PATH];
    UNICODE_STRING      uName;
    OBJECT_ATTRIBUTES   attr;
    DWORD               rc = 0;
    LARGE_INTEGER       readTimeout;
    IO_STATUS_BLOCK     ioStatusBlock;
    NTSTATUS            status;

    PSECURITY_DESCRIPTOR    pSDKey, pSDTemp;

    rc = ENTER_WS2HELP_API ();
    if (rc!=0)
        return rc;


    if (HelperHandle==NULL)
        return ERROR_INVALID_PARAMETER;
    else if ((HelperHandle!=FAKE_NOTIFICATION_HELPER_HANDLE)
            || (h==NULL))
        return ERROR_INVALID_PARAMETER;

    //
    // Build security descriptor for the pipe if we have not
    // already done this
    //

    if (pSDPipe==NULL) {
        //
        // First get security descriptor of the registry key that
        // contains the Winsock2 catalogs
        //
        rc = GetWinsockRootSecurityDescriptor (&pSDKey);
        if (rc==0) {
            //
            // Build the pipe security descriptor with grants
            // write permissions to same set of SIDs that have
            // write permissions to the registry key.
            //
            rc = BuildPipeSecurityDescriptor (pSDKey, &pSDTemp);
            if (rc==0) {
                //
                // Set the global if someone hasn't done this
                // while we were building it
                //
                if (InterlockedCompareExchangePointer (&pSDPipe,
                                            pSDTemp,
                                            NULL
                                            )!=NULL)
                    //
                    // Someone else did this, free ours
                    //
                    FREE_MEM (pSDTemp);
            }
            //
            // Free registry key descriptor
            //
            FREE_MEM (pSDKey);
        }
    }

    if (rc==0) {

        //
        // We use default timeout on our pipe (we do not actually
        // care what it is)
        //
        readTimeout.QuadPart =  -10 * 1000 * 50;

        do {
            //
            // Try to build unique pipe name using serial number
            //
            swprintf (name, WS2_PIPE_BASE WS2_PIPE_FORMAT,
                            GetCurrentProcessId(), PipeSerialNumber);
            InterlockedIncrement (&PipeSerialNumber);
            RtlInitUnicodeString( &uName, name );
            InitializeObjectAttributes (
                        &attr,
                        &uName,
                        OBJ_CASE_INSENSITIVE,
                        NULL,
                        pSDPipe);

            //
            // Try to create it
            //

            status = NtCreateNamedPipeFile (
                        h,                              // Handle
                        GENERIC_READ                    // DesiredAccess
                            | SYNCHRONIZE
                            | WRITE_DAC,
                        &attr,                          // Obja
                        &ioStatusBlock,                 // IoStatusBlock
                        FILE_SHARE_WRITE,               // Share access
                        FILE_CREATE,                    // CreateDisposition
                        0,                              // CreateFlags
                        FILE_PIPE_MESSAGE_TYPE,         // NamedPipeType
                        FILE_PIPE_MESSAGE_MODE,         // ReadMode
                        FILE_PIPE_QUEUE_OPERATION,      // CompletionMode
                        1,                              // MaxInstances
                        4,                              // InboundQuota
                        0,                              // OutboundQuota
                        &readTimeout                    // Timeout
                        );
            //
            // Continue on doing this if we have name collision
            // (serial number wrapped!!! or someone attempts to
            // interfere with out operation by using the same
            // naming scheme!!!)
            //
        }
        while (status==STATUS_OBJECT_NAME_COLLISION);

        if (NT_SUCCESS (status)) {
            WshPrint (DBG_NOTIFY,
                ("WS2HELP-%lx WahCreateNotificationHandle: Created pipe %ls.\n",
                PID, name));
            rc = 0;
        }
        else {
            WshPrint (DBG_NOTIFY|DBG_FAILURES,
                ("WS2HELP-%lx WahCreateNotificationHandle: Could not create pipe %ls, status: %lx\n",
                PID, name, status));
            rc = RtlNtStatusToDosError (status);
        }
    }

    return rc;
}


DWORD
WINAPI
WahWaitForNotification(
    IN HANDLE           HelperHandle,
    IN HANDLE           h,
    IN LPWSAOVERLAPPED  lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
/*++

Routine Description:

    This function waits for asyncronous interprocess notifications
    received on the pipe.

Arguments:

    HelperHandle - The handle of WinSock 2.0 handle helper.
    h            - notification handle
    lpOverlapped - overlapped structure for async IO
    lpCompletionRoutine - completion routine for async IO

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/
{
    DWORD           rc;
    NTSTATUS        status;
    IO_STATUS_BLOCK localIoStatus;

    HANDLE          event;
    PIO_APC_ROUTINE apcRoutine;
    PVOID           apcContext;
    PIO_STATUS_BLOCK ioStatus;

    rc = ENTER_WS2HELP_API ();
    if (rc!=0)
        return rc;

    if (HelperHandle==NULL)
        return ERROR_INVALID_PARAMETER;
    else if (HelperHandle!=FAKE_NOTIFICATION_HELPER_HANDLE)
        return ERROR_INVALID_PARAMETER;


    //
    // Disconnect previous client if any.
    // (If none were connected, the call fails, but
    // we ignore the error anyway).
    //
    status = NtFsControlFile(
                        h,
                        NULL,
                        NULL,   // ApcRoutine
                        NULL,   // ApcContext
                        &localIoStatus,
                        FSCTL_PIPE_DISCONNECT,
                        NULL,   // InputBuffer
                        0,      // InputBufferLength,
                        NULL,   // OutputBuffer
                        0       // OutputBufferLength
                        );

    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject( h, FALSE, NULL );
    }

    if (lpOverlapped) {
        //
        // Initialize for GetOverlappedResult to work
        //
        lpOverlapped->Internal = (DWORD)STATUS_PENDING;
        if (lpCompletionRoutine) {
            //
            // Async IO with completion routine
            //
            event = NULL;
            apcRoutine = PipeListenApc;
            apcContext = lpCompletionRoutine;
        }
        else {
            //
            // Event based or completion port async IO
            // 1 in low-order bit means they want to bypass completion
            // port
            //
            event = lpOverlapped->hEvent;
            apcRoutine = NULL;
            apcContext = ((ULONG_PTR)lpOverlapped->hEvent & 1) ? NULL : lpOverlapped;
        }
        //
        // Async IO, use overlapped for IoStatus and read buffer
        //
        ioStatus = (PIO_STATUS_BLOCK)lpOverlapped;
    }
    else {
        //
        // Synchronous IO, use locals for IoStatus and read buffer
        //
        ioStatus = &localIoStatus;
        ioStatus->Status = STATUS_PENDING;
        apcRoutine = NULL;
        apcContext = NULL;
        event = NULL;
    }

    //
    // Listen for new client
    //
    status = NtFsControlFile (
                    h,                  // Filehandle
                    event,              // Event
                    apcRoutine,         // ApcRoutine
                    apcContext,         // ApcContext
                    ioStatus,           // IoStatusBlock
                    FSCTL_PIPE_LISTEN,  // IoControlCode
                    NULL,               // InputBuffer
                    0,                  // InputBufferLength
                    NULL,               // OutputBuffer
                    0                   // OutputBufferLength
                    );

    if ((lpOverlapped==NULL) && (status==STATUS_PENDING)) {
        //
        // Wait for completion if IO was synchronous and
        // NtFsControlFile returned pending
        //
        status = NtWaitForSingleObject( h, FALSE, NULL );
        if (NT_SUCCESS (status)) {
            status = ioStatus->Status;
        }
        else {
            WshPrint (DBG_NOTIFY|DBG_FAILURES,
                ("WS2HELP-%lx WahWaitForNotification:"
                " Wait failed, status: %lx\n",
                PID, status));
        }
    }

    // Convert status code
    if (status==STATUS_SUCCESS)
        rc = 0;
    else if (status==STATUS_PENDING) {
        rc = WSA_IO_PENDING;
    }
    else {
        WshPrint (DBG_NOTIFY|DBG_FAILURES,
            ("WS2HELP-%lx WahWaitForNotification:"
            " Wait failed, status: %lx\n",
            PID, status));
        rc = RtlNtStatusToDosError (status);
    }
    return rc;
}

DWORD
WahNotifyAllProcesses (
    IN HANDLE           HelperHandle
    ) {
/*++

Routine Description:

    This function notifies all the processes that listen for
    notifications

Arguments:

    HelperHandle - The handle of WinSock 2.0 handle helper.

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/
    HANDLE          hDir, hPipe;
    struct {
        FILE_NAMES_INFORMATION  Info;
        WCHAR                   FileName[255];
    }               NameInfo;
    IO_STATUS_BLOCK ioStatusBlock;
    UNICODE_STRING  NameFormat;
    PUNICODE_STRING pNameFormat;
    NTSTATUS        status;
    UNICODE_STRING  PipeRootName;
    OBJECT_ATTRIBUTES PipeRootAttr;
    DWORD           id = GetCurrentProcessId ();
    WCHAR           name[MAX_PATH];
    UNICODE_STRING  uName;
    OBJECT_ATTRIBUTES attr;
    DWORD           rc;

    rc = ENTER_WS2HELP_API ();
    if (rc!=0)
        return rc;

    if (HelperHandle==NULL)
        return ERROR_INVALID_PARAMETER;
    else if (HelperHandle!=FAKE_NOTIFICATION_HELPER_HANDLE)
        return ERROR_INVALID_PARAMETER;

    //
    // Open handle to pipe root directory
    //
    RtlInitUnicodeString( &PipeRootName, WS2_PIPE_BASE );
    InitializeObjectAttributes(
        &PipeRootAttr,
        &PipeRootName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtOpenFile (
              &hDir,                                // FileHandle
              FILE_LIST_DIRECTORY | SYNCHRONIZE,    // DesiredAccess
              &PipeRootAttr,                        // ObjectAttributes
              &ioStatusBlock,                       // IoStatusBlock
              FILE_SHARE_READ|FILE_SHARE_WRITE,     // ShareAccess
              FILE_DIRECTORY_FILE                   // OpenOptions
                | FILE_SYNCHRONOUS_IO_NONALERT
                | FILE_OPEN_FOR_BACKUP_INTENT);

    if (NT_SUCCESS(status)) {
        //
        // Enumerate all pipes that match our pattern
        //
        RtlInitUnicodeString( &NameFormat, WS2_PIPE_WILDCARD );
        pNameFormat = &NameFormat;
        while ((status=NtQueryDirectoryFile (
                            hDir,                       // File Handle
                            NULL,                       // Event
                            NULL,                       // Apc routine
                            NULL,                       // Apc context
                            &ioStatusBlock,             // IoStatusBlock
                            &NameInfo,                  // FileInformation
                            sizeof(NameInfo),           // Length
                            FileNamesInformation,       // FileInformationClass
                            TRUE,                       // ReturnSingleEntry
                            pNameFormat,                // FileName
                            (BOOLEAN)(pNameFormat!=NULL)// RestartScan
                            ))==STATUS_SUCCESS) {

            pNameFormat = NULL; // No need for pattern on second
                                // and all successive enum calls

            //
            // Create client and of the pipe that matched the
            // pattern
            //
            NameInfo.Info.FileName[
                NameInfo.Info.FileNameLength
                    /sizeof(NameInfo.Info.FileName[0])] = 0;

            swprintf (name, WS2_PIPE_BASE L"%ls",
                        NameInfo.Info.FileName);

            RtlInitUnicodeString( &uName, name );
            InitializeObjectAttributes(
                &attr,
                &uName,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL
                );
            status = NtCreateFile (
                            &hPipe,
                            GENERIC_WRITE | SYNCHRONIZE,
                            &attr,
                            &ioStatusBlock,
                            NULL,
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_READ,
                            OPEN_EXISTING,
                            0,
                            NULL,
                            0);
            if (NT_SUCCESS (status)) {
                WshPrint (DBG_NOTIFY,
                    ("WS2HELP-%lx WahNotifyAllProcesses:"
                    " Opened pipe %ls.\n",
                    PID, name));
                NtClose (hPipe);
            }
#if DBG
            else if (status==STATUS_PIPE_NOT_AVAILABLE) {
                WshPrint (DBG_NOTIFY,
                    ("WS2HELP-%lx WahNotifyAllProcesses:"
                    " Pipe %ls is not currently listening.\n",
                    PID, name));
            }
            else {
                WshPrint (DBG_NOTIFY|DBG_FAILURES,
                    ("WS2HELP-%lx WahNotifyAllProcesses:"
                    " Could not open pipe %ls, status: %lx\n",
                    PID, name, status));
            }
#endif
        }
        if (status!=STATUS_NO_MORE_FILES) {
            //
            // Some other failure, means we could not even
            // enumerate
            //
            WshPrint (DBG_NOTIFY|DBG_FAILURES,
                ("WS2HELP-%lx WahNotifyAllProcesses:"
                " Could enumerate pipes, status: %lx\n",
                PID, status));
        }
        NtClose (hDir);
    }
    else {
        WshPrint (DBG_NOTIFY|DBG_FAILURES,
            ("WS2HELP-%lx WahNotifyAllProcesses:"
            " Could open pipe root, status: %lx\n",
            PID, status));
    }

    return 0;
}

// Private functions

VOID
PipeListenApc (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    )
/*++

Routine Description:

    This NT IO APC that converts parameters and calls client APC.

Arguments:

    ApcContext  -   apc context - pointer to client APC

    IoStatusBlock - io status block - part of client's overlapped structure

    Reserved    -   reserved


Return Value:

    None


--*/
{
    DWORD   rc;
    switch (IoStatusBlock->Status) {
    case STATUS_SUCCESS:
        rc = 0;
        break;
    case STATUS_CANCELLED:
        rc = WSA_OPERATION_ABORTED;
        break;
    default:
        rc = WSASYSCALLFAILURE;
        WshPrint (DBG_NOTIFY|DBG_FAILURES,
            ("WS2HELP-%lx PipeListenApc:"
            " Failed, status: %lx\n",
            PID, IoStatusBlock->Status));
        break;

    }
    (*(LPWSAOVERLAPPED_COMPLETION_ROUTINE)ApcContext)
            (rc, 0, (LPWSAOVERLAPPED)IoStatusBlock, 0);
}


DWORD
GetWinsockRootSecurityDescriptor (
    PSECURITY_DESCRIPTOR    *pDescr
    )
/*++

Routine Description:

    Reads security descriptor of the registry key that contains
    Winsock2 catalogs

Arguments:

    pDescr  - buffer to receive locally allocated pointer to descriptor
Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/
{
    HKEY                hKey;
    DWORD               sz;
    DWORD               rc;

    //
    // Open the key
    //
    rc = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                    WINSOCK_REGISTRY_ROOT,
                    0,
                    KEY_READ|READ_CONTROL,
                    &hKey
                    );
    if (rc==0) {
        //
        // Get the required buffer size
        //
        sz = 0;
        rc = RegGetKeySecurity (hKey,
                         DACL_SECURITY_INFORMATION, // we only need
                                                    // DACL to see
                                                    // who has write
                                                    // permissions to
                                                    // the key
                         NULL,
                         &sz);
        if (rc==ERROR_INSUFFICIENT_BUFFER) {
            PSECURITY_DESCRIPTOR descr;
            //
            // Allocate buffer
            //
            descr = (PSECURITY_DESCRIPTOR)ALLOC_MEM (sz);
            if (descr!=NULL) {
                //
                // Fetch the data
                //
                rc = RegGetKeySecurity (hKey,
                                 DACL_SECURITY_INFORMATION,
                                 descr,
                                 &sz);
                if (rc==0) {
                    *pDescr = descr;
                }
                else {
                    WshPrint (DBG_NOTIFY|DBG_FAILURES,
                        ("WS2HELP-%lx GetWinsockRootExplicitAccess:"
                        " Failed to get key security (data), err: %ld\n",
                        PID, rc));
                    FREE_MEM (descr);
                }
            }
            else {
                rc = GetLastError ();
                WshPrint (DBG_NOTIFY|DBG_FAILURES,
                    ("WS2HELP-%lx GetWinsockRootExplicitAccess:"
                    " Failed to allocate security descriptor, err: %ld\n",
                    PID, rc));
                if (rc==0)
                    rc = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else {
            WshPrint (DBG_NOTIFY|DBG_FAILURES,
                ("WS2HELP-%lx GetWinsockRootExplicitAccess:"
                " Failed to get key security (size), err: %ld\n",
                PID, rc));
        }
        //
        // Do not need key anymore
        //
        RegCloseKey (hKey);
    }
    else {
        WshPrint (DBG_NOTIFY|DBG_FAILURES,
            ("WS2HELP-%lx GetWinsockRootExplicitAccess:"
            " Failed to open winsock root key, err: %ld\n",
            PID, rc));
    }
    return rc;
}


DWORD
BuildPipeSecurityDescriptor (
    IN  PSECURITY_DESCRIPTOR    pBaseDescr,
    OUT PSECURITY_DESCRIPTOR    *pDescr
    )
/*++

Routine Description:

    Builds security descriptor with the same write permissions
    as in base descriptor (which is the descriptor of the
    registry key) minus network users

Arguments:

    pBaseDescr  - descriptor of the registry key from which to
                    read write permisions

    pDescr      - buffer to receive locally allocated pointer to descriptor

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/
{
    PACL                    pBaseDacl, pDacl;
    BOOL                    DaclPresent, DaclDefaulted;
    DWORD                   cbDacl;
    DWORD                   rc = 0;
    ACL_SIZE_INFORMATION    sizeInfo;
    ULONG                   i;
    ACE_HEADER              *pAce;
    SID_IDENTIFIER_AUTHORITY    siaNt = SECURITY_NT_AUTHORITY;
    PSID                    pSidNetUser;
    SID_IDENTIFIER_AUTHORITY    siaCreator = SECURITY_CREATOR_SID_AUTHORITY;
    PSID                    pSidCrOwner;
    PSID                    pSidCrGroup;


    *pDescr = NULL;

    //
    // Get DACL from the base descriptor
    //
    if (!GetSecurityDescriptorDacl (
                        pBaseDescr,
                        &DaclPresent,
                        &pBaseDacl,
                        &DaclDefaulted
                        )) {
        rc = GetLastError ();
        WshPrint (DBG_NOTIFY|DBG_FAILURES,
            ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
            " Failed to get DACL from base descriptor, err: %ld\n",
            PID, rc));
        if (rc==0)
            rc = ERROR_GEN_FAILURE;

        return rc;
    }

    //
    // Allocate SID for network users
    //

    if (!AllocateAndInitializeSid (&siaNt,
            1,
            SECURITY_NETWORK_RID,
            0,0,0,0,0,0,0,
            &pSidNetUser
            )) {
        rc = GetLastError ();
        WshPrint (DBG_NOTIFY|DBG_FAILURES,
            ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
            " Failed to allocate net user SID, err: %ld\n",
            PID, rc));
        if (rc==0)
            rc = ERROR_GEN_FAILURE;

        return rc;
    }

    //
    // Allocate SID for creator/owner
    //

    if (!AllocateAndInitializeSid (&siaCreator,
            1,
            SECURITY_CREATOR_OWNER_RID,
            0,0,0,0,0,0,0,
            &pSidCrOwner
            )) {
        rc = GetLastError ();
        WshPrint (DBG_NOTIFY|DBG_FAILURES,
            ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
            " Failed to allocate creator owner SID, err: %ld\n",
            PID, rc));
        if (rc==0)
            rc = ERROR_GEN_FAILURE;
        FreeSid (pSidNetUser);

        return rc;
    }

    //
    // Allocate SID for creator group
    //

    if (!AllocateAndInitializeSid (&siaCreator,
            1,
            SECURITY_CREATOR_GROUP_RID,
            0,0,0,0,0,0,0,
            &pSidCrGroup
            )) {
        rc = GetLastError ();
        WshPrint (DBG_NOTIFY|DBG_FAILURES,
            ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
            " Failed to allocate creator group SID, err: %ld\n",
            PID, rc));
        if (rc==0)
            rc = ERROR_GEN_FAILURE;
        FreeSid (pSidCrOwner);
        FreeSid (pSidNetUser);

        return rc;
    }

    //
    // Our DACL will at least contain an ACE that denies
    // access to all network users
    //
    cbDacl = sizeof (ACL)
                + FIELD_OFFSET (ACCESS_DENIED_ACE, SidStart)
                + GetLengthSid (pSidNetUser);


    //
    // If base DACL is present and non-NULL, we will need to
    // parse it, count all the accounts that have write permissions,
    // so we can allocate space in security descriptor to
    // hold them
    //
    if (DaclPresent && pBaseDacl!=NULL) {
        //
        // Get number of ACEs in the DACL
        //
        if (GetAclInformation (pBaseDacl,
                                &sizeInfo,
                                sizeof (sizeInfo),
                                AclSizeInformation
                                )) {
            //
            // Enumerate all ACEs to get the required size
            // of the DACL that we are about to build
            //
            for (i=0; i<sizeInfo.AceCount; i++) {
                if (GetAce (pBaseDacl, i, &pAce)) {
                    //
                    // Only count access-allowed or access-denied ACEs
                    // with write access to the key
                    //
                    switch (pAce->AceType) {
                    case ACCESS_ALLOWED_ACE_TYPE:
                        #define paAce ((ACCESS_ALLOWED_ACE  *)pAce)
                        if (((paAce->Mask & KEY_WRITE)==KEY_WRITE)
                                && !EqualSid (&paAce->SidStart, pSidCrOwner)
                                && !EqualSid (&paAce->SidStart, pSidCrGroup)
                                    ) {
                            cbDacl += FIELD_OFFSET (ACCESS_ALLOWED_ACE, SidStart)
                                        +  GetLengthSid (&paAce->SidStart);
                        }
                        #undef paAce
                        break;
                    case ACCESS_DENIED_ACE_TYPE:
                        #define pdAce ((ACCESS_DENIED_ACE  *)pAce)
                        if ((pdAce->Mask & KEY_WRITE)==KEY_WRITE) {
                            cbDacl += FIELD_OFFSET (ACCESS_DENIED_ACE, SidStart)
                                        +  GetLengthSid (&pdAce->SidStart);
                        }
                        #undef pdAce
                        break;
                    }

                }
                else {
                    rc = GetLastError ();
                    WshPrint (DBG_NOTIFY|DBG_FAILURES,
                        ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
                        " Failed to get ACE # %ld, err: %ld\n",
                        PID, i, rc));
                    if (rc==0)
                        rc = ERROR_GEN_FAILURE;
                    break;
                }
            } // for
        }
        else {
            rc = GetLastError ();
            WshPrint (DBG_NOTIFY|DBG_FAILURES,
                ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
                " Failed to get DACL size info, err: %ld\n",
                PID, rc));
            if (rc==0)
                rc = ERROR_GEN_FAILURE;
        }
    } // if DaclPresent and pDacl!=NULL
    else {
        //
        // Base DACL does not exist or empty
        //
        rc = 0;
    }


    if (rc==0) {
        //
        // Allocate memory for the descriptor and DACL
        //
        *pDescr = (PSECURITY_DESCRIPTOR)ALLOC_MEM
                        (sizeof (SECURITY_DESCRIPTOR)+cbDacl);
        if (*pDescr!=NULL) {
            pDacl = (PACL)((PUCHAR)(*pDescr)+sizeof(SECURITY_DESCRIPTOR));

            //
            // Initialize descriptor and DACL
            //

            if (InitializeSecurityDescriptor (*pDescr,
                            SECURITY_DESCRIPTOR_REVISION)
                   && InitializeAcl (pDacl, cbDacl, ACL_REVISION)) {

                //
                // First add access-denied ace for all
                // network users
                //

                if (AddAccessDeniedAce (pDacl,
                                        ACL_REVISION,
                                        GENERIC_WRITE
                                            |STANDARD_RIGHTS_WRITE
                                            |SYNCHRONIZE,
                                        pSidNetUser
                                        )) {
#if DBG
                    DumpSid (pSidNetUser, "Denying");
#endif

                    //
                    // If base DACL is present and non-NULL, we will need to
                    // parse it add all ACEs that have write permisions
                    // to the DACL we build
                    //
                    if (DaclPresent && (pBaseDacl!=NULL)) {
                        //
                        // Enumerate all ACEs and copy them
                        // to the new DACL
                        //
                        for (i=0; i<sizeInfo.AceCount; i++) {
                            if (GetAce (pBaseDacl, i, &pAce)) {
                                //
                                // Only count access-allowed or access-denied ACEs
                                // with write access to the key
                                //
                                switch (pAce->AceType) {
                                case ACCESS_ALLOWED_ACE_TYPE:
                                    #define paAce ((ACCESS_ALLOWED_ACE  *)pAce)
                                    if (((paAce->Mask & KEY_WRITE)==KEY_WRITE)
                                            && !EqualSid (&paAce->SidStart, pSidCrOwner)
                                            && !EqualSid (&paAce->SidStart, pSidCrGroup)
                                        ) {
                                        if (AddAccessAllowedAce (pDacl,
                                                ACL_REVISION,
                                                GENERIC_WRITE
                                                    | STANDARD_RIGHTS_WRITE
                                                    | SYNCHRONIZE
                                                    | FILE_READ_ATTRIBUTES,
                                                &paAce->SidStart
                                                )) {
#if DBG
                                            DumpSid (&paAce->SidStart, "Allowing");
#endif
                                        }
                                        else {
                                            rc = GetLastError ();
                                            WshPrint (DBG_NOTIFY|DBG_FAILURES,
                                                ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
                                                " Failed to add access allowed ACE # %ld, err: %ld\n",
                                                PID, i, rc));
                                            if (rc==0)
                                                rc = ERROR_GEN_FAILURE;
                                        }
                                    }
                                    #undef paAce
                                    break;
                                case ACCESS_DENIED_ACE_TYPE:
                                    #define pdAce ((ACCESS_DENIED_ACE  *)pAce)
                                    if ((pdAce->Mask & KEY_WRITE)==KEY_WRITE) {
                                        if (AddAccessDeniedAce (pDacl,
                                                ACL_REVISION,
                                                GENERIC_WRITE
                                                    | STANDARD_RIGHTS_WRITE
                                                    | SYNCHRONIZE,
                                                &pdAce->SidStart
                                                )) {
#if DBG
                                            DumpSid (&pdAce->SidStart, "Denying");
#endif
                                        }
                                        else {
                                            rc = GetLastError ();
                                            WshPrint (DBG_NOTIFY|DBG_FAILURES,
                                                ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
                                                " Failed to add access denied ACE # %ld, err: %ld\n",
                                                PID, i, rc));
                                            if (rc==0)
                                                rc = ERROR_GEN_FAILURE;
                                        }
                                    }
                                    #undef pdAce
                                    break;
                                }
                                if (rc!=0) {
                                    // Stop enumeration in case
                                    // of failure
                                    break;
                                }
                            }
                            else {
                                rc = GetLastError ();
                                WshPrint (DBG_NOTIFY|DBG_FAILURES,
                                    ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
                                    " Failed to re-get ACE # %ld, err: %ld\n",
                                    PID, i, rc));
                                if (rc==0)
                                    rc = ERROR_GEN_FAILURE;
                                break;
                            }
                        } // for
                    } // if (DaclPresent and pBaseDacl!=NULL)
                }
                else {
                    rc = GetLastError ();
                    WshPrint (DBG_NOTIFY|DBG_FAILURES,
                        ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
                        " Failed to add accees denied ace for net users %ld, err: %ld\n",
                        PID, rc));
                    if (rc==0)
                        rc = ERROR_GEN_FAILURE;
                }
            }
            else {
                rc = GetLastError ();
                WshPrint (DBG_NOTIFY|DBG_FAILURES,
                    ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
                    " Failed to initialize DACL, err: %ld\n",
                    PID, rc));
                if (rc==0)
                    rc = ERROR_GEN_FAILURE;
            }

            //
            // If we succeded in building of the
            // DACL, add it to the security descriptor
            //
            if (rc==0) {
                if (SetSecurityDescriptorDacl (
                                *pDescr,
                                TRUE,
                                pDacl,
                                FALSE
                                )) {
                    rc = 0;
                }
                else {
                    rc = GetLastError ();
                    WshPrint (DBG_NOTIFY|DBG_FAILURES,
                        ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
                        " Failed to set DACL, err: %ld\n",
                        PID, rc));
                    if (rc==0)
                        rc = ERROR_GEN_FAILURE;
                }
            } // if rc==0 (DACL is built)
            else {
                // Failed to build DACL, free memory for security descriptor
                FREE_MEM (*pDescr);
                *pDescr = NULL;
            }
        }
        else {
            rc = GetLastError ();
            WshPrint (DBG_NOTIFY|DBG_FAILURES,
                ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
                " Failed to allocate security descriptor, err: %ld\n",
                PID, rc));
                if (rc==0)
                    rc = ERROR_NOT_ENOUGH_MEMORY;
        }
    } // if rc==0 (Parsed base DACL ok)

    //
    // Free net user sid which we already copied to DACL in security
    // descriptor
    //
    FreeSid (pSidNetUser);
    FreeSid (pSidCrOwner);
    FreeSid (pSidCrGroup);

    return rc;
}

#if DBG
VOID
DumpSid (
    PSID    pSid,
    LPSTR   AccessType
    ) {
    TCHAR   Name[256];
    DWORD   szName = sizeof (Name);
    TCHAR   Domain[256];
    DWORD   szDomain = sizeof (Domain);
    SID_NAME_USE    nameUse;
    static HANDLE SAM_SERVICE_STARTED_EVENT = NULL;

    if (DbgLevel & DBG_NOTIFY) {
        if (SAM_SERVICE_STARTED_EVENT==NULL) {
            SAM_SERVICE_STARTED_EVENT = CreateEvent (NULL,
                                        FALSE,
                                        FALSE,
                                        TEXT("SAM_SERVICE_STARTED"));
            if (SAM_SERVICE_STARTED_EVENT!=NULL) {
                DWORD   rc;
                rc = WaitForSingleObject (SAM_SERVICE_STARTED_EVENT, 0);
                CloseHandle (SAM_SERVICE_STARTED_EVENT);
                if (rc!=WAIT_OBJECT_0) {
                    // Reset global so we try this again
                    SAM_SERVICE_STARTED_EVENT = NULL;
                    return;
                }
                // proceed without resetting global so we do not try again
                
            }
            else
                // Event must not have been created
                return;
        }

        if (LookupAccountSid (NULL,
                            pSid,
                            Name,
                            &szName,
                            Domain,
                            &szDomain,
                            &nameUse
                            )) {
            WshPrint (DBG_NOTIFY,
                ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
                " %s write permissions to %s\\%s (use:%d).\n",
                PID, AccessType, Domain, Name, nameUse));

        }
        else {
            DWORD   i, n;
            WshPrint (DBG_NOTIFY,
                ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
                " Could not lookup name for sid, err: %ld.\n",
                PID, GetLastError()));
            WshPrint (DBG_NOTIFY,
                ("WS2HELP-%lx, SID dump: S-%d-%d",
                PID, SID_REVISION, GetSidIdentifierAuthority(pSid)->Value[6]));
            n = *GetSidSubAuthorityCount(pSid);
            for (i=0; i<n; i++)
                WshPrint (DBG_NOTIFY, ("-%d", *GetSidSubAuthority (pSid, i)));
            WshPrint (DBG_NOTIFY, ("\n"));
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\ws2ifsl\debug.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    process.c

Abstract:

    This module implements debug support for ws2ifsl.sys driver.

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:

--*/

#include "precomp.h"
#if DBG
ULONG DbgLevel=DBG_FAILURES;

VOID
ReadDbgInfo (
    IN PUNICODE_STRING RegistryPath
    ) {
    PWSTR RegistryPathBuffer;
    PWSTR Parameters = L"Parameters";
    RTL_QUERY_REGISTRY_TABLE    paramTable[3]; // table size = nr of params + 2

    RegistryPathBuffer = (PWSTR)ExAllocatePool(NonPagedPool,
                                RegistryPath->Length + sizeof(WCHAR));

    if (RegistryPathBuffer == NULL) {
        return;
    }

    RtlCopyMemory (RegistryPathBuffer, RegistryPath->Buffer, RegistryPath->Length);
    *(PWCHAR)(((PUCHAR)RegistryPathBuffer)+RegistryPath->Length) = (WCHAR)'\0';

    RtlZeroMemory(&paramTable[0], sizeof(paramTable));

    paramTable[0].QueryRoutine = NULL;
    paramTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    paramTable[0].Name = Parameters;

    paramTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[1].Name = L"DbgLevel";
    paramTable[1].EntryContext = &DbgLevel;
    paramTable[1].DefaultType = REG_DWORD;
    paramTable[1].DefaultData = &DbgLevel;
    paramTable[1].DefaultLength = sizeof(ULONG);

    RtlQueryRegistryValues(
          RTL_REGISTRY_ABSOLUTE,
          RegistryPathBuffer,
          paramTable,
          NULL,
          NULL);

    ExFreePool(RegistryPathBuffer);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\ws2ifsl\dispatch.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dispatch.h

Abstract:

    This header contains the dispatch routine declarations
    for ws2ifsl.sys driver.

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:

--*/

NTSTATUS
DispatchCreate (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
	);

NTSTATUS
DispatchCleanup (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
	);

NTSTATUS
DispatchClose (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
	);

NTSTATUS
DispatchReadWrite (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
	);

NTSTATUS
DispatchDeviceControl (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
	);

BOOLEAN
FastIoDeviceControl (
	IN PFILE_OBJECT 		FileObject,
	IN BOOLEAN 			    Wait,
	IN PVOID 				InputBuffer	OPTIONAL,
	IN ULONG 				InputBufferLength,
	OUT PVOID 				OutputBuffer	OPTIONAL,
	IN ULONG 				OutputBufferLength,
	IN ULONG 				IoControlCode,
	OUT PIO_STATUS_BLOCK	IoStatus,
	IN PDEVICE_OBJECT 		DeviceObject
    );


NTSTATUS
DispatchPnP (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\ws2help\nt\wsht.c ===
#include "precomp.h"


#define USAGE(x)                        \
    "Usage:\n"\
    "   %s {s|c} name\n"\
    "   where\n"\
    "       s       -   run as the server (listen);\n"\
    "       c [machine pid number] -   run as the client (connect).\n"\
    ,x

HANDLE      hHelper;
OVERLAPPED  ovlp;

VOID WINAPI WsCompletion (
    DWORD           dwErrorCode,
    DWORD           dwNumberOfBytesTransfered,
    LPOVERLAPPED    lpOverlapped,
    DWORD           Flags
    );

int _cdecl
main (int argc, CHAR **argv) {
    DWORD   rc;
    BOOL    Server;

    if (argc<2) {
        printf (USAGE(argv[0]));
        return 0;
    }

    if (_stricmp (argv[1], "s")==0)
        Server = TRUE;
    else if (_stricmp (argv[1], "c")==0)
        Server = FALSE;
    else {
        printf ("Must specify s(erver) or c(lient).\n");
        printf (USAGE(argv[0]));
        return -1;
    }

    if ((rc=WahOpenNotificationHandleHelper (&hHelper))!=NO_ERROR) {
        printf ("WahOpenNotificationHandleHelper failed, err: %ld.\n", rc);
        return -1;
    }

    if (Server) {
        HANDLE  hSync, hApc, hAEvent, hAPort, hANoPort;
        OVERLAPPED  oApc, oEvent, oPort, oNoPort;
        LPOVERLAPPED lpo;
        HANDLE  hPort;
        HANDLE  hEvent;
        DWORD   count;
        ULONG_PTR key;

        hPort = CreateIoCompletionPort (
                    INVALID_HANDLE_VALUE,
                    NULL,
                    0,
                    0
                    );

        if (hPort==NULL) {
            printf ("CreateIoCompletionPort (create) failed, err: %ld.\n", GetLastError ());
            return -1;
        }

        hEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
        if (hEvent==NULL) {
            printf ("CreateEvent failed, err: %ld.\n", GetLastError ());
            return -1;
        }

        rc = WahCreateNotificationHandle (hHelper, &hSync);
        if (rc!=0) {
            printf ("WahCreateNotificationHandle failed, err: %ld.\n", rc);
            return -1;
        }

        rc = WahCreateNotificationHandle (hHelper, &hApc);
        if (rc!=0) {
            printf ("WahCreateNotificationHandle failed, err: %ld.\n", rc);
            return -1;
        }
        oApc.hEvent = NULL;

        rc = WahCreateNotificationHandle (hHelper, &hAEvent);
        if (rc!=0) {
            printf ("WahCreateNotificationHandle failed, err: %ld.\n", rc);
            return -1;
        }
        oEvent.hEvent = hEvent;

        rc = WahCreateNotificationHandle (hHelper, &hAPort);
        if (rc!=0) {
            printf ("WahCreateNotificationHandle failed, err: %ld.\n", rc);
            return -1;
        }
        if (CreateIoCompletionPort (hAPort, hPort, (ULONG_PTR)hAPort, 0)
               == INVALID_HANDLE_VALUE) {
            printf ("CreateIoCompletionPort (associate) failed, err: %ld.\n", GetLastError ());
            return -1;
        }
        oPort.hEvent = NULL;

        rc = WahCreateNotificationHandle (hHelper, &hANoPort);
        if (rc!=0) {
            printf ("WahCreateNotificationHandle failed, err: %ld.\n", rc);
            return -1;
        }
        if (CreateIoCompletionPort (hANoPort, hPort, (ULONG_PTR)hANoPort, 0)
               == INVALID_HANDLE_VALUE) {
            printf ("CreateIoCompletionPort (associate) failed, err: %ld.\n", GetLastError ());
            return -1;
        }
        oNoPort.hEvent = (HANDLE)1;

        while (1) {
            printf ("Posting apc wait.\n");
            rc = WahWaitForNotification (hHelper, hApc, &oApc, WsCompletion);
            if ((rc!=0) && (rc!=WSA_IO_PENDING)) {
                printf ("WahWaitForNotification(apc) failed, err: %ld.\n", rc);
                return -1;
            }

            printf ("Posting event wait.\n");
            rc = WahWaitForNotification (hHelper, hAEvent, &oEvent, NULL);
            if ((rc!=0) && (rc!=WSA_IO_PENDING)) {
                printf ("WahWaitForNotification(event) failed, err: %ld.\n", rc);
                return -1;
            }

            printf ("Posting port wait.\n");
            rc = WahWaitForNotification (hHelper, hAPort, &oPort, NULL);
            if ((rc!=0) && (rc!=WSA_IO_PENDING)) {
                printf ("WahWaitForNotification(port) failed, err: %ld.\n", rc);
                return -1;
            }

            printf ("Posting noport wait.\n");
            rc = WahWaitForNotification (hHelper, hANoPort, &oNoPort, NULL);
            if ((rc!=0) && (rc!=WSA_IO_PENDING)) {
                printf ("WahWaitForNotification(port) failed, err: %ld.\n", rc);
                return -1;
            }

            printf ("Posting sync wait.\n");
            memset (&ovlp, 0, sizeof (ovlp));
            rc = WahWaitForNotification (hHelper, hSync, NULL, NULL);
            if (rc!=0) {
                printf ("WahWaitForNotification failed, err: %ld.\n", rc);
                return -1;
            }

            printf ("Waiting for apc\n");
            rc = SleepEx (INFINITE, TRUE);
            if (rc!=WAIT_IO_COMPLETION) {
                printf ("Unexpected result on wait for apc: %ld.\n", rc);
                return rc;
            }

            printf ("Waiting for port\n");
            if (GetQueuedCompletionStatus (hPort, &count, &key, &lpo, INFINITE)) {
                rc = 0;
            }
            else if (lpo) {
                rc = GetLastError ();
                if (rc==0)
                    printf ("No error code for failed GetQueuedCompletionStatus.\n");
            }
            else {
                printf ("GetQueuedCompletionStatus failed, err: %ld.\n", GetLastError ());
                return -1;
            }
            if (key!=(ULONG_PTR)hAPort)
                printf ("Wrong completion key: %p (expected : %p)", key, hAPort);
            WsCompletion (rc, count, lpo, 0);

            printf ("Waiting for noport\n");
            oNoPort.hEvent = NULL;
            if (GetOverlappedResult (hANoPort, &oNoPort, &count, TRUE)) {
                rc = 0;
            }
            else {
                rc = GetLastError ();
                if (rc==0)
                    printf ("No error code for failed GetOverlappedResult.\n");
            }
            WsCompletion (rc, count, &oNoPort, 0);

            printf ("Waiting for event\n");
            if (GetOverlappedResult (hAEvent, &oEvent, &count, TRUE)) {
                rc = 0;
            }
            else {
                rc = GetLastError ();
                if (rc==0)
                    printf ("No error code for failed GetOverlappedResult.\n");
            }
            WsCompletion (rc, count, &oEvent, 0);
        }
        CloseHandle (hSync);
        CloseHandle (hANoPort);
        CloseHandle (hAPort);
        CloseHandle (hAEvent);
        CloseHandle (hApc);

        CloseHandle (hPort);
        CloseHandle (hEvent);
    }
    else if (argc<3) {
        rc = WahNotifyAllProcesses (hHelper);
        if (rc==0) {
            printf ("Notified all ok.\n");
        }
        else {
            printf ("WahNotifyAllProcesses failed, err: %ld.\n", rc);
        }
    }
    else if (argc>=5) {
        HANDLE          hPipe;
        DWORD           id = GetCurrentProcessId (), count;
        WCHAR           name[MAX_PATH];


        //
        // Create client and of the pipe that matched the
        // pattern
        //
        wsprintfW (name, L"\\\\%hs\\pipe\\Winsock2\\CatalogChangeListener-%hs-%hs", 
                    argv[2], argv[3], argv[4]);

        hPipe =  CreateFileW (name, 
                                GENERIC_WRITE, 
                                FILE_SHARE_READ, 
                                (LPSECURITY_ATTRIBUTES) NULL, 
                                OPEN_EXISTING, 
                                FILE_ATTRIBUTE_NORMAL, 
                                (HANDLE) NULL);
        if (hPipe!=INVALID_HANDLE_VALUE) {
            printf ("Opened pipe %ls.\n", name);
            CloseHandle (hPipe);
        }
        else {
            printf ("Could not open pipe %ls, err: %ld\n",
                name, GetLastError ());
        }
    }
    else
        printf (USAGE(argv[0]));

    WahCloseNotificationHandleHelper (hHelper);
    return 0;
}

VOID WINAPI WsCompletion (
    DWORD           dwErrorCode,
    DWORD           dwNumberOfBytesTransfered,
    LPOVERLAPPED    lpOverlapped,
    DWORD           dwFlags
    ) {
    if (dwErrorCode!=0) {
        printf ("Falure in WsCompletion, err: %ld.\n", dwErrorCode);
        ExitProcess (-1);
    }
    else {
        printf ("WsComletion: %d bytes transferred.\n", dwNumberOfBytesTransfered);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\ws2ifsl\debug.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    process.c

Abstract:

    This module contains debug support definitions for ws2ifsl.sys driver.

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:

--*/

#if DBG

// Components
#define DBG_DISPATCH            0x00000001
#define DBG_SOCKET              0x00000002
#define DBG_PROCESS             0x00000004
#define DBG_QUEUE               0x00000008
#define DBG_LOAD                0x00000010

// Operations
#define DBG_READWRITE           0x00000100
#define DBG_AFDIOCTL            0x00000200
#define DBG_DRV_COMPLETE        0x00000400
#define DBG_PVD_COMPLETE        0x00000800
#define DBG_RETRIEVE            0x00001000
#define DBG_CANCEL              0x00002000

// Failures
#define DBG_FAILURES            0x80000000

extern ULONG DbgLevel;

#define WsPrint(FLAGS,ARGS)	    \
	do {						\
		if (DbgLevel&FLAGS){    \
			DbgPrint ARGS;		\
		}						\
	} while (0)

#define WsProcessPrint(Process,FLAGS,ARGS)	\
	do {						            \
		if (((Process)->DbgLevel)&FLAGS){   \
			DbgPrint ARGS;		            \
		}						            \
	} while (0)

VOID
ReadDbgInfo (
    IN PUNICODE_STRING RegistryPath
    );
#else
#define WsPrint(FLAGS,ARGS) do {NOTHING;} while (0)
#define WsProcessPrint(Process,FLAGS,ARGS) do {NOTHING;} while (0)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\ws2ifsl\misc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    misc.c

Abstract:

    This module implemets helper routines not readily available
    in kernel or TDI libraries for ws2ifsl.sys driver.

Author:

    Vadim Eydelman (VadimE)    Oct-1997 (Inspired by AFD)

Revision History:

--*/

#include "precomp.h"


#pragma alloc_text(PAGE, AllocateMdlChain)
#pragma alloc_text(PAGE, CopyBufferToMdlChain)
#pragma alloc_text(PAGE, CopyMdlChainToBuffer)


VOID
AllocateMdlChain(
    IN PIRP Irp,
    IN LPWSABUF BufferArray,
    IN ULONG BufferCount,
    OUT PULONG TotalByteCount
    )

/*++

Routine Description:

    Allocates a MDL chain describing the WSABUF array and attaches
    the chain to the specified IRP.

Arguments:

    Irp - The IRP that will receive the MDL chain.

    BufferArray - Points to an array of WSABUF structures describing
        the user's buffers.

    BufferCount - Contains the number of WSABUF structures in the
        array.

    TotalByteCount - Will receive the total number of BYTEs described
        by the WSABUF array.

Return Value:

    None

Note:
    Raises appropriate exception if probing/allocation fails
--*/

{
    PMDL currentMdl;
    PMDL * chainTarget;
    KPROCESSOR_MODE previousMode;
    ULONG totalLength;
    PVOID bufferPointer;
    ULONG bufferLength;

    PAGED_CODE ();
    //
    //  Sanity check.
    //

    ASSERT( Irp != NULL );
    ASSERT( Irp->MdlAddress == NULL );
    ASSERT( BufferArray != NULL );
    ASSERT( BufferCount > 0 );
    ASSERT( TotalByteCount != NULL );

    //
    //  Get the previous processor mode.
    //

    previousMode = Irp->RequestorMode;

    if ((BufferArray == NULL) 
            || (BufferCount == 0)
                // Check for integer overflow (disabled by compiler)
            || (BufferCount>(MAXULONG/sizeof (WSABUF)))) {
        ExRaiseStatus (STATUS_INVALID_PARAMETER);
    }

   if( previousMode != KernelMode ) {

        //
        //  Probe the WSABUF array.
        //

        ProbeForRead(
            BufferArray,                            // Address
            BufferCount * sizeof(WSABUF),           // Length
            sizeof(ULONG)                           // Alignment
            );

    }

    //
    //  Get into a known state.
    //

    currentMdl = NULL;
    chainTarget = &Irp->MdlAddress;
    totalLength = 0;


    //
    //  Scan the array.
    //

    do {

        bufferPointer = BufferArray->buf;
        bufferLength = BufferArray->len;

        if( bufferPointer != NULL &&
            bufferLength > 0 ) {

            //
            //  Update the total byte counter.
            //

            totalLength += bufferLength;

            //
            //  Create a new MDL.
            //

            currentMdl = IoAllocateMdl(
                            bufferPointer,      // VirtualAddress
                            bufferLength,       // Length
                            FALSE,              // SecondaryBuffer
                            TRUE,               // ChargeQuota
                            NULL                // Irp
                            );

            if( currentMdl != NULL ) {

                //
                //  Chain the MDL onto the IRP.  In theory, we could
                //  do this by passing the IRP into IoAllocateMdl(),
                //  but IoAllocateMdl() does a linear scan on the MDL
                //  chain to find the last one in the chain.
                //
                //  We can do much better.
                //

                *chainTarget = currentMdl;
                chainTarget = &currentMdl->Next;

                //
                //  Advance to the next WSABUF structure.
                //

                BufferArray++;

            } else {

                //
                //  Cannot allocate new MDL, raise exception.
                //

                ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
            }

        }

    } while( --BufferCount );

    //
    //  Ensure the MDL chain is NULL terminated.
    //

    ASSERT( *chainTarget == NULL );


    //
    //  Return the total buffer count.
    //

    *TotalByteCount = totalLength;

} // AllocateMdlChain

ULONG
CopyMdlChainToBuffer(
    IN PMDL  SourceMdlChain,
    IN PVOID Destination,
    IN ULONG DestinationLength
    )

/*++

Routine Description:

    Copies data from a MDL chain to a linear buffer.
    Assumes that MDL in the right process context
    (virtual address is valid but it may not be mapped into system space)

Arguments:

    SourceMdlChain  - chain of MDL to copy buffer from.

    Destination - Points to the linear destination of the data.

    DestinationLength - The length of Destination.


Return Value:

    ULONG - The number of bytes copied.

--*/

{
    ULONG   SrcBytesLeft = 0;
    PUCHAR  Dst = Destination, Src;

    PAGED_CODE ();

    //ASSERT (SourceMdlChain->Process==PsGetCurrentProcess ());

    while (DestinationLength != 0) {
        do {
            if (SourceMdlChain == NULL) {
                goto Done;
            }
            Src = MmGetMdlVirtualAddress (SourceMdlChain);
            SrcBytesLeft = MmGetMdlByteCount (SourceMdlChain);
            SourceMdlChain = SourceMdlChain->Next;
        }
        while (SrcBytesLeft == 0);

        if (SrcBytesLeft >= DestinationLength) {
            RtlCopyMemory (Dst, Src, DestinationLength);
            Dst += DestinationLength;
            break;
        } else {
            RtlCopyMemory (Dst, Src, SrcBytesLeft);
            DestinationLength -= SrcBytesLeft;
            Dst += SrcBytesLeft;
        }
    }

Done:
    return (ULONG)(Dst - (PUCHAR)Destination);

} // CopyMdlChainToBuffer



ULONG
CopyBufferToMdlChain(
    IN PVOID Source,
    IN ULONG SourceLength,
    IN PMDL  DestinationMdlChain
    )

/*++

Routine Description:

    Copies data from a linear buffer to a MDL chain.
    Assumes that MDL in the right process context
    (virtual address is valid but it may not be mapped into system space)

Arguments:

    Source - Points to the linear source of the data.

    SourceLength - The length of Source.

    DestinationMdlChain  - chain of MDL to copy buffer to.

Return Value:

    ULONG - The number of bytes copied.

--*/

{
    ULONG   DstBytesLeft = 0;
    PUCHAR  Dst, Src = Source;

//    ASSERT (DestinationMdlChain->Process==PsGetCurrentProcess ());

    while (SourceLength != 0) {
        do {
            if (DestinationMdlChain == NULL) {
                goto Done;
            }
            Dst = MmGetMdlVirtualAddress (DestinationMdlChain);
            DstBytesLeft = MmGetMdlByteCount (DestinationMdlChain);
            DestinationMdlChain = DestinationMdlChain->Next;
        }
        while (DstBytesLeft == 0);

        if (DstBytesLeft >= SourceLength) {
            RtlCopyMemory (Dst, Src, SourceLength);
            Src += SourceLength;            
            break;
        } else {
            RtlCopyMemory (Dst, Src, DstBytesLeft);
            SourceLength -= DstBytesLeft;
            Src += DstBytesLeft;
        }
    }

Done:
    return (ULONG)(Src - (PUCHAR)Source);

} // CopyBufferToMdlChain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\ws2ifsl\driver.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    driver.c

Abstract:

    This module contains the driver entry and unload routines
    for ws2ifsl.sys driver.

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:

--*/

#include "precomp.h"

// Local routine declarations
NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
DriverUnload (
	IN PDRIVER_OBJECT 	DriverObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry )
#pragma alloc_text(PAGE, DriverUnload)
#endif

PDEVICE_OBJECT  DeviceObject;

FAST_IO_DISPATCH FastIoDispatchTable = {
    sizeof (FAST_IO_DISPATCH),  // SizeOfFastIoDispatch
    NULL,                       // FastIoCheckIfPossible
    NULL,                       // FastIoRead
    NULL,                       // FastIoWrite
    NULL,                       // FastIoQueryBasicInfo
    NULL,                       // FastIoQueryStandardInfo
    NULL,                       // FastIoLock
    NULL,                       // FastIoUnlockSingle
    NULL,                       // FastIoUnlockAll
    NULL,                       // FastIoUnlockAllByKey
    FastIoDeviceControl         // FastIoDeviceControl
};


NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This is the initialization routine for the ws2ifsl device driver.

Arguments:

    DriverObject - Pointer to driver object created by the system.
    RegistryPath - path to driver's registry ley

Return Value:

    Final status from the initialization operation.

--*/

{
    NTSTATUS        status;
    UNICODE_STRING  deviceName;

    PAGED_CODE( );


#if DBG
    ReadDbgInfo (RegistryPath);
#endif
    //
    // Create the device object.  (IoCreateDevice zeroes the memory
    // occupied by the object.)
    //

    RtlInitUnicodeString( &deviceName, WS2IFSL_DEVICE_NAME );

    status = IoCreateDevice(
                 DriverObject,                   // DriverObject
                 0,                              // DeviceExtension
                 &deviceName,                    // DeviceName
                 FILE_DEVICE_WS2IFSL,           // DeviceType
                 0,                              // DeviceCharacteristics
                 FALSE,                          // Exclusive
                 &DeviceObject                   // DeviceObject
                 );


    if (NT_SUCCESS(status)) {
    
        // Initialize device object
        
        // DeviceObject->Flags |= 0;  // Neither direct nor buffering
        DeviceObject->StackSize = 1; // No underlying drivers

        //
        // Initialize the driver object.
        //

        DriverObject->MajorFunction[IRP_MJ_CREATE] = DispatchCreate;
        DriverObject->MajorFunction[IRP_MJ_CLOSE] = DispatchClose;
        DriverObject->MajorFunction[IRP_MJ_CLEANUP] = DispatchCleanup;
        DriverObject->MajorFunction[IRP_MJ_READ] = 
            DriverObject->MajorFunction[IRP_MJ_WRITE] = DispatchReadWrite;
        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DispatchDeviceControl;
        DriverObject->MajorFunction[IRP_MJ_PNP] = DispatchPnP;
        DriverObject->DriverUnload = DriverUnload;
        DriverObject->FastIoDispatch = &FastIoDispatchTable;


        //
        // Initialize global data.
        //

        WsPrint (DBG_LOAD, ("WS2IFSL DriverEntry: driver loaded OK\n"));
        return STATUS_SUCCESS;
    }
    else {
        WsPrint (DBG_FAILURES|DBG_LOAD,
            ("WS2IFSL DriverEntry: unable to create device object: %X\n",
            status ));
    }

    return status;
} // DriverEntry


NTSTATUS
DriverUnload (
	IN PDRIVER_OBJECT 	DriverObject
    )
/*++

Routine Description:

    This routine releases all resources allocated by the driver
    when it is unloaded.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    STATUS_SUCCESS

--*/

{
    PAGED_CODE( );
    // Release global resources
    IoDeleteDevice (DeviceObject);

    WsPrint (DBG_LOAD, ("WS2IFSL DriverUnload: driver unloaded OK\n"));

    return STATUS_SUCCESS;
} // DriverUnload
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\ws2ifsl\driver.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    driver.h

Abstract:

    This module contains global variable and external routine
    declarations for driver object of ws2ifsl.sys driver.

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:

--*/

extern PDEVICE_OBJECT  DeviceObject;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\ws2ifsl\dispatch.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    This module contains the dispatch routines for 
    ws2ifsl.sys driver

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:
    Vadim Eydelman (VadimE)    Oct-1997, rewrite to properly handle IRP
                                        cancellation

--*/

#include "precomp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, DispatchCreate)
#pragma alloc_text (PAGE, DispatchCleanup)
#pragma alloc_text (PAGE, DispatchClose)
#pragma alloc_text (PAGE, DispatchReadWrite)
#pragma alloc_text (PAGE, DispatchDeviceControl)
#pragma alloc_text (PAGE, FastIoDeviceControl)
#endif

NTSTATUS
DispatchCreate (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
	)
/*++

Routine Description:

    This routine is called as the result of a request to create
    a file associated with WS2IFSL driver device object.

Arguments:

    DeviceObject - WS2IFSL device object
    Irp          - create Irp

Return Value:

    STATUS_SUCCESS - requested file object can be created
    STATUS_INVALID_PARAMETER - required extened attribute is missing
                        or invalid
    STATUS_INSUFFICIENT_RESOURCES - not enough resources to complete
                        this request

--*/
{
    NTSTATUS                    status;
    PIO_STACK_LOCATION          irpSp;
    PFILE_FULL_EA_INFORMATION   eaBuffer;

    PAGED_CODE ();

    // Get extended attribute buffer which identifies the
    // type of file that should be created.

    eaBuffer = Irp->AssociatedIrp.SystemBuffer;
    if (eaBuffer!=NULL) {
        irpSp = IoGetCurrentIrpStackLocation (Irp);
        if ((eaBuffer->EaNameLength==WS2IFSL_SOCKET_EA_NAME_LENGTH)
                && (strcmp (eaBuffer->EaName, WS2IFSL_SOCKET_EA_NAME)==0)) {
            // This is the request to create socket file

            status = CreateSocketFile (irpSp->FileObject,
                                        Irp->RequestorMode, 
                                        eaBuffer);
        }
        else if ((eaBuffer->EaNameLength==WS2IFSL_PROCESS_EA_NAME_LENGTH)
                && (strcmp (eaBuffer->EaName, WS2IFSL_PROCESS_EA_NAME)==0)) {
            // This is the request to create process file

            status = CreateProcessFile (irpSp->FileObject,
                                        Irp->RequestorMode, 
                                        eaBuffer);
        }
        else
            status = STATUS_INVALID_PARAMETER;
    }
    else
        status = STATUS_INVALID_PARAMETER;
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);  

    return status;
} // DispatchCreate

NTSTATUS
DispatchCleanup (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
	)
/*++

Routine Description:

    This routine is called when all handles to a file associated with WS2IFSL
    driver device object are closed, so the driver should cleanup all the
    outstanding IRPs.

Arguments:

    DeviceObject - WS2IFSL device object
    Irp          - cleanup Irp

Return Value:

    STATUS_SUCCESS - cleanup operation completed
    STATUS_PENDING - cleanup operation started and IoCompleteRequest will be
                    called when it is done

--*/
{
    NTSTATUS                    status;
    PIO_STACK_LOCATION          irpSp;
    ULONG                       eaNameTag;

    PAGED_CODE ();

    // Get the file type from file object context
    irpSp = IoGetCurrentIrpStackLocation (Irp);
    eaNameTag = *((PULONG)irpSp->FileObject->FsContext);

    // Call appropriate routine based on file type
    switch (eaNameTag) {
    case SOCKET_FILE_EANAME_TAG:
        status = CleanupSocketFile (irpSp->FileObject, Irp);
        break;
    case PROCESS_FILE_EANAME_TAG:
        status = CleanupProcessFile (irpSp->FileObject, Irp);
        break;
    default:
        ASSERTMSG ("Unknown file EA name tag", FALSE);
        status = STATUS_INVALID_HANDLE;
        break;
    }

    // Complete the request if it was not marked pending
    if (status!=STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }

    return status;
} // DispatchCleanup

NTSTATUS
DispatchClose (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
	)
/*++

Routine Description:

    This routine is called when all references to a file associated with WS2IFSL
    driver device object are released and IO system is about to delete the
    file object itself

Arguments:

    DeviceObject - WS2IFSL device object
    Irp          - close Irp

Return Value:

    STATUS_SUCCESS - close operation completed

--*/
{
    NTSTATUS                    status;
    PIO_STACK_LOCATION          irpSp;
    ULONG                       eaNameTag;

    PAGED_CODE ();

    // Get the file type from file object context
    irpSp = IoGetCurrentIrpStackLocation (Irp);
    eaNameTag = *((PULONG)irpSp->FileObject->FsContext);

    // Call appropriate routine based on file type
    switch (eaNameTag) {
    case SOCKET_FILE_EANAME_TAG:
        CloseSocketFile (irpSp->FileObject);
        status = STATUS_SUCCESS;
        break;
    case PROCESS_FILE_EANAME_TAG:
        CloseProcessFile (irpSp->FileObject);
        status = STATUS_SUCCESS;
        break;
    default:
        ASSERTMSG ("Unknown file EA name tag", FALSE);
        status = STATUS_INVALID_HANDLE;
        break;
    }

    // Complete the request
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return status;
} // DispatchClose

NTSTATUS
DispatchReadWrite (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
	)
/*++

Routine Description:

    This routine is called to perform read or write operation on file object.
    It is only supported for socket files.

Arguments:

    DeviceObject - WS2IFSL device object
    Irp          - read/write  Irp

Return Value:

    STATUS_PENDING - operation is passed onto WS2IFSL DLL to execute
    STATUS_CANCELED - operation canceled because WS2IFSL DLL has been unloaded
    STATUS_INVALID_DEVICE_REQUEST - the operation cannot be performed on 
                        this file object.
    STATUS_INVALID_HANDLE - file object is not valid in the context of
                        current process
                        

--*/
{
    NTSTATUS                    status;
    PIO_STACK_LOCATION          irpSp;
    ULONG                       eaNameTag;

    PAGED_CODE ();

    // Get the file type from file object context
    irpSp = IoGetCurrentIrpStackLocation (Irp);
    eaNameTag = *((PULONG)irpSp->FileObject->FsContext);

    // Call appropriate routine based on file type
    switch (eaNameTag) {
    case SOCKET_FILE_EANAME_TAG:
        status = DoSocketReadWrite (irpSp->FileObject, Irp);
        break;
    default:
        ASSERTMSG ("Unknown file EA name tag", FALSE);
    case PROCESS_FILE_EANAME_TAG:
        // This operation is not valid for process files
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    // Complete the request if it was not marked pending
    if (status!=STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }

    return status;
} // DispatchReadWrite


NTSTATUS
DispatchDeviceControl (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
	)
/*++

Routine Description:

    This routine is called to perform device control operation on file object.

Arguments:

    DeviceObject - WS2IFSL device object
    Irp          - device control Irp

Return Value:

    STATUS_SUCCESS - device control operation completed
    STATUS_PENDING - operation is in progress
    STATUS_INVALID_DEVICE_REQUEST - the operation cannot be performed on 
                        this file object.
    STATUS_INVALID_HANDLE - file object is not valid in the context of
                        current process

--*/
{
    NTSTATUS                    status;
    PIO_STACK_LOCATION          irpSp;
    ULONG                       eaNameTag;
    ULONG                       function;

    PAGED_CODE ();

    // Get the file type from file object context
    irpSp = IoGetCurrentIrpStackLocation (Irp);
    eaNameTag = *((PULONG)irpSp->FileObject->FsContext);

    // Call appropriate routine based on file type
    switch (eaNameTag) {
    case SOCKET_FILE_EANAME_TAG:
        function = WS2IFSL_IOCTL_FUNCTION(SOCKET,irpSp->Parameters.DeviceIoControl.IoControlCode);
        if ((function<sizeof(SocketIoControlMap)/sizeof(SocketIoControlMap[0])) &&
                (SocketIoctlCodeMap[function]==irpSp->Parameters.DeviceIoControl.IoControlCode)) {
            // Use table dispatch to call appropriate internal IOCTL routine
            ASSERTMSG ("Socket file device control requests should have been handled"
                    " by FastIo path ", FALSE);
            SocketIoControlMap[function] (
                    irpSp->FileObject,
                    Irp->RequestorMode,
                    irpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                    irpSp->Parameters.DeviceIoControl.InputBufferLength,
                    Irp->UserBuffer,
                    irpSp->Parameters.DeviceIoControl.OutputBufferLength,
                    &Irp->IoStatus);
            status = Irp->IoStatus.Status;
        }
        else if ((irpSp->Parameters.DeviceIoControl.IoControlCode==IOCTL_AFD_SEND_DATAGRAM)
                    || (irpSp->Parameters.DeviceIoControl.IoControlCode==IOCTL_AFD_RECEIVE_DATAGRAM)
                    || (irpSp->Parameters.DeviceIoControl.IoControlCode==IOCTL_AFD_RECEIVE))
            // Handle some "popular" afd IOCTLs
            status = DoSocketAfdIoctl (irpSp->FileObject, Irp);
        else {
            WsPrint (DBG_FAILURES, 
                ("WS2IFSL-%04lx DispatchDeviceControl: Unsupported IOCTL - %lx!!!\n",
                    PsGetCurrentProcessId(),
                    irpSp->Parameters.DeviceIoControl.IoControlCode
                    ));
            status = STATUS_INVALID_DEVICE_REQUEST;
        }
        break;
    case PROCESS_FILE_EANAME_TAG:
        function = WS2IFSL_IOCTL_FUNCTION(PROCESS,irpSp->Parameters.DeviceIoControl.IoControlCode);
        if ((function<sizeof(ProcessIoControlMap)/sizeof(ProcessIoControlMap[0])) &&
                (ProcessIoctlCodeMap[function]==irpSp->Parameters.DeviceIoControl.IoControlCode)) {
            // Use table dispatch to call appropriate internal IOCTL routine
            ASSERTMSG ("Process file device control requests should have been handled"
                    " by FastIo path ", FALSE);
            ProcessIoControlMap[function] (
                    irpSp->FileObject,
                    Irp->RequestorMode,
                    irpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                    irpSp->Parameters.DeviceIoControl.InputBufferLength,
                    Irp->UserBuffer,
                    irpSp->Parameters.DeviceIoControl.OutputBufferLength,
                    &Irp->IoStatus);
            status = Irp->IoStatus.Status;
        }
        else {
            WsPrint (DBG_FAILURES, 
                ("WS2IFSL-%04lx DispatchDeviceControl: Unsupported IOCTL - %lx!!!\n",
                    PsGetCurrentProcessId(),
                    irpSp->Parameters.DeviceIoControl.IoControlCode
                    ));
            status = STATUS_INVALID_DEVICE_REQUEST;
        }
        break;
    default:
        ASSERTMSG ("Unknown file EA name tag", FALSE);
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    // Complete the request if it was not marked pending
    if (status!=STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }

    return status;
} // DispatchDeviceControl


BOOLEAN
FastIoDeviceControl (
	IN PFILE_OBJECT 		FileObject,
	IN BOOLEAN 			    Wait,
	IN PVOID 				InputBuffer	OPTIONAL,
	IN ULONG 				InputBufferLength,
	OUT PVOID 				OutputBuffer	OPTIONAL,
	IN ULONG 				OutputBufferLength,
	IN ULONG 				IoControlCode,
	OUT PIO_STATUS_BLOCK	IoStatus,
	IN PDEVICE_OBJECT 		DeviceObject
    )
/*++

Routine Description:

    This routine is called to perform device control operation on file object.
    This is IO system fast path that assumes immediate action

Arguments:

    FileObject      - file object to which request is directed;
    Wait            - ??? (always TRUE);
    InputBuffer     - address of the input buffer;
    InputBufferLength - size of the input buffer;
    OutputBuffer    - address of the output buffer;
    OutputBufferLength - size of the output buffer;
    IoControlCode   - code of the operation to be performed;
    IoStatus        - status of the operation returned by the driver:
    DeviceObject    - WS2IFSL device object

Return Value:

    TRUE    - operation completed,
    FALSE   - operation should be preformed using Irps
--*/
{
    BOOLEAN         done = FALSE;
    ULONG           eaNameTag;
    ULONG           function;

    PAGED_CODE ();

    // Get the file type from file object context
    eaNameTag = *((PULONG)FileObject->FsContext);

    // Call appropriate routine based on file type
    switch (eaNameTag) {
    case SOCKET_FILE_EANAME_TAG:
        function = WS2IFSL_IOCTL_FUNCTION(SOCKET,IoControlCode);
        if ((function<sizeof(SocketIoControlMap)/sizeof(SocketIoControlMap[0])) &&
                (SocketIoctlCodeMap[function]==IoControlCode)) {
            // Use table dispatch to call appropriate internal IOCTL routine
            SocketIoControlMap[function] (
                    FileObject,
                    ExGetPreviousMode(),
                    InputBuffer,
                    InputBufferLength,
                    OutputBuffer,
                    OutputBufferLength,
                    IoStatus);
            done = TRUE;
        }
        else if ((IoControlCode==IOCTL_AFD_SEND_DATAGRAM)
                    || (IoControlCode==IOCTL_AFD_RECEIVE_DATAGRAM)
                    || (IoControlCode==IOCTL_AFD_RECEIVE))
            // AFD ioctls can only be handled on "slow" io path (need IRP)
            NOTHING;
        else {
            WsPrint (DBG_FAILURES, 
                ("WS2IFSL-%04lx FastIoDeviceControl: Unsupported IOCTL - %lx!!!\n",
                    PsGetCurrentProcessId(), IoControlCode));
            IoStatus->Status = STATUS_INVALID_DEVICE_REQUEST;
            done = TRUE;
        }
        break;
    case PROCESS_FILE_EANAME_TAG:
        function = WS2IFSL_IOCTL_FUNCTION(PROCESS,IoControlCode);
        if ((function<sizeof(ProcessIoControlMap)/sizeof(ProcessIoControlMap[0])) &&
                (ProcessIoctlCodeMap[function]==IoControlCode)) {
            // Use table dispatch to call appropriate internal IOCTL routine
            ProcessIoControlMap[function] (
                    FileObject,
                    ExGetPreviousMode(),
                    InputBuffer,
                    InputBufferLength,
                    OutputBuffer,
                    OutputBufferLength,
                    IoStatus);
            done = TRUE;
        }
        else {
            WsPrint (DBG_FAILURES, 
                ("WS2IFSL-%04lx FastIoDeviceControl: Unsupported IOCTL - %lx!!!\n",
                    PsGetCurrentProcessId(),IoControlCode));
            IoStatus->Status = STATUS_INVALID_DEVICE_REQUEST;
            done = TRUE;
        }
        break;
    default:
        ASSERTMSG ("Unknown file EA name tag", FALSE);
        IoStatus->Status = STATUS_INVALID_PARAMETER;
        IoStatus->Information = 0;
        done = TRUE;
        break;
    }

    return done;
} // FastIoDeviceControl

NTSTATUS
DispatchPnP (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
	)
/*++

Routine Description:

    This routine is called to perform PnP control operation on file object.

Arguments:

    DeviceObject - WS2IFSL device object
    Irp          - PnP Irp

Return Value:

    STATUS_SUCCESS - device control operation completed
    STATUS_PENDING - operation is in progress
    STATUS_INVALID_DEVICE_REQUEST - the operation cannot be performed on 
                        this file object.

--*/
{
    NTSTATUS                    status;
    PIO_STACK_LOCATION          irpSp;
    ULONG                       eaNameTag;

    PAGED_CODE ();

    // Get the file type from file object context
    irpSp = IoGetCurrentIrpStackLocation (Irp);
    eaNameTag = *((PULONG)irpSp->FileObject->FsContext);

    // Call appropriate routine based on file type
    switch (eaNameTag) {
    case SOCKET_FILE_EANAME_TAG:
        switch (irpSp->MinorFunction) {
        case IRP_MN_QUERY_DEVICE_RELATIONS:
            status = SocketPnPTargetQuery (irpSp->FileObject, Irp);
            break;
        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
        break;

    default:
        ASSERTMSG ("Unknown file EA name tag", FALSE);

    case PROCESS_FILE_EANAME_TAG:
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
   }
    // Complete the request if it was not marked pending
    if (status!=STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\ws2ifsl\precomp.h ===
#include <ntosp.h>

//extern POBJECT_TYPE *IoFileObjectType;
//extern POBJECT_TYPE *ExEventObjectType;
//extern POBJECT_TYPE *PsThreadType;

#ifndef SG_UNCONSTRAINED_GROUP
#define SG_UNCONSTRAINED_GROUP   0x01
#endif

#ifndef SG_CONSTRAINED_GROUP
#define SG_CONSTRAINED_GROUP     0x02
#endif

#include <tdi.h>
#include <tdikrnl.h>
#include <afd.h>       // To support "secret" AFD IOCTL's

#include <ws2ifsl.h>

#include "ws2ifslp.h"
#include "driver.h"
#include "debug.h"
#include "dispatch.h"
#include "socket.h"
#include "process.h"
#include "queue.h"
#include "misc.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\ws2ifsl\misc.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    misc.c

Abstract:

    This module contains declarations of functions and globals
    for helper routines not readily available
    in kernel or TDI libraries for ws2ifsl.sys driver.

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:

--*/

ULONG
CopyMdlChainToBuffer(
    IN PMDL  SourceMdlChain,
    IN PVOID Destination,
    IN ULONG DestinationLength
    );

VOID
AllocateMdlChain(
    IN PIRP Irp,
    IN LPWSABUF BufferArray,
    IN ULONG BufferCount,
    OUT PULONG TotalByteCount
    );

ULONG
CopyBufferToMdlChain(
    IN PVOID Source,
    IN ULONG SourceLength,
    IN PMDL  DestinationMdlChain
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\ws2ifsl\process.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    process.c

Abstract:

    This module implements process file object for ws2ifsl.sys driver.

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:

    Vadim Eydelman (VadimE)    Oct-1997, rewrite to properly handle IRP
                                        cancellation
--*/

#include "precomp.h"

//
// Internal routine prototypes
//

VOID
RetrieveDrvRequest (
    IN PFILE_OBJECT     ProcessFile,
    IN KPROCESSOR_MODE  RequestorMode,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    OUT PVOID           OutputBuffer,
    IN ULONG            OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
    );

VOID
CompleteDrvCancel (
    IN PFILE_OBJECT     SocketFile,
    IN KPROCESSOR_MODE  RequestorMode,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    OUT PVOID           OutputBuffer,
    IN ULONG            OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
    );

VOID
CallCompleteDrvRequest (
    IN PFILE_OBJECT     SocketFile,
    IN KPROCESSOR_MODE  RequestorMode,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    OUT PVOID           OutputBuffer,
    IN ULONG            OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CreateProcessFile)
#pragma alloc_text(PAGE, CleanupProcessFile)
#pragma alloc_text(PAGE, CloseProcessFile)
#pragma alloc_text(PAGE, RetrieveDrvRequest)
#pragma alloc_text(PAGE, CompleteDrvCancel)
#pragma alloc_text(PAGE, CallCompleteDrvRequest)
#endif

ULONG                   ProcessIoctlCodeMap[3] = {
#if WS2IFSL_IOCTL_FUNCTION(PROCESS,IOCTL_WS2IFSL_RETRIEVE_DRV_REQ)!=0
#error Mismatch between IOCTL function code and ProcessIoControlMap
#endif
    IOCTL_WS2IFSL_RETRIEVE_DRV_REQ,
#if WS2IFSL_IOCTL_FUNCTION(PROCESS,IOCTL_WS2IFSL_COMPLETE_DRV_CAN)!=1
#error Mismatch between IOCTL function code and ProcessIoControlMap
#endif
    IOCTL_WS2IFSL_COMPLETE_DRV_CAN,
#if WS2IFSL_IOCTL_FUNCTION(PROCESS,IOCTL_WS2IFSL_COMPLETE_DRV_REQ)!=2
#error Mismatch between IOCTL function code and ProcessIoControlMap
#endif
    IOCTL_WS2IFSL_COMPLETE_DRV_REQ
};

PPROCESS_DEVICE_CONTROL ProcessIoControlMap[3] = {
    RetrieveDrvRequest,
    CompleteDrvCancel,
    CallCompleteDrvRequest
};


NTSTATUS
CreateProcessFile (
    IN PFILE_OBJECT                 ProcessFile,
    IN KPROCESSOR_MODE              RequestorMode,
    IN PFILE_FULL_EA_INFORMATION    eaInfo
    )
/*++

Routine Description:

    Allocates and initializes process file context structure

Arguments:
    ProcessFile - socket file object
    eaInfo     - EA for process file

Return Value:

    STATUS_SUCCESS  - operation completed OK
    STATUS_INSUFFICIENT_RESOURCES - not enough memory to allocate context
    STATUS_INVALID_PARAMETER - invalid creation parameters
    STATUS_INVALID_HANDLE   - invalid event handle(s)
    STATUS_OBJECT_TYPE_MISMATCH - event handle(s) is not for event object
--*/
{
    NTSTATUS                status = STATUS_SUCCESS;
    PIFSL_PROCESS_CTX       ProcessCtx;
    PETHREAD                apcThread;

    PAGED_CODE ();

    //
    // Verify the size of the input strucuture
    //

    if (eaInfo->EaValueLength!=WS2IFSL_PROCESS_EA_VALUE_LENGTH) {
        WsPrint (DBG_PROCESS|DBG_FAILURES,
            ("WS2IFSL-%04lx CreateProcessFile: Invalid ea info size (%ld)"
             " for process file %p.\n",
             PsGetCurrentProcessId(),
             eaInfo->EaValueLength,
             ProcessFile));
        return STATUS_INVALID_PARAMETER;
    }


    //
    // Reference event handles for signalling to user mode DLL
    //
    status = ObReferenceObjectByHandle(
                 GET_WS2IFSL_PROCESS_EA_VALUE(eaInfo)->ApcThread,
                 THREAD_SET_CONTEXT,    // DesiredAccess
                 *PsThreadType,
                 RequestorMode,
                 (PVOID *)&apcThread,
                 NULL
                 );

    if (NT_SUCCESS (status)) {
        if (IoThreadToProcess (apcThread)==IoGetCurrentProcess ()) {

            // Allocate process context and charge it to the process
            try {
                ProcessCtx = (PIFSL_PROCESS_CTX) ExAllocatePoolWithQuotaTag (
                                                    NonPagedPool,
                                                    sizeof (IFSL_PROCESS_CTX),
                                                    PROCESS_FILE_CONTEXT_TAG);
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                ProcessCtx = NULL;
                status = GetExceptionCode ();
            }

            if (ProcessCtx!=NULL) {
                // Initialize process context structure
                ProcessCtx->EANameTag = PROCESS_FILE_EANAME_TAG;
                ProcessCtx->UniqueId = PsGetCurrentProcessId();
                ProcessCtx->CancelId = 0;
                InitializeRequestQueue (ProcessCtx,
                                        (PKTHREAD)apcThread,
                                        RequestorMode,
                                        (PKNORMAL_ROUTINE)GET_WS2IFSL_PROCESS_EA_VALUE(eaInfo)->RequestRoutine,
                                        GET_WS2IFSL_PROCESS_EA_VALUE(eaInfo)->ApcContext);
                InitializeCancelQueue (ProcessCtx,
                                        (PKTHREAD)apcThread,
                                        RequestorMode,
                                        (PKNORMAL_ROUTINE)GET_WS2IFSL_PROCESS_EA_VALUE(eaInfo)->CancelRoutine,
                                        GET_WS2IFSL_PROCESS_EA_VALUE(eaInfo)->ApcContext);
#if DBG
                ProcessCtx->DbgLevel
                    = GET_WS2IFSL_PROCESS_EA_VALUE(eaInfo)->DbgLevel|DbgLevel;
#endif



                ProcessFile->FsContext = ProcessCtx;
                WsProcessPrint (ProcessCtx, DBG_PROCESS,
                    ("WS2IFSL-%04lx CreateProcessFile: Process file %p (ctx: %p).\n",
                     PsGetCurrentProcessId(),
                     ProcessFile, ProcessFile->FsContext));
                return STATUS_SUCCESS;
            }
            else {
                WsPrint (DBG_PROCESS|DBG_FAILURES,
                    ("WS2IFSL-%04lx CreateProcessFile: Could not allocate context for"
                     " process file %p.\n",
                     PsGetCurrentProcessId(),
                     ProcessFile));
                if (NT_SUCCESS (status)) {
                    ASSERT (FALSE);
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }
        else {
            WsPrint (DBG_PROCESS|DBG_FAILURES,
                ("WS2IFSL-%04lx CreateProcessFile: Apc thread (%p)"
                 " is not from current process for process file %p.\n",
                 PsGetCurrentProcessId(),
                 GET_WS2IFSL_PROCESS_EA_VALUE(eaInfo)->ApcThread,
                 ProcessFile));
        }
        ObDereferenceObject (apcThread);
    }
    else {
        WsPrint (DBG_PROCESS|DBG_FAILURES,
            ("WS2IFSL-%04lx CreateProcessFile: Could not reference apc thread (%p)"
             " for process file %p, status: %lx.\n",
             PsGetCurrentProcessId(),
             GET_WS2IFSL_PROCESS_EA_VALUE(eaInfo)->ApcThread,
             ProcessFile,
             status));
    }

    return status;
} // CreateProcessFile


NTSTATUS
CleanupProcessFile (
    IN PFILE_OBJECT ProcessFile,
    IN PIRP         Irp
    )
/*++

Routine Description:

    Cleanup routine for process file, NOP

Arguments:
    ProcessFile  - process file object
    Irp          - cleanup request

Return Value:

    STATUS_SUCESS  - operation completed OK
--*/
{
    PIFSL_PROCESS_CTX  ProcessCtx = ProcessFile->FsContext;
    PAGED_CODE ();

    ASSERT (ProcessCtx->UniqueId==PsGetCurrentProcessId());

    WsProcessPrint (ProcessCtx, DBG_PROCESS,
        ("WS2IFSL-%04lx CleanupProcessFile: Process file %p (ctx:%p)\n",
        PsGetCurrentProcessId(),
        ProcessFile, ProcessFile->FsContext));

    return STATUS_SUCCESS;
} // CleanupProcessFile


VOID
CloseProcessFile (
    IN PFILE_OBJECT ProcessFile
    )
/*++

Routine Description:

    Deallocate all resources associated with process file

Arguments:
    ProcessFile  - process file object

Return Value:
    None
--*/
{
    PIFSL_PROCESS_CTX    ProcessCtx = ProcessFile->FsContext;
    PAGED_CODE ();

    WsProcessPrint (ProcessCtx, DBG_PROCESS,
        ("WS2IFSL-%04lx CloseProcessFile: Process file %p (ctx:%p)\n",
        ProcessCtx->UniqueId, ProcessFile, ProcessFile->FsContext));

    ASSERT (IsListEmpty (&ProcessCtx->RequestQueue.ListHead));
    ASSERT (IsListEmpty (&ProcessCtx->CancelQueue.ListHead));

    ObDereferenceObject (ProcessCtx->RequestQueue.Apc.Thread);

    // Now free the context itself
    ExFreePool (ProcessCtx);

} // CloseProcessFile




VOID
RetrieveDrvRequest (
    IN PFILE_OBJECT     ProcessFile,
    IN KPROCESSOR_MODE  RequestorMode,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    OUT PVOID           OutputBuffer,
    IN ULONG            OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    Retrievs parameters and data of the request to be executed by
    user mode DLL

Arguments:
    ProcessFile         - Identifies the process
    InputBuffer         - input buffer pointer
                                - identifies the request to retreive
                                  and received request parameters
    InputBufferLength   - size of the input buffer
    OutputBuffer        - output buffer pointer
                                - buffer to receive data and address
                                  for send operation
    OutputBufferLength  - size of output buffer
    IoStatus            - IO status information block
        Status: STATUS_SUCCESS - operation retreived OK, no more pending
                                 requests in the queue.
                STATUS_MORE_ENTRIES - operation retrieved OK, more requests
                                      are available in the queue
                STATUS_CANCELLED    - operation was cancelled before it
                                      could be retrieved
                STATUS_INVALID_PARAMETER - one of the parameters was invalid
                STATUS_INSUFFICIENT_RESOURCES - insufficient resources or
                                            buffer space to perform the
                                            operation.
        Information:            - number of bytes copied to OutputBuffer
Return Value:
    None (result returned via IoStatus block)
--*/
{
    PIFSL_PROCESS_CTX       ProcessCtx = ProcessFile->FsContext;
    PIFSL_SOCKET_CTX        SocketCtx;
    PWS2IFSL_RTRV_PARAMS    params;
    PIRP                    irp = NULL;
    PIO_STACK_LOCATION      irpSp;
    BOOLEAN                 more =FALSE;
    ULONG                   bytesCopied;

    PAGED_CODE();

    IoStatus->Information = 0;
    // Check input buffer size
    if (InputBufferLength<sizeof (WS2IFSL_RTRV_PARAMS)) {
        IoStatus->Status = STATUS_INVALID_PARAMETER;
        WsPrint (DBG_RETRIEVE|DBG_FAILURES,
            ("WS2IFSL-%04lx RetrieveDrvRequest: Invalid input buffer size (%ld).\n",
             PsGetCurrentProcessId(),
             InputBufferLength));
        return;
    }

    try {
        // Verify buffers
        if (RequestorMode!=KernelMode) {
            ProbeForRead (InputBuffer,
                            sizeof (*params),
                            sizeof (ULONG));
            if (OutputBufferLength>0)
                ProbeForWrite (OutputBuffer,
                            OutputBufferLength,
                            sizeof (UCHAR));
        }
        params = InputBuffer;

        // Dequeue the request indetified in the input buffer
        irp = DequeueRequest (ProcessCtx,
                                params->UniqueId,
                                &more);
        if (irp!=NULL) {
            //
            // Copy request parameters and data
            //
            irpSp = IoGetCurrentIrpStackLocation (irp);

            if (OutputBuffer==NULL) {
                //
                // Special condition, dll could not allocate support
                // structures
                //
                ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
            }

            SocketCtx = irpSp->FileObject->FsContext;
            params->DllContext = SocketCtx->DllContext;

            switch (irpSp->MajorFunction) {
            case IRP_MJ_READ:
                params->RequestType = WS2IFSL_REQUEST_READ;
                params->DataLen = irpSp->Parameters.Read.Length;
                params->AddrLen = 0;
                params->Flags = 0;
                break;

            case IRP_MJ_WRITE:
                bytesCopied = CopyMdlChainToBuffer (irp->MdlAddress,
                                        OutputBuffer,
                                        OutputBufferLength);
                if (bytesCopied<irpSp->Parameters.Write.Length) {
					WsPrint (DBG_RETRIEVE|DBG_FAILURES,
						("WS2IFSL-%04lx RetrieveDrvRequest: Invalid output buffer size (%ld).\n",
						 PsGetCurrentProcessId(),
						 OutputBufferLength));
                    ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
                }
                params->RequestType = WS2IFSL_REQUEST_WRITE;
                params->DataLen = bytesCopied;
                params->AddrLen = 0;
                params->Flags = 0;
                IoStatus->Information = bytesCopied;
                break;

            case IRP_MJ_DEVICE_CONTROL:
                switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
                case IOCTL_AFD_RECEIVE_DATAGRAM:
                    params->RequestType = WS2IFSL_REQUEST_RECVFROM;
                    params->DataLen = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
                    params->AddrLen = irpSp->Parameters.DeviceIoControl.InputBufferLength;
                    params->Flags = (ULONG)(ULONG_PTR)irp->Tail.Overlay.IfslRequestFlags;
                    break;

                case IOCTL_AFD_RECEIVE:
                    params->RequestType = WS2IFSL_REQUEST_RECV;
                    params->DataLen = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
                    params->AddrLen = 0;
                    params->Flags = (ULONG)(ULONG_PTR)irp->Tail.Overlay.IfslRequestFlags;
                    break;

                case IOCTL_AFD_SEND_DATAGRAM:
                    bytesCopied = CopyMdlChainToBuffer (irp->MdlAddress,
                                        OutputBuffer,
                                        OutputBufferLength);
                    if ((bytesCopied<=irpSp->Parameters.DeviceIoControl.OutputBufferLength)
                            || (ADDR_ALIGN(bytesCopied)+irpSp->Parameters.DeviceIoControl.InputBufferLength
                            < OutputBufferLength)) {
						WsPrint (DBG_RETRIEVE|DBG_FAILURES,
							("WS2IFSL-%04lx RetrieveDrvRequest: Invalid output buffer size (%ld).\n",
							 PsGetCurrentProcessId(),
							 OutputBufferLength));
                        ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
                    }

                    RtlCopyMemory (
                        (PUCHAR)OutputBuffer + ADDR_ALIGN(bytesCopied),
                        irpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                        irpSp->Parameters.DeviceIoControl.InputBufferLength);

                    params->RequestType = WS2IFSL_REQUEST_SENDTO;
                    params->DataLen = bytesCopied;
                    params->AddrLen = irpSp->Parameters.DeviceIoControl.InputBufferLength;
                    params->Flags = (ULONG)(ULONG_PTR)irp->Tail.Overlay.IfslRequestFlags;
                    IoStatus->Information = ADDR_ALIGN(bytesCopied)
                            + irpSp->Parameters.DeviceIoControl.InputBufferLength;
                    break;
                default:
                    ASSERTMSG ("Unknown IOCTL!!!", FALSE);
                    ExRaiseStatus( STATUS_INVALID_PARAMETER );
                }
                break;
            case IRP_MJ_PNP:
                params->RequestType = WS2IFSL_REQUEST_QUERYHANDLE;
                params->DataLen = sizeof (HANDLE);
                params->AddrLen = 0;
                params->Flags = 0;
                break;
            }

            //
            // Insert the request into the socket list
            //
            if (InsertProcessedRequest (SocketCtx, irp)) {
                if (more)
                    IoStatus->Status = STATUS_MORE_ENTRIES;
                else
                    IoStatus->Status = STATUS_SUCCESS;
                WsProcessPrint (ProcessCtx, DBG_RETRIEVE,
                    ("WS2IFSL-%04lx RetrieveDrvRequest:"
                     " Irp %p (id:%ld), socket file %p, op %ld.\n",
                     PsGetCurrentProcessId(),
                     irp, params->UniqueId, irpSp->FileObject,
                     params->RequestType));
            }

            else {
                ExRaiseStatus (STATUS_CANCELLED);
            }
        }
        else {
            WsProcessPrint (ProcessCtx, DBG_RETRIEVE|DBG_FAILURES,
                ("WS2IFSL-%04lx RetrieveDrvRequest:"
                 " Request with id %ld is not in the queue.\n",
                 PsGetCurrentProcessId(),
                 params->UniqueId));
            IoStatus->Status = STATUS_CANCELLED;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Something failed, complete the request (if any)
        //
        IoStatus->Status = GetExceptionCode ();
        WsProcessPrint (ProcessCtx, DBG_RETRIEVE|DBG_FAILURES,
            ("WS2IFSL-%04lx RetrieveDrvRequest: Failed to process"
             " id %ld, status %lx, irp %p (func: %s).\n",
             PsGetCurrentProcessId(),params->UniqueId, IoStatus->Status,
			 irp,	irp
						? (irpSp->MajorFunction==IRP_MJ_READ
							? "read"
							: (irpSp->MajorFunction==IRP_MJ_WRITE
								? "Write"
                                : (irpSp->MajorFunction==IRP_MJ_PNP
								    ? "PnP"
                                    : (irpSp->Parameters.DeviceIoControl.IoControlCode==IOCTL_AFD_RECEIVE_DATAGRAM
									    ? "RecvFrom"
									    : (irpSp->Parameters.DeviceIoControl.IoControlCode==IOCTL_AFD_RECEIVE
										    ? "Recv"
										    : (irpSp->Parameters.DeviceIoControl.IoControlCode==IOCTL_AFD_SEND_DATAGRAM
											    ? "SendTo"
											    : "UnknownCtl"
											    )
                                            )
										)
									)
								)
							)
						: "Unknown"));

        if (irp!=NULL) {
            irp->IoStatus.Status = IoStatus->Status;
            irp->IoStatus.Information = 0;
            CompleteSocketIrp (irp);
        }
    }
}

VOID
CompleteDrvCancel (
    IN PFILE_OBJECT     ProcessFile,
    IN KPROCESSOR_MODE  RequestorMode,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    OUT PVOID           OutputBuffer,
    IN ULONG            OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    Indicates that user mode has completed cancel request
Arguments:
    ProcessFile         - Identifies the process
    InputBuffer         - input buffer pointer
                                - identifies the request being completed
    InputBufferLength   - size of the input buffer
    OutputBuffer        - NULL
    OutputBufferLength  - 0
    IoStatus            - IO status information block
        Status: STATUS_SUCCESS - operation completed OK, no more pending
                                 requests in the queue.
                STATUS_MORE_ENTRIES - operation completed OK, more requests
                                      are available in the queue
        Information:            - 0

Return Value:
    None (result returned via IoStatus block)
--*/
{
    PIFSL_PROCESS_CTX       ProcessCtx = ProcessFile->FsContext;
    PWS2IFSL_CNCL_PARAMS    params;
    BOOLEAN                 more = FALSE;
    PIFSL_CANCEL_CTX        cancelCtx;

    PAGED_CODE();

    IoStatus->Information = 0;

    if (InputBufferLength<sizeof (*params)) {
        WsPrint (DBG_RETRIEVE|DBG_FAILURES,
            ("WS2IFSL-%04lx CompleteDrvCancel: Invalid input buffer size (%ld)"
             " for process file %p.\n",
             PsGetCurrentProcessId(),
             InputBufferLength,
             ProcessFile));
        IoStatus->Status = STATUS_INVALID_PARAMETER;
        return;
    }

    // Verify input buffer
    try {
        if (RequestorMode!=KernelMode) {
            ProbeForRead (InputBuffer,
                            sizeof (*params),
                            sizeof (ULONG));
        }
        params = InputBuffer;
        cancelCtx = DequeueCancel (ProcessCtx,
                                    params->UniqueId,
                                    &more);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        IoStatus->Status = GetExceptionCode ();
        WsPrint (DBG_RETRIEVE|DBG_FAILURES,
            ("WS2IFSL-%04lx CompleteDrvCancel: Invalid input buffer (%p).\n",
             PsGetCurrentProcessId(),
             InputBuffer));
        return ;
    }

    if (cancelCtx!=NULL) {
        FreeSocketCancel (cancelCtx);
    }
    else {
        WsProcessPrint (ProcessCtx, DBG_RETRIEVE|DBG_FAILURES,
            ("WS2IFSL-%04lx CompleteDrvCancel: Canceled request id %ld is gone already.\n",
             PsGetCurrentProcessId(), params->UniqueId));
    }

    if (more) {
        IoStatus->Status = STATUS_MORE_ENTRIES;
    }
    else {
        IoStatus->Status = STATUS_SUCCESS;
    }

}


VOID
CallCompleteDrvRequest (
    IN PFILE_OBJECT     ProcessFile,
    IN KPROCESSOR_MODE  RequestorMode,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    OUT PVOID           OutputBuffer,
    IN ULONG            OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    Validate parameters and call to complete request that was
    prviously passed to user mode DLL on a specified socket file
Arguments:
    SocketFile          - Socket file on which to operate
    InputBuffer         - input buffer pointer
                            identifies the request to complete and
                            supplies description of the results
    InputBufferLength   - size of the input buffer
    OutputBuffer        - result buffer (data and address)
    OutputBufferLength  - sizeof result buffer
    IoStatus            - IO status information block
        Status: STATUS_SUCCESS - request was completed OK
                STATUS_CANCELLED - request was already cancelled
                STATUS_INVALID_PARAMETER - one of the parameters was invalid

Return Value:
    None (result returned via IoStatus block)
--*/
{
    WS2IFSL_CMPL_PARAMS params;
    PFILE_OBJECT    SocketFile;

    PAGED_CODE();

    IoStatus->Information = 0;

    if (InputBufferLength<sizeof (WS2IFSL_CMPL_PARAMS)) {
        IoStatus->Status = STATUS_INVALID_PARAMETER;
        WsPrint (DBG_DRV_COMPLETE|DBG_FAILURES,
            ("WS2IFSL-%04lx CompleteDrvRequest: Invalid input buffer size (%ld).\n",
             PsGetCurrentProcessId(),
             InputBufferLength));
        return;
    }

    // Check and copy parameters
    try {
        if (RequestorMode !=KernelMode) {
            ProbeForRead (InputBuffer,
                            sizeof (WS2IFSL_CMPL_PARAMS),
                            sizeof (ULONG));
            if (OutputBufferLength>0)
                ProbeForRead (OutputBuffer,
                            OutputBufferLength,
                            sizeof (UCHAR));
        }
        params = *((PWS2IFSL_CMPL_PARAMS)InputBuffer);

    }
    except(EXCEPTION_EXECUTE_HANDLER) {
        IoStatus->Status = GetExceptionCode ();
        WsProcessPrint (
             (PIFSL_PROCESS_CTX)ProcessFile->FsContext,
             DBG_DRV_COMPLETE|DBG_FAILURES,
            ("WS2IFSL-%04lx CallCompleteDrvRequest: Exception accessing"
             " buffers.\n",
             PsGetCurrentProcessId()));
        return;
    }
    if (params.DataLen>OutputBufferLength) {
        IoStatus->Status = STATUS_INVALID_PARAMETER;
        WsPrint (DBG_DRV_COMPLETE|DBG_FAILURES,
            ("WS2IFSL-%04lx CompleteDrvRequest: Mismatch in output buffer size"
            " (data:%ld, total:%ld) for socket handle %p.\n",
             PsGetCurrentProcessId(),
             params.DataLen,
             OutputBufferLength,
             params.SocketHdl));
        return;
    }

    if (params.AddrLen>0) {
        if ((params.AddrLen>OutputBufferLength) ||
                (ADDR_ALIGN(params.DataLen)+params.AddrLen
                    >OutputBufferLength)) {
            WsPrint (DBG_DRV_COMPLETE|DBG_FAILURES,
                ("WS2IFSL-%04lx CompleteDrvRequest: Mismatch in output buffer size"
                " (data:%ld, addr:%ld, total:%ld) for socket handle %p.\n",
                 PsGetCurrentProcessId(),
                 params.DataLen,
                 params.AddrLen,
                 OutputBufferLength,
                 params.SocketHdl));
            return;
        }
    }

    IoStatus->Status = ObReferenceObjectByHandle (
                 params.SocketHdl,
                 FILE_ALL_ACCESS,
                 *IoFileObjectType,
                 RequestorMode,
                 (PVOID *)&SocketFile,
                 NULL
                 );

    if (NT_SUCCESS (IoStatus->Status)) {

        if ((IoGetRelatedDeviceObject (SocketFile)==DeviceObject)
                && ((*((PULONG)SocketFile->FsContext))
                        ==SOCKET_FILE_EANAME_TAG)) {
            CompleteDrvRequest (SocketFile,
                                &params,
                                OutputBuffer,
                                OutputBufferLength,
                                IoStatus
                                );
        }

        ObDereferenceObject (SocketFile);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\ws2ifsl\queue.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    process.h

Abstract:

    This module contains declarations of functions and globals
    for queue processing routines in ws2ifsl.sys driver.

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:

    Vadim Eydelman (VadimE)    Oct-1997, rewrite to properly handle IRP
                                        cancellation
--*/


VOID
InitializeRequestQueue (
    IN PIFSL_PROCESS_CTX    ProcessCtx,
    IN PKTHREAD             ApcThread,
    IN KPROCESSOR_MODE      ApcMode,
    IN PKNORMAL_ROUTINE     ApcRoutine,
    IN PVOID                ApcContext
    );

VOID
InitializeCancelQueue (
    IN PIFSL_PROCESS_CTX    ProcessCtx,
    IN PKTHREAD             ApcThread,
    IN KPROCESSOR_MODE      ApcMode,
    IN PKNORMAL_ROUTINE     ApcRoutine,
    IN PVOID                ApcContext
    );

BOOLEAN
QueueRequest (
    IN PIFSL_PROCESS_CTX    ProcessCtx,
    IN PIRP                 Irp
    );

PIRP
DequeueRequest (
    PIFSL_PROCESS_CTX   ProcessCtx,
    ULONG               UniqueId,
    BOOLEAN             *more
    );

VOID
CleanupQueuedRequests (
    IN  PIFSL_PROCESS_CTX       ProcessCtx,
    IN  PFILE_OBJECT            SocketFile,
    OUT PLIST_ENTRY             IrpList
    );

VOID
CancelQueuedRequest (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
    );

VOID
QueueCancel (
    IN PIFSL_PROCESS_CTX    ProcessCtx,
    IN PIFSL_CANCEL_CTX     CancelCtx
    );

PIFSL_CANCEL_CTX
DequeueCancel (
    PIFSL_PROCESS_CTX   ProcessCtx,
    ULONG               UniqueId,
    BOOLEAN             *more
    );

BOOLEAN
RemoveQueuedCancel (
    PIFSL_PROCESS_CTX   ProcessCtx,
    PIFSL_CANCEL_CTX    CancelCtx
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\ws2ifsl\queue.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    queue.c

Abstract:

    This module implements IRP queue processing routines for ws2ifsl.sys driver.

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:

    Vadim Eydelman (VadimE)    Oct-1997, rewrite to properly handle IRP
                                        cancellation
--*/

#include "precomp.h"

//
// Private prototypes
//

VOID
QueueKernelRoutine (
    IN struct _KAPC *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID *NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    );

VOID
SignalRequest (
	IN PIFSL_PROCESS_CTX		ProcessCtx
	);

VOID
RequestRundownRoutine (
    IN struct _KAPC *Apc
    );

VOID
FlushRequestQueue (
    PIFSL_QUEUE Queue
    );

VOID
QueuedCancelRoutine (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
    );

VOID
SignalCancel (
	IN PIFSL_PROCESS_CTX		ProcessCtx
	);

VOID
CancelRundownRoutine (
    IN struct _KAPC *Apc
    );

VOID
FlushCancelQueue (
    PIFSL_QUEUE Queue
    );



#pragma alloc_text(PAGE, InitializeRequestQueue)
#pragma alloc_text(PAGE, InitializeCancelQueue)

VOID
InitializeRequestQueue (
    IN PIFSL_PROCESS_CTX    ProcessCtx,
    IN PKTHREAD             ApcThread,
    IN KPROCESSOR_MODE      ApcMode,
    IN PKNORMAL_ROUTINE     ApcRoutine,
    IN PVOID                ApcContext
    )
/*++

Routine Description:

    Initializes request queue object

Arguments:
    ProcessCtx   - process context to which queue belongs
    ApcThread    - thread to which to queue APC requests for processing
    ApcMode      - mode of the caller (should be user)
    ApcRoutine   - routine that processes requests
    ApcContext   - context to pass to the routine in addition to request
                    parameters

Return Value:
    None
--*/
{
	PAGED_CODE ();

    InitializeListHead (&ProcessCtx->RequestQueue.ListHead);
    ProcessCtx->RequestQueue.Busy = FALSE;
    KeInitializeSpinLock (&ProcessCtx->RequestQueue.Lock);
    KeInitializeApc (&ProcessCtx->RequestQueue.Apc,
                        ApcThread,
                        OriginalApcEnvironment,
                        QueueKernelRoutine,
                        RequestRundownRoutine,
                        ApcRoutine,
                        ApcMode,
                        ApcContext);
}


BOOLEAN
QueueRequest (
    IN PIFSL_PROCESS_CTX    ProcessCtx,
    IN PIRP                 Irp
    )
/*++

Routine Description:

    Queues IRP to IFSL request queue and signals to user mode DLL
    to start processing if it is not busy already.

Arguments:
    ProcessCtx   - process context in which to queue
    Irp          - request to be queued

Return Value:
    TRUE    - IRP was queued
    FALSE   - IRP was already cancelled

--*/
{
	BOOLEAN		res;
    KIRQL       oldIRQL;
	PIFSL_QUEUE	queue = &ProcessCtx->RequestQueue;

    IoSetCancelRoutine (Irp, QueuedCancelRoutine);
    KeAcquireSpinLock (&queue->Lock, &oldIRQL);
    if (!Irp->Cancel) {
		//
		// Request is not cancelled, insert it into the queue
		//
        InsertTailList (&queue->ListHead, &Irp->Tail.Overlay.ListEntry);
        Irp->Tail.Overlay.IfslRequestQueue = queue;

		//
		// If queue wasn't busy, signal to user mode DLL to pick up new request
		//
        if (!queue->Busy) {
			ASSERT (queue->ListHead.Flink==&Irp->Tail.Overlay.ListEntry);
            SignalRequest (ProcessCtx);
            ASSERT (queue->Busy);
        }
        res = TRUE;
    }
    else {
        res = FALSE;
    }
    KeReleaseSpinLock (&queue->Lock, oldIRQL);

	return res;

} // QueueRequest

PIRP
DequeueRequest (
    PIFSL_PROCESS_CTX   ProcessCtx,
    ULONG               UniqueId,
    BOOLEAN             *more
    )
/*++

Routine Description:

    Removes IRP from IFSL request queue.

Arguments:
    ProcessCtx  - process context from which to remove
    UniqueId    - unique request id
    more        - set to TRUE if there are more requests in the queue

Return Value:
    IRP         - pointer to the IRP
    NULL        - the request was not in the queue

--*/
{
    KIRQL       oldIRQL;
    PIRP        irp;
    PIFSL_QUEUE queue = &ProcessCtx->RequestQueue;

    KeAcquireSpinLock (&queue->Lock, &oldIRQL);
    irp = CONTAINING_RECORD (queue->ListHead.Flink, IRP, Tail.Overlay.ListEntry);
    if (!IsListEmpty (&queue->ListHead)
            && (irp->Tail.Overlay.IfslRequestId==UlongToPtr(UniqueId))) {
		//
		// Queue is not empty and first request matches passed in parameters,
		// dequeue and return it
		//

		ASSERT (queue->Busy);
        
        RemoveEntryList (&irp->Tail.Overlay.ListEntry);
        irp->Tail.Overlay.IfslRequestQueue = NULL;
    }
    else {
        irp = NULL;
    }

    if (IsListEmpty (&queue->ListHead)) {
		//
		// Queue is now empty, change its state, so that new request knows to
		// signal to user mode DLL
		//
        queue->Busy = FALSE;
    }
    else {
		//
		// There is another request pending, signal it now
		//
        SignalRequest (ProcessCtx);
        ASSERT (queue->Busy);
    }
	//
	// Hint the caller that we just signalled, so it does not have to wait on event
	//
    *more = queue->Busy;

    KeReleaseSpinLock (&queue->Lock, oldIRQL);
    return irp;
}


VOID
SignalRequest (
	IN PIFSL_PROCESS_CTX		ProcessCtx
	)
/*++

Routine Description:

    Fills request parameters & signals user mode DLL to process the request

Arguments:
    ProcessCtx   - our context for the process which IRP belongs to

Return Value:
    None
Note:
	SHOULD ONLY BE CALLED WITH QUEUE SPINLOCK HELD
--*/
{
    PIRP                    irp;
    PIO_STACK_LOCATION      irpSp;
    ULONG                   bufferLen;

    ASSERT (!IsListEmpty (&ProcessCtx->RequestQueue.ListHead));


    irp = CONTAINING_RECORD (
                        ProcessCtx->RequestQueue.ListHead.Flink,
                        IRP,
                        Tail.Overlay.ListEntry
                        );
    irpSp = IoGetCurrentIrpStackLocation (irp);

    switch (irpSp->MajorFunction) {
    case IRP_MJ_READ:
        bufferLen = irpSp->Parameters.Read.Length;;
        break;
    case IRP_MJ_WRITE:
        bufferLen = irpSp->Parameters.Write.Length;
        break;
    case IRP_MJ_DEVICE_CONTROL:
        switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
        case IOCTL_AFD_RECEIVE_DATAGRAM:
            bufferLen = ADDR_ALIGN(irpSp->Parameters.DeviceIoControl.OutputBufferLength)
                        + irpSp->Parameters.DeviceIoControl.InputBufferLength;
            break;
        case IOCTL_AFD_RECEIVE:
            bufferLen = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
            break;
        case IOCTL_AFD_SEND_DATAGRAM:
            bufferLen = ADDR_ALIGN(irpSp->Parameters.DeviceIoControl.OutputBufferLength)
                        + irpSp->Parameters.DeviceIoControl.InputBufferLength;
            break;
        }
        break;
    case IRP_MJ_PNP:
        bufferLen = sizeof (HANDLE);
        break;
    default:
        ASSERT (FALSE);
        break;
    }

    if (KeInsertQueueApc (&ProcessCtx->RequestQueue.Apc,
                                irp->Tail.Overlay.IfslRequestId,
                                UlongToPtr(bufferLen),
                                IO_NETWORK_INCREMENT)) {
        WsProcessPrint (ProcessCtx, DBG_QUEUE,
            ("WS2IFSL-%04lx SignalRequest: Irp %p (id %ld) on socket %p.\n",
             PsGetCurrentProcessId(),
             irp, irp->Tail.Overlay.IfslRequestId,
		     irpSp->FileObject));
        ProcessCtx->RequestQueue.Busy = TRUE;
    }
    else {
        WsProcessPrint (ProcessCtx, DBG_QUEUE|DBG_FAILURES,
            ("WS2IFSL-%04lx KeInsertQueueApc failed: Irp %p (id %ld) on socket %p.\n",
             PsGetCurrentProcessId(),
             irp, irp->Tail.Overlay.IfslRequestId,
		     irpSp->FileObject));
        //
        // APC queing failed, cancel all outstanding requests.
        //
        FlushRequestQueue (&ProcessCtx->RequestQueue);
    }

} // SignalRequest

VOID
QueueKernelRoutine (
    IN struct _KAPC *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID *NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    )
{
    NOTHING;
}

VOID
RequestRundownRoutine (
    IN struct _KAPC *Apc
    )
/*++

Routine Description:

    APC rundown routine for request queue APC
    Flushes the queue and marks it as not busy so new
    request fail immediately as well.
Arguments:
    APC     - cancel queue APC structure
Return Value:
    None
--*/
{
    PIFSL_QUEUE Queue;
    KIRQL       oldIrql;

    Queue = CONTAINING_RECORD (Apc, IFSL_QUEUE, Apc);
    KeAcquireSpinLock (&Queue->Lock, &oldIrql);
    Queue->Busy = FALSE;
    FlushRequestQueue (Queue);
    KeReleaseSpinLock (&Queue->Lock, oldIrql);
}


VOID
FlushRequestQueue (
    PIFSL_QUEUE Queue
    )
/*++

Routine Description:

    Flushes and completes IRPs in the request queue
Arguments:
    Queue   - request queue to flush
Return Value:
    None
Note:
	SHOULD ONLY BE CALLED WITH QUEUE SPINLOCK HELD
--*/
{
    while (!IsListEmpty (&Queue->ListHead)) {
        PIRP irp = CONTAINING_RECORD (Queue->ListHead.Flink,
                                            IRP,
                                            Tail.Overlay.ListEntry);
        RemoveEntryList (&irp->Tail.Overlay.ListEntry);
        irp->Tail.Overlay.IfslRequestQueue = NULL;
        KeReleaseSpinLockFromDpcLevel (&Queue->Lock);
        irp->IoStatus.Information = 0;
        irp->IoStatus.Status = STATUS_CANCELLED;
        CompleteSocketIrp (irp);
        KeAcquireSpinLockAtDpcLevel (&Queue->Lock);
    }
}

VOID
CleanupQueuedRequests (
    IN  PIFSL_PROCESS_CTX       ProcessCtx,
    IN  PFILE_OBJECT            SocketFile,
    OUT PLIST_ENTRY             IrpList
    )
/*++

Routine Description:

    Cleans up all IRPs associated with a socket file object from the request
    queue

Arguments:
    ProcessCtx  - process context to which queue belongs
    SocketFile  - socket file object for which to remove requests
    IrpList     - list head to hold the IRPs removed from the queue

Return Value:
    None
--*/
{
    KIRQL               oldIRQL;
    PLIST_ENTRY         entry;
	PIFSL_QUEUE			queue = &ProcessCtx->RequestQueue;

    KeAcquireSpinLock (&queue->Lock, &oldIRQL);
    entry = queue->ListHead.Flink;
    while (entry!=&queue->ListHead) {
        PIRP    irp = CONTAINING_RECORD (entry, IRP, Tail.Overlay.ListEntry);
        PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation (irp);

        entry = entry->Flink;
        if (irpSp->FileObject==SocketFile) {
            RemoveEntryList (&irp->Tail.Overlay.ListEntry);
            irp->Tail.Overlay.IfslRequestQueue = NULL;
            InsertTailList (IrpList, &irp->Tail.Overlay.ListEntry);
        }
    }
    KeReleaseSpinLock (&queue->Lock, oldIRQL);
}

VOID
QueuedCancelRoutine (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
    )
/*++

Routine Description:

    Driver cancel routine for socket request waiting in the queue
    to be reported to user mode DLL.

Arguments:
    DeviceObject - WS2IFSL device object
    Irp          - Irp to be cancelled

Return Value:
    None
--*/
{
    PIO_STACK_LOCATION      irpSp;
    PIFSL_SOCKET_CTX        SocketCtx;
    PIFSL_PROCESS_CTX       ProcessCtx;

    irpSp = IoGetCurrentIrpStackLocation (Irp);

    SocketCtx = irpSp->FileObject->FsContext;
    ProcessCtx = SocketCtx->ProcessRef->FsContext;

    WsProcessPrint (ProcessCtx, DBG_QUEUE,
              ("WS2IFSL-%04lx CancelQueuedRequest: Socket %p , Irp %p\n",
              PsGetCurrentProcessId(),
              irpSp->FileObject, Irp));
    KeAcquireSpinLockAtDpcLevel (&ProcessCtx->RequestQueue.Lock);
    if (Irp->Tail.Overlay.IfslRequestQueue!=NULL) {
        ASSERT (Irp->Tail.Overlay.IfslRequestQueue==&ProcessCtx->RequestQueue);
		//
		// Request was in the queue, remove and cancel it here
		//
        RemoveEntryList (&Irp->Tail.Overlay.ListEntry);
        Irp->Tail.Overlay.IfslRequestQueue = NULL;
        KeReleaseSpinLockFromDpcLevel (&ProcessCtx->RequestQueue.Lock);
        IoReleaseCancelSpinLock (Irp->CancelIrql);

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_CANCELLED;
        CompleteSocketIrp (Irp);
    }
    else {
		//
		// Request was not in the queue, whoever removed should note the
		// cancel flag and properly deal with it
		//
        KeReleaseSpinLockFromDpcLevel (&ProcessCtx->RequestQueue.Lock);
        IoReleaseCancelSpinLock (Irp->CancelIrql);
        //
        // Don't touch IRP after this as we do not own it anymore
        //
    }
}

VOID
InitializeCancelQueue (
    IN PIFSL_PROCESS_CTX    ProcessCtx,
    IN PKTHREAD             ApcThread,
    IN KPROCESSOR_MODE      ApcMode,
    IN PKNORMAL_ROUTINE     ApcRoutine,
    IN PVOID                ApcContext
    )
/*++

Routine Description:

    Initializes cancel queue object

Arguments:
    ProcessCtx   - process context to which queue belongs
    ApcThread    - thread to which to queue APC requests for processing
    ApcMode      - mode of the caller (should be user)
    ApcRoutine   - routine that processes requests
    ApcContext   - context to pass to the routine in addition to request
                    parameters

Return Value:
    None
--*/
{
	PAGED_CODE ();

    InitializeListHead (&ProcessCtx->CancelQueue.ListHead);
    ProcessCtx->CancelQueue.Busy = FALSE;
    KeInitializeSpinLock (&ProcessCtx->CancelQueue.Lock);
    KeInitializeApc (&ProcessCtx->CancelQueue.Apc,
                        ApcThread,
                        OriginalApcEnvironment,
                        QueueKernelRoutine,
                        CancelRundownRoutine,
                        ApcRoutine,
                        ApcMode,
                        ApcContext);
}



VOID
QueueCancel (
    IN PIFSL_PROCESS_CTX    ProcessCtx,
    IN PIFSL_CANCEL_CTX     CancelCtx
    )
/*++

Routine Description:

    Queues cancel request to IFSL cancel queue and signals to user mode DLL
    to start processing if it is not busy already.

Arguments:
    ProcessCtx  - process context in which to queue
    CancelCtx   - request to be queued

Return Value:
    None

--*/
{
    KIRQL                   oldIRQL;
	PIFSL_QUEUE				queue = &ProcessCtx->CancelQueue;
    
    KeAcquireSpinLock (&queue->Lock, &oldIRQL);
    InsertTailList (&queue->ListHead, &CancelCtx->ListEntry);
    ASSERT (CancelCtx->ListEntry.Flink != NULL);
    if (!queue->Busy) {
		ASSERT (queue->ListHead.Flink==&CancelCtx->ListEntry);
        SignalCancel (ProcessCtx);
        ASSERT (ProcessCtx->CancelQueue.Busy);
    }
    KeReleaseSpinLock (&queue->Lock, oldIRQL);

} // QueueCancel


PIFSL_CANCEL_CTX
DequeueCancel (
    PIFSL_PROCESS_CTX   ProcessCtx,
    ULONG               UniqueId,
    BOOLEAN             *more
    )
/*++

Routine Description:

    Removes cancel request from IFSL cancel queue.

Arguments:
    ProcessCtx  - process context from which to remove
    UniqueId    - unique cancel request id
    more        - set to TRUE if there are more requests in the queue

Return Value:
    CTX         - pointer to cancel request context
    NULL        - the request was not in the queue

--*/
{
    KIRQL               oldIRQL;
    PIFSL_CANCEL_CTX    cancelCtx;
    PIFSL_QUEUE         queue = &ProcessCtx->CancelQueue;


    KeAcquireSpinLock (&queue->Lock, &oldIRQL);
    cancelCtx = CONTAINING_RECORD (
                        queue->ListHead.Flink,
                        IFSL_CANCEL_CTX,
                        ListEntry
                        );
    if (!IsListEmpty (&queue->ListHead)
            && (cancelCtx->UniqueId==UniqueId)) {
		//
		// Queue is not empty and first request matches passed in parameters,
		// dequeue and return it
		//

		ASSERT (queue->Busy);
        
		RemoveEntryList (&cancelCtx->ListEntry);
        cancelCtx->ListEntry.Flink = NULL;
    }
    else
        cancelCtx = NULL;

    if (IsListEmpty (&queue->ListHead)) {
		//
		// Queue is now empty, change its state, so that new request knows to
		// signal to user mode DLL
		//
        queue->Busy = FALSE;
    }
    else {
		//
		// There is another request pending, signal it now
		//
        SignalCancel (ProcessCtx);
        ASSERT (queue->Busy);
    }
	//
	// Hint the caller that we just signalled, so it does not have to wait on event
	//
    *more = queue->Busy;

    KeReleaseSpinLock (&queue->Lock, oldIRQL);
    return cancelCtx;
}


VOID
SignalCancel (
	IN PIFSL_PROCESS_CTX		ProcessCtx
	)
/*++

Routine Description:

    Fills request parameters & signals user mode DLL to process the request

Arguments:
    ProcessCtx   - our context for the process which cancel request belongs to

Return Value:
    None

Note:
	SHOULD ONLY BE CALLED WITH QUEUE SPINLOCK HELD

--*/
{
    PIFSL_CANCEL_CTX        cancelCtx;
    PIFSL_SOCKET_CTX        SocketCtx;

    ASSERT (!IsListEmpty (&ProcessCtx->CancelQueue.ListHead));

    ProcessCtx->CancelQueue.Busy = TRUE;

    cancelCtx = CONTAINING_RECORD (
                        ProcessCtx->CancelQueue.ListHead.Flink,
                        IFSL_CANCEL_CTX,
                        ListEntry
                        );
    SocketCtx = cancelCtx->SocketFile->FsContext;

    if (KeInsertQueueApc (&ProcessCtx->CancelQueue.Apc,
                                UlongToPtr(cancelCtx->UniqueId),
                                SocketCtx->DllContext,
                                IO_NETWORK_INCREMENT)) {
        WsProcessPrint (ProcessCtx, DBG_QUEUE,
            ("WS2IFSL-%04lx SignalCancel: Context %p on socket %p (h %p).\n",
             PsGetCurrentProcessId(),
             cancelCtx, cancelCtx->SocketFile, SocketCtx->DllContext));
    }
    else {
        //
        // APC queing failed, cancel all outstanding requests.
        //
        FlushCancelQueue (&ProcessCtx->CancelQueue);
    }

} // SignalCancel

VOID
FlushCancelQueue (
    PIFSL_QUEUE Queue
    )
/*++

Routine Description:

    Flushes and frees entries in the cancel queue
Arguments:
    Queue   - request queue to flush
Return Value:
    None
Note:
	SHOULD ONLY BE CALLED WITH QUEUE SPINLOCK HELD
--*/
{
    while (!IsListEmpty (&Queue->ListHead)) {
        PIFSL_CANCEL_CTX cancelCtx = CONTAINING_RECORD (
                        Queue->ListHead.Flink,
                        IFSL_CANCEL_CTX,
                        ListEntry
                        );
        RemoveEntryList (&cancelCtx->ListEntry);
        cancelCtx->ListEntry.Flink = NULL;
        FreeSocketCancel (cancelCtx);
    }
}


VOID
CancelRundownRoutine (
    IN struct _KAPC *Apc
    )
/*++

Routine Description:

    APC rundown routine for cancel queue APC
    Flushes the queue and marks it as not busy so new
    request fail immediately as well.
Arguments:
    APC     - cancel queue APC structure
Return Value:
    None
--*/
{
    PIFSL_QUEUE Queue;
    KIRQL       oldIrql;

    Queue = CONTAINING_RECORD (Apc, IFSL_QUEUE, Apc);
    KeAcquireSpinLock (&Queue->Lock, &oldIrql);
    Queue->Busy = FALSE;
    FlushCancelQueue (Queue);
    KeReleaseSpinLock (&Queue->Lock, oldIrql);
}


BOOLEAN
RemoveQueuedCancel (
    PIFSL_PROCESS_CTX   ProcessCtx,
    PIFSL_CANCEL_CTX    CancelCtx
    )
/*++

Routine Description:

    Remove cancel request from the cancel queue if it is there

Arguments:
    ProcessCtx  - process context to which queue belongs
    CancelCtx   - request to remove

Return Value:
    None
--*/
{
    KIRQL       oldIRQL;
    BOOLEAN     res;


    // Acquire queue lock
    KeAcquireSpinLock (&ProcessCtx->CancelQueue.Lock, &oldIRQL);
    res = (CancelCtx->ListEntry.Flink!=NULL);
    if (res) {
        RemoveEntryList (&CancelCtx->ListEntry);
        CancelCtx->ListEntry.Flink = NULL;
    }
    KeReleaseSpinLock (&ProcessCtx->CancelQueue.Lock, oldIRQL);
    return res;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\ws2ifsl\process.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    process.h

Abstract:

    This module contains declarations of functions and globals
    for process file object implemetation in ws2ifsl.sys driver.

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:

    Vadim Eydelman (VadimE)    Oct-1997, rewrite to properly handle IRP
                                        cancellation
--*/

// Process file device IO control function pointer
typedef
VOID                                        // Result is returned via IoStatus
(*PPROCESS_DEVICE_CONTROL) (
    IN PFILE_OBJECT     ProcessFile,        // Process file on which to operate
    IN KPROCESSOR_MODE  RequestorMode,      // Mode of the caller
    IN PVOID            InputBuffer,        // Input buffer pointer
    IN ULONG            InputBufferLength,  // Size of the input buffer
    OUT PVOID           OutputBuffer,       // Output buffer pointer
    IN ULONG            OutputBufferLength, // Size of output buffer
    OUT PIO_STATUS_BLOCK IoStatus           // IO status information block
    );

PPROCESS_DEVICE_CONTROL ProcessIoControlMap[3];
ULONG                   ProcessIoctlCodeMap[3];

NTSTATUS
CreateProcessFile (
    IN PFILE_OBJECT                 ProcessFile,
    IN KPROCESSOR_MODE              RequestorMode,
    IN PFILE_FULL_EA_INFORMATION    eaInfo
    );

NTSTATUS
CleanupProcessFile (
    IN PFILE_OBJECT ProcessFile,
    IN PIRP         Irp
    );

VOID
CloseProcessFile (
    IN PFILE_OBJECT ProcessFile
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\ws2ifsl\socket.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    socket.c

Abstract:

    This module implements socket file object for ws2ifsl.sys driver.

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:

    Vadim Eydelman (VadimE)    Oct-1997, rewrite to properly handle IRP
                                        cancellation
--*/

#include "precomp.h"



VOID
SetSocketContext (
    IN PFILE_OBJECT     SocketFile,
    IN KPROCESSOR_MODE  RequestorMode,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    OUT PVOID           OutputBuffer,
    IN ULONG            OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
    );


VOID
CompletePvdRequest (
    IN PFILE_OBJECT     SocketFile,
    IN KPROCESSOR_MODE  RequestorMode,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    OUT PVOID           OutputBuffer,
    IN ULONG            OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
    );

VOID
ProcessedCancelRoutine (
        IN PDEVICE_OBJECT       DeviceObject,
        IN PIRP                         Irp
    );

PIRP
GetProcessedRequest (
    PIFSL_SOCKET_CTX    SocketCtx,
    ULONG               UniqueId
    );

VOID
CleanupProcessedRequests (
    PIFSL_SOCKET_CTX    SocketCtx,
    PLIST_ENTRY         IrpList
    );


VOID
CancelSocketIo (
    PFILE_OBJECT    SocketFile
    );

PFILE_OBJECT
GetSocketProcessReference (
    IN  PIFSL_SOCKET_CTX    SocketCtx
    );

PFILE_OBJECT
SetSocketProcessReference (
    IN  PIFSL_SOCKET_CTX    SocketCtx,
    IN  PFILE_OBJECT        NewProcessFile,
    IN  PVOID               NewDllContext
    );

NTSTATUS
CompleteTargetQuery (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CreateSocketFile)
#pragma alloc_text(PAGE, CleanupSocketFile)
#pragma alloc_text(PAGE, CloseSocketFile)
#pragma alloc_text(PAGE, DoSocketReadWrite)
#pragma alloc_text(PAGE, DoSocketAfdIoctl)
#pragma alloc_text(PAGE, SetSocketContext)
#pragma alloc_text(PAGE, CompleteDrvRequest)
#pragma alloc_text(PAGE, CompletePvdRequest)
#pragma alloc_text(PAGE, SocketPnPTargetQuery)
//#pragma alloc_text (PAGE, CompleteTargetQuery) - should never be paged. 
#endif

ULONG                  SocketIoctlCodeMap[2] = {
#if WS2IFSL_IOCTL_FUNCTION(SOCKET,IOCTL_WS2IFSL_SET_SOCKET_CONTEXT)!=0
#error Mismatch between IOCTL function code and SocketIoControlMap
#endif
    IOCTL_WS2IFSL_SET_SOCKET_CONTEXT,
#if WS2IFSL_IOCTL_FUNCTION(SOCKET,IOCTL_WS2IFSL_COMPLETE_PVD_REQ)!=1
#error Mismatch between IOCTL function code and SocketIoControlMap
#endif
    IOCTL_WS2IFSL_COMPLETE_PVD_REQ
};

PSOCKET_DEVICE_CONTROL SocketIoControlMap[2] = {
    SetSocketContext,
    CompletePvdRequest
};


#define GenerateUniqueId(curId) \
    ((ULONG)InterlockedIncrement (&(curId)))


NTSTATUS
CreateSocketFile (
    IN PFILE_OBJECT                 SocketFile,
    IN KPROCESSOR_MODE              RequestorMode,
    IN PFILE_FULL_EA_INFORMATION    eaInfo
    )
/*++

Routine Description:

    Allocates and initializes socket file context structure.

Arguments:
    SocketFile - socket file object
    eaInfo     - EA for socket file

Return Value:

    STATUS_SUCCESS  - operation completed OK
    STATUS_INSUFFICIENT_RESOURCES - not enough memory to allocate context
--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PIFSL_SOCKET_CTX    SocketCtx;
    HANDLE              hProcessFile;
    PFILE_OBJECT        ProcessFile;
    PVOID               DllContext;

    PAGED_CODE ();

    if (eaInfo->EaValueLength!=WS2IFSL_SOCKET_EA_VALUE_LENGTH) {
        WsPrint (DBG_SOCKET|DBG_FAILURES,
            ("WS2IFSL-%04lx CreateSocketFile: Invalid ea info size (%ld)"
             " for process file %p.\n",
             PsGetCurrentProcessId(),
             eaInfo->EaValueLength,
             SocketFile));
        return STATUS_INVALID_PARAMETER;
    }

    hProcessFile = GET_WS2IFSL_SOCKET_EA_VALUE(eaInfo)->ProcessFile;
    DllContext = GET_WS2IFSL_SOCKET_EA_VALUE(eaInfo)->DllContext;
    // Get reference to the process file with which this context is associated
    status = ObReferenceObjectByHandle(
                 hProcessFile,
                 FILE_ALL_ACCESS,
                 *IoFileObjectType,
                 RequestorMode,
                 (PVOID *)&ProcessFile,
                 NULL
                 );
    if (NT_SUCCESS (status)) {
        // Verify that the file pointer is really our driver's process file
        // and that it created for the current process
        if ((IoGetRelatedDeviceObject (ProcessFile)
                        ==DeviceObject)
                && ((*((PULONG)ProcessFile->FsContext))
                        ==PROCESS_FILE_EANAME_TAG)
                && (((PIFSL_PROCESS_CTX)ProcessFile->FsContext)->UniqueId
                        ==PsGetCurrentProcessId())) {
            // Allocate socket context and charge it to the process
            try {
                SocketCtx = (PIFSL_SOCKET_CTX) ExAllocatePoolWithQuotaTag (
                                                    NonPagedPool,
                                                    sizeof (IFSL_SOCKET_CTX),
                                                    SOCKET_FILE_CONTEXT_TAG);
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                SocketCtx = NULL;
                status = GetExceptionCode ();
            }

            if (SocketCtx!=NULL) {
                WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_SOCKET,
                    ("WS2IFSL-%04lx CreateSocketFile: Created socket %p (ctx:%p)\n",
                        PsGetCurrentProcessId(), SocketFile, SocketCtx));
                // Initialize socket context structure
                SocketCtx->EANameTag = SOCKET_FILE_EANAME_TAG;
                SocketCtx->DllContext = DllContext;
                SocketCtx->ProcessRef = ProcessFile;
                InitializeListHead (&SocketCtx->ProcessedIrps);
                KeInitializeSpinLock (&SocketCtx->SpinLock);
                SocketCtx->CancelCtx = NULL;
                SocketCtx->IrpId = 0;

                // Associate socket context with socket file
                SocketFile->FsContext = SocketCtx;

                return status;
            }
            else {
                WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_FAILURES|DBG_SOCKET,
                    ("WS2IFSL-%04lx CreateSocketFile: Could not allocate socket context\n",
                        PsGetCurrentProcessId()));
                if (NT_SUCCESS (status)) {
                    ASSERT (FALSE);
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }
        else {
            // Handle refers to random file object
            WsPrint (DBG_SOCKET|DBG_FAILURES,
                ("WS2IFSL-%04lx CreateSocketFile: Procees file handle %p (File:%p)"
                 " is not valid\n",
                 PsGetCurrentProcessId(),
                 ProcessFile, hProcessFile));
            status = STATUS_INVALID_PARAMETER;
        }
        ObDereferenceObject (ProcessFile);
    }
    else {
        WsPrint (DBG_SOCKET|DBG_FAILURES,
            ("WS2IFSL-%04lx CreateSocketFile: Could not get process file from handle %p,"
             " status:%lx.\n",
             PsGetCurrentProcessId(),
             hProcessFile,
             status));
    }

    return status;
} // CreateSocketFile


NTSTATUS
CleanupSocketFile (
    IN PFILE_OBJECT SocketFile,
    IN PIRP         Irp
    )
/*++

Routine Description:

    Initiates socket file cleanup in context of current process.

Arguments:
    SocketFile  - socket file object
    Irp         - cleanup request

Return Value:

    STATUS_PENDING  - operation initiated OK
    STATUS_INVALID_HANDLE - socket has not been initialized
                        in current process
--*/
{
    NTSTATUS                status;
    PIFSL_SOCKET_CTX        SocketCtx;
    PFILE_OBJECT            ProcessFile;
    LIST_ENTRY              irpList;
    PIFSL_CANCEL_CTX        cancelCtx;

    PAGED_CODE ();
    SocketCtx = SocketFile->FsContext;
    ProcessFile = GetSocketProcessReference (SocketCtx);
    WsProcessPrint ((PIFSL_PROCESS_CTX)SocketCtx->ProcessRef->FsContext, DBG_SOCKET,
        ("WS2IFSL-%04lx CleanupSocketFile: Socket %p \n",
        PsGetCurrentProcessId(), SocketFile));
    //
    // Build the list of IRPS still panding on this socket
    //
    InitializeListHead (&irpList);
    CleanupQueuedRequests (ProcessFile->FsContext,
                            SocketFile,
                            &irpList);
    CleanupProcessedRequests (SocketCtx, &irpList);

            //
            // Complete the cancelled IRPS
            //
    while (!IsListEmpty (&irpList)) {
        PLIST_ENTRY entry;
        PIRP        irp;
        entry = RemoveHeadList (&irpList);
        irp = CONTAINING_RECORD (entry, IRP, Tail.Overlay.ListEntry);
        irp->IoStatus.Status = STATUS_CANCELLED;
        irp->IoStatus.Information = 0;
        WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_SOCKET,
            ("WS2IFSL-%04lx CleanupSocketFile: Cancelling Irp %p on socket %p \n",
            PsGetCurrentProcessId(), irp, SocketFile));
        CompleteSocketIrp (irp);
    }

    //
    // Indicate that cleanup routine is going to take care of the
    // pending cancel request if any.
    //
    cancelCtx = InterlockedExchangePointer (
                                    (PVOID *)&SocketCtx->CancelCtx,
                                    NULL);
    if (cancelCtx!=NULL) {
        //
        // We are going to try to free this request if it is still in the queue
        //
        WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_SOCKET,
            ("WS2IFSL-%04lx CleanupSocketFile: Removing cancel ctx %p on socket %p \n",
            PsGetCurrentProcessId(), cancelCtx, SocketFile));
        if (RemoveQueuedCancel (ProcessFile->FsContext, cancelCtx)) {
            //
            // Request was in the queue, it is safe to call regular free routine
            // (no-one else will find it now, so it is safe to put the pointer
            // back in place so that FreeSocketCancel can free it)
            //
            SocketCtx->CancelCtx = cancelCtx;
            FreeSocketCancel (cancelCtx);
        }
        else {
            //
            // Someone else managed to remove the request from the queue before
            // we did, let them or close routine free it. We aren't going to
            // touch it after this.
            //
            SocketCtx->CancelCtx = cancelCtx;
        }
    }

    status = STATUS_SUCCESS;

    ObDereferenceObject (ProcessFile);
    return status;
} // CleanupSocketFile


VOID
CloseSocketFile (
    IN PFILE_OBJECT SocketFile
    )
/*++

Routine Description:

    Deallocates all resources associated with socket file

Arguments:
    SocketFile  - socket file object

Return Value:
    None
--*/
{
    PIFSL_SOCKET_CTX    SocketCtx = SocketFile->FsContext;

    PAGED_CODE ();
    WsProcessPrint ((PIFSL_PROCESS_CTX)SocketCtx->ProcessRef->FsContext, DBG_SOCKET,
        ("WS2IFSL-%04lx CloseSocketFile: Socket %p \n",
         GET_SOCKET_PROCESSID(SocketCtx), SocketFile));

    // First dereference process file
    ObDereferenceObject (SocketCtx->ProcessRef);

    if (SocketCtx->CancelCtx!=NULL) {
        ExFreePool (SocketCtx->CancelCtx);
    }

    // Free context
    ExFreePool (SocketCtx);

} // CloseSocketFile

NTSTATUS
DoSocketReadWrite (
    IN PFILE_OBJECT SocketFile,
    IN PIRP         Irp
    )
/*++

Routine Description:

    Initiates read and write request processing on socket file.

Arguments:
    SocketFile  - socket file object
    Irp         - read/write request

Return Value:

    STATUS_PENDING  - operation initiated OK
    STATUS_INVALID_HANDLE - socket has not been initialized
                        in current process
--*/
{
    NTSTATUS                status;
    PIFSL_SOCKET_CTX        SocketCtx;
    PFILE_OBJECT            ProcessFile;
    PIO_STACK_LOCATION      irpSp;

    PAGED_CODE ();

    irpSp = IoGetCurrentIrpStackLocation (Irp);
    SocketCtx = SocketFile->FsContext;
    ProcessFile = GetSocketProcessReference (SocketCtx);

    if (((PIFSL_PROCESS_CTX)ProcessFile->FsContext)->UniqueId==PsGetCurrentProcessId()) {
        WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_READWRITE,
            ("WS2IFSL-%04lx DoSocketReadWrite: %s irp %p on socket %p, len %ld.\n",
            PsGetCurrentProcessId(),
            irpSp->MajorFunction==IRP_MJ_READ ? "Read" : "Write",
                        Irp, SocketFile,
                        irpSp->MajorFunction==IRP_MJ_READ
                                        ? irpSp->Parameters.Read.Length
                                        : irpSp->Parameters.Write.Length));
        //
        // Allocate MDL to describe the user buffer.
        //
        Irp->MdlAddress = IoAllocateMdl(
                        Irp->UserBuffer,      // VirtualAddress
                        irpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                            // Length
                        FALSE,              // SecondaryBuffer
                        TRUE,               // ChargeQuota
                        NULL                // Irp
                        );
        if (Irp->MdlAddress!=NULL) {

            // We are going to pend this request
            IoMarkIrpPending (Irp);

            // Prepare IRP for insertion into the queue
            Irp->Tail.Overlay.IfslRequestId = UlongToPtr(GenerateUniqueId (SocketCtx->IrpId));
            Irp->Tail.Overlay.IfslRequestFlags = (PVOID)0;
            Irp->Tail.Overlay.IfslAddressLenPtr = NULL;
            Irp->Tail.Overlay.IfslRequestQueue = NULL;
            if (!QueueRequest (ProcessFile->FsContext, Irp)) {
                Irp->IoStatus.Status = STATUS_CANCELLED;
                Irp->IoStatus.Information = 0;
                WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_READWRITE,
                    ("WS2IFSL-%04lx DoSocketReadWrite: Cancelling Irp %p on socket %p.\n",
                    PsGetCurrentProcessId(),
                    Irp, SocketFile));
                CompleteSocketIrp (Irp);
            }

            status = STATUS_PENDING;
        }
        else {
            WsPrint (DBG_SOCKET|DBG_READWRITE|DBG_FAILURES,
                ("WS2IFSL-%04lx DoSocketReadWrite: Failed to allocate Mdl for Irp %p"
                " on socket %p, status %lx.\n",
            PsGetCurrentProcessId(), Irp, SocketFile));;
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {
        status = STATUS_INVALID_HANDLE;
        WsPrint (DBG_SOCKET|DBG_READWRITE|DBG_FAILURES,
            ("WS2IFSL-%04lx DoSocketReadWrite: Socket %p has not"
                " been setup in the process.\n",
            PsGetCurrentProcessId(), SocketFile));
    }

    ObDereferenceObject (ProcessFile);

    return status;
} // DoSocketReadWrite

NTSTATUS
DoSocketAfdIoctl (
    IN PFILE_OBJECT SocketFile,
    IN PIRP         Irp
    )
/*++

Routine Description:

    Initiates read and write request processing on socket file.

Arguments:
    SocketFile  - socket file object
    Irp         - afd IOCTL request

Return Value:

    STATUS_PENDING  - operation initiated OK
    STATUS_INVALID_HANDLE - socket has not been initialized
                        in current process
--*/
{
    NTSTATUS                status;
    PIO_STACK_LOCATION      irpSp;
    PIFSL_SOCKET_CTX        SocketCtx;
    PFILE_OBJECT            ProcessFile;
    LPWSABUF                bufferArray = NULL;
    ULONG                   bufferCount = 0, length = 0, flags = 0;
    PVOID                   address = NULL;
    PULONG                  lengthPtr = NULL;

    PAGED_CODE ();

    irpSp = IoGetCurrentIrpStackLocation (Irp);
    Irp->IoStatus.Information = 0;
    SocketCtx = SocketFile->FsContext;
    ProcessFile = GetSocketProcessReference (SocketCtx);

    if (((PIFSL_PROCESS_CTX)ProcessFile->FsContext)->UniqueId==PsGetCurrentProcessId()) {

        try {
            if (Irp->RequestorMode!=KernelMode) {
                ProbeForRead (
                    irpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                    irpSp->Parameters.DeviceIoControl.InputBufferLength,
                    sizeof (ULONG));
            }
            switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
            case IOCTL_AFD_RECEIVE_DATAGRAM: {
                PAFD_RECV_DATAGRAM_INFO info;

                if (irpSp->Parameters.DeviceIoControl.InputBufferLength
                            < sizeof (*info)) {
                    ExRaiseStatus( STATUS_INVALID_PARAMETER );
                }
                info = irpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                bufferArray = info->BufferArray;
                bufferCount = info->BufferCount;
                address = info->Address;
                lengthPtr = info->AddressLength;
                if ((address == NULL) ^ (lengthPtr == NULL)) {
                    ExRaiseStatus( STATUS_INVALID_PARAMETER );
                }

                if (Irp->RequestorMode!=KernelMode) {
                    ProbeForRead (
                        lengthPtr,
                        sizeof (*lengthPtr),
                        sizeof (ULONG));
                }

                length = *lengthPtr;

                if (address != NULL ) {
                    //
                    // Bomb off if the user is trying to do something bad, like
                    // specify a zero-length address, or one that's unreasonably
                    // huge. Here, we (arbitrarily) define "unreasonably huge" as
                    // anything 64K or greater.
                    //
                    if( length == 0 ||
                        length >= 65536 ) {

                        ExRaiseStatus( STATUS_INVALID_PARAMETER );
                    }

                }
                flags = info->TdiFlags;
                WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_AFDIOCTL,
                        ("WS2IFSL-%04lx DoSocketAfdIoctl: RecvFrom irp %p, socket %p,"
                        " arr %p, cnt %ld, addr %p, lenp %p, len %ld, flags %lx.\n",
                        PsGetCurrentProcessId(), Irp, SocketFile,
                        bufferArray, bufferCount, address, lengthPtr, length, flags));
                break;
            }
            case IOCTL_AFD_RECEIVE: {
                PAFD_RECV_INFO info;
                if (irpSp->Parameters.DeviceIoControl.InputBufferLength
                        < sizeof (*info)) {
                    ExRaiseStatus( STATUS_INVALID_PARAMETER );
                }
                info = irpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                bufferArray = info->BufferArray;
                bufferCount = info->BufferCount;
                flags = info->TdiFlags;
                                WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_AFDIOCTL,
                                        ("WS2IFSL-%04lx DoSocketAfdIoctl: Recv irp %p, socket %p,"
                                        " arr %p, cnt %ld, flags %lx.\n",
                                        PsGetCurrentProcessId(), Irp, SocketFile,
                                        bufferArray, bufferCount, flags));
                break;
            }

            case IOCTL_AFD_SEND_DATAGRAM: {
                PAFD_SEND_DATAGRAM_INFO info;

                if (irpSp->Parameters.DeviceIoControl.InputBufferLength
                        < sizeof (*info)) {
                    ExRaiseStatus( STATUS_INVALID_PARAMETER );
                }
                info = irpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                bufferArray = info->BufferArray;
                bufferCount = info->BufferCount;
                address = &(((PTRANSPORT_ADDRESS)
                    info->TdiConnInfo.RemoteAddress)->Address[0].AddressType);
                length = info->TdiConnInfo.RemoteAddressLength
                    - FIELD_OFFSET (TRANSPORT_ADDRESS, Address[0].AddressType);

                //
                // Bomb off if the user is trying to do something bad, like
                // specify a zero-length address, or one that's unreasonably
                // huge. Here, we (arbitrarily) define "unreasonably huge" as
                // anything 64K or greater.
                //

                if( length == 0 ||
                    length >= 65536 ) {
                    ExRaiseStatus( STATUS_INVALID_PARAMETER );
                }

                if( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead (
                        address,
                        length,
                        sizeof (UCHAR));
                }

                flags = 0;
                WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_AFDIOCTL,
                        ("WS2IFSL-%04lx DoSocketAfdIoctl: SendTo irp %p, socket %p,"
                        " arr %p, cnt %ld, addr %p, len %ld, flags %lx.\n",
                        PsGetCurrentProcessId(), Irp, SocketFile,
                        bufferArray, bufferCount, address, length, flags));
                break;
            }
            default:
                ASSERTMSG ("Unknown IOCTL!!!", FALSE);
                ExRaiseStatus( STATUS_INVALID_PARAMETER );
            }

            AllocateMdlChain (Irp,
                    bufferArray,
                    bufferCount,
                    &irpSp->Parameters.DeviceIoControl.OutputBufferLength);

            WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_AFDIOCTL,
                    ("WS2IFSL-%04lx DoSocketAfdIoctl: %s irp %p, socket %p,"
                    " arr %p, cnt %ld, addr %p, lenp %p, len %ld, flags %lx.\n",
                    PsGetCurrentProcessId(),
                    irpSp->Parameters.DeviceIoControl.IoControlCode==IOCTL_AFD_RECEIVE_DATAGRAM
                            ? "RecvFrom"
                            : (irpSp->Parameters.DeviceIoControl.IoControlCode==IOCTL_AFD_RECEIVE
                                    ? "Recv"
                                    : "SendTo"
                                    ),
                    Irp, SocketFile,
                    bufferArray, bufferCount, address, lengthPtr, length, flags));
        }
        except (EXCEPTION_EXECUTE_HANDLER) {

            status = GetExceptionCode ();
            WsPrint (DBG_SOCKET|DBG_AFDIOCTL|DBG_FAILURES,
                ("WS2IFSL-%04lx DoSocketAfdIoctl: Failed to process Irp %p"
                " on socket %p, status %lx.\n",
            PsGetCurrentProcessId(), Irp, SocketFile, status));;
            goto Exit;
        }

        // We are going to pend this request
        IoMarkIrpPending (Irp);

        // Prepare IRP for insertion into the queue
        irpSp->Parameters.DeviceIoControl.IfslAddressBuffer = address;
        irpSp->Parameters.DeviceIoControl.IfslAddressLength = length;

        Irp->Tail.Overlay.IfslRequestId = UlongToPtr(GenerateUniqueId (SocketCtx->IrpId));
        Irp->Tail.Overlay.IfslAddressLenPtr = lengthPtr;
        Irp->Tail.Overlay.IfslRequestFlags = UlongToPtr(flags);
        Irp->Tail.Overlay.IfslRequestQueue = NULL;

        if (!QueueRequest (ProcessFile->FsContext, Irp)) {
            Irp->IoStatus.Status = STATUS_CANCELLED;
            Irp->IoStatus.Information = 0;
            WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_AFDIOCTL,
                ("WS2IFSL-%04lx DoAfdIoctl: Cancelling Irp %p on socket %p.\n",
                PsGetCurrentProcessId(),
                Irp, SocketFile));
            CompleteSocketIrp (Irp);
        }
        status = STATUS_PENDING;
    }
    else {
        status = STATUS_INVALID_HANDLE;
        WsPrint (DBG_SOCKET|DBG_AFDIOCTL|DBG_FAILURES,
            ("WS2IFSL-%04lx DoSocketAfdIoctl: Socket %p has not"
                " been setup in the process\n",
            PsGetCurrentProcessId(), SocketFile));
    }
Exit:
    ObDereferenceObject (ProcessFile);
    return status;
} // DoSocketAfdIoctl

VOID
SetSocketContext (
    IN PFILE_OBJECT     SocketFile,
    IN KPROCESSOR_MODE  RequestorMode,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    OUT PVOID           OutputBuffer,
    IN ULONG            OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    Sets up socket file in context of a current process: associates it with
    process file and assigns context supplied by the caller

Arguments:
    SocketFile          - Socket file on which to operate
    InputBuffer         - input buffer pointer
    InputBufferLength   - size of the input buffer
    OutputBuffer        - output buffer pointer
    OutputBufferLength  - size of output buffer
    IoStatus            - IO status information block

Return Value:
    None (result returned via IoStatus block)
--*/
{
    PIFSL_SOCKET_CTX        SocketCtx;
    HANDLE                  hProcessFile;
    PFILE_OBJECT            ProcessFile;
    PVOID                   DllContext;

    PAGED_CODE ();

    IoStatus->Information = 0;

    SocketCtx = SocketFile->FsContext;

    // First check arguments
    if (InputBufferLength<sizeof (WS2IFSL_SOCKET_CTX)) {
        IoStatus->Status = STATUS_INVALID_PARAMETER;
        WsPrint (DBG_SOCKET|DBG_FAILURES,
            ("WS2IFSL-%04lx SetSocketContext: Invalid input buffer size (%ld)"
             " for socket file %p.\n",
             PsGetCurrentProcessId(),
             InputBufferLength,
             SocketFile));
        return;
    }

    try {
        if (RequestorMode!=KernelMode) {
            ProbeForRead (InputBuffer,
                            sizeof (WS2IFSL_SOCKET_CTX),
                            sizeof (ULONG));
        }
        hProcessFile = ((PWS2IFSL_SOCKET_CTX)InputBuffer)->ProcessFile;
        DllContext = ((PWS2IFSL_SOCKET_CTX)InputBuffer)->DllContext;
    }
    except(EXCEPTION_EXECUTE_HANDLER) {
        IoStatus->Status = GetExceptionCode ();
        WsPrint (DBG_SOCKET|DBG_FAILURES,
            ("WS2IFSL-%04lx SetSocketContext: Invalid input buffer (%p)"
             " for socket file %p.\n",
             PsGetCurrentProcessId(),
             InputBuffer,
             SocketFile));
        return;
    }

    // Get reference to the process file with which this context is associated
    IoStatus->Status = ObReferenceObjectByHandle(
                 hProcessFile,
                 FILE_ALL_ACCESS,
                 *IoFileObjectType,
                 RequestorMode,
                 (PVOID *)&ProcessFile,
                 NULL
                 );
    if (NT_SUCCESS (IoStatus->Status)) {
        // Verify that the file pointer is really our driver's process file
        // and that it created for the current process
        if ((IoGetRelatedDeviceObject (ProcessFile)
                        ==DeviceObject)
                && ((*((PULONG)ProcessFile->FsContext))
                        ==PROCESS_FILE_EANAME_TAG)
                && (((PIFSL_PROCESS_CTX)ProcessFile->FsContext)->UniqueId
                        ==PsGetCurrentProcessId())) {

            PFILE_OBJECT    oldProcessFile;

            oldProcessFile = SetSocketProcessReference (
                                            SocketCtx,
                                            ProcessFile,
                                            DllContext);

            if (oldProcessFile==ProcessFile) {
                // Old socket, just reset DLL context
                WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_SOCKET,
                    ("WS2IFSL-%04lx ResetSocketContext:"
                    " Socket %p (h:%p->%p)\n",
                     PsGetCurrentProcessId(), SocketFile,
                     SocketCtx->DllContext, DllContext));
            }
            else {
                LIST_ENTRY  irpList;
                // Socket moved to a different process
                WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_SOCKET,
                    ("WS2IFSL-%04lx ResetSocketContext:"
                    " Socket %p (f:%p->%p(h:%p)\n",
                     PsGetCurrentProcessId(), SocketFile,
                     oldProcessFile, ProcessFile, DllContext));

                InitializeListHead (&irpList);

                // Make sure we do not keep IRPs that are queued to
                // the old object as it may go away as soon as we
                // dereference it below.  Note that processed IRPs
                // do not reference process file object in any way.
                CleanupQueuedRequests (oldProcessFile->FsContext, SocketFile, &irpList);
                while (!IsListEmpty (&irpList)) {
                    PLIST_ENTRY entry;
                    PIRP        irp;
                    entry = RemoveHeadList (&irpList);
                    irp = CONTAINING_RECORD (entry, IRP, Tail.Overlay.ListEntry);
                    irp->IoStatus.Status = STATUS_CANCELLED;
                    irp->IoStatus.Information = 0;
                    WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_SOCKET,
                        ("WS2IFSL-%04lx ResetSocketContext: Cancelling Irp %p on socket %p \n",
                        PsGetCurrentProcessId(), irp, SocketFile));
                    CompleteSocketIrp (irp);
                }


                // Dereference the old object below
                ProcessFile = oldProcessFile;

            }
        }
        else {
            // Handle refers to random file object
            WsPrint (DBG_SOCKET|DBG_FAILURES,
                ("WS2IFSL-%04lx SetSocketContext: Procees file handle %p (File:%p)"
                 " is not valid in the process.\n",
                 PsGetCurrentProcessId(),
                 ProcessFile, hProcessFile));
            IoStatus->Status = STATUS_INVALID_PARAMETER;
        }

        ObDereferenceObject (ProcessFile);
    }
    else {
        WsPrint (DBG_SOCKET|DBG_FAILURES,
            ("WS2IFSL-%04lx SetSocketContext: Could not get process file from handle %p,"
             " status:%lx.\n",
             PsGetCurrentProcessId(),
             hProcessFile,
             IoStatus->Status));
    }

} //SetSocketContext



VOID
CompletePvdRequest (
    IN PFILE_OBJECT     SocketFile,
    IN KPROCESSOR_MODE  RequestorMode,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    OUT PVOID           OutputBuffer,
    IN ULONG            OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    Completes this IOCTL to allow completion port usage by non-IFS providers
Arguments:
    SocketFile          - Socket file on which to operate
    InputBuffer         - input buffer pointer
                            contains IoStatus structure to be returned
                            as the result of this call
    InputBufferLength   - size of the input buffer
    OutputBuffer        - NULL
    OutputBufferLength  - 0
    IoStatus            - IO status information block

Return Value:
    None (result returned via IoStatus block)
--*/
{
    PIFSL_SOCKET_CTX    SocketCtx;
    PFILE_OBJECT        ProcessFile;
    PAGED_CODE();

    IoStatus->Information = 0;
    // First check arguments
    if (InputBufferLength<sizeof (IO_STATUS_BLOCK)) {
        IoStatus->Status = STATUS_INVALID_PARAMETER;
        WsPrint (DBG_PVD_COMPLETE|DBG_FAILURES,
            ("WS2IFSL-%04lx CompletePvdRequest: Invalid input buffer size (%ld)"
             " for socket file %p.\n",
             PsGetCurrentProcessId(),
             InputBufferLength,
             SocketFile));
        return;
    }

    SocketCtx = SocketFile->FsContext;
    ProcessFile = GetSocketProcessReference (SocketCtx);

    if (((PIFSL_PROCESS_CTX)ProcessFile->FsContext)->UniqueId==PsGetCurrentProcessId()) {
        WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_PVD_COMPLETE,
            ("WS2IFSL-%04lx CompletePvdRequest: Socket %p (h:%p,cport:%p)\n",
                PsGetCurrentProcessId(),
                SocketFile, SocketCtx->DllContext,
                SocketFile->CompletionContext));

        // Carefully write status info
        try {
            if (RequestorMode!=KernelMode)
                ProbeForRead (InputBuffer,
                                sizeof (IO_STATUS_BLOCK),
                                sizeof (ULONG));
            *IoStatus = *((PIO_STATUS_BLOCK)InputBuffer);
        }
        except(EXCEPTION_EXECUTE_HANDLER) {
            IoStatus->Status = GetExceptionCode ();
            WsPrint (DBG_SOCKET|DBG_FAILURES,
                ("WS2IFSL-%04lx CompletePvdRequest: Invalid input buffer (%p)"
                 " for socket file %p.\n",
                 PsGetCurrentProcessId(),
                 InputBuffer,
                 SocketFile));
        }
    }
    else {
        IoStatus->Status = STATUS_INVALID_HANDLE;
        WsPrint (DBG_SOCKET|DBG_PVD_COMPLETE|DBG_FAILURES,
            ("WS2IFSL-%04lx CompletePvdRequest: Socket %p has not"
                " been setup in the process\n",
            PsGetCurrentProcessId(), SocketFile));
    }

    ObDereferenceObject (ProcessFile);

} //CompletePvdRequest

VOID
CompleteDrvRequest (
    IN PFILE_OBJECT         SocketFile,
    IN PWS2IFSL_CMPL_PARAMS Params,
    IN PVOID                OutputBuffer,
    IN ULONG                OutputBufferLength,
    OUT PIO_STATUS_BLOCK    IoStatus
    )
/*++

Routine Description:

    Complete request that was prviously passed to user mode DLL
Arguments:
    SocketFile          - Socket file on which to operate
    Params              - description of the parameters
    OutputBuffer        - Request results (data and address)
    OutputBufferLength  - sizeof result buffer
    IoStatus            - IO status information block
        Status: STATUS_SUCCESS - request was completed OK
                STATUS_CANCELLED - request was already cancelled

Return Value:
    None (result returned via IoStatus block)
--*/
{
    PIFSL_SOCKET_CTX    SocketCtx;
    PIRP                irp = NULL;
    PIO_STACK_LOCATION  irpSp;

    PAGED_CODE();

    SocketCtx = SocketFile->FsContext;


    // Check and copy parameters
    try {

        //
        // Try to find matching IRP in the processed list.
        //
        irp = GetProcessedRequest (SocketCtx, Params->UniqueId);
        if (irp!=NULL) {
            NTSTATUS    status = Params->Status , status2 = 0;
            ULONG       bytesCopied;

            irpSp = IoGetCurrentIrpStackLocation (irp);

            //
            // Copy data based on the function we performed
            //

            switch (irpSp->MajorFunction) {
            case IRP_MJ_DEVICE_CONTROL:
                switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
                case IOCTL_AFD_RECEIVE_DATAGRAM:
                    //
                    // Copy address buffer and length
                    //
                    if (irpSp->Parameters.DeviceIoControl.IfslAddressBuffer!=NULL) {
                        ULONG   addrOffset = ADDR_ALIGN(irpSp->Parameters.DeviceIoControl.OutputBufferLength);
                        if (addrOffset+Params->AddrLen > OutputBufferLength) {
                            ExRaiseStatus (STATUS_INVALID_PARAMETER);
                        }
                        if (Params->AddrLen
                                <=irpSp->Parameters.DeviceIoControl.IfslAddressLength) {
                            RtlCopyMemory (
                                    irpSp->Parameters.DeviceIoControl.IfslAddressBuffer,
                                    (PUCHAR)OutputBuffer+addrOffset,
                                    Params->AddrLen);
                        }
                        else {
                            RtlCopyMemory (
                                    irpSp->Parameters.DeviceIoControl.IfslAddressBuffer,
                                    (PUCHAR)OutputBuffer+addrOffset,
                                    irpSp->Parameters.DeviceIoControl.IfslAddressLength);
                            status2 = STATUS_BUFFER_OVERFLOW;
                        }
                    }
                    if (NT_SUCCESS (status2) && irp->UserBuffer) {
                        *((PULONG)(irp->Tail.Overlay.IfslAddressLenPtr)) = Params->AddrLen;
                    }

                    //
                    // Drop through to copy data as well
                    //

                case IOCTL_AFD_RECEIVE:
                    break;
                case IOCTL_AFD_SEND_DATAGRAM:
                    goto NoCopy;
                    break;
                default:
                    ASSERTMSG ("Unsupported IOCTL!!!", FALSE);
                    ExRaiseStatus (STATUS_INVALID_PARAMETER);
                    break;
                }

                //
                // Drop through to copy data as well
                //

            case IRP_MJ_READ:
                if (irp->MdlAddress!=NULL) {
                    bytesCopied = CopyBufferToMdlChain (
                                    OutputBuffer,
                                    Params->DataLen,
                                    irp->MdlAddress);
                }
                else
                    bytesCopied = 0;

                if ((bytesCopied<Params->DataLen)
                        && NT_SUCCESS (status))
                    status = STATUS_BUFFER_OVERFLOW;
                break;
            case IRP_MJ_WRITE:
                bytesCopied = Params->DataLen;
                // goto NoCopy; // same as break;
                break;
            case IRP_MJ_PNP: 
                if (OutputBufferLength>=sizeof (HANDLE)) {
                    PDEVICE_OBJECT  targetDevice;
                    PIRP            targetIrp;
                    PIO_STACK_LOCATION targetSp;

                    status = ObReferenceObjectByHandle (
                                    *((PHANDLE)OutputBuffer),
                                    MAXIMUM_ALLOWED,
                                    *IoFileObjectType,
                                    irp->RequestorMode,
                                    (PVOID *)&irpSp->FileObject,
                                    NULL
                                    );
                    if (NT_SUCCESS (status)) {
                        targetDevice = IoGetRelatedDeviceObject (irpSp->FileObject);
                        targetIrp = IoBuildAsynchronousFsdRequest (
                                                    IRP_MJ_PNP,
                                                    targetDevice,
                                                    NULL,
                                                    0,
                                                    NULL,
                                                    NULL
                                                    );
                        if (targetIrp!=NULL) {
                            targetSp = IoGetNextIrpStackLocation (targetIrp);
                            *targetSp = *irpSp;
                            targetSp->FileObject = irpSp->FileObject;
                            IoSetCompletionRoutine( targetIrp, CompleteTargetQuery, irp, TRUE, TRUE, TRUE );
                            IoCallDriver (targetDevice, targetIrp);
                            goto NoCompletion;
                        }
                        else {
                            ObDereferenceObject (irpSp->FileObject);
                            status = STATUS_INSUFFICIENT_RESOURCES;
                        }
                    }
                }
                else {
                    ExRaiseStatus (STATUS_INVALID_PARAMETER);
                }
                    
                                
                break;
            default:
                ASSERTMSG ("Unsupported MJ code!!!", FALSE);
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
                break;
            }

        NoCopy:
            irp->IoStatus.Information = bytesCopied;

            if (NT_SUCCESS (status)) {
                irp->IoStatus.Status = status2;
            }
            else {
                irp->IoStatus.Status = status;
            }

            WsProcessPrint (
                (PIFSL_PROCESS_CTX)SocketCtx->ProcessRef->FsContext,
                DBG_DRV_COMPLETE,
                ("WS2IFSL-%04lx CompleteDrvRequest: Irp %p, status %lx, info %ld,"
                 " on socket %p (h:%p).\n",
                    PsGetCurrentProcessId(),
                    irp, irp->IoStatus.Status,
                    irp->IoStatus.Information,
                    SocketFile, SocketCtx->DllContext));
            CompleteSocketIrp (irp);
        NoCompletion:
            IoStatus->Status = STATUS_SUCCESS;
        }
        else {
            IoStatus->Status = STATUS_CANCELLED;
            WsProcessPrint (
                (PIFSL_PROCESS_CTX)SocketCtx->ProcessRef->FsContext,
                DBG_DRV_COMPLETE|DBG_FAILURES,
                ("WS2IFSL-%04lx CompleteDrvRequest:"
                 " Request id %ld is not in the list"
                 " for socket %p.\n",
                 PsGetCurrentProcessId(),
                 Params->UniqueId,
                 SocketFile));
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER) {
        IoStatus->Status = GetExceptionCode ();
        WsProcessPrint (
             (PIFSL_PROCESS_CTX)SocketCtx->ProcessRef->FsContext,
             DBG_DRV_COMPLETE|DBG_FAILURES,
            ("WS2IFSL-%04lx CompleteDrvRequest: Failed to process"
             " Irp %p (id %ld) for socket %p, status %lx.\n",
             PsGetCurrentProcessId(),
             irp, Params->UniqueId,
             SocketFile, IoStatus->Status));
        if (irp!=NULL) {
            //
            // Cleanup and complete the irp
            //
            irp->IoStatus.Status = IoStatus->Status;
            irp->IoStatus.Information = 0;
            if (irpSp->MajorFunction==IRP_MJ_DEVICE_CONTROL) {
                irp->UserBuffer = NULL;
            }
            CompleteSocketIrp (irp);
        }
    }
} //CompleteDrvRequest

NTSTATUS
CompleteTargetQuery (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PIRP    irp = Context;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation (irp);

    //
    // If pending has be returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending(Irp);
    }

    ObDereferenceObject (irpSp->FileObject);
    //
    // Copy the status info returned by target device
    //
    irp->IoStatus = Irp->IoStatus;

    //
    // Free the target irp;
    // 
    IoFreeIrp (Irp);

    //
    // Complete the original IRP.
    //
    CompleteSocketIrp (irp);

    //
    // Make sure IO subsystem does not touch the IRP we freed
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
SocketPnPTargetQuery (
    IN PFILE_OBJECT SocketFile,
    IN PIRP         Irp
    )
/*++

Routine Description:

    Passes target device relation query to the underlying
    socket if any.

Arguments:
    SocketFile  - socket file object
    Irp         - query target device relation request

Return Value:

    STATUS_PENDING  - operation initiated OK
--*/
{
    NTSTATUS                status;
    PIO_STACK_LOCATION      irpSp;
    PIFSL_SOCKET_CTX        SocketCtx;
    PFILE_OBJECT            ProcessFile;

    PAGED_CODE ();

    irpSp = IoGetCurrentIrpStackLocation (Irp);
    Irp->IoStatus.Information = 0;
    SocketCtx = SocketFile->FsContext;
    ProcessFile = GetSocketProcessReference (SocketCtx);


    // We are going to pend this request
    IoMarkIrpPending (Irp);

    // Prepare IRP for insertion into the queue
    irpSp->Parameters.DeviceIoControl.IfslAddressBuffer = NULL;
    irpSp->Parameters.DeviceIoControl.IfslAddressLength = 0;

    Irp->Tail.Overlay.IfslRequestId = UlongToPtr(GenerateUniqueId (SocketCtx->IrpId));
    Irp->Tail.Overlay.IfslAddressLenPtr = NULL;
    Irp->Tail.Overlay.IfslRequestFlags = (PVOID)0;
    Irp->Tail.Overlay.IfslRequestQueue = NULL;

    if (!QueueRequest (ProcessFile->FsContext, Irp)) {
        Irp->IoStatus.Status = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0;
        WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_AFDIOCTL,
            ("WS2IFSL-%04lx DoAfdIoctl: Cancelling Irp %p on socket %p.\n",
            PsGetCurrentProcessId(),
            Irp, SocketFile));
        CompleteSocketIrp (Irp);
    }
    status = STATUS_PENDING;

    ObDereferenceObject (ProcessFile);
    return status;
}

BOOLEAN
InsertProcessedRequest (
    PIFSL_SOCKET_CTX    SocketCtx,
    PIRP                Irp
    )
/*++

Routine Description:

    Inserts request that was processed to be passed to user mode
    DLL into socket list.  Checks if request is cancelled
Arguments:
    SocketCtx   - contex of the socket into which insert the request
    Irp         - request to insert
Return Value:
    TRUE        - request was inserted
    FALSE       - request is being cancelled
--*/
{
    KIRQL       oldIRQL;
    IoSetCancelRoutine (Irp, ProcessedCancelRoutine);
    KeAcquireSpinLock (&SocketCtx->SpinLock, &oldIRQL);
    if (!Irp->Cancel) {
        InsertTailList (&SocketCtx->ProcessedIrps,
                        &Irp->Tail.Overlay.ListEntry);
        Irp->Tail.Overlay.IfslRequestQueue = &SocketCtx->ProcessedIrps;
        KeReleaseSpinLock (&SocketCtx->SpinLock, oldIRQL);
        return TRUE;
    }
    else {
        KeReleaseSpinLock (&SocketCtx->SpinLock, oldIRQL);
        return FALSE;
    }
}

VOID
ProcessedCancelRoutine (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    )
/*++

Routine Description:

    Driver cancel routine for socket request waiting in the list
    (being processed by the user mode DLL).
Arguments:
    DeviceObject - WS2IFSL device object
    Irp          - Irp to be cancelled

Return Value:
    None
--*/
{
    PIO_STACK_LOCATION      irpSp;
    PIFSL_SOCKET_CTX        SocketCtx;

    irpSp = IoGetCurrentIrpStackLocation (Irp);
    SocketCtx = irpSp->FileObject->FsContext;
    WsProcessPrint ((PIFSL_PROCESS_CTX)SocketCtx->ProcessRef->FsContext,
              DBG_SOCKET,
              ("WS2IFSL-%04lx ProcessedCancel: Socket %p, Irp %p\n",
              PsGetCurrentProcessId(),
              irpSp->FileObject, Irp));
    KeAcquireSpinLockAtDpcLevel (&SocketCtx->SpinLock);
    if (Irp->Tail.Overlay.IfslRequestQueue!=NULL) {
        ASSERT (Irp->Tail.Overlay.IfslRequestQueue==&SocketCtx->ProcessedIrps);
        RemoveEntryList (&Irp->Tail.Overlay.ListEntry);
        Irp->Tail.Overlay.IfslRequestQueue = NULL;
        KeReleaseSpinLockFromDpcLevel (&SocketCtx->SpinLock);
        IoReleaseCancelSpinLock (Irp->CancelIrql);

        CancelSocketIo (irpSp->FileObject);

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_CANCELLED;
        CompleteSocketIrp (Irp);
    }
    else {
        KeReleaseSpinLockFromDpcLevel (&SocketCtx->SpinLock);
        IoReleaseCancelSpinLock (Irp->CancelIrql);
        //
        // Don't touch IRP after this as we do not own it anymore
        //
    }
}

VOID
CleanupProcessedRequests (
    IN  PIFSL_SOCKET_CTX    SocketCtx,
    OUT PLIST_ENTRY         IrpList
    )
/*++

Routine Description:

    Cleans up all requests on the socket which are being
    processed by the user mode DLL

Arguments:
    SocketCtx   -   context of the socket
    IrpList     -   list to insert cleaned up request (to be completed
                    by the caller)
Return Value:
    None
--*/
{
    PIRP            irp;
    PLIST_ENTRY     entry;
    KIRQL           oldIRQL;

    KeAcquireSpinLock (&SocketCtx->SpinLock, &oldIRQL);
    while (!IsListEmpty(&SocketCtx->ProcessedIrps)) {
        entry = RemoveHeadList (&SocketCtx->ProcessedIrps);
        irp = CONTAINING_RECORD (entry, IRP, Tail.Overlay.ListEntry);
        ASSERT (irp->Tail.Overlay.IfslRequestQueue==&SocketCtx->ProcessedIrps);
        irp->Tail.Overlay.IfslRequestQueue = NULL;
        InsertTailList (IrpList, &irp->Tail.Overlay.ListEntry);
    }
    KeReleaseSpinLock (&SocketCtx->SpinLock, oldIRQL);
}

VOID
CompleteSocketIrp (
    PIRP        Irp
    )
/*++

Routine Description:

    Completes IRP and properly synchronizes with cancel routine
    if necessary (it has already been called).
Arguments:
    Irp     - irp to complete
Return Value:
    None
--*/
{

    //
    // Reset cancel routine (it wont complete the IRP as it
    // won't be able to find it)
    //

    if (IoSetCancelRoutine (Irp, NULL)==NULL) {
        KIRQL   oldIRQL;
        //
        // Cancel routine has been called.
        // Synchronize with cancel routine (it won't touch the
        // IRP after it releases cancel spinlock)

        IoAcquireCancelSpinLock (&oldIRQL);
        IoReleaseCancelSpinLock (oldIRQL);
    }

    if (Irp->MdlAddress!=NULL) {
        ASSERT ((Irp->MdlAddress->MdlFlags & MDL_PAGES_LOCKED) == 0);
        IoFreeMdl (Irp->MdlAddress);
        Irp->MdlAddress = NULL;
    }

    IoCompleteRequest (Irp, IO_NO_INCREMENT);
}

PIRP
GetProcessedRequest (
    PIFSL_SOCKET_CTX    SocketCtx,
    ULONG               UniqueId
    )
/*++

Routine Description:

    Finds and returns matching IRP from the processed IRP list

Arguments:
    SocketCtx   - socket context to search for the IRP in
    UniqueId    - id assigned to the request to distinguish identify
                    it case it was cancelled and IRP was reused
Return Value:
    IRP
    NULL    - irp was not found
--*/
{
    PIRP        irp;
    PLIST_ENTRY entry;
    KIRQL       oldIRQL;

    //
    // We do not usually have many request sumulteneously pending
    // on a socket, so the linear search should suffice.
    //

    KeAcquireSpinLock (&SocketCtx->SpinLock, &oldIRQL);
    entry = SocketCtx->ProcessedIrps.Flink;
    while (entry!=&SocketCtx->ProcessedIrps) {
        irp = CONTAINING_RECORD (entry, IRP, Tail.Overlay.ListEntry);
        entry = entry->Flink;
        if (irp->Tail.Overlay.IfslRequestId==UlongToPtr(UniqueId)) {
            ASSERT (irp->Tail.Overlay.IfslRequestQueue==&SocketCtx->ProcessedIrps);
            RemoveEntryList (&irp->Tail.Overlay.ListEntry);
            irp->Tail.Overlay.IfslRequestQueue = NULL;
            KeReleaseSpinLock (&SocketCtx->SpinLock, oldIRQL);
            return irp;
        }
    }
    KeReleaseSpinLock (&SocketCtx->SpinLock, oldIRQL);
    return NULL;
}


VOID
CancelSocketIo (
    PFILE_OBJECT    SocketFile
    )
/*++

Routine Description:

    Queue a request to user mode DLL to cancel all io on the socket

Arguments:
    SocketCtx   - socket context on which IO is to be cancelled

Return Value:
        None
--*/
{
    PIFSL_SOCKET_CTX    SocketCtx = SocketFile->FsContext;
    PIFSL_PROCESS_CTX   ProcessCtx = SocketCtx->ProcessRef->FsContext;
    PIFSL_CANCEL_CTX    cancelCtx;

    try {
        cancelCtx = (PIFSL_CANCEL_CTX) ExAllocatePoolWithQuotaTag (
                                        NonPagedPool,
                                        sizeof (IFSL_CANCEL_CTX),
                                        CANCEL_CTX_TAG);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        cancelCtx = NULL;
    }


    if (cancelCtx!=NULL) {
        //
        // Make sure socket does not go away while this request exists
        //
        ObReferenceObject (SocketFile);
        cancelCtx->SocketFile = SocketFile;
        cancelCtx->UniqueId = GenerateUniqueId (ProcessCtx->CancelId);

        //
        // We do not want to queue another cancel request if we have
        // one pending or being executed
        //
        if (InterlockedCompareExchangePointer ((PVOID *)&SocketCtx->CancelCtx,
                                cancelCtx,
                                NULL)==NULL) {
            WsProcessPrint (
                      ProcessCtx,
                      DBG_CANCEL,
                      ("WS2IFSL-%04lx CancelSocketIo: Context %p, socket %p\n",
                      PsGetCurrentProcessId(),
                      cancelCtx, SocketFile));
            QueueCancel (ProcessCtx, cancelCtx);
            return;
        }

        WsProcessPrint (
                  ProcessCtx,
                  DBG_CANCEL,
                  ("WS2IFSL-%04lx CancelSocketIo: Another cancel active"
                  " context %p, socket %p\n",
                  PsGetCurrentProcessId(),
                  SocketCtx->CancelCtx, SocketFile));
        ObDereferenceObject (SocketFile);
        ExFreePool (cancelCtx);
    }
    else {
        WsPrint (DBG_SOCKET|DBG_CANCEL|DBG_FAILURES,
                  ("WS2IFSL-%04lx CancelSocketIo: Could not allocate cancel"
                  " context for socket %p\n",
                  PsGetCurrentProcessId(),
                  SocketFile));
    }
}

VOID
FreeSocketCancel (
    PIFSL_CANCEL_CTX CancelCtx
    )
/*++

Routine Description:

    Frees resources associated with cancel request

Arguments:
    CancelCtx   - cancel request context

Return Value:
        None
--*/
{
    PFILE_OBJECT        SocketFile = CancelCtx->SocketFile;
    PIFSL_SOCKET_CTX    SocketCtx = SocketFile->FsContext;

    ASSERT (IoGetRelatedDeviceObject (SocketFile)==DeviceObject);
    ASSERT (SocketCtx->EANameTag==SOCKET_FILE_EANAME_TAG);
    ASSERT (CancelCtx->ListEntry.Flink==NULL);

    //
    // We are going to dereference the file object whether
    // free the structure or not
    //
    CancelCtx->SocketFile = NULL;
    ObDereferenceObject (SocketFile);

    //
    // During socket closure, the cleanup routine may be in
    // process of freeing this cancel context and will set
    // the pointer to it to NULL to indicate the fact
    //
    if (InterlockedCompareExchangePointer ((PVOID *)&SocketCtx->CancelCtx,
                                            NULL,
                                            CancelCtx)) {
        WsProcessPrint (
                  (PIFSL_PROCESS_CTX)SocketCtx->ProcessRef->FsContext,
                  DBG_CANCEL,
                  ("WS2IFSL-%04lx FreeSocketCancel: Freeing cancel"
                  " context %p, socket %p\n",
                  PsGetCurrentProcessId(),
                  CancelCtx, SocketFile));
        ExFreePool (CancelCtx);
    }
    else {
        //
        // The close routine will take care of freeing the request
        //
        WsProcessPrint (
                  (PIFSL_PROCESS_CTX)SocketCtx->ProcessRef->FsContext,
                  DBG_CANCEL,
                  ("WS2IFSL-%04lx FreeSocketCancel: Cleanup owns cancel"
                  " context %p, socket %p\n",
                  PsGetCurrentProcessId(),
                  CancelCtx, SocketFile));
    }
}


PFILE_OBJECT
GetSocketProcessReference (
    IN  PIFSL_SOCKET_CTX    SocketCtx
    )
/*++

Routine Description:

    Reads and references process file currently associated with
    the socket under the lock to protect in case socket is moved
    to a different process

Arguments:
    SocketCtx   - socket context to read process file from

Return Value:
    Referenced pointer to process file object currently associated
    with the socket.

--*/
{
    KIRQL               oldIRQL;
    PFILE_OBJECT        ProcessFile;

    KeAcquireSpinLock (&SocketCtx->SpinLock, &oldIRQL);
    ObReferenceObject (SocketCtx->ProcessRef);
    ProcessFile = SocketCtx->ProcessRef;
    KeReleaseSpinLock (&SocketCtx->SpinLock, oldIRQL);

    return ProcessFile;
}


PFILE_OBJECT
SetSocketProcessReference (
    IN  PIFSL_SOCKET_CTX    SocketCtx,
    IN  PFILE_OBJECT        NewProcessFile,
    IN  PVOID               NewDllContext
    )
/*++

Routine Description:

    Sets new process context for the socket object under the protection
    of a lock.

Arguments:
    SocketCtx       - socket context to set
    NewProcessFile  - process file reference
    NewDllContext   - context to be associated with the socket
                        in the process

Return Value:
    Previous process file reference
--*/
{
    KIRQL               oldIRQL;
    PFILE_OBJECT        ProcessFile;

    KeAcquireSpinLock (&SocketCtx->SpinLock, &oldIRQL);
    ProcessFile = SocketCtx->ProcessRef;
    SocketCtx->ProcessRef = NewProcessFile;
    SocketCtx->DllContext = NewDllContext;
    KeReleaseSpinLock (&SocketCtx->SpinLock, oldIRQL);
    return ProcessFile;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\ws2ifsl\socket.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    socket.h

Abstract:

    This module contains declarations of functions and globals
    for socket file object implemetation in ws2ifsl.sys driver.

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:

--*/

// Socket file device IO control function pointer
typedef
VOID                                        // Result is returned via IoStatus
(*PSOCKET_DEVICE_CONTROL) (
    IN PFILE_OBJECT     SocketFile,         // Socket file on which to operate
    IN KPROCESSOR_MODE  RequestorMode,      // Mode of the caller
    IN PVOID            InputBuffer,        // Input buffer pointer
    IN ULONG            InputBufferLength,  // Size of the input buffer
    OUT PVOID           OutputBuffer,       // Output buffer pointer
    IN ULONG            OutputBufferLength, // Size of output buffer
    OUT PIO_STATUS_BLOCK IoStatus           // IO status information block
    );

PSOCKET_DEVICE_CONTROL SocketIoControlMap[2];
ULONG                  SocketIoctlCodeMap[2];

NTSTATUS
CreateSocketFile (
    IN PFILE_OBJECT                 SocketFile,
    IN KPROCESSOR_MODE              RequestorMode,
    IN PFILE_FULL_EA_INFORMATION    eaInfo
    );

NTSTATUS
CleanupSocketFile (
    IN PFILE_OBJECT SocketFile,
    IN PIRP         Irp
    );

VOID
CloseSocketFile (
    IN PFILE_OBJECT SocketFile
    );

NTSTATUS
DoSocketReadWrite (
    IN PFILE_OBJECT SocketFile,
    IN PIRP         Irp
    );

NTSTATUS
DoSocketAfdIoctl (
    IN PFILE_OBJECT SocketFile,
    IN PIRP         Irp
    );

VOID
FreeSocketCancel (
    PIFSL_CANCEL_CTX    CancelCtx
    );

VOID
CompleteSocketIrp (
    PIRP        Irp
    );

BOOLEAN
InsertProcessedRequest (
    PIFSL_SOCKET_CTX    SocketCtx,
    PIRP                Irp
    );

VOID
CompleteDrvRequest (
    IN PFILE_OBJECT         SocketFile,
    IN PWS2IFSL_CMPL_PARAMS Params,
    IN PVOID                OutputBuffer,
    IN ULONG                OutputBufferLength,
    OUT PIO_STATUS_BLOCK    IoStatus
    );

NTSTATUS
SocketPnPTargetQuery (
    IN PFILE_OBJECT SocketFile,
    IN PIRP         Irp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\ws2ifsl\testifsl.c ===
#include <nt.h>
#include <stdio.h>
#include <string.h>

#include "ws2ifsl.h"

HANDLE              ApcThreadHdl;
HANDLE              ProcessFile;

char                TestString[]="WS2IFSL";


DWORD WINAPI
ApcThread (
    PVOID   param
    );

VOID CALLBACK
ExitThreadApc (
    DWORD   param
    );

VOID 
Ws2ifslApc (
    IN PWS2IFSL_APC_REQUEST         Request,
    IN PVOID                        RequestCtx,
    IN PVOID                        SocketCtx
    );


int _cdecl
main (
    int     argc,
    char    *argv[]
    ) {
    UCHAR                       fullEaBuffer[FIELD_OFFSET(FILE_FULL_EA_INFORMATION,
                                            EaName[WS2IFSL_PROCESS_EA_NAME_LENGTH+1]);
    PFILE_FULL_EA_INFORMATION   fileEa;
    OBJECT_ATTRIBUTES           fileAttr;
    UNICODE_STRING              fileName;
    NTSTATUS                    status;
    DWORD                       apcThreadId;
    HANDLE                      hEvent;
    DWORD                       rc;
    BOOL                        res;

    hEvent = CreateEvent (NULL, TRUE, FALSE, NULL); // manual reset event
    if (hEvent==NULL) {
        printf ("Could not create event.\n");
        return 1;
    }

    RtlInitUnicodeString (fileName, WS2IFSL_DEVICE_NAME);
    InitializeObjectAttributes (&fileAttr,
                        fileName,
                        0,                  // Attributes
                        NULL,               // Root directory
                        NULL);              // Security descriptor
    fileEa = (PPFILE_FULL_EA_INFORMATION)fullEaBuffer;
    fileEa->NextOffset = 0;
    fileEa->Flags = 0;
    fileEa->EaNameLength = WS2IFSL_PROCESS_EA_NAME_LENGTH;
    fileEa->EaValueLength = 0;
    strcpy (fileEa->EaName, WS2IFSL_PROCESS_EA_NAME);

    status = NtCreateFile (&ProcessFile,
                         FILE_ALL_ACCESS,
                         fileAttr,
                         &ioStatus,
                         NULL,              // Allocation size
                         FILE_ATTRIBUTE_NORMAL,
                         0,                 // ShareAccess
                         FILE_OPEN_IF,      // Create disposition
                         0,                 // Create options
                         fullEaBuffer,
                         sizeof (fullEaBuffer));
    if (NT_SUCCESS (status)) {
        printf ("Created process file, handle: %lx.\n", ProcessFile);


        ApcThreadHdl = CreateThread (NULL,
                                    0,
                                    ApcThread,
                                    hEvent,
                                    0,
                                    &apcThreadId);
        if (ApcThreadHdl!=NULL) {
            rc = WaitForSingleObject (hEvent, INFINITE);
            if (rc==WAIT_OBJECT_0) {
                HANDLE              socketFile;
                HANDLE              hCompletion;
                char                TestBuffer[sizeof (TestString)];
                DWORD               count, key;
                OVERLAPPED          readOVLP, writeOVLP, ctrlOVLP;
                POVERLAPPED         ovlp;
                WS2IFSL_SOCKET_CTX  socketCtx;

                fileEa = (PPFILE_FULL_EA_INFORMATION)fullEaBuffer;
                fileEa->NextOffset = 0;
                fileEa->Flags = 0;
                fileEa->EaNameLength = WS2IFSL_SOCKET_EA_NAME_LENGTH;
                fileEa->EaValueLength = 0;
                strcpy (fileEa->EaName, WS2IFSL_SOCKET_EA_NAME);

                status = NtCreateFile (&socketFile,
                                     FILE_ALL_ACCESS,
                                     fileAttr,
                                     &ioStatus,
                                     NULL,              // Allocation size
                                     FILE_ATTRIBUTE_NORMAL,
                                     0,                 // ShareAccess
                                     FILE_OPEN_IF,      // Create disposition
                                     0,                 // Create options
                                     fullEaBuffer,
                                     sizeof (fullEaBuffer));
                if (NT_SUCCESS (status)) {
                    printf ("Created socket file, handle:%lx\n", socketFile);
                    socketCtx.SocketCtx = socketFile;
                    socketCtx.ProcessFile = ProcessFile;
                    res = DeviceIoControl (socketFile,
                                    IOCTL_WS2IFSL_SET_SOCKET_CONTEXT,
                                    &socketCtx,
                                    sizeof (socketCtx),
                                    NULL,
                                    0,
                                    &count,
                                    NULL);
                    if (res) {
                        hCompletion = CreateIoCompletionPort (socketFile,
                                            NULL,
                                            1,
                                            0);
                        if (hCompletion!=NULL) {
                            memset (TestBuffer, 0, sizeof (TestBuffer));
                            readOVLP.hEvent = NULL;
                            res = ReadFile (socketFile,
                                                TestBuffer,
                                                sizeof (TestBuffer),
                                                &count,
                                                &readOVLP);
                            if (res || (GetLastError ()==ERROR_IO_PENDING)) {
                                writeOVLP.hEvent = NULL;
                                res = WriteFile (socketFile,
                                                    TestString,
                                                    sizeof (TestString),
                                                    &count,
                                                    &writeOVLP);
                                if (res || (GetLastError ()==ERROR_IO_PENDING)) {
                                    ctrlOVLP.Internal = STATUS_BUFFER_OVERFLOW;
                                    ctrlOVLP.InternalHigh = 10;
                                    ctrlOVLP.hEvent = NULL;
                                    res = DeviceIoControl (socketFile,
                                                    IOCTL_WS2IFSL_COMPLETE_REQUEST,
                                                    &ctrlOVLP,
                                                    sizeof (IO_STATUS_BLOCK),
                                                    NULL,
                                                    0,
                                                    &count,
                                                    NULL);
                                    do {
                                        res = GetQueuedCompletionStatus (hCompletion,
                                                &count,
                                                &key,
                                                &ovlp,
                                                INFINITE);
                                        if (ovlp!=NULL) {
                                            if (ovlp==&readOVLP) {
                                                printf ("Read completed,"
                                                        "key: %ld, error: %ld, count: %ld, string: %ls.\n",
                                                        key,
                                                        res ? 0 : GetLastError (),
                                                        count,
                                                        TestBuffer);
                                                done |= 1;
                                            }
                                            else if (ovlp==&writeOVLP) {
                                                printf ("Write completed,"
                                                        "key:%ld, error: %ld, count: %ld.\n",
                                                        key,
                                                        res ? 0 : GetLastError (),
                                                        count);
                                                done |= 2;
                                            }
                                            else if (ovlp==&ctrlOVLP) {
                                                printf ("Control completed,"
                                                        "key:%ld, error: %ld, count: %ld.\n",
                                                        key,
                                                        res ? 0 : GetLastError (),
                                                        count);
                                                done |= 4;
                                            }
                                        }
                                        else {
                                            prinf ("GetQueuedCompletionStatus failed, error %ld.\n",
                                                    GetLastError ());
                                            break;
                                        }
                                    }
                                    while (done!=7);
                                }
                                else {
                                    printf ("Write failed, error: %ld.\n", GetLastError ());
                                }
                            }
                            else {
                                printf ("Read failed, error: %ld.\n", GetLastError ());
                            }
                            CloseHandle (hCompletion);
                        }
                        else {
                            printf ("Could not create completion port, error %ld.\n",
                                        GetLastError ());
                        }
                    }
                    else {
                        printf ("IOCTL_WS2IFSL_SET_SOCKET_CONTEXT failed, error: %ld.\n",
                                    GetLastError ());
                    }
                    
                    NtClose (socketFile);

                }
                else {
                    printf ("Could not create socket file, status:%lx\n", status);
                }

            }
            else {
                printf ("Wait for event failed, rc=%lx, error=%ld.\n",
                                rc, GetLastError ());
            }

            QueueUserAPC (ExitThreadApc, ApcThreadHdl, 0);
            WaitForSingleObject (ApcThreadHdl, INFINITE);
            CloseHandle (ApcThreadHdl);
        }
        else {
            printf ("Could not create thread.\n");
        }
        NtClose (ProcessFile);
    }
    CloseHandle (hEvent);
}


DWORD WINAPI
ApcThread (
    PVOID   param
    ) {
    WS2IFSL_APC_REQUEST     ApcRequest;
    WS2IFSL_THREAD_CTX      threadCtx;
    HANDLE                  hEvent = (HANDLE)param;
    BOOL                    res;
    OVERLAPPED              ovlp;

    threadCtx.ApcThreadHdl = ApcThreadHdl;
    threadCtx.ApcRoutine = Ws2ifslApc;
    ovlp.hEvent = NULL;
    res = DeviceIoControl (socketFile,
                    IOCTL_WS2IFSL_SET_THREAD_CONTEXT,
                    &threadCtx,
                    sizeof (threadCtx),
                    &ApcRequest,
                    sizeof (ApcRequest),
                    &count,
                    &ovlp);
    SetEvent (hEvent);
    if (!res && (GetLastError ()==ERROR_IO_PEDNING) {
        printf ("ApcThread: going into sleep mode....\n");
        while (TRUE)
            SleepEx (INIFINITE, TRUE);
    }
    else
        printf ("IOCTL_WS2IFSL_SET_THREAD_CONTEXT returned: %ld (status: %lx).\n",
                res ? 0 : GetLastError (), ovlp.Internal);
    return 0;
}

    
VOID CALLBACK
ExitThreadApc (
    DWORD   param
    ) {
    ExitThread (param);
}


typedef struct _PENDING_REQUEST {
    HANDLE      SocketCtx;
    PVOID       RequestCtx;
    PVOID       Buffer;
    ULONG       Length;
} PENDING_REQUEST, *PPENDING_REQUEST;

PPENDING_REQUEST    ReadRequest, WriteRequest;

                    
VOID 
Ws2ifslApc (
    IN PWS2IFSL_APC_REQUEST         Request,
    IN PVOID                        RequestCtx,
    IN PVOID                        SocketCtx
    ) {
    IO_STATUS_BLOCK IoStatus;
    DWORD           count;

    switch (Request->request) {
    case WS2IFSL_APC_REQUEST_READ:
        printf ("Processing read request, buffer: %lx, length: %ld, request %lx, context:%lx.",
                                Request->Read.Buffer,
                                Request->Read.Length,
                                RequestCtx,
                                SocketCtx);
        if (WriteRequest!=NULL) {
            if (WriteRequest->Length<=Request->Read.Length) {
                memcpy (Request->Read.Buffer, WriteRequest.Buffer, WriteRequest.Length);
                IoStatus.Status = STATUS_SUCCESS;
                IoStatus.Information = WriteRequest.Length;
            }
            else {
                memcpy (Request->Read.Buffer, WriteRequest.Buffer, Request.Read.Length);
                IoStatus.Status = STATUS_BUFFER_OVERFLOW;
                IoStatus.Information = Request.Read.Length;
            }
            res = DeviceIoControl ((HANDLE)WriteRequest->SocketCtx,
                            IOCTL_WS2IFSL_COMPLETE_REQUEST,
                            &IoStatus,
                            sizeof (IoStatus),
                            WriteRequest->RequestCtx,
                            0,
                            &count,
                            NULL);
            if (res)
                printf ("Completed write request, buffer %lx, count %ld, status %lx.\n",
                        WriteRequest->Buffer, IoStatus.Information, IoStatus.Status);
            else
                printf ("IOCTL_WS2IFSL_COMPLETE_REQUEST failed, error %ld\n", GetLastError ());
            free (WriteRequest);
            WriteRequest = NULL;
        }
        else if (ReadRequest==NULL) {
            ReadRequest = (PPENDING_REQUEST)malloc (sizeof (PENDING_REQUEST));
            if (ReadRequest!=NULL) {
                ReadRequest->SocketCtx = SocketCtx;
                ReadRequest->RequestCtx = RequestCtx;
                ReadRequest->Buffer = Request->Read.Buffer;
                ReadRequest->Length = Request->Read.Length;
                printf ("Pended read request.\n");
                break;
            }
            else {
                IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                IoStatus.Information = 0;
            }
        }
        else {
            IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            IoStatus.Information = 0;
        }
        res = DeviceIoControl ((HANDLE)SocketCtx,
                        IOCTL_WS2IFSL_COMPLETE_REQUEST,
                        &IoStatus,
                        sizeof (IoStatus),
                        RequestCtx,
                        0,
                        &count,
                        NULL);
        if (res)
            printf ("Completed read request, buffer %lx, count %ld, status %lx.\n",
                    Request->Read.Buffer, IoStatus.Information, IoStatus.Status);
        else
            printf ("IOCTL_WS2IFSL_COMPLETE_REQUEST failed, error %ld\n", GetLastError ());
        break;
    case WS2IFSL_APC_REQUEST_WRITE:
        printf ("Processing write request, buffer: %lx, length: %ld, request %lx, context:%lx.",
                                Request->Write.Buffer,
                                Request->Write.Length,
                                RequestCtx,
                                SocketCtx);
        if (ReadRequest!=NULL) {
            if (ReadRequest->Length>=Request->Write.Length) {
                memcpy (ReadRequest->Buffer, Request->Write.Buffer, Request->Write.Length);
                IoStatus.Status = STATUS_SUCCESS;
                IoStatus.Information = Request->Write.Length;
            }
            else {
                memcpy (ReadRequest->Buffer, Request->Write.Buffer, ReadRequest->Length);
                IoStatus.Status = STATUS_BUFFER_OVERFLOW;
                IoStatus.Information = ReadRequest->Length;
            }
            res = DeviceIoControl ((HANDLE)ReadRequest->SocketCtx,
                            IOCTL_WS2IFSL_COMPLETE_REQUEST,
                            &IoStatus,
                            sizeof (IoStatus),
                            ReadRequest->RequestCtx,
                            0,
                            &count,
                            NULL);
            if (res)
                printf ("Completed read request, buffer %lx, count %ld, status %lx.\n",
                        ReadRequest->Buffer, IoStatus.Information, IoStatus.Status);
            else
                printf ("IOCTL_WS2IFSL_COMPLETE_REQUEST failed, error %ld\n", GetLastError ());
            free (ReadRequest);
            ReadRequest = NULL;
        }
        else if (WriteRequest==NULL) {
            WriteRequest = (PPENDING_REQUEST)malloc (sizeof (PENDING_REQUEST));
            if (WriteRequest!=NULL) {
                WriteRequest->SocketCtx = SocketCtx;
                WriteRequest->RequestCtx = RequestCtx;
                WriteRequest->Buffer = Request->Write.Buffer;
                WriteRequest->Length = Request->Write.Length;
                printf ("Pended write request.\n");
                break;
            }
            else {
                IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                IoStatus.Information = 0;
            }
        }
        else {
            IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            IoStatus.Information = 0;
        }
        res = DeviceIoControl ((HANDLE)SocketCtx,
                        IOCTL_WS2IFSL_COMPLETE_REQUEST,
                        &IoStatus,
                        sizeof (IoStatus),
                        RequestCtx,
                        0,
                        &count,
                        NULL);
        if (res)
            printf ("Completed write request, buffer %lx, count %ld, status %lx.\n",
                    Request->Read.Buffer, IoStatus.Information, IoStatus.Status);
        else
            printf ("IOCTL_WS2IFSL_COMPLETE_REQUEST failed, error %ld\n", GetLastError ());
        break;
    case WS2IFSL_APC_REQUEST_CLOSE:
        printf ("Processing close request: %lx, context:%lx.",
                                RequestCtx,
                                SocketCtx);
        if ((WriteRequest!=NULL) && (WriteRequest->RequestCtx==RequestCtx)) {
            IoStatus.Status = STATUS_CANCELLED;
            IoStatus.Information = 0;
            res = DeviceIoControl ((HANDLE)WriteRequest->SocketCtx,
                            IOCTL_WS2IFSL_COMPLETE_REQUEST,
                            &IoStatus,
                            sizeof (IoStatus),
                            WriteRequest->RequestCtx,
                            0,
                            &count,
                            NULL);
            if (res)
                printf ("Completed write request, buffer %lx, count %ld, status %lx.\n",
                        WriteRequest->Buffer, IoStatus.Information, IoStatus.Status);
            else
                printf ("IOCTL_WS2IFSL_COMPLETE_REQUEST failed, error %ld\n", GetLastError ());
        }

        if ((ReadRequest!=NULL) && (ReadRequest->RequestCtx==RequestCtx)) {
            IoStatus.Status = STATUS_CANCELLED;
            IoStatus.Information = 0;
            res = DeviceIoControl ((HANDLE)ReadRequest->SocketCtx,
                            IOCTL_WS2IFSL_COMPLETE_REQUEST,
                            &IoStatus,
                            sizeof (IoStatus),
                            ReadRequest->RequestCtx,
                            0,
                            &count,
                            NULL);
            if (res)
                printf ("Completed read request, buffer %lx, count %ld, status %lx.\n",
                        ReadRequest->Buffer, IoStatus.Information, IoStatus.Status);
            else
                printf ("IOCTL_WS2IFSL_COMPLETE_REQUEST failed, error %ld\n", GetLastError ());
        }
        IoStatus.Status = STATUS_SUCCESS;
        IoStatus.Information = 0;
        res = DeviceIoControl ((HANDLE)SocketCtx,
                        IOCTL_WS2IFSL_COMPLETE_REQUEST,
                        &IoStatus,
                        sizeof (IoStatus),
                        RequestCtx,
                        0,
                        &count,
                        NULL);
        if (res)
            printf ("Completed close request, status %lx.\n", IoStatus.Status);
        else
            printf ("IOCTL_WS2IFSL_COMPLETE_REQUEST failed, error %ld\n", GetLastError ());
       break;
    default:
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2help\ws2ifsl\ws2ifslp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    WS2IFSLP.H

Abstract:

    This module defines private constants and data structures 
    for Winsock2 IFS transport layer driver.

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:

    Vadim Eydelman (VadimE)    Oct-1997, rewrite to properly handle IRP
                                        cancellation
--*/

// Pool tags
#define PROCESS_FILE_CONTEXT_TAG        'P2sW'
#define SOCKET_FILE_CONTEXT_TAG         'S2sW'
#define CANCEL_CTX_TAG                  'C2sW'

// File EAName tags
#define SOCKET_FILE_EANAME_TAG          'kcoS'
#define PROCESS_FILE_EANAME_TAG         'corP'

// Macro to get the code back from IOCTL
#define WS2IFSL_IOCTL_FUNCTION(File,Ioctl)          \
            (IoGetFunctionCodeFromCtlCode(Ioctl)    \
                - WS2IFSL_IOCTL_##File##_BASE)

typedef struct _IFSL_CANCEL_CTX {
    LIST_ENTRY              ListEntry;
    PFILE_OBJECT            SocketFile;
    ULONG                   UniqueId;
} IFSL_CANCEL_CTX, *PIFSL_CANCEL_CTX;

typedef struct _IFSL_QUEUE {
    LIST_ENTRY              ListHead;
    BOOLEAN                 Busy;
    KSPIN_LOCK              Lock;
    KAPC                    Apc;
} IFSL_QUEUE, *PIFSL_QUEUE;

// Context (FsContext field of the NT file object) associated with the
// file opened by WS2IFSL DLL on per process basis.
typedef struct _IFSL_PROCESS_CTX {
	ULONG				    EANameTag;  // 'Proc' - first four bytes of
                                        // extended attribute name for this
                                        // type of file
	HANDLE				    UniqueId;   // unique identifier of the process 
                                        // (read from UniqueProcessID field of
                                        // the EPROCESS structure)
    IFSL_QUEUE              RequestQueue;// queue of requests

    IFSL_QUEUE              CancelQueue;// queue of cancel requests
    ULONG                   CancelId;   // Used to generate IDs for
                                        // each cancel request in the process.
                                        // Combined with cancel request pointer 
                                        // itself allows to match requests completed by
                                        // user mode DLL with pending ones
#if DBG
    ULONG               DbgLevel;
#endif
} IFSL_PROCESS_CTX, *PIFSL_PROCESS_CTX;


// Context (FsContext field of the NT file object) associated with
// file opened by WS2IFSL DLL for each socket.
typedef struct _IFSL_SOCKET_CTX {
	ULONG					EANameTag;  // 'Sock' - first four bytes of
                                        // extended attribute name for this
                                        // type of file
	PVOID				    DllContext; // Context maintained for WS2IFSL DLL
	PFILE_OBJECT		    ProcessRef; // Pointer to process file object
    LONG                    IrpId;      // Used to generate IDs for
                                        // each IRP on the socket. Combined
                                        // with IRP pointer itself allows
                                        // to match requests completed by
                                        // user mode DLL with pending IRPs
    LIST_ENTRY              ProcessedIrps; // List of request being processed by
                                        // WS2IFSL DLL in APC thread
    KSPIN_LOCK              SpinLock;   // Protects requests in the list
                                        // above as well as process reference
    PIFSL_CANCEL_CTX        CancelCtx;  // Context to pass cancel request
                                        // to user mode DLL
} IFSL_SOCKET_CTX, *PIFSL_SOCKET_CTX;
#define GET_SOCKET_PROCESSID(ctx) \
            (((PIFSL_PROCESS_CTX)((ctx)->ProcessRef->FsContext))->UniqueId)

//
// Driver context field usage macros
//
#define IfslRequestId       DriverContext[0]    // Request's unique id
#define IfslRequestQueue    DriverContext[1]    // Queue if inserted, NULL othw
#define IfslRequestFlags    DriverContext[2]    // Request specific flags
#define IfslAddressLenPtr   DriverContext[3]    // Address length pointer

// Irp stack location fields usage macros
#define IfslAddressBuffer   Type3InputBuffer    // Source address
#define IfslAddressLength   InputBufferLength   // Source address length
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\common\trace.c ===
/*/////////////////////////////////////////////////////////////////////////
//
// INTEL Corporation Proprietary Information
// Copyright (c) Intel Corporation
//
// This listing is supplied under the terms of a license aggreement
// with INTEL Corporation and may not be used, copied nor disclosed
// except in accordance with that agreement.
//
//////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
// $Workfile:   TRACE.C  $
// $Revision:   1.3  $
// $Modtime:   27 Nov 1995 08:38:08  $
//
//  DESCRIPTION:
// This file contains the output function for the tracing facility
// used in PII DLL
//////////////////////////////////////////////////////////////////
*/

/* Single Line Comments */
#pragma warning(disable: 4001)
// Disable some more benign warnings for compiling at warning level 4

// nonstandard extension used : nameless struct/union
#pragma warning(disable: 4201)

// nonstandard extension used : bit field types other than int
#pragma warning(disable: 4214)

// Note: Creating precompiled header
#pragma warning(disable: 4699)

// unreferenced inline function has been removed
#pragma warning(disable: 4514)

// unreferenced formal parameter
//#pragma warning(disable: 4100)

// 'type' differs in indirection to slightly different base
// types from 'other type'
#pragma warning(disable: 4057)

// named type definition in parentheses
#pragma warning(disable: 4115)

// nonstandard extension used : benign typedef redefinition
#pragma warning(disable: 4209)

#include <windows.h>
#include <memory.h>
#include <stdio.h>
#include <stdarg.h>
#include <io.h>

/* because windows.h turns this one back on */
#pragma warning(disable: 4001)

#include "trace.h"
#include "osdef.h"

#ifdef TRACING

BOOL  InitMemoryBuffers(VOID);

LPSTR g_CurrentMessage=NULL;
LPSTR g_PreviousMessage=NULL;
CRITICAL_SECTION OutputRoutine;
int iTraceDestination=TRACE_TO_AUX;
char TraceFile[] = "trace.log";
DWORD debugLevel=DBG_ERR;



VOID
__cdecl
PrintDebugString(
                 char *Format,
                 ...
                 )
/*++
  Routine Description:

  This routine outputs a debug messages.  Debug messages are routed
  to a file or a debug window depnding on the value of a global
  variable defined in this module

  Arguments:

  Format - A "printf()" compatable format specification.

  ... - Additional arguments to "printf()" format specification.

  Returns:

  NONE

  --*/
{
    va_list ArgumentList; // argument list for varargs processing
    static HANDLE OutputFile =NULL; // file descriptor for file output
    static OFSTRUCT of; // open file struct for file output
    static int RepeatCount=0; // Count of repeated output statements
    static BOOL LogOpened = FALSE; // have we opened the file for
                                     // output
    static BOOL TraceInited = FALSE;
    DWORD  BytesWritten;

    if (!TraceInited)
    {
        HANDLE InitMutex;
        // Create the mutex to protect the rest of the init code
        InitMutex = CreateMutex(
                                NULL,  // Use default security attributes
                                FALSE, // We don't want automatic ownership
                                "TraceMutextName");
        if (!InitMutex)
        {
            // We failed to create the mutex there is nothign else we
            // can do so return.  This will cause the debug output to
            // be silently lost.
            return;
        } //if

        // Wait on mutex
        WaitForSingleObject( InitMutex,
                             INFINITE);

        // Check to see if init is still needed
        if (!TraceInited)
        {
            // Init the critical section to be used to protect the
            // output portion of this routine.
            InitializeCriticalSection( &OutputRoutine );
// Note:
// DeleteCriticalSection will not be called on this critical section
// we are reling on the OS to clean this one up.  We are doing this so
// the user of this module does not have to Init/DeInit the module explicitly.

            // allocate buffers to hold debug messages
            if (InitMemoryBuffers())
            {
                TraceInited = TRUE;
            } //if
        } //if

        // Signal the mutex and delete this threads handle to the mutex
        ReleaseMutex(InitMutex);
        CloseHandle(InitMutex);

        // Bail out if we couldn't init memory buffers
        if (!TraceInited)
        {
            return;
        }
    }


    // Here is where all the heavy lifting starts
    EnterCriticalSection( &OutputRoutine );

    // print the user message to our buffer
    va_start(ArgumentList, Format);
    vsprintf(g_CurrentMessage, Format, ArgumentList);
    va_end(ArgumentList);

    // Is the current debug message the same as the last debug
    // message?  If the two messages are the same just increment the
    // count of message repeats and return.  This keeps the system
    // from being flooded with debug messages that may be being
    // generated from inside a loop.

    if(lstrcmp(g_CurrentMessage, g_PreviousMessage))
    {
        if (iTraceDestination == TRACE_TO_FILE)
        {
            if (!LogOpened)
            {
                OutputFile =
                CreateFile( TraceFile,
                            GENERIC_WRITE,     // open for writing
                            FILE_SHARE_WRITE,  // Share the file with others
                            NULL,              // default security
                            OPEN_ALWAYS,       // Use file if it exsits
                            FILE_ATTRIBUTE_NORMAL, // Use a normal file
                            NULL);             // No template

                if (OutputFile != INVALID_HANDLE_VALUE)
                {
                    LogOpened = TRUE;
                } //if
            } //if

            if (LogOpened)
            {
                if (RepeatCount > 0)
                {
                    wsprintf(g_PreviousMessage,
                             "Last Message Repeated < %d > times\n",
                             RepeatCount);

                    WriteFile(OutputFile,
                              g_PreviousMessage,
                              lstrlen(g_PreviousMessage),
                              &BytesWritten,
                              NULL);
                } //if

                // Write the current message to the trace file
                WriteFile(OutputFile,
                          g_CurrentMessage,
                          lstrlen(g_CurrentMessage),
                          &BytesWritten,
                          NULL);

                // Flush debug output to file
                FlushFileBuffers( TraceFile );

                //reset the repeat count
                RepeatCount =0;
            } //if
        }

        if( iTraceDestination == TRACE_TO_AUX)
        {
            if(RepeatCount > 0)
            {
                wsprintf(g_PreviousMessage,
                         "Last Message Repeated < %d > times\n",
                         RepeatCount);
                OutputDebugString(g_PreviousMessage);
                RepeatCount = 0;
            }
            // Send message to AUX device
            OutputDebugString(g_CurrentMessage);
        }
        // Store off this message
        lstrcpy(g_PreviousMessage, g_CurrentMessage);
    }
    else
    {
        RepeatCount++;
    }
    LeaveCriticalSection( &OutputRoutine );
}




BOOL
InitMemoryBuffers(
                  VOID
                  )
/*++
  Routine Description:

  Initailizes the memory buffers used by this module.

  Arguments:

  NONE

  Returns:

  TRUE if all memory buffers are successfully created, Otherwise FALSE.

  --*/
{
    BOOL ReturnCode=FALSE;

    g_CurrentMessage = GlobalAlloc (GPTR, TRACE_OUTPUT_BUFFER_SIZE);
    if (g_CurrentMessage)
    {
        ZeroMemory( g_CurrentMessage, TRACE_OUTPUT_BUFFER_SIZE );
        g_PreviousMessage = GlobalAlloc(GPTR, TRACE_OUTPUT_BUFFER_SIZE);
        if (g_PreviousMessage)
        {
            ZeroMemory( g_PreviousMessage, TRACE_OUTPUT_BUFFER_SIZE );
            ReturnCode=TRUE;
        } //if
        else
        {
            GlobalFree( g_CurrentMessage );
            g_CurrentMessage = NULL;
        } //else
    } //if
    return(ReturnCode);
}

LONG
Ws2ExceptionFilter(
    LPEXCEPTION_POINTERS ExceptionPointers,
    LPSTR SourceFile,
    LONG LineNumber
    )
{

    LPSTR fileName;

    //
    // Protect ourselves in case the process is totally messed up.
    //

    __try {

        //
        // Exceptions should never be thrown in a properly functioning
        // system, so this is bad. To ensure that someone will see this,
        // print to the debugger directly
        //


        fileName = strrchr( SourceFile, '\\' );

        if( fileName == NULL ) {
            fileName = SourceFile;
        } else {
            fileName++;
        }

        //
        // Whine about the exception.
        //

        PrintDebugString("-| WS2_32 EXCEPTION   :: ");
        PrintDebugString(" %08lx @ %08lx, caught in %s : %d |-\n",
                            ExceptionPointers->ExceptionRecord->ExceptionCode,
                            ExceptionPointers->ExceptionRecord->ExceptionAddress,
                            fileName, LineNumber );
    }
    __except( EXCEPTION_EXECUTE_HANDLER ) {

        //
        // Not much we can do here...
        //

        ;
    }

    return EXCEPTION_EXECUTE_HANDLER;

}   // Ws2ExceptionFilter

#endif  // TRACING


#if DBG

VOID
WsAssert(
    LPVOID FailedAssertion,
    LPVOID FileName,
    ULONG LineNumber
    )
{

    PrintDebugString(
        "\n"
        "*** Assertion failed: %s\n"
        "*** Source file %s, line %lu\n\n",
        FailedAssertion,
        FileName,
        LineNumber
        );

    DebugBreak();

}   // WsAssert

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\inc\autodial.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    autodial.h

Abstract:

    This module contains definitions for
    Autodial support in Winsock.

Author:

    Anthony Discolo (adiscolo)    15-May-1996

Revision History:

--*/

VOID
InitializeAutodial(VOID);

VOID
UninitializeAutodial(VOID);

BOOL
WSAttemptAutodialAddr(
    IN const struct sockaddr FAR *name,
    IN int namelen
    );

BOOL
WSAttemptAutodialName(
    IN const LPWSAQUERYSETW lpqsRestrictions
    );

VOID
WSNoteSuccessfulHostentLookup(
    IN const char FAR *name,
    IN const ULONG ipaddr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\common\dbgheap.cpp ===
/*++

    Copyright (c) 1996 Microsoft Corporation

Module Name:

    dbgheap.cpp

Abstract:

    This module contains special debug versions of the new and delete
    C++ operators.

    The following functions are exported by this module:

        operator new
        operator delete

Author:

    Keith Moore keithmo@microsoft.com 10-May-1996

Revision History:

--*/

#if DBG

extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

}	// extern "C"

LIST_ENTRY SockHeapListHead;
ULONG SockTotalAllocations = 0;
ULONG SockTotalFrees = 0;
ULONG SockTotalBytesAllocated = 0;
RTL_RESOURCE SocketHeapLock;
BOOLEAN SockHeapDebugInitialized = FALSE;
BOOLEAN SockDebugHeap = FALSE;

PVOID SockHeap = NULL;
PVOID SockCaller1;
PVOID SockCaller2;
BOOLEAN SockDoHeapCheck = TRUE;
BOOLEAN SockDoubleHeapCheck = TRUE;

#define WINSOCK_HEAP_CODE_1 0xabcdef00
#define WINSOCK_HEAP_CODE_2 0x12345678
#define WINSOCK_HEAP_CODE_3 0x87654321
#define WINSOCK_HEAP_CODE_4 0x00fedcba
#define WINSOCK_HEAP_CODE_5 0xa1b2c3d4

#define MAX_STACK_BACKTRACE 3

//
// N.B. This header MUST be quadword aligned!
//

typedef struct _SOCK_HEAP_HEADER {
    ULONG HeapCode1;
    ULONG HeapCode2;
    LIST_ENTRY GlobalHeapListEntry;
    ULONG Size;
    PVOID Stack[MAX_STACK_BACKTRACE];
} SOCK_HEAP_HEADER, *PSOCK_HEAP_HEADER;

typedef struct _SOCK_HEAP_TAIL {
    PSOCK_HEAP_HEADER Header;
    ULONG HeapCode3;
    ULONG HeapCode4;
    ULONG HeapCode5;
} SOCK_HEAP_TAIL, *PSOCK_HEAP_TAIL;

#define FREE_LIST_SIZE 64
SOCK_HEAP_HEADER SockRecentFreeList[FREE_LIST_SIZE];
ULONG SockRecentFreeListIndex = 0;


VOID
SockInitializeDebugData(
    VOID
    )
{
    RtlInitializeResource( &SocketHeapLock );
    InitializeListHead( &SockHeapListHead );

} // SockInitializeDebugData


VOID
SockCheckHeap(
    VOID
    )
{
    PLIST_ENTRY listEntry;
    PLIST_ENTRY lastListEntry = NULL;
    PSOCK_HEAP_HEADER header;
    SOCK_HEAP_TAIL UNALIGNED *tail;

    if( !SockHeapDebugInitialized ) {
        SockInitializeDebugData();
        SockHeapDebugInitialized = TRUE;
    }

    if( !SockDoHeapCheck ) {
        return;
    }

    RtlValidateHeap(
        RtlProcessHeap(),
        0,
        NULL
        );

    RtlAcquireResourceExclusive(
        &SocketHeapLock,
        TRUE
        );

    for( listEntry = SockHeapListHead.Flink;
         listEntry != &SockHeapListHead;
         listEntry = listEntry->Flink ) {

        if( listEntry == NULL ) {
            DbgPrint( "listEntry == NULL, lastListEntry == %lx\n", lastListEntry );
            DbgBreakPoint();
        }

        header = CONTAINING_RECORD( listEntry, SOCK_HEAP_HEADER, GlobalHeapListEntry );
        tail = (SOCK_HEAP_TAIL UNALIGNED *)( (PCHAR)(header + 1) + header->Size );

        if( header->HeapCode1 != WINSOCK_HEAP_CODE_1 ) {
            DbgPrint( "SockCheckHeap, fail 1, header %lx tail %lx\n", header, tail );
            DbgBreakPoint();
        }

        if( header->HeapCode2 != WINSOCK_HEAP_CODE_2 ) {
            DbgPrint( "SockCheckHeap, fail 2, header %lx tail %lx\n", header, tail );
            DbgBreakPoint();
        }

        if( tail->HeapCode3 != WINSOCK_HEAP_CODE_3 ) {
            DbgPrint( "SockCheckHeap, fail 3, header %lx tail %lx\n", header, tail );
            DbgBreakPoint();
        }

        if( tail->HeapCode4 != WINSOCK_HEAP_CODE_4 ) {
            DbgPrint( "SockCheckHeap, fail 4, header %lx tail %lx\n", header, tail );
            DbgBreakPoint();
        }

        if( tail->HeapCode5 != WINSOCK_HEAP_CODE_5 ) {
            DbgPrint( "SockCheckHeap, fail 5, header %lx tail %lx\n", header, tail );
            DbgBreakPoint();
        }

        if( tail->Header != header ) {
            DbgPrint( "SockCheckHeap, fail 6, header %lx tail %lx\n", header, tail );
            DbgBreakPoint();
        }

        lastListEntry = listEntry;
    }

    RtlGetCallersAddress(
        &SockCaller1,
        &SockCaller2
        );

    RtlReleaseResource( &SocketHeapLock );

}   // SockCheckHeap


PVOID
SockAllocateHeap(
    IN ULONG NumberOfBytes
    )
{
    PSOCK_HEAP_HEADER header;
    SOCK_HEAP_TAIL UNALIGNED *tail;

    SockCheckHeap();

    ASSERT( (NumberOfBytes & 0xF0000000) == 0 );

    RtlAcquireResourceExclusive(
        &SocketHeapLock,
        TRUE
        );

    header = (PSOCK_HEAP_HEADER)RtlAllocateHeap(
                 RtlProcessHeap(),
                 0,
                 NumberOfBytes + sizeof(*header) + sizeof(*tail)
                 );

    if( header == NULL ) {
        RtlReleaseResource( &SocketHeapLock );

        if( SockDoubleHeapCheck ) {
            SockCheckHeap();
        }

        return NULL;
    }

    header->HeapCode1 = WINSOCK_HEAP_CODE_1;
    header->HeapCode2 = WINSOCK_HEAP_CODE_2;
    header->Size = NumberOfBytes;

    tail = (SOCK_HEAP_TAIL UNALIGNED *)( (PCHAR)(header + 1) + NumberOfBytes );
    tail->Header = header;
    tail->HeapCode3 = WINSOCK_HEAP_CODE_3;
    tail->HeapCode4 = WINSOCK_HEAP_CODE_4;
    tail->HeapCode5 = WINSOCK_HEAP_CODE_5;

    InsertTailList( &SockHeapListHead, &header->GlobalHeapListEntry );
    SockTotalAllocations++;
    SockTotalBytesAllocated += header->Size;

#if i386
    {
        ULONG hash;

        RtlCaptureStackBackTrace(
            2,
            MAX_STACK_BACKTRACE,
            (PVOID *)&header->Stack,
            &hash
            );
    }
#endif  // i386

    RtlReleaseResource( &SocketHeapLock );

    if( SockDoubleHeapCheck ) {
        SockCheckHeap();
    }

    return (PVOID)(header + 1);

}   // SockAllocateHeap


VOID
SockFreeHeap(
    IN PVOID Pointer
    )
{
    PSOCK_HEAP_HEADER header = (PSOCK_HEAP_HEADER)Pointer - 1;
    SOCK_HEAP_TAIL UNALIGNED * tail;

    SockCheckHeap();

    tail = (SOCK_HEAP_TAIL UNALIGNED *)( (PCHAR)(header + 1) + header->Size );

    RtlAcquireResourceExclusive(
        &SocketHeapLock,
        TRUE
        );

    ASSERT( header->HeapCode1 == WINSOCK_HEAP_CODE_1 );
    ASSERT( header->HeapCode2 == WINSOCK_HEAP_CODE_2 );
    ASSERT( tail->HeapCode3 == WINSOCK_HEAP_CODE_3 );
    ASSERT( tail->HeapCode4 == WINSOCK_HEAP_CODE_4 );
    ASSERT( tail->HeapCode5 == WINSOCK_HEAP_CODE_5 );
    ASSERT( tail->Header == header );

    RemoveEntryList( &header->GlobalHeapListEntry );
    SockTotalFrees++;
    SockTotalBytesAllocated -= header->Size;

    header->HeapCode1 = (ULONG)~WINSOCK_HEAP_CODE_1;
    header->HeapCode2 = (ULONG)~WINSOCK_HEAP_CODE_2;
    tail->HeapCode3 = (ULONG)~WINSOCK_HEAP_CODE_3;
    tail->HeapCode4 = (ULONG)~WINSOCK_HEAP_CODE_4;
    tail->HeapCode5 = (ULONG)~WINSOCK_HEAP_CODE_5;
    tail->Header = NULL;

    RtlReleaseResource( &SocketHeapLock );

    RtlFreeHeap(
        RtlProcessHeap(),
        0,
        (PVOID)header
        );

    if( SockDoubleHeapCheck ) {
        SockCheckHeap();
    }

} // SockFreeHeap


void *
__cdecl
operator new(
    size_t size
    )
{
    return (void *)SockAllocateHeap( (ULONG)size );

}   // operator new


void
__cdecl
operator delete(
    void *ptr
    )
{
    SockFreeHeap( (PVOID)ptr );

}   // operator delete

#endif  // DBG


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\inc\async.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    Async.h

Abstract:

    Global definitions for the WinSock asynchronous processing thread.

Author:

    Keith Moore (keithmo)        18-Jun-1992

Revision History:

--*/


#ifndef _ASYNC_H_
#define _ASYNC_H_


//
// Context block.
//

typedef struct _WINSOCK_CONTEXT_BLOCK {

    LIST_ENTRY AsyncThreadQueueListEntry;
    HANDLE TaskHandle;
    DWORD OpCode;

    union {

        struct {
            HWND hWnd;
            unsigned int wMsg;
            PCHAR Filter;
            int Length;
            int Type;
            PCHAR Buffer;
            int BufferLength;
        } AsyncGetHost;

        struct {
            HWND hWnd;
            unsigned int wMsg;
            PCHAR Filter;
            PCHAR Buffer;
            int BufferLength;
        } AsyncGetProto;

        struct {
            HWND hWnd;
            unsigned int wMsg;
            PCHAR Filter;
            PCHAR Protocol;
            PCHAR Buffer;
            int BufferLength;
        } AsyncGetServ;

    } Overlay;

} WINSOCK_CONTEXT_BLOCK, *PWINSOCK_CONTEXT_BLOCK;

//
// Opcodes for processing by the winsock asynchronous processing
// thread.
//

#define WS_OPCODE_GET_HOST_BY_ADDR    0x01
#define WS_OPCODE_GET_HOST_BY_NAME    0x02
#define WS_OPCODE_GET_PROTO_BY_NUMBER 0x03
#define WS_OPCODE_GET_PROTO_BY_NAME   0x04
#define WS_OPCODE_GET_SERV_BY_PORT    0x05
#define WS_OPCODE_GET_SERV_BY_NAME    0x06
#define WS_OPCODE_TERMINATE           0x07


//
// Initialization/termination functions.
//

BOOL
SockAsyncGlobalInitialize(
    VOID
    );

VOID
SockAsyncGlobalTerminate(
    VOID
    );

BOOL
SockCheckAndInitAsyncThread(
    VOID
    );

VOID
SockTerminateAsyncThread(
    VOID
    );


//
// Work queue functions.
//

PWINSOCK_CONTEXT_BLOCK
SockAllocateContextBlock(
    DWORD AdditionalSpace
    );

VOID
SockFreeContextBlock(
    IN PWINSOCK_CONTEXT_BLOCK ContextBlock
    );

VOID
SockQueueRequestToAsyncThread(
    IN PWINSOCK_CONTEXT_BLOCK ContextBlock
    );

INT
SockCancelAsyncRequest(
    IN HANDLE TaskHandle
    );


#endif  // _ASYNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\inc\classfwd.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    classfwd.h

Abstract:

    This  module  contains "forward" declarations for major types used commonly
    within the WinSock 2 DLL.

Author:

    Paul Drews (drewsxpa@ashland.intel.com) 08-July-1995

Notes:

    $Revision:   1.9  $

    $Modtime:   08 Mar 1996 04:52:58  $

Revision History:

    most-recent-revision-date email-name
        description

    25-July-1995 dirk@mink.intel.com
        Added forward definintions for DCATALOG

    07-09-1995  drewsxpa@ashland.intel.com
        Completed  first  complete  version with clean compile and released for
        subsequent implementation.

    07-08-1995  drewsxpa@ashland.intel.com
        Original version

--*/

#ifndef _CLASSFWD_
#define _CLASSFWD_

#include <windows.h>

class DTHREAD;
typedef DTHREAD FAR * PDTHREAD;

class DPROCESS;
typedef DPROCESS FAR * PDPROCESS;

class DSOCKET;
typedef DSOCKET FAR * PDSOCKET;

class DPROVIDER;
typedef DPROVIDER FAR * PDPROVIDER;

class PROTO_CATALOG_ITEM;
typedef PROTO_CATALOG_ITEM  FAR * PPROTO_CATALOG_ITEM;

class DCATALOG;
typedef DCATALOG FAR * PDCATALOG;

class NSPROVIDER;
typedef NSPROVIDER FAR * PNSPROVIDER;

class NSPSTATE;
typedef NSPSTATE FAR * PNSPSTATE;

class NSCATALOG;
typedef NSCATALOG FAR * PNSCATALOG;

class NSCATALOGENTRY;
typedef NSCATALOGENTRY FAR * PNSCATALOGENTRY;

class NSQUERY;
typedef NSQUERY FAR * PNSQUERY;

class NSPROVIDERSTATE;
typedef NSPROVIDERSTATE FAR * PNSPROVIDERSTATE;


#endif  // _CLASSFWD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\inc\dcatitem.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    dcatitem.h

Abstract:

    This  file  contains the class definition for the PROTO_CATALOG_ITEM class.
    This  class  defines the interface to the entries that can be installed and
    retrieved in the protocol catalog.

Author:

    Paul Drews (drewsxpa@ashland.intel.com) 31-July-1995

Notes:

    $Revision:   1.7  $

    $Modtime:   12 Jan 1996 15:09:02  $

Revision History:

    most-recent-revision-date email-name
        description

    07-31-1995 drewsxpa@ashland.intel.com
        Created  original  version  from  definitions  separated  out  from the
        dcatalog module.

--*/

#ifndef _DCATITEM_
#define _DCATITEM_

#include "winsock2.h"
#include <windows.h>
#include "classfwd.h"


class PROTO_CATALOG_ITEM {
public:

    PROTO_CATALOG_ITEM();

    INT
    InitializeFromRegistry(
        IN  HKEY  ParentKey,
        IN  INT   SequenceNum
        );

    INT
    InitializeFromValues(
        IN  LPSTR               LibraryPath,
        IN  LPWSAPROTOCOL_INFOW ProtoInfo
        );

    LPWSAPROTOCOL_INFOW
    GetProtocolInfo();

    LPGUID
    GetProviderId();

    PCHAR
    GetLibraryPath();

    PDPROVIDER
    GetProvider();

    INT WriteToRegistry(
        IN  HKEY  ParentKey,
        IN  INT   SequenceNum
        );


    VOID
    Reference ();

    VOID
    Dereference ();

private:

    INT
    IoRegistry(
        IN  HKEY  EntryKey,
        IN  BOOL  IsRead
        );


    // Should never be called directly, but through dereferencing.
    ~PROTO_CATALOG_ITEM();

friend class DCATALOG;  // So it can access some of the private fields 
                        // and methods below.
friend class DCATALOG_ITEMS;  // So it can access some of the private fields 
                        // and methods below.
    VOID
    SetProvider(
        IN  PDPROVIDER  Provider
        );

    LIST_ENTRY     m_CatalogLinkage;
    // Used  to  link  items  in  catalog.

    LONG        m_reference_count;
    // This object's reference count

    PDPROVIDER  m_Provider;
    // Pointer to the dprovider object attached to this catalog entry.

    WSAPROTOCOL_INFOW m_ProtoInfo;
    // The cataloged WSAPROTOCOL_INFOW structure.  This is typically used for
    // comparison  when  selecting  a  provider by address family, socket
    // type, etc.

    char m_LibraryPath[MAX_PATH];
    // Fully qualified path to the provider's DLL image.


};  // class PROTO_CATALOG_ITEM

inline
VOID
PROTO_CATALOG_ITEM::Reference () {
    //
    // Object is created with reference count of 1
    // and is destroyed whenever it gets back to 0.
    //
    assert (m_reference_count>0);
    InterlockedIncrement (&m_reference_count);
}


inline
VOID
PROTO_CATALOG_ITEM::Dereference () {
    assert (m_reference_count>0);
    if (InterlockedDecrement (&m_reference_count)==0)
        delete this;
}

inline
LPWSAPROTOCOL_INFOW
PROTO_CATALOG_ITEM::GetProtocolInfo()
/*++

Routine Description:

    This  procedure  retrieves a reference to the protocol info associated with
    the  catalog  item.   Note  that  the  reference is to storage owned by the
    catalog item.  It is the caller's responsibility to make sure the reference
    is no longer used after the catalog item is destroyed.

Arguments:

    None

Return Value:

    Returns a pointer to the associated protocol info.
--*/
{
    return(& m_ProtoInfo);
}  // GetProtocolInfo



inline
LPGUID
PROTO_CATALOG_ITEM::GetProviderId()
/*++

Routine Description:

    This procedure retrieves a the unique ID of the provider associated with
    the catalog item.

Arguments:

    None

Return Value:

    Returns the provider ID (a GUID).
--*/
{
    return &m_ProtoInfo.ProviderId;
}  // GetProviderId



inline
PCHAR
PROTO_CATALOG_ITEM::GetLibraryPath()
/*++

Routine Description:

    This    procedure   retrieves   a   reference   to   the   zero-terminated,
    fully-qualified  path  of  the library that is the service provider for the
    protocol  associated  with the catalog item.  Note that the reference is to
    storage  owned  by  the catalog item.  It is the caller's responsibility to
    make  sure  the  reference  is  no  longer  used  after the catalog item is
    destroyed.

Arguments:

    None

Return Value:

    Returns a pointer to the library path string.
--*/
{
    assert(m_LibraryPath[0] != '\0');
    return(m_LibraryPath);
}  // GetLibraryPath

inline
PDPROVIDER
PROTO_CATALOG_ITEM::GetProvider()
/*++

Routine Description:

    This  procedure  retrieves  a  reference to the DPROVIDER associated with a
    catalog  entry.  Note that the reference may be NULL if no provider has yet
    been loaded for this protocol.

Arguments:

    None

Return Value:

    Returns  the  current provider reference, or NULL if there is no associated
    provider.
--*/
{
    return(m_Provider);
}  // GetProvider

#endif // _DCATITEM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\inc\dcatalog.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    dcatalog.h

Abstract:

    This  module  contains  the  interface  to  the  catalog  of  protocol_info
    structures and their associated providers for the winsock2 DLL.

Author:

    Dirk Brandewie  dirk@mink.intel.com 25-JUL-1995

Notes:

    $Revision:   1.19  $

    $Modtime:   14 Feb 1996 10:40:22  $


Revision History:

    04-Oct-1995  keithmo@microsoft.com
        Added FindIFSProviderForSocket() to fully support sockets inherited
        by or duplicated into the current process.

    31-July-1995 drewsxpa@ashland.intel.com
        Moved catalog item class into a different file.

    27-July-1995 drewsxpa@ashland.intel.com
        Made  changes  to  reflect  the  decision  to make protocol_info be the
        primary identifiable and searchable item instead of provider.

    25-July-1995 dirk@mink.intel.com
        Initial revision.
--*/

#ifndef _DCATALOG_
#define _DCATALOG_

#include "winsock2.h"
#include <windows.h>
#include "classfwd.h"


typedef
BOOL
(* CATALOGITERATION) (
    IN PVOID                PassBack,
    IN PPROTO_CATALOG_ITEM  CatalogEntry
    );
/*++

Routine Description:

    CATALOGITERATION  is  a place-holder for a function supplied by the client.
    The  function  is  called once for each PROTO_CATALOG_ITEM structure in the
    catalog while enumerating the catalog.  The client can stop the enumeration
    early by returning FALSE from the function.

    Note  that  the DPROVIDER associated with an enumerated DPROTO_CATALOG_ITEM
    may  be  NULL.   To retrieve DPROTO_CATALOG_ITEM structure that has had its
    DPROVIDER      loaded      and      initialized,      you      can      use
    GetCatalogItemFromCatalogEntryId.

Arguments:

    PassBack     - Supplies  to  the  client an uninterpreted, unmodified value
                   that  was  specified  by the client in the original function
                   that  requested  the  enumeration.   The client can use this
                   value  to  carry context between the requesting site and the
                   enumeration function.

    CatalogEntry - Supplies  to  the client a reference to a PROTO_CATALOG_ITEM
                   structure with values for this item of the enumeration.

Return Value:

    TRUE  - The  enumeration  should continue with more iterations if there are
            more structures to enumerate.

    FALSE - The enumeration should stop with this as the last iteration even if
            there are more structures to enumerate.

--*/

class DCATALOG_ITEMS {
friend class DCATALOG;
    VOID
    UpdateProtocolList (
        PLIST_ENTRY new_list
        );

    LIST_ENTRY  m_protocol_list;
    // The head of the list of protocol catalog items

    ULONG m_num_items;
    // Number of items in this catalog.
};


class DCATALOG: private DCATALOG_ITEMS
{
public:

    DCATALOG();

    INT
    InitializeFromRegistry(
        IN  HKEY    ParentKey,
        IN  HANDLE  CatalogChangeEvent OPTIONAL
        );

#ifdef _WIN64
    INT
    InitializeFromRegistry32(
        IN  HKEY    ParentKey
    );

    INT
    InitializeFromRegistry64_32(
        IN  HKEY    ParentKey
    );

    VOID
    AppendCatalogItem32(
        IN  PPROTO_CATALOG_ITEM  CatalogItem
        );

    VOID
    RemoveCatalogItem32(
        IN  PPROTO_CATALOG_ITEM  CatalogItem
        );
#endif

    INT
    RefreshFromRegistry (
        IN  HANDLE  CatalogChangeEvent OPTIONAL
        );

    INT
    WriteToRegistry(
        );

    ~DCATALOG();

    VOID
    EnumerateCatalogItems(
        IN CATALOGITERATION  Iteration,
        IN PVOID             PassBack
        );

    INT
    GetCountedCatalogItemFromCatalogEntryId(
        IN  DWORD                     CatalogEntryId,
        OUT PPROTO_CATALOG_ITEM FAR * CatalogItem
        );

    INT
    GetCountedCatalogItemFromAddressFamily(
        IN  INT af,
        OUT PPROTO_CATALOG_ITEM FAR * CatalogItem
        );

    INT
    GetCountedCatalogItemFromAttributes(
        IN  INT   af,
        IN  INT   type,
        IN  INT   protocol,
        IN  DWORD StartAfterId OPTIONAL,
        OUT PPROTO_CATALOG_ITEM FAR * CatalogItem
        );

    DWORD
    AllocateCatalogEntryId(
        );

    VOID
    AppendCatalogItem(
        IN  PPROTO_CATALOG_ITEM  CatalogItem
        );

    VOID
    RemoveCatalogItem(
        IN  PPROTO_CATALOG_ITEM  CatalogItem
        );

    INT
    FindIFSProviderForSocket(
        SOCKET Socket
        );

    static
    LPSTR
    GetCurrentCatalogName(
        VOID
        );

private:

    VOID
    AcquireCatalogLock(
        VOID
        );

    VOID
    ReleaseCatalogLock(
        VOID
        );

    BOOL
    OpenCatalog(
        IN  HKEY   ParentKey
        );

    INT
    LoadProvider(
        IN PPROTO_CATALOG_ITEM CatalogEntry
        );

    PDPROVIDER
    FindAnotherProviderInstance(
        IN LPGUID ProviderId
        );

    ULONG m_serial_num;
    // The serial number of the catalog (changes every time catalog
    // is changed in the registry)

    ULONG m_next_id;
    // Next catalog id number to be assinged to newly installed provider

    HKEY m_reg_key;
    // Handle of the registry key under which catalog resides.
    // We keep it open so we can get notified whenever catalog
    // changes.

    CRITICAL_SECTION m_catalog_lock;
    // A critical section object protecting this class.

#ifdef _WIN64
    union {
        DCATALOG_ITEMS   *m_items32;
        LPCSTR           m_entries_name32;
    };
    static LPCSTR        sm_entries_name32;
#endif
};  // class dcatalog

inline
VOID
DCATALOG::AcquireCatalogLock(
    VOID
    )
{
    EnterCriticalSection( &m_catalog_lock );
}

inline
VOID
DCATALOG::ReleaseCatalogLock(
    VOID
    )
{
    LeaveCriticalSection( &m_catalog_lock );
}

#endif // _DCATALOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\inc\dthook.h ===
/*++

  Copyright (c) 1995 Intel Corp

  Module Name:

    dthook.h

  Abstract:

    Header file containing definitions, function prototypes, and other
    stuff for the Debug/Trace hooks in WinSock 2.

  Author:

    Michael A. Grafton

--*/

#ifndef DTHOOK_H
#define DTHOOK_H

#include "warnoff.h"
#include <windows.h>
#include "dt_dll.h"


//
// Function Declarations
//

LPFNWSANOTIFY
GetPreApiNotifyFP(void);

LPFNWSANOTIFY
GetPostApiNotifyFP(void);

void
DTHookInitialize(void);

void
DTHookShutdown(void);



#ifdef DEBUG_TRACING

#define PREAPINOTIFY(x) \
    ( GetPreApiNotifyFP()  ? ( (*(GetPreApiNotifyFP())) x ) : FALSE)
#define POSTAPINOTIFY(x) \
    if ( GetPostApiNotifyFP() ) { \
         (VOID) ( (*(GetPostApiNotifyFP())) x ); \
    } else

#else

#define PREAPINOTIFY(x) FALSE
#define POSTAPINOTIFY(x)

#endif  // DEBUG_TRACING


#ifdef DEBUG_TRACING
// In  this  case we need function prototypes for the DTHOOK_ prefaced versions
// of  all  the upcall functions.  Alas, the task of keeping these identical to
// the normal WPU function prototypes is an error-prone manual process.

#ifdef __cplusplus
extern "C" {
#endif

BOOL WSPAPI DTHOOK_WPUCloseEvent( WSAEVENT hEvent,
                           LPINT lpErrno );

int WSPAPI DTHOOK_WPUCloseSocketHandle( SOCKET s,
                                 LPINT lpErrno );

WSAEVENT WSPAPI DTHOOK_WPUCreateEvent( LPINT lpErrno );

SOCKET WSPAPI DTHOOK_WPUCreateSocketHandle( DWORD dwCatalogEntryId,
                                     DWORD_PTR dwContext,
                                     LPINT lpErrno );

int WSPAPI DTHOOK_WPUFDIsSet ( SOCKET s,
                        fd_set FAR * set );

int WSPAPI DTHOOK_WPUGetProviderPath( LPGUID lpProviderId,
                               WCHAR FAR * lpszProviderDllPath,
                               LPINT lpProviderDllPathLen,
                               LPINT lpErrno );

SOCKET WSPAPI DTHOOK_WPUModifyIFSHandle( DWORD dwCatalogEntryId,
                                  SOCKET ProposedHandle,
                                  LPINT lpErrno );

BOOL WSPAPI DTHOOK_WPUPostMessage( HWND hWnd,
                            UINT Msg,
                            WPARAM wParam,
                            LPARAM lParam );

int WSPAPI DTHOOK_WPUQueryBlockingCallback( DWORD dwCatalogEntryId,
                                     LPBLOCKINGCALLBACK FAR * lplpfnCallback,
                                     PDWORD_PTR lpdwContext,
                                     LPINT lpErrno );

int WSPAPI DTHOOK_WPUQuerySocketHandleContext( SOCKET s,
                                        PDWORD_PTR lpContext,
                                        LPINT lpErrno );

int WSPAPI DTHOOK_WPUQueueApc( LPWSATHREADID lpThreadId,
                        LPWSAUSERAPC lpfnUserApc,
                        DWORD_PTR dwContext,
                        LPINT lpErrno );

BOOL WSPAPI DTHOOK_WPUResetEvent( WSAEVENT hEvent,
                           LPINT lpErrno );

BOOL WSPAPI DTHOOK_WPUSetEvent( WSAEVENT hEvent,
                         LPINT lpErrno );

int WSPAPI DTHOOK_WPUOpenCurrentThread( OUT LPWSATHREADID lpThreadId,
                        OUT LPINT lpErrno );

int WSPAPI DTHOOK_WPUCloseThread( IN LPWSATHREADID lpThreadId,
                        OUT LPINT lpErrno );

#ifdef __cplusplus
}
#endif

#endif  // DEBUG_TRACING


#endif  // DTHOOK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\inc\llist.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\inc\dsocket.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

dsocket.h

Abstract:

This  header  defines the "DSOCKET" class.  The DSOCKET class defines state
variables  and  operations for DSOCKET objects within the WinSock 2 DLL.  A
DSOCKET  object  represents  all  of the information that the WinSock 2 DLL
knows about a socket created using the Windows Sockets API.

Author:

Paul Drews (drewsxpa@ashland.intel.com) 30-June-1995

Notes:

$Revision:   1.12  $

$Modtime:   08 Mar 1996 00:07:38  $

Revision History:

most-recent-revision-date email-name
description

07-14-1995  dirk@mink.intel.com
    Moved member function descriptions to the implementation file
    dsocket.cpp

07-09-1995  drewsxpa@ashland.intel.com
    Completed  first  complete  version with clean compile and released for
    subsequent implementation.

07-08-95  drewsxpa@ashland.intel.com
Original version

--*/

#ifndef _DSOCKET_
#define _DSOCKET_

#include "winsock2.h"
#include <windows.h>
#include "classfwd.h"
#include "ws2help.h"

class DSOCKET: private WSHANDLE_CONTEXT
{
  public:

    static
    INT
    DSocketClassInitialize();

    static
    INT
    DSocketClassCleanup();

    static
    INT
    AddSpecialApiReference(
        IN SOCKET SocketHandle
        );

    static
    PDSOCKET
    GetCountedDSocketFromSocket(
        IN  SOCKET     SocketHandle
        );

    static
    PDSOCKET
    GetCountedDSocketFromSocketNoExport(
        IN  SOCKET     SocketHandle
        );

    DSOCKET();

    INT
    Initialize(
        IN PPROTO_CATALOG_ITEM  CatalogEntry
        );

    ~DSOCKET();

    SOCKET
    GetSocketHandle();

    PDPROVIDER
    GetDProvider();

    DWORD_PTR
    GetContext();

    VOID
    SetContext(
        IN DWORD_PTR Context
        );

    PPROTO_CATALOG_ITEM
    GetCatalogItem();

    INT
    AssociateSocketHandle(
        IN  SOCKET  SocketHandle,
        IN  BOOLEAN ProviderSocket
        );

    INT
    DisassociateSocketHandle( );

    VOID
    AddDSocketReference(
        );

    VOID
    DropDSocketReference(
        );

    VOID
    DestroyDSocket(
        );

    BOOL
    IsProviderSocket(
        );

    BOOL
    IsApiSocket (
        );

    BOOL
    IsOverlappedSocket (
        );

#ifndef WS2_DEBUGGER_EXTENSION
//
// Give debugger extension access to all fields
//
  private:
#endif

    static
    PDSOCKET
    FindIFSSocket (
        IN  SOCKET     SocketHandle
        );

    friend class DPROCESS;

    static LPCONTEXT_TABLE  sm_context_table;
    // Context tables

//#define m_reference_count   RefCount
//#define m_socket_handle     Handle
    DWORD_PTR   m_handle_context;
    // The  uninterpreted  socket  handle  context  value  that  was  set  by
    // SetContext at the time of WPUCreateSocketHandle.

    PDPROVIDER  m_provider;
    // Reference  to  the  DPROVIDER object representing the service provider
    // that controls this socket.

    PPROTO_CATALOG_ITEM m_catalog_item;
    // The protocol catalog item used to create this socket

    BOOLEAN m_pvd_socket;
    // TRUE if this socket comes from the provider and not created by
    // helper DLL on provider request (WPUCreateSocketHandle).

    BOOLEAN m_api_socket;
    // TRUE if socket was returned via socket/WSASocketA/WSASocketW call,
    //      or imported from IFS provider in other API calls
    // FALSE for sockets that are used only at SPI level (created on
    //      request from layered provider and never exposed to the
    //      application)

    BOOLEAN m_overlapped_socket;
    // To support the hack of creations of non-overlapped handles
    // during Accept and JoinLeaf by handle helper.

#if defined(DEBUG_TRACING) || defined(WS2_DEBUGGER_EXTENSION)
#define SOCKET_STACK_BACKTRACE_DEPTH 2
  public:
	PVOID	m_CreatorBackTrace[SOCKET_STACK_BACKTRACE_DEPTH];
    // Socket creator information
#endif


};   // class DSOCKET



inline SOCKET
DSOCKET::GetSocketHandle()
/*++

Routine Description:

    Retrieves  the  external socket-handle value corresponding to this internal
    DSOCKET object.

Arguments:

    None

Return Value:

    The corresponding external socket-handle value.
--*/
{
    return((SOCKET)Handle);
}




inline PDPROVIDER
DSOCKET::GetDProvider()
/*++

Routine Description:

    Retrieves  a reference to the DPROVIDER object associated with this DSOCKET
    object.

Arguments:

    None

Return Value:

    The reference to the DPROVIDER object associated with this DSOCKET object.
--*/
{
    return(m_provider);
}


inline DWORD_PTR
DSOCKET::GetContext()
/*++

Routine Description:

    This  function  retrieves  the  socket  handle  context  value set with the
    SetContext  operation.   This  function  is typically called at the time of
    WPUQuerySocketHandleContext.  The return value is unspecified if SetContext
    has not been called.

Arguments:

    None

Return Value:

    Returns  the  context  value  that  was  set  by SetContext.  This value is
    uninterpreted by the WinSock 2 DLL.
--*/
{
    return(m_handle_context);
}




inline VOID
DSOCKET::SetContext(
    IN  DWORD_PTR Context
    )
/*++

Routine Description:

    This  function  sets  the  socket  handle  context value.  This function is
    typically called at the time of WPUCreateSocketHandle.

Arguments:

    lpContext - Supplies  the  uninterpreted  socket handle context value to be
                associated with this socket.

Return Value:

    None
--*/
{
    m_handle_context = Context;
}



inline PPROTO_CATALOG_ITEM
DSOCKET::GetCatalogItem()
/*++

Routine Description:

    Retreives the pointer to the catalog item associated with this socket.

Arguments:

Return Value:

    The pointer to the catalog item associated with this socket.
--*/
{
    return(m_catalog_item);
}






inline
BOOL
DSOCKET::IsProviderSocket(
    )
/*++
Routine Description:

    This function returns a boolean indicating whether the object is
    for the socket created by the provider (presumably IFS).

Arguments:

    None

Return Value:

    TRUE  - The object is for the socket created by the provider.

    FALSE - The object is for the socket created by helper DLL.
--*/
{
    return m_pvd_socket;

} // IsProviderSocket



inline
BOOL
DSOCKET::IsApiSocket(
    )
/*++
Routine Description:

    This function returns a boolean indicating whether the object represents
    socket used by API client.

Arguments:

    None

Return Value:

    TRUE  - The socket is used by API client .

    FALSE - The object is used by SPI client.
--*/
{
    return m_api_socket;

} // IsApiSocket


inline
BOOL
DSOCKET::IsOverlappedSocket(
    )
/*++
Routine Description:

    This function returns a boolean indicating whether the object represents
    overlapped socket.

Arguments:

    None

Return Value:

    TRUE  - The socket is overlapped.

    FALSE - The object is non-overlapped.
--*/
{
    return m_overlapped_socket;

} // IsOverlappedSocket





inline VOID
DSOCKET::AddDSocketReference(
    )
/*++
Routine Description:

    Adds a reference to the DSOCKET.

Arguments:

    None

Return Value:

    None
--*/
{

    WahReferenceHandleContext(this);

} // AddDSocketReference


inline VOID
DSOCKET::DropDSocketReference(
    )
/*++
Routine Description:

    Drops the DSOCKET reference and destroys the object
    if reference count is 0.

Arguments:

    None

Return Value:

    None
--*/
{

    if (WahDereferenceHandleContext(this)==0)
        DestroyDSocket ();
} // DropDSocketReference

inline
PDSOCKET
DSOCKET::GetCountedDSocketFromSocket(
    IN  SOCKET     SocketHandle
    )
/*++
Routine Description

    This procedure takes a client socket handle and maps it to a DSOCKET object
    reference.  The reference is counted.

    If socket object corresponding to the handle cannot be found in the table
    this function queires all IFS providers to see if one of the recognizes
    the handle.

    Whenever  this procedure successfuly returns a counted reference, it is the
    responsibility of the caller to eventually call DropDSocketReference.

    Note  that  this  procedure  assumes that the caller has already checked to
    make sure that WinSock is initialized.

Arguments:

    SocketHandle   - Supplies the client-level socket handle to be mapped.


Return Value:
    DSOCKET object or NULL in case the object cannot be found
--*/
{
    PDSOCKET    Socket;
    Socket = static_cast<PDSOCKET>(WahReferenceContextByHandle (
                                        sm_context_table,
                                        (HANDLE)SocketHandle));
    if (Socket!=NULL)
        return Socket;
    else
        return FindIFSSocket (SocketHandle);
}

inline
PDSOCKET
DSOCKET::GetCountedDSocketFromSocketNoExport(
    IN  SOCKET     SocketHandle
    )
/*++
Routine Description

    This procedure takes a client socket handle and maps it to a DSOCKET object
    reference.  The reference is counted.

    No attempt is made to find IFS provider for the socket if it cannot be found
    in the table.  This function is intented for calls from non-IFS providers
    such as in context of WPUQuerySocketHandleContext.

    Whenever  this procedure successfuly returns a counted reference, it is the
    responsibility of the caller to eventually call DropDSocketReference.

    Note  that  this  procedure  assumes that the caller has already checked to
    make sure that WinSock is initialized.

Arguments:

    SocketHandle   - Supplies the client-level socket handle to be mapped.


Return Value:
    DSOCKET object or NULL in case the object cannot be found
--*/
{
    return static_cast<PDSOCKET>(WahReferenceContextByHandle (
                                    sm_context_table,
                                    (HANDLE)SocketHandle));
}

#endif // _DSOCKET_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\inc\getxbyy.h ===
/*++

    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.

Module Name:

    getxbyy.h

Abstract:

    This  module  takes  care  of  forwarding  the getxbyy functions off to the
    correct  alternate  or  fallback  getxbyy  provider.   The only interesting
    internal aspect of the interface to this module is a pair of initialization
    and  shutdown  functions  that  must  be  called  when the WinSock 2 DLL is
    initialized and shut down.

Author:

    Paul Drews (drewsxpa@ashland.intel.com) 12-20-1995

Notes:

    $Revision:   1.1  $

    $Modtime:   12 Jan 1996 15:09:00  $

Revision History:

    12-20-1995 drewsxpa@ashland.intel.com
        Created
--*/

#ifndef _GETXBYY_
#define _GETXBYY_

//
// Obsolete.
//

#endif // _GETXBYY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\inc\dthread.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

dthread.h

Abstract:

This  header  defines the "DTHREAD" class.  The DTHREAD class defines state
variables  and  operations for DTHREAD objects within the WinSock 2 DLL.  A
DTHREAD object represents all of the information known about a thread using
the Windows Sockets API.

Author:

Paul Drews (drewsxpa@ashland.intel.com) 9-July-1995

Notes:

$Revision:   1.19  $

$Modtime:   20 Feb 1996 14:19:04  $

Revision History:

most-recent-revision-date email-name
description

    23-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Moved single line functions to be inlines.

    07-17-1995  dirk@mink.intel.com
        Moved function descriptions to implementation file. Added member
        variable to hold the handle of the Async Helper device.

    07-09-1995  drewsxpa@ashland.intel.com
        Completed  first  complete  version with clean compile and released for
        subsequent implementation.

    9-July-1995 drewsxpa@ashland.intel.com
        Original version

--*/


#ifndef _DTHREAD_
#define _DTHREAD_

#include "winsock2.h"
#include <windows.h>
#include "ws2help.h"
#include "classfwd.h"


#define RESULT_BUFFER_SIZE 32

#define MAX_PROTO_TEXT_LINE 511
#define MAX_PROTO_ALIASES   35

typedef struct _GETPROTO_INFO {

    struct protoent Proto;
    CHAR * Aliases[MAX_PROTO_ALIASES];
    CHAR TextLine[MAX_PROTO_TEXT_LINE+1];

} GETPROTO_INFO, *PGETPROTO_INFO;


class DTHREAD
{
  public:


    static
    INT
    DThreadClassInitialize(
        VOID);

    static
    VOID
    DThreadClassCleanup(
        VOID);

    static
    PDTHREAD
    GetCurrentDThread(
        VOID);

    static
    LPWSATHREADID
    GetCurrentDThreadID(
        IN  PDPROCESS  Process
        );

    static
    INT
    CreateDThreadForCurrentThread(
        IN  PDPROCESS  Process,
        OUT PDTHREAD FAR * CurrentThread
        );

    static
    VOID
    DestroyCurrentThread(
        VOID);

    DTHREAD(
        VOID);

    INT
    Initialize(
        IN PDPROCESS  Process
        );

    ~DTHREAD();


    PCHAR
    GetResultBuffer();

    PCHAR
    CopyHostEnt(LPBLOB pBlob);

    PCHAR
    CopyServEnt(LPBLOB pBlob);

    LPWSATHREADID
    GetWahThreadID();

    LPBLOCKINGCALLBACK
    GetBlockingCallback();

    BOOL
    IsBlocking();

    INT
    CancelBlockingCall();

    FARPROC
    SetBlockingHook(
        FARPROC lpBlockFunc
        );

    INT
    UnhookBlockingHook();

    VOID
    SetOpenType(
        INT OpenType
        );

    INT
    GetOpenType();

    PGETPROTO_INFO
    GetProtoInfo();
#if 0
    //Data member
    LIST_ENTRY  m_dprocess_linkage;

    // Provides the linkage space for a list of DTHREAD objects maintained by
    // the  DPROCESS  object  associated with this DTHREAD object.  Note that
    // this member variable must be public so that the linked-list macros can
    // maniplate the list linkage from within the DPROCESS object's methods.
#endif 
  private:

    static
    INT
    WINAPI
    DefaultBlockingHook();

    static
    BOOL
    CALLBACK
    BlockingCallback(
        DWORD_PTR dwContext
        );

    static DWORD  sm_tls_index;
    // The  class-scope  index  in  thread-local  storage  where  the DTHREAD
    // reference for the thread is stored.

    WSATHREADID  m_wah_thread_id;
    // The  thread  id  used  by  the  WinSock  Async  Helper  mechanism  for
    // processing IO completion callbacks.

    LPBLOCKINGCALLBACK m_blocking_callback;
    FARPROC m_blocking_hook;
    // The  pointer  to  the current client-level blocking hook procedure for
    // the thread.

    HANDLE  m_wah_helper_handle;
    // Handle to the APC helper device

    CHAR  m_result_buffer[RESULT_BUFFER_SIZE];

    //
    // m_hostent_buffer is used to construct a hostent for calls
    // such as gethostbyname. It also contains space for the
    // WSALookupServiceNext results structure.
    //

    PCHAR  m_hostent_buffer;
    PCHAR  m_servent_buffer;
    WORD   m_hostent_size;
    WORD   m_servent_size;

    PDPROCESS  m_process;
    // Reference to the DPROCESS object with which this thread is associated.

    BOOL m_is_blocking;
    // TRUE if this thread is currently in a blocking API.

    BOOL m_io_cancelled;
    // TRUE if current I/O has been cancelled.

    LPWSPCANCELBLOCKINGCALL m_cancel_blocking_call;
    // Pointer to current provider's cancel routine.

    INT m_open_type;
    // Current default socket() open type.

    PGETPROTO_INFO m_proto_info;
    // State for getprotobyXxx().

};  // class DTHREAD


inline PCHAR
DTHREAD::GetResultBuffer()
/*++

Routine Description:

    This function retrieves the pointer to the thread specific result buffer.

Arguments:

Return Value:

    The pointer to the thread specific buffer.

--*/
{
    return(&m_result_buffer[0]);
} //GetResultBuffer

inline PCHAR
DTHREAD::CopyHostEnt(LPBLOB pBlob)
/*++

Routine Description:

    This function copies the hostent in the blob and returns a pointer
    to the per-thread buffer

Arguments:

Return Value:

    The pointer to the thread specific buffer.

--*/
{
    if(m_hostent_size < pBlob->cbSize)
    {
        delete m_hostent_buffer;
        m_hostent_buffer = new CHAR[pBlob->cbSize];
        m_hostent_size = (WORD)pBlob->cbSize;
    }
    if(m_hostent_buffer)
    {
        memcpy(m_hostent_buffer, pBlob->pBlobData, pBlob->cbSize);
    }
    else
    {
        m_hostent_size = 0;
        SetLastError(WSA_NOT_ENOUGH_MEMORY);
    }
    return(m_hostent_buffer);
}

inline PCHAR
DTHREAD::CopyServEnt(LPBLOB pBlob)
/*++

Routine Description:

    This function copies the servent in the blob and returns a pointer
    to the per-thread buffer

Arguments:

Return Value:

    The pointer to the thread specific buffer.

--*/
{
    if(m_servent_size < pBlob->cbSize)
    {
        delete m_servent_buffer;
        m_servent_buffer = new CHAR[pBlob->cbSize];
        m_servent_size = (WORD)pBlob->cbSize;
    }
    if(m_servent_buffer)
    {
        memcpy(m_servent_buffer, pBlob->pBlobData, pBlob->cbSize);
    }
    else
    {
        m_servent_size = 0;
        SetLastError(WSA_NOT_ENOUGH_MEMORY);
    }
    return(m_servent_buffer);
}



inline LPWSATHREADID
DTHREAD::GetWahThreadID()
/*++

Routine Description:

    This  procedure  retrieves  the  per-thread "Thread ID" used by the WinSock
    Asynchronous  Helper  Thread  ID  mechanism  during  the  delivery  of a IO
    completion callback to the client's thread context.

Arguments:

    None

Return Value:

    Returns  the  WinSock  Asynchronous  Helper  Thread ID corresponding to the
    current thread.

Notes:

    // The WahThreadID is created during Initialize, because otherwise we could
    // encounter  an  error  while  trying to complete an overlapped operation,
    // even though the SP part succeeded.
    //
    // There  is  no special benefit in having the DPROCESS object postpone its
    // Wah-related  initialization  until  demanded,  since it will be demanded
    // essentially right away as a parameter added to each IO function.  If the
    // SPI  semantics were changed to only include the thread ID in cases where
    // async  callbacks  are  really  required,  there  could  be  a benefit in
    // postponing  creation of the WahThreadID until we were sure it was really
    // needed.
--*/
{
    return(& m_wah_thread_id);
} //GetWahThreadID



inline
LPBLOCKINGCALLBACK
DTHREAD::GetBlockingCallback()
/*++

Routine Description:

    Returns the blocking callback function pointer for this thread.

Arguments:

    None.

Return Value:

    The pointer to blocking callback function. Note that this may be NULL.

--*/
{
    return m_blocking_callback;
} // GetBlockingCallback



inline
BOOL
DTHREAD::IsBlocking()
/*++

Routine Description:

    Determines if the current thread is currently in a blocking operation.

Arguments:

    None.

Return Value:

    TRUE if the thread is blocking, FALSE otherwise.

--*/
{
    return m_is_blocking;
} // IsBlocking



inline
VOID
DTHREAD::SetOpenType(
    INT OpenType
    )
/*++

Routine Description:

    Sets the "open type" for this thread, as set by the SO_OPENTYPE socket
    option.

Arguments:

    OpenType - The new open type.

Return Value:

    None.

--*/
{
    m_open_type = OpenType;
} // SetOpenType



inline
INT
DTHREAD::GetOpenType()
/*++

Routine Description:

    Returns "open type" for this thread.

Arguments:

    None.

Return Value:

    The open type for this thread.

--*/
{
    return m_open_type;
} // GetOpenType


inline 
LPWSATHREADID
DTHREAD::GetCurrentDThreadID(
    IN  PDPROCESS  Process
    )
{
    PDTHREAD    Thread;
    Thread = (DTHREAD*)TlsGetValue(sm_tls_index);
    if (Thread!=NULL) {
        return Thread->GetWahThreadID ();
    }
    else
        return NULL;
}

inline
PDTHREAD
DTHREAD::GetCurrentDThread()
/*++

Routine Description:

    This  procedure  retrieves a reference to a DTHREAD object corresponding to
    the  current  thread.

Arguments:

Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it
    returns an appropriate WinSock error code.
--*/
{
    return (DTHREAD*)TlsGetValue(sm_tls_index);
}

#endif // _DTHREAD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\inc\dprovide.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

        dprovide.h

Abstract:

        This module defines the WinSock2 class dprovder along with its methods.

Author:

        Mark Hamilton (mark_hamilton@ccm.jf.intel.com) 7-July-1995

Revision History:

    23-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Changed names of private data
        members. Moved single line functions into this header.

    25-July-1995 dirk@mink.intel.com
        Removed process linage data member.

    7-July-1995     mark_hamilton

                Genesis
--*/
#ifndef _DPROVIDER_
#define _DPROVIDER_

#include <winsock2.h>
#include <ws2spi.h>
#include "dthook.h"


class DPROVIDER {

  public:

    DPROVIDER();

    INT
    Initialize(
        IN LPSTR lpszLibFile,
        IN LPWSAPROTOCOL_INFOW lpProtocolInfo);

    SOCKET
    WSPAccept(
        IN SOCKET s,
        OUT struct sockaddr FAR *addr,
        OUT INT FAR *addrlen,
        IN LPCONDITIONPROC lpfnCondition,
        IN DWORD_PTR dwCallbackData,
        OUT INT FAR *lpErrno);

    INT
    WSPAddressToString(
        IN     LPSOCKADDR lpsaAddress,
        IN     DWORD dwAddressLength,
        IN     LPWSAPROTOCOL_INFOW lpProtocolInfo,
        OUT    LPWSTR lpszAddressString,
        IN OUT LPDWORD lpdwAddressStringLength,
        OUT    LPINT lpErrno );

    INT
    WSPAsyncSelect(
        IN SOCKET s,
        IN HWND hWnd,
        IN unsigned int wMsg,
        IN long lEvent,
        OUT INT FAR *lpErrno);

    INT
    WSPBind(
        IN SOCKET s,
        IN const struct sockaddr FAR *name,
        IN INT namelen,
        OUT INT FAR *lpErrno);

    INT
    WSPCancelBlockingCall(
        OUT INT FAR *lpErrno);

    INT
    WSPCleanup(
        OUT INT FAR *lpErrno);

    INT
    WSPCloseSocket(
        IN SOCKET s,
        OUT INT FAR *lpErrno);

    INT
    WSPConnect(
        IN SOCKET s,
        IN const struct sockaddr FAR *name,
        IN INT namelen,
        IN LPWSABUF lpCallerData,
        IN LPWSABUF lpCalleeData,
        IN LPQOS lpSQOS,
        IN LPQOS lpGQOS,
        OUT INT FAR *lpErrno);

    INT
    WSPDuplicateSocket(
        IN SOCKET s,
        IN DWORD dwProcessID,
        IN LPWSAPROTOCOL_INFOW lpProtocolInfo,
        OUT INT FAR *lpErrno);

    INT
    WSPEnumNetworkEvents(
        IN SOCKET s,
        OUT WSAEVENT hEventObject,
        OUT LPWSANETWORKEVENTS lpNetworkEvents,
        OUT INT FAR *lpErrno);

    INT
    WSPEventSelect(
        IN SOCKET s,
        IN OUT WSAEVENT hEventObject,
        IN long lNetworkEvents,
        OUT INT FAR *lpErrno);

    INT
    WSPGetOverlappedResult(
        IN SOCKET s,
        IN LPWSAOVERLAPPED lpOverlapped,
        IN LPDWORD lpcbTransfer,
        IN BOOL fWait,
        OUT LPDWORD lpdwFlags,
        OUT INT FAR *lpErrno);

    INT
    WSPGetPeerName(
        IN SOCKET s,
        OUT struct sockaddr FAR *name,
        OUT INT FAR *namelen,
        OUT INT FAR *lpErrno);

    INT
    WSPGetQOSByName(
        IN SOCKET s,
        IN LPWSABUF lpQOSName,
        IN LPQOS lpQOS,
        OUT INT FAR *lpErrno);

    INT
    WSPGetSockName(
        IN SOCKET s,
        OUT struct sockaddr FAR *name,
        OUT INT FAR *namelen,
        OUT INT FAR *lpErrno);

    INT
    WSPGetSockOpt(
        IN SOCKET s,
        IN INT level,
        IN INT optname,
        OUT char FAR *optval,
        OUT INT FAR *optlen,
        OUT INT FAR *lpErrno);

    INT
    WSPIoctl(
        IN SOCKET s,
        IN DWORD dwIoControlCode,
        IN LPVOID lpvInBuffer,
        IN DWORD cbInBuffer,
        IN LPVOID lpvOutBuffer,
        IN DWORD cbOutBuffer,
        IN LPDWORD lpcbBytesReturned,
        IN LPWSAOVERLAPPED lpOverlapped,
        IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
        IN LPWSATHREADID lpThreadId,
        OUT INT FAR *lpErrno);

    SOCKET
    WSPJoinLeaf(
        IN SOCKET s,
        IN const struct sockaddr FAR *name,
        IN INT namelen,
        IN LPWSABUF lpCallerData,
        IN LPWSABUF lpCalleeData,
        IN LPQOS lpSQOS,
        IN LPQOS lpGQOS,
        IN DWORD dwFlags,
        OUT INT FAR *lpErrno);

    INT
    WSPListen(
        IN SOCKET s,
        IN INT backlog,
        OUT INT FAR *lpErrno);


    INT
    WSPRecv(
        IN SOCKET s,
        IN LPWSABUF lpBuffers,
        IN DWORD dwBufferCount,
        IN LPDWORD lpNumberOfBytesRecvd,
        IN OUT LPDWORD lpFlags,
        IN LPWSAOVERLAPPED lpOverlapped,
        IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
        IN LPWSATHREADID lpThreadId,
        OUT INT FAR *lpErrno);


    INT
    WSPRecvDisconnect(
        IN SOCKET s,
        IN LPWSABUF lpInboundDisconnectData,
        OUT INT FAR *lpErrno);


    INT
    WSPRecvFrom(
        IN SOCKET s,
        IN LPWSABUF lpBuffers,
        IN DWORD dwBufferCount,
        IN LPDWORD lpNumberOfBytesRecvd,
        IN OUT LPDWORD lpFlags,
        OUT  struct sockaddr FAR *  lpFrom,
        IN LPINT lpFromlen,
        IN LPWSAOVERLAPPED lpOverlapped,
        IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
        IN LPWSATHREADID lpThreadId,
        OUT INT FAR *lpErrno);


    INT
    WSPSelect(
        IN INT nfds,
        IN OUT fd_set FAR *readfds,
        IN OUT fd_set FAR *writefds,
        IN OUT fd_set FAR *exceptfds,
        IN const struct timeval FAR *timeout,
        OUT INT FAR *lpErrno);


    INT
    WSPSend(
        IN SOCKET s,
        IN LPWSABUF lpBuffers,
        IN DWORD dwBufferCount,
        OUT LPDWORD lpNumberOfBytesSent,
        IN DWORD dwFlags,
        IN LPWSAOVERLAPPED lpOverlapped,
        IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
        IN LPWSATHREADID lpThreadId,
        OUT INT FAR *lpErrno);

    INT
    WSPSendDisconnect(
        IN SOCKET s,
        IN LPWSABUF lpOutboundDisconnectData,
        OUT INT FAR *lpErrno);

    INT
    WSPSendTo(
        IN SOCKET s,
        IN LPWSABUF lpBuffers,
        IN DWORD dbBufferCount,
        IN LPDWORD lpNumberOfBytesSent,
        IN DWORD dwFlags,
        IN const struct sockaddr FAR * lpTo,
        IN INT iTolen,
        IN LPWSAOVERLAPPED lpOverlapped,
        IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
        IN LPWSATHREADID lpThreadId,
        OUT INT FAR *lpErrno);

    INT
    WSPSetSockOpt(
        IN SOCKET s,
        IN INT level,
        IN INT optname,
        IN const char FAR *optval,
        IN INT optlen,
        OUT INT FAR *lpErrno);

    INT
    WSPShutdown(
        IN SOCKET s,
        IN INT how,
        OUT INT FAR *lpErrno);

    SOCKET
    WSPSocket(
        IN int af,
        IN int type,
        IN int protocol,
        IN LPWSAPROTOCOL_INFOW lpProtocolInfo,
        IN GROUP g,
        IN DWORD dwFlags,
        OUT INT FAR *lpErrno);

    INT
    WSPStringToAddress(
        IN     LPWSTR AddressString,
        IN     INT AddressFamily,
        IN     LPWSAPROTOCOL_INFOW lpProtocolInfo,
        OUT    LPSOCKADDR lpAddress,
        IN OUT LPINT lpAddressLength,
        IN OUT LPINT lpErrno );

    DWORD_PTR
    GetCancelCallPtr();

    VOID
    Reference ();

    VOID
    Dereference ();

private:
    // Destruction should be done using dereferencing
    ~DPROVIDER();

    // Variables
    LONG             m_reference_count;
    HINSTANCE        m_library_handle;
    WSPPROC_TABLE    m_proctable;
#ifdef DEBUG_TRACING
    LPSTR            m_lib_name;
#endif
};

inline
VOID
DPROVIDER::Reference () {
    //
    // Object is created with reference count of 1
    // and is destroyed whenever it gets back to 0.
    //
    assert (m_reference_count>0);
    InterlockedIncrement (&m_reference_count);
}


inline
VOID
DPROVIDER::Dereference () {
    assert (m_reference_count>0);
    if (InterlockedDecrement (&m_reference_count)==0)
        delete this;
}

inline
DWORD_PTR
DPROVIDER::GetCancelCallPtr()
{
    return((DWORD_PTR)m_proctable.lpWSPCancelBlockingCall);
}



inline SOCKET
DPROVIDER::WSPAccept(
    IN SOCKET s,
    OUT struct sockaddr FAR *addr,
    OUT INT FAR *addrlen,
    IN LPCONDITIONPROC lpfnCondition,
    IN DWORD_PTR dwCallbackData,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Conditionally  accept a connection based on the return value of a condition
    function, and optionally create and/or join a socket group.

Arguments:

    s              - A  descriptor  identiying  a socket which is listening for
                     connections after a WSPListen().

    addr           - An optional pointer to a buffer which receives the address
                     of   the  connecting  entity,  as  known  to  the  service
                     provider.   The  exact  format  of  the  addr arguement is
                     determined  by  the  address  family  established when the
                     socket was created.

    addrlen        - An  optional  pointer  to  an  integer  which contains the
                     length of the address addr.

    lpfnCondition  - The  procedure  instance address of an optional, WinSock 2
                     client  supplied  condition  function  which  will make an
                     accept/reject  decision  based  on  the caller information
                     passed  in  as  parameters,  and optionally creaetd and/or
                     join  a  socket group by assigning an appropriate value to
                     the result parameter of this function.

    dwCallbackData - Callback data to be passed back to the WinSock 2 client as
                     a  condition  function  parameter.   This parameter is not
                     interpreted by the service provider.

    lpErrno        - A pointer to the error code.

Return Value:

    If  no  error occurs, WSPAccept() returns a value of type SOCKET which is a
    descriptor  for  the accepted socket.  Otherwise, a value of INVALID_SOCKET
    is returned, and a specific error code is available in lpErrno.

--*/
{
    SOCKET ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPAccept,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &addr,
                       &addrlen,
                       &lpfnCondition,
                       &dwCallbackData,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPAccept(
        s,
        addr,
        addrlen,
        lpfnCondition,
        dwCallbackData,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPAccept,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &addr,
                    &addrlen,
                    &lpfnCondition,
                    &dwCallbackData,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);

}




inline INT
DPROVIDER::WSPAddressToString(
    IN     LPSOCKADDR lpsaAddress,
    IN     DWORD dwAddressLength,
    IN     LPWSAPROTOCOL_INFOW lpProtocolInfo,
    OUT    LPWSTR lpszAddressString,
    IN OUT LPDWORD lpdwAddressStringLength,
    OUT    LPINT lpErrno )
/*++

Routine Description:

    WSPAddressToString() converts a SOCKADDR structure into a human-readable
    string representation of the address.  This is intended to be used mainly
    for display purposes. If the caller wishes the translation to be done by a
    particular provider, it should supply the corresponding WSAPROTOCOL_INFOW
    struct in the lpProtocolInfo parameter.

Arguments:

    lpsaAddress - points to a SOCKADDR structure to translate into a string.

    dwAddressLength - the length of the Address SOCKADDR.

    lpProtocolInfo - (optional) the WSAPROTOCOL_INFOW struct for a particular
                     provider.

    lpszAddressString - a buffer which receives the human-readable address
                        string.

    lpdwAddressStringLength - on input, the length of the AddressString buffer.
                              On output, returns the length of  the string
                              actually copied into the buffer.

Return Value:

    The return value is 0 if the operation was successful.  Otherwise the value
    SOCKET_ERROR is returned
--*/
{
     INT ReturnValue;

     assert (m_reference_count>0);
     if (PREAPINOTIFY(( DTCODE_WSPAddressToString,
                        &ReturnValue,
                        m_lib_name,
                        &lpsaAddress,
                        &dwAddressLength,
                        &lpProtocolInfo,
                        &lpszAddressString,
                        &lpdwAddressStringLength,
                        &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPAddressToString(
        lpsaAddress,
        dwAddressLength,
        lpProtocolInfo,
        lpszAddressString,
        lpdwAddressStringLength,
        lpErrno);


    POSTAPINOTIFY(( DTCODE_WSPAddressToString,
                    &ReturnValue,
                    m_lib_name,
                    &lpsaAddress,
                    &dwAddressLength,
                    &lpProtocolInfo,
                    &lpszAddressString,
                    &lpdwAddressStringLength,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}





inline INT
DPROVIDER::WSPAsyncSelect(
    IN SOCKET s,
    IN HWND hWnd,
    IN unsigned int wMsg,
    IN long lEvent,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Request  Windows  message-based  event notification of network events for a
    socket.

Arguments:

    s       - A  descriptor identiying a socket for which event notification is
              required.

    hWnd    - A  handle  identifying  the window which should receive a message
              when a network event occurs.

    wMsg    - The message to be sent when a network event occurs.

    lEvent  - bitmask  which specifies a combination of network events in which
              the WinSock client is interested.

    lpErrno - A pointer to the error code.

Return Value:

    The  return  value  is 0 if the WinSock client's declaration of interest in
    the  netowrk event set was successful.  Otherwise the value SOCKET_ERROR is
    returned, and a specific error code is available in lpErrno.

--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPAsyncSelect,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &hWnd,
                       &wMsg,
                       &lEvent,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPAsyncSelect(
        s,
        hWnd,
        wMsg,
        lEvent,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPAsyncSelect,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &hWnd,
                    &wMsg,
                    &lEvent,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);

}



inline INT
DPROVIDER::WSPBind(
    IN SOCKET s,
    IN const struct sockaddr FAR *name,
    IN INT namelen,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Associate a local address (i.e. name) with a socket.

Arguments:

    s       - A descriptor identifying an unbound socket.

    name    - The  address  to assign to the socket.  The sockaddr structure is
              defined as follows:

              struct sockaddr {
                  u_short sa_family;
                  char    sa_data[14];
              };

              Except  for  the sa_family field,
sockaddr contents are epxressed
              in network byte order.

    namelen - The length of the name.

    lpErrno - A pointer to the error code.

Return Value:

    If   no   erro   occurs,  WSPBind()  returns  0.   Otherwise, it  returns
    SOCKET_ERROR, and a specific error code is available in lpErrno.

--*/
{
    INT ReturnValue;
    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPBind,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &name,
                       &namelen,
                       &lpErrno)) ) {

        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPBind(
        s,
        name,
        namelen,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPBind,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &name,
                    &namelen,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);

}



inline INT
DPROVIDER::WSPCancelBlockingCall(OUT INT FAR *lpErrno)
/*++
Routine Description:

    Cancel a blocking call which is currently in progress.

Arguments:

    lpErrno - A pointer to the error code.

Return Value:

    The  value  returned  by  WSPCancelBlockingCall() is 0 if the operation was
    successfully canceled.  Otherwise the value SOCKET_ERROR is returned,
and a
    specific error code is available in lpErrno.

--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPCancelBlockingCall,
                       &ReturnValue,
                       m_lib_name,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPCancelBlockingCall(
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPCancelBlockingCall,
                    &ReturnValue,
                    m_lib_name,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);

}



inline INT
DPROVIDER::WSPCloseSocket(
    IN SOCKET s,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Close a socket.

Arguments:

    s       - A descriptor identifying a socket.

    lpErrno - A pointer to the error code.

Return Value:

    If  no  erro  occurs, WSPCloseSocket()  returns  0.  Otherwise, a value of
    SOCKET_ERROR  is  returned,  and  a  specific  error  code  is available in
    lpErrno.

--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPCloseSocket,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPCloseSocket(
        s,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPCloseSocket,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);

}



inline INT
DPROVIDER::WSPConnect(
    IN SOCKET s,
    IN const struct sockaddr FAR *name,
    IN INT namelen,
    IN LPWSABUF lpCallerData,
    IN LPWSABUF lpCalleeData,
    IN LPQOS lpSQOS,
    IN LPQOS lpGQOS,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Establish a connection to a peer,
exchange connect data,
and specify needed
    quality of service based on the supplied flow spec.

Arguments:

    s            - A descriptor identifying an unconnected socket.

    name         - The name of the peer to which the socket is to be connected.

    namelen      - The length of the name.

    lpCallerData - A  pointer to the user data that is to be transferred to the
                   peer during connection established.

    lpCalleeData - A pointer to a buffer into which may be copied any user data
                   received from the peer during connection establishment.

    lpSQOS       - A  pointer  to  the  flow  specs  for socket s, one for each
                   direction.

    lpGQOS       - A  pointer  to  the  flow  specs  for  the  socket group (if
                   applicable).

    lpErrno      - A pointer to the error code.

Return Value:

    If  no  error  occurs, WSPConnect()  returns ERROR_SUCCESS.  Otherwise, it
    returns SOCKET_ERROR, and a specific erro rcode is available in lpErrno.

--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPConnect,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &name,
                       &namelen,
                       &lpCallerData,
                       &lpCalleeData,
                       &lpSQOS,
                       &lpGQOS,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPConnect(
        s,
        name,
        namelen,
        lpCallerData,
        lpCalleeData,
        lpSQOS,
        lpGQOS,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPConnect,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &name,
                    &namelen,
                    &lpCallerData,
                    &lpCalleeData,
                    &lpSQOS,
                    &lpGQOS,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);

}



inline INT
DPROVIDER::WSPDuplicateSocket(
    IN SOCKET s,
    IN DWORD dwProcessID,
    IN LPWSAPROTOCOL_INFOW lpProtocolInfo,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    descriptor for a shared socket.


Arguments:

    s              - Specifies the local socket descriptor.

    dwProcessID    - Specifies  the  ID  of  the  target  process for which the
                     shared socket will be used.

    lpProtocolInfo - A  pointer  to  a  buffer  allocated by the client that is
                     large enough to contain a WSAPROTOCOL_INFOW struct.  The
                     service  provider copies the protocol info struct contents
                     to this buffer.

    lpErrno        - A pointer to the error code

Return Value:

    If  no  error  occurs, WPSDuplicateSocket()  returns zero.  Otherwise, the
    value of SOCKET_ERROR is returned, and a specific error number is available
    in lpErrno.

--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPDuplicateSocket,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &dwProcessID,
                       &lpProtocolInfo,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPDuplicateSocket(
        s,
        dwProcessID,
        lpProtocolInfo,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPDuplicateSocket,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &dwProcessID,
                    &lpProtocolInfo,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);

}



inline INT
DPROVIDER::WSPEnumNetworkEvents(
    IN SOCKET s,
    OUT WSAEVENT hEventObject,
    OUT LPWSANETWORKEVENTS lpNetworkEvents,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Report occurrences of network events for the indicated socket.

Arguments:

    s               - A descriptor identifying the socket.

    hEventObject    - An optional handle identifying an associated event object
                      to be reset.

    lpNetworkEvents - A  pointer  to  a WSANETWORKEVENTS struct which is filled
                      with   a  record  of  occurred  network  events  and  any
                      associated error codes.

    lpErrno         - A pointer to the error code.

Return Value:

    The  return  value  is  ERROR_SUCCESS  if  the  operation  was  successful.
    Otherwise  the  value SOCKET_ERROR is returned, and a specific error number
    is available in lpErrno.

--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPEnumNetworkEvents,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &hEventObject,
                       &lpNetworkEvents,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPEnumNetworkEvents(
        s,
        hEventObject,
        lpNetworkEvents,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPEnumNetworkEvents,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &hEventObject,
                    &lpNetworkEvents,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);

}



inline INT
DPROVIDER::WSPEventSelect(
    IN SOCKET s,
    IN OUT WSAEVENT hEventObject,
    IN long lNetworkEvents,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Specify  an  event object to be associated with the supplied set of network
    events.

Arguments:

    s              - A descriptor identifying the socket.

    hEventObject   - A  handle  identifying  the  event object to be associated
                     with the supplied set of network events.

    lNetworkEvents - A  bitmask  which  specifies  the  combination  of network
                     events in which the WinSock client has interest.

    lpErrno        - A pointer to the error code.

Return Value:

    The return value is 0 if the WinSock client's specification of the network
    events and the associated event object was successful. Otherwise the value
    SOCKET_ERROR is returned, and a specific error number is available in
    lpErrno

--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPEventSelect,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &hEventObject,
                       &lNetworkEvents,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPEventSelect(
        s,
        hEventObject,
        lNetworkEvents,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPEventSelect,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &hEventObject,
                    &lNetworkEvents,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);

}



inline INT
DPROVIDER::WSPGetOverlappedResult(
    IN SOCKET s,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPDWORD lpcbTransfer,
    IN BOOL fWait,
    OUT LPDWORD lpdwFlags,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Returns the results of an overlapped operation on the specified socket.

Arguments:

    s            - Identifies  the  socket.   This  is the same socket that was
                   specified  when  the  overlapped  operation was started by a
                   call to WSPRecv(), WSPRecvFrom(), WSPSend(), WSPSendTo(), or
                   WSPIoctl().

    lpOverlapped - Points to a WSAOVERLAPPED structure that was specified
                   when the overlapped operation was started.

    lpcbTransfer - Points to a 32-bit variable that receives the number of
                   bytes that were actually transferred by a send or receive
                   operation, or by WSPIoctl().

    fWait        - Specifies  whether  the function should wait for the pending
                   overlapped  operation  to  complete.   If TRUE, the function
                   does  not return until the operation has been completed.  If
                   FALSE  and  the  operation  is  still  pending, the function
                   returns FALSE and lperrno is WSA_IO_INCOMPLETE.

    lpdwFlags    - Points  to  a  32-bit variable that will receive one or more
                   flags   that  supplement  the  completion  status.   If  the
                   overlapped   operation   was   initiated  via  WSPRecv()  or
                   WSPRecvFrom(), this parameter will contain the results value
                   for lpFlags parameter.

    lpErrno      - A pointer to the error code.

Return Value:

    If WSPGetOverlappedResult() succeeds,the return value is TRUE.  This means
    that the overlapped operation has completed successfully and that the value
    pointed  to  by lpcbTransfer has been updated.  If WSPGetOverlappedResult()
    returns  FALSE,  this  means  that  either the overlapped operation has not
    completed  or  the  overlapped operation completed but with errors, or that
    completion  status  could  not  be  determined due to errors in one or more
    parameters  to  WSPGetOverlappedResult().  On failure, the value pointed to
    by  lpcbTransfer  will  not be updated.  lpErrno indicates the cause of the
    failure (either of WSPGetOverlappedResult() or of the associated overlapped
    operation).

--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPGetOverlappedResult,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &lpOverlapped,
                       &lpcbTransfer,
                       &fWait,
                       &lpdwFlags,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPGetOverlappedResult(
        s,
        lpOverlapped,
        lpcbTransfer,
        fWait,
        lpdwFlags,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPGetOverlappedResult,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &lpOverlapped,
                    &lpcbTransfer,
                    &fWait,
                    &lpdwFlags,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}



inline INT
DPROVIDER::WSPGetPeerName(
    IN SOCKET s,
    OUT struct sockaddr FAR *name,
    OUT INT FAR *namelen,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Get the address of the peer to which a socket is connected.

Arguments:

    s       - A descriptor identifying a connected socket.

    name    - A  pointer  to  the structure which is to receive the name of the
              peer.

    namelen - A  pointer  to  an integer which, on input, indicates the size of
              the  structure  pointed  to  by name, and on output indicates the
              size of the returned name.

    lpErrno - A pointer to the error code.

Return Value:

    If  no  error occurs, WSPGetPeerName() returns ERROR_SUCCESS.  Otherwise, a
    value  of  SOCKET_ERROR is returned, and a specific error code is available
    in lpErrno

--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPGetPeerName,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &name,
                       &namelen,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPGetPeerName(
        s,
        name,
        namelen,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPGetPeerName,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &name,
                    &namelen,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}



inline INT
DPROVIDER::WSPGetQOSByName(
    IN SOCKET s,
    IN LPWSABUF lpQOSName,
    IN LPQOS lpQOS,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Initializes a QOS structure based on a named template.

Arguments:

    s         - A descriptor identifying a socket.

    lpQOSName - Specifies the QOS template name.

    lpQOS     - A pointer to the QOS structure to be filled.

    lpErrno   - A pointer to the error code.

Return Value:

    If the function succeeds, the return value is TRUE.  If the function fails,
    the  return  value  is  FALSE, and  a  specific error code is available in
    lpErrno.

--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPGetQOSByName,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &lpQOSName,
                       &lpQOS,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPGetQOSByName(
        s,
        lpQOSName,
        lpQOS,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPGetQOSByName,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &lpQOSName,
                    &lpQOS,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}



inline INT
DPROVIDER::WSPGetSockName(
    IN SOCKET s,
    OUT struct sockaddr FAR *name,
    OUT INT FAR *namelen,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Get the local name for a socket.

Arguments:

    s       - A descriptor identifying a bound socket.

    name    - A pointer to a structure used to supply the address (name) of the
              socket.

    namelen - A  pointer  to  an integer which, on input, indicates the size of
              the  structure  pointed  to  by name, and on output indicates the
              size of the returned name

    lpErrno - A Pointer to the error code.

Return Value:

    If  no  error occurs, WSPGetSockName() returns ERROR_SUCCESS.  Otherwise, a
    value  of  SOCKET_ERROR is returned, and a specific error code is available
    in lpErrno.

--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPGetSockName,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &name,
                       &namelen,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPGetSockName(
        s,
        name,
        namelen,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPGetSockName,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &name,
                    &namelen,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}



inline INT
DPROVIDER::WSPGetSockOpt(
    IN SOCKET s,
    IN INT level,
    IN INT optname,
    OUT char FAR *optval,
    OUT INT FAR *optlen,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Retrieve a socket option.

Arguments:

    s       - A descriptor identifying a socket.

    level   - The  level  at  which the option is defined; the supported levels
              include SOL_SOCKET (See annex for more protocol-specific levels.)

    optname - The socket option for which the value is to be retrieved.

    optval  - A  pointer  to  the  buffer  in which the value for the requested
              option is to be returned.

    optlen  - A pointer to the size of the optval buffer.

    lpErrno - A pointer to the error code.

Return Value:

    If  no  error  occurs,  WSPGetSockOpt()  returns  0.  Otherwise, a value of
    SOCKET_ERROR  is  returned,  and  a  specific  error  code  is available in
    lpErrno.

--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPGetSockOpt,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &level,
                       &optname,
                       &optval,
                       &optlen,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPGetSockOpt(
        s,
        level,
        optname,
        optval,
        optlen,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPGetSockOpt,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &level,
                    &optname,
                    &optval,
                    &optlen,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}


inline INT
DPROVIDER::WSPIoctl(
    IN SOCKET s,
    IN DWORD dwIoControlCode,
    IN LPVOID lpvInBuffer,
    IN DWORD cbInBuffer,
    IN LPVOID lpvOutBuffer,
    IN DWORD cbOutBuffer,
    IN LPDWORD lpcbBytesReturned,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    IN LPWSATHREADID lpThreadId,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Control the mode of a socket.

Arguments:

    s                   - Handle to a socket

    dwIoControlCode     - Control code of operation to perform

    lpvInBuffer         - Address of input buffer

    cbInBuffer          - Size of input buffer

    lpvOutBuffer        - Address of output buffer

    cbOutBuffer         - Size of output buffer

    lpcbBytesReturned   - A pointer to the size of output buffer's contents.

    lpOverlapped        - Address of WSAOVERLAPPED structure

    lpCompletionRoutine - A  pointer  to the completion routine called when the
                          operation has been completed.

    lpThreadId          - A  pointer to a thread ID structure to be used by the
                          provider

    lpErrno             - A pointer to the error code.

Return Value:

    If  no error occurs and the operation has completed immediately, WSPIoctl()
    returns  0.   Note  that in this case the completion routine, if specified,
    will  have  already  been  queued.   Otherwise, a value of SOCKET_ERROR is
    returned, and  a  specific  error code is available in lpErrno.  The error
    code  WSA_IO_PENDING  indicates  that  an  overlapped  operation  has  been
    successfully  initiated  and  that  conpletion will be indicated at a later
    time.   Any  other  error  code  indicates that no overlapped operation was
    initiated and no completion indication will occur.

--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPIoctl,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &dwIoControlCode,
                       &lpvInBuffer,
                       &cbInBuffer,
                       &lpvOutBuffer,
                       &cbOutBuffer,
                       &lpcbBytesReturned,
                       &lpOverlapped,
                       &lpCompletionRoutine,
                       &lpThreadId,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPIoctl(
        s,
        dwIoControlCode,
        lpvInBuffer,
        cbInBuffer,
        lpvOutBuffer,
        cbOutBuffer,
        lpcbBytesReturned,
        lpOverlapped,
        lpCompletionRoutine,
        lpThreadId,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPIoctl,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &dwIoControlCode,
                    &lpvInBuffer,
                    &cbInBuffer,
                    &lpvOutBuffer,
                    &cbOutBuffer,
                    &lpcbBytesReturned,
                    &lpOverlapped,
                    &lpCompletionRoutine,
                    &lpThreadId,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}



inline SOCKET
DPROVIDER::WSPJoinLeaf(
    IN SOCKET s,
    IN const struct sockaddr FAR *name,
    IN INT namelen,
    IN LPWSABUF lpCallerData,
    IN LPWSABUF lpCalleeData,
    IN LPQOS lpSQOS,
    IN LPQOS lpGQOS,
    IN DWORD dwFlags,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Join  a  leaf  node  into  a multipoint session, exchange connect data, and
    specify needed quality of service based on the supplied flow specs.

Arguments:

    s            - A descriptor identifying a multipoint socket.

    name         - The name of the peer to which the socket is to be joined.

    namelen      - The length of the name.

    lpCallerData - A  pointer to the user data that is to be transferred to the
                   peer during multipoint session establishment.

    lpCalleeData - A  pointer  to  the user data that is to be transferred back
                   from the peer during multipoint session establishment.

    lpSQOS       - A  pointer  to  the  flow  specs  for socket s, one for each
                   direction.

    lpGQOS       - A  pointer  to  the  flow  specs  for  the  socket group (if
                   applicable).

    dwFlags      - Flags  to  indicate  that  the socket is acting as a sender,
                   receiver, or both.

    lpErrno      - A pointer to the error code.

Return Value:

    If no error occurs,
WSPJoinLeaf() returns a value of type SOCKET which is a
    descriptor  for the newly created multipoint socket.  Otherwise,a value of
    INVALID_SOCKET  is  returned, and  a  specific  error code is available in
    lpErrno.

--*/
{
    SOCKET ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPJoinLeaf,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &name,
                       &namelen,
                       &lpCallerData,
                       &lpCalleeData,
                       &lpSQOS,
                       &lpGQOS,
                       &dwFlags,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPJoinLeaf(
        s,
        name,
        namelen,
        lpCallerData,
        lpCalleeData,
        lpSQOS,
        lpGQOS,
        dwFlags,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPJoinLeaf,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &name,
                    &namelen,
                    &lpCallerData,
                    &lpCalleeData,
                    &lpSQOS,
                    &lpGQOS,
                    &dwFlags,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);

}



inline INT
DPROVIDER::WSPListen(
    IN SOCKET s,
    IN INT backlog,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Establish a socket to listen for incoming connections.

Arguments:

    s       - A descriptor identifying a bound,
unconnected socket.

    backlog - The  maximum length to which the queue of pending connections may
              grow.   If  this  value  is  SOMAXCONN,
then the service provider
              should set the backlog to a maximum "reasonable" value.

    lpErrno - A pointer to the error code.

Return Value:

    If  no  error  occurs, WSPListen()  returns  0.   Otherwise, a  value  of
    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in
    lpErrno.

--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPListen,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &backlog,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPListen(
        s,
        backlog,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPListen,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &backlog,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);

}



inline INT
DPROVIDER::WSPRecv(
    IN SOCKET s,
    IN LPWSABUF lpBuffers,
    IN DWORD dwBufferCount,
    IN LPDWORD lpNumberOfBytesRecvd,
    IN OUT LPDWORD lpFlags,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    IN LPWSATHREADID lpThreadId,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Receive data on a socket.

Arguments:

    s                    - A descriptor identifying a connected socket.

    lpBuffers            - A  pointer  to  an array of WSABUF structures.  Each
                           WSABUF  structure contains a pointer to a buffer and
                           the length of the buffer.

    dwBufferCount        - The  number  of  WSABUF  structures in the lpBuffers
                           array.

    lpNumberOfBytesRecvd - A  pointer  to  the number of bytes received by this
                           call.

    lpFlags              - A pointer to flags.

    lpOverlapped         - A pointer to a WSAOVERLAPPED structure.

    lpCompletionRoutine  - A  pointer to the completion routine called when the
                           receive operation has been completed.

    lpThreadId           - A pointer to a thread ID structure to be used by the
                           provider in a subsequent call to WPUQueueApc().

    lpErrno              - A pointer to the error code.

Return Value:

    If  no  error  occurs  and the receive operation has completed immediately,
    WSPRecv() returns the number of bytes received.  If the connection has been
    closed, it  returns  0.  Note that in this case the completion routine, if
    specified,  will   have  already  been  queued.   Otherwise, a  value  of
    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in
    lpErrno.   The  error  code WSA_IO_PENDING indicates that the overlapped an
    operation  has  been  successfully  initiated  and  that completion will be
    indicated  at  a  later  time.   Any  other  error  code  indicates that no
    overlapped  operations  was  initiated  and  no  completion indication will
    occur.
--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPRecv,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &lpBuffers,
                       &dwBufferCount,
                       &lpNumberOfBytesRecvd,
                       &lpFlags,
                       &lpOverlapped,
                       &lpCompletionRoutine,
                       &lpThreadId,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPRecv(
        s,
        lpBuffers,
        dwBufferCount,
        lpNumberOfBytesRecvd,
        lpFlags,
        lpOverlapped,
        lpCompletionRoutine,
        lpThreadId,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPRecv,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &lpBuffers,
                    &dwBufferCount,
                    &lpNumberOfBytesRecvd,
                    &lpFlags,
                    &lpOverlapped,
                    &lpCompletionRoutine,
                    &lpThreadId,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}



inline INT
DPROVIDER::WSPRecvDisconnect(
    IN SOCKET s,
    IN LPWSABUF lpInboundDisconnectData,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Terminate  reception  on  a socket, and retrieve the disconnect data if the
    socket is connection-oriented.

Arguments:

    s                       - A descriptor identifying a socket.

    lpInboundDisconnectData - A  pointer to a buffer into which disconnect data
                              is to be copied.

    lpErrno                 - A pointer to the error code.

Return Value:

    If  no error occurs, WSPRecvDisconnect() returns ERROR_SUCCESS.  Otherwise,
    a value of SOCKET_ERROR is returned, and a specific error code is available
    in lpErrno.

--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPRecvDisconnect,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &lpInboundDisconnectData,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPRecvDisconnect(
        s,
        lpInboundDisconnectData,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPRecvDisconnect,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &lpInboundDisconnectData,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);

}



inline INT
DPROVIDER::WSPRecvFrom(
    IN  SOCKET s,
    IN  LPWSABUF lpBuffers,
    IN  DWORD dwBufferCount,
    IN  LPDWORD lpNumberOfBytesRecvd,
    IN  OUT LPDWORD lpFlags,
    OUT struct sockaddr FAR *  lpFrom,
    IN  LPINT lpFromlen,
    IN  LPWSAOVERLAPPED lpOverlapped,
    IN  LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    IN LPWSATHREADID lpThreadId,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Receive a datagram and store the source address.

Arguments:

    s                    - A descriptor identifying a socket.

    lpBuffers            - A  pointer  to  an array of WSABUF structures.  Each
                           WSABUF  structure contains a pointer to a buffer and
                           the length of the buffer.

    dwBufferCount        - The  number  of  WSABUF  structures in the lpBuffers
                           array.

    lpNumberOfBytesRecvd - A  pointer  to  the number of bytes received by this
                           call.

    lpFlags              - A pointer to flags.

    lpFrom               - An  optional pointer to a buffer which will hold the
                           source address upon the completion of the overlapped
                           operation.

    lpFromlen            - A  pointer  to the size of the from buffer, required
                           only if lpFrom is specified.

    lpOverlapped         - A pointer to a WSAOVERLAPPED structure.

    CompletionRoutine    - A  pointer to the completion routine called when the
                           receive operation has been completed.

    lpThreadId           - A pointer to a thread ID structure to be used by the
                           provider in a subsequent call to WPUQueueApc().

    lpErrno              - A pointer to the error code.

Return Value:

    If  no  error  occurs  and the receive operation has completed immediately,
    WSPRecvFrom()  returns the number of bytes received.  If the connection has
    been  closed, it returns 0.  Note that in this case the completion routine,
    if  specified  will  have  already  been  queued.   Otherwise,  a  value of
    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in
    lpErrno.   The  error  code  WSA_IO_PENDING  indicates  that the overlapped
    operation  has  been  successfully  initiated  and  that completion will be
    indicated  at  a  later  time.   Any  other  error  code  indicates that no
    overlapped  operations  was  initiated  and  no  completion indication will
    occur.

--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPRecvFrom,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &lpBuffers,
                       &dwBufferCount,
                       &lpNumberOfBytesRecvd,
                       &lpFlags,
                       &lpFrom,
                       &lpFromlen,
                       &lpOverlapped,
                       &lpCompletionRoutine,
                       &lpThreadId,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPRecvFrom(
        s,
        lpBuffers,
        dwBufferCount,
        lpNumberOfBytesRecvd,
        lpFlags,
        lpFrom,
        lpFromlen,
        lpOverlapped,
        lpCompletionRoutine,
        lpThreadId,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPRecvFrom,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &lpBuffers,
                    &dwBufferCount,
                    &lpNumberOfBytesRecvd,
                    &lpFlags,
                    &lpFrom,
                    &lpFromlen,
                    &lpOverlapped,
                    &lpCompletionRoutine,
                    &lpThreadId,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}



inline INT
DPROVIDER::WSPSelect(
    IN INT nfds,
    IN OUT fd_set FAR *readfds,
    IN OUT fd_set FAR *writefds,
    IN OUT fd_set FAR *exceptfds,
    IN const struct timeval FAR *timeout,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Determine the status of one or more sockets.

Arguments:

    nfds      - This  argument  is  ignored  and  included only for the sake of
                compatibility.

    readfds   - An  optional  pointer  to  a  set  of sockets to be checked for
                readability.

    writefds  - An  optional  pointer  to  a  set  of sockets to be checked for
                writability

    exceptfds - An  optional  pointer  to  a  set  of sockets to be checked for
                errors.

    timeout   - The  maximum  time  for  WSPSelect()  to  wait, or  NULL for a
                blocking operation.

    lpErrno   - A pointer to the error code.

Return Value:

    WSPSelect()  returns  the  total  number of descriptors which are ready and
    contained  in  the  fd_set  structures, 0  if  the  time limit expired, or
    SOCKET_ERROR  if an error occurred.  If the return value is SOCKET_ERROR, a
    specific error code is available in lpErrno.

--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPSelect,
                       &ReturnValue,
                       m_lib_name,
                       &nfds,
                       &readfds,
                       &writefds,
                       &exceptfds,
                       &timeout,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPSelect(
        nfds,
        readfds,
        writefds,
        exceptfds,
        timeout,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPSelect,
                    &ReturnValue,
                    m_lib_name,
                    &nfds,
                    &readfds,
                    &writefds,
                    &exceptfds,
                    &timeout,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}




inline INT
DPROVIDER::WSPSend(
    IN SOCKET s,
    IN LPWSABUF lpBuffers,
    IN DWORD dwBufferCount,
    IN LPDWORD lpNumberOfBytesSent,
    IN DWORD dwFlags,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    IN LPWSATHREADID lpThreadId,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Send data on a connected socket.

Arguments:

    s                   - A descriptor identifying a connected socket.

    lpBuffers           - A  pointer  to  an  array of WSABUF structures.  Each
                          WSABUF  structure  contains a pointer to a buffer and
                          the length of the buffer.

    dwBufferCount       - The  number  of  WSABUF  structures  in the lpBuffers
                          array.

    lpNumberOfBytesSent - A pointer to the number of bytes sent by this call.

    dwFlags             - Flags.

    lpOverlapped        - A pointer to a WSAOVERLAPPED structure.

    lpCompletionRoutine - A  pointer  to the completion routine called when the
                          send operation has been completed.

    lpThreadId          - A  pointer to a thread ID structure to be used by the
                          provider in a subsequent call to WPUQueueApc().

    lpErrno             - A pointer to the error code.

Return Value:

    If  no  error  occurs  and  the  send  operation has completed immediately,
    WSPSend() returns the number of bytes received.  If the connection has been
    closed,  it  returns  0.  Note that in this case the completion routine, if
    specified, will   have  already  been  queued.   Otherwise, a  value  of
    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in
    lpErrno.   The  error  code  WSA_IO_PENDING  indicates  that the overlapped
    operation  has  been  successfully  initiated  and  that completion will be
    indicated  at  a  later  time.   Any  other  error  code  indicates that no
    overlapped operation was initiated and no completion indication will occur.

--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPSend,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &lpBuffers,
                       &dwBufferCount,
                       &lpNumberOfBytesSent,
                       &dwFlags,
                       &lpOverlapped,
                       &lpCompletionRoutine,
                       &lpThreadId,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPSend(
        s,
        lpBuffers,
        dwBufferCount,
        lpNumberOfBytesSent,
        dwFlags,
        lpOverlapped,
        lpCompletionRoutine,
        lpThreadId,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPSend,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &lpBuffers,
                    &dwBufferCount,
                    &lpNumberOfBytesSent,
                    &dwFlags,
                    &lpOverlapped,
                    &lpCompletionRoutine,
                    &lpThreadId,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}



inline INT
DPROVIDER::WSPSendDisconnect(
    IN SOCKET s,
    IN LPWSABUF lpOutboundDisconnectData,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Initiate  termination  of the connection for the socket and send disconnect
    data.

Arguments:

    s                        - A descriptor identifying a socket.

    lpOutboundDisconnectData - A pointer to the outgoing disconnect data.

    lpErrno                  - A pointer to the error code.

Return Value:

    If  no  error occurs, WSPSendDisconnect() returns 0.  Otherwise, a value of
    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in
    lpErrno.

--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPSendDisconnect,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &lpOutboundDisconnectData,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPSendDisconnect(
        s,
        lpOutboundDisconnectData,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPSendDisconnect,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &lpOutboundDisconnectData,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);

}



inline INT
DPROVIDER::WSPSendTo(
    IN SOCKET s,
    IN LPWSABUF lpBuffers,
    IN DWORD dwBufferCount,
    IN LPDWORD lpNumberOfBytesSent,
    IN DWORD dwFlags,
    IN const struct sockaddr FAR *  lpTo,
    IN INT iTolen,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    IN LPWSATHREADID lpThreadId,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Send data to a specific destination using overlapped I/O.

Arguments:

    s                   - A descriptor identifying a socket.

    lpBuffers           - A  pointer  to  an  array of WSABUF structures.  Each
                          WSABUF  structure  contains a pointer to a buffer and
                          the length of the buffer.

    dwBufferCount       - The  number  of  WSABUF  structures  in the lpBuffers
                          array.

    lpNumberOfBytesSent - A pointer to the number of bytes sent by this call.

    dwFlags             - Flags.

    lpTo                - An  optional  pointer  to  the  address of the target
                          socket.

    iTolen              - The size of the address in lpTo.

    lpOverlapped        - A pointer to a WSAOVERLAPPED structure.

    lpCompletionRoutine - A  pointer  to the completion routine called when the
                          send operation has been completed.

    lpThreadId          - A  pointer to a thread ID structure to be used by the
                          provider in a subsequent call to WPUQueueApc().

    lpErrno             - A pointer to the error code.

Return Value:

    If  no  error  occurs  and the receive operation has completed immediately,
    WSPSendTo()  returns  the  number of bytes received.  If the connection has
    been  closed,it returns 0.  Note that in this case the completion routine,
    if  specified, will  have  already  been  queued.   Otherwise, a value of
    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in
    lpErrno.   The  error  code  WSA_IO_PENDING  indicates  that the overlapped
    operation  has  been  successfully  initiated  and  that completion will be
    indicated  at  a  later  time.   Any  other  error  code  indicates that no
    overlapped operation was initiated and no completion indication will occur.

--*/


{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPSendTo,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &lpBuffers,
                       &dwBufferCount,
                       &lpNumberOfBytesSent,
                       &dwFlags,
                       &lpTo,
                       &iTolen,
                       &lpOverlapped,
                       &lpCompletionRoutine,
                       &lpThreadId,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPSendTo(
        s,
        lpBuffers,
        dwBufferCount,
        lpNumberOfBytesSent,
        dwFlags,
        lpTo,
        iTolen,
        lpOverlapped,
        lpCompletionRoutine,
        lpThreadId,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPSendTo,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &lpBuffers,
                    &dwBufferCount,
                    &lpNumberOfBytesSent,
                    &dwFlags,
                    &lpTo,
                    &iTolen,
                    &lpOverlapped,
                    &lpCompletionRoutine,
                    &lpThreadId,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}


inline INT
DPROVIDER::WSPSetSockOpt(
    IN SOCKET s,
    IN INT level,
    IN INT optname,
    IN const char FAR *optval,
    IN INT optlen,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Set a socket option.

Arguments:

    s       - A descriptor identifying a socket.

    level   - The  level  at  which the option is defined; the supported levels
              include   SOL_SOCKET.   (See  annex  for  more  protocol-specific
              levels.)

    optname - The socket option for which the value is to be set.

    optval  - A  pointer  to  the  buffer  in which the value for the requested
              option is supplied.

    optlen  - The size of the optval buffer.

    lpErrno - A pointer to the error code.

Return Value:

    If  no  error  occurs, WSPSetSockOpt()  returns  0.  Otherwise, a value of
    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in
    lpErrno.

--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPSetSockOpt,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &level,
                       &optname,
                       &optval,
                       &optlen,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPSetSockOpt(
        s,
        level,
        optname,
        optval,
        optlen,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPSetSockOpt,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &level,
                    &optname,
                    &optval,
                    &optlen,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);

}



inline INT
DPROVIDER::WSPShutdown(
    IN SOCKET s,
    IN INT how,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Disable sends and/or receives on a socket.

Arguments:

    s       - A descriptor identifying a socket.

    how     - A  flag  that describes what types of operation will no longer be
              allowed.

    lpErrno - A pointer to the error code.

Return Value:

    If  no  error  occurs, WSPShutdown()  returns  0.   Otherwise, a value of
    SOCKET_ERROR  is  returned, and  a  specific  error  code  is available in
    lpErrno.

--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPShutdown,
                       &ReturnValue,
                       m_lib_name,
                       &s,
                       &how,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPShutdown(
        s,
        how,
        lpErrno);

    POSTAPINOTIFY(( DTCODE_WSPShutdown,
                    &ReturnValue,
                    m_lib_name,
                    &s,
                    &how,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}



inline SOCKET
DPROVIDER::WSPSocket(
    IN int af,
    IN int type,
    IN int protocol,
    IN LPWSAPROTOCOL_INFOW lpProtocolInfo,
    IN GROUP g,
    IN DWORD dwFlags,
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Initialize  internal  data  and  prepare sockets for usage.  Must be called
    before any other socket routine.

Arguments:

    lpProtocolInfo - Supplies  a pointer to a WSAPROTOCOL_INFOW struct that
                     defines  the characteristics of the socket to be created.

    g              - Supplies  the identifier of the socket group which the new
                     socket is to join.

    dwFlags        - Supplies the socket attribute specification.

    lpErrno        - Returns the error code

Return Value:

    WSPSocket() returns zero if successful.  Otherwise it returns an error code
    as outlined in the SPI.

--*/
{
    SOCKET ReturnValue;

    assert (m_reference_count>0);
    // Debug/Trace stuff
    if (PREAPINOTIFY(( DTCODE_WSPSocket,
                       &ReturnValue,
                       m_lib_name,
                       &af,
                       &type,
                       &protocol,
                       &lpProtocolInfo,
                       &g,
                       &dwFlags,
                       &lpErrno)) ) {
        return(ReturnValue);
    }

    // Actual code...
    ReturnValue = m_proctable.lpWSPSocket(
        af,
        type,
        protocol,
        lpProtocolInfo,
        g,
        dwFlags,
        lpErrno);


    // Debug/Trace stuff
    POSTAPINOTIFY(( DTCODE_WSPSocket,
                    &ReturnValue,
                    m_lib_name,
                    &af,
                    &type,
                    &protocol,
                    &lpProtocolInfo,
                    &g,
                    &dwFlags,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}




inline INT
DPROVIDER::WSPStringToAddress(
    IN     LPWSTR AddressString,
    IN     INT AddressFamily,
    IN     LPWSAPROTOCOL_INFOW lpProtocolInfo,
    OUT    LPSOCKADDR lpAddress,
    IN OUT LPINT lpAddressLength,
    IN OUT LPINT lpErrno )
/*++

Routine Description:

    WSPStringToAddress() converts a human-readable string to a socket address
    structure (SOCKADDR) suitable for pass to Windows Sockets routines which
    take such a structure.  If the caller wishes the translation to be done by
    a particular provider, it should supply the corresponding WSAPROTOCOL_INFOW
    struct in the lpProtocolInfo parameter.

Arguments:

    AddressString - points to the zero-terminated human-readable string to
                    convert.

    AddressFamily - the address family to which the string belongs.

    lpProtocolInfo - (optional) the WSAPROTOCOL_INFOW struct for a particular
                     provider.

    Address - a buffer which is filled with a single SOCKADDR structure.

    lpAddressLength - The length of the Address buffer.  Returns the size of
                      the resultant SOCKADDR structure.

Return Value:

    The return value is 0 if the operation was successful.  Otherwise the value
    SOCKET_ERROR is returned.

--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_WSPStringToAddress,
                        &ReturnValue,
                        m_lib_name,
                        &AddressString,
                        &AddressFamily,
                        &lpProtocolInfo,
                        &lpAddress,
                        &lpAddressLength,
                        &lpErrno)) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.lpWSPStringToAddress(
        AddressString,
        AddressFamily,
        lpProtocolInfo,
        lpAddress,
        lpAddressLength,
        lpErrno);


    POSTAPINOTIFY(( DTCODE_WSPStringToAddress,
                    &ReturnValue,
                    m_lib_name,
                    &AddressString,
                    &AddressFamily,
                    &lpProtocolInfo,
                    &lpAddress,
                    &lpAddressLength,
                    &lpErrno));

    assert (m_reference_count>0);
    return(ReturnValue);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\inc\dprocess.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    dprocess.h

Abstract:

    This header defines the "DPROCESS" class.  The DPROCESS class defines state
    variables  and operations for DPROCESS objects within the WinSock 2 DLL.  A
    DPROCESS  object  represents  all  of the information known about a process
    using the Windows Sockets API.

Author:

    Paul Drews (drewsxpa@ashland.intel.com) 7-July-1995

Notes:

    $Revision:   1.16  $

    $Modtime:   08 Mar 1996 04:58:14  $

Revision History:

    most-recent-revision-date email-name
        description

    25-July dirk@mink.intel.com
        Moved protocol catalog related items into DCATALOG. Added data
        member to contain a pointer to the protocol catalog. Removed
        provider list moved provider references to into the protocol
        catalog.

    14-July-1995  dirk@mink.intel.com
        Moved member function documentation to implementation file
        dprocess.cpp. Changed critical section data members to be
        pointers to CRITICAL_SECTION. Added inline implementations for
        the list lock/unlock member functions.

    07-09-1995  drewsxpa@ashland.intel.com
        Completed  first  complete  version with clean compile and released for
        subsequent implementation.

    7-July-1995 drewsxpa@ashland.intel.com
        Original version

--*/

#ifndef _DPROCESS_
#define _DPROCESS_

#include "winsock2.h"
#include <windows.h>
#include "ws2help.h"
#include "classfwd.h"



class DPROCESS
{
  public:

  // Static (global-scope) member functions

    static PDPROCESS
    GetCurrentDProcess(
                        VOID
                        );
    static INT
    DProcessClassInitialize(
                            VOID
                            );

  // Normal member functions

    DPROCESS();

    INT Initialize();

    ~DPROCESS();

    BOOL 
    DSocketDetach (
                  IN LPWSHANDLE_CONTEXT   Context
                  );
    PDCATALOG
    GetProtocolCatalog();

    PNSCATALOG
    GetNamespaceCatalog();

    INT
    GetAsyncHelperDeviceID(
                           OUT LPHANDLE HelperHandle
                           );

    INT
    GetHandleHelperDeviceID(
                           OUT LPHANDLE HelperHandle
                           );
    INT
    GetNotificationHelperDeviceID(
                           OUT LPHANDLE HelperHandle
                           );
    VOID
    IncrementRefCount();

    DWORD
    DecrementRefCount();

    BYTE
    GetMajorVersion();

    BYTE
    GetMinorVersion();

    WORD
    GetVersion();

    VOID
    SetVersion( WORD Version );

#ifndef WS2_DEBUGGER_EXTENSION
//
// Give debugger extension access to all fields
//
  private:
#endif
    VOID    LockDThreadList();
    VOID    UnLockDThreadList();
    VOID    UpdateNamespaceCatalog ();

    INT
    OpenAsyncHelperDevice(
                           OUT LPHANDLE HelperHandle
                           );

    INT
    OpenHandleHelperDevice(
                           OUT LPHANDLE HelperHandle
                           );
    INT
    OpenNotificationHelperDevice(
                           OUT LPHANDLE HelperHandle
                           );


  static PDPROCESS sm_current_dprocess;
      // A class-scope reference to the single current DPROCESS object for this
      // process.

  LONG m_reference_count;
      // The   number   of   times   this   object   has   been   refereced  by
      // WSAStarup/WSACleanup.   WSAStartup  increases the count and WSACleanup
      // decreases the count.  Declarations for lists of associated objects:

  WORD m_version;
      // The WinSock version number for this process.

  BOOLEAN m_lock_initialized;
      // For proper cleanup of critical section if initialization fails

  PDCATALOG m_protocol_catalog;
      // Reference  to  the  protocol  catalog for the process

  HANDLE  m_proto_catalog_change_event;
      // Event that keeps track of protocol catalog changes
  
  PNSCATALOG m_namespace_catalog;
      // Reference  to  the  name space  catalog for the process

  HANDLE  m_ns_catalog_change_event;
      // Event that keeps track of name space catalog changes

  // Declarations for Helper objects created on demand:

  HANDLE  m_ApcHelper;
      // Reference to the Asynchronous callback helper device.  An asynchronous
      // callback helper device is only opened on demand.

  HANDLE  m_HandleHelper;
      // Reference to the handle helper device.  A handler
      // helper device is only opened on demand.

  HANDLE  m_NotificationHelper;
      // Reference to the notification handle helper device.  A notification
      // helper device is only opened on demand.
#if 0
      // Thread list not used due to race conditions.
      // Lock is still used.
  LIST_ENTRY  m_thread_list;
#endif
  CRITICAL_SECTION  m_thread_list_lock;
  
};  // class DPROCESS



inline 
PDPROCESS
DPROCESS::GetCurrentDProcess(
    )
/*++

Routine Description:

    Retrieves  a reference to the current DPROCESS object.  Note that this is a
    "static" function with global scope instead of object-instance scope.

Arguments:

    None
Return Value:
    Returns pointer to current DPROCESS object or NULL if process has not been
    initialized yet

--*/
{
    return sm_current_dprocess;
} //GetCurrentDProcess


inline VOID
DPROCESS::IncrementRefCount(
    VOID
    )
/*++

Routine Description:

    This function increases the reference count on this object.

Arguments:

Return Value:

    NONE
--*/
{
    InterlockedIncrement(&m_reference_count);
}



inline DWORD
DPROCESS::DecrementRefCount(
    VOID
    )
/*++

Routine Description:

    This function decreases the reference count on this object.

Arguments:

Return Value:

    Returns the new value of the reference count
--*/
{
    return(InterlockedDecrement(&m_reference_count));
}



inline
BYTE
DPROCESS::GetMajorVersion()
/*++

Routine Description:

    This function returns the major WinSock version number negotiated
    at WSAStartup() time.

Arguments:

    None.

Return Value:

    Returns the major WinSock version number.

--*/
{
    assert(m_version != 0);
    return LOBYTE(m_version);
} // GetMajorVersion



inline
BYTE
DPROCESS::GetMinorVersion()
/*++

Routine Description:

    This function returns the minor WinSock version number negotiated
    at WSAStartup() time.

Arguments:

    None.

Return Value:

    Returns the minor WinSock version number.

--*/
{
    assert(m_version != 0);
    return HIBYTE(m_version);
} // GetMinorVersion



inline
WORD
DPROCESS::GetVersion()
/*++

Routine Description:

    This function returns the WinSock version number negotiated
    at WSAStartup() time.

Arguments:

    None.

Return Value:

    Returns the WinSock version number.

--*/
{
    assert(m_version != 0);
    return m_version;
} // GetVersion



inline VOID
DPROCESS::LockDThreadList()
/*++

  Routine Description:

  This  function  acquires  mutually  exclusive access to the list of DTHREAD
  objects   attached  to  the  DPROCESS  object.   The  companion  procedures
  LockDThreadList  and  UnLockDThreadList  are  used  internally  to  bracket
  operations that add and remove items from the DTHREAD list.

  NOTE:

  Use  a  Critical  Section object for best performance.  Create the Critical
  Section  object  at  DPROCESS  object initialization time and destroy it at
  DPROCESS object destruction time.

  Arguments:

  None

  Return Value:

  None
  --*/
{
    EnterCriticalSection(&m_thread_list_lock);
}


inline VOID
DPROCESS::UnLockDThreadList()
/*++

  Routine Description:

  This  function  releases  mutually  exclusive access to the list of DTHREAD
  objects   attached  to  the  DPROCESS  object.   The  companion  procedures
  LockDThreadList  and  UnLockDThreadList  are  used  internally  to  bracket
  operations that add and remove items from the DTHREAD list.

  NOTE:

  Use  a  Critical  Section object for best performance.  Create the Critical
  Section  object  at  DPROCESS  object initialization time and destroy it at
  DPROCESS object destruction time.

  Arguments:

  None

  Return Value:

  None
  --*/
{
    LeaveCriticalSection(&m_thread_list_lock);
}



inline INT
DPROCESS::GetAsyncHelperDeviceID(
    OUT LPHANDLE HelperHandle
    )
/*++

Routine Description:

    Retrieves  the  opened  Async  Helper  device  ID  required  for processing
    callbacks  in  the  overlapped  I/O  model.   The operation opens the Async
    Helper device if necessary.

Arguments:

    HelperHandle - Returns the requested Async Helper device ID.

Return Value:

    The  function  returns ERROR_SUCESS if successful, otherwise it
    returns an appropriate WinSock error code.
--*/
{
    if (m_ApcHelper) {
        *HelperHandle = m_ApcHelper;
        return ERROR_SUCCESS;
        } //if
    else {
        return OpenAsyncHelperDevice (HelperHandle);
    }
}


inline INT
DPROCESS::GetHandleHelperDeviceID(
    OUT LPHANDLE HelperHandle
    )
/*++

Routine Description:

    Retrieves  the  opened  Handle  Helper  device  ID  required  for allocation
    of socket handles for non-IFS providers.   The operation opens the Handle
    Helper device if necessary.

Arguments:

    HelperHandle - Returns the requested Handle Helper device ID.

Return Value:

    The  function  returns ERROR_SUCESS if successful, otherwise it
    returns an appropriate WinSock error code.
--*/
{
    if (m_HandleHelper) {
        *HelperHandle = m_HandleHelper;
        return ERROR_SUCCESS;
        } //if
    else {
        return OpenHandleHelperDevice (HelperHandle);
    }
}



inline INT
DPROCESS::GetNotificationHelperDeviceID(
    OUT LPHANDLE HelperHandle
    )
/*++

Routine Description:

    Retrieves  the  opened  Async  Helper  device  ID  required  for processing
    callbacks  in  the  overlapped  I/O  model.   The operation opens the Async
    Helper device if necessary.

Arguments:

    HelperHandle - Returns the requested Async Helper device ID.

Return Value:

    The  function  returns ERROR_SUCESS if successful, otherwise it
    returns an appropriate WinSock error code.
--*/
{
    if (m_NotificationHelper) {
        *HelperHandle = m_NotificationHelper;
        return ERROR_SUCCESS;
        } //if
    else {
        return OpenNotificationHelperDevice (HelperHandle);
    }
}

#endif // _DPROCESS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\inc\nsprovid.h ===
/*++


  Intel Corporation Proprietary Information
  Copyright (c) 1995 Intel Corporation

  This listing is supplied under the terms of a license agreement with
  Intel Corporation and may not be used, copied, nor disclosed except in
  accordance with the terms of that agreeement.


  Module Name:

      nsprovid.h

  Abstract:

      This module defines the WinSock2 class NSPROVIDER along with its
      methods.

  Author:

      Dirk Brandewie (dirk@mink.intel.com)  05-Dec-1995

  Revision History:

      09-Nov-1995 dirk@mink.intel.com
      Initial Revision
  --*/
#ifndef _NSPROVIDER_
#define _NSPROVIDER_

#include <winsock2.h>
#include <ws2spi.h>
#include "classfwd.h"
#include "dthook.h"
#include "wsautil.h"
#include "dprocess.h"
#include "dthread.h"


class NSPROVIDER {

  public:

    NSPROVIDER();

    INT
    Initialize(
        IN LPWSTR  lpszLibFile,
        IN LPGUID  lpProviderId
        );


    INT WSAAPI
    NSPUnInstallNameSpace (
        );

//
// Client Query APIs
//

    INT WSAAPI
    NSPLookupServiceBegin(
        IN  LPWSAQUERYSETW           lpqsRestrictions,
        IN  LPWSASERVICECLASSINFOW   lpServiceClassInfo,
        IN  DWORD                    dwControlFlags,
        OUT LPHANDLE                 lphLookup
        );

    INT WINAPI
    SupportsIoctl(
        );

    INT WSAAPI
    NSPIoctl(
        IN  HANDLE           hLookup,
        IN  DWORD            dwControlCode,
        IN  LPVOID           lpvInBuffer,
        IN  DWORD            cbInBuffer,
        OUT LPVOID           lpvOutBuffer,
        IN  DWORD            cbOutBuffer,
        OUT LPDWORD          lpcbBytesReturned,
        IN  LPWSACOMPLETION  lpCompletion,
        IN  LPWSATHREADID    lpThreadId
        );

    INT WSAAPI
    NSPLookupServiceNext(
        IN     HANDLE           hLookup,
        IN     DWORD            dwcontrolFlags,
        IN OUT LPDWORD          lpdwBufferLength,
        OUT    LPWSAQUERYSETW   lpqsResults
        );

    INT WSAAPI
    NSPLookupServiceEnd(
        IN HANDLE  hLookup
        );

//
// Service Address Registration and Deregistration APIs and Data Types.
//

    INT WSAAPI
    NSPSetService(
        IN  LPWSASERVICECLASSINFOW   lpServiceClassInfo,
        IN  LPWSAQUERYSETW           lpqsRegInfo,
        IN  WSAESETSERVICEOP         essOperation,
        IN  DWORD                    dwControlFlags
        );


//
// Service Installation/Removal APIs and Data Types.
//

    INT WSAAPI
    NSPInstallServiceClass(
        IN  LPWSASERVICECLASSINFOW   lpServiceClassInfo
        );

    INT WSAAPI
    NSPRemoveServiceClass(
        IN  LPGUID  lpServiceClassId
        );

    INT WSAAPI
    NSPGetServiceClassInfo(
        IN OUT  LPDWORD                 lpdwBufSize,
        IN OUT  LPWSASERVICECLASSINFOW  lpServiceClassInfo
        );


    // Provider cleanup
    INT WSAAPI
    NSPCleanup (
        );

    VOID
    Reference (
        );

    VOID
    Dereference (
        );

  private:

    // Should never be called directly, but through dereferencing.
    ~NSPROVIDER();

    LONG             m_reference_count;
    // How many time this structure was referenced

    DWORD            m_namespace_id;
    // The identifier of the namespace supported by the service provider.

    HINSTANCE        m_library_handle;
    // The handle to the service provider DLL.

    NSP_ROUTINE      m_proctable;
    // Structure containing the fuction pointers to the entry points of the
    // service provider DLL.

    GUID             m_provider_id;
    // The GUID associated with an interface in the service provider DLL.

#ifdef DEBUG_TRACING
    LPSTR            m_library_name;
    // The name of the service provider DLL.
#endif

};

inline
VOID
NSPROVIDER::Reference () {
    //
    // Object is created with reference count of 1
    // and is destroyed whenever it gets back to 0.
    //
    assert (m_reference_count>0);
    InterlockedIncrement (&m_reference_count);
}

inline
VOID
NSPROVIDER::Dereference () {
    assert (m_reference_count>0);
    if (InterlockedDecrement (&m_reference_count)==0)
        delete this;
}

//
// Client Query APIs
//


inline INT WSAAPI
NSPROVIDER::NSPLookupServiceBegin(
    IN  LPWSAQUERYSETW          lpqsRestrictions,
    IN  LPWSASERVICECLASSINFOW  lpServiceClassInfo,
    IN  DWORD                   dwControlFlags,
    OUT LPHANDLE                lphLookup
    )
/*++

Routine Description:

    NSPLookupServiceBegin() is used to initiate a client query that is
    constrained by the information contained within a WSAQUERYSET
    structure. WSALookupServiceBegin() only returns a handle, which should be
    used by subsequent calls to NSPLookupServiceNext() to get the actual
    results.



Arguments:

    lpProviderId - Contains the specific provider ID that should be used for
                   the query.

    lpqsRestrictions - contains the search criteria.

    lpServiceClassInfo - A WSASERVICECLASSINFOW structure which contains all of
                         the schema information for the service.

    dwControlFlags - controls the depth of the search:

    lphLookup - Handle to be used in subsequent calls to NSPLookupServiceNext
                in order to retrieve the results set.

Return Value:

    The function should return NO_ERROR (0) if the routine succeeds.  It should
    return SOCKET_ERROR (-1) if the routine fails
--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_NSPLookupServiceBegin,
                       &ReturnValue,
                       (LPSTR) m_library_name,
                       &m_provider_id,
                       &lpqsRestrictions,
                       &lpServiceClassInfo,
                       &dwControlFlags,
                       &lphLookup )) ) {
        return(ReturnValue);
    }

    ReturnValue =   ReturnValue = m_proctable.NSPLookupServiceBegin(
        &m_provider_id,
        lpqsRestrictions,
        lpServiceClassInfo,
        dwControlFlags,
        lphLookup
        );

    POSTAPINOTIFY((DTCODE_NSPLookupServiceBegin,
                   &ReturnValue,
                   m_library_name,
                   &m_provider_id,
                   &lpqsRestrictions,
                   &lpServiceClassInfo,
                   &dwControlFlags,
                   &lphLookup ));

    assert (m_reference_count>0);
    return(ReturnValue);


}

inline INT WSAAPI
NSPROVIDER::NSPLookupServiceNext(
    IN     HANDLE           hLookup,
    IN     DWORD            dwControlFlags,
    IN OUT LPDWORD          lpdwBufferLength,
    OUT    LPWSAQUERYSETW   lpqsResults
    )
/*++

Routine Description:

    NSPLookupServiceNext() is called after obtaining a Handle from a previous
    call to NSPLookupServiceBegin() in order to retrieve the requested service
    information.  The provider will pass back a WSAQUERYSET structure in the
    lpqsResults buffer.  The client should continue to call this API until it
    returns WSA_E_NOMORE, indicating that all of the WSAQUERYSET have been
    returned.

Arguments:

    hLookup - Handle returned from the previous call to
              NSPLookupServiceBegin().

    dwControlFlags - Flags to control the next operation.  This is currently
                     used  to indicate to the provider what to do if the result
                     set is too big for the buffer.  If on the previous call to
                     NSPLookupServiceNext() the result set was too large for
                     the buffer, the client can choose to do one of two things
                     on this call.  First, it can choose to pass a bigger
                     buffer and try again.  Second, if it cannot or is
                     unwilling to allocate a larger buffer, it can pass
                     LUP_FLUSHPREVIOUS to tell the provider to throw away the
                     last result set - which was too large - and move on to the
                     next set for this call.

    lpdwBufferLength - on input, the number of bytes contained in the buffer
                       pointed  to by lpresResults.  On output - if the API
                       fails, and the error is WSAEFAULT, then it contains the
                       minimum number of bytes to pass for the lpqsResults to
                       retrieve the record.

    lpqsResults - a pointer to a block of memory, which will contain one result
                  set  in a WSAQUERYSET structure on return.

Return Value:

    The function should return NO_ERROR (0) if the routine succeeds.  It should
    return SOCKET_ERROR (-1) if the routine fails.
--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_NSPLookupServiceNext,
                       &ReturnValue,
                       m_library_name,
                       &hLookup,
                       &dwControlFlags,
                       &lpdwBufferLength,
                       &lpqsResults )) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.NSPLookupServiceNext(
        hLookup,
        dwControlFlags,
        lpdwBufferLength,
        lpqsResults
        );

    POSTAPINOTIFY((DTCODE_NSPLookupServiceNext,
                   &ReturnValue,
                   m_library_name,
                   &hLookup,
                   &dwControlFlags,
                   &lpdwBufferLength,
                   &lpqsResults  ));

    assert (m_reference_count>0);
    return(ReturnValue);
}


inline INT WINAPI
NSPROVIDER::SupportsIoctl(
    )
{
    if (m_proctable.NSPIoctl != NULL)
        return (TRUE);
    else
        return (FALSE);
}


inline INT WSAAPI
NSPROVIDER::NSPIoctl(
    IN  HANDLE           hLookup,
    IN  DWORD            dwControlCode,
    IN  LPVOID           lpvInBuffer,
    IN  DWORD            cbInBuffer,
    OUT LPVOID           lpvOutBuffer,
    IN  DWORD            cbOutBuffer,
    OUT LPDWORD          lpcbBytesReturned,
    IN  LPWSACOMPLETION  lpCompletion,
    IN  LPWSATHREADID    lpThreadId
    )
/*++

Routine Description:

    The NSPIoctl function is used to set or retrieve operating parameters
    associated with a namespace query handle.

    Any IOCTL may block indefinitely, depending upon the relevant namespace's
    implementation.  If an application cannot tolerate blocking in a
    NSPIoctl call, overlapped I/O would be advised.  For these operations,
    which cannot be completed immediately, completion is indicated later
    through the mechanism specified in the pCompletion parameter.
    If pCompletion is NULL, this is a blocking call.  To make this call
    non-blocking and return immediately, set WSACOMPLETION::Type to
    LUP_NOTIFY_IMMEDIATELY.

Arguments:

    hLookup - Lookup handle returned from a call to WSALookupServiceBegin.

    dwControlCode - The control code of the operation to perform.

    pvInBuffer - A pointer to the input buffer for the operation.

    cbInBuffer - The size of the input buffer for the operation.

    pvOutBuffer - A pointer to the output buffer for the operation.

    pcbOutBuffer - A pointer to an integral value for the size of the output
                   buffer.

    pCompletion - A pointer to a WSACOMPLETION structure.

Return Value:

    Upon successful completion, WSANSIoctl returns NO_ERROR (0).  Otherwise,
    a value of SOCKET_ERROR (-1) is returned, and a specific error code can
    be retrieved by calling WSAGetLastError.
--*/
{
    INT ReturnValue;

    assert(m_reference_count > 0);
    if (PREAPINOTIFY((DTCODE_NSPIoctl,
                      &ReturnValue,
                      m_library_name,
                      &hLookup,
                      &dwControlCode,
                      &lpvInBuffer,
                      &cbInBuffer,
                      &lpvOutBuffer,
                      &lpcbBytesReturned,
                      &cbOutBuffer,
                      &lpCompletion,
                      &lpThreadId)) ) {
        return (ReturnValue);
    }

    ReturnValue = m_proctable.NSPIoctl(
        hLookup,
        dwControlCode,
        lpvInBuffer,
        cbInBuffer,
        lpvOutBuffer,
        cbOutBuffer,
        lpcbBytesReturned,
        lpCompletion,
        lpThreadId
        );

    POSTAPINOTIFY((DTCODE_NSPIoctl,
                   &ReturnValue,
                   m_library_name,
                   &hLookup,
                   &dwControlCode,
                   &lpvInBuffer,
                   &cbInBuffer,
                   &lpvOutBuffer,
                   &lpcbBytesReturned,
                   &cbOutBuffer,
                   &lpCompletion,
                   &lpThreadId));

    assert(m_reference_count > 0);
    return (ReturnValue);
}


inline INT WSAAPI
NSPROVIDER::NSPLookupServiceEnd(
    IN HANDLE  hLookup
    )
/*++

Routine Description:

    NSPLookupServiceEnd() is called to free the handle after previous calls to
    NSPLookupServiceBegin() and NSPLookupServiceNext().  It is possible to
    receive a NSPLookupServiceEnd() call on another thread while processing a
    NSPLookupServiceNext().  This indicates that the client has cancelled the
    request, and the provider should close the handle and return from the
    NSPLookupServiceNext() call as well, setting the last error to
    WSA_E_CANCELLED.


Arguments:

    hLookup - Handle previously obtained by calling NSPLookupServiceBegin().


Return Value:

    The function should return NO_ERROR (0) if the routine succeeds.  It should
    return SOCKET_ERROR (-1) if the routine fails.
--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_NSPLookupServiceEnd,
                       &ReturnValue,
                       m_library_name,
                       &hLookup )) ) {
        return(ReturnValue);
    }

    ReturnValue =m_proctable.NSPLookupServiceEnd(
        hLookup );

    POSTAPINOTIFY((DTCODE_NSPLookupServiceEnd,
                   &ReturnValue,
                   m_library_name,
                   &hLookup ));

    assert (m_reference_count>0);
    return(ReturnValue);
}


//
// Service Address Registration and Deregistration APIs and Data Types.
//

inline INT WSAAPI
NSPROVIDER::NSPSetService(
    IN  LPWSASERVICECLASSINFOW   lpServiceClassInfo,
    IN  LPWSAQUERYSETW           lpqsRegInfo,
    IN  WSAESETSERVICEOP         essOperation,
    IN  DWORD                    dwControlFlags
    )
/*++

Routine Description:

    NSPSetService() is used to register or deregister a service instance within
    a name space.

Arguments:

    lpProviderId - Pointer to the GUID of the specific name space provider that
                   this service is being registered in.

    lpServiceClasslnfo - contains service class schema information.

    lpqsRegInfo - specifies property information to be updated upon
                  registration.

    essOperation - an enumeration.

    dwControlFlags - ControlFlags.

Return Value:

    The function should return NO_ERROR (0) if the routine succeeds.  It should
    return SOCKET_ERROR (-1) if the routine fails.
--*/
{
    INT ReturnValue=NO_ERROR;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_NSPSetService
                       &ReturnValue,
                       m_library_name,
                       (PCHAR) &m_provider_id,
                       &lpServiceClassInfo,
                       &lpqsRegInfo,
                       &essOperation,
                       &dwControlFlags )) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.NSPSetService(
        &m_provider_id,
        lpServiceClassInfo,
        lpqsRegInfo,
        essOperation,
        dwControlFlags);

    POSTAPINOTIFY((DTCODE_NSPSetService,
                   &ReturnValue,
                   m_library_name,
                   &m_provider_id,
                   &lpServiceClassInfo,
                   &lpqsRegInfo,
                   &essOperation,
                   &dwControlFlags ));

    assert (m_reference_count>0);
    return(ReturnValue);
}



//
// Service Installation/Removal APIs and Data Types.
//

inline INT WSAAPI
NSPROVIDER::NSPInstallServiceClass(
    IN  LPWSASERVICECLASSINFOW   lpServiceClassInfo
    )
/*++

Routine Description:

    NSPInstallServiceClass() is used to register service class schema within
    the name space providers.  The schema includes the class name, class id,
    and any name space specific type information that is common to all
    instances of the service, such as SAP ID or object ID.  A name space
    provider is expected to store any class info associated with that
    namespace.

Arguments:

    lpProviderId - Pointer to the GUID of the specific name space provider that
                   this  service class schema is being registered in.

    lpServiceClasslnfo - contains service class schema information.

Return Value:

    The function should return NO_ERROR (0) if the routine succeeds.  It should
    return SOCKET_ERROR (-1) if the routine fails.
--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_NSPInstallServiceClass,
                       &ReturnValue,
                       m_library_name,
                       &m_provider_id,
                       &lpServiceClassInfo )) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.NSPInstallServiceClass(
        &m_provider_id,
        lpServiceClassInfo);

    POSTAPINOTIFY(( DTCODE_NSPInstallServiceClass,
                    &ReturnValue,
                    m_library_name,
                    &m_provider_id,
                    &lpServiceClassInfo ));

    assert (m_reference_count>0);
    return(ReturnValue);
}


inline INT WSAAPI
NSPROVIDER::NSPRemoveServiceClass(
    IN  LPGUID  lpServiceClassId
    )
/*++

Routine Description:

    NSPRemoveServiceClass() is used to permanently remove a specified service
    class from the name space.

Arguments:

    lpServiceClassId    Pointer to the service class ID that is to be removed.

Return Value:

    The function should return NO_ERROR (0) if the routine succeeds.  It should
    return SOCKET_ERROR (-1) if the routine fails.
--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_NSPRemoveServiceClass,
                       &ReturnValue,
                       m_library_name,
                       &m_provider_id,
                       &lpServiceClassId )) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.NSPRemoveServiceClass(
        &m_provider_id,
        lpServiceClassId);

    POSTAPINOTIFY((DTCODE_NSPRemoveServiceClass,
                   &ReturnValue,
                   m_library_name,
                   &m_provider_id,
                   &lpServiceClassId ));

    assert (m_reference_count>0);
    return(ReturnValue);
}


inline INT WSAAPI
NSPROVIDER::NSPGetServiceClassInfo(
    IN OUT  LPDWORD                 lpdwBufSize,
    IN OUT  LPWSASERVICECLASSINFOW  lpServiceClassInfo
    )
/*++

Routine Description:

    NSPGetServiceClassInfo() is used to retrieve all of the class information
    (schema) pertaining to the service from the name space providers.  This
    call retrieves any name space specific information that is common to all
    instances of the service, including connection information for SAP, or port
    information for SAP or TCP.

Arguments:

    lpdwBufferLength - on input, the number of bytes contained in the buffer
                       pointed to by lpServiceClassInfos.  On output - if the
                       API fails, and the error is WSAEFAULT, then it contains
                       the minimum number of bytes to pass for the
                       lpServiceClassInfo to retrieve the record.

    lpServiceClasslnfo - returns service class to name space specific mapping
                         information.  The lpServiceClassId field must be
                         filled in to indicate which SERVICECLASSINFOW record
                         should be returned.

Return Value:

    The function should return NO_ERROR (0) if the routine succeeds.  It should
    return SOCKET_ERROR (-1) if the routine fails.
--*/
{
    INT ReturnValue;

    assert (m_reference_count>0);
    if (PREAPINOTIFY(( DTCODE_NSPGetServiceClassInfo,
                       &ReturnValue,
                       m_library_name,
                       &m_provider_id,
                       &lpdwBufSize,
                       &lpServiceClassInfo )) ) {
        return(ReturnValue);
    }

    ReturnValue = m_proctable.NSPGetServiceClassInfo(
        &m_provider_id,
        lpdwBufSize,
        lpServiceClassInfo);

    POSTAPINOTIFY((DTCODE_NSPGetServiceClassInfo,
                   &ReturnValue,
                   m_library_name,
                   &m_provider_id,
                   &lpdwBufSize,
                   &lpServiceClassInfo ));

    assert (m_reference_count>0);
    return(ReturnValue);
}

#endif // _NSPROVIDER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\inc\nsquery.h ===
/*++


  Intel Corporation Proprietary Information
  Copyright (c) 1995 Intel Corporation

  This listing is supplied under the terms of a license agreement with
  Intel Corporation and may not be used, copied, nor disclosed except in
  accordance with the terms of that agreeement.


Module Name:

    nsquery.h

Abstract:

    This  module  gives  the class definition for the NSQUERY object type.  The
    NSQUERY    object   holds   all   the   state   information   regarding   a
    WSALookup{Begin/Next/End}   series   of  operations.   It  supplies  member
    functions that implement the API-level operations in terms of the SPI-level
    operations.

Author:

    Paul Drews (drewsxpa@ashland.intel.com) 09-November-1995

Notes:

    $Revision:   1.8  $

    $Modtime:   15 Feb 1996 16:54:32  $

Revision History:

    most-recent-revision-date email-name
        description

    09-November-1995 drewsxpa@ashland.intel.com
        created

--*/

#ifndef _NSQUERY_
#define _NSQUERY_


#include "winsock2.h"
#include <windows.h>
#include "classfwd.h"


#define QUERYSIGNATURE 0xbeadface
// A signature bit pattern used to validate an object of this type is still
// valid.

class NSQUERY
{
  public:

    NSQUERY();

    INT
    Initialize(
        );
    BOOL
    ValidateAndReference();


    ~NSQUERY();

    INT
    WINAPI
    LookupServiceBegin(
        IN  LPWSAQUERYSETW  lpqsRestrictions,
        IN  DWORD           dwControlFlags,
        IN PNSCATALOG       NsCatalog
        );

    INT
    WINAPI
    LookupServiceNext(
        IN     DWORD           dwControlFlags,
        IN OUT LPDWORD         lpdwBufferLength,
        IN OUT LPWSAQUERYSETW  lpqsResults
        );

    INT
    WINAPI
    Ioctl(
        IN  DWORD            dwControlCode,
        IN  LPVOID           lpvInBuffer,
        IN  DWORD            cbInBuffer,
        OUT LPVOID           lpvOutBuffer,
        IN  DWORD            cbOutBuffer,
        OUT LPDWORD          lpcbBytesReturned,
        IN  LPWSACOMPLETION  lpCompletion,
        IN  LPWSATHREADID    lpThreadId
        );
    
    INT
    WINAPI
    LookupServiceEnd();

    VOID
    WINAPI
    Dereference();


    BOOL
    RemoveProvider(
        PNSPROVIDER  pNamespaceProvider
        );

    BOOL
    AddProvider(
        PNSPROVIDER  pNamespaceProvider
        );



  private:

    PNSPROVIDERSTATE
    NextProvider(
        PNSPROVIDERSTATE Provider
        );

    PNSPROVIDERSTATE
    PreviousProvider(
        PNSPROVIDERSTATE Provider
        );


    volatile DWORD m_signature;
    // The signature of the object.

    volatile LONG  m_reference_count;
    // The number of threads currently using the object.  Used to determine
    // when the object can be deleted.

    volatile BOOL  m_shutting_down;
    // True when LookupEnd has been called.  Tells other thread that may
    // still be enumerating to get out ASAP.

    LIST_ENTRY  m_provider_list;
    // The  ordered  list  of  remaining  providers to which the LookupNext
    // operation  can be directed.  A provider is deleted from the front of
    // the  list  as  WSA_E_NOMORE  is first encountered from the provider.
    // The   actual   type   of   the   list  entries  is  private  to  the
    // implementation.

    PNSPROVIDERSTATE  m_current_provider;
    // This  keeps  track  of  the  sequence  number  of  the current first
    // provider  in  the  provider  list.   When  a  LookupNext  encounters
    // WSA_E_NOMORE, this number is compared against the number that was at
    // the  start  of  the operation.  The provider list is updated only if
    // these  two  numbers  are  equal.  This covers the case where several
    // threads are doing concurrent LookupNext operations.

    CRITICAL_SECTION  m_members_guard;
    // This  critical  section  must be entered when updating the values of
    // any  of  the member variables of the NSQUERY object.  This keeps the
    // values  consistent even though there may be concurrent threads using
    // the  object  with  LookupServiceNext or LookupServiceEnd operations.
    // Do not keep this critical section entered while calling through to a
    // service provider.

    BOOL m_change_ioctl_succeeded;
    // For providers which support Ioctl, after a change notification the
    // list of providers can be reset so that further calls to
    // LookupServiceNext will succeed with change information.

#ifdef RASAUTODIAL
    LPWSAQUERYSETW m_query_set;
    // The LPWSAQUERYSET structure passed in to LookupServiceBegin, in case
    // we need to restart the query (call LookupServiceBegin).

    DWORD m_control_flags;
    // The control flags of the query, in case we have to restart the query
    // (call LookupServiceBegin) due to an autodial attempt.

    PNSCATALOG m_catalog;
    // The catalog of the original query, in case we have to restart the
    // query (call LookupServiceBegin), due to an autodial attempt.

    BOOL m_restartable;
    // TRUE if no results have been returned for this query; FALSE
    // otherwise.
#endif // RASAUTODIAL

};  // class NSQUERY

#endif // _NSQUERY_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\inc\nscatent.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    nscatent.h

Abstract:

    This  file  contains the class definition for the NSCATALOGENTRY class.
    This  class  defines the interface to the entries that can be installed and
    retrieved in the namespace provider catalog.

Author:
    Dirk Brandewie (dirk@mink.intel.com)  09-Nov-1995

Notes:

    $Revision:   1.9  $

    $Modtime:   15 Feb 1996 16:13:18  $

Revision History:

    09-Nov-1995  dirk@mink.intel.com
        Initial Revision

--*/

#ifndef _NSCATENT_
#define _NSCATENT_

#include "winsock2.h"
#include <windows.h>


class NSCATALOGENTRY {
public:

    NSCATALOGENTRY();

    INT
    InitializeFromRegistry(
        IN  HKEY  ParentKey,
        IN  INT   SequenceNum
        );

    INT
    InitializeFromValues(
        IN  LPWSTR            LibraryPath,
        IN  LPWSTR            DisplayString,
        IN  LPGUID            ProviderId,
        IN  DWORD             NameSpaceId,
        IN  DWORD             Version
        );

    PNSPROVIDER
    GetProvider();

    LPGUID
    GetProviderId();

    DWORD
    GetNamespaceId();

    LONG
    GetAddressFamily();

    LPWSTR
    GetLibraryPath();

    VOID
    SetVersion(
        IN DWORD Version
        );

    DWORD
    GetVersion();

    BOOL
    GetEnabledState();

    BOOL
    StoresServiceClassInfo();

    LPWSTR
    GetProviderDisplayString();

    INT
    WriteToRegistry(
        IN  HKEY  ParentKey,
        IN  INT   SequenceNum
        );

    VOID
    Enable(
        IN BOOLEAN EnableValue
        );

    VOID
    Reference (
        );
    VOID
    Dereference (
        );
private:

    // Should never be called directly but through dereferencing
    ~NSCATALOGENTRY();

friend class NSCATALOG; // So it can access some of the private
                        // fields and methods below.

    VOID
    SetProvider (
        IN PNSPROVIDER  Provider
        );

    INT
    IoRegistry(
        IN  HKEY  EntryKey,
        IN  BOOL  IsRead);

    LIST_ENTRY     m_CatalogLinkage;
    // Used  to  link  items  in  catalog.   Note  that  this particular member
    // variable  is in the public section to make it available for manipulation
    // by the catalog object.

    LONG        m_reference_count;
    // How many time this structure was referenced

    PNSPROVIDER  m_provider;
    // Pointer to the dprovider object attached to this catalog entry.

    DWORD m_namespace_id;
    // The name space supported by this provider

    LONG m_address_family;
    // the address family it supports

    DWORD m_version;
    // The version supported by this provider

    BOOLEAN m_enabled;
    // Is this provider enabled / should it be returned by
    // WSAEnumNameSpaceProviders

    BOOLEAN m_stores_service_class_info;
    // Does this provider store service class info information

    LPWSTR m_providerDisplayString;
    // The human readable string describing this provider

    GUID m_providerId;
    // The GUID for this provider

    WCHAR m_LibraryPath[MAX_PATH];
    // Fully qualified path to the provider's DLL image.

};  // class NSCATALOGENTRY


inline
VOID
NSCATALOGENTRY::Reference () {
    //
    // Object is created with reference count of 1
    // and is destroyed whenever it gets back to 0.
    //
    assert (m_reference_count>0);
    InterlockedIncrement (&m_reference_count);
}


inline
VOID
NSCATALOGENTRY::Dereference () {
    assert (m_reference_count>0);
    if (InterlockedDecrement (&m_reference_count)==0)
        delete this;
}


inline
PNSPROVIDER
NSCATALOGENTRY::GetProvider()
/*++

Routine Description:

    This  procedure  retrieves  a reference to the NSPROVIDER associated with a
    catalog  entry. 

Arguments:

    None

Return Value:

    Returns  the  current  provider  reference,  or  NULL if provider is not
    loaded yet
--*/
{
    return(m_provider);
}  // GetProvider


inline LPGUID
NSCATALOGENTRY::GetProviderId(
    )
/*++

Routine Description:

    This function returns a pointer to the provider ID sored in this object.

Arguments:

    NONE

Return Value:

    The address of m_providerId.

--*/
{
    return(&m_providerId);
}



inline LONG
NSCATALOGENTRY::GetAddressFamily(
    )
/*++

Routine Description:

    Returns the Address family of the namespace supported by this provider.

Arguments:

    NONE

Return Value:

    The value of m_address_family.

--*/
{
    return(m_address_family);
}



inline DWORD
NSCATALOGENTRY::GetNamespaceId(
    )
/*++

Routine Description:

    Returns the ID of the namespace supported by this provider.

Arguments:

    NONE

Return Value:

    The value of m_namespace_id.

--*/
{
    return(m_namespace_id);
}



inline DWORD
NSCATALOGENTRY::GetVersion()
/*++

Routine Description:

    Returns the version supported by this namespace provider.

Arguments:

    NONE

Return Value:

    The value of m_version.

--*/
{
    return(m_version);
}


inline LPWSTR
NSCATALOGENTRY::GetLibraryPath()
/*++

Routine Description:

    Returns library path of the provider

Arguments:

    NONE

Return Value:

    The value of m_LibraryPath.

--*/
{
    return(m_LibraryPath);
}


inline BOOL
NSCATALOGENTRY::GetEnabledState(
    )
/*++

Routine Description:

    Returns the enabled state of the provider.

Arguments:

    NONE

Return Value:

    The value of m_enabled.

--*/
{
    return(m_enabled);
}


inline LPWSTR
NSCATALOGENTRY::GetProviderDisplayString(
    )
/*++

Routine Description:

    Returns the display string of the provider.

Arguments:

    NONE

Return Value:

    The value of m_providerDisplayString;

--*/
{
    return(m_providerDisplayString);
}


inline BOOL
NSCATALOGENTRY::StoresServiceClassInfo()
/*++

Routine Description:

    Returns whether the provider stores service class infomation.

Arguments:

    NONE

Return Value:

   The value of m_stores_service_class_info.

--*/
{
    return(m_stores_service_class_info);
}


#endif // _NSCATENT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\inc\qshelpr.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    qshelpr.h

Abstract:

    This  file contains the definitions of the procedures exported by the query
    set helper module for internal use within the WinSock 2 DLL.

Author:

    Paul Drews (drewsxpa@ashland.intel.com) 11-Jan-1996

Notes:

    $Revision:   1.2  $

    $Modtime:   18 Jan 1996 11:22:32  $

Revision History:

    most-recent-revision-date email-name
        description

    11-Jan-1996 drewsxpa@ashland.intel.com
        Created original version

--*/

#ifndef _QSHELPR_
#define _QSHELPR_

#include "winsock2.h"
#include <windows.h>


INT
MapAnsiQuerySetToUnicode(
    IN     LPWSAQUERYSETA  Source,
    IN OUT LPDWORD         lpTargetSize,
    OUT    LPWSAQUERYSETW  Target
    );


INT
MapUnicodeQuerySetToAnsi(
    IN     LPWSAQUERYSETW  Source,
    IN OUT LPDWORD         lpTargetSize,
    OUT    LPWSAQUERYSETA  Target
    );

INT
CopyQuerySetA(
    IN LPWSAQUERYSETA  Source,
    OUT LPWSAQUERYSETA *Target
    );


CopyQuerySetW(
    IN LPWSAQUERYSETW  Source,
    OUT LPWSAQUERYSETW *Target
    );

LPWSTR
wcs_dup_from_ansi(
    IN LPSTR  Source
    );

LPSTR
ansi_dup_from_wcs(
    IN LPWSTR  Source
    );


#endif // _QSHELPR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\inc\scihlpr.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    scihelpr.h

Abstract:

    This  file contains the definitions of the procedures exported by the
    service class info helper module for internal use within the WinSock 2
    DLL. 

Author:

    Dirk Brandewie (dirk@mink.intel.com)  25-Jan-1996

Notes:

    $Revision:   1.0  $

    $Modtime:   25 Jan 1996 11:08:36  $

Revision History:

    most-recent-revision-date email-name
        description

    25-Jan-1996 dirk@mink.intel.com
        Created original version

--*/

#ifndef _SCIHELPR_
#define _SCIHELPR_

#include "winsock2.h"
#include <windows.h>

INT
MapAnsiServiceClassInfoToUnicode(
    IN     LPWSASERVICECLASSINFOA Source,
    IN OUT LPDWORD                lpTargetSize,
    IN     LPWSASERVICECLASSINFOW Target
    );

INT
MapUnicodeServiceClassInfoToAnsi(
    IN     LPWSASERVICECLASSINFOW Source,
    IN OUT LPDWORD                lpTargetSize,
    IN     LPWSASERVICECLASSINFOA Target
    );

#endif // _SCIHELPR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\inc\nspstate.h ===
/*++


  Intel Corporation Proprietary Information
  Copyright (c) 1995 Intel Corporation

  This listing is supplied under the terms of a license agreement with
  Intel Corporation and may not be used, copied, nor disclosed except in
  accordance with the terms of that agreeement.


Module Name:

    nsstate.h

Abstract:

    This  module  gives  the class definition for the NSPROVIDERSTATE object
    type.  The NSPROVIDERSTATE object holds the pointer to the provider object
    and the handle for a WSALookup{Begin/Next/End} series.

Author:

    Dirk Brandewie (dirk@mink.intel.com)  04-12-1995

Notes:

$Revision:   1.10  $

$Modtime:   15 Feb 1996 16:50:42  $


Revision History:

    04-Dec-1995 dirk@mink.intel.com
    created

--*/

#ifndef _NSPROVIDERSTATE_
#define _NSPROVIDERSTATE_

#include "classfwd.h"
#include "nsprovid.h"

class NSPROVIDERSTATE
{
  public:

    NSPROVIDERSTATE();

    INT
    Initialize(
        PNSPROVIDER  pNamespaceProvider
        );

    INT
    WINAPI
    LookupServiceBegin(
        IN  LPWSAQUERYSETW          lpqsRestrictions,
        IN  LPWSASERVICECLASSINFOW  lpServiceClassInfo,
        IN  DWORD                   dwControlFlags
        );

    INT
    WINAPI
    LookupServiceNext(
        IN     DWORD           dwContolFlags,
        IN OUT LPDWORD         lpdwBufferLength,
        OUT    LPWSAQUERYSETW  lpqsResults
        );

    INT
    WINAPI
    SupportsIoctl(
        );

    INT
    WINAPI
    Ioctl(
        IN  DWORD            dwControlCode,
        IN  LPVOID           lpvInBuffer,
        IN  DWORD            cbInBuffer,
        OUT LPVOID           lpvOutBuffer,
        IN  DWORD            cbOutBuffer,
        OUT LPDWORD          lpcbBytesReturned,
        IN  LPWSACOMPLETION  lpCompletion,
        IN  LPWSATHREADID    lpThreadId
        );

    INT
    WINAPI
    LookupServiceEnd();

    INT 
    WINAPI
    SetService(
        IN  LPWSASERVICECLASSINFOW   lpServiceClassInfo,
        IN  LPWSAQUERYSETW           lpqsRegInfo,
        IN  WSAESETSERVICEOP         essOperation,
        IN  DWORD                    dwControlFlags
        );

    INT
    WINAPI
    InstallServiceClass(
        IN  LPWSASERVICECLASSINFOW   lpServiceClassInfo
        );

    INT 
    WINAPI
    RemoveServiceClass(
        IN  LPGUID  lpServiceClassId
        );

    INT
    WINAPI
    GetServiceClassInfo(
        IN OUT  LPDWORD                 lpdwBufSize,
        IN OUT  LPWSASERVICECLASSINFOW  lpServiceClassInfo
        );


    ~NSPROVIDERSTATE();

    LIST_ENTRY   m_query_linkage;
    //Public data member to support putting this object on a linked list

  private:

    PNSPROVIDER  m_provider;
    // Pointer to the NSPROVIDER object associated with this object.

    HANDLE       m_provider_query_handle;
    // The handle returned from NSPLookupServiceBegin() to be passed to
    // NSPlookupServiceNext and NSPLookupSeviceEnd.

};  // class NSPROVIDERSTATE

inline
NSPROVIDERSTATE::NSPROVIDERSTATE()
/*++

Routine Description:

    Constructor for the NSPROVIDERSTATE object.  The first member function
    called after this must be Initialize.

Arguments:

    None

Return Value:

    Returns a pointer to a NSPROVIDERSTATE object.
--*/
{
    m_provider = NULL;
    m_provider_query_handle = NULL;
}



inline
INT
NSPROVIDERSTATE::Initialize(
    PNSPROVIDER  pNamespaceProvider
    )
/*++

Routine Description:

    This  procedure  performs  all initialization for the NSPROVIDERSTATE
    object.  This function  must  be  invoked  after the constructor, before
    any other member function is invoked.

Arguments:

    pNamespaceProvider - A pointer to a namespace provider object.

    ProviderQueryHandle - A handle to used in calls to Lookup
Return Value:

    If  the  function  is  successful,  it  returns ERROR_SUCCESS, otherwise it
    returns an appropriate WinSock 2 error code.
--*/
{
    assert (m_provider==NULL);
    pNamespaceProvider->Reference ();
    m_provider = pNamespaceProvider;
    return(ERROR_SUCCESS);
}





inline
INT
WINAPI
NSPROVIDERSTATE::LookupServiceBegin(
    IN  LPWSAQUERYSETW          lpqsRestrictions,
    IN  LPWSASERVICECLASSINFOW   lpServiceClassInfo,
    IN  DWORD                   dwControlFlags
    )
/*++

Routine Description:

    See description in NSPROVID.H

Arguments:

    None

Return Value:

    None
--*/
{
    return( m_provider->NSPLookupServiceBegin(
        lpqsRestrictions,
        lpServiceClassInfo,
        dwControlFlags,
        &m_provider_query_handle
        ));
}



inline
INT
WINAPI
NSPROVIDERSTATE::LookupServiceNext(
    IN     DWORD           dwContolFlags,
    IN OUT LPDWORD        lpdwBufferLength,
    OUT    LPWSAQUERYSETW  lpqsResults
    )
/*++

Routine Description:

    See description in NSPROVID.H

Arguments:

    None

Return Value:

    None
--*/
{
    return(m_provider->NSPLookupServiceNext(
        m_provider_query_handle,
        dwContolFlags,
        lpdwBufferLength,
        lpqsResults
        ));
}



inline
INT
WINAPI
NSPROVIDERSTATE::SupportsIoctl(
    )
{
    return (m_provider->SupportsIoctl());
}



inline
INT
WINAPI
NSPROVIDERSTATE::Ioctl(
    IN  DWORD            dwControlCode,
    IN  LPVOID           lpvInBuffer,
    IN  DWORD            cbInBuffer,
    OUT LPVOID           lpvOutBuffer,
    IN  DWORD            cbOutBuffer,
    OUT LPDWORD          lpcbBytesReturned,
    IN  LPWSACOMPLETION  lpCompletion,
    IN  LPWSATHREADID    lpThreadId
    )
{
    return (m_provider->NSPIoctl(
        m_provider_query_handle,
        dwControlCode,
        lpvInBuffer,
        cbInBuffer,
        lpvOutBuffer,
        cbOutBuffer,
        lpcbBytesReturned,
        lpCompletion,
        lpThreadId
        ));
}



inline
INT
WINAPI
NSPROVIDERSTATE::LookupServiceEnd()
/*++

Routine Description:

    See description in NSPROVID.H

Arguments:

    None

Return Value:

    None
--*/
{
    return(m_provider->NSPLookupServiceEnd(m_provider_query_handle));
}

inline
NSPROVIDERSTATE::~NSPROVIDERSTATE()
/*++

Routine Description:

    Denstructor for the NSPROVIDERSTATE object. 

Arguments:

    None

Return Value:

    None
--*/
{
    if (m_provider!=NULL) {
        m_provider->Dereference ();
        m_provider = NULL;
    }
}


#endif // _NSPROVIDERSTATE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\inc\startup.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    startup.h

Abstract:

    This  module  defines  procedures  to  be called at the time of loading and
    unloading  the  WinSock  2  DLL (typically from DllMain).  These procedures
    create and destroy the Startup/Cleanup synchronization mechanism.

Author:

    Paul Drews (drewsxpa@ashland.intel.com) 31-Aug-1995

Notes:

    $Revision:   1.4  $

    $Modtime:   12 Jan 1996 15:09:00  $

Revision History:

    1995-11-04 keithmo@microsoft.com
        Added support for WPUPostMessage() upcall.

    1995-08-31 drewsxpa@ashland.intel.com
        created

--*/

#ifndef _STARTUP_
#define _STARTUP_

#include "warnoff.h"
#include <windows.h>



extern
#if defined(__cplusplus)
"C"
#endif  // defined(__cplusplus)
VOID
CreateStartupSynchronization();

typedef
BOOL
(WINAPI *PWINSOCK_POST_ROUTINE)(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    );

extern PWINSOCK_POST_ROUTINE SockPostRoutine;

PWINSOCK_POST_ROUTINE
GetSockPostRoutine(
    VOID
    );

#define GET_SOCK_POST_ROUTINE()      \
    (SockPostRoutine ? SockPostRoutine : GetSockPostRoutine())


extern
#if defined(__cplusplus)
"C"
#endif  // defined(__cplusplus)
VOID
DestroyStartupSynchronization();

#endif // _STARTUP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\inc\nscatalo.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    nscatalo.h

Abstract:

    This module contains the interface to the catalog of name space providers
    for the winsock2 DLL.

Author:

    Dirk Brandewie  dirk@mink.intel.com 9-NOV-1995

Notes:

    $Revision:   1.7  $

    $Modtime:   14 Feb 1996 14:13:32  $


Revision History:

    09-NOV-1995 dirk@mink.intel.com
        Initial revision.
--*/

#ifndef _NSCATALO_
#define _NSCATALO_

#include "winsock2.h"
#include <windows.h>


typedef
BOOL
(* NSCATALOGITERATION) (
    IN PVOID            PassBack,
    IN PNSCATALOGENTRY  CatalogEntry
    );
/*++

Routine Description:

    CATALOGITERATION  is  a place-holder for a function supplied by the client.
    The  function  is  called once for each NSPROTO_CATALOG_ITEM structure in
    the catalog while enumerating the catalog.  The client can stop the
    enumeration early by returning FALSE from the function.

Arguments:

    PassBack     - Supplies  to  the  client an uninterpreted, unmodified value
                   that  was  specified  by the client in the original function
                   that  requested  the  enumeration.   The client can use this
                   value  to  carry context between the requesting site and the
                   enumeration function.

    CatalogEntry - Supplies  to  the client a reference to a NSCATALOGENTRY
                   structure with values for this item of the enumeration.

Return Value:

    TRUE  - The  enumeration  should continue with more iterations if there are
            more structures to enumerate.

    FALSE - The enumeration should stop with this as the last iteration even if
            there are more structures to enumerate.

--*/

PNSCATALOG
OpenInitializedNameSpaceCatalog();
/*++

Routine Description:

    Creates and returns catalog object that represents current reqistry state
Arguments:
    None
Return Value:
    Catalog object or NULL if allocation or registry IO fails

--*/



class NSCATALOG
{
public:

    NSCATALOG();

    INT
    InitializeFromRegistry(
        IN  HKEY    ParentKey,
        IN  HANDLE  CatalogChangeEvent OPTIONAL
        );

#ifdef _WIN64
    INT
    InitializeFromRegistry32(
        IN  HKEY    ParentKey
        );
#endif

    INT
    RefreshFromRegistry (
        IN  HANDLE  CatalogChangeEvent OPTIONAL
        );

    INT
    WriteToRegistry(
        );

    ~NSCATALOG();

    VOID
    EnumerateCatalogItems(
        IN NSCATALOGITERATION  Iteration,
        IN PVOID               PassBack
        );

    INT
    GetCountedCatalogItemFromProviderId(
        IN  LPGUID ProviderId,
        OUT PNSCATALOGENTRY FAR * CatalogItem
        );

    INT
    GetCountedCatalogItemFromNameSpaceId(
        IN  DWORD                 NameSpaceId,
        OUT PNSCATALOGENTRY FAR * CatalogItem
        );


    VOID
    AppendCatalogItem(
        IN  PNSCATALOGENTRY  CatalogItem
        );

    VOID
    RemoveCatalogItem(
        IN  PNSCATALOGENTRY  CatalogItem
        );

    INT WSAAPI
    GetServiceClassInfo(
        IN OUT  LPDWORD                 lpdwBufSize,
        IN OUT  LPWSASERVICECLASSINFOW  lpServiceClassInfo
        );

    INT
    LoadProvider(
        IN PNSCATALOGENTRY CatalogEntry
        );

    static
    LPSTR
    GetCurrentCatalogName(
        VOID
        );

private:

    BOOL
    OpenCatalog(
        IN  HKEY   ParentKey
        );

    VOID
    AcquireCatalogLock(
        VOID
        );

    VOID
    ReleaseCatalogLock(
        VOID
        );


    VOID
    UpdateNamespaceList (
        PLIST_ENTRY new_list
        );

    PNSPROVIDER
    GetClassInfoProvider(
        IN  DWORD BufSize,
        IN  LPWSASERVICECLASSINFOW  lpServiceClassInfo
        );


    LIST_ENTRY  m_namespace_list;
    // The head of the list of protocol catalog items

    ULONG m_num_items;
    // Number of items in this catalog.

    ULONG m_serial_num;
    // The serial number of the catalog (changes every time catalog
    // is changed in the registry)

    HKEY m_reg_key;
    // Handle of the registry key under which catalog resides.
    // We keep it open so we can get notified whenever catalog
    // changes.

    PNSPROVIDER m_classinfo_provider;
#ifdef _WIN64
    BOOLEAN     m_entries32;
#endif

    CRITICAL_SECTION m_nscatalog_lock;

};  // class dcatalog

inline
VOID
NSCATALOG::AcquireCatalogLock(
    VOID
    )
{
    EnterCriticalSection( &m_nscatalog_lock );
}



inline
VOID
NSCATALOG::ReleaseCatalogLock(
    VOID
    )
{
    LeaveCriticalSection( &m_nscatalog_lock );
}


#endif // _NSCATALO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\inc\ws2_rp.h ===
//--------------------------------------------------------------------
// Copyright (c)1997 Microsoft Corporation, All Rights Reserved
//
// ws2_rp.h
//
//--------------------------------------------------------------------


#ifndef _WS2_RP_H_
#define _WS2_RP_H_

// If this flag is defined, then WinSock2 will always act as if it is
// running in a restricted process:
#ifdef DBG
// #define DBG_ALWAYS_RESTRICTED
#endif

// #define LOCAL_HANDLES
#define LOCAL_EVENT_HANDLES

//--------------------------------------------------------------------
// This is the Provider ID for the chain that a restricted process 
// should follow.
//
// UUID: ec91fa14-5d3e-11d1-8c0f-0000f8754035
//--------------------------------------------------------------------

DEFINE_GUID( RestrictedProviderId,
             0xec91fa14,
             0x5d3e,
             0x11d1,
             0x8c, 0x0f, 0x00, 0x00, 0xf8, 0x75, 0x40, 0x35 );

//------------------------------------------------------------------------
// This is the Provider ID for the LSP entry itself.
//
// UUID: a92d64e1-5709-11d1-8c02-0000f8754035
//------------------------------------------------------------------------
DEFINE_GUID( RestrictedLayeredProviderGuid,
             0xa92d64e1,
             0x5709,
             0x11d1,
             0x8c, 0x02, 0x00, 0x00, 0xf8, 0x75, 0x40, 0x35 );

//--------------------------------------------------------------------
//
//--------------------------------------------------------------------

extern DWORD RP_Init();

extern BOOL  RP_IsRestrictedProcess();

#endif //_WS2_RP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\inc\trycatch.h ===
/*++

****COPYRIGHT NOTICE*****

Module Name:

    trycatch.h

Abstract:

    This  module  provides macros to support a lexical-scope exception-handling
    mechanism.  A brief comparison between this mechanism and the C++ exception
    mechanism is as follows:

    macro exception mechamism:

        extremely low run-time overhead

        catches exceptions only in lexical scope

        no value passed to exception handler

        explicitly thrown exceptions only

        exception regions can be nested and named

        usable by older compilers

    C++ exception mechanism:

        handles  all  types  of  exceptions  including  C  exceptions implicity
        thrown.

        catches exceptions thrown in dynamic scope

        involves some setup and teardown run-time overhead

        requires an up-to-date C++ compiler version

    These  macros  are  written  and  used  in  such a fashion that they can be
    transformed back into the C++ exception mechanism if needed.

Author:

    Paul Drews (drewsxpa@ashland.intel.com) 31-October-1995

Notes:

    $Revision:   1.2  $

    $Modtime:   12 Jan 1996 15:09:02  $

Revision History:

    most-recent-revision-date email-name
        description

    31-October-1995 drewsxpa@ashland.intel.com
        created

--*/

#ifndef _TRYCATCH_
#define _TRYCATCH_


// The TRY_START macro starts a guarded region

#define TRY_START(block_label) \
    /* nothing to do */


// The  TRY_THROW  macro  is  used  inside a guarded region to exit the guarded
// region immediately and enter the exception-recovery region.

#define TRY_THROW(block_label) \
    goto catch_##block_label


// The  TRY_CATCH  macro  marks  the  end  of the guarded region and starts the
// beginning  of  the  exception-recovery  region.   If  the TRY_CATCH macro is
// encountered in normal execution, the exception-recovery region is skipped.

#define TRY_CATCH(block_label) \
    goto end_##block_label; \
    catch_##block_label:


// The TRY_END macro marks the end of the exception-recovery region.  Execution
// resumes  here after completing execution of either the guarded region or the
// exception-recovery region.

#define TRY_END(block_label) \
    end_##block_label:



// A typical usage example of these macros is as follows:
//
// char *  buf1 = NULL;
// char *  buf2 = NULL;
// BOOL    return_value;
//
// TRY_START(mem_guard) {
//     buf1 = (char *) malloc(1000);
//     if (buf1 == NULL) {
//         TRY_THROW(mem_guard);
//     }
//     buf2 = (char *) malloc(1000);
//     if (buf2 == NULL) {
//         TRY_THROW(mem_guard);
//     }
//     return_value = TRUE;
// } TRY_CATCH(mem_guard) {
//     if (buf1 != NULL) {
//         free(buf1);
//         buf1 = NULL;
//     }
//     return_value = FALSE;
// } TRY_END(mem_guard);
//
// return return_value;


#endif // _TRYCATCH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\inc\trace.h ===
//////////////////////////////////////////////////////////////////////////
//
// INTEL Corporation Proprietary Information
// Copyright (c) Intel Corporation
//
// This listing is supplied under the terms of a license aggreement
// with INTEL Corporation and may not be used, copied nor disclosed
// except in accordance with that agreement.
//
//////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// $Workfile:   TRACE.H  $
// $Revision:   1.5  $
// $Modtime:   12 Jan 1996 15:09:00  $
//
// DESCRIPTION:
//
// this file defines a macros for tracing and the function prototypes
// for the actual output functions. If the symbol TRACING is not
// defined  all the macros expands to ((void)0).
//
// There are three global variables that control the behavior of the
// tracing macros/functions.  debugLevel is a 32 bit bitmask that
// determine controls what level of debug messages is output.
// iTraceDestination controls whether the debug output goes to a file or
// to the aux device. if iTraceDestination == TRACE_TO_FILE szTraceFile
// must contain the filename
//
/////////////////////////////////////////////////////////////////////

#ifndef __TRACE_H__
#define __TRACE_H__

extern
#if defined(__cplusplus)
"C"
#endif  // defined(__cplusplus)
VOID __cdecl PrintDebugString(char *format, ...);

extern
#if defined(__cplusplus)
"C"
#endif  // defined(__cplusplus)
LONG
Ws2ExceptionFilter(
    LPEXCEPTION_POINTERS ExceptionPointers,
    LPSTR SourceFile,
    LONG LineNumber
    );

//
// defines for where the debug output should go
//
#define TRACE_TO_FILE    0
#define TRACE_TO_AUX     1

// the size of the string buffers used as arg to wsprintf
// in trace.c
#define TRACE_OUTPUT_BUFFER_SIZE  1024

// Debug level masks
#define DBG_TRACE       0x00000001
#define DBG_WARN        0x00000002
#define DBG_ERR         0x00000004
#define DBG_MEMORY      0x00000008
#define DBG_LIST        0x00000010
#define DBG_FUNCTION    0x00000020

#if defined(TRACING)

extern
#if defined(__cplusplus)
"C"
#endif  // defined(__cplusplus)
DWORD debugLevel;

//
// This macro creates debug output depending on the debug mask "sev" and
// calls PrintDebugString output function. PrintDebugString makes the
// descision on whether the output goes into a file or to the aux device.
//
#define  DEBUGF(sev, var_args)                                                  \
{                                                                               \
   if ((sev) & debugLevel) {                                                    \
      switch (sev) {                                                            \
         case DBG_TRACE:                                                        \
            PrintDebugString("WS2_32 TRACE  :: %s:%d\n", __FILE__, __LINE__ );  \
            PrintDebugString var_args ;                                         \
         break;                                                                 \
         case DBG_WARN:                                                         \
            PrintDebugString("WS2_32 WARNING:: %s : %d\n", __FILE__, __LINE__ );\
            PrintDebugString var_args ;                                         \
            break;                                                              \
         case DBG_ERR:                                                          \
            PrintDebugString("WS2_32 ERROR  :: %s : %d\n", __FILE__, __LINE__ );\
            PrintDebugString var_args;                                          \
            break;                                                              \
        case DBG_MEMORY:                                                        \
            PrintDebugString("WS2_32 MEMORY :: %s : %d\n", __FILE__, __LINE__ );\
            PrintDebugString var_args ;                                         \
            break;                                                              \
        case DBG_LIST:                                                          \
            PrintDebugString("WS2_32 LIST   :: %s : %d\n", __FILE__, __LINE__ );\
            PrintDebugString var_args ;                                         \
            break;                                                              \
        case DBG_FUNCTION:                                                      \
            PrintDebugString var_args;                                          \
            break;                                                              \
      }                                                                         \
   }                                                                            \
}                                                                               \



#define ALLOC_LOG( pointer, size)                                             \
    DEBUGF( DBG_MEMORY ,("MEMORY %lX size %X Allocated \n",                   \
                         (pointer),(size)))                                   \

#define DEALLOC_LOG(pointer, size)                                            \
DEBUGF( DBG_MEMORY ,("MEMORY %lX size %X Deallocated \n",                     \
                         (pointer),(size)))                                   \


#define LIST_ADD_LOG(list, element)                                           \
    DEBUGF( DBG_LIST ,("LIST %lX element %lX Added \n",                       \
                       (list),(element)))                                     \

#define LIST_DEL_LOG(list, element)                                           \
    DEBUGF( DBG_LIST ,("LIST %lX element %lX Deleted \n",                     \
                       (list),(element)))                                     \

#define ENTER_FUNCTION(name)                                                  \
DEBUGF( DBG_FUNCTION,name)                                \


#define EXIT_FUNCTION(name)                                                   \
DEBUGF( DBG_FUNCTION,name)                                \

#define WS2_EXCEPTION_FILTER()                            \
            Ws2ExceptionFilter(                           \
                GetExceptionInformation(),                \
                (LPSTR)__FILE__,                          \
                (LONG)__LINE__                            \
                )

#else // TRACING
     // make sure that these are defined if tracing is turned off
#define DEBUGF(sev, va)                     ((void)0)
#define LIST_ADD_LOG(list, element)         ((void)0)
#define LIST_DEL_LOG(list, element)         ((void)0)
#define ENTER_FUNCTION(name)                ((void)0)
#define EXIT_FUNCTION(name)                 ((void)0)
#define WS2_EXCEPTION_FILTER()              EXCEPTION_EXECUTE_HANDLER
#define ALLOC_LOG( pointer, size)                                             \
    DEBUGF( DBG_MEMORY ,("",                                                  \
                         (pointer),(size)))                                   \

#define DEALLOC_LOG(pointer, size)\
    DEBUGF( DBG_MEMORY ,("",\
                         (pointer),(size)))  \

#endif // TRACING

#endif // __TRACE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\inc\wsassert.h ===
#ifndef _WSASSERT_
#define _WSASSERT_


//
// Define an assert that actually works.
//

#if DBG

#ifdef __cplusplus
extern "C" {
#endif

VOID
WsAssert(
    LPVOID FailedAssertion,
    LPVOID FileName,
    ULONG LineNumber
    );

#ifdef __cplusplus
}
#endif

#define WS_ASSERT(exp)      if( !(exp) )                                \
                                WsAssert( #exp, __FILE__, __LINE__ );   \
                            else

#define WS_REQUIRE(exp)     WS_ASSERT(exp)

#else

#define WS_ASSERT(exp)
#define WS_REQUIRE(exp)     ((VOID)(exp))

#endif


//
// Map CRT assert to our manly assert.
//

#undef assert
#define assert WS_ASSERT


#endif  // _WSASSERT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\addrinfo.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    addrinfo.c

Abstract:

    Forward & reverse name resolution library routines
    and related helper functions.

    Could be improved if necessary:
    QueryDNSforA could use WSALookupService instead of gethostbyname.
    gethostbyname will return success on some weird strings.
    Similarly, inet_addr is very loose (octal digits, etc).
    Could support multiple h_aliases.
    Could support hosts.txt file entries.

Author:

Revision History:

--*/

#include "precomp.h"
#include <svcguid.h>

#define NUM_ADDRESS_FAMILIES 2

#define L_A              0x1
#define L_AAAA           0x2
#define L_BOTH           0x3
#define L_AAAA_PREFERRED 0x6
#define L_A_PREFERRED    0x9  // Not used, but code would support it.

#define T_A     1
#define T_CNAME 5
#define T_AAAA  28
#define T_PTR   12
#define T_ALL   255

#define C_IN    1

void * __cdecl 
renew(void *p, size_t sz);


//
//  DCR:  fix up winsock2.h
//

#define PSOCKET_ADDRESS_LIST    LPSOCKET_ADDRESS_LIST


//
//  Turn static off until solid
//  otherwise we get bad symbols
//

#define STATIC
//#define STATIC  static



STATIC
int
ParseDNSReply(
    u_short         Needed,
    u_char *        data,
    u_int           size,
    SOCKADDR_IN **  pV4Addrs,
    u_int *         pNumV4Slots,
    u_int *         pNumV4Addrs,
    SOCKADDR_IN6 ** pV6Addrs,
    u_int *         pNumV6Slots,
    u_int *         pNumV6Addrs,
    char **         pName,
    u_short         ServicePort
    );

STATIC
int
QueryDNS(
    IN      const char *        name,
    IN      u_int               LookupType,
    OUT     SOCKADDR_IN  **     pV4Addrs,
    OUT     u_int *             pNumV4Addrs,
    OUT     SOCKADDR_IN6 **     pV6Addrs,
    OUT     u_int *             pNumV6Addrs,
    OUT     char **             pAlias,
    IN      u_short             ServicePort
    );


//* SortIPAddrs - sort addresses of the same family.
//
//  A wrapper around a sort Ioctl.  If the Ioctl isn't implemented, 
//  the sort is a no-op.
//

int
SortIPAddrs(
    IN      int                     af,
    OUT     LPVOID                  Addrs,
    IN OUT  u_int *                 pNumAddrs,
    IN      u_int                   width,
    OUT     SOCKET_ADDRESS_LIST **  pAddrlist
    )
{
    DWORD           status = NO_ERROR;
    SOCKET          s = 0;
    DWORD           bytesReturned;
    DWORD           size;
    DWORD           i;
    PSOCKADDR       paddr;
    UINT            countAddrs = *pNumAddrs;

    PSOCKET_ADDRESS_LIST    paddrlist = NULL;

    //
    //  open a socket in the specified address family.
    //
    //  DCR:  SortIpAddrs dumps addresses if not supported by stack
    //
    //      this makes some sense at one level but is still silly
    //      in implementation, because by the time this is called we
    //      can't go back and query for the other protocol;
    //
    //      in fact, the way this was first implemented:  if no
    //      hint is given you query for AAAA then A;  and since
    //      you stop as soon as you get results -- you're done
    //      and stuck with AAAA which you then dump here if you
    //      don't have the stack!  hello
    //
    //      it strikes me that you test for the stack FIRST before
    //      the query, then live with whatever results you get
    //

#if 0
    s = socket( af, SOCK_DGRAM, 0 );
    if ( s == INVALID_SOCKET )
    {
        status = WSAGetLastError();

        if (status == WSAEAFNOSUPPORT) {
            // Address family is not supported by the stack.
            // Remove all addresses in this address family from the list.
            *pNumAddrs = 0;
            return 0;
        }
        return status;
    }
#endif

#if 0
    // Ok, stack is installed, but is it running?
    //
    // We do not care if stack is installed but is not running.
    // Whoever stopped it, must know better what he/she was doing.
    //
    // Binding even to wildcard address consumes valueable machine-global
    // resource (UDP port) and may have unexpected side effects on
    // other applications running on the same machine (e.g. an application
    // running frequent getaddrinfo queries would adversly imact
    // (compete with) application(s) on the same machine trying to send
    // datagrams from wildcard ports).
    //
    // If someone really really wants to have this code check if the
    // stack is actually running, he/she should do it inside of WSAIoctl
    // call below and return a well-defined error code to single-out
    // the specific case of stack not running.
    //

    memset(&TestSA, 0, sizeof(TestSA));
    TestSA.ss_family = (short)af;
    status = bind(s, (LPSOCKADDR)&TestSA, sizeof(TestSA));
    if (status == SOCKET_ERROR)
    {
        // Address family is not currently supported by the stack.
        // Remove all addresses in this address family from the list.
        closesocket(s);
        return 0;
    }
#endif

    //
    //  build SOCKET_ADDRESS_LIST
    //      - allocate
    //      - fill in with pointers into SOCKADDR array
    //

    size = FIELD_OFFSET( SOCKET_ADDRESS_LIST, Address[countAddrs] );
    paddrlist = (SOCKET_ADDRESS_LIST *)new BYTE[size];

    if ( !paddrlist )
    {
        status = WSA_NOT_ENOUGH_MEMORY;
        goto Done;
    }

    for ( i=0; i<countAddrs; i++ )
    {
        paddr = (PSOCKADDR) (((PBYTE)Addrs) + i * width);
        paddrlist->Address[i].lpSockaddr      = paddr;
        paddrlist->Address[i].iSockaddrLength = width;
    }
    paddrlist->iAddressCount = countAddrs;

    //
    //  sort if multiple addresses and able to open socket
    //      - open socket of desired type for sort
    //      - sort, if sort fails just return unsorted
    //

    if ( countAddrs > 1 )
    {
        s = socket( af, SOCK_DGRAM, 0 );
        if ( s == INVALID_SOCKET )
        {
            s = 0;
            goto Done;
        }

        status = WSAIoctl(
                    s,
                    SIO_ADDRESS_LIST_SORT,
                    (LPVOID)paddrlist,
                    size,
                    (LPVOID)paddrlist,
                    size,
                    & bytesReturned,
                    NULL,
                    NULL );

        if ( status == SOCKET_ERROR )
        {
            status = NO_ERROR;
#if 0
            status = WSAGetLastError();
            if (status==WSAEINVAL) {
                // Address family does not support this IOCTL
                // Addresses are valid but no sort is done.
                status = NO_ERROR;
            }
#endif
        }
    }

Done:

    if ( status == NO_ERROR )
    {
        *pNumAddrs = paddrlist->iAddressCount;
        *pAddrlist = paddrlist;
    }

    if ( s != 0 )
    {
        closesocket(s);
    }

    return status;
}


//
//* getipnodebyaddr - get node name corresponding to an address.
//
//  A wrapper around WSALookupServiceBegin/Next/End,
//  that is like gethostbyaddr but handles AF_INET6 addresses also.
//
//  DCR:  need to change this routine
//      - the caller of this function just wants the name
//      - we go and allocate and build a hostent that has nothing
//          but the address and the name
//      - why not just return the name!
//      - even if do want hostent, just ask for it and
//          create copy as in RnR routines
//

STATIC
PHOSTENT
getipnodebyaddr(
    IN      const void *    Address,        // Address for which to look up corresponding name.
    IN      int             AddressLength,  // Length of Address, in bytes.
    IN      int             AddressFamily,  // Family address belongs to (i.e. AF_*).
    OUT     int *           ReturnError     // Where to return error (optional, NULL if none).
    )
{
    u_char *LookupAddr = (u_char *)Address;
    int LookupAF = AddressFamily;
    char LookupString[80];
    GUID PtrGuid =  SVCID_DNS(T_PTR);
    HANDLE Resolver;
    char Buffer[sizeof(WSAQUERYSETA) + 2048];
    PWSAQUERYSETA query = (PWSAQUERYSETA) Buffer;
    u_long Size;
    int Error;
    char *Name;
    u_int NameLength;
    struct hostent *HostEntry;
    char *Marker;


    //
    // Prepare for error returns.
    //
    Name = NULL;
    query->lpszServiceInstanceName = NULL;
    HostEntry = NULL;

    //
    // Verify arguments are reasonable.
    //

    if (Address == NULL) {
        Error = WSAEFAULT;
        goto Return;
    }

    if (AddressFamily == AF_INET6) {
        if (AddressLength == 16) {
            // Check if this is a v4 mapped or v4 compatible address.
            if ((IN6_IS_ADDR_V4MAPPED((struct in6_addr *)Address)) ||
                (IN6_IS_ADDR_V4COMPAT((struct in6_addr *)Address))) {
                // Skip over first 12 bytes of IPv6 address.
                LookupAddr = &LookupAddr[12];
                // Set address family to IPv4.
                LookupAF = AF_INET;
            }
        } else {
            // Bad length for IPv6 address.
            Error = WSAEFAULT;
            goto Return;
        }
    } else if (AddressFamily == AF_INET) {
        if (AddressLength != 4) {
            // Bad length for IPv4 address.
            Error = WSAEFAULT;
            goto Return;
        }
    } else {
        // Address family not supported.
        Error = WSAEAFNOSUPPORT;
        goto Return;
    }

    //
    // Prepare lookup string.
    //
    //  DCR:  just call IP6 to reverse function
    //  DCR:  just call IP4 to reverse function
    //

    if (LookupAF == AF_INET6) {
        int Position, Loop;
        u_char Hex[] = "0123456789abcdef";

        //
        // Create reverse DNS name for IPv6.
        // The domain is "ip6.int".
        // Append a trailing "." to prevent domain suffix searching.
        //
        for (Position = 0, Loop = 15; Loop >= 0; Loop--) {
            LookupString[Position++] = Hex[LookupAddr[Loop] & 0x0f];
            LookupString[Position++] = '.';
            LookupString[Position++] = Hex[(LookupAddr[Loop] & 0xf0) >> 4];
            LookupString[Position++] = '.';
        }
        LookupString[Position] = 0;
        strcat(LookupString, "ip6.int.");

    } else {
        //
        // Create reverse DNS name for IPv4.
        // The domain is "in-addr.arpa".
        // Append a trailing "." to prevent domain suffix searching.
        //
        (void)sprintf(LookupString, "%u.%u.%u.%u.in-addr.arpa.",
                      LookupAddr[3], LookupAddr[2], LookupAddr[1],
                      LookupAddr[0]);
    }

    //
    // Format DNS query.
    // Build a Winsock T_PTR DNS query.
    //
    //
    //  DCR:  calling for blob just means a cache miss
    //
    memset( query, 0, sizeof(*query) );

    query->dwSize = sizeof(*query);
    query->lpszServiceInstanceName = LookupString;
    query->dwNameSpace = NS_DNS;
    query->lpServiceClassId = &PtrGuid;

    Error = WSALookupServiceBeginA(
                query,
                LUP_RETURN_NAME | LUP_RETURN_BLOB,
                &Resolver );
    if (Error) {
        Error = WSAGetLastError();
        if (Error == WSASERVICE_NOT_FOUND)
        {
            Error = WSAHOST_NOT_FOUND;
        }
        goto Return;
    }

    Size = sizeof(Buffer);
    Error = WSALookupServiceNextA(
                Resolver,
                0,
                &Size,
                query );
    if (Error) {
        Error = WSAGetLastError();
        if (Error == WSASERVICE_NOT_FOUND)
        {
            Error = WSAHOST_NOT_FOUND;
        }
        (void) WSALookupServiceEnd(Resolver);
        goto Return;
    }

    //
    //  First check if we got parsed name back.
    //
    //  DCR:  why parse blob, when only want name
    //  DCR:  why would WSALookupServiceNext() fail
    //          to get name on successful query
    //

    if (query->lpszServiceInstanceName != NULL) {
        Name = query->lpszServiceInstanceName;
    } else {
        //
        // Next check if got a raw DNS reply.
        //
        if (query->lpBlob != NULL) {
            //
            // Parse the DNS reply message, looking for a PTR record.
            //
            Error = ParseDNSReply(
                        T_PTR,
                        query->lpBlob->pBlobData,
                        query->lpBlob->cbSize,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &Name,
                        0 );

            if ( Name == NULL ) {
                if (Error == 0)
                {
                    Error = WSAHOST_NOT_FOUND;
                }
                (void) WSALookupServiceEnd(Resolver);
                goto Return;
            }

        } else {
            // 
            // Something wrong.
            //
            Error = WSANO_RECOVERY;
            (void) WSALookupServiceEnd(Resolver);
            goto Return;
        }
    }

    (void) WSALookupServiceEnd(Resolver);

    //
    //  DCR:  functionalize basic hostent creation
    //  DCR:  functionalize PTR hostent creation
    //

    //
    // Allocate the hostent structure.  Also need space for the things it
    // points to - a name buffer and null terminator, an empty null terminated
    // array of aliases, and an array of addresses with one entry.
    //
    NameLength = strlen(Name) + sizeof(char);
    Size = sizeof(struct hostent) + // aligned @ wordsize
        (3 * sizeof(char *)) +      // aligned @ wordsize
        AddressLength +             // aligned @ wordsize
        NameLength;                 // align @ sizeof(char)
    HostEntry = (struct hostent *) new BYTE[Size];
    if (HostEntry == NULL) {
        Error = WSA_NOT_ENOUGH_MEMORY;
        goto Return;
    }

    //
    // Populate the hostent structure we will return.
    //
    HostEntry->h_addrtype = (short)AddressFamily;
    HostEntry->h_length = (short)AddressLength;

    //
    // The order in which the padding after the hostent structure is
    // used is dictated by the alignment requirements of the fields.
    // h_alias and h_addr_list[x] (char *) must be aligned on a word
    // boundary while *h_addr_list[x] and *h_name (char) need not be.
    //
    Marker = (char *)(HostEntry + 1);

    HostEntry->h_aliases = (char **)Marker;
    *HostEntry->h_aliases = NULL;
    Marker += sizeof(char *);

    HostEntry->h_addr_list = (char **)Marker;
    *HostEntry->h_addr_list = Marker + (2 * sizeof(char *));
    memcpy(*HostEntry->h_addr_list, Address, AddressLength);
    Marker += sizeof(char *);
    *(char **)Marker = NULL;
    Marker += sizeof(char *);


    HostEntry->h_name = Marker;
    strcpy(HostEntry->h_name, Name);
    
Return:

    if (ReturnError != NULL)
        *ReturnError = Error;
    if ((Name != NULL) && (Name != query->lpszServiceInstanceName))
        delete Name;
    return HostEntry;
}


//* freehostent
//
STATIC
void
freehostent(struct hostent *Free)
{
    delete Free;
}


//* freeaddrinfo - Free an addrinfo structure (or chain of structures).
//
//  As specified in RFC 2553, Section 6.4.
//

void
WSAAPI
freeaddrinfo(
    IN OUT  struct addrinfo *   Free
    )
{
    struct addrinfo * pnext;

    //
    //  free each addrinfo struct in chain
    //

    for ( pnext = Free; pnext != NULL; Free = pnext )
    {
        pnext = Free->ai_next;

        if ( Free->ai_canonname )
        {
            delete Free->ai_canonname;
        }
        if ( Free->ai_addr )
        {
            delete Free->ai_addr;
        }
        delete Free;
    }
}


//* NewAddrInfo - Allocate an addrinfo structure and populate some fields.
//
//  Internal function, not exported.  Expects to be called with valid
//  arguments, does no checking.
//
//  Returns a partially filled-in addrinfo struct, or NULL if out of memory.
//

STATIC
struct addrinfo *
NewAddrInfo(
    IN      int             ProtocolFamily, // Must be either PF_INET or PF_INET6.
    IN      int             SocketType,     // SOCK_*.  Can be wildcarded (zero).
    IN      int             Protocol,       // IPPROTO_*.  Can be wildcarded (zero).
    IN OUT  struct addrinfo ***Prev         // In/out param for accessing previous ai_next.
    )
{
    struct addrinfo *New;

    //
    // Allocate a new addrinfo structure.
    //
    New = (struct addrinfo *)new BYTE[sizeof(struct addrinfo)];
    if (New == NULL)
        return NULL;

    //
    // Fill in the easy stuff.
    //
    New->ai_flags = 0;  // REVIEW: Spec doesn't say what this should be.
    New->ai_family = ProtocolFamily;
    New->ai_socktype = SocketType;
    New->ai_protocol = Protocol;
    if (ProtocolFamily == PF_INET) {
        New->ai_addrlen = sizeof(struct sockaddr_in);
    } else {
        New->ai_addrlen = sizeof(struct sockaddr_in6);
    }
    New->ai_canonname = NULL;
    New->ai_addr = (struct sockaddr *)new BYTE[New->ai_addrlen];
    if (New->ai_addr == NULL) {
        delete New;
        return NULL;
    }
    New->ai_next = NULL;

    //
    // Link this one onto the end of the chain.
    //
    **Prev = New;
    *Prev = &New->ai_next;

    return New;
}


int
AppendAddrInfo(
    LPSOCKADDR pAddr, 
    int SocketType,           // SOCK_*.  Can be wildcarded (zero).
    int Protocol,             // IPPROTO_*.  Can be wildcarded (zero).
    struct addrinfo ***Prev)  // In/out param for accessing previous ai_next.
{
    int     Error = 0;
    int     ProtocolFamily = pAddr->sa_family;
    struct addrinfo * CurrentInfo;

    CurrentInfo = NewAddrInfo(
                        ProtocolFamily,
                        SocketType,
                        Protocol,
                        Prev );

    if ( CurrentInfo == NULL )
    {
        return EAI_MEMORY;
    }

    memcpy(
        CurrentInfo->ai_addr,
        pAddr,
        CurrentInfo->ai_addrlen );

    return Error;
}


VOID
UnmapV4Address(
    OUT     LPSOCKADDR_IN   pV4Addr, 
    IN      LPSOCKADDR_IN6  pV6Addr
    )
/*++

Routine Description:

    Map IP6 sockaddr with IP4 mapped address into IP4 sockaddr.

    Note:  no checked that address IP4 mapped\compatible.

Arguments:

    pV4Addr -- ptr to IP4 sockaddr to write

    pV6Addr -- ptr to IP6 sockaddr with mapped-IP4 address

Return Value:

    None

--*/
{
    pV4Addr->sin_family = AF_INET;
    pV4Addr->sin_port   = pV6Addr->sin6_port;

    memcpy(
        &pV4Addr->sin_addr,
        &pV6Addr->sin6_addr.s6_addr[12],
        sizeof(struct in_addr) );

    memset(
        &pV4Addr->sin_zero,
        0,
        sizeof(pV4Addr->sin_zero) );
}


BOOL
IsIp6Running(
    VOID
    )
/*++

Routine Description:

    Is IP6 running?

Arguments:

    None

Return Value:

    TRUE if IP6 stack is up.
    FALSE if down.

--*/
{
    SOCKET  s;

    //
    //  test is IP6 up by openning IP6 socket
    //

    s = socket(
            AF_INET6,
            SOCK_DGRAM,
            0
            );
    if ( s != INVALID_SOCKET )
    {
        closesocket( s );
        return( TRUE );
    }
    return( FALSE );
}


//* LookupNode - Resolve a nodename and add any addresses found to the list.
//
//  Internal function, not exported.  Expects to be called with valid
//  arguments, does no checking.
//
//  Note that if AI_CANONNAME is requested, then **Prev should be NULL
//  because the canonical name should be returned in the first addrinfo
//  that the user gets.
//
//  Returns 0 on success, an EAI_* style error value otherwise.
//
//  DCR:  extra memory allocation
//      the whole paradigm here
//          - query DNS
//          - alloc\realloc SOCKADDR for each address building array
//          - build SOCKET_ADDRESS_LIST to sort
//          - build ADDRINFO for each SOCKADDR
//      seems to have an unnecessary step -- creating the first SOCKADDR
//      we could just build the ADDRINFO blobs we want from the CSADDR
//      WHEN NECESSARY build the SOCKET_ADDRESS_LIST to do the sort
//          and rearrange the ADDRINFOs to match
//
//      OR (if that's complicated)
//          just build one big SOCKADDR array and SOCKET_ADDRESS_LIST
//          array from CSADDR count
//

STATIC
int
LookupNode(
    IN      PCSTR           NodeName,       // Name of node to resolve.
    IN      int             ProtocolFamily, // Must be zero, PF_INET, or PF_INET6.
    IN      int             SocketType,     // SOCK_*.  Can be wildcarded (zero).
    IN      int             Protocol,       // IPPROTO_*.  Can be wildcarded (zero).
    IN      u_short         ServicePort,    // Port number of service.
    IN      int             Flags,          // Flags.
    IN OUT  ADDRINFO ***    Prev            // In/out param for accessing previous ai_next.
    )
{
    u_int           LookupType;
    u_int           NumV6Addrs;
    u_int           NumV4Addrs;
    SOCKADDR_IN  *  V4Addrs = NULL;
    SOCKADDR_IN6 *  V6Addrs = NULL;
    PCHAR           Alias = NULL;
    int             Error;
    u_int           i;
    SOCKET_ADDRESS_LIST *   V4addrlist = NULL;
    SOCKET_ADDRESS_LIST *   V6addrlist = NULL;
    struct addrinfo **      pFirst = *Prev;

    //
    //  set query types based on family hint
    //
    //      - if no family query for IP4 and
    //      IP6 ONLY if IP6 stack is installed
    //
    //  DCR:  in future releases change this so select protocols
    //      of all stacks running
    //

    switch (ProtocolFamily)
    {
    case 0:

        LookupType = L_A;

        if ( IsIp6Running() )
        {
            LookupType |= L_AAAA;
        }
        break;

    case PF_INET:
        LookupType = L_A;
        break;

    case PF_INET6:
        LookupType = L_AAAA;
        break;

    default:
        return EAI_FAMILY;
    }

    //
    //  query
    //

    Error = QueryDNS(
                NodeName,
                LookupType,
                & V4Addrs,
                & NumV4Addrs,
                & V6Addrs,
                & NumV6Addrs,
                & Alias,
                ServicePort
                );
    if ( Error != NO_ERROR )
    {
        if (Error == WSANO_DATA) {
            Error = EAI_NODATA;
        } else if (Error == WSAHOST_NOT_FOUND) {
            Error = EAI_NONAME;
        } else {
            Error = EAI_FAIL;
        }
        goto Done;
    }

    //
    //  sort addresses to best order
    //

    if ( NumV6Addrs > 0 )
    {
        Error = SortIPAddrs(
                    AF_INET6,
                    (LPVOID)V6Addrs,
                    &NumV6Addrs,
                    sizeof(SOCKADDR_IN6),
                    &V6addrlist );

        if ( Error != NO_ERROR )
        {
            Error = EAI_FAIL;
            goto Done;
        }
    }

    if ( NumV4Addrs > 0 )
    {
        Error = SortIPAddrs(
                    AF_INET,
                    (LPVOID)V4Addrs,
                    &NumV4Addrs,
                    sizeof(SOCKADDR_IN),
                    &V4addrlist );

        if ( Error != NO_ERROR )
        {
            Error = EAI_FAIL;
            goto Done;
        }
    }

    //
    //  build addrinfo structure for each address returned
    //
    //  for IP6 v4 mapped addresses
    //      - if querying EXPLICITLY for IP6 => dump
    //      - if querying for anything => turn into IP4 addrinfo
    //

    for ( i = 0;  !Error && (i < NumV6Addrs); i++)
    {
        if ( IN6_IS_ADDR_V4MAPPED(
                (struct in6_addr *)
                    &((LPSOCKADDR_IN6)V6addrlist->Address[i].lpSockaddr)->sin6_addr))
        {
            if (ProtocolFamily != PF_INET6)
            {
                SOCKADDR_IN V4Addr;

                UnmapV4Address(
                    &V4Addr,
                    (LPSOCKADDR_IN6)V6addrlist->Address[i].lpSockaddr );
    
                Error = AppendAddrInfo(
                            (LPSOCKADDR) &V4Addr,
                            SocketType,
                            Protocol,
                            Prev );
            }
        }
        else
        {
            Error = AppendAddrInfo(
                        V6addrlist->Address[i].lpSockaddr,
                        SocketType,
                        Protocol,
                        Prev );
        }
    }

    for ( i = 0;  !Error && (i < NumV4Addrs);  i++ )
    {
        Error = AppendAddrInfo(
                    V4addrlist->Address[i].lpSockaddr,
                    SocketType,
                    Protocol,
                    Prev );
    }

    //
    //  fill in canonname of first addrinfo
    //      - only if CANNONNAME flag set
    //
    //  canon name is
    //      - actual name of address record if went through CNAME (chain)
    //      - otherwise the passed in name we looked up
    //
    //  DCR:  should canon name be the APPENDED name we queried for?
    //

    if ( *pFirst && (Flags & AI_CANONNAME) )
    {
        if (Alias != NULL) {
            //
            // The alias that QueryDNS gave us is
            // the canonical name.
            //
            (*pFirst)->ai_canonname = Alias;
            Alias = NULL;
        } else {
            int NameLength;

            NameLength = strlen(NodeName) + 1;
            (*pFirst)->ai_canonname = (char *)new BYTE[NameLength];
            if ((*pFirst)->ai_canonname == NULL) {
                Error = EAI_MEMORY;
                goto Done;
            }
            memcpy((*pFirst)->ai_canonname, NodeName, NameLength);
        }

        // Turn off flag so we only do this once.
        Flags &= ~AI_CANONNAME;
    }

Done:

    if ( V4addrlist != NULL )
        delete V4addrlist;

    if (V6addrlist != NULL)
        delete V6addrlist;

    if (V4Addrs != NULL)
        delete V4Addrs;

    if (V6Addrs != NULL)
        delete V6Addrs;

    if (Alias != NULL)
        delete Alias;

    return Error;
}


//* ParseV4Address
//
//  Helper function for parsing a literal v4 address, because
//  WSAStringToAddress is too liberal in what it accepts.
//  Returns FALSE if there is an error, TRUE for success.
//
//  The syntax is a.b.c.d, where each number is between 0 - 255.
//

int
ParseV4Address(
    IN      PCSTR           String,
    OUT     PIN_ADDR        Addr
    )
{
    u_int Number;
    int NumChars;
    char Char;
    int i;

    for (i = 0; i < 4; i++) {
        Number = 0;
        NumChars = 0;
        for (;;) {
            Char = *String++;
            if (Char == '\0') {
                if ((NumChars > 0) && (i == 3))
                    break;
                else
                    return FALSE;
            }
            else if (Char == '.') {
                if ((NumChars > 0) && (i < 3))
                    break;
                else
                    return FALSE;
            }
            else if (('0' <= Char) && (Char <= '9')) {
                if ((NumChars != 0) && (Number == 0))
                    return FALSE;
                else if (++NumChars <= 3)
                    Number = 10*Number + (Char - '0');
                else
                    return FALSE;
            } else
                return FALSE;
        }
        if (Number > 255)
            return FALSE;
        ((u_char *)Addr)[i] = (u_char)Number;
    }

    return TRUE;
}



INT
WSAAPI
getaddrinfo(
    IN      const char FAR *            NodeName,
    IN      const char FAR *            ServiceName,
    IN      const struct addrinfo FAR * Hints,
    OUT     struct addrinfo FAR * FAR * Result
    )
/*++

Routine Description:

    Protocol independent name to address translation routine.

    Spec'd in RFC 2553, section 6.4.

Arguments:

    NodeName    - name to lookup

    ServiceName - service to lookup

    Hints       - address info providing hints to guide lookup

    Result      - addr to receive ptr to resulting buffer

Return Value:

    ERROR_SUCCESS if successful.
    Winsock error code on failure.

--*/
{
    struct addrinfo *CurrentInfo;
    struct addrinfo **Next;
    int ProtocolId = 0;
    u_short ProtocolFamily = PF_UNSPEC;
    u_short ServicePort = 0;
    int SocketType = 0;
    int Flags = 0;
    int Error;
    struct sockaddr_in *sin;
    struct sockaddr_in6 *sin6;
    char AddressString[INET6_ADDRSTRLEN];
    

    Error = TURBO_PROLOG();
    if (Error!=NO_ERROR) {
        return Error;
    }

    //
    // In case we have to bail early, make it clear to our caller
    // that we haven't allocated an addrinfo structure.
    //
    *Result = NULL;
    Next = Result;

    //
    // Both the node name and the service name can't be NULL.
    //
    if ((NodeName == NULL) && (ServiceName == NULL))
    {
        Error = EAI_NONAME;
        goto Bail;
    }

    //
    // Validate hints argument.
    //
    if ( Hints != NULL )
    {
        //
        // All members other than ai_flags, ai_family, ai_socktype
        // and ai_protocol must be zero or a null pointer.
        //
        if ( (Hints->ai_addrlen != 0) ||
             (Hints->ai_canonname != NULL) ||
             (Hints->ai_addr != NULL) ||
             (Hints->ai_next != NULL))
        {
            // REVIEW: Not clear what error to return here.

            Error = EAI_FAIL;
            goto Bail;
        }

        //
        // The spec has the "bad flags" error code, so presumably we should
        // check something here.  Insisting that there aren't any unspecified
        // flags set would break forward compatibility, however.  So we just
        // check for non-sensical combinations.
        //
        Flags = Hints->ai_flags;
        if ((Flags & AI_CANONNAME) && !NodeName) {
            //
            // We can't come up with a canonical name given a null nodename.
            //
            Error = EAI_BADFLAGS;
            goto Bail;
        }

        //
        // We only support a limited number of protocol families.
        //
        ProtocolFamily = (u_short)Hints->ai_family;

        if ( (ProtocolFamily != PF_UNSPEC)  &&
             (ProtocolFamily != PF_INET6)   &&
             (ProtocolFamily != PF_INET) )
        {
            Error = EAI_FAMILY;
            goto Bail;
        }

        //
        // We only support a limited number of socket types.
        //
        SocketType = Hints->ai_socktype;

        if ( (SocketType != 0) &&
             (SocketType != SOCK_STREAM) &&
             (SocketType != SOCK_DGRAM) )
        {
            Error = EAI_SOCKTYPE;
            goto Bail;
        }

        //
        // REVIEW: What if ai_socktype and ai_protocol are at odds?
        // REVIEW: Should we enforce the mapping triples here?
        //
        ProtocolId = Hints->ai_protocol;
    }

    //
    // Lookup service first (if we're given one) as we'll need the
    // corresponding port number for all the address structures we return.
    //

    if ( ServiceName != NULL )
    {
        char *EndPtr;

        //
        // The ServiceName string can be either a service name
        // or a decimal port number.  Check for the latter first.
        //
        ServicePort = htons((u_short)strtoul(ServiceName, &EndPtr, 10));

        if (*EndPtr != '\0')
        {
            struct servent *ServiceEntry;

            //
            // We have to look up the service name.  Since it may be
            // socktype/protocol specific, we have to do multiple lookups
            // unless our caller limits us to one.
            //
            // Spec doesn't say whether we should use the Hints' ai_protocol
            // or ai_socktype when doing this lookup.  But the latter is more
            // commonly used in practice, and is what the spec implies anyhow.
            //

            if (SocketType != SOCK_DGRAM) {
                //
                // See if this service exists for TCP.
                //
                ServiceEntry = getservbyname(ServiceName, "tcp");
                if (ServiceEntry == NULL) {
                    Error = WSAGetLastError();
                    if (Error == WSANO_DATA) {
                        //
                        // Unknown service for this protocol.
                        // Bail if we're restricted to TCP.
                        //
                        if (SocketType == SOCK_STREAM)
                        {
                            Error = EAI_SERVICE;  // REVIEW: or EAI_NONAME?
                            goto Bail;
                        }

                        // Otherwise we'll try UDP below...

                    } else {
                        // Some other failure.
                        Error = EAI_FAIL;
                        goto Bail;
                    }
                } else {
                    //
                    // Service is known for TCP.
                    //
                    ServicePort = ServiceEntry->s_port;
                }
            }

            if (SocketType != SOCK_STREAM) {
                //
                // See if this service exists for UDP.
                //
                ServiceEntry = getservbyname(ServiceName, "udp");
                if (ServiceEntry == NULL) {
                    Error = WSAGetLastError();
                    if (Error == WSANO_DATA) {
                        //
                        // Unknown service for this protocol.
                        // Bail if we're restricted to UDP or if
                        // the TCP lookup also failed.
                        //
                        if (SocketType == SOCK_DGRAM)
                            return EAI_SERVICE;  // REVIEW: or EAI_NONAME?
                        if (ServicePort == 0)
                            return EAI_NONAME;  // Both lookups failed.
                        SocketType = SOCK_STREAM;
                    } else {
                        // Some other failure.
                        Error = EAI_FAIL;
                        goto Bail;
                    }
                } else {
                    //
                    // Service is known for UDP.
                    //
                    if (ServicePort == 0) {
                        //
                        // If we made a TCP lookup, it failed.
                        // Limit ourselves to UDP.
                        //
                        SocketType = SOCK_DGRAM;
                        ServicePort = ServiceEntry->s_port;
                    } else {
                        if (ServicePort != ServiceEntry->s_port) {
                            //
                            // Port number is different for TCP and UDP,
                            // and our caller will accept either socket type.
                            // Arbitrarily limit ourselves to TCP.
                            //
                            SocketType = SOCK_STREAM;
                        }
                    }
                }
            }
        }
    }

    //
    // If we weren't given a node name, return the service info with
    // the loopback or wildcard address (which one depends upon the
    // AI_PASSIVE flag).  Note that if our caller didn't specify an
    // protocol family, we'll return both a V6 and a V4 address.
    //

    if ( NodeName == NULL )
    {
        //
        // What address to return depends upon the protocol family and
        // whether or not the AI_PASSIVE flag is set.
        //
        if ( (ProtocolFamily == PF_UNSPEC) || (ProtocolFamily == PF_INET6) )
        {
            //
            // Return an IPv6 address.
            //
            CurrentInfo = NewAddrInfo(
                                PF_INET6,
                                SocketType,
                                ProtocolId,
                                &Next );
            if ( CurrentInfo == NULL )
            {
                Error = EAI_MEMORY;
                goto Bail;
            }
            sin6 = (struct sockaddr_in6 *)CurrentInfo->ai_addr;
            sin6->sin6_family = AF_INET6;
            sin6->sin6_port = ServicePort;
            sin6->sin6_flowinfo = 0;
            sin6->sin6_scope_id = 0;
            if (Flags & AI_PASSIVE) {
                //
                // Assume user wants to accept on any address.
                //
                sin6->sin6_addr = in6addr_any;
            } else {
                //
                // Only address we can return is loopback.
                //
                sin6->sin6_addr = in6addr_loopback;
            }
        }

        if ((ProtocolFamily == PF_UNSPEC) || (ProtocolFamily == PF_INET)) {

            //
            // Return an IPv4 address.
            //
            CurrentInfo = NewAddrInfo(
                                PF_INET,
                                SocketType,
                                ProtocolId,
                                &Next );
            if (CurrentInfo == NULL)
            {
                Error = EAI_MEMORY;
                goto Bail;
            }
            sin = (struct sockaddr_in *)CurrentInfo->ai_addr;
            sin->sin_family = AF_INET;
            sin->sin_port = ServicePort;
            if (Flags & AI_PASSIVE) {
                //
                // Assume user wants to accept on any address.
                //
                sin->sin_addr.s_addr = htonl(INADDR_ANY);
            } else {
                //
                // Only address we can return is loopback.
                //
                sin->sin_addr.s_addr = htonl(INADDR_LOOPBACK);
            }
            memset(sin->sin_zero, 0, sizeof(sin->sin_zero) );
        }

        return 0;  // Success!
    }

    //
    //  have a node name (either alpha or numeric) to look up
    //

    //
    //  first check if name is numeric address (v4 or v6)
    //
    //  note:  shouldn't have to set the sa_family field prior to calling
    //         WSAStringToAddress, but it appears we do.
    //
    //  check if IPv6 address first
    //
    //
    //  DCR:  WSAStringToAddress() may not work if IP6 stack not installed
    //      can directly call my dnslib.lib routines
    //

    if ( (ProtocolFamily == PF_UNSPEC) ||
         (ProtocolFamily == PF_INET6))
    {
        struct sockaddr_in6 TempSockAddr;
        int AddressLength;

        TempSockAddr.sin6_family = AF_INET6;
        AddressLength = sizeof( TempSockAddr );

        if ( WSAStringToAddress(
                    (char *)NodeName,
                    AF_INET6,
                    NULL,
                    (struct sockaddr *)&TempSockAddr,
                    &AddressLength) != SOCKET_ERROR )
        {
            //
            // Conversion from IPv6 numeric string to binary address
            // was sucessfull.  Create an addrinfo structure to hold it,
            // and return it to the user.
            //
            CurrentInfo = NewAddrInfo(
                                PF_INET6,
                                SocketType,
                                ProtocolId,
                                &Next );
            if ( CurrentInfo == NULL )
            {
                Error = EAI_MEMORY;
                goto Bail;
            }
            memcpy(CurrentInfo->ai_addr, &TempSockAddr, AddressLength);
            sin6 = (struct sockaddr_in6 *)CurrentInfo->ai_addr;
            sin6->sin6_port = ServicePort;

            //
            // Implementation specific behavior: set AI_NUMERICHOST
            // to indicate that we got a numeric host address string.
            //
            CurrentInfo->ai_flags |= AI_NUMERICHOST;

            if (Flags & AI_CANONNAME) {
                goto CanonicalizeAddress;
            }
        
            return 0;  // Success!
        }
    }

    //
    //  check if IPv4 address
    //

    if ( (ProtocolFamily == PF_UNSPEC) ||
         (ProtocolFamily == PF_INET) )
    {
        struct in_addr TempAddr;

        if ( ParseV4Address(NodeName, &TempAddr) )
        {
            //
            // Conversion from IPv4 numeric string to binary address
            // was sucessfull.  Create an addrinfo structure to hold it,
            // and return it to the user.
            //
            CurrentInfo = NewAddrInfo(
                                PF_INET,
                                SocketType,
                                ProtocolId,
                                &Next );
            if (CurrentInfo == NULL)
            {
                Error = EAI_MEMORY;
                goto Bail;
            }
            sin = (struct sockaddr_in *)CurrentInfo->ai_addr;
            sin->sin_family = AF_INET;
            sin->sin_addr = TempAddr;
            sin->sin_port = ServicePort;
            memset( sin->sin_zero, 0, sizeof(sin->sin_zero) );

            //
            // Implementation specific behavior: set AI_NUMERICHOST
            // to indicate that we got a numeric host address string.
            //
            CurrentInfo->ai_flags |= AI_NUMERICHOST;

            if (Flags & AI_CANONNAME) {
                goto CanonicalizeAddress;
            }
            
            return 0;  // Success!
        }
    }

    //
    //  not a numeric address
    //      - bail if only wanted numeric conversion
    //

    if ( Flags & AI_NUMERICHOST )
    {
        Error = EAI_NONAME;
        goto Bail;
    }

    //
    //  do name lookup
    //

    Error = LookupNode(
                    NodeName,
                    ProtocolFamily,
                    SocketType,
                    ProtocolId,
                    ServicePort,
                    Flags,
                    &Next );
    if ( Error != NO_ERROR )
    {
        goto Bail;
    }
    return 0;


CanonicalizeAddress:

    Error = getnameinfo((*Result)->ai_addr,
                        (*Result)->ai_addrlen,
                        AddressString,
                        INET6_ADDRSTRLEN,   // max of v4 & v6 address lengths
                        NULL,
                        0,
                        NI_NUMERICHOST);    // return numeric form of address 
    if (!Error) {
        (*Result)->ai_canonname = new char[strlen(AddressString)+1];
        if ((*Result)->ai_canonname) {
            strcpy ((*Result)->ai_canonname, AddressString);
            return 0;
        }

        Error = EAI_MEMORY;
    }
    //
    // Fall through and bail...
    //
    
Bail:
    if (*Result != NULL) {
        freeaddrinfo(*Result);
        *Result = NULL;
    }

    //
    //  DCR:  need a spec on error handling for getaddrinfo
    //      - winsock like?
    //      - or actually returning error code?

    WSASetLastError( Error );
    return Error;
}


INT
WSAAPI
getnameinfo(
    IN      const struct sockaddr * SocketAddress,
    IN      socklen_t               SocketAddressLength,
    OUT     PCHAR                   NodeName,
    IN      DWORD                   NodeBufferSize,
    OUT     PCHAR                   ServiceName,
    IN      DWORD                   ServiceBufferSize,
    IN      INT                     Flags
    )
/*++

Routine Description:

    Protocol independent address-to-name translation routine.

    Spec'd in RFC 2553, section 6.5.

//  REVIEW: Spec doesn't say what error code space to use.

Arguments:

    SocketAddress       - socket address to translate
    SocketAddressLength - length of socket address
    NodeName            - ptr to buffer to recv node name
    NodeBufferSize      - size of NodeName buffer
    ServiceName         - ptr to buffer to recv the service name.
    ServiceBufferSize   - size of ServiceName buffer
    Flags               - flags of type NI_*.

Return Value:

    ERROR_SUCCESS if successful.
    Winsock error code on failure.

--*/
{
    PCHAR   p;
    PCHAR   q;
    INT     Space;
    INT     Error;

    Error = TURBO_PROLOG();
    if (Error!=NO_ERROR) {
        return Error;
    }

    //
    //  Sanity check SocketAddress and SocketAddressLength.
    //

    if ((SocketAddress == NULL) ||
        (SocketAddressLength < sizeof(*SocketAddress)) )
        return WSAEFAULT;

    switch (SocketAddress->sa_family) {
    case AF_INET:
        if (SocketAddressLength != sizeof(SOCKADDR_IN))
            return WSAEFAULT;
        break;
    case AF_INET6:
        if (SocketAddressLength != sizeof(SOCKADDR_IN6))
            return WSAEFAULT;
        break;
    default:
        return WSAEAFNOSUPPORT;
    }

    //
    // Translate the address to a node name (if requested).
    //
    //  DCR:  backward jumping goto -- shoot the developer
    //     simple replacement
    //      - not specifically numeric -- do lookup
    //      - success => out
    //      - otherwise do numeric lookup
    //
    //  DCR:  use DNS string\address conversion that doesn't require stack to be up
    //      
    //

    if (NodeName != NULL) {
        void *Address;
        int AddressLength;

        switch (SocketAddress->sa_family) {
        case AF_INET:
            //
            // Caller gave us an IPv4 address.
            //
            Address = &((struct sockaddr_in *)SocketAddress)->sin_addr;
            AddressLength = sizeof(struct in_addr);
            break;

        case AF_INET6:
            //
            // Caller gave us an IPv6 address.
            //
            Address = &((struct sockaddr_in6 *)SocketAddress)->sin6_addr;
            AddressLength = sizeof(struct in6_addr);
            break;
        }

        if (Flags & NI_NUMERICHOST) {
            //
            // Return numeric form of the address.
            // 
            struct sockaddr_storage TempSockAddr;  // Guaranteed big enough.

          ReturnNumeric:
            //
            // We need to copy our SocketAddress so we can zero the
            // port field before calling WSAAdressToString.
            //
            memcpy(&TempSockAddr, SocketAddress, SocketAddressLength);
            if (SocketAddress->sa_family == AF_INET) {
                ((struct sockaddr_in *)&TempSockAddr)->sin_port = 0;
            } else {
                ((struct sockaddr_in6 *)&TempSockAddr)->sin6_port = 0;
            }

            if ( WSAAddressToString(
                        (struct sockaddr *)&TempSockAddr,
                        SocketAddressLength,
                        NULL,
                        NodeName,
                        &NodeBufferSize) == SOCKET_ERROR )
            {
                return WSAGetLastError();
            }

        } else {
            //
            // Return node name corresponding to address.
            //
            struct hostent *HostEntry;

            HostEntry = getipnodebyaddr(
                            Address,
                            AddressLength,
                            SocketAddress->sa_family,
                            &Error );

            if (HostEntry == NULL) {
                //
                // DNS lookup failed.
                //
                if (Flags & NI_NAMEREQD)
                    return Error;
                else
                    goto ReturnNumeric;
            }

            //
            // Lookup successful.  Put result in 'NodeName'.
            // Stop copying at a "." if NI_NOFQDN is specified.
            //
            Space = NodeBufferSize;
            for (p = NodeName, q = HostEntry->h_name; *q != '\0' ; ) {
                if (Space-- == 0) {
                    freehostent(HostEntry);
                    return WSAEFAULT;
                }
                if ((*q == '.') && (Flags & NI_NOFQDN))
                    break;
                *p++ = *q++;
            }
            if (Space == 0) {
                freehostent(HostEntry);
                return WSAEFAULT;
            }
            *p = '\0';
            freehostent(HostEntry);
        }
    }

    //
    // Translate the port number to a service name (if requested).
    //

    if ( ServiceName != NULL )
    {
        u_short Port;

        switch (SocketAddress->sa_family)
        {
        case AF_INET:
            //
            // Caller gave us an IPv4 address.
            //
            Port = ((struct sockaddr_in *)SocketAddress)->sin_port;
            break;

        case AF_INET6:
            //
            // Caller gave us an IPv6 address.
            //
            Port = ((struct sockaddr_in6 *)SocketAddress)->sin6_port;
            break;
        }

        if ( Flags & NI_NUMERICSERV )
        {
            //
            // Return numeric form of the port number.
            //
            //  DCR:  use sprintf()?
            //

            char Temp[6];
            
            (void)sprintf(Temp, "%u", ntohs(Port));
            Space = ServiceBufferSize - 1;

            for (p = ServiceName, q = Temp; *q != '\0' ; )
            {
                if (Space-- == 0)
                {
                    return WSAEFAULT;
                }
                *p++ = *q++;
            }
            *p = '\0';

        } else {
            //
            // Return service name corresponding to the port number.
            //
            PSERVENT ServiceEntry;

            ServiceEntry = getservbyport(
                                Port,
                                (Flags & NI_DGRAM) ? "udp" : "tcp" );

            if (ServiceEntry == NULL)
                return WSAGetLastError();

            Space = ServiceBufferSize;
            for (p = ServiceName, q = ServiceEntry->s_name; *q != '\0' ; ) {
                if (Space-- == 0)
                    return WSAEFAULT;
                *p++ = *q++;
            }
            if (Space == 0)
                return WSAEFAULT;
            *p = '\0';
        }
    }

    return 0;
}

//
//  DCR:  should have simple counted sockaddr array routines
//          like my IP_ARRAY routines
//
//  DCR:  duplicate code SaveV4 and SaveV6 do exactly the
//          same thing;
//          private function takes
//              - family, sockaddr size, addr size (if diff)
//              and does alloc and copy
//
//  DCR:  realloc, realloc, realloc?
//          how about we simply take a count and size and
//          consume the whole CSADDR blob
//          

STATIC
int
SaveV4Address(
    IN      struct in_addr *    NewAddr,
    IN      u_short             ServicePort,
    IN OUT  SOCKADDR_IN **      pAddrs,
    OUT     u_int *             pNumSlots,
    OUT     u_int *             pNumAddrs
    )
{
    SOCKADDR_IN *addr;

    //
    //  grow sockaddr array if full
    //

    if (*pNumSlots == *pNumAddrs)
    {
        SOCKADDR_IN *NewAddrs;
        u_int NewSlots;

        if (*pAddrs == NULL) {
            NewSlots = 1;
            NewAddrs = (SOCKADDR_IN *)new BYTE[sizeof(**pAddrs)];
        }
        else {
            NewSlots = 2 * *pNumSlots;
            NewAddrs = (SOCKADDR_IN *)renew(*pAddrs, 
                                            NewSlots * sizeof(**pAddrs));
        }
        if (NewAddrs == NULL)
            return FALSE;
        *pAddrs = NewAddrs;
        *pNumSlots = NewSlots;
    }

    //  fill in IP4 sockaddr

    addr = &(*pAddrs)[(*pNumAddrs)++];
    memset(
        addr,
        0,
        sizeof(SOCKADDR_IN) );

    addr->sin_family = AF_INET;
    addr->sin_port = ServicePort;

    memcpy(
        &addr->sin_addr,
        NewAddr,
        sizeof(struct in_addr) );

    return TRUE;
}

//* SaveV6Address
//
//  Save an address into our array of addresses,
//  possibly growing the array.
//
//  Returns FALSE on failure. (Couldn't grow array.)
//

int
SaveV6Address(
    IN      struct in6_addr *   NewAddr,
    IN      u_short             ServicePort,
    OUT     SOCKADDR_IN6 **     pAddrs,
    IN OUT  u_int *             pNumSlots,
    IN      u_int *             pNumAddrs
    )
{
    SOCKADDR_IN6 *addr6;

    //
    //  add another sockaddr to array if not enough space
    //

    if ( *pNumSlots == *pNumAddrs )
    {
        SOCKADDR_IN6 *NewAddrs;
        u_int NewSlots;

        if (*pAddrs == NULL) {
            NewSlots = 1;
            NewAddrs = (SOCKADDR_IN6 *) new BYTE[sizeof(SOCKADDR_IN6)];
        }
        else {
            NewSlots = 2 * *pNumSlots;
            NewAddrs = (SOCKADDR_IN6 *) renew(
                                            *pAddrs,
                                            NewSlots * sizeof(SOCKADDR_IN6) );
        }
        if (NewAddrs == NULL)
            return FALSE;
        *pAddrs = NewAddrs;
        *pNumSlots = NewSlots;
    }

    //  fill in IP6 sockaddr

    addr6 = &(*pAddrs)[(*pNumAddrs)++];
    memset(
        addr6,
        0,
        sizeof(*addr6) );

    addr6->sin6_family = AF_INET6;
    addr6->sin6_port = ServicePort;

    memcpy(
        &addr6->sin6_addr,
        NewAddr,
        sizeof(*NewAddr) );

    return TRUE;
}


//* DomainNameLength
//
//  Determine the length of a domain name (a sequence of labels)
//  in a DNS message. Zero return means error.
//  On success, the length includes one for a null terminator.
//

u_int
DomainNameLength(
    u_char *start,
    u_int total,
    u_char *data,
    u_int size
    )
{
    u_int NameLength = 0;

    for (;;) {
        u_char length;

        if (size < sizeof(length) )
            return 0;
        length = *data;

        if ((length & 0xc0) == 0xc0) {
            u_short pointer;
            //
            // This is a pointer to labels elsewhere.
            //
            if (size < sizeof(pointer) )
                return FALSE;
            pointer = ((length & 0x3f) << 8) | data[1];

            if (pointer > total)
                return 0;

            data = start + pointer;
            size = total - pointer;
            continue;
        }

        data += sizeof(length);
        size -= sizeof(length);

        //
        // Zero-length label terminates the name.
        //
        if (length == 0)
            break;

        if (size < length)
            return 0;

        NameLength += length + 1;
        data += length;
        size -= length;

        //
        // Prevent infinite loops with an upper-bound.
        // Note that each label adds at least one to the length.
        //
        if (NameLength > NI_MAXHOST)
            return 0;
    }

    return NameLength;
}


//* CopyDomainName
//
//  Copy a domain name (a sequence of labels) from a DNS message
//  to a null-terminated C string.
// 
//  The DNS message must be syntactically correct.
//

void
CopyDomainName(
    char *Name,
    u_char *start,
    u_char *data
    )
{
    for (;;) {
        u_char length = *data;

        if ((length & 0xc0) == 0xc0) {
            u_short pointer;
            //
            // This is a pointer to labels elsewhere.
            //
            pointer = ((length & 0x3f) << 8) | data[1];
            data = start + pointer;
            continue;
        }

        data += sizeof(length);

        if (length == 0) {
            //
            // Backup and overwrite the last '.' with a null.
            //
            Name[-1] = '\0';
            break;
        }

        memcpy( Name, data, length );
        Name[length] = '.';
        Name += length + 1;
        data += length;
    }
}


//* SaveDomainName
//
//  Copy a domain name (a sequence of labels) from a DNS message
//  to a null-terminated C string.
//
//  Return values are WSA error codes, 0 means success.
//

int
SaveDomainName(
    char **pName,
    u_char *start,
    u_int total,
    u_char *data,
    u_int size
    )
{
    u_int NameLength;
    char *Name;

    NameLength = DomainNameLength(start, total, data, size);
    if (NameLength == 0)
        return WSANO_RECOVERY;

    Name = *pName;
    if (Name == NULL)
        Name = (char *)new BYTE[NameLength];
    else
        Name = (char *)renew(Name, NameLength);
    if (Name == NULL)
        return WSA_NOT_ENOUGH_MEMORY;

    *pName = Name;
    CopyDomainName( Name, start, data );
    return 0;
}


//* ParseDNSReply
//
//  This is a bit complicated so it gets its own helper function.
//
//  Needed indicates the desired type: T_A, T_AAAA, T_CNAME, or T_PTR.
//  For T_A and T_AAAA, pAddrs, pNumSlots, and pNumAddrs are used.
//  For T_CNAME and T_PTR, pName is used (only last name found is returned).
//
//  Return values are WSA error codes, 0 means successful parse
//  but that does not mean anything was found.
//

STATIC
int
ParseDNSReply(
    u_short         Needed,
    u_char *        data,
    u_int           size,
    SOCKADDR_IN **  pV4Addrs,
    u_int *         pNumV4Slots,
    u_int *         pNumV4Addrs,
    SOCKADDR_IN6 ** pV6Addrs,
    u_int *         pNumV6Slots,
    u_int *         pNumV6Addrs,
    char **         pName,
    u_short         ServicePort
    )
{
    u_short id, codes, qdcount, ancount, nscount, arcount;
    u_char *start = data;
    u_int total = size;
    int err;

    //
    // The DNS message starts with six two-byte fields.
    //
    if (size < sizeof(u_short) * 6)
        return WSANO_RECOVERY;

    id = ntohs(((u_short * )data)[0]);
    codes = ntohs(((u_short * )data)[1]);
    qdcount = ntohs(((u_short * )data)[2]);
    ancount = ntohs(((u_short * )data)[3]);
    nscount = ntohs(((u_short * )data)[4]);
    arcount = ntohs(((u_short * )data)[5]);

    data += sizeof(u_short) * 6;
    size -= sizeof(u_short) * 6;

    //
    // Skip over the question records.
    // Each question record has a QNAME, a QTYPE, and a QCLASS.
    // The QNAME is a sequence of labels, where each label
    // has a length byte. It is terminated by a zero-length label.
    // The QTYPE and QCLASS are two bytes each.
    //
    while (qdcount > 0) {

        //
        // Skip over the QNAME labels.
        //
        for (;;) {
            u_char length;

            if ( size < sizeof(length) )
                return WSANO_RECOVERY;

            length = *data;
            if ( (length & 0xc0) == 0xc0 )
            {
                //
                // This is a pointer to labels elsewhere.
                //
                if (size < sizeof(u_short))
                    return WSANO_RECOVERY;
                data += sizeof(u_short);
                size -= sizeof(u_short);
                break;
            }

            data += sizeof(length);
            size -= sizeof(length);

            if (length == 0)
                break;

            if (size < length)
                return WSANO_RECOVERY;
            data += length;
            size -= length;
        }

        //
        // Skip over QTYPE and QCLASS.
        //
        if (size < sizeof(u_short) * 2)
            return WSANO_RECOVERY;
        data += sizeof(u_short) * 2;
        size -= sizeof(u_short) * 2;

        qdcount--;
    }

    //
    // Examine the answer records, looking for A/AAAA/CNAME records.
    // Each answer record has a name, followed by several values:
    // TYPE, CLASS, TTL, RDLENGTH, and then RDLENGTH bytes of data.
    // TYPE, CLASS, and RDLENGTH are two bytes; TTL is four bytes.
    //
    while (ancount > 0)
    {
        u_short type, recclass, rdlength;
        u_int ttl;

        //
        // Skip over the name.
        //
        for (;;) {
            u_char length;

            if (size < sizeof(length) )
                return WSANO_RECOVERY;

            length = *data;
            if ((length & 0xc0) == 0xc0) {
                //
                // This is a pointer to labels elsewhere.
                //
                if (size < sizeof(u_short))
                    return WSANO_RECOVERY;
                data += sizeof(u_short);
                size -= sizeof(u_short);
                break;
            }
            data += sizeof( length );
            size -= sizeof( length );

            if (length == 0)
                break;

            if (size < length)
                return WSANO_RECOVERY;
            data += length;
            size -= length;
        }

        if (size < sizeof(u_short) * 3 + sizeof(u_int))
            return WSANO_RECOVERY;
        type = ntohs(((u_short *)data)[0]);
        recclass = ntohs(((u_short * )data)[1]);
        ttl = ntohl(((u_int * )data)[1]);
        rdlength = ntohs(((u_short * )data)[4]);

        data += sizeof(u_short) * 3 + sizeof(u_int);
        size -= sizeof(u_short) * 3 + sizeof(u_int);

        if (size < rdlength)
            return WSANO_RECOVERY;

        //
        // Is this the answer record type that we want?
        //
        if ((type == Needed) && (recclass == C_IN)) {

            switch (type) {
            case T_A:
                if (rdlength != sizeof(struct in_addr))
                    return WSANO_RECOVERY;

                // We have found a valid A record

                if (! SaveV4Address((struct in_addr *)data, ServicePort,
                                    pV4Addrs, pNumV4Slots, pNumV4Addrs))
                    return WSA_NOT_ENOUGH_MEMORY;
                break;

            case T_AAAA:
                if (rdlength != sizeof(struct in6_addr))
                    return WSANO_RECOVERY;

                //
                // We have found a valid AAAA record.
                //
                if (! SaveV6Address((struct in6_addr *)data, ServicePort,
                                  pV6Addrs, pNumV6Slots, pNumV6Addrs))
                    return WSA_NOT_ENOUGH_MEMORY;
                break;

            case T_CNAME:
            case T_PTR:
                //
                // We have found a valid CNAME or PTR record.
                // Save the name.
                //
                err = SaveDomainName(pName, start, total, data, rdlength);
                if (err)
                    return err;
                break;
            }
        }

        data += rdlength;
        size -= rdlength;
        ancount--;
    }

    return 0;
}


//* QueryDNSforAAAA
//
//  Helper routine for getaddrinfo
//  that performs name resolution by querying the DNS
//  for AAAA records.
//

STATIC
int
QueryDNSforAAAA(
    IN      PCSTR           name,
    IN OUT  SOCKADDR_IN6 ** pAddrs,
    IN OUT  u_int *         pNumSlots,
    IN OUT  u_int *         pNumAddrs,
    IN OUT  char **         pAlias,
    IN      u_short         ServicePort
    )
{
    STATIC GUID     QuadAGuid = SVCID_DNS(T_AAAA);
    char            buffer[sizeof(WSAQUERYSETA) + 2048];
    u_long          bufSize;
    PWSAQUERYSETA   query = (PWSAQUERYSETA) buffer;
    HANDLE          handle = NULL;
    int             err;
    PBYTE           pallocBuffer = NULL;

    //
    // Build a Winsock T_AAAA DNS query.
    //

    memset( query, 0, sizeof(*query) );

    query->dwSize = sizeof(*query);
    query->lpszServiceInstanceName = (char *)name;
    query->dwNameSpace = NS_DNS;
    query->lpServiceClassId = &QuadAGuid;

    //
    // Initiate the DNS query, asking for both addresses and
    // a raw DNS reply. On NT5, we'll get back addresses.
    // On NT4, we'll only get a raw DNS reply. (The resolver
    // does not understand AAAA records.) This means that on
    // NT4 there is no caching. OTOH, NT5 has a bug
    // that causes WSALookupServiceNextA to return a NetBios
    // address instead of any IPv6 addresses when you lookup
    // an unqualified machine name on that machine. That is,
    // lookup of "foobar" on foobar does the wrong thing.
    // Finally, we also ask for the fully qualified name.
    //
    err = WSALookupServiceBeginA(
                query,
                //LUP_RETURN_ADDR | LUP_RETURN_BLOB | LUP_RETURN_NAME,
                LUP_RETURN_ADDR | LUP_RETURN_NAME,
                & handle
                );
    if (err)
    {
        err = WSAGetLastError();
        if ((err == 0) || (err == WSASERVICE_NOT_FOUND))
            err = WSAHOST_NOT_FOUND;
        return err;
    }

    //
    // Loop until we get all of the queryset back in answer to our query.
    //
    // REVIEW: It's not clear to me that this is implemented
    // REVIEW: right, shouldn't we be checking for a WSAEFAULT and
    // REVIEW: then either increase the queryset buffer size or
    // REVIEW: set LUP_FLUSHPREVIOUS to move on for the next call?
    // REVIEW: Right now we just bail in that case.
    //

    bufSize = sizeof( buffer );

    for (;;)
    {
        DWORD   bufSizeQuery = bufSize;

        err = WSALookupServiceNextA(
                    handle,
                    0,
                    & bufSizeQuery,
                    query );
        if ( err )
        {
            err = WSAGetLastError();
            if ( err == WSAEFAULT )
            {
                if ( !pallocBuffer )
                {
                    pallocBuffer = new BYTE[ bufSizeQuery ];
                    if ( pallocBuffer )
                    {
                        bufSize = bufSizeQuery;
                        query = (PWSAQUERYSETA) pallocBuffer;
                        continue;
                    }
                    err = WSA_NOT_ENOUGH_MEMORY;
                }
                //  else ASSERT on WSAEFAULT if alloc'd buf
                goto Cleanup;
            }
            break;
        }

        if ( query->dwNumberOfCsAddrs != 0 )
        {
            u_int i;

            //
            // We got back parsed addresses.
            //
            for (i = 0; i < query->dwNumberOfCsAddrs; i++)
            {
                CSADDR_INFO *CsAddr = &query->lpcsaBuffer[i];

                //
                // We check iSockaddrLength against 24 instead of
                // sizeof(sockaddr_in6). Some versions of the NT5 resolver
                // are built with a sockaddr_in6 that is smaller than
                // the one we use here, but sin6_addr is in the same place
                // so it is ok.
                //
                if ((CsAddr->iProtocol == AF_INET6) &&
                    (CsAddr->RemoteAddr.iSockaddrLength >= 24) &&
                    (CsAddr->RemoteAddr.lpSockaddr->sa_family == AF_INET6))
                {
                    PSOCKADDR_IN6 sin6 = (PSOCKADDR_IN6)
                                            CsAddr->RemoteAddr.lpSockaddr;

                    //
                    // Again, note that sin6 may be pointing to a
                    // structure which is actually not our sockaddr_in6!
                    //
                    if ( ! SaveV6Address(
                                &sin6->sin6_addr,
                                ServicePort,
                                pAddrs,
                                pNumSlots,
                                pNumAddrs ))
                    {
                        err = WSA_NOT_ENOUGH_MEMORY;
                        goto Cleanup;
                    }
                }
            }
        }
#if 0
        else if (query->lpBlob != NULL)
        {
            //
            // We got back a raw DNS reply message.
            // Parse first for T_AAAA and then for T_CNAME.
            // These functions only return errors
            // if the DNS reply is malformed.
            //
            if ((err = ParseDNSReply(
                            T_AAAA,
                            query->lpBlob->pBlobData,
                            query->lpBlob->cbSize,
                            NULL,
                            NULL,
                            NULL,
                            pAddrs,
                            pNumSlots,
                            pNumAddrs,
                            NULL,
                            ServicePort))
                    ||
                (err = ParseDNSReply(
                            T_CNAME,
                            query->lpBlob->pBlobData,
                            query->lpBlob->cbSize,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            pAlias,
                            ServicePort)))
            {
                (void) WSALookupServiceEnd(handle);
                return err;
            }
        }
        else {
            //
            // Otherwise there's something wrong with WSALookupServiceNextA.
            // But to be more robust, just keep going.
            //
        }
#endif

        //
        // Pick up the canonical name. Note that this will override
        // any alias from ParseDNSReply.
        //

        if ( query->lpszServiceInstanceName != NULL )
        {
            u_int   length;
            PCHAR   Alias;

            length = strlen(query->lpszServiceInstanceName) + 1;
            Alias = *pAlias;

            if (Alias == NULL)
                Alias = (char *)new BYTE[length];
            else
                Alias = (char *)renew(Alias, length + 1);

            if ( Alias == NULL )
            {
                err = WSA_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            memcpy( Alias, query->lpszServiceInstanceName, length );
            *pAlias = Alias;
        }
    }

    err = 0;

Cleanup:

    if ( handle )
    {
        WSALookupServiceEnd(handle);
    }
    if ( pallocBuffer )
    {
        delete pallocBuffer;
    }
    return err;
}

//
//* QueryDNSforA
//
//  Helper routine for getaddrinfo
//  that performs name resolution by querying the DNS
//  for A records.
//
STATIC int
QueryDNSforA(
    IN      const char *        name,
    OUT     SOCKADDR_IN **      pAddrs,
    OUT     u_int *             pNumSlots,
    OUT     u_int *             pNumAddrs,
    OUT     char **             pAlias,
    IN      u_short             ServicePort
    )
{
    PHOSTENT    hA;
    char **     addrs;
    u_int       length;
    char *      Alias;

    hA = gethostbyname( name );

    if ( hA != NULL )
    {
        if ((hA->h_addrtype == AF_INET) &&
            (hA->h_length == sizeof(struct in_addr))) {

            for (addrs = hA->h_addr_list; *addrs != NULL; addrs++) {
                if (! SaveV4Address((struct in_addr *)*addrs, ServicePort,
                                    pAddrs, pNumSlots, pNumAddrs))
                    return WSA_NOT_ENOUGH_MEMORY;
            }
        }

        //
        // Pick up the canonical name.
        //
        length = strlen(hA->h_name) + 1;
        Alias = *pAlias;
        if (Alias == NULL)
            Alias = (char *)new BYTE[length];
        else
            Alias = (char *)renew(Alias, length + 1);
        if (Alias == NULL)
            return WSA_NOT_ENOUGH_MEMORY;

        memcpy(Alias, hA->h_name, length);
        *pAlias = Alias;
    }

    return 0;
}


//* QueryDNS
//
//  Helper routine for getaddrinfo
//  that performs name resolution by querying the DNS.
//
//  This helper function always initializes
//  *pAddrs, *pNumAddrs, and *pAlias
//  and may return memory that must be freed,
//  even if it returns an error code.
//
//  Return values are WSA error codes, 0 means success.
//
//  The NT4 DNS name space resolver (rnr20.dll) does not
//  cache replies when you request a specific RR type.
//  This means that every call to getaddrinfo
//  results in DNS message traffic. There is no caching!
//  On NT5 there is caching because the resolver understands AAAA.
//

STATIC
int
QueryDNS(
    IN      const char *        name,
    IN      u_int               LookupType,
    OUT     SOCKADDR_IN  **     pV4Addrs,
    OUT     u_int *             pNumV4Addrs,
    OUT     SOCKADDR_IN6 **     pV6Addrs,
    OUT     u_int *             pNumV6Addrs,
    OUT     char **             pAlias,
    IN      u_short             ServicePort
    )
{
    u_int   AliasCount = 0;
    u_int   NumV4Slots;
    u_int   NumV6Slots;
    char *  Name = (char *)name;
    int     err;

    //
    //  Start with zero addresses.
    //

    *pV4Addrs = NULL;
    NumV4Slots = *pNumV4Addrs = 0;
    *pV6Addrs = NULL;
    NumV6Slots = *pNumV6Addrs = 0;
    *pAlias = NULL;

    //
    //  DCR:  separate code for A and AAAA isn't good
    //      just call function that takes GUID\type
    //      perhaps sockaddr or address size
    //      makes query and packs up results from CSADDR
    //

    for (;;) {

        //
        // Must have at least one of L_AAAA and L_A enabled.
        //
        // Unfortunately it seems that some DNS servers out there
        // do not react properly to T_ALL queries - they reply
        // with referrals instead of doing the recursion
        // to get A and AAAA answers. To work around this bug,
        // we query separately for A and AAAA.
        //

        if (LookupType & L_AAAA)
        {
            err = QueryDNSforAAAA(
                        Name,
                        pV6Addrs,
                        &NumV6Slots,
                        pNumV6Addrs,
                        pAlias,
                        ServicePort );
            if (err)
                break;
        }

        if (LookupType & L_A)
        {
            err = QueryDNSforA(
                        Name,
                        pV4Addrs,
                        &NumV4Slots,
                        pNumV4Addrs,
                        pAlias,
                        ServicePort );
            if (err)
                break;
        }

        //
        //  If we found addresses, then we are done.
        //

        if ((*pNumV4Addrs != 0) || (*pNumV6Addrs != 0))
        {
            err = 0;
            break;
        }

        //
        //  if no addresses but alias -- follow CNAME chain
        //

        if ( (*pAlias != NULL) && (strcmp(Name, *pAlias) != 0) )
        {
            char *alias;

            //
            // Stop infinite loops due to DNS misconfiguration.
            // There appears to be no particular recommended
            // limit in RFCs 1034 and 1035.
            //
            //  DCR:  use standard CNAME limit #define here
            //

            if (++AliasCount > 8) {
                err = WSANO_RECOVERY;
                break;
            }

            //
            // If there was a new CNAME, then look again.
            // We need to copy *pAlias because *pAlias
            // could be deleted during the next iteration.
            //
            alias = (char *)new BYTE[strlen(*pAlias) + 1];
            if (alias == NULL) {
                err = WSA_NOT_ENOUGH_MEMORY;
                break;
            }
            strcpy(alias, *pAlias);
            if (Name != name)
                delete Name;
            Name = alias;
        }
        else if (LookupType >> NUM_ADDRESS_FAMILIES) {
            //
            // Or we were looking for one type and are willing to take another.
            // Switch to secondary lookup type.
            //
            LookupType >>= NUM_ADDRESS_FAMILIES;  
        }
        else {
            //
            // This name does not resolve to any addresses.
            //
            err = WSAHOST_NOT_FOUND;
            break;
        }
    }

    if (Name != name)
        delete Name;
    return err;
}

//
//  End addrinfo.cpp
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\inc\warnoff.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    warnoff.h

Abstract:

    This header contains pragmas to turn off compiler warnings that
    may be safely ignored.

Author:

    Dirk Brandewie dirk@mink.intel.com  29-Jun-1995

Revision History:

--*/


/*#ifndef _WARNOFF_
  #define _WARNOFF_
  */
/* nonstandard extension 'single line comment' was used */
#pragma warning(disable: 4001)

// nonstandard extension used : nameless struct/union
#pragma warning(disable: 4201)

// nonstandard extension used : bit field types other than int
#pragma warning(disable: 4214)

// Note: Creating precompiled header
#pragma warning(disable: 4699)

// unreferenced inline function has been removed
#pragma warning(disable: 4514)

// unreferenced formal parameter
//#pragma warning(disable: 4100)

// 'type' differs in indirection to slightly different base
// types from 'other type'
#pragma warning(disable: 4057)

// named type definition in parentheses
#pragma warning(disable: 4115)

// nonstandard extension used : benign typedef redefinition
#pragma warning(disable: 4209)

/*
#endif // _WARNOFF_
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\inc\wsautil.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    util.h

Abstract:

    This module contains utility MACRO'S and definitions used for
    WINSOCK2 DLL

Author:

    Dirk Brandewie dirk@mink.intel.com  11-JUL-1995

Revision History:


--*/
#include "warnoff.h"
#include <windows.h>
#include "classfwd.h"


//
// The highest WinSock versions supported by this DLL.
//

#define WINSOCK_HIGH_API_VERSION MAKEWORD(2,2)
#define WINSOCK_HIGH_SPI_VERSION MAKEWORD(2,2)


//
// The maximum allowed length for a catalog name such as "Protocol_Catalog9"
// or "NameSpace_Catalog5". This makes ValidateCurrentCatalogName() a bit
// simpler.
//

#define MAX_CATALOG_NAME_LENGTH 32

//
// Special value that keeps serial number of the registry catalog
// and helps synchronize access to registry without "public"
// mutex object
//
#define SERIAL_NUMBER_NAME      "Serial_Access_Num"


//
// API prolog. Note that Prolog_v1 is always used for WinSock 1.1 apps,
// and Prolog_v2 is always used for WinSock 2.x apps.
//
// Code within this DLL should call the prolog through the PROLOG macro.
// This will make life a bit simpler if we decide to change it yet again
// in the future.
//

INT
WINAPI
Prolog_v1(
    OUT PDPROCESS FAR * Process,
    OUT PDTHREAD FAR * Thread
    );

INT
WINAPI
Prolog_v2(
    OUT PDPROCESS FAR * Process,
    OUT PDTHREAD FAR * Thread
    );

INT
WINAPI
Prolog_Detached(
    OUT PDPROCESS FAR * Process,
    OUT PDTHREAD FAR * Thread
    );

typedef
INT
(WINAPI * LPFN_PROLOG)(
    OUT PDPROCESS FAR * Process,
    OUT PDTHREAD FAR * Thread
    );


extern LPFN_PROLOG PrologPointer;
extern HANDLE gHeap;
extern HINSTANCE    gDllHandle;

#define PROLOG(p,t)   (PrologPointer)( (p), (t) )
//
// Optimized inline version for V2 apps to be used
// on sensitive performance paths.
//

INT
WINAPI
SlowPrologOvlp (
	OUT	PDTHREAD FAR *	Thread
	);

INT
WINAPI
SlowProlog (
	VOID
	);

#define TURBO_PROLOG()												\
    (((PrologPointer==Prolog_v2) &&                                 \
            (DPROCESS::GetCurrentDProcess()!=NULL))					\
		? ERROR_SUCCESS												\
		: SlowProlog())

#define TURBO_PROLOG_OVLP(t)										\
    (((PrologPointer==Prolog_v2) &&                                 \
            (DPROCESS::GetCurrentDProcess()!=NULL) &&               \
			((*(t)=DTHREAD::GetCurrentDThread())!=NULL))		    \
		? ERROR_SUCCESS												\
        : SlowPrologOvlp(t))



//
// NT WOW Support.
//

typedef
BOOL
(WINAPI * LPFN_POSTMESSAGE)(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    );

//
// Registry manipulation.
//

BOOL
WriteRegistryEntry(
    IN HKEY     EntryKey,
    IN LPCTSTR  EntryName,
    IN PVOID    Data,
    IN DWORD    TypeFlag
    );

BOOL
ReadRegistryEntry(
    IN  HKEY    EntryKey,
    IN  LPTSTR  EntryName,
    OUT PVOID   Data,
    IN  DWORD   MaxBytes,
    IN  DWORD   TypeFlag
    );

LONG
RegDeleteKeyRecursive(
    IN HKEY  hkey,
    IN LPCTSTR  lpszSubKey
    );

LONG
RegDeleteSubkeys(
    IN HKEY  hkey
    );

HKEY
OpenWinSockRegistryRoot();

VOID
CloseWinSockRegistryRoot(
    HKEY  RootKey
    );

VOID
ValidateCurrentCatalogName(
    HKEY RootKey,
    LPSTR ValueName,
    LPSTR ExpectedName
    );

INT
AcquireExclusiveCatalogAccess (
	IN	HKEY	CatalogKey,
	IN	DWORD	ExpextedSerialNum,
    OUT PHKEY   AccessKey
    );

VOID
ReleaseExclusiveCatalogAccess (
	IN	HKEY	CatalogKey,
	IN  DWORD	CurrentSerialNum,
    IN  HKEY    access_key
    );

INT
SynchronizeSharedCatalogAccess (
	IN	HKEY	CatalogKey,
	IN	HANDLE	ChangeEvent,
	OUT	LPDWORD	CurrentSerialNum
	);

BOOL
HasCatalogChanged (
	IN	HANDLE	ChangeEvent
	);

//
// Ansi/Unicode conversions.
//

INT
MapUnicodeProtocolInfoToAnsi(
    IN  LPWSAPROTOCOL_INFOW UnicodeProtocolInfo,
    OUT LPWSAPROTOCOL_INFOA AnsiProtocolInfo
    );

INT
MapAnsiProtocolInfoToUnicode(
    IN  LPWSAPROTOCOL_INFOA AnsiProtocolInfo,
    OUT LPWSAPROTOCOL_INFOW UnicodeProtocolInfo
    );

BOOL
CompareMemory(
    LPBYTE  p1,
    LPBYTE  p2,
    DWORD   dwSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\addrconv.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    addrconv.c

Abstract:

    This module contains the address conversion routines from the
    winsock2 API. This module contains the following functions.

    htonl()
    htons()
    ntohl()
    ntohs()
    inet_addr()
    inet_ntoa()
    WSAHtonl()
    WSAHtons()
    WSANtohl()
    WSANtohs()


Author:

    Dirk Brandewie dirk@mink.intel.com  14-06-1995

[Environment:]

[Notes:]

Revision History:

    22-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Moved includes to precomp.h

--*/

#include "precomp.h"

// these defines are used to check if address parts are in range
#define MAX_EIGHT_BIT_VALUE       0xff
#define MAX_SIXTEEN_BIT_VALUE     0xffff
#define MAX_TWENTY_FOUR_BIT_VALUE 0xffffff

// Defines for different based numbers in an address
#define BASE_TEN     10
#define BASE_EIGHT   8
#define BASE_SIXTEEN 16

//
// Macros for swapping the bytes in a long and a short.
//

#define SWAP_LONG(l)                                \
            ( ( ((l) >> 24) & 0x000000FFL ) |       \
              ( ((l) >>  8) & 0x0000FF00L ) |       \
              ( ((l) <<  8) & 0x00FF0000L ) |       \
              ( ((l) << 24) & 0xFF000000L ) )

#define WS_SWAP_SHORT(s)                            \
            ( ( ((s) >> 8) & 0x00FF ) |             \
              ( ((s) << 8) & 0xFF00 ) )

//
// This preinitialized array defines the strings to be used for
// inet_ntoa.  The index of each row corresponds to the value for a byte
// in an IP address.  The first three bytes of each row are the
// char/string value for the byte, and the fourth byte in each row is
// the length of the string required for the byte.  This approach
// allows a fast implementation with no jumps.
//

BYTE NToACharStrings[][4] = {
    '0', 'x', 'x', 1,
    '1', 'x', 'x', 1,
    '2', 'x', 'x', 1,
    '3', 'x', 'x', 1,
    '4', 'x', 'x', 1,
    '5', 'x', 'x', 1,
    '6', 'x', 'x', 1,
    '7', 'x', 'x', 1,
    '8', 'x', 'x', 1,
    '9', 'x', 'x', 1,
    '1', '0', 'x', 2,
    '1', '1', 'x', 2,
    '1', '2', 'x', 2,
    '1', '3', 'x', 2,
    '1', '4', 'x', 2,
    '1', '5', 'x', 2,
    '1', '6', 'x', 2,
    '1', '7', 'x', 2,
    '1', '8', 'x', 2,
    '1', '9', 'x', 2,
    '2', '0', 'x', 2,
    '2', '1', 'x', 2,
    '2', '2', 'x', 2,
    '2', '3', 'x', 2,
    '2', '4', 'x', 2,
    '2', '5', 'x', 2,
    '2', '6', 'x', 2,
    '2', '7', 'x', 2,
    '2', '8', 'x', 2,
    '2', '9', 'x', 2,
    '3', '0', 'x', 2,
    '3', '1', 'x', 2,
    '3', '2', 'x', 2,
    '3', '3', 'x', 2,
    '3', '4', 'x', 2,
    '3', '5', 'x', 2,
    '3', '6', 'x', 2,
    '3', '7', 'x', 2,
    '3', '8', 'x', 2,
    '3', '9', 'x', 2,
    '4', '0', 'x', 2,
    '4', '1', 'x', 2,
    '4', '2', 'x', 2,
    '4', '3', 'x', 2,
    '4', '4', 'x', 2,
    '4', '5', 'x', 2,
    '4', '6', 'x', 2,
    '4', '7', 'x', 2,
    '4', '8', 'x', 2,
    '4', '9', 'x', 2,
    '5', '0', 'x', 2,
    '5', '1', 'x', 2,
    '5', '2', 'x', 2,
    '5', '3', 'x', 2,
    '5', '4', 'x', 2,
    '5', '5', 'x', 2,
    '5', '6', 'x', 2,
    '5', '7', 'x', 2,
    '5', '8', 'x', 2,
    '5', '9', 'x', 2,
    '6', '0', 'x', 2,
    '6', '1', 'x', 2,
    '6', '2', 'x', 2,
    '6', '3', 'x', 2,
    '6', '4', 'x', 2,
    '6', '5', 'x', 2,
    '6', '6', 'x', 2,
    '6', '7', 'x', 2,
    '6', '8', 'x', 2,
    '6', '9', 'x', 2,
    '7', '0', 'x', 2,
    '7', '1', 'x', 2,
    '7', '2', 'x', 2,
    '7', '3', 'x', 2,
    '7', '4', 'x', 2,
    '7', '5', 'x', 2,
    '7', '6', 'x', 2,
    '7', '7', 'x', 2,
    '7', '8', 'x', 2,
    '7', '9', 'x', 2,
    '8', '0', 'x', 2,
    '8', '1', 'x', 2,
    '8', '2', 'x', 2,
    '8', '3', 'x', 2,
    '8', '4', 'x', 2,
    '8', '5', 'x', 2,
    '8', '6', 'x', 2,
    '8', '7', 'x', 2,
    '8', '8', 'x', 2,
    '8', '9', 'x', 2,
    '9', '0', 'x', 2,
    '9', '1', 'x', 2,
    '9', '2', 'x', 2,
    '9', '3', 'x', 2,
    '9', '4', 'x', 2,
    '9', '5', 'x', 2,
    '9', '6', 'x', 2,
    '9', '7', 'x', 2,
    '9', '8', 'x', 2,
    '9', '9', 'x', 2,
    '1', '0', '0', 3,
    '1', '0', '1', 3,
    '1', '0', '2', 3,
    '1', '0', '3', 3,
    '1', '0', '4', 3,
    '1', '0', '5', 3,
    '1', '0', '6', 3,
    '1', '0', '7', 3,
    '1', '0', '8', 3,
    '1', '0', '9', 3,
    '1', '1', '0', 3,
    '1', '1', '1', 3,
    '1', '1', '2', 3,
    '1', '1', '3', 3,
    '1', '1', '4', 3,
    '1', '1', '5', 3,
    '1', '1', '6', 3,
    '1', '1', '7', 3,
    '1', '1', '8', 3,
    '1', '1', '9', 3,
    '1', '2', '0', 3,
    '1', '2', '1', 3,
    '1', '2', '2', 3,
    '1', '2', '3', 3,
    '1', '2', '4', 3,
    '1', '2', '5', 3,
    '1', '2', '6', 3,
    '1', '2', '7', 3,
    '1', '2', '8', 3,
    '1', '2', '9', 3,
    '1', '3', '0', 3,
    '1', '3', '1', 3,
    '1', '3', '2', 3,
    '1', '3', '3', 3,
    '1', '3', '4', 3,
    '1', '3', '5', 3,
    '1', '3', '6', 3,
    '1', '3', '7', 3,
    '1', '3', '8', 3,
    '1', '3', '9', 3,
    '1', '4', '0', 3,
    '1', '4', '1', 3,
    '1', '4', '2', 3,
    '1', '4', '3', 3,
    '1', '4', '4', 3,
    '1', '4', '5', 3,
    '1', '4', '6', 3,
    '1', '4', '7', 3,
    '1', '4', '8', 3,
    '1', '4', '9', 3,
    '1', '5', '0', 3,
    '1', '5', '1', 3,
    '1', '5', '2', 3,
    '1', '5', '3', 3,
    '1', '5', '4', 3,
    '1', '5', '5', 3,
    '1', '5', '6', 3,
    '1', '5', '7', 3,
    '1', '5', '8', 3,
    '1', '5', '9', 3,
    '1', '6', '0', 3,
    '1', '6', '1', 3,
    '1', '6', '2', 3,
    '1', '6', '3', 3,
    '1', '6', '4', 3,
    '1', '6', '5', 3,
    '1', '6', '6', 3,
    '1', '6', '7', 3,
    '1', '6', '8', 3,
    '1', '6', '9', 3,
    '1', '7', '0', 3,
    '1', '7', '1', 3,
    '1', '7', '2', 3,
    '1', '7', '3', 3,
    '1', '7', '4', 3,
    '1', '7', '5', 3,
    '1', '7', '6', 3,
    '1', '7', '7', 3,
    '1', '7', '8', 3,
    '1', '7', '9', 3,
    '1', '8', '0', 3,
    '1', '8', '1', 3,
    '1', '8', '2', 3,
    '1', '8', '3', 3,
    '1', '8', '4', 3,
    '1', '8', '5', 3,
    '1', '8', '6', 3,
    '1', '8', '7', 3,
    '1', '8', '8', 3,
    '1', '8', '9', 3,
    '1', '9', '0', 3,
    '1', '9', '1', 3,
    '1', '9', '2', 3,
    '1', '9', '3', 3,
    '1', '9', '4', 3,
    '1', '9', '5', 3,
    '1', '9', '6', 3,
    '1', '9', '7', 3,
    '1', '9', '8', 3,
    '1', '9', '9', 3,
    '2', '0', '0', 3,
    '2', '0', '1', 3,
    '2', '0', '2', 3,
    '2', '0', '3', 3,
    '2', '0', '4', 3,
    '2', '0', '5', 3,
    '2', '0', '6', 3,
    '2', '0', '7', 3,
    '2', '0', '8', 3,
    '2', '0', '9', 3,
    '2', '1', '0', 3,
    '2', '1', '1', 3,
    '2', '1', '2', 3,
    '2', '1', '3', 3,
    '2', '1', '4', 3,
    '2', '1', '5', 3,
    '2', '1', '6', 3,
    '2', '1', '7', 3,
    '2', '1', '8', 3,
    '2', '1', '9', 3,
    '2', '2', '0', 3,
    '2', '2', '1', 3,
    '2', '2', '2', 3,
    '2', '2', '3', 3,
    '2', '2', '4', 3,
    '2', '2', '5', 3,
    '2', '2', '6', 3,
    '2', '2', '7', 3,
    '2', '2', '8', 3,
    '2', '2', '9', 3,
    '2', '3', '0', 3,
    '2', '3', '1', 3,
    '2', '3', '2', 3,
    '2', '3', '3', 3,
    '2', '3', '4', 3,
    '2', '3', '5', 3,
    '2', '3', '6', 3,
    '2', '3', '7', 3,
    '2', '3', '8', 3,
    '2', '3', '9', 3,
    '2', '4', '0', 3,
    '2', '4', '1', 3,
    '2', '4', '2', 3,
    '2', '4', '3', 3,
    '2', '4', '4', 3,
    '2', '4', '5', 3,
    '2', '4', '6', 3,
    '2', '4', '7', 3,
    '2', '4', '8', 3,
    '2', '4', '9', 3,
    '2', '5', '0', 3,
    '2', '5', '1', 3,
    '2', '5', '2', 3,
    '2', '5', '3', 3,
    '2', '5', '4', 3,
    '2', '5', '5', 3
};



u_long WSAAPI
htonl (
    IN u_long hostlong
    )
/*++
Routine Description:

    Convert a u_long from host to TCP/IP network byte order.

Arguments:

    hostlong - A 32-bit number in host byte order.

Returns:
    htonl() returns the value in TCP/IP network byte order.
--*/
{

    return SWAP_LONG( hostlong );

}



u_short WSAAPI
htons (
    IN u_short hostshort
    )
/*++
Routine Description:

    Convert a u_short from host to TCP/IP network byte order.

Arguments:

    hostshort - A 16-bit number in host byte order.

Returns:
    htons() returns the value in TCP/IP network byte order.
--*/
{

    return WS_SWAP_SHORT( hostshort );

}




u_long WSAAPI
ntohl (
    IN u_long netlong
    )
/*++
Routine Description:

    Convert a u_long from TCP/IP network order to host byte order.

Arguments:

    netlong   A 32-bit number in TCP/IP network byte order.

Returns:
    ntohl() returns the value in host byte order.
--*/
{

    return SWAP_LONG( netlong );

}


u_short WSAAPI
ntohs (
    IN u_short netshort
    )
/*++
Routine Description:

    Convert a u_short from TCP/IP network byte order to host byte order.

Arguments:

    netshort  A 16-bit number in TCP/IP network byte order.

Returns:
    ntohs() returns the value in host byte order.
--*/
{

    return WS_SWAP_SHORT( netshort );

}



unsigned long WSAAPI
inet_addr (
           IN const char FAR * cp
           )
/*++
Routine Description:

    Convert a string containing an Internet Protocol dotted address into an
    in_addr.

Arguments:

    cp - A null terminated character string representing a number expressed in
         the Internet standard ".'' notation.

Returns:

    If no error occurs, inet_addr() returns an unsigned long containing a
    suitable binary representation of the Internet address given.  If the
    passed-in string does not contain a legitimate Internet address, for
    example if a portion of an "a.b.c.d" address exceeds 255, inet_addr()
    returns the value INADDR_NONE.

--*/
{
    IN_ADDR value;                // value to return to the user
    NTSTATUS status;

    __try {
        //
        // Special case: we need to make " " return 0.0.0.0 because MSDN
        // says it does.
        //
        if ((cp[0] == ' ') && (cp[1] == '\0')) {
            return (INADDR_ANY);
            }

        status = RtlIpv4StringToAddressA(cp, FALSE, &cp, &value);
        if (!NT_SUCCESS(status)) {
            return (INADDR_NONE);
        }

        //
        //  Check for trailing characters. A valid address can end with
        //  NULL or whitespace.  
        //
        //  N.B. To avoid bugs where the caller hasn't done setlocale()
        //  and passes us a DBCS string, we only allow ASCII whitespace.
        //
        if (*cp && !(isascii(*cp) && isspace(*cp))) {
            return (INADDR_NONE);
        }
    }
    __except (WS2_EXCEPTION_FILTER()) {
        SetLastError (WSAEFAULT);
        return (INADDR_NONE);
    }

    return (value.s_addr);
}


char FAR * WSAAPI
inet_ntoa (
    IN struct in_addr in
    )
/*++
Routine Description:

    Convert a network address into a string in dotted format.

Arguments:

        in - A structure which represents an Internet host address.

Returns:
    If no error occurs, inet_ntoa() returns a char pointer to a static buffer
    containing the text address in standard ".'' notation.  Otherwise, it
    returns NULL.  The data should be copied before another WinSock call is
    made.
--*/
{
    PDTHREAD  Thread;
    INT       ErrorCode;
    PCHAR     Buffer=NULL;
    BOOL      AddedArtificialStartup = FALSE;
    WSADATA   wsaData;
    PUCHAR p;
    PUCHAR b;

    ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if (ERROR_SUCCESS != ErrorCode) {

        if( ErrorCode != WSANOTINITIALISED ) {
            SetLastError(ErrorCode);
            return(NULL);
        }

        //
        // PROLOG failed with WSANOTINITIALIZED, meaning the app has not
        // yet called WSAStartup(). For historical (hysterical?) reasons,
        // inet_ntoa() must be functional before WSAStartup() is called.
        // So, we'll add an artificial WSAStartup() and press on.
        //

        ErrorCode = WSAStartup( WINSOCK_HIGH_API_VERSION, &wsaData );

        if( ErrorCode != NO_ERROR ) {
            SetLastError( ErrorCode );
            return NULL;
        }

        AddedArtificialStartup = TRUE;

        //
        // Retry the PROLOG.
        //

        ErrorCode = TURBO_PROLOG_OVLP(&Thread);
        if (ErrorCode!=ERROR_SUCCESS) {
            WSACleanup();
            SetLastError(ErrorCode);
            return NULL;
        }

    } //if

    Buffer = Thread->GetResultBuffer();
    b = (PUCHAR)Buffer;

    //
    // In an unrolled loop, calculate the string value for each of the four
    // bytes in an IP address.  Note that for values less than 100 we will
    // do one or two extra assignments, but we save a test/jump with this
    // algorithm.
    //

    p = (PUCHAR)&in;

    *b = NToACharStrings[*p][0];
    *(b+1) = NToACharStrings[*p][1];
    *(b+2) = NToACharStrings[*p][2];
    b += NToACharStrings[*p][3];
    *b++ = '.';

    p++;
    *b = NToACharStrings[*p][0];
    *(b+1) = NToACharStrings[*p][1];
    *(b+2) = NToACharStrings[*p][2];
    b += NToACharStrings[*p][3];
    *b++ = '.';

    p++;
    *b = NToACharStrings[*p][0];
    *(b+1) = NToACharStrings[*p][1];
    *(b+2) = NToACharStrings[*p][2];
    b += NToACharStrings[*p][3];
    *b++ = '.';

    p++;
    *b = NToACharStrings[*p][0];
    *(b+1) = NToACharStrings[*p][1];
    *(b+2) = NToACharStrings[*p][2];
    b += NToACharStrings[*p][3];
    *b = '\0';

    if( AddedArtificialStartup ) {
        WSACleanup();
    }

    return(Buffer);
}





int WSAAPI
WSAHtonl (
    IN SOCKET s,
    IN u_long hostlong,
    OUT u_long FAR * lpnetlong
    )
/*++
Routine Description:

    Convert a u_long from a specified host byte order to network byte
    order.

Arguments:

    s - A descriptor identifying a socket.

    hostlong - A 32-bit number in host byte order.

    lpnetlong - A pointer to a 32-bit number in network byte order.


Returns:
    If no error occurs, WSAHtonl() returns 0. Otherwise, a value of
    SOCKET_ERROR is returned.

--*/
{
    PDSOCKET            Socket;
    INT                 ErrorCode;
    PPROTO_CATALOG_ITEM CatalogEntry;
    LPWSAPROTOCOL_INFOW ProtocolInfo;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode==ERROR_SUCCESS) {

		if( lpnetlong == NULL ) {
			SetLastError( WSAEFAULT );
			return(SOCKET_ERROR);
		}

		Socket = DSOCKET::GetCountedDSocketFromSocket(s);
		if(Socket != NULL){
			CatalogEntry = Socket->GetCatalogItem();
			ProtocolInfo = CatalogEntry->GetProtocolInfo();

            __try {
			    if (LITTLEENDIAN == ProtocolInfo->iNetworkByteOrder) {
				    *lpnetlong = hostlong;
			    } //if
			    else {
				    *lpnetlong = SWAP_LONG( hostlong );
			    } //else
                ErrorCode = ERROR_SUCCESS;
            }
            __except (WS2_EXCEPTION_FILTER()) {
                ErrorCode = WSAEFAULT;
            }

			Socket->DropDSocketReference();
            if (ErrorCode==ERROR_SUCCESS)
                return ErrorCode;
		} //if
		else
			ErrorCode = WSAENOTSOCK;
	}


    SetLastError(ErrorCode);
    return (SOCKET_ERROR);
}




int WSAAPI
WSAHtons(
    IN SOCKET s,
    IN u_short hostshort,
    OUT u_short FAR * lpnetshort )
/*++
Routine Description:

    Convert a u_short from a specified host byte order to network byte
    order.

Arguments:

    s - A descriptor identifying a socket.

    netshort - A 16-bit number in network byte order.

    lphostshort - A pointer to a 16-bit number in host byte order.

Returns:
     If no error occurs, WSANtohs() returns 0. Otherwise, a value of
     SOCKET_ERROR is returned.

--*/
{
    PDSOCKET            Socket;
    INT                 ErrorCode;
    PPROTO_CATALOG_ITEM CatalogEntry;
    LPWSAPROTOCOL_INFOW ProtocolInfo;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode==ERROR_SUCCESS) {

		if( lpnetshort == NULL ) {
			SetLastError( WSAEFAULT );
			return(SOCKET_ERROR);
		}

		Socket = DSOCKET::GetCountedDSocketFromSocket(s);
		if(Socket != NULL){
			CatalogEntry = Socket->GetCatalogItem();
			ProtocolInfo = CatalogEntry->GetProtocolInfo();
            __try {
			    if (LITTLEENDIAN == ProtocolInfo->iNetworkByteOrder) {
				    *lpnetshort = hostshort;
			    } //if
			    else {
				    *lpnetshort = WS_SWAP_SHORT( hostshort );
			    } //else

			    ErrorCode = ERROR_SUCCESS;
            }
            __except (WS2_EXCEPTION_FILTER()) {
                ErrorCode = WSAEFAULT;
            }
			Socket->DropDSocketReference();
            if (ErrorCode==ERROR_SUCCESS)
                return ErrorCode;
		} //if
		else
			ErrorCode = WSAENOTSOCK;
	}

    SetLastError(ErrorCode);
    return (SOCKET_ERROR);
}




int WSAAPI
WSANtohl (
    IN SOCKET s,
    IN u_long netlong,
    OUT u_long FAR * lphostlong
    )
/*++
Routine Description:

    Convert a u_long from network byte order to host byte order.

Arguments:
    s - A descriptor identifying a socket.

    netlong - A 32-bit number in network byte order.

    lphostlong - A pointer to a 32-bit number in host byte order.

Returns:
     If no error occurs, WSANtohs() returns 0. Otherwise, a value of
     SOCKET_ERROR is returned.
--*/
{
    PDSOCKET            Socket;
    INT                 ErrorCode;
    PPROTO_CATALOG_ITEM CatalogEntry;
    LPWSAPROTOCOL_INFOW ProtocolInfo;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode==ERROR_SUCCESS) {

		if( lphostlong == NULL ) {
			SetLastError( WSAEFAULT );
			return(SOCKET_ERROR);
		}


		Socket = DSOCKET::GetCountedDSocketFromSocket(s);
		if(Socket != NULL){
			CatalogEntry = Socket->GetCatalogItem();
			ProtocolInfo = CatalogEntry->GetProtocolInfo();

            __try {
			    if (LITTLEENDIAN == ProtocolInfo->iNetworkByteOrder) {
				    *lphostlong = netlong;
			    } //if
			    else {
				    *lphostlong = SWAP_LONG( netlong );
			    } //else
			    ErrorCode = ERROR_SUCCESS;
            }
            __except (WS2_EXCEPTION_FILTER()) {
                ErrorCode = WSAEFAULT;
            }
			Socket->DropDSocketReference();
            if (ErrorCode==ERROR_SUCCESS)
                return ErrorCode;
		} //if
		else
			ErrorCode = WSAENOTSOCK;
	}

    SetLastError(ErrorCode);
    return (SOCKET_ERROR);
}


int WSAAPI
WSANtohs (
    IN SOCKET s,
    IN u_short netshort,
    OUT u_short FAR * lphostshort
    )
/*++
Routine Description:


Arguments:

Returns:
    Zero on success else SOCKET_ERROR. The error code is stored with
    SetErrorCode().
--*/
{
    PDSOCKET            Socket;
    INT                 ErrorCode;
    PPROTO_CATALOG_ITEM CatalogEntry;
    LPWSAPROTOCOL_INFOW ProtocolInfo;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode==ERROR_SUCCESS) {

		if( lphostshort == NULL ) {
			SetLastError( WSAEFAULT );
			return(SOCKET_ERROR);
		}


		Socket = DSOCKET::GetCountedDSocketFromSocket(s);
		if(Socket != NULL){
			CatalogEntry = Socket->GetCatalogItem();
			ProtocolInfo = CatalogEntry->GetProtocolInfo();

            __try {
			    if (LITTLEENDIAN == ProtocolInfo->iNetworkByteOrder) {
				    *lphostshort = netshort;
			    } //if
			    else {
				    *lphostshort = WS_SWAP_SHORT( netshort );
			    } //else
			    ErrorCode = ERROR_SUCCESS;
            }
            __except (WS2_EXCEPTION_FILTER()) {
                ErrorCode = WSAEFAULT;
            }
			Socket->DropDSocketReference();
            if (ErrorCode==ERROR_SUCCESS)
                return ErrorCode;
		} //if
		else
			ErrorCode = WSAENOTSOCK;
	}

    SetLastError(ErrorCode);
    return (SOCKET_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\async.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    Async.c

Abstract:

    This module contains code for the WinSock asynchronous processing
    thread.

Author:

    David Treadwell (davidtr)    25-May-1992

Revision History:

    Keith Moore (keithmo)        18-Jun-1996
        Moved it over to WS2_32.DLL.

--*/


#include "precomp.h"


//
// Private types
//

typedef struct _SOCK_ASYNC_THREAD_PARAMS
{
      LIST_ENTRY    SockAsyncQueueHead;

      HANDLE        SockAsyncQueueEvent;

      LIST_ENTRY    SocketList;

} SOCK_ASYNC_THREAD_PARAMS, *PSOCK_ASYNC_THREAD_PARAMS;

//
// Private globals.
//

BOOL SockAsyncThreadInitialized;
CRITICAL_SECTION SockAsyncLock;
HANDLE SockAsyncQueueEvent;
PLIST_ENTRY SockAsyncQueueHead;
HANDLE SockAsyncCurrentTaskHandle;
HANDLE SockAsyncCancelledTaskHandle;
HMODULE SockAsyncModuleHandle;
LONG SockAsyncTaskHandleCounter;

//
// Private prototypes.
//

DWORD
WINAPI
SockAsyncThread(
    IN PSOCK_ASYNC_THREAD_PARAMS pThreadParams
    );

BOOL
WINAPI
SockAsyncThreadBlockingHook(
    VOID
    );

VOID
SockProcessAsyncGetHost (
    IN HANDLE TaskHandle,
    IN DWORD OpCode,
    IN HWND hWnd,
    IN unsigned int wMsg,
    IN char FAR *Filter,
    IN int Length,
    IN int Type,
    IN char FAR *Buffer,
    IN int BufferLength
    );

VOID
SockProcessAsyncGetProto (
    IN HANDLE TaskHandle,
    IN DWORD OpCode,
    IN HWND hWnd,
    IN unsigned int wMsg,
    IN char FAR *Filter,
    IN char FAR *Buffer,
    IN int BufferLength
    );

VOID
SockProcessAsyncGetServ (
    IN HANDLE TaskHandle,
    IN DWORD OpCode,
    IN HWND hWnd,
    IN unsigned int wMsg,
    IN char FAR *Filter,
    IN char FAR *Protocol,
    IN char FAR *Buffer,
    IN int BufferLength
    );

DWORD
CopyHostentToBuffer(
    IN char FAR * Buffer,
    IN int BufferLength,
    IN PHOSTENT Hostent
    );

DWORD
CopyServentToBuffer(
    IN char FAR *Buffer,
    IN int BufferLength,
    IN PSERVENT Servent
    );

DWORD
CopyProtoentToBuffer(
    IN char FAR *Buffer,
    IN int BufferLength,
    IN PPROTOENT Protoent
    );

DWORD
BytesInHostent(
    PHOSTENT Hostent
    );

DWORD
BytesInServent(
    PSERVENT Servent
    );

DWORD
BytesInProtoent(
    IN PPROTOENT Protoent
    );

#define SockAcquireGlobalLock() EnterCriticalSection( &SockAsyncLock )
#define SockReleaseGlobalLock() LeaveCriticalSection( &SockAsyncLock )


//
// Public functions.
//


BOOL
SockAsyncGlobalInitialize(
    )
{
    
    assert (gDllHandle!=NULL);
    __try {
        InitializeCriticalSection( &SockAsyncLock );
        return TRUE;
    }
    __except (WS2_EXCEPTION_FILTER ()) {
        return FALSE;
    }
}   // SockAsyncGlobalInitialize

VOID
SockAsyncGlobalTerminate(
    VOID
    )
{

    DeleteCriticalSection( &SockAsyncLock );

}   // SockAsyncGlobalTerminate


BOOL
SockCheckAndInitAsyncThread(
    VOID
    )
{

    HANDLE threadHandle;
    DWORD threadId;
    BOOL  startup_done;
    PSOCK_ASYNC_THREAD_PARAMS pThreadParams;
    union {
        WSADATA WSAData;
        TCHAR   ModuleName[MAX_PATH];
    } u;


    //
    // If the async thread is already initialized, return.
    //

    if( SockAsyncThreadInitialized ) {
        return TRUE;
    }

    //
    // Acquire the global lock to synchronize the thread startup.
    //

    SockAcquireGlobalLock();


    //
    // Check again, in case another thread has already initialized
    // the async thread.
    //

    if( !SockAsyncThreadInitialized ) {

        SockAsyncModuleHandle = NULL;
        SockAsyncQueueEvent = NULL;
        pThreadParams = NULL;
        startup_done = FALSE;

        TRY_START (guard_lock) {
            //
            // Initialize globals for the async thread
            //

            pThreadParams = new SOCK_ASYNC_THREAD_PARAMS;
            if (pThreadParams==NULL) {
                DEBUGF (DBG_ERR,
                    ("Allocating async thread parameter block.\n"));
                TRY_THROW(guard_lock);
            }


            SockAsyncQueueHead = &pThreadParams->SockAsyncQueueHead;

            InitializeListHead( SockAsyncQueueHead );

            SockAsyncQueueEvent =
            pThreadParams->SockAsyncQueueEvent = CreateEvent(
                                      NULL,
                                      FALSE,
                                      FALSE,
                                      NULL
                                      );

            if( SockAsyncQueueEvent == NULL ) {
                DEBUGF (DBG_ERR,
                    ("Creating async queue event.\n"));
                TRY_THROW (guard_lock);
            }


            //
            // Add an artificial reference to WS2_32.DLL so that it doesn't
            // go away unexpectedly. We'll remove this reference when we shut
            // down the async thread.
            //

            if( (GetModuleFileName(
                            gDllHandle,
                            u.ModuleName,
                            sizeof (u.ModuleName)
                            )==0) ||
                ((SockAsyncModuleHandle = LoadLibrary(
                            u.ModuleName 
                            ))==NULL) ) {

                DEBUGF (DBG_ERR,
                    ("Referencing ws2_32.dll.\n"));
                TRY_THROW (guard_lock);
            }

            //
            // Add an artificial reference to the startup count so that we
            // won't clean up this dll while the SockAsyncThread is still
            // processing a request
            //

            if ( WSAStartup( 0x202, &u.WSAData ) != 0 ) {
                DEBUGF (DBG_ERR,
                    ("Starting up ws2_32.dll.\n"));
                TRY_THROW (guard_lock);
            }
            startup_done = TRUE;

            //
            // Create the async thread itself.
            //

            threadHandle = CreateThread(
                               NULL,
                               0,
                               (LPTHREAD_START_ROUTINE) SockAsyncThread,
                               pThreadParams,
                               0,
                               &threadId
                               );

            if( threadHandle == NULL ) {
                DEBUGF (DBG_ERR,
                    ("Creating async thread.\n"));
                TRY_THROW (guard_lock);
            }
            //
            // Close the thread handle, indicate a successful result,
            // and jump down to the right cleanup step
            //

            CloseHandle( threadHandle );

            SockAsyncThreadInitialized = TRUE;
        }
        TRY_CATCH (guard_lock) {
            if (startup_done)
                WSACleanup ();

            if (SockAsyncModuleHandle!=NULL) {
                FreeLibrary (SockAsyncModuleHandle);
                SockAsyncModuleHandle = NULL;
            }

            if (SockAsyncQueueEvent!=NULL) {
                CloseHandle( SockAsyncQueueEvent );
                SockAsyncQueueEvent = NULL;
            }
            if (pThreadParams!=NULL)
                delete pThreadParams;
        } TRY_END(guard_lock);

    }


    SockReleaseGlobalLock();

    return SockAsyncThreadInitialized;

} // SockCheckAndInitializeAsyncThread


VOID
SockTerminateAsyncThread(
    VOID
    )
{

    PWINSOCK_CONTEXT_BLOCK contextBlock;

    //
    // If the thread's not running, there's not much to do.
    //

    if( !SockAsyncThreadInitialized ) {

        return;

    }

    //
    // Get an async context block.
    //

    contextBlock = SockAllocateContextBlock( 0 );

    if( contextBlock == NULL ) {

        //
        // !!! Use brute force method!
        //

        return;

    }

    //
    // Initialize the context block for this operation.
    //

    contextBlock->OpCode = WS_OPCODE_TERMINATE;

    //
    // Queue the request to the async thread.  The async thread will
    // kill itself when it receives this request.
    //

    SockQueueRequestToAsyncThread( contextBlock );

    SockAsyncThreadInitialized = FALSE;

} // SockTerminateAsyncThread


PWINSOCK_CONTEXT_BLOCK
SockAllocateContextBlock(
    DWORD AdditionalSpace
    )
{

    PWINSOCK_CONTEXT_BLOCK contextBlock;

    //
    // Allocate memory for the context block plus any additional
    // space requested.
    //

    AdditionalSpace += sizeof(*contextBlock);

    contextBlock = (PWINSOCK_CONTEXT_BLOCK)new BYTE[AdditionalSpace];

    if( contextBlock == NULL ) {

        return NULL;

    }

    //
    // Get a task handle for this context block.
    //

    contextBlock->TaskHandle = LongToHandle (
                                    InterlockedIncrement(
                                        &SockAsyncTaskHandleCounter
                                        ));

    assert( contextBlock->TaskHandle != NULL );

    //
    // Return the task handle we allocated.
    //

    return contextBlock;

} // SockAllocateContextBlock


VOID
SockFreeContextBlock(
    IN PWINSOCK_CONTEXT_BLOCK ContextBlock
    )
{
    //
    // Just free the block to process heap.
    //

    delete ContextBlock;

} // SockFreeContextBlock


VOID
SockQueueRequestToAsyncThread(
    IN PWINSOCK_CONTEXT_BLOCK ContextBlock
    )
{
    BOOL result;

    //
    // Acquire the lock that protects the async queue list.
    //

    SockAcquireGlobalLock();

    //
    // Insert the context block at the end of the queue.
    //

    InsertTailList(
        SockAsyncQueueHead,
        &ContextBlock->AsyncThreadQueueListEntry
        );

    //
    // Set the queue event so that the async thread wakes up to service
    // this request.
    //

    result = SetEvent( SockAsyncQueueEvent );
    assert( result );

    //
    // Release the resource and return.
    //

    SockReleaseGlobalLock();
    return;

} // SockQueueRequestToAsyncThread

INT
SockCancelAsyncRequest(
    IN HANDLE TaskHandle
    )
{

    PLIST_ENTRY entry;
    PWINSOCK_CONTEXT_BLOCK contextBlock;

    //
    // If the async thread has not been initialized, then this must
    // be an invalid context handle.
    //

    if( !SockAsyncThreadInitialized ) {

        return WSAEINVAL;

    }

    //
    // Hold the lock that protects the async thread context block queue
    // while we do this.  This prevents the async thread from starting
    // new requests while we determine how to execute this cancel.
    //

    SockAcquireGlobalLock();

    //
    // If the specified task handle is currently being processed by the
    // async thread, just set this task handle as the cancelled async
    // thread task handle.  The async thread's blocking hook routine
    // will cancel the request, and the handler routine will not
    // post the message for completion of the request.
    //
    // *** Note that it is possible to complete this request with a
    //     WSAEINVAL while an async request completion message is
    //     about to be posted to the application.  Does this matter?
    //     There is no way an app can distinguish this case from
    //     where the post occurs just before the call to this routine.

    if( TaskHandle == SockAsyncCurrentTaskHandle ) {

        SockAsyncCancelledTaskHandle = TaskHandle;
        SockReleaseGlobalLock();

        return NO_ERROR;

    }

    //
    // Attempt to find the task handle in the queue of context blocks to
    // the async thread.
    //

    for( entry = SockAsyncQueueHead->Flink;
         entry != SockAsyncQueueHead;
         entry = entry->Flink ) {

        contextBlock = CONTAINING_RECORD(
                           entry,
                           WINSOCK_CONTEXT_BLOCK,
                           AsyncThreadQueueListEntry
                           );

        if( TaskHandle == contextBlock->TaskHandle ) {

            //
            // We found the correct task handle.  Remove it from the list.
            //

            RemoveEntryList( entry );

            //
            // Release the lock, free the context block, and return.
            //

            SockReleaseGlobalLock( );
            SockFreeContextBlock( contextBlock );

            return NO_ERROR;

        }

    }

    //
    // The task handle was not found on the list.  Either the request
    // was already completed or the task handle was just plain bogus.
    // In either case, fail the request.
    //

    SockReleaseGlobalLock();
    return WSAEINVAL;

}   // SockCancelAsyncRequest


DWORD
WINAPI
SockAsyncThread(
    IN PSOCK_ASYNC_THREAD_PARAMS    pThreadParams
    )
{

    PWINSOCK_CONTEXT_BLOCK contextBlock;
    PLIST_ENTRY listEntry;
    FARPROC previousHook;
    HANDLE sockAsyncQueueEvent = pThreadParams->SockAsyncQueueEvent;
    PLIST_ENTRY sockAsyncQueueHead = &pThreadParams->SockAsyncQueueHead;

    //
    // Set up our blocking hook routine.  We'll use it to handle
    // cancelling async requests.
    //

    previousHook = WSASetBlockingHook(
                       (FARPROC)SockAsyncThreadBlockingHook
                       );

    //
    // Loop forever dispatching actions.
    //

    while( TRUE ) {

        //
        // Wait for the async queue event to indicate that there is
        // something on the queue.
        //

        WaitForSingleObject(
            sockAsyncQueueEvent,
            INFINITE
            );

        //
        // Acquire the lock that protects the async queue.
        //

        SockAcquireGlobalLock();

        //
        // As long as there are items to process, process them.
        //

        while( !IsListEmpty( sockAsyncQueueHead ) ) {

            //
            // Remove the first item from the queue.
            //

            listEntry = RemoveHeadList( sockAsyncQueueHead );

            contextBlock = CONTAINING_RECORD(
                               listEntry,
                               WINSOCK_CONTEXT_BLOCK,
                               AsyncThreadQueueListEntry
                               );

            //
            // Remember the task handle that we're processing.  This
            // is necessary in order to support WSACancelAsyncRequest.
            //

            SockAsyncCurrentTaskHandle = contextBlock->TaskHandle;

            //
            // Release the list lock while we're processing the request.
            //

            SockReleaseGlobalLock();

            //
            // Act based on the opcode in the context block.
            //

            switch( contextBlock->OpCode ) {

            case WS_OPCODE_GET_HOST_BY_ADDR:
            case WS_OPCODE_GET_HOST_BY_NAME:

                SockProcessAsyncGetHost(
                    contextBlock->TaskHandle,
                    contextBlock->OpCode,
                    contextBlock->Overlay.AsyncGetHost.hWnd,
                    contextBlock->Overlay.AsyncGetHost.wMsg,
                    contextBlock->Overlay.AsyncGetHost.Filter,
                    contextBlock->Overlay.AsyncGetHost.Length,
                    contextBlock->Overlay.AsyncGetHost.Type,
                    contextBlock->Overlay.AsyncGetHost.Buffer,
                    contextBlock->Overlay.AsyncGetHost.BufferLength
                    );

                break;

            case WS_OPCODE_GET_PROTO_BY_NUMBER:
            case WS_OPCODE_GET_PROTO_BY_NAME:

                SockProcessAsyncGetProto(
                    contextBlock->TaskHandle,
                    contextBlock->OpCode,
                    contextBlock->Overlay.AsyncGetProto.hWnd,
                    contextBlock->Overlay.AsyncGetProto.wMsg,
                    contextBlock->Overlay.AsyncGetProto.Filter,
                    contextBlock->Overlay.AsyncGetProto.Buffer,
                    contextBlock->Overlay.AsyncGetProto.BufferLength
                    );

                break;

            case WS_OPCODE_GET_SERV_BY_PORT:
            case WS_OPCODE_GET_SERV_BY_NAME:

                SockProcessAsyncGetServ(
                    contextBlock->TaskHandle,
                    contextBlock->OpCode,
                    contextBlock->Overlay.AsyncGetServ.hWnd,
                    contextBlock->Overlay.AsyncGetServ.wMsg,
                    contextBlock->Overlay.AsyncGetServ.Filter,
                    contextBlock->Overlay.AsyncGetServ.Protocol,
                    contextBlock->Overlay.AsyncGetServ.Buffer,
                    contextBlock->Overlay.AsyncGetServ.BufferLength
                    );

                break;

            case WS_OPCODE_TERMINATE:

                //
                // Decrement our init ref count (can safely clean up now)
                //

                WSACleanup();

                //
                // Free the termination context block.
                //

                SockFreeContextBlock( contextBlock );

                //
                // Clear out the queue of async requests.
                //

                SockAcquireGlobalLock();

                while( !IsListEmpty( sockAsyncQueueHead ) ) {

                    listEntry = RemoveHeadList( sockAsyncQueueHead );

                    contextBlock = CONTAINING_RECORD(
                                       listEntry,
                                       WINSOCK_CONTEXT_BLOCK,
                                       AsyncThreadQueueListEntry
                                       );

                    SockFreeContextBlock( contextBlock );

                }

                SockReleaseGlobalLock();

                //
                // Clean up thread-specific resources
                //

                CloseHandle( sockAsyncQueueEvent );

                delete pThreadParams;

                //
                // Remove the artifical reference we added in
                // SockCheckAndInitAsyncThread() and exit this thread.
                //

                FreeLibraryAndExitThread(
                    SockAsyncModuleHandle,
                    0
                    );

                //
                // We should never get here, but just in case...
                //

                return 0;

            default:

                //
                // We got a bogus opcode.
                //

                assert( !"Bogus async opcode" );
                break;
            }

            //
            // Set the variable that holds the task handle that we're
            // currently processing to 0, since we're not actually
            // processing a task handle right now.
            //

            SockAsyncCurrentTaskHandle = NULL;

            //
            // Free the context block, reacquire the list lock, and
            // continue.
            //

            SockFreeContextBlock( contextBlock );
            SockAcquireGlobalLock();

        }

        //
        // Release the list lock and redo the wait.
        //

        SockReleaseGlobalLock();

    }

} // SockAsyncThread


BOOL
WINAPI
SockAsyncThreadBlockingHook(
    VOID
    )
{

    //
    // If the current async request is being cancelled, blow away
    // the current blocking call.
    //

    if( SockAsyncCurrentTaskHandle == SockAsyncCancelledTaskHandle ) {

        int error;

        error = WSACancelBlockingCall();
        assert( error == NO_ERROR );
    }

    return FALSE;

} // SockAsyncThreadBlockingHook


VOID
SockProcessAsyncGetHost(
    IN HANDLE TaskHandle,
    IN DWORD OpCode,
    IN HWND hWnd,
    IN unsigned int wMsg,
    IN char FAR *Filter,
    IN int Length,
    IN int Type,
    IN char FAR *Buffer,
    IN int BufferLength
    )
{

    PHOSTENT returnHost;
    DWORD requiredBufferLength = 0;
    LPARAM lParam;
    INT error;
    PWINSOCK_POST_ROUTINE   sockPostRoutine;

    assert( OpCode == WS_OPCODE_GET_HOST_BY_ADDR ||
            OpCode == WS_OPCODE_GET_HOST_BY_NAME );

    //
    // Get the necessary information.
    //

    if( OpCode == WS_OPCODE_GET_HOST_BY_ADDR ) {

        returnHost = gethostbyaddr(
                          Filter,
                          Length,
                          Type
                          );

    } else {

        returnHost = gethostbyname(
                          Filter
                          );

    }

    if( returnHost == NULL ) {

        error = WSAGetLastError();

    }

    //
    // Hold the lock that protects the async thread context block queue
    // while we do this.  This prevents a race between this thread and
    // any thread invoking WSACancelAsyncRequest().
    //

    SockAcquireGlobalLock();

    //
    // If this request was cancelled, just return.
    //

    if( TaskHandle == SockAsyncCancelledTaskHandle ) {

        SockReleaseGlobalLock();
        return;

    }

    //
    // Copy the hostent structure to the output buffer.
    //

    if( returnHost != NULL ) {

        requiredBufferLength = CopyHostentToBuffer(
                                   Buffer,
                                   BufferLength,
                                   returnHost
                                   );

        if( requiredBufferLength > (DWORD)BufferLength ) {

            error = WSAENOBUFS;

        } else {

            error = NO_ERROR;

        }

    }

    //
    // Set the current async thread task handle to 0 so that if a cancel
    // request comes in after this point it is failed properly.
    //

    SockAsyncCurrentTaskHandle = NULL;

    //
    // Release the global lock.
    //

    SockReleaseGlobalLock();

    //
    // Build lParam for the message we'll post to the application.
    // The high 16 bits are the error code, the low 16 bits are
    // the minimum buffer size required for the operation.
    //

    lParam = WSAMAKEASYNCREPLY( requiredBufferLength, error );

    //
    // Post a message to the application indication that the data it
    // requested is available.
    //

    assert( sizeof(TaskHandle) == sizeof(HANDLE) );

    sockPostRoutine = GET_SOCK_POST_ROUTINE ();

    //
    // !!! Need a mechanism to repost if the post failed!
    //

    if (!sockPostRoutine || !sockPostRoutine(
                 hWnd,
                 wMsg,
                 (WPARAM)TaskHandle,
                 lParam
                 )) {


        // Rem assert, since this might be an "orphaned" SockAsyncThread
        // in the process of tearing itself down
        //
        //assert( !"SockPostRoutine failed" );

    }

}   // SockProcessAsyncGetHost


VOID
SockProcessAsyncGetProto(
    IN HANDLE TaskHandle,
    IN DWORD OpCode,
    IN HWND hWnd,
    IN unsigned int wMsg,
    IN char FAR *Filter,
    IN char FAR *Buffer,
    IN int BufferLength
    )
{

    PPROTOENT returnProto;
    DWORD requiredBufferLength = 0;
    LPARAM lParam;
    INT error;
    PWINSOCK_POST_ROUTINE   sockPostRoutine;

    assert( OpCode == WS_OPCODE_GET_PROTO_BY_NAME ||
            OpCode == WS_OPCODE_GET_PROTO_BY_NUMBER );

    //
    // Get the necessary information.
    //

    if( OpCode == WS_OPCODE_GET_PROTO_BY_NAME ) {

        returnProto = getprotobyname( Filter );

    } else {

        returnProto = getprotobynumber( (int)(LONG_PTR)Filter );

    }

    if( returnProto == NULL ) {

        error = WSAGetLastError();

    }

    //
    // Hold the lock that protects the async thread context block queue
    // while we do this.  This prevents a race between this thread and
    // any thread invoking WSACancelAsyncRequest().
    //

    SockAcquireGlobalLock();

    //
    // If this request was cancelled, just return.
    //

    if( TaskHandle == SockAsyncCancelledTaskHandle ) {

        SockReleaseGlobalLock();
        return;

    }

    //
    // Copy the protoent structure to the output buffer.
    //

    if( returnProto != NULL ) {

        requiredBufferLength = CopyProtoentToBuffer(
                                   Buffer,
                                   BufferLength,
                                   returnProto
                                   );

        if( requiredBufferLength > (DWORD)BufferLength ) {

            error = WSAENOBUFS;

        } else {

            error = NO_ERROR;

        }

    }

    //
    // Set the current async thread task handle to 0 so that if a cancel
    // request comes in after this point it is failed properly.
    //

    SockAsyncCurrentTaskHandle = NULL;

    //
    // Release the global lock.
    //

    SockReleaseGlobalLock();

    //
    // Build lParam for the message we'll post to the application.
    // The high 16 bits are the error code, the low 16 bits are
    // the minimum buffer size required for the operation.
    //

    lParam = WSAMAKEASYNCREPLY( requiredBufferLength, error );

    //
    // Post a message to the application indication that the data it
    // requested is available.
    //

    assert( sizeof(TaskHandle) == sizeof(HANDLE) );

    sockPostRoutine = GET_SOCK_POST_ROUTINE ();
    //
    // !!! Need a mechanism to repost if the post failed!
    //

    if (!sockPostRoutine || !sockPostRoutine(
                 hWnd,
                 wMsg,
                 (WPARAM)TaskHandle,
                 lParam
                 )) {


        // Rem assert, since this might be an "orphaned" SockAsyncThread
        // in the process of tearing itself down
        //
        //assert( !"SockPostRoutine failed" );

    }

}   // SockProcessAsyncGetProto


VOID
SockProcessAsyncGetServ(
    IN HANDLE TaskHandle,
    IN DWORD OpCode,
    IN HWND hWnd,
    IN unsigned int wMsg,
    IN char FAR *Filter,
    IN char FAR *Protocol,
    IN char FAR *Buffer,
    IN int BufferLength
    )
{

    PSERVENT returnServ;
    DWORD requiredBufferLength = 0;
    LPARAM lParam;
    INT error;
    PWINSOCK_POST_ROUTINE   sockPostRoutine;

    assert( OpCode == WS_OPCODE_GET_SERV_BY_NAME ||
            OpCode == WS_OPCODE_GET_SERV_BY_PORT );

    //
    // Get the necessary information.
    //

    if( OpCode == WS_OPCODE_GET_SERV_BY_NAME ) {

        returnServ = getservbyname(
                         Filter,
                         Protocol
                         );

    } else {

        returnServ = getservbyport(
                         (int)(LONG_PTR)Filter,
                         Protocol
                         );

    }

    if( returnServ == NULL ) {

        error = GetLastError();

    }

    //
    // Hold the lock that protects the async thread context block queue
    // while we do this.  This prevents a race between this thread and
    // any thread invoking WSACancelAsyncRequest().
    //

    SockAcquireGlobalLock();

    //
    // If this request was cancelled, just return.
    //

    if( TaskHandle == SockAsyncCancelledTaskHandle ) {

        SockReleaseGlobalLock();
        return;

    }

    //
    // Copy the servent structure to the output buffer.
    //

    if( returnServ != NULL ) {

        requiredBufferLength = CopyServentToBuffer(
                                   Buffer,
                                   BufferLength,
                                   returnServ
                                   );

        if( requiredBufferLength > (DWORD)BufferLength ) {

            error = WSAENOBUFS;

        } else {

            error = NO_ERROR;

        }

    }

    //
    // Set the current async thread task handle to 0 so that if a cancel
    // request comes in after this point it is failed properly.
    //

    SockAsyncCurrentTaskHandle = NULL;

    //
    // Release the global lock.
    //

    SockReleaseGlobalLock();

    //
    // Build lParam for the message we'll post to the application.
    // The high 16 bits are the error code, the low 16 bits are
    // the minimum buffer size required for the operation.
    //

    lParam = WSAMAKEASYNCREPLY( requiredBufferLength, error );

    //
    // Post a message to the application indication that the data it
    // requested is available.
    //

    assert( sizeof(TaskHandle) == sizeof(HANDLE) );


    sockPostRoutine = GET_SOCK_POST_ROUTINE ();
    //
    // !!! Need a mechanism to repost if the post failed!
    //

    if (!sockPostRoutine || !sockPostRoutine(
                 hWnd,
                 wMsg,
                 (WPARAM)TaskHandle,
                 lParam
                 )) {


        // Rem assert, since this might be an "orphaned" SockAsyncThread
        // in the process of tearing itself down
        //
        //assert( !"SockPostRoutine failed" );

    }
}   // SockProcessAsyncGetServ



DWORD
CopyHostentToBuffer(
    char FAR *Buffer,
    int BufferLength,
    PHOSTENT Hostent
    )
{
    DWORD requiredBufferLength;
    DWORD bytesFilled;
    PCHAR currentLocation = Buffer;
    DWORD aliasCount;
    DWORD addressCount;
    DWORD i;
    PHOSTENT outputHostent = (PHOSTENT)Buffer;

    //
    // Determine how many bytes are needed to fully copy the structure.
    //

    requiredBufferLength = BytesInHostent( Hostent );

    //
    // Zero the user buffer.
    //

    if ( (DWORD)BufferLength > requiredBufferLength ) {
        ZeroMemory( Buffer, requiredBufferLength );
    } else {
        ZeroMemory( Buffer, BufferLength );
    }

    //
    // Copy over the hostent structure if it fits.
    //

    bytesFilled = sizeof(*Hostent);

    if ( bytesFilled > (DWORD)BufferLength ) {
        return requiredBufferLength;
    }

    CopyMemory( currentLocation, Hostent, sizeof(*Hostent) );
    currentLocation = Buffer + bytesFilled;

    outputHostent->h_name = NULL;
    outputHostent->h_aliases = NULL;
    outputHostent->h_addr_list = NULL;

    //
    // Count the host's aliases and set up an array to hold pointers to
    // them.
    //

    for ( aliasCount = 0;
          Hostent->h_aliases[aliasCount] != NULL;
          aliasCount++ );

    bytesFilled += (aliasCount+1) * sizeof(char FAR *);

    if ( bytesFilled > (DWORD)BufferLength ) {
        Hostent->h_aliases = NULL;
        return requiredBufferLength;
    }

    outputHostent->h_aliases = (char FAR * FAR *)currentLocation;
    currentLocation = Buffer + bytesFilled;

    //
    // Count the host's addresses and set up an array to hold pointers to
    // them.
    //

    for ( addressCount = 0;
          Hostent->h_addr_list[addressCount] != NULL;
          addressCount++ );

    bytesFilled += (addressCount+1) * sizeof(void FAR *);

    if ( bytesFilled > (DWORD)BufferLength ) {
        Hostent->h_addr_list = NULL;
        return requiredBufferLength;
    }

    outputHostent->h_addr_list = (char FAR * FAR *)currentLocation;
    currentLocation = Buffer + bytesFilled;

    //
    // Start filling in addresses.  Do addresses before filling in the
    // host name and aliases in order to avoid alignment problems.
    //

    for ( i = 0; i < addressCount; i++ ) {

        bytesFilled += Hostent->h_length;

        if ( bytesFilled > (DWORD)BufferLength ) {
            outputHostent->h_addr_list[i] = NULL;
            return requiredBufferLength;
        }

        outputHostent->h_addr_list[i] = currentLocation;

        CopyMemory(
            currentLocation,
            Hostent->h_addr_list[i],
            Hostent->h_length
            );

        currentLocation = Buffer + bytesFilled;
    }

    outputHostent->h_addr_list[i] = NULL;

    //
    // Copy the host name if it fits.
    //

    bytesFilled += strlen( Hostent->h_name ) + 1;

    if ( bytesFilled > (DWORD)BufferLength ) {
        return requiredBufferLength;
    }

    outputHostent->h_name = currentLocation;

    CopyMemory( currentLocation, Hostent->h_name, strlen( Hostent->h_name ) + 1 );
    currentLocation = Buffer + bytesFilled;

    //
    // Start filling in aliases.
    //

    for ( i = 0; i < aliasCount; i++ ) {

        bytesFilled += strlen( Hostent->h_aliases[i] ) + 1;

        if ( bytesFilled > (DWORD)BufferLength ) {
            outputHostent->h_aliases[i] = NULL;
            return requiredBufferLength;
        }

        outputHostent->h_aliases[i] = currentLocation;

        CopyMemory(
            currentLocation,
            Hostent->h_aliases[i],
            strlen( Hostent->h_aliases[i] ) + 1
            );

        currentLocation = Buffer + bytesFilled;
    }

    outputHostent->h_aliases[i] = NULL;

    return requiredBufferLength;

}   // CopyHostentToBuffer



DWORD
CopyServentToBuffer(
    IN char FAR *Buffer,
    IN int BufferLength,
    IN PSERVENT Servent
    )
{
    DWORD requiredBufferLength;
    DWORD bytesFilled;
    PCHAR currentLocation = Buffer;
    DWORD aliasCount;
    DWORD i;
    PSERVENT outputServent = (PSERVENT)Buffer;

    //
    // Determine how many bytes are needed to fully copy the structure.
    //

    requiredBufferLength = BytesInServent( Servent );

    //
    // Zero the user buffer.
    //

    if ( (DWORD)BufferLength > requiredBufferLength ) {
        ZeroMemory( Buffer, requiredBufferLength );
    } else {
        ZeroMemory( Buffer, BufferLength );
    }

    //
    // Copy over the servent structure if it fits.
    //

    bytesFilled = sizeof(*Servent);

    if ( bytesFilled > (DWORD)BufferLength ) {
        return requiredBufferLength;
    }

    CopyMemory( currentLocation, Servent, sizeof(*Servent) );
    currentLocation = Buffer + bytesFilled;

    outputServent->s_name = NULL;
    outputServent->s_aliases = NULL;
    outputServent->s_proto = NULL;

    //
    // Count the service's aliases and set up an array to hold pointers to
    // them.
    //

    for ( aliasCount = 0;
          Servent->s_aliases[aliasCount] != NULL;
          aliasCount++ );

    bytesFilled += (aliasCount+1) * sizeof(char FAR *);

    if ( bytesFilled > (DWORD)BufferLength ) {
        Servent->s_aliases = NULL;
        return requiredBufferLength;
    }

    outputServent->s_aliases = (char FAR * FAR *)currentLocation;
    currentLocation = Buffer + bytesFilled;

    //
    // Copy the service name if it fits.
    //

    bytesFilled += strlen( Servent->s_name ) + 1;

    if ( bytesFilled > (DWORD)BufferLength ) {
        return requiredBufferLength;
    }

    outputServent->s_name = currentLocation;

    CopyMemory( currentLocation, Servent->s_name, strlen( Servent->s_name ) + 1 );
    currentLocation = Buffer + bytesFilled;

    //
    // Copy the protocol name if it fits.
    //

    bytesFilled += strlen( Servent->s_proto ) + 1;

    if ( bytesFilled > (DWORD)BufferLength ) {
        return requiredBufferLength;
    }

    outputServent->s_proto = currentLocation;

    CopyMemory( currentLocation, Servent->s_proto, strlen( Servent->s_proto ) + 1 );
    currentLocation = Buffer + bytesFilled;

    //
    // Start filling in aliases.
    //

    for ( i = 0; i < aliasCount; i++ ) {

        bytesFilled += strlen( Servent->s_aliases[i] ) + 1;

        if ( bytesFilled > (DWORD)BufferLength ) {
            outputServent->s_aliases[i] = NULL;
            return requiredBufferLength;
        }

        outputServent->s_aliases[i] = currentLocation;

        CopyMemory(
            currentLocation,
            Servent->s_aliases[i],
            strlen( Servent->s_aliases[i] ) + 1
            );

        currentLocation = Buffer + bytesFilled;
    }

    outputServent->s_aliases[i] = NULL;

    return requiredBufferLength;

}   // CopyServentToBuffer



DWORD
CopyProtoentToBuffer(
    IN char FAR *Buffer,
    IN int BufferLength,
    IN PPROTOENT Protoent
    )
{
    DWORD requiredBufferLength;
    DWORD bytesFilled;
    PCHAR currentLocation = Buffer;
    DWORD aliasCount;
    DWORD i;
    PPROTOENT outputProtoent = (PPROTOENT)Buffer;

    //
    // Determine how many bytes are needed to fully copy the structure.
    //

    requiredBufferLength = BytesInProtoent( Protoent );

    //
    // Zero the user buffer.
    //

    if ( (DWORD)BufferLength > requiredBufferLength ) {
        ZeroMemory( Buffer, requiredBufferLength );
    } else {
        ZeroMemory( Buffer, BufferLength );
    }

    //
    // Copy over the protoent structure if it fits.
    //

    bytesFilled = sizeof(*Protoent);

    if ( bytesFilled > (DWORD)BufferLength ) {
        return requiredBufferLength;
    }

    CopyMemory( currentLocation, Protoent, sizeof(*Protoent) );
    currentLocation = Buffer + bytesFilled;

    outputProtoent->p_name = NULL;
    outputProtoent->p_aliases = NULL;

    //
    // Count the protocol's aliases and set up an array to hold pointers to
    // them.
    //

    for ( aliasCount = 0;
          Protoent->p_aliases[aliasCount] != NULL;
          aliasCount++ );

    bytesFilled += (aliasCount+1) * sizeof(char FAR *);

    if ( bytesFilled > (DWORD)BufferLength ) {
        Protoent->p_aliases = NULL;
        return requiredBufferLength;
    }

    outputProtoent->p_aliases = (char FAR * FAR *)currentLocation;
    currentLocation = Buffer + bytesFilled;

    //
    // Copy the protocol name if it fits.
    //

    bytesFilled += strlen( Protoent->p_name ) + 1;

    if ( bytesFilled > (DWORD)BufferLength ) {
        return requiredBufferLength;
    }

    outputProtoent->p_name = currentLocation;

    CopyMemory( currentLocation, Protoent->p_name, strlen( Protoent->p_name ) + 1 );
    currentLocation = Buffer + bytesFilled;

    //
    // Start filling in aliases.
    //

    for ( i = 0; i < aliasCount; i++ ) {

        bytesFilled += strlen( Protoent->p_aliases[i] ) + 1;

        if ( bytesFilled > (DWORD)BufferLength ) {
            outputProtoent->p_aliases[i] = NULL;
            return requiredBufferLength;
        }

        outputProtoent->p_aliases[i] = currentLocation;

        CopyMemory(
            currentLocation,
            Protoent->p_aliases[i],
            strlen( Protoent->p_aliases[i] ) + 1
            );

        currentLocation = Buffer + bytesFilled;
    }

    outputProtoent->p_aliases[i] = NULL;

    return requiredBufferLength;

}   // CopyProtoentToBuffer



DWORD
BytesInHostent(
    PHOSTENT Hostent
    )
{
    DWORD total;
    int i;

    total = sizeof(HOSTENT);
    total += strlen( Hostent->h_name ) + 1;

    //
    // Account for the NULL terminator pointers at the end of the
    // alias and address arrays.
    //

    total += sizeof(char *) + sizeof(char *);

    for ( i = 0; Hostent->h_aliases[i] != NULL; i++ ) {
        total += strlen( Hostent->h_aliases[i] ) + 1 + sizeof(char *);
    }

    for ( i = 0; Hostent->h_addr_list[i] != NULL; i++ ) {
        total += Hostent->h_length + sizeof(char *);
    }

    //
    // Pad the answer to an eight-byte boundary.
    //

    return (total + 7) & ~7;

}   // BytesInHostent



DWORD
BytesInServent(
    IN PSERVENT Servent
    )
{
    DWORD total;
    int i;

    total = sizeof(SERVENT);
    total += strlen( Servent->s_name ) + 1;
    total += strlen( Servent->s_proto ) + 1;
    total += sizeof(char *);

    for ( i = 0; Servent->s_aliases[i] != NULL; i++ ) {
        total += strlen( Servent->s_aliases[i] ) + 1 + sizeof(char *);
    }

    return total;

}   // BytesInServent



DWORD
BytesInProtoent(
    IN PPROTOENT Protoent
    )
{
    DWORD total;
    int i;

    total = sizeof(PROTOENT);
    total += strlen( Protoent->p_name ) + 1;
    total += sizeof(char *);

    for ( i = 0; Protoent->p_aliases[i] != NULL; i++ ) {
        total += strlen( Protoent->p_aliases[i] ) + 1 + sizeof(char *);
    }

    return total;

}   // BytesInProtoent
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\dcatalog.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    dcatalog.cpp

Abstract:

    This module contains the implementation of the dcatalog class.

Author:

    Dirk Brandewie dirk@mink.intel.com  25-JUL-1995

Revision History:

    23-Aug-1995 dirk@mink.intel.com
        Moved includes into precomp.h.

    27-Jan-1998 vadime@miscrosoft.com
        Implemented dynamic catalog

--*/

#include "precomp.h"

#define CATALOG_NAME            "Protocol_Catalog9"
#define NEXT_CATALOG_ENTRY_NAME "Next_Catalog_Entry_ID"
#ifdef _WIN64
#define CATALOG_ENTRIES_NAME    "Catalog_Entries64"
#define NUM_ENTRIES_NAME        "Num_Catalog_Entries64"
#define CATALOG_ENTRIES_NAME32  "Catalog_Entries"
#define NUM_ENTRIES_NAME32      "Num_Catalog_Entries"
LPCSTR DCATALOG::sm_entries_name32 = CATALOG_ENTRIES_NAME32;
#else
#define CATALOG_ENTRIES_NAME    "Catalog_Entries"
#define NUM_ENTRIES_NAME        "Num_Catalog_Entries"
#endif

#define FIRST_SERIAL_NUMBER 1
    // The first access serial number to be assigned on a given system.
#define FIRST_CATALOG_ENTRY_ID 1001
    // The first catalog entry ID to be assigned on a given system.




DCATALOG::DCATALOG()
/*++

Routine Description:

    Destructor for the DCATALOG object.

Arguments:

    NONE.

Return Value:

    NONE.

--*/
{
    // Initialize members
    m_num_items = 0;
    m_reg_key = NULL;
    m_serial_num = FIRST_SERIAL_NUMBER-1;
    m_next_id = FIRST_CATALOG_ENTRY_ID-1;
    m_protocol_list.Flink = NULL;
#ifdef _WIN64
    m_items32 = NULL;
    assert (m_entries_name32==NULL); // Part of the union.
#endif
}




BOOL
DCATALOG::OpenCatalog(
    IN  HKEY   ParentKey
    )
/*++

Routine Description:

    This  procedure  opens the catalog portion of the registry.  If the catalog
    is  not  yet  present,  it  also  initializes  new  first-level  values and
    first-level  subkeys  for  the  catalog.  It is assumed that the catalog is
    locked against competing registry I/O attempts.

Arguments:

    ParentKey  - Supplies  the open registry key representing the parent key of
                 the catalog.

Return Value:

    The function returns TRUE if successful, otherwise it returns FALSE.

--*/
{
    LONG   lresult;
    HKEY   new_key;
    DWORD  key_disposition;

    assert(ParentKey != NULL);

    assert (m_protocol_list.Flink == NULL);
    __try {
        InitializeCriticalSection(&m_catalog_lock);
    }
    __except (WS2_EXCEPTION_FILTER ()) {
        return FALSE;
    }
    InitializeListHead (&m_protocol_list);

    //
    // We must first try to open the key before trying to create it.
    // RegCreateKeyEx() will fail with ERROR_ACCESS_DENIED if the current
    // user has insufficient privilege to create the target registry key,
    // even if that key already exists.
    //

    lresult = RegOpenKeyEx(
        ParentKey,                              // hkey
        DCATALOG::GetCurrentCatalogName(),      // lpszSubKey
        0,                                      // dwReserved
        MAXIMUM_ALLOWED,                        // samDesired
        & new_key                               // phkResult
        );

    if( lresult == ERROR_SUCCESS ) {
        key_disposition = REG_OPENED_EXISTING_KEY;

    } else if( lresult == ERROR_FILE_NOT_FOUND ) {
        lresult = RegCreateKeyEx(
            ParentKey,                          // hkey
            DCATALOG::GetCurrentCatalogName(),  // lpszSubKey
            0,                                  // dwReserved
            NULL,                               // lpszClass
            REG_OPTION_NON_VOLATILE,            // fdwOptions
            KEY_READ|KEY_WRITE,                 // samDesired
            NULL,                               // lpSecurityAttributes
            & new_key,                          // phkResult
            & key_disposition                   // lpdwDisposition
            );
    }

    if (lresult != ERROR_SUCCESS) {
        DEBUGF (DBG_ERR,
            ("Opening/Creating catalog key %s (%ld)\n",
                DCATALOG::GetCurrentCatalogName(), lresult));
        return FALSE;
    }

    TRY_START(guard_open) {
        BOOL	bresult;
        DWORD	dwData;
		if (key_disposition == REG_CREATED_NEW_KEY) {
            HKEY	entries_key;
            DWORD	dont_care;

			DEBUGF(
				DBG_TRACE,
				("Creating empty catalog in registry.\n"));

            dwData = 0;
            bresult = WriteRegistryEntry(
                new_key,           // EntryKey
                NUM_ENTRIES_NAME,  // EntryName
                (PVOID) & dwData,  // Data
                REG_DWORD          // TypeFlag
                );
            if (! bresult) {
                DEBUGF(
                    DBG_ERR,
                    ("Writing %s\n", NUM_ENTRIES_NAME));
                TRY_THROW(guard_open);
            }

#ifdef _WIN64
            bresult = WriteRegistryEntry(
                new_key,           // EntryKey
                NUM_ENTRIES_NAME32,// EntryName
                (PVOID) & dwData,  // Data
                REG_DWORD          // TypeFlag
                );
            if (! bresult) {
                DEBUGF(
                    DBG_ERR,
                    ("Writing %s\n", NUM_ENTRIES_NAME32));
                TRY_THROW(guard_open);
            }
#endif

            dwData = FIRST_CATALOG_ENTRY_ID;
            bresult = WriteRegistryEntry(
                new_key,                  // EntryKey
                NEXT_CATALOG_ENTRY_NAME,  // EntryName
                (PVOID) & dwData,         // Data
                REG_DWORD                 // TypeFlag
                );
            if (! bresult) {
                DEBUGF(
                    DBG_ERR,
                    ("Writing %s\n",
                    NEXT_CATALOG_ENTRY_NAME));
                TRY_THROW(guard_open);
            }

            dwData = FIRST_SERIAL_NUMBER;
            bresult = WriteRegistryEntry(
                new_key,                  // EntryKey
                SERIAL_NUMBER_NAME,       // EntryName
                (PVOID) & dwData,         // Data
                REG_DWORD                 // TypeFlag
                );
            if (! bresult) {
                DEBUGF(
                    DBG_ERR,
                    ("Writing %s\n",
                    SERIAL_NUMBER_NAME));
                TRY_THROW(guard_open);
            }

            lresult = RegCreateKeyEx(
                new_key,                  // hkey
                CATALOG_ENTRIES_NAME,     // lpszSubKey
                0,                        // dwReserved
                NULL,                     // lpszClass
                REG_OPTION_NON_VOLATILE,  // fdwOptions
                KEY_READ|KEY_WRITE,       // samDesired
                NULL,                     // lpSecurityAttributes
                & entries_key,            // phkResult
                & dont_care               // lpdwDisposition
                );
            if (lresult != ERROR_SUCCESS) {
                DEBUGF(
                    DBG_ERR,
                    ("Creating entries subkey %s\n",
                    CATALOG_ENTRIES_NAME));
                TRY_THROW(guard_open);
            }
            lresult = RegCloseKey(
                entries_key  // hkey
                );
            if (lresult != ERROR_SUCCESS) {
                DEBUGF(
                    DBG_ERR,
                    ("Closing entries subkey %s\n", CATALOG_ENTRIES_NAME));
                TRY_THROW(guard_open);
            }

#ifdef _WIN64
            lresult = RegCreateKeyEx(
                new_key,                  // hkey
                CATALOG_ENTRIES_NAME32,   // lpszSubKey
                0,                        // dwReserved
                NULL,                     // lpszClass
                REG_OPTION_NON_VOLATILE,  // fdwOptions
                KEY_READ|KEY_WRITE,       // samDesired
                NULL,                     // lpSecurityAttributes
                & entries_key,            // phkResult
                & dont_care               // lpdwDisposition
                );
            if (lresult != ERROR_SUCCESS) {
                DEBUGF(
                    DBG_ERR,
                    ("Creating entries subkey %s\n",
                    CATALOG_ENTRIES_NAME32));
                TRY_THROW(guard_open);
            }
            lresult = RegCloseKey(
                entries_key  // hkey
                );
            if (lresult != ERROR_SUCCESS) {
                DEBUGF(
                    DBG_ERR,
                    ("Closing entries subkey %s\n", CATALOG_ENTRIES_NAME32));
                TRY_THROW(guard_open);
            }
#endif

        }  // if REG_CREATED_NEW_KEY
        else {
            bresult = ReadRegistryEntry (
                        new_key,                // EntryKey
                        SERIAL_NUMBER_NAME,     // EntryName
                        (PVOID) &dwData,		// Data
                        sizeof (DWORD),         // MaxBytes
                        REG_DWORD               // TypeFlag
                        );
            if (!bresult) {
                // This must be the first time this version of ws2_32.dll
                // is being run.  We need to update catalog to have this
                // new entry or fail initialization.
            
			    dwData = FIRST_SERIAL_NUMBER;
                bresult = WriteRegistryEntry (
                            new_key,                // EntryKey
                            SERIAL_NUMBER_NAME,     // EntryName
                            (PVOID) &dwData,		// Data
                            REG_DWORD               // TypeFlag
                            );
                if (!bresult) {
                    DEBUGF (DBG_ERR,
                        ("Writing %s value.\n", SERIAL_NUMBER_NAME));
				    TRY_THROW (guard_open);
			    }
            }
        } // else

		m_reg_key = new_key;
		return TRUE;

    } TRY_CATCH(guard_open) {
        LONG close_result;

        close_result = RegCloseKey(
            new_key  // hkey
            );
        if (close_result != ERROR_SUCCESS) {
            DEBUGF(
                DBG_ERR,
                ("Closing catalog key %s, err: %ld\n",
                DCATALOG::GetCurrentCatalogName(), close_result));
        }

        return FALSE;
    } TRY_END(guard_open);


}  // OpenCatalog


#ifdef _WIN64
INT
DCATALOG::InitializeFromRegistry64_32(
    IN  HKEY    ParentKey
    )
/*++

Routine Description:

    This  procedure takes care of initializing a newly-created protocol catalog
    from  the  registry.  If the registry does not currently contain a protocol
    catalog,  an  empty catalog is created and the registry is initialized with
    the new empty catalog.

Arguments:

    ParentKey - Supplies  an  open registry key under which the catalog is read
                or  created  as  a  subkey.   The  key may be closed after this
                procedure returns.
    ChangeEvent - if event handle is specified it is associated with changes to
                the catalog.

Return Value:

    The  function  returns  ERROR_SUCESS if successful, otherwise it returns an
    appropriate WinSock error code.

Implementation Notes:

    lock the catalog
    open catalog, creating empty if required
    read the catalog
    unlock the catalog
--*/
{
    INT return_value;
    BOOL bresult;

    assert(ParentKey != NULL);
    assert(m_reg_key==NULL);


    bresult = OpenCatalog(
        ParentKey
        );
    // Opening  the catalog has the side-effect of creating an empty catalog if
    // needed.
    if (bresult) {
        m_items32 = new DCATALOG_ITEMS;
        if (m_items32!=NULL) {
            assert (m_entries_name32!=sm_entries_name32); // Part of the union
            m_items32->m_num_items = 0;
            InitializeListHead (&m_items32->m_protocol_list);
            return_value =  RefreshFromRegistry (NULL);
        }
        else {
            DEBUGF(
                DBG_ERR,
                ("Allocating 32bit item list\n"));
            return_value = WSA_NOT_ENOUGH_MEMORY;
            return return_value;
        }
    }
    else {
        return_value = WSASYSCALLFAILURE;
    }
    return return_value;

}  // InitializeFromRegistry64_32

INT
DCATALOG::InitializeFromRegistry32(
    IN  HKEY    ParentKey
    )
/*++

Routine Description:

    This  procedure takes care of initializing a newly-created protocol catalog
    from  the  registry.  If the registry does not currently contain a protocol
    catalog,  an  empty catalog is created and the registry is initialized with
    the new empty catalog.

Arguments:

    ParentKey - Supplies  an  open registry key under which the catalog is read
                or  created  as  a  subkey.   The  key may be closed after this
                procedure returns.
    ChangeEvent - if event handle is specified it is associated with changes to
                the catalog.

Return Value:

    The  function  returns  ERROR_SUCESS if successful, otherwise it returns an
    appropriate WinSock error code.

Implementation Notes:

    lock the catalog
    open catalog, creating empty if required
    read the catalog
    unlock the catalog
--*/
{
    INT return_value;
    BOOL bresult;

    assert(ParentKey != NULL);
    assert(m_reg_key==NULL);


    bresult = OpenCatalog(
        ParentKey
        );
    // Opening  the catalog has the side-effect of creating an empty catalog if
    // needed.
    if (bresult) {
        m_entries_name32 = sm_entries_name32;
        return_value =  RefreshFromRegistry (NULL);
    }
    else {
        return_value = WSASYSCALLFAILURE;
    }
    return return_value;

}  // InitializeFromRegistry64
#endif


INT
DCATALOG::InitializeFromRegistry(
    IN  HKEY    ParentKey,
    IN  HANDLE  ChangeEvent OPTIONAL
    )
/*++

Routine Description:

    This  procedure takes care of initializing a newly-created protocol catalog
    from  the  registry.  If the registry does not currently contain a protocol
    catalog,  an  empty catalog is created and the registry is initialized with
    the new empty catalog.

Arguments:

    ParentKey - Supplies  an  open registry key under which the catalog is read
                or  created  as  a  subkey.   The  key may be closed after this
                procedure returns.
    ChangeEvent - if event handle is specified it is associated with changes to
                the catalog.

Return Value:

    The  function  returns  ERROR_SUCESS if successful, otherwise it returns an
    appropriate WinSock error code.

Implementation Notes:

    lock the catalog
    open catalog, creating empty if required
    read the catalog
    unlock the catalog
--*/
{
    INT return_value;
    BOOL bresult;

    assert(ParentKey != NULL);
    assert(m_reg_key==NULL);


    bresult = OpenCatalog(
        ParentKey
        );
    // Opening  the catalog has the side-effect of creating an empty catalog if
    // needed.
    if (bresult) {
        return_value =  RefreshFromRegistry (ChangeEvent);
    }
    else {
        return_value = WSASYSCALLFAILURE;
    }
    return return_value;

}  // InitializeFromRegistry


INT
DCATALOG::RefreshFromRegistry(
    IN  HANDLE  ChangeEvent OPTIONAL
    )
/*++

Routine Description:

    This  procedure takes care of initializing a newly-created protocol catalog
    from  the  registry.  If the registry does not currently contain a protocol
    catalog,  an  empty catalog is created and the registry is initialized with
    the new empty catalog.

Arguments:

    ChangeEvent - if event handle is specified it is associated with changes to
                the catalog.

Return Value:

    The  function  returns  ERROR_SUCESS if successful, otherwise it returns an
    appropriate WinSock error code.

Implementation Notes:

    lock the catalog
    do
		establish event notification for any registry catalog modifications
		RegOpenKey(... entries, entries_key)
		ReadRegistryEntry(... next_id)
		ReadRegistryEntry(... num_items)
		for i in (1 .. num_items)
			item = new catalog item
			item->InitializeFromRegistry(entries_key, i)
			add item to temp list
		end for
		RegCloseKey(... entries_key)
    while registry catalog has changed during read.
    update the catalog
    unlock the catalog

--*/
{
    INT			return_value;
    BOOLEAN		created_event = FALSE;
    DWORD       serial_num;
	LONG        lresult;
	HKEY        entries_key;
	LIST_ENTRY  temp_list;
	PPROTO_CATALOG_ITEM  item;
	DWORD       num_entries, next_id;
    BOOL        catalog_changed = TRUE;
#ifdef _WIN64
    LIST_ENTRY  temp_list32;
	DWORD       num_entries32;
    BOOLEAN     saveCatalog64 = FALSE;
#endif

    //
    // Create the event if caller did not provide one
    //
    if (ChangeEvent==NULL) {
        ChangeEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
        if (ChangeEvent==NULL) {
            return WSASYSCALLFAILURE;
        }
        created_event = TRUE;
    }

    // Lock this catalog object
    AcquireCatalogLock ();

    assert(m_reg_key != NULL);

	// Initialize locals to known defaults
	InitializeListHead (&temp_list);

#ifdef _WIN64
	InitializeListHead (&temp_list32);
#endif

    do {
    	BOOL        bresult;
        // Synchronize with writers
        return_value = SynchronizeSharedCatalogAccess (
								m_reg_key,
								ChangeEvent,
								&serial_num);
        if (return_value != ERROR_SUCCESS) {
            // Non-recoverable
            break;
        }

        // Check if catalog has changed.
        if (m_serial_num == serial_num) {
            return_value = ERROR_SUCCESS;
            break;
        }

		// Read id of next catalog entry
		bresult = ReadRegistryEntry(
			m_reg_key,              // EntryKey
			NEXT_CATALOG_ENTRY_NAME,// EntryName
			(PVOID) & next_id,      // Data
			sizeof(DWORD),          // MaxBytes
			REG_DWORD               // TypeFlag
			);

		if (! bresult) {
			DEBUGF(
				DBG_ERR,
				("Reading %s from registry\n",
				NUM_ENTRIES_NAME));
            return_value = WSASYSCALLFAILURE;
            break;
		}

		// read number of items in the catalog
		bresult = ReadRegistryEntry(
			m_reg_key,              // EntryKey
#ifdef _WIN64
            m_entries_name32==sm_entries_name32
                ? NUM_ENTRIES_NAME32 :
#endif
			NUM_ENTRIES_NAME,       // EntryName
			(PVOID) & num_entries,  // Data
			sizeof(DWORD),          // MaxBytes
			REG_DWORD               // TypeFlag
			);

#ifdef _WIN64
        if (! bresult  &&
            m_entries_name32!=sm_entries_name32) {
            //
            // We may be upgrading 64 bit installation with
            // only one catalog (prior to catalog separation
            // being implemented on WIN64).
            // Read 32 bit catalog instead and remeber to save
            // it as 64 bit catalog.
            //
            DEBUGF(
				DBG_ERR,
				("Reading %s from registry, trying %s...\n",
				NUM_ENTRIES_NAME, NUM_ENTRIES_NAME32));            
            saveCatalog64 = TRUE;
		    bresult = ReadRegistryEntry(
			    m_reg_key,              // EntryKey
			    NUM_ENTRIES_NAME32,     // EntryName
			    (PVOID) & num_entries,  // Data
			    sizeof(DWORD),          // MaxBytes
			    REG_DWORD               // TypeFlag
			    );
        }
#endif

		if (! bresult) {
			DEBUGF(
				DBG_ERR,
				("Reading %s from registry\n",
				NUM_ENTRIES_NAME));
            return_value = WSASYSCALLFAILURE;
			break;
		}

		// Open entry key
		lresult = RegOpenKeyEx(
			m_reg_key,             // hkey
#ifdef _WIN64
            m_entries_name32==sm_entries_name32
                ? CATALOG_ENTRIES_NAME32 :
#endif
			CATALOG_ENTRIES_NAME,  // lpszSubKey
			0,                     // dwReserved
			MAXIMUM_ALLOWED,       // samDesired
			& entries_key          // phkResult
			);

#ifdef _WIN64
        if (lresult == ERROR_FILE_NOT_FOUND &&
                m_entries_name32!=sm_entries_name32) {
            //
            // We may be upgrading 64 bit installation with
            // only one catalog (prior to catalog separation
            // being implemented on WIN64).
            // Read 32 bit catalog instead and remeber to save
            // it as 64 bit catalog.
            //
			DEBUGF(
				DBG_ERR,
				("Opening protocol entries key of registry, trying entries32...\n"));
            saveCatalog64 = TRUE;
		    lresult = RegOpenKeyEx(
			    m_reg_key,             // hkey
			    CATALOG_ENTRIES_NAME32,// lpszSubKey
			    0,                     // dwReserved
			    MAXIMUM_ALLOWED,       // samDesired
			    & entries_key          // phkResult
			    );
        }
#endif
        if (lresult != ERROR_SUCCESS) {

            if (lresult != ERROR_SUCCESS) {
                // Non-recoverable
			    DEBUGF(
				    DBG_ERR,
				    ("Opening entries key of registry\n"));
			    return_value = WSASYSCALLFAILURE;
                break;
            }
        }

		TRY_START(guard_open) {
			DWORD                seq_num;

            assert (IsListEmpty (&temp_list));
			// read the items and place on temp list
			for (seq_num = 1; seq_num <= num_entries; seq_num++) {
				item = new PROTO_CATALOG_ITEM();
				if (item == NULL) {
					return_value = WSA_NOT_ENOUGH_MEMORY;
					DEBUGF(
						DBG_ERR,
						("Allocating new proto catalog item\n"));
					TRY_THROW(guard_open);
				}
				return_value = item->InitializeFromRegistry(
					entries_key,  // ParentKey
					(INT)seq_num  // SequenceNum
					);
				if (return_value != ERROR_SUCCESS) {
    				item->Dereference ();
					DEBUGF(
						DBG_ERR,
						("Initializing new proto catalog item\n"));
					TRY_THROW(guard_open);
				}
				InsertTailList (&temp_list, &item->m_CatalogLinkage);
			}  // for seq_num


#ifdef _WIN64
            if (m_items32!=NULL && m_entries_name32!=sm_entries_name32) {
                HKEY    entries_key32;

			    // read number of items in the catalog
			    bresult = ReadRegistryEntry(
				    m_reg_key,              // EntryKey
				    NUM_ENTRIES_NAME32,     // EntryName
				    (PVOID) & num_entries32,// Data
				    sizeof(DWORD),          // MaxBytes
				    REG_DWORD               // TypeFlag
				    );
			    if (! bresult) {
				    DEBUGF(
					    DBG_ERR,
					    ("Reading %s from registry\n",
					    NUM_ENTRIES_NAME32));
                    return_value = WSASYSCALLFAILURE;
				    TRY_THROW(guard_open);
			    }

		        // Open entry key
		        lresult = RegOpenKeyEx(
			        m_reg_key,             // hkey
			        CATALOG_ENTRIES_NAME32,// lpszSubKey
			        0,                     // dwReserved
			        MAXIMUM_ALLOWED,       // samDesired
			        & entries_key32        // phkResult
			        );

                if (lresult != ERROR_SUCCESS) {
                    // Non-recoverable
			        DEBUGF(
				        DBG_ERR,
				        ("Opening entries key of registry\n"));
			        return_value = WSASYSCALLFAILURE;
				    TRY_THROW(guard_open);
                }

        		TRY_START(guard_open32) {
                    assert (IsListEmpty (&temp_list32));
			        // read the items and place on temp list
			        for (seq_num = 1; seq_num <= num_entries32; seq_num++) {
				        item = new PROTO_CATALOG_ITEM();
				        if (item == NULL) {
					        return_value = WSA_NOT_ENOUGH_MEMORY;
					        DEBUGF(
						        DBG_ERR,
						        ("Allocating new proto catalog item\n"));
					        TRY_THROW(guard_open32);
				        }
				        return_value = item->InitializeFromRegistry(
					        entries_key,  // ParentKey
					        (INT)seq_num  // SequenceNum
					        );
				        if (return_value != ERROR_SUCCESS) {
    				        item->Dereference ();
					        DEBUGF(
						        DBG_ERR,
						        ("Initializing new proto catalog item\n"));
					        TRY_THROW(guard_open32);
				        }
				        InsertTailList (&temp_list32, &item->m_CatalogLinkage);
			        }  // for seq_num
                }
                TRY_CATCH(guard_open32) {
                    assert (return_value!=ERROR_SUCCESS);
		        } TRY_END(guard_open32);

                // close catalog
		        lresult = RegCloseKey(
			        entries_key32  // hkey
			        );
		        if (lresult != ERROR_SUCCESS) {
			        DEBUGF(
				        DBG_ERR,
				        ("Closing entries key of registry\n"));
			        // non-fatal
		        }
            }
#endif
        }
        TRY_CATCH(guard_open) {
            assert (return_value!=ERROR_SUCCESS);
		} TRY_END(guard_open);

        // close catalog
		lresult = RegCloseKey(
			entries_key  // hkey
			);
		if (lresult != ERROR_SUCCESS) {
			DEBUGF(
				DBG_ERR,
				("Closing entries key of registry\n"));
			// non-fatal
		}

        //
        // Check if catalog has changed while we were reading it
        // If so, we'll have to retry even though we succeeded
        // in reading it to ensure consistent view of the whole
        // catalog.
        //

        catalog_changed = HasCatalogChanged (ChangeEvent);
        
        if ((return_value==ERROR_SUCCESS) && !catalog_changed) {
            UpdateProtocolList (&temp_list);
#ifdef _WIN64
            if (m_items32!=NULL && m_entries_name32!=sm_entries_name32) {
                m_items32->UpdateProtocolList (&temp_list32);
	            assert (m_items32->m_num_items == num_entries32);
            }
#endif
	        
            // Store new catalog parameters
	        assert (m_num_items == num_entries);
	        m_next_id = next_id;
            m_serial_num = serial_num;

            break;
        }
            
        //
        // Free the entries we might have read
        //

        while (!IsListEmpty (&temp_list)) {
        	PLIST_ENTRY     list_member;
			list_member = RemoveHeadList (&temp_list);
			item = CONTAINING_RECORD (list_member,
										PROTO_CATALOG_ITEM,
										m_CatalogLinkage);
#if defined(DEBUG_TRACING)
            InitializeListHead (&item->m_CatalogLinkage);
#endif
			item->Dereference ();
		}
#ifdef _WIN64
        if (m_items32!=NULL && m_entries_name32!=sm_entries_name32) {
            while (!IsListEmpty (&temp_list32)) {
        	    PLIST_ENTRY     list_member;
			    list_member = RemoveHeadList (&temp_list32);
			    item = CONTAINING_RECORD (list_member,
										PROTO_CATALOG_ITEM,
										m_CatalogLinkage);
#if defined(DEBUG_TRACING)
                InitializeListHead (&item->m_CatalogLinkage);
#endif
			    item->Dereference ();
    		}
        }
        else {
            assert (IsListEmpty (&temp_list32));
        }
#endif
    }
    while (catalog_changed); // Retry while catalog is being written over

    //
    // We should have freed or consumed all the items we
    // might have read.
    //
    assert (IsListEmpty (&temp_list));

#ifdef _WIN64
    if (saveCatalog64 && return_value==ERROR_SUCCESS) {
		DEBUGF(
			DBG_ERR,
			("Duplicating 32 bit protocol catalog to 64 bit...\n"));
        WriteToRegistry ();
    }
#endif

    ReleaseCatalogLock ();

    // Close the event if we created one.
    if (created_event)
        CloseHandle (ChangeEvent);

    return return_value;

}  // RefreshFromRegistry

VOID
DCATALOG_ITEMS::UpdateProtocolList (
    PLIST_ENTRY     new_list
    ) 
/*++

Routine Description:

    This procedure carefully updates the catalog to match the one
    just read from the registry.  It takes care of moving item
    that did not change, removing itmes that no longer exists,
    adding new items, as well as establishing new item order.

Arguments:

    new_list    - list of the items just read form the registry

Return Value:

    None.

Implementation Notes:

    move all items from current catalog to old list
	for all items in new list
		if same item exist in old list
			add old item to current catalog and destroy new one
		else
			add new item to current catalog
	end for
	dereference all remaining items in the old list

--*/
{
    LIST_ENTRY          old_list;
    PPROTO_CATALOG_ITEM item;
    PLIST_ENTRY         list_member;

	// Move items from current list to old list
	InsertHeadList (&m_protocol_list, &old_list);
	RemoveEntryList (&m_protocol_list);
	InitializeListHead (&m_protocol_list);

	// for all loaded items
	while (!IsListEmpty (new_list)) {
		list_member = RemoveHeadList (new_list);
		item = CONTAINING_RECORD (list_member,
									PROTO_CATALOG_ITEM,
									m_CatalogLinkage);

		// check if the same item is in the old list
		list_member = old_list.Flink;
		while (list_member!=&old_list) {
			PPROTO_CATALOG_ITEM old_item;
			old_item = CONTAINING_RECORD (list_member,
									PROTO_CATALOG_ITEM,
									m_CatalogLinkage);
            list_member = list_member->Flink;
			if (item->GetProtocolInfo()->dwCatalogEntryId==
				   old_item->GetProtocolInfo()->dwCatalogEntryId) {
				// it is, use the old one and get rid of the new
				assert (*(item->GetProviderId ()) == *(old_item->GetProviderId()));
#if defined(DEBUG_TRACING)
                InitializeListHead (&item->m_CatalogLinkage);
#endif
				item->Dereference ();

				item = old_item;
				RemoveEntryList (&item->m_CatalogLinkage);
#if defined(DEBUG_TRACING)
                InitializeListHead (&item->m_CatalogLinkage);
#endif
                m_num_items -= 1;
				break;
			}
		}
		// add item to the current list
		InsertTailList (&m_protocol_list, &item->m_CatalogLinkage);
        m_num_items += 1;
	}

	// destroy all remaining items on the old list
	while (!IsListEmpty (&old_list)) {
		list_member = RemoveHeadList (&old_list);
		item = CONTAINING_RECORD (list_member,
									PROTO_CATALOG_ITEM,
									m_CatalogLinkage);
#if defined(DEBUG_TRACING)
        InitializeListHead (&item->m_CatalogLinkage);
#endif
        m_num_items -= 1;
		item->Dereference ();
	}
}


INT
DCATALOG::WriteToRegistry(
    )
/*++

Routine Description:

    This procedure writes the "entries" and "numentries" portion of the catalog
    out  to  the  registry.

Arguments:

Return Value:

    If  the  function  is  successful,  it  returns ERROR_SUCCESS, otherwise it
    returns an appropriate WinSock error code.

Implementation Notes:
	lock catalog object
	acquire registry catalog lock (exclusive)
    RegCreateKeyEx(... entries, entries_key)
    RegDeleteSubkeys (... entries_key)
    while (get item from catalog)
        num_items++;
        item->WriteToRegistry(entries_key, num_items)
    end while
    RegCloseKey(... entries_key)
    WriteRegistryEntry(... num_items)
	WriteRegistryEntry(... nex_id)
	release registry catalog
	unlock catalog object
--*/
{
    LONG lresult;
    HKEY access_key, entries_key;
    DWORD dont_care;
    INT return_value;
    BOOL bresult;

	// lock the catalog object
    AcquireCatalogLock ();
    assert (m_reg_key!=NULL);
    assert (m_serial_num!=0);

	// Get exclusive access to the registry
	// This also verifies that registry has not change since
	// it was last read
    return_value = AcquireExclusiveCatalogAccess (
							m_reg_key,
							m_serial_num,
							&access_key);
    if (return_value == ERROR_SUCCESS) {
		// Create or open existing entries key
        lresult = RegCreateKeyEx(
            m_reg_key,                // hkey
#ifdef _WIN64
            m_entries_name32==sm_entries_name32
                ? CATALOG_ENTRIES_NAME32 :
#endif
            CATALOG_ENTRIES_NAME,     // lpszSubKey
            0,                        // dwReserved
            NULL,                     // lpszClass
            REG_OPTION_NON_VOLATILE,  // fdwOptions
            KEY_READ|KEY_WRITE,       // samDesired
            NULL,                     // lpSecurityAttributes
            & entries_key,            // phkResult
            & dont_care               // lpdwDisposition
            );
        if (lresult == ERROR_SUCCESS) {
            PLIST_ENTRY          ListMember;
            PPROTO_CATALOG_ITEM  item;
            DWORD                num_items = 0;

            lresult = RegDeleteSubkeys (entries_key);

            TRY_START(any_failure) {

#ifdef _WIN64
                if (m_items32!=NULL && m_entries_name32!=sm_entries_name32) {
                    HKEY entries_key32;
                    DWORD num_items32 = 0;


		            // Create or open existing entries key
                    lresult = RegCreateKeyEx(
                        m_reg_key,                // hkey
                        CATALOG_ENTRIES_NAME32,   // lpszSubKey
                        0,                        // dwReserved
                        NULL,                     // lpszClass
                        REG_OPTION_NON_VOLATILE,  // fdwOptions
                        KEY_READ|KEY_WRITE,       // samDesired
                        NULL,                     // lpSecurityAttributes
                        & entries_key32,          // phkResult
                        & dont_care               // lpdwDisposition
                        );
                    if (lresult != ERROR_SUCCESS) {
                        TRY_THROW(any_failure);
                    }

                    lresult = RegDeleteSubkeys (entries_key32);

                    TRY_START(any_failure32) {
				        // Write catalog items to registry
                        ListMember = m_items32->m_protocol_list.Flink;
                        while (ListMember != & m_items32->m_protocol_list) {
                            item = CONTAINING_RECORD(
                                ListMember,
                                PROTO_CATALOG_ITEM,
                                m_CatalogLinkage);
                            ListMember = ListMember->Flink;
                            num_items32 += 1;
                            return_value = item->WriteToRegistry(
                                entries_key32,  // ParentKey
                                num_items32     // SequenceNum
                                );
                            if (return_value != ERROR_SUCCESS) {
                                DEBUGF(
                                    DBG_ERR,
                                    ("Writing item (%lu) to registry\n",
                                    num_items32));
                                TRY_THROW(any_failure32);
                            }
                        }  // while get item

                        assert (m_items32->m_num_items == num_items32);
				        // Write number of items
                        bresult = WriteRegistryEntry(
                            m_reg_key,             // EntryKey
                            NUM_ENTRIES_NAME32,    // EntryName
                            (PVOID) & m_items32->m_num_items,// Data
                            REG_DWORD             // TypeFlag
                            );
                        if (! bresult) {
                            DEBUGF(
                                DBG_ERR,
                                ("Writing %s value\n",
                                NUM_ENTRIES_NAME32));
                            return_value = WSASYSCALLFAILURE;
                            TRY_THROW(any_failure32);
                        }
                    } TRY_CATCH(any_failure32) {
                        assert (return_value != ERROR_SUCCESS);
                    } TRY_END(any_failure32);

			        // Close entries key
                    lresult = RegCloseKey(
                        entries_key32  // hkey
                        );
                    if (lresult != ERROR_SUCCESS) {
                        DEBUGF(
                            DBG_ERR,
                            ("Closing entries key of registry\n"));
				        // Non-fatal
                    }
                }
#endif _WIN64


				// Write catalog items to registry
                ListMember = m_protocol_list.Flink;
                while (ListMember != & m_protocol_list) {
                    item = CONTAINING_RECORD(
                        ListMember,
                        PROTO_CATALOG_ITEM,
                        m_CatalogLinkage);
                    ListMember = ListMember->Flink;
                    num_items += 1;
                    return_value = item->WriteToRegistry(
                        entries_key,  // ParentKey
                        num_items     // SequenceNum
                        );
                    if (return_value != ERROR_SUCCESS) {
                        DEBUGF(
                            DBG_ERR,
                            ("Writing item (%lu) to registry\n",
                            num_items));
                        TRY_THROW(any_failure);
                    }
                }  // while get item

                assert (m_num_items == num_items);
				// Write number of items
                bresult = WriteRegistryEntry(
                    m_reg_key,             // EntryKey
#ifdef _WIN64
                    m_entries_name32==sm_entries_name32
                        ? NUM_ENTRIES_NAME32 :
#endif
                    NUM_ENTRIES_NAME,     // EntryName
                    (PVOID) & m_num_items,// Data
                    REG_DWORD             // TypeFlag
                    );
                if (! bresult) {
                    DEBUGF(
                        DBG_ERR,
                        ("Writing %s value\n",
                        NUM_ENTRIES_NAME));
                    return_value = WSASYSCALLFAILURE;
                    TRY_THROW(any_failure);
                }

				// Write next catalog id
                bresult = WriteRegistryEntry(
                    m_reg_key,               // EntryKey
                    NEXT_CATALOG_ENTRY_NAME,// EntryName
                    (PVOID) & m_next_id,    // Data
                    REG_DWORD               // TypeFlag
                    );
                if (! bresult) {
                    DEBUGF(
                        DBG_ERR,
                        ("Writing %s value\n",
                        NUM_ENTRIES_NAME));
                    return_value = WSASYSCALLFAILURE;
                    TRY_THROW(any_failure);
                }

            } TRY_CATCH(any_failure) {
                if (return_value == ERROR_SUCCESS) {
                    return_value = WSASYSCALLFAILURE;
                }
            } TRY_END(any_failure);

			// Close entries key
            lresult = RegCloseKey(
                entries_key  // hkey
                );
            if (lresult != ERROR_SUCCESS) {
                DEBUGF(
                    DBG_ERR,
                    ("Closing entries key of registry\n"));
				// Non-fatal
            }
        }
        else {
            return_value = WSASYSCALLFAILURE;
        }

		// Release registry
        ReleaseExclusiveCatalogAccess (
							m_reg_key,
							m_serial_num, 
							access_key);
    }

	// Unlock catalog object
	ReleaseCatalogLock();
    return return_value;

}  // WriteToRegistry



DCATALOG::~DCATALOG()
/*++

Routine Description:

    This  function  destroys the catalog object.  It takes care of removing and
    dereferecing  all  of  the  catalog  entries  in  the catalog.  This includes
    dereferencing  all  of the DPROVIDER objects referenced by the catalog.  

Arguments:

    None

Return Value:

    None

Implementation Notes:

    lock the catalog
    for each catalog entry
        remove the entry
        dereference the entry
    end for
    close registry key
    unlock the catalog
    delete catalog lock
--*/
{
    PLIST_ENTRY this_linkage;
    PPROTO_CATALOG_ITEM  this_item;
    LONG        lresult;

    DEBUGF(
        DBG_TRACE,
        ("Catalog destructor\n"));

    //
    // Check if we were fully initialized.
    //
    if (m_protocol_list.Flink==NULL) {
        return;
    }
    AcquireCatalogLock();

    while ((this_linkage = m_protocol_list.Flink) != & m_protocol_list) {
        this_item = CONTAINING_RECORD(
            this_linkage,        // address
            PROTO_CATALOG_ITEM,  // type
            m_CatalogLinkage     // field
            );
        RemoveCatalogItem(
            this_item  // CatalogItem
            );
        this_item->Dereference ();
    }  // while (get entry linkage)

#ifdef _WIN64
    if (m_items32!=NULL && m_entries_name32!=sm_entries_name32) {
        while ((this_linkage = m_items32->m_protocol_list.Flink) != & m_items32->m_protocol_list) {
            this_item = CONTAINING_RECORD(
                this_linkage,        // address
                PROTO_CATALOG_ITEM,  // type
                m_CatalogLinkage     // field
                );
            RemoveCatalogItem32(
                this_item  // CatalogItem
                );
            this_item->Dereference ();
        }  // while (get entry linkage)
    }
#endif

    assert( m_num_items == 0 );
    if (m_reg_key!=NULL) {
        lresult = RegCloseKey (m_reg_key);
        if (lresult != ERROR_SUCCESS) {
            DEBUGF (DBG_ERR,
                ("Closing catalog registry key, err: %ld.\n", lresult));
        }
        m_reg_key = NULL;
    }

    ReleaseCatalogLock();
    DeleteCriticalSection( &m_catalog_lock );

}  // ~DCATALOG




VOID
DCATALOG::EnumerateCatalogItems(
    IN CATALOGITERATION  Iteration,
    IN PVOID             PassBack
    )
/*++

Routine Description:

    This  procedure enumerates all of the DPROTO_CATALOG_ITEM structures in the
    catalog  by  calling  the indicated iteration procedure once for each item.
    The called procedure can stop the iteration early by returning FALSE.

    Note  that  the DPROVIDER associated with an enumerated DPROTO_CATALOG_ITEM
    may  be  NULL.   To retrieve DPROTO_CATALOG_ITEM structure that has had its
    DPROVIDER      loaded      and      initialized,      you      can      use
    GetCatalogItemFromCatalogEntryId.

Arguments:

    Iteration - Supplies   a  reference  to  the  catalog  iteration  procedure
                supplied by the client.

    PassBack  - Supplies  a  value uninterpreted by this procedure.  This value
                is  passed  unmodified to the catalog iteration procedure.  The
                client can use this value to carry context between the original
                call site and the iteration procedure.

Return Value:

    None
--*/
{
    PLIST_ENTRY         ListMember;
    PPROTO_CATALOG_ITEM CatalogEntry;
    BOOL                enumerate_more;

    assert(Iteration != NULL);

    enumerate_more = TRUE;

    AcquireCatalogLock();

    ListMember = m_protocol_list.Flink;

    while (enumerate_more && (ListMember != & m_protocol_list)) {
        CatalogEntry = CONTAINING_RECORD(
            ListMember,
            PROTO_CATALOG_ITEM,
            m_CatalogLinkage);
        ListMember = ListMember->Flink;
        enumerate_more = (* Iteration) (
            PassBack,     // PassBack
            CatalogEntry  // CatalogEntry
            );
    } //while

#ifdef _WIN64
    if (m_items32!=NULL && m_entries_name32!=sm_entries_name32) {
        ListMember = m_items32->m_protocol_list.Flink;

        while (enumerate_more && (ListMember != & m_items32->m_protocol_list)) {
            CatalogEntry = CONTAINING_RECORD(
                ListMember,
                PROTO_CATALOG_ITEM,
                m_CatalogLinkage);
            ListMember = ListMember->Flink;
            enumerate_more = (* Iteration) (
                PassBack,     // PassBack
                CatalogEntry  // CatalogEntry
                );
        } //while
    }
#endif

    ReleaseCatalogLock();

}  // EnumerateCatalogItems




INT
DCATALOG::GetCountedCatalogItemFromCatalogEntryId(
    IN  DWORD                     CatalogEntryId,
    OUT PPROTO_CATALOG_ITEM FAR * CatalogItem
    )
/*++

Routine Description:

    This  procedure  retrieves  a  reference  to a catalog item given a catalog
    entry ID to search for.

    The operation takes care of creating, initializing, and setting a DPROVIDER
    object  for the retrieved catalog item if necessary. 

Arguments:

    CatalogEntryId  - Supplies The ID of a catalog entry to be searched for.

    CatalogItem     - Returns a reference to the catalog item with the matching
                      catalog entry ID if it is found, otherwise returns NULL.

Return Value:

  The  function  returns  ERROR_SUCESS  if  successful, otherwise it returns an
  appropriate WinSock error code.
--*/
{
    PLIST_ENTRY         ListMember;
    INT                 ReturnCode;
    PPROTO_CATALOG_ITEM CatalogEntry;

    assert(CatalogItem != NULL);

    // Prepare for early error return
    * CatalogItem = NULL;
    ReturnCode = WSAEINVAL;

    AcquireCatalogLock();

    ListMember = m_protocol_list.Flink;

    while (ListMember != & m_protocol_list) {
        CatalogEntry = CONTAINING_RECORD(
            ListMember,
            PROTO_CATALOG_ITEM,
            m_CatalogLinkage);
        ListMember = ListMember->Flink;
        if (CatalogEntry->GetProtocolInfo()->dwCatalogEntryId==CatalogEntryId) {
            if (CatalogEntry->GetProvider() == NULL) {
                ReturnCode = LoadProvider(
                    CatalogEntry    // CatalogEntry
                    );
                if (ReturnCode != ERROR_SUCCESS) {
                    break;
                }
            }  // if provider is NULL
            CatalogEntry->Reference ();
            *CatalogItem = CatalogEntry;
            ReturnCode = ERROR_SUCCESS;
            break;
        } //if
    } //while

    ReleaseCatalogLock();
    return(ReturnCode);
}  // GetCatalogItemFromCatalogEntryId

INT
DCATALOG::GetCountedCatalogItemFromAddressFamily(
    IN  INT af,
    OUT PPROTO_CATALOG_ITEM FAR * CatalogItem
    )
/*++

Routine Description:

    This  procedure  retrieves  a  reference  to a catalog item given an
    address  to search for.

    The operation takes care of creating, initializing, and setting a DPROVIDER
    object  for the retrieved catalog item if necessary.  This includes setting
    the DPROVIDER object in all catalog entries for the same provider.

Arguments:

    af  - Supplies The address family to be searched for.

    CatalogItem     - Returns a reference to the catalog item with the matching
                      catalog entry ID if it is found, otherwise returns NULL.

Return Value:

  The  function  returns  ERROR_SUCESS  if  successful, otherwise it returns an
  appropriate WinSock error code.
--*/
{
    PLIST_ENTRY         ListMember;
    INT                 ReturnCode;
    PPROTO_CATALOG_ITEM CatalogEntry;

    assert(CatalogItem != NULL);

    // Prepare for early error return
    * CatalogItem = NULL;
    ReturnCode = WSAEINVAL;

    AcquireCatalogLock();

    ListMember = m_protocol_list.Flink;

    while (ListMember != & m_protocol_list) {
        CatalogEntry = CONTAINING_RECORD(
            ListMember,
            PROTO_CATALOG_ITEM,
            m_CatalogLinkage);
        ListMember = ListMember->Flink;

        if (CatalogEntry->GetProtocolInfo()->iAddressFamily == af) {
            if (CatalogEntry->GetProvider() == NULL) {
                ReturnCode = LoadProvider(
                    CatalogEntry    // CatalogEntry
                    );
                if (ReturnCode != ERROR_SUCCESS) {
                    break;
                }
            }  // if provider is NULL
            CatalogEntry->Reference ();
            * CatalogItem = CatalogEntry;
            ReturnCode = ERROR_SUCCESS;
            //
            // Found something, break out.
            //
            break;
        } //if
    } //while

    ReleaseCatalogLock();
    return(ReturnCode);
}



INT
DCATALOG::GetCountedCatalogItemFromAttributes(
    IN  INT     af,
    IN  INT     type,
    IN  INT     protocol,
    IN  DWORD   StartAfterId OPTIONAL,
    OUT PPROTO_CATALOG_ITEM FAR * CatalogItem
    )
/*++

Routine Description:

    Retrieves a PROTO_CATALOG_ITEM reference, choosing an item from the catalog
    based  on  three parameters (af, type, protocol) to determine which service
    provider  is used.  The procedure selects the first transport provider able
    to support the stipulated address family, socket type, and protocol values.
    If "protocol" is not specifieid (i.e., equal to zero).  the default for the
    specified socket type is used.  However, the address family may be given as
    AF_UNSPEC  (unspecified),  in  which  case the "protocol" parameter must be
    specified.   The protocol number to use is particular to the "communication
    domain" in which communication is to take place.

    The operation takes care of creating, initializing, and setting a DPROVIDER
    object  for the retrieved catalog item if necessary. 

Arguments:

    af          - Supplies an address family specification

    type        - Supplies a socket type specification

    protocol    - Supplies  an  address  family  specific  identification  of a
                  protocol  to  be  used with a socket, or 0 if the caller does
                  not wish to specify a protocol.

    StartAfterId - Optionally (non 0) supplies the catalog id of the item 
                    after which to begin enumeration.

    CatalogItem - Returns  a reference to the catalog item that was found to be
                  a suitable match or NULL if no suitable match was found.


Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it returns an
    appropriate WinSock error code.

Implementation Notes:

    For  each  protocol  item  to  test,  match  first  type, then family, then
    protocol.   Keep  track of the "strongest" match found.  If there was not a
    complete  match,  the  strength of the strongest match determines the error
    code returned.
--*/
{
#define MATCHED_NONE 0
#define MATCHED_TYPE 1
#define MATCHED_TYPE_FAMILY 2
#define MATCHED_TYPE_FAMILY_PROTOCOL 3
#define LARGER_OF(a,b) (((a) > (b)) ? (a) : (b))

    PLIST_ENTRY ListMember;
    INT         ReturnCode;
    PPROTO_CATALOG_ITEM CatalogEntry;
    LPWSAPROTOCOL_INFOW ProtoInfo;
    INT match_strength = MATCHED_NONE;

    assert(CatalogItem != NULL);

    // Prepare for early error returns
    * CatalogItem = NULL;

    // Parameter consistency check:
    if (af == 0) {
        if( protocol == 0 ) {
            //
            // These cannot both be zero.
            //

            return WSAEINVAL;
        }

        DEBUGF(
            DBG_WARN,
            ("Use of AF_UNSPEC is discouraged\n"));
        // Unfortunately we cannot treat this as an error case.
    }

    AcquireCatalogLock();

    ListMember = m_protocol_list.Flink;

    // Find the place to start if asked
    if( StartAfterId != 0 ) {
        while (ListMember != & m_protocol_list) {
            CatalogEntry = CONTAINING_RECORD(
                ListMember,
                PROTO_CATALOG_ITEM,
                m_CatalogLinkage);
            ListMember = ListMember->Flink;
            if (CatalogEntry->GetProtocolInfo()->dwCatalogEntryId==StartAfterId)
                break;
        }
    }


    while ((ListMember != & m_protocol_list) &&
        (match_strength < MATCHED_TYPE_FAMILY_PROTOCOL))
    {
        CatalogEntry = CONTAINING_RECORD(
            ListMember,
            PROTO_CATALOG_ITEM,
            m_CatalogLinkage);
        ListMember = ListMember->Flink;
        ProtoInfo = CatalogEntry->GetProtocolInfo();
        if (ProtoInfo->ProtocolChain.ChainLen != LAYERED_PROTOCOL) {
#define TYPE_WILDCARD_VALUE 0
            // Can  this  entry  support  the  requested  socket  type?   Or is the
            // wildcard type specified?
            if ((ProtoInfo->iSocketType == type) ||
                (type == TYPE_WILDCARD_VALUE)) {
                match_strength = LARGER_OF(
                    match_strength,
                    MATCHED_TYPE);

#define FAMILY_WILDCARD_VALUE AF_UNSPEC
                // Can it support the requested address family?  Or is the wildcard
                // family specified?
                if ((ProtoInfo->iAddressFamily == af) ||
                    (af == FAMILY_WILDCARD_VALUE)) {
                    match_strength = LARGER_OF(
                        match_strength,
                        MATCHED_TYPE_FAMILY);

#define PROTO_IN_RANGE(proto,lo,hi) (((proto) >= (lo)) && ((proto) <= (hi)))
#define IS_BIT_SET(test_val,bitmask) (((test_val) & (bitmask)) == (bitmask))
                    // Is  the  requested  protcol  in  range?  Or is the requested
                    // protocol zero and entry supports protocol zero?
                    {  // declare block
                        int range_lo = ProtoInfo->iProtocol;
                        int range_hi = range_lo + ProtoInfo->iProtocolMaxOffset;
                        if (PROTO_IN_RANGE(protocol, range_lo, range_hi) ||
                            ((protocol == 0) &&
                             IS_BIT_SET(
                                 ProtoInfo->dwProviderFlags,
                                 PFL_MATCHES_PROTOCOL_ZERO))) {
                            match_strength = LARGER_OF(
                                match_strength,
                                MATCHED_TYPE_FAMILY_PROTOCOL);
                        } // if protocol supported
                    } // declare block
                } //if address family supported
            } //if type supported
        } //if not layered protocol
    }  // while


    // Select  an  appropriate error code for "no match" cases, or success code
    // to proceed.
    switch (match_strength) {
        case MATCHED_NONE:
            ReturnCode = WSAESOCKTNOSUPPORT;
            break;

        case MATCHED_TYPE:
            ReturnCode = WSAEAFNOSUPPORT;
            break;

        case MATCHED_TYPE_FAMILY:
            ReturnCode = WSAEPROTONOSUPPORT;
            break;

        case MATCHED_TYPE_FAMILY_PROTOCOL:
            // A full match found, continue
            ReturnCode = ERROR_SUCCESS;
            break;

        default:
            DEBUGF(
                DBG_ERR,
                ("Should not get here\n"));
            ReturnCode = WSASYSCALLFAILURE;

    }  // switch (match_strength)

    if (ReturnCode == ERROR_SUCCESS) {
        if (CatalogEntry->GetProvider() == NULL) {
            ReturnCode = LoadProvider(
                CatalogEntry
                );
            if (ReturnCode != ERROR_SUCCESS) {
                DEBUGF(
                    DBG_ERR,
                    ("Error (%lu) loading chosen provider\n",
                    ReturnCode));
            } // else
        }  // if provider is NULL
    }  // if ReturnCode is ERROR_SUCCESS

    if (ReturnCode == ERROR_SUCCESS) {
        CatalogEntry->Reference ();
        * CatalogItem = CatalogEntry;
    } // if ReturnCode is ERROR_SUCCESS

    ReleaseCatalogLock();

    return ReturnCode;

}  // GetCountedCatalogItemFromAttributes


INT
DCATALOG::FindIFSProviderForSocket(
    SOCKET Socket
    )

/*++

Routine Description:

    This procedure searches the installed providers that support IFS handles
    for one that recognizes the given socket. If one is found, then the
    necessary internal infrastructure is established for supporting the
    socket.

Arguments:

    Socket - The socket.

Return Value:

    If  the  function  is  successful,  it  returns ERROR_SUCCESS, otherwise it
    returns an appropriate WinSock error code.

--*/

{

    INT result;
    INT error;
    INT optionLength;
    PLIST_ENTRY listEntry;
    PPROTO_CATALOG_ITEM catalogItem;
    PDPROVIDER provider;
    WSAPROTOCOL_INFOW protocolInfo;
    SOCKET modifiedSocket;
    DWORD  serial_num;

    //
    // Scan the installed providers.
    //

    AcquireCatalogLock();

Restart:
    for( listEntry = m_protocol_list.Flink ;
         listEntry != &m_protocol_list ;
         listEntry = listEntry->Flink ) {

        catalogItem = CONTAINING_RECORD(
                          listEntry,
                          PROTO_CATALOG_ITEM,
                          m_CatalogLinkage
                          );

        //
        // Skip non-IFS providers.
        //

        if( ( catalogItem->GetProtocolInfo()->dwServiceFlags1 &
                XP1_IFS_HANDLES ) == 0 ) {

            continue;

        }

        //
        // Load the provider if necessary.
        //

        provider = catalogItem->GetProvider();

        if( provider == NULL ) {

            result = LoadProvider(
                         catalogItem
                         );

            if( result != NO_ERROR ) {

                //
                // Could not load the provider. Press on regardless.
                //

                continue;

            }
            provider = catalogItem->GetProvider ();

            assert( provider != NULL );
        }

        //
        // Reference catalog item, remeber current catalog serial
        // number, and release the lock to prevent a deadlock
        // in case provider waits in another thread on catalog lock
        // while holding on of its locks which it may need to acquire
        // while we are calling into it.
        //
        catalogItem->Reference ();
        serial_num = m_serial_num;
        ReleaseCatalogLock ();

        //
        // Try a getsockopt( SO_PROTOCOL_INFOW ) on the socket to determine
        // if the current provider recognizes it. This has the added benefit
        // of returning the dwCatalogEntryId for the socket, which we can
        // use to call WPUModifyIFSHandle().
        //

        optionLength = sizeof(protocolInfo);

        result = provider->WSPGetSockOpt(
                     Socket,
                     SOL_SOCKET,
                     SO_PROTOCOL_INFOW,
                     (char FAR *)&protocolInfo,
                     &optionLength,
                     &error
                     );

        // Do not need catalog item any longer
        catalogItem->Dereference ();
        if( result != ERROR_SUCCESS) {
            
            //
            // It is possible that while we were talking to the provider
            // application has called WSACleanup in another thread.
            // Do this check, which although is not fool-proof
            // but should prevent AV's in most cases.
            // Yes, it is possible to create fool-proof code by
            // implementing ref-counting of the process object,
            // but it is expensive and does not solve the real problem:
            //   IF APPLICATION TRIES TO CLOSE THE SOCKET HANDLE OR
            //   CLEANUP WINSOCK (which closes all socket handles)
            //   IT HAS TO ACCEPT THE FACT THAT IT MAY ENCOUNTER AN
            //   EXCEPTION (e.g. INVALID_HANDLE).
            //
            if (DPROCESS::GetCurrentDProcess ()==NULL) {
                break;
            }

            //
            // WPUGetSockOpt() failed, probably because the socket is
            // not recognized. Continue on and try another provider.
            //

            AcquireCatalogLock ();
            //
            // Check if catalog has changed while we are calling
            // into the provider, if so, restart the lookup
            // otherwise, press on.
            //
            if (serial_num==m_serial_num)
                continue;
            else
                goto Restart;

        }

        //
        // Call WPUModifyIFSHandle(). The current implementation doesn't
        // actually modify the handle, but it does setup the necessary
        // internal infrastructure for the socket.
        //
        // Note that provider might have already called this function,
        // in which case our call will have no effect (because we support
        // layered providers that reuse base provider sockets which
        // employ the same method.
        //
        //
        // !!! We should move the "create the DSocket object and setup
        //     all of the internal stuff" from WPUModifyIFSHandle() into
        //     a common function shared with this function.
        //

        modifiedSocket = WPUModifyIFSHandle(
                             protocolInfo.dwCatalogEntryId,
                             Socket,
                             &error
                             );

        if( modifiedSocket == INVALID_SOCKET ) {

            //
            // This error is not continuable, as the provider has
            // recognized the socket, but for some reason we cannot
            // create the necessary internal infrastructure for the
            // socket. We have no choice here except to just bail out
            // and fail the request.
            //
            // !!! The provider may have established internal state for
            //     this socket. Should we invoke provider->WSPCloseSocket()
            //     on it now to remove any such state?
            //

            return WSAENOTSOCK;

        }

        //
        // Success!
        //

        assert( modifiedSocket == Socket );
        return ERROR_SUCCESS;

    }

    //
    // If we made it this far, then no provider recognized the socket.
    //

    ReleaseCatalogLock();
    return WSAENOTSOCK;

} // FindIFSProviderForSocket


DWORD
DCATALOG::AllocateCatalogEntryId (
    VOID
    )
{
    DWORD   id;
    AcquireCatalogLock ();
    assert (m_reg_key!=NULL);

    if (m_next_id!=0)
        id = m_next_id++;
    else
        id = 0;

    ReleaseCatalogLock ();
    return id;
}



VOID
DCATALOG::AppendCatalogItem(
    IN  PPROTO_CATALOG_ITEM  CatalogItem
    )
/*++

Routine Description:

    This procedure appends a catalog item to the end of the (in-memory) catalog
    object.   It becomes the last item in the catalog.  The catalog information
    in the registry is NOT updated.

Arguments:

    CatalogItem - Supplies a reference to the catalog item to be added.

Return Value:

    None
--*/
{
    assert(CatalogItem != NULL);
    assert (IsListEmpty (&CatalogItem->m_CatalogLinkage));

    InsertTailList(
        & m_protocol_list,               // ListHead
        & CatalogItem->m_CatalogLinkage  // Entry
       );
    m_num_items++;
}  // AppendCatalogItem


#ifdef _WIN64
VOID
DCATALOG::AppendCatalogItem32(
    IN  PPROTO_CATALOG_ITEM  CatalogItem
    )
/*++

Routine Description:

    This procedure appends a catalog item to the end of the (in-memory) catalog
    object.   It becomes the last item in the catalog.  The catalog information
    in the registry is NOT updated.

Arguments:

    CatalogItem - Supplies a reference to the catalog item to be added.

Return Value:

    None
--*/
{
    assert(CatalogItem != NULL);
    assert(IsListEmpty (&CatalogItem->m_CatalogLinkage));
    assert(m_items32!=NULL && m_entries_name32!=sm_entries_name32);

    InsertTailList(
        & m_items32->m_protocol_list,               // ListHead
        & CatalogItem->m_CatalogLinkage  // Entry
       );
    m_items32->m_num_items++;
}  // AppendCatalogItem32
#endif


VOID
DCATALOG::RemoveCatalogItem(
    IN  PPROTO_CATALOG_ITEM  CatalogItem
    )
/*++

Routine Description:

    This  procedure removes a catalog item from the (in-memory) catalog object.
    The catalog information in the registry is NOT updated.

Arguments:

    CatalogItem - Supplies a reference to the catalog item to be removed.

Return Value:

    None
--*/
{
    assert(CatalogItem != NULL);
    assert(!IsListEmpty (&CatalogItem->m_CatalogLinkage));

    RemoveEntryList(
        & CatalogItem->m_CatalogLinkage  // Entry
        );
#if defined(DEBUG_TRACING)
    InitializeListHead (&CatalogItem->m_CatalogLinkage);
#endif
    assert(m_num_items > 0);
    m_num_items--;
}  // RemoveCatalogItem


#ifdef _WIN64
VOID
DCATALOG::RemoveCatalogItem32(
    IN  PPROTO_CATALOG_ITEM  CatalogItem
    )
/*++

Routine Description:

    This  procedure removes a catalog item from the (in-memory) catalog object.
    The catalog information in the registry is NOT updated.

Arguments:

    CatalogItem - Supplies a reference to the catalog item to be removed.

Return Value:

    None
--*/
{
    assert(CatalogItem != NULL);
    assert(!IsListEmpty (&CatalogItem->m_CatalogLinkage));

    RemoveEntryList(
        & CatalogItem->m_CatalogLinkage  // Entry
        );
#if defined(DEBUG_TRACING)
    InitializeListHead (&CatalogItem->m_CatalogLinkage);
#endif
    assert(m_items32->m_num_items > 0);
    m_items32->m_num_items--;
}  // RemoveCatalogItem32
#endif

LPSTR
DCATALOG::GetCurrentCatalogName()
{
    return CATALOG_NAME;

} // GetCurrentCatalogName


INT
DCATALOG::LoadProvider(
    IN PPROTO_CATALOG_ITEM CatalogEntry
    )
/*++

Routine Description:

    Load   the   provider  described  by  CatalogEntry and set it into
    catalog entry

Arguments:

    CatalogEntry - Supplies  a reference to a protocol catalog entry describing
                   the provider to load.


Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it returns an
    appropriate WinSock error code.
--*/
{
    INT ReturnCode = ERROR_SUCCESS;
    PDPROVIDER LocalProvider;

    assert(CatalogEntry != NULL);

    // Serialize provider loading/unloading
    AcquireCatalogLock ();

    // Check if provider is loaded under the lock
    if (CatalogEntry->GetProvider ()==NULL) {

        // First attempt to find another instance of the provider
        LocalProvider = FindAnotherProviderInstance (
                                CatalogEntry->GetProviderId ());
        if (LocalProvider != NULL) {
            // Success, just set it
            CatalogEntry->SetProvider (LocalProvider);
            ReturnCode = ERROR_SUCCESS;
        }
        else {
            // Create and attempt to load provider object
            LocalProvider = new(DPROVIDER);
            if (LocalProvider !=NULL ) {

                ReturnCode = LocalProvider->Initialize(
                    CatalogEntry->GetLibraryPath(),
                    CatalogEntry->GetProtocolInfo()
                    );
                if (ERROR_SUCCESS == ReturnCode) {
                    CatalogEntry->SetProvider (LocalProvider);
                } //if

                LocalProvider->Dereference ();
            } //if
            else {
                DEBUGF(
                    DBG_ERR,
                    ("Allocating a DPROVIDER object\n"));
                ReturnCode = WSA_NOT_ENOUGH_MEMORY;
            }
        } // else
    } // if provider not loaded
  
    // Serialize provider loading/unloading
    ReleaseCatalogLock ();
    return(ReturnCode);
}  // LoadProvider




PDPROVIDER
DCATALOG::FindAnotherProviderInstance(
    IN LPGUID ProviderId
    )
/*++

Routine Description:

    Check  all catalog enteries for a provider with the pointer to the provider
    object for the provider.

Arguments:

    ProviderId - Supplies the Provider ID for the catalog enteries to check in.


Return Value:

    Pointer to provider object if found

Implementation notes:

--*/
{
    PLIST_ENTRY ListMember;
    PPROTO_CATALOG_ITEM CatalogEntry;
    PDPROVIDER   LocalProvider;

    ListMember = m_protocol_list.Flink;

    while (ListMember != & m_protocol_list)
    {
        CatalogEntry = CONTAINING_RECORD(
            ListMember,
            PROTO_CATALOG_ITEM,
            m_CatalogLinkage);
        ListMember = ListMember->Flink;
        LocalProvider = CatalogEntry->GetProvider ();
        if( (LocalProvider!=NULL) // This check is much less expensive
                && (*(CatalogEntry->GetProviderId()) == *ProviderId)) {
            return LocalProvider;
        } //if
    } //while

    return NULL;
}  // FindAnotherProviderInstance
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\autodial.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    autodial.c

Abstract:

    This module contains Autodial support for Winsock.

Author:

    Anthony Discolo (adiscolo)    15-May-1996

Revision History:

--*/

#include "precomp.h"

#ifdef RASAUTODIAL

//
// Registry value under the Winsock
// registry root that contains the
// path of the Autodial DLL.
//
#define REGVAL_AUTODIAL_DLL    "AutodialDLL"

//
// The default Autodial DLL if one
// isn't defined in the registry.
//
#define AUTODIAL_DLL            "rasadhlp.dll"

//
// The well-known entry points in the
// Autodial DLL that we call to
// invoke an Autodial attempt.
//
#define WSATTEMPTAUTODIALADDR       "WSAttemptAutodialAddr"
#define WSATTEMPTAUTODIALNAME       "WSAttemptAutodialName"
#define WSNOTESUCCESSFULHOSTENTLOOKUP  "WSNoteSuccessfulHostentLookup"

//
// Definition of the Autodial APIs.
//
typedef int (*WSAttemptAutodialAddrProc)(
    IN const struct sockaddr FAR *name,
    IN int namelen
    );

typedef int (*WSAttemptAutodialNameProc)(
    IN const LPWSAQUERYSETW lpqsRestrictions
    );

typedef void (*WSNoteSuccessfulHostentLookupProc)(
    IN const char FAR *name,
    IN const ULONG ipaddr
    );

CRITICAL_SECTION AutodialHelperLockG;
BOOLEAN fAutodialHelperInitG;
HINSTANCE hAutodialHelperDllG;
WSAttemptAutodialAddrProc lpfnWSAttemptAutodialAddrG;
WSAttemptAutodialNameProc lpfnWSAttemptAutodialNameG;
WSNoteSuccessfulHostentLookupProc lpfnWSNoteSuccessfulHostentLookupG;



VOID
InitializeAutodial(VOID)

/*++

Routine Description:
    Initialize the resources necessary for loading
    the Autodial helper DLL.

Arguments:
    None.

Return Value:
    None.

--*/

{
    InitializeCriticalSection(&AutodialHelperLockG);
} // InitializeAutodial



VOID
UninitializeAutodial(VOID)

/*++

Routine Description:
    Free the Autodial helper DLL if it has been loaded.

Arguments:
    None.

Return Value:
    None.

--*/

{
    EnterCriticalSection(&AutodialHelperLockG);
    if (hAutodialHelperDllG != NULL) {
        FreeLibrary(hAutodialHelperDllG);
        hAutodialHelperDllG = NULL;
    }
    LeaveCriticalSection(&AutodialHelperLockG);
    DeleteCriticalSection (&AutodialHelperLockG);
} // UninitializeAutodial



BOOL
LoadAutodialHelperDll(void)

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    HKEY hKey;
    BOOL bSuccess;

    EnterCriticalSection(&AutodialHelperLockG);
    if (!fAutodialHelperInitG) {
        PCHAR pszPath;
        //
        // Bail out if we were unable to allocate
        // the path string.
        //
        pszPath = new char[MAX_PATH];
        if (pszPath == NULL)
            return FALSE;
        //
        // Read the registry to determine the
        // location of the Autodial helper DLL.
        //
        hKey = OpenWinSockRegistryRoot();
        if (hKey != NULL) {
            bSuccess = ReadRegistryEntry(
                         hKey,
                         REGVAL_AUTODIAL_DLL,
                         (PVOID)pszPath,
                         MAX_PATH,
                         REG_SZ);
            CloseWinSockRegistryRoot(hKey);
            if (bSuccess)
                hAutodialHelperDllG = LoadLibrary(pszPath);
        }
        delete pszPath;

        //
        // If the registry key doesn't exist, then
        // try to load the default helper DLL.
        //
        if (hAutodialHelperDllG == NULL)
            hAutodialHelperDllG = LoadLibrary(AUTODIAL_DLL);
        if (hAutodialHelperDllG != NULL) {
            lpfnWSAttemptAutodialAddrG = (WSAttemptAutodialAddrProc)
              GetProcAddress(hAutodialHelperDllG, WSATTEMPTAUTODIALADDR);
            lpfnWSAttemptAutodialNameG = (WSAttemptAutodialNameProc)
              GetProcAddress(hAutodialHelperDllG, WSATTEMPTAUTODIALNAME);
            lpfnWSNoteSuccessfulHostentLookupG = (WSNoteSuccessfulHostentLookupProc)
              GetProcAddress(hAutodialHelperDllG, WSNOTESUCCESSFULHOSTENTLOOKUP);
        }
        fAutodialHelperInitG = TRUE;
    }
    LeaveCriticalSection(&AutodialHelperLockG);

    return (hAutodialHelperDllG != NULL);
} // LoadAutodialHelperDll



BOOL
WSAttemptAutodialAddr(
    IN const struct sockaddr FAR *name,
    IN int namelen
    )

/*++

Routine Description:
    Attempt an Autodial connection given the parameters
    to an unsuccessful call to connect().

Arguments:
    name: a pointer to the sockaddr structure used in
        the call to connect().

    namelen: the length of the name parameter.

Return Value:
    TRUE if the connection was made successfully,
    FALSE otherwise.

--*/

{
    //
    // Load helper DLL, if necessary.
    //
    if (!LoadAutodialHelperDll() || lpfnWSAttemptAutodialAddrG == NULL)
        return FALSE;
    //
    // Call the Autodial DLL.  It will return
    // TRUE if a new connection was made, and
    // FALSE otherwise.
    //
    return (*lpfnWSAttemptAutodialAddrG)(name, namelen);
} // WSAttemptAutoDialAddr



BOOL
WSAttemptAutodialName(
    IN const LPWSAQUERYSETW lpqsRestrictions
    )

/*++

Routine Description:
    Attempt an autodial connection given the parameters
    to an unsuccessful to WSALookupServiceNext().

Arguments:
    lpqsRestrictions: a pointer to the WSAQUERYSETW
        structure used in the call to
        WSALookupServiceBegin().

Return Value:
    TRUE if the connection was made successfully,
    FALSE otherwise.

--*/

{
    //
    // Load helper DLL, if necessary.
    //
    if (!LoadAutodialHelperDll() || lpfnWSAttemptAutodialNameG == NULL)
        return FALSE;
    //
    // Call the Autodial DLL.  It will return
    // TRUE if a new connection was made, and
    // FALSE otherwise.
    //
    return (*lpfnWSAttemptAutodialNameG)(lpqsRestrictions);
} // WSAttemptAutoDialName



VOID
WSNoteSuccessfulHostentLookup(
    IN const char FAR *name,
    IN const ULONG ipaddr
    )

/*++

Routine Description:
    Give Autodial information about successful name
    resolutions via gethostbyname().  This is
    useful for resolvers like DNS where it is impossible
    to get complete alias information about aliases via a
    low-level address.

    Ultimately, this should be called from WSLookupServiceNext(),
    but it's impossible at that level to determine what format
    the results are in.

Arguments:
    name: a pointer to the DNS name

    ipaddr: the IP address

Return Value:
    None.

--*/

{
    //
    // Load helper DLL, if necessary.
    //
    if (!LoadAutodialHelperDll() || lpfnWSNoteSuccessfulHostentLookupG == NULL)
        return;
    //
    // Call the Autodial DLL.
    //
    (*lpfnWSNoteSuccessfulHostentLookupG)(name, ipaddr);
} // WSNoteSuccessulNameLookup

#endif // RASAUTODIAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\dllmain.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    dllmain.cpp

Abstract:
    This module contains the DllMain entry point for winsock2 dll to
    control the global init and shutdown of the DLL.

Author:

    Dirk Brandewie dirk@mink.intel.com  14-06-1995

[Environment:]

[Notes:]

Revision History:

    22-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Moved includes to precomp.h

--*/

#include "precomp.h"
#pragma warning(disable: 4001)      /* Single-line comment */

#if defined(DEBUG_TRACING)
#include "dthook.h"
#endif // defined(DEBUG_TRACING)

DWORD gdwTlsIndex = TLS_OUT_OF_INDEXES;
HINSTANCE gDllHandle = NULL;


BOOL WINAPI DllMain(
    IN HINSTANCE hinstDll,
    IN DWORD fdwReason,
    LPVOID lpvReserved
    )
{
    switch (fdwReason) {

    case DLL_PROCESS_ATTACH:
        // DLL is attaching to the address
        // space of the current process.

        // Save DLL handle
        gDllHandle = hinstDll;

        gdwTlsIndex = TlsAlloc();
        if (gdwTlsIndex==TLS_OUT_OF_INDEXES) {
            return FALSE;
        }

        // Use private heap on MP machines to
        // avoid lock contention with other DLLs
        {
            SYSTEM_INFO sysInfo;
            GetSystemInfo (&sysInfo);

            if (sysInfo.dwNumberOfProcessors>1) {
                gHeap = HeapCreate (0, 0, 0);
                if (gHeap==NULL) {
                    gHeap = GetProcessHeap ();
                }
            }
            else
                gHeap = GetProcessHeap ();
        }


        {
            BOOLEAN startup = FALSE
#ifdef RASAUTODIAL
                    , autodial = FALSE
#endif
#if defined(DEBUG_TRACING)
                    , dthook = FALSE
#endif // defined(DEBUG_TRACING)
                    ;

                    

            __try {
                CreateStartupSynchronization();
                startup = TRUE;
#ifdef RASAUTODIAL
                InitializeAutodial();
                autodial = TRUE;
#endif // RASAUTODIAL

#if defined(DEBUG_TRACING)
                DTHookInitialize();
                dthook = TRUE;
#endif // defined(DEBUG_TRACING)

            }
            __except (WS2_EXCEPTION_FILTER ()) {
                goto cleanup;
            }
            if (!SockAsyncGlobalInitialize())
                goto cleanup;
            break;

        cleanup:
#if defined(DEBUG_TRACING)
            if (dthook) {
                DTHookShutdown();
            }
#endif // defined(DEBUG_TRACING)
#ifdef RASAUTODIAL
            if (autodial) {
                UninitializeAutodial();
            }
#endif // RASAUTODIAL
            if (startup) {
                DestroyStartupSynchronization();
            }

            gDllHandle = NULL;

            return FALSE;
        }

   case DLL_THREAD_ATTACH:
        // A new thread is being created in the current process.
        break;

   case DLL_THREAD_DETACH:
        // A thread is exiting cleanly.
        DTHREAD::DestroyCurrentThread();
        break;

   case DLL_PROCESS_DETACH:
        //
        // Check if we were initialized.
        //
        if (gDllHandle==NULL)
            break;

        // The calling process is detaching
        // the DLL from its address space.
        //
        // Note that lpvReserved will be NULL if the detach is due to
        // a FreeLibrary() call, and non-NULL if the detach is due to
        // process cleanup.
        //

        if( lpvReserved == NULL ) {
            PDPROCESS  CurrentProcess;

            // A thread is exiting cleanly (if we do not get a separate 
            // DLL_THREAD_DETACH).
            DTHREAD::DestroyCurrentThread();

            CurrentProcess = DPROCESS::GetCurrentDProcess();
            if (CurrentProcess!=NULL) {
                delete CurrentProcess;
            }

            DTHREAD::DThreadClassCleanup();
            DSOCKET::DSocketClassCleanup();
            SockAsyncGlobalTerminate();
            DestroyStartupSynchronization();
            if ((gHeap!=NULL) && (gHeap!=GetProcessHeap ())) {
                HeapDestroy (gHeap);
            }
            TlsFree (gdwTlsIndex);

#if defined(DEBUG_TRACING)
            DTHookShutdown();
#endif // defined(DEBUG_TRACING)

#ifdef RASAUTODIAL
            UninitializeAutodial();
#endif // RASAUTODIAL
        }

        //
        // Set the function prolog pointer to point to Prolog_Detached just
        // in case some DLL trys to invoke one of our entrypoints
        // *after* we've been detached...
        //

        PrologPointer = &Prolog_Detached;

        gDllHandle = NULL;
        break;
    }


    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\dprocess.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    dprocess.cpp

Abstract:

    This module contains the implementation of the dprocess class.

Author:

    Dirk Brandewie dirk@mink.intel.com  11-JUL-1995

Revision History:

    21-Aug-1995 dirk@mink.intel.com
       Cleanup after code review. Moved single line functions to header file as
       inlines. Added debug/trace code. Changed LIST_ENTRY's and
       CRITICAL_SECTION's from pointers to being embedded in the dprocess
       object.

--*/

#include "precomp.h"

// This is a static class member. It contains a pointer to the dprocess object
// for the current process.
PDPROCESS DPROCESS::sm_current_dprocess=NULL;



DPROCESS::DPROCESS(
    )
/*++

Routine Description:

    DPROCESS  object constructor.  Creates and returns a DPROCESS object.  Note
    that  the DPROCESS object has not been fully initialized.  The "Initialize"
    member  function  must  be  the  first  member  function  called on the new
    DPROCESS object.

    In  the Win32 environment, only one DPROCESS object may be in existence for
    a  process.   It  is  the  caller's  responsibility  to  ensure  that  this
    restriction is met.

Arguments:

    None

Return Value:

    Returns a pointer to the new DPROCESS object or NULL if a memory allocation
    failed.

--*/
{
    //
    // Initialize the list objects
    //
#if 0
    // Not used because of inherent race conditions.
    InitializeListHead(&m_thread_list);
#endif

    // Set our data members to known values.
    m_reference_count   = 0;
    m_ApcHelper         = NULL;
    m_HandleHelper      = NULL;
    m_NotificationHelper = NULL;
    m_protocol_catalog  = NULL;
    m_proto_catalog_change_event = NULL;
    m_namespace_catalog = NULL;
    m_ns_catalog_change_event = NULL;
    m_version           = WINSOCK_HIGH_API_VERSION; // until proven otherwise...
    m_lock_initialized = FALSE;
} //DPROCESS




INT
DPROCESS::Initialize(
    )
/*++

Routine Description:

    Completes  the  initialization  of  the DPROCESS object.  This must be the
    first  member  function  called  for  the DPROCESS object.  This procedure
    should be called only once for the object.

Arguments:

  None

Return Value:

  The  function returns 0 if successful.  Otherwise it returns an appropriate
  WinSock error code if the initialization cannot be completed.

--*/
{
    INT ReturnCode = WSAEFAULT;  // user return value
    HKEY RegistryKey = NULL;

    TRY_START(mem_guard){

        //
        // Initialize our critical sections
        //
        __try {
            InitializeCriticalSection( &m_thread_list_lock );
        }
        __except (WS2_EXCEPTION_FILTER ()) {
            ReturnCode = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(mem_guard);
        }
        m_lock_initialized = TRUE;


        RegistryKey = OpenWinSockRegistryRoot();
        if (!RegistryKey) {
            DEBUGF(
                DBG_ERR,
                ("Opening Winsock Registry Root\n"));
            ReturnCode = WSASYSCALLFAILURE;
            TRY_THROW(mem_guard);
        } //if

        m_proto_catalog_change_event = CreateEvent(
                    (LPSECURITY_ATTRIBUTES) NULL,
                    TRUE,       // manual reset
                    FALSE,      // initially non-signaled
                    NULL        // unnamed
                    );
        if (m_proto_catalog_change_event==NULL) {
			ReturnCode = GetLastError ();
            DEBUGF(
                DBG_ERR,
                ("Creating protocol catalog change event, err:%ld\n",
                ReturnCode));
            TRY_THROW(mem_guard);
        }

        //
        // Build the protocol catalog
        //

        m_protocol_catalog = new(DCATALOG);
        if (!m_protocol_catalog) {
            DEBUGF(
                DBG_ERR,
                ("Allocating dcatalog object\n"));
            ReturnCode = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(mem_guard);
        } //if

        ReturnCode = m_protocol_catalog->InitializeFromRegistry(
                            RegistryKey,
                            m_proto_catalog_change_event);
        if (ERROR_SUCCESS != ReturnCode) {
            DEBUGF(
                DBG_ERR,
                ("Initializing protocol catalog from registry\n"));
            TRY_THROW(mem_guard);
        } //if


        m_ns_catalog_change_event = CreateEvent(
                    (LPSECURITY_ATTRIBUTES) NULL,
                    TRUE,       // manual reset
                    FALSE,      // initially non-signaled
                    NULL        // unnamed
                    );
        if (m_ns_catalog_change_event==NULL) {
			ReturnCode = GetLastError ();
            DEBUGF(
                DBG_ERR,
                ("Creating ns catalog change event, err:%ld\n",
                ReturnCode));
            TRY_THROW(mem_guard);
        }

        //
        // Build the namespace catalog
        //

        m_namespace_catalog = new(NSCATALOG);
        if (!m_namespace_catalog) {
            DEBUGF(
                DBG_ERR,
                ("Allocating nscatalog object\n"));
            ReturnCode = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(mem_guard);
        } //if

        ReturnCode = m_namespace_catalog->InitializeFromRegistry (
                            RegistryKey,                // ParentKey
                            m_ns_catalog_change_event   // ChangeEvent
                            );
        if (ERROR_SUCCESS != ReturnCode) {
            DEBUGF(
                DBG_ERR,
                ("Initializing name space catalog from registry\n"));
            TRY_THROW(mem_guard);
        } //if


        // Set helper object pointers to null
        m_ApcHelper = NULL;
        m_HandleHelper = NULL;
        m_NotificationHelper = NULL;

    } TRY_CATCH(mem_guard) {
		assert (ReturnCode!=ERROR_SUCCESS);
        if (m_protocol_catalog!=NULL) {
            delete(m_protocol_catalog);
            m_protocol_catalog = NULL;
        }

        if (m_proto_catalog_change_event!=NULL) {
            CloseHandle (m_proto_catalog_change_event);
            m_proto_catalog_change_event = NULL;
        }

        if (m_namespace_catalog!=NULL) {
            delete(m_namespace_catalog);
            m_namespace_catalog = NULL;
        }

        if (m_ns_catalog_change_event!=NULL) {
            CloseHandle (m_ns_catalog_change_event);
            m_ns_catalog_change_event = NULL;
        }

    } TRY_END(mem_guard);

    { // declaration block
        LONG close_result;
        if (RegistryKey) {
            close_result = RegCloseKey(
                RegistryKey);  // hkey
            assert(close_result == ERROR_SUCCESS);
        } // if
    } // declaration block

    return (ReturnCode);
} //Initialize

BOOL  
DeleteSockets(
    LPVOID              EnumCtx,
    LPWSHANDLE_CONTEXT  HContext
    ) {
    return ((PDPROCESS)EnumCtx)->DSocketDetach (HContext);
}

BOOL
DPROCESS::DSocketDetach (
    IN LPWSHANDLE_CONTEXT   HContext
    )
{
    PDSOCKET    Socket = static_cast<PDSOCKET>(HContext);
    //
    // Remove socket from the table, so no-one can find and reference
    // it again
    //
    Socket->DisassociateSocketHandle ();

    //
    // For non-IFS provider we force socket closure because provider
    // won't be able to find this socket anymore
    //
    if (!Socket->IsProviderSocket ()) {
        if (m_HandleHelper) {
            WahCloseSocketHandle (m_HandleHelper, Socket->GetSocketHandle ());
        }
    }

    //
    // Drop active reference on the socket.
    // No-one can find it anymore and thus no-one can call closesocket 
    // or WPUCloseSocket handle on it to remove active reference.
    //
    Socket->DropDSocketReference ();
    return TRUE;
}


BOOL
CleanupProtocolProviders (
    IN PVOID                PassBack,
    IN PPROTO_CATALOG_ITEM  CatalogEntry
    )
{
	PDPROVIDER		Provider;

	Provider = CatalogEntry->GetProvider ();
	if (Provider!=NULL) {
		INT	ErrorCode, ReturnValue;
        //
        // Set exception handler around this call since we
        // hold critical section (catalog lock).
        //
        __try {
		    ReturnValue = Provider->WSPCleanup (&ErrorCode);
		    if (ReturnValue!=NO_ERROR) {
			    DEBUGF (DBG_WARN,
				    ("Calling provider %ls cleanup function, ret: %ld, err: %ld.\n",
				    CatalogEntry->GetProtocolInfo()->szProtocol,
				    ReturnValue,
				    ErrorCode));
		    }
        }
        __except (WS2_EXCEPTION_FILTER ()) {
            DEBUGF(DBG_ERR, ("Unhandled exception in WSPCleanup for provider %ls @ %p, code:%lx\n",
                    CatalogEntry->GetProtocolInfo()->szProtocol,
                    Provider, GetExceptionCode()));
            assert (FALSE);
        }
	}

	return TRUE;
}


BOOL
CleanupNamespaceProviders (
    IN PVOID                PassBack,
    IN PNSCATALOGENTRY      CatalogEntry
    )
{
	PNSPROVIDER		Provider;

	Provider = CatalogEntry->GetProvider ();
	if (Provider!=NULL) {
		INT	ReturnValue;
        //
        // Set exception handler around this call since we
        // hold critical section (catalog lock).
        //
        __try {
    		ReturnValue = Provider->NSPCleanup ();
		    if (ReturnValue!=NO_ERROR) {
			    DEBUGF (DBG_WARN,
				    ("Calling provider %ls cleanup function, ret: %ld, err: %ld.\n",
				    CatalogEntry->GetProviderDisplayString (),
				    ReturnValue,
				    GetLastError ()));
		    }
        }
        __except (WS2_EXCEPTION_FILTER ()) {
            DEBUGF(DBG_ERR, ("Unhandled exception in NSPCleanup for provider %ls @ %p, code:%lx\n",
                    CatalogEntry->GetProviderDisplayString (),
                    Provider, GetExceptionCode()));
            assert (FALSE);
        }
	}

	return TRUE;
}


DPROCESS::~DPROCESS()
/*++

Routine Description:

    DPROCESS  object  destructor.   This  procedure  has  the responsibility to
    perfrom any required shutdown operations for the DPROCESS object before the
    object  memory  is  deallocated.   The caller is required to do removal and
    destruction  of  all explicitly-attached objects (e.g., DPROVIDER, DSOCKET,
    DTHREAD).   Removal  or  shutdown  for  implicitly-attached  objects is the
    responsibility of this function.

Arguments:

    None

Return Value:

    None

--*/
{

    //
    // Check if initialization succeeded
    //
    if (!m_lock_initialized)
        return;

    sm_current_dprocess = NULL;

    //
    // Walk the list of sockets removing each socket from the list and
    // deleting the socket
    //

    if (DSOCKET::sm_context_table)
    {
        WahEnumerateHandleContexts (DSOCKET::sm_context_table,
                                    DeleteSockets,
                                    this
                                    );
    }


    //
    // this has been removed to eliminate the race with the thread
    // detach code  which also tries to delete the thread. It is
    // impossibe to use a mutex since holding up the thread detach
    // code ties up the PEB mutex.
    // Doing this delete is desirable as it cleans up
    // memory ASAP. The only trouble is it doesn't work -- do you
    // want it fast or do you want it right?
    //
#if 0
    while (!IsListEmpty(&m_thread_list)) {
        Thread = CONTAINING_RECORD(
            m_thread_list.Flink,
            DTHREAD,
            m_dprocess_linkage);
        DEBUGF(DBG_TRACE, ("Deleting thread\n"));
        DThreadDetach(Thread);
        delete(Thread);
    } //while
#endif

    // If we opened the async helper close it now
    if (m_ApcHelper) {
        DEBUGF(DBG_TRACE, ("Closing APC helper\n"));
        WahCloseApcHelper(m_ApcHelper);
    } //if

    // If we opened the handle helper close it now
    if (m_HandleHelper) {
        DEBUGF(DBG_TRACE, ("Closing Handle helper\n"));
        WahCloseHandleHelper(m_HandleHelper);
    } //if

    // If we opened the notification helper close it now
    if (m_NotificationHelper) {
        DEBUGF(DBG_TRACE, ("Closing Notification helper\n"));
        WahCloseNotificationHandleHelper(m_NotificationHelper);
    } //if

    // delete the protocol catalog and its change event if any. 
    if (m_protocol_catalog!=NULL) {
		// First call cleanup procedures of all loaded providers.
		m_protocol_catalog->EnumerateCatalogItems (
								CleanupProtocolProviders,	// Iteration
								NULL				        // Passback
								);
        //
        // Let other threads execute before removing catalog object
        // from under them. This is not fool-proof, but should
        // be sufficient in most normal cases - races of WSACleanup
        // against other winsock calls are not handled here, application
        // that excercises this should be prepared to handle invalid handle
        // exception anyway.
        //
        SwitchToThread ();
        delete(m_protocol_catalog);
        m_protocol_catalog = NULL;
    }

    if (m_proto_catalog_change_event != NULL) {

        CloseHandle (m_proto_catalog_change_event);
        m_proto_catalog_change_event = NULL;
    }

    // delete the name space catalog and its change event if any. 
    if (m_namespace_catalog!=NULL) {
		// First call cleanup procedures of all loaded providers.
		m_namespace_catalog->EnumerateCatalogItems (
								CleanupNamespaceProviders,	// Iteration
								NULL				        // Passback
								);
        //
        // Let other threads execute before removing catalog object
        // from under them. This is not fool-proof, but should
        // be sufficient in most normal cases - races of WSACleanup
        // against other winsock calls are not handled here, application
        // that excercises this should be prepared to handle invalid handle
        // exception anyway.
        //
        SwitchToThread ();
        delete(m_namespace_catalog);
        m_namespace_catalog = NULL;
    }

    if (m_ns_catalog_change_event != NULL) {

        CloseHandle (m_ns_catalog_change_event);
        m_ns_catalog_change_event = NULL;
    }

    // Clean up critical sections
    DeleteCriticalSection( &m_thread_list_lock );

} //~DPROCESS





INT
DPROCESS::DProcessClassInitialize(
    IN VOID
    )
/*++

Routine Description:

    Performs  global  initialization for the DPROCESS class.  In particular, it
    creates  the  global  DPROCESS  object  and  stores  it  in a static member
    variable.

Arguments:

    None

Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it returns an
    appropriate WinSock error code.

--*/
{
    INT ReturnCode=WSAEFAULT;
    PDPROCESS   process;

    assert( sm_current_dprocess == NULL );

    process = new(DPROCESS);
    if (process) {
        ReturnCode = process->Initialize();
        if (ReturnCode == ERROR_SUCCESS) {
            sm_current_dprocess = process;
        }
        else {
            DEBUGF( DBG_ERR,
                    ("Initializing dprocess object\n"));
            delete(process);
        }
    } //if
    else {
        DEBUGF( DBG_ERR,
                ("Allocating dprocess object\n"));
        ReturnCode = WSA_NOT_ENOUGH_MEMORY;
    } //else
    return(ReturnCode);
} //DProcessClassInitialize




INT
DPROCESS::OpenAsyncHelperDevice(
    OUT LPHANDLE HelperHandle
    )
/*++

Routine Description:

    Retrieves  the  opened  Async  Helper  device  ID  required  for processing
    callbacks  in  the  overlapped  I/O  model.   The operation opens the Async
    Helper device if necessary.

Arguments:

    HelperHandle - Returns the requested Async Helper device ID.

Return Value:

    The  function  returns ERROR_SUCESS if successful, otherwise it
    returns an appropriate WinSock error code.
--*/
{
    INT ReturnCode;

    // Protect from multiple opens
    LockDThreadList ();
    // If the helper device has not been opened yet for this process
    // lets go out and open it.
    if (m_ApcHelper || (WahOpenApcHelper(&m_ApcHelper) == 0)) {
        *HelperHandle = m_ApcHelper;
        ReturnCode = ERROR_SUCCESS;
    } //if
    else {
        DEBUGF( DBG_ERR, ("Opening APC helper\n"));
        ReturnCode = WSASYSCALLFAILURE;
    } //else
    UnLockDThreadList ();
    return(ReturnCode);
} //OpenAsyncHelperDevice



INT
DPROCESS::OpenHandleHelperDevice(
    OUT LPHANDLE HelperHandle
    )
/*++

Routine Description:

    Retrieves  the  opened  Handle  Helper  device  ID  required  for allocation
    of socket handles for non-IFS providers.   The operation opens the Handle
    Helper device if necessary.

Arguments:

    HelperHandle - Returns the requested Handle Helper device ID.

Return Value:

    The  function  returns ERROR_SUCESS if successful, otherwise it
    returns an appropriate WinSock error code.
--*/
{
    INT ReturnCode;

    // Protect from double opens
    LockDThreadList ();

    // If the helper device has not been opened yet for this process
    // lets go out and open it.
    if (m_HandleHelper || (WahOpenHandleHelper(&m_HandleHelper) == 0)) {
        *HelperHandle = m_HandleHelper;
        ReturnCode = ERROR_SUCCESS;
    } //if
    else {
        DEBUGF( DBG_ERR, ("Opening Handle helper\n"));
        ReturnCode = WSASYSCALLFAILURE;
    } //else
    UnLockDThreadList ();
    return(ReturnCode);
} //GetHandleHelperDeviceID


INT
DPROCESS::OpenNotificationHelperDevice(
    OUT LPHANDLE HelperHandle
    )
/*++

Routine Description:

    Retrieves  the  opened  Notification  Helper  device  ID  required  for allocation
    of notification handles for catalog change notification. 
    The operation opens the Notification Helper device if necessary.

Arguments:

    HelperHandle - Returns the requested Notification Helper device ID.

Return Value:

    The  function  returns ERROR_SUCESS if successful, otherwise it
    returns an appropriate WinSock error code.
--*/
{
    INT ReturnCode;

    // Protect from double opens
    LockDThreadList ();

    // If the helper device has not been opened yet for this process
    // lets go out and open it.
    if (m_NotificationHelper || (WahOpenNotificationHandleHelper(&m_NotificationHelper) == 0)) {
        *HelperHandle = m_NotificationHelper;
        ReturnCode = ERROR_SUCCESS;
    } //if
    else {
        DEBUGF( DBG_ERR, ("Opening Notification helper\n"));
        ReturnCode = WSASYSCALLFAILURE;
    } //else
    UnLockDThreadList ();
    return(ReturnCode);
} //OpenNotificationHelperDevice


VOID
DPROCESS::SetVersion( WORD Version )
/*++

Routine Description:

    This function sets the WinSock version number for this process.

Arguments:

    Version - The WinSock version number.

Return Value:

    None.

--*/
{

    WORD newMajor;
    WORD newMinor;

    assert(Version != 0);

    newMajor = LOBYTE( Version );
    newMinor = HIBYTE( Version );

    //
    // If the version number is getting downgraded from a previous
    // setting, save the new (updated) number.
    //

    if( newMajor < GetMajorVersion() ||
        ( newMajor == GetMajorVersion() &&
          newMinor < GetMinorVersion() ) ) {

        m_version = Version;

    }

} // SetVersion


PDCATALOG
DPROCESS::GetProtocolCatalog()
/*++

Routine Description:
    Returns the protocol catalog associated with the process object.

Arguments:

    None

Return Value:

    The value of m_protocol_catalog
--*/
{
    if (HasCatalogChanged (m_proto_catalog_change_event))
        m_protocol_catalog->RefreshFromRegistry (m_proto_catalog_change_event);
    return(m_protocol_catalog);
}


PNSCATALOG
DPROCESS::GetNamespaceCatalog()
/*++

Routine Description:
    Returns the namespace catalog associated with the process object.

Arguments:

    None

Return Value:

    The value of m_namespace_catalog
--*/
{
    if (HasCatalogChanged (m_ns_catalog_change_event))
        m_namespace_catalog->RefreshFromRegistry (m_ns_catalog_change_event);
    return(m_namespace_catalog);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\bhook.cpp ===
/*++

    Copyright (c) 1996 Microsoft Corporation

Module Name:

    bhook.cpp

Abstract:

    This module contains the winsock API entrypoints for manipulating
    blocking hooks for WinSock 1.x applications.

    The following functions are exported by this module:

        WSACancelBlockingCall()
        WSAIsBlocking()
        WSASetBlockingHook()
        WSAUnhookBlockingHook()

Author:

    Keith Moore keithmo@microsoft.com 10-May-1996

Revision History:

--*/

#include "precomp.h"



int
WSAAPI
WSACancelBlockingCall(
    VOID
    )

/*++

Routine Description:

    This function cancels any outstanding blocking operation for this
    task.  It is normally used in two situations:

        (1) An application is processing a message which has been
          received while a blocking call is in progress.  In this case,
          WSAIsBlocking() will be true.

        (2) A blocking call is in progress, and Windows Sockets has
          called back to the application's "blocking hook" function (as
          established by WSASetBlockingHook()).

    In each case, the original blocking call will terminate as soon as
    possible with the error WSAEINTR.  (In (1), the termination will not
    take place until Windows message scheduling has caused control to
    revert to the blocking routine in Windows Sockets.  In (2), the
    blocking call will be terminated as soon as the blocking hook
    function completes.)

    In the case of a blocking connect() operation, the Windows Sockets
    implementation will terminate the blocking call as soon as possible,
    but it may not be possible for the socket resources to be released
    until the connection has completed (and then been reset) or timed
    out.  This is likely to be noticeable only if the application
    immediately tries to open a new socket (if no sockets are
    available), or to connect() to the same peer.

Arguments:

    None.

Return Value:

    The value returned by WSACancelBlockingCall() is 0 if the operation
    was successfully canceled.  Otherwise the value SOCKET_ERROR is
    returned, and a specific error number may be retrieved by calling
    WSAGetLastError().

--*/

{
    PDPROCESS Process;
    PDTHREAD  Thread;
    INT       ErrorCode;

    ErrorCode = PROLOG(&Process,&Thread);

    if (ErrorCode!=ERROR_SUCCESS)
    {
        if( ErrorCode != WSAEINPROGRESS ) {
            SetLastError(ErrorCode);
            return SOCKET_ERROR;
        }
    } //if

    //
    // Verify this isn't a WinSock 2.x app trying to do something.
    //

    if( Process->GetMajorVersion() >= 2 ) {
        SetLastError( WSAEOPNOTSUPP );
        return SOCKET_ERROR;
    }

    //
    // Let the DTHREAD object cancel the socket I/O initiated in
    // this thread.
    //

    ErrorCode = Thread->CancelBlockingCall();

    if (ErrorCode == ERROR_SUCCESS) {
        return (ERROR_SUCCESS);
    }
    else {
        SetLastError(ErrorCode);
        return (SOCKET_ERROR);
    }

} // WSACancelBlockingCall


BOOL
WSAAPI
WSAIsBlocking(
    VOID
    )

/*++

Routine Description:

    This function allows a task to determine if it is executing while
    waiting for a previous blocking call to complete.

Arguments:

    None.

Return Value:

    The return value is TRUE if there is an outstanding blocking
    function awaiting completion.  Otherwise, it is FALSE.

--*/

{
    PDTHREAD  Thread;
    INT       ErrorCode;

    ErrorCode = TURBO_PROLOG_OVLP(&Thread);

    if (ErrorCode!=ERROR_SUCCESS)
    {
        if( ErrorCode != WSAEINPROGRESS ) {
            return FALSE;
        }
    } //if

    return Thread->IsBlocking();

} // WSAIsBlocking


FARPROC
WSAAPI
WSASetBlockingHook (
    FARPROC lpBlockFunc
    )

/*++

Routine Description:

    This function installs a new function which a Windows Sockets
    implementation should use to implement blocking socket function
    calls.

    A Windows Sockets implementation includes a default mechanism by
    which blocking socket functions are implemented.  The function
    WSASetBlockingHook() gives the application the ability to execute
    its own function at "blocking" time in place of the default
    function.

    When an application invokes a blocking Windows Sockets API
    operation, the Windows Sockets implementation initiates the
    operation and then enters a loop which is equivalent to the
    following pseudocode:

        for(;;) {
             // flush messages for good user response
             while(BlockingHook())
                  ;
             // check for WSACancelBlockingCall()
             if(operation_cancelled())
                  break;
             // check to see if operation completed
             if(operation_complete())
                  break;     // normal completion
        }

    The default BlockingHook() function is equivalent to:

        BOOL DefaultBlockingHook(void) {
             MSG msg;
             BOOL ret;
             // get the next message if any
             ret = (BOOL)PeekMessage(&msg,0,0,PM_REMOVE);
             // if we got one, process it
             if (ret) {
                  TranslateMessage(&msg);
                  DispatchMessage(&msg);
             }
             // TRUE if we got a message
             return ret;
        }

    The WSASetBlockingHook() function is provided to support those
    applications which require more complex message processing - for
    example, those employing the MDI (multiple document interface)
    model.  It is not intended as a mechanism for performing general
    applications functions.  In particular, the only Windows Sockets API
    function which may be issued from a custom blocking hook function is
    WSACancelBlockingCall(), which will cause the blocking loop to
    terminate.

Arguments:

    lpBlockFunc - A pointer to the procedure instance address of the
        blocking function to be installed.

Return Value:

    The return value is a pointer to the procedure-instance of the
    previously installed blocking function.  The application or library
    that calls the WSASetBlockingHook () function should save this
    return value so that it can be restored if necessary.  (If "nesting"
    is not important, the application may simply discard the value
    returned by WSASetBlockingHook() and eventually use
    WSAUnhookBlockingHook() to restore the default mechanism.) If the
    operation fails, a NULL pointer is returned, and a specific error
    number may be retrieved by calling WSAGetLastError().

--*/

{
    PDPROCESS          Process;
    PDTHREAD           Thread;
    INT                ErrorCode;
    FARPROC            PreviousHook;

    ErrorCode = PROLOG(&Process,&Thread);

    if (ErrorCode!=ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return NULL;
    } //if

    //
    // Verify this isn't a WinSock 2.x app trying to do something.
    //

    if( Process->GetMajorVersion() >= 2 ) {
        SetLastError( WSAEOPNOTSUPP );
        return NULL;
    }

    //
    // Validate the blocking hook parameter.
    //

    if( IsBadCodePtr( lpBlockFunc ) ) {
        SetLastError( WSAEFAULT );
        return NULL;
    }

    //
    // Let the DTHREAD object set the blocking hook & return the previous
    // hook.
    //

    PreviousHook = Thread->SetBlockingHook( lpBlockFunc );
    assert( PreviousHook != NULL );

    return PreviousHook;

} // WSASetBlockingHook


int
WSAAPI
WSAUnhookBlockingHook(
    VOID
    )

/*++

Routine Description:

    This function removes any previous blocking hook that has been
    installed and reinstalls the default blocking mechanism.

    WSAUnhookBlockingHook() will always install the default mechanism,
    not the previous mechanism.  If an application wish to nest blocking
    hooks - i.e.  to establish a temporary blocking hook function and
    then revert to the previous mechanism (whether the default or one
    established by an earlier WSASetBlockingHook()) - it must save and
    restore the value returned by WSASetBlockingHook(); it cannot use
    WSAUnhookBlockingHook().

Arguments:

    None.

Return Value:

    The return value is 0 if the operation was successful.  Otherwise
    the value SOCKET_ERROR is returned, and a specific error number may
    be retrieved by calling WSAGetLastError().

--*/

{
    PDPROCESS          Process;
    PDTHREAD           Thread;
    INT                ErrorCode;

    ErrorCode = PROLOG(&Process,&Thread);

    if (ErrorCode!=ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return SOCKET_ERROR;
    } //if

    //
    // Verify this isn't a WinSock 2.x app trying to do something.
    //

    if( Process->GetMajorVersion() >= 2 ) {
        SetLastError( WSAEOPNOTSUPP );
        return SOCKET_ERROR;
    }

    //
    // Let the DTHREAD object unhook the blocking hook.
    //

    ErrorCode = Thread->UnhookBlockingHook();

    if (ErrorCode == ERROR_SUCCESS) {
        return (ERROR_SUCCESS);
    }
    else {
        SetLastError(ErrorCode);
        return (SOCKET_ERROR);
    }
} // WSAUnhookBlockingHook
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\dprovide.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    dprovide.cpp

Abstract:

    This module defines the WinSock2 class dprovder along with its methods.

Author:

    Mark Hamilton (mark_hamilton@jf2.intel.com) 7-July-1995

Revision History:

    21-Aug-1995 dirk@mink.intel.com
        Clean up from code review. Moved single line functions to inlines in
        header file. Added debug traceing code. Rewrote destructor. Removed
        ProviderID from the class.

    7-July-1995 mark_hamilton
      Genesis
--*/

#include "precomp.h"


DPROVIDER::DPROVIDER()
/*++
Routine Description:

    Creates any internal state.

Arguments:

    None

Return Value:

    None

--*/

{
    m_library_handle = NULL;
    m_reference_count = 1;
#ifdef DEBUG_TRACING
    m_lib_name = NULL;
#endif
}


INT
DPROVIDER::WSPCleanup(
    OUT INT FAR *lpErrno
    )
/*++
Routine Description:

    Terminate use of the WinSock service provider.

Arguments:

    lpErrno - A pointer to the error code.

Return Value:

    The  return  value  is  0 if the operation has been successfully initiated.
    Otherwise  the  value SOCKET_ERROR is returned,
and a specific error number
    is available in lpErrno.

--*/
{
    INT ReturnValue = NO_ERROR;

    if (m_library_handle) {
        LPWSPCLEANUP    lpWSPCleanup;

        lpWSPCleanup =
            (LPWSPCLEANUP)InterlockedExchangePointer (
                            (PVOID *)&m_proctable.lpWSPCleanup,
                            NULL
                            );
        if (lpWSPCleanup!=NULL) {

            DEBUGF( DBG_TRACE,
                    ("Calling WSPCleanup for provider %s @ %p\n", m_lib_name, this));

            if (!PREAPINOTIFY(( DTCODE_WSPCleanup,
                               &ReturnValue,
                               m_lib_name,
                               &lpErrno)) ) {

                ReturnValue = lpWSPCleanup(lpErrno);

                POSTAPINOTIFY(( DTCODE_WSPCleanup,
                                &ReturnValue,
                                m_lib_name,
                                &lpErrno));
            }
        }
    }
    return ReturnValue;
}


DPROVIDER::~DPROVIDER()
/*++
Routine Description:

    destroys any internal state.

Arguments:

    None

Return Value:

    None

--*/
{

    if (m_library_handle)
    {
        INT ErrorCode;
#ifdef DEBUG_TRACING
        assert (m_lib_name);
#endif

        // Cleanup service provider DLL if not already done so
        WSPCleanup (&ErrorCode);
        // Free the service provider DLL
        FreeLibrary(m_library_handle);

#ifdef DEBUG_TRACING
        delete m_lib_name;
#endif
    } //if
    DEBUGF( DBG_TRACE,
            ("Destroying provider %X\n", this));
}



INT
DPROVIDER::Initialize(
    IN LPSTR lpszLibFile,
    IN LPWSAPROTOCOL_INFOW lpProtocolInfo
    )
/*++
Routine Description:

    Initializes the DPROVIDER object.

Arguments:

    lpszLibFile - A  Null  terminating  string  that  points to the .DLL of the
                  service to load.

    lpProtocolInfo - A pointer to a WSAPROTOCOL_INFOW struct to hand to the
                     provider startup routine.

Return Value:

    If no error occurs, Initialize() returns ERROR_SUCEES.  Otherwise the value
    SOCKET_ERROR  is  returned,  and  a  specific  error  code  is available in
    lpErrno.

--*/
{
    LPWSPSTARTUP        WSPStartupFunc          = NULL;
    WORD                wVersionRequested       = WINSOCK_HIGH_SPI_VERSION;
    INT                 error_code              = 0;
    WSPDATA             WSPData;
    WSPUPCALLTABLE      UpCallTable;
    char                LibraryPath[MAX_PATH];

    DEBUGF( DBG_TRACE,
            ("Initializing provider %s @%p\n", lpszLibFile, this));

    TRY_START(guard_memalloc) {
        // Zero out contents of m_proctable
        ZeroMemory(
            (PVOID) &m_proctable,     // Destination
            sizeof(m_proctable));   // Length

        //
        // Fill  the  upcall  table  we  will hand to the service provider with the
        // address  of  our  upcall entry points.  We will also pre-fill this thing
        // with  zeros,  mainly  to  help  with  consistency  checks  if we add new
        // functions to the upcall table in the future.
        //
        ZeroMemory(
            (PVOID) & UpCallTable,  // Destination
            sizeof(UpCallTable));   // Length

    #if !defined(DEBUG_TRACING)
        UpCallTable.lpWPUCloseEvent = WPUCloseEvent;
        UpCallTable.lpWPUCloseSocketHandle = WPUCloseSocketHandle;
        UpCallTable.lpWPUCreateEvent = WPUCreateEvent;
        UpCallTable.lpWPUCreateSocketHandle = WPUCreateSocketHandle;
        UpCallTable.lpWPUModifyIFSHandle = WPUModifyIFSHandle;
        UpCallTable.lpWPUQueryBlockingCallback = WPUQueryBlockingCallback;
        UpCallTable.lpWPUQuerySocketHandleContext = WPUQuerySocketHandleContext;
        UpCallTable.lpWPUQueueApc = WPUQueueApc;
        UpCallTable.lpWPUResetEvent = WPUResetEvent;
        UpCallTable.lpWPUSetEvent = WPUSetEvent;
        UpCallTable.lpWPUPostMessage = WPUPostMessage;
        UpCallTable.lpWPUGetProviderPath = WPUGetProviderPath;
        UpCallTable.lpWPUFDIsSet = WPUFDIsSet;
        UpCallTable.lpWPUOpenCurrentThread = WPUOpenCurrentThread;
        UpCallTable.lpWPUCloseThread = WPUCloseThread;
    #else
        UpCallTable.lpWPUCloseEvent = DTHOOK_WPUCloseEvent;
        UpCallTable.lpWPUCloseSocketHandle = DTHOOK_WPUCloseSocketHandle;
        UpCallTable.lpWPUCreateEvent = DTHOOK_WPUCreateEvent;
        UpCallTable.lpWPUCreateSocketHandle = DTHOOK_WPUCreateSocketHandle;
        UpCallTable.lpWPUModifyIFSHandle = DTHOOK_WPUModifyIFSHandle;
        UpCallTable.lpWPUQueryBlockingCallback = DTHOOK_WPUQueryBlockingCallback;
        UpCallTable.lpWPUQuerySocketHandleContext = DTHOOK_WPUQuerySocketHandleContext;
        UpCallTable.lpWPUQueueApc = DTHOOK_WPUQueueApc;
        UpCallTable.lpWPUResetEvent = DTHOOK_WPUResetEvent;
        UpCallTable.lpWPUSetEvent = DTHOOK_WPUSetEvent;
        UpCallTable.lpWPUPostMessage = DTHOOK_WPUPostMessage;
        UpCallTable.lpWPUGetProviderPath = DTHOOK_WPUGetProviderPath;
        UpCallTable.lpWPUFDIsSet = DTHOOK_WPUFDIsSet;
        UpCallTable.lpWPUOpenCurrentThread = DTHOOK_WPUOpenCurrentThread;
        UpCallTable.lpWPUCloseThread = DTHOOK_WPUCloseThread;
    #endif  // !defined(DEBUG_TRACING)

        //
        // Expand the library name to pickup environment/registry variables
        //
        if (!( ExpandEnvironmentStrings(lpszLibFile,
                                        LibraryPath,
                                        MAX_PATH))){
            DEBUGF(
                DBG_ERR,
                ("Expanding environment variable %s\n", lpszLibFile));
            error_code = WSASYSCALLFAILURE;
            TRY_THROW(guard_memalloc);
        } //if

#ifdef DEBUG_TRACING
        m_lib_name = (LPSTR) new char[lstrlen(LibraryPath) + 1];
        if (m_lib_name == NULL) {
            DEBUGF(
                DBG_ERR,
                ("Allocating m_lib_name\n"));
            error_code = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(guard_memalloc);
        }
        lstrcpy(m_lib_name, LibraryPath);
#endif DEBUG_TRACING
        //
        // First load the DLL for the service provider. Then get two functions that
        // init the service provider structures.
        //
        m_library_handle = LoadLibrary(LibraryPath);
        if(!m_library_handle){
            error_code = GetLastError ();
            DEBUGF(
                DBG_ERR,
                ("Loading DLL %s, err: %ld\n",LibraryPath, error_code));
            switch (error_code) {
            case ERROR_NOT_ENOUGH_MEMORY:
            case ERROR_COMMITMENT_LIMIT:
                error_code = WSA_NOT_ENOUGH_MEMORY;
                break;
            default:
                error_code = WSAEPROVIDERFAILEDINIT;
                break;
            }
            TRY_THROW(guard_memalloc);
        }

        WSPStartupFunc = (LPWSPSTARTUP)GetProcAddress(
            m_library_handle,
            "WSPStartup"
            );

        if(!(WSPStartupFunc)){

            DEBUGF( DBG_ERR,("Getting startup entry point for %ls-%s\n",
                             lpProtocolInfo->szProtocol, lpszLibFile));
            error_code = WSAEPROVIDERFAILEDINIT;
            TRY_THROW(guard_memalloc);
        }

        //
        // Set exception handler around this call since we
        // hold critical section (catalog lock).
        //
        __try {
#if !defined(DEBUG_TRACING)
            error_code = (*WSPStartupFunc)(
                wVersionRequested,
                & WSPData,
                lpProtocolInfo,
                UpCallTable,
                &m_proctable);
#else
            { // declaration block
                LPWSPDATA  pWSPData = & WSPData;
                BOOL       bypassing_call;

                bypassing_call = PREAPINOTIFY((
                    DTCODE_WSPStartup,
                    & error_code,
                    LibraryPath,
                    & wVersionRequested,
                    & pWSPData,
                    & lpProtocolInfo,
                    & UpCallTable,
                    & m_proctable));
                if (! bypassing_call) {
                    error_code = (*WSPStartupFunc)(
                        wVersionRequested,
                        & WSPData,
                        lpProtocolInfo,
                        UpCallTable,
                        &m_proctable);
                    POSTAPINOTIFY((
                        DTCODE_WSPStartup,
                        & error_code,
                        LibraryPath,
                        & wVersionRequested,
                        & pWSPData,
                        & lpProtocolInfo,
                        & UpCallTable,
                        & m_proctable));
                } // if ! bypassing_call
            } // declaration block
#endif // !defined(DEBUG_TRACING)
        }
        __except (WS2_EXCEPTION_FILTER ()) {
            DEBUGF(DBG_ERR, ("Unhandled exception in WSPStartup for %ls %s, code:%lx\n",
                    lpProtocolInfo->szProtocol, lpszLibFile, GetExceptionCode()));
            assert (FALSE);
            error_code = WSAEPROVIDERFAILEDINIT;
            TRY_THROW(guard_memalloc);
        }

        if(ERROR_SUCCESS != error_code){
            DEBUGF(DBG_ERR, ("Calling WSPStartup for %ls %s, err:%ld\n",
                    lpProtocolInfo->szProtocol, lpszLibFile, error_code));
            TRY_THROW(guard_memalloc);
        }

        //
        // Make sure that all of the procedures at least have a non null pointer.
        //
        if( !m_proctable.lpWSPAccept              ||
            !m_proctable.lpWSPAddressToString     ||
            !m_proctable.lpWSPAsyncSelect         ||
            !m_proctable.lpWSPBind                ||
            !m_proctable.lpWSPCancelBlockingCall  ||
            !m_proctable.lpWSPCleanup             ||
            !m_proctable.lpWSPCloseSocket         ||
            !m_proctable.lpWSPConnect             ||
            !m_proctable.lpWSPDuplicateSocket     ||
            !m_proctable.lpWSPEnumNetworkEvents   ||
            !m_proctable.lpWSPEventSelect         ||
            !m_proctable.lpWSPGetOverlappedResult ||
            !m_proctable.lpWSPGetPeerName         ||
            !m_proctable.lpWSPGetSockName         ||
            !m_proctable.lpWSPGetSockOpt          ||
            !m_proctable.lpWSPGetQOSByName        ||
            !m_proctable.lpWSPIoctl               ||
            !m_proctable.lpWSPJoinLeaf            ||
            !m_proctable.lpWSPListen              ||
            !m_proctable.lpWSPRecv                ||
            !m_proctable.lpWSPRecvDisconnect      ||
            !m_proctable.lpWSPRecvFrom            ||
            !m_proctable.lpWSPSelect              ||
            !m_proctable.lpWSPSend                ||
            !m_proctable.lpWSPSendDisconnect      ||
            !m_proctable.lpWSPSendTo              ||
            !m_proctable.lpWSPSetSockOpt          ||
            !m_proctable.lpWSPShutdown            ||
            !m_proctable.lpWSPSocket              ||
            !m_proctable.lpWSPStringToAddress ){

            DEBUGF(DBG_ERR,
                   ("Service provider %ls %s returned an invalid procedure table\n",
                    lpProtocolInfo->szProtocol,lpszLibFile));
            error_code = WSAEINVALIDPROCTABLE;
            TRY_THROW(guard_memalloc);
        }

        //
        // Confirm that the WinSock service provider supports 2.2. If it supports a
        // version greater then 2.2 it will still return 2.2 since this is the
        // version  we requested.
        //
        if( WSPData.wVersion != WINSOCK_HIGH_SPI_VERSION ) {
            WSPCleanup (&error_code);
            DEBUGF( DBG_ERR,
                    ("Service Provider %ls %s does not support version 2.2\n",
                     lpProtocolInfo->szProtocol,lpszLibFile));
            error_code = WSAVERNOTSUPPORTED;
            TRY_THROW(guard_memalloc);
        }
    } TRY_CATCH(guard_memalloc) {
        if (m_library_handle!=NULL) {
            FreeLibrary (m_library_handle);
            m_library_handle = NULL;
        }


#ifdef DEBUG_TRACING
        if (m_lib_name!=NULL) {
            delete m_lib_name;
            m_lib_name = NULL;
        }
#endif
    } TRY_END(guard_memalloc);

    return error_code;
} //Initailize
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\dcatitem.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    dcatitem.cpp

Abstract:

    This  file  contains  the  class  implementation for the PROTO_CATALOG_ITEM
    class.   This  class  defines  the  interface  to  the  entries that can be
    installed and retrieved in the protocol catalog.

Author:

    Paul Drews (drewsxpa@ashland.intel.com) 31-July-1995

Notes:

    $Revision:   1.16  $

    $Modtime:   08 Mar 1996 13:16:44  $

Revision History:

    most-recent-revision-date email-name
        description

    23-Aug-1995 dirk@mink.intel.com
        Moved includes into precomp.h

    31-July-1995 drewsxpa@ashland.intel.com
        Original created from code separated out from dcatalog module.

--*/


#include "precomp.h"



PROTO_CATALOG_ITEM::PROTO_CATALOG_ITEM()
/*++

Routine Description:

    This  procedure  constructs  an empty PROTO_CATALOG_ITEM object.  The first
    method  invoked  after  this  constructor must be InitializeFromRegistry or
    InitializeFromValues.

Arguments:

    None

Return Value:

    Implicitly  returns  a pointer to a newly created PROTO_CATALOG_ITEM object
    or NULL if there is a memory allocation failure.
--*/
{
    DEBUGF(
        DBG_TRACE,
        ("PROTO_CATALOG_ITEM constructor\n"));

    // Simply initialize embedded pointer values for safety.
    m_LibraryPath[0] = '\0';
    m_Provider = NULL;
    m_reference_count = 1;
#if defined(DEBUG_TRACING)
    InitializeListHead (&m_CatalogLinkage);
#endif
}  // PROTO_CATALOG_ITEM



// The   following   two   defines  determine  the  number  of  digits  in  the
// sequence-numbered  name  of  each  catalog  entry key.  The two defines must
// include  the  same  number.   If there is a way to cause the preprocessor to
// derive both a quoted and unquoted character sequence from the same sequence,
// I don't know what it is.
#define SEQUENCE_KEY_DIGITS 12
#define SEQUENCE_KEY_DIGITS_STRING "12"




INT
PROTO_CATALOG_ITEM::InitializeFromRegistry(
    IN  HKEY  ParentKey,
    IN  INT   SequenceNum
    )
/*++

Routine Description:

    This  procedure initializes the protocol info part of the catalog item from
    information  retrieved  from  the  catalog  portion of the registry.  It is
    assumed that the catalog portion is locked against competing I/O attempts.

Arguments:

    ParentKey   - Supplies  an open registry key for the registry entry that is
                  the  parent  of  the registry item defining the catalog item,
                  i.e., the catalog entry list key.

    SequenceNum - Supplies  the  sequence  number  within the entry list of the
                  target registry entry.

Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it returns an
    appropriate WinSock error code.

--*/
{
    char  keyname[SEQUENCE_KEY_DIGITS + 1];
    HKEY  thiskey;
    LONG  result;
    INT   ReturnCode;

    sprintf(keyname, "%0"SEQUENCE_KEY_DIGITS_STRING"i", SequenceNum);
    result = RegOpenKeyEx(
        ParentKey,     // hkey
        keyname,       // lpszSubKey
        0,             // dwReserved
        KEY_READ,      // samDesired
        & thiskey      // phkResult
        );
    if (result != ERROR_SUCCESS) {
        DEBUGF(
            DBG_ERR,
            ("Opening catalog entry key '%s', error = %lu\n",
            keyname,
            result));
        return(WSASYSCALLFAILURE);
    }

    ReturnCode = IoRegistry(
        thiskey,  // EntryKey
        TRUE      // IsRead
        );

    result = RegCloseKey(
        thiskey  // hkey
        );
    if (result != ERROR_SUCCESS) {
        DEBUGF(
            DBG_ERR,
            ("Closing catalog entry, error = %lu\n",
            result));
        return(WSASYSCALLFAILURE);
    }

    return ReturnCode;

}  // InitializeFromRegistry




INT
PROTO_CATALOG_ITEM::InitializeFromValues(
    IN  LPSTR               LibraryPath,
    IN  LPWSAPROTOCOL_INFOW ProtoInfo
    )
/*++

Routine Description:

    This  procedure initializes the protocol info part of the catalog item from
    the  values  supplied.  Values are copied from the structures passed by the
    caller,  so  the  caller  is  free  to  deallocate the passed structures on
    return.

Arguments:

    LibraryPath  - Supplies    a    reference   to   a   buffer   holding   the
                   zero-terminated,   fully-qualified   path  of  the  provider
                   library that implements this protocol.  The path may include
                   expandable environment references of the form '%variable%'.

    ProviderName - Supplies a reference to a buffer holding the zero-terminated
                   locally unique name of this provider.

    ProtoInfo    - Supplies  a reference to the fully initialized protocol info
                   structure describing this protocol.

return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it returns an
    appropriate WinSock error code.

--*/
{
    size_t  len_needed;
    INT ReturnValue = ERROR_SUCCESS;

    // Copy LibraryPath
    len_needed = lstrlen(LibraryPath) + 1;
    if (len_needed > sizeof(m_LibraryPath)) {
        DEBUGF(
            DBG_ERR,
            ("Library Path Too long (%u) '%s'\n",
            len_needed,
            LibraryPath));
        return(WSAEINVAL);
    }
    lstrcpy(
        m_LibraryPath,
        LibraryPath);

    // Copy ProtoInfo
    m_ProtoInfo = *ProtoInfo;

    return (ReturnValue);

}  // InitializeFromValues




PROTO_CATALOG_ITEM::~PROTO_CATALOG_ITEM()
/*++

Routine Description:

    This  procedure  destroys  a  protocol catalog item, deallocating memory it
    owns.   It  is the caller's responsibility to remove the item from the list
    it  occupies  before  calling  this  procedure.   It  is  also the caller's
    responsibility  to unload and/or destroy any dprovider associated with this
    catalog item if appropriate.

Arguments:

    None

Return Value:

    None
--*/
{
    if (m_Provider!=NULL) {
        m_Provider->Dereference ();
        m_Provider = NULL;
    }
    assert(IsListEmpty (&m_CatalogLinkage));
}  // ~PROTO_CATALOG_ITEM





VOID
PROTO_CATALOG_ITEM::SetProvider(
    IN  PDPROVIDER  Provider
    )
/*++

Routine Description:

    This procedure sets the DPROVIDER associated with a catalog entry.

Arguments:

    Provider - Supplies the new DPROVIDER reference.

Return Value:

    None
--*/
{
    assert (m_Provider==NULL);
    Provider->Reference ();
    m_Provider = Provider;
}  // SetProvider



INT
PROTO_CATALOG_ITEM::WriteToRegistry(
    IN  HKEY  ParentKey,
    IN  INT   SequenceNum
    )
/*++

Routine Description:

    This  procedure  writes  the fully-initialized protocol info portion of the
    catalog  entry  out  to the catalog portion of the registry.  It is assumed
    that  the  catalog  portion of the registry is locked against competing I/O
    attempts.

Arguments:

    ParentKey -   Supplies  the  open registry key of the parent registry entry
                  in which this catalog entry will be written as a subkey.

    Sequencenum - Supplies the sequence number of this catalog entry within the
                  entire set of catalog entries.

Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it returns an
    appropriate WINSOCK error code.
--*/
{
    char  keyname[SEQUENCE_KEY_DIGITS + 1];
    HKEY  thiskey;
    LONG  result;
    INT   ReturnCode;
    DWORD key_disposition;


    sprintf(keyname, "%0"SEQUENCE_KEY_DIGITS_STRING"i", SequenceNum);
    result = RegCreateKeyEx(
        ParentKey,                // hkey
        keyname,                  // lpszSubKey
        0,                        // dwReserved
        NULL,                     // lpszClass
        REG_OPTION_NON_VOLATILE,  // fdwOptions
        KEY_READ|KEY_WRITE,        // samDesired
        NULL,                     // lpSecurityAttributes
        & thiskey,                // phkResult
        & key_disposition         // lpdwDisposition
        );
    if (result != ERROR_SUCCESS) {
        DEBUGF(
            DBG_ERR,
            ("Creating catalog entry key %s (%lu)\n",
            keyname, result));
        return(WSASYSCALLFAILURE);
    }
    if (key_disposition == REG_OPENED_EXISTING_KEY) {
        DEBUGF(
            DBG_WARN,
            ("Overwriting a catalog entry key '%s'\n",
            keyname));
    }

    ReturnCode = IoRegistry(
        thiskey,  // EntryKey
        FALSE     // IsRead
        );

    result = RegCloseKey(
        thiskey  // hkey
        );
    if (result != ERROR_SUCCESS) {
        DEBUGF(
            DBG_ERR,
            ("Closing catalog entry key %s, error = %lu\n",
            keyname, result));
        return(WSASYSCALLFAILURE);
    }

    return ReturnCode;

}  // WriteToRegistry



// The following typedef is used in packing and unpacking catalog item data for
// reading and writing in the registry.

typedef struct {
    char            LibraryPath[MAX_PATH];
        // The unexpanded path where the provider DLL is found.

    WSAPROTOCOL_INFOW   ProtoInfo;
        // The  protocol information.  Note that if the WSAPROTOCOL_INFOW structure
        // is  ever changed to a non-flat structure (i.e., containing pointers)
        // then  this  type  definition  will  have  to  be changed, since this
        // structure must be strictly flat.
} PACKED_CAT_ITEM;

typedef PACKED_CAT_ITEM * PPACKED_CAT_ITEM;


#define PACKED_ITEM_NAME "PackedCatalogItem"



INT
PROTO_CATALOG_ITEM::IoRegistry(
    IN  HKEY  EntryKey,
    IN  BOOL  IsRead)
/*++

Routine Description:

    This  procedure  performs  the  actual  input  or  output  of catalog entry
    information  from  or  to  the  registry.   It  is assumed that the catalog
    portion of the registry is locked against competing I/O attempts.

Arguments:

    EntryKey - Supplies  the open registry key where the catalog entry is to be
               read or written.

    IsRead   - Supplies  a  BOOL  determining  disposition.  TRUE indicates the
               entry  is  to  be  read  into  memory  from the registry.  FALSE
               indicates  the  entry  is  to  be written out from memory to the
               registry.

Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it returns an
    appropriate WINSOCK error code.

Implementation Notes:

    An  early  implementation represented the catalog item as a single registry
    key  with multiple named values.  Each named value corresponded to a single
    member  variable  of  the  catalog  entry  or  field  of  the protocol info
    structure.   Thus each catalog item consisted of about 20 named values in a
    registry key.  Unfortunately, the registry has very poor performance for so
    many values.

    Therefore  the  implementation  has been changed to pack the entire catalog
    item  into  a single REG_BINARY value.  Each catalog item then has a single
    key  with  a  single  large  REG_BINARY value.  This mitigates the registry
    performance problem.
--*/
{
    DWORD             packed_size;
    PPACKED_CAT_ITEM  packed_buf = NULL;
    INT               return_value;

    return_value = ERROR_SUCCESS;


    TRY_START(guard_memalloc) {
        // Determine required size of packed structure
        if (IsRead) {
            LONG lresult;

            lresult = RegQueryValueEx(
                EntryKey,          // hkey
                PACKED_ITEM_NAME,  // lpszValueName
                0,                 // lpdwReserved
                NULL,              // lpdwType
                NULL,              // lpbData
                & packed_size      // lpcbData
                );
            if (lresult != ERROR_SUCCESS) {
                DEBUGF(
                    DBG_ERR,
                    ("Querying length of %s entry\n", PACKED_ITEM_NAME));
                return_value = WSASYSCALLFAILURE;
                TRY_THROW(guard_memalloc);
            }
        } // if IsRead
        else { // not IsRead
            packed_size = sizeof(PACKED_CAT_ITEM);
        } // else not IsRead


        // Allocate memory for packed structure
        packed_buf = (PPACKED_CAT_ITEM) new char[packed_size];
        if (packed_buf == NULL) {
            DEBUGF(
                DBG_ERR,
                ("Allocating space for packed entry\n"));
            return_value = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(guard_memalloc);
        }


        // If writing, then initialize the packed structure
        if (! IsRead) {
            lstrcpy(
                packed_buf->LibraryPath,
                m_LibraryPath);
            packed_buf->ProtoInfo = m_ProtoInfo;
        } // if ! IsRead


        // Read or write the structure
        { // declaration block
            BOOL io_result;
            WSABUF  io_descr;

            io_descr.len = packed_size;
            io_descr.buf = (char FAR *) packed_buf;
            if (IsRead) {
                io_result = ReadRegistryEntry(
                    EntryKey,             // EntryKey
                    PACKED_ITEM_NAME,     // EntryName
                    (PVOID) & io_descr,   // Data
                    packed_size,          // MaxBytes
                    REG_BINARY            // TypeFlag
                    );
            } // if IsRead
            else { // not IsRead
                io_result = WriteRegistryEntry(
                    EntryKey,             // EntryKey
                    PACKED_ITEM_NAME,     // EntryName
                    (PVOID) & io_descr,   // Data
                    REG_BINARY            // TypeFlag
                    );
            } // else not IsRead
            if (! io_result) {
                DEBUGF(
                    DBG_ERR,
                    ("%s registry entry\n",
                    IsRead ? "reading" : "writing"));
                return_value = WSASYSCALLFAILURE;
                TRY_THROW(guard_memalloc);
            }
            if (io_descr.len != packed_size) {
                DEBUGF(
                    DBG_ERR,
                    ("Registry entry size expected (%lu), got (%lu)\n",
                    packed_size,
                    io_descr.len));
                return_value = WSASYSCALLFAILURE;
                TRY_THROW(guard_memalloc);
            }
        } // declaration block


        // If reading, extract data from the packed structure
        if (IsRead) {
            lstrcpy(
                m_LibraryPath,
                packed_buf->LibraryPath);
            m_ProtoInfo = packed_buf->ProtoInfo;
        } // if IsRead


        // deallocate the packed structure
        delete packed_buf;

    } TRY_CATCH(guard_memalloc) {
        if (return_value == ERROR_SUCCESS) {
            return_value = WSASYSCALLFAILURE;
        }
        if (packed_buf!=NULL)
            delete packed_buf;
    } TRY_END(guard_memalloc);

    return(return_value);

}  // IoRegistry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\dsocket.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

dsocket.cpp

Abstract:

This module contains the implemetation of the dsocket object used
by winsock2.dll

Author:

Dirk Brandewie  dirk@mink.intel.com  14-JUL-1995

Notes:

$Revision:   1.15  $

$Modtime:   08 Mar 1996 05:15:30  $

Revision History:
    21-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Moved single line functions to
        inlines in header file. Added debug/trace code.
--*/

#include "precomp.h"

#define m_reference_count   RefCount
#define m_socket_handle     Handle

LPCONTEXT_TABLE DSOCKET::sm_context_table=NULL;


INT
DSOCKET::DSocketClassInitialize(
    )
/*++
Routine Description:

    DSOCKET  class initializer.  This funtion must be called before any DSOCKET
    objects  are  created.   It  takes  care  of initializing the socket handle
    mapping table that maps socket handles to DSOCKET object references.

Arguments:

    None

Return Value:

    If  the function succeeds, it returns ERROR_SUCCESS, otherwise it returns a
    WinSock specific error code.
--*/
{
    if (sm_context_table==NULL) {
        return WahCreateHandleContextTable (&sm_context_table);
    }
    else
        return NO_ERROR;

} // DSocketClassInitialize




INT
DSOCKET::DSocketClassCleanup(
    )
/*++
Routine Description:

    DSOCKET  class  cleanup  function.   This function must be called after all
    DSOCKET  objects  have  been  destroyed.   It  takes care of destroying the
    socket  handle  mapping  table  that  maps socket handles to DSOCKET object
    references.

Arguments:

    None

Return Value:

    If  the function succeeds, it returns ERROR_SUCCESS, otherwise it returns a
    WinSock specific error code.
--*/
{
    DWORD   rc = NO_ERROR;
    if (sm_context_table!=NULL) {
        rc = WahDestroyHandleContextTable (sm_context_table);
        sm_context_table = NULL;
    }

    return rc;
} // DSocketClassCleanup




DSOCKET::DSOCKET(
    )
/*++

Routine Description:

    DSOCKET  object  constructor.   Creates and returns a DSOCKET object.  Note
    that  the  DSOCKET object has not been fully initialized.  The "Initialize"
    member function must be the first member function called on the new DSOCKET
    object.

Arguments:

    None

Return Value:

    None
--*/
{
    // Set our data members to known values
    m_reference_count   = 2;
    m_provider          = NULL;
    m_handle_context    = NULL;
    m_socket_handle     = (HANDLE)INVALID_SOCKET;
    m_catalog_item      = NULL;
    m_pvd_socket        = FALSE;
    m_api_socket        = FALSE;
    m_overlapped_socket = TRUE;     // This is the default for socket call.
}




INT
DSOCKET::Initialize(
    IN PPROTO_CATALOG_ITEM  CatalogEntry
    )
/*++

Routine Description:

    Completes  the  initialization  of  the  DSOCKET object.  This must be the
    first  member  function  called  for  the  DSOCKET object.  

Arguments:

    CatalogEntry - Supplies  a  reference  to  the catalog item object associated with
               this DSOCKET object.

Return Value:

    The  function returns ERROR_SUCCESS if successful.  Otherwise it
    returns an appropriate WinSock error code if the initialization
    cannot be completed.
--*/
{
    PDTHREAD    currentThread;

    // Store the provider, catalog, and process object.
    CatalogEntry->Reference ();
    m_catalog_item = CatalogEntry;
    m_provider = CatalogEntry->GetProvider ();

    currentThread = DTHREAD::GetCurrentDThread ();
    if (currentThread!=NULL) {
        m_overlapped_socket = (currentThread->GetOpenType ()==0);
    }

    //else The thread must have never been used by the application
    // No API call was made, only SPI.  Thus leave the overlapped attribute
    // at its default.


    DEBUGF( DBG_TRACE,
            ("Initializing socket %p\n",this));
    return(ERROR_SUCCESS);
}



DSOCKET::~DSOCKET()
/*++

Routine Description:

    DSOCKET  object  destructor.   This  procedure  has  the  responsibility to
    perform  any required shutdown operations for the DSOCKET object before the
    object  memory  is  deallocated.  The caller is reponsible for removing the
    object  from its list in the DPROCESS object and removing the object/handle
    association  from  the  socket handle association manager before destroying
    the DSOCKET object.

Arguments:

    None

Return Value:

    None
--*/
{
    DEBUGF( DBG_TRACE,
            ("Destroying socket %p\n",this));
    if (m_catalog_item) {
        m_catalog_item->Dereference ();
        m_catalog_item = NULL;
    }
#ifdef DEBUG_TRACING
    {
        PDSOCKET Socket;
        if (sm_context_table!=NULL) {
            Socket = GetCountedDSocketFromSocketNoExport ((SOCKET)m_socket_handle);
            if (Socket!=NULL) {
                assert (Socket!=this);
                Socket->DropDSocketReference ();
            }
        }
    }
#endif
}

VOID
DSOCKET::DestroyDSocket()
/*++

Routine Description:

    Destroy DSocket object
Arguments:

    None

Return Value:

    None
--*/
{
    delete this;
}



INT
DSOCKET::AssociateSocketHandle(
    IN  SOCKET SocketHandle,
    IN  BOOLEAN ProviderSocket
    )
/*++
Routine Description:

    This  procedure  takes  the  socket  handle  that will be given to external
    clients  and  stores  it in the DSOCKET object.  It also enters this handle
    into  the  association table so that the client socket handle can be mapped
    to  a  DSOCKET  reference.  Note that this procedure must be called at some
    point for both IFS and non-IFS sockets.

Arguments:

    SocketHandle - Supplies  the  client  socket  handle  to  be  stored in and
                   associated with the DSOCKET object.
    ProviderSocket  - TRUE if socket is created by the provider

Return Value:

    If  the function succeeds, it returns ERROR_SUCCESS, otherwise it returns a
    WinSock specific error code.
--*/
{
    INT					return_code;
    PDSOCKET            oldSocket;

    return_code = ERROR_SUCCESS;
	m_socket_handle = (HANDLE)SocketHandle;
    m_pvd_socket = ProviderSocket;

    oldSocket = static_cast<PDSOCKET>(WahInsertHandleContext(
                                        sm_context_table,
                                        this));
    if (oldSocket==this) {
        //
        // We managed to insert new socket object into the table, done
        //
        ;
    }
    else if (oldSocket!=NULL) {
        //
        // There was another socket object associated with the same
        // handle. This could happen in three cases:
        //  1) the socket was closed via CloseHandle and we never
        //      have had a chance to free it.
        //  2) the layered provider is reusing socket created by
        //      the base provider
        //  3) the socket was used by layered service provider
        //      which also never calls closesocket on it (just
        //      WSPCloseSocket which we never see -> yet another bug
        //      in the spec).
        // Of course, there could be a fourth case where the provider
        // gives us a bogus handle value, but we can't check for it
        // 
        // Wah call replaces the context in the table, so we just
        // need to dereference the old one, to account to refernce
        // we add when we create the object
        //

        oldSocket->DropDSocketReference();

    }
    else
        return_code = WSAENOBUFS;

    return return_code;
} // AssociateSocketHandle



INT
DSOCKET::DisassociateSocketHandle(
    )
/*++
Routine Description:

    This  procedure  removes  the (handle, DSOCKET) pair from the handle table.
    It also optionally destroys the handle.

Arguments:

    None
Return Value:

    None
--*/
{
    return WahRemoveHandleContext (sm_context_table, this);
}




PDSOCKET
DSOCKET::FindIFSSocket(
    IN  SOCKET     SocketHandle
    )
/*++
Routine Description

    This routine queries all IFS provider for the socket handle.
    If provider recognizes the socket, DSOCKET object for it
    is read from the table

Arguments:

    SocketHandle   - Supplies the client-level socket handle to be mapped.


Return Value:

    DSOCKET object or NULL in case the object cannot be found
--*/
{
    DWORD     flags;
    INT       result;
    PDPROCESS process = NULL;
    PDCATALOG catalog = NULL;
    PDSOCKET  temp_dsocket;

    //
    // Cannot find an association for the socket. Find the current
    // protocol catalog, and ask it to search the installed IFS providers
    // for one recognizing the socket.  Make sure the handle is valid
    //

    temp_dsocket = NULL;  // until proven otherwise

    if ( SocketHandle!=INVALID_SOCKET && // (NtCurrentProcess==(HANDLE)-1)
            GetHandleInformation( (HANDLE)SocketHandle, &flags ) ) {

        process = DPROCESS::GetCurrentDProcess();

        if( process!=NULL ) {

            catalog = process->GetProtocolCatalog();
            assert( catalog != NULL );

            result = catalog->FindIFSProviderForSocket( SocketHandle );

            if( result == ERROR_SUCCESS ) {
                //
                // One of the installed IFS providers recognized the socket.
                // Requery the context. If this fails, we'll just give up.
                //
                temp_dsocket = GetCountedDSocketFromSocketNoExport (SocketHandle);

                //
                // If we successed, mark socket as API socket because
                // we are going to return it from some API call.
                //
                if (temp_dsocket!=NULL)
                    temp_dsocket->m_api_socket = TRUE;
            }
        }
    }
   

    return(temp_dsocket);
} // FindIFSSocket


INT
DSOCKET::AddSpecialApiReference(
    IN SOCKET SocketHandle
    )
/*++

Routine Description:

    Mark socket so that we know that it was returned via API call to the
    application

Arguments:

    SocketHandle - The handle to reference.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/
{
    PDSOCKET Socket;

    //
    // First, get a pointer to the (newly created) socket.
    // No need to do export in this case.
    //

    Socket = GetCountedDSocketFromSocketNoExport(
              SocketHandle
              );

    if( Socket!=NULL ) {
        // The app may start using handle before it event sees it
        // which causes as to import it from the provider and set
        // this flag.
        // At least one java test app does this.
        //assert (Socket->m_api_socket==FALSE);
        Socket->m_api_socket = TRUE;
        Socket->DropDSocketReference();
        return NO_ERROR;
    }
    else {
        //
        // This can only happen if we are being cleaned up
        //
        assert (DPROCESS::GetCurrentDProcess()==NULL);
        return WSASYSCALLFAILURE;
    }

} // AddSpecialApiReference
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\dthread.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    dthread.cpp

Abstract:

    This  module  contains  the  implementation  of  the  DTHREAD class used in
    winsock2 DLL.

Author:

    Dirk Brandewie (dirk@mink.intel.com)   14-July-1995

Notes:

    $Revision:   1.27  $

    $Modtime:   08 Mar 1996 14:59:46  $

Revision History:

    most-recent-revision-date email-name
        description
    23-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Moved includes into precomp.h. Added
        debug/trace code.

--*/
#include "precomp.h"

extern DWORD gdwTlsIndex;

DWORD DTHREAD::sm_tls_index = TLS_OUT_OF_INDEXES;
// Initialize the static member to a known variable



INT
DTHREAD::DThreadClassInitialize()
/*++

Routine Description:

    This  function  performs  global  initialization  required  for the DTHREAD
    class.   This  function  must  be  called  before  any  DTHREAD objects are
    created.  In particular, this function reserves a thread-local storage slot
    for  the thread-local storage used by the WinSock 2 DLL.  Note that this is
    a "static" function with global scope instead of object-instance scope.

Arguments:

    None

Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it
    returns an appropriate WinSock error code.
--*/
{
    INT ReturnCode = WSASYSCALLFAILURE; // the user return code

    if (sm_tls_index == TLS_OUT_OF_INDEXES) {
        DEBUGF( DBG_TRACE,
                ("Initializing dthread class\n"));
        sm_tls_index = gdwTlsIndex;
        if (sm_tls_index != TLS_OUT_OF_INDEXES) {
            ReturnCode = ERROR_SUCCESS;
        } //if
    } //if
    else {
         ReturnCode = ERROR_SUCCESS;
    } //else

    return(ReturnCode);
} //DThreadClassInitialize




VOID
DTHREAD::DThreadClassCleanup()
/*++

Routine Description:

    This  routine  de-inits the thread class.  The thread local storage slot is
    freed.   Note that this is a "static" function with global scope instead of
    object-instance scope.

Arguments:

    None

Return Value:

    None
--*/
{
    //
    // NOTE: The following is bogus, as it means the tls index will never
    // get freed.  Have since taken care of things by alloc'ing/free'ing
    // tls index in DllMain (process attach/detach handlers)
    //

    //
    // This code is elided. We retain the tls index so that thread terminating
    // after the WSACleanup can free the per-thread storage. Since this
    // operation is done only when the thread actually detaches, there's
    // a race between deleting this tls index and the thread completing.
    // So, keep it around. Note that if another WSAStartup is done, the
    // code will simply use this index.
    //

    //
    // Resurected this code but now calling from DllMain (DLL_PROCESS_DETACH)
    // VadimE.
    //
    DEBUGF( DBG_TRACE,
            ("Cleaning up dthread class\n"));
    // Killing it again
    // taking care of it directly in DLLMain
    // VadimE
    if (sm_tls_index != TLS_OUT_OF_INDEXES)
        {
        // TlsFree(sm_tls_index); // Free the TLS slot
        sm_tls_index = TLS_OUT_OF_INDEXES;
    } //if

} //DThreadClassCleanup



INT
DTHREAD::CreateDThreadForCurrentThread(
    IN  PDPROCESS  Process,
    OUT PDTHREAD FAR * CurrentThread
    )
/*++

Routine Description:

    This  procedure  retrieves a reference to a DTHREAD object corresponding to
    the  current  thread.  It takes care of creating and initializing a DTHREAD
    object and installing it into the thread's thread-local storage if there is
    not already a DTHREAD object for this thread.  Note that this is a "static"
    function with global scope instead of object-instance scope.

    Note  that  this  is  the  ONLY  procedure  that should be used to create a
    DTHREAD   object  outside  of  the  DTHREAD  class.   The  constructor  and
    Initialize  function  should  only  be  used  internally within the DTHREAD
    class.

Arguments:

    Process       - Supplies a reference to the DPROCESS object associated with
                    this DTHREAD object.

    CurrentThread - Returns  the  DTHREAD  object  corresponding to the current
                    thread.

Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it
    returns an appropriate WinSock error code.
--*/
{
    INT ReturnCode = WSASYSCALLFAILURE;  // Return Code
    PDTHREAD LocalThread=NULL;            // Temp thread object pointer

    if (sm_tls_index != TLS_OUT_OF_INDEXES){
        // No thread object for the current thread so create one
        // and initialize the new object
        LocalThread = new(DTHREAD);
        if (LocalThread) {
            if (LocalThread->Initialize(Process) == ERROR_SUCCESS) {
                if (TlsSetValue(sm_tls_index, LocalThread)) {
                    *CurrentThread = LocalThread;
                    ReturnCode = ERROR_SUCCESS;
                } //if
            } //if

            if (ERROR_SUCCESS != ReturnCode){
                delete(LocalThread);
            } //if
        } //if
    } //if
    return(ReturnCode);
} //CreateDThreadForCurrentThread

VOID
DTHREAD::DestroyCurrentThread()
/*++

Routine Description:

    This routine destroys the thread object associated with the
    currently running thread.

Arguments:

Return Value:

    The  function  returns TRUE if the thread was sucessfully
    destroyed else FALSE
--*/
{
    PDTHREAD  Thread;

    // Is Thread local Storage been inited
    if (sm_tls_index != TLS_OUT_OF_INDEXES)
        {
        Thread = (DTHREAD*)TlsGetValue(sm_tls_index);
        if (Thread)
        {
            delete(Thread);
        } //if
    } //if
}



DTHREAD::DTHREAD()
/*++

Routine Description:

    DTHREAD  object  constructor.   Creates and returns a DTHREAD object.  Note
    that  the  DTHREAD object has not been fully initialized.  The "Initialize"
    member function must be the first member function called on the new DTHREAD
    object.

    Note  that  this  procedure  should  not be used to create a DTHREAD object
    outside  of  the  DTHREAD  class.   This procedure is only for internal use
    within  the DTHREAD class.  The static "GetCurrentDThread" procedure should
    be  used  to  retrieve  a reference to a DTHREAD object outside the DTHREAD
    class.

Arguments:

    None

Return Value:

--*/
{
    // Set data member to known values
    m_blocking_hook        = (FARPROC)&DTHREAD::DefaultBlockingHook;
    m_blocking_callback    = NULL;
    m_process              = NULL;
    m_hostent_buffer       = NULL;
    m_servent_buffer       = NULL;
    m_hostent_size         = 0;
    m_servent_size         = 0;
    m_is_blocking          = FALSE;
    m_io_cancelled         = FALSE;
    m_cancel_blocking_call = NULL;
    m_open_type            = 0;
    m_proto_info           = NULL;

} //DTHREAD




INT
DTHREAD::Initialize(
    IN PDPROCESS  Process
    )
/*++

Routine Description:

    Completes the initialization of the DTHREAD object.  This must be the first
    member  function  called  for the DTHREAD object.  This procedure should be
    called only once for the object.

    Note  that  this  procedure  should  only  be  called internally within the
    DTHREAD  class.   Outside  of  the class, the "GetCurrentDThread" procedure
    should  be  used  to  retrieve  a  reference to a fully initialized DTHREAD
    object.

Arguments:

    Process - Supplies  a reference to the DPROCESS object associated with this
              DTHREAD object.

Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it
    returns an appropriate WinSock error code.
--*/
{
    INT ReturnCode= WSASYSCALLFAILURE;

    m_process = Process; // Store process pointer

    DEBUGF( DBG_TRACE,
            ("Initializing dthread %p\n", this));

    // Init WAH thread:
    // Open the helper device
    if (Process->GetAsyncHelperDeviceID(&m_wah_helper_handle) ==
        ERROR_SUCCESS) {
        //Initialize helper thread ID structure
        if (WahOpenCurrentThread(m_wah_helper_handle,
                                 & m_wah_thread_id) == ERROR_SUCCESS) {
                ReturnCode = ERROR_SUCCESS;
        } //if
    } //if

    return(ReturnCode);
} //Initialize




DTHREAD::~DTHREAD()
/*++

Routine Description:

    DTHREAD  object  destructor.   This  procedure  has  the  responsibility to
    perform  any required shutdown operations for the DTHREAD object before the
    object  memory  is  deallocated.  The caller is reponsible for removing the
    object  from  its list in the DPROCESS object before destroying the DTHREAD
    object.

    This  procedure takes care of removing the DTHREAD object from thread-local
    storage.

Arguments:

    None

Return Value:

    None
--*/
{
    BOOL bresult;

    DEBUGF( DBG_TRACE,
            ("Freeing dthread %p\n", this));

    assert(sm_tls_index != TLS_OUT_OF_INDEXES);

    m_blocking_hook = NULL;

    delete m_hostent_buffer;
    delete m_servent_buffer;
    delete m_proto_info;

    bresult = TlsSetValue(
        sm_tls_index,  // dwTlsIndex
        (LPVOID) NULL  // lpvTlsValue
        );
    if (! bresult) {
        DEBUGF(
            DBG_WARN,
            ("Resetting thread-local storage for this thread\n"));
    }

    WahCloseThread(
        m_wah_helper_handle,
        & m_wah_thread_id);
    m_wah_helper_handle = NULL;

    m_process = NULL;
} //~DTHREAD


INT
DTHREAD::CancelBlockingCall()
{
    INT result;
    INT err;

    //
    // Bail if the thread is not blocking.
    //

    if( !m_is_blocking ) {

        return WSAEINVAL;

    }

    //
    // Verify we've got the blocking pointers setup correctly.
    //

    assert( m_blocking_callback != NULL );
    assert( m_cancel_blocking_call != NULL );

    //
    // If the IO request has not already been cancelled, call the
    // cancellation routine.
    //

    if( !m_io_cancelled ) {

        result = (m_cancel_blocking_call)( &err );

        if( result != ERROR_SUCCESS ) {
            return err;
        }

        m_io_cancelled = TRUE;

    }

    return ERROR_SUCCESS;

}   // DTHREAD::CancelBlockingCall


FARPROC
DTHREAD::SetBlockingHook(
    FARPROC lpBlockFunc
    )
{
    FARPROC PreviousHook;

    //
    // Snag the current hook so we can return it as the previous hook.
    //

    PreviousHook = m_blocking_hook;

    //
    // Set the current hook & the appropriate blocking callback.
    //

    if( lpBlockFunc == (FARPROC)&DTHREAD::DefaultBlockingHook ) {
        m_blocking_callback = NULL;
    } else {
        m_blocking_callback = &DTHREAD::BlockingCallback;
    }

    m_blocking_hook = lpBlockFunc;

    return PreviousHook;

}   // DTHREAD::SetBlockingHook


INT
DTHREAD::UnhookBlockingHook()
{

    //
    // Just reset everything back to defaults.
    //

    m_blocking_hook = (FARPROC)DTHREAD::DefaultBlockingHook;
    m_blocking_callback = NULL;

    return ERROR_SUCCESS;

}   // DTHREAD::UnhookBlockingHook


INT
WINAPI
DTHREAD::DefaultBlockingHook()
{

    MSG msg;
    BOOL retrievedMessage;

    __try {
        //
        // Get the next message for this thread, if any.
        //

        retrievedMessage = PeekMessage( &msg, NULL, 0, 0, PM_REMOVE );

        //
        // Process the message if we got one.
        //

        if ( retrievedMessage ) {
            TranslateMessage( &msg );
            DispatchMessage( &msg );
        }
    }
    __except (WS2_EXCEPTION_FILTER ()) {
        retrievedMessage = FALSE; 
    }

    //
    // If we got a message, indicate that we want to be called again.
    //

    return retrievedMessage;

}   // DTHREAD::DefaultBlockingHook


BOOL
CALLBACK
DTHREAD::BlockingCallback(
    DWORD_PTR dwContext
    )
{
    PDTHREAD Thread;

    assert( dwContext != 0 );

    //
    // Just grab the DTHREAD pointer directly out of the thread local
    // storage. Since we came in through a blocking hook, we must have
    // already setup this stuff.
    //

    Thread = (DTHREAD *)TlsGetValue( sm_tls_index );
    assert( Thread != NULL );

    //
    // Set the blocking flag and the pointer to the cancel function
    // and clear the i/o cancelled flag.
    //

    Thread->m_is_blocking = TRUE;
    Thread->m_cancel_blocking_call = (LPWSPCANCELBLOCKINGCALL)dwContext;
    Thread->m_io_cancelled = FALSE;

    //
    // Call the user's blocking hook.
    //

    assert( Thread->m_blocking_hook != NULL );
    assert( Thread->m_blocking_hook != (FARPROC)&DTHREAD::DefaultBlockingHook );

    while( (Thread->m_blocking_hook)() ) {

        //
        // This space intentionally left blank.
        //

    }

    //
    // Reset the blocking flag and return TRUE if everything was OK,
    // FALSE if the operation was cancelled.
    //

    Thread->m_is_blocking = FALSE;

    return !Thread->m_io_cancelled;

}   // DTHREAD::BlockingCallback





PGETPROTO_INFO
DTHREAD::GetProtoInfo()
/*++

Routine Description:

    Returns a pointer to the state structure used for the
    getprotobyXxx() APIs.

Arguments:

    None.

Return Value:

    Pointer to the state structure.

--*/
{

    //
    // Allocate the buffer if necessary.
    //

    if( m_proto_info == NULL ) {

        m_proto_info = new GETPROTO_INFO;

    }

    return m_proto_info;

} // GetProtoInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\dthook.cpp ===
/*++

  Copyright (c) 1995 Intel Corp

  Module Name:

    dthook.cpp

  Abstract:

    This module contains the hooks that allow specially-compiled
    versions of the WinSock 2 DLL call into the debug/trace DLL.

    For each function in the WinSock 2 API, this module has a hook
    function called DT_<function>, which, if WinSock 2 is compiled
    with the DEBUG_TRACING symbol defined, is exported under the name
    of the original function.  The hook function calls into the
    debug/trace DLL through the two entry points,
    WSA[Pre|Post]ApiNotify, which are wrapped around the real call to
    the API function.  Please see the debug/trace documentation for
    more details.

  Author:

    Michael A. Grafton

--*/

#include "precomp.h"

#if defined(DEBUG_TRACING)

//
// Static Globals
//

// Function pointers to the Debug/Trace DLL entry points
static LPFNWSANOTIFY PreApiNotifyFP = NULL;
static LPFNWSANOTIFY PostApiNotifyFP = NULL;
static LPFNWSAEXCEPTIONNOTIFY ExceptionNotifyFP = NULL;

// Handle to the Debug/Trace DLL module
static HMODULE       DTDll = NULL;
// Lock that facilitates module initialization on demand
// instead of doing this inside of DLLMain
static CRITICAL_SECTION DTHookSynchronization;
static BOOL          DTHookInitialized = FALSE;

// Static string to pass to Debug/Trace notification functions --
// The value of this variable should never be changed; however, the
// keyword 'const' causes bizarre compilation errors...
static char LibName[] = "WinSock2";


//
// Goodies to make it easier to catch exceptions in WS2_32.DLL and the
// service providers.
//

extern "C" {

LONG
DtExceptionFilter(
    LPEXCEPTION_POINTERS ExceptionPointers,
    LPSTR Routine
    );

} // extern "C"

// From ntrtl.h
extern "C" {

typedef USHORT (WINAPI * LPFNRTLCAPTURESTACKBACKTRACE) (
   IN ULONG FramesToSkip,
   IN ULONG FramesToCapture,
   OUT PVOID *BackTrace,
   OUT PULONG BackTraceHash OPTIONAL
   );


// Stack backtrace function pointer available on NT
LPFNRTLCAPTURESTACKBACKTRACE pRtlCaptureStackBackTrace = NULL;

#define RECORD_SOCKET_CREATOR(s)                                            \
    if ((s!=INVALID_SOCKET) &&                                              \
            (pRtlCaptureStackBackTrace!=NULL)) {                            \
        PDSOCKET    socket;                                                 \
        socket = DSOCKET::GetCountedDSocketFromSocketNoExport(s);           \
        if (socket!=NULL) {                                                 \
            for (INT _i=0; _i <sizeof (socket->m_CreatorBackTrace)/         \
                               sizeof (socket->m_CreatorBackTrace[0]); _i++)\
                socket->m_CreatorBackTrace[_i] = NULL;                      \
            pRtlCaptureStackBackTrace(                                      \
                        1,                                                  \
                        sizeof (socket->m_CreatorBackTrace) /               \
                            sizeof (socket->m_CreatorBackTrace[0]),         \
                        &socket->m_CreatorBackTrace[0],                     \
                        NULL);                                              \
            socket->DropDSocketReference ();                                \
        }                                                                   \
    }
} // extern "C"


VOID
DoDTHookInitialization (
    VOID
    );

#ifndef NOTHING
#define NOTHING
#endif

#define INVOKE_ROUTINE(routine)                                         \
            __try {                                                     \
                routine                                                 \
            } __except( DtExceptionFilter(                              \
                        GetExceptionInformation (),                     \
                        #routine                                        \
                        ) ) {                                           \
                NOTHING;                                                \
            }


//
// Functions
//


LPFNWSANOTIFY
GetPreApiNotifyFP(void)
/*++

  Function Description:

      Returns a pointer to the WSAPreApiNotify function exported by
      the Debug/Trace DLL.  This variable is global to this file only,
      and is initialized during DT_Initialize().

  Arguments:

      None.

  Return Value:

      Returns whatever is stored in PreApiNotifyFP.

--*/
{
    if (!DTHookInitialized) {
        DoDTHookInitialization ();
    }
    return(PreApiNotifyFP);
}





LPFNWSANOTIFY
GetPostApiNotifyFP(void)
/*++

  Function Description:

      Returns a pointer to the WSAPreApiNotify function exported by
      the Debug/Trace DLL.  This variable is global to this file only,
      and is initialized during DT_Initialize().

  Arguments:

      None.

  Return Value:

      Returns whatever is stored in PreApiNotifyFP.

--*/
{
    if (!DTHookInitialized) {
        DoDTHookInitialization ();
    }
    return(PostApiNotifyFP);
}





void
DTHookInitialize(void)
/*++

  Function Description:

      This function must be called from DLLMain to let
      this module initialize its critical section that protects
      the initialization below.

  Arguments:

      None.

  Return Value:

      None.

--*/
{
    InitializeCriticalSection (&DTHookSynchronization);
}

VOID
DoDTHookInitialization (
    VOID
    )
/*++

  Function Description:

      Intializes this hook module.  Loads the Debug/Trace DLL, if
      possible, and sets the global function pointers to point to the
      entry points exported by that DLL.  If the DLL can't be loaded,
      the function just returns and the function pointers are left at
      NULL.

      This function MUST be called before any of the hook functions
      are called, or the hook functions will not work.

  Arguments:

      None.

  Return Value:

      None.

--*/
{
    EnterCriticalSection (&DTHookSynchronization);
    if (!DTHookInitialized) {
        //
        // If we are running on NT, get pointer to stack back
        // trace recording function and keep record of socket creators
        //
        HMODULE hNtDll;

        hNtDll = GetModuleHandle (TEXT("ntdll.dll"));
        if (hNtDll!=NULL) {
            pRtlCaptureStackBackTrace = 
                (LPFNRTLCAPTURESTACKBACKTRACE)GetProcAddress (
                                                hNtDll,
                                                "RtlCaptureStackBackTrace");
        }


        DTDll = (HMODULE)LoadLibrary("dt_dll");

        if (DTDll != NULL) {

            PreApiNotifyFP = (LPFNWSANOTIFY)GetProcAddress(
                DTDll,
                "WSAPreApiNotify");

            PostApiNotifyFP = (LPFNWSANOTIFY)GetProcAddress(
                DTDll,
                "WSAPostApiNotify");

            ExceptionNotifyFP = (LPFNWSAEXCEPTIONNOTIFY)GetProcAddress(
                DTDll,
                "WSAExceptionNotify");
        }
        DTHookInitialized = TRUE;
    }
    LeaveCriticalSection (&DTHookSynchronization);
}



void
DTHookShutdown(void)
/*++

  Function Description:

      Should be called to shutdown Debug/Tracing.  The function
      pointers are set to NULL, and the DLL is unloaded from memory.

  Arguments:

      None.

  Return Value:

      None.

--*/
{
    if ((DTDll != NULL && DTDll!=INVALID_HANDLE_VALUE)) {
        FreeLibrary(DTDll);
    }

    PreApiNotifyFP = NULL;
    PostApiNotifyFP = NULL;
    DTHookInitialized = FALSE;
    DeleteCriticalSection (&DTHookSynchronization);
}


//
// Hook Functions for WinSock2 API.
//

// This comment serves as a function comment for all the hook
// functions.  There  is  one hook function for each function exported
// by the WinSock 2 API.  Each hook  function has the exact same
// parameter profile of the corresponding API function.   Each one
// calls PREAPINOTIFY and POSTAPINOTIFY macros, which call into   the
// Debug/Trace   DLL,   if  it  was  loaded  successfully.   After
// PREAPINOTIFY,  the  hook  functions  call  the  real WS2 functions.
// See the Debug/Trace documentation for more information.
//
// Note  that  all of the debug-hook functions must be declared with C
// language binding, while the internally-used initialization and
// utility functions must not be.

extern "C" {


#ifdef _X86_
#pragma optimize("y", off)  // Make sure we can at least get the caller.
#endif

SOCKET WSAAPI
DTHOOK_accept (
    SOCKET s,
    struct sockaddr FAR *addr,
    int FAR *addrlen)
{
    SOCKET ReturnValue;

    if (PREAPINOTIFY((DTCODE_accept,
                       &ReturnValue,
                       LibName,
                       &s,
                       &addr,
                       &addrlen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = accept(s, addr, addrlen);
        );

    RECORD_SOCKET_CREATOR(ReturnValue);

    POSTAPINOTIFY((DTCODE_accept,
                    &ReturnValue,
                    LibName,
                    &s,
                    &addr,
                    &addrlen));

    return(ReturnValue);
}
#ifdef _X86_
#pragma optimize("", on)
#endif



int WSAAPI
DTHOOK_bind (
    SOCKET s,
    const struct sockaddr FAR *name,
    int namelen)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_bind,
                       &ReturnValue,
                       LibName,
                       &s,
                       &name,
                       &namelen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = bind(s, name, namelen);
        );

    POSTAPINOTIFY((DTCODE_bind,
                    &ReturnValue,
                    LibName,
                    &s,
                    &name,
                    &namelen));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_closesocket (
    SOCKET s)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_closesocket,
                       &ReturnValue,
                       LibName,
                       &s))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = closesocket(s);
        );

    POSTAPINOTIFY((DTCODE_closesocket,
                    &ReturnValue,
                    LibName,
                    &s));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_connect (
    SOCKET s,
    const struct sockaddr FAR *name,
    int namelen)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_connect,
                       &ReturnValue,
                       LibName,
                       &s,
                       &name,
                       &namelen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = connect(s, name, namelen);
        );

    POSTAPINOTIFY((DTCODE_connect,
                    &ReturnValue,
                    LibName,
                    &s,
                    &name,
                    &namelen));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_ioctlsocket (
    SOCKET s,
    long cmd,
    u_long FAR *argp)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_ioctlsocket,
                       &ReturnValue,
                       LibName,
                       &s,
                       &cmd,
                       &argp))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = ioctlsocket(s, cmd, argp);
        );

    POSTAPINOTIFY((DTCODE_ioctlsocket,
                    &ReturnValue,
                    LibName,
                    &s,
                    &cmd,
                    &argp));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_getpeername (
    SOCKET s,
    struct sockaddr FAR *name,
    int FAR * namelen)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_getpeername,
                       &ReturnValue,
                       LibName,
                       &s,
                       &name,
                       &namelen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = getpeername(s, name, namelen);
        );

    POSTAPINOTIFY((DTCODE_getpeername,
                    &ReturnValue,
                    LibName,
                    &s,
                    &name,
                    &namelen));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_getsockname (
    SOCKET s,
    struct sockaddr FAR *name,
    int FAR * namelen)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_getsockname,
                       &ReturnValue,
                       LibName,
                       &s,
                       &name,
                       &namelen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = getsockname(s, name, namelen);
        );

    POSTAPINOTIFY((DTCODE_getsockname,
                    &ReturnValue,
                    LibName,
                    &s,
                    &name,
                    &namelen));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_getsockopt (
    SOCKET s,
    int level,
    int optname,
    char FAR * optval,
    int FAR *optlen)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_getsockopt,
                       &ReturnValue,
                       LibName,
                       &s,
                       &level,
                       &optname,
                       &optval,
                       &optlen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = getsockopt(s, level, optname, optval, optlen);
        );

    POSTAPINOTIFY((DTCODE_getsockopt,
                    &ReturnValue,
                    LibName,
                    &s,
                    &level,
                    &optname,
                    &optval,
                    &optlen));

    return(ReturnValue);
}




u_long WSAAPI
DTHOOK_htonl (
    u_long hostlong)
{
    u_long ReturnValue;

    if (PREAPINOTIFY((DTCODE_htonl,
                       &ReturnValue,
                       LibName,
                       &hostlong))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = htonl(hostlong);
        );

    POSTAPINOTIFY((DTCODE_htonl,
                    &ReturnValue,
                    LibName,
                    &hostlong));

    return(ReturnValue);
}




u_short WSAAPI
DTHOOK_htons (
    u_short hostshort)
{
    u_short ReturnValue;

    if (PREAPINOTIFY((DTCODE_htons,
                       &ReturnValue,
                       LibName,
                       &hostshort))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = htons(hostshort);
        );

    POSTAPINOTIFY((DTCODE_htons,
                    &ReturnValue,
                    LibName,
                    &hostshort));

    return(ReturnValue);
}




unsigned long WSAAPI
DTHOOK_inet_addr (
    const char FAR * cp)
{
    unsigned long ReturnValue;

    if (PREAPINOTIFY((DTCODE_inet_addr,
                       &ReturnValue,
                       LibName,
                       &cp))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = inet_addr(cp);
        );

    POSTAPINOTIFY((DTCODE_inet_addr,
                    &ReturnValue,
                    LibName,
                    &cp));

    return(ReturnValue);
}




char FAR * WSAAPI
DTHOOK_inet_ntoa (
    struct in_addr in)
{
    char FAR *ReturnValue;

    if (PREAPINOTIFY((DTCODE_inet_ntoa,
                       &ReturnValue,
                       LibName,
                       &in))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = inet_ntoa(in);
        );

    POSTAPINOTIFY((DTCODE_inet_ntoa,
                    &ReturnValue,
                    LibName,
                    &in));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_listen (
    SOCKET s,
    int backlog)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_listen,
                       &ReturnValue,
                       LibName,
                       &s,
                       &backlog))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = listen(s, backlog);
        );

    POSTAPINOTIFY((DTCODE_listen,
                    &ReturnValue,
                    LibName,
                    &s,
                    &backlog));

    return(ReturnValue);
}




u_long WSAAPI
DTHOOK_ntohl (
    u_long netlong)
{
    u_long ReturnValue;

    if (PREAPINOTIFY((DTCODE_ntohl,
                       &ReturnValue,
                       LibName,
                       &netlong))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = ntohl(netlong);
        );

    POSTAPINOTIFY((DTCODE_ntohl,
                    &ReturnValue,
                    LibName,
                    &netlong));

    return(ReturnValue);
}




u_short WSAAPI
DTHOOK_ntohs (
    u_short netshort)
{
    u_short ReturnValue;

    if (PREAPINOTIFY((DTCODE_ntohs,
                       &ReturnValue,
                       LibName,
                       &netshort))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = ntohs(netshort);
        );

    POSTAPINOTIFY((DTCODE_ntohs,
                    &ReturnValue,
                    LibName,
                    &netshort));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_recv (
    SOCKET s,
    char FAR * buf,
    int len,
    int flags)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_recv,
                       &ReturnValue,
                       LibName,
                       &s,
                       &buf,
                       &len,
                       &flags))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = recv(s, buf, len, flags);
        );

    POSTAPINOTIFY((DTCODE_recv,
                    &ReturnValue,
                    LibName,
                    &s,
                    &buf,
                    &len,
                    &flags));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_recvfrom (
    SOCKET s,
    char FAR * buf,
    int len,
    int flags,
    struct sockaddr FAR *from,
    int FAR * fromlen)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_recvfrom,
                       &ReturnValue,
                       LibName,
                       &s,
                       &buf,
                       &len,
                       &flags,
                       &from,
                       &fromlen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = recvfrom(s, buf, len, flags, from, fromlen);
        );

    POSTAPINOTIFY((DTCODE_recvfrom,
                    &ReturnValue,
                    LibName,
                    &s,
                    &buf,
                    &len,
                    &flags,
                    &from,
                    &fromlen));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_select (
    int nfds,
    fd_set FAR *readfds,
    fd_set FAR *writefds,
    fd_set FAR *exceptfds,
    const struct timeval FAR *timeout)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_select,
                       &ReturnValue,
                       LibName,
                       &nfds,
                       &readfds,
                       &writefds,
                       &exceptfds,
                       &timeout))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = select(nfds, readfds, writefds, exceptfds, timeout);
        );

    POSTAPINOTIFY((DTCODE_select,
                    &ReturnValue,
                    LibName,
                    &nfds,
                    &readfds,
                    &writefds,
                    &exceptfds,
                    &timeout));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_send (
    SOCKET s,
    const char FAR * buf,
    int len,
    int flags)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_send,
                       &ReturnValue,
                       LibName,
                       &s,
                       &buf,
                       &len,
                       &flags))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = send(s, buf, len, flags);
        );

    POSTAPINOTIFY((DTCODE_send,
                    &ReturnValue,
                    LibName,
                    &s,
                    &buf,
                    &len,
                    &flags));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_sendto (
    SOCKET s,
    const char FAR * buf,
    int len,
    int flags,
    const struct sockaddr FAR *to,
    int tolen)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_sendto,
                       &ReturnValue,
                       LibName,
                       &s,
                       &buf,
                       &len,
                       &flags,
                       &to,
                       &tolen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = sendto(s, buf, len, flags, to, tolen);
        );

    POSTAPINOTIFY((DTCODE_sendto,
                    &ReturnValue,
                    LibName,
                    &s,
                    &buf,
                    &len,
                    &flags,
                    &to,
                    &tolen));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_setsockopt (
    SOCKET s,
    int level,
    int optname,
    const char FAR * optval,
    int optlen)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_setsockopt,
                       &ReturnValue,
                       LibName,
                       &s,
                       &level,
                       &optname,
                       &optval,
                       &optlen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = setsockopt(s, level, optname, optval, optlen);
        );

    POSTAPINOTIFY((DTCODE_setsockopt,
                    &ReturnValue,
                    LibName,
                    &s,
                    &level,
                    &optname,
                    &optval,
                    &optlen));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_shutdown (
    SOCKET s,
    int how)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_shutdown,
                       &ReturnValue,
                       LibName,
                       &s,
                       &how))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = shutdown(s, how);
        );

    POSTAPINOTIFY((DTCODE_shutdown,
                    &ReturnValue,
                    LibName,
                    &s,
                    &how));

    return(ReturnValue);
}




#ifdef _X86_
#pragma optimize("y", off)  // Make sure we can at least get the caller.
#endif

SOCKET WSAAPI
DTHOOK_socket (
    int af,
    int type,
    int protocol)
{
    SOCKET ReturnValue;

    if (PREAPINOTIFY((DTCODE_socket,
                       &ReturnValue,
                       LibName,
                       &af,
                       &type,
                       &protocol))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = socket(af, type, protocol);
        );

    RECORD_SOCKET_CREATOR(ReturnValue);

    POSTAPINOTIFY((DTCODE_socket,
                    &ReturnValue,
                    LibName,
                    &af,
                    &type,
                    &protocol));

    return(ReturnValue);
}
#ifdef _X86_
#pragma optimize("", on)
#endif



#ifdef _X86_
#pragma optimize("y", off)  // Make sure we can at least get the caller.
#endif

SOCKET WSAAPI
DTHOOK_WSAAccept (
    SOCKET s,
    struct sockaddr FAR *addr,
    LPINT addrlen,
    LPCONDITIONPROC lpfnCondition,
    DWORD dwCallbackData)
{
    SOCKET ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAAccept,
                       &ReturnValue,
                       LibName,
                       &s,
                       &addr,
                       &addrlen,
                       &lpfnCondition,
                       &dwCallbackData))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAAccept(s, addr, addrlen, lpfnCondition,
                                dwCallbackData);
        );

    RECORD_SOCKET_CREATOR(ReturnValue);

    POSTAPINOTIFY((DTCODE_WSAAccept,
                    &ReturnValue,
                    LibName,
                    &s,
                    &addr,
                    &addrlen,
                    &lpfnCondition,
                    &dwCallbackData));

    return(ReturnValue);
}
#ifdef _X86_
#pragma optimize("", on)
#endif



int WSAAPI
DTHOOK_WSAAsyncSelect(
    SOCKET s,
    HWND hWnd,
    u_int wMsg,
    long lEvent)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAAsyncSelect,
                       &ReturnValue,
                       LibName,
                       &s,
                       &hWnd,
                       &wMsg,
                       &lEvent))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAAsyncSelect(s, hWnd, wMsg, lEvent);
        );

    POSTAPINOTIFY((DTCODE_WSAAsyncSelect,
                    &ReturnValue,
                    LibName,
                    &s,
                    &hWnd,
                    &wMsg,
                    &lEvent));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSACleanup(
    void)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSACleanup,
                       &ReturnValue,
                       LibName))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSACleanup();
        );

    POSTAPINOTIFY((DTCODE_WSACleanup,
                    &ReturnValue,
                    LibName));

    return(ReturnValue);
}




BOOL WSAAPI
DTHOOK_WSACloseEvent (
    WSAEVENT hEvent)
{
    BOOL ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSACloseEvent,
                       &ReturnValue,
                       LibName,
                       &hEvent))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSACloseEvent(hEvent);
        );

    POSTAPINOTIFY((DTCODE_WSACloseEvent,
                    &ReturnValue,
                    LibName,
                    &hEvent));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSAConnect (
    SOCKET s,
    const struct sockaddr FAR *name,
    int namelen,
    LPWSABUF lpCallerData,
    LPWSABUF lpCalleeData,
    LPQOS lpSQOS,
    LPQOS lpGQOS)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAConnect,
                       &ReturnValue,
                       LibName,
                       &s,
                       &name,
                       &namelen,
                       &lpCallerData,
                       &lpCalleeData,
                       &lpSQOS,
                       &lpGQOS))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAConnect(s, name, namelen, lpCallerData, lpCalleeData,
                                 lpSQOS, lpGQOS);
        );

    POSTAPINOTIFY((DTCODE_WSAConnect,
                    &ReturnValue,
                    LibName,
                    &s,
                    &name,
                    &namelen,
                    &lpCallerData,
                    &lpCalleeData,
                    &lpSQOS,
                    &lpGQOS));

    return(ReturnValue);
}




WSAEVENT WSAAPI
DTHOOK_WSACreateEvent (
    void)
{
    WSAEVENT ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSACreateEvent,
                       &ReturnValue,
                       LibName))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSACreateEvent();
        );

    POSTAPINOTIFY((DTCODE_WSACreateEvent,
                    &ReturnValue,
                    LibName));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSADuplicateSocketA (
    SOCKET s,
    DWORD dwProcessId,
    LPWSAPROTOCOL_INFOA lpProtocolInfo)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSADuplicateSocketA,
                       &ReturnValue,
                       LibName,
                       &s,
                       &dwProcessId,
                       &lpProtocolInfo))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSADuplicateSocketA(s, dwProcessId, lpProtocolInfo);
        );

    POSTAPINOTIFY((DTCODE_WSADuplicateSocketA,
                    &ReturnValue,
                    LibName,
                    &s,
                    &dwProcessId,
                    &lpProtocolInfo));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSADuplicateSocketW (
    SOCKET s,
    DWORD dwProcessId,
    LPWSAPROTOCOL_INFOW lpProtocolInfo)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSADuplicateSocketW,
                       &ReturnValue,
                       LibName,
                       &s,
                       &dwProcessId,
                       &lpProtocolInfo))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSADuplicateSocketW(s, dwProcessId, lpProtocolInfo);
        );

    POSTAPINOTIFY((DTCODE_WSADuplicateSocketW,
                    &ReturnValue,
                    LibName,
                    &s,
                    &dwProcessId,
                    &lpProtocolInfo));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSAEnumNetworkEvents (
    SOCKET s,
    WSAEVENT hEventObject,
    LPWSANETWORKEVENTS lpNetworkEvents)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAEnumNetworkEvents,
                       &ReturnValue,
                       LibName,
                       &s,
                       &hEventObject,
                       &lpNetworkEvents))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAEnumNetworkEvents(s, hEventObject, lpNetworkEvents);
        );

    POSTAPINOTIFY((DTCODE_WSAEnumNetworkEvents,
                    &ReturnValue,
                    LibName,
                    &s,
                    &hEventObject,
                    &lpNetworkEvents));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSAEnumProtocolsA (
    LPINT lpiProtocols,
    LPWSAPROTOCOL_INFOA lpProtocolBuffer,
    LPDWORD lpdwBufferLength)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAEnumProtocolsA,
                       &ReturnValue,
                       LibName,
                       &lpiProtocols,
                       &lpProtocolBuffer,
                       &lpdwBufferLength))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAEnumProtocolsA(lpiProtocols, lpProtocolBuffer,
                                        lpdwBufferLength);
        );

    POSTAPINOTIFY((DTCODE_WSAEnumProtocolsA,
                    &ReturnValue,
                    LibName,
                    &lpiProtocols,
                    &lpProtocolBuffer,
                    &lpdwBufferLength));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSAEnumProtocolsW (
    LPINT lpiProtocols,
    LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    LPDWORD lpdwBufferLength)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAEnumProtocolsW,
                       &ReturnValue,
                       LibName,
                       &lpiProtocols,
                       &lpProtocolBuffer,
                       &lpdwBufferLength))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAEnumProtocolsW(lpiProtocols, lpProtocolBuffer,
                                        lpdwBufferLength);
        );

    POSTAPINOTIFY((DTCODE_WSAEnumProtocolsW,
                    &ReturnValue,
                    LibName,
                    &lpiProtocols,
                    &lpProtocolBuffer,
                    &lpdwBufferLength));

    return(ReturnValue);
}





int WSPAPI
DTHOOK_WSCEnumProtocols (
    LPINT lpiProtocols,
    LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    LPDWORD lpdwBufferLength,
    LPINT  lpErrno)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSCEnumProtocols,
                       &ReturnValue,
                       LibName,
                       &lpiProtocols,
                       &lpProtocolBuffer,
                       &lpdwBufferLength,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCEnumProtocols(lpiProtocols, lpProtocolBuffer,
                                       lpdwBufferLength, lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WSCEnumProtocols,
                    &ReturnValue,
                    LibName,
                    &lpiProtocols,
                    &lpProtocolBuffer,
                    &lpdwBufferLength,
                    &lpErrno));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSAEventSelect (
    SOCKET s,
    WSAEVENT hEventObject,
    long lNetworkEvents)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAEventSelect,
                       &ReturnValue,
                       LibName,
                       &s,
                       &hEventObject,
                       &lNetworkEvents))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAEventSelect(s, hEventObject, lNetworkEvents);
        );

    POSTAPINOTIFY((DTCODE_WSAEventSelect,
                    &ReturnValue,
                    LibName,
                    &s,
                    &hEventObject,
                    &lNetworkEvents));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSAGetLastError(
    void)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAGetLastError,
                       &ReturnValue,
                       LibName))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAGetLastError();
        );

    POSTAPINOTIFY((DTCODE_WSAGetLastError,
                    &ReturnValue,
                    LibName));

    return(ReturnValue);
}




BOOL WSAAPI
DTHOOK_WSAGetOverlappedResult (
    SOCKET s,
    LPWSAOVERLAPPED lpOverlapped,
    LPDWORD lpcbTransfer,
    BOOL fWait,
    LPDWORD lpdwFlags)
{
    BOOL ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAGetOverlappedResult,
                       &ReturnValue,
                       LibName,
                       &s,
                       &lpOverlapped,
                       &lpcbTransfer,
                       &fWait,
                       &lpdwFlags))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAGetOverlappedResult(s, lpOverlapped, lpcbTransfer,
                                             fWait, lpdwFlags);
        );

    POSTAPINOTIFY((DTCODE_WSAGetOverlappedResult,
                    &ReturnValue,
                    LibName,
                    &s,
                    &lpOverlapped,
                    &lpcbTransfer,
                    &fWait,
                    &lpdwFlags));

    return(ReturnValue);
}




BOOL WSAAPI
DTHOOK_WSAGetQOSByName (
    SOCKET s,
    LPWSABUF lpQOSName,
    LPQOS lpQOS)
{
    BOOL ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAGetQOSByName,
                       &ReturnValue,
                       LibName,
                       &s,
                       &lpQOSName,
                       &lpQOS))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAGetQOSByName(s, lpQOSName, lpQOS);
        );

    POSTAPINOTIFY((DTCODE_WSAGetQOSByName,
                    &ReturnValue,
                    LibName,
                    &s,
                    &lpQOSName,
                    &lpQOS));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSAHtonl (
    SOCKET s,
    u_long hostlong,
    u_long FAR * lpnetlong)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAHtonl,
                       &ReturnValue,
                       LibName,
                       &s,
                       &hostlong,
                       &lpnetlong))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAHtonl(s, hostlong, lpnetlong);
        );

    POSTAPINOTIFY((DTCODE_WSAHtonl,
                    &ReturnValue,
                    LibName,
                    &s,
                    &hostlong,
                    &lpnetlong));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSAHtons (
    SOCKET s,
    u_short hostshort,
    u_short FAR * lpnetshort)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAHtons,
                       &ReturnValue,
                       LibName,
                       &s,
                       &hostshort,
                       &lpnetshort))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAHtons(s, hostshort, lpnetshort);
        );

    POSTAPINOTIFY((DTCODE_WSAHtons,
                    &ReturnValue,
                    LibName,
                    &s,
                    &hostshort,
                    &lpnetshort));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSAIoctl (
    SOCKET s,
    DWORD dwIoControlCode,
    LPVOID lpvInBuffer,
    DWORD cbInBuffer,
    LPVOID lpvOutBuffer,
    DWORD cbOutBuffer,
    LPDWORD lpcbBytesReturned,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAIoctl,
                       &ReturnValue,
                       LibName,
                       &s,
                       &dwIoControlCode,
                       &lpvInBuffer,
                       &cbInBuffer,
                       &lpvOutBuffer,
                       &cbOutBuffer,
                       &lpcbBytesReturned,
                       &lpOverlapped,
                       &lpCompletionRoutine))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAIoctl(s, dwIoControlCode, lpvInBuffer, cbInBuffer,
                               lpvOutBuffer, cbOutBuffer, lpcbBytesReturned,
                               lpOverlapped, lpCompletionRoutine);
        );

    POSTAPINOTIFY((DTCODE_WSAIoctl,
                    &ReturnValue,
                    LibName,
                    &s,
                    &dwIoControlCode,
                    &lpvInBuffer,
                    &cbInBuffer,
                    &lpvOutBuffer,
                    &cbOutBuffer,
                    &lpcbBytesReturned,
                    &lpOverlapped,
                    &lpCompletionRoutine));

    return(ReturnValue);
}




#ifdef _X86_
#pragma optimize("y", off)  // Make sure we can at least get the caller.
#endif

SOCKET WSAAPI
DTHOOK_WSAJoinLeaf (
    SOCKET s,
    const struct sockaddr FAR * name,
    int namelen,
    LPWSABUF lpCallerData,
    LPWSABUF lpCalleeData,
    LPQOS lpSQOS,
    LPQOS lpGQOS,
    DWORD dwFlags)
{
    SOCKET ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAJoinLeaf,
                       &ReturnValue,
                       LibName,
                       &s,
                       &name,
                       &namelen,
                       &lpCallerData,
                       &lpCalleeData,
                       &lpSQOS,
                       &lpGQOS,
                       &dwFlags))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAJoinLeaf(s, name, namelen, lpCallerData, lpCalleeData,
                                  lpSQOS, lpGQOS, dwFlags);
        );

    if (ReturnValue!=s) {
        RECORD_SOCKET_CREATOR(ReturnValue);
    }

    POSTAPINOTIFY((DTCODE_WSAJoinLeaf,
                    &ReturnValue,
                    LibName,
                    &s,
                    &name,
                    &namelen,
                    &lpCallerData,
                    &lpCalleeData,
                    &lpSQOS,
                    &lpGQOS,
                    &dwFlags));

    return(ReturnValue);
}
#ifdef _X86_
#pragma optimize("", on)
#endif



int WSAAPI
DTHOOK_WSANtohl (
    SOCKET s,
    u_long netlong,
    u_long FAR * lphostlong)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSANtohl,
                       &ReturnValue,
                       LibName,
                       &s,
                       &netlong,
                       &lphostlong))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSANtohl(s, netlong, lphostlong);
        );

    POSTAPINOTIFY((DTCODE_WSANtohl,
                    &ReturnValue,
                    LibName,
                    &s,
                    &netlong,
                    &lphostlong));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSANtohs (
    SOCKET s,
    u_short netshort,
    u_short FAR * lphostshort)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSANtohs,
                       &ReturnValue,
                       LibName,
                       &s,
                       &netshort,
                       &lphostshort))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSANtohs(s, netshort, lphostshort);
        );

    POSTAPINOTIFY((DTCODE_WSANtohs,
                    &ReturnValue,
                    LibName,
                    &s,
                    &netshort,
                    &lphostshort));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSARecv (
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesRecvd,
    LPDWORD lpFlags,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSARecv,
                       &ReturnValue,
                       LibName,
                       &s,
                       &lpBuffers,
                       &dwBufferCount,
                       &lpNumberOfBytesRecvd,
                       &lpFlags,
                       &lpOverlapped,
                       &lpCompletionRoutine))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSARecv(s, lpBuffers, dwBufferCount, lpNumberOfBytesRecvd,
                              lpFlags, lpOverlapped, lpCompletionRoutine);
        );

    POSTAPINOTIFY((DTCODE_WSARecv,
                    &ReturnValue,
                    LibName,
                    &s,
                    &lpBuffers,
                    &dwBufferCount,
                    &lpNumberOfBytesRecvd,
                    &lpFlags,
                    &lpOverlapped,
                    &lpCompletionRoutine));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSARecvDisconnect (
    SOCKET s,
    LPWSABUF lpInboundDisconnectData)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSARecvDisconnect,
                       &ReturnValue,
                       LibName,
                       &s,
                       &lpInboundDisconnectData))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSARecvDisconnect(s, lpInboundDisconnectData);
        );

    POSTAPINOTIFY((DTCODE_WSARecvDisconnect,
                    &ReturnValue,
                    LibName,
                    &s,
                    &lpInboundDisconnectData));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSARecvFrom (
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesRecvd,
    LPDWORD lpFlags,
    struct sockaddr FAR * lpFrom,
    LPINT lpFromlen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSARecvFrom,
                       &ReturnValue,
                       LibName,
                       &s,
                       &lpBuffers,
                       &dwBufferCount,
                       &lpNumberOfBytesRecvd,
                       &lpFlags,
                       &lpFrom,
                       &lpFromlen,
                       &lpOverlapped,
                       &lpCompletionRoutine))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSARecvFrom(s, lpBuffers, dwBufferCount,
                                  lpNumberOfBytesRecvd, lpFlags, lpFrom,
                                  lpFromlen, lpOverlapped,
                                  lpCompletionRoutine);
        );

    POSTAPINOTIFY((DTCODE_WSARecvFrom,
                    &ReturnValue,
                    LibName,
                    &s,
                    &lpBuffers,
                    &dwBufferCount,
                    &lpNumberOfBytesRecvd,
                    &lpFlags,
                    &lpFrom,
                    &lpFromlen,
                    &lpOverlapped,
                    &lpCompletionRoutine));

    return(ReturnValue);
}




BOOL WSAAPI
DTHOOK_WSAResetEvent (
    WSAEVENT hEvent)
{
    BOOL ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAResetEvent,
                       &ReturnValue,
                       LibName,
                       &hEvent))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAResetEvent(hEvent);
        );

    POSTAPINOTIFY((DTCODE_WSAResetEvent,
                    &ReturnValue,
                    LibName,
                    &hEvent));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSASend (
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesSent,
    DWORD dwFlags,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSASend,
                       &ReturnValue,
                       LibName,
                       &s,
                       &lpBuffers,
                       &dwBufferCount,
                       &lpNumberOfBytesSent,
                       &dwFlags,
                       &lpOverlapped,
                       &lpCompletionRoutine))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSASend(s, lpBuffers, dwBufferCount, lpNumberOfBytesSent,
                              dwFlags, lpOverlapped, lpCompletionRoutine);
        );

    POSTAPINOTIFY((DTCODE_WSASend,
                    &ReturnValue,
                    LibName,
                    &s,
                    &lpBuffers,
                    &dwBufferCount,
                    &lpNumberOfBytesSent,
                    &dwFlags,
                    &lpOverlapped,
                    &lpCompletionRoutine));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSASendDisconnect (
    SOCKET s,
    LPWSABUF lpOutboundDisconnectData)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSASendDisconnect,
                       &ReturnValue,
                       LibName,
                       &s,
                       &lpOutboundDisconnectData))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSASendDisconnect(s, lpOutboundDisconnectData);
        );

    POSTAPINOTIFY((DTCODE_WSASendDisconnect,
                    &ReturnValue,
                    LibName,
                    &s,
                    &lpOutboundDisconnectData));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSASendTo (
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesSent,
    DWORD dwFlags,
    const struct sockaddr FAR * lpTo,
    int iTolen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSASendTo,
                       &ReturnValue,
                       LibName,
                       &s,
                       &lpBuffers,
                       &dwBufferCount,
                       &lpNumberOfBytesSent,
                       &dwFlags,
                       &lpTo,
                       &iTolen,
                       &lpOverlapped,
                       &lpCompletionRoutine))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSASendTo(s, lpBuffers, dwBufferCount,
                                lpNumberOfBytesSent, dwFlags, lpTo, iTolen,
                                lpOverlapped, lpCompletionRoutine);
        );

    POSTAPINOTIFY((DTCODE_WSASendTo,
                    &ReturnValue,
                    LibName,
                    &s,
                    &lpBuffers,
                    &dwBufferCount,
                    &lpNumberOfBytesSent,
                    &dwFlags,
                    &lpTo,
                    &iTolen,
                    &lpOverlapped,
                    &lpCompletionRoutine));

    return(ReturnValue);
}




BOOL WSAAPI
DTHOOK_WSASetEvent(
    WSAEVENT hEvent)
{
    BOOL ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSASetEvent,
                       &ReturnValue,
                       LibName,
                       &hEvent))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSASetEvent(hEvent);
        );

    POSTAPINOTIFY((DTCODE_WSASetEvent,
                    &ReturnValue,
                    LibName,
                    &hEvent));

    return(ReturnValue);
}




void WSAAPI
DTHOOK_WSASetLastError(
    int iError)
{
    if (PREAPINOTIFY((DTCODE_WSASetLastError,
                       NULL,
                       LibName,
                       &iError))) {

        return;
    }

    WSASetLastError(iError);

    POSTAPINOTIFY((DTCODE_WSASetLastError,
                    NULL,
                    LibName,
                    &iError));

    return;
}




#ifdef _X86_
#pragma optimize("y", off)  // Make sure we can at least get the caller.
#endif

SOCKET WSAAPI
DTHOOK_WSASocketA(
    int af,
    int type,
    int protocol,
    LPWSAPROTOCOL_INFOA lpProtocolInfo,
    GROUP g,
    DWORD dwFlags)
{

    SOCKET ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSASocketA,
                       &ReturnValue,
                       LibName,
                       &af,
                       &type,
                       &protocol,
                       &lpProtocolInfo,
                       &g,
                       &dwFlags))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSASocketA(af, type, protocol, lpProtocolInfo, g,
                                 dwFlags);
        );

    RECORD_SOCKET_CREATOR(ReturnValue);

    POSTAPINOTIFY((DTCODE_WSASocketA,
                    &ReturnValue,
                    LibName,
                    &af,
                    &type,
                    &protocol,
                    &lpProtocolInfo,
                    &g,
                    &dwFlags));

    return(ReturnValue);
}
#ifdef _X86_
#pragma optimize("", on)
#endif



#ifdef _X86_
#pragma optimize("y", off)  // Make sure we can at least get the caller.
#endif

SOCKET WSAAPI
DTHOOK_WSASocketW(
    int af,
    int type,
    int protocol,
    LPWSAPROTOCOL_INFOW lpProtocolInfo,
    GROUP g,
    DWORD dwFlags)
{

    SOCKET ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSASocketW,
                       &ReturnValue,
                       LibName,
                       &af,
                       &type,
                       &protocol,
                       &lpProtocolInfo,
                       &g,
                       &dwFlags))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSASocketW(af, type, protocol, lpProtocolInfo, g,
                                 dwFlags);
        );

   RECORD_SOCKET_CREATOR(ReturnValue);

   POSTAPINOTIFY((DTCODE_WSASocketW,
                    &ReturnValue,
                    LibName,
                    &af,
                    &type,
                    &protocol,
                    &lpProtocolInfo,
                    &g,
                    &dwFlags));

    return(ReturnValue);
}
#ifdef _X86_
#pragma optimize("", on)
#endif



int WSAAPI
DTHOOK_WSAStartup(
    WORD wVersionRequested,
    LPWSADATA lpWSAData)
{

    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAStartup,
                       &ReturnValue,
                       LibName,
                       &wVersionRequested,
                       &lpWSAData))) {
        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAStartup(wVersionRequested, lpWSAData);
        );

    POSTAPINOTIFY((DTCODE_WSAStartup,
                    &ReturnValue,
                    LibName,
                    &wVersionRequested,
                    &lpWSAData));

    return(ReturnValue);
}




DWORD WSAAPI
DTHOOK_WSAWaitForMultipleEvents(
    DWORD cEvents,
    const WSAEVENT FAR * lphEvents,
    BOOL fWaitAll,
    DWORD dwTimeout,
    BOOL fAlertable)
{

    DWORD ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAWaitForMultipleEvents,
                       &ReturnValue,
                       LibName,
                       &cEvents,
                       &lphEvents,
                       &fWaitAll,
                       &dwTimeout,
                       &fAlertable))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAWaitForMultipleEvents(cEvents, lphEvents, fWaitAll,
                                               dwTimeout, fAlertable);
        );

    POSTAPINOTIFY((DTCODE_WSAWaitForMultipleEvents,
                    &ReturnValue,
                    LibName,
                    &cEvents,
                    &lphEvents,
                    &fWaitAll,
                    &dwTimeout,
                    &fAlertable));

    return(ReturnValue);
}




struct hostent FAR * WSAAPI
DTHOOK_gethostbyaddr(
    const char FAR * addr,
    int len,
    int type)
{

    struct hostent FAR *ReturnValue;

    if (PREAPINOTIFY((DTCODE_gethostbyaddr,
                       &ReturnValue,
                       LibName,
                       &addr,
                       &len,
                       &type))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = gethostbyaddr(addr, len, type);
        );

    POSTAPINOTIFY((DTCODE_gethostbyaddr,
                    &ReturnValue,
                    LibName,
                    &addr,
                    &len,
                    &type));

    return(ReturnValue);
}




struct hostent FAR * WSAAPI
DTHOOK_gethostbyname(
    const char FAR * name)
{

    struct hostent FAR *ReturnValue;

    if (PREAPINOTIFY((DTCODE_gethostbyname,
                       &ReturnValue,
                       LibName,
                       &name))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = gethostbyname(name);
        );

    POSTAPINOTIFY((DTCODE_gethostbyname,
                    &ReturnValue,
                    LibName,
                    &name));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_gethostname (
    char FAR * name,
    int namelen)
{

    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_gethostname,
                       &ReturnValue,
                       LibName,
                       &name,
                       &namelen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = gethostname(name, namelen);
        );

    POSTAPINOTIFY((DTCODE_gethostname,
                    &ReturnValue,
                    LibName,
                    &name,
                    &namelen));

    return(ReturnValue);
}




struct protoent FAR * WSAAPI
DTHOOK_getprotobyname(
    const char FAR * name)
{

    struct protoent FAR *ReturnValue;

    if (PREAPINOTIFY((DTCODE_getprotobyname,
                       &ReturnValue,
                       LibName,
                       &name))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = getprotobyname(name);
        );

    POSTAPINOTIFY((DTCODE_getprotobyname,
                    &ReturnValue,
                    LibName,
                    &name));

    return(ReturnValue);
}




struct protoent FAR * WSAAPI
DTHOOK_getprotobynumber(
    int number)
{

    struct protoent FAR *ReturnValue;

    if (PREAPINOTIFY((DTCODE_getprotobynumber,
                       &ReturnValue,
                       LibName,
                       &number))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = getprotobynumber(number);
        );

    POSTAPINOTIFY((DTCODE_getprotobynumber,
                    &ReturnValue,
                    LibName,
                    &number));

    return(ReturnValue);
}




struct servent FAR * WSAAPI
DTHOOK_getservbyname(
    const char FAR * name,
    const char FAR * proto)
{

    struct servent FAR *ReturnValue;

    if (PREAPINOTIFY((DTCODE_getservbyname,
                       &ReturnValue,
                       LibName,
                       &name,
                       &proto))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = getservbyname(name, proto);
        );

    POSTAPINOTIFY((DTCODE_getservbyname,
                    &ReturnValue,
                    LibName,
                    &name,
                    &proto));

    return(ReturnValue);
}




struct servent FAR * WSAAPI
DTHOOK_getservbyport(
    int port,
    const char FAR * proto)
{

    struct servent FAR *ReturnValue;

    if (PREAPINOTIFY((DTCODE_getservbyport,
                       &ReturnValue,
                       LibName,
                       &port,
                       &proto))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = getservbyport(port, proto);
        );

    POSTAPINOTIFY((DTCODE_getservbyport,
                    &ReturnValue,
                    LibName,
                    &port,
                    &proto));

    return(ReturnValue);
}




HANDLE WSAAPI
DTHOOK_WSAAsyncGetHostByAddr(
    HWND hWnd,
    u_int wMsg,
    const char FAR * addr,
    int len,
    int type,
    char FAR * buf,
    int buflen)
{

    HANDLE ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAAsyncGetHostByAddr,
                       &ReturnValue,
                       LibName,
                       &hWnd,
                       &wMsg,
                       &addr,
                       &len,
                       &type,
                       &buf,
                       &buflen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAAsyncGetHostByAddr(hWnd, wMsg, addr, len, type, buf,
                                            buflen);
        );

    POSTAPINOTIFY((DTCODE_WSAAsyncGetHostByAddr,
                    &ReturnValue,
                    LibName,
                    &hWnd,
                    &wMsg,
                    &addr,
                    &len,
                    &type,
                    &buf,
                    &buflen));

    return(ReturnValue);
}




HANDLE WSAAPI
DTHOOK_WSAAsyncGetHostByName(
    HWND hWnd,
    u_int wMsg,
    const char FAR * name,
    char FAR * buf,
    int buflen)
{

    HANDLE ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAAsyncGetHostByName,
                       &ReturnValue,
                       LibName,
                       &hWnd,
                       &wMsg,
                       &name,
                       &buf,
                       &buflen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAAsyncGetHostByName(hWnd, wMsg, name, buf, buflen);
        );

    POSTAPINOTIFY((DTCODE_WSAAsyncGetHostByName,
                    &ReturnValue,
                    LibName,
                    &hWnd,
                    &wMsg,
                    &name,
                    &buf,
                    &buflen));

    return(ReturnValue);
}




HANDLE WSAAPI
DTHOOK_WSAAsyncGetProtoByName(
    HWND hWnd,
    u_int wMsg,
    const char FAR * name,
    char FAR * buf,
    int buflen)
{

    HANDLE ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAAsyncGetProtoByName,
                       &ReturnValue,
                       LibName,
                       &hWnd,
                       &wMsg,
                       &name,
                       &buf,
                       &buflen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAAsyncGetProtoByName(hWnd, wMsg, name, buf, buflen);
        );

    POSTAPINOTIFY((DTCODE_WSAAsyncGetProtoByName,
                    &ReturnValue,
                    LibName,
                    &hWnd,
                    &wMsg,
                    &name,
                    &buf,
                    &buflen));

    return(ReturnValue);
}




HANDLE WSAAPI
DTHOOK_WSAAsyncGetProtoByNumber(
    HWND hWnd,
    u_int wMsg,
    int number,
    char FAR * buf,
    int buflen)
{

    HANDLE ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAAsyncGetProtoByNumber,
                       &ReturnValue,
                       LibName,
                       &hWnd,
                       &wMsg,
                       &number,
                       &buf,
                       &buflen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAAsyncGetProtoByNumber(hWnd, wMsg, number, buf,
                                               buflen);
        );

    POSTAPINOTIFY((DTCODE_WSAAsyncGetProtoByNumber,
                    &ReturnValue,
                    LibName,
                    &hWnd,
                    &wMsg,
                    &number,
                    &buf,
                    &buflen));

    return(ReturnValue);
}




HANDLE WSAAPI
DTHOOK_WSAAsyncGetServByName(
    HWND hWnd,
    u_int wMsg,
    const char FAR * name,
    const char FAR * proto,
    char FAR * buf,
    int buflen)
{

    HANDLE ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAAsyncGetServByName,
                       &ReturnValue,
                       LibName,
                       &hWnd,
                       &wMsg,
                       &name,
                       &proto,
                       &buf,
                       &buflen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAAsyncGetServByName(hWnd, wMsg, name, proto, buf,
                                            buflen);
        );

    POSTAPINOTIFY((DTCODE_WSAAsyncGetServByName,
                    &ReturnValue,
                    LibName,
                    &hWnd,
                    &wMsg,
                    &name,
                    &proto,
                    &buf,
                    &buflen));

    return(ReturnValue);
}




HANDLE WSAAPI
DTHOOK_WSAAsyncGetServByPort(
    HWND hWnd,
    u_int wMsg,
    int port,
    const char FAR * proto,
    char FAR * buf,
    int buflen)
{

    HANDLE ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAAsyncGetServByPort,
                       &ReturnValue,
                       LibName,
                       &hWnd,
                       &wMsg,
                       &port,
                       &proto,
                       &buf,
                       &buflen))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAAsyncGetServByPort(hWnd, wMsg, port, proto, buf,
                                            buflen);
        );

    POSTAPINOTIFY((DTCODE_WSAAsyncGetServByPort,
                    &ReturnValue,
                    LibName,
                    &hWnd,
                    &wMsg,
                    &port,
                    &proto,
                    &buf,
                    &buflen));

    return(ReturnValue);
}




int WSAAPI
DTHOOK_WSACancelAsyncRequest(
    HANDLE hAsyncTaskHandle)
{

    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSACancelAsyncRequest,
                       &ReturnValue,
                       LibName,
                       &hAsyncTaskHandle))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSACancelAsyncRequest(hAsyncTaskHandle);
        );

    POSTAPINOTIFY((DTCODE_WSACancelAsyncRequest,
                    &ReturnValue,
                    LibName,
                    &hAsyncTaskHandle));

    return(ReturnValue);
}




BOOL WSPAPI
DTHOOK_WPUCloseEvent(
    WSAEVENT hEvent,
    LPINT lpErrno )
{

    BOOL ReturnValue;

    if (PREAPINOTIFY((DTCODE_WPUCloseEvent,
                       &ReturnValue,
                       LibName,
                       &hEvent,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUCloseEvent(hEvent, lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WPUCloseEvent,
                    &ReturnValue,
                    LibName,
                    &hEvent,
                    &lpErrno));

    return(ReturnValue);
}




int WSPAPI
DTHOOK_WPUCloseSocketHandle(
    SOCKET s,
    LPINT lpErrno )
{

    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WPUCloseSocketHandle,
                       &ReturnValue,
                       LibName,
                       &s,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUCloseSocketHandle(s, lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WPUCloseSocketHandle,
                    &ReturnValue,
                    LibName,
                    &s,
                    &lpErrno));

    return(ReturnValue);
}




WSAEVENT WSPAPI
DTHOOK_WPUCreateEvent(
    LPINT lpErrno )
{

    WSAEVENT ReturnValue;

    if (PREAPINOTIFY((DTCODE_WPUCreateEvent,
                       &ReturnValue,
                       LibName,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUCreateEvent(lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WPUCreateEvent,
                    &ReturnValue,
                    LibName,
                    &lpErrno));

    return(ReturnValue);
}




#ifdef _X86_
#pragma optimize("y", off)  // Make sure we can at least get the caller.
#endif

SOCKET WSPAPI
DTHOOK_WPUCreateSocketHandle(
    DWORD dwCatalogEntryId,
    DWORD_PTR dwContext,
    LPINT lpErrno)
{

    SOCKET ReturnValue;

    if (PREAPINOTIFY((DTCODE_WPUCreateSocketHandle,
                       &ReturnValue,
                       LibName,
                       &dwCatalogEntryId,
                       &dwContext,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUCreateSocketHandle(dwCatalogEntryId, dwContext,
                                            lpErrno);
        );

    RECORD_SOCKET_CREATOR (ReturnValue);
    POSTAPINOTIFY((DTCODE_WPUCreateSocketHandle,
                    &ReturnValue,
                    LibName,
                    &dwCatalogEntryId,
                    &dwContext,
                    &lpErrno));

    return(ReturnValue);
}
#ifdef _X86_
#pragma optimize("", on)
#endif



#ifdef _X86_
#pragma optimize("y", off)  // Make sure we can at least get the caller.
#endif

SOCKET WSPAPI
DTHOOK_WPUModifyIFSHandle(
    DWORD dwCatalogEntryId,
    SOCKET ProposedHandle,
    LPINT lpErrno)
{

    SOCKET ReturnValue;

    if (PREAPINOTIFY((DTCODE_WPUModifyIFSHandle,
                       &ReturnValue,
                       LibName,
                       &dwCatalogEntryId,
                       &ProposedHandle,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUModifyIFSHandle(dwCatalogEntryId, ProposedHandle,
                                         lpErrno);
        );

    RECORD_SOCKET_CREATOR (ReturnValue);
    POSTAPINOTIFY((DTCODE_WPUModifyIFSHandle,
                    &ReturnValue,
                    LibName,
                    &dwCatalogEntryId,
                    &ProposedHandle,
                    &lpErrno));

    return(ReturnValue);
}
#ifdef _X86_
#pragma optimize("", on)
#endif




int WSPAPI
DTHOOK_WPUQueryBlockingCallback(
    DWORD dwCatalogEntryId,
    LPBLOCKINGCALLBACK FAR * lplpfnCallback,
    PDWORD_PTR lpdwContext,
    LPINT lpErrno)
{

    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WPUQueryBlockingCallback,
                       &ReturnValue,
                       LibName,
                       &dwCatalogEntryId,
                       &lplpfnCallback,
                       &lpdwContext,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUQueryBlockingCallback(dwCatalogEntryId, lplpfnCallback,
                                               lpdwContext, lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WPUQueryBlockingCallback,
                    &ReturnValue,
                    LibName,
                    &dwCatalogEntryId,
                    &lplpfnCallback,
                    &lpdwContext,
                    &lpErrno));

    return(ReturnValue);
}




int WSPAPI
DTHOOK_WPUQuerySocketHandleContext(
    SOCKET s,
    PDWORD_PTR lpContext,
    LPINT lpErrno )
{

    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WPUQuerySocketHandleContext,
                       &ReturnValue,
                       LibName,
                       &s,
                       &lpContext,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUQuerySocketHandleContext(s, lpContext, lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WPUQuerySocketHandleContext,
                    &ReturnValue,
                    LibName,
                    &s,
                    &lpContext,
                    &lpErrno));

    return(ReturnValue);
}




int WSPAPI
DTHOOK_WPUQueueApc(
    LPWSATHREADID lpThreadId,
    LPWSAUSERAPC lpfnUserApc,
    DWORD_PTR dwContext,
    LPINT lpErrno)
{

    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WPUQueueApc,
                       &ReturnValue,
                       LibName,
                       &lpThreadId,
                       &lpfnUserApc,
                       &dwContext,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUQueueApc(lpThreadId, lpfnUserApc, dwContext, lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WPUQueueApc,
                    &ReturnValue,
                    LibName,
                    &lpThreadId,
                    &lpfnUserApc,
                    &dwContext,
                    &lpErrno));

    return(ReturnValue);
}




BOOL WSPAPI
DTHOOK_WPUResetEvent(
    WSAEVENT hEvent,
    LPINT lpErrno)
{

    BOOL ReturnValue;

    if (PREAPINOTIFY((DTCODE_WPUResetEvent,
                       &ReturnValue,
                       LibName,
                       &hEvent,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUResetEvent(hEvent, lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WPUResetEvent,
                    &ReturnValue,
                    LibName,
                    &hEvent,
                    &lpErrno));

    return(ReturnValue);
}




BOOL WSPAPI
DTHOOK_WPUSetEvent(
    WSAEVENT hEvent,
    LPINT lpErrno)
{

    BOOL ReturnValue;

    if (PREAPINOTIFY((DTCODE_WPUSetEvent,
                       &ReturnValue,
                       LibName,
                       &hEvent,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUSetEvent(hEvent, lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WPUSetEvent,
                    &ReturnValue,
                    LibName,
                    &hEvent,
                    &lpErrno));

    return(ReturnValue);
}




int WSPAPI
DTHOOK_WSCDeinstallProvider(
    LPGUID lpProviderId,
    LPINT lpErrno)
{

    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSCDeinstallProvider,
                       &ReturnValue,
                       LibName,
                       &lpProviderId,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCDeinstallProvider(lpProviderId, lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WSCDeinstallProvider,
                    &ReturnValue,
                    LibName,
                    &lpProviderId,
                    &lpErrno));

    return(ReturnValue);
}




int WSPAPI
DTHOOK_WSCInstallProvider(
    LPGUID lpProviderId,
    const WCHAR FAR * lpszProviderDllPath,
    const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    DWORD dwNumberOfEntries,
    LPINT lpErrno)
{

    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSCInstallProvider,
                       &ReturnValue,
                       LibName,
                       &lpProviderId,
                       &lpszProviderDllPath,
                       &lpProtocolInfoList,
                       &dwNumberOfEntries,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCInstallProvider(lpProviderId, lpszProviderDllPath,
                                         lpProtocolInfoList, dwNumberOfEntries,
                                         lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WSCInstallProvider,
                    &ReturnValue,
                    LibName,
                    &lpProviderId,
                    &lpszProviderDllPath,
                    &lpProtocolInfoList,
                    &dwNumberOfEntries,
                    &lpErrno));

    return(ReturnValue);
}




int WSPAPI
DTHOOK_WPUGetProviderPath(
    IN     LPGUID     lpProviderId,
    OUT    WCHAR FAR * lpszProviderDllPath,
    IN OUT LPINT      lpProviderDllPathLen,
    OUT    LPINT      lpErrno
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WPUGetProviderPath,
                       &ReturnValue,
                       LibName,
                       &lpProviderId,
                       &lpszProviderDllPath,
                       &lpProviderDllPathLen,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUGetProviderPath(lpProviderId, lpszProviderDllPath,
                                         lpProviderDllPathLen, lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WPUGetProviderPath,
                       &ReturnValue,
                       LibName,
                       &lpProviderId,
                       &lpszProviderDllPath,
                       &lpProviderDllPathLen,
                       &lpErrno));

    return(ReturnValue);
} // DTHOOK_WPUGetProviderPath




BOOL WSPAPI
DTHOOK_WPUPostMessage(
    HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    BOOL ReturnValue;

    if (PREAPINOTIFY((DTCODE_WPUPostMessage,
                       &ReturnValue,
                       LibName,
                       &hWnd,
                       &Msg,
                       &wParam,
                       &lParam
                       ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUPostMessage(hWnd, Msg, wParam, lParam);
        );

    POSTAPINOTIFY((DTCODE_WPUPostMessage,
                       &ReturnValue,
                       LibName,
                       &hWnd,
                       &Msg,
                       &wParam,
                       &lParam
                       ));

    return(ReturnValue);
} // DTHOOK_WPUPostMessage




int WSPAPI
DTHOOK_WPUFDIsSet(
    SOCKET       s,
    fd_set FAR * set
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WPUFDIsSet,
                       &ReturnValue,
                       LibName,
                       &s,
                       &set
                       ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUFDIsSet(s, set);
        );

    POSTAPINOTIFY((DTCODE_WPUFDIsSet,
                       &ReturnValue,
                       LibName,
                       &s,
                       &set
                       ));

    return(ReturnValue);
} // DTHOOK_WPUFDIsSet




int WSPAPI
DTHOOK___WSAFDIsSet(
    SOCKET       s,
    fd_set FAR * set
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE___WSAFDIsSet,
                       &ReturnValue,
                       LibName,
                       &s,
                       &set
                       ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = __WSAFDIsSet(s, set);
        );

    POSTAPINOTIFY((DTCODE___WSAFDIsSet,
                       &ReturnValue,
                       LibName,
                       &s,
                       &set
                       ));

    return(ReturnValue);
} // DTHOOK___WSAFDIsSet

INT
WSPAPI
DTHOOK_WSAAddressToStringA(
    IN     LPSOCKADDR          lpsaAddress,
    IN     DWORD               dwAddressLength,
    IN     LPWSAPROTOCOL_INFOA lpProtocolInfo,
    IN OUT LPSTR               lpszAddressString,
    IN OUT LPDWORD             lpdwAddressStringLength
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAAddressToStringA,
                      &ReturnValue,
                      LibName,
                      &lpsaAddress,
                      &dwAddressLength,
                      &lpProtocolInfo,
                      &lpszAddressString,
                      &lpdwAddressStringLength))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAAddressToStringA(lpsaAddress, dwAddressLength,
                                          lpProtocolInfo, lpszAddressString,
                                          lpdwAddressStringLength);
        );

    POSTAPINOTIFY( (DTCODE_WSAAddressToStringA,
                   &ReturnValue,
                   LibName,
                   &lpsaAddress,
                   &dwAddressLength,
                   &lpProtocolInfo,
                   &lpszAddressString,
                   &lpdwAddressStringLength
                   ) );

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSAAddressToStringW(
    IN     LPSOCKADDR          lpsaAddress,
    IN     DWORD               dwAddressLength,
    IN     LPWSAPROTOCOL_INFOW lpProtocolInfo,
    IN OUT LPWSTR              lpszAddressString,
    IN OUT LPDWORD             lpdwAddressStringLength
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAAddressToStringW,
                      &ReturnValue,
                      LibName,
                      &lpsaAddress,
                      &dwAddressLength,
                      &lpProtocolInfo,
                      &lpszAddressString,
                      &lpdwAddressStringLength))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAAddressToStringW(lpsaAddress, dwAddressLength,
                                          lpProtocolInfo, lpszAddressString,
                                          lpdwAddressStringLength);
        );

    POSTAPINOTIFY( (DTCODE_WSAAddressToStringW,
                   &ReturnValue,
                   LibName,
                   &lpsaAddress,
                   &dwAddressLength,
                   &lpProtocolInfo,
                   &lpszAddressString,
                   &lpdwAddressStringLength
                   ) );

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSAStringToAddressA(
    IN     LPSTR               AddressString,
    IN     INT                 AddressFamily,
    IN     LPWSAPROTOCOL_INFOA  lpProtocolInfo,
    IN OUT LPSOCKADDR          lpAddress,
    IN OUT LPINT               lpAddressLength
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAStringToAddressA,
                      &ReturnValue,
                      LibName,
                      &AddressString,
                      &AddressFamily,
                      &lpProtocolInfo,
                      &lpAddress,
                      &lpAddressLength
                      ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAStringToAddressA(AddressString, AddressFamily,
                                          lpProtocolInfo, lpAddress,
                                          lpAddressLength);
        );

    POSTAPINOTIFY((DTCODE_WSAStringToAddressA,
                   &ReturnValue,
                   LibName,
                   &AddressString,
                   &AddressFamily,
                   &lpProtocolInfo,
                   &lpAddress,
                   &lpAddressLength));
    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSAStringToAddressW(
    IN     LPWSTR              AddressString,
    IN     INT                 AddressFamily,
    IN     LPWSAPROTOCOL_INFOW lpProtocolInfo,
    IN OUT LPSOCKADDR          lpAddress,
    IN OUT LPINT               lpAddressLength
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAStringToAddressW,
                      &ReturnValue,
                      LibName,
                      &AddressString,
                      &AddressFamily,
                      &lpProtocolInfo,
                      &lpAddress,
                      &lpAddressLength
                      ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAStringToAddressW(AddressString, AddressFamily,
                                          lpProtocolInfo, lpAddress,
                                          lpAddressLength);
        );

    POSTAPINOTIFY((DTCODE_WSAStringToAddressW,
                   &ReturnValue,
                   LibName,
                   &AddressString,
                   &AddressFamily,
                   &lpProtocolInfo,
                   &lpAddress,
                   &lpAddressLength));
    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSALookupServiceBeginA(
    IN  LPWSAQUERYSETA lpqsRestrictions,
    IN  DWORD          dwControlFlags,
    OUT LPHANDLE       lphLookup
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSALookupServiceBeginA,
                      &ReturnValue,
                      LibName,
                      &lpqsRestrictions,
                      &dwControlFlags,
                      &lphLookup
                      ))) {
        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSALookupServiceBeginA(lpqsRestrictions, dwControlFlags,
                                             lphLookup);
        );

    POSTAPINOTIFY((DTCODE_WSALookupServiceBeginA,
                   &ReturnValue,
                   LibName,
                   &lpqsRestrictions,
                   &dwControlFlags,
                   &lphLookup));

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSALookupServiceBeginW(
    IN  LPWSAQUERYSETW lpqsRestrictions,
    IN  DWORD          dwControlFlags,
    OUT LPHANDLE       lphLookup
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSALookupServiceBeginW,
                      &ReturnValue,
                      LibName,
                      &lpqsRestrictions,
                      &dwControlFlags,
                      &lphLookup
                      ))) {
        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSALookupServiceBeginW(lpqsRestrictions, dwControlFlags,
                                             lphLookup);
        );

    POSTAPINOTIFY((DTCODE_WSALookupServiceBeginW,
                   &ReturnValue,
                   LibName,
                   &lpqsRestrictions,
                   &dwControlFlags,
                   &lphLookup));

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSALookupServiceNextA(
    IN     HANDLE           hLookup,
    IN     DWORD            dwControlFlags,
    IN OUT LPDWORD          lpdwBufferLength,
    OUT    LPWSAQUERYSETA   lpqsResults
    )
{
       int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSALookupServiceNextA,
                      &ReturnValue,
                      LibName,
                      &hLookup,
                      &dwControlFlags,
                      &lpdwBufferLength,
                      &lpqsResults
                      ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSALookupServiceNextA(hLookup, dwControlFlags,
                                            lpdwBufferLength, lpqsResults);
        );

    POSTAPINOTIFY((DTCODE_WSALookupServiceNextA,
                   &ReturnValue,
                   LibName,
                   &hLookup,
                   &dwControlFlags,
                   &lpdwBufferLength,
                   &lpqsResults
                   ));

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSALookupServiceNextW(
    IN     HANDLE           hLookup,
    IN     DWORD            dwControlFlags,
    IN OUT LPDWORD          lpdwBufferLength,
    OUT    LPWSAQUERYSETW   lpqsResults
    )
{
       int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSALookupServiceNextW,
                      &ReturnValue,
                      LibName,
                      &hLookup,
                      &dwControlFlags,
                      &lpdwBufferLength,
                      &lpqsResults
                      ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSALookupServiceNextW(hLookup, dwControlFlags,
                                            lpdwBufferLength, lpqsResults);
        );

    POSTAPINOTIFY((DTCODE_WSALookupServiceNextW,
                   &ReturnValue,
                   LibName,
                   &hLookup,
                   &dwControlFlags,
                   &lpdwBufferLength,
                   &lpqsResults
                   ));

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSANSPIoctl(
    IN  HANDLE           hLookup,
    IN  DWORD            dwControlCode,
    IN  LPVOID           lpvInBuffer,
    IN  DWORD            cbInBuffer,
    OUT LPVOID           lpvOutBuffer,
    IN  DWORD            cbOutBuffer,
    OUT LPDWORD          lpcbBytesReturned,
    IN  LPWSACOMPLETION  lpCompletion
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSANSPIoctl,
                      &ReturnValue,
                      LibName,
                      &hLookup,
                      &dwControlCode,
                      &lpvInBuffer,
                      &cbInBuffer,
                      &lpvOutBuffer,
                      &cbOutBuffer,
                      &lpcbBytesReturned,
                      &lpCompletion
                      ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSANSPIoctl(hLookup, dwControlCode,
                                  lpvInBuffer, cbInBuffer,
                                  lpvOutBuffer, cbOutBuffer,
                                  lpcbBytesReturned, lpCompletion);
        );

    POSTAPINOTIFY((DTCODE_WSANSPIoctl,
                   &ReturnValue,
                   LibName,
                   &hLookup,
                   &dwControlCode,
                   &lpvInBuffer,
                   &cbInBuffer,
                   &lpvOutBuffer,
                   &cbOutBuffer,
                   &lpcbBytesReturned,
                   &lpCompletion
                   ));

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSALookupServiceEnd(
    IN HANDLE  hLookup
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSALookupServiceEnd,
                      &ReturnValue,
                      LibName,
                      &hLookup
                      ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSALookupServiceEnd(hLookup);
        );

    POSTAPINOTIFY((DTCODE_WSALookupServiceEnd,
                   &ReturnValue,
                   LibName,
                   &hLookup
                   ));

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSAInstallServiceClassA(
    IN  LPWSASERVICECLASSINFOA   lpServiceClassInfo
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAInstallServiceClassA,
                      &ReturnValue,
                      LibName,
                      &lpServiceClassInfo
                      ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAInstallServiceClassA(lpServiceClassInfo);
        );

    POSTAPINOTIFY((DTCODE_WSAInstallServiceClassA,
                   &ReturnValue,
                   LibName,
                   &lpServiceClassInfo));

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSAInstallServiceClassW(
    IN  LPWSASERVICECLASSINFOW   lpServiceClassInfo
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAInstallServiceClassW,
                      &ReturnValue,
                      LibName,
                      &lpServiceClassInfo
                      ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAInstallServiceClassW(lpServiceClassInfo);
        );

    POSTAPINOTIFY((DTCODE_WSAInstallServiceClassW,
                   &ReturnValue,
                   LibName,
                   &lpServiceClassInfo));

    return(ReturnValue);
}



INT WSPAPI
DTHOOK_WSASetServiceA(
    IN  LPWSAQUERYSETA    lpqsRegInfo,
    IN  WSAESETSERVICEOP  essOperation,
    IN  DWORD             dwControlFlags
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSASetServiceA,
                      &ReturnValue,
                      LibName,
                      &lpqsRegInfo,
                      &essOperation,
                      &dwControlFlags
                      ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSASetServiceA(lpqsRegInfo, essOperation,
                                     dwControlFlags);
        );

    POSTAPINOTIFY((DTCODE_WSASetServiceA,
                   &ReturnValue,
                   LibName,
                   &lpqsRegInfo,
                   &essOperation,
                   &dwControlFlags));

    return(ReturnValue);
}


INT WSPAPI
DTHOOK_WSASetServiceW(
    IN  LPWSAQUERYSETW    lpqsRegInfo,
    IN  WSAESETSERVICEOP  essOperation,
    IN  DWORD             dwControlFlags
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSASetServiceW,
                      &ReturnValue,
                      LibName,
                      &lpqsRegInfo,
                      &essOperation,
                      &dwControlFlags
                      ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSASetServiceW(lpqsRegInfo, essOperation,
                                     dwControlFlags);
        );

    POSTAPINOTIFY((DTCODE_WSASetServiceW,
                   &ReturnValue,
                   LibName,
                   &lpqsRegInfo,
                   &essOperation,
                   &dwControlFlags));

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSARemoveServiceClass(
    IN  LPGUID  lpServiceClassId
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSARemoveServiceClass,
                      &ReturnValue,
                      LibName,
                      &lpServiceClassId))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSARemoveServiceClass(lpServiceClassId);
        );

    POSTAPINOTIFY((DTCODE_WSARemoveServiceClass,
                   &ReturnValue,
                   LibName,
                   &lpServiceClassId));

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSAGetServiceClassInfoA(
    IN     LPGUID                  lpProviderId,
    IN     LPGUID                  lpServiceClassId,
    IN OUT LPDWORD                 lpdwBufSize,
    OUT    LPWSASERVICECLASSINFOA   lpServiceClassInfo
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAGetServiceClassInfoA,
                      &ReturnValue,
                      LibName,
                      &lpProviderId,
                      &lpServiceClassId,
                      &lpdwBufSize,
                      &lpServiceClassInfo
                      ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAGetServiceClassInfoA(lpProviderId, lpServiceClassId,
                                              lpdwBufSize, lpServiceClassInfo);
        );

    POSTAPINOTIFY((DTCODE_WSAGetServiceClassInfoA,
                   &ReturnValue,
                   LibName,
                   &lpProviderId,
                   &lpServiceClassId,
                   &lpdwBufSize,
                   &lpServiceClassInfo));

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSAGetServiceClassInfoW(
    IN     LPGUID                  lpProviderId,
    IN     LPGUID                  lpServiceClassId,
    IN OUT LPDWORD                 lpdwBufSize,
    OUT    LPWSASERVICECLASSINFOW   lpServiceClassInfo
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAGetServiceClassInfoW,
                      &ReturnValue,
                      LibName,
                      &lpProviderId,
                      &lpServiceClassId,
                      &lpdwBufSize,
                      &lpServiceClassInfo
                      ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAGetServiceClassInfoW(lpProviderId, lpServiceClassId,
                                              lpdwBufSize, lpServiceClassInfo);
        );

    POSTAPINOTIFY((DTCODE_WSAGetServiceClassInfoW,
                   &ReturnValue,
                   LibName,
                   &lpProviderId,
                   &lpServiceClassId,
                   &lpdwBufSize,
                   &lpServiceClassInfo));

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSAEnumNameSpaceProvidersA(
    IN OUT LPDWORD              lpdwBufferLength,
    IN     LPWSANAMESPACE_INFOA  Lpnspbuffer
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAEnumNameSpaceProvidersA,
                      &ReturnValue,
                      LibName,
                      &lpdwBufferLength,
                      &Lpnspbuffer))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAEnumNameSpaceProvidersA(lpdwBufferLength, Lpnspbuffer);
        );

    POSTAPINOTIFY((DTCODE_WSAEnumNameSpaceProvidersA,
                   &ReturnValue,
                   LibName,
                   &lpdwBufferLength,
                   &Lpnspbuffer));

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSAEnumNameSpaceProvidersW(
    IN OUT LPDWORD              lpdwBufferLength,
    IN     LPWSANAMESPACE_INFOW  Lpnspbuffer
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAEnumNameSpaceProvidersW,
                      &ReturnValue,
                      LibName,
                      &lpdwBufferLength,
                      &Lpnspbuffer))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAEnumNameSpaceProvidersW(lpdwBufferLength, Lpnspbuffer);
        );

    POSTAPINOTIFY((DTCODE_WSAEnumNameSpaceProvidersW,
                   &ReturnValue,
                   LibName,
                   &lpdwBufferLength,
                   &Lpnspbuffer));

    return(ReturnValue);
}


INT
WSPAPI
DTHOOK_WSAGetServiceClassNameByClassIdA(
    IN      LPGUID  lpServiceClassId,
    OUT     LPSTR   lpszServiceClassName,
    IN OUT  LPDWORD lpdwBufferLength
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAGetServiceClassNameByClassIdA,
                      &ReturnValue,
                      LibName,
                      &lpServiceClassId,
                      &lpszServiceClassName,
                      &lpdwBufferLength
                      ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAGetServiceClassNameByClassIdA(lpServiceClassId,
                                                       lpszServiceClassName,
                                                       lpdwBufferLength);
        );

    POSTAPINOTIFY((DTCODE_WSAGetServiceClassNameByClassIdA,
                   &ReturnValue,
                   LibName,
                   &lpServiceClassId,
                   &lpszServiceClassName,
                   &lpdwBufferLength ));

    return(ReturnValue);
}

INT
WSPAPI
DTHOOK_WSAGetServiceClassNameByClassIdW(
    IN      LPGUID  lpServiceClassId,
    OUT     LPWSTR   lpszServiceClassName,
    IN OUT  LPDWORD lpdwBufferLength
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAGetServiceClassNameByClassIdW,
                      &ReturnValue,
                      LibName,
                      &lpServiceClassId,
                      &lpszServiceClassName,
                      &lpdwBufferLength
                      ))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAGetServiceClassNameByClassIdW(lpServiceClassId,
                                                       lpszServiceClassName,
                                                       lpdwBufferLength);
        );

    POSTAPINOTIFY((DTCODE_WSAGetServiceClassNameByClassIdW,
                   &ReturnValue,
                   LibName,
                   &lpServiceClassId,
                   &lpszServiceClassName,
                   &lpdwBufferLength ));

    return(ReturnValue);
}

INT
WSAAPI
DTHOOK_WSACancelBlockingCall(
    VOID
    )
{
    INT ReturnValue;

    if( PREAPINOTIFY((
            DTCODE_WSACancelBlockingCall,
            &ReturnValue,
            LibName
            )) ) {
        return ReturnValue;
    }

    INVOKE_ROUTINE(
        ReturnValue = WSACancelBlockingCall();
        );

    POSTAPINOTIFY((
        DTCODE_WSACancelBlockingCall,
        &ReturnValue,
        LibName
        ));

    return ReturnValue;
}

FARPROC
WSAAPI
DTHOOK_WSASetBlockingHook(
    FARPROC lpBlockFunc
    )
{
    FARPROC ReturnValue;

    if( PREAPINOTIFY((
            DTCODE_WSASetBlockingHook,
            &ReturnValue,
            LibName,
            &lpBlockFunc
            )) ) {
        return ReturnValue;
    }

    INVOKE_ROUTINE(
        ReturnValue = WSASetBlockingHook( lpBlockFunc );
        );

    POSTAPINOTIFY((
        DTCODE_WSASetBlockingHook,
        &ReturnValue,
        LibName,
        &lpBlockFunc
        ));

    return ReturnValue;
}

INT
WSAAPI
DTHOOK_WSAUnhookBlockingHook(
    VOID
    )
{
    INT ReturnValue;

    if( PREAPINOTIFY((
            DTCODE_WSAUnhookBlockingHook,
            &ReturnValue,
            LibName
            )) ) {
        return ReturnValue;
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAUnhookBlockingHook();
        );

    POSTAPINOTIFY((
        DTCODE_WSAUnhookBlockingHook,
        &ReturnValue,
        LibName
        ));

    return ReturnValue;
}

BOOL
WSAAPI
DTHOOK_WSAIsBlocking(
    VOID
    )
{
    BOOL ReturnValue;

    if( PREAPINOTIFY((
            DTCODE_WSAIsBlocking,
            &ReturnValue,
            LibName
            )) ) {
        return ReturnValue;
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAIsBlocking();
        );

    POSTAPINOTIFY((
        DTCODE_WSAIsBlocking,
        &ReturnValue,
        LibName
        ));

    return ReturnValue;
}


int WSPAPI
DTHOOK_WSCGetProviderPath(
    LPGUID lpProviderId,
    WCHAR FAR * lpszProviderDllPath,
    LPINT lpProviderDllPathLen,
    LPINT lpErrno)
{

    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSCGetProviderPath,
                       &ReturnValue,
                       LibName,
                       &lpProviderId,
                       &lpszProviderDllPath,
                       &lpProviderDllPathLen,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCGetProviderPath(lpProviderId, lpszProviderDllPath,
                                         lpProviderDllPathLen, lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WSCGetProviderPath,
                    &ReturnValue,
                    LibName,
                    &lpProviderId,
                    &lpszProviderDllPath,
                    &lpProviderDllPathLen,
                    &lpErrno));

    return(ReturnValue);
}


int WSPAPI
DTHOOK_WSCInstallNameSpace(
    LPWSTR lpszIdentifier,
    LPWSTR lpszPathName,
    DWORD dwNameSpace,
    DWORD dwVersion,
    LPGUID lpProviderId)
{

    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSCInstallNameSpace,
                       &ReturnValue,
                       LibName,
                       &lpszIdentifier,
                       &lpszPathName,
                       &dwNameSpace,
                       &dwVersion,
                       &lpProviderId))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCInstallNameSpace(lpszIdentifier, lpszPathName,
                                          dwNameSpace, dwVersion, lpProviderId);
        );

    POSTAPINOTIFY((DTCODE_WSCInstallNameSpace,
                    &ReturnValue,
                    LibName,
                    &lpszIdentifier,
                    &lpszPathName,
                    &dwNameSpace,
                    &dwVersion,
                    &lpProviderId));

    return(ReturnValue);
}


int WSPAPI
DTHOOK_WSCUnInstallNameSpace(
    LPGUID lpProviderId
    )
{

    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSCUnInstallNameSpace,
                       &ReturnValue,
                       LibName,
                       &lpProviderId))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCUnInstallNameSpace(lpProviderId);
        );

    POSTAPINOTIFY((DTCODE_WSCUnInstallNameSpace,
                    &ReturnValue,
                    LibName,
                    &lpProviderId));

    return(ReturnValue);
}


int WSPAPI
DTHOOK_WSCEnableNSProvider(
    LPGUID lpProviderId,
    BOOL fEnable
    )
{

    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSCEnableNSProvider,
                       &ReturnValue,
                       LibName,
                       &lpProviderId,
                       &fEnable))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCEnableNSProvider(lpProviderId, fEnable);
        );

    POSTAPINOTIFY((DTCODE_WSCEnableNSProvider,
                    &ReturnValue,
                    LibName,
                    &lpProviderId,
                    &fEnable));

    return(ReturnValue);
}

int
WSPAPI
DTHOOK_WPUCompleteOverlappedRequest (
    SOCKET s, 	
    LPWSAOVERLAPPED lpOverlapped, 	
    DWORD dwError, 	
    DWORD cbTransferred, 	
    LPINT lpErrno
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WPUCompleteOverlappedRequest,
                       &ReturnValue,
                       LibName,
                       &s,
                       &lpOverlapped,
                       &dwError,
                       &cbTransferred,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUCompleteOverlappedRequest(
                       s,
                       lpOverlapped,
                       dwError,
                       cbTransferred,
                       lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WPUCompleteOverlappedRequest,
                    &ReturnValue,
                    LibName,
                    &s,
                    &lpOverlapped,
                    &dwError,
                    &cbTransferred,
                    &lpErrno));

    return(ReturnValue);

}

int WSAAPI
DTHOOK_WSAProviderConfigChange(
    IN OUT LPHANDLE lpNotificationHandle,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSAProviderConfigChange,
                       &ReturnValue,
                       LibName,
                       &lpNotificationHandle,
                       &lpOverlapped,
                       &lpCompletionRoutine))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSAProviderConfigChange(
                       lpNotificationHandle,
                       lpOverlapped,
                       lpCompletionRoutine);
        );

    POSTAPINOTIFY((DTCODE_WSAProviderConfigChange,
                    &ReturnValue,
                    LibName,
                    &lpNotificationHandle,
                    &lpOverlapped,
                    &lpCompletionRoutine));

    return(ReturnValue);

}
int
WSPAPI
DTHOOK_WSCWriteProviderOrder (
    IN LPDWORD lpwdCatalogEntryId,
    IN DWORD dwNumberOfEntries
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSCWriteProviderOrder,
                       &ReturnValue,
                       LibName,
                       &lpwdCatalogEntryId,
                       &dwNumberOfEntries))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCWriteProviderOrder(
                       lpwdCatalogEntryId,
                       dwNumberOfEntries);
        );

    POSTAPINOTIFY((DTCODE_WSCWriteProviderOrder,
                    &ReturnValue,
                    LibName,
                    &lpwdCatalogEntryId,
                    &dwNumberOfEntries));

    return(ReturnValue);

}

int
WSPAPI
DTHOOK_WSCWriteNameSpaceOrder (
    IN LPGUID lpProviderId,
    IN DWORD dwNumberOfEntries
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSCWriteNameSpaceOrder,
                       &ReturnValue,
                       LibName,
                       &lpProviderId,
                       &dwNumberOfEntries))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCWriteNameSpaceOrder(
                       lpProviderId,
                       dwNumberOfEntries);
        );

    POSTAPINOTIFY((DTCODE_WSCWriteNameSpaceOrder,
                    &ReturnValue,
                    LibName,
                    &lpProviderId,
                    &dwNumberOfEntries));

    return(ReturnValue);
}

int
WSPAPI
DTHOOK_WSCUpdateProvider(
    IN  LPGUID lpProviderId,
    IN  const WCHAR FAR * lpszProviderDllPath,
    IN  const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN  DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSCUpdateProvider,
                       &ReturnValue,
                       LibName,
                       &lpProviderId,
                       &lpszProviderDllPath,
                       &lpProtocolInfoList,
                       &dwNumberOfEntries,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCUpdateProvider(
                       lpProviderId,
                       lpszProviderDllPath,
                       lpProtocolInfoList,
                       dwNumberOfEntries,
                       lpErrno
                       );
        );

    POSTAPINOTIFY((DTCODE_WSCUpdateProvider,
                    &ReturnValue,
                    LibName,
                    &lpProviderId,
                    &lpszProviderDllPath,
                    &lpProtocolInfoList,
                    &dwNumberOfEntries,
                    &lpErrno));

    return(ReturnValue);
}

int WSAAPI
DTHOOK_getaddrinfo(
    const char FAR *NodeName,
    const char FAR *ServiceName,
    const struct addrinfo FAR *Hints,
    struct addrinfo FAR * FAR *Result
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_getaddrinfo,
                       &ReturnValue,
                       LibName,
                       &NodeName,
                       &ServiceName,
                       &Hints,
                       &Result))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = getaddrinfo(
                       NodeName,
                       ServiceName,
                       Hints,
                       Result
                       );
        );

    POSTAPINOTIFY((DTCODE_getaddrinfo,
                    &ReturnValue,
                    LibName,
                    &NodeName,
                    &ServiceName,
                    &Hints,
                    &Result));

    return(ReturnValue);
}

int WSAAPI
DTHOOK_getnameinfo(
    const struct sockaddr *SocketAddress,
    socklen_t SocketAddressLength,
    char *NodeName,
    DWORD NodeBufferSize,
    char *ServiceName,
    DWORD ServiceBufferSize,
    int Flags
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_getnameinfo,
                       &ReturnValue,
                       LibName,
                       &SocketAddress,
                       &SocketAddressLength,
                       &NodeName,
                       &NodeBufferSize,
                       &ServiceName,
                       &ServiceBufferSize,
                       &Flags))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = getnameinfo(
                       SocketAddress,
                       SocketAddressLength,
                       NodeName,
                       NodeBufferSize,
                       ServiceName,
                       ServiceBufferSize,
                       Flags
                       );
        );

    POSTAPINOTIFY((DTCODE_getnameinfo,
                    &ReturnValue,
                    LibName,
                    &SocketAddress,
                    &SocketAddressLength,
                    &NodeName,
                    &NodeBufferSize,
                    &ServiceName,
                    &ServiceBufferSize,
                    &Flags));

    return(ReturnValue);
}

void WSAAPI
DTHOOK_freeaddrinfo(
    struct addrinfo *Free
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_freeaddrinfo,
                       &ReturnValue,
                       LibName,
                       &Free))) {

        return;
    }

    INVOKE_ROUTINE(
        freeaddrinfo(Free);
        );

    POSTAPINOTIFY((DTCODE_freeaddrinfo,
                    &ReturnValue,
                    LibName,
                    &Free));

    return;
}

int WSPAPI
DTHOOK_WPUOpenCurrentThread(
    OUT LPWSATHREADID lpThreadId,
    OUT LPINT lpErrno
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WPUOpenCurrentThread,
                       &ReturnValue,
                       LibName,
                       &lpThreadId,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUOpenCurrentThread(
                       lpThreadId,
                       lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WPUOpenCurrentThread,
                    &ReturnValue,
                    LibName,
                    &lpThreadId,
                    &lpErrno));

    return(ReturnValue);
}

int WSPAPI
DTHOOK_WPUCloseThread(
    IN LPWSATHREADID lpThreadId,
    OUT LPINT lpErrno
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WPUCloseThread,
                       &ReturnValue,
                       LibName,
                       &lpThreadId,
                       &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WPUCloseThread(
                       lpThreadId,
                       lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WPUCloseThread,
                    &ReturnValue,
                    LibName,
                    &lpThreadId,
                    &lpErrno));

    return(ReturnValue);
}

#ifdef _WIN64

int 
WSPAPI
DTHOOK_WSCEnumProtocols32(
    IN LPINT                lpiProtocols,
    OUT LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    IN OUT LPDWORD          lpdwBufferLength,
    LPINT                   lpErrno
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSCEnumProtocols32,
                        &ReturnValue,
                        LibName,
                        lpiProtocols,
                        lpProtocolBuffer,
                        lpdwBufferLength,
                        &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCEnumProtocols32(
                        lpiProtocols,
                        lpProtocolBuffer,
                        lpdwBufferLength,
                        lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WSCEnumProtocols32,
                        &ReturnValue,
                        LibName,
                        lpiProtocols,
                        lpProtocolBuffer,
                        lpdwBufferLength,
                        &lpErrno));

    return(ReturnValue);
}

int
WSPAPI
DTHOOK_WSCInstallProvider64_32(
    IN  LPGUID lpProviderId,
    IN  const WCHAR FAR * lpszProviderDllPath,
    IN  const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN  DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSCInstallProvider64_32,
                        &ReturnValue,
                        LibName,
                        lpProviderId,
                        lpszProviderDllPath,
                        lpProtocolInfoList,
                        dwNumberOfEntries,
                        &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCInstallProvider64_32(
                        lpProviderId,
                        lpszProviderDllPath,
                        lpProtocolInfoList,
                        dwNumberOfEntries,
                        lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WSCInstallProvider64_32,
                        &ReturnValue,
                        LibName,
                        lpProviderId,
                        lpszProviderDllPath,
                        lpProtocolInfoList,
                        dwNumberOfEntries,
                        &lpErrno));

    return(ReturnValue);
}

int
WSPAPI
DTHOOK_WSCDeinstallProvider32(
    IN  LPGUID lpProviderId,
    OUT LPINT lpErrno
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSCDeinstallProvider32,
                        &ReturnValue,
                        LibName,
                        lpProviderId,
                        &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCDeinstallProvider32(
                        lpProviderId,
                        lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WSCDeinstallProvider32,
                        &ReturnValue,
                        LibName,
                        lpProviderId,
                        &lpErrno));

    return(ReturnValue);
}

int
WSPAPI
DTHOOK_WSCGetProviderPath32 (
    IN LPGUID lpProviderId,
    OUT WCHAR FAR * lpszProviderDllPath,
    IN OUT LPINT ProviderDLLPathLen,
    OUT LPINT lpErrno
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSCGetProviderPath32,
                        &ReturnValue,
                        LibName,
                        lpProviderId,
                        lpszProviderDllPath,
                        ProviderDLLPathLen,
                        &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCGetProviderPath32(
                        lpProviderId,
                        lpszProviderDllPath,
                        ProviderDLLPathLen,
                        lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WSCGetProviderPath32,
                        &ReturnValue,
                        LibName,
                        lpProviderId,
                        lpszProviderDllPath,
                        ProviderDLLPathLen,
                        &lpErrno));

    return(ReturnValue);
}

int
WSPAPI
DTHOOK_WSCUpdateProvider32(
    IN  LPGUID lpProviderId,
    IN  const WCHAR FAR * lpszProviderDllPath,
    IN  const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN  DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSCUpdateProvider32,
                        &ReturnValue,
                        LibName,
                        lpProviderId,
                        lpszProviderDllPath,
                        lpProtocolInfoList,
                        dwNumberOfEntries,
                        &lpErrno))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCUpdateProvider32(
                        lpProviderId,
                        lpszProviderDllPath,
                        lpProtocolInfoList,
                        dwNumberOfEntries,
                        lpErrno);
        );

    POSTAPINOTIFY((DTCODE_WSCUpdateProvider32,
                        &ReturnValue,
                        LibName,
                        lpProviderId,
                        lpszProviderDllPath,
                        lpProtocolInfoList,
                        dwNumberOfEntries,
                        &lpErrno));

    return(ReturnValue);
}

int
WSPAPI
DTHOOK_WSCWriteProviderOrder32 (
    IN LPDWORD lpwdCatalogEntryId,
    IN DWORD dwNumberOfEntries
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSCWriteProviderOrder32,
                        &ReturnValue,
                        LibName,
                        lpwdCatalogEntryId,
                        dwNumberOfEntries))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCWriteProviderOrder32(
                        lpwdCatalogEntryId,
                        dwNumberOfEntries);
        );

    POSTAPINOTIFY((DTCODE_WSCWriteProviderOrder32,
                        &ReturnValue,
                        LibName,
                        lpwdCatalogEntryId,
                        dwNumberOfEntries));

    return(ReturnValue);
}

INT 
WSAAPI
DTHOOK_WSCEnumNameSpaceProviders32(
    IN OUT LPDWORD              lpdwBufferLength,
    IN OUT LPWSANAMESPACE_INFOW lpnspBuffer
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSCEnumNameSpaceProviders32,
                        &ReturnValue,
                        LibName,
                        lpdwBufferLength,
                        lpnspBuffer))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCEnumNameSpaceProviders32(
                        lpdwBufferLength,
                        lpnspBuffer);
        );

    POSTAPINOTIFY((DTCODE_WSCEnumNameSpaceProviders32,
                        &ReturnValue,
                        LibName,
                        lpdwBufferLength,
                        lpnspBuffer));

    return(ReturnValue);
}

INT 
WSAAPI
DTHOOK_WSCInstallNameSpace32 (
    IN  LPWSTR  lpszIdentifier,
    IN  LPWSTR  lpszPathName,
    IN  DWORD   dwNameSpace,
    IN  DWORD   dwVersion,
    IN  LPGUID  lpProviderId
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSCInstallNameSpace32,
                        &ReturnValue,
                        LibName,
                        lpszIdentifier,
                        lpszPathName,
                        dwNameSpace,
                        dwVersion,
                        lpProviderId))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCInstallNameSpace32(
                        lpszIdentifier,
                        lpszPathName,
                        dwNameSpace,
                        dwVersion,
                        lpProviderId);
        );

    POSTAPINOTIFY((DTCODE_WSCInstallNameSpace32,
                        &ReturnValue,
                        LibName,
                        lpszIdentifier,
                        lpszPathName,
                        dwNameSpace,
                        dwVersion,
                        lpProviderId));

    return(ReturnValue);
}

INT
WSAAPI
DTHOOK_WSCUnInstallNameSpace32 (
    IN  LPGUID  lpProviderId
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSCUnInstallNameSpace32,
                        &ReturnValue,
                        LibName,
                        lpProviderId))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCUnInstallNameSpace32(
                        lpProviderId);
        );

    POSTAPINOTIFY((DTCODE_WSCUnInstallNameSpace32,
                        &ReturnValue,
                        LibName,
                        lpProviderId));

    return(ReturnValue);
}

INT
WSAAPI
DTHOOK_WSCEnableNSProvider32 (
    IN  LPGUID  lpProviderId,
    IN  BOOL    fEnable
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSCEnableNSProvider32,
                        &ReturnValue,
                        LibName,
                        lpProviderId,
                        fEnable))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCEnableNSProvider32(
                        lpProviderId,
                        fEnable);
        );

    POSTAPINOTIFY((DTCODE_WSCEnableNSProvider32,
                        &ReturnValue,
                        LibName,
                        lpProviderId,
                        fEnable));

    return(ReturnValue);
}

int
WSPAPI
DTHOOK_WSCWriteNameSpaceOrder32 (
    IN LPGUID lpProviderId,
    IN DWORD dwNumberOfEntries
    )
{
    int ReturnValue;

    if (PREAPINOTIFY((DTCODE_WSCWriteNameSpaceOrder32,
                        &ReturnValue,
                        LibName,
                        lpProviderId,
                        dwNumberOfEntries))) {

        return(ReturnValue);
    }

    INVOKE_ROUTINE(
        ReturnValue = WSCWriteNameSpaceOrder32(
                        lpProviderId,
                        dwNumberOfEntries);
        );

    POSTAPINOTIFY((DTCODE_WSCWriteNameSpaceOrder32,
                        &ReturnValue,
                        LibName,
                        lpProviderId,
                        dwNumberOfEntries));

    return(ReturnValue);
}

#endif // _WIN64

LONG
DtExceptionFilter(
    LPEXCEPTION_POINTERS ExceptionPointers,
    LPSTR                Routine
    )
{

    //
    // Protect ourselves in case the process is messed up.
    //

    __try {

        //
        // Whine about the exception.
        //

        PrintDebugString(
            "Exception: %08lx @ %08lx, caught in %s\n",
            ExceptionPointers->ExceptionRecord->ExceptionCode,
            ExceptionPointers->ExceptionRecord->ExceptionAddress,
            Routine
            );

        //
        // Call the debug/trace exception routine if installed.
        //

        if( ExceptionNotifyFP != NULL ) {

            (ExceptionNotifyFP)( ExceptionPointers );

        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        //
        // Not much we can do here...
        //

        NOTHING;

    }

    //
    // We don't actually want to suppress exceptions, just whine about them.
    // So, we return EXCEPTION_CONTINUE_SEARCH here so that the exception will
    // be seen by the app/debugger/whatever.
    //

    return EXCEPTION_CONTINUE_SEARCH;

}   // DtExceptionFilter

} // extern "C"

#endif  // DEBUG_TRACING
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\event.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    event.cpp

Abstract:

    This module contains the event handling functions from the winsock
    API.  This module contains the following entry points.

    WSACloseEvent()
    WSACreateEvent()
    WSAResetEvent()
    WSASetEvent()
    WSAWaintForMultipleEvents()

Author:

    Dirk Brandewie dirk@mink.intel.com  14-06-1995

Revision History:

    22-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Moved includes to precomp.h

    dirk@mink.intel.com  21-Jul-1995
        Added warnoff.h to includes

    Mark Hamilton mark_hamilton@ccm.jf.intel.com 19-07-1995

        Implemented all of the functions.

--*/
#include "precomp.h"



BOOL WSAAPI
WSACloseEvent(
              IN WSAEVENT hEvent
              )
/*++
Routine Description:

    Closes an open event object handle.

Arguments:

    hEvent - Identifies an open event object handle.

Returns:

    TRUE on success else FALSE. The error code is stored with
    SetLastError().

--*/
{

    BOOL result;

    //
    // NT will throw an exception if a stale handle is closed,
    // so protect ourselves in try/except so we can return the
    // correct error code.
    //

    __try {

        result = CloseHandle( hEvent );

    } __except( WS2_EXCEPTION_FILTER() ) {

        result = FALSE;

    }

    if( !result ) {

        SetLastError( WSA_INVALID_HANDLE );

    }

    return result;

}



WSAEVENT WSAAPI
WSACreateEvent (
                void
                )
/*++
Routine Description:

    Creates a new event object.

Arguments:

    NONE

Returns:

    The return value is the handle of the event object. If the
    function fails, the return value is WSA_INVALID_EVENT.

--*/
{
    return(CreateEvent(NULL,TRUE,FALSE,NULL));
}




BOOL WSAAPI
WSAResetEvent(
              IN WSAEVENT hEvent
              )
/*++
Routine Description:

    Resets the state of the specified event object to nonsignaled.

Arguments:

    hEvent - Identifies an open event object handle.

Returns:
    TRUE on success else FALSE. The error code is stored with
    SetErrorCode().
--*/
{
    return(ResetEvent(hEvent));
}




BOOL WSAAPI
WSASetEvent(
            IN WSAEVENT hEvent
            )
/*++
Routine Description:

    Sets the state of the specified event object to signaled.

Arguments:

     hEvent - Identifies an open event object handle.

Returns:

    TRUE on success else FALSE. The error code is stored with
    SetErrorCode().

--*/

{
  return( SetEvent(hEvent));
}





DWORD WSAAPI
WSAWaitForMultipleEvents(
                         IN DWORD cEvents,
                         IN const WSAEVENT FAR * lphEvents,
                         IN BOOL fWaitAll,
                         IN DWORD dwTimeout,
                         IN BOOL fAlertable
                         )
/*++
Routine Description:

    Returns  either when any one or when all of the specified event objects are
    in the signaled state, or when the time-out interval expires.

Arguments:

    cEvents    - Specifies  the  number  of  event  object handles in the array
                 pointed  to  by lphEvents.  The maximum number of event object
                 handles is WSA_MAXIMUM_WAIT_EVENTS.

    lphEvents  - Points to an array of event object handles.

    fWaitAll   - Specifies  the  wait type.  If TRUE, the function returns when
                 all  event  objects in the lphEvents array are signaled at the
                 same time.  If FALSE, the function returns when any one of the
                 event  objects  is  signaled.   In the latter case, the return
                 value  indicates  the  event  object  whose  state  caused the
                 function to return.

    dwTimeout  - Specifies   the   time-out  interval,  in  milliseconds.   The
                 function  returns  if the interval expires, even if conditions
                 specified  by  the  fWaitAll  parameter are not satisfied.  If
                 dwTimeout  is  zero,  the  function  tests  the  state  of the
                 specified event objects and returns immediately.  If dwTimeout
                 is   WSA_INFINITE,  the  function's  time-out  interval  never
                 expires.

    fAlertable - Specifies  whether the function returns when the system queues
                 an I/O completion routine for execution by the calling thread.
                 If  TRUE,  the  function returns and the completion routine is
                 executed.   If  FALSE,  the  function  does not return and the
                 completion  routine is not executed.  Note that this parameter
                 is ignored in Win16.

Returns:

     If the function succeeds, the return value indicates the event
     object that caused the function to return. If the function fails,
     the return value is WSA_WAIT_FAILED.
--*/
{
    return(WaitForMultipleObjectsEx(
        cEvents,
        lphEvents,
        fWaitAll,
        dwTimeout,
        fAlertable));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\dupsock.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    dupsock.cpp

Abstract:

    This   module   contains   the   winsock   API   functions   dealing   with
    duplicating/sharing sockets.  The following functions are contained in this
    module.

    WSADuplicateSocketA()
    WSADuplicateSocketW()

Author:

    Dirk Brandewie dirk@mink.intel.com  14-06-1995


Revision History:

    09-19-95  drewsxpa@ashland.intel.com
        Changed over to C++, actually implemented the function

--*/


#include "precomp.h"




int WSAAPI
WSADuplicateSocketW(
    IN  SOCKET          s,
    IN  DWORD           dwProcessId,
    OUT LPWSAPROTOCOL_INFOW lpProtocolInfo
    )
/*++

Routine Description:

    Return a WSAPROTOCOL_INFOW structure that can be used to create a new socket
    descriptor for a shared socket.

Arguments:

    s              - Supplies the local socket descriptor.

    dwProcessId    - Supplies the ID of the target process for which the shared
                     socket will be used.

    lpProtocolInfo - Returns a WSAPROTOCOL_INFOW struct identifying the socket
                     in the target process.

Return Value:

    If  the  function  is  successful,  it  returns ERROR_SUCCESS, otherwise it
    returns  SOCKET_ERROR,  and  a specific error message can be retrieved with
    WSAGetLastError().
--*/
{
    INT        ErrorCode, ReturnValue;
    PDPROVIDER Provider;
    PDSOCKET   Socket;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode == ERROR_SUCCESS) {

        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPDuplicateSocket(
                s,
                dwProcessId,
                lpProtocolInfo,
                & ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
} // WSADuplicateSocketW




int WSAAPI
WSADuplicateSocketA(
    IN  SOCKET          s,
    IN  DWORD           dwProcessId,
    OUT LPWSAPROTOCOL_INFOA lpProtocolInfo
    )
/*++

Routine Description:

    ANSI thunk to WSADuplicateSocketW.

Arguments:

    s              - Supplies the local socket descriptor.

    dwProcessId    - Supplies the ID of the target process for which the shared
                     socket will be used.

    lpProtocolInfo - Returns a WSAPROTOCOL_INFOA struct identifying the socket
                     in the target process.

Return Value:

    If  the  function  is  successful,  it  returns ERROR_SUCCESS, otherwise it
    returns  SOCKET_ERROR,  and  a specific error message can be retrieved with
    WSAGetLastError().
--*/
{

    INT               result;
    INT               error;
    WSAPROTOCOL_INFOW ProtocolInfoW;

    //
    // Call through to the UNICODE version.
    //

    result = WSADuplicateSocketW(
                 s,
                 dwProcessId,
                 &ProtocolInfoW
                 );

    if( result == ERROR_SUCCESS ) {

        //
        // Map the UNICODE WSAPROTOCOL_INFOW to ANSI.
        //

        if( lpProtocolInfo == NULL ) {

            error = WSAEFAULT;

        } else {

            error = MapUnicodeProtocolInfoToAnsi(
                        &ProtocolInfoW,
                        lpProtocolInfo
                        );

        }

        if( error != ERROR_SUCCESS ) {

            SetLastError( error );
            result = SOCKET_ERROR;

        }

    }

    return result;

} // WSADuplicateSocketA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\getxbyy.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    getxbyy.cpp

Abstract:

    This  module takes care of forwarding the "getxbyy" family of operations to
    the  correct getxbyy provider.  The preferred getxbyy provider is found via
    a  DLL  path  stored  in the registry.  If this registry entry is found, an
    attempt  is  made  to  load the DLL and retrieve entry points from it.  Any
    failures  cause  entry  points to be taken from the WSOCK32.DLL instead.  A
    getxbyy provider does not have to export all of the getxbyy functions since
    any it does not export are taken from WSOCK32.DLL.

    The  getxbyy  functions  handled  by  this module that can be replaced by a
    getxyy provider are the following:

    gethostbyaddr()
    gethostbyname()
    gethostname()
    getservbyname()
    getservbyport()
    WSAAsyncGetServByName()
    WSAAsyncGetServByPort()
    WSAAsyncGetProtoByName()
    WSAAsyncGetProtoByNumber()
    WSAAsyncGetHostByName()
    WSAAsyncGetHostByAddr()
    WSACancelAsyncRequest()

    The   actual  entry  points  supplied  by  the  getxbyy  provider  (or  the
    WSOCK32.DLL) are prefixed with a special string.  This prefix is defined by
    the manifest constant GETXBYYPREFIX.

Author:

    Paul Drews  drewsxpa@ashland.intel.com 12-19-1995

Revision History:

    12-19-1995 drewsxpa@ashland.intel.com
        Initial implementation
--*/



#include "precomp.h"
#include "svcguid.h"
#include <windns.h>
#include <dnslib.h>

//
//  Address to string conversion for gethostbyaddr()
//

PCHAR
Local_Ip6AddressToString_A(
    OUT     PCHAR           pBuffer,
    IN      PIP6_ADDRESS    pIp6Addr
    );

PCHAR
Local_Ip4AddressToString_A(
    OUT     PCHAR           pBuffer,
    IN      PIP4_ADDRESS    pIp4Addr
    );


//
// This is the initial buffer size passed by getxbyy functions
// to WSALookupServiceNext.  If it is insuffucient for the query,
// the amount specified by the provider is allocated and call is
// repeated.
// The initial buffer is allocated from stack, so we try to keep it
// relatively small, but still for performance reasons we want to be able
//  to satisfy most of the calls with just this amount
//
#define RNR_BUFFER_SIZE (sizeof(WSAQUERYSET) + 256)


LPBLOB
getxyDataEnt(
    IN OUT PCHAR *pResults,
    IN     DWORD dwLength,
    IN     LPSTR lpszName,
    IN     LPGUID lpType,
    OUT    LPSTR *  lppName OPTIONAL
    );

VOID
FixList(PCHAR ** List, PCHAR Base);

VOID
UnpackHostEnt(struct hostent * hostent);

VOID
UnpackServEnt(struct servent * servent);

GUID HostAddrByNameGuid = SVCID_INET_HOSTADDRBYNAME;
GUID HostNameGuid = SVCID_HOSTNAME;
GUID AddressGuid =  SVCID_INET_HOSTADDRBYINETSTRING;
GUID IANAGuid    =  SVCID_INET_SERVICEBYNAME;

//
// Utility to turn a list of offsets into a list of addresses. Used
// to convert structures returned as BLOBs.
//

VOID
FixList(PCHAR ** List, PCHAR Base)
{
    if(*List)
    {
        PCHAR * Addr;

        Addr = *List = (PCHAR *)( ((ULONG_PTR)*List + Base) );
        while(*Addr)
        {
            *Addr = (PCHAR)(((ULONG_PTR)*Addr + Base));
            Addr++;
        }
    }
}


//
// Routine to convert a hostent returned in a BLOB to one with
// usable pointers. The structure is converted in-place.
//
VOID
UnpackHostEnt(struct hostent * hostent)
{
     PCHAR pch;

     pch = (PCHAR)hostent;

     if(hostent->h_name)
     {
         hostent->h_name = (PCHAR)((ULONG_PTR)hostent->h_name + pch);
     }
     FixList(&hostent->h_aliases, pch);
     FixList(&hostent->h_addr_list, pch);
}

//
// Routine to unpack a servent returned in a BLOB to one with
// usable pointers. The structure is converted in-place
//

VOID
UnpackServEnt(struct servent * servent)
{
    PCHAR pch;

    pch = (PCHAR)servent;

    FixList(&servent->s_aliases, pch);
    servent->s_name = (PCHAR)(ULONG_PTR(servent->s_name) + pch);
    servent->s_proto = (PCHAR)(ULONG_PTR(servent->s_proto) + pch);
}





struct hostent FAR *
WSAAPI
gethostbyaddr(
    IN  const char FAR *    addr,
    IN  int                 len,
    IN  int                 type
    )
/*++
Routine Description:

    Get host information corresponding to an address.

Arguments:

    addr - A pointer to an address in network byte order.

    len  - The length of the address, which must be 4 for PF_INET addresses.

    type - The type of the address, which must be PF_INET.

Returns:

    If  no  error  occurs,  gethostbyaddr()  returns  a  pointer to the hostent
    structure  described  above.   Otherwise  it  returns  a NULL pointer and a
    specific error code is stored with SetErrorCode().
--*/
{
    CHAR        qbuf[ DNS_MAX_NAME_BUFFER_LENGTH ];
    PHOSTENT    ph;
    LPBLOB      pBlob;
    PCHAR       pResults;
    CHAR        localResults[RNR_BUFFER_SIZE];
    INT         ErrorCode;
    PDTHREAD    Thread;

    ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if(ErrorCode != ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return(NULL);
    }

    if ( !addr )
    {
        SetLastError(WSAEINVAL);
        return(NULL);
    }

    pResults = localResults;

    //
    //  build name from address
    //      - try IP6
    //      - but default to IP4
    //
    //  note, not testing for IP4 address family and length
    //  because historically this API didn't check and i don't
    //  want to now break sloppy apps
    //

    if ( type == AF_INET6 )
    {
        if ( len != sizeof(IN6_ADDR) )
        {
            SetLastError( WSAEINVAL );
            return( NULL );
        }
        Local_Ip6AddressToString_A(
            qbuf,
            (PIP6_ADDRESS) addr );
    }
    else
    {
        Local_Ip4AddressToString_A(
            qbuf,
            (PIP4_ADDRESS) addr );
    }

    pBlob = getxyDataEnt(
                    & pResults,
                    RNR_BUFFER_SIZE,
                    qbuf,
                    &AddressGuid,
                    0 );
    if(pBlob)
    {
        ph = (struct hostent *)Thread->CopyHostEnt(pBlob);
        if(ph)
        {
            UnpackHostEnt(ph);
        }
    }
    else
    {
        ph = 0;
        if(GetLastError() == WSASERVICE_NOT_FOUND)
        {
            SetLastError(WSANO_ADDRESS);
        }
    }
    if (pResults!=localResults)
        delete pResults;

    return(ph);
}  // gethostbyaddr




struct hostent FAR *
WSAAPI
gethostbyname(
    IN  const char FAR *    name
    )
/*++

Routine Description:

    Get host information corresponding to a hostname.

Arguments:

    name - A pointer to the null terminated name of the host.

Returns:

    If  no  error  occurs,  gethostbyname()  returns  a  pointer to the hostent
    structure  described  above.   Otherwise  it  returns  a NULL pointer and a
    specific errorr code is stored with SetErrorCode().

--*/
{
    struct hostent * hent;
    LPBLOB pBlob;
    PCHAR pResults;
    CHAR localResults[RNR_BUFFER_SIZE];
    INT ErrorCode;
    PDTHREAD Thread;
    CHAR  szLocalName[200];   // for storing the local name. This
                              // is simply a big number assumed
                              // to be large enough. This is used
                              // only when the caller chooses not to
                              // provide a name. Very lazy.
    PCHAR pszName;

    ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if(ErrorCode != ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return(NULL);
    }

    //
    // A NULL input name means look for the local name. So,
    // get it.
    //
    if(!name || !*name)
    {
        if(gethostname(szLocalName, 200) != NO_ERROR)
        {
            return(NULL);
        }
        pszName = szLocalName;
    }
    else
    {
        pszName = (PCHAR)name;
    }

    pResults = localResults;

    pBlob = getxyDataEnt( &pResults,
                          RNR_BUFFER_SIZE,
                          pszName,
                          &HostAddrByNameGuid,
                          0);

    if ( !pBlob &&
         ( !name || !*name ) )
    {
        pBlob = getxyDataEnt( &pResults,
                              RNR_BUFFER_SIZE,
                              NULL,
                              &HostAddrByNameGuid,
                              0);
    }

    if(pBlob)
    {
        hent = (struct hostent *)Thread->CopyHostEnt(pBlob);
        if(hent)
        {
            UnpackHostEnt(hent);
        }
    }
    else
    {
        hent = 0;

        if(GetLastError() == WSASERVICE_NOT_FOUND)
        {
            SetLastError(WSAHOST_NOT_FOUND);
        }
    }

    if (pResults!=localResults)
        delete pResults;
#ifdef RASAUTODIAL
    //
    // Inform Autodial of a successful name lookup.
    // This is important with DNS, since reverse lookups
    // do not provide complete information about name
    // aliases.
    //
    if (hent)
        WSNoteSuccessfulHostentLookup(name, *(PULONG)hent->h_addr);
#endif // RASAUTODIAL
    return(hent);
}  // gethostbyname




int WSAAPI
gethostname(
    OUT char FAR * name,
    IN int namelen
    )
/*++
Routine Description:

    Return the standard host name for the local machine.

Arguments:

    name    - A pointer to a buffer that will receive the host name.

    namelen - The length of the buffer.

Returns:

    Zero  on  success  else  SOCKET_ERROR.   The  error  code  is  stored  with
    SetErrorCode().
--*/
{
    PCHAR lpName = NULL;
    INT ErrorCode, ReturnValue;
    PDTHREAD Thread;
    PCHAR pResults;
    CHAR localResults[RNR_BUFFER_SIZE];
    int   ValueLength;

    ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if(ErrorCode != ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    }

    if (!name || IsBadWritePtr (name, namelen))
    {
        SetLastError (WSAEFAULT);
        return(SOCKET_ERROR);
    }

    //
    // Fix for bug #94978
    //
    // First check to see if the cluster computername variable is set.
    // If so, this overrides the actual gethostname to fool the application
    // into working when its network name and computer name are different.
    //
    ValueLength = GetEnvironmentVariableA("_CLUSTER_NETWORK_NAME_",
                                          name,
                                          namelen);

    if (ValueLength != 0)
    {
        //
        // The environment variable exists, return it directly
        //
        if ( ValueLength > namelen )
        {
            SetLastError(WSAEFAULT);
            return (SOCKET_ERROR);
        }

        return (ERROR_SUCCESS);
    }

    pResults = localResults;

    ReturnValue = ERROR_SUCCESS;

    (void) getxyDataEnt( &pResults,
                         RNR_BUFFER_SIZE,
                         NULL,
                         &HostAddrByNameGuid,
                         &lpName);

    if ( lpName )
    {
        INT iSize = strlen(lpName) + 1;

        if(iSize <= namelen)
        {
            memcpy(name, lpName, iSize);
        }
        else
        {
            SetLastError(WSAEFAULT);
            ReturnValue = SOCKET_ERROR;
        }
    }
    else
    {
        //
        // If getxyDataEnt() fails for any reason (like no NSPs installed)
        // then do things the 1.x way, giving them back the computer name
        //

        DWORD len = namelen;

        if (!GetComputerNameA (name, &len))
        {
            ReturnValue = SOCKET_ERROR;

            if (len >= (DWORD) namelen)
            {
                WSASetLastError (WSAEFAULT);
            }
        }
    }
    if (pResults!=localResults)
        delete pResults;
    return(ReturnValue);
}  // gethostname




struct servent FAR * WSAAPI
getservbyport(
    IN int port,
    IN const char FAR * proto
    )
/*++
Routine Description:

    Get service information corresponding to a port and protocol.

Arguments:

    port  - The port for a service, in network byte order.

    proto - An  optional  pointer  to  a  protocol  name.   If  this  is  NULL,
            getservbyport()  returns the first service entry for which the port
            matches  the  s_port.   Otherwise  getservbyport() matches both the
            port and the proto.

Returns:

    If  no  error  occurs,  getservbyport()  returns  a  pointer to the servent
    structure  described  above.   Otherwise  it  returns  a NULL pointer and a
    specific error code is stored with SetErrorCode().
--*/
{
    PCHAR pszTemp;
    struct servent * sent;
    INT  ErrorCode;
    PDTHREAD Thread;
    LPBLOB pBlob;
    PCHAR pResults;
    CHAR localResults[RNR_BUFFER_SIZE];


    ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if(ErrorCode != ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return(NULL);
    }

    pResults = localResults;

    if(!proto)
    {
        proto = "";
    }

    //
    // the 5 is the max number of digits in a port
    //
    pszTemp = new CHAR[strlen(proto) + 1 + 1 + 5];
    if (pszTemp==NULL) {
        SetLastError(WSA_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    sprintf(pszTemp, "%d/%s", (port & 0xffff), proto);
    pBlob =  getxyDataEnt(&pResults, RNR_BUFFER_SIZE, pszTemp, &IANAGuid, 0);
    delete pszTemp;

    if(!pBlob)
    {
        sent = NULL;
        if(GetLastError() == WSATYPE_NOT_FOUND)
        {
            SetLastError(WSANO_DATA);
        }
    }
    else
    {
        sent = (struct servent *)Thread->CopyServEnt(pBlob);
        if(sent)
        {
            UnpackServEnt(sent);
        }
    }
    if (pResults!=localResults)
        delete pResults;
    return(sent);
}  // getservbyport




struct servent FAR * WSAAPI
getservbyname(
    IN const char FAR * name,
    IN const char FAR * proto
    )
/*++
Routine Description:

     Get service information corresponding to a service name and protocol.

Arguments:

     name  - A pointer to a null terminated service name.

     proto - An  optional  pointer to a null terminated protocol name.  If this
             pointer  is  NULL, getservbyname() returns the first service entry
             for  which  the  name  matches the s_name or one of the s_aliases.
             Otherwise getservbyname() matches both the name and the proto.

Returns:

     If  no  error  occurs,  getservbyname()  returns  a pointer to the servent
     structure  described  above.   Otherwise  it  returns a NULL pointer and a
     specific error code is stored with SetErrorCode().
--*/
{
    PCHAR pszTemp;
    struct servent * sent;
    INT ErrorCode;
    PDTHREAD Thread;
    LPBLOB pBlob;
    PCHAR pResults;
    CHAR localResults[RNR_BUFFER_SIZE];

    ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if(ErrorCode != ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return(NULL);
    }

    if ( !name ) // Bug fix for #112969
    {
        SetLastError(WSAEINVAL);
        return(NULL);
    }

    pResults = localResults;

    if(!proto)
    {
        proto = "";
    }
    pszTemp = new CHAR[strlen(name) + strlen(proto) + 1 + 1];
    if (pszTemp==NULL) {
        SetLastError(WSA_NOT_ENOUGH_MEMORY);
        return(NULL);
    }
    sprintf(pszTemp, "%s/%s", name, proto);
    pBlob = getxyDataEnt(&pResults, RNR_BUFFER_SIZE, pszTemp, &IANAGuid, 0);
    delete pszTemp;
    if(!pBlob)
    {
        sent = NULL;
        if(GetLastError() == WSATYPE_NOT_FOUND)
        {
            SetLastError(WSANO_DATA);
        }
    }
    else
    {
        sent = (struct servent *)Thread->CopyServEnt(pBlob);
        if(sent)
        {
            UnpackServEnt(sent);
        }
    }
    if (pResults!=localResults)
        delete pResults;
    return(sent);
}  // getservbyname


//
// Common routine for obtaining a xxxent buffer. Input is used to
// execute the WSALookup series of APIs.
//
// Args:
//   pResults -- a pointer to a buffer supplied by the caller to be used in
//               the WASLookup calls. If the buffer is not large enough
//               this routine allocates a new one and modifies the value
//               in pResults.  The new buffer should be freed by the caller
//               using delete.
//   dwLength -- number of bytes in pResults (originally).
//   lpszName -- pointer to the service name. May by NULL
//   lpType   -- pointer to the service type . This should be one of
//               the SVCID_INET_xxxxx types. It may be anything
//               that produces a BLOB.
//   lppName  -- pointer to pointer where the resulting name pointer
//               is stored. May be NULL if the name is not needed.
//
// Returns:
//   0  --  No BLOB data was returned. In general, this means the operation
//          failed. Evev if the WSALookupNext succeeded and returned a
//          name, the name will not be returned.
//   else -- a pointer to the BLOB.
//
//


//
// The protocol restrictions list for all emulation operations. This should
// limit the invoked providers to the set that know about hostents and
// servents. If not, then the special SVCID_INET GUIDs should take care
// of the remainder.
//
AFPROTOCOLS afp[2] = {
                      {AF_INET, IPPROTO_UDP},
                      {AF_INET, IPPROTO_TCP}
                     };

LPBLOB
getxyDataEnt(
    IN OUT  PCHAR *         pResults,
    IN      DWORD           dwLength,
    IN      LPSTR           lpszName,
    IN      LPGUID          lpType,
    OUT     LPSTR *         lppName     OPTIONAL
    )
{

/*++
Routine Description:
   See comment above for details
--*/

    PWSAQUERYSETA   pwsaq = (PWSAQUERYSETA)*pResults;
    int             err;
    HANDLE          hRnR;
    LPBLOB          pvRet = 0;
    INT             Err = 0;
    DWORD           origLength = dwLength;  // save length of original buffer
                                            // in case we need to reallocate it

    if ( lppName )
    {
        *lppName = NULL;
    }

    //
    //  create the query
    //

    memset(pwsaq, 0, sizeof(*pwsaq));

    pwsaq->dwSize                   = sizeof(*pwsaq);
    pwsaq->lpszServiceInstanceName  = lpszName;
    pwsaq->lpServiceClassId         = lpType;
    pwsaq->dwNameSpace              = NS_ALL;
    pwsaq->dwNumberOfProtocols      = 2;
    pwsaq->lpafpProtocols           = &afp[0];

    err = WSALookupServiceBeginA(
                pwsaq,
                LUP_RETURN_BLOB | LUP_RETURN_NAME,
                &hRnR );

    if(err == NO_ERROR)
    {

        //
        // If the original buffer is small to contain the results
        // will allocate new one and retry the call.
        //
    Retry:

        //
        // The query was accepted, so execute it via the Next call.
        //
        err = WSALookupServiceNextA(
                                hRnR,
                                0,
                                &dwLength,
                                pwsaq);
        //
        // if NO_ERROR was returned and a BLOB is present, this
        // worked, just return the requested information. Otherwise,
        // invent an error or capture the transmitted one.
        //

        if(err == NO_ERROR)
        {
            if(pvRet = pwsaq->lpBlob)
            {
                if(lppName)
                {
                    *lppName = pwsaq->lpszServiceInstanceName;
                }
            }
            else
            {
                if ( lpType == &HostNameGuid )
                {
                    if(lppName)
                    {
                        *lppName = pwsaq->lpszServiceInstanceName;
                    }
                }
                else
                {
                    err = WSANO_DATA;
                }
            }
        }
        else
        {
            //
            // WSALookupServiceEnd clobbers LastError so save
            // it before closing the handle.
            //

            err = GetLastError();

            //
            // The provider returns WSAEFAULT if the result buffer
            // is not large enough (to make sure that this is not
            // just a random error or a result AV when accessing the
            // the buffer content, we check the returned buffer size
            // against the value that we initially supplied).
            //
            if ((err==WSAEFAULT) && (dwLength>origLength))
            {
                PCHAR   newBuffer = new CHAR[dwLength];
                if (newBuffer)
                {
                    //
                    // Remeber the new length, so that provider cannot
                    // force us to loop indefinitely (well if it keeps
                    // increasing required buffer size, we'll run into
                    // out of memory error sometimes).
                    // 
                    origLength = dwLength;

                    //
                    // Replace the callers pointer to the buffer, so
                    // it knows to free it
                    //
                    *pResults = newBuffer;

                    //
                    // Repoint results to new buffer.
                    //
                    pwsaq = (PWSAQUERYSETA)newBuffer;
                    
                    //
                    // Try the Next call again.
                    //
                    goto Retry;
                }
                else 
                {
                    err = WSA_NOT_ENOUGH_MEMORY;
                }
            }
        }
        WSALookupServiceEnd(hRnR);

        //
        // if an error happened, stash the value in LastError
        //

        if(err != NO_ERROR)
        {
            SetLastError(err);
        }
    }


    return(pvRet);
}



HANDLE
WSAAPI
WSAAsyncGetServByName(
    IN HWND hWnd,
    IN unsigned int wMsg,
    IN const char FAR * Name,
    IN const char FAR * Protocol,
    IN char FAR * Buffer,
    IN int BufferLength
    )

/*++

Routine Description:

    This function is an asynchronous version of getservbyname(), and is
    used to retrieve service information corresponding to a service
    name.  The Windows Sockets implementation initiates the operation
    and returns to the caller immediately, passing back an asynchronous
    task handle which the application may use to identify the operation.
    When the operation is completed, the results (if any) are copied
    into the buffer provided by the caller and a message is sent to the
    application's window.

    When the asynchronous operation is complete the application's window
    hWnd receives message wMsg.  The wParam argument contains the
    asynchronous task handle as returned by the original function call.
    The high 16 bits of lParam contain any error code.  The error code
    may be any error as defined in winsock.h.  An error code of zero
    indicates successful completion of the asynchronous operation.  On
    successful completion, the buffer supplied to the original function
    call contains a hostent structure.  To access the elements of this
    structure, the original buffer address should be cast to a hostent
    structure pointer and accessed as appropriate.

    Note that if the error code is WSAENOBUFS, it indicates that the
    size of the buffer specified by buflen in the original call was too
    small to contain all the resultant information.  In this case, the
    low 16 bits of lParam contain the size of buffer required to supply
    ALL the requisite information.  If the application decides that the
    partial data is inadequate, it may reissue the
    WSAAsyncGetHostByAddr() function call with a buffer large enough to
    receive all the desired information (i.e.  no smaller than the low
    16 bits of lParam).

    The error code and buffer length should be extracted from the lParam
    using the macros WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in
    winsock.h as:

        #define WSAGETASYNCERROR(lParam) HIWORD(lParam)
        #define WSAGETASYNCBUFLEN(lParam) LOWORD(lParam)

    The use of these macros will maximize the portability of the source
    code for the application.

    The buffer supplied to this function is used by the Windows Sockets
    implementation to construct a hostent structure together with the
    contents of data areas referenced by members of the same hostent
    structure.  To avoid the WSAENOBUFS error noted above, the
    application should provide a buffer of at least MAXGETHOSTSTRUCT
    bytes (as defined in winsock.h).

Arguments:

    hWnd - The handle of the window which should receive a message when
       the asynchronous request completes.

    wMsg - The message to be received when the asynchronous request
       completes.

    name - A pointer to a service name.

    proto - A pointer to a protocol name.  This may be NULL, in which
        case WSAAsyncGetServByName() will search for the first service
        entry for which s_name or one of the s_aliases matches the given
        name.  Otherwise WSAAsyncGetServByName() matches both name and
        proto.

    buf - A pointer to the data area to receive the servent data.  Note
       that this must be larger than the size of a servent structure.
       This is because the data area supplied is used by the Windows
       Sockets implementation to contain not only a servent structure
       but any and all of the data which is referenced by members of the
       servent structure.  It is recommended that you supply a buffer of
       MAXGETHOSTSTRUCT bytes.

    buflen    The size of data area buf above.

Return Value:

    The return value specifies whether or not the asynchronous operation
    was successfully initiated.  Note that it does not imply success or
    failure of the operation itself.

    If the operation was successfully initiated, WSAAsyncGetHostByAddr()
    returns a nonzero value of type HANDLE which is the asynchronous
    task handle for the request.  This value can be used in two ways.
    It can be used to cancel the operation using
    WSACancelAsyncRequest().  It can also be used to match up
    asynchronous operations and completion messages, by examining the
    wParam message argument.

    If the asynchronous operation could not be initiated,
    WSAAsyncGetHostByAddr() returns a zero value, and a specific error
    number may be retrieved by calling WSAGetLastError().

--*/

{

    INT                    ErrorCode;
    PWINSOCK_CONTEXT_BLOCK contextBlock;
    HANDLE                 taskHandle;
    PCHAR                  localName;

    ErrorCode = TURBO_PROLOG();

    if (ErrorCode!=ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return NULL;
    } //if

    //
    // Initialize the async thread if it hasn't already been started.
    //

    if( !SockCheckAndInitAsyncThread() ) {

        // !!! better error code?
        SetLastError( WSAENOBUFS );
        return NULL;

    }

    //
    // Get an async context block with enough extra space for
    // the name.  We must preserve the name until we're done using
    // it, since the application may reuse the buffer.
    //

    contextBlock = SockAllocateContextBlock( strlen(Name) + 1 );

    if( contextBlock == NULL ) {

        SetLastError( WSAENOBUFS );
        return NULL;

    }

    localName = (PCHAR)( contextBlock + 1 );

    strcpy( localName, Name );

    //
    // Initialize the context block for this operation.
    //

    contextBlock->OpCode = WS_OPCODE_GET_SERV_BY_NAME;
    contextBlock->Overlay.AsyncGetServ.hWnd = hWnd;
    contextBlock->Overlay.AsyncGetServ.wMsg = wMsg;
    contextBlock->Overlay.AsyncGetServ.Filter = localName;
    contextBlock->Overlay.AsyncGetServ.Protocol = (PCHAR)Protocol;;
    contextBlock->Overlay.AsyncGetServ.Buffer = Buffer;
    contextBlock->Overlay.AsyncGetServ.BufferLength = BufferLength;

    //
    // Save the task handle so that we can return it to the caller.
    // After we post the context block, we're not allowed to access
    // it in any way.
    //

    taskHandle = contextBlock->TaskHandle;

    //
    // Queue the request to the async thread.
    //

    SockQueueRequestToAsyncThread( contextBlock );

    return taskHandle;

}   // WSAAsyncGetServByName



HANDLE
WSAAPI
WSAAsyncGetServByPort(
    IN HWND hWnd,
    IN unsigned int wMsg,
    IN int Port,
    IN const char FAR * Protocol,
    IN char FAR * Buffer,
    IN int BufferLength
    )

/*++

Routine Description:

    This function is an asynchronous version of getservbyport(), and is
    used to retrieve service information corresponding to a port number.
    The Windows Sockets implementation initiates the operation and
    returns to the caller immediately, passing back an asynchronous task
    handle which the application may use to identify the operation.
    When the operation is completed, the results (if any) are copied
    into the buffer provided by the caller and a message is sent to the
    application's window.

    When the asynchronous operation is complete the application's window
    hWnd receives message wMsg.  The wParam argument contains the
    asynchronous task handle as returned by the original function call.
    The high 16 bits of lParam contain any error code.  The error code
    may be any error as defined in winsock.h.  An error code of zero
    indicates successful completion of the asynchronous operation.  On
    successful completion, the buffer supplied to the original function
    call contains a servent structure.  To access the elements of this
    structure, the original buffer address should be cast to a servent
    structure pointer and accessed as appropriate.

    Note that if the error code is WSAENOBUFS, it indicates that the
    size of the buffer specified by buflen in the original call was too
    small to contain all the resultant information.  In this case, the
    low 16 bits of lParam contain the size of buffer required to supply
    ALL the requisite information.  If the application decides that the
    partial data is inadequate, it may reissue the
    WSAAsyncGetServByPort() function call with a buffer large enough to
    receive all the desired information (i.e.  no smaller than the low
    16 bits of lParam).

    The error code and buffer length should be extracted from the lParam
    using the macros WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in
    winsock.h as:

        #define WSAGETASYNCERROR(lParam) HIWORD(lParam)
        #define WSAGETASYNCBUFLEN(lParam) LOWORD(lParam)

    The use of these macros will maximize the portability of the source
    code for the application.


    The buffer supplied to this function is used by the Windows Sockets
    implementation to construct a servent structure together with the
    contents of data areas referenced by members of the same servent
    structure.  To avoid the WSAENOBUFS error noted above, the
    application should provide a buffer of at least MAXGETHOSTSTRUCT
    bytes (as defined in winsock.h).

Arguments:

    hWnd - The handle of the window which should receive a message when
       the asynchronous request completes.

    wMsg - The message to be received when the asynchronous request
       completes.

    port - The port for the service, in network byte order.

    proto - A pointer to a protocol name.  This may be NULL, in which
        case WSAAsyncGetServByPort() will search for the first service
        entry for which s_port match the given port.  Otherwise
        WSAAsyncGetServByPort() matches both port and proto.

    buf - A pointer to the data area to receive the servent data.  Note
       that this must be larger than the size of a servent structure.
       This is because the data area supplied is used by the Windows
       Sockets implementation to contain not only a servent structure
       but any and all of the data which is referenced by members of the
       servent structure.  It is recommended that you supply a buffer of
       MAXGETHOSTSTRUCT bytes.

    buflen    The size of data area buf above.

Return Value:

    The return value specifies whether or not the asynchronous operation
    was successfully initiated.  Note that it does not imply success or
    failure of the operation itself.

    If the operation was successfully initiated, WSAAsyncGetServByPort()
    returns a nonzero value of type HANDLE which is the asynchronous
    task handle for the request.  This value can be used in two ways.
    It can be used to cancel the operation using
    WSACancelAsyncRequest().  It can also be used to match up
    asynchronous operations and completion messages, by examining the
    wParam message argument.

    If the asynchronous operation could not be initiated,
    WSAAsyncGetServByPort() returns a zero value, and a specific error
    number may be retrieved by calling WSAGetLastError().

--*/

{

    INT                    ErrorCode;
    PWINSOCK_CONTEXT_BLOCK contextBlock;
    HANDLE                 taskHandle;

    ErrorCode = TURBO_PROLOG();

    if (ErrorCode!=ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return NULL;
    } //if

    //
    // Initialize the async thread if it hasn't already been started.
    //

    if( !SockCheckAndInitAsyncThread() ) {

        // !!! better error code?
        SetLastError( WSAENOBUFS );
        return NULL;

    }

    //
    // Get an async context block.
    //

    contextBlock = SockAllocateContextBlock( 0 );

    if ( contextBlock == NULL ) {

        SetLastError( WSAENOBUFS );
        return NULL;

    }

    //
    // Initialize the context block for this operation.
    //

    contextBlock->OpCode = WS_OPCODE_GET_SERV_BY_PORT;
    contextBlock->Overlay.AsyncGetServ.hWnd = hWnd;
    contextBlock->Overlay.AsyncGetServ.wMsg = wMsg;
    contextBlock->Overlay.AsyncGetServ.Filter = (PCHAR)IntToPtr(Port);
    contextBlock->Overlay.AsyncGetServ.Protocol = (PCHAR)Protocol;
    contextBlock->Overlay.AsyncGetServ.Buffer = Buffer;
    contextBlock->Overlay.AsyncGetServ.BufferLength = BufferLength;

    //
    // Save the task handle so that we can return it to the caller.
    // After we post the context block, we're not allowed to access
    // it in any way.
    //

    taskHandle = contextBlock->TaskHandle;

    //
    // Queue the request to the async thread.
    //

    SockQueueRequestToAsyncThread( contextBlock );

    return taskHandle;

}   // WSAAsyncGetServByPort



HANDLE
WSAAPI
WSAAsyncGetHostByName(
    HWND hWnd,
    unsigned int wMsg,
    const char FAR * Name,
    char FAR * Buffer,
    int BufferLength
    )

/*++

Routine Description:

    This function is an asynchronous version of gethostbyname(), and is
    used to retrieve host name and address information corresponding to
    a hostname.  The Windows Sockets implementation initiates the
    operation and returns to the caller immediately, passing back an
    asynchronous task handle which the application may use to identify
    the operation.  When the operation is completed, the results (if
    any) are copied into the buffer provided by the caller and a message
    is sent to the application's window.

    When the asynchronous operation is complete the application's window
    hWnd receives message wMsg.  The wParam argument contains the
    asynchronous task handle as returned by the original function call.
    The high 16 bits of lParam contain any error code.  The error code
    may be any error as defined in winsock.h.  An error code of zero
    indicates successful completion of the asynchronous operation.  On
    successful completion, the buffer supplied to the original function
    call contains a hostent structure.  To access the elements of this
    structure, the original buffer address should be cast to a hostent
    structure pointer and accessed as appropriate.

    Note that if the error code is WSAENOBUFS, it indicates that the
    size of the buffer specified by buflen in the original call was too
    small to contain all the resultant information.  In this case, the
    low 16 bits of lParam contain the size of buffer required to supply
    ALL the requisite information.  If the application decides that the
    partial data is inadequate, it may reissue the
    WSAAsyncGetHostByName() function call with a buffer large enough to
    receive all the desired information (i.e.  no smaller than the low
    16 bits of lParam).

    The error code and buffer length should be extracted from the lParam
    using the macros WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in
    winsock.h as:

        #define WSAGETASYNCERROR(lParam) HIWORD(lParam)
        #define WSAGETASYNCBUFLEN(lParam) LOWORD(lParam)

    The use of these macros will maximize the portability of the source
    code for the application.

    The buffer supplied to this function is used by the Windows Sockets
    implementation to construct a hostent structure together with the
    contents of data areas referenced by members of the same hostent
    structure.  To avoid the WSAENOBUFS error noted above, the
    application should provide a buffer of at least MAXGETHOSTSTRUCT
    bytes (as defined in winsock.h).

Arguments:

    hWnd - The handle of the window which should receive a message when
       the asynchronous request completes.

    wMsg - The message to be received when the asynchronous request
       completes.

    name - A pointer to the name of the host.

    buf - A pointer to the data area to receive the hostent data.  Note
       that this must be larger than the size of a hostent structure.
       This is because the data area supplied is used by the Windows
       Sockets implementation to contain not only a hostent structure
       but any and all of the data which is referenced by members of the
       hostent structure.  It is recommended that you supply a buffer of
       MAXGETHOSTSTRUCT bytes.

    buflen - The size of data area buf above.

Return Value:

    The return value specifies whether or not the asynchronous operation
    was successfully initiated.  Note that it does not imply success or
    failure of the operation itself.

    If the operation was successfully initiated, WSAAsyncGetHostByName()
    returns a nonzero value of type HANDLE which is the asynchronous
    task handle for the request.  This value can be used in two ways.
    It can be used to cancel the operation using
    WSACancelAsyncRequest().  It can also be used to match up
    asynchronous operations and completion messages, by examining the
    wParam message argument.

    If the asynchronous operation could not be initiated,
    WSAAsyncGetHostByName() returns a zero value, and a specific error
    number may be retrieved by calling WSAGetLastError().

--*/

{

    INT                    ErrorCode;
    PWINSOCK_CONTEXT_BLOCK contextBlock;
    HANDLE                 taskHandle;
    PCHAR                  localName;

    ErrorCode = TURBO_PROLOG();

    if (ErrorCode!=ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return NULL;
    } //if

    //
    // Initialize the async thread if it hasn't already been started.
    //

    if( !SockCheckAndInitAsyncThread() ) {

        // !!! better error code?
        SetLastError( WSAENOBUFS );
        return NULL;

    }

    //
    // Get an async context block with enough extra space for
    // the name.  We must preserve the name until we're done using
    // it, since the application may reuse the buffer.
    //

    contextBlock = SockAllocateContextBlock( strlen(Name) + 1 );

    if( contextBlock == NULL ) {

        SetLastError( WSAENOBUFS );
        return NULL;

    }

    localName = (PCHAR)( contextBlock + 1 );

    strcpy( localName, Name );

    //
    // Initialize the context block for this operation.
    //

    contextBlock->OpCode = WS_OPCODE_GET_HOST_BY_NAME;
    contextBlock->Overlay.AsyncGetHost.hWnd = hWnd;
    contextBlock->Overlay.AsyncGetHost.wMsg = wMsg;
    contextBlock->Overlay.AsyncGetHost.Filter = localName;
    contextBlock->Overlay.AsyncGetHost.Buffer = Buffer;
    contextBlock->Overlay.AsyncGetHost.BufferLength = BufferLength;

    //
    // Save the task handle so that we can return it to the caller.
    // After we post the context block, we're not allowed to access
    // it in any way.
    //

    taskHandle = contextBlock->TaskHandle;

    //
    // Queue the request to the async thread.
    //

    SockQueueRequestToAsyncThread( contextBlock );

    return taskHandle;

}   // WSAAsyncGetHostByName


HANDLE
WSAAPI
WSAAsyncGetHostByAddr(
    HWND hWnd,
    unsigned int wMsg,
    const char FAR * Address,
    int Length,
    int Type,
    char FAR * Buffer,
    int BufferLength
    )

/*++

Routine Description:

    This function is an asynchronous version of gethostbyaddr(), and is
    used to retrieve host name and address information corresponding to
    a network address.  The Windows Sockets implementation initiates the
    operation and returns to the caller immediately, passing back an
    asynchronous task handle which the application may use to identify
    the operation.  When the operation is completed, the results (if
    any) are copied into the buffer provided by the caller and a message
    is sent to the application's window.

    When the asynchronous operation is complete the application's window
    hWnd receives message wMsg.  The wParam argument contains the
    asynchronous task handle as returned by the original function call.
    The high 16 bits of lParam contain any error code.  The error code
    may be any error as defined in winsock.h.  An error code of zero
    indicates successful completion of the asynchronous operation.  On
    successful completion, the buffer supplied to the original function
    call contains a hostent structure.  To access the elements of this
    structure, the original buffer address should be cast to a hostent
    structure pointer and accessed as appropriate.

    Note that if the error code is WSAENOBUFS, it indicates that the
    size of the buffer specified by buflen in the original call was too
    small to contain all the resultant information.  In this case, the
    low 16 bits of lParam contain the size of buffer required to supply
    ALL the requisite information.  If the application decides that the
    partial data is inadequate, it may reissue the
    WSAAsyncGetHostByAddr() function call with a buffer large enough to
    receive all the desired information (i.e.  no smaller than the low
    16 bits of lParam).

    The error code and buffer length should be extracted from the lParam
    using the macros WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in
    winsock.h as:

        #define WSAGETASYNCERROR(lParam) HIWORD(lParam)
        #define WSAGETASYNCBUFLEN(lParam) LOWORD(lParam)

    The use of these macros will maximize the portability of the source
    code for the application.

    The buffer supplied to this function is used by the Windows Sockets
    implementation to construct a hostent structure together with the
    contents of data areas referenced by members of the same hostent
    structure.  To avoid the WSAENOBUFS error noted above, the
    application should provide a buffer of at least MAXGETHOSTSTRUCT
    bytes (as defined in winsock.h).

Arguments:

    hWnd - The handle of the window which should receive a message when
       the asynchronous request completes.

    wMsg - The message to be received when the asynchronous request
       completes.

    addr - A pointer to the network address for the host.  Host
       addresses are stored in network byte order.

    len - The length of the address, which must be 4 for PF_INET.

    type - The type of the address, which must be PF_INET.

    buf - A pointer to the data area to receive the hostent data.  Note
       that this must be larger than the size of a hostent structure.
       This is because the data area supplied is used by the Windows
       Sockets implementation to contain not only a hostent structure
       but any and all of the data which is referenced by members of the
       hostent structure.  It is recommended that you supply a buffer of
       MAXGETHOSTSTRUCT bytes.

    buflen - The size of data area buf above.

Return Value:

    The return value specifies whether or not the asynchronous operation
    was successfully initiated.  Note that it does not imply success or
    failure of the operation itself.

    If the operation was successfully initiated, WSAAsyncGetHostByAddr()
    returns a nonzero value of type HANDLE which is the asynchronous
    task handle for the request.  This value can be used in two ways.
    It can be used to cancel the operation using
    WSACancelAsyncRequest().  It can also be used to match up
    asynchronous operations and completion messages, by examining the
    wParam message argument.

    If the asynchronous operation could not be initiated,
    WSAAsyncGetHostByAddr() returns a zero value, and a specific error
    number may be retrieved by calling WSAGetLastError().

--*/

{

    INT                    ErrorCode;
    PWINSOCK_CONTEXT_BLOCK contextBlock;
    HANDLE                 taskHandle;
    PCHAR                  localAddress;

    ErrorCode = TURBO_PROLOG();

    if (ErrorCode!=ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return NULL;
    } //if

    //
    // Initialize the async thread if it hasn't already been started.
    //

    if( !SockCheckAndInitAsyncThread() ) {

        // !!! better error code?
        SetLastError( WSAENOBUFS );
        return NULL;

    }

    //
    // Get an async context block with enough extra space for
    // the address.  We must preserve the address until we're done
    // using it, since the application may reuse the buffer.
    //

    contextBlock = SockAllocateContextBlock( Length );

    if( contextBlock == NULL ) {

        SetLastError( WSAENOBUFS );
        return NULL;

    }

    localAddress = (PCHAR)( contextBlock + 1 );

    CopyMemory(
        localAddress,
        Address,
        Length
        );

    //
    // Initialize the context block for this operation.
    //

    contextBlock->OpCode = WS_OPCODE_GET_HOST_BY_ADDR;
    contextBlock->Overlay.AsyncGetHost.hWnd = hWnd;
    contextBlock->Overlay.AsyncGetHost.wMsg = wMsg;
    contextBlock->Overlay.AsyncGetHost.Filter = localAddress;
    contextBlock->Overlay.AsyncGetHost.Length = Length;
    contextBlock->Overlay.AsyncGetHost.Type = Type;
    contextBlock->Overlay.AsyncGetHost.Buffer = Buffer;
    contextBlock->Overlay.AsyncGetHost.BufferLength = BufferLength;

    //
    // Save the task handle so that we can return it to the caller.
    // After we post the context block, we're not allowed to access
    // it in any way.
    //

    taskHandle = contextBlock->TaskHandle;

    //
    // Queue the request to the async thread.
    //

    SockQueueRequestToAsyncThread( contextBlock );

    return taskHandle;

}   // WSAAsyncGetHostByAddr


HANDLE
WSAAPI
WSAAsyncGetProtoByName (
    IN HWND hWnd,
    IN unsigned int wMsg,
    IN const char FAR *Name,
    IN char FAR *Buffer,
    IN int BufferLength
    )

/*++

Routine Description:

    This function is an asynchronous version of getprotobyname(), and is
    used to retrieve the protocol name and number corresponding to a
    protocol name.  The Windows Sockets implementation initiates the
    operation and returns to the caller immediately, passing back an
    asynchronous task handle which the application may use to identify
    the operation.  When the operation is completed, the results (if
    any) are copied into the buffer provided by the caller and a message
    is sent to the application's window.

    When the asynchronous operation is complete the application's window
    hWnd receives message wMsg.  The wParam argument contains the
    asynchronous task handle as returned by the original function call.
    The high 16 bits of lParam contain any error code.  The error code
    may be any error as defined in winsock.h.  An error code of zero
    indicates successful completion of the asynchronous operation.  On
    successful completion, the buffer supplied to the original function
    call contains a protoent structure.  To access the elements of this
    structure, the original buffer address should be cast to a protoent
    structure pointer and accessed as appropriate.

    Note that if the error code is WSAENOBUFS, it indicates that the
    size of the buffer specified by buflen in the original call was too
    small to contain all the resultant information.  In this case, the
    low 16 bits of lParam contain the size of buffer required to supply
    ALL the requisite information.  If the application decides that the
    partial data is inadequate, it may reissue the
    WSAAsyncGetProtoByName() function call with a buffer large enough to
    receive all the desired information (i.e.  no smaller than the low
    16 bits of lParam).

    The error code and buffer length should be extracted from the lParam
    using the macros WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in
    winsock.h as:

        #define WSAGETASYNCERROR(lParam) HIWORD(lParam)
        #define WSAGETASYNCBUFLEN(lParam) LOWORD(lParam)

    The use of these macros will maximize the portability of the source
    code for the application.

    The buffer supplied to this function is used by the Windows Sockets
    implementation to construct a protoent structure together with the
    contents of data areas referenced by members of the same protoent
    structure.  To avoid the WSAENOBUFS error noted above, the
    application should provide a buffer of at least MAXGETHOSTSTRUCT
    bytes (as defined in winsock.h).

Arguments:

    hWnd - The handle of the window which should receive a message when
       the asynchronous request completes.

    wMsg - The message to be received when the asynchronous request
       completes.

    name - A pointer to the protocol name to be resolved.

    buf - A pointer to the data area to receive the protoent data.  Note
       that this must be larger than the size of a protoent structure.
       This is because the data area supplied is used by the Windows
       Sockets implementation to contain not only a protoent structure
       but any and all of the data which is referenced by members of the
       protoent structure.  It is recommended that you supply a buffer
       of MAXGETHOSTSTRUCT bytes.

    buflen - The size of data area buf above.

Return Value:

    The return value specifies whether or not the asynchronous operation
    was successfully initiated.  Note that it does not imply success or
    failure of the operation itself.

    If the operation was successfully initiated,
    WSAAsyncGetProtoByName() returns a nonzero value of type HANDLE
    which is the asynchronous task handle for the request.  This value
    can be used in two ways.  It can be used to cancel the operation
    using WSACancelAsyncRequest().  It can also be used to match up
    asynchronous operations and completion messages, by examining the
    wParam message argument.

    If the asynchronous operation could not be initiated,
    WSAAsyncGetProtoByName() returns a zero value, and a specific error
    number may be retrieved by calling WSAGetLastError().

--*/

{

    INT                    ErrorCode;
    PWINSOCK_CONTEXT_BLOCK contextBlock;
    HANDLE                 taskHandle;
    PCHAR                  localName;

    ErrorCode = TURBO_PROLOG();

    if (ErrorCode!=ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return NULL;
    } //if

    //
    // Initialize the async thread if it hasn't already been started.
    //

    if( !SockCheckAndInitAsyncThread() ) {

        // !!! better error code?
        SetLastError( WSAENOBUFS );
        return NULL;

    }

    //
    // Get an async context block with enough extra space for
    // the name.  We must preserve the name until we're done using
    // it, since the application may reuse the buffer.
    //

    contextBlock = SockAllocateContextBlock( strlen(Name) + 1 );

    if( contextBlock == NULL ) {

        SetLastError( WSAENOBUFS );
        return NULL;

    }

    localName = (PCHAR)( contextBlock + 1 );

    strcpy( localName, Name );

    //
    // Initialize the context block for this operation.
    //

    contextBlock->OpCode = WS_OPCODE_GET_PROTO_BY_NAME;
    contextBlock->Overlay.AsyncGetProto.hWnd = hWnd;
    contextBlock->Overlay.AsyncGetProto.wMsg = wMsg;
    contextBlock->Overlay.AsyncGetProto.Filter = localName;
    contextBlock->Overlay.AsyncGetProto.Buffer = Buffer;
    contextBlock->Overlay.AsyncGetProto.BufferLength = BufferLength;

    //
    // Save the task handle so that we can return it to the caller.
    // After we post the context block, we're not allowed to access
    // it in any way.
    //

    taskHandle = contextBlock->TaskHandle;

    //
    // Queue the request to the async thread.
    //

    SockQueueRequestToAsyncThread( contextBlock );

    return taskHandle;

}   // WSAAsyncGetProtoByName


HANDLE
WSAAPI
WSAAsyncGetProtoByNumber (
    HWND hWnd,
    unsigned int wMsg,
    int Number,
    char FAR * Buffer,
    int BufferLength
    )

/*++

Routine Description:

    This function is an asynchronous version of getprotobynumber(), and
    is used to retrieve the protocol name and number corresponding to a
    protocol number.  The Windows Sockets implementation initiates the
    operation and returns to the caller immediately, passing back an
    asynchronous task handle which the application may use to identify
    the operation.  When the operation is completed, the results (if
    any) are copied into the buffer provided by the caller and a message
    is sent to the application's window.

    When the asynchronous operation is complete the application's window
    hWnd receives message wMsg.  The wParam argument contains the
    asynchronous task handle as returned by the original function call.
    The high 16 bits of lParam contain any error code.  The error code
    may be any error as defined in winsock.h.  An error code of zero
    indicates successful completion of the asynchronous operation.  On
    successful completion, the buffer supplied to the original function
    call contains a protoent structure.  To access the elements of this
    structure, the original buffer address should be cast to a protoent
    structure pointer and accessed as appropriate.

    Note that if the error code is WSAENOBUFS, it indicates that the
    size of the buffer specified by buflen in the original call was too
    small to contain all the resultant information.  In this case, the
    low 16 bits of lParam contain the size of buffer required to supply
    ALL the requisite information.  If the application decides that the
    partial data is inadequate, it may reissue the
    WSAAsyncGetProtoByNumber() function call with a buffer large enough
    to receive all the desired information (i.e.  no smaller than the
    low 16 bits of lParam).

    The error code and buffer length should be extracted from the lParam
    using the macros WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in
    winsock.h as:

        #define WSAGETASYNCERROR(lParam) HIWORD(lParam)
        #define WSAGETASYNCBUFLEN(lParam) LOWORD(lParam)

    The use of these macros will maximize the portability of the source
    code for the application.

    The buffer supplied to this function is used by the Windows Sockets
    implementation to construct a protoent structure together with the
    contents of data areas referenced by members of the same protoent
    structure.  To avoid the WSAENOBUFS error noted above, the
    application should provide a buffer of at least MAXGETHOSTSTRUCT
    bytes (as defined in winsock.h).

Arguments:

    hWnd - The handle of the window which should receive a message when
       the asynchronous request completes.

    wMsg - The message to be received when the asynchronous request
       completes.

    number - The protocol number to be resolved, in host byte order.

    buf - A pointer to the data area to receive the protoent data.  Note
       that this must be larger than the size of a protoent structure.
       This is because the data area supplied is used by the Windows
       Sockets implementation to contain not only a protoent structure
       but any and all of the data which is referenced by members of the
       protoent structure.  It is recommended that you supply a buffer
       of MAXGETHOSTSTRUCT bytes.

    buflen - The size of data area buf above.

Return Value:

    The return value specifies whether or not the asynchronous operation
    was successfully initiated.  Note that it does not imply success or
    failure of the operation itself.

    If the operation was successfully initiated,
    WSAAsyncGetProtoByNumber() returns a nonzero value of type HANDLE
    which is the asynchronous task handle for the request.  This value
    can be used in two ways.  It can be used to cancel the operation
    using WSACancelAsyncRequest().  It can also be used to match up
    asynchronous operations and completion messages, by examining the
    wParam message argument.

    If the asynchronous operation could not be initiated,
    WSAAsyncGetProtoByNumber() returns a zero value, and a specific
    error number may be retrieved by calling WSAGetLastError().

--*/

{

    INT                    ErrorCode;
    PWINSOCK_CONTEXT_BLOCK contextBlock;
    HANDLE                 taskHandle;

    ErrorCode = TURBO_PROLOG();

    if (ErrorCode!=ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return NULL;
    } //if

    //
    // Initialize the async thread if it hasn't already been started.
    //

    if( !SockCheckAndInitAsyncThread() ) {

        // !!! better error code?
        SetLastError( WSAENOBUFS );
        return NULL;

    }

    //
    // Get an async context block.
    //

    contextBlock = SockAllocateContextBlock( 0 );

    if( contextBlock == NULL ) {

        SetLastError( WSAENOBUFS );
        return NULL;

    }

    //
    // Initialize the context block for this operation.
    //

    contextBlock->OpCode = WS_OPCODE_GET_PROTO_BY_NUMBER;
    contextBlock->Overlay.AsyncGetProto.hWnd = hWnd;
    contextBlock->Overlay.AsyncGetProto.wMsg = wMsg;
    contextBlock->Overlay.AsyncGetProto.Filter = (PCHAR)IntToPtr(Number);
    contextBlock->Overlay.AsyncGetProto.Buffer = Buffer;
    contextBlock->Overlay.AsyncGetProto.BufferLength = BufferLength;

    //
    // Save the task handle so that we can return it to the caller.
    // After we post the context block, we're not allowed to access
    // it in any way.
    //

    taskHandle = contextBlock->TaskHandle;

    //
    // Queue the request to the async thread.
    //

    SockQueueRequestToAsyncThread( contextBlock );

    return taskHandle;

}   // WSAAsyncGetProtoByNumber



int
WSAAPI
WSACancelAsyncRequest (
    HANDLE hAsyncTaskHandle
    )

/*++

Routine Description:

    The WSACancelAsyncRequest() function is used to cancel an
    asynchronous operation which was initiated by one of the
    WSAAsyncGetXByY() functions such as WSAAsyncGetHostByName().  The
    operation to be canceled is identified by the hAsyncTaskHandle
    parameter, which should be set to the asynchronous task handle as
    returned by the initiating function.

Arguments:

    hAsyncTaskHandle - Specifies the asynchronous operation to be
        canceled.

Return Value:

    The value returned by WSACancelAsyncRequest() is 0 if the operation
    was successfully canceled.  Otherwise the value SOCKET_ERROR is
    returned, and a specific error number may be retrieved by calling
    WSAGetLastError().

--*/

{

    INT       ErrorCode;

    ErrorCode = TURBO_PROLOG();

    if (ErrorCode!=ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return SOCKET_ERROR;
    } //if

    //
    // Let the async code do the grunt work.
    //

    ErrorCode = SockCancelAsyncRequest( hAsyncTaskHandle );

    if (ErrorCode == ERROR_SUCCESS) {
        return (ERROR_SUCCESS);
    }
    else {
        SetLastError(ErrorCode);
        return (SOCKET_ERROR);
    }

}   // WSACancelAsyncRequest



//
//  Address to string routines for gethostbyaddr()
//
//  Linking in the dnslib.lib routines causes multiple defintion
//  problems for the linker on every winsock routine it hits
//  in the dnslib.lib modules brought in.
//
//  These simple conversion routines get the job done.
//

PCHAR
Local_Ip6AddressToString_A(
    OUT     PCHAR           pBuffer,
    IN      PIP6_ADDRESS    pIp6Addr
    )
/*++

Routine Description:

    Convert IP6 address to string format.

Arguments:

    pBuffer -- buffer to hold string;  MUST be at least
        IPV6_ADDRESS_STRING_LENGTH+1 in length

    pIp6Addr -- IP6 address to convert to string

Return Value:

    Ptr to next location in buffer (the terminating NULL).

--*/
{
    INT i;

    //
    //  write the address in colon separated words
    //

    for (i = 0; i < 8; i++)
    {
        WORD    thisWord;

        //  write address word
        //
        //  note:  not using ntohs() here so that this function can
        //      be used in winsock code without symbol confusion

        thisWord = inline_ntohs( pIp6Addr->IP6Word[i] );

        pBuffer += sprintf(
                        pBuffer,
                        "%x:",
                        thisWord );
    }

    //  whack off last ":"

    * (--pBuffer) = 0;

    return( pBuffer );
}



PCHAR
Local_Ip4AddressToString_A(
    OUT     PCHAR           pBuffer,
    IN      PIP4_ADDRESS    pIp4Addr
    )
/*++

Routine Description:

    Convert IP4 address to string format.

Arguments:

    pBuffer -- buffer to hold string;  MUST be at least
        IPV6_ADDRESS_STRING_LENGTH+1 in length

    pIp4Addr -- IP4 address to convert to string

Return Value:

    Ptr to next location in buffer (the terminating NULL).

--*/
{
    IP4_ADDRESS ip = *pIp4Addr;

    //
    //  convert IP4 address to string
    //      - address is in net order, lead byte in low memory
    //

    pBuffer += sprintf(
                    pBuffer,
                    "%u.%u.%u.%u",
                    (UCHAR) (ip & 0x000000ff),
                    (UCHAR) ((ip & 0x0000ff00) >> 8),
                    (UCHAR) ((ip & 0x00ff0000) >> 16),
                    (UCHAR) ((ip & 0xff000000) >> 24)
                    );

    return( pBuffer );
}



PCHAR
Local_AddressToString_A(
    OUT     PCHAR           pBuffer,
    IN OUT  PDWORD          pBufferLength,
    IN      PBYTE           pAddr,
    IN      DWORD           AddrLength,
    IN      DWORD           AddrFamily
    )
/*++

Routine Description:

    Convert address to string format.

Arguments:

    pBuffer -- buffer to hold string;  MUST be at least
        IPV6_ADDRESS_STRING_LENGTH+1 in length

    pBufferLength -- string buffer length

    pAddr -- ptr to address

    AddrLength -- address length

    AddrFamily -- address family (AF_INET, AF_INET6)

Return Value:

    Ptr to next location in buffer (the terminating NULL).
    NULL if no conversion.

--*/
{
    DWORD   length = *pBufferLength;

    //  dispatch to conversion routine for this type

    if ( AddrFamily == AF_INET )
    {
        if ( length < IP_ADDRESS_STRING_LENGTH+1 )
        {
            length = IP_ADDRESS_STRING_LENGTH+1;
            goto Failed;
        }
        return  Local_Ip4AddressToString_A(
                    pBuffer,
                    (PIP4_ADDRESS) pAddr );
    }

    if ( AddrFamily == AF_INET6 )
    {
        if ( length < IP6_ADDRESS_STRING_LENGTH+1 )
        {
            length = IP6_ADDRESS_STRING_LENGTH+1;
            goto Failed;
        }
        return  Local_Ip6AddressToString_A(
                    pBuffer,
                    (PIP6_ADDRESS) pAddr );
    }

Failed:

    *pBufferLength = length;

    return  NULL;
}

//
//  End getxbyy.cpp
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\enumprot.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    enumprot.cpp

Abstract:

    This module contains the WSAEnumProtocol entrypoint for the
    winsock API.


Author:

    Dirk Brandewie dirk@mink.intel.com  14-06-1995

[Environment:]

[Notes:]

Revision History:

    22-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Moved includes to precomp.h


--*/

#include "precomp.h"

#define END_PROTOCOL_LIST_MARKER 0

// The  following  structure is passed as a passback value to the provider path
// iterator.   The  user  arguments  are  copied to ProviderId, PathBuffer, and
// PathBufferLength.   If  the  provider  is found then ProviderFound is set to
// TRUE  and  the  actual  number  of bytes needed for the path is written into
// CharsNeeded.   The  path is copied into the buffer if there is enough space,
// otherwise the buffer is not used.
typedef struct
{
    GUID   ProviderId;
    LPWSTR PathBuffer;
    INT    PathBufferLength;
    INT    CharsNeeded;
    BOOL   ProviderFound;
    INT    ErrorCode;
} PATH_ENUMERATION_CONTEXT,  *PPATH_ENUMERATION_CONTEXT;


//
// Stucture to be used as a passback value to the catalog iterator. The user
// arguments to WSAEnumProtocols are copied into "Protocols", "ProtocolBuffer"
// and BufferLength. BytesUsed and ProtocolCount are used for bookkeeping in
// the enumeration procedure ProtocolIterationProc() and the functions it calls
// to do its work.
//
typedef struct
{
    LPINT               Protocols;
    LPWSAPROTOCOL_INFOW ProtocolBuffer;
    DWORD               BufferLength;
    DWORD               BytesUsed;
    DWORD               ProtocolCount;
    INT                 ErrorCode;
} PROTOCOL_ENUMERATION_CONTEXT, *PPROTOCOL_ENUMERATION_CONTEXT;

//Return whether there is enough room in the application buffer to
//hold another WSAPROTOCOL_INFOW struct
#define OK_TO_COPY_PROTOCOL(p_context)\
(((p_context)->BytesUsed + sizeof(WSAPROTOCOL_INFOW)) <=\
((p_context)->BufferLength)?TRUE:FALSE)

#define NEXT_BUFFER_LOCATION(p_context)\
((char*)(p_context)->ProtocolBuffer + (p_context)->BytesUsed)



static
VOID
CopyProtocolInfo(
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    IN PPROTOCOL_ENUMERATION_CONTEXT Context
    )
/*++
Routine Description:

    Copies a protocol info struct onto the end of a user buffer is enough room
    exists in the user buffer.

Arguments:

    ProtocolInfo - A Pointer to a WSAPROTOCOL_INFOW struct to be copied.

    Context - A Pointer to an enumeration context structure. This structure
              contians all the infomation about the user buffer.

Returns:

--*/
{
    if (OK_TO_COPY_PROTOCOL(Context)) {
        CopyMemory(
            NEXT_BUFFER_LOCATION(Context),
            ProtocolInfo,
            sizeof(WSAPROTOCOL_INFOW));

        // So we can tell the user how many WSAPROTOCOL_INFOW struct
        // we copied into their buffer
        Context->ProtocolCount++;
    } //if
}


static
BOOL
IsProtocolInSet(
    IN LPINT Set,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo
    )
/*++
Routine Description:

    This function returns whether the protocol described by ProtocolInfo is a
    member of the set of protocols pointed to by Set.

Arguments:

    Set - Apointer to an array of protocol ID's

    ProtocolInfo - A Pointer to a WSAPROTOCOL_INFOW struct.

Returns:

--*/
{
    BOOL ReturnCode  =FALSE;
    INT   SetIndex   =0;
    INT   ProtocolID =0;

    if (Set) {
        ProtocolID = Set[SetIndex];
        while (ProtocolID != END_PROTOCOL_LIST_MARKER) {
            if ((ProtocolID >= ProtocolInfo->iProtocol) &&
                (ProtocolID <= (ProtocolInfo->iProtocol +
                               ProtocolInfo->iProtocolMaxOffset))
                ) {
                ReturnCode = TRUE;
                break;
            } //if
            SetIndex++;
            ProtocolID = Set[SetIndex];
        } //while
    } //if
    else {
        // If the set pointer is null all protocols are in the set.
        ReturnCode = TRUE;
    } //else
    return(ReturnCode);
}




static
BOOL
ProtocolIterationProcAPI(
    IN OUT PVOID IterationContext,
    IN PPROTO_CATALOG_ITEM  CatalogEntry
    )
/*++
Routine Description:

    This  function  is the enumeration procedure passed to the protocol catalog
    enumeration  function.   It  adds  the  protocol  to  the list if (1) it is
    allowed  by the protocol list restriction set, (2) if it is not hidden, and
    (3) it is not a non-chained layer.  "Adding to the list" only has effect if
    there is room in the buffer.

    The  procedure  updates  the  number  of  bytes "used" for each protocol it
    accepts regardless of whether it actually found room in the buffer or not.

Arguments:

    IterationContext - Passback value from call to
                       DCATALOG::EnumerateCatalogItems();

    CatalofEntry - A pointer to a PROTO_CATALOG_ITEM.

Returns:
    TRUE to continue the enumeration of the protocol catalog

--*/
{
    PPROTOCOL_ENUMERATION_CONTEXT Context;
    LPWSAPROTOCOL_INFOW ProtocolInfo;

    Context = (PPROTOCOL_ENUMERATION_CONTEXT)IterationContext;
    ProtocolInfo = CatalogEntry->GetProtocolInfo();

    __try {
        // If the protocol meets acceptance criteria, then add it
        if (IsProtocolInSet(Context->Protocols, ProtocolInfo)) {
            if (! ((ProtocolInfo->dwProviderFlags) & PFL_HIDDEN)) {
                if (ProtocolInfo->ProtocolChain.ChainLen != LAYERED_PROTOCOL) {
                    CopyProtocolInfo(ProtocolInfo, Context);
                    Context->BytesUsed += sizeof(WSAPROTOCOL_INFOW);
                } // if non-layered
            } //if non-hidden
        } //if is in set
        return(TRUE); //Continue enumeration
    }
    __except (WS2_EXCEPTION_FILTER()) {
        Context->ErrorCode = WSAEFAULT;
        return FALSE;
    }

}




static
BOOL
ProtocolIterationProcSPI(
    IN OUT PVOID IterationContext,
    IN PPROTO_CATALOG_ITEM  CatalogEntry
    )
/*++
Routine Description:

    This  function  is the enumeration procedure passed to the protocol catalog
    enumeration function.  It adds the protocol to the list if it is allowed by
    the protocol list restriction set.  "Adding to the list" only has effect if
    there is room in the buffer.

    The  procedure  updates  the  number  of  bytes "used" for each protocol it
    accepts regardless of whether it actually found room in the buffer or not.

Arguments:

    IterationContext - Passback value from call to
                       DCATALOG::EnumerateCatalogItems();

    CatalofEntry - A pointer to a PROTO_CATALOG_ITEM.

Returns:
    TRUE to continue the enumeration of the protocol catalog

--*/
{
    PPROTOCOL_ENUMERATION_CONTEXT Context;
    LPWSAPROTOCOL_INFOW ProtocolInfo;

    Context = (PPROTOCOL_ENUMERATION_CONTEXT)IterationContext;
    ProtocolInfo = CatalogEntry->GetProtocolInfo();

    __try {
        // If the protocol meets acceptance criteria, then add it.
        if (IsProtocolInSet(Context->Protocols, ProtocolInfo)) {
            CopyProtocolInfo(ProtocolInfo, Context);
            Context->BytesUsed += sizeof(WSAPROTOCOL_INFOW);
        } //if
        return(TRUE); //Continue enumeration
    }
    __except (WS2_EXCEPTION_FILTER()) {
        Context->ErrorCode = WSAEFAULT;
        return FALSE;
    }
}


int WSAAPI
WSAEnumProtocolsW(
    IN LPINT                lpiProtocols,
    OUT LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    IN OUT LPDWORD          lpdwBufferLength
    )
/*++
Routine Description:

    Retrieve information about available transport protocols.

Arguments:

    lpiProtocols     - A NULL-terminated array of protocol ids.  This parameter
                       is optional; if lpiProtocols is NULL, information on all
                       available  protocols  is returned, otherwise information
                       is  retrieved  only  for  those  protocols listed in the
                       array.

    lpProtocolBuffer - A buffer which is filled with WSAPROTOCOL_INFOW
                       structures.  See below for a detailed description of the
                       contents of the WSAPROTOCOL_INFOW structure.

    lpdwBufferLength - On input, the count of bytes in the lpProtocolBuffer
                       buffer passed to WSAEnumProtocols().  On output, the
                       minimum buffer size that can be passed to
                       WSAEnumProtocols() to retrieve all the requested
                       information.  This routine has no ability to enumerate
                       over multiple calls; the passed-in buffer must be large
                       enough to hold all entries in order for the routine to
                       succeed.  This reduces the complexity of the API and
                       should not pose a problem because the number of
                       protocols loaded on a machine is typically small.

Returns:
    The number of protocols to be reported on. Otherwise a value of
    SOCKET_ERROR is returned and a specific  stored with SetLastError().
--*/
{
    INT                          ReturnCode;
    PDPROCESS                    Process;
    PDTHREAD                     Thread;
    INT                          ErrorCode;
    PDCATALOG                    Catalog;
    PROTOCOL_ENUMERATION_CONTEXT EnumerationContext;


    ErrorCode = PROLOG(&Process, &Thread);

    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    } //if

    // Setup the enumeration context structure to hand the the
    // protocol catalog iterator.
    EnumerationContext.Protocols = lpiProtocols;
    EnumerationContext.ProtocolBuffer = lpProtocolBuffer;
    if (lpProtocolBuffer) {
        __try {
            EnumerationContext.BufferLength = *lpdwBufferLength;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            SetLastError (WSAEFAULT);
            return SOCKET_ERROR;
        }
    }
    else {
        EnumerationContext.BufferLength = 0;
    }

    EnumerationContext.BytesUsed = 0;
    EnumerationContext.ProtocolCount= 0;
    EnumerationContext.ErrorCode = ERROR_SUCCESS;

    Catalog = Process->GetProtocolCatalog();
    assert(Catalog);

    // Start the iteration through the catalog. All the real work is
    // done in ProtocolIterationProc
    Catalog->EnumerateCatalogItems(ProtocolIterationProcAPI,
                                   &EnumerationContext);
    if (EnumerationContext.ErrorCode==ERROR_SUCCESS) {
        ReturnCode = EnumerationContext.ProtocolCount;

        __try {
            if ( EnumerationContext.BufferLength < EnumerationContext.BytesUsed) {
                *lpdwBufferLength = EnumerationContext.BytesUsed;
                SetLastError(WSAENOBUFS);
                ReturnCode = SOCKET_ERROR;
            } //if
        }
        __except (WS2_EXCEPTION_FILTER()) {
            SetLastError (WSAEFAULT);
            ReturnCode = SOCKET_ERROR;
        }
    }
    else {
        SetLastError (EnumerationContext.ErrorCode);
        ReturnCode = SOCKET_ERROR;
    }

    return(ReturnCode);
}



PDCATALOG
OpenInitializedCatalog()
{
    INT ReturnCode;
    PDCATALOG protocol_catalog;
    HKEY RegistryKey = 0;

    //
    // Build the protocol catalog
    //
    protocol_catalog = new(DCATALOG);
    if (protocol_catalog) {
        TRY_START(mem_guard){
            RegistryKey = OpenWinSockRegistryRoot();
            if (!RegistryKey) {
                DEBUGF(
                    DBG_ERR,
                    ("OpenWinSockRegistryRoot Failed \n"));
                TRY_THROW(mem_guard);
            } //if

            ReturnCode = protocol_catalog->InitializeFromRegistry(
                                RegistryKey,        // ParentKey
                                NULL                // ChangeEvent
                                );
            if (ERROR_SUCCESS != ReturnCode) {
                DEBUGF(
                    DBG_ERR,
                    ("Initializing from registry\n"));
                TRY_THROW(mem_guard);
            } //if

        }TRY_CATCH(mem_guard) {

            delete(protocol_catalog);
            protocol_catalog = NULL;
        }TRY_END(mem_guard);

        if (RegistryKey) {
            LONG close_result;
            close_result = RegCloseKey(
                RegistryKey);  // hkey
            assert(close_result == ERROR_SUCCESS);
        } // if
    }
    else {
        DEBUGF(
            DBG_ERR,
            ("Allocating dcatalog object\n"));
    } //if

    return(protocol_catalog);
}



int WSPAPI
WSCEnumProtocols(
    IN LPINT                lpiProtocols,
    OUT LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    IN OUT LPDWORD          lpdwBufferLength,
    LPINT lpErrno
    )
/*++
Routine Description:

    Retrieve information about available transport protocols.

Arguments:

    lpiProtocols     - A NULL-terminated array of protocol ids.  This parameter
                       is optional; if lpiProtocols is NULL, information on all
                       available  protocols  is returned, otherwise information
                       is  retrieved  only  for  those  protocols listed in the
                       array.

    lpProtocolBuffer - A buffer which is filled with WSAPROTOCOL_INFOW
                       structures.  See below for a detailed description of the
                       contents of the WSAPROTOCOL_INFOW structure.

    lpdwBufferLength - On input, the count of bytes in the lpProtocolBuffer
                       buffer passed to WSAEnumProtocols().  On output, the
                       minimum buffer size that can be passed to
                       WSAEnumProtocols() to retrieve all the requested
                       information.  This routine has no ability to enumerate
                       over multiple calls; the passed-in buffer must be large
                       enough to hold all entries in order for the routine to
                       succeed.  This reduces the complexity of the API and
                       should not pose a problem because the number of
                       protocols loaded on a machine is typically small.

Returns:
    The number of protocols to be reported on. Otherwise a value of
    SOCKET_ERROR is returned and a specific error code is returned in lpErrno
--*/
{
    BOOL                         delete_catalog=FALSE;
    PDPROCESS                    Process;
    PDTHREAD                     Thread;
    INT                          ErrorCode;
    PDCATALOG                    Catalog;
    PROTOCOL_ENUMERATION_CONTEXT EnumerationContext;

    ErrorCode = PROLOG(&Process,&Thread);

    if (ErrorCode == ERROR_SUCCESS) {

        Catalog = Process->GetProtocolCatalog();
        assert(Catalog);
    }
    else if (ErrorCode == WSANOTINITIALISED) {

        // Take care of case when called with a prior WSAStartup()
        // as when called from WSCGetProviderPath

        Catalog = OpenInitializedCatalog();
        if (Catalog==NULL) {
            ErrorCode = WSA_NOT_ENOUGH_MEMORY;
            goto Exit;
        }
        delete_catalog = TRUE;
        ErrorCode = ERROR_SUCCESS;
    }
    else {
        goto Exit;
    }

    // Setup the enumeration context structure to hand the the
    // protocol catalog iterator.
    EnumerationContext.Protocols = lpiProtocols;
    EnumerationContext.ProtocolBuffer = lpProtocolBuffer;
    if (lpProtocolBuffer) {
        __try {
            EnumerationContext.BufferLength = *lpdwBufferLength;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            ErrorCode = WSAEFAULT;
            goto Exit;
        }
    }
    else {
        EnumerationContext.BufferLength = 0;
    }
    EnumerationContext.BytesUsed = 0;
    EnumerationContext.ProtocolCount= 0;
    EnumerationContext.ErrorCode = ERROR_SUCCESS;

    Catalog->EnumerateCatalogItems(ProtocolIterationProcSPI,
                                   &EnumerationContext);
    if (EnumerationContext.ErrorCode==ERROR_SUCCESS) {
        if ( EnumerationContext.BufferLength >= EnumerationContext.BytesUsed) {
            assert (ErrorCode == ERROR_SUCCESS);
        }
        else {
            __try {
                *lpdwBufferLength = EnumerationContext.BytesUsed;
                ErrorCode = WSAENOBUFS;
            }
            __except (WS2_EXCEPTION_FILTER()) {
                ErrorCode = WSAEFAULT;
            }
        } //if
    }
    else {
        ErrorCode = EnumerationContext.ErrorCode;
    }

Exit:
    if (delete_catalog) {

        delete Catalog;
    }

    if (ErrorCode==ERROR_SUCCESS) {
        return EnumerationContext.ProtocolCount;
    }
    else {
        __try {
            *lpErrno = ErrorCode;
        }
        __except (WS2_EXCEPTION_FILTER ()) {
            ;
        }
        return SOCKET_ERROR;
    }
}


#ifdef _WIN64
int WSPAPI
WSCEnumProtocols32(
    IN LPINT                lpiProtocols,
    OUT LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    IN OUT LPDWORD          lpdwBufferLength,
    LPINT                   lpErrno
    )
/*++
Routine Description:

    Retrieve information about available transport protocols.

Arguments:

    lpiProtocols     - A NULL-terminated array of protocol ids.  This parameter
                       is optional; if lpiProtocols is NULL, information on all
                       available  protocols  is returned, otherwise information
                       is  retrieved  only  for  those  protocols listed in the
                       array.

    lpProtocolBuffer - A buffer which is filled with WSAPROTOCOL_INFOW
                       structures.  See below for a detailed description of the
                       contents of the WSAPROTOCOL_INFOW structure.

    lpdwBufferLength - On input, the count of bytes in the lpProtocolBuffer
                       buffer passed to WSAEnumProtocols().  On output, the
                       minimum buffer size that can be passed to
                       WSAEnumProtocols() to retrieve all the requested
                       information.  This routine has no ability to enumerate
                       over multiple calls; the passed-in buffer must be large
                       enough to hold all entries in order for the routine to
                       succeed.  This reduces the complexity of the API and
                       should not pose a problem because the number of
                       protocols loaded on a machine is typically small.

Returns:
    The number of protocols to be reported on. Otherwise a value of
    SOCKET_ERROR is returned and a specific error code is returned in lpErrno
--*/
{
    INT                          ErrorCode;
    PDCATALOG                    Catalog = NULL;
    PROTOCOL_ENUMERATION_CONTEXT EnumerationContext;
    HKEY registry_root;

    registry_root = OpenWinSockRegistryRoot();
    if (registry_root == NULL) {
        DEBUGF(
            DBG_ERR,
            ("Opening registry root\n"));
        ErrorCode = WSANO_RECOVERY;
        goto Exit;
    }

    //
    // Build the protocol catalog
    //
    Catalog = new(DCATALOG);

    if (Catalog!=NULL) {
        
        ErrorCode = Catalog->InitializeFromRegistry32(
                            registry_root
                            );
    }
    else {
        ErrorCode = WSA_NOT_ENOUGH_MEMORY;
        DEBUGF(
            DBG_ERR,
            ("Allocating dcatalog object\n"));
    }


    {
        LONG close_result;
        close_result = RegCloseKey(
            registry_root);  // hkey
        assert(close_result == ERROR_SUCCESS);
    }


    if (ErrorCode!=ERROR_SUCCESS) {
        goto Exit;
    }

    assert (Catalog!=NULL);

    // Setup the enumeration context structure to hand the the
    // protocol catalog iterator.
    EnumerationContext.Protocols = lpiProtocols;
    EnumerationContext.ProtocolBuffer = lpProtocolBuffer;
    if (lpProtocolBuffer) {
        __try {
            EnumerationContext.BufferLength = *lpdwBufferLength;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            ErrorCode = WSAEFAULT;
            goto Exit;
        }
    }
    else {
        EnumerationContext.BufferLength = 0;
    }
    EnumerationContext.BytesUsed = 0;
    EnumerationContext.ProtocolCount= 0;
    EnumerationContext.ErrorCode = ERROR_SUCCESS;

    Catalog->EnumerateCatalogItems(ProtocolIterationProcSPI,
                                   &EnumerationContext);
    if (EnumerationContext.ErrorCode==ERROR_SUCCESS) {
        if ( EnumerationContext.BufferLength >= EnumerationContext.BytesUsed) {
            assert (ErrorCode == ERROR_SUCCESS);
        }
        else {
            __try {
                *lpdwBufferLength = EnumerationContext.BytesUsed;
                ErrorCode = WSAENOBUFS;
            }
            __except (WS2_EXCEPTION_FILTER()) {
                ErrorCode = WSAEFAULT;
            }
        } //if
    }
    else {
        ErrorCode = EnumerationContext.ErrorCode;
    }

Exit:
    if (Catalog!=NULL) {

        delete Catalog;
    }

    if (ErrorCode==ERROR_SUCCESS) {
        return EnumerationContext.ProtocolCount;
    }
    else {
        __try {
            *lpErrno = ErrorCode;
        }
        __except (WS2_EXCEPTION_FILTER ()) {
            ;
        }
        return SOCKET_ERROR;
    }
}
#endif


static
BOOL
PathIterationProc(
    IN OUT PVOID IterationContext,
    IN PPROTO_CATALOG_ITEM  CatalogEntry
    )
/*++
Routine Description:

    This function is the enumeration procedure passed to the protocol catalog
    enumeration function.

Arguments:

    IterationContext - Passback value from call to
                       DCATALOG::EnumerateCatalogItems();

    CatalofEntry - A pointer to a PROTO_CATALOG_ITEM.

Returns:
    TRUE to continue the enumeration of the protocol catalog

--*/
{
    PPATH_ENUMERATION_CONTEXT Context;
    LPWSAPROTOCOL_INFOW ProtocolInfo;
    INT result;

    Context = (PPATH_ENUMERATION_CONTEXT)IterationContext;
    ProtocolInfo = CatalogEntry->GetProtocolInfo();

    // If  the  entry  is  the  correct  one,  update  the context and stop the
    // enumeration.
    if( ProtocolInfo->ProviderId == Context->ProviderId ) {
        PCHAR Path;
        INT   PathLen;

        Path =  CatalogEntry->GetLibraryPath();
        PathLen = lstrlen(Path) + 1;
        Context->CharsNeeded = PathLen;
        Context->ProviderFound = TRUE;
        if (PathLen <= Context->PathBufferLength)
        {
            __try {
                result = MultiByteToWideChar(
                             CP_ACP,
                             0,
                             Path,
                             -1,
                             Context->PathBuffer,
                             Context->PathBufferLength
                             );
            }
            __except (WS2_EXCEPTION_FILTER()) {
                Context->ErrorCode = WSAEFAULT;
            }
        } //if
        return(FALSE); //Discontinue enumeration
    } //if
    return(TRUE); //Continue enumeration
}

int WSPAPI WPUGetProviderPath(
    IN LPGUID lpProviderId,
    OUT WCHAR FAR * lpszProviderDllPath,
    IN OUT LPINT ProviderDLLPathLen,
    OUT LPINT lpErrno )
/*++
Routine Description:

    Returns the path to the provider DLL associated with a specific providerId

Arguments:

    lpProviderId - The ID of the provider to look up.

    lpszProviderDllPath - A pointer to a buffer to hold the path to the
                          provider DLL

    ProviderDLLPathLen - On input the size of lpszProviderDllPath, on output
                         the number of bytes used.

    lpErrno - A pointer to the error value of the function.

Returns:
    WSCGetProviderPath() returns 0. Otherwise, it returns SOCKET_ERROR, and a
    specific error code is available in lpErrno.
--*/
{
    BOOL                      delete_catalog=FALSE;
    PDPROCESS                 Process;
    PDTHREAD                  Thread;
    INT                       ErrorCode;
    PDCATALOG                 Catalog;
    PATH_ENUMERATION_CONTEXT  EnumerationContext;

    ErrorCode = PROLOG(&Process,&Thread);


    if (ErrorCode == ERROR_SUCCESS) {

        Catalog = Process->GetProtocolCatalog();
        assert(Catalog);
    }
    else if (ErrorCode == WSANOTINITIALISED) {

        // Take care of case when called with a prior WSAStartup()
        // as when called from WSCGetProviderPath

        Catalog = OpenInitializedCatalog();
        if (Catalog==NULL) {
            ErrorCode = WSAENOBUFS;
            goto Exit;
        }
        delete_catalog = TRUE;
    }
    else {
        goto Exit;
    }

    __try {
        // Setup the enumeration context structure to hand to the
        // protocol catalog iterator.
        EnumerationContext.ProviderId       = *lpProviderId;
        EnumerationContext.PathBuffer       = lpszProviderDllPath;
        EnumerationContext.PathBufferLength = *ProviderDLLPathLen;
        EnumerationContext.CharsNeeded      = 0;
        EnumerationContext.ProviderFound    = FALSE;
        EnumerationContext.ErrorCode        = ERROR_SUCCESS;
    }
    __except (WS2_EXCEPTION_FILTER()) {
        ErrorCode = WSAEFAULT;
        goto Exit;
    }


    // Start the iteration through the catalog. All the real work is
    // done in ProtocolIterationProc
    Catalog->EnumerateCatalogItems(PathIterationProc,
                                   &EnumerationContext);

    if (EnumerationContext.ErrorCode==ERROR_SUCCESS) {
        __try {
            if (EnumerationContext.ProviderFound) {
                if (EnumerationContext.CharsNeeded > * ProviderDLLPathLen) {
                    ErrorCode = WSAEFAULT;
                    *ProviderDLLPathLen = EnumerationContext.CharsNeeded;
                } //if
            } // if found
            else {
                ErrorCode = WSAEINVAL;
            }
        }
        __except (WS2_EXCEPTION_FILTER()) {
            ErrorCode = WSAEFAULT;
        }
    }
    else {
        ErrorCode = EnumerationContext.ErrorCode;
    }

Exit:
    if (delete_catalog) {

        delete Catalog;
    }

    if (ErrorCode==ERROR_SUCCESS)
        return ERROR_SUCCESS;
    else {
        __try {
            *lpErrno = ErrorCode;
        }
        __except (WS2_EXCEPTION_FILTER ()) {
            ;
        }
        return SOCKET_ERROR;
    }
}


int
WSPAPI
WSCGetProviderPath(
    IN LPGUID lpProviderId,
    OUT WCHAR FAR * lpszProviderDllPath,
    IN OUT LPINT ProviderDLLPathLen,
    OUT LPINT lpErrno )
{
    return WPUGetProviderPath(
               lpProviderId,
               lpszProviderDllPath,
               ProviderDLLPathLen,
               lpErrno
               );
}


#ifdef _WIN64
int
WSPAPI
WSCGetProviderPath32 (
    IN LPGUID lpProviderId,
    OUT WCHAR FAR * lpszProviderDllPath,
    IN OUT LPINT ProviderDLLPathLen,
    OUT LPINT lpErrno )
{
    INT                          ErrorCode;
    PDCATALOG                    Catalog = NULL;
    PATH_ENUMERATION_CONTEXT  EnumerationContext;
    HKEY registry_root;

    registry_root = OpenWinSockRegistryRoot();
    if (registry_root == NULL) {
        DEBUGF(
            DBG_ERR,
            ("Opening registry root\n"));
        ErrorCode = WSANO_RECOVERY;
        goto Exit;
    }

    //
    // Build the protocol catalog
    //
    Catalog = new(DCATALOG);

    if (Catalog!=NULL) {
        
        ErrorCode = Catalog->InitializeFromRegistry32(
                            registry_root
                            );
    }
    else {
        ErrorCode = WSA_NOT_ENOUGH_MEMORY;
        DEBUGF(
            DBG_ERR,
            ("Allocating dcatalog object\n"));
    }


    {
        LONG close_result;
        close_result = RegCloseKey(
            registry_root);  // hkey
        assert(close_result == ERROR_SUCCESS);
    }


    if (ErrorCode!=ERROR_SUCCESS) {
        goto Exit;
    }

    assert (Catalog!=NULL);

    __try {
        // Setup the enumeration context structure to hand to the
        // protocol catalog iterator.
        EnumerationContext.ProviderId       = *lpProviderId;
        EnumerationContext.PathBuffer       = lpszProviderDllPath;
        EnumerationContext.PathBufferLength = *ProviderDLLPathLen;
        EnumerationContext.CharsNeeded      = 0;
        EnumerationContext.ProviderFound    = FALSE;
        EnumerationContext.ErrorCode        = ERROR_SUCCESS;
    }
    __except (WS2_EXCEPTION_FILTER()) {
        ErrorCode = WSAEFAULT;
        goto Exit;
    }


    // Start the iteration through the catalog. All the real work is
    // done in ProtocolIterationProc
    Catalog->EnumerateCatalogItems(PathIterationProc,
                                   &EnumerationContext);

    if (EnumerationContext.ErrorCode==ERROR_SUCCESS) {
        __try {
            if (EnumerationContext.ProviderFound) {
                if (EnumerationContext.CharsNeeded > * ProviderDLLPathLen) {
                    ErrorCode = WSAEFAULT;
                    *ProviderDLLPathLen = EnumerationContext.CharsNeeded;
                } //if
            } // if found
            else {
                ErrorCode = WSAEINVAL;
            }
        }
        __except (WS2_EXCEPTION_FILTER()) {
            ErrorCode = WSAEFAULT;
        }
    }
    else {
        ErrorCode = EnumerationContext.ErrorCode;
    }

Exit:
    if (Catalog!=NULL) {

        delete Catalog;
    }

    if (ErrorCode==ERROR_SUCCESS)
        return ERROR_SUCCESS;
    else {
        __try {
            *lpErrno = ErrorCode;
        }
        __except (WS2_EXCEPTION_FILTER ()) {
            ;
        }
        return SOCKET_ERROR;
    }
}
#endif


int WSAAPI
WSAEnumProtocolsA(
    IN LPINT                lpiProtocols,
    OUT LPWSAPROTOCOL_INFOA lpProtocolBuffer,
    IN OUT LPDWORD          lpdwBufferLength
    )
/*++
Routine Description:

    ANSI thunk to WSAEnumProtocolsW.

Arguments:

    lpiProtocols     - A NULL-terminated array of protocol ids.  This parameter
                       is optional; if lpiProtocols is NULL, information on all
                       available  protocols  is returned, otherwise information
                       is  retrieved  only  for  those  protocols listed in the
                       array.

    lpProtocolBuffer - A buffer which is filled with WSAPROTOCOL_INFOA
                       structures.  See below for a detailed description of the
                       contents of the WSAPROTOCOL_INFOA structure.

    lpdwBufferLength - On input, the count of bytes in the lpProtocolBuffer
                       buffer passed to WSAEnumProtocols().  On output, the
                       minimum buffer size that can be passed to
                       WSAEnumProtocols() to retrieve all the requested
                       information.  This routine has no ability to enumerate
                       over multiple calls; the passed-in buffer must be large
                       enough to hold all entries in order for the routine to
                       succeed.  This reduces the complexity of the API and
                       should not pose a problem because the number of
                       protocols loaded on a machine is typically small.

Returns:
    The number of protocols to be reported on. Otherwise a value of
    SOCKET_ERROR is returned and a specific  stored with SetLastError().
--*/
{

    LPWSAPROTOCOL_INFOW ProtocolInfoW;
    DWORD NumProtocolEntries;
    DWORD ProtocolInfoWLength;
    INT result;
    INT error;
    INT i;

    __try {
        if( *lpdwBufferLength > 0 && lpProtocolBuffer!=NULL) {

            //
            // Since all of the structures are of fixed size (no embedded
            // pointers to variable-sized data) we can calculate the required
            // size of the UNICODE buffer by dividing the buffer size by the size
            // of the ANSI structure, then multiplying by the size of the
            // UNICODE structure.
            //

            NumProtocolEntries  = *lpdwBufferLength / sizeof(WSAPROTOCOL_INFOA);
            ProtocolInfoWLength = NumProtocolEntries * sizeof(WSAPROTOCOL_INFOW);

            //
            // Try to allocate the UNICODE buffer.
            //

            ProtocolInfoW = new WSAPROTOCOL_INFOW[NumProtocolEntries];

            if( ProtocolInfoW == NULL ) {

                SetLastError( WSA_NOT_ENOUGH_MEMORY );
                return SOCKET_ERROR;

            }

        } else {

            ProtocolInfoW = NULL;
            ProtocolInfoWLength = 0;

        }

        //
        // Call through to the UNICODE version.
        //

        result = WSAEnumProtocolsW(
                     lpiProtocols,
                     ProtocolInfoW,
                     &ProtocolInfoWLength
                     );

        //
        // Map the size back to ANSI.
        //

        *lpdwBufferLength = ( ProtocolInfoWLength / sizeof(WSAPROTOCOL_INFOW) ) *
            sizeof(WSAPROTOCOL_INFOA);

    }
    __except (WS2_EXCEPTION_FILTER()) {
        result = SOCKET_ERROR;
        SetLastError (WSAEFAULT);
    }

    if( result == SOCKET_ERROR ) {

        //
        // Could not store the data, probably because the supplied buffer
        // was too small.
        //

        delete ProtocolInfoW;
        return result;

    }

    //
    // OK, we've got the UNICODE data now, and we know the user's buffer
    // is sufficient to hold the ANSI structures. Map them in.
    //

    for( i = 0 ; i < result ; i++ ) {

        error = MapUnicodeProtocolInfoToAnsi(
                    ProtocolInfoW + i,
                    lpProtocolBuffer + i
                    );

        if( error != ERROR_SUCCESS ) {

            delete ProtocolInfoW;
            SetLastError( error );
            return SOCKET_ERROR;

        }

    }

    //
    // Success!
    //

    delete ProtocolInfoW;
    return result;

}   // WSAEnumProtocolsA



BOOL
CompareMemory(
    LPBYTE  p1,
    LPBYTE  p2,
    DWORD   dwSize
    )
/*++

Routine Description:

    Does a binary compare of memory at specified address.  Returns TRUE
    if memory blocks are equal, FALSE otherwise.

Arguments:

    p1     - Pointer to first memory block to compare

    p2     - Pointer to second memory block to compare

    dwSize - Size of memory blocks

--*/
{
    DWORD i;

    for (i = 0; (i < dwSize) && (*p1 == *p2); i++, p1++, p2++);

    return (i == dwSize);
}


int WSAAPI
WSAProviderConfigChange(
    IN OUT LPHANDLE lpNotificationHandle,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
/*++
Routine Description:



Arguments:

    lpNotificationHandle -

    lpOverlapped         -

    lpCompletionRoutine  -

Returns:

--*/
{
    INT                          ErrorCode;
    PDPROCESS                    Process;
    PDTHREAD                     Thread;
    HANDLE                       HelperHandle = NULL;

    if (IsBadReadPtr (lpNotificationHandle, sizeof(HANDLE)))
    {
        SetLastError (WSAEFAULT);
        return SOCKET_ERROR;
    }

    ErrorCode = PROLOG(&Process,&Thread);

    if (ErrorCode==ERROR_SUCCESS) {
        ErrorCode = Process->GetNotificationHelperDeviceID(&HelperHandle);
        if (ErrorCode==ERROR_SUCCESS) {
            __try {
                if (*lpNotificationHandle == NULL)
                {
                    ErrorCode = WahCreateNotificationHandle(
                        HelperHandle,
                        lpNotificationHandle
                        );
                }
                else
                {
                    ErrorCode = WahWaitForNotification(
                        HelperHandle,
                        *lpNotificationHandle,
                        lpOverlapped,
                        lpCompletionRoutine
                        );
                }
            }
            __except (WS2_EXCEPTION_FILTER()) {
                ErrorCode = WSAEFAULT;
            }
        }
    }


    if (ErrorCode == ERROR_SUCCESS) {
        return (ERROR_SUCCESS);
    }
    else {
        SetLastError(ErrorCode);
        return (SOCKET_ERROR);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\getproto.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    getproto.cpp

Abstract:

    This module handles the getprotobyX() functions.

    The following functions are exported by this module:

    getprotobyname()
    getprotobynumber()

Author:

    Keith Moore (keithmo)        18-Jun-1996

Revision History:

--*/


#include "precomp.h"
//#pragma hdrstop
//#include <stdio.h> Now in precomp.h


//
// Private contants.
//

#define DATABASE_PATH_REGISTRY_KEY \
            "System\\CurrentControlSet\\Services\\Tcpip\\Parameters"

#define DATABASE_PATH_REGISTRY_VALUE "DataBasePath"

#define PROTOCOL_DATABASE_FILENAME "protocol"


//
// Private prototypes.
//

FILE *
GetProtoOpenNetworkDatabase(
    CHAR * Name
    );

CHAR *
GetProtoPatternMatch(
    CHAR * Scan,
    CHAR * Match
    );

PPROTOENT
GetProtoGetNextEnt(
    FILE * DbFile,
    PGETPROTO_INFO ProtoInfo
    );


//
// Public functions.
//


struct protoent FAR *
WSAAPI
getprotobynumber(
    IN int number
    )
/*++
Routine Description:

    Get protocol information corresponding to a protocol number.

Arguments:

    number - Supplies a protocol number, in host byte order

Returns:

    If  no  error  occurs, getprotobynumber() returns a pointer to the protoent
    structure  described  above.   Otherwise  it  returns  a NULL pointer and a
    specific error r code is stored with SetErrorCode().
--*/
{

    PDTHREAD Thread;
    INT ErrorCode;
    PGETPROTO_INFO protoInfo;
    PPROTOENT pent;
    FILE * dbFile;

    ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if(ErrorCode != ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return(NULL);
    }

    //
    // Get the per-thread buffer.
    //

    protoInfo = Thread->GetProtoInfo();

    if( protoInfo == NULL ) {

        SetLastError( WSANO_DATA );
        return NULL;

    }

    //
    // Open the database file.
    //

    dbFile = GetProtoOpenNetworkDatabase( "protocol" );

    if( dbFile == NULL ) {

        SetLastError( WSANO_DATA );
        return NULL;

    }

    //
    // Scan it.
    //

    while( TRUE ) {

        pent = GetProtoGetNextEnt(
                   dbFile,
                   protoInfo
                   );

        if( pent == NULL ) {

            break;

        }

        if( (int)pent->p_proto == number ) {

            break;

        }

    }

    //
    // Close the database.
    //

    fclose( dbFile );

    if( pent == NULL ) {

        SetLastError( WSANO_DATA );

    }

    return pent;

}  // getprotobynumber


struct protoent FAR *
WSAAPI
getprotobyname(
    IN const char FAR * name
    )
/*++
Routine Description:

    Get protocol information corresponding to a protocol name.

Arguments:

    name - A pointer to a null terminated protocol name.

Returns:

    If  no  error  occurs,  getprotobyname()  returns a pointer to the protoent
    structure  described  above.   Otherwise  it  returns  a NULL pointer and a
    specific error code is stored with SetErrorCode().
--*/
{

    PDTHREAD Thread;
    INT ErrorCode;
    PGETPROTO_INFO protoInfo;
    PPROTOENT pent;
    FILE * dbFile;

    ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if(ErrorCode != ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return(NULL);
    }

    if ( !name ) // Bug fix for #112420
    {
        SetLastError(WSAEINVAL);
        return(NULL);
    }

    //
    // Get the per-thread buffer.
    //

    protoInfo = Thread->GetProtoInfo();

    if( protoInfo == NULL ) {

        SetLastError( WSANO_DATA );
        return NULL;

    }

    //
    // Open the database file.
    //

    dbFile = GetProtoOpenNetworkDatabase( "protocol" );

    if( dbFile == NULL ) {

        SetLastError( WSANO_DATA );
        return NULL;

    }

    //
    // Scan it.
    //

    while( TRUE ) {

        pent = GetProtoGetNextEnt(
                   dbFile,
                   protoInfo
                   );

        if( pent == NULL ) {

            break;

        }

        __try {
            if( _stricmp( pent->p_name, name ) == 0 ) {

                break;

            }

        }
        __except (WS2_EXCEPTION_FILTER()) {
            fclose (dbFile);
            SetLastError (WSAEFAULT);
            return NULL;
        }
    }

    //
    // Close the database.
    //

    fclose( dbFile );

    if( pent == NULL ) {

        SetLastError( WSANO_DATA );

    }

    return pent;

}  // getprotobyname


//
// Private functions.
//


FILE *
GetProtoOpenNetworkDatabase(
    CHAR * Name
    )

/*++

Routine Description:

    Opens a stream to the specified network database file.

Arguments:

    Name - The name of the database to open (i.e. "services" or
        "protocol").

Return Value:

    FILE * - Pointer to the open stream if successful, NULL if not.

--*/

{

    CHAR path[MAX_PATH];
    CHAR unexpanded[MAX_PATH];
    CHAR * suffix;
    OSVERSIONINFO version;
    LONG err;
    HKEY key;
    DWORD type;
    DWORD length;

    //
    // Determine the directory for the database file.
    //
    // Under Win95, the database files live under the Windows directory
    // (i.e. C:\WINDOWS).
    //
    // Under WinNT, the path to the database files is configurable in
    // the registry, but the default is in the Drivers\Etc directory
    // (i.e. C:\WINDOWS\SYSTEM32\DRIVERS\ETC).
    //

    version.dwOSVersionInfoSize = sizeof(version);

    if( !GetVersionEx( &version ) ) {

        return NULL;

    }

    suffix = "";

    if( version.dwPlatformId == VER_PLATFORM_WIN32_NT ) {

        //
        // We're running under NT, so try to get the path from the
        // registry.
        //

        err = RegOpenKeyEx(
                  HKEY_LOCAL_MACHINE,
                  DATABASE_PATH_REGISTRY_KEY,
                  0,
                  KEY_READ,
                  &key
                  );

        if( err == NO_ERROR ) {

            length = sizeof(unexpanded);

            err = RegQueryValueEx(
                      key,
                      DATABASE_PATH_REGISTRY_VALUE,
                      NULL,
                      &type,
                      (LPBYTE)unexpanded,
                      &length
                      );

            RegCloseKey( key );

        }

        if( err == NO_ERROR ) {

            if( ExpandEnvironmentStrings(
                    unexpanded,
                    path,
                    sizeof(path)
                    ) == 0 ) {

                err = WSASYSCALLFAILURE;

            }

        }

        if( err != NO_ERROR ) {

            //
            // Couldn't get it from the registry, just use the default.
            //

            if( GetSystemDirectory(
                    path,
                    sizeof(path)
                    ) == 0 ) {

                return NULL;

            }

            suffix = "DRIVERS\\ETC\\";

        }

    } else {

        //
        // We're running under Win95, so just get the Windows directory.
        //

        if( GetWindowsDirectory(
                path,
                sizeof(path)
                ) == 0 ) {

            return NULL;

        }

    }

    //
    // Ensure the path has a trailing backslash, then tack on any suffix
    // needed, then tack on the filename.
    //

    if( path[strlen( path ) - 1] != '\\' ) {

        strcat( path, "\\" );

    }

    strcat( path, suffix );
    strcat( path, Name );

    //
    // Open the file, return the result.
    //

    return fopen( path, "rt" );

}   // GetProtoOpenNetworkDatabase


CHAR *
GetProtoPatternMatch(
    CHAR * Scan,
    CHAR * Match
    )

/*++

Routine Description:

    Finds the first character in Scan that matches any character in Match.

Arguments:

    Scan - The string to scan.

    Match - The list of characters to match against.

Return Value:

    CHAR * - Pointer to the first occurrance in Scan if successful,
        NULL if not.

--*/

{

    CHAR ch;

    while( ( ch = *Scan ) != '\0' ) {

        if( strchr( Match, ch ) != NULL ) {

            return Scan;

        }

        Scan++;

    }

    return NULL;

}   // GetProtoPatternMatch



PPROTOENT
GetProtoGetNextEnt(
    FILE * DbFile,
    PGETPROTO_INFO ProtoInfo
    )
{
    CHAR * ptr;
    CHAR * token;
    CHAR ** aliases;
    PPROTOENT result = NULL;

    while( TRUE ) {

        //
        // Get the next line, bail if EOF.
        //

        ptr = fgets(
                  ProtoInfo->TextLine,
                  MAX_PROTO_TEXT_LINE,
                  DbFile
                  );

        if( ptr == NULL ) {

            break;

        }

        //
        // Skip comments.
        //

        if( *ptr == '#' ) {

            continue;

        }

        token = GetProtoPatternMatch ( ptr, "#\n" );

        if( token == NULL ) {

            continue;

        }

        *token = '\0';

        //
        // Start building the entry.
        //

        ProtoInfo->Proto.p_name = ptr;

        token = GetProtoPatternMatch( ptr, " \t" );

        if( token == NULL ) {

            continue;

        }

        *token++ = '\0';

        while( *token == ' ' || *token == '\t' ) {

            token++;

        }

        ptr = GetProtoPatternMatch( token, " \t" );

        if( ptr != NULL ) {

            *ptr++ = '\0';

        }

        ProtoInfo->Proto.p_proto = (short)atoi( token );

        //
        // Build the alias list.
        //

        ProtoInfo->Proto.p_aliases = ProtoInfo->Aliases;
        aliases = ProtoInfo->Proto.p_aliases;

        if( ptr != NULL ) {

            token = ptr;

            while( token && *token ) {

                if( *token == ' ' || *token == '\t' ) {

                    token++;
                    continue;

                }

                if( aliases < &ProtoInfo->Proto.p_aliases[MAX_PROTO_ALIASES - 1] ) {

                    *aliases++ = token;

                }

                token = GetProtoPatternMatch( token, " \t" );

                if( token != NULL ) {

                    *token++ = '\0';

                }

            }

        }

        *aliases = NULL;
        result = &ProtoInfo->Proto;
        break;

    }

    return result;

}   // GetProtoGetNextEnt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\ipconst.c ===
// Copyright (c) 2000 Microsoft Corporation
//
// Abstract:
//
//    Exported const structures declared in ws2tcpip.h.

// Force constants to use dllexport linkage so we can use the safe DATA
// keyword in the .def file, rather than the unsafe CONSTANT.
#define WINSOCK_API_LINKAGE __declspec(dllexport)

#include <winsock2.h>
#include <ws2tcpip.h>

const struct in6_addr in6addr_any = IN6ADDR_ANY_INIT;
const struct in6_addr in6addr_loopback = IN6ADDR_LOOPBACK_INIT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\nspins64.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    64_32.cpp

Abstract:


Author:

Revision History:

--*/

#include "precomp.h"
#ifdef _WIN64
#define _WIN64_32
#include "nspinstl.cpp"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\ioctl.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    ioctl.c

Abstract:

    This module contains the socket I/O control calls of the winsock
    API.  The following functions are contained in ths module.

    ioctlsocket()
    WSAIoctl()

Author:

    Dirk Brandewie dirk@mink.intel.com  14-06-1995

Revision History:

    22-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Moved includes to precomp.h

--*/

#include "precomp.h"



int WSAAPI
ioctlsocket (
    IN SOCKET s,
    IN long cmd,
    IN OUT u_long FAR *argp
    )
/*++
Routine Description:

    Control the mode of a socket.

Arguments:

    s - A descriptor identifying a socket.

    cmd - The command to perform on the socket s.

    argp - A pointer to a parameter for cmd.

Returns:
   Upon successful completion, the ioctlsocket() returns 0.
   Otherwise, a value of SOCKET_ERROR is returned, and a specific
   error code is stored with SetErrorCode().

--*/
{
    DWORD DontCare;

    return(WSAIoctl(
        s,                     // Socket handle
        cmd,                   //Command
        argp,                  // Input buffer
        sizeof(unsigned long), // Input buffer size
        argp,                  // Output buffer
        sizeof(unsigned long), // Output buffer size
        &DontCare,             // bytes returned
        NULL,                  // Overlapped struct
        NULL                   // Completion Routine
        ));
}




int WSAAPI
WSAIoctl(
    IN SOCKET s,
    IN DWORD dwIoControlCode,
    IN LPVOID lpvInBuffer,
    IN DWORD cbInBuffer,
    OUT LPVOID lpvOutBuffer,
    OUT DWORD cbOutBuffer,
    OUT LPDWORD lpcbBytesReturned,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
/*++
Routine Description:

    Control the mode of a socket.

Arguments:

    s - Handle to a socket

    dwIoControlCode - Control code of operation to perform

    lpvInBuffer - Address of input buffer

    cbInBuffer - Size of input buffer

    lpvOutBuffer - Address of output buffer

    cbOutBuffer - Size of output buffer

    lpcbBytesReturned - Address of actual bytes of output

    lpOverlapped - Address of WSAOVERLAPPED structure

    lpCompletionRoutine - A pointer to the completion routine called
                          when the operation  has been completed.

Returns:
    Zero on success else SOCKET_ERROR. The error code is stored with
    SetErrorCode().
--*/
{
    PDTHREAD           Thread;
    INT                ErrorCode, ReturnValue = ERROR_SUCCESS;
    PDPROVIDER         Provider;
    PDSOCKET           Socket;

	ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if (ErrorCode==ERROR_SUCCESS)
	{
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPIoctl(
                s,
                dwIoControlCode,
                lpvInBuffer,
                cbInBuffer,
                lpvOutBuffer,
                cbOutBuffer,
                lpcbBytesReturned,
                lpOverlapped,
                lpCompletionRoutine,
                Thread->GetWahThreadID(),
                &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
        } //if
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return(SOCKET_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\nscatalo.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    nscatalo.cpp

Abstract:

    This module contains the implementation of the dcatalog class.

Author:

    Dirk Brandewie dirk@mink.intel.com  25-JUL-1995

Revision History:

    23-Aug-1995 dirk@mink.intel.com
        Moved includes into precomp.h.

--*/

#include "precomp.h"

#define CATALOG_NAME            "NameSpace_Catalog5"
#ifdef _WIN64
#define CATALOG_ENTRIES_NAME    "Catalog_Entries64"
#define NUM_ENTRIES_NAME        "Num_Catalog_Entries64"

#define CATALOG_ENTRIES_NAME32  "Catalog_Entries"
#define NUM_ENTRIES_NAME32      "Num_Catalog_Entries"
#else
#define CATALOG_ENTRIES_NAME    "Catalog_Entries"
#define NUM_ENTRIES_NAME        "Num_Catalog_Entries"
#endif

#define FIRST_SERIAL_NUMBER 1
    // The first access serial number to be assigned on a given system.


NSCATALOG::NSCATALOG()
/*++

Routine Description:

    Constructor for the NSCATALOG object

Arguments:

    NONE

Return Value:

    NONE

--*/
{
    // Initialize members
    m_num_items = 0;
    m_reg_key = NULL;
    m_serial_num = FIRST_SERIAL_NUMBER-1;
    m_namespace_list.Flink = NULL;
    m_classinfo_provider = NULL;
#ifdef _WIN64
    m_entries32 = FALSE;
#endif
}




BOOL
NSCATALOG::OpenCatalog(
    IN  HKEY   ParentKey
    )
/*++

Routine Description:

    This  procedure  opens the catalog portion of the registry.  If the catalog
    is  not  yet  present,  it  also  initializes  new  first-level  values and
    first-level  subkeys  for  the  catalog.  It is assumed that the catalog is
    locked against competing registry I/O attempts.

Arguments:

    ParentKey  - Supplies  the open registry key representing the parent key of
                 the catalog.


Return Value:

    The function returns TRUE if successful, otherwise it returns FALSE.

--*/
{
    LONG   lresult;
    HKEY   new_key;
    DWORD  key_disposition;

    assert(ParentKey != NULL);

    __try {
        InitializeCriticalSection(&m_nscatalog_lock);
    }
    __except (WS2_EXCEPTION_FILTER ()) {
        return FALSE;
    }
    InitializeListHead(&m_namespace_list);

    //
    // We must first try to open the key before trying to create it.
    // RegCreateKeyEx() will fail with ERROR_ACCESS_DENIED if the current
    // user has insufficient privilege to create the target registry key,
    // even if that key already exists.
    //

    lresult = RegOpenKeyEx(
        ParentKey,                              // hkey
        NSCATALOG::GetCurrentCatalogName(),     // lpszSubKey
        0,                                      // dwReserved
        MAXIMUM_ALLOWED,                        // samDesired
        & new_key                               // phkResult
        );

    if( lresult == ERROR_SUCCESS ) {
        key_disposition = REG_OPENED_EXISTING_KEY;
    } else if( lresult == ERROR_FILE_NOT_FOUND ) {
        lresult = RegCreateKeyEx(
            ParentKey,                          // hkey
            NSCATALOG::GetCurrentCatalogName(), // lpszSubKey
            0,                                  // dwReserved
            NULL,                               // lpszClass
            REG_OPTION_NON_VOLATILE,            // fdwOptions
            KEY_READ|KEY_WRITE,                 // samDesired
            NULL,                               // lpSecurityAttributes
            & new_key,                          // phkResult
            & key_disposition                   // lpdwDisposition
            );
    }

    if (lresult != ERROR_SUCCESS) {
        return FALSE;
    }

    TRY_START(guard_open) {
        BOOL	bresult;
        DWORD	dwData;
        if (key_disposition == REG_CREATED_NEW_KEY) {
            HKEY	entries_key;
            DWORD	dont_care;

            DEBUGF(
                DBG_TRACE,
                ("Creating empty ns catalog in registry\n"));


            dwData = 0;
            bresult = WriteRegistryEntry(
                new_key,           // EntryKey
                NUM_ENTRIES_NAME,  // EntryName
                (PVOID) & dwData,  // Data
                REG_DWORD          // TypeFlag
                );
            if (! bresult) {
                DEBUGF(
                    DBG_ERR,
                    ("Writing %s\n", NUM_ENTRIES_NAME));
                TRY_THROW(guard_open);
            }

#ifdef _WIN64
            bresult = WriteRegistryEntry(
                new_key,           // EntryKey
                NUM_ENTRIES_NAME32,// EntryName
                (PVOID) & dwData,  // Data
                REG_DWORD          // TypeFlag
                );
            if (! bresult) {
                DEBUGF(
                    DBG_ERR,
                    ("Writing %s\n", NUM_ENTRIES_NAME32));
                TRY_THROW(guard_open);
            }
#endif

            dwData = FIRST_SERIAL_NUMBER;
            bresult = WriteRegistryEntry(
                new_key,                  // EntryKey
                SERIAL_NUMBER_NAME,       // EntryName
                (PVOID) & dwData,         // Data
                REG_DWORD                 // TypeFlag
                );
            if (! bresult) {
                DEBUGF(
                    DBG_ERR,
                    ("Writing %s\n",
                    SERIAL_NUMBER_NAME));
                TRY_THROW(guard_open);
            }

            lresult = RegCreateKeyEx(
                new_key,                  // hkey
                CATALOG_ENTRIES_NAME,     // lpszSubKey
                0,                        // dwReserved
                NULL,                     // lpszClass
                REG_OPTION_NON_VOLATILE,  // fdwOptions
                KEY_READ|KEY_WRITE,       // samDesired
                NULL,                     // lpSecurityAttributes
                & entries_key,            // phkResult
                & dont_care               // lpdwDisposition
                );
            if (lresult != ERROR_SUCCESS) {
                DEBUGF(
                    DBG_ERR,
                    ("Creating entries subkey %s\n",
                    CATALOG_ENTRIES_NAME));
                TRY_THROW(guard_open);
            }
            lresult = RegCloseKey(
                entries_key  // hkey
                );
            if (lresult != ERROR_SUCCESS) {
                DEBUGF(
                    DBG_ERR,
                    ("Closing entries subkey\n"));
                TRY_THROW(guard_open);
            }

#ifdef _WIN64
            lresult = RegCreateKeyEx(
                new_key,                  // hkey
                CATALOG_ENTRIES_NAME32,   // lpszSubKey
                0,                        // dwReserved
                NULL,                     // lpszClass
                REG_OPTION_NON_VOLATILE,  // fdwOptions
                KEY_READ|KEY_WRITE,       // samDesired
                NULL,                     // lpSecurityAttributes
                & entries_key,            // phkResult
                & dont_care               // lpdwDisposition
                );
            if (lresult != ERROR_SUCCESS) {
                DEBUGF(
                    DBG_ERR,
                    ("Creating entries subkey %s\n",
                    CATALOG_ENTRIES_NAME32));
                TRY_THROW(guard_open);
            }
            lresult = RegCloseKey(
                entries_key  // hkey
                );
            if (lresult != ERROR_SUCCESS) {
                DEBUGF(
                    DBG_ERR,
                    ("Closing %s subkey\n", CATALOG_ENTRIES_NAME32));
                TRY_THROW(guard_open);
            }
#endif

        }  // if REG_CREATED_NEW_KEY
        else {
            bresult = ReadRegistryEntry (
                        new_key,                // EntryKey
                        SERIAL_NUMBER_NAME,     // EntryName
                        (PVOID) &dwData,		// Data
                        sizeof (DWORD),         // MaxBytes
                        REG_DWORD               // TypeFlag
                        );
            if (!bresult) {
                // This must be the first time this version of ws2_32.dll
                // is being run.  We need to update catalog to have this
                // new entry or fail initialization.
            
			    dwData = FIRST_SERIAL_NUMBER;
                bresult = WriteRegistryEntry (
                            new_key,                // EntryKey
                            SERIAL_NUMBER_NAME,     // EntryName
                            (PVOID) &dwData,		// Data
                            REG_DWORD               // TypeFlag
                            );
                if (!bresult) {
                    DEBUGF (DBG_ERR,
                        ("Writing %s value.\n", SERIAL_NUMBER_NAME));
				    TRY_THROW (guard_open);
			    }
            }
        } // else

		m_reg_key = new_key;
		return TRUE;

    } TRY_CATCH(guard_open) {
        LONG close_result;

        close_result = RegCloseKey(
            new_key  // hkey
            );
        if (close_result != ERROR_SUCCESS) {
            DEBUGF(
                DBG_ERR,
                ("Closing catalog key\n"));
        }

        return FALSE;
    } TRY_END(guard_open);

}  // OpenCatalog




INT
NSCATALOG::InitializeFromRegistry(
    IN  HKEY    ParentKey,
    IN  HANDLE  ChangeEvent OPTIONAL
    )
/*++

Routine Description:

    This  procedure takes care of initializing a newly-created name space catalog
    from  the  registry.  If the registry does not currently contain a name space
    catalog,  an  empty catalog is created and the registry is initialized with
    the new empty catalog.

Arguments:

    ParentKey - Supplies  an  open registry key under which the catalog is read
                or  created  as  a  subkey.   The  key may be closed after this
                procedure returns.

Return Value:

    The  function  returns  ERROR_SUCESS if successful, otherwise it returns an
    appropriate WinSock error code.

Implementation Notes:

    lock the catalog
    open catalog, creating empty if required
    read the catalog
    unlock the catalog
--*/
{
    INT return_value;
    BOOL bresult;


    assert(ParentKey != NULL);
    assert(m_reg_key==NULL);

    bresult = OpenCatalog(
        ParentKey
        );
    // Opening  the catalog has the side-effect of creating an empty catalog if
    // needed.
    if (bresult) {
        return_value =  RefreshFromRegistry (ChangeEvent);
    }
    else {
        return_value = WSASYSCALLFAILURE;
    }
    return return_value;

}  // InitializeFromRegistry


#ifdef _WIN64
INT
NSCATALOG::InitializeFromRegistry32(
    IN  HKEY    ParentKey
    )
/*++

Routine Description:

    This  procedure takes care of initializing a newly-created name space catalog
    from  the  registry.  If the registry does not currently contain a name space
    catalog,  an  empty catalog is created and the registry is initialized with
    the new empty catalog.

Arguments:

    ParentKey - Supplies  an  open registry key under which the catalog is read
                or  created  as  a  subkey.   The  key may be closed after this
                procedure returns.

Return Value:

    The  function  returns  ERROR_SUCESS if successful, otherwise it returns an
    appropriate WinSock error code.

Implementation Notes:

    lock the catalog
    open catalog, creating empty if required
    read the catalog
    unlock the catalog
--*/
{
    INT return_value;
    BOOL bresult;


    assert(ParentKey != NULL);
    assert(m_reg_key==NULL);
    assert(m_entries32==FALSE);

    m_entries32 = TRUE;

    bresult = OpenCatalog(
        ParentKey
        );
    // Opening  the catalog has the side-effect of creating an empty catalog if
    // needed.
    if (bresult) {
        return_value =  RefreshFromRegistry (NULL);
    }
    else {
        return_value = WSASYSCALLFAILURE;
    }
    return return_value;

}  // InitializeFromRegistry32
#endif



INT
NSCATALOG::RefreshFromRegistry(
    IN  HANDLE  ChangeEvent OPTIONAL
    )
/*++

Routine Description:

    This  procedure takes care of initializing a newly-created name space catalog
    from  the  registry.  If the registry does not currently contain a protocol
    catalog,  an  empty catalog is created and the registry is initialized with
    the new empty catalog.

Arguments:

    ParentKey - Supplies  an  open registry key under which the catalog is read
                or  created  as  a  subkey.   The  key may be closed after this
                procedure returns.

Return Value:

    The  function  returns  ERROR_SUCESS if successful, otherwise it returns an
    appropriate WinSock error code.

Implementation Notes:

    lock the catalog
    do
		establish event notification for any registry catalog modifications
		RegOpenKey(... entries, entries_key)
		ReadRegistryEntry(... next_id)
		ReadRegistryEntry(... num_items)
		for i in (1 .. num_items)
			item = new catalog item
			item->InitializeFromRegistry(entries_key, i)
			add item to temp list
		end for
		RegCloseKey(... entries_key)
    while registry catalog has changed during read.
    update the catalog
    unlock the catalog

--*/
{
    INT			return_value;
    BOOLEAN		created_event = FALSE;
    DWORD       serial_num;
	LONG        lresult;
	HKEY        entries_key;
	LIST_ENTRY  temp_list;
	PNSCATALOGENTRY  item;
	DWORD       num_entries;
    BOOL        catalog_changed;
	BOOL                 bresult;
#ifdef _WIN64
    BOOLEAN     saveCatalog64 = FALSE;
#endif

    //
    // Create the event if caller did not provide one
    //
    if (ChangeEvent==NULL) {
        ChangeEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
        if (ChangeEvent==NULL) {
            return WSASYSCALLFAILURE;
        }
        created_event = TRUE;
    }

    // Lock this catalog object
    AcquireCatalogLock ();

    assert(m_reg_key != NULL);

	// Initialize locals to known defaults
	item = NULL;
	InitializeListHead (&temp_list);

    do {
        // Synchronize with writers
        return_value = SynchronizeSharedCatalogAccess (
								m_reg_key,
								ChangeEvent,
								&serial_num);
        if (return_value != ERROR_SUCCESS) {
            // Non-recoverable;
            break;
        }

        // Check if catalog has changed.
        if (m_serial_num == serial_num) {
            return_value = ERROR_SUCCESS;
            break;
        }

		// read number of items in the catalog
		bresult = ReadRegistryEntry(
			m_reg_key,              // EntryKey
#ifdef _WIN64
            m_entries32
                ? NUM_ENTRIES_NAME32 :
#endif
			NUM_ENTRIES_NAME,       // EntryName
			(PVOID) & num_entries,  // Data
			sizeof(DWORD),          // MaxBytes
			REG_DWORD               // TypeFlag
			);

#ifdef _WIN64
        if (! bresult  && !m_entries32) {
            //
            // We may be upgrading 64 bit installation with
            // only one catalog (prior to catalog separation
            // being implemented on WIN64).
            // Read 32 bit catalog instead and remeber to save
            // it as 64 bit catalog.
            //
            saveCatalog64 = TRUE;
			DEBUGF(
				DBG_ERR,
				("Reading %s from registry, trying %s...\n",
				NUM_ENTRIES_NAME, NUM_ENTRIES_NAME32));
		    bresult = ReadRegistryEntry(
			    m_reg_key,              // EntryKey
			    NUM_ENTRIES_NAME32,     // EntryName
			    (PVOID) & num_entries,  // Data
			    sizeof(DWORD),          // MaxBytes
			    REG_DWORD               // TypeFlag
			    );
        }
#endif
		if (! bresult) {
			DEBUGF(
				DBG_ERR,
				("Reading %s from registry\n",
				NUM_ENTRIES_NAME));
            return_value = WSASYSCALLFAILURE;
			break;
		}

		// Open entry key
		lresult = RegOpenKeyEx(
			m_reg_key,             // hkey
#ifdef _WIN64
            m_entries32
                ? CATALOG_ENTRIES_NAME32 :
#endif
			CATALOG_ENTRIES_NAME,  // lpszSubKey
			0,                     // dwReserved
			MAXIMUM_ALLOWED,       // samDesired
			& entries_key          // phkResult
			);

#ifdef _WIN64
        if (lresult == ERROR_FILE_NOT_FOUND && !m_entries32) {
            //
            // We may be upgrading 64 bit installation with
            // only one catalog (prior to catalog separation
            // being implemented on WIN64).
            // Read 32 bit catalog instead and remeber to save
            // it as 64 bit catalog.
            //
			DEBUGF(
				DBG_ERR,
				("Opening name space entries key of registry, trying entries32...\n"));
            saveCatalog64 = TRUE;
		    lresult = RegOpenKeyEx(
			    m_reg_key,             // hkey
			    CATALOG_ENTRIES_NAME32,// lpszSubKey
			    0,                     // dwReserved
			    MAXIMUM_ALLOWED,       // samDesired
			    & entries_key          // phkResult
			    );
        }
#endif
		if (lresult != ERROR_SUCCESS) {
            // Non-recoverable
			DEBUGF(
				DBG_ERR,
				("Opening entries key of registry\n"));
			return_value = WSASYSCALLFAILURE;
            break;
        }

		TRY_START(guard_open) {
			DWORD                seq_num;

			// read the items and place on temp list
            InitializeListHead (&temp_list);
			for (seq_num = 1; seq_num <= num_entries; seq_num++) {
				item = new NSCATALOGENTRY();
				if (item == NULL) {
					return_value = WSA_NOT_ENOUGH_MEMORY;
					DEBUGF(
						DBG_ERR,
						("Allocating new proto catalog item\n"));
					TRY_THROW(guard_open);
				}
				return_value = item->InitializeFromRegistry(
					entries_key,  // ParentKey
					(INT)seq_num  // SequenceNum
					);
				if (return_value != ERROR_SUCCESS) {
					item->Dereference ();
					DEBUGF(
						DBG_ERR,
						("Initializing new proto catalog item\n"));
					TRY_THROW(guard_open);
				}
				InsertTailList (&temp_list, &item->m_CatalogLinkage);
			}  // for seq_num

		} TRY_CATCH(guard_open) {

		    assert (return_value!=ERROR_SUCCESS);

		} TRY_END(guard_open);

		// close catalog
		lresult = RegCloseKey(
			entries_key  // hkey
			);
		if (lresult != ERROR_SUCCESS) {
			DEBUGF(
				DBG_ERR,
				("Closing entries key of registry\n"));
			// non-fatal
		}

        //
        // Check if catalog has changed while we were reading it
        // If so, we'll have to retry even though we succeeded
        // in reading it to ensure consistent view of the whole
        // catalog.
        //

        catalog_changed = HasCatalogChanged (ChangeEvent);
        
        if ((return_value==ERROR_SUCCESS) && !catalog_changed) {
            UpdateNamespaceList (&temp_list);

            // Store new catalog parameters
            assert (m_num_items == num_entries);
            m_serial_num = serial_num;
            break;
        }

        //
        // Free the entries we might have read
        //

        while (!IsListEmpty (&temp_list)) {
            PLIST_ENTRY list_member;
			list_member = RemoveHeadList (&temp_list);
			item = CONTAINING_RECORD (list_member,
										NSCATALOGENTRY,
										m_CatalogLinkage);
#if defined(DEBUG_TRACING)
            InitializeListHead (&item->m_CatalogLinkage);
#endif
			item->Dereference ();
		}
    }
    while (catalog_changed); // Retry while catalog is being written over

    //
    // We should have freed or consumed all the items we
    // might have read.
    //
    assert (IsListEmpty (&temp_list));
    
#ifdef _WIN64
    if (saveCatalog64 && return_value==ERROR_SUCCESS) {
		DEBUGF(
			DBG_ERR,
			("Duplicating 32 bit namespace catalog to 64 bit...\n"));
        WriteToRegistry ();
    }
#endif
    ReleaseCatalogLock ();

    // Close the event if we created one.
    if (created_event)
        CloseHandle (ChangeEvent);

    return return_value;

}  // RefreshFromRegistry



VOID
NSCATALOG::UpdateNamespaceList (
    PLIST_ENTRY     new_list
    ) 
/*++

Routine Description:

    This procedure carefully updates the catalog to match the one
    just read from the registry.  It takes care of moving item
    that did not change, removing itmes that no longer exists,
    adding new items, as well as establishing new item order.

Arguments:

    new_list    - list of the items just read form the registry

Return Value:

    None.

Implementation Notes:

    move all items from current catalog to old list
	for all items in new list
		if same item exist in old list
			add old item to current catalog and destroy new one
		else
			add new item to current catalog
	end for
	dereference all remaining items in the old list

--*/
{
    LIST_ENTRY      old_list;
    PNSCATALOGENTRY item;
    PLIST_ENTRY     list_member;

    // Move items from current list to old list
	InsertHeadList (&m_namespace_list, &old_list);
	RemoveEntryList (&m_namespace_list);
	InitializeListHead (&m_namespace_list);

	// for all loaded items
	while (!IsListEmpty (new_list)) {
		list_member = RemoveHeadList (new_list);
		item = CONTAINING_RECORD (list_member,
									NSCATALOGENTRY,
									m_CatalogLinkage);

		// check if the same item is in the old list
		list_member = old_list.Flink;
		while (list_member!=&old_list) {
			PNSCATALOGENTRY     old_item;
			old_item = CONTAINING_RECORD (list_member,
									NSCATALOGENTRY,
									m_CatalogLinkage);
            list_member = list_member->Flink;
			if (*(item->GetProviderId()) == *(old_item->GetProviderId())) {
				// it is, use the old one and get rid of the new
				assert (item->GetNamespaceId () == old_item->GetNamespaceId());
#if defined(DEBUG_TRACING)
                InitializeListHead (&item->m_CatalogLinkage);
#endif
				item->Dereference ();

                item = old_item;
				RemoveEntryList (&item->m_CatalogLinkage);
                m_num_items -= 1;
				break;
			}
		}
		// add item to the current list
		InsertTailList (&m_namespace_list, &item->m_CatalogLinkage);
        m_num_items += 1;
	}

	// destroy all remaining items on the old list
	while (!IsListEmpty (&old_list)) {
		list_member = RemoveHeadList (&old_list);
		item = CONTAINING_RECORD (list_member,
									NSCATALOGENTRY,
									m_CatalogLinkage);
#if defined(DEBUG_TRACING)
        InitializeListHead (&item->m_CatalogLinkage);
#endif
        m_num_items -= 1;
		item->Dereference ();
	}

}


INT
NSCATALOG::WriteToRegistry(
    )
/*++

Routine Description:

    This procedure writes the "entries" and "numentries" portion of the catalog
    out  to  the  registry.  

Arguments:

Return Value:

    If  the  function  is  successful,  it  returns ERROR_SUCCESS, otherwise it
    returns an appropriate WinSock error code.

Implementation Notes:
	lock catalog object
	acquire registry catalog lock (exclusive)
    RegCreateKeyEx(... entries, entries_key)
    RegDeleteSubkeys (... entries_key)
    while (get item from catalog)
        num_items++;
        item->WriteToRegistry(entries_key, num_items)
    end while
    RegCloseKey(... entries_key)
    WriteRegistryEntry(... num_items)
	WriteRegistryEntry(... nex_id)
	release registry catalog
	unlock catalog object
--*/
{
    LONG lresult;
    HKEY access_key, entries_key;
    DWORD dont_care;
    INT return_value;
    BOOL bresult;

	// lock the catalog object
    AcquireCatalogLock ();
    assert (m_reg_key!=NULL);
    assert (m_serial_num!=0);

	// Get exclusive access to the registry
	// This also verifies that registry has not change since
	// it was last read
    return_value = AcquireExclusiveCatalogAccess (
							m_reg_key,
							m_serial_num,
							&access_key);
    if (return_value == ERROR_SUCCESS) {
		// Create or open existing entries key
        lresult = RegCreateKeyEx(
            m_reg_key,                // hkey
#ifdef _WIN64
            m_entries32
                ? CATALOG_ENTRIES_NAME32 :
#endif
            CATALOG_ENTRIES_NAME,     // lpszSubKey
            0,                        // dwReserved
            NULL,                     // lpszClass
            REG_OPTION_NON_VOLATILE,  // fdwOptions
            KEY_READ|KEY_WRITE,       // samDesired
            NULL,                     // lpSecurityAttributes
            & entries_key,            // phkResult
            & dont_care               // lpdwDisposition
            );
        if (lresult == ERROR_SUCCESS) {
            TRY_START(any_failure) {
                PLIST_ENTRY          ListMember;
                PNSCATALOGENTRY     item;
                DWORD               num_items = 0;

                lresult = RegDeleteSubkeys (entries_key);

				// Write catalog items to registry
                ListMember = m_namespace_list.Flink;
                while (ListMember != & m_namespace_list) {
                    item = CONTAINING_RECORD(
                        ListMember,
                        NSCATALOGENTRY,
                        m_CatalogLinkage);
                    ListMember = ListMember->Flink;
                    num_items += 1;
                    return_value = item->WriteToRegistry(
                        entries_key,  // ParentKey
                        num_items     // SequenceNum
                        );
                    if (return_value != ERROR_SUCCESS) {
                        DEBUGF(
                            DBG_ERR,
                            ("Writing item (%lu) to registry\n",
                            num_items));
                        TRY_THROW(any_write_failure);
                    }
                }  // while get item

                assert (m_num_items == num_items);
				// Write number of items
                bresult = WriteRegistryEntry(
                    m_reg_key,             // EntryKey
#ifdef _WIN64
                    m_entries32
                        ? NUM_ENTRIES_NAME32 :
#endif
                    NUM_ENTRIES_NAME,     // EntryName
                    (PVOID) & m_num_items,// Data
                    REG_DWORD             // TypeFlag
                    );
                if (! bresult) {
                    DEBUGF(
                        DBG_ERR,
                        ("Writing %s value\n",
                        NUM_ENTRIES_NAME));
                    return_value = WSASYSCALLFAILURE;
                    TRY_THROW(any_write_failure);
                }

            } TRY_CATCH(any_write_failure) {
                if (return_value == ERROR_SUCCESS) {
                    return_value = WSASYSCALLFAILURE;
                }
            } TRY_END(any_write_failure);

			// Close entries key
            lresult = RegCloseKey(
                entries_key  // hkey
                );
            if (lresult != ERROR_SUCCESS) {
                DEBUGF(
                    DBG_ERR,
                    ("Closing entries key of registry\n"));
				// Non-fatal
            }
        }

		// Release registry
        ReleaseExclusiveCatalogAccess (
							m_reg_key,
							m_serial_num, 
							access_key);
    }

	// Unlock catalog object
	ReleaseCatalogLock();
    return return_value;

}  // WriteToRegistry


NSCATALOG::~NSCATALOG()
/*++

Routine Description:

    This  function  destroys the catalog object.  It takes care of removing and
    dereferencing  all  of  the  catalog  entries  in  the catalog.  This includes
    dereferencing  all  of the NSPROVIDER objects referenced by the catalog. 

Arguments:

    None

Return Value:

    None

Implementation Notes:

    lock the catalog
    for each catalog entry
        remove the entry
        dereference the entry
    end for
    close registry key
    unlock the catalog
    delete catalog lock
--*/
{
    PLIST_ENTRY  this_linkage;
    PNSCATALOGENTRY  this_item;
    LONG        lresult;

    DEBUGF(
        DBG_TRACE,
        ("Catalog destructor\n"));

    //
    // Check if we were fully initialized.
    //
    if (m_namespace_list.Flink==NULL) {
        return;
    }
    AcquireCatalogLock();
    while ((this_linkage = m_namespace_list.Flink) != & m_namespace_list) {
        this_item = CONTAINING_RECORD(
            this_linkage,        // address
            NSCATALOGENTRY,      // type
            m_CatalogLinkage     // field
            );
        RemoveCatalogItem(
            this_item  // CatalogItem
            );
        this_item->Dereference ();
    }  // while (get entry linkage)

    if (m_reg_key!=NULL) {
        lresult = RegCloseKey (m_reg_key);
        if (lresult != ERROR_SUCCESS) {
            DEBUGF (DBG_ERR,
                ("Closing catalog registry key, err: %ld.\n", lresult));
        }
        m_reg_key = NULL;
    }
    ReleaseCatalogLock();
    DeleteCriticalSection(&m_nscatalog_lock);
}  // ~NSCATALOG




VOID
NSCATALOG::EnumerateCatalogItems(
    IN NSCATALOGITERATION  IterationProc,
    IN PVOID               PassBack
    )
/*++

Routine Description:

    This  procedure enumerates all of the NSCATALOGENTRY structures in the
    catalog  by  calling  the indicated iteration procedure once for each item.
    The called procedure can stop the iteration early by returning FALSE.

    Note  that  the DPROVIDER associated with an enumerated NSCATALOGENTRY
    may  be  NULL.   To retrieve NSCATALOGENTRY structure that has had its
    DPROVIDER      loaded      and      initialized,      you      can      use
    GetCatalogItemFromCatalogEntryId.

Arguments:

    IterationProc - Supplies   a  reference  to  the  catalog  iteration
                    procedure supplied by the client.

    PassBack  - Supplies  a  value uninterpreted by this procedure.  This value
                is  passed  unmodified to the catalog iteration procedure.  The
                client can use this value to carry context between the original
                call site and the iteration procedure.

Return Value:

    None
--*/
{
    PLIST_ENTRY         ListMember;
    PNSCATALOGENTRY CatalogEntry;
    BOOL                enumerate_more;

    assert(IterationProc != NULL);

    enumerate_more = TRUE;

    AcquireCatalogLock ();

    ListMember = m_namespace_list.Flink;

    while (enumerate_more && (ListMember != & m_namespace_list)) {
        CatalogEntry = CONTAINING_RECORD(
            ListMember,
            NSCATALOGENTRY,
            m_CatalogLinkage);
        ListMember = ListMember->Flink;
        enumerate_more = (* IterationProc) (
            PassBack,     // PassBack
            CatalogEntry  // CatalogEntry
            );
    } //while

    ReleaseCatalogLock ();
}  // EnumerateCatalogItems




INT
NSCATALOG::GetCountedCatalogItemFromNameSpaceId(
    IN  DWORD NamespaceId,
    OUT PNSCATALOGENTRY FAR * CatalogItem
    )
/*++

Routine Description:

    Chooses  a  reference  to  a  suitable  catalog  item  given a provider ID.
    structure.   Note  that  any  one  of  multiple  catalog items for the same
    provider ID may be chosen.

    The operation takes care of creating, initializing, and setting a
    NSPROVIDER object  for the retrieved catalog item if necessary.  

Arguments:

    ProviderId  - Supplies  the  identification  of a provider to search for in
                  the catalog.

    CatalogItem - Returns  the reference to the chosen catalog item, or NULL if
                  no suitable entry was found.

Return Value:

    The  function  returns  ERROR_SUCESS if successful, otherwise it returns an
    appropriate WinSock error code.
--*/
{
    PLIST_ENTRY         ListMember;
    INT                 ReturnCode;
    PNSCATALOGENTRY     CatalogEntry;
    BOOL                Found=FALSE;

    assert(CatalogItem != NULL);

    // Prepare for early error return
    * CatalogItem = NULL;
    ReturnCode = WSAEINVAL;

    AcquireCatalogLock();
    ListMember = m_namespace_list.Flink;

    while (ListMember != & m_namespace_list) {
        CatalogEntry = CONTAINING_RECORD(
            ListMember,
            NSCATALOGENTRY,
            m_CatalogLinkage);
        ListMember = ListMember->Flink;
        if (CatalogEntry->GetNamespaceId() == NamespaceId) {
            if (CatalogEntry->GetProvider() == NULL) {
                ReturnCode = LoadProvider(
                    CatalogEntry    // CatalogEntry
                    );
                if (ReturnCode != ERROR_SUCCESS) {
                    break;
                }
            }  // if provider is NULL
            CatalogEntry->Reference ();
            * CatalogItem = CatalogEntry;
            ReturnCode = ERROR_SUCCESS;
            break;
        } //if
    } //while

    ReleaseCatalogLock();
    return(ReturnCode);
}



INT
NSCATALOG::GetCountedCatalogItemFromProviderId(
    IN  LPGUID                ProviderId,
    OUT PNSCATALOGENTRY FAR * CatalogItem
    )
/*++

Routine Description:

    Chooses  a  reference  to  a  suitable  catalog  item  given a provider ID.
    structure.

Arguments:

    ProviderId  - Supplies  the  identification  of a provider to search for in
                  the catalog.

    CatalogItem - Returns  the reference to the chosen catalog item, or NULL if
                  no suitable entry was found.

Return Value:

    The  function  returns  ERROR_SUCESS if successful, otherwise it returns an
    appropriate WinSock error code.
--*/
{
    PLIST_ENTRY         ListMember;
    INT                 ReturnCode;
    PNSCATALOGENTRY      CatalogEntry;

    assert(CatalogItem != NULL);

    // Prepare for early error return
    *CatalogItem = NULL;
    ReturnCode = WSAEINVAL;

    AcquireCatalogLock();

    ListMember = m_namespace_list.Flink;

    while (ListMember != & m_namespace_list) {
        CatalogEntry = CONTAINING_RECORD(
            ListMember,
            NSCATALOGENTRY,
            m_CatalogLinkage);
        ListMember = ListMember->Flink;

        if ( *(CatalogEntry->GetProviderId()) == *ProviderId) {
            if (CatalogEntry->GetProvider() == NULL) {
                ReturnCode = LoadProvider(
                    CatalogEntry    // CatalogEntry
                    );
                if (ReturnCode != ERROR_SUCCESS) {
                    break;
                }
            }  // if provider is NULL
            CatalogEntry->Reference ();
            * CatalogItem = CatalogEntry;
            ReturnCode = ERROR_SUCCESS;
            break;
        } //if
    } //while

    ReleaseCatalogLock();

    return(ReturnCode);
}


VOID
NSCATALOG::AppendCatalogItem(
    IN  PNSCATALOGENTRY  CatalogItem
    )
/*++

Routine Description:

    This procedure appends a catalog item to the end of the (in-memory) catalog
    object.   It becomes the last item in the catalog.  The catalog information
    in the registry is NOT updated.

 Arguments:

    CatalogItem - Supplies a reference to the catalog item to be added.

Return Value:

    None
--*/
{
    assert(CatalogItem != NULL);
    assert(IsListEmpty (&CatalogItem->m_CatalogLinkage));
    InsertTailList(
        & m_namespace_list,               // ListHead
        & CatalogItem->m_CatalogLinkage  // Entry
        );
    m_num_items ++;
}  // AppendCatalogItem




VOID
NSCATALOG::RemoveCatalogItem(
    IN  PNSCATALOGENTRY  CatalogItem
    )
/*++

Routine Description:

    This  procedure removes a catalog item from the (in-memory) catalog object.
    The catalog information in the registry is NOT updated.

Arguments:

    CatalogItem - Supplies a reference to the catalog item to be removed.

Return Value:

    None
--*/
{
    assert(CatalogItem != NULL);
    assert (!IsListEmpty (&CatalogItem->m_CatalogLinkage));

    RemoveEntryList(
        & CatalogItem->m_CatalogLinkage  // Entry
        );
#if defined(DEBUG_TRACING)
    InitializeListHead (&CatalogItem->m_CatalogLinkage);
#endif
    assert(m_num_items > 0);
    m_num_items--;

}  // RemoveCatalogItem




INT WSAAPI
NSCATALOG::GetServiceClassInfo(
    IN OUT  LPDWORD                 lpdwBufSize,
    IN OUT  LPWSASERVICECLASSINFOW  lpServiceClassInfo
    )
/*++

Routine Description:

    Returns the service class info for the service class specified in
    lpServiceClassInfo from the current service clas info enabled namespace
    provider.

Arguments:

    lpdwBufSize - A pointer to the size of the buffer pointed to by
                  lpServiceClassInfo.

    lpServiceClassInfo - A pointer to a service class info struct

Return Value:

    ERROR_SUCCESS on success, Otherwise SOCKET_ERROR.  If the buffer passed in
    is to small to hold the service class info struct, *lpdwBufSize is updated
    to reflect the required buffer size to hole the class info and an error
    value of WSAEINVAL is set with SetLastError().

--*/
{
    SetLastError(ERROR_SUCCESS);
    return(SOCKET_ERROR);
    // This stubbed out until the model for how we find the service class
    // infomation is to be found.
    UNREFERENCED_PARAMETER(lpdwBufSize);
    UNREFERENCED_PARAMETER(lpServiceClassInfo);

#if 0
    INT ReturnCode;
    BOOL ValidAnswer = FALSE;
    DWORD BufSize;
    PNSPROVIDER Provider;


    // Save off the buffer size incase we need it later
    BufSize = *lpdwBufSize;

    if (!m_classinfo_provider){
        m_classinfo_provider = GetClassInfoProvider(
            BufSize,
            lpServiceClassInfo);
        if (!m_classinfo_provider){
            SetLastError(WSAEFAULT);
            return(SOCKET_ERROR);
        } //if
    } //if
    // Call the current classinfo provider.
    ReturnCode = m_classinfo_provider->NSPGetServiceClassInfo(
        lpdwBufSize,
        lpServiceClassInfo
        );

    if (ERROR_SUCCESS == ReturnCode){
        ValidAnswer = TRUE;
    } //if

    if (!ValidAnswer){
        // The name space provider we where using failed to find the class info
        // go find a provider that can answer the question
        ReturnCode = SOCKET_ERROR;
        Provider = GetClassInfoProvider(
            BufSize,
            lpServiceClassInfo);
        if (Provider){
            //We found a provider that can service the request so use this
            //provider until it fails
            m_classinfo_provider = Provider;

            // Now retry the call
             ReturnCode = m_classinfo_provider->NSPGetServiceClassInfo(
                 lpdwBufSize,
                 lpServiceClassInfo
                 );
        } //if
    } //if
    return(ReturnCode);
#endif
}

PNSPROVIDER
NSCATALOG::GetClassInfoProvider(
    IN  DWORD BufSize,
    IN  LPWSASERVICECLASSINFOW  lpServiceClassInfo
    )
/*++

Routine Description:

    Searches for a name space provider to satisfy get service class info
    request

Arguments:

    lpdwBufSize - A pointer to the size of the buffer pointed to by
                  lpServiceClassInfo.

    lpServiceClassInfo - A pointer to a service class info struct

Return Value:

    A pointer to a provider that can satisfy the query or NULL

--*/
{
    UNREFERENCED_PARAMETER(BufSize);
    UNREFERENCED_PARAMETER(lpServiceClassInfo);

    return(NULL);

#if 0
    PLIST_ENTRY ListEntry;
    PNSPROVIDER Provider=NULL;
    PNSCATALOGENTRY CatalogEntry;
    INT ReturnCode;


    ListEntry = m_namespace_list.Flink;

    while (ListEntry != &m_namespace_list){
        CatalogEntry = CONTAINING_RECORD(ListEntry,
                                         NSCATALOGENTRY,
                                         m_CatalogLinkage);
        Provider = CatalogEntry->GetProvider();
        if (Provider &&
            CatalogEntry->GetEnabledState() &&
            CatalogEntry->StoresServiceClassInfo()){
            ReturnCode = Provider->NSPGetServiceClassInfo(
                &BufSize,
                lpServiceClassInfo
                 );
            if (ERROR_SUCCESS == ReturnCode){
                break;
            } //if
        } //if
        Provider = NULL;
        ListEntry = ListEntry->Flink;
    } //while
    return(Provider);
#endif //0
}

INT
NSCATALOG::LoadProvider(
    IN PNSCATALOGENTRY CatalogEntry
    )
/*++

Routine Description:

    Load   the   provider  described  by  CatalogEntry and set it into
    catalog entry

Arguments:

    CatalogEntry - Supplies  a reference to a name sapce catalog entry describing
                   the provider to load.


Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it returns an
    appropriate WinSock error code.
--*/
{
    INT ReturnCode = ERROR_SUCCESS;
    PNSPROVIDER LocalProvider;

    // Serialize provider loading/unloading
    AcquireCatalogLock ();

    // Check if provider is loaded under the lock
    if (CatalogEntry->GetProvider ()==NULL) {

        LocalProvider = new NSPROVIDER;
        if (LocalProvider!=NULL){
            ReturnCode = LocalProvider->Initialize(
                CatalogEntry->GetLibraryPath (),
                CatalogEntry->GetProviderId ()
                );
            if (ERROR_SUCCESS == ReturnCode){
                CatalogEntry->SetProvider (LocalProvider);
            }
            LocalProvider->Dereference ();

        } //if
        else {
            DEBUGF(
                DBG_ERR,
                ("Allocating a NSPROVIDER object\n"));
            ReturnCode = WSA_NOT_ENOUGH_MEMORY;
        }
    } // if provider not loaded

    // Serialize provider loading/unloading
    ReleaseCatalogLock ();
    return ReturnCode;
}


LPSTR
NSCATALOG::GetCurrentCatalogName()
{
    return CATALOG_NAME;

} // GetCurrentCatalogName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\nscatent.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    nscatitem.cpp

Abstract:

    This  file  contains  the  class  implementation for the NSCATALOGENTRY
    class.   This  class  defines  the  interface  to  the  entries that can be
    installed and retrieved in the namespace provider catalog.

Author:

    Dirk Brandewie (dirk@mink.intel.com) 09-Nov-1995

Notes:

    $Revision:   1.16  $

    $Modtime:   08 Mar 1996 15:36:46  $

Revision History:

    most-recent-revision-date email-name
        description
    09-Nov-1995 dirk@mink.intel.com
        Initial Revision

--*/


#include "precomp.h"



NSCATALOGENTRY::NSCATALOGENTRY()
/*++

Routine Description:

    This  procedure  constructs  an empty NSCATALOGENTRY object.  The first
    method  invoked  after  this  constructor must be InitializeFromRegistry or
    InitializeFromValues.

Arguments:

    None

Return Value:

    Implicitly  returns  a pointer to a newly created NSCATALOGENTRY object
    or NULL if there is a memory allocation failure.
--*/
{
    DEBUGF(
        DBG_TRACE,
        ("NSCATALOGENTRY constructor\n"));

    m_reference_count = 1;
    // Simply initialize embedded pointer values for safety.
#if defined(DEBUG_TRACING)
    InitializeListHead (&m_CatalogLinkage);
#endif
    m_LibraryPath[0] = '\0';
    m_providerDisplayString = NULL;
    m_namespace_id = 0;
    m_provider = NULL;
    m_enabled = TRUE;
    m_version = NULL;
    m_address_family = -1;        // all by default
}  // NSCATALOGENTRY



// The   following   two   defines  determine  the  number  of  digits  in  the
// sequence-numbered  name  of  each  catalog  entry key.  The two defines must
// include  the  same  number.   If there is a way to cause the preprocessor to
// derive both a quoted and unquoted character sequence from the same sequence,
// I don't know what it is.
#define SEQUENCE_KEY_DIGITS 12
#define SEQUENCE_KEY_DIGITS_STRING "12"




INT
NSCATALOGENTRY::InitializeFromRegistry(
    IN  HKEY  ParentKey,
    IN  INT   SequenceNum
    )
/*++

Routine Description:

    This  procedure initializes the protocol info part of the catalog item from
    information  retrieved  from  the  catalog  portion of the registry.  It is
    assumed that the catalog portion is locked against competing I/O attempts.

Arguments:

    ParentKey   - Supplies  an open registry key for the registry entry that is
                  the  parent  of  the registry item defining the catalog item,
                  i.e., the catalog entry list key.

    SequenceNum - Supplies  the  sequence  number  within the entry list of the
                  target registry entry.

Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it returns an
    appropriate WinSock error code.

--*/
{
    char  keyname[SEQUENCE_KEY_DIGITS + 1];
    HKEY  thiskey;
    LONG  result;
    INT   sock_result;

    sprintf(keyname, "%0"SEQUENCE_KEY_DIGITS_STRING"i", SequenceNum);
    result = RegOpenKeyEx(
        ParentKey,     // hkey
        keyname,       // lpszSubKey
        0,             // dwReserved
        KEY_READ,      // samDesired
        & thiskey      // phkResult
        );
    if (result != ERROR_SUCCESS) {
        DEBUGF(
            DBG_ERR,
            ("Opening catalog entry key %s, error = %lu\n",
            keyname,
            result));
        return(WSANO_RECOVERY);
    }

    sock_result = IoRegistry(
        thiskey,  // EntryKey
        TRUE      // IsRead
        );

    result = RegCloseKey(
        thiskey  // hkey
        );
    if (result != ERROR_SUCCESS) {
        DEBUGF(
            DBG_ERR,
            ("Close catalog entry key %s, error = %lu\n",
            keyname, result));
        return(WSANO_RECOVERY);
    }

    return sock_result;

}  // InitializeFromRegistry




INT
NSCATALOGENTRY::InitializeFromValues(
    IN  LPWSTR           LibraryPath,
    IN  LPWSTR           DisplayString,
    IN  LPGUID           ProviderId,
    IN  DWORD            NameSpaceId,
    IN  DWORD            Version
    )
/*++

Routine Description:

    This  procedure initializes the protocol info part of the catalog item from
    the  values  supplied.  Values are copied from the structures passed by the
    caller,  so  the  caller  is  free  to  deallocate the passed structures on
    return.

Arguments:

    LibraryPath  - Supplies    a    reference   to   a   buffer   holding   the
                   zero-terminated,   fully-qualified   path  of  the  provider
                   library that implements this protocol.  The path may include
                   expandable environment references of the form '%variable%'.

    DisplayString  - Supplies a reference to a buffer holding a
                     zero-terminated display string for this namespace
                     privider.

    ProviderId - A pointer to the GUID for this provider.

    NameSpaceId - The ID of the namespace this provider serves.

Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it returns an
    appropriate WinSock error code.

--*/
{
    size_t  len_needed;
    INT ReturnValue = ERROR_SUCCESS;

    // Copy LibraryPath
    len_needed = wcslen(LibraryPath) + 1;
    if (len_needed > sizeof(m_LibraryPath)) {
        DEBUGF(
            DBG_ERR,
            ("Library Path Too long (%u) '%S'\n",
            len_needed,
            LibraryPath));
        return(WSAEINVAL);
    }
    wcscpy(
        m_LibraryPath,
        LibraryPath);

    // Copy DisplayString
    m_providerDisplayString =  new WCHAR[wcslen(DisplayString) + 1];
    if (m_providerDisplayString != NULL) {
        (void) wcscpy(
            m_providerDisplayString,
            DisplayString);
    } else {
        ReturnValue = WSAENOBUFS;
    }


    m_providerId = *ProviderId;
    m_namespace_id = NameSpaceId;
    m_version = Version;
    m_address_family = -1;

    return (ReturnValue);

}  // InitializeFromValues




NSCATALOGENTRY::~NSCATALOGENTRY()
/*++

Routine Description:

    This  procedure  destroys  a  protocol catalog item, deallocating memory it
    owns.   It  is the caller's responsibility to remove the item from the list
    it  occupies  before  calling  this  procedure.   It  is  also the caller's
    responsibility  to unload and/or destroy any dprovider associated with this
    catalog item if appropriate.

Arguments:

    None

Return Value:

    None
--*/
{
    assert (IsListEmpty (&m_CatalogLinkage));
    if (m_providerDisplayString != NULL) {
        delete m_providerDisplayString;
        m_providerDisplayString = NULL;
    } else {
        DEBUGF(
            DBG_WARN,
            ("Destructing uninitialized protocol catalog item\n"));
    }
    if (m_provider!=NULL)
    {
        m_provider->Dereference ();
        m_provider = NULL;
    } //if

}  // ~NSCATALOGENTRY





VOID
NSCATALOGENTRY::SetProvider(
    IN  PNSPROVIDER  Provider
    )
/*++

Routine Description:

    This procedure sets the NSPROVIDER associated with a catalog entry.

Arguments:

    Provider - Supplies the new NSPROVIDER reference.

Return Value:

    None
--*/
{
    assert (m_provider==NULL);
    Provider->Reference ();
    m_provider = Provider;
}  // SetProvider



INT
NSCATALOGENTRY::WriteToRegistry(
    IN  HKEY  ParentKey,
    IN  INT   SequenceNum
    )
/*++

Routine Description:

    This  procedure  writes  the fully-initialized protocol info portion of the
    catalog  entry  out  to the catalog portion of the registry.  It is assumed
    that  the  catalog  portion of the registry is locked against competing I/O
    attempts.

Arguments:

    ParentKey -   Supplies  the  open registry key of the parent registry entry
                  in which this catalog entry will be written as a subkey.

    Sequencenum - Supplies the sequence number of this catalog entry within the
                  entire set of catalog entries.

Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it returns an
    appropriate WINSOCK error code.
--*/
{
    char  keyname[SEQUENCE_KEY_DIGITS + 1];
    HKEY  thiskey;
    LONG  result;
    INT   sock_result;
    DWORD key_disposition;


    sprintf(keyname, "%0"SEQUENCE_KEY_DIGITS_STRING"i", SequenceNum);
    result = RegCreateKeyEx(
        ParentKey,                // hkey
        keyname,                  // lpszSubKey
        0,                        // dwReserved
        NULL,                     // lpszClass
        REG_OPTION_NON_VOLATILE,  // fdwOptions
        KEY_READ|KEY_WRITE,       // samDesired
        NULL,                     // lpSecurityAttributes
        & thiskey,                // phkResult
        & key_disposition         // lpdwDisposition
        );
    if (result != ERROR_SUCCESS) {
        DEBUGF(
            DBG_ERR,
            ("Creating catalog entry key %s (%lu)\n",
            keyname, result));
        return(WSANO_RECOVERY);
    }
    if (key_disposition == REG_OPENED_EXISTING_KEY) {
        DEBUGF(
            DBG_WARN,
            ("Overwriting a catalog entry key '%s'\n",
            keyname));
    }

    sock_result = IoRegistry(
        thiskey,  // EntryKey
        FALSE     // IsRead
        );

    result = RegCloseKey(
        thiskey  // hkey
        );
    if (result != ERROR_SUCCESS) {
        DEBUGF(
            DBG_ERR,
            ("Closing catalog entry %s, error = %lu\n",
            keyname, result));
        return(WSANO_RECOVERY);
    }

    return sock_result;

}  // WriteToRegistry




VOID
NSCATALOGENTRY::Enable(
    IN BOOLEAN EnableValue
    )
/*++

Routine Description:

    Sets the enabled state of this catalog entry

Arguments:

    EnableValue - The new state value.

Return Value:

    NONE

--*/
{
    m_enabled = EnableValue;
}





INT
NSCATALOGENTRY::IoRegistry(
    IN  HKEY  EntryKey,
    IN  BOOL  IsRead)
/*++

Routine Description:

    This  procedure  performs  the  actual  input  or  output  of catalog entry
    information  from  or  to  the  registry.   It  is assumed that the catalog
    portion of the registry is locked against competing I/O attempts.

Arguments:

    EntryKey - Supplies  the open registry key where the catalog entry is to be
               read or written.

    IsRead   - Supplies  a  BOOL  determining  disposition.  TRUE indicates the
               entry  is  to  be  read  into  memory  from the registry.  FALSE
               indicates  the  entry  is  to  be written out from memory to the
               registry.

Return Value:

    The  function  returns ERROR_SUCCESS if successful, otherwise it returns an
    appropriate WINSOCK error code.
--*/
{
    BOOL io_result;
    DWORD  val;
    WSABUF carrier;
    INT pathLength;
    CHAR ansiPath[MAX_PATH];

    // The  library pathnames are expandable against environment variables.  So
    // technically they should be REG_EXPAND_SZ instead of REG_SZ.  However, as
    // of  09-14-1995,  the  registry  editor does not display REG_EXPAND_SZ as
    // strings.   So  to  ease debugging and diagnostics, the library pathnames
    // are written into the registry as REG_SZ instead.

    // char m_LibraryPath[MAX_PATH];
    if (IsRead) {
        io_result = ReadRegistryEntry(
            EntryKey,                                     // EntryKey
            "LibraryPath",                                // EntryName
            ansiPath,                                     // Data
            sizeof(ansiPath),                             // MaxBytes
            REG_SZ                                        // TypeFlag
            );

        if( io_result ) {
            pathLength = MultiByteToWideChar(
                CP_ACP,                                   // CodePage
                0,                                        // dwFlags
                ansiPath,                                 // lpMultiByteStr
                -1,                                       // cchMultiByte
                m_LibraryPath,                            // lpWideCharStr
                sizeof(m_LibraryPath) / sizeof(WCHAR)     // cchWideChar
                );

            io_result = ( pathLength > 0 );
        }
    } else {
        pathLength = WideCharToMultiByte(
            CP_ACP,                                       // CodePage
            0,                                            // dwFlags
            m_LibraryPath,                                // lpWideCharStr
            -1,                                           // cchWideChar
            ansiPath,                                     // lpMultiByteStr
            sizeof(ansiPath),                             // cchMultiByte
            NULL,
            NULL
            );

        if( pathLength == 0 ) {

            io_result = FALSE;

        } else {

            io_result = WriteRegistryEntry(
                EntryKey,                                     // EntryKey
                "LibraryPath",                                // EntryName
                ansiPath,                                     // Data
                REG_SZ                                        // TypeFlag
                );

        }

    }

    if (! io_result) {
        DEBUGF(
            DBG_ERR,
            ("%s registry entry\n",
            IsRead ? "Reading" : "Writing"));
        return WSANO_RECOVERY;
    }

    // PCHAR m_providerDisplayString
    if (IsRead) {
        // Determine size and allocate space for dynamically allocated parts.
        LONG lresult;

        // RegQueryValueEx  includes  the  null  terminator  when returning the
        // length of a string.
        lresult = RegQueryValueEx(
            EntryKey,            // hkey
            "DisplayString",      // lpszValueName
            0,                   // lpdwReserved
            NULL,                // lpdwType
            NULL,                // lpbData
            & val                // lpcbData
            );
        if (lresult != ERROR_SUCCESS) {
            DEBUGF(
                DBG_ERR,
                ("Querying length of ProviderName entry\n"));
            return WSANO_RECOVERY;
        }
        if (m_providerDisplayString != NULL) {
            DEBUGF(
                DBG_ERR,
                ("should never be re-reading a catalog entry\n"));
            return WSANO_RECOVERY;
        }
        if (val >= MAX_PATH) {
            DEBUGF(
                DBG_ERR,
                ("cannot handle provider names > MAX_PATH\n"));
            return WSANO_RECOVERY;
        }
        m_providerDisplayString =  new WCHAR[val];
        if (m_providerDisplayString == NULL) {
            return WSANO_RECOVERY;
        }
    }  // if (isRead)


    // PCHAR m_providerDisplayString
    if (IsRead) {
        io_result = ReadRegistryEntry(
            EntryKey,                                     // EntryKey
            "DisplayString",                              // EntryName
            ansiPath,                                     // Data
            sizeof(ansiPath),                             // MaxBytes
            REG_SZ                                            // TypeFlag
            );

        if( io_result ) {
            pathLength = MultiByteToWideChar(
                CP_ACP,                                   // CodePage
                0,                                        // dwFlags
                ansiPath,                                 // lpMultiByteStr
                -1,                                       // cchMultiByte
                m_providerDisplayString,                  // lpWideCharStr
                val                                       // cchWideChar
                );

            io_result = ( pathLength > 0 );
        }
    } else {
        pathLength = WideCharToMultiByte(
            CP_ACP,                                       // CodePage
            0,                                            // dwFlags
            m_providerDisplayString,                      // lpWideCharStr
            -1,                                           // cchWideChar
            ansiPath,                                     // lpMultiByteStr
            sizeof(ansiPath),                             // cchMultiByte
            NULL,
            NULL
            );

        if( pathLength == 0 ) {

            io_result = FALSE;

        } else {

            io_result = WriteRegistryEntry(
                EntryKey,                                     // EntryKey
                "DisplayString",                              // EntryName
                ansiPath,                                     // Data
                REG_SZ                                        // TypeFlag
                );

        }
    }
    if (! io_result) {
        DEBUGF(
            DBG_ERR,
            ("%s registry entry\n",
            IsRead ? "Reading" : "Writing"));
        return WSANO_RECOVERY;
    }

    // GUID ProviderId;
    if (IsRead) {
        carrier.len = sizeof(GUID);
        carrier.buf = (char*)& m_providerId;

        io_result = ReadRegistryEntry(
            EntryKey,                                  // EntryKey
            "ProviderId",                              // EntryName
            (PVOID) & (carrier),                       // Data
            sizeof(GUID),                              // MaxBytes
            REG_BINARY                                 // TypeFlag
            );
    } else {
        carrier.len = sizeof(GUID);
        carrier.buf = (char*) &m_providerId;
        io_result = WriteRegistryEntry(
            EntryKey,                                     // EntryKey
            "ProviderId",                                 // EntryName
            (PVOID) & (carrier),                          // Data
            REG_BINARY                                    // TypeFlag
            );
    }
    if (! io_result) {
        DEBUGF(
            DBG_ERR,
            ("%s registry entry\n",
            IsRead ? "Reading" : "Writing"));
        return WSANO_RECOVERY;
    }


    // DWORD m_address_family;
    if (IsRead) {
        io_result = ReadRegistryEntry(
            EntryKey,                                     // EntryKey
            "AddressFamily",                              // EntryName
            (PVOID) & (m_address_family),                 // Data
            sizeof(DWORD),                                // MaxBytes
            REG_DWORD                                     // TypeFlag
            );
        if(!io_result)
        {
            //
            // since this key may not exist, treat an error
            // as an acceptable case and simply store the
            // default value.
            //
            m_address_family = -1;
            io_result = TRUE;
        }
    } else {
       //
       // only do this if a value has been set
       //
       if(m_address_family != -1)
       {
           io_result = WriteRegistryEntry(
                EntryKey,                                     // EntryKey
                "AddressFamily",                              // EntryName
                (PVOID) & (m_address_family),                 // Data
                REG_DWORD                                     // TypeFlag
                );
        }
        else
        {
           io_result = TRUE;
        }
    }
    if (! io_result) {
        DEBUGF(
            DBG_ERR,
            ("%s registry entry\n",
            IsRead ? "Reading" : "Writing"));
        return WSANO_RECOVERY;
    }

    // DWORD m_namespace_id;
    if (IsRead) {
        io_result = ReadRegistryEntry(
            EntryKey,                                     // EntryKey
            "SupportedNameSpace",                         // EntryName
            (PVOID) & (m_namespace_id),                   // Data
            sizeof(DWORD),                                // MaxBytes
            REG_DWORD                                     // TypeFlag
            );
    } else {
       io_result = WriteRegistryEntry(
            EntryKey,                                     // EntryKey
            "SupportedNameSpace",                         // EntryName
            (PVOID) & (m_namespace_id),                   // Data
            REG_DWORD                                     // TypeFlag
            );
    }
    if (! io_result) {
        DEBUGF(
            DBG_ERR,
            ("%s registry entry\n",
            IsRead ? "Reading" : "Writing"));
        return WSANO_RECOVERY;
    }

    // BOOLEAN m_enabled;
    if (IsRead) {
        io_result = ReadRegistryEntry(
            EntryKey,                                     // EntryKey
            "Enabled",                                    // EntryName
            &val,                                         // Data
            sizeof(DWORD),                                // MaxBytes
            REG_DWORD                                     // TypeFlag
            );
        if (io_result)
            m_enabled = (val!=0);
    } else {
       val = m_enabled ? 1 : 0;
       io_result = WriteRegistryEntry(
            EntryKey,                                     // EntryKey
            "Enabled",                                    // EntryName
            &val,                                         // Data
            REG_DWORD                                     // TypeFlag
            );
    }
    if (! io_result) {
        DEBUGF(
            DBG_ERR,
            ("%s registry entry\n",
            IsRead ? "Reading" : "Writing"));
        return WSANO_RECOVERY;
    }

        // DWORD m_version;
    if (IsRead) {
        io_result = ReadRegistryEntry(
            EntryKey,                                     // EntryKey
            "Version",                                    // EntryName
            (PVOID) & (m_version),                        // Data
            sizeof(DWORD),                                // MaxBytes
            REG_DWORD                                     // TypeFlag
            );
    } else {
       io_result = WriteRegistryEntry(
            EntryKey,                                     // EntryKey
            "Version",                                    // EntryName
            (PVOID) & (m_version),                        // Data
            REG_DWORD                                     // TypeFlag
            );
    }
    if (! io_result) {
        DEBUGF(
            DBG_ERR,
            ("%s registry entry\n",
            IsRead ? "Reading" : "Rriting"));
        return WSANO_RECOVERY;
    }

    // BOOLEAN m_stores_service_class_info;
    if (IsRead) {
        io_result = ReadRegistryEntry(
            EntryKey,                                     // EntryKey
            "StoresServiceClassInfo",                     // EntryName
            &val,                                         // Data
            sizeof(DWORD),                                // MaxBytes
            REG_DWORD                                     // TypeFlag
            );
        if (io_result)
            m_stores_service_class_info = (val!=0);
    } else {
       val = m_stores_service_class_info ? 1 : 0;
       io_result = WriteRegistryEntry(
            EntryKey,                                     // EntryKey
            "StoresServiceClassInfo",                     // EntryName
            &val,                                         // Data
            REG_DWORD                                     // TypeFlag
            );
    }
    if (! io_result) {
        DEBUGF(
            DBG_ERR,
            ("%s registry entry\n",
            IsRead ? "Reading" : "Writing"));
        return WSANO_RECOVERY;
    }

    return(ERROR_SUCCESS);
}  // IoRegistry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\nspinstl.cpp ===
/*++

    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.

Module Name:

    nspinstl.cpp

Abstract:

    This module contains the entry points for name space provider
    installation/configuration.

Author:

    Dirk Brandewie (dirk@mink.intel.com) 04-December-1995

Notes:

    $Revision:   1.11  $

    $Modtime:   08 Mar 1996 15:46:16  $


Revision History:

    most-recent-revision-date email-name
        description

    04-Dec-1995 dirk@mink.intel.com
        Initial revision

--*/

#include "precomp.h"

// Structure used as context value for catalog enumerations
typedef struct
{
    GUID            ProviderId;
    PNSCATALOGENTRY CatalogItem;
} GUID_MATCH_CONTEXT, *PGUID_MATCH_CONTEXT;


BOOL
GuidMatcher(
    IN PVOID             PassBack,
    IN PNSCATALOGENTRY   CatalogItem
    )
#ifndef _WIN64_32
/*++

Routine Description:

    Enumeration proceedure for WSC calls. Finds catalog item
    with matching provider id

Arguments:

    PassBack - A context value passed to EunerateCatalogItems. It is really a
               pointer to a GUID_MATCH_CONTEXT struct.

    CatalogItem - A pointer to a catalog item to be inspected.

Return Value:

    TRUE if the Enumeration should continue else FALSE.

--*/
{
    PGUID_MATCH_CONTEXT Context;
    BOOL                ContinueEnumeration =TRUE;

    Context = (PGUID_MATCH_CONTEXT)PassBack;

    if (Context->ProviderId == *(CatalogItem->GetProviderId ())){
        Context->CatalogItem = CatalogItem;
        ContinueEnumeration = FALSE;
    } //if

    return(ContinueEnumeration);
}
#else
;
#endif


INT WSAAPI
#ifndef _WIN64_32
WSCInstallNameSpace (
#else
WSCInstallNameSpace32 (
#endif
    IN  LPWSTR  lpszIdentifier,
    IN  LPWSTR  lpszPathName,
    IN  DWORD   dwNameSpace,
    IN  DWORD   dwVersion,
    IN  LPGUID  lpProviderId
    )
/*++

Routine Description:

    WSCInstallNameSpace() is used to install a name space provider. For
    providers that are able to support multiple names spaces, this function
    must be called once for every name space supported, and a unique provider
    ID must be supplied each time.

Arguments:

    lpszIdentifier - Display string for the provider.

    lpszPathname - Points to a path to the providers DLL image which
                   follows  the usual rules for path resolution. This path may
                   contain embedded environment strings (such as
                   %SystemRoot%). Such environment strings are expanded
                   whenever the WinSock 2 DLL needs to subsequently load
                   theprovider DLL on behalf of an application. After any
                   embedded environment strings are expanded, the WinSock 2 DLL
                   passes the resulting string into the LoadLibrary() function
                   to load the provider into memory.

    dwNameSpace - Specifies the name space supported by this provider.

    dwVersion - Specifies the version number of the provider.

    bStoresAllServiceClassInfo - Specifies that this provider supports the
                                 storage  of service class schema information
                                 for all service classes across all namespaces.
                                 The Winsock DLL will then use this provider to
                                 get all of its classinfo information rather
                                 than asking each individual provider.

    lpProviderId - A unique identifier for this provider.  This GUID should be
                   generated by UUIDGEN.EXE.

Return Value:

    The function should return NO_ERROR (0) if the routine succeeds.  It should
    return SOCKET_ERROR (-1) if the routine fails and it must set the
    appropriate error code using SetLastError().
--*/
{
    INT             ReturnCode;
    PNSCATALOG      Catalog =NULL;
    PNSCATALOGENTRY Item =NULL;
    HKEY            registry_root;
    BOOL            lock_owned = FALSE;

    registry_root = OpenWinSockRegistryRoot();
    if (NULL == registry_root) {
        DEBUGF(
            DBG_ERR,
            ("Opening registry root\n"));
        SetLastError(WSASYSCALLFAILURE);
        return(SOCKET_ERROR);
    }

    //
    // Check the current protocol catalog key. If it doesn't match
    // the expected value, blow away the old key and update the
    // stored value.
    //

    ValidateCurrentCatalogName(
        registry_root,
        WINSOCK_CURRENT_NAMESPACE_CATALOG_NAME,
        NSCATALOG::GetCurrentCatalogName()
        );

    TRY_START(guard_memalloc){
        GUID_MATCH_CONTEXT context;


        Catalog = new NSCATALOG;
        if (NULL == Catalog){
            ReturnCode = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(guard_memalloc);
        } //item

        Item = new NSCATALOGENTRY;
        if (NULL == Item){
            ReturnCode = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(guard_memalloc);
        } //if


        __try {
            context.ProviderId = *lpProviderId;
            ReturnCode = Item->InitializeFromValues(
                lpszPathName,
                lpszIdentifier,
                lpProviderId,
                dwNameSpace,
                dwVersion
                );
        }
        __except (WS2_EXCEPTION_FILTER()) {
            ReturnCode = WSAEFAULT;
            TRY_THROW(guard_memalloc);
        }

        if (ERROR_SUCCESS != ReturnCode){
            TRY_THROW(guard_memalloc);
        } //if

#ifndef _WIN64_32
        ReturnCode = Catalog->InitializeFromRegistry(
            registry_root,  // ParentKey
            NULL            // ChangeEvent
            );
#else
        ReturnCode = Catalog->InitializeFromRegistry32(
            registry_root
            );
#endif

        if (ERROR_SUCCESS != ReturnCode){
            TRY_THROW(guard_memalloc);
        } //if

        context.CatalogItem = NULL;
        Catalog->EnumerateCatalogItems(
            GuidMatcher,
            &context
            );

        if (context.CatalogItem != NULL){
            ReturnCode = WSAEINVAL;
            TRY_THROW(guard_memalloc);
        } //if

        Catalog->AppendCatalogItem(
            Item
            );
        Item = NULL;  // item deletion is now covered by catalog

        ReturnCode = Catalog->WriteToRegistry();
        if (ReturnCode!=ERROR_SUCCESS) {
            TRY_THROW (guard_memalloc);
        }
        delete Catalog;

    } TRY_CATCH(guard_memalloc){
        assert (ReturnCode!=ERROR_SUCCESS);

        if (Item){
            Item->Dereference ();
        } //if

        if (Catalog){
            delete Catalog;
        } //if

    } TRY_END(guard_memalloc);


    CloseWinSockRegistryRoot(registry_root);

    if (ReturnCode == ERROR_SUCCESS) {
        HANDLE hHelper;

        //
        // Alert all interested apps of change via the notification method
        //


        if (WahOpenNotificationHandleHelper( &hHelper )==ERROR_SUCCESS) {
            WahNotifyAllProcesses( hHelper );
            WahCloseNotificationHandleHelper( hHelper );
        }
        else {
            // This is non-fatal and catalog was updated anyway
        }

        return ERROR_SUCCESS;
    }
    else {
        SetLastError(ReturnCode);
        return SOCKET_ERROR;
    }
}





INT
WSAAPI
#ifndef _WIN64_32
WSCUnInstallNameSpace (
#else
WSCUnInstallNameSpace32 (
#endif
    IN  LPGUID  lpProviderId
    )
/*++

Routine Description:

    WSCUnInstallNameSpace() is used to uninstall the indicated name space
    provider.

Arguments:

    lpProviderId - The unique identifier for a provider.

Return Value:

    The function should return NO_ERROR (0) if the routine succeeds.  It should
    return SOCKET_ERROR (-1) if the routine fails and it must set the
    appropriate error code using SetLastError().
--*/
{
    INT                  ReturnCode;
    PNSCATALOG           Catalog =NULL;
    HKEY                 registry_root;

    //Open and Initialize a name space jprovider catalog
    registry_root = OpenWinSockRegistryRoot();
    if (NULL == registry_root) {
        DEBUGF(
            DBG_ERR,
            ("Opening registry root\n"));
        SetLastError(WSASYSCALLFAILURE);
        return(SOCKET_ERROR);
    }

    TRY_START(guard_memalloc){
        GUID_MATCH_CONTEXT     context;
        Catalog = new NSCATALOG;
        if (NULL == Catalog){
            ReturnCode = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(guard_memalloc);
        } //item


#ifndef _WIN64_32
        ReturnCode = Catalog->InitializeFromRegistry(
                            registry_root,  // ParentKey
                            NULL            // ChangeEvent
                            );
#else
        ReturnCode = Catalog->InitializeFromRegistry32(
                            registry_root  // ParentKey
                            );
#endif
        if (ERROR_SUCCESS != ReturnCode){
            TRY_THROW(guard_memalloc);
        } //if

        __try {
            context.ProviderId = *lpProviderId;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            ReturnCode = WSAEFAULT;
            TRY_THROW(guard_memalloc);
        }

        context.CatalogItem = NULL;
        Catalog->EnumerateCatalogItems(
            GuidMatcher,
            &context);

        if (context.CatalogItem!=NULL) {
            Catalog->RemoveCatalogItem (context.CatalogItem);
            context.CatalogItem->Dereference ();
        }
        else {
            ReturnCode = WSAEINVAL;
            TRY_THROW(guard_memalloc);
        }

        ReturnCode = Catalog->WriteToRegistry();

        if (ERROR_SUCCESS != ReturnCode){
            TRY_THROW(guard_memalloc);
        } //if

        delete Catalog;
    } TRY_CATCH(guard_memalloc){
        assert (ReturnCode!=ERROR_SUCCESS);
        if (Catalog){
            delete Catalog;
        } //if
    } TRY_END(guard_memalloc);

    CloseWinSockRegistryRoot(registry_root);

    if (ERROR_SUCCESS == ReturnCode){
        HANDLE hHelper;

        //
        // Alert all interested apps of change via the notification method
        //

        if (WahOpenNotificationHandleHelper( &hHelper) == ERROR_SUCCESS) {
            WahNotifyAllProcesses( hHelper );
            WahCloseNotificationHandleHelper( hHelper );
        }
        else {
            //
            // This in non-fatal and catalog was updated anyway.
            //
        }

        return ERROR_SUCCESS;
    } 
    else {
        SetLastError(ReturnCode);
        return SOCKET_ERROR;
    }
}




INT WSAAPI
#ifndef _WIN64_32
WSCEnableNSProvider (
#else
WSCEnableNSProvider32 (
#endif
    IN  LPGUID  lpProviderId,
    IN  BOOL    fEnable
    )
/*++

Routine Description:

    WSCEnableNSProvider() is used to change the state of a given name space
    provider.  This function is intended to be used by the control panel applet
    to change the state of the providers.  An ISV should not just blindly
    de-activate another ISV's provider in order to activate their own.  This
    choice should be left up to the user.description-of-function

Arguments:

    lpProviderId - The unique identifier for this provider.

    fEnable - If TRUE, the provider is set to the active state.  If FALSE, the
              provider is disabled and will not be available for query
              operations or service registration.

Return Value:

    The function should return NO_ERROR (0) if the routine succeeds.  It should
    return SOCKET_ERROR (-1) if the routine fails and it must set the
    appropriate error code using SetLastError().

--*/
{
    INT                  ReturnCode;
    PNSCATALOG           Catalog =NULL;
    HKEY                 registry_root;

    registry_root = OpenWinSockRegistryRoot();
    if (NULL == registry_root) {
        DEBUGF(
            DBG_ERR,
            ("Opening registry root\n"));
        SetLastError(WSASYSCALLFAILURE);
        return(SOCKET_ERROR);
    }

    TRY_START(guard_memalloc){
        GUID_MATCH_CONTEXT     context;

        Catalog = new NSCATALOG;
        if (NULL == Catalog){
            ReturnCode = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(guard_memalloc);
        } //item


#ifndef _WIN64_32
        ReturnCode = Catalog->InitializeFromRegistry(
                        registry_root,  // ParentKey
                        NULL            // ChangeEvent
                        );
#else
        ReturnCode = Catalog->InitializeFromRegistry32(
                        registry_root   // ParentKey
                        );
#endif

        if (ERROR_SUCCESS != ReturnCode){
            TRY_THROW(guard_memalloc);
        } //if

        __try {
            context.ProviderId = *lpProviderId;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            ReturnCode = WSAEFAULT;
            TRY_THROW(guard_memalloc);
        }

        context.CatalogItem = NULL;
        Catalog->EnumerateCatalogItems(
            GuidMatcher,
            &context);

        if (context.CatalogItem!=NULL) {
            context.CatalogItem->Enable (fEnable ? TRUE : FALSE);
        }
        else {
            ReturnCode = WSAEINVAL;
            TRY_THROW(guard_memalloc);
        }

        ReturnCode = Catalog->WriteToRegistry();
        if (ReturnCode != ERROR_SUCCESS) {
            TRY_THROW(guard_memalloc);
        }

        delete Catalog;

    } TRY_CATCH(guard_memalloc){

        assert (ReturnCode!=ERROR_SUCCESS);
        if (Catalog){
            delete Catalog;
        } //if
    } TRY_END(guard_memalloc);

    CloseWinSockRegistryRoot(registry_root);

    if (ERROR_SUCCESS == ReturnCode){
        HANDLE hHelper;

        //
        // Alert all interested apps of change via the notification method
        //

        if (WahOpenNotificationHandleHelper( &hHelper) == ERROR_SUCCESS) {
            WahNotifyAllProcesses( hHelper );
            WahCloseNotificationHandleHelper( hHelper );
        }
        else {
            //
            // This in non-fatal and catalog was updated anyway.
            //
        }

        return ERROR_SUCCESS;
    } 
    else {
        SetLastError(ReturnCode);
        return SOCKET_ERROR;
    }

}


// The  following  type is used to pass context back and forth to an enumerator
// iteration procedure when removing all items form the catalog
typedef struct {
    IN  DWORD               Count;      // Number of ids / size of item array
    IN  GUID                *ProviderIds;// Array of provider id's to match against
    OUT PNSCATALOGENTRY     *Items;     // Array of item pointers to return
    OUT INT                 ErrorCode;
} PROVIDER_SNAP_CONTEXT,  FAR * PPROVIDER_SNAP_CONTEXT;




BOOL
ProviderSnap(
    IN PVOID                PassBack,
    IN PNSCATALOGENTRY      CatalogEntry
    )
#ifndef _WIN64_32
/*++

Routine Description:
    Snaps all the catalog items in the current catalog

Arguments:

    PassBack     - Supplies  a reference to a PROVIDER_SNAP_CONTEXT structure.
                   Returns an array of items in the order specified by catalog
                   id array.

    CatalogEntry - Supplies  to  the client a reference to a PROTO_CATALOG_ITEM
                   structure with values for this item of the enumeration.  The
                   pointer  is  not guaranteed to be valid after this procedure
                   returns, so the client should copy data if required.

Return Value:

    If an item is found that could not be matched to catalog id in the array,
    the function returns FALSE to terminate the iteration,
    otherwise it returns TRUE.
--*/
{
    PPROVIDER_SNAP_CONTEXT      context;
    DWORD                       i;

    context = (PPROVIDER_SNAP_CONTEXT)PassBack;

    __try {
        for (i=0; i<context->Count; i++) {
            if (context->ProviderIds[i]
                    == *(CatalogEntry->GetProviderId ())) {
                assert (context->Items[i]==NULL);
                context->Items[i] = CatalogEntry;
                return TRUE;
            }
        }
    }
    __except (WS2_EXCEPTION_FILTER()) {
        context->ErrorCode = WSAEFAULT;
    }

    return FALSE;
}  // ProviderSnap
#else
;
#endif

int
WSPAPI
#ifndef _WIN64_32
WSCWriteNameSpaceOrder (
#else
WSCWriteNameSpaceOrder32 (
#endif
    IN LPGUID lpProviderId,
    IN DWORD dwNumberOfEntries
    )
/*++

Routine Description:

    Reorder existing WinSock2 name space providers.  The order of the service
    providers determines their priority in being selected for use.  The
    sporder.exe tool will show you the installed provider and their ordering,
    Alternately, WSAEnumNameSpaces(), in conjunction with this function,
    will allow you to write your own tool.

Arguments:

    lpwdCatalogEntryId  [in]
      An array of CatalogEntryId elements as found in the WSAPROTOCOL_INFO
      structure.  The order of the CatalogEntryId elements is the new
      priority ordering for the service providers.

    dwNumberOfEntries  [in]
      The number of elements in the lpwdCatalogEntryId array.


Return Value:

    ERROR_SUCCESS   - the service providers have been reordered.
    WSAEINVAL       - input parameters were bad, no action was taken.
    WSAEFAULT       - CatalogEnryId array is not fully contained within
                        process address space.
    WSATRY_AGAIN    - the routine is being called by another thread or process.
    any registry error code


Comments:

    Here are scenarios in which the WSCWriteProviderOrder function may fail:

      The dwNumberOfEntries is not equal to the number of registered service
      providers.

      The lpwdCatalogEntryId contains an invalid catalog ID.

      The lpwdCatalogEntryId does not contain all valid catalog IDs exactly
      1 time.

      The routine is not able to access the registry for some reason
      (e.g. inadequate user persmissions)

      Another process (or thread) is currently calling the routine.


--*/
{
    INT             errno_result;
    HKEY            registry_root;
    PNSCATALOGENTRY *items = NULL;
    DWORD           i;

    // object protected by "try" block
    PNSCATALOG           catalog = NULL;


    items = new PNSCATALOGENTRY[dwNumberOfEntries];
    if (items==NULL) {
        DEBUGF(
            DBG_ERR,
            ("Allocating items array\n"));
        return WSA_NOT_ENOUGH_MEMORY;
    }

    memset (items, 0, sizeof (PNSCATALOGENTRY)*dwNumberOfEntries);

    errno_result = ERROR_SUCCESS;

    TRY_START(guard_memalloc) {
        PROVIDER_SNAP_CONTEXT context;
        registry_root = OpenWinSockRegistryRoot();
        if (registry_root == NULL) {
            DEBUGF(
                DBG_ERR,
                ("Opening registry root\n"));
            errno_result = WSANO_RECOVERY;
            TRY_THROW(guard_memalloc);
        }

        catalog = new NSCATALOG();
        if (catalog == NULL) {
            errno_result = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(guard_memalloc);
        }

#ifndef _WIN64_32
        errno_result = catalog->InitializeFromRegistry(
            registry_root,  // ParentKey
            NULL            // ChangeEvent
            );
#else
        errno_result = catalog->InitializeFromRegistry32(
            registry_root   // ParentKey
            );
#endif
        if (errno_result != ERROR_SUCCESS) {
            TRY_THROW(guard_memalloc);
        }

        context.Items = items;
        context.ProviderIds = lpProviderId;
        context.Count = dwNumberOfEntries;
        context.ErrorCode = ERROR_SUCCESS;

        catalog->EnumerateCatalogItems(
            ProviderSnap,         // Iteration
            & context               // PassBack
            );
        if (context.ErrorCode!=ERROR_SUCCESS) {
            errno_result = context.ErrorCode;
            TRY_THROW(guard_memalloc);
        }

        for (i=0; i<dwNumberOfEntries; i++) {
            if (context.Items[i]!=NULL) {
                //
                // Remove catalog item and add it in the end.
                //
                catalog->RemoveCatalogItem (context.Items[i]);
                catalog->AppendCatalogItem (context.Items[i]);
            }
            else {
                DEBUGF (DBG_ERR,
                    ("Checking item array against catalog, item: %ld.\n",
                    i));
                errno_result = WSAEINVAL;
                TRY_THROW(guard_memalloc);
            }
        } // for i

        errno_result = catalog->WriteToRegistry();
        if (errno_result!=ERROR_SUCCESS) {
            TRY_THROW(guard_memalloc);
        }

        delete catalog;
        CloseWinSockRegistryRoot(registry_root);

    } TRY_CATCH(guard_memalloc) {
        assert (errno_result != ERROR_SUCCESS);
        if (catalog != NULL) {
            delete catalog; // This destroys the items as well
        }
        
        if (registry_root!=NULL) {
            CloseWinSockRegistryRoot(registry_root);
        }
    } TRY_END(guard_memalloc);


    delete items;

    if (errno_result == ERROR_SUCCESS) {
        HANDLE hHelper;

        //
        // Alert all interested apps of change via the notification method
        //

        if (WahOpenNotificationHandleHelper( &hHelper) == ERROR_SUCCESS) {
            WahNotifyAllProcesses( hHelper );
            WahCloseNotificationHandleHelper( hHelper );
        }
        else {
            //
            // This in non-fatal and catalog was updated anyway.
            //
        }
    }

    return errno_result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\nsprovid.cpp ===
/*++

    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.

Module Name:

    nsprovid.cpp

Abstract:

    This module gives the class implementation for the NSPROVIDE object type.

Author:

    Dirk Brandewie (dirk@mink.intel.com) 04-December-1995

Notes:

    $Revision:   1.8  $

    $Modtime:   08 Mar 1996 16:04:36  $


Revision History:

    most-recent-revision-date email-name
        description

    04-Dec-1995 dirk@mink.intel.com
        Initial revision

--*/

#include "precomp.h"

NSPROVIDER::NSPROVIDER()
/*++

Routine Description:

    Coustructor for a NSPROVIDER object. Initializes object member variables to
    default values.

Arguments:

    None

Return Value:

    None
--*/
{
    // Init all member variable to known values
    m_reference_count = 1;
    memset(&m_proctable, 0, sizeof(m_proctable));
    m_proctable.cbSize = sizeof(m_proctable);
    m_library_handle = NULL;
#ifdef DEBUG_TRACING
    m_library_name = NULL;
#endif
}


INT WSAAPI
NSPROVIDER::NSPCleanup(
    VOID
    )
/*++
Routine Description:

    Terminate use of the WinSock name space service provider.

Arguments:

    None

Return Value:

    If no error occurs, NSPCleanup returns a value of NO_ERROR (zero).
    Otherwise, SOCKET_ERROR (-1) is returned and the provider must
    set the appropriate error code using SetLastError

--*/
{
    INT ReturnValue = NO_ERROR;

    if (m_library_handle) {
        LPNSPCLEANUP    lpNSPCleanup;

        lpNSPCleanup =
            (LPNSPCLEANUP)InterlockedExchangePointer (
                            (PVOID *)&m_proctable.NSPCleanup,
                            NULL
                            );
        if (lpNSPCleanup!=NULL) {

            DEBUGF( DBG_TRACE,
                    ("Calling NSPCleanup for provider %s @ %p\n",
                        m_library_name,
                        this));

            ReturnValue = lpNSPCleanup(&m_provider_id);

        }
    }
    return ReturnValue;
}

NSPROVIDER::~NSPROVIDER()
/*++

Routine Description:

    Destructor for NSPROVIDER object.  Frees resoures used by the object and
    set the member variables to the uninitialized state.

Arguments:

    None

Return Value:

    None
--*/
{
#ifdef DEBUG_TRACING
    if (m_library_name)
    {
        delete(m_library_name);
        m_library_name = NULL;
    } //if
#endif


    if (m_library_handle)
    {
        NSPCleanup();
        FreeLibrary(m_library_handle);
        m_library_handle = NULL;
    } //if
}


INT
NSPROVIDER::Initialize(
    IN LPWSTR lpszLibFile,
    IN LPGUID  lpProviderId
    )
/*++

Routine Description:

    This routine initializes an NSPROVIDER object.

Arguments:

    lpszLibFile - A string containing the path to the DLL for the name space
                  provider to be associated with this object.

    lpProviderId - A pointer to a GUID containing the provider ID for the
                   namespace provider.

Return Value:

    ERROR_SUCCESS if the provider was successfully initialized else an
    apropriate winsock error code.
--*/
{
    LPNSPSTARTUP        NSPStartupFunc;
    CHAR                AnsiPath[MAX_PATH];
    CHAR                ExpandedAnsiPath[MAX_PATH];
    INT                 ReturnCode;
    INT                 PathLength;
    DWORD               ExpandedPathLen;

    DEBUGF( DBG_TRACE,
            ("Initializing namespace provider %ls\n", lpszLibFile));

    //
    // Map the UNICODE path to ANSI.
    //

    PathLength = WideCharToMultiByte(
        CP_ACP,                                       // CodePage
        0,                                            // dwFlags
        lpszLibFile,                                  // lpWideCharStr
        -1,                                           // cchWideChar
        AnsiPath,                                     // lpMultiByteStr
        sizeof(AnsiPath),                             // cchMultiByte
        NULL,
        NULL
        );

    if( PathLength == 0 ) {
        DEBUGF(
            DBG_ERR,
            ("Mapping library path %ls from UNICODE to ANSI\n", lpszLibFile));
        return WSASYSCALLFAILURE;
    }

    //
    // Expand the library name to pickup environment/registry variables
    //

    ExpandedPathLen = ExpandEnvironmentStringsA(AnsiPath,
                                                ExpandedAnsiPath,
                                                MAX_PATH);

    if (ExpandedPathLen == 0) {
        DEBUGF(
            DBG_ERR,
            ("Expanding environment variable %s failed\n", ExpandedAnsiPath));
        return WSASYSCALLFAILURE;
    } //if

    TRY_START(guard_memalloc) {
#ifdef DEBUG_TRACING
        m_library_name = new CHAR[ExpandedPathLen];
        if (m_library_name == NULL) {
            DEBUGF(
                DBG_ERR,
                ("Allocating m_lib_name\n"));
            ReturnCode = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(guard_memalloc);
        }
        lstrcpy(m_library_name, ExpandedAnsiPath);

#endif
        //
        // Load the provider DLL, Call the provider startup routine and validate
        // that the provider filled out all the NSP_ROUTINE function pointers.
        //
        m_library_handle = LoadLibraryA(ExpandedAnsiPath);
        if (NULL == m_library_handle)
        {
            ReturnCode = GetLastError ();
            DEBUGF(
                DBG_ERR,
                ("Loading DLL %s, err: %ld\n",ExpandedAnsiPath, ReturnCode));
            switch (ReturnCode) {
            case ERROR_NOT_ENOUGH_MEMORY:
            case ERROR_COMMITMENT_LIMIT:
                ReturnCode = WSA_NOT_ENOUGH_MEMORY;
                break;
            default:
                ReturnCode = WSAEPROVIDERFAILEDINIT;
                break;
            }
            TRY_THROW(guard_memalloc);
        } //if

        //Get the procedure address of the NSPStartup routine
        NSPStartupFunc = (LPNSPSTARTUP)GetProcAddress(
            m_library_handle,
            "NSPStartup");
        if (NULL == NSPStartupFunc)
        {
            DEBUGF( DBG_ERR,("Getting startup entry point for NSP %ls\n",
                             lpszLibFile));
            ReturnCode = WSAEPROVIDERFAILEDINIT;
            TRY_THROW(guard_memalloc);
        } //if



        //
        // Set exception handler around this call since we
        // hold critical section (catalog lock).
        //
        __try {
#if !defined(DEBUG_TRACING)
            ReturnCode = (*NSPStartupFunc)(
                lpProviderId,
                &m_proctable);
#else
            { // declaration block
                BOOL       bypassing_call;
                bypassing_call = PREAPINOTIFY((
                    DTCODE_NSPStartup,
                    & ReturnCode,
                    ExpandedAnsiPath,
                    &lpProviderId,
                    &m_proctable));
                if (! bypassing_call) {
                    ReturnCode = (*NSPStartupFunc)(
                        lpProviderId,
                        &m_proctable);
                    POSTAPINOTIFY((
                        DTCODE_NSPStartup,
                        & ReturnCode,
                        ExpandedAnsiPath,
                        &lpProviderId,
                        &m_proctable));
                } // if ! bypassing_call
            } // declaration block
#endif // !defined(DEBUG_TRACING)

        }
        __except (WS2_EXCEPTION_FILTER ()) {
            DEBUGF(DBG_ERR, ("Unhandled exception in NSPStartup for %ls (%8.8x-%4.4x-%4.4x-%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x), code:%lx\n",
                                    lpszLibFile,
                                    lpProviderId->Data1,
                                    lpProviderId->Data2,
                                    lpProviderId->Data3,
                                    lpProviderId->Data4[0],
                                    lpProviderId->Data4[1],
                                    lpProviderId->Data4[2],
                                    lpProviderId->Data4[3],
                                    lpProviderId->Data4[4],
                                    lpProviderId->Data4[5],
                                    lpProviderId->Data4[6],
                                    lpProviderId->Data4[7],
                                    GetExceptionCode()));
            assert (FALSE);
            ReturnCode = WSAEPROVIDERFAILEDINIT;
            TRY_THROW(guard_memalloc);
        }

        if (ERROR_SUCCESS != ReturnCode)
        {
            ReturnCode = GetLastError();
            DEBUGF(DBG_ERR, ("Calling NSPStartup for %ls (%8.8x-%4.4x-%4.4x-%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x), err:%ld\n",
                                    lpszLibFile,
                                    lpProviderId->Data1,
                                    lpProviderId->Data2,
                                    lpProviderId->Data3,
                                    lpProviderId->Data4[0],
                                    lpProviderId->Data4[1],
                                    lpProviderId->Data4[2],
                                    lpProviderId->Data4[3],
                                    lpProviderId->Data4[4],
                                    lpProviderId->Data4[5],
                                    lpProviderId->Data4[6],
                                    lpProviderId->Data4[7],
                                    ReturnCode));
            if(!ReturnCode)
            {
                ReturnCode = WSAEPROVIDERFAILEDINIT;
            }
            TRY_THROW(guard_memalloc);
        } //if

        // Check to see that the namespce provider filled in all the fields in the
        // NSP_ROUTINE struct like a good provider
        if (NULL == m_proctable.NSPCleanup             ||
            NULL == m_proctable.NSPLookupServiceBegin  ||
            NULL == m_proctable.NSPLookupServiceNext   ||
            NULL == m_proctable.NSPLookupServiceEnd    ||
            NULL == m_proctable.NSPSetService          ||
            NULL == m_proctable.NSPInstallServiceClass ||
            NULL == m_proctable.NSPRemoveServiceClass  ||
            NULL == m_proctable.NSPGetServiceClassInfo
            )
        {
            DEBUGF(DBG_ERR,
                   ("Service provider %ls (%8.8x-%4.4x-%4.4x-%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x) returned an invalid procedure table\n",
                    lpszLibFile,
                    lpProviderId->Data1,
                    lpProviderId->Data2,
                    lpProviderId->Data3,
                    lpProviderId->Data4[0],
                    lpProviderId->Data4[1],
                    lpProviderId->Data4[2],
                    lpProviderId->Data4[3],
                    lpProviderId->Data4[4],
                    lpProviderId->Data4[5],
                    lpProviderId->Data4[6],
                    lpProviderId->Data4[7]));
            ReturnCode = WSAEINVALIDPROCTABLE;
            TRY_THROW(guard_memalloc);
        } //if
        if (m_proctable.cbSize < sizeof(NSP_ROUTINE)) {
            //
            // Older provider, does not suport NSPIoctl
            //
            m_proctable.NSPIoctl = NULL;
        } else {
            if (m_proctable.NSPIoctl == NULL) {
                DEBUGF(DBG_ERR,
                       ("New service provider %ls (%8.8x-%4.4x-%4.4x-%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x) returned an invalid procedure table\n",
                        lpszLibFile,
                        lpProviderId->Data1,
                        lpProviderId->Data2,
                        lpProviderId->Data3,
                        lpProviderId->Data4[0],
                        lpProviderId->Data4[1],
                        lpProviderId->Data4[2],
                        lpProviderId->Data4[3],
                        lpProviderId->Data4[4],
                        lpProviderId->Data4[5],
                        lpProviderId->Data4[6],
                        lpProviderId->Data4[7]));
                ReturnCode = WSAEINVALIDPROCTABLE;
                TRY_THROW(guard_memalloc);
            }
        }
        m_provider_id = *lpProviderId;
        return(ERROR_SUCCESS);
    }
    TRY_CATCH(guard_memalloc) {
        // Cleanup
        if (m_library_handle!=NULL) {
            FreeLibrary (m_library_handle);
            m_library_handle = NULL;
        }
#ifdef DEBUG_TRACING
        if (m_library_name!=NULL) {
            delete m_library_name;
            m_library_name = NULL;
        }
#endif
        return ReturnCode;
    } TRY_END(guard_memalloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\qos.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    qos.c

Abstract:

    This modules contains the quality of service related entrypoints
    from the winsock API.  This module contains the following functions.

    WSAGetQosByName()


Author:

    Dirk Brandewie dirk@mink.intel.com  14-06-1995

Revision History:


--*/

#include "precomp.h"


BOOL WSAAPI
WSAGetQOSByName(
                SOCKET s,
                LPWSABUF lpQOSName,
                LPQOS lpQOS
                )
/*++
Routine Description:

     Initializes the QOS based on a template.

Arguments:

    s - A descriptor identifying a socket.

    lpQOSName - Specifies the QOS template name.

    lpQOS - A pointer to the QOS structure to be filled.

Returns:
    If the function succeeds, the return value is TRUE.  If the
    function fails, the return value is FALSE.
--*/
{
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDSOCKET            Socket;
    BOOL                ReturnValue;


    ErrorCode = TURBO_PROLOG();
    if (ErrorCode==ERROR_SUCCESS) {

        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPGetQOSByName( s,
                                       lpQOSName,
                                       lpQOS,
                                       &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\qshelpr.cpp ===
/*++

    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.

Module Name:

    qshelpr.cpp

Abstract:

    Helper functions for managing the WSAQUERYSET data structure.  The external
    entry points exported by this module are the following:

    WSAComputeQuerySetSizeA()
    WSAComputeQuerySetSizeW()
    WSABuildQuerySetBufferA()
    WSABuildQuerySetBufferW()

Author:

    Paul Drews (drewsxpa@ashland.intel.com) 11-Jan-1996

Revision History:

    most-recent-revision-date email-name
        description

    11-Jan-1996  drewsxpa@ashland.intel.com
        created

--*/


#include "precomp.h"


//
//  Implementation Note:
//
//  It is important that these sizing routines be accurate and NOT throw
//  in random pads.
//  Here's the problem:
//      - the real work of WSALookupServiceNext() is done in unicode
//      and that ANSI call just translates the results
//      - WSALookupServiceNextA() called without a result buffer calls
//      WSALookupServiceNextW() without a result buffer and gets only
//      the size required for unicode results;  this unicode buffer size
//      is in all cases sufficient for the ANSI structure (which can only
//      be the same size or smaller)
//      - WSALookupServiceNextA() returns the unicode buffer size (plus small
//      pad) to the application
//      - the app then calls again with the requested buffer size
//      - WLSNextA calls WLSNextW() which returns the results
//      - WLSNextA then calls MapUnicodeQuerySetToAnsi() (below) to
//      convert the results to ANSI
//      - now if the sizing routines throw in random pads to the required
//      length, they may well determine that the required ANSI buffer size
//      is LARGER than the buffer the application provided and the copy
//      fails -- even though the buffer in fact is sufficient
//
//  This is in fact what happened with the original implementation.
//  It had numerous sloppy sizings of the form:
//      <compute size> + 3
//          later changed to
//      (sizeof(DWORD) - 1)
//
//  As soon as the number of addresses returned reached a certain number,
//  these unnecessary pads became larger than the fudge added to the
//  unicode buffer size when WSALookupServiceNextA() returned a required
//  size to the application.   Apps passed in the requested size and still
//  got a WSAEFAULT and another requested LARGER size.  But, even calling
//  down with a larger buffer doesn't work because the WSALookupServiceNextW()
//  call thought the call was successful, so a recall will get WSA_E_NO_MORE.
//
//  Bottom Line:  no unnecessary padding, the sizing must be correct
//

//
//  Rounding routines that don't unnecessarily pad
//

#define ROUND_TO_PTR(c)     ( ((c) + (sizeof(PVOID) - 1)) & ~(sizeof(PVOID)-1) ) 
#define ROUND_TO_DWORD(c)   ( ((c) + 3) & ~3 )
#define ROUND_TO_WORD(c)    ( ((c) + 1) & ~1 )
#define ROUND_TO_WCHAR(c)   ( ((c) + 1) & ~1 )


//
//  Define ASSERT
//

#define ASSERT( e )     assert( e )





static
INT
ComputeAddrInfoArraySize(
    IN      DWORD           dwNumAddrs,
    IN      PCSADDR_INFO    pCsAddrBuf
    )
/*++

Routine Description:

    This procedure computes the required size, in bytes, of a buffer to hold
    the indicated array of CSADDR_INFO structures if it were packed into a
    single buffer.

Arguments:

    dwNumAddrs - Supplies the number of CSADDR_INFO structures in the array.

    lpAddrBuf  - Supplies the array of CSADDR_INFO structures. These
                 structures in turn  may be organized as separately-allocated
                 pieces or as a single packed buffer.

Return Value:

    Required size, in bytes, of the packed buffer to hold this array
    of CSADDRs.

--*/
{
    INT     size;
    DWORD   i;

    //
    //  size
    //      - size of CSADDR array
    //      - size of sockaddrs for all CSADDRs in array
    //
    //  note that building function aligns each sockaddr on PTR boundary,
    //  so this sizing function must also
    //  

    size = dwNumAddrs * sizeof(CSADDR_INFO);

    for ( i = 0; i < dwNumAddrs; i++ )
    {
        PCSADDR_INFO paddr = &pCsAddrBuf[i];

        if ( paddr->LocalAddr.lpSockaddr )
        {
            size = ROUND_TO_PTR( size );
            size += paddr->LocalAddr.iSockaddrLength;
        }
    
        if ( paddr->RemoteAddr.lpSockaddr )
        {
            size = ROUND_TO_PTR( size );
            size += paddr->RemoteAddr.iSockaddrLength;
        }
    }

    return( size );

} // ComputeAddrInfoArraySize



static
INT
ComputeBlobSize(
    IN      LPBLOB          pBlob
    )
/*++

Routine Description:

    Computes size required to hold blob in packed buffer.

Arguments:

    pBlob - Ptr to BLOB.

Return Value:

    Required size, in bytes, of the packed buffer to hold this blob.

--*/
{
    INT size;

    size = sizeof(BLOB);

    if ( pBlob->pBlobData )
    {
        size += pBlob->cbSize;
    }

    return( size );

} // ComputeBlobSize



INT
static
StringSize(
    IN      PSTR            pString,
    IN      BOOL            fUnicode
    )
/*++

Routine Description:

    Get size of string in bytes.

    Utility to avoid dual code for sizing unicode\ANSI structures
    with imbedded strings.

Arguments:

    pString -- string to size

    fUnicode -- TRUE if string unicode
                FALSE for single byte representation

Return Value:

    Size of string in bytes including terminating NULL.

--*/
{
    if ( !pString )
    {
        return( 0 );
    }

    if ( fUnicode )
    {
        return( (wcslen((PWSTR)pString) + 1) * sizeof(WCHAR) );
    }
    else
    {
        return( strlen(pString) + 1 );
    }
}



INT
WSAAPI
ComputeQuerySetSize(
    IN      PWSAQUERYSETA   pQuerySet,
    IN      BOOL            fUnicode
    )
/*++

Routine Description:

    Get required size to hold query set in packed buffer.

    Utility to size query set independent of its unicode\ANSI character.
    This routine is called by specific routine for unicode\ANSI versions
    with the fUnicode flag set appropriately.

Arguments:

    pQuerySet - ptr to query set to compute required buffer size for

Return Value:

    Required size in bytes of packed buffer to hold pQuerySet.

--*/
{
    INT size;

    //
    //  note:  sizing must account for alignment in building
    //
    //  where build function aligns a field with TakeSpaceDWORD_PTR()
    //  then sizing here for that field must round up size to nearest
    //  DWORD_PTR
    //

    //
    //  basic structure -- size is the same unicode or ANSI
    //

    size = sizeof(WSAQUERYSETW);

    // DWORD        dwSize;
    // no further action required

    // LPSTR        lpszServiceInstanceName;

    if ( pQuerySet->lpszServiceInstanceName )
    {
        if ( fUnicode )
        {
            size = ROUND_TO_WCHAR( size );
        }
        size += StringSize( pQuerySet->lpszServiceInstanceName, fUnicode );
    }

    // LPGUID       lpServiceClassId;
    if ( pQuerySet->lpServiceClassId )
    {
        size = ROUND_TO_PTR( size );
        size += sizeof(GUID);
    }

    // LPWSAVERSION     lpVersion;
    if ( pQuerySet->lpVersion )
    {
        size = ROUND_TO_PTR( size );
        size += sizeof(WSAVERSION);
    }

    // LPSTR        lpszComment;
    if ( pQuerySet->lpszComment )
    {
        if ( fUnicode )
        {
            size = ROUND_TO_WCHAR( size );
        }
        size += StringSize( pQuerySet->lpszComment, fUnicode );
    }

    // DWORD        dwNameSpace;
    // no further action required

    // LPGUID       lpNSProviderId;
    if ( pQuerySet->lpNSProviderId )
    {
        size = ROUND_TO_PTR( size );
        size += sizeof(GUID);
    }

    // LPSTR        lpszContext;
    if (pQuerySet->lpszContext )
    {
        if ( fUnicode )
        {
            size = ROUND_TO_WCHAR( size );
        }
        size += StringSize( pQuerySet->lpszContext, fUnicode );
    }

    // LPSTR        lpszQueryString;
    if ( pQuerySet->lpszQueryString )
    {
        if ( fUnicode )
        {
            size = ROUND_TO_WCHAR( size );
        }
        size += StringSize( pQuerySet->lpszQueryString, fUnicode );
    }

    // DWORD        dwNumberOfProtocols;
    // no further action required

    // LPAFPROTOCOLS    lpafpProtocols;
    if ( pQuerySet->lpafpProtocols )
    {
        size = ROUND_TO_PTR( size );
        size += ( sizeof(AFPROTOCOLS) * pQuerySet->dwNumberOfProtocols );
    }

    // DWORD           dwNumberOfCsAddrs;
    // no further action required

    // PCSADDR_INFO    lpcsaBuffer;
    if ( pQuerySet->lpcsaBuffer )
    {
        size = ROUND_TO_PTR( size );
        size += ComputeAddrInfoArraySize(
                    pQuerySet->dwNumberOfCsAddrs,
                    pQuerySet->lpcsaBuffer );
    }

    // LPBLOB          lpBlob;
    if ( pQuerySet->lpBlob )
    {
        size = ROUND_TO_PTR( size );
        size += ComputeBlobSize( pQuerySet->lpBlob );
    }

    return( size );

} // ComputeQuerySetSize



INT
WSAAPI
WSAComputeQuerySetSizeA(
    IN      PWSAQUERYSETA  pQuerySet
    )
/*++

Routine Description:

    Get required size to hold query set in packed buffer.

Arguments:

    pQuerySet - ptr to query set to compute required buffer size for

Return Value:

    Required size in bytes of packed buffer to hold pQuerySet.

--*/
{
    return  ComputeQuerySetSize(
                pQuerySet,
                FALSE       // not unicode
                );

#if 0
    //
    //  here's the code prior to my change for reference (jamesg)
    //

    INT size;

    size = sizeof(WSAQUERYSETA);

    // DWORD           dwSize;
    // no further action required

    // LPSTR            lpszServiceInstanceName;
    if (pQuerySet->lpszServiceInstanceName != NULL) {
        size += lstrlen(pQuerySet->lpszServiceInstanceName)
            + sizeof(DWORD_PTR);
    }

    // LPGUID          lpServiceClassId;
    if (pQuerySet->lpServiceClassId != NULL) {
        size += sizeof(GUID) + (sizeof(DWORD_PTR) -1);
    }

    // LPWSAVERSION      lpVersion;
    if (pQuerySet->lpVersion != NULL) {
        size += sizeof(WSAVERSION) + (sizeof(DWORD_PTR) -1);
    }

    // LPSTR             lpszComment;
    if (pQuerySet->lpszComment != NULL) {
        size += lstrlen(pQuerySet->lpszComment)
            + sizeof(DWORD_PTR);
    }

    // DWORD           dwNameSpace;
    // no further action required

    // LPGUID          lpNSProviderId;
    if (pQuerySet->lpNSProviderId != NULL) {
        size += sizeof(GUID) + (sizeof(DWORD_PTR) -1);
    }

    // LPSTR             lpszContext;
    if (pQuerySet->lpszContext != NULL) {
        size += lstrlen(pQuerySet->lpszContext)
            + sizeof(DWORD_PTR);
    }

    // LPSTR             lpszQueryString;
    if (pQuerySet->lpszQueryString != NULL) {
        size += lstrlen(pQuerySet->lpszQueryString)
            + sizeof(DWORD_PTR);
    }

    // DWORD           dwNumberOfProtocols;
    // no further action required

    // LPAFPROTOCOLS   lpafpProtocols;
    if (pQuerySet->lpafpProtocols != NULL) {
        size += sizeof(AFPROTOCOLS) *
            pQuerySet->dwNumberOfProtocols + (sizeof(DWORD_PTR) -1);
    }

    // DWORD           dwNumberOfCsAddrs;
    // no further action required

    // PCSADDR_INFO    lpcsaBuffer;
    if (pQuerySet->lpcsaBuffer != NULL) {
        size += ComputeAddrInfoArraySize(
            pQuerySet->dwNumberOfCsAddrs,   // dwNumAddrs
            pQuerySet->lpcsaBuffer) + (sizeof(DWORD_PTR) -1);        // lpAddrBuf
    }

    // LPBLOB          lpBlob;
    if (pQuerySet->lpBlob != NULL) {
        size += ComputeBlobSize(
            pQuerySet->lpBlob) + (sizeof(DWORD_PTR) -1);
    }

    return(size);
#endif

} // WSAComputeQuerySetSizeA



INT
WSAAPI
WSAComputeQuerySetSizeW(
    IN      PWSAQUERYSETW  pQuerySet
    )
/*++

Routine Description:

    Get required size to hold query set in packed buffer.

Arguments:

    pQuerySet - ptr to query set to compute required buffer size for

Return Value:

    Required size in bytes of packed buffer to hold pQ