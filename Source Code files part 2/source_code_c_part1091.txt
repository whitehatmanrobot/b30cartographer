em32 = GlobalLock((HGLOBAL)dd);
        Status = (*((PWORD) lpMem32));
        GlobalUnlock((HGLOBAL)dd);

        (pfnOut.pfnFreeDDEData)((HANDLE)dd, TRUE, TRUE);

        GlobalDeleteAtom (ww);

        if ((Status & fAckReq) || (t1.message == WM_DDE_POKE)) {
            LoadString(hmodWOW32, iszOLEMemAllocFailedFatal, szMsgBoxText, sizeof szMsgBoxText);
            LoadString(hmodWOW32, iszSystemError, szCaption, sizeof szCaption);
            MessageBox(t1.hwnd, (LPCTSTR) szMsgBoxText, szCaption, MB_OK | MB_SETFOREGROUND | MB_TOPMOST);
            PostMessage((HWND) t1.wParam, WM_DDE_TERMINATE, (WPARAM)FULLHWND32((WORD)t1.hwnd), (LPARAM)0l);
        }
        else {
            LoadString(hmodWOW32, iszOLEMemAllocFailed, szMsgBoxText, sizeof szMsgBoxText);
            LoadString(hmodWOW32, iszSystemError, szCaption, sizeof szCaption);
            MessageBox(t1.hwnd, (LPCTSTR) szMsgBoxText, szCaption, MB_OK | MB_SETFOREGROUND | MB_TOPMOST);
        }

        FREEVDMPTR(pmsg16);

        // restore the frame ptr due to possible 16-bit memory movement
        GETFRAMEPTR(((PTD)CURRENTPTD())->vpStack, pFrame);

        goto get_next_dde_message;
    }

    BlockWOWIdle(FALSE);

    FREEARGPTR(parg16);
    FREEVDMPTR(pFrame);
    RETURN(ul);
}







/*++
    DWORD GetMessagePos(VOID)

    The %GetMessagePos% function returns a long value that represents the cursor
    position (in screen coordinates) when the last message obtained by the
    %GetMessage% function occurred.

    This function has no parameters.

    The return value specifies the <x>- and <y>-coordinates of the cursor
    position. The <x>-coordinate is in the low-order word, and the
    <y>-coordinate is in the high-order word. If the return value is assigned to
    a variable, the %MAKEPOINT% macro can be used to obtain a %POINT% structure
    from the return value; the %LOWORD% or %HIWORD% macro can be used to extract
    the <x>- or the <y>-coordinate.

    To obtain the current position of the cursor instead of the position when
    the last message occurred, use the %GetCursorPos% function.
--*/

ULONG FASTCALL WU32GetMessagePos(PVDMFRAME pFrame)
{
    ULONG ul;

    UNREFERENCED_PARAMETER(pFrame);

    ul = GETDWORD16(GetMessagePos());

    RETURN(ul);
}







/*++
    DWORD GetMessageTime(VOID)

    The %GetMessageTime% function returns the message time for the last message
    retrieved by the %GetMessage% function. The time is a long integer that
    specifies the elapsed time (in milliseconds) from the time the system was
    booted to the time the message was created (placed in the application
    queue).

    This function has no parameters.

    The return value specifies the message time.

    Do not assume that the return value is always increasing. The return value
    will wrap around to zero if the timer count exceeds the maximum value for
    long integers.

    To calculate time delays between messages, subtract the time of the second
    message from the time of the first message.
--*/

ULONG FASTCALL WU32GetMessageTime(PVDMFRAME pFrame)
{
    ULONG ul;

    UNREFERENCED_PARAMETER(pFrame);

    ul = GETLONG16(GetMessageTime());

    RETURN(ul);
}







/*++
    BOOL InSendMessage(VOID)

    The %InSendMessage% function specifies whether the current window function
    is processing a message that is passed to it through a call to the
    %SendMessage% function.

    This function has no parameters.

    The return value specifies the outcome of the function. It is TRUE if the
    window function is processing a message sent to it with %SendMessage%.
    Otherwise, it is FALSE.

    Applications use the %InSendMessage% function to determine how to handle
    errors that occur when an inactive window processes messages. For example,
    if the active window uses %SendMessage% to send a request for information to
    another window, the other window cannot become active until it returns
    control from the %SendMessage% call. The only method an inactive window has
    to inform the user of an error is to create a message box.
--*/

ULONG FASTCALL WU32InSendMessage(PVDMFRAME pFrame)
{
    ULONG ul;

    UNREFERENCED_PARAMETER(pFrame);

    ul = GETBOOL16(InSendMessage());

    RETURN(ul);
}







/*++
    BOOL PeekMessage(<lpMsg>, <hwnd>, <wMsgFilterMin>, <wMsgFilterMax>,
        <wRemoveMsg>)
    LPMSG <lpMsg>;
    HWND <hwnd>;
    WORD <wMsgFilterMin>;
    WORD <wMsgFilterMax>;
    WORD <wRemoveMsg>;

    The %PeekMessage% function checks the application queue for a message and
    places the message (if any) in the structure pointed to by the <lpMsg>
    parameter. Unlike the %GetMessage% function, the %PeekMessage% function does
    not wait for a message to be placed in the queue before returning. It does,
    however, yield control (if the PM_NOYIELD flag isn't set) and does not
    return control after the yield until Windows returns control to the
    application.

    %PeekMessage% retrieves only messages associated with the window specified
    by the <hwnd> parameter, or any of its children as specified by the
    %IsChild% function, and within the range of message values given by the
    <wMsgFilterMin> and <wMsgFilterMax> parameters. If <hwnd> is NULL,
    %PeekMessage% retrieves messages for any window that belongs to the
    application making the call. (The %PeekMessage% function does not retrieve
    messages for windows that belong to other applications.) If <hwnd> is -1,
    %PeekMessage% returns only messages with a <hwnd> of NULL as posted by the
    %PostAppMessage% function. If <wMsgFilterMin> and <wMsgFilterMax> are both
    zero, %PeekMessage% returns all available messages (no range filtering is
    performed).

    The WM_KEYFIRST and WM_KEYLAST flags can be used as filter values to
    retrieve all key messages; the WM_MOUSEFIRST and WM_MOUSELAST flags can be
    used to retrieve all mouse messages.

    <lpMsg>
        Points to an %MSG% structure that contains message information from
        the Windows application queue.

    <hwnd>
        Identifies the window whose messages are to be examined.

    <wMsgFilterMin>
        Specifies the value of the lowest message position to be
        examined.

    <wMsgFilterMax>
        Specifies the value of the highest message position to be
        examined.

    <wRemoveMsg>
        Specifies a combination of the flags described in the following
        list. PM_NOYIELD can be combined with either PM_NOREMOVE or PM_REMOVE:

    PM_NOREMOVE
        Messages are not removed from the queue after processing by
        PeekMessage.

    PM_NOYIELD
        Prevents the current task from halting and yielding system resources to
        another task.

    PM_REMOVE
        Messages are removed from the queue after processing by %PeekMessage%.

    The return value specifies whether or not a message is found. It is TRUE if
    a message is available. Otherwise, it is FALSE.

    %PeekMessage% does not remove WM_PAINT messages from the queue. The messages
    remain in the queue until processed. The %GetMessage%, %PeekMessage%, and
    %WaitMessage% functions yield control to other applications. These calls are
    the only way to let other applications run. If your application does not
    call any of these functions for long periods of time, other applications
    cannot run.

    When %GetMessage%, %PeekMessage%, and %WaitMessage% yield control to other
    applications, the stack and data segments of the application calling the
    function may move in memory to accommodate the changing memory requirements
    of other applications.

    If the application has stored long pointers to objects in the data or stack
    segment (global or local variables), and if they are unlocked, these
    pointers can become invalid after a call to %GetMessage%, %PeekMessage%, or
    %WaitMessage%. The <lpMsg> parameter of the called function remains valid in
    any case.
--*/

ULONG FASTCALL WU32PeekMessage(PVDMFRAME pFrame)
{
    ULONG ul;
    VPMSG16 vpf1;
    HANDLE  f2;
    WORD    f3, f4, f5;
    MSG t1;
    register PPEEKMESSAGE16 parg16;
    BOOL fNoYield;

    BlockWOWIdle(TRUE);

// NOTE: pFrame needs to be restored on all GOTO's to get_next_dde_message
get_next_dde_message:

    GETARGPTR(pFrame, sizeof(PEEKMESSAGE16), parg16);

    vpf1 = parg16->f1;
    f2   = HWND32(parg16->f2);
    f3   = WORD32(parg16->f3);
    f4   = WORD32(parg16->f4);
    f5   = parg16->f5;

    fNoYield = f5 & PM_NOYIELD;

    ul = GETBOOL16(PeekMessage(&t1, f2, f3, f4, f5));

    // There could've been a task switch before peekmessage returned
    // so Don't trust any 32 bit flat pointers we have, memory could
    // have been compacted or moved.
    FREEARGPTR(parg16);
    FREEVDMPTR(pFrame);

#ifdef DEBUG
    if (ul && t1.message == WM_TIMER) {
        WOW32ASSERT(HIWORD(t1.wParam) == 0);
    }
#endif

    // If PeekMessage returned NULL don't bother to copy anything back

    if (ul) {
        ULONG ulReturn;

        //
        // We need to set/reset fThunkDDEmsg (based on PM_REMOVE flag)
        // so that we know whether to call FreeDDElParam or not while
        // thunking 32 bit message to 16 bit message.
        //

        fThunkDDEmsg = (BOOL) (f5 & PM_REMOVE);
        ulReturn = putmsg16(vpf1, &t1);

        // There Could've been a Task Switch Before putmsg16 Returned so Don't
        // Trust any 32 bit flat pointers we have, memory could have been
        // compacted or moved.
        FREEARGPTR(parg16);
        FREEVDMPTR(pFrame);

        fThunkDDEmsg = TRUE;

        if (((t1.message == WM_DDE_DATA) || (t1.message == WM_DDE_POKE)) && (!ulReturn)) {
            register PMSG16 pmsg16;
            DDEDATA *lpMem32;
            WORD Status;
            UINT dd;
            WORD ww;
            char szMsgBoxText[1024];
            char szCaption[256];

            GETVDMPTR(vpf1, sizeof(MSG16), pmsg16);

            dd = FETCHDWORD(pmsg16->lParam);
            ww = FETCHWORD(pmsg16->wParam);

            lpMem32 = GlobalLock((HGLOBAL)dd);
            Status = (*((PWORD) lpMem32));
            GlobalUnlock((HGLOBAL)dd);

            (pfnOut.pfnFreeDDEData)((HANDLE)dd, TRUE, TRUE);

            GlobalDeleteAtom (ww);

            if (!(f5 & PM_REMOVE)) {

                ul = GETBOOL16(PeekMessage(&t1, f2, f3, f4, f5 | PM_REMOVE));

                // There could've been a task switch before peekmessage returned
                // so Don't trust any 32 bit flat pointers we have, memory could
                // have been compacted or moved.
                FREEARGPTR(parg16);
                FREEVDMPTR(pFrame);
                FREEVDMPTR(pmsg16);

                // uncomment if parg16 is ref'd before goto get_next_dde_message
                //GETFRAMEPTR(((PTD)CURRENTPTD())->vpStack, pFrame);
                //GETARGPTR(pFrame, sizeof(PEEKMESSAGE16), parg16);

                // uncomment if pmsg16 is ref'd before goto get_next_dde_message
                //GETVDMPTR(vpf1, sizeof(MSG16), pmsg16);
            }

            if ((Status & fAckReq) || (t1.message == WM_DDE_POKE)) {

                LoadString(hmodWOW32, iszOLEMemAllocFailedFatal, szMsgBoxText, sizeof szMsgBoxText);
                LoadString(hmodWOW32, iszSystemError, szCaption, sizeof szCaption);
                MessageBox(t1.hwnd, (LPCTSTR) szMsgBoxText, szCaption, MB_OK);
                PostMessage ((HWND) t1.wParam, WM_DDE_TERMINATE, (WPARAM)FULLHWND32((WORD)t1.hwnd), (LPARAM)0l);
            }
            else {
                LoadString(hmodWOW32, iszOLEMemAllocFailed, szMsgBoxText, sizeof szMsgBoxText);
                LoadString(hmodWOW32, iszSystemError, szCaption, sizeof szCaption);
                MessageBox(t1.hwnd, (LPCTSTR) szMsgBoxText, szCaption, MB_OK);
            }

            FREEVDMPTR(pmsg16);

            // restore the frame ptr due to possible 16-bit memory movement
            GETFRAMEPTR(((PTD)CURRENTPTD())->vpStack, pFrame);

            goto get_next_dde_message;
        }
    }
    else if (fNoYield && (CURRENTPTD()->dwWOWCompatFlags & WOWCF_SETNULLMESSAGE)) {

        // winproj (help.tutorial) calls peekmessage with PM_REMOVE and
        // PM_NOYIELD  and an lpmsg whose contents are uninitialized. However
        // even if peekmessage returns false, it checks if lpmsg->message is
        // WM_QUIT and if true exits. In WOW by pure coincidence the
        // unintialized lpmsg->message happens to be value 0x12, which is
        // WM_QUIT and thus the tutorial always exits after initialization.
        //
        // So we reset lpmsg->message to zero, if it was called with PM_NOYIELD
        // and if it happens to be WM_QUIT and if peekmessage returns zero.
        //
        //                                                       - nanduri

        // we don't need to reinitialize pFrame etc. 'cause peekmessage was
        // called with PM_NOYIELD and thus the 16bit memory couldn't have moved

        register PMSG16 pmsg16;
        GETVDMPTR(vpf1, sizeof(MSG16), pmsg16);
        if (pmsg16 && (pmsg16->message == WM_QUIT)) {
            pmsg16->message = 0;
        }
        FREEVDMPTR(pmsg16);
    }


    BlockWOWIdle(FALSE);

    FREEARGPTR(parg16);
    FREEVDMPTR(pFrame);
    RETURN(ul);
}







/*++
    BOOL PostAppMessage(<hTask>, <wMsg>, <wParam>, <lParam>)
    HANDLE <hTask>;
    WORD <wMsg>;
    WORD <wParam>;
    DWORD <lParam>;

    The %PostAppMessage% function posts a message to an application identified
    by a task handle, and then returns without waiting for the application to
    process the message. The application receiving the message obtains the
    message by calling the %GetMessage% or %PeekMessage% function. The <hwnd>
    parameter of the returned %MSG% structure is NULL.

    <hTask>
        Identifies the task that is to receive the message. The
        %GetCurrentTask% function returns this handle.

    <wMsg>
        Specifies the type of message posted.

    <wParam>
        Specifies additional message information.

    <lParam>
        Specifies additional message information.

    The return value specifies whether or not the message is posted. It is
    TRUE if the message is posted. Otherwise, it is FALSE.
--*/

ULONG FASTCALL WU32PostAppMessage(PVDMFRAME pFrame)
{
    register PPOSTAPPMESSAGE16 parg16;
    DWORD    f1;
    MSGPARAMEX mpex;

    GETARGPTR(pFrame, sizeof(POSTAPPMESSAGE16), parg16);

    mpex.lReturn = 0;
    mpex.Parm16.WndProc.hwnd   = 0;
    mpex.Parm16.WndProc.wMsg   = WORD32(parg16->f2);
    mpex.Parm16.WndProc.wParam = WORD32(parg16->f3);
    mpex.Parm16.WndProc.lParam = LONG32(parg16->f4);
    mpex.iMsgThunkClass = 0;

    f1 = THREADID32(parg16->f1);

    ThunkMsg16(&mpex);

    // Note: ThunkMsg16 may have caused 16-bit memory movement
    FREEARGPTR(pFrame);
    FREEARGPTR(parg16);

    mpex.lReturn = PostThreadMessage(f1, mpex.uMsg, mpex.uParam, mpex.lParam);

    if (MSG16NEEDSTHUNKING(&mpex)) {
        (mpex.lpfnUnThunk16)(&mpex);
    }

    FREEARGPTR(parg16);
    RETURN((ULONG)mpex.lReturn);
}







/*++
    BOOL PostMessage(<hwnd>, <msg>, <wParam>, <lParam>)
    HWND <hwnd>;
    WORD <msg>;
    WORD <wParam>;
    LONG <lParam>;

    The %PostMessage% function places a message in a window's application queue,
    and then returns without waiting for the corresponding window to process the
    message. Messages in a message queue are retrieved by calls to the
    %GetMessage% or %PeekMessage% function.

    .*
    .* DA's: the following parameters section should be identical to the
    .*       parameters section in the sdmsg.ref file. If there is a change
    .*       to this section, the identical change should be made in the other
    .*       file.
    .*

    <hwnd>
        Identifies the window that is to receive the message. If this parameter
        is 0xFFFF (-1), the message is sent to all top-level windows.

    <msg>
        Specifies the message to be sent.

    <wParam>
        Specifies additional message information. The contents of this
        parameter depends on the message being sent.

    <lParam>
        Specifies additional message information. The contents of this
        parameter depends on the message being sent.

    The return value is TRUE if the message is posted, or FALSE if it is not.

    An application should never use the %PostMessage% function to send a message
    to a control.

    .cmt
    27-Oct-1990 [ralphw]

    The following is a rewording of the previous documentation. However, it
    needs confirmation from development as to its technical accuracy before it
    can be released for public consumption.

    If the message is being sent to another application, and the <wParam> or
    <lParam> parameters are used to pass a handle or pointer to global memory,
    the memory should be allocated by the %GlobalAlloc% function using the
    GMEM_NOT_BANKED flag. In a system using expanded memory (EMS), this ensures
    that the memory is not in in a different bank of memory from the application
    using the memory.
    .endcmt
--*/

ULONG FASTCALL WU32PostMessage(PVDMFRAME pFrame)
{
    LONG l;
    UINT f2;
    WPARAM f3;
    LPARAM f4;
    HWND hwnd;
    register PPOSTMESSAGE16 parg16;
    MSGPARAMEX mpex;
    DWORD err = NO_ERROR;

    GETARGPTR(pFrame, sizeof(POSTMESSAGE16), parg16);

    // Apps should never use PostMessage to post messages that have
    // pointers to structures, because those messages will show up in
    // GetMessage, and if GetMessage tries to thunk them (ie, tries to
    // call back to the 16-bit kernel to allocate some 16-bit memory to
    // copy the converted 32-bit structure into), we have no way of
    // knowing when to free that 16-bit memory.
    //
    // BUGBUG 22-Aug-91 JeffPar:  a flag should be added to ThunkMsg16
    // indicating whether or not such allocations are permissible;  this
    // flag should be passed on to all the ThunkXXMsg16 subfunctions,
    // and each of those subfunctions should assert the flag is false
    // whenever allocating 16-bit memory.


    //
    // Used by 16->32 DDE thunkers.
    //

    WOW32ASSERT(fWhoCalled == FALSE);
    fWhoCalled = WOWDDE_POSTMESSAGE;

    f2 = (UINT)WORD32(parg16->f2);
    f3 = (WPARAM)(WORD32(parg16->f3));
    f4 = (LPARAM)(LONG32(parg16->f4));

    mpex.lReturn = 0;
    mpex.Parm16.WndProc.hwnd   = parg16->f1;
    mpex.Parm16.WndProc.wMsg   = (WORD)f2;
    mpex.Parm16.WndProc.wParam = (WORD)f3;
    mpex.Parm16.WndProc.lParam = f4;
    mpex.iMsgThunkClass = 0;

    // The Reader.exe shipped with Lotus 123MM version has a message
    // synchronization problem.  Force proper synchronization by
    // converting this PostMessage call to a SendMessage().
    if ((f2 == WM_VSCROLL) &&
         ((f3 == SB_THUMBTRACK) || (f3 == SB_THUMBPOSITION)) &&
         (CURRENTPTD()->dwWOWCompatFlagsEx & WOWCFEX_SENDPOSTEDMSG) ) {

        l = (LONG)WU32SendMessage(pFrame);
        FREEARGPTR(parg16);
        RETURN((ULONG) l);
    }

    hwnd = ThunkMsg16(&mpex);

    // Note: ThunkMsg16 may have caused 16-bit memory movement
    FREEARGPTR(pFrame);
    FREEARGPTR(parg16);

    WOW32ASSERT(fWhoCalled == WOWDDE_POSTMESSAGE);
    fWhoCalled = FALSE;
    if (hwnd) {

        l = PostMessage(hwnd, mpex.uMsg, mpex.uParam, mpex.lParam);

        if (!l)
            err = GetLastError();

        mpex.lReturn = l;
        if (MSG16NEEDSTHUNKING(&mpex)) {
            (mpex.lpfnUnThunk16)(&mpex);
        }


        // If the post message failed, then the message was probably one
        // that has pointers and therefore can not be posted. (MetaDesign
        // tries to post these kind of messages.) If the destination was a
        // WOW app, then make it into a private message, and try the post
        // again.  We don't have to worry about thunking since both the source
        // and destination are in the WOW address space.

        if (err == ERROR_INVALID_PARAMETER) {
            PWW   pww;
            DWORD dwpid;

            pww = FindPWW(hwnd);

            // was added for WM_DRAWITEM messages which are probably intended
            // for owner drawn std-type classes.  see bug #2047 NTBUG4
            if (pww != NULL && GETICLASS(pww, hwnd) != WOWCLASS_WIN16) {

                // make sure we're in the same vdm process
                if (!(GetWindowThreadProcessId(hwnd, &dwpid) &&
                      (dwpid == GetCurrentProcessId()))) {
                          return 0;
                }

                mpex.lReturn = PostMessage(hwnd, f2 | WOWPRIVATEMSG, f3, f4);
            }
        }
    }

    FREEARGPTR(parg16);
    RETURN((ULONG)mpex.lReturn);
}







/*++
    void PostQuitMessage(<nExitCode>)
    int <nExitCode>;

    The %PostQuitMessage% function informs Windows that the application wishes
    to terminate execution. It is typically used in response to a WM_DESTROY
    message.

    The %PostQuitMessage% function posts a WM_QUIT message to the application
    and returns immediately; the function merely informs the system that the
    application wants to quit sometime in the future.

    When the application receives the WM_QUIT message, it should exit the
    message loop in the main function and return control to Windows. The exit
    code returned to Windows must be the <wParam> parameter of the WM_QUIT
    message.

    <nExitCode>
        Specifies an application exit code. It is used as the wParam parameter
        of the WM_QUIT message.

    This function does not return a value.
--*/

ULONG FASTCALL WU32PostQuitMessage(PVDMFRAME pFrame)
{
    register PPOSTQUITMESSAGE16 parg16;

    GETARGPTR(pFrame, sizeof(POSTQUITMESSAGE16), parg16);

    PostQuitMessage(INT32(parg16->wExitCode));

    FREEARGPTR(parg16);
    RETURN(0);
}







/*++
    WORD RegisterWindowMessage(<lpString>)
    LPSTR <lpString>;

    This function defines a new window message that is guaranteed to be unique
    throughout the system. The returned message value can be used when calling
    the %SendMessage% or %PostMessage% function.

    %RegisterWindowMessage% is typically used for communication between two
    cooperating applications.

    If the same message string is registered by two different applications, the
    same message value is returned. The message remains registered until the
    user ends the Windows session.

    <lpString>
        Points to the message string to be registered.

    The return value specifies the outcome of the function. It is an unsigned
    short integer within the range 0xC000 to 0xFFFF if the message is
    successfully registered. Otherwise, it is zero.

    Use the %RegisterWindowMessage% function only when the same message must be
    understood by more than one application. For sending private messages within
    an application, an application can use any integer within the range WM_USER
    to 0xBFFF.
--*/

ULONG FASTCALL WU32RegisterWindowMessage(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz1;
    register PREGISTERWINDOWMESSAGE16 parg16;

    GETARGPTR(pFrame, sizeof(REGISTERWINDOWMESSAGE16), parg16);
    GETPSZPTR(parg16->f1, psz1);

    ul = GETWORD16(RegisterWindowMessage(psz1));

    FREEPSZPTR(psz1);
    FREEARGPTR(parg16);
    RETURN(ul);
}







/*++
    void ReplyMessage(<lReply>)
    LONG <lReply>;

    The %ReplyMessage% function is used to reply to a message sent through the
    %SendMessage% function without returning control to the function that called
    %SendMessage.%

    By calling this function, the window function that receives the message
    allows the task that called %SendMessage% to continue to execute as though
    the task that received the message had returned control. The task that calls
    %ReplyMessage% also continues to execute.

    Normally a task that calls %SendMessage% to send a message to another task
    will not continue executing until the window procedure that Windows calls to
    receive the message returns. However, if a task that is called to receive a
    message needs to perform some type of operation that might yield control
    (such as calling the %MessageBox% or %DialogBox% functions), Windows could
    be placed in a deadlock situation where the sending task needs to execute
    and process messages but cannot because it is waiting for %SendMessage% to
    return. An application can avoid this problem if the task receiving the
    message calls %ReplyMessage% before performing any operation that could
    cause the task to yield.

    The %ReplyMessage% function has no effect if the message was not sent
    through the %SendMessage% function or if the message was sent by the same
    task.

    <lReply>
        Specifies the result of the message processing. The possible values
        depend on the actual message sent.

    This function does not return a value.
--*/

ULONG FASTCALL WU32ReplyMessage(PVDMFRAME pFrame)
{
    register PREPLYMESSAGE16 parg16;

    GETARGPTR(pFrame, sizeof(REPLYMESSAGE16), parg16);

    ReplyMessage(LONG32(parg16->f1));

    // WARNING - Don't use any 32 bit flat pointers after call to ReplyMessage,
    //           other tasks might have run and made the pointers invalid.

    FREEARGPTR(parg16);
    RETURN(0);
}







/*++
    DWORD SendDlgItemMessage(<hDlg>, <nIDDlgItem>, <wMsg>, <wParam>, <lParam>)
    HWND <hDlg>;
    int <nIDDlgItem>;
    WORD <wMsg>;
    WORD <wParam>;
    DWORD <lParam>;

    The %SendDlgItemMessage% function sends a message to the control specified
    by the <nIDDlgItem> parameter within the dialog box specified by the <hDlg>
    parameter. The %SendDlgItemMessage% function does not return until the
    message has been processed.

    <hDlg>
        Identifies the dialog box that contains the control.

    <nIDDlgItem>
        Specifies the integer identifier of the dialog item that is to
        receive the message.

    <wMsg>
        Specifies the message value.

    <wParam>
        Specifies additional message information.

    <lParam>
        Specifies additional message information.

    The return value specifies the outcome of the function. It is the value
    returned by the control's window function, or zero if the control identifier
    is not valid.

    Using %SendDlgItemMessage% is identical to obtaining a handle to the given
    control and calling the %SendMessage% function.
--*/

#define W31EM_GETRECT (WM_USER+2)  // w31 EM_GETRECT != NT EM_GETRECT

ULONG FASTCALL WU32SendDlgItemMessage(PVDMFRAME pFrame)
{
    HWND hdlg, hwndItem, hwnd;
    register PSENDDLGITEMMESSAGE16 parg16;
    MSGPARAMEX mpex;

static HWND  hwndCached = NULL ;
static DWORD dwCachedItem = 0L ;

    GETARGPTR(pFrame, sizeof(SENDDLGITEMMESSAGE16), parg16);

    // QuarkExpress v3.31 passes a hard coded 7fff:0000 as the pointer to the
    // RECT struct for EM_GETRECT message - W3.1 rejects it in validation layer
    if( (DWORD32(parg16->f5) == 0x7FFF0000)    &&
        (WORD32(parg16->f3) == W31EM_GETRECT)  &&
        (CURRENTPTD()->dwWOWCompatFlagsEx & WOWCFEX_BOGUSPOINTER) ) {

        FREEARGPTR(parg16);
        RETURN((ULONG)0);
    }

    // Need unique handle
    hdlg = (HWND)FULLHWND32(parg16->f1);

    //
    // Caching the hwnd for the dialog item because EForm will
    // call SendDlgItemMessage in a tight loop.
    //
    if ( hdlg == hdlgSDIMCached && WORD32(parg16->f2) == dwCachedItem ) {

        // Set from cached
        hwndItem = hwndCached ;
    }
    else {
        if ( hwndItem = GetDlgItem(hdlg, WORD32(parg16->f2)) ) {

            // and cache needed information
            hdlgSDIMCached     = hdlg ;
            hwndCached         = hwndItem ;
            dwCachedItem       = WORD32(parg16->f2) ;
        }
        else {
            FREEARGPTR(parg16);
            RETURN((ULONG)0);
        }
    }

    mpex.lReturn = 0;
    if (hwndItem) {
        mpex.Parm16.WndProc.hwnd   = GETHWND16(hwndItem);
        mpex.Parm16.WndProc.wMsg   = WORD32(parg16->f3);
        mpex.Parm16.WndProc.wParam = WORD32(parg16->f4);
        mpex.Parm16.WndProc.lParam = LONG32(parg16->f5);
        mpex.iMsgThunkClass = 0;

        if (hwnd = ThunkMsg16(&mpex)) {

            // Note: ThunkMsg16 may have caused memory movement
            FREEARGPTR(pFrame);
            FREEARGPTR(parg16);

            /*
            ** Since we already know which window the message is going to
            ** don't make USER32 look it up again. - MarkRi
            */
            mpex.lReturn = SendMessage(hwndItem, mpex.uMsg, mpex.uParam,
                                                                mpex.lParam);
            // to keep common dialog structs in sync (see wcommdlg.c)
            Check_ComDlg_pszptr(CURRENTPTD()->CommDlgTd,
                                (VPVOID)mpex.Parm16.WndProc.lParam);

            if (MSG16NEEDSTHUNKING(&mpex)) {
                (mpex.lpfnUnThunk16)(&mpex);
            }
        }
    }

    FREEARGPTR(parg16);
    RETURN((ULONG)mpex.lReturn);
}







/*++
    DWORD SendMessage(<hwnd>, <msg>, <wParam>, <lParam>)
    HWND <hwnd>;
    WORD <msg>;
    WORD <wParam>;
    LONG <lParam>;

    The %SendMessage% function sends a message to a window or windows. The
    %SendMessage% function calls the window procedure for the specified window,
    and does not return until that window procedure has processed the message.
    This is in contrast to the %PostMessage% function which places the message
    into the specified window's message queue and returns immediately.

    <hwnd>
        Identifies the window that is to receive the message. If this parameter
        is 0xFFFF (-1), the message is sent to all top-level windows.

    <msg>
        Specifies the message to be sent.

    <wParam>
        Specifies additional message information. The contents of this
        parameter depends on the message being sent.

    <lParam>
        Specifies additional message information. The contents of this
        parameter depends on the message being sent.

    The return value is the result returned by the invoked window procedure; its
    value depends on the message being sent.
--*/

ULONG FASTCALL WU32SendMessage(PVDMFRAME pFrame)
{
    // NOTE: This can be called directly by WU32PostMessage!!!

    HWND hwnd;
    register PSENDMESSAGE16 parg16;
    MSGPARAMEX mpex;
    HWND16 hwndOld;
    UINT uMsgOld;
    UINT uParamOld;
    LONG lParamOld;
#ifdef DBCS
    HMEM16 hMem16;
    LPSZ lpBuf16,lpBuf32;
#endif // DBCS

    GETARGPTR(pFrame, sizeof(SENDMESSAGE16), parg16);

    hwndOld   = parg16->f1;
    uMsgOld   = WORD32(parg16->f2);
    uParamOld = WORD32(parg16->f3);
    lParamOld = LONG32(parg16->f4);

    //
    // Check for funky apps sending WM_SYSCOMMAND - SC_CLOSE to progman
    //
    if ( uMsgOld == WM_SYSCOMMAND && uParamOld == SC_CLOSE ) {
        if ( hwndOld == GETHWND16(hwndProgman) && hwndProgman != (HWND)0 ) {
            //
            // Now if shift key is down, they must be trying to save
            // settings in progman.
            //
            if ( GetKeyState( VK_SHIFT ) < 0 ) {
                uMsgOld = RegisterWindowMessage("SaveSettings");
            }
        }
    }


    //
    // This is for the apps that use DDE protocol wrongly, like AmiPro.
    //

    WOW32ASSERT(fWhoCalled == FALSE);
    fWhoCalled = WOWDDE_POSTMESSAGE;

    mpex.lReturn = 0;
    mpex.Parm16.WndProc.hwnd   = hwndOld;
    mpex.Parm16.WndProc.wMsg   = (WORD)uMsgOld;
#ifdef DBCS
    //
    // For WIN3.1J's BUG ?
    // SendMessage( hwnd, WM_GETTEXT, 2, lpBuffer )
    // if string is DBCS, return is DBCS-leadbyte.
    // KKSUZUKA:#1731
    // 1994.8.8 add by V-HIDEKK
    //
    if( uMsgOld == WM_GETTEXT && uParamOld == 2 ){
        mpex.Parm16.WndProc.wParam = (WORD)(uParamOld + 1);
        mpex.Parm16.WndProc.lParam = GlobalAllocLock16( GMEM_SHARE | GMEM_MOVEABLE, uParamOld +1, &hMem16 );
    }
    else {
        mpex.Parm16.WndProc.wParam = (WORD)uParamOld;
        mpex.Parm16.WndProc.lParam = lParamOld;
    }
#else // !DBCS
    mpex.Parm16.WndProc.wParam = (WORD)uParamOld;
    mpex.Parm16.WndProc.lParam = lParamOld;
#endif // !DBCS
    mpex.iMsgThunkClass = 0;

    hwnd = ThunkMsg16(&mpex);

    // Note: ThunkMsg16 may have caused memory movement
    FREEARGPTR(pFrame);
    FREEARGPTR(parg16);

    WOW32ASSERT(fWhoCalled == WOWDDE_POSTMESSAGE);
    fWhoCalled = FALSE;

    if (hwnd) {

        BlockWOWIdle(TRUE);

#ifdef DEBUG
        if ( WM_DDE_EXECUTE == mpex.uMsg ) {
             // comes handy when debugging shell shortcut problems
             LOGDEBUG(1,("dest %x, src%x, msg %s\n",hwnd,mpex.uParam,mpex.lParam));
        }             
#endif
        mpex.lReturn = SendMessage(hwnd, mpex.uMsg, mpex.uParam, mpex.lParam);

        BlockWOWIdle(FALSE);
#ifdef DBCS
    //
    // For WIN3.1J's BUG ?
    // SendMessage( hwnd, WM_GETTEXT, 2, lpBuffer )
    // if string is DBCS, return is DBCSLeadbyte.
    // KKSUZUKA:#1731
    // 1994.8.8 add by V-HIDEKK
    //
        if( uMsgOld == WM_GETTEXT && uParamOld == 2 ){

            GETVDMPTR(mpex.Parm16.WndProc.lParam,mpex.Parm16.WndProc.wParam,lpBuf32);
            GETVDMPTR(lParamOld,uParamOld,lpBuf16);
            lpBuf16[0] = lpBuf32[0];
            if( mpex.lReturn == 2 ){
                lpBuf16[1] = 0;
                mpex.lReturn = 1;
            }
            else {
                lpBuf16[1] = lpBuf32[1];
            }
            FREEVDMPTR(lpBuf16);
            FREEVDMPTR(lpBuf32);
            GlobalUnlockFree16( mpex.Parm16.WndProc.lParam );
            mpex.Parm16.WndProc.wParam = (WORD)uParamOld;
            mpex.Parm16.WndProc.lParam = lParamOld;
        }
#endif // DBCS


        WOW32ASSERT(fWhoCalled == FALSE);
        fWhoCalled = WOWDDE_POSTMESSAGE;
        if (MSG16NEEDSTHUNKING(&mpex)) {
            (mpex.lpfnUnThunk16)(&mpex);
        }
        WOW32ASSERT(fWhoCalled == WOWDDE_POSTMESSAGE);
        fWhoCalled = FALSE;
    }

    FREEARGPTR(parg16);
    RETURN((ULONG)mpex.lReturn);
}







/*++
    int TranslateAccelerator(<hwnd>, <hAccTable>, <lpMsg>)

    The %TranslateAccelerator% function processes keyboard accelerators for menu
    commands. The %TranslateAccelerator% function translates WM_KEYUP and
    WM_KEYDOWN messages to WM_COMMAND or WM_SYSCOMMAND messages, if there is an
    entry for the key in the application's accelerator table. The high-order
    word of the <lParam> parameter of the WM_COMMAND or WM_SYSCOMMAND message
    contains the value 1 to differentiate the message from messages sent by
    menus or controls.

    WM_COMMAND or WM_SYSCOMMAND messages are sent directly to the window, rather
    than being posted to the application queue. The %TranslateAccelerator%
    function does not return until the message is processed.

    Accelerator key strokes that are defined to select items from the system
    menu are translated into WM_SYSCOMMAND messages; all other accelerators are
    translated into WM_COMMAND messages.

    <hwnd>
        Identifies the window whose messages are to be translated.

    <hAccTable>
        %HANDLE% Identifies an accelerator table (loaded by using the
        %LoadAccelerators% function).

    <lpMsg>
        Points to a message retrieved by using the %GetMessage% or
        %PeekMessage% function. The message must be an %MSG% structure and
        contain message information from the Windows application queue.

    .cmt
    19-Sep-1990 [johnca]
    Doesn't this function really return a BOOL?
    .endcmt

    The return value specifies the outcome of the function. It is nonzero if
    translation occurs. Otherwise, it is zero.

    When %TranslateAccelerator% returns nonzero (meaning that the message is
    translated), the application should <not> process the message again by using
    the %TranslateMessage% function.

    Commands in accelerator tables do not have to correspond to menu items.

    If the accelerator command does correspond to a menu item, the application
    is sent WM_INITMENU and WM_INITMENUPOPUP messages, just as if the user were
    trying to display the menu. However, these messages are not sent if any of
    the following conditions are present:

    o   The window is disabled.

    o   The menu item is disabled.

    o   The command is not in the System menu and the window is minimized.

    o   A mouse capture is in effect (for more information, see the %SetCapture%
        function, earlier in this chapter).

    If the window is the active window and there is no keyboard focus (generally
    true if the window is minimized), then WM_SYSKEYUP and WM_SYSKEYDOWN
    messages are translated instead of WM_KEYUP and WM_KEYDOWN messages.

    If an accelerator key stroke that corresponds to a menu item occurs when the
    window that owns the menu is iconic, no WM_COMMAND message is sent. However,
    if an accelerator key stroke that does not match any of the items on the
    window's menu or the System menu occurs, a WM_COMMAND message is sent, even
    if the window is iconic.
--*/

ULONG FASTCALL WU32TranslateAccelerator(PVDMFRAME pFrame)
{
    ULONG ul;
    MSG t3;
    register PTRANSLATEACCELERATOR16 parg16;

    GETARGPTR(pFrame, sizeof(TRANSLATEACCELERATOR16), parg16);

    W32CopyMsgStruct(parg16->f3, &t3, TRUE);
    ul = GETINT16(TranslateAccelerator(HWND32(parg16->f1),
                                       HACCEL32(parg16->f2), &t3 ));

    FREEARGPTR(parg16);
    RETURN(ul);
}







/*++
    BOOL TranslateMDISysAccel(<hwndClient>, <lpMsg>)

    The %TranslateMDISysAccel% function processes keyboard accelerators for
    multiple document interface (MDI) child window System-menu commands. The
    %TranslateMDISysAccel% function translates WM_KEYUP and WM_KEYDOWN messages
    to WM_SYSCOMMAND messages. The high-order word of the <lParam> parameter of
    the WM_SYSCOMMAND message contains the value 1 to differentiate the message
    from messages sent by menus or controls.

    <hwndClient>
        Identifies the parent MDI client window.

    <lpMsg>
        Points to a message retrieved by using the %GetMessage% or
        %PeekMessage% function. The message must be an %MSG% structure and
        contain message information from the Windows application queue.

    The return value is TRUE if the function translated a message into a system
    command. Otherwise, it is FALSE.
--*/

ULONG FASTCALL WU32TranslateMDISysAccel(PVDMFRAME pFrame)
{
    ULONG ul;
    MSG t2;
    register PTRANSLATEMDISYSACCEL16 parg16;

    GETARGPTR(pFrame, sizeof(TRANSLATEMDISYSACCEL16), parg16);

    W32CopyMsgStruct(parg16->f2, &t2, TRUE);

    ul = GETBOOL16(TranslateMDISysAccel(HWND32(parg16->f1), &t2));

    FREEARGPTR(parg16);
    RETURN(ul);
}







/*++
    BOOL TranslateMessage(<lpMsg>)

    The %TranslateMessage% function translates virtual-key messages into
    character messages, as follows:

    o   WM_KEYDOWN/WM_KEYUP combinations produce a WM_CHAR or a WM_DEADCHAR
        message.

    o   WM_SYSKEYDOWN/WM_SYSKEYUP combinations produce a WM_SYSCHAR or a
        WM_SYSDEADCHAR message.

    The character messages are posted to the application queue, to be read the
    next time the application calls the %GetMessage% or %PeekMessage% function.

    <lpMsg>
        Points to a %MSG% structure retrieved through the GetMessage or
        PeekMessage function. The structure contains message information from
        the Windows application queue.

    The return value specifies the outcome of the function. It is TRUE if the
    message is translated (that is, character messages are posted to the
    application queue). Otherwise, it is FALSE.

    The %TranslateMessage% function does not modify the message given by the
    <lpMsg> parameter.

    %TranslateMessage% produces WM_CHAR messages only for keys which are mapped
    to ASCII characters by the keyboard driver.

    An application should not call %TranslateMessage% if the application
    processes virtual-key messages for some other purpose. For instance, an
    application should not call the %TranslateMessage% function if the
    %TranslateAccelerator% function returns TRUE.
--*/

ULONG FASTCALL WU32TranslateMessage(PVDMFRAME pFrame)
{
    ULONG ul;
    MSG t1;
    register PTRANSLATEMESSAGE16 parg16;

    GETARGPTR(pFrame, sizeof(TRANSLATEMESSAGE16), parg16);

    W32CopyMsgStruct(parg16->f1, &t1, TRUE);

    ul = GETBOOL16(TranslateMessage( &t1 ));

    FREEARGPTR(parg16);
    RETURN(ul);
}







/*++
    void WaitMessage(VOID)

    The %WaitMessage% function yields control to other applications when an
    application has no other tasks to perform. The %WaitMessage% function
    suspends the application and does not return until a new message is placed
    in the application's queue.

    This function has no parameters.

    This function does not return a value.

    The %GetMessage%, %PeekMessage%, and %WaitMessage% functions yield control
    to other applications. These calls are the only way to let other
    applications run. If your application does not call any of these functions
    for long periods of time, other applications cannot run.

    When %GetMessage%, %PeekMessage%, and %WaitMessage% yield control to other
    applications, the stack and data segments of the application calling the
    function may move in memory to accommodate the changing memory requirements
    of other applications. If the application has stored long pointers to
    objects in the data or stack segment (that is, global or local variables),
    these pointers can become invalid after a call to %GetMessage%,
    %PeekMessage%, or %WaitMessage%.
--*/

ULONG FASTCALL WU32WaitMessage(PVDMFRAME pFrame)
{
    UNREFERENCED_PARAMETER(pFrame);

    BlockWOWIdle(TRUE);

    WaitMessage();

    BlockWOWIdle(FALSE);

    RETURN(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wusercli.c ===
//**************************************************************************
// wusercli.c :
//     Contains all functions that execute USER32 client code on 16bitside.
//     Most of these functions don't exist on x86 builds. So any changes
//     to these files must be reflected in wow16\user\usercli.asm
//
//                                                          - nanduri
//**************************************************************************

#include "precomp.h"
#pragma hdrstop

MODNAME(wusercli.c);


//**************************************************************************
//  WU32ClientToScreen -
//
//**************************************************************************

ULONG FASTCALL WU32ClientToScreen(PVDMFRAME pFrame)
{
    POINT t2;
    register PCLIENTTOSCREEN16 parg16;

    GETARGPTR(pFrame, sizeof(CLIENTTOSCREEN16), parg16);
    GETPOINT16(parg16->f2, &t2);

    ClientToScreen( HWND32(parg16->f1), &t2 );

    PUTPOINT16(parg16->f2, &t2);
    FREEARGPTR(parg16);
    RETURN(0);
}


//**************************************************************************
//  WU32GetClientRect -
//
//**************************************************************************

ULONG FASTCALL WU32GetClientRect(PVDMFRAME pFrame)
{
    RECT t2;
    register PGETCLIENTRECT16 parg16;

    GETARGPTR(pFrame, sizeof(GETCLIENTRECT16), parg16);

    /*
     * Home Design Gold 2.0
     *
     * If the call fails, don't overwrite the passed-in
     * rect.
     */
    if (GetClientRect(HWND32(parg16->hwnd), &t2)) {
        PUTRECT16(parg16->vpRect, &t2);
    }

    FREEARGPTR(parg16);
    RETURN(0);
}



//**************************************************************************
//  WU32GetCursorPos -
//
//**************************************************************************

ULONG FASTCALL WU32GetCursorPos(PVDMFRAME pFrame)
{
    POINT t1;
    register PGETCURSORPOS16 parg16;

    GETARGPTR(pFrame, sizeof(GETCURSORPOS16), parg16);

    GetCursorPos( &t1 );

    PUTPOINT16(parg16->f1, &t1);
    FREEARGPTR(parg16);
    RETURN(0);
}


//**************************************************************************
//  WU32GetDesktopWindow -
//
//**************************************************************************

ULONG FASTCALL WU32GetDesktopWindow(PVDMFRAME pFrame)
{
    ULONG ul;

    UNREFERENCED_PARAMETER(pFrame);

    ul = GETHWND16(GetDesktopWindow());

    RETURN(ul);
}


//**************************************************************************
//  WU32GetDlgItem -
//
//**************************************************************************

ULONG FASTCALL WU32GetDlgItem(PVDMFRAME pFrame)
{
    ULONG ul;
    register PGETDLGITEM16 parg16;

    //
    // pass the child ID zero-extended.  this ID is the hMenu param to
    // CreateWindow, so USER gets this ID with hiword = 0.
    // Visual Basic relies on this.
    //


    GETARGPTR(pFrame, sizeof(GETDLGITEM16), parg16);

    ul = GETHWND16(GetDlgItem(HWND32(parg16->f1),WORD32(parg16->f2)));

    if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_DBASEHANDLEBUG) {
        ((PTDB)SEGPTR(pFrame->wTDB,0))->TDB_CompatHandle = (USHORT) ul;
    }


    FREEARGPTR(parg16);
    RETURN(ul);
}


//**************************************************************************
//  WU32GetMenu -
//
//**************************************************************************

ULONG FASTCALL WU32GetMenu(PVDMFRAME pFrame)
{
    ULONG ul;
    register PGETMENU16 parg16;

    GETARGPTR(pFrame, sizeof(GETMENU16), parg16);

    ul = GETHMENU16(GetMenu(HWND32(parg16->f1)));

    FREEARGPTR(parg16);
    RETURN(ul);
}



//**************************************************************************
//  WU32GetMenuItemCount -
//
//**************************************************************************

ULONG FASTCALL WU32GetMenuItemCount(PVDMFRAME pFrame)
{
    ULONG ul;
    register PGETMENUITEMCOUNT16 parg16;

    GETARGPTR(pFrame, sizeof(GETMENUITEMCOUNT16), parg16);

    ul = GETWORD16(GetMenuItemCount( HMENU32(parg16->f1) ));

    FREEARGPTR(parg16);
    RETURN(ul);
}


//**************************************************************************
//  WU32GetSysColor -
//
//**************************************************************************

ULONG FASTCALL WU32GetSysColor(PVDMFRAME pFrame)
{
    ULONG ul;
    register PGETSYSCOLOR16 parg16;

    GETARGPTR(pFrame, sizeof(GETSYSCOLOR16), parg16);

    ul = GETDWORD16(GetSysColor( INT32(parg16->f1) ));

    FREEARGPTR(parg16);
    RETURN(ul);
}



//**************************************************************************
//  WU32GetSystemMetrics -
//
//**************************************************************************

ULONG FASTCALL WU32GetSystemMetrics(PVDMFRAME pFrame)
{
    ULONG ul;
    register PGETSYSTEMMETRICS16 parg16;
    int     sm;

    GETARGPTR(pFrame, sizeof(GETSYSTEMMETRICS16), parg16);

    sm = INT32(parg16->f1);

    ul = GETINT16(GetSystemMetrics(sm) );

    FREEARGPTR(parg16);
    RETURN(ul);
}


//**************************************************************************
//  WU32GetTopWindow -
//
//**************************************************************************

ULONG FASTCALL WU32GetTopWindow(PVDMFRAME pFrame)
{
    ULONG ul;
    register PGETTOPWINDOW16 parg16;

    GETARGPTR(pFrame, sizeof(GETTOPWINDOW16), parg16);

    ul = GETHWND16(GetTopWindow(HWND32(parg16->f1)));

    FREEARGPTR(parg16);
    RETURN(ul);
}


char szTrayWnd[] = "Shell_TrayWnd";

//**************************************************************************
//  WU32GetWindowRect -
//
//**************************************************************************

ULONG FASTCALL WU32GetWindowRect(PVDMFRAME pFrame)
{
    RECT t2;
    register PGETWINDOWRECT16 parg16;

    GETARGPTR(pFrame, sizeof(GETWINDOWRECT16), parg16);

    /*
     * Home Design Gold 2.0
     *
     * If the call fails, don't overwrite the passed-in
     * rect.
     */
    if (GetWindowRect(HWND32(parg16->f1), &t2)) {

        // Sierra on-line setup hack (expects tray rect to be Classic style)
        // See bug #425058
        // Unfortunately we can't cache the tray hwnd because if explorer dies
        // while the VDM is still running, explorer will get a new hwnd when it
        // is restarted that won't match our cached one.

        // IMHO this could be a general fix and not under an app compat flag
        // in BlackComb.
        if(CURRENTPTD()->dwWOWCompatFlags2 & WOWCF2_FIXLUNATRAYRECT) {

            char szClassName[20];

            if(GetClassName((HWND)parg16->f1,
                            szClassName,
                            sizeof(szClassName))) {

                if(!lstrcmp(szClassName, szTrayWnd)) {

                    // these will only be 0 for the Luna theme
                    if((t2.left == 0) || (t2.top == 0)) {

                        // Find tray position on desktop. Leave the border that
                        // is actually in the desktop alone so that the apps can
                        // calculate their windows accurately.

                        /*******************************************************
                        * Note: IMHO the code that is commented out below could
                        *       be uncommented for BlackComb as it more acurr-
                        *       ately resembles what would be returned in
                        *       Classic view.  Instead, since we are late in the
                        *       cycle for Whistler (RC2), we adjust the bare
                        *       minimum required to fix the known Sierra cases.
                        *
                        * // if tray is at the BOTTOM of the desktop window
                        * if(t2.top > 0) {
                        *     t2.left--;
                        *     t2.right++;
                        *     t2.bottom++;
                        *
                        * // else if the tray is at the RIGHT of desktop window
                        * } else if(t2.left > 0) {
                        *     t2.top--;
                        *     t2.right++;
                        *     t2.bottom++;
                        *
                        * // else if the tray is at the TOP of desktop window
                        * } else if(t2.right > t2.bottom) {
                        *     t2.top--;
                        *     t2.left--;
                        *     t2.right++;
                        *
                        * // else the tray must be at the LEFT of desktop window
                        * } else {
                        *     t2.top--;
                        *     t2.left--;
                        *     t2.bottom++;
                        * }
                        *******************************************************/

                       // if tray is at the BOTTOM of the desktop window
                       if(t2.top > 0)
                           t2.bottom++;

                       // else if the tray is at the TOP of the desktop window
                       else if(t2.right > t2.bottom)
                           t2.top--;
                    }
                }
            }
        }
        PUTRECT16(parg16->f2, &t2);
    }

    FREEARGPTR(parg16);
    RETURN(0);
}



//**************************************************************************
//  WU32IsWindow -
//
//**************************************************************************

ULONG FASTCALL WU32IsWindow(PVDMFRAME pFrame)
{
    ULONG  ul;
    HWND   hWnd;
    register PISWINDOW16 parg16;

    GETARGPTR(pFrame, sizeof(ISWINDOW16), parg16);

    hWnd = HWND32(parg16->f1);

    ul = GETBOOL16(IsWindow(hWnd));

    // For apps that get burned by recycled handles -- ie. the old handle they
    // had has been destroyed & realloc'd to a different window -- not the one
    // they were expecting.  This needs to be handled on an app by app basis.
    if(ul && (CURRENTPTD()->dwWOWCompatFlagsEx & WOWCFEX_FAKENOTAWINDOW)) {

        // NetScape 4.0x install (the bug is in InstallShield)
        // Test the offset portion of the 16:16 return address to this call.
        // Bug #132616 et al
        switch(pFrame->vpCSIP & 0x0000FFFF) {

            case 0x4880:  // (InstallShield 3.00.104.0)
            case 0x44E4:  // (InstallShield 3.00.091.0)

            {
                ULONG  result;
                LPVOID lp;

                // we only want this to fail for calls during Int.Shld cleanup
                // we probably shouldn't fail it if was created by a WOW process
                result = GetWindowLong(hWnd, GWL_WNDPROC);
                if(!IsWOWProc(result)) {
                    goto IW_HACK;
                }

                // extra sanity check: InstallSheild calls GetWindowLong & uses
                // the returned value as a 16:16 ptr
                result = GetWindowLong(hWnd, DWL_MSGRESULT);
                GETVDMPTR(result, sizeof(VPVOID), lp);
                if(!lp) {
                    goto IW_HACK;
                }
                break;
                    
            }
        }
    }

    FREEARGPTR(parg16);
    RETURN(ul);

IW_HACK:
    WOW32WARNMSG((0),"WOW32::IsWindow hack hit!\n");
    RETURN(0);
   
}



//**************************************************************************
//  WU32ScreenToClient -
//
//**************************************************************************

ULONG FASTCALL WU32ScreenToClient(PVDMFRAME pFrame)
{
    POINT t2;
    register PSCREENTOCLIENT16 parg16;

    GETARGPTR(pFrame, sizeof(SCREENTOCLIENT16), parg16);
    GETPOINT16(parg16->f2, &t2);

    ScreenToClient( HWND32(parg16->f1), &t2 );

    PUTPOINT16(parg16->f2, &t2);
    FREEARGPTR(parg16);
    RETURN(0);
}


//**************************************************************************
//  WU32IsChild -
//
//**************************************************************************

ULONG FASTCALL WU32IsChild(PVDMFRAME pFrame)
{
    ULONG ul;
    register PISCHILD16 parg16;

    GETARGPTR(pFrame, sizeof(ISCHILD16), parg16);

    ul = GETBOOL16(IsChild( HWND32(parg16->f1), HWND32(parg16->f2) ));

    FREEARGPTR(parg16);
    RETURN(ul);
}



//**************************************************************************
//  WU32IsIconic -
//
//**************************************************************************

ULONG FASTCALL WU32IsIconic(PVDMFRAME pFrame)
{
    ULONG ul;
    register PISICONIC16 parg16;

    GETARGPTR(pFrame, sizeof(ISICONIC16), parg16);

    ul = GETBOOL16(IsIconic( HWND32(parg16->f1) ));

    FREEARGPTR(parg16);
    RETURN(ul);
}



//**************************************************************************
//  WU32IsWindowEnabled -
//
//**************************************************************************

ULONG FASTCALL WU32IsWindowEnabled(PVDMFRAME pFrame)
{
    ULONG ul;
    register PISWINDOWENABLED16 parg16;

    GETARGPTR(pFrame, sizeof(ISWINDOWENABLED16), parg16);

    ul = GETBOOL16(IsWindowEnabled( HWND32(parg16->f1) ));

    FREEARGPTR(parg16);
    RETURN(ul);
}



//**************************************************************************
//  WU32IsWindowVisible -
//
//**************************************************************************

ULONG FASTCALL WU32IsWindowVisible(PVDMFRAME pFrame)
{
    ULONG ul;
    register PISWINDOWVISIBLE16 parg16;

    GETARGPTR(pFrame, sizeof(ISWINDOWVISIBLE16), parg16);

    ul = GETBOOL16(IsWindowVisible( HWND32(parg16->f1) ));

    FREEARGPTR(parg16);
    RETURN(ul);
}


//**************************************************************************
//  WU32IsZoomed -
//
//**************************************************************************

ULONG FASTCALL WU32IsZoomed(PVDMFRAME pFrame)
{
    ULONG ul;
    register PISZOOMED16 parg16;

    GETARGPTR(pFrame, sizeof(ISZOOMED16), parg16);

    ul = GETBOOL16(IsZoomed( HWND32(parg16->f1) ));

    FREEARGPTR(parg16);
    RETURN(ul);
}



//**************************************************************************
//  WU32GetTickCount -
//
//**************************************************************************

ULONG FASTCALL WU32GetTickCount(PVDMFRAME pFrame)
{
    ULONG   ul;

    UNREFERENCED_PARAMETER(pFrame);

    ul = (ULONG)GetTickCount();

    if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_GRAINYTICS) {

        //
        // round down to the nearest 55ms    this is for RelayGold, which
        // spins calling this API until consecutive calls return a delta
        // greater than 52.
        //

        ul = ul - (ul % 55);
    }

    RETURN(ul);
}



//**************************************************************************
//  On I386 all these functions her handled on clientside. But conditionally
//  they may endup doing the actual work via these thunks.
//
//  So any changes here like 'win31 compatiblity code' may have to be added
//  in mvdm\wow16\user\usercli.asm too.
//
//                                                               - nanduri
//**************************************************************************


//**************************************************************************
//  WU32DefHookProc -
//
//**************************************************************************

ULONG FASTCALL WU32DefHookProc(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    register PDEFHOOKPROC16 parg16;
    HOOKSTATEDATA HkData;
    ULONG hHook16;
    INT iHookCode;
    INT nCode;
    LONG wParam;
    LONG lParam;
    LPINT lpiFunc;

    GETARGPTR(pFrame, sizeof(DEFHOOKPROC16), parg16);

    nCode = INT32(parg16->f1);
    wParam = WORD32(parg16->f2);
    lParam = DWORD32(parg16->f3);

    GETMISCPTR(parg16->f4, lpiFunc);
    hHook16 = FETCHDWORD(*lpiFunc);
    FREEVDMPTR(lpiFunc);

    if (ISVALIDHHOOK(hHook16)) {
        iHookCode = GETHHOOKINDEX(hHook16);
        HkData.iIndex = (BYTE)iHookCode;
        if ( W32GetHookStateData( &HkData ) ) {
            ul = (ULONG)WU32StdDefHookProc(nCode, wParam, lParam, iHookCode);
        }
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


//**************************************************************************
//  WU32GetKeyState -
//
//**************************************************************************

ULONG FASTCALL WU32GetKeyState(PVDMFRAME pFrame)
{
    ULONG ul;
    SHORT sTmp;
    register PGETKEYSTATE16 parg16;

    GETARGPTR(pFrame, sizeof(GETKEYSTATE16), parg16);

    sTmp = GetKeyState(INT32(parg16->f1));

    // compatiblity:
    // MSTEST (testdrvr.exe) tests the bit 0x80 for checking the
    // shift key state. This works in win31 because the keystate in win31 is
    // one byte long and because of similar code below
    //
    // win31 code is similar to:
    //             mov al, byte ptr keystate
    //             cbw
    //             ret
    //
    // if 'al' is 0x80, cbw will make ax = 0xff80 and thus in win31
    // (state & 0x8000) and (state & 0x0080) will work and mean the same.
    //

    ul = (ULONG)((sTmp & 0x8000) ? (sTmp | 0x80) : sTmp);



    FREEARGPTR(parg16);
    RETURN(ul);
}



//**************************************************************************
//  WU32GetKeyboardState -
//
//**************************************************************************

ULONG FASTCALL WU32GetKeyboardState(PVDMFRAME pFrame)
{
    PBYTE pb1;
    register PGETKEYBOARDSTATE16 parg16;

    GETARGPTR(pFrame, sizeof(GETKEYBOARDSTATE16), parg16);
    ALLOCVDMPTR(parg16->f1, 256, pb1);

#ifdef HACK32   // bug 5704
    if (pb1) {
        GetKeyboardState( pb1 );
    }
#else
        GetKeyboardState( pb1 );
#endif

    FLUSHVDMPTR(parg16->f1, 256, pb1);
    FREEVDMPTR(pb1);
    FREEARGPTR(parg16);
    RETURN(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wutbl.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUTBL.H
 *  WOW32 16-bit User API tables
 *
 *  History:
 *  Created 27-Jan-1991 by Jeff Parsons (jeffpar)
--*/



/* User dispatch table
 */
extern W32 aw32User[];



#ifdef DEBUG_OR_WOWPROFILE
extern INT iUserMax;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wutext.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUTEXT.H
 *  WOW32 16-bit User API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/



ULONG FASTCALL WU32GetTabbedTextExtent(PVDMFRAME pFrame);
ULONG FASTCALL WU32TabbedTextOut(PVDMFRAME pFrame);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wutext.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUTEXT.C
 *  WOW32 16-bit User API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/


#include "precomp.h"
#pragma hdrstop

MODNAME(wutext.c);


ULONG FASTCALL WU32GetTabbedTextExtent(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz2;
    PINT p5;
    register PGETTABBEDTEXTEXTENT16 parg16;
    INT BufferT[256];

    GETARGPTR(pFrame, sizeof(GETTABBEDTEXTEXTENT16), parg16);
    GETPSZPTR(parg16->f2, psz2);
    p5 = STACKORHEAPALLOC(parg16->f4 * sizeof(INT), sizeof(BufferT), BufferT);
    getintarray16(parg16->f5, parg16->f4, p5);

    ul = GETDWORD16(GetTabbedTextExtent(HDC32(parg16->f1), psz2,
                     INT32(parg16->f3),  INT32(parg16->f4), p5 ));

    STACKORHEAPFREE(p5, BufferT);
    FREEPSZPTR(psz2);
    FREEARGPTR(parg16);
    RETURN(ul);
}


ULONG FASTCALL WU32TabbedTextOut(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz4;
    PINT p7;
    register PTABBEDTEXTOUT16 parg16;
    INT BufferT[256];

    GETARGPTR(pFrame, sizeof(TABBEDTEXTOUT16), parg16);
    GETPSZPTR(parg16->f4, psz4);
    p7 = STACKORHEAPALLOC(parg16->f6 * sizeof(INT), sizeof(BufferT), BufferT);
    getintarray16(parg16->f7, parg16->f6, p7);

    ul = GETLONG16(TabbedTextOut(
        HDC32(parg16->f1),
        INT32(parg16->f2),
        INT32(parg16->f3),
        psz4,
        INT32(parg16->f5),
        INT32(parg16->f6),
        p7,
        INT32(parg16->f8)
        ));

    STACKORHEAPFREE(p7, BufferT);
    FREEPSZPTR(psz4);
    FREEARGPTR(parg16);
    RETURN(ul);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wutbl2.h ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, 1992, 1993 Microsoft Corporation
 *
 *  WUTBL2.h
 *  WOW32 user API thunks
 *
 *  This file is included into the master thunk table.
 *
--*/


    {W32FUN(UNIMPLEMENTEDAPI,               "DUMMYENTRY",           MOD_USER,      0)},
    {W32FUN(WU32MessageBox,                 "MESSAGEBOX",           MOD_USER,      sizeof(MESSAGEBOX16))},
    {W32FUN(LOCALAPI,                       "OLDEXITWINDOWS",       MOD_USER,      0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "ENABLEOEMLAYER",       MOD_USER,      0)},
    {W32FUN(NOPAPI,                         "DISABLEOEMLAYER",      MOD_USER,      0)},
    {W32FUN(LOCALAPI,                       "INITAPP",              MOD_USER,      0)},
    {W32FUN(WU32PostQuitMessage,            "POSTQUITMESSAGE",      MOD_USER,      sizeof(POSTQUITMESSAGE16))},
    {W32FUN(WU32ExitWindows,                "EXITWINDOWS",          MOD_USER,      sizeof(EXITWINDOWS16))},
    {W32FUN(UNIMPLEMENTED95API,             "PlaySoundEvent",       MOD_USER,      sizeof(PLAYSOUNDEVENT16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                     MOD_USER,      0)},

  /*** 0010 ***/
    {W32FUN(WU32SetTimer,                   "SETTIMER",              MOD_USER,     sizeof(SETTIMER16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "SETSYSTEMTIMER",        MOD_USER,     0)},
    {W32FUN(WU32KillTimer,                  "KILLTIMER",             MOD_USER,     sizeof(KILLTIMER16))},
    {W32FUN(WU32GETTICKCOUNT,               "GETTICKCOUNT",          MOD_USER,     0)},
    {W32FUN(WU32GetTimerResolution,         "GETTIMERRESOLUTION",    MOD_USER,     0)},
    {W32FUN(WU32GETTICKCOUNT,               "GETCURRENTTIME",        MOD_USER,     0)},
    {W32FUN(WU32ClipCursor,                 "CLIPCURSOR",            MOD_USER,     sizeof(CLIPCURSOR16))},
    {W32FUN(WU32GETCURSORPOS,               "GETCURSORPOS",          MOD_USER,     sizeof(GETCURSORPOS16))},
    {W32FUN(WU32SetCapture,                 "SetCapture",            MOD_USER,     sizeof(SETCAPTURE16))},
    {W32FUN(IT(ReleaseCapture),             "ReleaseCapture",        MOD_USER,     0)},

  /*** 0020 ***/
    {W32FUN(IT(SetDoubleClickTime),         "SetDoubleClickTime",    MOD_USER,     sizeof(SETDOUBLECLICKTIME16))},
    {W32FUN(IT(GetDoubleClickTime),         "GetDoubleClickTime",    MOD_USER,     0)},
    {W32FUN(IT(SetFocus),                   "SetFocus",              MOD_USER,     sizeof(SETFOCUS16))},
    {W32FUN(IT(GetFocus),                   "GetFocus",              MOD_USER,     0)},
    {W32FUN(IT(RemoveProp),                 "RemoveProp",            MOD_USER,     sizeof(REMOVEPROP16))},
    {W32FUN(IT(GetProp),                    "GetProp",               MOD_USER,     sizeof(GETPROP16))},
    {W32FUN(IT(SetProp),                    "SetProp",               MOD_USER,     sizeof(SETPROP16))},
    {W32FUN(WU32EnumProps,                  "ENUMPROPS",             MOD_USER,     sizeof(ENUMPROPS16))},
    {W32FUN(WU32CLIENTTOSCREEN,             "CLIENTTOSCREEN",        MOD_USER,     sizeof(CLIENTTOSCREEN16))},
    {W32FUN(WU32SCREENTOCLIENT,             "SCREENTOCLIENT",        MOD_USER,     sizeof(SCREENTOCLIENT16))},

  /*** 0030 ***/
    {W32FUN(WU32WindowFromPoint,            "WindowFromPoint",        MOD_USER,    sizeof(WINDOWFROMPOINT16))},
    {W32FUN(WU32ISICONIC,                   "IsIconic",               MOD_USER,    sizeof(ISICONIC16))},
    {W32FUN(WU32GETWINDOWRECT,              "GetWindowRect",          MOD_USER,    sizeof(GETWINDOWRECT16))},
    {W32FUN(WU32GETCLIENTRECT,              "GetClientRect",          MOD_USER,    sizeof(GETCLIENTRECT16))},
    {W32FUN(IT(EnableWindow),               "EnableWindow",           MOD_USER,    sizeof(ENABLEWINDOW16))},
    {W32FUN(WU32ISWINDOWENABLED,            "IsWindowEnabled",        MOD_USER,    sizeof(ISWINDOWENABLED16))},
    {W32FUN(WU32GetWindowText,              "GetWindowText",          MOD_USER,    sizeof(GETWINDOWTEXT16))},
    {W32FUN(WU32SetWindowText,              "SetWindowText",          MOD_USER,    sizeof(SETWINDOWTEXT16))},
    {W32FUN(IT(GetWindowTextLength),        "GetWindowTextLength",    MOD_USER,    sizeof(GETWINDOWTEXTLENGTH16))},
    {W32FUN(WU32BeginPaint,                 "BEGINPAINT",             MOD_USER,    sizeof(BEGINPAINT16))},

  /*** 0040 ***/
    {W32FUN(WU32EndPaint,                   "ENDPAINT",               MOD_USER,    sizeof(ENDPAINT16))},
    {W32FUN(WU32CreateWindow,               "CreateWindow",           MOD_USER,    sizeof(CREATEWINDOW16))},
    {W32FUN(WU32ShowWindow,                 "ShowWindow",             MOD_USER,    sizeof(SHOWWINDOW16))},
    {W32FUN(IT(CloseWindow),                "CloseWindow",            MOD_USER,    sizeof(CLOSEWINDOW16))},
    {W32FUN(IT(OpenIcon),                   "OpenIcon",               MOD_USER,    sizeof(OPENICON16))},
    {W32FUN(IT(BringWindowToTop),           "BringWindowToTop",       MOD_USER,    sizeof(BRINGWINDOWTOTOP16))},
    {W32FUN(WU32GETPARENT,                  "GetParent",              MOD_USER,    sizeof(GETPARENT16))},
    {W32FUN(WU32ISWINDOW,                   "IsWindow",               MOD_USER,    sizeof(ISWINDOW16))},
    {W32FUN(WU32ISCHILD,                    "ISCHILD",                MOD_USER,    sizeof(ISCHILD16))},
    {W32FUN(WU32ISWINDOWVISIBLE,            "IsWindowVisible",        MOD_USER,    sizeof(ISWINDOWVISIBLE16))},

  /*** 0050 ***/
    {W32FUN(WU32FindWindow,                 "FINDWINDOW",             MOD_USER,    sizeof(FINDWINDOW16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "ISTWOBYTECHARPREFIX",    MOD_USER,    sizeof(ISTWOBYTECHARPREFIX16))},
    {W32FUN(IT(AnyPopup),                   "AnyPopup",               MOD_USER,    0)},
    {W32FUN(WU32DestroyWindow,              "DestroyWindow",          MOD_USER,    sizeof(DESTROYWINDOW16))},
    {W32FUN(WU32EnumWindows,                "EnumWindows",            MOD_USER,    sizeof(ENUMWINDOWS16))},
    {W32FUN(WU32EnumChildWindows,           "EnumChildWindows",       MOD_USER,    sizeof(ENUMCHILDWINDOWS16))},
    {W32FUN(WU32MoveWindow,                 "MoveWindow",             MOD_USER,    sizeof(MOVEWINDOW16))},
    {W32FUN(WU32RegisterClass,              "RegisterClass",          MOD_USER,    sizeof(REGISTERCLASS16))},
    {W32FUN(WU32GETCLASSNAME,               "GetClassName",           MOD_USER,    sizeof(GETCLASSNAME16))},
    {W32FUN(IT(SetActiveWindow),            "SetActiveWindow",        MOD_USER,    sizeof(SETACTIVEWINDOW16))},

  /*** 0060 ***/
    {W32FUN(WU32GetActiveWindow,            "GetActiveWindow",        MOD_USER,    0)},
    {W32FUN(WU32ScrollWindow,               "ScrollWindow",           MOD_USER,    sizeof(SCROLLWINDOW16))},
    {W32FUN(IT(SetScrollPos),               "SetScrollPos",           MOD_USER,    sizeof(SETSCROLLPOS16))},
    {W32FUN(IT(GetScrollPos),               "GetScrollPos",           MOD_USER,    sizeof(GETSCROLLPOS16))},
    {W32FUN(IT(SetScrollRange),             "SetScrollRange",         MOD_USER,    sizeof(SETSCROLLRANGE16))},
    {W32FUN(WU32GetScrollRange,             "GetScrollRange",         MOD_USER,    sizeof(GETSCROLLRANGE16))},
    {W32FUN(WU32GetDC,                      "GetDC",                  MOD_USER,    sizeof(GETDC16))},
    {W32FUN(WU32GetWindowDC,                "GetWindowDC",            MOD_USER,    sizeof(GETWINDOWDC16))},
    {W32FUN(WU32ReleaseDC,                  "ReleaseDC",              MOD_USER,    sizeof(RELEASEDC16))},
    {W32FUN(WU32SetCursor,                  "SetCursor",              MOD_USER,    sizeof(SETCURSOR16))},

  /*** 0070 ***/
    {W32FUN(WU32SetCursorPos,               "SETCURSORPOS",           MOD_USER,    sizeof(SETCURSORPOS16))},
    {W32FUN(WU32ShowCursor,                 "SHOWCURSOR",             MOD_USER,    sizeof(SHOWCURSOR16))},
    {W32FUN(LOCALAPI,                       "SETRECT",                MOD_USER,    sizeof(SETRECT16))},
    {W32FUN(LOCALAPI,                       "SETRECTEMPTY",           MOD_USER,    sizeof(SETRECTEMPTY16))},
    {W32FUN(LOCALAPI,                       "COPYRECT",               MOD_USER,    sizeof(COPYRECT16))},
    {W32FUN(LOCALAPI,                       "ISRECTEMPTY",            MOD_USER,    sizeof(ISRECTEMPTY16))},
    {W32FUN(LOCALAPI,                       "PTINRECT",               MOD_USER,    sizeof(PTINRECT16))},
    {W32FUN(LOCALAPI,                       "OFFSETRECT",             MOD_USER,    sizeof(OFFSETRECT16))},
    {W32FUN(LOCALAPI,                       "INFLATERECT",            MOD_USER,    sizeof(INFLATERECT16))},
    {W32FUN(LOCALAPI,                       "INTERSECTRECT",          MOD_USER,    sizeof(INTERSECTRECT16))},

  /*** 0080 ***/
    {W32FUN(LOCALAPI,                       "UNIONRECT",               MOD_USER,   sizeof(UNIONRECT16))},
    {W32FUN(WU32FillRect,                   "FILLRECT",                MOD_USER,   sizeof(FILLRECT16))},
    {W32FUN(WU32InvertRect,                 "INVERTRECT",              MOD_USER,   sizeof(INVERTRECT16))},
    {W32FUN(WU32FrameRect,                  "FRAMERECT",               MOD_USER,   sizeof(FRAMERECT16))},
    {W32FUN(IT(DrawIcon),                   "DrawIcon",                MOD_USER,   sizeof(DRAWICON16))},
    {W32FUN(WU32DrawText,                   "DrawText",                MOD_USER,   sizeof(DRAWTEXT16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "ICONSIZE",                MOD_USER,   0)},
    {W32FUN(LOCALAPI,                       "DIALOGBOX",               MOD_USER,   sizeof(DIALOGBOX16))},
    {W32FUN(WU32EndDialog,                  "ENDDIALOG",               MOD_USER,   sizeof(ENDDIALOG16))},
    {W32FUN(LOCALAPI,                       "CREATEDIALOG",            MOD_USER,   sizeof(CREATEDIALOG16))},

  /*** 0090 ***/
    {W32FUN(WU32IsDialogMessage,            "ISDIALOGMESSAGE",         MOD_USER,   sizeof(ISDIALOGMESSAGE16))},
    {W32FUN(WU32GETDLGITEM,                 "GETDLGITEM",              MOD_USER,   sizeof(GETDLGITEM16))},
    {W32FUN(WU32SetDlgItemText,             "SETDLGITEMTEXT",          MOD_USER,   sizeof(SETDLGITEMTEXT16))},
    {W32FUN(WU32GetDlgItemText,             "GETDLGITEMTEXT",          MOD_USER,   sizeof(GETDLGITEMTEXT16))},
    {W32FUN(WU32SetDlgItemInt,              "SETDLGITEMINT",           MOD_USER,   sizeof(SETDLGITEMINT16))},
    {W32FUN(WU32GetDlgItemInt,              "GETDLGITEMINT",           MOD_USER,   sizeof(GETDLGITEMINT16))},
    {W32FUN(WU32CheckRadioButton,           "CHECKRADIOBUTTON",        MOD_USER,   sizeof(CHECKRADIOBUTTON16))},
    {W32FUN(WU32CheckDlgButton,             "CHECKDLGBUTTON",          MOD_USER,   sizeof(CHECKDLGBUTTON16))},
    {W32FUN(WU32IsDlgButtonChecked,         "ISDLGBUTTONCHECKED",      MOD_USER,   sizeof(ISDLGBUTTONCHECKED16))},
    {W32FUN(WU32DlgDirSelect,               "DLGDIRSELECT",            MOD_USER,   sizeof(DLGDIRSELECT16))},

  /*** 0100 ***/
    {W32FUN(WU32DlgDirList,                 "DLGDIRLIST",               MOD_USER,  sizeof(DLGDIRLIST16))},
    {W32FUN(WU32SendDlgItemMessage,         "SENDDLGITEMMESSAGE",       MOD_USER,  sizeof(SENDDLGITEMMESSAGE16))},
    {W32FUN(WU32AdjustWindowRect,           "ADJUSTWINDOWRECT",         MOD_USER,  sizeof(ADJUSTWINDOWRECT16))},
    {W32FUN(WU32MapDialogRect,              "MAPDIALOGRECT",            MOD_USER,  sizeof(MAPDIALOGRECT16))},
    {W32FUN(IT(MessageBeep),                "MessageBeep",              MOD_USER,  sizeof(MESSAGEBEEP16))},
    {W32FUN(IT(FlashWindow),                "FlashWindow",              MOD_USER,  sizeof(FLASHWINDOW16))},
    {W32FUN(WU32GetKeyState,                "GETKEYSTATE",              MOD_USER,  sizeof(GETKEYSTATE16))},
    {W32FUN(WU32DefWindowProc,              "DEFWINDOWPROC",            MOD_USER,  sizeof(DEFWINDOWPROC16))},
    {W32FUN(WU32GetMessage,                 "GETMESSAGE",               MOD_USER,  sizeof(GETMESSAGE16))},
    {W32FUN(WU32PeekMessage,                "PEEKMESSAGE",              MOD_USER,  sizeof(PEEKMESSAGE16))},

  /*** 0110 ***/
    {W32FUN(WU32PostMessage,                "POSTMESSAGE",              MOD_USER,  sizeof(POSTMESSAGE16))},
    {W32FUN(WU32SendMessage,                "SENDMESSAGE",              MOD_USER,  sizeof(SENDMESSAGE16))},
    {W32FUN(WU32WaitMessage,                "WAITMESSAGE",              MOD_USER,  0)},
    {W32FUN(WU32TranslateMessage,           "TRANSLATEMESSAGE",         MOD_USER,  sizeof(TRANSLATEMESSAGE16))},
    {W32FUN(WU32DispatchMessage,            "DISPATCHMESSAGE",          MOD_USER,  sizeof(DISPATCHMESSAGE16))},
    {W32FUN(WU32ReplyMessage,               "REPLYMESSAGE",             MOD_USER,  sizeof(REPLYMESSAGE16))},
    {W32FUN(WU32PostAppMessage,             "POSTAPPMESSAGE",           MOD_USER,  sizeof(POSTAPPMESSAGE16))},
    {W32FUN(IT(WindowFromDC),               "WindowFromDC",             MOD_USER,  sizeof(WINDOWFROMDC16))},
    {W32FUN(WU32RegisterWindowMessage,      "RegisterWindowMessage",    MOD_USER,  sizeof(REGISTERWINDOWMESSAGE16))},
    {W32FUN(WU32GetMessagePos,              "GETMESSAGEPOS",            MOD_USER,  0)},

  /*** 0120 ***/
    {W32FUN(WU32GetMessageTime,             "GETMESSAGETIME",           MOD_USER,  0)},
    {W32FUN(WU32SetWindowsHookInternal,     "SETWINDOWSHOOKINTERNAL",   MOD_USER,  sizeof(SETWINDOWSHOOKINTERNAL16))},
    {W32FUN(WU32CallWindowProc,             "CALLWINDOWPROC",           MOD_USER,  sizeof(CALLWINDOWPROC16))},
    {W32FUN(WU32CallMsgFilter,              "CALLMSGFILTER",            MOD_USER,  sizeof(CALLMSGFILTER16))},
    {W32FUN(WU32UpdateWindow,               "UPDATEWINDOW",             MOD_USER,  sizeof(UPDATEWINDOW16))},
    {W32FUN(WU32InvalidateRect,             "INVALIDATERECT",           MOD_USER,  sizeof(INVALIDATERECT16))},
    {W32FUN(WU32InvalidateRgn,              "INVALIDATERGN",            MOD_USER,  sizeof(INVALIDATERGN16))},
    {W32FUN(WU32ValidateRect,               "VALIDATERECT",             MOD_USER,  sizeof(VALIDATERECT16))},
    {W32FUN(WU32ValidateRgn,                "VALIDATERGN",              MOD_USER,  sizeof(VALIDATERGN16))},
    {W32FUN(WU32GetClassWord,               "GETCLASSWORD",             MOD_USER,  sizeof(GETCLASSWORD16))},

  /*** 0130 ***/
    {W32FUN(WU32SetClassWord,               "SETCLASSWORD",             MOD_USER,  sizeof(SETCLASSWORD16))},
    {W32FUN(WU32GetClassLong,               "GETCLASSLONG",             MOD_USER,  sizeof(GETCLASSLONG16))},
    {W32FUN(WU32SetClassLong,               "SETCLASSLONG",             MOD_USER,  sizeof(SETCLASSLONG16))},
    {W32FUN(WU32GetWindowWord,              "GETWINDOWWORD",            MOD_USER,  sizeof(GETWINDOWWORD16))},
    {W32FUN(WU32SetWindowWord,              "SETWINDOWWORD",            MOD_USER,  sizeof(SETWINDOWWORD16))},
    {W32FUN(WU32GetWindowLong,              "GETWINDOWLONG",            MOD_USER,  sizeof(GETWINDOWLONG16))},
    {W32FUN(WU32SetWindowLong,              "SETWINDOWLONG",            MOD_USER,  sizeof(SETWINDOWLONG16))},
    {W32FUN(WU32OpenClipboard,              "OPENCLIPBOARD",            MOD_USER,  sizeof(OPENCLIPBOARD16))},
    {W32FUN(WU32CloseClipboard,             "CLOSECLIPBOARD",           MOD_USER,  0)},
    {W32FUN(WU32EmptyClipboard,             "EMPTYCLIPBOARD",           MOD_USER,  0)},

  /*** 0140 ***/
    {W32FUN(WU32GetClipboardOwner,          "GETCLIPBOARDOWNER",        MOD_USER,  0)},
    {W32FUN(WU32SetClipboardData,           "SETCLIPBOARDDATA",         MOD_USER,  sizeof(SETCLIPBOARDDATA16))},
    {W32FUN(WU32GetClipboardData,           "GETCLIPBOARDDATA",         MOD_USER,  sizeof(GETCLIPBOARDDATA16))},
    {W32FUN(WU32CountClipboardFormats,      "COUNTCLIPBOARDFORMATS",    MOD_USER,  0)},
    {W32FUN(WU32EnumClipboardFormats,       "ENUMCLIPBOARDFORMATS",     MOD_USER,  sizeof(ENUMCLIPBOARDFORMATS16))},
    {W32FUN(WU32RegisterClipboardFormat,    "REGISTERCLIPBOARDFORMAT",  MOD_USER,  sizeof(REGISTERCLIPBOARDFORMAT16))},
    {W32FUN(WU32GetClipboardFormatName,     "GETCLIPBOARDFORMATNAME",   MOD_USER,  sizeof(GETCLIPBOARDFORMATNAME16))},
    {W32FUN(WU32SetClipboardViewer,         "SETCLIPBOARDVIEWER",       MOD_USER,  sizeof(SETCLIPBOARDVIEWER16))},
    {W32FUN(WU32GetClipboardViewer,         "GETCLIPBOARDVIEWER",       MOD_USER,  0)},
    {W32FUN(WU32ChangeClipboardChain,       "CHANGECLIPBOARDCHAIN",     MOD_USER,  sizeof(CHANGECLIPBOARDCHAIN16))},

  /*** 0150 ***/
    {W32FUN(WU32LoadMenu,                   "LOADMENU",                 MOD_USER,  sizeof(LOADMENU16))},
    {W32FUN(WU32CreateMenu,                 "CREATEMENU",               MOD_USER,  0)},
    {W32FUN(WU32DestroyMenu,                "DESTROYMENU",              MOD_USER,  sizeof(DESTROYMENU16))},
    {W32FUN(WU32ChangeMenu,                 "CHANGEMENU",               MOD_USER,  sizeof(CHANGEMENU16))},
    {W32FUN(WU32CheckMenuItem,              "CHECKMENUITEM",            MOD_USER,  sizeof(CHECKMENUITEM16))},
    {W32FUN(IT(EnableMenuItem),             "EnableMenuItem",           MOD_USER,  sizeof(ENABLEMENUITEM16))},
    {W32FUN(WU32GetSystemMenu,              "GETSYSTEMMENU",            MOD_USER,  sizeof(GETSYSTEMMENU16))},
    {W32FUN(WU32GETMENU,                    "GETMENU",                  MOD_USER,  sizeof(GETMENU16))},
    {W32FUN(WU32SetMenu,                    "SETMENU",                  MOD_USER,  sizeof(SETMENU16))},
    {W32FUN(WU32GETSUBMENU,                 "GetSubMenu",               MOD_USER,  sizeof(GETSUBMENU16))},

  /*** 0160 ***/
    {W32FUN(WU32DrawMenuBar,                "DRAWMENUBAR",              MOD_USER,  sizeof(DRAWMENUBAR16))},
    {W32FUN(WU32GetMenuString,              "GETMENUSTRING",            MOD_USER,  sizeof(GETMENUSTRING16))},
    {W32FUN(WU32HiliteMenuItem,             "HILITEMENUITEM",           MOD_USER,  sizeof(HILITEMENUITEM16))},
    {W32FUN(WU32CreateCaret,                "CREATECARET",              MOD_USER,  sizeof(CREATECARET16))},
    {W32FUN(WU32DestroyCaret,               "DESTROYCARET",             MOD_USER,  0)},
    {W32FUN(WU32SetCaretPos,                "SETCARETPOS",              MOD_USER,  sizeof(SETCARETPOS16))},
    {W32FUN(WU32HideCaret,                  "HIDECARET",                MOD_USER,  sizeof(HIDECARET16))},
    {W32FUN(WU32ShowCaret,                  "SHOWCARET",                MOD_USER,  sizeof(SHOWCARET16))},
    {W32FUN(WU32SetCaretBlinkTime,          "SETCARETBLINKTIME",        MOD_USER,  sizeof(SETCARETBLINKTIME16))},
    {W32FUN(WU32GetCaretBlinkTime,          "GETCARETBLINKTIME",        MOD_USER,  0)},

  /*** 0170 ***/
    {W32FUN(IT(ArrangeIconicWindows),       "ArrangeIconicWindows",     MOD_USER,  sizeof(ARRANGEICONICWINDOWS16))},
    {W32FUN(LOCALAPI,                       "WINHELP",                  MOD_USER,  sizeof(WINHELP16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "SWITCHTOTHISWINDOW",       MOD_USER,  0)},
    {W32FUN(WU32LoadCursor,                 "LOADCURSOR",               MOD_USER,  sizeof(LOADCURSOR16))},
    {W32FUN(WU32LoadCursor,                 "LOADICON",                 MOD_USER,  sizeof(LOADICON16))},
    {W32FUN(WU32LoadBitmap,                 "LOADBITMAP",               MOD_USER,  sizeof(LOADBITMAP16))},
    {W32FUN(LOCALAPI,                       "LOADSTRING",               MOD_USER,  sizeof(LOADSTRING16))},
    {W32FUN(LOCALAPI,                       "LOADACCELERATORS",         MOD_USER,  sizeof(LOADACCELERATORS16))},
    {W32FUN(WU32TranslateAccelerator,       "TRANSLATEACCELERATOR",     MOD_USER,  sizeof(TRANSLATEACCELERATOR16))},
    {W32FUN(WU32GETSYSTEMMETRICS,           "GETSYSTEMMETRICS",         MOD_USER,  sizeof(GETSYSTEMMETRICS16))},

  /*** 0180 ***/
    {W32FUN(WU32GETSYSCOLOR,                "GETSYSCOLOR",              MOD_USER,  sizeof(GETSYSCOLOR16))},
    {W32FUN(WU32SetSysColors,               "SETSYSCOLORS",             MOD_USER,  sizeof(SETSYSCOLORS16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "KILLSYSTEMTIMER",          MOD_USER,  0)},
    {W32FUN(WU32GetCaretPos,                "GETCARETPOS",              MOD_USER,  sizeof(GETCARETPOS16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "QUERYSENDMESSAGE",         MOD_USER,  sizeof(QUERYSENDMESSAGE16))},
    {W32FUN(WU32GrayString,                 "GRAYSTRING",               MOD_USER,  sizeof(GRAYSTRING16))},
    {W32FUN(IT(SwapMouseButton),            "SwapMouseButton",          MOD_USER,  sizeof(SWAPMOUSEBUTTON16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "ENDMENU",                  MOD_USER,  0)},
    {W32FUN(LOCALAPI,                       "SETSYSMODALWINDOW",        MOD_USER,  sizeof(SETSYSMODALWINDOW16))},
    {W32FUN(LOCALAPI,                       "GETSYSMODALWINDOW",        MOD_USER,  0)},

  /*** 0190 ***/
    {W32FUN(WU32GetUpdateRect,              "GETUPDATERECT",            MOD_USER, sizeof(GETUPDATERECT16))},
    {W32FUN(WU32ChildWindowFromPoint,       "ChildWindowFromPoint",     MOD_USER, sizeof(CHILDWINDOWFROMPOINT16))},
    {W32FUN(WU32InSendMessage,              "INSENDMESSAGE",            MOD_USER, 0)},
    {W32FUN(WU32IsClipboardFormatAvailable, "ISCLIPBOARDFORMATAVAILABLE",MOD_USER, sizeof(ISCLIPBOARDFORMATAVAILABLE16))},
    {W32FUN(WU32DlgDirSelectComboBox,       "DLGDIRSELECTCOMBOBOX",     MOD_USER, sizeof(DLGDIRSELECTCOMBOBOX16))},
    {W32FUN(WU32DlgDirListComboBox,         "DLGDIRLISTCOMBOBOX",       MOD_USER, sizeof(DLGDIRLISTCOMBOBOX16))},
    {W32FUN(WU32TabbedTextOut,              "TABBEDTEXTOUT",            MOD_USER, sizeof(TABBEDTEXTOUT16))},
    {W32FUN(WU32GetTabbedTextExtent,        "GETTABBEDTEXTEXTENT",      MOD_USER, sizeof(GETTABBEDTEXTEXTENT16))},
    {W32FUN(LOCALAPI,                       "CascadeChildWindows",      MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "TileChildWindows",         MOD_USER, 0)},

  /*** 0200 ***/
    {W32FUN(WU32OpenComm,                   "OPENCOMM",                 MOD_USER,  sizeof(OPENCOMM16))},
    {W32FUN(WU32SetCommState,               "SETCOMMSTATE",             MOD_USER,  sizeof(SETCOMMSTATE16))},
    {W32FUN(WU32GetCommState,               "GETCOMMSTATE",             MOD_USER,  sizeof(GETCOMMSTATE16))},
    {W32FUN(WU32GetCommError,               "GETCOMMERROR",             MOD_USER,  sizeof(GETCOMMERROR16))},
    {W32FUN(WU32ReadComm,                   "READCOMM",                 MOD_USER,  sizeof(READCOMM16))},
    {W32FUN(WU32WriteComm,                  "WRITECOMM",                MOD_USER,  sizeof(WRITECOMM16))},
    {W32FUN(WU32TransmitCommChar,           "TRANSMITCOMMCHAR",         MOD_USER,  sizeof(TRANSMITCOMMCHAR16))},
    {W32FUN(WU32CloseComm,                  "CLOSECOMM",                MOD_USER,  sizeof(CLOSECOMM16))},
    {W32FUN(WU32SetCommEventMask,           "SETCOMMEVENTMASK",         MOD_USER,  sizeof(SETCOMMEVENTMASK16))},
    {W32FUN(WU32GetCommEventMask,           "GETCOMMEVENTMASK",         MOD_USER,  sizeof(GETCOMMEVENTMASK16))},

  /*** 0210 ***/
    {W32FUN(WU32SetCommBreak,               "SETCOMMBREAK",             MOD_USER,  sizeof(SETCOMMBREAK16))},
    {W32FUN(WU32ClearCommBreak,             "CLEARCOMMBREAK",           MOD_USER,  sizeof(CLEARCOMMBREAK16))},
    {W32FUN(WU32UngetCommChar,              "UNGETCOMMCHAR",            MOD_USER,  sizeof(UNGETCOMMCHAR16))},
    {W32FUN(WU32BuildCommDCB,               "BUILDCOMMDCB",             MOD_USER,  sizeof(BUILDCOMMDCB16))},
    {W32FUN(WU32EscapeCommFunction,         "ESCAPECOMMFUNCTION",       MOD_USER,  sizeof(ESCAPECOMMFUNCTION16))},
    {W32FUN(WU32FlushComm,                  "FLUSHCOMM",                MOD_USER,  sizeof(FLUSHCOMM16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "USERSEEUSERDO",            MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "LOOKUPMENUHANDLE",         MOD_USER,  0)},
    {W32FUN(LOCALAPI,                       "DIALOGBOXINDIRECT",        MOD_USER,  sizeof(DIALOGBOXINDIRECT16))},
    {W32FUN(LOCALAPI,                       "CREATEDIALOGINDIRECT",     MOD_USER,  sizeof(CREATEDIALOGINDIRECT16))},

  /*** 0220 ***/
    {W32FUN(WU32LoadMenuIndirect,           "LOADMENUINDIRECT",         MOD_USER,  sizeof(LOADMENUINDIRECT16))},
    {W32FUN(WU32ScrollDC,                   "SCROLLDC",                 MOD_USER,  sizeof(SCROLLDC16))},
    {W32FUN(WU32GetKeyboardState,           "GETKEYBOARDSTATE",         MOD_USER,  sizeof(GETKEYBOARDSTATE16))},
    {W32FUN(WU32SetKeyboardState,           "SETKEYBOARDSTATE",         MOD_USER,  sizeof(SETKEYBOARDSTATE16))},
    {W32FUN(WU32GetWindowTask,              "GETWINDOWTASK",            MOD_USER,  sizeof(GETWINDOWTASK16))},
    {W32FUN(WU32EnumTaskWindows,            "ENUMTASKWINDOWS",          MOD_USER,  sizeof(ENUMTASKWINDOWS16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "LOCKINPUT",                MOD_USER,  sizeof(LOCKINPUT16))},
    {W32FUN(WU32GetNextDlgGroupItem,        "GETNEXTDLGGROUPITEM",      MOD_USER,  sizeof(GETNEXTDLGGROUPITEM16))},
    {W32FUN(WU32GetNextDlgTabItem,          "GETNEXTDLGTABITEM",        MOD_USER,  sizeof(GETNEXTDLGTABITEM16))},
    {W32FUN(WU32GETTOPWINDOW,               "GETTOPWINDOW",             MOD_USER,  sizeof(GETTOPWINDOW16))},

  /*** 0230 ***/
    {W32FUN(WU32GETNEXTWINDOW,              "GetNextWindow",            MOD_USER,  sizeof(GETNEXTWINDOW16))},
    {W32FUN(LOCALAPI,                       "GETSYSTEMDEBUGSTATE",      MOD_USER,  0)},
    {W32FUN(WU32SetWindowPos,               "SetWindowPos",             MOD_USER,  sizeof(SETWINDOWPOS16))},
    {W32FUN(IT(SetParent),                  "SetParent",                MOD_USER,  sizeof(SETPARENT16))},
    {W32FUN(WU32UnhookWindowsHook,          "UnhookWindowsHook",        MOD_USER,  sizeof(UNHOOKWINDOWSHOOK16))},
    {W32FUN(WU32DefHookProc,                "DefHookProc",              MOD_USER,  sizeof(DEFHOOKPROC16))},
    {W32FUN(IT(GetCapture),                 "GetCapture",               MOD_USER,  0)},
    {W32FUN(IT(GetUpdateRgn),               "GetUpdateRgn",             MOD_USER,  sizeof(GETUPDATERGN16))},
    {W32FUN(IT(ExcludeUpdateRgn),           "ExcludeUpdateRgn",         MOD_USER,  sizeof(EXCLUDEUPDATERGN16))},
    {W32FUN(WU32DialogBoxParam,             "DialogBoxParam",           MOD_USER,  sizeof(DIALOGBOXPARAM16))},

  /*** 0240 ***/
    {W32FUN(LOCALAPI,                       "DIALOGBOXINDIRECTPARAM",   MOD_USER,  sizeof(DIALOGBOXINDIRECTPARAM16))},
    {W32FUN(LOCALAPI,                       "CREATEDIALOGPARAM",        MOD_USER,  sizeof(CREATEDIALOGPARAM16))},
    {W32FUN(LOCALAPI,                       "CREATEDIALOGINDIRECTPARAM",MOD_USER,  sizeof(CREATEDIALOGINDIRECTPARAM16))},
    {W32FUN(WU32GetDialogBaseUnits,         "GETDIALOGBASEUNITS",       MOD_USER,  0)},
    {W32FUN(LOCALAPI,                       "EQUALRECT",                MOD_USER,  sizeof(EQUALRECT16))},
    {W32FUN(WU32EnableCommNotification,     "ENABLECOMMNOTIFICATION",   MOD_USER,  sizeof(ENABLECOMMNOTIFICATION16))},
    {W32FUN(WU32ExitWindowsExec,            "EXITWINDOWSEXEC",          MOD_USER,  0)},
    {W32FUN(IT(GetCursor),                  "GetCursor",                MOD_USER,  0)},
    {W32FUN(IT(GetOpenClipboardWindow),     "GetOpenClipboardWindow",   MOD_USER,  0)},
    {W32FUN(IT(GetAsyncKeyState),           "GetAsyncKeyState",         MOD_USER,  sizeof(GETASYNCKEYSTATE16))},

  /*** 0250 ***/
    {W32FUN(WU32GETMENUSTATE,               "GetMenuState",             MOD_USER,  sizeof(GETMENUSTATE16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "SENDDRIVERMESSAGE",        MOD_USER,  sizeof(SENDDRIVERMESSAGE16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "OPENDRIVER",               MOD_USER,  sizeof(OPENDRIVER16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "CLOSEDRIVER",              MOD_USER,  sizeof(CLOSEDRIVER16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "GETDRIVERMODULEHANDLE",    MOD_USER,  sizeof(GETDRIVERMODULEHANDLE16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "DEFDRIVERPROC",            MOD_USER,  sizeof(DEFDRIVERPROC16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "GETDRIVERINFO",            MOD_USER,  sizeof(GETDRIVERINFO16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "GETNEXTDRIVER",            MOD_USER,  sizeof(GETNEXTDRIVER16))},
    {W32FUN(WU32MapWindowPoints,            "MAPWINDOWPOINTS",          MOD_USER,  sizeof(MAPWINDOWPOINTS16))},
    {W32FUN(IT(BeginDeferWindowPos),        "BeginDeferWindowPos",      MOD_USER,  sizeof(BEGINDEFERWINDOWPOS16))},

  /*** 0260 ***/
    {W32FUN(WU32DeferWindowPos,             "DEFERWINDOWPOS",           MOD_USER,  sizeof(DEFERWINDOWPOS16))},
    {W32FUN(WU32EndDeferWindowPos,          "ENDDEFERWINDOWPOS",        MOD_USER,  sizeof(ENDDEFERWINDOWPOS16))},
    {W32FUN(WU32GETWINDOW,                  "GetWindow",                MOD_USER,  sizeof(GETWINDOW16))},
    {W32FUN(WU32GETMENUITEMCOUNT,           "GETMENUITEMCOUNT",         MOD_USER,  sizeof(GETMENUITEMCOUNT16))},
    {W32FUN(WU32GETMENUITEMID,              "GetMenuItemID",            MOD_USER,  sizeof(GETMENUITEMID16))},
    {W32FUN(IT(ShowOwnedPopups),            "ShowOwnedPopups",          MOD_USER,  sizeof(SHOWOWNEDPOPUPS16))},
    {W32FUN(LOCALAPI,                       "SetMessageQueue",          MOD_USER,  sizeof(SETMESSAGEQUEUE16))},
    {W32FUN(IT(ShowScrollBar),              "ShowScrollBar",            MOD_USER,  sizeof(SHOWSCROLLBAR16))},
    {W32FUN(WU32GlobalAddAtom,              "GLOBALADDATOM",            MOD_USER,  sizeof(GLOBALADDATOM16))},
    {W32FUN(WU32GlobalDeleteAtom,           "GLOBALDELETEATOM",         MOD_USER,  sizeof(GLOBALDELETEATOM16))},

  /*** 0270 ***/
    {W32FUN(IT(GlobalFindAtom),             "GlobalFindAtom",           MOD_USER,  sizeof(GLOBALFINDATOM16))},
    {W32FUN(WU32GlobalGetAtomName,          "GLOBALGETATOMNAME",        MOD_USER,  sizeof(GLOBALGETATOMNAME16))},
    {W32FUN(WU32ISZOOMED,                   "ISZOOMED",                 MOD_USER,  sizeof(ISZOOMED16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "CONTROLPANELINFO",         MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "GETNEXTQUEUEWINDOW",       MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "REPAINTSCREEN",            MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "LOCKMYTASK",               MOD_USER,  0)},
    {W32FUN(WU32GetDlgCtrlID,               "GETDLGCTRLID",             MOD_USER,  sizeof(GETDLGCTRLID16))},
    {W32FUN(WU32GETDESKTOPWINDOW,           "GETDESKTOPHWND",           MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "SETDESKPATTERN",           MOD_USER,  0)},

  /*** 0280 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "SETSYSTEMMENU",            MOD_USER,  0)},
    {W32FUN(IT(GetSysColorBrush),           "GetSysColorBrush",         MOD_USER,  sizeof(GETSYSCOLORBRUSH16))},
    {W32FUN(IT(SelectPalette),              "SelectPalette",            MOD_USER,  sizeof(SELECTPALETTE16))},
    {W32FUN(IT(RealizePalette),             "RealizePalette",           MOD_USER,  sizeof(REALIZEPALETTE16))},
    {W32FUN(WU32GetFreeSystemResources,     "GETFREESYSTEMRESOURCES",   MOD_USER,  sizeof(GETFREESYSTEMRESOURCES16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "SETDESKWALLPAPER",         MOD_USER,  0)},
    {W32FUN(WU32GETDESKTOPWINDOW,           "GETDESKTOPWINDOW",         MOD_USER,  0)},
    {W32FUN(IT(GetLastActivePopup),         "GetLastActivePopup",       MOD_USER,  sizeof(GETLASTACTIVEPOPUP16))},
    {W32FUN(IT(GetMessageExtraInfo),        "GetMessageExtraInfo",      MOD_USER,  0)},
    {W32FUN(LOCALAPI,                       "KEYBD_EVENT",              MOD_USER,  0)},

  /*** 0290 ***/
    {W32FUN(WU32RedrawWindow,               "REDRAWWINDOW",             MOD_USER,  sizeof(REDRAWWINDOW16))},
    {W32FUN(WU32SetWindowsHookEx,           "SETWINDOWSHOOKEX",         MOD_USER,  sizeof(SETWINDOWSHOOKEX16))},
    {W32FUN(WU32UnhookWindowsHookEx,        "UNHOOKWINDOWSHOOKEX",      MOD_USER,  sizeof(UNHOOKWINDOWSHOOKEX16))},
    {W32FUN(WU32CallNextHookEx,             "CALLNEXTHOOKEX",           MOD_USER,  sizeof(CALLNEXTHOOKEX16))},
    {W32FUN(IT(LockWindowUpdate),           "LockWindowUpdate",         MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                         MOD_USER,  0)},
    {W32FUN(LOCALAPI,                       "MOUSE_EVENT",              MOD_USER,  0)},

  /*** 0300 ***/
    {W32FUN(UNIMPLEMENTED95API,             "UnloadInstallableDrivers", MOD_USER,  sizeof(UNLOADINSTALLABLEDRIVERS16))},
    {W32FUN(LOCALAPI,                       "EDITWNDPROC",              MOD_USER,  sizeof(SENDMESSAGE16))},
    {W32FUN(LOCALAPI,                       "STATICWNDPROC",            MOD_USER,  sizeof(SENDMESSAGE16))},
    {W32FUN(LOCALAPI,                       "BUTTONWNDPROC",            MOD_USER,  sizeof(SENDMESSAGE16))},
    {W32FUN(LOCALAPI,                       "SBWNDPROC",                MOD_USER,  sizeof(SENDMESSAGE16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "DESKTOPWNDPROC",           MOD_USER,  0)},
    {W32FUN(LOCALAPI,                       "MENUWINDOWPROC",           MOD_USER,  sizeof(SENDMESSAGE16))},
    {W32FUN(LOCALAPI,                       "LBOXCTLWNDPROC",           MOD_USER,  sizeof(SENDMESSAGE16))},
    {W32FUN(WU32DefDlgProc,                 "DEFDLGPROC",               MOD_USER,  sizeof(DEFDLGPROC16))},
    {W32FUN(WU32GetClipCursor,              "GETCLIPCURSOR",            MOD_USER,  sizeof(GETCLIPCURSOR16))},

  /*** 0310 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "CONTSCROLL",               MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "CARETBLINKPROC",           MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "SENDMESSAGE2",             MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "POSTMESSAGE2",             MOD_USER,  0)},
    {W32FUN(WU32SignalProc,                 "SIGNALPROC",               MOD_USER,  sizeof(SIGNALPROC16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "XCSTODS",                  MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "COMPUPDATERECT",           MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "COMPUPDATERGN",            MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "GETWC2",                   MOD_USER,  0)},
    {W32FUN(WU32ScrollWindowEx,             "SCROLLWINDOWEX",           MOD_USER,  sizeof(SCROLLWINDOWEX16))},

  /*** 0320 ***/
    {W32FUN(WU32SysErrorBox,                "SYSERRORBOX",              MOD_USER,  sizeof(SYSERRORBOX16))},
    {W32FUN(WU32SetEventHook,               "SETEVENTHOOK",             MOD_USER,  sizeof(SETEVENTHOOK16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "WINOLDAPPHACKOMATIC",      MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "GETMESSAGE2",              MOD_USER,  0)},
    {W32FUN(WU32FillWindow,                 "FillWindow",               MOD_USER,  sizeof(FILLWINDOW16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "PAINTRECT",                MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "GETCONTROLBRUSH",          MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "KILLTIMER2",               MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "SETTIMER2",                MOD_USER,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "MENUITEMSTATE",            MOD_USER,  0)},

  /*** 0330 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "SETGETKBDSTATE",            MOD_USER, 0)},
    {W32FUN(NOPAPI,                         "EnableHardwareInput",       MOD_USER, sizeof(ENABLEHARDWAREINPUT16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "USERYIELD",                 MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "ISUSERIDLE",                MOD_USER, 0)},
    {W32FUN(IT(GetQueueStatus),             "GetQueueStatus",            MOD_USER, sizeof(GETQUEUESTATUS16))},
    {W32FUN(IT(GetInputState),              "GetInputState",             MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "LOADCURSORICONHANDLER",     MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "GETMOUSEEVENTPROC",         MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},

  /*** 0340 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "WINFARFRAME",               MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "_FFFE_FARFRAME",            MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "GETFILEPORTNAME",           MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "COMBOBOXCTLWNDPROC",        MOD_USER, sizeof(SENDMESSAGE16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "TITLEWNDPROC",              MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "FILEPORTDLGPROC",           MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "SWITCHWNDPROC",             MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},

  /*** 0350 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "TABTHETEXTOUTFORWIMPS",     MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "BROADCASTMESSAGE",          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "LOADDIBCURSORHANDLER",      MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "LOADDIBICONHANDLER",        MOD_USER, 0)},
    {W32FUN(IT(IsMenu),                     "IsMenu",                    MOD_USER, sizeof(ISMENU16))},
    {W32FUN(WU32GetDCEx,                    "GETDCEX",                   MOD_USER, sizeof(GETDCEX16))},

  /*** 0360 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(IT(LookupIconIdFromDirectoryEx),"LookupIconIdFromDirectoryEx",MOD_USER,sizeof(LOOKUPICONIDFROMDIRECTORYEX16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "COPYICON",                  MOD_USER,  sizeof(COPYICON16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "COPYCURSOR",                MOD_USER,  sizeof(COPYCURSOR16))},

  /*** 0370 ***/
    {W32FUN(WU32GetWindowPlacement,         "GETWINDOWPLACEMENT",        MOD_USER, sizeof(GETWINDOWPLACEMENT16))},
    {W32FUN(WU32SetWindowPlacement,         "SETWINDOWPLACEMENT",        MOD_USER, sizeof(SETWINDOWPLACEMENT16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "SUBTRACTRECT",              MOD_USER, sizeof(SUBTRACTRECT16))},
    {W32FUN(UNIMPLEMENTED95API,             "DllEntryPoint",             MOD_USER, sizeof(DLLENTRYPOINT16))},
    {W32FUN(WU32DrawTextEx,                 "DrawTextEx",                MOD_USER, sizeof(DRAWTEXTEX16))},
    {W32FUN(IT(SetMessageExtraInfo),        "SetMessageExtraInfo",       MOD_USER, sizeof(SETMESSAGEEXTRAINFO16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(IT(SetPropEx),                  "SetPropEx",                 MOD_USER, sizeof(SETPROPEX16))},
    {W32FUN(IT(GetPropEx),                  "GetPropEx",                 MOD_USER, sizeof(GETPROPEX16))},

  /*** 0380 ***/
    {W32FUN(IT(RemovePropEx),               "RemovePropEx",              MOD_USER, sizeof(REMOVEPROPEX16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(IT(SetWindowContextHelpId),     "SetWindowContextHelpId",    MOD_USER, sizeof(SETWINDOWCONTEXTHELPID16))},
    {W32FUN(IT(GetWindowContextHelpId),     "GetWindowContextHelpId",    MOD_USER, sizeof(GETWINDOWCONTEXTHELPID16))},
    {W32FUN(IT(SetMenuContextHelpId),       "SetMenuContextHelpId",      MOD_USER, sizeof(SETMENUCONTEXTHELPID16))},
    {W32FUN(IT(GetMenuContextHelpId),       "GetMenuContextHelpId",      MOD_USER, sizeof(GETMENUCONTEXTHELPID16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(IT(LoadImage),                  "LoadImage",                 MOD_USER, sizeof(LOADIMAGE16))},

  /*** 0390 ***/
    {W32FUN(WU32CopyImage,                  "CopyImage",                 MOD_USER, sizeof(COPYIMAGE16))},
    {W32FUN(UNIMPLEMENTED95API,             "SignalProc32",              MOD_USER, sizeof(SIGNALPROC3216))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(IT(DrawIconEx),                 "DrawIconEx",                MOD_USER, sizeof(DRAWICONEX16))},
    {W32FUN(WU32GetIconInfo,                "GetIconInfo",               MOD_USER, sizeof(GETICONINFO16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTED95API,             "RegisterClassEx",           MOD_USER, sizeof(REGISTERCLASSEX16))},
    {W32FUN(UNIMPLEMENTED95API,             "GetClassInfoEx",            MOD_USER, sizeof(GETCLASSINFOEX16))},
    {W32FUN(WU32ChildWindowFromPointEx,     "ChildWindowFromPointEx",    MOD_USER, sizeof(CHILDWINDOWFROMPOINTEX16))},

  /*** 0400 ***/
    {W32FUN(NOPAPI,                         "FinalUserInit",             MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(WU32GetPriorityClipboardFormat, "GETPRIORITYCLIPBOARDFORMAT",MOD_USER, sizeof(GETPRIORITYCLIPBOARDFORMAT16))},
    {W32FUN(IT(UnregisterClass),            "UnregisterClass",           MOD_USER, sizeof(UNREGISTERCLASS16))},
    {W32FUN(WU32GetClassInfo,               "GETCLASSINFO",              MOD_USER, sizeof(GETCLASSINFO16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(WU32CreateCursor,               "CREATECURSOR",              MOD_USER, sizeof(CREATECURSOR16))},
    {W32FUN(WU32CreateIcon,                 "CREATEICON",                MOD_USER, sizeof(CREATEICON16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "CREATECURSORICONINDIRECT",  MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTED95API,             "InitThreadInput",           MOD_USER, sizeof(INITTHREADINPUT16))},

  /*** 0410 ***/
    {W32FUN(WU32InsertMenu,                 "INSERTMENU",                MOD_USER, sizeof(INSERTMENU16))},
    {W32FUN(WU32AppendMenu,                 "APPENDMENU",                MOD_USER, sizeof(APPENDMENU16))},
    {W32FUN(WU32RemoveMenu,                 "REMOVEMENU",                MOD_USER, sizeof(REMOVEMENU16))},
    {W32FUN(WU32DeleteMenu,                 "DELETEMENU",                MOD_USER, sizeof(DELETEMENU16))},
    {W32FUN(WU32ModifyMenu,                 "MODIFYMENU",                MOD_USER, sizeof(MODIFYMENU16))},
    {W32FUN(WU32CreatePopupMenu,            "CREATEPOPUPMENU",           MOD_USER, 0)},
    {W32FUN(WU32TrackPopupMenu,             "TRACKPOPUPMENU",            MOD_USER, sizeof(TRACKPOPUPMENU16))},
    {W32FUN(WU32GetMenuCheckMarkDimensions, "GETMENUCHECKMARKDIMENSIONS",MOD_USER, 0)},
    {W32FUN(WU32SetMenuItemBitmaps,         "SETMENUITEMBITMAPS",        MOD_USER, sizeof(SETMENUITEMBITMAPS16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},

  /*** 0420 ***/
    {W32FUN(LOCALAPI,                       "_WSPRINTF",                 MOD_USER, sizeof(WSPRINTF16))},
    {W32FUN(LOCALAPI,                       "WVSPRINTF",                 MOD_USER, sizeof(WVSPRINTF16))},
    {W32FUN(WU32DlgDirSelectEx,             "DLGDIRSELECTEX",            MOD_USER, sizeof(DLGDIRSELECTEX16))},
    {W32FUN(WU32DlgDirSelectComboBoxEx,     "DLGDIRSELECTCOMBOBOXEX",    MOD_USER, sizeof(DLGDIRSELECTCOMBOBOXEX16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(IT(FindWindowEx),               "FindWindowEx",              MOD_USER, sizeof(FINDWINDOWEX16))},
    {W32FUN(WU32TileWindows,                "TileWindows",               MOD_USER, sizeof(TILEWINDOWS16))},
    {W32FUN(WU32CascadeWindows,             "CascadeWindows",            MOD_USER, sizeof(CASCADEWINDOWS16))},

  /*** 0430 ***/
    {W32FUN(WU32lstrcmp,                    "LSTRCMP",                   MOD_USER, 0)},
    {W32FUN(WU32AnsiUpper,                  "ANSIUPPER",                 MOD_USER, sizeof(ANSIUPPER16))},
    {W32FUN(WU32AnsiLower,                  "ANSILOWER",                 MOD_USER, sizeof(ANSILOWER16))},
    {W32FUN(WU32IsCharAlpha,                "ISCHARALPHA",               MOD_USER, sizeof(ISCHARALPHA16))},
    {W32FUN(WU32IsCharAlphaNumeric,         "ISCHARALPHANUMERIC",        MOD_USER, sizeof(ISCHARALPHANUMERIC16))},
    {W32FUN(WU32IsCharUpper,                "ISCHARUPPER",               MOD_USER, sizeof(ISCHARUPPER16))},
    {W32FUN(WU32IsCharLower,                "ISCHARLOWER",               MOD_USER, sizeof(ISCHARLOWER16))},
    {W32FUN(WU32AnsiUpperBuff,              "ANSIUPPERBUFF",             MOD_USER, sizeof(ANSIUPPERBUFF16))},
    {W32FUN(WU32AnsiLowerBuff,              "ANSILOWERBUFF",             MOD_USER, sizeof(ANSILOWERBUFF16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},

  /*** 0440 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(WU32InsertMenuItem,             "InsertMenuItem",            MOD_USER, sizeof(INSERTMENUITEM16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(WU32GetMenuItemInfo,            "GetMenuItemInfo",           MOD_USER, sizeof(GETMENUITEMINFO16))},
    {W32FUN(LOCALAPI,                       "MDIClientWndProc",          MOD_USER, sizeof(SENDMESSAGE16))},
    {W32FUN(WU32DefFrameProc,               "DefFrameProc",              MOD_USER, sizeof(DEFFRAMEPROC16))},
    {W32FUN(WU32SetMenuItemInfo,            "SetMenuItemInfo",           MOD_USER, sizeof(SETMENUITEMINFO16))},
    {W32FUN(WU32DefMDIChildProc,            "DefMDIChildProc",           MOD_USER, sizeof(DEFMDICHILDPROC16))},
    {W32FUN(WU32DrawAnimatedRects,          "DrawAnimatedRects",         MOD_USER, sizeof(DRAWANIMATEDRECTS16))},
    {W32FUN(WU32DrawState,                  "DrawState",                 MOD_USER, sizeof(DRAWSTATE16))},

  /*** 0450 ***/
    {W32FUN(IT(CreateIconFromResourceEx),   "CreateIconFromResourceEx",  MOD_USER, sizeof(CREATEICONFROMRESOURCEEX16))},
    {W32FUN(WU32TranslateMDISysAccel,       "TRANSLATEMDISYSACCEL",      MOD_USER, sizeof(TRANSLATEMDISYSACCEL16))},
    {W32FUN(WU32CreateWindowEx,             "CREATEWINDOWEX",            MOD_USER, sizeof(CREATEWINDOWEX16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "LBOXCARETBLINKER",          MOD_USER, 0)},
    {W32FUN(WU32AdjustWindowRectEx,         "ADJUSTWINDOWRECTEX",        MOD_USER, sizeof(ADJUSTWINDOWRECTEX16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "GETICONID",                 MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "LOADICONHANDLER",           MOD_USER, 0)},
    {W32FUN(WU32DestroyIcon,                "DESTROYICON",               MOD_USER, sizeof(DESTROYICON16))},
    {W32FUN(WU32DestroyCursor,              "DESTROYCURSOR",             MOD_USER, sizeof(DESTROYCURSOR16))},
    {W32FUN(LOCALAPI,                       "DUMPICON",                  MOD_USER, 0)},

  /*** 0460 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "GETINTERNALWINDOWPOS",      MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "SETINTERNALWINDOWPOS",      MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "CALCCHILDSCROLL",           MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "SCROLLCHILDREN",            MOD_USER, 0)},
    {W32FUN(IT(DragObject),                 "DragObject",                MOD_USER, sizeof(DRAGOBJECT16))},
    {W32FUN(WU32DragDetect,                 "DragDetect",                MOD_USER, sizeof(DRAGDETECT16))},
    {W32FUN(WU32DrawFocusRect,              "DrawFocusRect",             MOD_USER, sizeof(DRAWFOCUSRECT16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},

  /*** 0470 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "STRINGFUNC",                MOD_USER, 0)},
    {W32FUN(WU32lstrcmpi,                   "LSTRCMPI",                  MOD_USER, 0)},
    {W32FUN(WU32AnsiNext,                   "ANSINEXT",                  MOD_USER, sizeof(ANSINEXT16))},
    {W32FUN(WU32AnsiPrev,                   "ANSIPREV",                  MOD_USER, sizeof(ANSIPREV16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(IT(SetScrollInfo),              "SetScrollInfo",             MOD_USER, sizeof(SETSCROLLINFO16))},
    {W32FUN(IT(GetScrollInfo),              "GetScrollInfo",             MOD_USER, sizeof(GETSCROLLINFO16))},
    {W32FUN(IT(GetKeyboardLayoutName),      "GetKeyboardLayoutName",     MOD_USER, sizeof(GETKEYBOARDLAYOUTNAME16))},
    {W32FUN(IT(LoadKeyboardLayout),         "LoadKeyboardLayout",        MOD_USER, sizeof(LOADKEYBOARDLAYOUT16))},
    {W32FUN(WU32MenuItemFromPoint,          "MenuItemFromPoint",         MOD_USER, sizeof(MENUITEMFROMPOINT16))},

  /*** 0480 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(IT(EnableScrollBar),            "EnableSrollBar",            MOD_USER, sizeof(ENABLESCROLLBAR16))},
    {W32FUN(WU32SystemParametersInfo,       "SystemParametersInfo",      MOD_USER, sizeof(SYSTEMPARAMETERSINFO16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},

  /*** 0490 ***/
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(WU32GetAppVer,                  "GetAppVer",                 MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},

  /*** 0500 ***/
    {W32FUN(LOCALAPI,                       "FARCALLNETDRIVER",          MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETOPENJOB",               MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETCLOSEJOB",              MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,               "",                          MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETHOLDJOB",               MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETRELEASEJOB",            MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETCANCELJOB",             MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETSETJOBCOPIES",          MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETWATCHQUEUE",            MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETUNWATCHQUEUE",          MOD_USER, 0)},

  /*** 0510 ***/
    {W32FUN(LOCALAPI,                       "WNETLOCKQUEUEDATA",         MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETUNLOCKQUEUEDATA",       MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETGETCONNECTION",         MOD_USER, sizeof(WNETGETCONNECTION16))},
    {W32FUN(LOCALAPI,                       "WNETGETCAPS",               MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETDEVICEMODE",            MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETBROWSEDIALOG",          MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETGETUSER",               MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETADDCONNECTION",         MOD_USER, sizeof(WNETADDCONNECTION16))},
    {W32FUN(LOCALAPI,                       "WNETCANCELCONNECTION",      MOD_USER, sizeof(WNETCANCELCONNECTION16))},
    {W32FUN(LOCALAPI,                       "WNETGETERROR",              MOD_USER, 0)},

  /*** 0520 ***/
    {W32FUN(LOCALAPI,                       "WNETGETERRORTEXT",          MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETENABLE",                MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETDISABLE",               MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETRESTORECONNECTION",     MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETWRITEJOB",              MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETCONNECTDIALOG",         MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETDISCONNECTDIALOG",      MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETCONNECTIONDIALOG",      MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETVIEWQUEUEDIALOG",       MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETPROPERTYDIALOG",        MOD_USER, 0)},

  /*** 0530 ***/
    {W32FUN(LOCALAPI,                       "WNETGETDIRECTORYTYPE",      MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETDIRECTORYNOTIFY",       MOD_USER, 0)},
    {W32FUN(LOCALAPI,                       "WNETGETPROPERTYTEXT",       MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTED95API,             "WNetInitialize",            MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTED95API,             "WNetLogon",                 MOD_USER, sizeof(WNETLOGON16))},
    {W32FUN(WU32NotifyWow,                  "NOTIFYWOW",                 MOD_USER, sizeof(NOTIFYWOW16))},
    {W32FUN(UNIMPLEMENTEDAPI,               "--Available--",             MOD_USER, 0)},
    {W32FUN(WU32WOWWordBreakProc,           "WOWWordBreakProc",          MOD_USER, sizeof(WOWWORDBREAKPROC16))},
    {W32FUN(WU32MouseEvent,                 "MOUSEEVENT",                MOD_USER, sizeof(MOUSEEVENT16))},
    {W32FUN(WU32KeybdEvent,                 "KEYBDEVENT",                MOD_USER, sizeof(KEYBDEVENT16))},

  /*** 0540 ***/
    {W32FUN(IT(GetShellWindow),             "GetShellWindow",            MOD_USER, 0)},
    {W32FUN(NOPAPI,                         "DoHotKeyStuff",             MOD_USER, sizeof(DOHOTKEYSTUFF16))},
    {W32FUN(NOPAPI,                         "SetCheckCursorTimer",       MOD_USER, sizeof(SETCHECKCURSORTIMER16))},
    {W32FUN(IT(SetMenuDefaultItem),         "SetMenuDefaultItem",        MOD_USER, sizeof(SETMENUDEFAULTITEM16))},
    {W32FUN(UNIMPLEMENTED95API,             "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                          MOD_USER, 0)},

  /*** 0550 ***/
    {W32FUN(UNIMPLEMENTED95API,             "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                          MOD_USER, 0)},
    {W32FUN(UNIMPLEMENTED95API,             "",                          MOD_USER, 0)},
    {W32FUN(IT(DestroyIcon32),              "DestroyIcon32",             MOD_USER, sizeof(DESTROYICON3216))},
    {W32FUN(UNIMPLEMENTED95API,             "BroadcastSystemMessage",    MOD_USER, sizeof(BROADCASTSYSTEMMESSAGE16))},
    {W32FUN(UNIMPLEMENTED95API,             "HackTaskMonitor",           MOD_USER, sizeof(HACKTASKMONITOR16))},
    {W32FUN(UNIMPLEMENTED95API,             "FormatMessage",             MOD_USER, sizeof(FORMATMESSAGE16))},
    {W32FUN(IT(ChangeDisplaySettings),      "ChangeDisplaySettings",     MOD_USER, sizeof(CHANGEDISPLAYSETTINGS16))},
    {W32FUN(IT(GetForegroundWindow),        "GetForegroundWindow",       MOD_USER, 0)},
    {W32FUN(IT(SetForegroundWindow),        "SetForegroundWindow",       MOD_USER, sizeof(SETFOREGROUNDWINDOW16))},

  /*** 0560 ***/
    {W32FUN(IT(EnumDisplaySettings),        "EnumDisplaySettings",       MOD_USER, sizeof(ENUMDISPLAYSETTINGS16))},
    {W32FUN(IT(MsgWaitForMultipleObjects),  "MsgWaitForMultipleObjects", MOD_USER, sizeof(MSGWAITFORMULTIPLEOBJECTS16))},
    {W32FUN(IT(ActivateKeyboardLayout),     "ActivateKeyboardLayout",    MOD_USER, sizeof(ACTIVATEKEYBOARDLAYOUT16))},
    {W32FUN(IT(GetKeyboardLayout),          "GetKeyboardLayout",         MOD_USER, sizeof(GETKEYBOARDLAYOUT16))},
    {W32FUN(IT(GetKeyboardLayoutList),      "GetKeyboardLayoutList",     MOD_USER, sizeof(GETKEYBOARDLAYOUTLIST16))},
    {W32FUN(IT(UnloadKeyboardLayout),       "UnloadKeyboardLayout",      MOD_USER, sizeof(UNLOADKEYBOARDLAYOUT16))},
    {W32FUN(UNIMPLEMENTED95API,             "PostPostedMessages",        MOD_USER, 0)},
    {W32FUN(WU32DrawFrameControl,           "DrawFrameControl",          MOD_USER, sizeof(DRAWFRAMECONTROL16))},
    {W32FUN(UNIMPLEMENTED95API,             "DrawCaptionTemp",           MOD_USER, sizeof(DRAWCAPTIONTEMP16))},
    {W32FUN(NOPAPI,                         "DispatchInput",             MOD_USER, 0)},

  /*** 0570 ***/
    {W32FUN(WU32DrawEdge,                   "DrawEdge",                  MOD_USER, sizeof(DRAWEDGE16))},
    {W32FUN(WU32DrawCaption,                "DrawCaption",               MOD_USER, sizeof(DRAWCAPTION16))},
    {W32FUN(UNIMPLEMENTED95API,             "SetSysColorsTemp",          MOD_USER, sizeof(SETSYSCOLORSTEMP16))},
    {W32FUN(UNIMPLEMENTED95API,             "DrawMenuBarTemp",           MOD_USER, sizeof(DRAWMENUBARTEMP16))},
    {W32FUN(IT(GetMenuDefaultItem),         "GetMenuDefaultItem",        MOD_USER, sizeof(GETMENUDEFAULTITEM16))},
    {W32FUN(WU32GetMenuItemRect,            "GetMenuItemRect",           MOD_USER, sizeof(GETMENUITEMRECT16))},
    {W32FUN(IT(CheckMenuRadioItem),         "CheckMenuRadioItem",        MOD_USER, sizeof(CHECKMENURADIOITEM16))},
    {W32FUN(WU32TrackPopupMenuEx,           "TrackPopupMenuEx",          MOD_USER, sizeof(TRACKPOPUPMENUEX16))},
    {W32FUN(IT(SetWindowRgn),               "SetWindowRgn",              MOD_USER, sizeof(SETWINDOWRGN16))},
    {W32FUN(IT(GetWindowRgn),               "GetWindowRgn",              MOD_USER, sizeof(GETWINDOWRGN16))},

  /*** 0580 ***/
    {W32FUN(UNIMPLEMENTED95API,             "ChooseFont_Callback16",     MOD_USER, sizeof(CHOOSEFONT_CALLBACK1616))},
    {W32FUN(UNIMPLEMENTED95API,             "FindReplace_Callback16",    MOD_USER, sizeof(FINDREPLACE_CALLBACK1616))},
    {W32FUN(UNIMPLEMENTED95API,             "OpenFilename_Callback16",   MOD_USER, sizeof(OPENFILENAME_CALLBACK1616))},
    {W32FUN(UNIMPLEMENTED95API,             "PrintDlg_Callback16",       MOD_USER, sizeof(PRINTDLG_CALLBACK1616))},
    {W32FUN(UNIMPLEMENTED95API,             "ChooseColor_Callback16",    MOD_USER, sizeof(CHOOSECOLOR_CALLBACK1616))},
    {W32FUN(UNIMPLEMENTED95API,             "PeekMessage32",             MOD_USER, sizeof(PEEKMESSAGE3216))},
    {W32FUN(UNIMPLEMENTED95API,             "GetMessage32",              MOD_USER, sizeof(GETMESSAGE3216))},
    {W32FUN(UNIMPLEMENTED95API,             "TranslateMessage32",        MOD_USER, sizeof(TRANSLATEMESSAGE3216))},
    {W32FUN(IT(DispatchMessage32),          "DispatchMessage32",         MOD_USER, sizeof(DISPATCHMESSAGE3216))},
    {W32FUN(UNIMPLEMENTED95API,             "CallMsgFilter32",           MOD_USER, sizeof(CALLMSGFILTER3216))},

  /*** 0590 ***/
    {W32FUN(UNIMPLEMENTED95API,             "IsDialogMessage32",         MOD_USER, sizeof(ISDIALOGMESSAGE3216))},
    {W32FUN(UNIMPLEMENTED95API,             "PostMessage32",             MOD_USER, sizeof(POSTMESSAGE3216))},
    {W32FUN(UNIMPLEMENTED95API,             "PostThreadMessage32",       MOD_USER, sizeof(POSTTHREADMESSAGE3216))},
    {W32FUN(WU32MessageBoxIndirect,         "MessageBoxIndirect",        MOD_USER, sizeof(MESSAGEBOXINDIRECT16))},
    {W32FUN(UNIMPLEMENTED95API,             "InstallIMT",                MOD_USER, sizeof(INSTALLIMT16))},
    {W32FUN(UNIMPLEMENTED95API,             "UninstallIMT",              MOD_USER, sizeof(UNINSTALLIMT16))},
    {W32FUN(WU32WinHelp,                    "Win32WinHelp",              MOD_USER, sizeof(WIN32WINHELP16))},
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wusercli.h ===
//**************************************************************************
// wusercli.h : prototypes for thunks that may be handled on 16bit side
//
//**************************************************************************

ULONG FASTCALL WU32DefHookProc(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetKeyState(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetKeyboardState(PVDMFRAME pFrame);


#define WU32CLIENTTOSCREEN             WU32ClientToScreen
#define WU32GETCLASSNAME               IT(GetClassName)
#define WU32GETCLIENTRECT              WU32GetClientRect
#define WU32GETCURSORPOS               WU32GetCursorPos
#define WU32GETDESKTOPWINDOW           WU32GetDesktopWindow
#define WU32GETDLGITEM                 WU32GetDlgItem
#define WU32GETMENU                    WU32GetMenu
#define WU32GETMENUITEMCOUNT           WU32GetMenuItemCount
#define WU32GETMENUITEMID              IT(GetMenuItemID)
#define WU32GETMENUSTATE               IT(GetMenuState)
#define WU32GETNEXTWINDOW              IT(GetWindow)
#define WU32GETPARENT                  IT(GetParent)
#define WU32GETSUBMENU                 IT(GetSubMenu)
#define WU32GETSYSCOLOR                WU32GetSysColor
#define WU32GETSYSTEMMETRICS           WU32GetSystemMetrics
#define WU32GETTICKCOUNT               WU32GetTickCount
#define WU32GETTOPWINDOW               WU32GetTopWindow
#define WU32GETWINDOW                  IT(GetWindow)
#define WU32GETWINDOWRECT              WU32GetWindowRect
#define WU32ISCHILD                    WU32IsChild
#define WU32ISICONIC                   WU32IsIconic
#define WU32ISWINDOW                   WU32IsWindow 
#define WU32ISWINDOWENABLED            WU32IsWindowEnabled
#define WU32ISWINDOWVISIBLE            IT(IsWindowVisible)
#define WU32ISZOOMED                   WU32IsZoomed
#define WU32SCREENTOCLIENT             WU32ScreenToClient

ULONG FASTCALL WU32ClientToScreen(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetClientRect(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetCursorPos(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetDesktopWindow(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetDlgItem(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetMenu(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetMenuItemCount(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetMenuItemID(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetSysColor(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetSystemMetrics(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetTopWindow(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetWindowRect(PVDMFRAME pFrame);
ULONG FASTCALL WU32ScreenToClient(PVDMFRAME pFrame);
ULONG FASTCALL WU32IsChild(PVDMFRAME pFrame);
ULONG FASTCALL WU32IsIconic(PVDMFRAME pFrame);
ULONG FASTCALL WU32IsWindow(PVDMFRAME pFrame);
ULONG FASTCALL WU32IsWindowEnabled(PVDMFRAME pFrame);
ULONG FASTCALL WU32IsZoomed(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetTickCount(PVDMFRAME pFrame);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wutmr.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUTMR.H
 *  WOW32 16-bit User Timer API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/


/* Types
 */
typedef struct _TMR {       /* tmr */
    LIST_ENTRY TmrList;     // TMRs are stored in a list
    HWND16  hwnd16;	    // 16-bit handle of owning window, if any
    HTASK16 htask16;        // 16-bit handle of owning task
    HWND    hwnd32;         // 32-bit handle of owning window, if any
    WORD    wIndex;         // index into array for this timer
    UINT    dwEventID;      // 32-bit timer ID (as generated by WIN32)
    VPPROC  vpfnTimerProc;  // 16-bit timer proc address
    DWORD   dwTimerProc32;  // 32-bit timer proc address
} TMR, *PTMR, **PPTMR;


/* Function prototypes
 */

VOID CALLBACK W32Timer1(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer2(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer3(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer4(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer5(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer6(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer7(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer8(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer9(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer10(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer11(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer12(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer13(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer14(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer15(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer16(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer17(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer18(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer19(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer20(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer21(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer22(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer23(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer24(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer25(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer26(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer27(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer28(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer29(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer30(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer31(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer32(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer33(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);
VOID CALLBACK W32Timer34(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime);


VOID W32TimerFunc(UINT index, HWND hwnd, UINT idEvent, DWORD dwTime);


VOID    FreeTimer16(PTMR ptmr);
VOID    DestroyTimers16(HTASK16 htask16);

ULONG FASTCALL  WU32KillTimer(PVDMFRAME pFrame);
ULONG FASTCALL  WU32SetTimer(PVDMFRAME pFrame);

PTMR	FindTimer32(HWND16 hwnd, DWORD dwEventID);
PTMR    FindTimer16(HWND16 hwnd, HTASK16 htask16, WORD wEventID);
PTMR    IsDuplicateTimer16(HWND16 hwnd16, HTASK16 htask16, WORD wEventID);
VOID    FreeWindowTimers16(HWND hwnd32);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wutmr.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUTMR.C
 *  WOW32 16-bit User Timer API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
 *          24-Feb-1993 reworked to use array of timer functions - barryb
--*/


#include "precomp.h"
#pragma hdrstop

MODNAME(wutmr.c);

LIST_ENTRY TimerList;

// Element Zero is unused.

STATIC PTMR aptmrWOWTimers[] = {
                                 NULL, NULL, NULL, NULL,
                                 NULL, NULL, NULL, NULL,
                                 NULL, NULL, NULL, NULL,
                                 NULL, NULL, NULL, NULL,
                                 NULL, NULL, NULL, NULL,
                                 NULL, NULL, NULL, NULL,
                                 NULL, NULL, NULL, NULL,
                                 NULL, NULL, NULL, NULL,
                                 NULL, NULL, NULL
                               };


STATIC TIMERPROC afnTimerFuncs[] = {
                        NULL,       W32Timer1,  W32Timer2,  W32Timer3,
                        W32Timer4,  W32Timer5,  W32Timer6,  W32Timer7,
                        W32Timer8,  W32Timer9,  W32Timer10, W32Timer11,
                        W32Timer12, W32Timer13, W32Timer14, W32Timer15,
                        W32Timer16, W32Timer17, W32Timer18, W32Timer19,
                        W32Timer20, W32Timer21, W32Timer22, W32Timer23,
                        W32Timer24, W32Timer25, W32Timer26, W32Timer27,
                        W32Timer28, W32Timer29, W32Timer30, W32Timer31,
                        W32Timer32, W32Timer33, W32Timer34
                        };


/* Timer mapping functions
 *
 * The basic 16-bit timer mapping operations are Add, Find and Free.  When
 * a 16-bit app calls SetTimer, we call Win32's SetTimer with W32TimerProc
 * in place of the 16-bit proc address.  Assuming the timer is successfully
 * allocated, we add the timer to our own table, recording the 16-bit proc
 * address.
 */


//
// Search for a timer by its 16-bit information.  Looks in the list of
// active timers.  If the timer is found by this routine, then SetTimer()
// has been called and KillTimer() has not yet been called.
//
PTMR IsDuplicateTimer16(HWND16 hwnd16, HTASK16 htask16, WORD wIDEvent)
{
    register PTMR ptmr;
    register INT iTimer;

    //
    // Excel calls SetTimer with hwnd==NULL but dispatches the
    // WM_TIMER messages with hwnd!=NULL.  so call it a match if
    // hwnd16!=NULL and ptmr->hwnd16==NULL
    //

    for (iTimer=1; iTimer<NUMEL(aptmrWOWTimers); iTimer++) {

        ptmr = aptmrWOWTimers[iTimer];

        if (ptmr) {
            if (LOWORD(ptmr->dwEventID) == wIDEvent &&
                ptmr->htask16 == htask16 &&
                (ptmr->hwnd16 == hwnd16 || !ptmr->hwnd16)) {

                return ptmr;
            }
        }
    }

    return NULL;
}



//
// This is called to free *ALL* timers created with a given hwnd16
// ie. All timers created by SetTimer(hwnd != NULL, id, duration)
// This should only be called when the hwnd is being destroyed: DestroyWindow()
//
VOID FreeWindowTimers16(HWND hwnd32)
{
    register PTMR ptmr;
    register INT iTimer;
    HAND16 htask16;

    htask16 = CURRENTPTD()->htask16;

    for (iTimer=1; iTimer<NUMEL(aptmrWOWTimers); iTimer++) {

        ptmr = aptmrWOWTimers[iTimer];

        if (ptmr) {
            if (ptmr->htask16 == htask16 && GETHWND16(hwnd32) == ptmr->hwnd16) {

                // we can't wait for Win32 to kill the timer for us during its
                // normal DestroyWindow() handling because it might send another
                // WM_TIMER message which we are now not ready to handle.
                KillTimer(ptmr->hwnd32, ptmr->dwEventID);

                // now free our WOW structures supporting this timer
                FreeTimer16(ptmr);
            }
        }
    }
}





//
// Search for a timer by its 32-bit information.  Looks in the list of
// all timers (including those that have already been killed by KillTimer().
//
//
PTMR FindTimer32(HWND16 hwnd16, DWORD dwIDEvent)
{
    register PTMR ptmr;
    HAND16 htask16;

    htask16 = CURRENTPTD()->htask16;

    //
    // Excel calls SetTimer with hwnd==NULL but dispatches the
    // WM_TIMER messages with hwnd!=NULL.  so call it a match if
    // hwnd16!=NULL and ptmr->hwnd16==NULL
    //

    for (ptmr = (PTMR)TimerList.Flink; ptmr != (PTMR)&TimerList; ptmr = (PTMR)ptmr->TmrList.Flink) {

        if (ptmr->dwEventID == dwIDEvent &&
            ptmr->htask16 == htask16 &&
            (ptmr->hwnd16 == hwnd16 || (hwnd16 && !ptmr->hwnd16))) {

            return ptmr;
        }
    }

    return (PTMR)NULL;
}


//
// Search for a timer by its 16-bit information.  Looks in the list of
// all timers (including those that have already been killed by KillTimer().
//
//
PTMR FindTimer16(HWND16 hwnd16, HTASK16 htask16, WORD wIDEvent)
{
    register PTMR ptmr;

    //
    // Excel calls SetTimer with hwnd==NULL but dispatches the
    // WM_TIMER messages with hwnd!=NULL.  so call it a match if
    // hwnd16!=NULL and ptmr->hwnd16==NULL
    //

    for (ptmr = (PTMR)TimerList.Flink; ptmr != (PTMR)&TimerList; ptmr = (PTMR)ptmr->TmrList.Flink) {

        if (LOWORD(ptmr->dwEventID) == wIDEvent &&
            ptmr->htask16 == htask16 &&
            (ptmr->hwnd16 == hwnd16 || (hwnd16 && !ptmr->hwnd16))) {

            return ptmr;
        }
    }

    return (PTMR)NULL;
}


//
// Search for a killed timer by its 16-bit information.
//
//
PTMR FindKilledTimer16(HWND16 hwnd16, HTASK16 htask16, WORD wIDEvent)
{
    register PTMR ptmr;

    for (ptmr = (PTMR)TimerList.Flink; ptmr != (PTMR)&TimerList; ptmr = (PTMR)ptmr->TmrList.Flink) {

        if (ptmr->wIndex == 0 &&
            ptmr->htask16 == htask16 &&
            ptmr->hwnd16 == hwnd16 &&
            (LOWORD(ptmr->dwEventID) == wIDEvent || !hwnd16)) {
            // 1. the timer has been killed and
            // 2. the timer is in this task and
            // 3. the hwnds match (both might be 0) and
            // 4. the IDs match, or the hwnds are both 0 (in that case,
            //    IDs are ignored)

            return ptmr;
        }
    }

    return (PTMR)NULL;
}


VOID FreeTimer16(PTMR ptmr)
{
    WOW32ASSERT(ptmr->wIndex == 0 || ptmr == aptmrWOWTimers[ptmr->wIndex]);
    aptmrWOWTimers[ptmr->wIndex] = NULL;
    RemoveEntryList(&ptmr->TmrList);
    free_w(ptmr);
}


VOID DestroyTimers16(HTASK16 htask16)
{
    PTMR ptmr, next;

    for (ptmr = (PTMR)TimerList.Flink; ptmr != (PTMR)&TimerList; ptmr = next) {

        next = (PTMR)ptmr->TmrList.Flink;
        if (ptmr->htask16 == htask16) {

            //
            // don't call KillTimer() if the timer was associated with
            // a window and the window is gone, USER has already
            // cleaned it up.
            //

            if (ptmr == aptmrWOWTimers[ptmr->wIndex] && (!ptmr->hwnd32 || IsWindow(ptmr->hwnd32))) {
                if ( KillTimer(ptmr->hwnd32, ptmr->dwEventID) ) {
                    LOGDEBUG(LOG_IMPORTANT,
                       ("DestroyTimers16:Killed %04x\n",ptmr->dwEventID));
                } else {
                    LOGDEBUG(LOG_ERROR,
                       ("DestroyTimers16:FAILED %04x\n",ptmr->dwEventID));
                }
            }
            FreeTimer16(ptmr);
        }

    }
}


VOID W32TimerFunc(UINT index, HWND hwnd, UINT idEvent, DWORD dwTime)
{
    PARM16 Parm16;
    register PTMR ptmr;

    ptmr = aptmrWOWTimers[index];

    if ( !ptmr ) {
        LOGDEBUG(LOG_ALWAYS,("    W32TimerFunc ERROR: cannot find timer %08x\n", idEvent));
        return;
    }

    if (ptmr->dwEventID != idEvent) {
        //
        // This is an extra timer message which was already in the message
        // queue when the app called KillTimer().  The PTMR isn't in the
        // array, but it is still linked into the TimerList.
        //
        LOGDEBUG(LOG_WARNING,("    W32TimerFunc WARNING: Timer %08x called after KillTimer()\n", idEvent));
        for (ptmr = (PTMR)TimerList.Flink; ptmr != (PTMR)&TimerList; ptmr = (PTMR)ptmr->TmrList.Flink) {
            if (ptmr->dwEventID == idEvent) {
                break;
            }
        }

        if ( ptmr == (PTMR)&TimerList ) {
            LOGDEBUG(LOG_ALWAYS,("    W32TimerFunc ERROR: cannot find timer %08x (second case)\n", idEvent));
            return;
        }
    }

    Parm16.WndProc.hwnd   = ptmr->hwnd16;
    Parm16.WndProc.wMsg   = WM_TIMER;
    Parm16.WndProc.wParam = LOWORD(ptmr->dwEventID);
    Parm16.WndProc.lParam = dwTime;
    Parm16.WndProc.hInst  = 0;     // callback16 defaults to ss

    CallBack16(RET_WNDPROC, &Parm16, ptmr->vpfnTimerProc, NULL);
}


/*++
    BOOL KillTimer(<hwnd>, <nIDEvent>)
    HWND <hwnd>;
    INT <nIDEvent>;

    The %KillTimer% function kills the timer event identified by the <hwnd> and
    <nIDEvent> parameters. Any pending WM_TIMER messages associated with the
    timer are removed from the message queue.

    <hwnd>
        Identifies the window associated with the given timer event. This must
        be the same value passed as the hwnd parameter to the SetTimer function
        call that created the timer event.

    <nIDEvent>
        Specifies the timer event to be killed. If the application called
        %SetTimer% with the <hwnd> parameter set to NULL, this must be the event
        identifier returned by %SetTimer%. If the <hwnd> parameter of %SetTimer%
        was a valid window handle, <nIDEvent> must be the value of the
        <nIDEvent> parameter passed to %SetTimer%.

    The return value specifies the outcome of the function. It is TRUE if the
    event was killed. It is FALSE if the %KillTimer% function could not find the
    specified timer event.
--*/

ULONG FASTCALL WU32KillTimer(PVDMFRAME pFrame)
{
    ULONG ul;
    register PTMR ptmr;
    register PKILLTIMER16 parg16;
    HWND16 hwnd16;
    WORD   wIDEvent;
    HAND16 htask16;

    GETARGPTR(pFrame, sizeof(KILLTIMER16), parg16);

    htask16  = CURRENTPTD()->htask16;
    hwnd16   = (HWND16)parg16->f1;
    wIDEvent = parg16->f2;

    ptmr = IsDuplicateTimer16(hwnd16, htask16, wIDEvent);

    if (ptmr) {
        ul = GETBOOL16(KillTimer(ptmr->hwnd32, ptmr->dwEventID));
        aptmrWOWTimers[ptmr->wIndex] = NULL;
        ptmr->wIndex = 0;
    }
    else {
        ul = 0;
        LOGDEBUG(LOG_IMPORTANT,("    WU32KillTimer ERROR: cannot find timer %04x\n", wIDEvent));
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    WORD SetTimer(<hwnd>, <nIDEvent>, <wElapse>, <lpTimerFunc>)
    HWND <hwnd>;
    int <nIDEvent>;
    WORD <wElapse>;
    FARPROC <lpTimerFunc>;

    The %SetTimer% function creates a system timer event. When a timer event
    occurs, Windows passes a WM_TIMER message to the application-supplied
    function specified by the <lpTimerFunc> parameter. The function can then
    process the event. A NULL value for <lpTimerFunc> causes WM_TIMER messages
    to be placed in the application queue.

    <hwnd>
        Identifies the window to be associated with the timer. If hwnd is NULL,
        no window is associated with the timer.

    <nIDEvent>
        Specifies a nonzero timer-event identifier if the <hwnd> parameter
        is not NULL.

    <wElapse>
        Specifies the elapsed time (in milliseconds) between timer
        events.

    <lpTimerFunc>
        Is the procedure-instance address of the function to be
        notified when the timer event takes place. If <lpTimerFunc> is NULL, the
        WM_TIMER message is placed in the application queue, and the %hwnd%
        member of the %MSG% structure contains the <hwnd> parameter given in the
        %SetTimer% function call. See the following Comments section for
        details.

    The return value specifies the integer identifier for the new timer event.
    If the <hwnd> parameter is NULL, an application passes this value to the
    %KillTimer% function to kill the timer event. The return value is zero if
    the timer was not created.

    Timers are a limited global resource; therefore, it is important that an
    application check the value returned by the %SetTimer% function to verify
    that a timer is actually available.

    To install a timer function, %SetTimer% must receive a procedure-instance
    address of the function, and the function must be exported in the
    application's module-definition file. A procedure-instance address can be
    created using the %MakeProcInstance% function.

    The callback function must use the Pascal calling convention and must be
    declared %FAR%.

    Callback Function:

    WORD FAR PASCAL <TimerFunc>(<hwnd>, <wMsg>, <nIDEvent>, <dwTime>)
    HWND <hwnd>;
    WORD <wMsg>;
    int <nIDEvent>;
    DWORD <dwTime>;

    <TimerFunc> is a placeholder for the application-supplied function name. The
    actual name must be exported by including it in an %EXPORTS% statement in
    the application's module-definition file.

    <hwnd>
        Identifies the window associated with the timer event.

    <wMsg>
        Specifies the WM_TIMER message.

    <nIDEvent>
        Specifies the timer's ID.

    <dwTime>
        Specifies the current system time.
--*/

ULONG FASTCALL WU32SetTimer(PVDMFRAME pFrame)
{
    ULONG ul;
    register PTMR ptmr;
    register PSETTIMER16 parg16;
    HWND16  hwnd16;
    WORD    wIDEvent;
    WORD    wElapse;
    DWORD   vpfnTimerProc;
    DWORD   dwTimerProc32;
    HAND16  htask16;
    INT     iTimer;

    GETARGPTR(pFrame, sizeof(SETTIMER16), parg16);

    ul = 0;

    htask16       = CURRENTPTD()->htask16;
    hwnd16        = (HWND16)parg16->f1;
    wIDEvent      = parg16->f2;
    wElapse       = parg16->f3;

    // Don't allow WOW apps to set a timer with a period of less than
    // 55 ms. Myst and Winstone depend on this.
    if (wElapse < 55) wElapse = 55;

    vpfnTimerProc = VPFN32(parg16->f4);

    ptmr = IsDuplicateTimer16(hwnd16, htask16, wIDEvent);

    if (!ptmr) {

        // Loop through the slots in the timer array

        iTimer = 2;
        while (iTimer < NUMEL(aptmrWOWTimers)) {
            /*
            ** Find a slot in the arrays for which
            ** no pointer has yet been allocated.
            */
            if ( !aptmrWOWTimers[iTimer] ) {

                //
                // See if there is already thunking information for this
                // timer.  If there is, delete it from the list of timer
                // info and re-use its memory because this new timer
                // superceeds the old thunking information.
                //
                ptmr = FindKilledTimer16(hwnd16, htask16, wIDEvent);
                if (ptmr) {

                    RemoveEntryList(&ptmr->TmrList);

                } else {

                    // Allocate a TMR structure for the new timer
                    ptmr = malloc_w(sizeof(TMR));

                }

                aptmrWOWTimers[iTimer] = ptmr;

                if (!ptmr) {
                    LOGDEBUG(LOG_ALWAYS,("    WOW32 ERROR: TMR allocation failure\n"));
                    return 0;
                }

                break;          // Fall out into initialization code
            }
            iTimer++;
        }
        if (iTimer >= NUMEL(aptmrWOWTimers)) {
            LOGDEBUG(LOG_ALWAYS,("    WOW32 ERROR: out of timer slots\n"));
            return 0;
        }

        // Initialize the constant parts of the TMR structure (done on 1st SetTimer)
        InsertHeadList(&TimerList, &ptmr->TmrList);
        ptmr->hwnd16    = hwnd16;
        ptmr->hwnd32    = HWND32(hwnd16);
        ptmr->htask16   = htask16;
        ptmr->wIndex    = (WORD)iTimer;
    }


    // Setup the changeable parts of the TMR structure (done for every SetTimer)

    if (vpfnTimerProc) {
        dwTimerProc32 = (DWORD)afnTimerFuncs[ptmr->wIndex];
    } else {
        dwTimerProc32 = (DWORD)NULL;
    }

    ptmr->vpfnTimerProc = vpfnTimerProc;
    ptmr->dwTimerProc32 = dwTimerProc32;

    ul = SetTimer(
                ptmr->hwnd32,
                (UINT)wIDEvent,
                (UINT)wElapse,
                (TIMERPROC)dwTimerProc32 );

    //
    // USER-generated timerID's are between 0x100 and 0x7fff
    //

    WOW32ASSERT(HIWORD(ul) == 0);

    if (ul) {

        ptmr->dwEventID = ul;

        //
        // when hwnd!=NULL and nEventID==0 the API returns 1 to
        // indicate success but the timer's ID is 0 as requested.
        //

        if (!wIDEvent && ptmr->hwnd32)
            ptmr->dwEventID = 0;

    } else {

        // Since the real SetTimer failed, free
        // our local data using simply our own timer ID

        FreeTimer16(ptmr);
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


VOID CALLBACK W32Timer1(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(1, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer2(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(2, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer3(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(3, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer4(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(4, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer5(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(5, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer6(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(6, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer7(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(7, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer8(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(8, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer9(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(9, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer10(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(10, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer11(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(11, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer12(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(12, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer13(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(13, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer14(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(14, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer15(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(15, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer16(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(16, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer17(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(17, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer18(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(18, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer19(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(19, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer20(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(20, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer21(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(21, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer22(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(22, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer23(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(23, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer24(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(24, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer25(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(25, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer26(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(26, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer27(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(27, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer28(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(28, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer29(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(29, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer30(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(30, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer31(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(31, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer32(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(32, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer33(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(33, hwnd, idEvent, dwTime);
}

VOID CALLBACK W32Timer34(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    WOW32ASSERT(msg == WM_TIMER);
    W32TimerFunc(34, hwnd, idEvent, dwTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wwmman.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1994, Microsoft Corporation
 *
 *  WWMMAN.H
 *  WOW32 16-bit WifeMan API support (manually-coded thunks)
 *
 *  History:
 *  Created 17-May-1994 by hiroh
--*/

ULONG FASTCALL	WWM32MiscGetEUDCLeadByteRange(PVDMFRAME pFrame);
unsigned char far * PASCAL SkipWhite(unsigned char far *lpch);
unsigned char far * PASCAL StrtoNum(unsigned char  far *lpch,
                                    unsigned short far *lpus);
unsigned short PASCAL CharToNum(unsigned char ch);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wwmman.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1994, Microsoft Corporation
 *
 *  WWMMAN.C
 *  WOW32 16-bit WifeMan API support (manually-coded thunks)
 *
 *  History:
 *  Created 17-May-1994 by hiroh
 *  Rewrote 12-May-1995 by hideyukn
 *
--*/
#include "precomp.h"
#pragma hdrstop

#ifdef FE_SB

#include "wowwife.h"
#include "wwmman.h"

MODNAME(wwmman.c);

STATIC LPSTR SkipSpaces(LPSTR lpch)
{
    if (lpch == NULL) return(NULL);

    for ( ; ; lpch++ ) {
        switch (*lpch) {
        case ' ':
        case '\t':
        case '\r':
        case '\n':
            break;

        case '\0':
        // fall through...
        default:
            return(lpch);
        }
    }
}

#define EUDC_RANGE_KEY \
   (LPSTR) "SYSTEM\\CurrentControlSet\\Control\\Nls\\CodePage\\EUDCCodeRange"

ULONG FASTCALL WWM32MiscGetEUDCLeadByteRange(PVDMFRAME pFrame)
{
    unsigned short usEUDCRange = 0;
    unsigned char  chEUDCStart = 0, chEUDCEnd = 0;

    HKEY   hKey;
    ULONG  ulRet;
    CHAR   achACP[10];
    CHAR   achRange[256];

    DWORD  dwType;
    DWORD  dwRangeSize = sizeof(achRange);

    UNREFERENCED_PARAMETER(pFrame);

    //
    // Get EUDC Range
    //
    // In Win32, We support multiple EUDC Range, but for
    // Win16, we just return only first EUDC range to
    // keep backward compatibility...
    //

    ulRet = RegOpenKeyExA(HKEY_LOCAL_MACHINE, EUDC_RANGE_KEY,
                          (DWORD) 0, KEY_QUERY_VALUE, &hKey);
 
    if (ulRet != ERROR_SUCCESS) {
        #if DBG
        LOGDEBUG(0,("WOW32:RegOpenKeyExA(EUDC_RANGE_KEY) fail\n"));
        #endif
        return 0;
    }

    //
    // Convert ACP to string..
    //
    RtlIntegerToChar(GetACP(),10,sizeof(achACP),achACP);

    ulRet = RegQueryValueExA(hKey, achACP, (LPDWORD)NULL, (LPDWORD)&dwType,
                             (LPBYTE)achRange, &dwRangeSize);

    if (ulRet != ERROR_SUCCESS) {
        #if DBG
        LOGDEBUG(0,("WOW32:RegQueryValueExA(CP_ACP) fail\n"));
        #endif
        RegCloseKey(hKey);
        return 0;
    }

    RegCloseKey(hKey);

    //
    // Perse the data.
    //
    {
        LPSTR  pszData = achRange;
        USHORT usStart, usEnd;

        pszData = SkipSpaces(pszData);

        if ((*pszData) == '\0') {
            #if DBG
            LOGDEBUG(0,("WOW32:Parse First Data fail\n"));
            #endif
            return 0;
        }

        usStart = (USHORT)strtoul(pszData,&pszData,16);

        if ((pszData = WOW32_strchr(pszData,'-')) == NULL) {
            #if DBG
            LOGDEBUG(0,("WOW32:Find End Data fail\n"));
            #endif
            return 0;
        }

        //
        // Skip '-'..
        //
        pszData++;

        pszData = SkipSpaces(pszData);

        if ((*pszData) == '\0') {
            #if DBG
            LOGDEBUG(0,("WOW32:Parse End Data fail\n"));
            #endif
            return 0;
        }

        usEnd = (USHORT)strtoul(pszData,&pszData,16);

        //
        // Confirm the data sort order is correct
        //
        if (usStart > usEnd) {
            #if DBG
            LOGDEBUG(0,("WOW32:Invalid EUDC Range Order\n"));
            #endif
            return 0;
        }

        //
        // Get EUDC Start, End LeadByte...
        //
        chEUDCStart = HIBYTE(usStart);
        chEUDCEnd   = HIBYTE(usEnd);
    }

    //
    // Setup return value.
    //

    usEUDCRange = ((unsigned short)chEUDCEnd << 8) |
                  ((unsigned short)chEUDCStart     );

    #if DBG
    LOGDEBUG(10,("WOW32:EUDC Range = %x\n",usEUDCRange));
    #endif

    RETURN(usEUDCRange); 
}
#endif // FE_SB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wuwind.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUWIND.H
 *  WOW32 16-bit User API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
--*/


/* Enumeration handler data
 */
typedef struct _WNDDATA {       /* wnddata */
    VPPROC  vpfnEnumWndProc;    // 16-bit enumeration function
    DWORD   dwUserWndParam;     // user param, if any
} WNDDATA, *PWNDDATA;


/* Function prototypes
 */
ULONG FASTCALL WU32AdjustWindowRect(PVDMFRAME pFrame);
ULONG FASTCALL WU32AdjustWindowRectEx(PVDMFRAME pFrame);
ULONG FASTCALL WU32ChildWindowFromPoint(PVDMFRAME pFrame);
ULONG FASTCALL WU32ChildWindowFromPointEx(PVDMFRAME pFrame);
ULONG FASTCALL WU32CreateWindow(PVDMFRAME pFrame);
ULONG FASTCALL WU32CreateWindowEx(PVDMFRAME pFrame);
ULONG FASTCALL W32CreateWindow(PVDMFRAME pFrame);
ULONG FASTCALL WU32DeferWindowPos(PVDMFRAME pFrame);
ULONG FASTCALL WU32DestroyWindow(PVDMFRAME pFrame);
ULONG FASTCALL WU32EndDeferWindowPos(PVDMFRAME pFrame);

BOOL    W32EnumWindowFunc(HWND hwnd, DWORD lParam);

ULONG FASTCALL WU32EnumChildWindows(PVDMFRAME pFrame);
ULONG FASTCALL WU32EnumTaskWindows(PVDMFRAME pFrame);
ULONG FASTCALL WU32EnumWindows(PVDMFRAME pFrame);
ULONG FASTCALL WU32FindWindow(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetActiveWindow(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetWindowDC(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetWindowLong(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetWindowTask(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetWindowText(PVDMFRAME pFrame);
ULONG FASTCALL WU32GetWindowWord(PVDMFRAME pFrame);
ULONG FASTCALL WU32MenuItemFromPoint(PVDMFRAME pFrame);
ULONG FASTCALL WU32MoveWindow(PVDMFRAME pFrame);
ULONG FASTCALL WU32ScrollWindow(PVDMFRAME pFrame);
ULONG FASTCALL WU32SetWindowLong(PVDMFRAME pFrame);
ULONG FASTCALL WU32SetWindowPos(PVDMFRAME pFrame);
ULONG FASTCALL WU32SetWindowText(PVDMFRAME pFrame);
ULONG FASTCALL WU32SetWindowWord(PVDMFRAME pFrame);
ULONG FASTCALL WU32ShowWindow(PVDMFRAME pFrame);
ULONG FASTCALL WU32UpdateWindow(PVDMFRAME pFrame);
ULONG FASTCALL WU32WindowFromPoint(PVDMFRAME pFrame);

ULONG FASTCALL GetGWW_HINSTANCE(HWND hwnd);

extern HWND hwndProgman;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wuwind.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WUWIND.C
 *  WOW32 16-bit User API support
 *
 *  History:
 *  Created 07-Mar-1991 by Jeff Parsons (jeffpar)
 *  12-FEB-92 mattfe changed WU32EnumTaskWindows to access 16 bit TDB
--*/

#include "precomp.h"
#pragma hdrstop

MODNAME(wuwind.c);

// From wumsg.c [SendDlgItemMesssage caching]
extern HWND hdlgSDIMCached ;

// From wuman.c [Identify thunked system class WndProcs]
extern WORD gUser16CS;

// From wkman.c [hinst/hmod for user32]
extern HANDLE ghInstanceUser32;

// dwExStyle is used by the CreateWindow and CreateWindowEx thunks
// so that they can use a common procedure (don't worry, the current
// task cannot be preempted during its use)

STATIC ULONG dwExStyle;

// Some apps (DASHboard from HP) try to get PROGMAN to save its settings
// in a funky way.  This variable is used to help detect these guys.
// Bobday 5/29/93
HWND hwndProgman = (HWND)0;

/*++
    void AdjustWindowRect(<lpRect>, <dwStyle>, <bMenu>)
    LPRECT <lpRect>;
    DWORD <dwStyle>;
    BOOL <bMenu>;

    The %AdjustWindowRect% function computes the required size of the window
    rectangle based on the desired client-rectangle size. The window rectangle
    can then be passed to the %CreateWindow% function to create a window whose
    client area is the desired size. A client rectangle is the smallest
    rectangle that completely encloses a client area. A window rectangle is the
    smallest rectangle that completely encloses the window. The dimensions of
    the resulting window rectangle depend on the window styles and on whether
    the window has a menu.

    <lpRect>
        Points to a %RECT% structure that contains the coordinates of the
        client rectangle.

    <dwStyle>
        Specifies the window styles of the window whose client rectangle
        is to be converted.

    <bMenu>
        Specifies whether the window has a menu.

    This function does not return a value.

    This function assumes a single menu row. If the menu bar wraps to two or
    more rows, the coordinates are incorrect.
--*/

ULONG FASTCALL WU32AdjustWindowRect(PVDMFRAME pFrame)
{
    RECT t1;
    register PADJUSTWINDOWRECT16 parg16;

    GETARGPTR(pFrame, sizeof(ADJUSTWINDOWRECT16), parg16);
    WOW32VERIFY(GETRECT16(parg16->f1, &t1));

    AdjustWindowRect(
        &t1,
        LONG32(parg16->f2),
        BOOL32(parg16->f3)
        );

    PUTRECT16(parg16->f1, &t1);
    FREEARGPTR(parg16);
    RETURN(0);
}


/*++
    void AdjustWindowRectEx(<lpRect>, <dwStyle>, <bMenu>, <dwExStyle>)
    LPRECT <lpRect>;
    DWORD <dwStyle>;
    BOOL <bMenu>;
    DWORD <dwExStyle>;

    The %AdjustWindowRectEx% function computes the required size of the
    rectangle of a window with extended style based on the desired
    client-rectangle size. The window rectangle can then be passed to the
    %CreateWindowEx% function to create a window whose client area is the
    desired size.

    A client rectangle is the smallest rectangle that completely encloses a
    client area. A window rectangle is the smallest rectangle that completely
    encloses the window. The dimensions of the resulting window rectangle
    depends on the window styles and on whether the window has a menu.

    <lpRect>
        Points to a %RECT% structure that contains the coordinates of the
        client rectangle.

    <dwStyle>
        Specifies the window styles of the window whose client rectangle
        is to be converted.

    <bMenu>
        Specifies whether the window has a menu.

    <dwExStyle>
        Specifies the extended style of the window being created.

    This function does not return a value.

    This function assumes a single menu row. If the menu bar wraps to two or
    more rows, the coordinates are incorrect.
--*/

ULONG FASTCALL WU32AdjustWindowRectEx(PVDMFRAME pFrame)
{
    RECT t1;
    register PADJUSTWINDOWRECTEX16 parg16;

    GETARGPTR(pFrame, sizeof(ADJUSTWINDOWRECTEX16), parg16);
    WOW32VERIFY(GETRECT16(parg16->f1, &t1));

    AdjustWindowRectEx(
        &t1,
        LONG32(parg16->f2),
        BOOL32(parg16->f3),
        DWORD32(parg16->f4)
        );

    PUTRECT16(parg16->f1, &t1);
    FREEARGPTR(parg16);
    RETURN(0);
}

/*++
    HWND ChildWindowFromPoint(<hwndParent>, <Point>)
    HWND <hwndParent>;
    POINT <Point>;

    The %ChildWindowFromPoint% function determines which, if any, of the child
    windows belonging to the given parent window contains the specified point.

    <hwndParent>
        Identifies the parent window.

    <Point>
        Specifies the client coordinates of the point to be tested.

    The return value identifies the child window that contains the point. It is
    NULL if the given point lies outside the parent window. If the point is
    within the parent window but is not contained within any child window, the
    handle of the parent window is returned.
--*/

ULONG FASTCALL WU32ChildWindowFromPoint(PVDMFRAME pFrame)
{
    ULONG ul;
    POINT t2;
    register PCHILDWINDOWFROMPOINT16 parg16;

    GETARGPTR(pFrame, sizeof(CHILDWINDOWFROMPOINT16), parg16);
    COPYPOINT16(parg16->f2, t2);

    ul = GETHWND16(ChildWindowFromPoint(HWND32(parg16->f1), t2));

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    HWND ChildWindowFromPointEx(<hwndParent>, <Point>, <Flags>)
    HWND <hwndParent>;
    POINT <Point>;
    UINT <Flags>;

    The %ChildWindowFromPointEx% function determines which, if any, of the child
    windows belonging to the given parent window contains the specified point.

    <hwndParent>
        Identifies the parent window.

    <Point>
        Specifies the client coordinates of the point to be tested.
        
    <Flags>
        Skipping flags

    The return value identifies the child window that contains the point. It is
    NULL if the given point lies outside the parent window. If the point is
    within the parent window but is not contained within any child window, the
    handle of the parent window is returned.
--*/

ULONG FASTCALL WU32ChildWindowFromPointEx(PVDMFRAME pFrame)
{
    ULONG ul;
    POINT pt32;
    register PCHILDWINDOWFROMPOINTEX16 parg16;

    GETARGPTR(pFrame, sizeof(CHILDWINDOWFROMPOINTEX16), parg16);
    COPYPOINT16(parg16->pt, pt32);

    ul = GETHWND16(ChildWindowFromPointEx(HWND32(parg16->hwnd), pt32, DWORD32(parg16->wFlags)));

    FREEARGPTR(parg16);
    RETURN(ul);
}

/*++
    HWND CreateWindow(<lpClassName>, <lpWindowName>, <dwStyle>, <X>, <Y>,
        <nWidth>, <nHeight>, <hwndParent>, <hMenu>, <hInstance>, <lpParam>)
    LPSTR <lpClassName>;
    LPSTR <lpWindowName>;
    DWORD <dwStyle>;
    int <X>;
    int <Y>;
    int <nWidth>;
    int <nHeight>;
    HWND <hwndParent>;
    HMENU <hMenu>;
    HANDLE <hInstance>;
    LPSTR <lpParam>;

    The %CreateWindow% function creates an overlapped, pop-up, or child
    window. The %CreateWindow% function specifies the window class, window
    title, window style, and (optionally) initial position and size of the
    window. The %CreateWindow% function also specifies the window's parent (if
    any) and menu.

    For overlapped, pop-up, and child windows, the %CreateWindow% function sends
    WM_CREATE, WM_GETMINMAXINFO, and WM_NCCREATE messages to the window. The
    <lParam> parameter of the WM_CREATE message contains a pointer to a
    %CREATESTRUCT% structure. If WS_VISIBLE style is given, %CreateWindow%
    sends the window all the messages required to activate and show the window.

    If the window style specifies a title bar, the window title pointed to by
    the <lpWindowName> parameter is displayed in the title bar. When using
    %CreateWindow% to create controls such as buttons, check boxes, and text
    controls, the <lpWindowName> parameter specifies the text of the control.

    <lpClassName>
        Points to a null-terminated string that names the window class. The
        class name can be any name registered with the RegisterClass function or
        any of the predefined control-class names specified in Table T.2,
        "Control Classes."

    <lpWindowName>
        Points to a null-terminated string that represents the window name.

    <dwStyle>
        Specifies the style of window being created. It can be any
        combination of the styles given in Table *** <$R[C#]> ***.3, Window
        Styles the control styles given in Table 4.4, Control Styles, or a
        combination of styles created by using the bitwise OR operator. ,

    <X>
        Specifies the initial <x>-position of the window. For an
        overlapped or pop-up window, the <X> parameter is the initial
        <x>-coordinate of the window's upper-left corner (in screen
        coordinates). If this value is CW_USEDEFAULT, Windows selects the
        default position for the window's upper-left corner. For a child window,
        <X> is the <x>-coordinate of the upper-left corner of the window in the
        client area of its parent window.

    <Y>
        Specifies the initial <y>-position of the window. For an
        overlapped window, the <Y> parameter is the initial <y>-coordinate of
        the window's upper-left corner. For a pop-up window, <Y> is the
        <y>-coordinate (in screen coordinates) of the upper-left corner of the
        pop-up window. For list-box controls, <Y> is the <y>-coordinate of the
        upper-left corner of the control's client area. For a child window, <Y>
        is the <y>-coordinate of the upper-left corner of the child window. All
        of these coordinates are for the window, not the window's client area.

    <nWidth>
        Specifies the width (in device units) of the window. For
        overlapped windows, the <nWidth> parameter is either the window's width
        (in screen coordinates) or CW_USEDEFAULT. If <nWidth> is CW_USEDEFAULT,
        Windows selects a default width and height for the window (the default
        width extends from the initial <x>-position to the right edge of the
        screen, and the default height extends from the initial <y>-position to
        the top of the icon area).

    <nHeight>
        Specifies the height (in device units) of the window. For
        overlapped windows, the <nHeight> parameter is the window's height in
        screen coordinates. If the <nWidth> parameter is CW_USEDEFAULT, Windows
        ignores <nHeight>.

    <hwndParent>
        Identifies the parent or owner window of the window being
        created. A valid window handle must be supplied when creating a child
        window or an owned window. An owned window is an overlapped window that
        is destroyed when its owner window is destroyed, hidden when its owner
        is made iconic, and which is always displayed on top of its owner
        window. For pop-up windows, a handle can be supplied, but is not
        required. If the window does not have a parent or is not owned by
        another window, the <hwndParent> parameter must be set to NULL.

    <hMenu>
        Identifies a menu or a child-window identifier. The meaning
        depends on the window style. For overlapped or pop-up windows, the
        <hMenu> parameter identifies the menu to be used with the window. It can
        be NULL, if the class menu is to be used. For child windows, <hMenu>
        specifies the child-window identifier, an integer value that is used by
        a dialog-box control to notify its parent of events (such as the
        EN_HSCROLL message). The child-window identifier is determined by the
        application and should be unique for all child windows with the same
        parent window.

    <hInstance>
        Identifies the instance of the module to be associated with the
        window.

    <lpParam>
        Points to a value that is passed to the window through the
        %CREATESTRUCT% structure referenced by the <lParam> parameter of
        the WM_CREATE message. If an application is calling %CreateWindow% to
        create a multiple document interface (MDI) client window, <lpParam> must
        point to a %CLIENTCREATESTRUCT% structure.

    The return value identifies the new window. It is NULL if the window is not
    created.

    The %CreateWindow% function sends a WM_CREATE message to to the window
    procedure before it returns.

    For overlapped windows where the <X> parameter is CW_USEDEFAULT, the <Y>
    parameter can be one of the show-style parameters described with the
    %ShowWindow% function, or, for the first overlapped window to be created by
    the application, it can be the <nCmdShow> parameter passed to the WinMain
    function.

    BUTTON
        Designates a small rectangular child window that represents a button the
        user can turn on or off by clicking it. Button controls can be used
        alone or in groups, and can either be labeled or appear without text.
        Button controls typically change appearance when the user clicks them.

    COMBOBOX
        Designates a control consisting of a selection field similar to an edit
        control plus a list box. The list box may be displayed at all times or
        may be dropped down when the user selects a pop box next to the
        selection field.

        Depending on the style of the combo box, the user can or cannot edit the
        contents of the selection field. If the list box is visible, typing
        characters into the selection box will cause the first list box entry
        that matches the characters typed to be highlighted. Conversely,
        selecting an item in the list box displays the selected text in the
        selection field.

    EDIT
        Designates a rectangular child window in which the user can enter text
        from the keyboard. The user selects the control, and gives it the input
        focus by clicking it or moving to it by using the ^TAB^ key. The user
        can enter text when the control displays a flashing caret. The mouse can
        be used to move the cursor and select characters to be replaced, or to
        position the cursor for inserting characters. The ^BACKSPACE^ key can be
        used to delete characters.

        Edit controls use the variable-pitch system font and display ANSI
        characters. Applications compiled to run with previous versions of
        Windows display text with a fixed-pitch system font unless they have
        been marked by the Windows 3.0 %MARK% utility with the %MEMORY FONT%
        option. An application can also send the WM_SETFONT message to the edit
        control to change the default font.

        Edit controls expand tab characters into as many space characters as are
        required to move the cursor to the next tab stop. Tab stops are assumed
        to be at every eighth character position.

    LISTBOX
        Designates a list of character strings. This control is used whenever an
        application needs to present a list of names, such as filenames, that
        the user can view and select. The user can select a string by pointing
        to it and clicking. When a string is selected, it is highlighted and a
        notification message is passed to the parent window. A vertical or
        horizontal scroll bar can be used with a list-box control to scroll
        lists that are too long for the control window. The list box
        automatically hides or shows the scroll bar as needed.

    MDICLIENT
        Designates an MDI client window. The MDI client window receives messages
        which control the MDI application's child windows. The recommended style
        bits are WS_CLIPCHILDREN and WS_CHILD. To create a scrollable MDI client
        window which allows the user to scroll MDI child windows into view, an
        application can also use the WS_HSCROLL and WS_VSCROLL styles.

    SCROLLBAR
        Designates a rectangle that contains a thumb and has direction arrows at
        both ends. The scroll bar sends a notification message to its parent
        window whenever the user clicks the control. The parent window is
        responsible for updating the thumb position, if necessary. Scroll-bar
        controls have the same appearance and function as scroll bars used in
        ordinary windows. Unlike scroll bars, scroll-bar controls can be
        positioned anywhere in a window and used whenever needed to provide
        scrolling input for a window.

        The scroll-bar class also includes size-box controls. A size-box control
        is a small rectangle that the user can expand to change the size of the
        window.

    STATIC
        Designates a simple text field, box, or rectangle that can be used to
        label, box, or separate other controls. Static controls take no input
        and provide no output.

    DS_LOCALEDIT
        Specifies that edit controls in the dialog box will use memory in the
        application's data segment. By default, all edit controls in dialog
        boxes use memory outside the application's data segment. This feature
        may be suppressed by adding the DS_LOCALEDIT flag to the STYLE command
        for the dialog box. If this flag is not used, EM_GETHANDLE and
        EM_SETHANDLE messages must not be used since the storage for the control
        is not in the application's data segment. This feature does not affect
        edit controls created outside of dialog boxes.

    DS_MODALFRAME
        Creates a dialog box with a modal dialog-box frame that can be combined
        with a title bar and System menu by specifying the WS_CAPTION and
        WS_SYSMENU styles.

    DS_NOIDLEMSG
        Suppresses WM_ENTERIDLE messages that Windows would otherwise send to
        the owner of the dialog box while the dialog box is displayed.

    DS_SYSMODAL
        Creates a system-modal dialog box.

    WS_BORDER
        Creates a window that has a border.

    WS_CAPTION
        Creates a window that has a title bar (implies the WS_BORDER style).
        This style cannot be used with the WS_DLGFRAME style.

    WS_CHILD
        Creates a child window. Cannot be used with the WS_POPUP style.

    WS_CHILDWINDOW
        Creates a child window that has the WS_CHILD style.

    WS_CLIPCHILDREN
        Excludes the area occupied by child windows when drawing within the
        parent window. Used when creating the parent window.

    WS_CLIPSIBLINGS
        Clips child windows relative to each other; that is, when a particular
        child window receives a paint message, the WS_CLIPSIBLINGS style clips
        all other overlapped child windows out of the region of the child window
        to be updated. (If WS_CLIPSIBLINGS is not given and child windows
        overlap, it is possible, when drawing within the client area of a child
        window, to draw within the client area of a neighboring child window.)
        For use with the WS_CHILD style only.

    WS_DISABLED
        Creates a window that is initially disabled.

    WS_DLGFRAME
        Creates a window with a double border but no title.

    WS_GROUP
        Specifies the first control of a group of controls in which the user can
        move from one control to the next by using the ^DIRECTION^ keys. All
        controls defined with the WS_GROUP style after the first control belong
        to the same group. The next control with the WS_GROUP style ends the
        style group and starts the next group (that is, one group ends where the
        next begins). Only dialog boxes use this style.

    WS_HSCROLL
        Creates a window that has a horizontal scroll bar.

    WS_ICONIC
        Creates a window that is initially iconic. For use with the
        WS_OVERLAPPED style only.

    WS_MAXIMIZE
        Creates a window of maximum size.

    WS_MAXIMIZEBOX
        Creates a window that has a maximize box.

    WS_MINIMIZE
        Creates a window of minimum size.

    WS_MINIMIZEBOX
        Creates a window that has a minimize box.

    WS_OVERLAPPED
        Creates an overlapped window. An overlapped window has a caption and a
        border.

    WS_OVERLAPPEDWINDOW
        Creates an overlapped window having the WS_OVERLAPPED, WS_CAPTION,
        WS_SYSMENU, WS_THICKFRAME, WS_MINIMIZEBOX, and WS_MAXIMIZEBOX styles.

    WS_POPUP
        Creates a pop-up window. Cannot be used with the WS_CHILD style.

    WS_POPUPWINDOW
        Creates a pop-up window that has the WS_BORDER, WS_POPUP, and WS_SYSMENU
        styles. The WS_CAPTION style must be combined with the WS_POPUPWINDOW
        style to make the system menu visible.

    WS_SYSMENU
        Creates a window that has a System-menu box in its title bar. Used only
        for windows with title bars.

    WS_TABSTOP
        Specifies one of any number of controls through which the user can move
        by using the ^TAB^ key. The ^TAB^ key moves the user to the next control
        specified by the WS_TABSTOP style. Only dialog boxes use this style.

    WS_THICKFRAME
        Creates a window with a thick frame that can be used to size the
        window.

    WS_VISIBLE
        Creates a window that is initially visible. This applies to overlapped
        and pop-up windows. For overlapped windows, the <Y> parameter is used as
        a %ShowWindow% function parameter.

    WS_VSCROLL
        Creates a window that has a vertical scroll bar.
--*/

ULONG FASTCALL WU32CreateWindow(PVDMFRAME pFrame)
{

    dwExStyle = 0;

    // this is a hack for MS Explorapedia -- see bug #189004 -- handle recycling
    // the app destroys this 1st hwnd it squirreled away -- which is the problem
    if(CURRENTPTD()->dwWOWCompatFlagsEx & WOWCF_CREATEBOGUSHWND) {

        // we detect this version by the offset of the return address
        if((pFrame->vpCSIP & 0x0000FFFF) == 0x8DBB)
            W32CreateWindow(pFrame);
    }

    return W32CreateWindow(pFrame);
}


/*++
    HWND CreateWindowEx(<dwExStyle>, <lpszClass>, <lpszName>,
        <dwStyle>, <x>, <y>, <cx>, <cy>, <hwndParent>, <hMenu>,
        <hInstance>, <lpCreateParams>)
    DWORD <dwExStyle>;
    LPSTR <lpszClass>;
    LPSTR <lpszName>;
    DWORD <dwStyle>;
    int <x>;
    int <y>;
    int <cx>;
    int <cy>;
    HWND <hwndParent>;
    HMENU <hMenu>;
    HANDLE <hInstance>;
    LPSTR <lpCreateParams>;

    The %CreateWindowEx% function creates an overlapped, pop-up, or child window
    with an extended style specified in the <dwExStyle> parameter. Otherwise,
    this function is identical to the %CreateWindow% function. See the
    description of the %CreateWindow% function for more information on creating
    a window and for a full descriptions of the other parameters of
    %CreateWindowEx%.

    <dwExStyle>
        Specifies the extended style of the window being created. It may be one
        of the following values:

    WS_EX_DLGMODALFRAME
        Designates a window with a double border that may optionally be created
        with a title bar by specifying the WS_CAPTION style flag in the
        <dwStyle> parameter.

    WS_EX_NOPARENTNOTIFY
        Specifies that a child window created with this style will not send the
        WM_PARENTNOTIFY message to its parent window when the child window is
        created or destroyed.

    WS_EX_TOPMOST
        ???

    WS_EX_ACCEPTFILES
        ???

    <lpszClass>
        Points to a null-terminated string containing the name of the window
        class.

    <lpszName>
        Points to a null-terminated string containing the window name.

    <dwStyle>
        Specifies the style of window being created.

    <x>
        Specifies the initial left side position of the window.

    <y>
        Specifies the initial top position of the window.

    <cx>
        Specifies the width (in device units) of the window.

    <cy>
        Specifies the height (in device units) of the window.

    <hwndParent>
        Identifies the parent or owner window of the window being
        created.

    <hMenu>
        Identifies a menu or a child-window identifier. The meaning
        depends on the window style.

    <hInstance>
        Identifies the instance of the module to be associated with the
        window.

    <lpCreateParams>
        Contains any application-specific creation parameters. The window being
        created may access this data when the %CREATESTRUCT% structure is passed
        to the window via the WM_NCCREATE and WM_CREATE messages.

    The return value identifies the new window. It is NULL if the window is not
    created.

    The %CreateWindowEx% function sends the following messages to the window
    being created:

         WM_NCCREATE
         WM_NCCALCSIZE
         WM_CREATE
         WM_OTHERWINDOWCREATED
--*/

ULONG FASTCALL WU32CreateWindowEx(PVDMFRAME pFrame)
{
    register PCREATEWINDOWEX16 parg16;

    GETARGPTR(pFrame, sizeof(CREATEWINDOWEX16), parg16);
    /*
     * We've had problems with apps setting new (Win 5.0) bits, like WS_EX_LAYERED.
     * This causes Real Bad Problems with thos apps.  Keep Wow apps from doing that.
     *  FritzS
     */
    dwExStyle = DWORD32(parg16->f1) & WS_EX_VALID40;

    FREEARGPTR(parg16);
    RETURN(W32CreateWindow(pFrame));
}
#ifdef FE_SB
// HACK for Director 4.0J
#define MAXNUMOFSTR 20
typedef struct _DIRECTOR {
    HWND   hwnd;            // handle of director window
    UCHAR  orgstr[2];       // application oreginal string
} DIRECTOR, *PDIRECTOR;
DIRECTOR  director[MAXNUMOFSTR];
#endif // FE_SB

ULONG FASTCALL W32CreateWindow(PVDMFRAME pFrame)
{
    PSZ     psz1;
    PSZ     pszClass;
    PSZ     psz2;
    HWND    hwnd32;
    HMENU   hmenu32;
    register PCREATEWINDOW16 parg16;
    CLIENTCREATESTRUCT  clientcreatestruct;
    LPVOID  vpparam;
    CHAR    szAtomName[WOWCLASS_ATOM_NAME];
    DWORD   dwStyle;
#ifdef FE_SB
    PDIRECTOR pdirector;
    unsigned char * pszTmp;
#endif // FE_SB

    GETARGPTR(pFrame, sizeof(CREATEWINDOW16), parg16);
    GETPSZIDPTR(parg16->vpszClass, psz1);
    GETPSZPTR(parg16->vpszWindow, psz2);

    if ( HIWORD(psz1) == 0 ) {
        pszClass = szAtomName;
        GetAtomName( (ATOM)psz1, pszClass, WOWCLASS_ATOM_NAME );
    } else {
        pszClass = psz1;
    }

    //
    // For child windows, the hMenu parameter is just a child window ID
    //
    if (DWORD32(parg16->dwStyle) & WS_CHILD) {
        hmenu32 = (HMENU)parg16->hMenu;

        // Invalidate SendDlgItemMessage cache
        hdlgSDIMCached = NULL ;
    }
    else
        hmenu32 = (HMENU32(parg16->hMenu));

    if (WOW32_stricmp(pszClass, "MDIClient")) {
        vpparam = (LPVOID)DWORD32(parg16->vpParam);
    } else {
        GETCLIENTCREATESTRUCT16(parg16->vpParam, &clientcreatestruct );
        vpparam = &clientcreatestruct;
    }

    dwStyle = DWORD32(parg16->dwStyle);
#ifdef FE_SB
        if (CURRENTPTD()->dwWOWCompatFlagsFE & WOWCF_FE_DIRECTOR_START && psz2) {

            pdirector = director;
            while (pdirector->hwnd)
                   pdirector++;

            for ((PSZ)pszTmp = psz2; *pszTmp; pszTmp++) {
                if (IsDBCSLeadByte(*pszTmp)) {
                    if (*(pszTmp+1) < 0x40 || *(pszTmp+1) > 0xfc) {
                        pdirector->orgstr[0] = *pszTmp;
                        pdirector->orgstr[1] = *(pszTmp+1);
                        *(pszTmp+1) = *pszTmp = 0x7c;
                        pdirector++;
                    }
                    pszTmp++;
                }
            }
        }
#endif // FE_SB

    hwnd32 = (pfnOut.pfnCsCreateWindowEx)(
               dwExStyle,
               pszClass,
               psz2,
               dwStyle,
               INT32DEFAULT(parg16->x),
               INT32DEFAULT(parg16->y),
               INT32DEFAULT(parg16->cx),
               INT32DEFAULT(parg16->cy),
               HWND32(parg16->hwndParent),
               hmenu32,
               HMODINST32(parg16->hInstance),
               vpparam,
               CW_FLAGS_ANSI);
#ifdef FE_SB
    if (CURRENTPTD()->dwWOWCompatFlagsFE & WOWCF_FE_DIRECTOR_START) {

        pdirector = director;

        for (; pdirector->orgstr[0]; pdirector++) {
            if (hwnd32)
                if (!pdirector->hwnd)
                    pdirector->hwnd = hwnd32;
            else
                if (!pdirector->hwnd)
                    pdirector->orgstr[1] = pdirector->orgstr[0] = 0;
        }
    }
#endif // FE_SB

#ifdef DEBUG
    if (hwnd32) {
        CHAR    szClassName[80];

        LOGDEBUG(LOG_WARNING,("  Window %04x created on class = %s\n", GETHWND16(hwnd32),
                (GetClassName(hwnd32, szClassName, sizeof(szClassName)) ? szClassName : "Unknown")));
    } else {
        LOGDEBUG(LOG_WARNING,("  CreateWindow failed, class = %s\n", pszClass));
    }
#endif

    FREEPSZPTR(psz1);
    FREEPSZPTR(psz2);
    FREEARGPTR(parg16);
    RETURN((ULONG) GETHWND16(hwnd32));
}


/*++
    HANDLE BeginDeferWindowPos(<nNumWindows>)
    int <nNumWindows>;

    The %BeginDeferWindowPos% function allocates memory to contain a multiple
    window-position data structure and returns a handle to the structure. The
    %DeferWindowPos% function fills this structure with information about the
    target position for a window that is about to be moved. The
    %EndDeferWindowPos% function accepts this structure and instantaneously
    repositions the windows using the information stored in the structure.

    <nNumWindows>
        Specifies the initial number of windows for which position information
        is to be stored in the structure. The %DeferWindowPos% function
        increases the size of the structure if needed.

    The return value identifies the multiple window-position structure. The
    return value is NULL if system resources are not available to allocate the
    structure.
--*/

ULONG FASTCALL WU32DeferWindowPos(PVDMFRAME pFrame)
{
    ULONG ul = 0;
    HDWP  h32;
    register PDEFERWINDOWPOS16 parg16;

    GETARGPTR(pFrame, sizeof(DEFERWINDOWPOS16), parg16);

    h32 = HDWP32(parg16->f1);

    if ( h32 ) {
      ul = (ULONG) DeferWindowPos(
                     h32,
                     HWND32(parg16->f2),
                     HWNDIA32(parg16->f3),
                     INT32(parg16->f4),
                     INT32(parg16->f5),
                     INT32(parg16->f6),
                     INT32(parg16->f7),
                     WORD32(parg16->f8) & SWP_VALID
                     );
    }
    else {
        goto WDWP_error;
    }

    if (ul != (ULONG) h32) {
        FREEHDWP16(parg16->f1);
        ul = GETHDWP16(ul);
        LOGDEBUG (12, ("WOW::DeferWindowsPos: ul = %08x, h32 = %08x\n", ul, h32));
    }
    else {
        ul = parg16->f1;
        LOGDEBUG (12, ("WOW::DeferWindowsPos: ul = %08x, parg = %08x\n", ul, parg16->f1));
    }
WDWP_error:
    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    BOOL DestroyWindow(<hwnd>)
    HWND <hwnd>;

    The %DestroyWindow% function destroys the specified window. The
    %DestroyWindow% function sends appropriate messages to the window to
    deactivate it and remove the input focus. It also destroys the window's
    menu, flushes the application queue, destroys outstanding timers, removes
    clipboard ownership, and breaks the clipboard-viewer chain, if the window is
    at the top of the viewer chain. It sends WM_DESTROY and WM_NCDESTROY
    messages to the window.

    If the given window is the parent of any windows, these child windows are
    automatically destroyed when the parent window is destroyed. The
    %DestroyWindow% function destroys child windows first, and then the window
    itself.

    The %DestroyWindow% function also destroys modeless dialog boxes created by
    the %CreateDialog% function.

    <hwnd>
        Identifies the window to be destroyed.

    The return value specifies whether or not the specified window is destroyed.
    It is TRUE if the window is destroyed. Otherwise, it is FALSE.

    If the window being destroyed is a top-level window, a
    WM_OTHERWINDOWDESTROYED message will be broadcast to all top-level windows.

    If the window being destroyed is a child window and does not have the
    WS_NOPARENTNOTIFY style set, then a WM_PARENTNOTIFY message is sent to the
    parent.
--*/

ULONG FASTCALL WU32DestroyWindow(PVDMFRAME pFrame)
{
    ULONG ul;
    register PDESTROYWINDOW16 parg16;

    GETARGPTR(pFrame, sizeof(DESTROYWINDOW16), parg16);

    ul = GETBOOL16(DestroyWindow(HWND32(parg16->f1)));

    // Invalidate SendDlgItemMessage cache
    hdlgSDIMCached = NULL ;
#ifdef FE_SB
    if (CURRENTPTD()->dwWOWCompatFlagsFE & WOWCF_FE_DIRECTOR_START) {

        PDIRECTOR pdirector = director;

        for (; pdirector->hwnd; ) {
            if (parg16->f1 == (WORD)pdirector->hwnd) {

                PDIRECTOR ptmp = pdirector;

                do {
                    ptmp->hwnd = (ptmp+1)->hwnd;
                    ptmp->orgstr[0] = (ptmp+1)->orgstr[0];
                    ptmp->orgstr[1] = (ptmp+1)->orgstr[1];
                    ptmp++;
                } while (ptmp->hwnd);
            }
            else
                pdirector++;
        }
    }
#endif // FE_SB

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    void EndDeferWindowPos(<hWinPosInfo>)
    HANDLE <hWinPosInfo>;

    The %EndDeferWindowPos% function simultaneously updates the position and
    size of one or more windows in a single screen-refresh cycle. The
    <hWinPosInfo> parameter identifies a multiple window-position structure that
    contains the update information for the windows. The %DeferWindowPos%
    function stores the update information in the structure; the
    %BeginDeferWindowPos% function creates the initial structure used by these
    functions.

    <hWinPosInfo>
        Identifies a multiple window-position structure that contains size
        and position information for one or more windows. This structure is
        returned by the %BeginDeferWindowPos% function or the most recent call to
        the %DeferWindowPos% function.

    This function does not return a value.
--*/

ULONG FASTCALL WU32EndDeferWindowPos(PVDMFRAME pFrame)
{
    ULONG ul;
    register PENDDEFERWINDOWPOS16 parg16;

    GETARGPTR(pFrame, sizeof(ENDDEFERWINDOWPOS16), parg16);

    ul = (ULONG)EndDeferWindowPos(HDWP32(parg16->f1));
    FREEHDWP16(parg16->f1);

    FREEARGPTR(parg16);
    RETURN(ul);
}


BOOL W32EnumWindowFunc(HWND hwnd, DWORD lParam)
{
    BOOL fReturn;
    PARM16 Parm16;

    WOW32ASSERT(lParam);

    Parm16.EnumWndProc.hwnd = GETHWND16(hwnd);
    STOREDWORD(Parm16.EnumWndProc.lParam, ((PWNDDATA)lParam)->dwUserWndParam);
    CallBack16(RET_ENUMWINDOWPROC, &Parm16, ((PWNDDATA)lParam)->vpfnEnumWndProc, (PVPVOID)&fReturn);

    return (BOOL16)fReturn;
}


/*++
    BOOL EnumChildWindows(<hwndParent>, <lpEnumFunc>, <lParam>)
    HWND <hwndParent>;
    FARPROC <lpEnumFunc>;
    DWORD <lParam>;

    The %EnumChildWindows% function enumerates the child windows that belong to
    the specified parent window by passing the handle of each child window, in
    turn, to the application-supplied callback function pointed to by the
    <lpEnumFunc> parameter.

    The %EnumChildWindows% function continues to enumerate windows until the
    called function returns zero or until the last child window has been
    enumerated.

    <hwndParent>
        Identifies the parent window whose child windows are to be enumerated.

    <lpEnumFunc>
        Is the procedure-instance address of the callback function.

    <lParam>
        Specifies the value to be passed to the callback function for
        the application's use.

    The return value is TRUE if all child windows have been enumerated.
    Otherwise, it is FALSE.

    This function does not enumerate pop-up windows that belong to the
    <hwndParent> parameter.

    The address passed as the <lpEnumFunc> parameter must be created by using
    the %MakeProcInstance% function.

    The callback function must use the Pascal calling convention and must be
    declared %FAR%.

    Callback Function:

    BOOL FAR PASCAL <EnumFunc>(<hwnd>, <lParam>)
    HWND <hwnd>;
    DWORD <lParam>;

    <EnumFunc> is a placeholder for the application-supplied function name. The
    actual name must be exported by including it in an %EXPORTS% statement in
    the application's module-definition file.

    <hwnd>
        Identifies the window handle.

    <lParam>
        Specifies the long parameter argument of the %EnumChildWindows%
        function.

    The callback function should return TRUE to continue enumeration; it should
    return FALSE to stop enumeration.
--*/

ULONG FASTCALL WU32EnumChildWindows(PVDMFRAME pFrame)
{
    ULONG    ul;
    WNDDATA  WndData;
    register PENUMCHILDWINDOWS16 parg16;

    GETARGPTR(pFrame, sizeof(ENUMCHILDWINDOWS16), parg16);

    WndData.vpfnEnumWndProc = DWORD32(parg16->f2);
    WndData.dwUserWndParam  = DWORD32(parg16->f3);

    ul = GETBOOL16(EnumChildWindows(HWND32(parg16->f1),
                                    (WNDENUMPROC)W32EnumWindowFunc,
                                    (LONG)&WndData));
    FREEARGPTR(parg16);
    RETURN(ul);
}



/*++
    BOOL EnumTaskWindows(<hTask>, <lpEnumFunc>, <lParam>)
    HANDLE <hTask>;
    FARPROC <lpEnumFunc>;
    DWORD <lParam>;

    The %EnumTaskWindows% function enumerates all windows associated with the
    <hTask> parameter, which is returned by the %GetCurrentTask% function. (A
    task is any program that executes as an independent unit. All applications
    are executed as tasks and each instance of an application is a task.) The
    enumeration terminates when the callback function, pointed to by
    <lpEnumFunc>, returns FALSE.

    <hTask>
        Identifies the specified task. The GetCurrentTask function returns this
        handle.

    <lpEnumFunc>
        Specifies the procedure-instance address of the window's callback
        function.

    <lParam>
        Specifies the 32-bit value that contains additional parameters
        that are sent to the callback function pointed to by <lpEnumFunc>.

    The return value specifies the outcome of the function. It is TRUE if all
    the windows associated with a particular task are enumerated. Otherwise, it
    is FALSE.

    The callback function must use the Pascal calling convention and must be
    declared %FAR%. The callback function must have the following form:

    Callback Function:

    BOOL FAR PASCAL <EnumFunc>(<hwnd>, <lParam>)
    HWND <hwnd>;
    DWORD <lParam>;

    <EnumFunc> is a placeholder for the application-supplied function name. The
    actual name must be exported by including it in an %EXPORTS% statement in
    the application's module-definition file.

    <hwnd>
        Identifies a window associated with the current task.

    <lParam>
        Specifies the same argument that was passed to the %EnumTaskWindows%
        function.

    The callback function can carry out any desired task. It must return TRUE to
    continue enumeration, or FALSE to stop it.
--*/

ULONG FASTCALL WU32EnumTaskWindows(PVDMFRAME pFrame)
{
    ULONG    ul;
    WNDDATA  WndData;
    register PENUMTASKWINDOWS16 parg16;

    GETARGPTR(pFrame, sizeof(ENUMTASKWINDOWS16), parg16);

    WndData.vpfnEnumWndProc = DWORD32(parg16->f2);
    WndData.dwUserWndParam  = DWORD32(parg16->f3);

    ul = GETBOOL16(EnumThreadWindows(THREADID32(parg16->f1),
                                     (WNDENUMPROC)W32EnumWindowFunc,
                                     (LONG)&WndData));
    FREEARGPTR(parg16);
    RETURN(ul);
}



/*++
    BOOL EnumWindows(<lpEnumFunc>, <lParam>)
    FARPROC <lpEnumFunc>;
    DWORD <lParam>;

    The %EnumWindows% function enumerates all parent windows on the screen by
    passing the handle of each window, in turn, to the callback function pointed
    to by the <lpEnumFunc> parameter. Child windows are not enumerated.

    The %EnumWindows% function continues to enumerate windows until the called
    function returns zero or until the last window has been enumerated.

    <lpEnumFunc>
        Is the procedure-instance address of the callback function. See the
        following "Comments" section for details.

    <lParam>
        Specifies the value to be passed to the callback function for
        the application's use.

    The return value is TRUE if all windows have been enumerated. Otherwise, it
    is FALSE.

    The address passed as the <lpEnumFunc> parameter must be created by using
    the %MakeProcInstance% function.

    The callback function must use the Pascal calling convention and must be
    declared %FAR%. The callback function must have the following form:

    Callback Function:

    BOOL FAR PASCAL <EnumFunc>(<hwnd>, <lParam>)
    HWND <hwnd>;
    DWORD <lParam>;

    <EnumFunc> is a placeholder for the application-supplied function name. The
    actual name must be exported by including it in an %EXPORTS% statement in
    the application's module-definition file.

    <hwnd>
        Identifies the window handle.

    <lParam>
        Specifies the 32-bit argument of the %EnumWindows% function.

    The function must return TRUE to continue enumeration, or FALSE to stop it.
--*/

ULONG FASTCALL WU32EnumWindows(PVDMFRAME pFrame)
{
    ULONG    ul;
    WNDDATA  WndData;
    register PENUMWINDOWS16 parg16;

    GETARGPTR(pFrame, sizeof(ENUMWINDOWS16), parg16);

    WndData.vpfnEnumWndProc = DWORD32(parg16->f1);
    WndData.dwUserWndParam  = DWORD32(parg16->f2);

    ul = GETBOOL16(EnumWindows((WNDENUMPROC)W32EnumWindowFunc, (LONG)&WndData));

    FREEARGPTR(parg16);
    RETURN(ul);
}




/*++
    HWND FindWindow(<lpClassName>, <lpWindowName>)
    LPSTR <lpClassName>;
    LPSTR <lpWindowName>;

    The %FindWindow% function returns the handle of the window whose class is
    given by the <lpClassName> parameter and whose window name, or caption, is
    given by the <lpWindowName> parameter. This function does not search child
    windows.

    <lpClassName>
        Points to a null-terminated string that specifies the window's class
        name. If lpClassName is NULL, all class names match.

    <lpWindowName>
        Points to a null-terminated string that specifies the window name (the
        window's text caption). If <lpWindowName> is NULL, all window names
        match.

    The return value identifies the window that has the specified class name and
    window name. It is NULL if no such window is found.
--*/

ULONG FASTCALL WU32FindWindow(PVDMFRAME pFrame)
{
    ULONG ul;
    PSZ psz1;
    PSZ psz2;
    PSZ pszClass;
    register PFINDWINDOW16 parg16;
    CHAR    szAtomName[WOWCLASS_ATOM_NAME];

    GETARGPTR(pFrame, sizeof(FINDWINDOW16), parg16);
    GETPSZIDPTR(parg16->f1, psz1);
    GETOPTPTR(parg16->f2, 0, psz2);

    if ( psz1 && HIWORD(psz1) == 0 ) {
        pszClass = szAtomName;
        GetAtomName( (ATOM)psz1, pszClass, WOWCLASS_ATOM_NAME );
    } else {
        pszClass = psz1;
    }


    // Some apps during their installation try to find Program Manager's
    // window handle by doing FindWindow. Once they get the window handle
    // then they do DDE with program manager to create app group. An app
    // can call FindWindow in one of the three ways.
    //
    //   FindWindow ("progman", NULL)
    //   FindWindow (NULL, "program manager")
    //   FindWindow ("progman", "program manager")
    //
    // The case 2 and 3 of the above will fail on NT because the title of
    // the program manager window under NT is "Program Manager - xxx\yyy".
    // Where xxx is the domain name and yyy is the user name.
    //
    // To provide the Win 3.1 compatibility to the 16 bit apps, we check for
    // the above cases. For these cases we call FindWindow ("progman", NULL)
    // to get the window handle of the program manager's top level window.
    //
    // AmiPro calls FindWindow as case two of the above to find the window
    // handle of the program manager to do DDE with.
    // ChandanC, 5/18/93
    //

    // Some apps send WM_SYSCOMMAND - SC_CLOSE messages to program manager
    // with the shift key down to get it to save its settings.  They do
    // this by 1st finding the program manager window...

    if ((pszClass && !WOW32_stricmp (pszClass, "progman")) ||
        (psz2 && !WOW32_stricmp (psz2, "program manager"))) {

        ul = GETHWND16(FindWindow("progman", NULL));

        // Some apps send WM_SYSCOMMAND - SC_CLOSE messages to program manager
        // with the shift key down to get it to save its settings.      They do
        // this by 1st finding the program manager window...
        // So, save this window handle for later.
        hwndProgman = (HWND)ul;
    }
    else {
        ul = GETHWND16(FindWindow(pszClass, psz2));
    }

    FREEPSZPTR(psz1);
    FREEPSZPTR(psz2);
    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    HWND GetActiveWindow(VOID)

    The %GetActiveWindow% function retrieves the window handle of the active
    window. The active window is either the window that has the current input
    focus, or the window explicitly made active by the %SetActiveWindow%
    function.

    This function has no parameters.

    The return value identifies the active window.
--*/

ULONG FASTCALL WU32GetActiveWindow(PVDMFRAME pFrame)
{
    ULONG ul;

    UNREFERENCED_PARAMETER(pFrame);

    ul = (ULONG)GetActiveWindow();

    // GetActiveWindow returned NULL. So try GetForegroundWindow.
    // Some apps like Toolbook donot paint if GetActiveWindow returns NULL.
    //
    // Alternatively we can return the wowexec's window handle.. basically
    // something NON-NULL
    //
    // NOTE: Win31 and Win32 GetActiveWindow differ semantically and hence
    //       the need for fooling with this API.
    //
    //                                              - Nanduri Ramakrishna
    //
    // We need to do something different now, since JimA recently changed
    // GetForegroundWindow() so that it can return NULL if the caller doesn't
    // have access to the foreground window.
    //
    //                                              - Dave Hart
    //
    // When GetForegroundWindow() returns null, now we return wowexec's
    // window handle. This theoretically could have some strange effects
    // since it is a hidden window. It might be better to return, say,
    // the desktop window. However, for reasons currently unknown, 
    // this screws a shutdown scenario with Micrografix Designer (it
    // gpfaults).
    //                                              - Neil Sandlin

    if (ul == (ULONG)NULL) {
        ul = (ULONG)GetForegroundWindow();
    }

    if (ul == (ULONG)NULL) {
        ul = (ULONG)ghwndShell;
    }

    ul = GETHWND16(ul);

    WOW32ASSERT(ul);
    RETURN(ul);
}


/*++
    HDC GetWindowDC(<hwnd>)
    HWND <hwnd>;

    The %GetWindowDC% function retrieves the display context for the entire
    window, including caption bar, menus, and scroll bars. A window display
    context permits painting anywhere in a window, including the caption bar,
    menus, and scroll bars, since the origin of the context is the upper-left
    corner of the window instead of the client area.

    %GetWindowDC% assigns default attributes to the display context each time it
    retrieves the context. Previous attributes are lost.

    <hwnd>
        Identifies the window whose display context is to be retrieved.

    The return value identifies the display context for the given window if the
    function is successful. Otherwise, it is NULL.

    The %GetWindowDC% function is intended to be used for special painting
    effects within a window's nonclient area. Painting in nonclient areas of any
    window is not recommended.

    The %GetSystemMetrics% function can be used to retrieve the dimensions of
    various parts of the nonclient area, such as the caption bar, menu, and
    scroll bars.

    After painting is complete, the %ReleaseDC% function must be called to
    release the display context. Failure to release a window display context
    will have serious effects on painting requested by applications.
--*/

ULONG FASTCALL WU32GetWindowDC(PVDMFRAME pFrame)
{
    ULONG ul;
    register PGETWINDOWDC16 parg16;
    HAND16 htask16 = pFrame->wTDB;

    GETARGPTR(pFrame, sizeof(GETWINDOWDC16), parg16);

    ReleaseCachedDCs(htask16, parg16->f1, 0, 0, SRCHDC_TASK16_HWND16);

    ul = GETHDC16(GetWindowDC(
    HWND32(parg16->f1)
    ));

    if (ul)
        StoreDC(htask16, parg16->f1, (HAND16)ul);

    FREEARGPTR(parg16);
    RETURN(ul);
}

/*++
    LONG GetWindowLong(<hwnd>, <nIndex>)
    HWND <hwnd>;
    int <nIndex>;

    The %GetWindowLong% function retrieves information about the window
    identified by the <hwnd> parameter.

    <hwnd>
        Identifies the window.

    <nIndex>
        Specifies the byte offset of the value to be retrieved. It can
        also be one of the following values:

    GWL_EXSTYLE
        Extended window style.

    GWL_STYLE
        Window style

    GWL_WNDPROC
        Long pointer to the window function

    The return value specifies information about the given window.

    To access any extra four-byte values allocated when the window-class
    structure was created, use a positive byte offset as the index specified by
    the <nIndex> parameter, starting at zero for the first four-byte value in
    the extra space, 4 for the next four-byte value and so on.
--*/

ULONG FASTCALL WU32GetWindowLong(PVDMFRAME pFrame)
{
    ULONG ul;
    INT iOffset;
    register PWW pww;
    register PGETWINDOWLONG16 parg16;

    GETARGPTR(pFrame, sizeof(GETWINDOWLONG16), parg16);

    // Make sure Win32 didn't change offsets for GWL constants

#if (GWL_WNDPROC != (-4) || GWL_STYLE != (-16) || GWL_EXSTYLE != (-20) || DWL_MSGRESULT != (0))
#error Win16/Win32 GWL constants differ
#endif

#ifndef WIN16_GWW_HINSTANCE
#define WIN16_GWW_HINSTANCE     (-6)
#define WIN16_GWW_HWNDPARENT    (-8)
#define WIN16_GWW_ID            (-12)
#endif

    // Make sure the 16-bit app is requesting allowable offsets

    iOffset = INT32(parg16->f2);
    WOW32ASSERT(iOffset >= 0 ||
        iOffset == GWL_WNDPROC  ||
        iOffset == GWL_STYLE || iOffset == GWL_EXSTYLE ||
        iOffset == WIN16_GWW_HINSTANCE  ||
        iOffset == WIN16_GWW_HWNDPARENT ||
        iOffset == WIN16_GWW_ID         );

    ul = 0;
    switch( iOffset ) {
        case DWL_DLGPROC:
        case GWL_WNDPROC:
            if (pww = FindPWW(HWND32(parg16->f1))) {
                DWORD dwWndProc32Cur;

                if ((iOffset == DWL_DLGPROC) && !(pww->state & WF_DIALOG_WINDOW)) {
                    goto defgwl;
                }
                dwWndProc32Cur = GetWindowLong(HWND32(parg16->f1), iOffset);

                if (IsWOWProc (dwWndProc32Cur)) {
                    if ( HIWORD(dwWndProc32Cur) == WNDPROC_HANDLE ) {
                        /*
                        ** Has a 32-bit WindowProc that is a handle-based value
                        ** (if it needs a 32-bit Ansi-Unicode transition, or
                        ** vice versa.)
                        */
                        ul = GetThunkWindowProc( dwWndProc32Cur, NULL, pww, HWND32(parg16->f1) );
                    } else {
                        /*
                        ** Has a WOW WindowProc
                        */

                        //Unmark the proc and restore the high bits from rpl field
                        UnMarkWOWProc (dwWndProc32Cur,ul);
                    }
                } else {
                    /*
                    ** Has a 32-bit WindowProc
                    */
                    if (dwWndProc32Cur) {
                        ul = GetThunkWindowProc( dwWndProc32Cur, NULL, pww, HWND32(parg16->f1) );
                    }
                }
            }
            break;

        case GWL_EXSTYLE:
            // Lotus Approach needs the WS_EX_TOPMOST bit cleared on
            // GetWindowLong of NETDDE AGENT window.
            ul = GetWindowLong(HWND32(parg16->f1), iOffset);
            if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_GWLCLRTOPMOST) {
                char szBuf[40];

                if (GetClassName(HWND32(parg16->f1), szBuf, sizeof(szBuf))) {
                    if (!WOW32_stricmp(szBuf, "NDDEAgnt")) {
                        ul &= !WS_EX_TOPMOST;
                    }
                }
            }

            break;

defgwl:
        default:

            // This is a real HACK for PowerBuild 3.0. Before we change the offset
            // from 2 to 4, we nneed to make sure that we are doing it correctly for
            // this specific class.
            // The class in this case is "PaList".
            //
            // ChandanC Marh 9th 1994
            //

            if (iOffset == 2) {
                if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_GWLINDEX2TO4) {
                    char Buffer[40];

                    if (GetClassName (HWND32(parg16->f1), Buffer, sizeof(Buffer))) {
                        if (!WOW32_stricmp (Buffer, "PaList")) {
                            iOffset = 4;
                        }
                    }
                }
            }

            ul = GetWindowLong(HWND32(parg16->f1), iOffset);
            break;

        case WIN16_GWW_HINSTANCE:
            /*
            ** We might need to set the high 16-bits to
            ** some mysterious value (See Win 3.1 WND structure)
            */
            ul = GetGWW_HINSTANCE(HWND32(parg16->f1));
            break;

        case WIN16_GWW_HWNDPARENT:
            /*
            ** We might need to set the high 16-bits to
            ** some mysterious value (See Win 3.1 WND structure)
            */

            ul = (ULONG)GETHWND16((HAND32)GetWindowLong(HWND32(parg16->f1),
                                                        GWL_HWNDPARENT));
            break;

        case WIN16_GWW_ID:
            /*
            ** We might need to set the high 16-bits to
            ** some mysterious value (See Win 3.1 WND structure)
            */
            ul = (ULONG)((WORD)GetWindowLong(HWND32(parg16->f1), GWL_ID));
            break;

    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    HANDLE GetWindowTask(<hwnd>)
    HWND <hwnd>;

    The %GetWindowTask% function searches for the handle of a task associated
    with the <hwnd> parameter. A task is any program that executes as an
    independent unit. All applications are executed as tasks. Each instance of
    an application is a task.

    <hwnd>
        Identifies the window for which a task handle is retrieved.

    The return value identifies the task associated with a particular window.
--*/

ULONG FASTCALL WU32GetWindowTask(PVDMFRAME pFrame)
{
    register PGETWINDOWTASK16 parg16;
    DWORD dwThreadID, dwProcessID;
    PTD ptd;

    GETARGPTR(pFrame, sizeof(GETWINDOWTASK16), parg16);

    dwThreadID = GetWindowThreadProcessId(HWND32(parg16->f1), &dwProcessID);

    //
    // return corresponding htask16 if window belongs to a WOW thread
    // else return WowExec's htask.
    //

    ptd = ThreadProcID32toPTD(dwThreadID, dwProcessID);

    if (ptd == NULL) {
        ptd = gptdShell;
    }

    FREEARGPTR(parg16);
    return (ULONG)ptd->htask16;
}





/*++
    int GetWindowText(<hwnd>, <lpString>, <nMaxCount>)
    HWND <hwnd>;
    LPSTR <lpString>;
    int <nMaxCount>;

    The %GetWindowText% function copies the given window's caption title (if it
    has one) into the buffer pointed to by the <lpString> parameter. If the
    <hwnd> parameter identifies a control, the %GetWindowText% function copies
    the text within the control instead of copying the caption.

    <hwnd>
        Identifies the window or control whose caption or text is to be copied.

    <lpString>
        Points to the buffer that is to receive the copied string.

    <nMaxCount>
        Specifies the maximum number of characters to be copied to the
        buffer. If the string is longer than the number of characters specified
        in the <nMaxCount> parameter, it is truncated.

    The return value specifies the length of the copied string. It is zero if
    the window has no caption or if the caption is empty.

    This function causes a WM_GETTEXT message to be sent to the given window or
    control.
--*/

ULONG FASTCALL WU32GetWindowText(PVDMFRAME pFrame)
{
    ULONG ul;
    VPVOID vp;
    PSZ psz2;
    register PGETWINDOWTEXT16 parg16;

    GETARGPTR(pFrame, sizeof(GETWINDOWTEXT16), parg16);
    ALLOCVDMPTR(parg16->f2, parg16->f3, psz2);
    vp = parg16->f2;

    ul = GETINT16(GetWindowText(HWND32(parg16->f1), psz2, WORD32(parg16->f3)));

    // special case to keep common dialog structs in sync (see wcommdlg.c)
    Check_ComDlg_pszptr(CURRENTPTD()->CommDlgTd, vp);

    FLUSHVDMPTR(parg16->f2, (USHORT)ul+1, psz2);
    FREEVDMPTR(psz2);
    FREEARGPTR(parg16);
    RETURN(ul);
}




/*++
    WORD GetWindowWord(<hwnd>, <nIndex>)
    HWND <hwnd>;
    int <nIndex>;

    The %GetWindowWord% function retrieves information about the window
    identified by <hwnd>.

    <hwnd>
        Identifies the window.

    <nIndex>
        Specifies the byte offset of the value to be retrieved. It can
        also be one of the following values:

    GWL_HINSTANCE
        Instance handle of the module that owns the window.

    GWL_HWNDPARENT
        Handle of the parent window, if any. The %SetParent% function changes
        the parent window of a child window. An application should not call the
        %SetWindowLong% function to change the parent of a child window.

    GWL_ID
        Control ID of the child window.

    The return value specifies information about the given window.


    To access any extra two-byte values allocated when the window-class
    structure was created, use a positive byte offset as the index specified by
    the <nIndex> parameter, starting at zero for the first two-byte value in the
    extra space, 2 for the next two-byte value and so on.
--*/

ULONG FASTCALL WU32GetWindowWord(PVDMFRAME pFrame)
{
    ULONG ul;
    HWND hwnd;
    INT iOffset;
    PWW pww;
    PGETWINDOWWORD16 parg16;

    GETARGPTR(pFrame, sizeof(GETWINDOWWORD16), parg16);

    // Make sure Win32 didn't change offsets

#if (GWL_HINSTANCE != (-6) || GWL_HWNDPARENT != (-8) || GWL_ID != (-12))
#error Win16/Win32 window-word constants differ
#endif

    // Make sure the 16-bit app is requesting allowable offsets

    iOffset = INT32(parg16->f2);
    WOW32ASSERT(iOffset >= 0 ||
        iOffset == GWL_HINSTANCE  ||
        iOffset == GWL_STYLE      ||
        iOffset == GWL_HWNDPARENT || iOffset == GWL_ID);

    hwnd = HWND32(parg16->f1);

    switch(iOffset) {
    case GWL_STYLE:
        // Wordperfect for windows calls GetWindowWord with GWL_STYLE.
        ul = (ULONG)GetWindowLong(hwnd, iOffset);
        break;

    case GWL_HINSTANCE:
        ul = GetGWW_HINSTANCE(hwnd);
        break;

    case GWL_HWNDPARENT:
        ul = (ULONG)GETHWND16((HAND32)GetWindowLong(hwnd, iOffset));
        break;

    case GWL_ID:
        ul = GetWindowLong(hwnd, iOffset);
        if (!(GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)) {
            ul = (ULONG)GETHMENU16(ul);
        }
        break;

    // Under Windows index 4 of a static control could be the icon
    case 4:
        pww = FindPWW(hwnd);
        if (pww) {
            if (((pww->style & SS_TYPEMASK) == SS_ICON)    && 
                (GETICLASS(pww, hwnd) == WOWCLASS_STATIC)) {
                ul = SendMessage(hwnd, STM_GETICON, 0, 0);
                return GETHICON16(ul);
            }
        }
        // FALL THROUGH!


    default:
        //
        // Offset is non-negative, this is the cbWndExtra bytes that
        // are fair game.
        //

        //
        // Gross app hack for Adonis' Clip-Art Window Shopper online
        // clipart software that comes with CA-Cricket Presents.
        // These people SetWindowWord(hwnd, 3, wWhatever), thereby
        // overwriting the 4th and 5th bytes of per-window data.
        // The edit control itself only uses the first 2 bytes
        // on 3.1, and has 6 bytes reserved, so this works.  On
        // NT the first 4 bytes are used (32-bit handle), and so
        // this P.O.S. overwrites the high byte of the handle.
        // So if it's the compatibility flag is set and the class name
        // matches the one this bogus app uses, and it's storing a
        // word at offset 3, change it to 4.  This is safe because
        // the NT edit control only uses the first 4 of its 6
        // reserved window extra bytes.
        //

        if (3 == iOffset && (CURRENTPTD()->dwWOWCompatFlags & WOWCF_EDITCTRLWNDWORDS)) {

            char szClassName[30];

            if (GetClassName(hwnd, szClassName, sizeof(szClassName)) &&
                !WOW32_strcmp(szClassName, "SuperPassEdit")) {

                iOffset = 4;

                LOGDEBUG(LOG_ALWAYS,("WOW WU32GetWindowWord: SHOPPER hack triggered, using offset 4, rc = %x.\n",
                         GetWindowWord(hwnd, iOffset)));

            }
        }

        ul = GetWindowWord(hwnd, iOffset);
        break;
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}

//
// GetGWW_HINSTANCE is a common implementation for GetWindowWord(GWW_HINSTANCE)
// and GetWindowLong(GWW_HINSTANCE).
//

ULONG FASTCALL GetGWW_HINSTANCE(HWND hwnd)
{
    DWORD dwProcessID32, dwThreadID32;
    ULONG ul;
    PWOAINST pWOA;
    PTD ptd;
    HTASK16 htask16;

    dwProcessID32 = (DWORD)-1;
    dwThreadID32 = GetWindowThreadProcessId( hwnd, &dwProcessID32 );

    ul = (ULONG)GetWindowLong(hwnd, GWL_HINSTANCE);

    if ( ISINST16(ul) ) {

        //
        // This could be a valid HINST in another WOW VDM,
        // in which case we need to hide it from this VDM.
        //

        if (dwProcessID32 != GetCurrentProcessId() &&
            dwProcessID32 != (DWORD)-1) {

            ul = (ULONG)ghInstanceUser32;
            goto ElseClause;
        }
    }
    else
    {
      ElseClause:
        // here if ul = NULL or ul = 0xZZZZ0000
        //
        // if (ul is 0xZZZZ0000) return 16bit user.exe instance.
        // PowerBuilder 3.0 does
        //     hInst =  GetWindowWord(Dialog, GWL_HINSTANCE)
        //     hIcon =  CreateIcon(... hInst ...);
        // CreateIcon will fail if hInst is invalid (say BOGUSGDT). So
        // we return 16bit user.exe hinstance in all such cases.
        //
        // Some 32-bit applications put 0 in the HINSTANCE
        // stuff for their window (its optional for 32-bit windows).
        //

        //
        // Check if this window belongs to a task we spawned via
        // WinOldAp, if so, return WinOldAp's hmodule.
        //

        ptd = CURRENTPTD();
        EnterCriticalSection(&ptd->csTD);
        pWOA = ptd->pWOAList;
        while (pWOA && pWOA->dwChildProcessID != dwProcessID32) {
            pWOA = pWOA->pNext;
        }

        if (pWOA) {
            ul = pWOA->ptdWOA->hInst16;
            LOGDEBUG(LOG_ALWAYS, ("WOW32 GetWindowWord(0x%x, GWW_HINSTANCE) returning 0x%04x\n",
                                  hwnd, ul));
        } else {

            ul = (ul) ? gUser16hInstance : ul;

            if (cHtaskAliasCount != 0 ) {

                //
                // Must be some 32-bit process, not a wow app's window
                //

                if ( dwThreadID32 != 0 ) {

                    htask16 = FindHtaskAlias( dwThreadID32 );

                    if ( htask16 != 0 ) {
                        ul = (ULONG)htask16;
                    }
                }
            }
        }
        LeaveCriticalSection(&ptd->csTD);
    }

    return ul;
}

/*++
    UINT MenuItemFromPoint(<hwndParent>, <Menu>, <Point>)
    HWND <hwndParent>;
    HMENU <Menu>;
    POINT <Point>;

    The %MenuItemFromPoint% function determines which, if any, of the menu
    items belonging to the given parent window contains the specified point.

    <hwndParent>
        Identifies the parent window.

    <Point>
        Specifies the client coordinates of the point to be tested.

    The return value identifies the menu item that contains the point. It is
    -1 if the given point lies outside the parent window. If the point is
    within the parent window but is not contained within any menu item, -1
    is returned.
--*/

ULONG FASTCALL WU32MenuItemFromPoint(PVDMFRAME pFrame)
{
    ULONG ul;
    POINT pt32;
    register PMENUITEMFROMPOINT16 parg16;

    GETARGPTR(pFrame, sizeof(MENUITEMFROMPOINT16), parg16);
    COPYPOINT16(parg16->ptScreen, pt32);

    ul = MenuItemFromPoint(HWND32(parg16->hwnd), HMENU32(parg16->hmenu), pt32);

    FREEARGPTR(parg16);
    RETURN(ul);
}

/*++
    BOOL MoveWindow(<hwnd>, <left>, <top>, <width>, <height>, <fRepaint>)
    HWND <hwnd>;
    int <left>;
    int <top>;
    int <width>;
    int <height>;
    BOOL <fRepaint>;

    The %MoveWindow% function changes the position and dimensions of a window.

    <hwnd>
        Identifies the window to change.

    <left>
        Specifies the new position of the left side of the window.

    <top>
        Specifies the new position of the top of the window.

    <width>
        Specifies the new width of the window.

    <height>
        Specifies the new height of the window.

    <fRepaint>
        Specifies whether or not the window is to be repainted. If this
        parameter is TRUE, the window is repainted.

    The return value is nonzero if the function is successful. Otherwise it is
    zero.  (updated for Win3.1 compatability -- this returned void for Win3.0)

    For top-level windows the <left> and <top> parameters are relative to the
    upper-left corner of the screen. For child windows, they are relative to the
    upper-left corner of the parent window's client area.

    The %MoveWindow% function sends a WM_GETMINMAXINFO message to the window
    being moved. This gives the window being moved the opportunity to modify
    the default values for the largest and smallest possible windows. If the
    parameters to the %MoveWindow% function exceed these values, the values will
    be replaced by the minimum or maximum values specified in the
    WM_GETMINMAXINFO message.
--*/

ULONG FASTCALL WU32MoveWindow(PVDMFRAME pFrame)
{
    ULONG    ul;
    register PMOVEWINDOW16 parg16;

    GETARGPTR(pFrame, sizeof(MOVEWINDOW16), parg16);

    if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_DBASEHANDLEBUG) {
        RECT ParentRect;
        RECT ScreenRect;

        GetWindowRect(GetDesktopWindow(), &ScreenRect);
        if ((INT32(parg16->f2) > ScreenRect.right) ||
            (INT32(parg16->f3) > ScreenRect.bottom) ||
            (INT32(parg16->f4) > ScreenRect.right) ||
            (INT32(parg16->f5) > ScreenRect.bottom)) {
            int x, y, cx, cy;

            GetWindowRect(GetParent(HWND32(parg16->f1)), &ParentRect);
            x  = ParentRect.left;
            y  = ParentRect.top;
            cx = ParentRect.right - ParentRect.left;
            cy = ParentRect.bottom - ParentRect.top;


            ul = GETBOOL16(MoveWindow(HWND32(parg16->f1), x, y, cx, cy,
                                      BOOL32(parg16->f6)));
            FREEARGPTR(parg16);
            RETURN(ul);
        }
    }

    ul = GETBOOL16(MoveWindow(HWND32(parg16->f1),
                              INT32(parg16->f2),
                              INT32(parg16->f3),
                              INT32(parg16->f4),
                              INT32(parg16->f5),
                              BOOL32(parg16->f6)));


    FREEARGPTR(parg16);

    RETURN(ul);
}


/*++
    void ScrollWindow(<hwnd>, <XAmount>, <YAmount>, <lpRect>, <lpClipRect>)
    HWND <hwnd>;
    int <XAmount>;
    int <YAmount>;
    LPRECT <lpRect>;
    LPRECT <lpClipRect>;

    The %ScrollWindow% function scrolls a window by moving the contents of the
    window's client area the number of units specified by the <XAmount>
    parameter along the screen's <x>-axis and the number of units specified by
    the <YAmount> parameter along the <y>-axis. The scroll moves right if
    <XAmount> is positive and left if it is negative. The scroll moves down if
    <YAmount> is positive and up if it is negative.

    <hwnd>
        Identifies the window whose client area is to be scrolled.

    <XAmount>
        Specifies the amount (in device units) to scroll in the <x>
        direction.

    <YAmount>
        Specifies the amount (in device units) to scroll in the <y>
        direction.

    <lpRect>
        Points to a %RECT% structure that specifies the portion of
        the client area to be scrolled. If <lpRect> is NULL, the entire client
        area is scrolled.

    <lpClipRect>
        Points to a %RECT% structure that specifies the clipping
        rectangle to be scrolled. Only bits inside this rectangle are scrolled.
        If <lpClipRect> is NULL, the entire window is scrolled.

    This function does not return a value.

    If the caret is in the window being scrolled, %ScrollWindow% automatically
    hides the caret to prevent it from being erased, then restores the caret
    after the scroll is finished. The caret position is adjusted accordingly.

    The area uncovered by the %ScrollWindow% function is not repainted, but is
    combined into the window's update region. The application will eventually
    receive a WM_PAINT message notifying it that the region needs repainting. To
    repaint the uncovered area at the same time the scrolling is done, call the
    %UpdateWindow% function immediately after calling %ScrollWindow%.

    If the <lpRect> parameter is NULL, the positions of any child windows in the
    window are offset by the amount specified by <XAmount> and <YAmount>, and
    any invalid (unpainted) areas in the window are also offset. %ScrollWindow%
    is faster when <lpRect> is NULL.

    If the <lpRect> parameter is not NULL, the positions of child windows are
    <not> changed, and invalid areas in the window are <not> offset. To prevent
    updating problems when <lpRect> is not NULL, call the %UpdateWindow%
    function to repaint the window before calling %ScrollWindow%.
--*/

ULONG FASTCALL WU32ScrollWindow(PVDMFRAME pFrame)
{
    RECT t4, *p4;
    RECT t5, *p5;
    register PSCROLLWINDOW16 parg16;

    GETARGPTR(pFrame, sizeof(SCROLLWINDOW16), parg16);
    p4 = GETRECT16(parg16->f4, &t4);
    p5 = GETRECT16(parg16->f5, &t5);

    ScrollWindow(
        HWND32(parg16->f1),
        INT32(parg16->f2),
        INT32(parg16->f3),
        p4,
        p5
        );

    FREEARGPTR(parg16);
    RETURN(0);
}


/*++
    LONG SetWindowLong(<hwnd>, <nIndex>, <dwNewLong>)
    HWND <hwnd>;
    int <nIndex>;
    DWORD <dwNewLong>;

    The %SetWindowLong% function changes an attribute of the window specified by
    the <hwnd> parameter.

    <hwnd>
        Identifies the window.

    <nIndex>
        Specifies the byte offset of the attribute to be changed. It may
        also be one of the following values:

    GWL_EXSTYLE
        Sets a new extended window style.

    GWL_STYLE
        Sets a new window style.

    GWL_WNDPROC
        Sets a new long pointer to the window procedure.

    <dwNewLong>
        Specifies the replacement value.

    The return value specifies the previous value of the specified long
    integer.

    If the %SetWindowLong% function and the GWL_WNDPROC index are used to set a
    new window function, that function must have the window-function form and be
    exported in the module-definition file of the application. For more
    information, see the %RegisterClass% function, earlier in this chapter.

    Calling %SetWindowLong% with the GCL_WNDPROC index creates a subclass of the
    window class used to create the window. See Chapter 1, Window Manager
    Interface Functions, for more information on window subclassing. An
    application should not attempt to create a window subclass for standard
    Windows controls such as combo boxes and buttons.

    To access any extra four-byte values allocated when the window-class
    structure was created, use a positive byte offset as the index specified by
    the <nIndex> parameter, starting at zero for the first four-byte value in
    the extra space, 4 for the next four-byte value and so on.
--*/
ULONG FASTCALL WU32SetWindowLong(PVDMFRAME pFrame)
{
    ULONG ul;
    INT iOffset, iClass;
    register PWW pww;
    register PSETWINDOWLONG16 parg16;

    GETARGPTR(pFrame, sizeof(SETWINDOWLONG16), parg16);

    // Make sure Win32 didn't change offsets for GWL constants

#if (GWL_WNDPROC != (-4) || GWL_STYLE != (-16) || GWL_EXSTYLE != (-20))
#error Win16/Win32 GWL constants differ
#endif

    // Make sure the 16-bit app is requesting allowable offsets

    iOffset = INT32(parg16->f2);
    WOW32ASSERT(iOffset >= 0 ||
        iOffset == GWL_WNDPROC  ||
        iOffset == GWL_STYLE || iOffset == GWL_EXSTYLE);

    ul = 0;
    if ((iOffset == GWL_WNDPROC) || (iOffset == DWL_DLGPROC)) {

        if (pww = FindPWW(HWND32(parg16->f1))) {
            DWORD dwWndProc32Old;
            DWORD dwWndProc32New;

            if ((iOffset == DWL_DLGPROC) && !(pww->state & WF_DIALOG_WINDOW)) {
                goto defswp;
            }
            // Look to see if the new 16:16 proc is a thunk for a 32-bit proc.
            dwWndProc32New = IsThunkWindowProc(LONG32(parg16->f3), &iClass );

            if ( dwWndProc32New != 0 ) {
                //
                // They are attempting to set the window proc to an existing
                // 16-bit thunk that is really just a thunk for a 32-bit
                // routine.  We can just set it back to the 32-bit routine.
                //
                dwWndProc32Old = SetWindowLong(HWND32(parg16->f1), iOffset, dwWndProc32New);

                // If the 32 bit set failed, perhaps because its another process,
                // then we want to fail too
                if (!dwWndProc32Old)
                    goto SWL_Cleanup;

            } else {
                //
                // They are attempting to set it to a real 16:16 proc.
                //
                LONG    l;

                l = LONG32(parg16->f3);

                // mark the proc as WOW proc and save the high bits in the RPL
                //
                // Don't mark a NULL proc since USER32 DefWindowProcWorker
                // looks specifically for NULL. WOW used to do this correctly
                // but was broken by a performance enhancement checkin. This
                // fixes VC1.52 debugging.
                //
                if (l) {
                    MarkWOWProc (l,l);
                }

                dwWndProc32Old = SetWindowLong(HWND32(parg16->f1), iOffset, l);

                // If the 32 bit set failed, perhaps because its another process,
                // then we want to fail too
                if (!dwWndProc32Old)
                    goto SWL_Cleanup;

            }

            if ( IsWOWProc (dwWndProc32Old)) {
                if ( HIWORD(dwWndProc32Old) == WNDPROC_HANDLE ) {
                    //
                    // If the return value was a handle to a proc (due to
                    // the need for unicode-ansi transitions, or vice versa)
                    // then treat it as a 32-bit thunk.
                    //
                    ul = GetThunkWindowProc(dwWndProc32Old, NULL, pww, HWND32(parg16->f1));
                } else {
                    //
                    // Previous proc was a 16:16 proc
                    //
                    //Unmark the proc and restore the high bits from rpl field
                    UnMarkWOWProc (dwWndProc32Old,ul);
                }
            } else {
                //
                // Previous proc was a 32-bit proc, use an allocated thunk
                //
                ul = GetThunkWindowProc(dwWndProc32Old, NULL, pww, HWND32(parg16->f1));
            }
        }

    }
    else {    // not GWL_WNDPROC or GWL_DLGPROC
        LONG new;
defswp:
        new = LONG32(parg16->f3);
    /*
     * We need to keep Wow apps from putting garbage in post-4.0 bits in
     * the extended style DWORD.  Kiplinger's TaxCut 97 sets the WS_EX_LAYERED
     * bit on their help window, which is quite unfortunate.
     */

        if (iOffset == GWL_EXSTYLE) {
            new &= WS_EX_VALID40;
            new |= (GetWindowLong(HWND32(parg16->f1), GWL_EXSTYLE) & ~WS_EX_VALID40);
    }

    // This is a real HACK for PowerBuild 3.0. Before we change the offset
    // from 2 to 4, we nneed to make sure that we are doing it for this
    // specific class.
    // The class in this case is "PaList".
    //
    // ChandanC Marh 9th 1994
    //

        if (iOffset == 2) {
            if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_GWLINDEX2TO4) {
                char Buffer[40];

                if (GetClassName (HWND32(parg16->f1), Buffer, sizeof(Buffer))) {
                    if (!WOW32_stricmp (Buffer, "PaList")) {
                        iOffset = 4;
                    }
                }
            }
        }

        ul = SetWindowLong(HWND32(parg16->f1), iOffset, new);
    }

SWL_Cleanup:
    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++
    BOOL ShowWindow(<hWnd>, <nCmdShow>)
    HWND <hWnd>;
    int <nCmdShow>;

    The %ShowWindow% function sets the specified windows show state.

    <hWnd>
        Handle to the window.

    <nCmdShow>
        Specifies how the window is to be shown. This value can have any of the
        following values:

    SW_FORCEMINIMIZE
        Minimizes a window, even if the thread that owns the window is hung.
        This flag should only be used when minimizing windows from a different
        thread.

    SW_HIDE
        Hides the window and activiates another window.

    SW_MINIMIZE
        Minimizes the specified window and activates the next top-level window
        in the Z order.

    SW_RESTORE
        Activates and displays the window. If the window is minimized or maximized,
        the system restores it to its original size and position. An application 
        should specify this flag when restoring a minimized window.

    SW_SHOW
        Activiates the window and displays it in its current size and position.

    SW_SHOWDEFAULT
        Sets the show state based on the SW_ value specified in the STARTUPINFO
        structure passed to the CreateProcess() function by the program that started
        the application.

    SW_SHOWMAXIMIZED
        Activates the window and displays it as a minimized window.

    SW_SHOWMINNOACTIVE
        Displays the window as a minimized window. This value is similar to 
        SW_SHOWMINIMIZED, except the window is not activated.
 
    SW_SHOWNA
        Displays the window in its current size and position. This value is similar
        to SW_SHOW, except the window is not activated.

    SW_SHOWNOACTIVATE
        Displays a window in its most recent size and position. This value is similar
        to SW_SHOWNORMAL, except the window is not activated.

    SW_SHOWNORMAL
        Activates and displays a window. If the window is minimized or maximized,
        the system restores it to its orignial size and position. An application 
        should specify this flag when displaying the window for the first time.


    This function returns nonzero if the window if the window was previously visible. 
    It returns zero if the window was previously hidden.

    The first time an application calls ShowWindow(), it should use the WinMain
    function's <nCmdShow> parameter as its <nCmdShow> parameter. Subsequent calls to
    ShowWindow() must use one of the values in the given list, instead of the one
    specified by the WinMain function's <nCmdShow> parameter.

--*/        
ULONG FASTCALL WU32ShowWindow(PVDMFRAME pFrame)
{
    BOOL bReturn = FALSE;
    register PSHOWWINDOW16 parg16;
   
    GETARGPTR(pFrame, sizeof(SHOWWINDOW16), parg16);

    bReturn = ShowWindow(HWND32(parg16->f1), INT32(parg16->f2));
    
    // WHISTLER RAID BUG #348251
    // The artgalry.exe window would remain behind autosketches window after it was
    // invoked. This hack works in conjuction with the GACF2_GIVEUPFOREGROUND
    // compatibility flag, applied to the app that will not give up the foreground.
    // In order to move the 16bit window to the top, we have to call 
    // SetForegroundWindow() on the hwnd. We only want to call this if the windows
    // show bit is set and the window is active.
    if((INT32(parg16->f2) | SW_SHOW) && (bReturn == 0) && (CURRENTPTD()->dwWOWCompatFlags2 & WOWCF2_SETFOREGROUND))
    {
        SetForegroundWindow(HWND32(parg16->f1));
        
        LOGDEBUG(LOG_WARNING, ("WU32ShowWindow: SetForegroundWindow called. HWND=%x STYLE=%x\n",
                 HWND32(parg16->f1),
                 INT32(parg16->f2)));
    }

    FREEARGPTR(parg16);
    RETURN((ULONG)bReturn);
}


/*++
    BOOL SetWindowPos(<hwnd>, <hwndInsertAfter>, <X>, <Y>, <cx>, <cy>, <wFlags>)
    HWND <hwnd>;
    HWND <hwndInsertAfter>;
    int <X>;
    int <Y>;
    int <cx>;
    int <cy>;
    WORD <wFlags>;

    The %SetWindowPos% function changes the size, position, and ordering of
    child, pop-up, and top-level windows. Child, pop-up, and top-level windows
    are ordered according to their appearance on the screen; the topmost window
    receives the highest rank, and it is the first window in the list. This
    ordering is recorded in a window list.

    <hwnd>
        Identifies the window that will be positioned.

    <hwndInsertAfter>
        Identifies a window in the window-manager's list that will
        precede the positioned window.

    <X>
        Specifies the <x->coordinate of the window's upper-left corner.

    <Y>
        Specifies the <y->coordinate of the window's upper-left corner.

    <cx>
        Specifies the new window's width.

    <cy>
        Specifies the new window's height.

    <wFlags>
        Specifies one of eight possible 16-bit values that affect the
        sizing and positioning of the window. It must be one of the following
        values:

    SWP_DRAWFRAME
        Draws a frame (defined in the window's class description) around the
        window.

    SWP_HIDEWINDOW
        Hides the window.

    SWP_NOACTIVATE
        Does not activate the window.

    SWP_NOMOVE
        Retains current position (ignores the <x> and <y> parameters).

    SWP_NOSIZE
        Retains current size (ignores the <cx> and <cy> parameters).

    SWP_NOREDRAW
        Does not redraw changes.

    SWP_NOZORDER
        Retains current ordering (ignores the <hwndInsertAfter> parameter).

    SWP_SHOWWINDOW
        Displays the window.

    The return value is nonzero if the function is successful. Otherwise it is
    zero.  (updated for Win3.1 compatability -- this returned void for Win3.0)

    If the SWP_NOZORDER flag is not specified, Windows places the window
    identified by the <hwnd> parameter in the position following the window
    identified by the <hwndInsertAfter> parameter. If <hwndInsertAfter> is NULL,
    Windows places the window identified by <hwnd> at the top of the list. If
    <hwndInsertAfter> is set to 1, Windows places the window identified by
    <hwnd> at the bottom of the list.

    If the SWP_SHOWWINDOW or the SWP_HIDEWINDOW flags are set, scrolling and
    moving cannot be done simultaneously.

    All coordinates for child windows are relative to the upper-left corner of
    the parent window's client area.
--*/

ULONG FASTCALL WU32SetWindowPos(PVDMFRAME pFrame)
{
    ULONG    ul;
    register PSETWINDOWPOS16 parg16;

    GETARGPTR(pFrame, sizeof(SETWINDOWPOS16), parg16);
#ifdef FE_IME	
    // MSKKBUG:3866  HWND_IMETOPMOST for MS-DRAW
    if ( (HWND)INT32(parg16->f2) == (HWND)-3 )
        ul = GETBOOL16(SetWindowPos(HWND32(parg16->f1),
                                    HWND_TOPMOST,
                                    INT32(parg16->f3),
                                    INT32(parg16->f4),
                                    INT32(parg16->f5),
                                    INT32(parg16->f6),
                                    WORD32(parg16->f7) & SWP_VALID));
    else
#endif // FE_IME
    ul = GETBOOL16(SetWindowPos(HWND32(parg16->f1),
                                HWNDIA32(parg16->f2),
                                INT32(parg16->f3),
                                INT32(parg16->f4),
                                INT32(parg16->f5),
                                INT32(parg16->f6),
                                WORD32(parg16->f7) & SWP_VALID));
    FREEARGPTR(parg16);

    RETURN(ul);
}


/*++
    void SetWindowText(<hwnd>, <lpString>)

    The %SetWindowText% function sets the given window's caption title (if one
    exists) to the string pointed to by the <lpString> parameter. If the <hwnd>
    parameter is a handle to a control, the %SetWindowText% function sets the
    text within the control instead of within the caption.

    <hwnd>
        Identifies the window or control whose text is to be changed.

    <lpString>
        Points to a null-terminated string.

    This function does not return a value.
--*/

ULONG FASTCALL WU32SetWindowText(PVDMFRAME pFrame)
{
    PSZ psz2;
    register PSETWINDOWTEXT16 parg16;
    HANDLE handle;

    GETARGPTR(pFrame, sizeof(SETWINDOWTEXT16), parg16);
    GETPSZPTR(parg16->f2, psz2);
    handle = HWND32(parg16->f1);

    if (NULL != psz2) {
        AddParamMap((DWORD)psz2, FETCHDWORD(parg16->f2));
    }

    if (CURRENTPTD()->dwWOWCompatFlags & WOWCF_DBASEHANDLEBUG) {

        if (NULL == handle) {
            handle = (HANDLE) ((PTDB)SEGPTR(pFrame->wTDB,0))->TDB_CompatHandle;
        }
    }

    SetWindowText(handle, psz2);

    // if we used param map successfully - then nuke there

    if (NULL != psz2) {
        DeleteParamMap((DWORD)psz2, PARAM_32, NULL);
    }

    FREEPSZPTR(psz2);
    FREEARGPTR(parg16);
    RETURN(0);
}


/*++
    WORD SetWindowWord(<hwnd>, <nIndex>, <wNewWord>)

    The %SetWindowWord% function changes an attribute of the window specified by
    the <hwnd> parameter.

    <hwnd>
        Identifies the window to be modified.

    <nIndex>
        Specifies the byte offset of the word to be changed. It can also
        be one of the following values:

    GWL_HINSTANCE
        Instance handle of the module that owns the window.

    GWL_ID
        Control ID of the child window.

    <wNewWord>
        Specifies the replacement value.

    The return value specifies the previous value of the specified word.

    To access any extra two-byte values allocated when the window-class
    structure was created, use a positive byte offset as the index specified by
    the <nIndex> parameter, starting at zero for the first two-byte value in the
    extra space, 2 for the next two-byte value and so on.
--*/

ULONG FASTCALL WU32SetWindowWord(PVDMFRAME pFrame)
{
    ULONG ul;
    HWND hwnd;
    INT iOffset;
    PSETWINDOWWORD16 parg16;
    PWW pww;

    GETARGPTR(pFrame, sizeof(SETWINDOWWORD16), parg16);

    // Make sure Win32 didn't change offsets

#if (GWL_HINSTANCE != (-6) || GWL_HWNDPARENT != (-8) || GWL_ID != (-12))
#error Win16/Win32 window-word constants differ
#endif

    // Make sure the 16-bit app is requesting allowable offsets

    iOffset = INT32(parg16->f2);
    WOW32ASSERT(iOffset >= 0 ||
        iOffset == GWL_HINSTANCE || iOffset == GWL_ID ||
        iOffset == GWL_HWNDPARENT);

    hwnd = HWND32(parg16->f1);
    ul = WORD32(parg16->f3);

    switch(iOffset) {
        case GWL_HINSTANCE:
            ul = GETHINST16(SetWindowLong(hwnd,
                                          iOffset,
                                          (LONG)HMODINST32(parg16->f3)));
            break;

        case GWL_HWNDPARENT:
            //    ul = 0;         // not allowed to set this
            ul = SetWindowLong(hwnd, iOffset, (LONG)HWND32(parg16->f3));
            ul = GETHWND16((HAND32)ul);
            break;

        case GWL_ID:
            {
                // if this isn't a child window then the value should be a
                // menu handle
                BOOL    fChild = (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD);
                ul = SetWindowLong(hwnd,
                                   iOffset,
                                   fChild ? (LONG)ul : (LONG)HMENU32(parg16->f3));

                if (!fChild)
                    ul = (ULONG)GETHMENU16(ul);

                // Invalidate the SendDlgItemMessage cache
                hdlgSDIMCached = NULL ;
            }
            break;

        // Under Windows index 4 of a static control could be the icon
        case 4:
            pww = FindPWW(hwnd);
            if (pww) {
                if (((pww->style & SS_TYPEMASK) == SS_ICON)    && 
                    (GETICLASS(pww, hwnd) == WOWCLASS_STATIC)) {
                    ul = SendMessage(hwnd, STM_SETICON, (WPARAM)HICON32(ul), 0);
                    return GETHICON16(ul);
                }
            }
            // FALL THROUGH!

        default:
            //
            // Offset is non-negative, this is the cbWndExtra bytes that
            // are fair game.
            //

            //
            // Gross app hack for Adonis' Clip-Art Window Shopper online
            // clipart software that comes with CA-Cricket Presents.
            // These people SetWindowWord(hwnd, 3, wWhatever), thereby
            // overwriting the 4th and 5th bytes of per-window data.
            // The edit control itself only uses the first 2 bytes
            // on 3.1, and has 6 bytes reserved, so this works.  On
            // NT the first 4 bytes are used (32-bit handle), and so
            // this P.O.S. overwrites the high byte of the handle.
            // So if it's an app called "SHOPPER" and it's storing a
            // word at offset 3, change it to 4.  This is safe because
            // the NT edit control only uses the first 4 of its 6
            // reserved window extra bytes.
            //

            if (3 == iOffset && (CURRENTPTD()->dwWOWCompatFlags & WOWCF_EDITCTRLWNDWORDS)) {

                char szClassName[30];

                if (GetClassName(hwnd, szClassName, sizeof(szClassName)) &&
                    !WOW32_strcmp(szClassName, "SuperPassEdit")) {

                    iOffset = 4;

                    LOGDEBUG(LOG_ALWAYS,("WOW WU32SetWindowWord: SHOPPER hack triggered, using offset 4.\n"));
                }
            }

            ul = SetWindowWord(hwnd, iOffset, (WORD)ul);
            break;
    }

    FREEARGPTR(parg16);
    RETURN(ul);
}


/*++          user
    void UpdateWindow(<hwnd>)

    The %UpdateWindow% function updates the client area of the given window by
    sending a WM_PAINT message to the window if the update region for the window
    is not empty. The %UpdateWindow% function sends a WM_PAINT message directly
    to the window function of the given window, bypassing the application
    queue. If the update region is empty, no message is sent.

    <hwnd>
        Identifies the window to be updated.

    This function does not return a value.
--*/

ULONG FASTCALL WU32UpdateWindow(PVDMFRAME pFrame)
{
    register PUPDATEWINDOW16 parg16;

    GETARGPTR(pFrame, sizeof(UPDATEWINDOW16), parg16);

    UpdateWindow(
        HWND32(parg16->f1)
        );

    FREEARGPTR(parg16);
    RETURN(0xcdef);         // ack!     same as win31
}


/*++
    HWND WindowFromPoint(<Point>)

    The %WindowFromPoint% function identifies the window that contains the given
    point; <Point> must specify the screen coordinates of a point on the screen.

    <Point>
        Specifies a %POINT% structure that defines the point to be checked.

    The return value identifies the window in which the point lies. It is NULL
    if no window exists at the given point.
--*/

ULONG FASTCALL WU32WindowFromPoint(PVDMFRAME pFrame)
{
    ULONG ul;
    POINT t1;
    register PWINDOWFROMPOINT16 parg16;

    GETARGPTR(pFrame, sizeof(WINDOWFROMPOINT16), parg16);
    COPYPOINT16(parg16->f1, t1);

    ul = GETHWND16(WindowFromPoint(t1));

    FREEARGPTR(parg16);
    RETURN(ul);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wwstbl2.h ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WWSTBL2.h
 *  WOW32 16-bit Winsock API tables
 *
 *  History:
 *  Created 02-Oct-1992 by David Treadwell (davidtr)
 *
 *  This file is included into the master thunk table.
 *
--*/

    {W32FUN(UNIMPLEMENTEDAPI,              "DUMMYENTRY",           MOD_WINSOCK,    0)},
    {W32FUN(WWS32accept,                   "ACCEPT",               MOD_WINSOCK,    sizeof(ACCEPT16))},
    {W32FUN(WWS32bind,                     "BIND",                 MOD_WINSOCK,    sizeof(BIND16))},
    {W32FUN(WWS32closesocket,              "CLOSESOCKET",          MOD_WINSOCK,    sizeof(CLOSESOCKET16))},
    {W32FUN(WWS32connect,                  "CONNECT",              MOD_WINSOCK,    sizeof(CONNECT16))},
    {W32FUN(WWS32getpeername,              "GETPEERNAME",          MOD_WINSOCK,    sizeof(GETPEERNAME16))},
    {W32FUN(WWS32getsockname,              "GETSOCKNAME",          MOD_WINSOCK,    sizeof(GETSOCKNAME16))},
    {W32FUN(WWS32getsockopt,               "GETSOCKOPT",           MOD_WINSOCK,    sizeof(GETSOCKOPT16))},
    {W32FUN(WWS32htonl,                    "HTONL",                MOD_WINSOCK,    sizeof(HTONL16))},
    {W32FUN(WWS32htons,                    "HTONS",                MOD_WINSOCK,    sizeof(HTONS16))},

  /*** 0010 ***/
    {W32FUN(WWS32inet_addr,                "INET_ADDR",            MOD_WINSOCK,    sizeof(INET_ADDR16))},
    {W32FUN(WWS32inet_ntoa,                "INET_NTOA",            MOD_WINSOCK,    sizeof(INET_NTOA16))},
    {W32FUN(WWS32ioctlsocket,              "IOCTLSOCKET",          MOD_WINSOCK,    sizeof(IOCTLSOCKET16))},
    {W32FUN(WWS32listen,                   "LISTEN",               MOD_WINSOCK,    sizeof(LISTEN16))},
    {W32FUN(WWS32ntohl,                    "NTOHL",                MOD_WINSOCK,    sizeof(NTOHL16))},
    {W32FUN(WWS32ntohs,                    "NTOHS",                MOD_WINSOCK,    sizeof(NTOHS16))},
    {W32FUN(WWS32recv,                     "RECV",                 MOD_WINSOCK,    sizeof(RECV16))},
    {W32FUN(WWS32recvfrom,                 "RECVFROM",             MOD_WINSOCK,    sizeof(RECVFROM16))},
    {W32FUN(WWS32select,                   "SELECT",               MOD_WINSOCK,    sizeof(SELECT16))},
    {W32FUN(WWS32send,                     "SEND",                 MOD_WINSOCK,    sizeof(SEND16))},

  /*** 0020 ***/
    {W32FUN(WWS32sendto,                   "SENDTO",               MOD_WINSOCK,    sizeof(SENDTO16))},
    {W32FUN(WWS32setsockopt,               "SETSOCKOPT",           MOD_WINSOCK,    sizeof(SETSOCKOPT16))},
    {W32FUN(WWS32shutdown,                 "SHUTDOWN",             MOD_WINSOCK,    sizeof(SHUTDOWN16))},
    {W32FUN(WWS32socket,                   "SOCKET",               MOD_WINSOCK,    sizeof(SOCKET16))},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},

  /*** 0030 ***/
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},

  /*** 0040 ***/
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},

  /*** 0050 ***/
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(WWS32gethostbyaddr,            "GETHOSTBYADDR",        MOD_WINSOCK,    sizeof(GETHOSTBYADDR16))},
    {W32FUN(WWS32gethostbyname,            "GETHOSTBYNAME",        MOD_WINSOCK,    sizeof(GETHOSTBYNAME16))},
    {W32FUN(WWS32getprotobyname,           "GETPROTOBYNAME",       MOD_WINSOCK,    sizeof(GETPROTOBYNAME16))},
    {W32FUN(WWS32getprotobynumber,         "GETPROTOBYNUMBER",     MOD_WINSOCK,    sizeof(GETPROTOBYNUMBER16))},
    {W32FUN(WWS32getservbyname,            "GETSERVBYNAME",        MOD_WINSOCK,    sizeof(GETSERVBYNAME16))},
    {W32FUN(WWS32getservbyport,            "GETSERVBYPORT",        MOD_WINSOCK,    sizeof(GETSERVBYPORT16))},
    {W32FUN(WWS32gethostname,              "GETHOSTNAME",          MOD_WINSOCK,    sizeof(GETHOSTNAME16))},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},

  /*** 0060 ***/
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},

  /*** 0070 ***/
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                     MOD_WINSOCK,    0)},

  /*** 0080 ***/
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},

  /*** 0090 ***/
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},

  /*** 0100 ***/
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(WWS32WSAAsyncSelect,           "WSAASYNCSELECT",         MOD_WINSOCK,  sizeof(WSAASYNCSELECT16))},
    {W32FUN(WWS32WSAAsyncGetHostByAddr,    "WSAASYNCGETHOSTBYADDR",  MOD_WINSOCK,  sizeof(WSAASYNCGETHOSTBYADDR16))},
    {W32FUN(WWS32WSAAsyncGetHostByName,    "WSAASYNCGETHOSTBYNAME",  MOD_WINSOCK,  sizeof(WSAASYNCGETHOSTBYNAME16))},
    {W32FUN(WWS32WSAAsyncGetProtoByNumber, "WSAASYNCGETPROTOBYNUMBER",MOD_WINSOCK, sizeof(WSAASYNCGETPROTOBYNUMBER16))},
    {W32FUN(WWS32WSAAsyncGetProtoByName,   "WSAASYNCGETPROTOBYNAME", MOD_WINSOCK,  sizeof(WSAASYNCGETPROTOBYNAME16))},
    {W32FUN(WWS32WSAAsyncGetServByPort,    "WSAASYNCGETSERVBYPORT",  MOD_WINSOCK,  sizeof(WSAASYNCGETSERVBYPORT16))},
    {W32FUN(WWS32WSAAsyncGetServByName,    "WSAASYNCGETSERVBYNAME",  MOD_WINSOCK,  sizeof(WSAASYNCGETSERVBYNAME16))},
    {W32FUN(WWS32WSACancelAsyncRequest,    "WSACANCELASYNCREQUEST",  MOD_WINSOCK,  sizeof(WSACANCELASYNCREQUEST16))},
    {W32FUN(WWS32WSASetBlockingHook,       "WSASETBLOCKINGHOOK",     MOD_WINSOCK,  sizeof(WSASETBLOCKINGHOOK16))},

  /*** 0110 ***/
    {W32FUN(WWS32WSAUnhookBlockingHook,    "WSAUNHOOKBLOCKINGHOOK",  MOD_WINSOCK,  0)},
    {W32FUN(WWS32WSAGetLastError,          "WSAGETLASTERROR",        MOD_WINSOCK,  0)},
    {W32FUN(WWS32WSASetLastError,          "WSASETLASTERROR",        MOD_WINSOCK,  sizeof(WSASETLASTERROR16))},
    {W32FUN(WWS32WSACancelBlockingCall,    "WSACANCELBLOCKINGCALL",  MOD_WINSOCK,  0)},
    {W32FUN(WWS32WSAIsBlocking,            "WSAISBLOCKING",          MOD_WINSOCK,  0)},
    {W32FUN(WWS32WSAStartup,               "WSASTARTUP",             MOD_WINSOCK,  sizeof(WSASTARTUP16))},
    {W32FUN(WWS32WSACleanup,               "WSACLEANUP",             MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},

  /*** 0120 ***/
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},

  /*** 0130 ***/
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},

  /*** 0140 ***/
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},

  /*** 0150 ***/
    {W32FUN(UNIMPLEMENTEDAPI,              "",                       MOD_WINSOCK,  0)},
    {W32FUN(WWS32__WSAFDIsSet,             "__WSAFDISSET",           MOD_WINSOCK,  sizeof(__WSAFDISSET16))},
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\wwmtbl2.h ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, 1992, 1993 Microsoft Corporation
 *
 *  WKTBL2.h
 *  WOW32 wifeman API thunks
 *
 *  This file is included into the master thunk table.
 *
--*/
#ifdef FE_SB
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},

  /*** 0010 ***/
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},

  /*** 0020 ***/
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},

  /*** 0030 ***/
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},

  /*** 0040 ***/
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},

  /*** 0050 ***/
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},

  /*** 0060 ***/
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(WWM32MiscGetEUDCLeadByteRange, "MISCGETEUDCLEADBYTERANGE", MOD_WIFEMAN, sizeof(MISCGETEUDCLEADBYTERANGE16))},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
    {W32FUN(UNIMPLEMENTEDAPI,		"UNDEFINED",                MOD_WIFEMAN, 0)},
#endif // FE_SB

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\nec_98\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\i386\callpr32.asm ===
title "x86-only Helper routine for generic thunk interface CallProc32[Ex]W"
;++
;
; Copyright (c) 1996  Microsoft Corporation
;
; Module Name:
;
;    callpr32.asm
;
; Abstract:
;
;    WK32ICallProc32MakeCall is a helper routine for wkgthunk.c's
;    WK32ICallProc32, the common thunk for CallProc32W and
;    CallProc32ExW, the two generic thunk routines which allow
;    16-bit code to call any 32-bit function.
;
; Author:
;
;    Dave Hart (davehart) 23-Jan-96
;--
.386p

include callconv.inc

if DBG
DEBUG   equ 1
endif

ifdef DEBUG
DEBUG_OR_WOWPROFILE equ 1
endif
ifdef WOWPROFILE
DEBUG_OR_WOWPROFILE equ 1
endif

;include wow.inc

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

;        EXTRNP _DispatchInterrupts,0

_TEXT   ENDS


_DATA   SEGMENT  DWORD PUBLIC 'DATA'

;        extrn _aw32WOW:Dword

_DATA   ENDS




_TEXT   SEGMENT

        page    ,132
        subttl "WK32ICallProc32MakeCall"
;++
;
;   Routine Description:
;
;    WK32ICallProc32MakeCall is a helper routine for wkgthunk.c's
;    WK32ICallProc32, the common thunk for CallProc32W and
;    CallProc32ExW, the two generic thunk routines which allow
;    16-bit code to call any 32-bit function.
;
;    Like Win95's implementation, this code allows the called
;    routine to fail to restore esp (for example, if we are
;    told the routine is STDCALL but it's really CDECL).
;    A number of Works 95's Wizards don't work otherwise.
;
;   Arguments:
;
;       pfn        procedure to call
;       cArgs      count of DWORDs
;       pArgs      Argument array
;
;   Returns:
;
;       return value of called routine.
;

        assume DS:_DATA,ES:Nothing,SS:_DATA
ALIGN 16
cPublicProc _WK32ICallProc32MakeCall,3
.FPO (0,3,2,2,0,0)                ; 3 params, 2 byte prolog, 2 saved registers

        push    edi
        push    esi

pfn     equ     [esp+0ch]
cbArgs  equ     [esp+10h]
pArgs   equ     [esp+14h]

        mov     ecx,cbArgs
        mov     edx,pfn
        mov     edi,esp                ; Save ESP if no args
        or      ecx,ecx
        mov     eax,ecx
        jz      DoneArgs
        shr     ecx,2                  ; convert bytes to dwords

        mov     esi,pArgs
        sub     esp,eax                ; parm macros are invalid
        cld                            ; "push" the arguments
        mov     edi,esp
        rep movsd
                                       ; edi is left at correct post-call ESP
DoneArgs:

        call    edx
        mov     esp,edi

        pop     esi
        pop     edi
        stdRET  _WK32ICallProc32MakeCall

stdENDP _WK32ICallProc32MakeCall


_TEXT   ends

        end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow32\i386\fastwow.asm ===
title "Fast Protected Mode services"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    fastwow.asm
;
; Abstract:
;
;    This module implements a fast mechanism for WOW apps to go back
;    and forth from app code (protected mode, 16-bit segmented) to
;    WOW32.DLL (flat).
;
;
; Author:
;
;    Bob Day (bobday) 07-29-92
;    copied from FASTPM.ASM written by Dave Hastings (daveh) 26-Jul-91
;
;    barryb 11-nov-92       added fast callback mechanism, pared
;                           WOWBopEntry to the bare essentials (hopefully)
;
;
;    rules of thumb:
;       - monitor context gets saved on monitor stack on entry to
;         FastWOWCallbackCall and restored on the way out of FastWOWCallbackRet
;       - no need to save any VDM general registers - krnl286 uses the
;         WOW16Call stack frame for this
;       - you can't save anything on the 16-bit stack because the stack
;         gets tinkered with by DispatchInterrupts
;
;    WARNING    WARNING    WARNING    WARNING    WARNING    WARNING    WARNING
;       these routines are optimized for the straight-through case, no
;       interrupt being dispatched, so there's duplicate code in the
;       routines.  if you add stuff, be sure to add it to both paths.
;    WARNING    WARNING    WARNING    WARNING    WARNING    WARNING    WARNING
;
;    sudeepb 09-Dec-1992
;         Changed all the refernces to virtual interrupt flag in the VDMTIB
;         to fixed DOS location.
;--
.386p

include ks386.inc
include bop.inc
include wowtd.inc

if DBG
DEBUG   equ 1
endif

ifdef DEBUG
DEBUG_OR_WOWPROFILE equ 1
endif
ifdef WOWPROFILE
DEBUG_OR_WOWPROFILE equ 1
endif

include wow.inc
include callconv.inc
include vint.inc
include vdmtib.inc


        EXTRN   __imp__CurrentMonitorTeb:DWORD
        EXTRN   __imp__FlatAddress:DWORD

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:NOTHING, ES:NOTHING, SS:FLAT, FS:NOTHING, GS:NOTHING

        EXTRNP _DispatchInterrupts,0
        EXTRNP @W32PatchCodeWithLpfnw32, 2
        EXTRNP @InterpretThunk, 2

        EXTRNP _Ssync_WOW_CommDlg_Structs, 3

ifdef DEBUG
        EXTRNP _logargs,2
        EXTRNP _logreturn,3
endif

_TEXT   ENDS

_DATA   SEGMENT  DWORD PUBLIC 'DATA'
        extrn _aw32WOW:Dword

        public _WowpLockPrefixTable
_WowpLockPrefixTable    label dword
        dd offset FLAT:_wowlock1
        dd offset FLAT:_wowlock2
        dd offset FLAT:_wowlock3
        dd offset FLAT:_wowlock4
        dd offset FLAT:_wowlock5
        dd offset FLAT:_wowlock6
        dd 0

Stack16     LABEL   DWORD
_savesp16 DW  0
_savess16 DW  0

_saveip16 DD  0
_savecs16 DD  0

_saveebp32    DD    0

_saveeax    DD  0
_saveebx    DD  0
_saveecx    DD  0
_saveedx    DD  0

_fKernelCSIPFixed DB 0
_DATA   ENDS

public  _saveeax
public  _saveebx
public  _saveecx
public  _saveedx

public  _savesp16
public  _savess16
public  _savecs16
public  _saveip16
public  _saveebp32
public  _fKernelCSIPFixed
public  Stack16

;
; The variable fKernelCSIPFixed is used so the fastbop/callback mechanism
; knows when it no longer needs to pop the 16-bit return address off the
; 16-bit stack on entry to WOWBopEntry and FastWOWCallbackRet because kernel
; has booted and the address won't be changing.
;
;
; The assumption is that we're always coming from the same place in kernel.
; It also saves a jmp when returning to kernel.
;


_TEXT   SEGMENT

        page    ,132
        subttl "WOWBopEntry"
;++
;
;   Routine Description:
;
;       This routine switches from the VDM context to the monitor context.
;       Then executes the appropriate WOW api call.
;       Then returns back to the VDM context.
;
;   Arguments:
;
;       none
;
;   Returns:
;
;       puts result of WOW api call (EAX) into pFrame->wDX, pFrame->wAX
;
;   [LATER] add a field to the frame and set it to !0 if a task switch
;           has occurred.  kernel can read this off the stack instead
;           of having to load the kernelDS to look at wCurTDB
;

        assume DS:Nothing,ES:Nothing,SS:Nothing
ALIGN 16
cPublicProc _WOWBopEntry,0
        mov     bx,KGDT_R3_DATA OR RPL_MASK     ; Move back to Flat DS
        mov     ds,bx                           ; so push and pop size same
        assume ds:_DATA
        mov     _saveeax,eax                    ; Multi Media Apps call api's
        mov     _saveebx,ebx                    ; at interrupt time which trash
        mov     _saveecx,ecx                    ; the high parts of the 32 bit
        mov     _saveedx,edx                    ; registers.   [LATER] this
                                                ; should be moved to fame
        pushfd                                  ; Save them flags

        ; we make here the assumption that the c compiler always keeps the
        ; direction flag clear. We clear it here instead of restoring it
        ; from the context for performance
        cld

        mov     eax,KGDT_R3_TEB OR RPL_MASK     ; restore flat FS
        mov     fs,ax
        mov     ebx, dword ptr fs:[PcTeb]
        mov     ebx, dword ptr [ebx].TeVdm      ; get pointer to contexts

        ;
        ; start saving some of the 16-bit context
        ;

        ; Interrupts are always enabled in WOW, but if we are trying
        ; to simulate the fact that they are disabled, we need to
        ; turn them off in the structure.

        pop     eax
        mov     edx,dword ptr ds:FIXED_NTVDMSTATE_LINEAR ; Get simulated bits
        or      edx,NOT VDM_VIRTUAL_INTERRUPTS
        and     eax,edx                 ; Pass on interrupt bit if it was on
        mov     dword ptr [ebx].VtVdmContext.CsEFlags,eax

        ; Save the calling address
        ; this address remains constant once krnl286 has booted.
        ; these three instructions are cheaper than saving it
        ; [LATER] this can be reduced. how?

        cmp     _fKernelCSIPFixed, 0
        je      wbegetretaddress
        add     esp, 8                  ; pop cs, ip

wbe10:
        ; Save the stack (pre-call)
        mov     _savess16,di    ; 16-bit SS put in di by krnl286
        mov     _savesp16,sp

        ; switch Stacks

.errnz  (CsEsp + 4 - CsSegSS)
        lss     esp, [ebx].VtMonitorContext.CsEsp

        ; Now running on Monitor stack

        ; save hiword of ESI, EDI
        ; note that di has already been trashed
        ;
        ; [LATER] move this to the vdmframe, don't need to push it twice

        push    esi
        push    edi
        push    ebp

cPublicFpo 6,0                 ; locals, params
                               ; we only save 3 but FastWOWCallbackCall
                               ; saves 3 as well

        ; Set up flat segment registers

        mov     edx,KGDT_R3_DATA OR RPL_MASK
        mov     es,dx       ; Make them all point to DS
        mov     gs,dx       ; [LATER] do we really have to set up GS?

        mov     eax,KGDT_R3_TEB OR RPL_MASK     ; restore flat FS
        mov     fs,ax

        mov     ebp, _saveebp32

        ; Update the CURRENTPTD->vpStack
        mov     eax,fs:[PcTeb]
        mov     ecx,[eax+TbWOW32Reserved] ; move CURRENTPTD into ecx
        mov     esi, [Stack16]
        mov     dword ptr [ecx],esi       ; PTD->vpStack = vpCurrentStack


        ; Convert the 16:16 SS:SP pointer into a 32-bit flat pointer
        ; DI = 16-bit SS, put there by kernel

        and     esi, 0FFFFh                 ; esi = 16-bit sp
        and     edi, 0FFFFh                 ; remove junk from high word
        shr     edi, 3                      ; remove ring and table bits

        mov     edx, dword ptr [__imp__FlatAddress]
        add     esi, dword ptr [edx+edi*4]
        ; esi is now a flat pointer to the frame

        mov     eax,dword ptr [ecx+cbOffCOMMDLGTD]  ; ecx = CURRENTPTD
        cmp     eax,0                               ; eax = PTD->PCOMMDLGTD
        jnz     SsyncCommDlg16to32

SsyncContinue1:


ifdef DEBUG
        push    ecx
        stdCall _logargs,<3,esi>
        pop     ecx
endif


        ; Convert the wCallID into a Thunk routine address.

        mov     edx, dword ptr [esi].vf_wCallID

        ; esi = pFrame
        mov     [ecx].WtdFastWowEsp, esp
        test    edx, 0ffff0000h
        mov     eax, edx
        jnz     MakeCall
ifdef DEBUG
        imul    edx, size W32
else
.errnz  (size W32 - 4)
        shl     edx, 2
endif
        mov     edx, dword ptr [_aw32WOW + edx]    ; eax = aw32WOW[edx].lpfnW32
        test    edx, 0ffff0000h                    ; check for intthunk (hiword 0)
        jnz     @f
        mov     eax, @InterpretThunk@8
        jmp     MakeCall
@@:
        mov     ecx, esi  ; ecx  = pFrame & edx = lpfnW32
        call    @W32PatchCodeWithLpfnw32@8
MakeCall:
        mov     ecx, esi  ; ecx  = pFrame & edx = lpfnW32
        call    eax

ApiReturnAddress:

;
; IMPORTANT NOTE: Upon retruned from wow32 worker routine, the
;   non-volatile registers may be destroyed if it is returned via
;   try-except handler.
;

        mov     ebx, dword ptr [__imp__CurrentMonitorTeb]
        mov     ecx,fs:[PcTeb]
        mov     [ebx], ecx  ; Tell NTVDM which is the active thread
        mov     ecx,[ecx+TbWOW32Reserved]          ; move CURRENTPTD into ecx

        mov     ebx,dword ptr [ecx+cbOffCOMMDLGTD]  ; ecx = CURRENTPTD
        cmp     ebx,0                               ; ebx = PTD->PCOMMDLGTD
        jnz     SsyncCommDlg32to16

SsyncContinue2:

ifdef DEBUG
        push    ecx
        push    eax

        movzx   esi, word ptr [ecx]         ; offset
        movzx   edi, word ptr [ecx+2]       ; selector
        shr     edi, 3                      ; remove ring and table bits
        mov     ebx, dword ptr [__imp__FlatAddress]
        add     esi, dword ptr [ebx+edi*4]  ; esi = offset + base

        stdCall _logreturn,<5, esi, eax>

        pop     eax
        pop     ecx
endif
        mov     ebx, dword ptr fs:[PcTeb]
        mov     ebx, dword ptr [ebx].TeVdm      ; get pointer to contexts

        push    dword ptr [ebx].VtVdmContext.CsEFlags   ;get 16-bit flags
        popfd   ; in case the direction flag was set


        test    dword ptr ds:FIXED_NTVDMSTATE_LINEAR,dword ptr VDM_INTERRUPT_PENDING
        jnz     wl70

wl40:
        mov     _saveebp32, ebp

        pop     ebp
        pop     edi
        pop     esi

        mov     [ebx].VtMonitorContext.CsEsp,esp
        mov     [ecx].WtdFastWowEsp,esp

        ; return to vdm stack
        push    word ptr [ecx+2]
        push    word ptr 0
        push    word ptr [ecx]
        lss     esp,[esp]

        ; stick the API return value in the stack for kernel to pop.
        ; it's been in EAX since we called the thunk routine.

        mov     bx, sp          ; for temporary addressing
        mov     dword ptr ss:[bx].vf_wAX, eax

        ; return to VDM, fake a far jump
        push    _savecs16
        push    _saveip16

        mov     eax,_saveeax                    ; Retore High parts of regs
        mov     ebx,_saveebx
        mov     ecx,_saveecx
        mov     edx,_saveedx

        retf

        ;
wl60:   ; Interrupts are disabled, turn them off in the virtual flags
        ;
_wowlock1:
        lock and        dword ptr ds:FIXED_NTVDMSTATE_LINEAR,NOT VDM_VIRTUAL_INTERRUPTS
        jmp     wl40

        ;
wl70:   ; Interrupt came in, dispatch it
        ;

        ; translate the interrupt flag to the virtual interrupt flag
        ; if interrupts are disabled then blow it off

        test    [ebx].VtVdmContext.CsEFlags,dword ptr EFLAGS_INTERRUPT_MASK
        jz      wl60
_wowlock2:
        lock or         dword ptr ds:FIXED_NTVDMSTATE_LINEAR,dword ptr VDM_VIRTUAL_INTERRUPTS


        push    eax     ; save API return value
        push    ebx
        push    ecx

        ;
        ; refresh VdmTib.VtVdmContext so DispatchInterrupts can party
        ;

        ; ecx points to CURRENTPTD->vpStack 16-bit ss:sp

        mov     si, [ecx + 2]
        xor     edi,edi
        mov     di, [ecx]

        mov     eax, _saveip16
        mov     dword ptr [ebx].VtVdmContext.CsEip, eax
        mov     eax, _savecs16
        mov     dword ptr [ebx].VtVdmContext.CsSegCs, eax

        mov     word ptr [ebx].VtVdmContext.CsSegSs, si
        mov     dword ptr [ebx].VtVdmContext.CsEsp, edi

        stdCall _DispatchInterrupts
        test    dword ptr [ebx].VtVdmContext.CsEFlags,VDM_VIRTUAL_INTERRUPTS
        jnz     wl80
_wowlock3:
        lock and dword ptr ds:FIXED_NTVDMSTATE_LINEAR,NOT VDM_VIRTUAL_INTERRUPTS

wl80:   pop     ecx     ; points to ptd->vpStack
        pop     ebx
        pop     eax     ; eax = API return value

        mov     _saveebp32, ebp

        ; restore the hiwords of esi, edi
        pop     ebp
        pop     edi
        pop     esi

        mov     dword ptr [ebx].VtMonitorContext.CsEsp,esp
        mov     [ecx].WtdFastWowEsp,esp

        pushfd
        and     dword ptr [esp], 0ffffbfffH
        popfd

        ;
        ; switch to 16-bit stack (probably an interrupt stack)
        ;

.errnz  (CsEsp + 4 - CsSegSS)
        lss     esp, [ebx].VtVdmContext.CsEsp

        ;
        ; fake far jump to the 16-bit interrupt routine
        ;

        push    dword ptr [ebx].VtVdmContext.CsEflags
        push    dword ptr [ebx].VtVdmContext.CsSegCs
        push    dword ptr [ebx].VtVdmContext.CsEip

        ; stick the API return value in the stack for kernel to pop.
        ; it's been in EAX since we called the thunk routine.

 ;       les     bx, Stack16
        les     bx, [ecx]
        mov     dword ptr es:[bx].vf_wAX, eax

        mov     eax,_saveeax                    ; Retore High parts of regs
        mov     ebx,_saveebx
        mov     ecx,_saveecx
        mov     edx,_saveedx
        iretd

wbegetretaddress:

        pop     eax
        mov     _saveip16, eax
        pop     edx
        mov     _savecs16, edx

        jmp     wbe10

SsyncCommDlg16to32:

        push    ecx   ; save CURRENTPTD

        push    dword ptr [esi+cbOffwThunkCSIP]  ; esi = pFrame
        push    1                                ; 16to32 flag
        push    eax                              ; pComDlgTD
        call    _Ssync_WOW_CommDlg_Structs@12

        pop     ecx
        jmp     SsyncContinue1

SsyncCommDlg32to16:
        push    ecx   ; save CURRENTPTD
        push    eax   ; preserve API return value

        ; build a flat ptr to pFrame
        mov     esi, [ecx]
        and     esi, 0FFFFh                 ; esi = 16-bit sp
                                            ; edi should already be set

        mov     edx, dword ptr [__imp__FlatAddress]
        add     esi, dword ptr [edx+edi*4] ; esi = pframe

        push    dword ptr [esi+cbOffwThunkCSIP]  ; esi = pFrame
        push    0                                ; 32to16 flag
        push    ebx                              ; pComDlgTD
        call    _Ssync_WOW_CommDlg_Structs@12

        pop     eax
        pop     ecx
        jmp     SsyncContinue2

stdENDP _WOWBopEntry




cPublicProc _PostExceptionHandler,0
        assume ds:_DATA

;
;       Fixed up Exception registration pointer (just in case)
;

        mov     eax, fs:[PcExceptionList]
peh00:
        cmp     eax, esp
        jb      short @f

        mov     fs:[PcExceptionList], eax
        xor     eax, eax
        jmp     ApiReturnAddress

@@:
        mov     eax, [eax]                      ; move to next reg record
        jmp     short peh00

stdENDP _PostExceptionHandler

;++
;
;   VOID
;   W32SetExceptionContext (
;       PCONTEXT ContextRecord
;       );
;
;   Routine Description:
;
;       This functions updates exception context to our predefined
;       post-exception handler such that if we continue exception
;       execution the control will continue on our post-exception
;       handling code.
;
;   Arguments:
;
;       ContextRecord - supplies a pointer to the exception context.
;
;   Returns:
;
;       Exception context updated.
;--

cPublicProc _W32SetExceptionContext,1
        assume ds:_DATA

        push    fs      ; I don;t think we need this, just in case
        mov     ecx,KGDT_R3_TEB OR RPL_MASK     ; restore flat FS
        mov     fs,cx
        mov     ecx, fs:[PcTeb]
        mov     ecx, dword [ecx].TeVdm
        pop     fs

        mov     edx, [esp+4]            ; (edx) = Context Record
        mov     ecx, dword ptr [ecx].VtMonitorContext.CsEsp
        mov     [edx].CsEsp, ecx
        mov     [edx].CsEip, offset FLAT:_PostExceptionHandler
        stdRET  _W32SetExceptionContext

stdENDP _W32SetExceptionContext


;++
;
;   BOOLEAN
;   IsW32WorkerException (
;       VOID
;       );
;
;   Routine Description:
;
;       This function checks if the exception occurred in WOW32 API.
;
;   Arguments:
;
;       None
;
;   Returns:
;
;       returns a BOOLEAN value to indicate if this is WOW32 API exception.
;
;--

cPublicProc _IsW32WorkerException, 0
        assume  ds:_DATA

        mov     ecx, fs:[PcTeb]
        mov     ecx, [ecx].TbWOW32Reserved
        mov     eax, dword ptr [ecx].WtdFastWowEsp
        or      eax, eax
        jz      @f            ; FastWowEsp is zero, not worker exception
        mov     edx, [eax-4]
        cmp     edx, offset FLAT:ApiReturnAddress
        ; eax is still monitor esp, so it's nonzero
        je      short @f
        xor     eax, eax
@@:     stdRET  _IsW32WorkerException

stdENDP _IsW32WorkerException


_TEXT   ends

        page    ,132
        subttl "FastWOWCallbackCall"
;++
;
;   Routine Description:
;
;       This routine is a fast callback from WOW32 to 16-bit code.
;       It assumes that the 16-bit stack pointer is already in Stack16.
;       The caller must set this up with FastBopSetVDMStack() before
;       calling this routine.
;
;       WARNING:  only the minimal set of registers are saved/restored
;                 as a speed optimization.
;
;   Arguments:
;
;       none
;
;   Returns:
;
;       nothing.
;


_TEXT   SEGMENT

        assume DS:FLAT
cPublicProc _FastWOWCallbackCall,0

        ; Save monitor general registers on monitor stack
        ; we'll pick em back up on the way out of FastWOWCallbackRet

        push    esi
        push    edi
        push    ebx

        mov     ebx, fs:[PcTeb]
        mov     ebx, dword ptr [ebx].TeVdm

        ; translate the interrupt flag to the virtual interrupt flag

        test    [ebx].VtVdmContext.CsEFlags,dword ptr EFLAGS_INTERRUPT_MASK
        jz      fe10
_wowlock4:
        lock or dword ptr ds:FIXED_NTVDMSTATE_LINEAR,dword ptr VDM_VIRTUAL_INTERRUPTS

        test    dword ptr ds:FIXED_NTVDMSTATE_LINEAR,dword ptr VDM_INTERRUPT_PENDING
        jnz     fe70

        jmp     fe20

fe10:
_wowlock5:
        lock and dword ptr ds:FIXED_NTVDMSTATE_LINEAR, NOT VDM_VIRTUAL_INTERRUPTS
fe20:

        mov     _saveebp32, ebp

        mov     ecx, fs:[PcTeb]
        mov     ecx, [ecx].TbWOW32Reserved       ; move CURRENTPTD into ecx
        mov     [ebx].VtMonitorContext.CsEsp,esp
        mov     [ecx].WtdFastWowEsp,esp

        pushfd
        pop     ecx
        mov     [ebx].VtMonitorContext.CsEflags,ecx

        pushfd
        and     dword ptr [esp], 0ffffbfffH
        popfd

        ; switch to vdm stack
        push    _savess16
        push    word ptr 0
        push    _savesp16
        lss     esp, [esp]

        ; before going to 16 bit, patch ebp to zero the high bits
        ; hijaak pro app is relying upon hiword of ebp being 0
        and     ebp, 0ffffh

        ; put flags, cs, and ip onto the 16-bit stack so we can iret to krnl286

        push    dword ptr [ebx].VtVdmContext.CsEflags
        push    _savecs16
        push    _saveip16

        ; return to krnl286

        iretd


fe70:   ; Interrupt pending, dispatch it
        ;

        push    ebx
        push    eax

        ;
        ; refresh VdmTib.VtVdmContext so DispatchInterrupts can party
        ;

        mov     eax, _saveip16
        mov     edx, _savecs16
        mov     dword ptr [ebx].VtVdmContext.CsEip, eax
        mov     dword ptr [ebx].VtVdmContext.CsSegCs, edx

        mov     ax, _savess16
        xor     edx,edx
        mov     dx, _savesp16
        mov     word ptr [ebx].VtVdmContext.CsSegSs, ax
        mov     dword ptr [ebx].VtVdmContext.CsEsp, edx

        stdCall _DispatchInterrupts

        test    dword ptr [ebx].VtVdmContext.CsEFlags,VDM_VIRTUAL_INTERRUPTS
        jnz     fe80

_wowlock6:
        lock and dword ptr ds:FIXED_NTVDMSTATE_LINEAR,NOT VDM_VIRTUAL_INTERRUPTS

fe80:   pop     eax
        pop     ebx

        mov     _saveebp32, ebp

        mov     ecx, fs:[PcTeb]
        mov     ecx, [ecx].TbWOW32Reserved
        mov     [ebx].VtMonitorContext.CsEsp,esp
        mov     [ecx].WtdFastWowEsp,esp

        pushfd
        pop     ecx
        mov     [ebx].VtMonitorContext.CsEflags,ecx
        pushfd
        and     dword ptr [esp], 0ffffbfffH
        popfd


        ; switch to vdm stack
        push    word ptr [ebx].VtVdmContext.CsSegSs
        push    dword ptr [ebx].VtVdmContext.CsEsp
        lss     esp, [esp]

        ; put flags, cs, and ip onto the 16-bit stack so we can iret to krnl286

        ; before interrupts are dispatched, patch ebp to zero the high bits
        ; hijaak pro app is relying upon hiword of ebp being 0
        and     ebp, 0ffffh

        push    dword ptr [ebx].VtVdmContext.CsEflags
        push    dword ptr [ebx].VtVdmContext.CsSegCs
        push    dword ptr [ebx].VtVdmContext.CsEip

        ; return to krnl or interrupt routine

        iretd


stdENDP _FastWOWCallbackCall


;++
;
;   Routine Description:
;
;       This routine is called by krnl286 upon returning from a
;       callback.
;
;   Arguments:
;
;       none
;
;   Returns:
;
;       nothing
;
;       WARNING:  only the minimal set of registers are saved/restored
;                 as a speed optimization.
;
;
        assume DS:Nothing,ES:Nothing,SS:Nothing
ALIGN 16
cPublicProc _FastWOWCallbackRet,0

        mov     ebx,KGDT_R3_DATA OR RPL_MASK
        mov     ds,bx
        assume ds:_DATA

        mov     ebx, KGDT_R3_TEB OR RPL_MASK
        mov     fs, bx
        mov     ebx, fs:[PcTeb]
        mov     ebx, dword ptr [ebx].TeVdm

        pushfd
        pop     eax
        mov     dword ptr [ebx].VtVdmContext.CsEFlags,eax


        ; the words at top of stack are the return address of our
        ; caller (krnl286).
        ; this address remains constant once krnl286 has booted.
        ; these three instructions are cheaper than saving it

        cmp     _fKernelCSIPFixed, 0
        je      fwcbrgetretaddress

        add     esp, 8                  ; pop cs, ip

fwcbr10:

        ; refresh CURRENTPTD->vpStack with the current stack

        ;mov     ecx, KGDT_R3_TEB OR RPL_MASK
        ;mov     fs, cx
        mov     eax, fs:[PcTeb]
        mov     ecx, [eax+TbWOW32Reserved] ; move CURRENTPTD into ecx

        mov     _savess16,ss
        mov     _savesp16,sp

        mov     esi, [Stack16]
        mov     [ecx], esi

        movzx   esi,si

        mov     dword ptr [ebx].VtVdmContext.CsEsp, esi
        mov     word ptr [ebx].VtVdmContext.CsSegSs, ss

        ; switch Stacks
.errnz  (CsEsp + 4 - CsSegSS)
        lss     esp, [ebx].VtMonitorContext.CsEsp

        ; Now running on Monitor stack

        test    dword ptr ds:FIXED_NTVDMSTATE_LINEAR,dword ptr VDM_VIRTUAL_INTERRUPTS
        jz      fl10

        or      [ebx].VtVdmContext.CsEFlags,dword ptr EFLAGS_INTERRUPT_MASK
        jmp     fl20

fl10:   and     dword ptr [ebx].VtVdmContext.CsEFlags, NOT EFLAGS_INTERRUPT_MASK
fl20:

        ; set up Monitor regs

        mov     esi, KGDT_R3_DATA OR RPL_MASK
        mov     es, si
        ; [LATER]  do we really have to set up the GS?
        mov     gs, si

        ; set up Monitor general regs

        mov     ebp, _saveebp32

        ; return

        pop     ebx
        pop     edi
        pop     esi
        ret

fwcbrgetretaddress:

        pop     eax
        pop     edx

        mov     _saveip16, eax
        mov     _savecs16, edx

        jmp     fwcbr10

stdENDP _FastWOWCallbackRet


;++
;
;   Routine Description:
;
;       This returns the current task's 16-bit ss:sp (vpStack)
;
;   Arguments:
;
;       none
;
;   Returns:
;
;       returns a 32-bit value that can be passed to GetVDMPointer
;

        assume DS:_DATA,SS:Nothing
cPublicProc _FastBopVDMStack,0
        mov     eax, [Stack16]
        stdRET  _FastBopVDMStack

stdENDP _FastBopVDMStack


;++
;
;   Routine Description:
;
;       This sets the current task's 16-bit ss:sp (vpStack),
;       used only when FASTSTACK is enabled.
;
;   Arguments:
;
;       vpStack  (32-bit ss:sp, not a flat pointer)
;
;   Returns:
;
;       none
;

cPublicProc _FastBopSetVDMStack,1

        mov     eax, [esp+4]
        mov     [Stack16], eax
        stdRET  _FastBopSetVDMStack

stdENDP _FastBopSetVDMStack

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\xms.486\sources.inc ===
!IF 0

Copyright (c) 1989-1991 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

MAJORCOMP=mvdm
MINORCOMP=xms

TARGETNAME=xms486
TARGETPATH=obj
TARGETTYPE=LIBRARY

SOFTPC_TREE=$(PROJECT_ROOT)\mvdm\softpc.new

INCLUDES=\
    ..;\
    ..\..\inc;\
    $(SOFTPC_TREE)\base\inc

!IF $(ALPHA) || $(MIPS)
GPSIZE=0
!ELSE
GPSIZE=32
!ENDIF

SOURCES=..\xms.c       \
        ..\xmsa20.c    \
        ..\xmsblock.c  \
        ..\xmsdisp.c   \
        ..\xmsmisc.c   \
        ..\xmsumb.c

i386_SOURCES=..\i386\xmsmem86.c
MIPS_SOURCES=..\xmsmemr.c
ALPHA_SOURCES=..\xmsmemr.c
PPC_SOURCES=..\xmsmemr.c

C_DEFINES=-DWIN_32

UMTYPE=console
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\xms.486\xmsa20.c ===
/* xmsa20.c - A20 related XMS routines
 *
 * XMSA20
 *
 * Modification History:
 *
 * Sudeepb 15-May-1991 Created
 */

#include "xms.h"

#include <xmssvc.h>
#include <softpc.h>

void sas_enable_20_bit_wrapping(void);
void sas_disable_20_bit_wrapping(void);
BOOL sas_twenty_bit_wrapping_enabled(void);

BYTE * pHimemA20State = NULL;


/* xmsA20 - Handle A20 requests
 *
 *
 * Entry - Client (AX) 0 - Disable A20
 *		       1 - Enable A20
 *		       2 - Query
 *
 * Exit
 *	   SUCCESS
 *	     Client (AX) = 1
 *	     if on entry AX=2 Then
 *		Cleint (AX) =1 means was enabled
 *		Cleint (AX) =0 means was disabled
 *
 *	   FAILURE
 *	     Client (AX) = 0
 */

VOID xmsA20 (VOID)
{
    int reason;

    reason = getAX();

    setAX(1);

    if (reason == 0)
	xmsEnableA20Wrapping();
    else if (reason == 1)
	    xmsDisableA20Wrapping();
	 else if (reason == 2) {
		if (sas_twenty_bit_wrapping_enabled())
		    setAX(0);
		setBL(0);
	      }
	      else
		setAX(0);
}
// function to enable 1MB wrapping (turn off A20 line)
VOID xmsEnableA20Wrapping(VOID)
{
    sas_enable_20_bit_wrapping();
    if (pHimemA20State != NULL)
	*pHimemA20State = 0;

#if 0 // this is not necessay because the intel space(pointed by
      // HimemA20State) doesn't contain instruction
      // doesn't contain instruction
#ifdef MIPS
	Sim32FlushVDMPointer
	 (
	  (((ULONG)pHimemA20State >> 4) << 16) | ((ULONG)pHimemA20State & 0xF),
	  1,
	  pHimemA20State,
	  FALSE
	 );

#endif
#endif

}

// function to disable 1MB wrapping(turn on A20 line)
VOID xmsDisableA20Wrapping(VOID)
{

    sas_disable_20_bit_wrapping();
    if (pHimemA20State != NULL)
	*pHimemA20State = 1;
#if 0 // this is not necessay because the intel space(pointed by
      // HimemA20State) doesn't contain instruction
      // doesn't contain instruction
#ifdef MIPS
	Sim32FlushVDMPointer
	 (
	  (((ULONG)pHimemA20State >> 4) << 16) | ((ULONG)pHimemA20State & 0xF),
	  1,
	  pHimemA20State,
	  FALSE
	 );

#endif
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\xms.486\xmsdisp.c ===
/*
 *  xmsdisp.c - SVC dispatch module for XMS
 *
 *  Modification History:
 *
 *  Sudeepb 15-May-1991 Created
 *
 *  williamh 25-Sept-1992 Added UMB support
 */

#include <xms.h>
#include <xmsexp.h>
#include <stdio.h>
#include <softpc.h>
#include <xmssvc.h>

PFNSVC	apfnXMSSvc [] = {
     xmsA20,		    // XMS_A20
     xmsMoveBlock,	    // XMS_MOVEBLOCK
     xmsAllocBlock,	    // XMS_ALLOCBLOCK
     xmsFreeBlock,	    // XMS_FREEBLOCK
     xmsSysPageSize,	    // XMS_SYSTEMPAGESIZE
     xmsQueryExtMem,	    // XMS_EXTMEM
     xmsInitUMB,	    // XMS_INITUMB
     xmsRequestUMB,	    // XMS_REQUESTUMB
     xmsReleaseUMB,         // XMS_RELEASEUMB
     xmsNotifyHookI15,      // XMS_NOTIFYHOOKI15
     xmsQueryFreeExtMem,    // XMS_QUERYEXTMEM
     xmsReallocBlock        // XMS_REALLOCBLOCK
};

/* XMSDispatch - Dispatch SVC call to right handler.
 *
 * Entry - iSvc (SVC byte following SVCop)
 *
 * Exit  - None
 *
 * Note  - Some mechanism has to be worked out to let the emulator know
 *	   about DOSKRNL code segment and size. Using these it will figure
 *	   out whether SVCop (hlt for the moment) has to be passed to
 *	   DEM or to be handled as normal invalid opcode.
 */

BOOL XMSDispatch (ULONG iSvc)
{

#if DBG

    if (iSvc >= XMS_LASTSVC){
	printf("XMS:Unimplemented SVC index %x\n",iSvc);
	setCF(1);
	return FALSE;
    }

#endif

    (apfnXMSSvc [iSvc])();
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\xms.486\xmsmemr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    xmscmt86.c

Abstract:

    This module conains the memory commit/decommit/move routines
    for risc.

Author:

    Dave Hastings (daveh) creation-date 25-Jan-1994

Revision History:


--*/
#include <xms.h>
#include <suballoc.h>
#include <softpc.h>

NTSTATUS
xmsCommitBlock(
    ULONG BaseAddress,
    ULONG Size
    )
/*++

Routine Description:

    This routine commits a block of memory using sas_manage_xms.

Arguments:

    BaseAddress -- Supplies the base address to commit memory at
    Size -- Supplies the size of the block to commit
    
Return Value:

    0 if successfull

--*/
{
    BOOL Status;
    
    //
    // Perform the allocation
    //
    Status = sas_manage_xms( 
        (PVOID)BaseAddress,
        Size,
        1
        );

    //
    // We elected to have 0 indicate success, because that allows
    // us to directly pass back NTSTATUS codes.  On x86 we use
    // NT memory management to do the commit for us, and the returned
    // status code contains more information than just success or failure
    //
    
    if (Status) {
        return STATUS_SUCCESS;
    } else {
        return -1;
    }
}

NTSTATUS
xmsDecommitBlock(
    ULONG BaseAddress,
    ULONG Size
    )
/*++

Routine Description:

    This routine commits a block of memory using sas_manage_xms.

Arguments:

    BaseAddress -- Supplies the base address to decommit memory at
    Size -- Supplies the size of the block to decommit
    
Return Value:

    0 if successful

--*/
{
    BOOL Status;
    
    //
    // Perform the allocation
    //
    Status = sas_manage_xms(
        (PVOID)BaseAddress,
        Size,
        2
        );
        
    //
    // We elected to have 0 indicate success, because that allows
    // us to directly pass back NTSTATUS codes.  On x86 we use
    // NT memory management to do the commit for us, and the returned
    // status code contains more information than just success or failure
    //
    if (Status) {
        return STATUS_SUCCESS;
    } else {
        return -1;
    }
}

VOID
xmsMoveMemory(
    ULONG Destination,
    ULONG Source,
    ULONG Count
    )
/*++

Routine Description:

    This routine moves a block of memory, and notifies the emulator.
    It correctly handles overlapping source and destination

Arguments:

    Destination -- Supplies a pointer to the destination Intel (NOT Linear)
        Address
    Source -- Supplies a pointer to the source Intel Address
    Count -- Supplies the number of bytes to move
    
Return Value:

    None.

--*/
{
    ULONG SoftpcBase;
    
    //
    // Get the linear address of the beginning of Intel memory
    //
    SoftpcBase = (ULONG) GetVDMAddr(0,0);
    
    //
    // Move the memory
    //
    RtlMoveMemory(
        (PVOID)((ULONG)Destination + SoftpcBase),
        (PVOID)((ULONG)Source + SoftpcBase),
        Count
        );

    // WARNING!!!! Donot use Sim32FlushVDMPoiner unless you know the exact segment
    // address. In this case, we have no idea what the segment value is, all we
    // know is its "linear address".

    sas_overwrite_memory((PBYTE)Destination, Count);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\xms.486\xms.h ===
/* xms.h - main include file for dem
 *
 * Modification History
 *
 * Sudeepb 31-Mar-1991 Created
 *
 * williamh 25-Sept-1992 Added UMB support
 */

/*
#define WIN
#define FLAT_32
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define _WINDOWS
#include <windows.h>

*/

#ifdef DOS
#define SIGNALS
#endif

#ifdef OS2_16
#define OS2
#define SIGNALS
#endif

#ifdef OS2_32
#define OS2
#define FLAT_32
#endif

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <process.h>

#ifdef WIN_16
#define WIN
#define API16
#endif

#ifdef WIN_32
#define WIN
#define FLAT_32
#define TRUE_IF_WIN32	1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#else
#define TRUE_IF_WIN32	0
#endif

#ifdef FLAT_32
#ifndef i386
#define ALIGN_32
#else
#define NOALIGN_32
#endif
#endif

#ifdef WIN
#define _WINDOWS
#include <windows.h>
#endif

#ifdef SIGNALS
#include <conio.h>
#include <signal.h>
#endif

#ifdef OS2_32
#include <excpt.h>
#define XCPT_SIGNAL	0xC0010003
#endif
#include <xmsexp.h>
#include <suballoc.h>

#define SIZE_PARAGRAPH	16
#define XMSUMB_THRESHOLD    3 * SIZE_PARAGRAPH

/** Basic Typedefs of XMS **/

typedef VOID (*PFNSVC)(VOID);

typedef struct _ExtMemMove {
    ULONG   mm_len;		// Move Length
    USHORT  mm_hSource; 	// Source Handle
    ULONG   mm_SourceOffset;	// Source Offset
    USHORT  mm_hDest;		// Dest Handle
    ULONG   mm_DestOffset;	// Dest. offset
} EXTMEMMOVE, *PEXTMEMMOVE;


typedef struct _XMSUMB_ {
    WORD    Segment;
    WORD    Size;
    WORD    Owner;
    struct _XMSUMB_ *Next;
} XMSUMB, *PXMSUMB;

/** Function Prototypes */

VOID xmsA20		    (VOID);
VOID xmsAllocBlock	    (VOID);
VOID xmsFreeBlock	    (VOID);
VOID xmsReallocBlock	    (VOID);
VOID xmsMoveBlock	    (VOID);
VOID xmsSysPageSize	    (VOID);
VOID xmsQueryExtMem	    (VOID);
VOID xmsQueryFreeExtMem	    (VOID);
ULONG xmsGetMemorySize	    (BOOL);
ULONG xmsGetDefaultVDMSize  (VOID);
VOID xmsInitUMB		    (VOID);
VOID xmsRequestUMB	    (VOID);
VOID xmsReleaseUMB	    (VOID);
VOID xmsReleaseUMBNotify    (PVOID, ULONG);
VOID xmsInsertUMB           (PVOID, ULONG);
VOID xmsNotifyHookI15       (VOID);

VOID xmsDisableA20Wrapping   (VOID);
VOID xmsEnableA20Wrapping   (VOID);

NTSTATUS
xmsCommitBlock(
    ULONG BaseAddress,
    ULONG Size
    );

NTSTATUS
xmsDecommitBlock(
    ULONG BaseAddress,
    ULONG Size
    );

VOID
xmsMoveMemory(
    ULONG Source,
    ULONG Destination,
    ULONG Count
    );


#ifndef i386
BOOL sas_manage_xms (VOID * start_addr, ULONG cb, INT a_or_f);
#endif

/** External Data */

extern ULONG xmsMemorySize;
extern BYTE * pHimemA20State;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\xms.486\xms.c ===
/*
 *  xms.c - Main Module of XMS DLL.
 *
 *  Sudeepb 15-May-1991 Craeted
 *  williamh 25-Sept-1992 added UMB support
 *  williamh 10-10-1992 added A20 line support
 */

#include <xms.h>
#include <suballoc.h>
#include "umb.h"
#include "memapi.h"

/* XMSInit - XMS Initialiazation routine. (This name may change when XMS is
 *       converted to DLL).
 *
 * Entry
 *  None
 *
 * Exit
 *  None
 */

ULONG xmsMemorySize = (ULONG)0;   // Total XMS meory in K

extern BOOL VDMForWOW;

PVOID ExtMemSA;

BOOL XMSInit (int argc, char *argv[])
{
    DWORD   Size;
    PVOID   Address;
    ULONG   VdmAddress, XmsSize;
    NTSTATUS Status;

    if (!xmsMemorySize)
        return FALSE;

    Size = 0;
    Address = NULL;
    // commit all free UMBs.
    ReserveUMB(UMB_OWNER_RAM, &Address, &Size);

    XmsSize = xmsMemorySize * 1024 - (64*1024);

#ifndef i386
    Status = VdmAllocateVirtualMemory(&VdmAddress,
                                      XmsSize,
                                      FALSE);

    if (Status == STATUS_NOT_IMPLEMENTED) {

        // Old emulator, just assume base address
#endif ; //i386
        //
        // Initialize the sub allocator
        //
        ExtMemSA = SAInitialize(
            1024 * 1024 + 64*1024,
            XmsSize,
            xmsCommitBlock,
            xmsDecommitBlock,
            xmsMoveMemory
            );

#ifndef i386
    } else {

        //
        // New emulator. Make sure the reserve worked
        //

        if (!NT_SUCCESS(Status)) {
            ASSERT(FALSE);
            return FALSE;
        }
       
        //
        // We only work correctly if emulator returned this value
        //
        if (VdmAddress != (1024 * 1024 + 64*1024)) {
            ASSERT(FALSE);
            return FALSE;
        }

        ExtMemSA = SAInitialize(
            VdmAddress,
            XmsSize,
            VdmCommitVirtualMemory,
            VdmDeCommitVirtualMemory,
            xmsMoveMemory
            );
            
    }
#endif // i386

    if (ExtMemSA == NULL) {
        return FALSE;
    }
        
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\xms.486\xmsmisc.c ===
/* xmsmisc.c - Misc. Support Functions for himem.
 *
 * xmsSysPageSize
 * xmsQueryExtMem
 *
 * Modification History:
 *
 * Sudeepb 15-May-1991 Created
 */

#include "xms.h"

#include <xmssvc.h>
#include <softpc.h>

extern void UpdateKbdInt15(WORD Seg,WORD Off);

/* xmsSysPageSize - Get the System Page size.
 *
 *
 * Entry - None
 *
 * Exit
 *	   SUCCESS
 *	     Client (AX) = Page Size in bytes
 *
 *	   FAILURE
 *	     Not Valid
 */

VOID xmsSysPageSize (VOID)
{
SYSTEM_INFO SysInfo;

    GetSystemInfo(&SysInfo);

    setAX((USHORT)SysInfo.dwPageSize);

    return;
}



/* xmsQueryExtMem - Get the extended memory for the vdm
 *
 *
 * Entry - None
 *
 * Exit
 *	   SUCCESS
 *	     Client (AX) = Extended Memory in K
 *
 *	   FAILURE
 *	     Not Valid
 */

VOID xmsQueryExtMem (VOID)
{
    setAX((USHORT)(xmsMemorySize));
    return;
}


/* xmsNotifyHookI15 - Informs softpc that someone is hooking I15
 *            - also returns the extended memory for the vdm
 *
 *
 * Entry -   Client (CS:AX) seg:off of new I15 vector
 *
 * Exit
 *         SUCCESS
 *           Client (CX) = Extended Memory in K
 *
 *	   FAILURE
 *	     Not Valid
 */

VOID xmsNotifyHookI15 (VOID)
{
    UpdateKbdInt15(getCS(), getAX());

    setCX((USHORT)(xmsMemorySize));
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\xms.486\xmsblock.c ===
/* xmsblock.c - XMS Extended block related routines
 *
 * xmsAllocBlock
 * xmsFreeBlock
 * xmsReallocBlock
 * xmsMoveBlock
 * xmsQueryExtMem
 *
 * Modification History:
 *
 * Sudeepb 15-May-1991 Created
 */

#include "xms.h"
#include <memory.h>
#include <string.h>
#include <xmssvc.h>
#include <softpc.h>
#include <mvdm.h>


/* xmsAllocBlock - Commit Memory for an EMB.
 *
 *
 * Entry - DX    - Size in K to allocate 
 *
 * Exit
 *	   SUCCESS
 *	     Client (AX) - Start address of the EMB (in K)
 *
 *	   FAILURE
 *	     Client (AX) = 0
 */

VOID xmsAllocBlock (VOID)
{
BOOL Success;
ULONG BaseAddress;
ULONG size;

    size = getDX() * 1024;
    if(size) {

        //
        // Ask for a chunk of memory
        //
        Success = SAAllocate(
            ExtMemSA,
            size,
            &BaseAddress
            );
            
        if (!Success) {
            DbgPrint("xmsAllocBlock:SAAlloc failed !!!!\n");
            setAX(0);
            return;
        }
    }
    else
	BaseAddress = 0;

    ASSERT((USHORT)(BaseAddress / 1024) < 65535);
    setAX((USHORT)(BaseAddress / 1024));
    return;
}

/* xmsFreeBlock - Free Memory for an EMB.
 *
 *
 * Entry - AX	 - Start address of the EMB (in K)
 *	   DX	 - Size in K to free 
 *
 * Exit
 *	   SUCCESS
 *	     Client (AX) = 1
 *
 *	   FAILURE
 *	     Client (AX) = 0
 */

VOID xmsFreeBlock (VOID)
{
BOOL Success;
ULONG BaseAddress;
ULONG size;

    BaseAddress = (getAX() * 1024);
    size = getDX() * 1024;

    Success = SAFree(
        ExtMemSA,
        size,
        BaseAddress
        );
        
    if (!Success) {
        DbgPrint("xmsFreeBlock:SAFree failed !!!!");
        setAX(0);
        return;
    }

    setAX(1);
    return;
}

/* xmsReallocBlock - Change the size of an EMB.
 *
 *
 * Entry - AX       - Start address of the EMB (in K)
 *	   DX       - Original Size in K
 *         BX       - New size in K
 *
 * Exit
 *	   SUCCESS
 *	     Client (CX) = New base of block
 *
 *	   FAILURE
 *	     Client (AX) = 0
 */

VOID xmsReallocBlock (VOID)
{
BOOL Success;
ULONG BaseAddress;
ULONG NewAddress;
ULONG size;
ULONG NewSize;

    size = getDX() * 1024;
    NewSize = getBX() * 1024;
    BaseAddress = getAX() * 1024;
    if(size != NewSize) {

        //
        // Realloc the chunk of memory
        //
        Success = SAReallocate(
            ExtMemSA,
            size,
            BaseAddress,
            NewSize,
            &NewAddress
            );
            
        if (!Success) {
            DbgPrint("xmsReallocBlock:SARealloc failed !!!!\n");
            setCX(0);
            return;
        }
    }
    else
    {
	NewAddress = BaseAddress;
    }

    ASSERT((NewAddress / 1024) < 65535);
    setCX((USHORT)(NewAddress / 1024));
    return;
}

/* xmsMoveBlock - Process Move Block Functions
 *
 *
 * Entry - Client (SS:BP) Pointer to Ext. Memory Move Structure
 *	    SS:BP-4	= DWORD Transfer Count in words (guaranteed even)
 *	    SS:BP-8	= DWORD Src Linear Address
 *	    SS:BP-12	= DWORD Dst Linear Address
 *
 * Exit
 *	   SUCCESS
 *	     Client (AX) = 1
 *
 *	   FAILURE
 *	     Client (AX) = 0
 *	     Client (BL) = error code
 *
 *  NOTE: For Overlapping regions XMS spec says "If the Source and
 *	  Destination blocks overlap, only forward moves (i.e. where
 *	  the destination base is less than the source base) are
 *	  guaranteed to work properly"
 */

VOID xmsMoveBlock (VOID)
{
PBYTE	pExtMoveInfo,pSrc,pDst;
ULONG	cbTransfer,SoftpcBase, DstSegOff;

    pExtMoveInfo = (PBYTE) GetVDMAddr(getSS(),getBP());
    (ULONG)pExtMoveInfo = (ULONG)pExtMoveInfo -4;
    cbTransfer = (FETCHDWORD(*(PULONG)pExtMoveInfo));
    cbTransfer *= 2;					// Get in bytes
    (ULONG)pExtMoveInfo = (ULONG)pExtMoveInfo -4;
    (DWORD)pSrc = FETCHDWORD(*(PULONG)pExtMoveInfo);
    (ULONG)pExtMoveInfo = (ULONG)pExtMoveInfo -4;
    (DWORD)pDst = FETCHDWORD(*(PULONG)pExtMoveInfo);

    // Yes, we could use memmov for handling the overlapping regions
    // but XMS spec wants memcpy behaviour.

#ifdef i386
    RtlCopyMemory (pDst,pSrc,cbTransfer);
#else
    SoftpcBase = (ULONG) GetVDMAddr (0,0);
    RtlCopyMemory((PVOID)((ULONG)pDst + SoftpcBase),
	   (PVOID)((ULONG)pSrc + SoftpcBase),
	   cbTransfer);
    // if we touched the intel memory, tell the emulator to flush its cache
    // WARNING!!!! Donot use Sim32FlushVDMPoiner unless you know the exact segment
    // address. In this case, we have no idea what the segment value is, all we
    // know is its "linear address".
    // BUGBUG verify whether we can ignore the case with pDst > 0x110000
    sas_overwrite_memory(pDst, cbTransfer);

#endif
    setAX(1);
    return;
}

/* xmsQueryExtMem - Process query extended memory
 *
 *
 * Entry - None
 *
 * Exit
 *	   SUCCESS
 *	     Client (AX) = Largest Free Block in K
 *	     Client (DX) = Free Memory in K
 *
 *	   FAILURE
 *	     Client (AX) = 0
 *	     Client (DX) = 0
 *
 */
VOID xmsQueryFreeExtMem(VOID)
{
    ULONG LargestFree = 0;
    ULONG TotalFree = 0;
    
    //
    // Find out how much memory remains
    //
    SAQueryFree(
        ExtMemSA,
        &TotalFree,
        &LargestFree
        );
        
    ASSERT((TotalFree / 1024) < 65534);
    setAX((USHORT)(TotalFree / 1024));
    ASSERT((LargestFree / 1024) < 65534);
    setDX((USHORT)(LargestFree / 1024));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\xms.486\i386\xmsmem86.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    xmscmt86.c

Abstract:

    This module conains the memory commit/decommit routines
    for x86.

Author:

    Dave Hastings (daveh) creation-date 25-Jan-1994

Revision History:


--*/
#include <xms.h>
#include <suballoc.h>

NTSTATUS
xmsCommitBlock(
    ULONG BaseAddress,
    ULONG Size
    )
/*++

Routine Description:

    This routine commits a block of memory using NtAllocateVirtualMemory.

Arguments:

    BaseAddress -- Supplies the base address to commit memory at
    Size -- Supplies the size of the block to commit
    
Return Value:

    Same as NtAllocateVirtualMemory.

--*/
{
    PVOID Address;
    ULONG s;
    NTSTATUS Status;
    
    //
    // Copy the parameters locally, so that MM doesn't 
    // change them for us
    //
    Address = (PVOID)BaseAddress;
    s = Size;
    
    //
    // Perform the allocation
    //
    Status = NtAllocateVirtualMemory( 
        NtCurrentProcess(),
        &Address,
        0L,
        &s,
        MEM_COMMIT,
        PAGE_READWRITE
        );

    return Status;
}

NTSTATUS
xmsDecommitBlock(
    ULONG BaseAddress,
    ULONG Size
    )
/*++

Routine Description:

    This routine commits a block of memory using NtAllocateVirtualMemory.

Arguments:

    BaseAddress -- Supplies the base address to decommit memory at
    Size -- Supplies the size of the block to decommit
    
Return Value:

    Same as NtFreeVirtualMemory.

--*/
{
    PVOID Address;
    ULONG s;
    NTSTATUS Status;
    
    //
    // Copy the parameters locally, so that MM doesn't 
    // change them for us
    //
    Address = (PVOID)BaseAddress;
    s = Size;
    
    //
    // Perform the allocation
    //
    Status = NtFreeVirtualMemory( NtCurrentProcess(),
        &Address,
        &s,
        MEM_DECOMMIT
        );

    return Status;
}

VOID
xmsMoveMemory(
    ULONG Destination,
    ULONG Source,
    ULONG Count
    )
/*++

Routine Description:

    This routine moves a block of memory, and notifies the emulator.
    It correctly handles overlapping source and destination

Arguments:

    Destination -- Supplies a pointer to the destination Linear
        Address
    Source -- Supplies a pointer to the source Linear Address
    Count -- Supplies the number of bytes to move
    
Return Value:

    None.

--*/
{
   
    //
    // Move the memory
    //
    RtlMoveMemory(
        (PVOID)Destination,
        (PVOID)Source,
        Count
        );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\xms.486\xmsumb.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    XNSUMB.C

Abstract:

    Routines to service XMS Request UMB and Release UMB functions.
    Also includes UMB initialization routine

Author:

    William Hsieh (williamh) Created 23-Sept-1992

[Environment:]

    User mode, running in the MVDM context (bop from 16bits)

[Notes:]



Revision History:

--*/
#include    <xms.h>
#include    "umb.h"
#include    "softpc.h"



// This global variable points to the first node(lowest address) UMB list
static PXMSUMB	xmsUMBHead;
static BOOL xmsIsON = FALSE;
// ------------------------------------------------------------------
// Initialization for UMB support. It create a single direction linked
// list and allocate all available UMBs.
// Input: client (AX:BX) = segment:offset of himem.sys A20State variable
//
// Output: list header, xmsUMBHead set.
//-------------------------------------------------------------------
VOID  xmsInitUMB(VOID)
{
    PVOID   Address;
    ULONG   Size;
    PXMSUMB xmsUMB, xmsUMBNew;
    xmsUMBHead = NULL;
    while (ReserveUMB(UMB_OWNER_XMS, &Address, &Size) &&
	   (xmsUMBNew = (PXMSUMB) malloc(sizeof(XMSUMB))) != NULL) {
	    // convert size in bytes to paragraphs
	    xmsUMBNew->Size = (WORD) (Size >> 4);
	    // convert linear address to paragraphs segment
	    xmsUMBNew->Segment = (WORD)((DWORD)Address >> 4);
	    xmsUMBNew->Owner = 0;
	    if (xmsUMBHead == NULL) {
		xmsUMBHead = xmsUMBNew;
		xmsUMBHead->Next = NULL;
	    }
	    else {
		xmsUMBNew->Next = xmsUMB->Next;
		xmsUMB->Next = xmsUMBNew;
	    }
	    xmsUMB = xmsUMBNew;
    }
    xmsIsON = TRUE;
    pHimemA20State = (PBYTE) GetVDMAddr(getAX(), getBX());
    xmsEnableA20Wrapping();



}

// This function receives control whenever there has been an UMB released
// Input: PVOID Address = the block address
//	  ULONG Size = the block size
VOID xmsReleaseUMBNotify(
PVOID	Address,
DWORD	Size
)
{
    // If the block is good and xms driver is ON,
    // grab the block and insert it into our xms UMB list
    if (Address != NULL && Size > 0  && xmsIsON &&
	ReserveUMB(UMB_OWNER_XMS, &Address, &Size)){
	xmsInsertUMB(Address, Size);
    }

}
// ------------------------------------------------------------------
// Insert a given UMB into the list
// Input: PVOID Address = linear address of the block to be inserted
//	  ULONG Size = size in byte of the block
// Output: TRUE if the block was inserted to the list successfully
//	   FALSE if the block wasn't inserted
//-------------------------------------------------------------------

VOID xmsInsertUMB(
PVOID	Address,
ULONG	Size
)
{
    PXMSUMB xmsUMB, xmsUMBNew;
    WORD    Segment;

    Segment = (WORD) ((DWORD)Address >> 4);
    Size >>= 4;

    xmsUMB = xmsUMBNew = xmsUMBHead;
    while (xmsUMBNew != NULL && xmsUMBNew->Segment < Segment) {
	xmsUMB = xmsUMBNew;
	xmsUMBNew = xmsUMBNew->Next;
    }
    // merge it with previous block if possible
    if (xmsUMB != NULL &&
	xmsUMB->Owner == 0 &&
	Segment == xmsUMB->Segment + xmsUMB->Size) {

        xmsUMB->Size += (WORD) Size;
	return;
    }
    // merge it with the after block if possible
    if (xmsUMBNew != NULL &&
	xmsUMBNew->Owner == 0 &&
	xmsUMBNew->Segment == Segment + Size) {

        xmsUMBNew->Size += (WORD) Size;
	xmsUMBNew->Segment = Segment;
	return;
    }
    // create a new node for the block
    if ((xmsUMBNew = (PXMSUMB)malloc(sizeof(XMSUMB))) != NULL) {
        xmsUMBNew->Size = (WORD) Size;
	xmsUMBNew->Segment = Segment;
	xmsUMBNew->Owner = 0;
	if (xmsUMBHead == NULL) {
	    xmsUMBHead = xmsUMBNew;
	    xmsUMBNew->Next = NULL;
	}
	else {
	    xmsUMBNew->Next = xmsUMB->Next;
	    xmsUMB->Next = xmsUMBNew;
	}
    }
}
// ------------------------------------------------------------------
// XMS function 16, Request UMB.
// Input: (DX) = requested size in paragraphs
// Output: (AX) = 1 if succeed and
//		    (BX) has segment address(number) of the block
//		    (DX) has actual allocated size in paragraphs
//	   (AX) = 0 if failed and
//		    (BL) = 0xB0, (DX) = largest size available
//		    or
//		    (BL) = 0xB1 if no UMBs are available
//-------------------------------------------------------------------
VOID xmsRequestUMB(VOID)
{
    PXMSUMB xmsUMB, xmsUMBNew;
    WORD    SizeRequested, SizeLargest;

    xmsUMB = xmsUMBHead;
    SizeRequested = getDX();
    SizeLargest = 0;
    while (xmsUMB != NULL) {
	if (xmsUMB->Owner == 0) {
	    if (xmsUMB->Size >= SizeRequested) {
		if((xmsUMB->Size - SizeRequested) >= XMSUMB_THRESHOLD &&
		   (xmsUMBNew = (PXMSUMB) malloc(sizeof(XMSUMB))) != NULL) {

		    xmsUMBNew->Segment = xmsUMB->Segment + SizeRequested;
		    xmsUMBNew->Size = xmsUMB->Size - SizeRequested;
		    xmsUMBNew->Next = xmsUMB->Next;
		    xmsUMB->Next = xmsUMBNew;
		    xmsUMBNew->Owner = 0;
		    xmsUMB->Size -= xmsUMBNew->Size;
		}
		xmsUMB->Owner = 0xFFFF;
		setAX(1);
		setBX(xmsUMB->Segment);
		setDX(xmsUMB->Size);
		return;
	    }
	    else {
		if (xmsUMB->Size > SizeLargest)
		    SizeLargest = xmsUMB->Size;
	    }
	}
	xmsUMB = xmsUMB->Next;
    }
    setAX(0);
    setDX(SizeLargest);
    if (SizeLargest > 0)
	setBL(0xB0);
    else
	setBL(0xB1);
}


//------------------------------------------------------------------
// XMS function 17, Release UMB.
// Input : (DX) = segment to be released
// Output: (AX) = 1 if succeed
//	   (AX) = 0 if failed and
//		    (BL) = 0xB2 if segment not found in the list
//------------------------------------------------------------------
VOID xmsReleaseUMB(VOID)
{
    PXMSUMB xmsUMB, xmsUMBNext;
    WORD    Segment;

    xmsUMB = xmsUMBHead;
    Segment = getDX();
    while (xmsUMB != NULL && xmsUMB->Segment != Segment) {
	xmsUMB = xmsUMB->Next;
    }
    if (xmsUMB != NULL && xmsUMB->Owner != 0) {
	xmsUMB->Owner = 0;
	// no walk through the entire list to combine consecutive
	// blocks together
	xmsUMB = xmsUMBHead;
	while (xmsUMB != NULL) {
	    while (xmsUMB->Owner == 0 &&
		   (xmsUMBNext = xmsUMB->Next) != NULL &&
		   xmsUMBNext->Owner == 0 &&
		   (WORD)(xmsUMB->Segment + xmsUMB->Size) == xmsUMBNext->Segment){
		xmsUMB->Size += xmsUMBNext->Size;
		xmsUMB->Next = xmsUMBNext->Next;
		free(xmsUMBNext);
	    }
	    xmsUMB = xmsUMB->Next;
	}
	setAX(1);
    }
    else {
	setBL(0xB2);
	setAX(0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\csrtask.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dlltask.c

Abstract:

    This module implements Csr DLL tasking routines

Author:

    Mark Lucovsky (markl) 13-Nov-1990

Revision History:

--*/

#include "csrdll.h"

NTSTATUS
CsrNewThread(
    VOID
    )

/*++

Routine Description:

    This function is called by each new thread (except the first thread in
    a process.) It's function is to call the subsystem to notify it that
    a new thread is starting.

Arguments:

    None.

Return Value:

    Status Code from either client or server

--*/

{
    return NtRegisterThreadTerminatePort( CsrPortHandle );
}

NTSTATUS
CsrIdentifyAlertableThread( VOID )
{
    NTSTATUS Status;
    CSR_API_MSG m;
    PCSR_IDENTIFY_ALERTABLE_MSG a = &m.u.IdentifyAlertable;

    a->ClientId = NtCurrentTeb()->ClientId;

    Status = CsrClientCallServer(
                &m,
                NULL,
                CSR_MAKE_API_NUMBER( CSRSRV_SERVERDLL_INDEX,
                                     CsrpIdentifyAlertable
                                   ),
                sizeof( *a )
                );

    return Status;
}


NTSTATUS
CsrSetPriorityClass(
    IN HANDLE ProcessHandle,
    IN OUT PULONG PriorityClass
    )
{
    NTSTATUS Status;
    CSR_API_MSG m;
    PCSR_SETPRIORITY_CLASS_MSG a = &m.u.PriorityClass;

    a->ProcessHandle = ProcessHandle;
    a->PriorityClass = *PriorityClass;

    Status = CsrClientCallServer(
                &m,
                NULL,
                CSR_MAKE_API_NUMBER( CSRSRV_SERVERDLL_INDEX,
                                     CsrpSetPriorityClass
                                   ),
                sizeof( *a )
                );

    if ( *PriorityClass == 0 ) {
        *PriorityClass = a->PriorityClass;
        }

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\csrdll.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    csrdll.h

Abstract:

    Main include file for Client side of the Client Server Runtime (CSR)

Author:

    Steve Wood (stevewo) 8-Oct-1990

Revision History:

--*/

//
// Include definitions common between the Client and Server portions.
//

#include "csr.h"

//
// Include definitions specific to the Client portion.
//

#include "ntcsrdll.h"
#include "ntcsrsrv.h"

#if DBG
#define CSR_DEBUG_INIT              0x00000001
#define CSR_DEBUG_LPC               0x00000002
#define CSR_DEBUG_FLAG3             0x00000004
#define CSR_DEBUG_FLAG4             0x00000008
#define CSR_DEBUG_FLAG5             0x00000010
#define CSR_DEBUG_FLAG6             0x00000020
#define CSR_DEBUG_FLAG7             0x00000040
#define CSR_DEBUG_FLAG8             0x00000080
#define CSR_DEBUG_FLAG9             0x00000100
#define CSR_DEBUG_FLAG10            0x00000200
#define CSR_DEBUG_FLAG11            0x00000400
#define CSR_DEBUG_FLAG12            0x00000800
#define CSR_DEBUG_FLAG13            0x00001000
#define CSR_DEBUG_FLAG14            0x00002000
#define CSR_DEBUG_FLAG15            0x00004000
#define CSR_DEBUG_FLAG16            0x00008000
#define CSR_DEBUG_FLAG17            0x00010000
#define CSR_DEBUG_FLAG18            0x00020000
#define CSR_DEBUG_FLAG19            0x00040000
#define CSR_DEBUG_FLAG20            0x00080000
#define CSR_DEBUG_FLAG21            0x00100000
#define CSR_DEBUG_FLAG22            0x00200000
#define CSR_DEBUG_FLAG23            0x00400000
#define CSR_DEBUG_FLAG24            0x00800000
#define CSR_DEBUG_FLAG25            0x01000000
#define CSR_DEBUG_FLAG26            0x02000000
#define CSR_DEBUG_FLAG27            0x04000000
#define CSR_DEBUG_FLAG28            0x08000000
#define CSR_DEBUG_FLAG29            0x10000000
#define CSR_DEBUG_FLAG30            0x20000000
#define CSR_DEBUG_FLAG31            0x40000000
#define CSR_DEBUG_FLAG32            0x80000000

ULONG CsrDebug;
#define IF_CSR_DEBUG( ComponentFlag ) \
    if (CsrDebug & (CSR_DEBUG_ ## ComponentFlag))

#else
#define IF_CSR_DEBUG( ComponentFlag ) if (FALSE)
#endif

//
// Common Types and Definitions
//

//
// CSR_HEAP_MEMORY_SIZE defines how much address space should be
// reserved for the Client heap.  This heap is used to store all
// data structures maintained by the Client DLL.
//

#define CSR_HEAP_MEMORY_SIZE (64*1024)


//
// CSR_PORT_MEMORY_SIZE defines how much address space should be
// reserved for passing data to the Server.  The memory is visible
// to both the client and server processes.
//

#define CSR_PORT_MEMORY_SIZE 0x10000

//
// Global data accessed by Client DLL
//

BOOLEAN CsrInitOnceDone;

//
// This boolean is TRUE if the dll is attached to a server process.
//

BOOLEAN CsrServerProcess;

//
// This points to the server routine that dispatches APIs, if the dll is
// being called by a server process.
//

NTSTATUS (*CsrServerApiRoutine)(PCSR_API_MSG,PCSR_API_MSG);

//
// The CsrNtSysInfo global variable contains NT specific constants of
// interest, such as page size, allocation granularity, etc.  It is filled
// in once during process initialization.
//

SYSTEM_BASIC_INFORMATION CsrNtSysInfo;

#define ROUND_UP_TO_PAGES(SIZE) (((ULONG)(SIZE) + CsrNtSysInfo.PageSize - 1) & ~(CsrNtSysInfo.PageSize - 1))
#define ROUND_DOWN_TO_PAGES(SIZE) (((ULONG)(SIZE)) & ~(CsrNtSysInfo.PageSize - 1))

//
// The CsrDebugFlag is non-zero if the Client Application was
// invoked with the Debug option.
//

ULONG CsrDebugFlag;

//
// The CsrHeap global variable describes a single heap used by the Client
// DLL for process wide storage management.  Process private data maintained
// by the Client DLL is allocated out of this heap.
//

PVOID CsrHeap;


//
// The connection to the Server is described by the CsrPortHandle global
// variable.  The connection is established when the CsrConnectToServer
// function is called.
//

UNICODE_STRING CsrPortName;
HANDLE CsrPortHandle;
HANDLE CsrProcessId;

//
// In order to pass large arguments to the Server (e.g. path name
// arguments) the CsrPortHeap global variable describes a heap that
// is visible to both the Windows Client process and the Server
// process.
//

PVOID CsrPortHeap;
ULONG_PTR CsrPortMemoryRemoteDelta;

ULONG CsrPortBaseTag;

#define MAKE_CSRPORT_TAG( t ) (RTL_HEAP_MAKE_TAG( CsrPortBaseTag, t ))

#define CAPTURE_TAG 0

//
// The CsrDllHandle global variable contains the DLL handle for the WINDLL
// client stubs executable.
//

HANDLE CsrDllHandle;


//
// The CsrObjectDirecotory global variable contains the handle to the
// object directory that is the name of the server.
//

HANDLE CsrObjectDirectory;


//
// Routines defined in dllinit.c
//

BOOLEAN
CsrDllInitialize(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    );

NTSTATUS
CsrpConnectToServer(
    IN PWSTR ObjectDirectory
    );


//
// Routines defined in dllutil.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\avrfp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    avrfp.h

Abstract:

    Internal application verifier header.

Author:

    Silviu Calinoiu (SilviuC) 2-Feb-2001

Revision History:

--*/

#ifndef _AVRFP_
#define _AVRFP_

//
// Application verifier interfaces used in other parts 
// of the loader.
//

VOID
AVrfInitializeVerifier (
    BOOLEAN EnabledSystemWide,
    PUNICODE_STRING ImageName,
    ULONG Phase
    );

VOID
AVrfDllLoadNotification (
    PLDR_DATA_TABLE_ENTRY LoadedDllData
    );

VOID
AVrfDllUnloadNotification (
    PLDR_DATA_TABLE_ENTRY LoadedDllData
    );

VOID
AVrfPageHeapDllNotification (
    PLDR_DATA_TABLE_ENTRY LoadedDllData
    );

#endif // _AVRFP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\buffer.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    buffer.c

Abstract:

    The module implements a buffer in the style popularized by
    Michael J. Grier (MGrier), where some amount (like MAX_PATH)
    of storage is preallocated (like on the stack) and if the storage
    needs grow beyond the preallocated size, the heap is used.

Author:

    Jay Krell (a-JayK) June 2000

Environment:

    User Mode or Kernel Mode (but don't preallocate much on the stack in kernel mode)

Revision History:

--*/
#include "ntos.h"
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include <limits.h>

NTSTATUS
NTAPI
RtlpEnsureBufferSize(
    IN ULONG    Flags,
    IN OUT PRTL_BUFFER Buffer,
    IN SIZE_T          Size
    )
/*++

Routine Description:

    This function ensures Buffer can hold Size bytes, or returns
    an error. It either bumps Buffer->Size closer to Buffer->StaticSize,
    or heap allocates.

Arguments:

    Buffer - a Buffer object, see also RtlInitBuffer.

    Size - the number of bytes the caller wishes to store in Buffer->Buffer.


Return Value:

     STATUS_SUCCESS
     STATUS_NO_MEMORY

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUCHAR Temp = NULL;

    if ((Flags & ~(RTL_ENSURE_BUFFER_SIZE_NO_COPY)) != 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (Buffer == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (Size <= Buffer->Size) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }
    // Size <= Buffer->StaticSize does not imply static allocation, it
    // could be heap allocation that the client poked smaller.
    if (Buffer->Buffer == Buffer->StaticBuffer && Size <= Buffer->StaticSize) {
        Buffer->Size = Size;
        Status = STATUS_SUCCESS;
        goto Exit;
    }
    //
    // The realloc case was messed up in Whistler, and got removed.
    // Put it back in Blackcomb.
    //
    Temp = (PUCHAR)RtlAllocateStringRoutine(Size);
    if (Temp == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    if ((Flags & RTL_ENSURE_BUFFER_SIZE_NO_COPY) == 0) {
        RtlCopyMemory(Temp, Buffer->Buffer, Buffer->Size);
    }

    if (RTLP_BUFFER_IS_HEAP_ALLOCATED(Buffer)) {
        RtlFreeStringRoutine(Buffer->Buffer);
        Buffer->Buffer = NULL;
    }
    ASSERT(Temp != NULL);
    Buffer->Buffer = Temp;
    Buffer->Size = Size;
    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

NTSTATUS
NTAPI
RtlMultiAppendUnicodeStringBuffer(
    OUT PRTL_UNICODE_STRING_BUFFER Destination,
    IN  ULONG                      NumberOfSources,
    IN  const UNICODE_STRING*      SourceArray
    )
/*++

Routine Description:


Arguments:

    Destination -
    NumberOfSources -
    SourceArray -

Return Value:

     STATUS_SUCCESS
     STATUS_NO_MEMORY
     STATUS_NAME_TOO_LONG

--*/
{
    SIZE_T Length = 0;
    ULONG i = 0;
    NTSTATUS Status = STATUS_SUCCESS;
    const SIZE_T CharSize = sizeof(*Destination->String.Buffer);
    const ULONG OriginalDestinationLength = Destination->String.Length;

    Length = OriginalDestinationLength;
    for (i = 0 ; i != NumberOfSources ; ++i) {
        Length += SourceArray[i].Length;
    }
    Length += CharSize;
    if (Length > MAX_UNICODE_STRING_MAXLENGTH) {
        return STATUS_NAME_TOO_LONG;
    }

    Status = RtlEnsureBufferSize(0, &Destination->ByteBuffer, Length);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Destination->String.MaximumLength = (USHORT)Length;
    Destination->String.Length = (USHORT)(Length - CharSize);
    Destination->String.Buffer = (PWSTR)Destination->ByteBuffer.Buffer;
    Length = OriginalDestinationLength;
    for (i = 0 ; i != NumberOfSources ; ++i) {
        RtlMoveMemory(
            Destination->String.Buffer + Length / CharSize,
            SourceArray[i].Buffer,
            SourceArray[i].Length);
        Length += SourceArray[i].Length;
    }
    Destination->String.Buffer[Length / CharSize] = 0;
    return STATUS_SUCCESS;
}

#if 0 // not yet unused

NTSTATUS
NTAPI
RtlPrependStringToUnicodeStringBuffer(
    IN     ULONG                      Flags,
    IN OUT PRTL_UNICODE_STRING_BUFFER UnicodeStringBuffer,
    IN     PCUNICODE_STRING           UnicodeString
    )
/*++

Routine Description:

    Insert a string at the beginning of a unicode string buffer.
    This should be equivalent to RtlInsertStringIntoUnicodeStringBuffer(0).

Arguments:

     Flags - 0, room for future binary compatible expansion
     Buffer - buffer to change
     Length - number of chars to keep

Return Value:

     STATUS_SUCCESS
     STATUS_INVALID_PARAMETER
     STATUS_NAME_TOO_LONG
--*/
{
    //
    // This could be sped up. It does an extra copy of the buffer's
    // existing contents when the buffer needs to grow.
    //
    NTSTATUS Status = STATUS_SUCCESS;

    if (Flags != 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (UnicodeStringBuffer == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (UnicodeString == NULL || UnicodeString->Length == 0) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }
    Status =
        RtlEnsureUnicodeStringBufferSizeChars(
            UnicodeStringBuffer,
              RTL_STRING_GET_LENGTH_CHARS(&UnicodeStringBuffer->String)
            + RTL_STRING_GET_LENGTH_CHARS(UnicodeString)
            );
    if (!NT_SUCCESS(Status))
        goto Exit;

    RtlMoveMemory(
        UnicodeStringBuffer->String.Buffer + RTL_STRING_GET_LENGTH_CHARS(UnicodeString),
        UnicodeStringBuffer->String.Buffer,
        UnicodeStringBuffer->String.Length + sizeof(WCHAR)
        );
    RtlMoveMemory(
        UnicodeStringBuffer->String.Buffer
        UnicodeString->Buffer,
        UnicodeString->Length
        );
    UnicodeStringBuffer->String.Length += UnicodeString->Length;

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

#endif

#if 0 // not yet unused

NTSTATUS
NTAPI
RtlUnicodeStringBufferRight(
    IN     ULONG                      Flags,
    IN OUT PRTL_UNICODE_STRING_BUFFER Buffer,
    IN     ULONG                      Length
    )
/*++

Routine Description:

    This function replaces a unicode string buffer with characters
    taken from its right. This requires a copy. In the future
    we should allow
        RTL_UNICODE_STRING_BUFFER.UnicodeString.Buffer
            != RTL_UNICODE_STRING_BUFFER.ByteBuffer.Buffer
    so this can be fast. Likewise for Mid.

Arguments:

    Flags - 0, room for future binary compatible expansion
    Buffer - buffer to change
    Length - number of chars to keep

Return Value:

     STATUS_SUCCESS
     STATUS_INVALID_PARAMETER
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    const PUNICODE_STRING String   =    (Buffer == NULL ? NULL : &Buffer->String);
    const ULONG CurrentLengthChars =    (String == NULL ? 0    : RTL_STRING_GET_LENGTH_CHARS(String));

    if (Flags != 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (Buffer == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (Length >= CurrentLengthChars) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }

    RtlMoveMemory(
        String->Buffer,
        String->Buffer + CurrentLengthChars - Length,
        Length * sizeof(String->Buffer[0])
        );

    RTL_STRING_SET_LENGTH_CHARS_UNSAFE(String, Length);
    RTL_STRING_NUL_TERMINATE(String);
    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

#endif

#if 0 // not yet unused

NTSTATUS
NTAPI
RtlUnicodeStringBufferLeft(
    IN     ULONG                      Flags,
    IN OUT PRTL_UNICODE_STRING_BUFFER Buffer,
    IN     ULONG                      Length
    )
/*++

Routine Description:

    This function replaces a unicode string buffer with characters
    taken from its left. This is fast.

Arguments:

    Flags - 0, room for future binary compatible expansion
    Buffer - buffer to change
    Length - number of chars to keep

Return Value:

    STATUS_SUCCESS
    STATUS_INVALID_PARAMETER
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    const PUNICODE_STRING String = (Buffer == NULL ? NULL : &Buffer->String);
    const ULONG CurrentLengthChars =    (String == NULL ? 0    : RTL_STRING_GET_LENGTH_CHARS(String));

    if (Flags != 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (Buffer == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (Length >= CurrentLengthChars) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }

    RTL_STRING_SET_LENGTH_CHARS_UNSAFE(String, Length);
    RTL_STRING_NUL_TERMINATE(String);
    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

#endif

#if 0 // not yet unused

NTSTATUS
NTAPI
RtlUnicodeStringBufferMid(
    IN     ULONG                      Flags,
    IN OUT PRTL_UNICODE_STRING_BUFFER Buffer,
    IN     ULONG                      Offset,
    IN     ULONG                      Length
    )
/*++

Routine Description:

    This function replaces a unicode string buffer with characters
    taken from its "middle", as defined by an offset
    from the start and length, both in chars.

Arguments:

    Flags - 0, room for future binary compatible expansion
    Buffer - buffer to change
    Offset - offset to keep chars from
    Length - number of chars to keep

Return Value:

    STATUS_SUCCESS
    STATUS_INVALID_PARAMETER
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    const PUNICODE_STRING String   =    (Buffer == NULL ? NULL : &Buffer->String);
    const ULONG CurrentLengthChars =    (String == NULL ? 0    : RTL_STRING_GET_LENGTH_CHARS(String));

    if (Flags != 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (Buffer == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (Offset >= CurrentLengthChars) {
        Offset = 0;
        Length = 0;
    } else if (Offset + Length >= CurrentLengthChars) {
        Length = CurrentLengthChars - Offset;
    }
    ASSERT(Offset < CurrentLengthChars);
    ASSERT(Length <= CurrentLengthChars);
    ASSERT(Offset + Length <= CurrentLengthChars);
    if (Length != 0 && Offset != 0 && Length != CurrentLengthChars) {
        RtlMoveMemory(
            String->Buffer,
            String->Buffer + Offset,
            Length * sizeof(String->Buffer[0])
            );
    }
    RTL_STRING_SET_LENGTH_CHARS_UNSAFE(String, Length);
    RTL_STRING_NUL_TERMINATE(String);
    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

#endif

#if 0 // not yet unused

NTSTATUS
NTAPI
RtlInsertStringIntoUnicodeStringBuffer(
    IN     ULONG                      Flags,
    IN OUT PRTL_UNICODE_STRING_BUFFER UnicodeStringBuffer,
    IN     ULONG                      Offset,
    IN     PCUNICODE_STRING           InsertString
    )
/*++

Routine Description:

    This function insert a string into a unicode string buffer at
    a specified offset, growing the buffer as necessary to fit,
    and even handling the aliased case where the string and buffer overlap.

Arguments:

    Flags - 0, the ever popular "room for future binary compatible expansion"
    UnicodeStringBuffer - buffer to insert string into
    Offset - offset to insert the string at
    InsertString - string to insert into UnicodeStringBuffer

Return Value:

    STATUS_SUCCESS
    STATUS_INVALID_PARAMETER
    STATUS_NO_MEMORY
    STATUS_NAME_TOO_LONG
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    typedef WCHAR TChar;
    const PUNICODE_STRING String = (UnicodeStringBuffer == NULL ? NULL : &UnicodeStringBuffer->String);
    const ULONG CurrentLengthChars      = (String       == NULL ? 0    : RTL_STRING_GET_LENGTH_CHARS(String));
    const ULONG InsertStringLengthChars = (InsertString == NULL ? 0    : RTL_STRING_GET_LENGTH_CHARS(InsertString));
    const ULONG NewLengthChars = CurrentLengthChars + InsertStringLengthChars;
    const ULONG NewLengthBytes = (CurrentLengthChars + InsertStringLengthChars) * sizeof(TChar);
    RTL_UNICODE_STRING_BUFFER AliasBuffer = { 0 };
    BOOLEAN Alias = FALSE;
    ULONG i = 0;

    if (Flags != 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (UnicodeStringBuffer == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (InsertString == NULL || InsertString->Length == 0) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }
    if (Offset >= CurrentLengthChars) {
        Offset = CurrentLengthChars;
    }

    //
    // Check for aliasing. This check is overly cautious.
    //
    if (InsertString->Buffer >= String->Buffer && InsertString->Buffer < String->Buffer + CurrentLengthChars) {
        Alias = TRUE;
    }
    else if (String->Buffer >= InsertString->Buffer && String->Buffer < InsertString->Buffer + InsertStringLengthChars) {
        Alias = TRUE;
    }
    if (Alias) {
        RtlInitUnicodeStringBuffer(&AliasBuffer, NULL, 0);
        Status = RtlAssignUnicodeStringBuffer(&AliasBuffer, InsertString);
        if (!NT_SUCCESS(Status))
            goto Exit;
        InsertString = &AliasBuffer->String;
    }

    Status = RtlEnsureUnicodeBufferSizeChars(UnicodeStringBuffer, NewLength);
    if (!NT_SUCCESS(Status))
        goto Exit;
    RtlMoveMemory(String->Buffer + Offset + InsertStringLengthChars, String->Buffer + Offset, (CurrentLengthChars - Offset) * sizeof(TChar));
    RtlMoveMemory(String->Buffer + Offset, InsertString->Insert, InsertStringLengthChars * sizeof(TChar));
    RTL_STRING_SET_LENGTH_CHARS_UNSAFE(String, NewLength);
    RTL_STRING_NUL_TERMINATE(String);
    Status = STATUS_SUCCESS;
Exit:
    RtlFreeUnicodeStringBuffer(&AliasBuffer);
    return Status;
}

#endif

#if 0 // not yet unused

NTSTATUS
NTAPI
RtlBufferTakeValue(
    IN     ULONG       Flags,
    IN OUT PRTL_BUFFER DestinationBuffer,
    IN OUT PRTL_BUFFER SourceBuffer
    )
/*++

Routine Description:

    This function copies the value of one RTL_BUFFER to another
    and frees the source, in one step. If source is heap allocated, this enables
    the optimization of not doing a RtlMoveMemory, just moving the pointers and sizes.

Arguments:

     Flags - 0
     DestinationBuffer - ends up holding source's value
     SourceBuffer - ends up freed

Return Value:

     STATUS_SUCCESS
     STATUS_INVALID_PARAMETER
     STATUS_NO_MEMORY
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    typedef WCHAR TChar;

    if (Flags != 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (DestinationBuffer == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (SourceBuffer == NULL) {
        RtlFreeBuffer(DestinationBuffer);
        Status = STATUS_SUCCESS;
        goto Exit;
    }

    if (RTLP_BUFFER_IS_HEAP_ALLOCATED(SourceBuffer)
        && SourceBuffer->ReservedForIMalloc == DestinationBuffer->ReservedForIMalloc
        ) {
        DestinationBuffer->Size = SourceBuffer->Size;
        DestinationBuffer->Buffer = SourceBuffer->Buffer;
        SourceBuffer->Buffer = SourceBuffer->StaticBuffer;
        SourceBuffer->Size   = SourceBuffer->StaticSize;
        goto Exit;
    }
    Status = RtlEnsureBufferSize(RTL_ENSURE_BUFFER_SIZE_NO_COPY, DestinationBuffer, SourceBuffer->Size);
    if (!NT_SUCCESS(Status))
        goto Exit;
    RtlMoveMemory(DestinationBuffer->Buffer, SourceBuffer->Buffer, SourceBuffer->Size);
    RtlFreeBuffer(SourceBuffer);

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

#endif

#if 0 // not yet unused

NTSTATUS
NTAPI
RtlValidateBuffer(
    IN ULONG Flags,
    IN CONST RTL_BUFFER* Buffer
    )
/*++

Routine Description:

    This function performs some sanity checking on the buffer.

Arguments:

     Flags - 0
     Buffer - the buffer to check

Return Value:

     STATUS_SUCCESS - the buffer is aok
     STATUS_INVALID_PARAMETER - the buffer is not good
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (Flags != 0) {
        Status = STATUS_INVALID_PARAMETER
        goto Exit;
    }
    if (Buffer == NULL) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }
    Status = STATUS_INVALID_PARAMETER;
    if (!RTL_IMPLIES(Buffer->Buffer == Buffer->StaticBuffer, Buffer->Size <= Buffer->StaticSize))
        goto Exit;

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

#endif

#if 0 // not yet unused

NTSTATUS
NTAPI
RtlValidateUnicodeStringBuffer(
    IN ULONG Flags,
    IN CONST RTL_UNICODE_STRING_BUFFER* UnicodeStringBuffer
    )
/*++

Routine Description:

    This function performs some sanity checking on the buffer.

Arguments:

     Flags - 0
     UnicodeStringBuffer - the buffer to check

Return Value:

     STATUS_SUCCESS - the buffer is aok
     STATUS_INVALID_PARAMETER - the buffer is not good
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (Flags != 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (UnicodeStringBuffer == NULL) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }
    if (!RTL_VERIFY(NT_SUCCESS(Status = RtlValidateUnicodeString(&UnicodeStringBuffer->String))))
        goto Exit;
    if (!RTL_VERIFY(NT_SUCCESS(Status = RtlValidateBuffer(&UnicodeStringBuffer->Buffer))))
        goto Exit;
    Status = STATUS_INVALID_PARAMETER;
    if (!RTL_VERIFY(UnicodeStringBuffer->String.Length < UnicodeStringBuffer->ByteBuffer.Size))
        goto Exit;
    if (!RTL_VERIFY(UnicodeStringBuffer->String.MaximumLength >= UnicodeStringBuffer->String.Length))
        goto Exit;
    if (!RTL_VERIFY(UnicodeStringBuffer->String.MaximumLength == UnicodeStringBuffer->ByteBuffer.Size))
        goto Exit;
    if (!RTL_VERIFY(UnicodeStringBuffer->String.Buffer == UnicodeStringBuffer->ByteBuffer.Buffer))
        goto Exit;
    if (!RTL_VERIFY(UnicodeStringBuffer->String.MaximumLength != 0))
        goto Exit;

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

#endif

#if 0
static void test()
{
    RTL_BUFFER       Buffer = { 0 };
    UCHAR            chars[260 * sizeof(WCHAR)];

    RtlInitBuffer(&Buffer, chars, sizeof(chars));
    RtlEnsureBufferSize(0, &Buffer, 1024 * sizeof(WCHAR));
    RtlFreeBuffer(&Buffer);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\csrinit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dllinit.c

Abstract:

    This module contains the initialization code for the Client-Server (CS)
    Client DLL.

Author:

    Steve Wood (stevewo) 8-Oct-1990

Environment:

    User Mode only

Revision History:

--*/

#include "csrdll.h"
#include "ldrp.h"

BOOLEAN
CsrDllInitialize(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )

/*++

Routine Description:

    This function is the DLL initialization routine for the Client DLL
    This function gets control when the application links to this DLL
    are snapped.

Arguments:

    Context - Supplies an optional context buffer that will be restore
              after all DLL initialization has been completed.  If this
              parameter is NULL then this is a dynamic snap of this module.
              Otherwise this is a static snap prior to the user process
              gaining control.

Return Value:

    Status value.

--*/

{
    Context;

    if (Reason != DLL_PROCESS_ATTACH) {
        return( TRUE );
        }

    //
    // Remember our DLL handle in a global variable.
    //

    CsrDllHandle = DllHandle;

    return( TRUE );
}


NTSTATUS
CsrOneTimeInitialize( VOID )
{
    NTSTATUS Status;

    //
    // Save away system information in a global variable
    //

    Status = NtQuerySystemInformation( SystemBasicInformation,
                                       &CsrNtSysInfo,
                                       sizeof( CsrNtSysInfo ),
                                       NULL
                                     );
    if (!NT_SUCCESS( Status )) {
        return( Status );
        }

    //
    // Use the process heap for memory allocation.
    //

    CsrHeap = RtlProcessHeap();

    CsrInitOnceDone = TRUE;

    return( STATUS_SUCCESS );
}


NTSTATUS
CsrClientConnectToServer(
    IN PWSTR ObjectDirectory,
    IN ULONG ServerDllIndex,
    IN PVOID ConnectionInformation,
    IN OUT PULONG ConnectionInformationLength OPTIONAL,
    OUT PBOOLEAN CalledFromServer OPTIONAL
    )

/*++

Routine Description:

    This function is called by the client side DLL to connect with its
    server side DLL.

Arguments:

    ObjectDirectory - Points to a null terminate string that is the same
        as the value of the ObjectDirectory= argument passed to the CSRSS
        program.

    ServerDllIndex - Index of the server DLL that is being connected to.
        It should match one of the ServerDll= arguments passed to the CSRSS
        program.

    ConnectionInformation - An optional pointer to uninterpreted data.
        This data is intended for clients to pass package, version and
        protocol identification information to the server to allow the
        server to determine if it can satisify the client before
        accepting the connection.  Upon return to the client, the
        ConnectionInformation data block contains any information passed
        back from the server DLL by its call to the
        CsrCompleteConnection call.  The output data overwrites the
        input data.

    ConnectionInformationLength - Pointer to the length of the
        ConnectionInformation data block.  The output value is the
        length of the data stored in the ConnectionInformation data
        block by the server's call to the NtCompleteConnectPort
        service.  This parameter is OPTIONAL only if the
        ConnectionInformation parameter is NULL, otherwise it is
        required.

    CalledFromServer - On output, TRUE if the dll has been called from
        a server process.

Return Value:

    Status value.

--*/

{
    NTSTATUS Status;
    CSR_API_MSG m;
    PCSR_CLIENTCONNECT_MSG a = &m.u.ClientConnect;
    PCSR_CAPTURE_HEADER CaptureBuffer;
    HANDLE CsrServerModuleHandle;
    STRING ProcedureName;
    ANSI_STRING DllName;
    UNICODE_STRING DllName_U;
    PIMAGE_NT_HEADERS NtHeaders;

    if (ARGUMENT_PRESENT( ConnectionInformation ) &&
        (!ARGUMENT_PRESENT( ConnectionInformationLength ) ||
          *ConnectionInformationLength == 0
        )
       ) {
        return( STATUS_INVALID_PARAMETER );
        }

    if (!CsrInitOnceDone) {
        Status = CsrOneTimeInitialize();
        if (!NT_SUCCESS( Status )) {
            return( Status );
            }
        }

    //
    // if we are being called by a server process, skip lpc port initialization
    // and call to server connect routine and just initialize heap.  the
    // dll initialization routine will do any necessary initialization.  this
    // stuff only needs to be done for the first connect.
    //

    if ( CsrServerProcess == TRUE ) {
        *CalledFromServer = CsrServerProcess;
        return STATUS_SUCCESS;
        }

    //
    // If the image is an NT Native image, we are running in the
    // context of the server.
    //

    NtHeaders = RtlImageNtHeader(NtCurrentPeb()->ImageBaseAddress);
    if (! NtHeaders) {
        return STATUS_INVALID_IMAGE_FORMAT;
    }
    CsrServerProcess =
        (NtHeaders->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_NATIVE) ? TRUE : FALSE;

    if ( CsrServerProcess ) {
        extern PVOID NtDllBase;
        RtlInitAnsiString( &DllName, "csrsrv" );
        Status = RtlAnsiStringToUnicodeString(&DllName_U, &DllName, TRUE);
        ASSERT(NT_SUCCESS(Status));

        LdrDisableThreadCalloutsForDll(NtDllBase);

        Status = LdrGetDllHandle(
        		UNICODE_NULL,
                    NULL,
        		&DllName_U,
                    (PVOID *)&CsrServerModuleHandle
                    );

        RtlFreeUnicodeString(&DllName_U);

        CsrServerProcess = TRUE;

        RtlInitString(&ProcedureName,"CsrCallServerFromServer");
        Status = LdrGetProcedureAddress(
                        CsrServerModuleHandle,
                        &ProcedureName,
                        0L,
                        (PVOID *)&CsrServerApiRoutine
                        );
        ASSERT(NT_SUCCESS(Status));

        ASSERT (CsrPortHeap==NULL);
        CsrPortHeap = RtlProcessHeap();

        CsrPortBaseTag = RtlCreateTagHeap( CsrPortHeap,
                                           0,
                                           L"CSRPORT!",
                                           L"CAPTURE\0"
                                         );

        if (ARGUMENT_PRESENT(CalledFromServer)) {
            *CalledFromServer = CsrServerProcess;
            }
        return STATUS_SUCCESS;
        }

    if ( ARGUMENT_PRESENT(ConnectionInformation) ) {
        CsrServerProcess = FALSE;
        if (CsrPortHandle == NULL) {
            Status = CsrpConnectToServer( ObjectDirectory );
            if (!NT_SUCCESS( Status )) {
                return( Status );
                }
            }

        a->ServerDllIndex = ServerDllIndex;
        a->ConnectionInformationLength = *ConnectionInformationLength;
        if (ARGUMENT_PRESENT( ConnectionInformation )) {
            CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                      a->ConnectionInformationLength
                                                    );
            if (CaptureBuffer == NULL) {
                return( STATUS_NO_MEMORY );
                }

            CsrAllocateMessagePointer( CaptureBuffer,
                                       a->ConnectionInformationLength,
                                       (PVOID *)&a->ConnectionInformation
                                     );
            RtlMoveMemory( a->ConnectionInformation,
                           ConnectionInformation,
                           a->ConnectionInformationLength
                         );

            *ConnectionInformationLength = a->ConnectionInformationLength;
            }
        else {
            CaptureBuffer = NULL;
            }

        Status = CsrClientCallServer( &m,
                                      CaptureBuffer,
                                      CSR_MAKE_API_NUMBER( CSRSRV_SERVERDLL_INDEX,
                                                           CsrpClientConnect
                                                         ),
                                      sizeof( *a )
                                    );

        if (CaptureBuffer != NULL) {
            if (ARGUMENT_PRESENT( ConnectionInformation )) {
                RtlMoveMemory( ConnectionInformation,
                               a->ConnectionInformation,
                               *ConnectionInformationLength
                             );
                }

            CsrFreeCaptureBuffer( CaptureBuffer );
            }
        }
    else {
        Status = STATUS_SUCCESS;
        }

    if (ARGUMENT_PRESENT(CalledFromServer)) {
        *CalledFromServer = CsrServerProcess;
        }
    return( Status );
}

BOOLEAN
xProtectHandle(
    HANDLE hObject
    )
{
    NTSTATUS Status;
    OBJECT_HANDLE_FLAG_INFORMATION HandleInfo;

    Status = NtQueryObject( hObject,
                            ObjectHandleFlagInformation,
                            &HandleInfo,
                            sizeof( HandleInfo ),
                            NULL
                          );
    if (NT_SUCCESS( Status )) {
        HandleInfo.ProtectFromClose = TRUE;

        Status = NtSetInformationObject( hObject,
                                         ObjectHandleFlagInformation,
                                         &HandleInfo,
                                         sizeof( HandleInfo )
                                       );
        if (NT_SUCCESS( Status )) {
            return TRUE;
            }
        }

    return FALSE;
}

BOOLEAN
xUnProtectHandle(
    HANDLE hObject
    )
{
    NTSTATUS Status;
    OBJECT_HANDLE_FLAG_INFORMATION HandleInfo;

    Status = NtQueryObject( hObject,
                            ObjectHandleFlagInformation,
                            &HandleInfo,
                            sizeof( HandleInfo ),
                            NULL
                          );
    if (NT_SUCCESS( Status )) {
        HandleInfo.ProtectFromClose = FALSE;

        Status = NtSetInformationObject( hObject,
                                         ObjectHandleFlagInformation,
                                         &HandleInfo,
                                         sizeof( HandleInfo )
                                       );
        if (NT_SUCCESS( Status )) {
            return TRUE;
            }
        }

    return FALSE;
}

NTSTATUS
CsrpConnectToServer(
    IN PWSTR ObjectDirectory
    )
{
    NTSTATUS Status;
    REMOTE_PORT_VIEW ServerView;
    ULONG MaxMessageLength;
    ULONG ConnectionInformationLength;
    CSR_API_CONNECTINFO ConnectionInformation;
    SECURITY_QUALITY_OF_SERVICE DynamicQos;
    HANDLE PortSection;
    PORT_VIEW ClientView;
    ULONG n;
    LARGE_INTEGER SectionSize;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID SystemSid;

    //
    // Create the port name string by combining the passed in object directory
    // name with the port name.
    //

    n = ((wcslen( ObjectDirectory ) + 1) * sizeof( WCHAR )) +
        sizeof( CSR_API_PORT_NAME );
    CsrPortName.Length = 0;
    CsrPortName.MaximumLength = (USHORT)n;
    CsrPortName.Buffer = RtlAllocateHeap( CsrHeap, MAKE_TAG( CSR_TAG ), n );
    if (CsrPortName.Buffer == NULL) {
        return( STATUS_NO_MEMORY );
        }
    RtlAppendUnicodeToString( &CsrPortName, ObjectDirectory );
    RtlAppendUnicodeToString( &CsrPortName, L"\\" );
    RtlAppendUnicodeToString( &CsrPortName, CSR_API_PORT_NAME );

    //
    // Set up the security quality of service parameters to use over the
    // port.  Use the most efficient (least overhead) - which is dynamic
    // rather than static tracking.
    //

    DynamicQos.ImpersonationLevel = SecurityImpersonation;
    DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    DynamicQos.EffectiveOnly = TRUE;


    //
    // Create a section to contain the Port Memory.  Port Memory is private
    // memory that is shared between the client and server processes.
    // This allows data that is too large to fit into an API request message
    // to be passed to the server.
    //

    SectionSize.LowPart = CSR_PORT_MEMORY_SIZE;
    SectionSize.HighPart = 0;

    Status = NtCreateSection( &PortSection,
                              SECTION_ALL_ACCESS,
                              NULL,
                              &SectionSize,
                              PAGE_READWRITE,
                              SEC_RESERVE,
                              NULL
                            );
    if (!NT_SUCCESS( Status )) {
        return( Status );
        }

    //
    // Connect to the server.  This includes a description of the Port Memory
    // section so that the LPC connection logic can make the section visible
    // to both the client and server processes.  Also pass information the
    // server needs in the connection information structure.
    //

    ClientView.Length = sizeof( ClientView );
    ClientView.SectionHandle = PortSection;
    ClientView.SectionOffset = 0;
    ClientView.ViewSize = SectionSize.LowPart;
    ClientView.ViewBase = 0;
    ClientView.ViewRemoteBase = 0;

    ServerView.Length = sizeof( ServerView );
    ServerView.ViewSize = 0;
    ServerView.ViewBase = 0;

    ConnectionInformationLength = sizeof( ConnectionInformation );
    ConnectionInformation.ExpectedVersion = CSR_VERSION;

    SystemSid = NULL;
    Status = RtlAllocateAndInitializeSid( &NtAuthority,
                                          1,
                                          SECURITY_LOCAL_SYSTEM_RID,
                                          0, 0, 0, 0, 0, 0, 0,
                                          &SystemSid
                                        );
    if (!NT_SUCCESS( Status )) {
        return( Status );
        }
    Status = NtSecureConnectPort( &CsrPortHandle,
                          &CsrPortName,
                          &DynamicQos,
                          &ClientView,
                          SystemSid,
                          &ServerView,
                          (PULONG)&MaxMessageLength,
                          (PVOID)&ConnectionInformation,
                          (PULONG)&ConnectionInformationLength
                        );
    RtlFreeSid( SystemSid );
    NtClose( PortSection );
    if (!NT_SUCCESS( Status )) {
        IF_DEBUG {
            DbgPrint( "CSRDLL: Unable to connect to %wZ Server - Status == %X\n",
                      &CsrPortName,
                      Status
                    );
            }

        return( Status );
        }
    xProtectHandle(CsrPortHandle);

    NtCurrentPeb()->ReadOnlySharedMemoryBase = ConnectionInformation.SharedSectionBase;
    NtCurrentPeb()->ReadOnlySharedMemoryHeap = ConnectionInformation.SharedSectionHeap;
    NtCurrentPeb()->ReadOnlyStaticServerData = (PVOID *)ConnectionInformation.SharedStaticServerData;
    CsrProcessId = ConnectionInformation.ServerProcessId;

#if DBG
    CsrDebug = ConnectionInformation.DebugFlags;
#endif
    CsrObjectDirectory = ConnectionInformation.ObjectDirectory;

    CsrPortMemoryRemoteDelta = (ULONG_PTR)ClientView.ViewRemoteBase -
                               (ULONG_PTR)ClientView.ViewBase;

    IF_CSR_DEBUG( LPC ) {
        DbgPrint( "CSRDLL: ClientView: Base=%p  RemoteBase=%p  Delta: %lX  Size=%lX\n",
                  ClientView.ViewBase,
                  ClientView.ViewRemoteBase,
                  CsrPortMemoryRemoteDelta,
                  (ULONG)ClientView.ViewSize
                );
        }

    //
    // Create a sparse heap in the share memory section.  Initially
    // commit just one page.
    //

    CsrPortHeap = RtlCreateHeap( HEAP_CLASS_8,                      // Flags
                                 ClientView.ViewBase,               // HeapBase
                                 ClientView.ViewSize,               // ReserveSize
                                 CsrNtSysInfo.PageSize,             // CommitSize
                                 0,                                 // Reserved
                                 0                                  // GrowthThreshold
                               );
    if (CsrPortHeap == NULL) {
        xUnProtectHandle(CsrPortHandle);

        NtClose( CsrPortHandle );
        CsrPortHandle = NULL;

        return( STATUS_NO_MEMORY );
        }

    CsrPortBaseTag = RtlCreateTagHeap( CsrPortHeap,
                                       0,
                                       L"CSRPORT!",
                                       L"!CSRPORT\0"
                                       L"CAPTURE\0"
                                     );

    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\csrutil.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dllutil.c

Abstract:

    This module contains utility procedures for the Windows Client DLL


Author:

    Steve Wood (stevewo) 8-Oct-1990

Revision History:

--*/

#include "csrdll.h"

NTSTATUS
CsrClientCallServer(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_CAPTURE_HEADER CaptureBuffer OPTIONAL,
    IN CSR_API_NUMBER ApiNumber,
    IN ULONG ArgLength
    )

/*++

Routine Description:

    This function sends an API request to the Windows Emulation Subsystem
    Server and waits for a reply.

Arguments:

    m - Pointer to the API request message to send.

    CaptureBuffer - Optional pointer to a capture buffer located in the
        Port Memory section that contains additional data being sent
        to the server.  Since Port Memory is also visible to the server,
        no data needs to be copied, but pointers to locations within the
        capture buffer need to be converted into pointers valid in the
        server's process context, since the server's view of the Port Memory
        is not at the same virtual address as the client's view.

    ApiNumber - Small integer that is the number of the API being called.

    ArgLength - Length, in bytes, of the argument portion located at the
        end of the request message.  Used to calculate the length of the
        request message.

Return Value:

    Status Code from either client or server

--*/

{
    NTSTATUS Status;
    PULONG_PTR PointerOffsets;
    ULONG CountPointers;
    ULONG_PTR Pointer;

    //
    // Initialize the header of the message.
    //

    if ((LONG)ArgLength < 0) {
        ArgLength = (ULONG)(-(LONG)ArgLength);
        m->h.u2.s2.Type = 0;
        }
    else {
        m->h.u2.ZeroInit = 0;
        }

    ArgLength |= (ArgLength << 16);
    ArgLength +=     ((sizeof( CSR_API_MSG ) - sizeof( m->u )) << 16) |
                     (FIELD_OFFSET( CSR_API_MSG, u ) - sizeof( m->h ));
    m->h.u1.Length = ArgLength;
    m->CaptureBuffer = NULL;
    m->ApiNumber = ApiNumber;

    //
    // if the caller is within the server process, do the API call directly
    // and skip the capture buffer fixups and LPC call.
    //

    if (CsrServerProcess == FALSE) {

        //
        // If the CaptureBuffer argument is present, then there is data located
        // in the Port Memory section that is being passed to the server.  All
        // Port Memory pointers need to be converted so they are valid in the
        // Server's view of the Port Memory.
        //

        if (ARGUMENT_PRESENT( CaptureBuffer )) {
            //
            // Store a pointer to the capture buffer in the message that is valid
            // in the server process's context.
            //

            m->CaptureBuffer = (PCSR_CAPTURE_HEADER)
                ((PCHAR)CaptureBuffer + CsrPortMemoryRemoteDelta);

            //
            // Mark the fact that we are done allocating space from the end of
            // the capture buffer.
            //

            CaptureBuffer->FreeSpace = NULL;

            //
            // Loop over all of the pointers to Port Memory within the message
            // itself and convert them into server pointers.  Also, convert
            // the pointers to pointers into offsets.
            //

            PointerOffsets = CaptureBuffer->MessagePointerOffsets;
            CountPointers = CaptureBuffer->CountMessagePointers;
            while (CountPointers--) {
                Pointer = *PointerOffsets++;
                if (Pointer != 0) {
                    *(PULONG_PTR)Pointer += CsrPortMemoryRemoteDelta;
                    PointerOffsets[ -1 ] = Pointer - (ULONG_PTR)m;
                    }
                }
            }

        //
        // Send the request to the server and wait for a reply.  The wait is
        // NOT alertable, because ? FIX,FIX
        //

        Status = NtRequestWaitReplyPort( CsrPortHandle,
                                         (PPORT_MESSAGE)m,
                                         (PPORT_MESSAGE)m
                                       );
        //
        // If the CaptureBuffer argument is present then reverse what we did
        // to the pointers above so that the client side code can use them
        // again.
        //

        if (ARGUMENT_PRESENT( CaptureBuffer )) {
            //
            // Convert the capture buffer pointer back to a client pointer.
            //

            m->CaptureBuffer = (PCSR_CAPTURE_HEADER)
                ((PCHAR)m->CaptureBuffer - CsrPortMemoryRemoteDelta);

            //
            // Loop over all of the pointers to Port Memory within the message
            // itself and convert them into client pointers.  Also, convert
            // the offsets pointers to pointers into back into pointers
            //

            PointerOffsets = CaptureBuffer->MessagePointerOffsets;
            CountPointers = CaptureBuffer->CountMessagePointers;
            while (CountPointers--) {
                Pointer = *PointerOffsets++;
                if (Pointer != 0) {
                    Pointer += (ULONG_PTR)m;
                    PointerOffsets[ -1 ] = Pointer;
                    *(PULONG_PTR)Pointer -= CsrPortMemoryRemoteDelta;
                    }
                }
            }

        //
        // Check for failed status and do something.
        //
        if (!NT_SUCCESS( Status )) {
            IF_DEBUG {
                if (Status != STATUS_PORT_DISCONNECTED &&
                    Status != STATUS_INVALID_HANDLE
                   ) {
                    DbgPrint( "CSRDLL: NtRequestWaitReplyPort failed - Status == %X\n",
                              Status
                            );
                    }
                }
            m->ReturnValue = Status;
            }
    } else {
        m->h.ClientId = NtCurrentTeb()->ClientId;
        Status = (CsrServerApiRoutine)((PCSR_API_MSG)m,
                                       (PCSR_API_MSG)m
                                      );

        //
        // Check for failed status and do something.
        //

        if (!NT_SUCCESS( Status )) {
            IF_DEBUG {
                DbgPrint( "CSRDLL: Server side client call failed - Status == %X\n",
                          Status
                        );
                }

            m->ReturnValue = Status;
            }
        }

    //
    // The value of this function is whatever the server function returned.
    //

    return( m->ReturnValue );
}

HANDLE
CsrGetProcessId (
    VOID
    )
/*++

Routine Description:

    This function gets the process ID of the CSR process (for the session)

Arguments:

    None

Return Value:

    Process ID of CSR

--*/

{
    return CsrProcessId;
}


PCSR_CAPTURE_HEADER
CsrAllocateCaptureBuffer(
    IN ULONG CountMessagePointers,
    IN ULONG Size
    )

/*++

Routine Description:

    This function allocates a buffer from the Port Memory section for
    use by the client in capture arguments into Port Memory.  In addition to
    specifying the size of the data that needs to be captured, the caller
    needs to specify how many pointers to captured data will be passed.
    Pointers can be located in either the request message itself, and/or
    the capture buffer.

Arguments:

    CountMessagePointers - Number of pointers within the request message
        that will point to locations within the allocated capture buffer.

    Size - Total size of the data that will be captured into the capture
        buffer.

Return Value:

    A pointer to the capture buffer header.

--*/

{
    PCSR_CAPTURE_HEADER CaptureBuffer;
    ULONG CountPointers;

    //
    // Calculate the total number of pointers that will be passed
    //

    CountPointers = CountMessagePointers;

    //
    // Calculate the total size of the capture buffer.  This includes the
    // header, the array of pointer offsets and the data length.  We round
    // the data length to a 32-bit boundary, assuming that each pointer
    // points to data whose length is not aligned on a 32-bit boundary.
    //

    if (Size >= MAXLONG) {
        //
        // Bail early if too big
        //
        return NULL;
        }
    Size += FIELD_OFFSET(CSR_CAPTURE_HEADER, MessagePointerOffsets) + (CountPointers * sizeof( PVOID ));
    Size = (Size + (3 * (CountPointers+1))) & ~3;

    //
    // Allocate the capture buffer from the Port Memory Heap.
    //

    CaptureBuffer = RtlAllocateHeap( CsrPortHeap, MAKE_CSRPORT_TAG( CAPTURE_TAG ), Size );
    if (CaptureBuffer == NULL) {

        //
        // FIX, FIX - need to attempt the receive lost reply messages to
        // to see if they contain CaptureBuffer pointers that can be freed.
        //

        return( NULL );
    }

    //
    // Initialize the capture buffer header
    //

    CaptureBuffer->Length = Size;
    CaptureBuffer->CountMessagePointers = 0;

    //
    // If there are pointers being passed then initialize the arrays of
    // pointer offsets to zero.  In either case set the free space pointer
    // in the capture buffer header to point to the first 32-bit aligned
    // location after the header, the arrays of pointer offsets are considered
    // part of the header.
    //

    RtlZeroMemory( CaptureBuffer->MessagePointerOffsets,
                   CountPointers * sizeof( ULONG_PTR )
                 );

    CaptureBuffer->FreeSpace = (PCHAR)
        (CaptureBuffer->MessagePointerOffsets + CountPointers);

    //
    // Returned the address of the capture buffer.
    //

    return( CaptureBuffer );
}


VOID
CsrFreeCaptureBuffer(
    IN PCSR_CAPTURE_HEADER CaptureBuffer
    )

/*++

Routine Description:

    This function frees a capture buffer allocated by CsrAllocateCaptureBuffer.

Arguments:

    CaptureBuffer - Pointer to a capture buffer allocated by
        CsrAllocateCaptureBuffer.

Return Value:

    None.

--*/

{
    //
    // Free the capture buffer back to the Port Memory heap.
    //

    RtlFreeHeap( CsrPortHeap, 0, CaptureBuffer );
}


ULONG
CsrAllocateMessagePointer(
    IN OUT PCSR_CAPTURE_HEADER CaptureBuffer,
    IN ULONG Length,
    OUT PVOID *Pointer
    )

/*++

Routine Description:

    This function allocates space from the capture buffer along with a
    pointer to point to it.  The pointer is presumed to be located in
    the request message structure.

Arguments:

    CaptureBuffer - Pointer to a capture buffer allocated by
        CsrAllocateCaptureBuffer.

    Length - Size of data being allocated from the capture buffer.

    Pointer - Address of the pointer within the request message that
        is to point to the space allocated out of the capture buffer.

Return Value:

    The actual length of the buffer allocated, after it has been rounded
    up to a multiple of 4.

--*/

{
    if (Length == 0) {
        *Pointer = NULL;
        Pointer = NULL;
        }

    else {

        //
        // Set the returned pointer value to point to the next free byte in
        // the capture buffer.
        //

        *Pointer = CaptureBuffer->FreeSpace;

        //
        // Round the length up to a multiple of 4
        //

        if (Length >= MAXLONG) {
            //
            // Bail early if too big
            //
            return 0;
            }

        Length = (Length + 3) & ~3;

        //
        // Update the free space pointer to point to the next available byte
        // in the capture buffer.
        //

        CaptureBuffer->FreeSpace += Length;
        }


    //
    // Remember the location of this pointer so that CsrClientCallServer can
    // convert it into a server pointer prior to sending the request to
    // the server.
    //

    CaptureBuffer->MessagePointerOffsets[ CaptureBuffer->CountMessagePointers++ ] =
        (ULONG_PTR)Pointer;

    //
    // Returned the actual length allocated.
    //

    return( Length );
}


VOID
CsrCaptureMessageBuffer(
    IN OUT PCSR_CAPTURE_HEADER CaptureBuffer,
    IN PVOID Buffer OPTIONAL,
    IN ULONG Length,
    OUT PVOID *CapturedBuffer
    )

/*++

Routine Description:

    This function captures a buffer of bytes in an API request message.

Arguments:

    CaptureBuffer - Pointer to a capture buffer allocated by
        CsrAllocateCaptureBuffer.

    Buffer - Optional pointer to the buffer.  If this parameter is
        not present, then no data is copied into capture buffer.

    Length - Length of the buffer.

    CapturedBuffer - Pointer to the field in the message that will
        be filled in to point to the capture buffer.

Return Value:

    None.

--*/

{
    //
    // Set the length fields of the captured string structure and allocated
    // the Length for the string from the capture buffer.
    //

    CsrAllocateMessagePointer( CaptureBuffer,
                               Length,
                               CapturedBuffer
                             );

    //
    // If Buffer parameter is not present or the length of the data is zero,
    // return.
    //

    if (!ARGUMENT_PRESENT( Buffer ) || (Length == 0)) {
        return;
        }

    //
    // Copy the buffer data to the capture area.
    //

    RtlMoveMemory( *CapturedBuffer, Buffer, Length );

    return;
}

VOID
CsrCaptureMessageString(
    IN OUT PCSR_CAPTURE_HEADER CaptureBuffer,
    IN PCSTR String OPTIONAL,
    IN ULONG Length,
    IN ULONG MaximumLength,
    OUT PSTRING CapturedString
    )

/*++

Routine Description:

    This function captures an ASCII string into a counted string data
    structure located in an API request message.

Arguments:

    CaptureBuffer - Pointer to a capture buffer allocated by
        CsrAllocateCaptureBuffer.

    String - Optional pointer to the ASCII string.  If this parameter is
        not present, then the counted string data structure is set to
        the null string.

    Length - Length of the ASCII string, ignored if String is NULL.

    MaximumLength - Maximum length of the string.  Different for null
        terminated strings, where Length does not include the null and
        MaximumLength does. This is always how much space is allocated
        from the capture buffer.

    CaptureString - Pointer to the counted string data structure that will
        be filled in to point to the captured ASCII string.

Return Value:

    None.

--*/

{
    ASSERT(CapturedString != NULL);
    //
    // If String parameter is not present, then set the captured string
    // to be the null string and returned.
    //

    if (!ARGUMENT_PRESENT( String )) {
        CapturedString->Length = 0;
        CapturedString->MaximumLength = (USHORT)MaximumLength;
        CsrAllocateMessagePointer( CaptureBuffer,
                                   MaximumLength,
                                   (PVOID *)&CapturedString->Buffer
                                 );
        //
        // Make it nul terminated if there is any room.
        //
        if (MaximumLength != 0) {
            CapturedString->Buffer[0] = 0;
            }
        return;
        }

    //
    // Set the length fields of the captured string structure and allocated
    // the MaximumLength for the string from the capture buffer.
    //

    CapturedString->Length = (USHORT)Length;
    CapturedString->MaximumLength = (USHORT)
        CsrAllocateMessagePointer( CaptureBuffer,
                                   MaximumLength,
                                   (PVOID *)&CapturedString->Buffer
                                 );
    //
    // If the Length of the ASCII string is non-zero then move it to the
    // capture area.
    //

    if (Length != 0) {
        RtlMoveMemory( CapturedString->Buffer, String, MaximumLength );
        }
    if (CapturedString->Length < CapturedString->MaximumLength) {
        CapturedString->Buffer[ CapturedString->Length ] = '\0';
        }

    return;
}

VOID
CsrCaptureMessageUnicodeStringInPlace(
    IN OUT PCSR_CAPTURE_HEADER CaptureBuffer,
    IN OUT PUNICODE_STRING     String
    )
/*++

Routine Description:

    This function captures an ASCII string into a counted string data
    structure located in an API request message.

Arguments:

    CaptureBuffer - Pointer to a capture buffer allocated by
        CsrAllocateCaptureBuffer.

    String - Optional pointer to the Unicode string.  If this parameter is
        not present, then the counted string data structure is set to
        the null string.

    Length - Length of the Unicode string in bytes, ignored if String is NULL.

    MaximumLength - Maximum length of the string.  Different for null
        terminated strings, where Length does not include the null and
        MaximumLength does. This is always how much space is allocated
        from the capture buffer.

    CaptureString - Pointer to the counted string data structure that will
        be filled in to point to the captured Unicode string.

Return Value:

    None, but if you don't trust the String parameter, use a __try block.

--*/
{
    ASSERT(String != NULL);

    CsrCaptureMessageString(
        CaptureBuffer,
        (PCSTR)String->Buffer,
        String->Length,
        String->MaximumLength,
        (PSTRING)String
        );

    // test > before substraction due to unsignedness
    if (String->MaximumLength > String->Length) {
        if ((String->MaximumLength - String->Length) >= sizeof(WCHAR)) {
            String->Buffer[ String->Length / sizeof(WCHAR) ] = 0;
            }
    }
}

NTSTATUS
CsrCaptureMessageMultiUnicodeStringsInPlace(
    IN OUT PCSR_CAPTURE_HEADER* InOutCaptureBuffer,
    IN ULONG                    NumberOfStringsToCapture,
    IN const PUNICODE_STRING*   StringsToCapture
    )
/*++

Routine Description:

    Capture multiple unicode strings.
    If the CaptureBuffer hasn't been allocated yet (passed as NULL), first
        allocate it.

Arguments:

    CaptureBuffer - Pointer to a capture buffer allocated by
        CsrAllocateCaptureBuffer, or NULL, in which case we call CsrAllocateCaptureBuffer
        for you; this is the case if you are only capturing these strings
        and nothing else.

    NumberOfStringsToCapture - 

    StringsToCapture - 

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Length = 0;
    ULONG i = 0;
    PCSR_CAPTURE_HEADER CaptureBuffer = NULL;

    if (InOutCaptureBuffer == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    CaptureBuffer = *InOutCaptureBuffer;

    if (CaptureBuffer == NULL) {
        Length = 0;
        for (i = 0 ; i != NumberOfStringsToCapture ; ++i) {
            if (StringsToCapture[i] != NULL) {
                Length += StringsToCapture[i]->MaximumLength;
            }
        }
        CaptureBuffer = CsrAllocateCaptureBuffer(NumberOfStringsToCapture, Length);
        if (CaptureBuffer == NULL) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }
        *InOutCaptureBuffer = CaptureBuffer;
    }
    for (i = 0 ; i != NumberOfStringsToCapture ; ++i) {
        if (StringsToCapture[i] != NULL) {
            CsrCaptureMessageUnicodeStringInPlace(
                CaptureBuffer,
                StringsToCapture[i]
                );
        } else {
        }
    }
    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

PLARGE_INTEGER
CsrCaptureTimeout(
    IN ULONG MilliSeconds,
    OUT PLARGE_INTEGER Timeout
    )
{
    if (MilliSeconds == -1) {
        return( NULL );
        }
    else {
        Timeout->QuadPart = Int32x32To64( MilliSeconds, -10000 );
        return( (PLARGE_INTEGER)Timeout );
        }
}

VOID
CsrProbeForWrite(
    IN PVOID Address,
    IN ULONG Length,
    IN ULONG Alignment
    )

/*++

Routine Description:

    This function probes a structure for read accessibility.
    If the structure is not accessible, then an exception is raised.

Arguments:

    Address - Supplies a pointer to the structure to be probed.

    Length - Supplies the length of the structure.

    Alignment - Supplies the required alignment of the structure expressed
        as the number of bytes in the primitive datatype (e.g., 1 for char,
        2 for short, 4 for long, and 8 for quad).

Return Value:

    None.

--*/

{
    volatile CHAR *StartAddress;
    volatile CHAR *EndAddress;
    CHAR Temp;

    //
    // If the structure has zero length, then do not probe the structure for
    // write accessibility or alignment.
    //

    if (Length != 0) {

        //
        // If the structure is not properly aligned, then raise a data
        // misalignment exception.
        //

        ASSERT((Alignment == 1) || (Alignment == 2) ||
               (Alignment == 4) || (Alignment == 8));
        StartAddress = (volatile CHAR *)Address;

        if (((ULONG_PTR)StartAddress & (Alignment - 1)) != 0) {
            RtlRaiseStatus(STATUS_DATATYPE_MISALIGNMENT);
        } else {
            //
            // BUG, BUG - this should not be necessary once the 386 kernel
            // makes system space inaccessable to user mode.
            //
            if ((ULONG_PTR)StartAddress > CsrNtSysInfo.MaximumUserModeAddress) {
                RtlRaiseStatus(STATUS_ACCESS_VIOLATION);
            }

            Temp = *StartAddress;
            *StartAddress = Temp;
            EndAddress = StartAddress + Length - 1;
            Temp = *EndAddress;
            *EndAddress = Temp;
        }
    }
}

VOID
CsrProbeForRead(
    IN PVOID Address,
    IN ULONG Length,
    IN ULONG Alignment
    )

/*++

Routine Description:

    This function probes a structure for read accessibility.
    If the structure is not accessible, then an exception is raised.

Arguments:

    Address - Supplies a pointer to the structure to be probed.

    Length - Supplies the length of the structure.

    Alignment - Supplies the required alignment of the structure expressed
        as the number of bytes in the primitive datatype (e.g., 1 for char,
        2 for short, 4 for long, and 8 for quad).

Return Value:

    None.

--*/

{
    volatile CHAR *StartAddress;
    volatile CHAR *EndAddress;
    CHAR Temp;

    //
    // If the structure has zero length, then do not probe the structure for
    // read accessibility or alignment.
    //

    if (Length != 0) {

        //
        // If the structure is not properly aligned, then raise a data
        // misalignment exception.
        //

        ASSERT((Alignment == 1) || (Alignment == 2) ||
               (Alignment == 4) || (Alignment == 8));
        StartAddress = (volatile CHAR *)Address;

        if (((ULONG_PTR)StartAddress & (Alignment - 1)) != 0) {
            RtlRaiseStatus(STATUS_DATATYPE_MISALIGNMENT);
        } else {
            Temp = *StartAddress;
            EndAddress = StartAddress + Length - 1;
            Temp = *EndAddress;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\dbgdllp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dbgdllp.h

Abstract:

    Debug Subsystem Dll Private Types and Prototypes

Author:

    Mark Lucovsky (markl) 22-Jan-1990

Revision History:

--*/

#ifndef _DBGDLLP_
#define _DBGDLLP_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsm.h>
#define NOEXTAPI
#include <wdbgexts.h>
#include <ntdbg.h>



//
// DbgSs Private Dll Prototypes and variables
//

HANDLE DbgSspApiPort;
HANDLE DbgSspKmReplyPort;
PDBGSS_UI_LOOKUP DbgSspUiLookUpRoutine;
PDBGSS_SUBSYSTEMKEY_LOOKUP DbgSspSubsystemKeyLookupRoutine;
PDBGSS_DBGKM_APIMSG_FILTER DbgSspKmApiMsgFilter;

typedef struct _DBGSS_CONTINUE_KEY {
    DBGKM_APIMSG KmApiMsg;
    HANDLE ReplyEvent;
} DBGSS_CONTINUE_KEY, *PDBGSS_CONTINUE_KEY;


NTSTATUS
DbgSspConnectToDbg( VOID );

NTSTATUS
DbgSspSrvApiLoop(
    IN PVOID ThreadParameter
    );

NTSTATUS
DbgSspCreateProcess (
    IN PDBGSS_CONTINUE_KEY ContinueKey,
    IN PCLIENT_ID AppClientId,
    IN PCLIENT_ID DebugUiClientId,
    IN PDBGKM_CREATE_PROCESS NewProcess
    );

NTSTATUS
DbgSspCreateThread (
    IN PDBGSS_CONTINUE_KEY ContinueKey,
    IN PCLIENT_ID AppClientId,
    IN PDBGKM_CREATE_THREAD NewThread
    );

NTSTATUS
DbgSspExitThread (
    IN PDBGSS_CONTINUE_KEY ContinueKey,
    IN PCLIENT_ID AppClientId,
    IN PDBGKM_EXIT_THREAD ExitThread
    );

NTSTATUS
DbgSspExitProcess (
    IN PDBGSS_CONTINUE_KEY ContinueKey,
    IN PCLIENT_ID AppClientId,
    IN PDBGKM_EXIT_PROCESS ExitProcess
    );

NTSTATUS
DbgSspException (
    IN PDBGSS_CONTINUE_KEY ContinueKey,
    IN PCLIENT_ID AppClientId,
    IN PDBGKM_EXCEPTION Exception
    );

NTSTATUS
DbgSspLoadDll (
    IN PDBGSS_CONTINUE_KEY ContinueKey,
    IN PCLIENT_ID AppClientId,
    IN PDBGKM_LOAD_DLL LoadDll
    );

NTSTATUS
DbgSspUnloadDll (
    IN PDBGSS_CONTINUE_KEY ContinueKey,
    IN PCLIENT_ID AppClientId,
    IN PDBGKM_UNLOAD_DLL UnloadDll
    );

#endif // _DBGDLLP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\frame.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    frame.c

Abstract:

    Code to set/restore the active frame pointer in the TEB for
    additional debugging assistance.

Author:

    Michael Grier (mgrier) 3/2/2001

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

NTSYSAPI
VOID
NTAPI
RtlPushFrame(
    IN PTEB_ACTIVE_FRAME Frame
    )
{
    const PTEB Teb = NtCurrentTeb();
    Frame->Previous = Teb->ActiveFrame;
    Teb->ActiveFrame = Frame;
}

NTSYSAPI
VOID
NTAPI
RtlPopFrame(
    IN PTEB_ACTIVE_FRAME Frame
    )
{
    const PTEB Teb = NtCurrentTeb();
    Teb->ActiveFrame = Frame->Previous;
}

NTSYSAPI
PTEB_ACTIVE_FRAME
NTAPI
RtlGetFrame(
    VOID
    )
{
    return NtCurrentTeb()->ActiveFrame;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\dllssstb.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dllssstb.c

Abstract:

    Debug Subsystem DbgSs API Stubs

Author:

    Mark Lucovsky (markl) 22-Jan-1990

Revision History:

--*/

#include "dbgdllp.h"
#include "ldrp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\filestm.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    filestm.c

Abstract:

    This modules implements IStream over a file.

Author:

    Jay Krell (a-JayK) June 2000

Revision History:

--*/

#define RTL_DECLARE_STREAMS 1
#define RTL_DECLARE_FILE_STREAM 1
#include "ntos.h"
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "objidl.h"

#define RTLP_FILE_STREAM_NOT_IMPL(x) \
  KdPrintEx((DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "RTLSXS: %s() E_NOTIMPL", __FUNCTION__)); \
  return E_NOTIMPL;

#if !defined(RTLP_FILE_STREAM_HRESULT_FROM_STATUS)
  #if defined(RTLP_HRESULT_FROM_STATUS)
    #define RTLP_FILE_STREAM_HRESULT_FROM_STATUS(x) RTLP_HRESULT_FROM_STATUS(x)
  #else
    #define RTLP_FILE_STREAM_HRESULT_FROM_STATUS(x) HRESULT_FROM_WIN32(RtlNtStatusToDosErrorNoTeb(x))
    //#define RTLP_FILE_STREAM_HRESULT_FROM_STATUS(x) HRESULT_FROM_WIN32(RtlNtStatusToDosError(x))
    //#define RTLP_FILE_STREAM_HRESULT_FROM_STATUS(x)   HRESULT_FROM_NT(x)
  #endif
#endif

HRESULT
STDMETHODCALLTYPE
RtlInitFileStream(
    PRTL_FILE_STREAM FileStream
    )
{
    RtlZeroMemory(FileStream, sizeof(*FileStream));
    return NOERROR;
}

HRESULT
STDMETHODCALLTYPE
RtlCloseFileStream(
    PRTL_FILE_STREAM FileStream
    )
{
    const HANDLE FileHandle = FileStream->FileHandle;
    NTSTATUS Status = STATUS_SUCCESS;
    HRESULT Hr = NOERROR;

    if (FileHandle != NULL) {
        FileStream->FileHandle = NULL;
        Status = NtClose(FileHandle);
        if (!NT_SUCCESS(Status)) {
            Hr = RTLP_FILE_STREAM_HRESULT_FROM_STATUS(Status);
        }
    }
    return Hr;
}

ULONG
STDMETHODCALLTYPE
RtlAddRefFileStream(
    PRTL_FILE_STREAM FileStream
    )
{
    LONG ReferenceCount = InterlockedIncrement(&FileStream->ReferenceCount);
    return ReferenceCount;
}

ULONG
STDMETHODCALLTYPE
RtlReleaseFileStream(
    PRTL_FILE_STREAM FileStream
    )
{
    LONG ReferenceCount = InterlockedDecrement(&FileStream->ReferenceCount);
    if (ReferenceCount == 0 && FileStream->FinalRelease != NULL) {
        FileStream->FinalRelease(FileStream);
    }
    return ReferenceCount;
}

HRESULT
STDMETHODCALLTYPE
RtlQueryInterfaceFileStream(
    IStream*         Functions,
    PRTL_FILE_STREAM Data,
    const IID*       Interface,
    PVOID*           Object
    )
{
    if (IsEqualGUID(Interface, &IID_IUnknown)
        || IsEqualGUID(Interface, &IID_IStream)
        || IsEqualGUID(Interface, &IID_ISequentialStream)
        )
    {
        InterlockedIncrement(&Data->ReferenceCount);
        *Object = Functions;
        return NOERROR;
    }
    return E_NOINTERFACE;
}

HRESULT
STDMETHODCALLTYPE
RtlReadFileStream(
    PRTL_FILE_STREAM FileStream,
    PVOID              Buffer,
    ULONG              BytesToRead,
    ULONG*             BytesRead
    )
{
    //
    // based on Win32 ReadFile
    // we should allow asynchronous i/o here.. put the IO_STATUS_BLOCK
    // in the RTL_FILE_STREAM..
    //
    IO_STATUS_BLOCK IoStatusBlock;
    const HANDLE FileHandle = FileStream->FileHandle;
    NTSTATUS Status = STATUS_SUCCESS;
    HRESULT Hr = NOERROR;

    Status = NtReadFile(
            FileHandle,
            NULL, // optional event
            NULL, // optional apc routine
            NULL, // optional apc context
            &IoStatusBlock,
            Buffer,
            BytesToRead,
            NULL, // optional offset
            NULL  // optional "key"
            );

    if ( Status == STATUS_PENDING) {
        // Operation must complete before return & IoStatusBlock destroyed
        Status = NtWaitForSingleObject(FileHandle, FALSE, NULL);
        if (NT_SUCCESS(Status)) {
            Status = IoStatusBlock.Status;
        }
    }

    if (NT_SUCCESS(Status)) {
        *BytesRead = (ULONG)IoStatusBlock.Information; // cast from ULONG_PTR
        Hr = NOERROR;
    } else if (Status == STATUS_END_OF_FILE) {
        *BytesRead = 0;
        Hr = NOERROR;
    } else {
        if (NT_WARNING(Status)) {
            *BytesRead = (ULONG)IoStatusBlock.Information; // cast from ULONG_PTR
        }
        Hr = RTLP_FILE_STREAM_HRESULT_FROM_STATUS(Status);
    }
    return Hr;
}

HRESULT
STDMETHODCALLTYPE
RtlWriteFileStream(
    PRTL_FILE_STREAM FileStream,
    const VOID*      Buffer,
    ULONG            BytesToWrite,
    ULONG*           BytesWritten
    )
{
    RTLP_FILE_STREAM_NOT_IMPL(Write);
}

HRESULT
STDMETHODCALLTYPE
RtlSeekFileStream(
    PRTL_FILE_STREAM   FileStream,
    LARGE_INTEGER      Distance,
    DWORD              Origin,
    ULARGE_INTEGER*    NewPosition
    )
{
    //
    // based closely on Win32 SetFilePointer
    //
    HRESULT Hr = NOERROR;
    NTSTATUS Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_POSITION_INFORMATION CurrentPosition;
    const HANDLE FileHandle = FileStream->FileHandle;

    switch (Origin) {
        case STREAM_SEEK_SET:
            CurrentPosition.CurrentByteOffset = Distance;
            break;

        case STREAM_SEEK_CUR:
            Status = NtQueryInformationFile(
                FileHandle,
                &IoStatusBlock,
                &CurrentPosition,
                sizeof(CurrentPosition),
                FilePositionInformation
                );
            if (!NT_SUCCESS(Status)) {
                Hr = RTLP_FILE_STREAM_HRESULT_FROM_STATUS(Status);
                goto Exit;
            }
            CurrentPosition.CurrentByteOffset.QuadPart += Distance.QuadPart;
            break;

        case STREAM_SEEK_END: {
                FILE_STANDARD_INFORMATION StandardInfo;

                Status = NtQueryInformationFile(
                            FileHandle,
                            &IoStatusBlock,
                            &StandardInfo,
                            sizeof(StandardInfo),
                            FileStandardInformation
                            );
                if (!NT_SUCCESS(Status)) {
                    Hr = RTLP_FILE_STREAM_HRESULT_FROM_STATUS(Status);
                    goto Exit;
                }
                // SetFilePointer uses + here. Which is correct?
                // Descriptions of how Seek work are always unclear on this point..
                CurrentPosition.CurrentByteOffset.QuadPart =
                                    StandardInfo.EndOfFile.QuadPart - Distance.QuadPart;
            }
            break;

        default:
        // You would expect this to be E_INVALIDARG, but since
        // the IStream
        // but IStream docs weakly suggest STG_E_INVALIDPOINTER.
            Hr = STG_E_INVALIDFUNCTION; // E_INVALIDARG?
            goto Exit;
    }
    if (CurrentPosition.CurrentByteOffset.QuadPart < 0) {
        // You would expect this to be E_INVALIDARG,
        // but IStream docs say to return STG_E_INVALIDPOINTER.
        Hr = STG_E_INVALIDPOINTER;
        goto Exit;
    }

    //
    // Set the current file position
    //

    Status = NtSetInformationFile(
                FileHandle,
                &IoStatusBlock,
                &CurrentPosition,
                sizeof(CurrentPosition),
                FilePositionInformation
                );

    NewPosition->QuadPart = CurrentPosition.CurrentByteOffset.QuadPart;
    Hr = NOERROR;
Exit:
    return Hr;
}

HRESULT
STDMETHODCALLTYPE
RtlSetFileStreamSize(
    PRTL_FILE_STREAM  FileStream,
    ULARGE_INTEGER    NewSize
    )
{
    //
    // based on Win32 SetEndOfFile, but is independent of current seek pointer
    //
    NTSTATUS Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_END_OF_FILE_INFORMATION EndOfFile;
    FILE_ALLOCATION_INFORMATION Allocation;
    const HANDLE FileHandle = FileStream->FileHandle;

    EndOfFile.EndOfFile.QuadPart = NewSize.QuadPart;
    Allocation.AllocationSize.QuadPart = NewSize.QuadPart;

    Status = NtSetInformationFile(
                FileHandle,
                &IoStatusBlock,
                &EndOfFile,
                sizeof(EndOfFile),
                FileEndOfFileInformation
                );
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    Status = NtSetInformationFile(
                FileHandle,
                &IoStatusBlock,
                &Allocation,
                sizeof(Allocation),
                FileAllocationInformation
                );
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }
    Status = STATUS_SUCCESS;
Exit:
    if (NT_SUCCESS(Status)) {
        return NOERROR;
    } else {
        return RTLP_FILE_STREAM_HRESULT_FROM_STATUS(Status);
    }
}

HRESULT
STDMETHODCALLTYPE
RtlCopyFileStreamTo(
    PRTL_FILE_STREAM   FileStream,
    IStream*           AnotherStream,
    ULARGE_INTEGER     NumberOfBytesToCopyLargeInteger,
    ULARGE_INTEGER*    NumberOfBytesRead,
    ULARGE_INTEGER*    NumberOfBytesWrittenLargeInteger
    )
{
    //
    // Memory mapping where possible would be nice (but beware sockets and consoles).
    // see \vsee\lib\CWin32Stream.
    //
    RTLP_FILE_STREAM_NOT_IMPL(CopyTo);
}

HRESULT
STDMETHODCALLTYPE
RtlCommitFileStream(
    PRTL_FILE_STREAM FileStream,
    ULONG              Flags
    )
{
    RTLP_FILE_STREAM_NOT_IMPL(Commit);
}

HRESULT
STDMETHODCALLTYPE
RtlRevertFileStream(
    PRTL_FILE_STREAM FileStream
    )
{
    RTLP_FILE_STREAM_NOT_IMPL(Revert);
}

HRESULT
STDMETHODCALLTYPE
RtlLockFileStreamRegion(
    PRTL_FILE_STREAM FileStream,
    ULARGE_INTEGER     Offset,
    ULARGE_INTEGER     NumberOfBytes,
    ULONG              LockType
    )
{
    RTLP_FILE_STREAM_NOT_IMPL(LockRegion);
}

HRESULT
STDMETHODCALLTYPE
RtlUnlockFileStreamRegion(
    PRTL_FILE_STREAM FileStream,
    ULARGE_INTEGER   Offset,
    ULARGE_INTEGER   NumberOfBytes,
    ULONG            LockType
    )
{
    RTLP_FILE_STREAM_NOT_IMPL(UnlockRegion);
}

HRESULT
STDMETHODCALLTYPE
RtlStatFileStream(
    PRTL_FILE_STREAM FileStream,
    STATSTG*         StatusInformation,
    ULONG            Flags
    )
{
    RTLP_FILE_STREAM_NOT_IMPL(Stat);
}

HRESULT
STDMETHODCALLTYPE
RtlCloneFileStream(
    PRTL_FILE_STREAM FileStream,
    IStream**          NewStream
    )
{
    RTLP_FILE_STREAM_NOT_IMPL(Clone);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\heaptag.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    heaptag.c

Abstract:

    This module implements the support routines needed for FLG_HEAP_ENABLE_TAG_BY_DLL

Author:

    Steve Wood (stevewo) 07-Apr-1995

Revision History:

--*/

#include <ntos.h>
#include "ldrp.h"
#include <stktrace.h>
#include <heap.h>
#include <stdio.h>

#define LDRP_MAXIMUM_DLL_TAGS 64

BOOLEAN LdrpDllTagsInitialized;
ULONG LdrpNumberOfDllTags;
ULONG LdrpBaseDllTag;
ULONG LdrpDllTags[ LDRP_MAXIMUM_DLL_TAGS ];

#define DEFINE_HEAPTAG_ENTRY( n ) \
PVOID LdrpTagAllocateHeap##n( PVOID h, ULONG f, ULONG s ) {return LdrpTagAllocateHeap( h, f, s, n ); }

PVOID
LdrpTagAllocateHeap(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN ULONG Size,
    IN ULONG n
    )
{
    if ((Flags & HEAP_TAG_MASK) == 0) {
        Flags |= LdrpDllTags[ n ];
        }

    return RtlAllocateHeap( HeapHandle, Flags, Size );
}

DEFINE_HEAPTAG_ENTRY(  0 );
DEFINE_HEAPTAG_ENTRY(  1 );
DEFINE_HEAPTAG_ENTRY(  2 );
DEFINE_HEAPTAG_ENTRY(  3 );
DEFINE_HEAPTAG_ENTRY(  4 );
DEFINE_HEAPTAG_ENTRY(  5 );
DEFINE_HEAPTAG_ENTRY(  6 );
DEFINE_HEAPTAG_ENTRY(  7 );
DEFINE_HEAPTAG_ENTRY(  8 );
DEFINE_HEAPTAG_ENTRY(  9 );
DEFINE_HEAPTAG_ENTRY( 10 );
DEFINE_HEAPTAG_ENTRY( 11 );
DEFINE_HEAPTAG_ENTRY( 12 );
DEFINE_HEAPTAG_ENTRY( 13 );
DEFINE_HEAPTAG_ENTRY( 14 );
DEFINE_HEAPTAG_ENTRY( 15 );
DEFINE_HEAPTAG_ENTRY( 16 );
DEFINE_HEAPTAG_ENTRY( 17 );
DEFINE_HEAPTAG_ENTRY( 18 );
DEFINE_HEAPTAG_ENTRY( 19 );
DEFINE_HEAPTAG_ENTRY( 20 );
DEFINE_HEAPTAG_ENTRY( 21 );
DEFINE_HEAPTAG_ENTRY( 22 );
DEFINE_HEAPTAG_ENTRY( 23 );
DEFINE_HEAPTAG_ENTRY( 24 );
DEFINE_HEAPTAG_ENTRY( 25 );
DEFINE_HEAPTAG_ENTRY( 26 );
DEFINE_HEAPTAG_ENTRY( 27 );
DEFINE_HEAPTAG_ENTRY( 28 );
DEFINE_HEAPTAG_ENTRY( 29 );
DEFINE_HEAPTAG_ENTRY( 30 );
DEFINE_HEAPTAG_ENTRY( 31 );
DEFINE_HEAPTAG_ENTRY( 32 );
DEFINE_HEAPTAG_ENTRY( 33 );
DEFINE_HEAPTAG_ENTRY( 34 );
DEFINE_HEAPTAG_ENTRY( 35 );
DEFINE_HEAPTAG_ENTRY( 36 );
DEFINE_HEAPTAG_ENTRY( 37 );
DEFINE_HEAPTAG_ENTRY( 38 );
DEFINE_HEAPTAG_ENTRY( 39 );
DEFINE_HEAPTAG_ENTRY( 40 );
DEFINE_HEAPTAG_ENTRY( 41 );
DEFINE_HEAPTAG_ENTRY( 42 );
DEFINE_HEAPTAG_ENTRY( 43 );
DEFINE_HEAPTAG_ENTRY( 44 );
DEFINE_HEAPTAG_ENTRY( 45 );
DEFINE_HEAPTAG_ENTRY( 46 );
DEFINE_HEAPTAG_ENTRY( 47 );
DEFINE_HEAPTAG_ENTRY( 48 );
DEFINE_HEAPTAG_ENTRY( 49 );
DEFINE_HEAPTAG_ENTRY( 50 );
DEFINE_HEAPTAG_ENTRY( 51 );
DEFINE_HEAPTAG_ENTRY( 52 );
DEFINE_HEAPTAG_ENTRY( 53 );
DEFINE_HEAPTAG_ENTRY( 54 );
DEFINE_HEAPTAG_ENTRY( 55 );
DEFINE_HEAPTAG_ENTRY( 56 );
DEFINE_HEAPTAG_ENTRY( 57 );
DEFINE_HEAPTAG_ENTRY( 58 );
DEFINE_HEAPTAG_ENTRY( 59 );
DEFINE_HEAPTAG_ENTRY( 60 );
DEFINE_HEAPTAG_ENTRY( 61 );
DEFINE_HEAPTAG_ENTRY( 62 );
DEFINE_HEAPTAG_ENTRY( 63 );

typedef PVOID (*PLDRP_DLL_TAG_PROCEDURE)(
    PVOID HeapHandle,
    ULONG Flags,
    ULONG Size
    );

const PLDRP_DLL_TAG_PROCEDURE LdrpDllTagProcedures[ LDRP_MAXIMUM_DLL_TAGS ] = {
    LdrpTagAllocateHeap0,
    LdrpTagAllocateHeap1,
    LdrpTagAllocateHeap2,
    LdrpTagAllocateHeap3,
    LdrpTagAllocateHeap4,
    LdrpTagAllocateHeap5,
    LdrpTagAllocateHeap6,
    LdrpTagAllocateHeap7,
    LdrpTagAllocateHeap8,
    LdrpTagAllocateHeap9,
    LdrpTagAllocateHeap10,
    LdrpTagAllocateHeap11,
    LdrpTagAllocateHeap12,
    LdrpTagAllocateHeap13,
    LdrpTagAllocateHeap14,
    LdrpTagAllocateHeap15,
    LdrpTagAllocateHeap16,
    LdrpTagAllocateHeap17,
    LdrpTagAllocateHeap18,
    LdrpTagAllocateHeap19,
    LdrpTagAllocateHeap20,
    LdrpTagAllocateHeap21,
    LdrpTagAllocateHeap22,
    LdrpTagAllocateHeap23,
    LdrpTagAllocateHeap24,
    LdrpTagAllocateHeap25,
    LdrpTagAllocateHeap26,
    LdrpTagAllocateHeap27,
    LdrpTagAllocateHeap28,
    LdrpTagAllocateHeap29,
    LdrpTagAllocateHeap30,
    LdrpTagAllocateHeap31,
    LdrpTagAllocateHeap32,
    LdrpTagAllocateHeap33,
    LdrpTagAllocateHeap34,
    LdrpTagAllocateHeap35,
    LdrpTagAllocateHeap36,
    LdrpTagAllocateHeap37,
    LdrpTagAllocateHeap38,
    LdrpTagAllocateHeap39,
    LdrpTagAllocateHeap40,
    LdrpTagAllocateHeap41,
    LdrpTagAllocateHeap42,
    LdrpTagAllocateHeap43,
    LdrpTagAllocateHeap44,
    LdrpTagAllocateHeap45,
    LdrpTagAllocateHeap46,
    LdrpTagAllocateHeap47,
    LdrpTagAllocateHeap48,
    LdrpTagAllocateHeap49,
    LdrpTagAllocateHeap50,
    LdrpTagAllocateHeap51,
    LdrpTagAllocateHeap52,
    LdrpTagAllocateHeap53,
    LdrpTagAllocateHeap54,
    LdrpTagAllocateHeap55,
    LdrpTagAllocateHeap56,
    LdrpTagAllocateHeap57,
    LdrpTagAllocateHeap58,
    LdrpTagAllocateHeap59,
    LdrpTagAllocateHeap60,
    LdrpTagAllocateHeap61,
    LdrpTagAllocateHeap62,
    LdrpTagAllocateHeap63
};

PVOID
LdrpDefineDllTag(
    PWSTR TagName,
    PUSHORT TagIndex
    )
{
    PVOID Result;
    WCHAR TagNameBuffer[ 260 ];

    if (RtlpGlobalTagHeap == NULL) {
        RtlpGlobalTagHeap = RtlAllocateHeap( RtlProcessHeap( ), HEAP_ZERO_MEMORY, sizeof( HEAP ));
        if (RtlpGlobalTagHeap == NULL) {
            return NULL;
        }
    }
    
    if (!LdrpDllTagsInitialized) {
        //
        // Keep QUERY.C happy
        //
        InitializeListHead( &RtlpGlobalTagHeap->VirtualAllocdBlocks );
        LdrpDllTagsInitialized = TRUE;
        }

    Result = NULL;
    if (LdrpNumberOfDllTags < LDRP_MAXIMUM_DLL_TAGS) {
        memset( TagNameBuffer, 0, sizeof( TagNameBuffer ) );
        wcscpy( TagNameBuffer, TagName );
        LdrpDllTags[ LdrpNumberOfDllTags ] =
            RtlCreateTagHeap( NULL,
                              0,
                              NULL,
                              TagNameBuffer
                            );

        if (LdrpDllTags[ LdrpNumberOfDllTags ] != 0) {
            Result = LdrpDllTagProcedures[ LdrpNumberOfDllTags ];
            }

        if (Result != NULL) {
            *TagIndex = (USHORT)(LdrpDllTags[ LdrpNumberOfDllTags ] >> HEAP_TAG_SHIFT);
            LdrpNumberOfDllTags += 1;
            }
        }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\dlluistb.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dlluistb.c

Abstract:

    Debug Subsystem DbgUi API Stubs

Author:

    Mark Lucovsky (markl) 23-Jan-1990

Revision History:

    Neill Clift 27-Apr-2000 - Rehashed to call new kernel API's for process debugging

--*/

#include "dbgdllp.h"
#include "windows.h"

#define DbgUiDebugObjectHandle (NtCurrentTeb()->DbgSsReserved[1])

NTSTATUS
DbgUiConnectToDbg( VOID )

/*++

Routine Description:

    This routine makes a connection between the caller and the DbgUi
    port in the Dbg subsystem.  In addition to returning a handle to a
    port object, a handle to a state change semaphore is returned.  This
    semaphore is used in DbgUiWaitStateChange APIs.

Arguments:

    None.

Return Value:

    TBD.

--*/

{
    NTSTATUS st;
    OBJECT_ATTRIBUTES oa;

    //
    // if app is already connected, don't reconnect
    //
    st = STATUS_SUCCESS;
    if ( !DbgUiDebugObjectHandle ) {

        InitializeObjectAttributes (&oa, NULL, 0, NULL, NULL);
        st = NtCreateDebugObject (&DbgUiDebugObjectHandle,
                                  DEBUG_ALL_ACCESS,
                                  &oa,
                                  DEBUG_KILL_ON_CLOSE);
    }
    return st;

}

HANDLE
DbgUiGetThreadDebugObject (
    )
/*++

Routine Description:

    This function returns the current threads debug port handle if it has one.

Arguments:

    None

Return Value:

    HANDLE - Debug port handle;

--*/
{
    return DbgUiDebugObjectHandle;
}


VOID
DbgUiSetThreadDebugObject (
    IN HANDLE DebugObject
    )
/*++

Routine Description:

    This function sets the current thread's debug port handle.
    Any previous value is simply overwritten; there is no
    automatic close of a previous handle.

Arguments:

    DebugObject - Debug object handle to set.

Return Value:

    None.

--*/
{
    DbgUiDebugObjectHandle = DebugObject;
}


NTSTATUS
DbgUiWaitStateChange (
    OUT PDBGUI_WAIT_STATE_CHANGE StateChange,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )

/*++

Routine Description:

    This function causes the calling user interface to wait for a
    state change to occur in one of it's application threads. The
    wait is ALERTABLE.

Arguments:

    StateChange - Supplies the address of state change record that
        will contain the state change information.

Return Value:

    TBD

--*/

{
    NTSTATUS st;


    //
    // Wait for a StateChange to occur
    //
    st = NtWaitForDebugEvent (DbgUiDebugObjectHandle,
                              TRUE,
                              Timeout,
                              StateChange);

    return st;
}

NTSTATUS
DbgUiContinue (
    IN PCLIENT_ID AppClientId,
    IN NTSTATUS ContinueStatus
    )

/*++

Routine Description:

    This function continues an application thread whose state change was
    previously reported through DbgUiWaitStateChange.

Arguments:

    AppClientId - Supplies the address of the ClientId of the
        application thread being continued.  This must be an application
        thread that previously notified the caller through
        DbgUiWaitStateChange but has not yet been continued.

    ContinueStatus - Supplies the continuation status to the thread
        being continued.  valid values for this are:

        DBG_EXCEPTION_HANDLED
        DBG_EXCEPTION_NOT_HANDLED
        DBG_TERMINATE_THREAD
        DBG_TERMINATE_PROCESS
        DBG_CONTINUE

Return Value:

    STATUS_SUCCESS - Successful call to DbgUiContinue

    STATUS_INVALID_CID - An invalid ClientId was specified for the
        AppClientId, or the specified Application was not waiting
        for a continue.

    STATUS_INVALID_PARAMETER - An invalid continue status was specified.

--*/

{
    NTSTATUS st;

    st = NtDebugContinue (DbgUiDebugObjectHandle,
                          AppClientId,
                          ContinueStatus);

    return st;
}

NTSTATUS
DbgUiStopDebugging (
    IN HANDLE Process
    )
/*++

Routine Description:

    This function stops debugging the specified process

Arguments:

    Process - Process handle of process being debugged

Return Value:

    NTSTATUS - Status of call

--*/
{
    NTSTATUS st;

    st = NtRemoveProcessDebug (Process,
                               DbgUiDebugObjectHandle);

    return st;
}

VOID
DbgUiRemoteBreakin (
    IN PVOID Context
    )
/*++

Routine Description:

    This function starts debugging the target process

Arguments:

    Context - Thread context    

Return Value:

    None

--*/
{
    //
    // We need to cover the case here where the caller detaches the debugger
    // (or the debugger fails and the port is removed by
    // the kernel). In this case by the time we execute the debugger may be
    // gone. Test first that the debugger is present and if it
    // is call the breakpoint routine in a try/except block so if it goes
    // away now we unwind and just exit this thread.
    //
    if ((NtCurrentPeb()->BeingDebugged) ||
        (USER_SHARED_DATA->KdDebuggerEnabled & 0x00000002)) {
        try {
            DbgBreakPoint();
        } except (EXCEPTION_EXECUTE_HANDLER) {
        }
    }
    RtlExitUserThread (STATUS_SUCCESS);
}

NTSTATUS
DbgUiIssueRemoteBreakin (
    IN HANDLE Process
    )
/*++

Routine Description:

    This function creates a remote thread int he target process to break in

Arguments:

    Process - Process to debug

Return Value:

    NTSTATUS - Status of call

--*/
{
    NTSTATUS Status, Status1;
    HANDLE Thread;
    CLIENT_ID ClientId;

    Status = RtlCreateUserThread (Process,
                                  NULL,
                                  FALSE,
                                  0,
                                  0,
                                  0,
                                  (PUSER_THREAD_START_ROUTINE) DbgUiRemoteBreakin,
                                  NULL,
                                  &Thread,
                                  &ClientId);
    if (NT_SUCCESS (Status)) {
        Status1 = NtClose (Thread);
        ASSERT (NT_SUCCESS (Status1));
    }
    return Status;
}

NTSTATUS
DbgUiDebugActiveProcess (
     IN HANDLE Process
     )
/*++

Routine Description:

    This function starts debugging the target process

Arguments:

    dwProcessId - Process ID of process being debugged

Return Value:

    NTSTATUS - Status of call

--*/
{
    NTSTATUS Status, Status1;

    Status = NtDebugActiveProcess (Process,
                                   DbgUiDebugObjectHandle);
    if (NT_SUCCESS (Status)) {
        Status = DbgUiIssueRemoteBreakin (Process);
        if (!NT_SUCCESS (Status)) {
            Status1 = DbgUiStopDebugging (Process);
        }
    }

    return Status;
}

NTSTATUS
DbgUiConvertStateChangeStructure (
    IN PDBGUI_WAIT_STATE_CHANGE StateChange,
    OUT LPDEBUG_EVENT DebugEvent)
/*++

Routine Description:

    This function converts the internal state change record to the win32 structure.

Arguments:

    StateChange - Native debugger event structure
    DebugEvent  - Win32 structure

Return Value:

    NTSTATUS - Status of call

--*/
{
    NTSTATUS Status;
    HANDLE hThread;
    THREAD_BASIC_INFORMATION ThreadBasicInfo;
    OBJECT_ATTRIBUTES Obja;


    DebugEvent->dwProcessId = HandleToUlong (StateChange->AppClientId.UniqueProcess);
    DebugEvent->dwThreadId = HandleToUlong (StateChange->AppClientId.UniqueThread);

    switch (StateChange->NewState) {

    case DbgCreateThreadStateChange :
        DebugEvent->dwDebugEventCode = CREATE_THREAD_DEBUG_EVENT;
        DebugEvent->u.CreateThread.hThread =
            StateChange->StateInfo.CreateThread.HandleToThread;
        DebugEvent->u.CreateThread.lpStartAddress =
            (LPTHREAD_START_ROUTINE)StateChange->StateInfo.CreateThread.NewThread.StartAddress;
        Status = NtQueryInformationThread (StateChange->StateInfo.CreateThread.HandleToThread,
                                           ThreadBasicInformation,
                                           &ThreadBasicInfo,
                                           sizeof (ThreadBasicInfo),
                                           NULL);
        if (!NT_SUCCESS (Status)) {
            DebugEvent->u.CreateThread.lpThreadLocalBase = NULL;
        } else {
            DebugEvent->u.CreateThread.lpThreadLocalBase = ThreadBasicInfo.TebBaseAddress;
        }

        break;

    case DbgCreateProcessStateChange :
        DebugEvent->dwDebugEventCode = CREATE_PROCESS_DEBUG_EVENT;
        DebugEvent->u.CreateProcessInfo.hProcess =
            StateChange->StateInfo.CreateProcessInfo.HandleToProcess;
        DebugEvent->u.CreateProcessInfo.hThread =
            StateChange->StateInfo.CreateProcessInfo.HandleToThread;
        DebugEvent->u.CreateProcessInfo.hFile =
            StateChange->StateInfo.CreateProcessInfo.NewProcess.FileHandle;
        DebugEvent->u.CreateProcessInfo.lpBaseOfImage =
            StateChange->StateInfo.CreateProcessInfo.NewProcess.BaseOfImage;
        DebugEvent->u.CreateProcessInfo.dwDebugInfoFileOffset =
            StateChange->StateInfo.CreateProcessInfo.NewProcess.DebugInfoFileOffset;
        DebugEvent->u.CreateProcessInfo.nDebugInfoSize =
            StateChange->StateInfo.CreateProcessInfo.NewProcess.DebugInfoSize;
        DebugEvent->u.CreateProcessInfo.lpStartAddress =
            (LPTHREAD_START_ROUTINE)StateChange->StateInfo.CreateProcessInfo.NewProcess.InitialThread.StartAddress;
        Status = NtQueryInformationThread (StateChange->StateInfo.CreateProcessInfo.HandleToThread,
                                           ThreadBasicInformation,
                                           &ThreadBasicInfo,
                                           sizeof (ThreadBasicInfo),
                                           NULL);
        if (!NT_SUCCESS (Status)) {
            DebugEvent->u.CreateProcessInfo.lpThreadLocalBase = NULL;
        } else {
            DebugEvent->u.CreateProcessInfo.lpThreadLocalBase = ThreadBasicInfo.TebBaseAddress;
        }
        DebugEvent->u.CreateProcessInfo.lpImageName = NULL;
        DebugEvent->u.CreateProcessInfo.fUnicode = 1;


        break;

    case DbgExitThreadStateChange :

        DebugEvent->dwDebugEventCode = EXIT_THREAD_DEBUG_EVENT;
        DebugEvent->u.ExitThread.dwExitCode = (DWORD)StateChange->StateInfo.ExitThread.ExitStatus;
        break;

    case DbgExitProcessStateChange :

        DebugEvent->dwDebugEventCode = EXIT_PROCESS_DEBUG_EVENT;
        DebugEvent->u.ExitProcess.dwExitCode = (DWORD)StateChange->StateInfo.ExitProcess.ExitStatus;
        break;

    case DbgExceptionStateChange :
    case DbgBreakpointStateChange :
    case DbgSingleStepStateChange :

        if (StateChange->StateInfo.Exception.ExceptionRecord.ExceptionCode == DBG_PRINTEXCEPTION_C) {
            DebugEvent->dwDebugEventCode = OUTPUT_DEBUG_STRING_EVENT;

            DebugEvent->u.DebugString.lpDebugStringData =
                (PVOID)StateChange->StateInfo.Exception.ExceptionRecord.ExceptionInformation[1];
            DebugEvent->u.DebugString.nDebugStringLength =
                (WORD)StateChange->StateInfo.Exception.ExceptionRecord.ExceptionInformation[0];
            DebugEvent->u.DebugString.fUnicode = (WORD)0;
        } else if (StateChange->StateInfo.Exception.ExceptionRecord.ExceptionCode == DBG_RIPEXCEPTION) {
            DebugEvent->dwDebugEventCode = RIP_EVENT;

            DebugEvent->u.RipInfo.dwType =
                (DWORD)StateChange->StateInfo.Exception.ExceptionRecord.ExceptionInformation[1];
            DebugEvent->u.RipInfo.dwError =
                (DWORD)StateChange->StateInfo.Exception.ExceptionRecord.ExceptionInformation[0];
        } else {
            DebugEvent->dwDebugEventCode = EXCEPTION_DEBUG_EVENT;
            DebugEvent->u.Exception.ExceptionRecord =
                StateChange->StateInfo.Exception.ExceptionRecord;
            DebugEvent->u.Exception.dwFirstChance =
                StateChange->StateInfo.Exception.FirstChance;
        }
        break;

    case DbgLoadDllStateChange :
        DebugEvent->dwDebugEventCode = LOAD_DLL_DEBUG_EVENT;
        DebugEvent->u.LoadDll.lpBaseOfDll =
            StateChange->StateInfo.LoadDll.BaseOfDll;
        DebugEvent->u.LoadDll.hFile =
            StateChange->StateInfo.LoadDll.FileHandle;
        DebugEvent->u.LoadDll.dwDebugInfoFileOffset =
            StateChange->StateInfo.LoadDll.DebugInfoFileOffset;
        DebugEvent->u.LoadDll.nDebugInfoSize =
            StateChange->StateInfo.LoadDll.DebugInfoSize;
        //
        // pick up the image name
        //

        InitializeObjectAttributes(&Obja, NULL, 0, NULL, NULL);
        Status = NtOpenThread (&hThread,
                               THREAD_QUERY_INFORMATION,
                               &Obja,
                               &StateChange->AppClientId);
        if (NT_SUCCESS (Status)) {
            Status = NtQueryInformationThread (hThread,
                                               ThreadBasicInformation,
                                               &ThreadBasicInfo,
                                               sizeof (ThreadBasicInfo),
                                               NULL);
            NtClose (hThread);
        }
        if (NT_SUCCESS (Status)) {
            DebugEvent->u.LoadDll.lpImageName = &ThreadBasicInfo.TebBaseAddress->NtTib.ArbitraryUserPointer;
        } else {
            DebugEvent->u.LoadDll.lpImageName = NULL;
        }
        DebugEvent->u.LoadDll.fUnicode = 1;


        break;

    case DbgUnloadDllStateChange :
        DebugEvent->dwDebugEventCode = UNLOAD_DLL_DEBUG_EVENT;
        DebugEvent->u.UnloadDll.lpBaseOfDll =
            StateChange->StateInfo.UnloadDll.BaseAddress;
        break;

    default:
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\curdir.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    curdir.c

Abstract:

    Current directory support

Author:

    Mark Lucovsky (markl) 10-Oct-1990

Revision History:

--*/

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "string.h"
#include "ctype.h"
#include "sxstypes.h"
#include "ntdllp.h"

#define IS_PATH_SEPARATOR_U(ch) (((ch) == L'\\') || ((ch) == L'/'))
#define IS_END_OF_COMPONENT_U(ch) (IS_PATH_SEPARATOR_U(ch) || (ch) == UNICODE_NULL)
#define IS_DOT_U(s) ( (s)[0] == L'.' && IS_END_OF_COMPONENT_U( (s)[1] ))
#define IS_DOT_DOT_U(s) ( (s)[0] == L'.' && IS_DOT_U( (s) + 1))
#define IS_DRIVE_LETTER(ch) (((ch) >= 'a' && (ch) <= 'z') || ((ch) >= 'A' && (ch) <= 'Z'))

extern const UNICODE_STRING RtlpDosLPTDevice = RTL_CONSTANT_STRING( L"LPT" );
extern const UNICODE_STRING RtlpDosCOMDevice = RTL_CONSTANT_STRING( L"COM" );
extern const UNICODE_STRING RtlpDosPRNDevice = RTL_CONSTANT_STRING( L"PRN" );
extern const UNICODE_STRING RtlpDosAUXDevice = RTL_CONSTANT_STRING( L"AUX" );
extern const UNICODE_STRING RtlpDosNULDevice = RTL_CONSTANT_STRING( L"NUL" );
extern const UNICODE_STRING RtlpDosCONDevice = RTL_CONSTANT_STRING( L"CON" );

extern const UNICODE_STRING RtlpDosSlashCONDevice   = RTL_CONSTANT_STRING( L"\\\\.\\CON" );
extern const UNICODE_STRING RtlpSlashSlashDot       = RTL_CONSTANT_STRING( L"\\\\.\\" );
extern const UNICODE_STRING RtlpDosDevicesPrefix    = RTL_CONSTANT_STRING( L"\\??\\" );
extern const UNICODE_STRING RtlpDosDevicesUncPrefix = RTL_CONSTANT_STRING( L"\\??\\UNC\\" );

#define RtlpLongestPrefix   RtlpDosDevicesUncPrefix.Length

const UNICODE_STRING RtlpEmptyString = RTL_CONSTANT_STRING(L"");

//
// \\? is referred to as the "Win32Nt" prefix or root.
// Paths that start with \\? are referred to as "Win32Nt" paths.
// Fudging the \\? to \?? converts the path to an Nt path.
//
extern const UNICODE_STRING RtlpWin32NtRoot         = RTL_CONSTANT_STRING( L"\\\\?" );
extern const UNICODE_STRING RtlpWin32NtRootSlash    = RTL_CONSTANT_STRING( L"\\\\?\\" );
extern const UNICODE_STRING RtlpWin32NtUncRoot      = RTL_CONSTANT_STRING( L"\\\\?\\UNC" );
extern const UNICODE_STRING RtlpWin32NtUncRootSlash = RTL_CONSTANT_STRING( L"\\\\?\\UNC\\" );

#define DPFLTR_LEVEL_STATUS(x) ((NT_SUCCESS(x) \
                                    || (x) == STATUS_OBJECT_NAME_NOT_FOUND    \
                                    ) \
                                ? DPFLTR_TRACE_LEVEL : DPFLTR_ERROR_LEVEL)

ULONG
RtlpComputeBackupIndex(
    IN PCURDIR CurDir
    )
{
    ULONG BackupIndex;
    PWSTR UncPathPointer;
    ULONG NumberOfPathSeparators;
    RTL_PATH_TYPE CurDirPathType;


    //
    // Get pathType of curdir
    //

    CurDirPathType = RtlDetermineDosPathNameType_U(CurDir->DosPath.Buffer);
    BackupIndex = 3;
    if ( CurDirPathType == RtlPathTypeUncAbsolute ) {

        //
        // We want to scan the supplied path to determine where
        // the "share" ends, and set BackupIndex to that point.
        //

        UncPathPointer = CurDir->DosPath.Buffer + 2;
        NumberOfPathSeparators = 0;
        while (*UncPathPointer) {
            if (IS_PATH_SEPARATOR_U(*UncPathPointer)) {

                NumberOfPathSeparators++;

                if (NumberOfPathSeparators == 2) {
                    break;
                    }
                }

            UncPathPointer++;

            }

        BackupIndex = (ULONG)(UncPathPointer - CurDir->DosPath.Buffer);
        }
    return BackupIndex;
}


ULONG
RtlGetLongestNtPathLength( VOID )
{
    return RtlpLongestPrefix + DOS_MAX_PATH_LENGTH + 1;
}

VOID
RtlpResetDriveEnvironment(
    IN WCHAR DriveLetter
    )
{
    WCHAR EnvVarNameBuffer[4];
    WCHAR EnvVarNameValue[4];
    UNICODE_STRING s1,s2;

    EnvVarNameBuffer[0] = L'=';
    EnvVarNameBuffer[1] = DriveLetter;
    EnvVarNameBuffer[2] = L':';
    EnvVarNameBuffer[3] = L'\0';
    RtlInitUnicodeString(&s1,EnvVarNameBuffer);

    EnvVarNameValue[0] = DriveLetter;
    EnvVarNameValue[1] = L':';
    EnvVarNameValue[2] = L'\\';
    EnvVarNameValue[3] = L'\0';
    RtlInitUnicodeString(&s2,EnvVarNameValue);

    RtlSetEnvironmentVariable(NULL,&s1,&s2);
}

ULONG
RtlGetCurrentDirectory_U(
    ULONG nBufferLength,
    PWSTR lpBuffer
    )

/*++

Routine Description:

    The current directory for a process can be retreived using
    GetCurrentDirectory.

Arguments:

    nBufferLength - Supplies the length in bytes of the buffer that is to
        receive the current directory string.

    lpBuffer - Returns the current directory string for the current
        process.  The string is a null terminated string and specifies
        the absolute path to the current directory.

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating null character.  If the return value is
    greater than nBufferLength, the return value is the size of the buffer
    required to hold the pathname.  The return value is zero if the
    function failed.

--*/

{
    PCURDIR CurDir;
    ULONG Length;
    PWSTR  CurDirName;

    CurDir = &(NtCurrentPeb()->ProcessParameters->CurrentDirectory);

    RtlAcquirePebLock();
    CurDirName = CurDir->DosPath.Buffer;

    //
    // Make sure user's buffer is big enough to hold the null
    // terminated current directory
    //

    Length = CurDir->DosPath.Length>>1;
    if (CurDirName[Length-2] != L':') {
        if ( nBufferLength < (Length)<<1 ) {
            RtlReleasePebLock();
            return (Length)<<1;
            }
        }
    else {
        if ( nBufferLength <= (Length<<1) ) {
            RtlReleasePebLock();
            return ((Length+1)<<1);
            }
        }

    try {
        RtlMoveMemory(lpBuffer,CurDirName,Length<<1);
        ASSERT(lpBuffer[Length-1] == L'\\');
        if (lpBuffer[Length-2] == L':') {
            lpBuffer[Length] = UNICODE_NULL;
            }
        else {
            lpBuffer[Length-1] = UNICODE_NULL;
            Length--;
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        RtlReleasePebLock();
        return 0L;
        }
    RtlReleasePebLock();
    return Length<<1;
}

NTSTATUS
RtlSetCurrentDirectory_U(
    PUNICODE_STRING PathName
    )

/*++

Routine Description:

    The current directory for a process is changed using
    SetCurrentDirectory.

    Each process has a single current directory.  A current directory is
    made up of type parts.

        - A disk designator either which is either a drive letter followed
          by a colon, or a UNC servername/sharename "\\servername\sharename".

        - A directory on the disk designator.

    For APIs that manipulate files, the file names may be relative to
    the current directory.  A filename is relative to the entire current
    directory if it does not begin with a disk designator or a path name
    SEPARATOR.  If the file name begins with a path name SEPARATOR, then
    it is relative to the disk designator of the current directory.  If
    a file name begins with a disk designator, than it is a fully
    qualified absolute path name.

    The value of lpPathName supplies the current directory.  The value
    of lpPathName, may be a relative path name as described above, or a
    fully qualified absolute path name.  In either case, the fully
    qualified absolute path name of the specified directory is
    calculated and is stored as the current directory.

Arguments:

    lpPathName - Supplies the pathname of the directory that is to be
        made the current directory.

Return Value:

    NT_SUCCESS - The operation was successful

    !NT_SUCCESS - The operation failed

--*/

{
    PCURDIR CurDir;
    NTSTATUS Status;
    BOOLEAN TranslationStatus;
    PVOID FreeBuffer;
    ULONG DosDirLength;
    ULONG IsDevice;
    ULONG DosDirCharCount;
    UNICODE_STRING DosDir;
    UNICODE_STRING NtFileName;
    HANDLE NewDirectoryHandle;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_DEVICE_INFORMATION DeviceInfo;
    RTL_PATH_TYPE InputPathType;

    CurDir = &(NtCurrentPeb()->ProcessParameters->CurrentDirectory);


    DosDir.Buffer = NULL;
    FreeBuffer = NULL;
    NewDirectoryHandle = NULL;

    RtlAcquirePebLock();

    NtCurrentPeb()->EnvironmentUpdateCount += 1;

    //
    // Set current directory is called first by the loader.
    // If current directory is not being inherited, then close
    // it !
    //

    if ( ((ULONG_PTR)CurDir->Handle & OBJ_HANDLE_TAGBITS) == RTL_USER_PROC_CURDIR_CLOSE ) {
        NtClose(CurDir->Handle);
        CurDir->Handle = NULL;
        }

    try {
        try {

            //
            // Compute the length of the Dos style fully qualified current
            // directory
            //

            DosDirLength = CurDir->DosPath.MaximumLength;
            DosDir.Buffer = RtlAllocateHeap(RtlProcessHeap(), 0,DosDirLength);
            if ( !DosDir.Buffer ) {
                return STATUS_NO_MEMORY;
                }
            DosDir.Length = 0;
            DosDir.MaximumLength = (USHORT)DosDirLength;

            //
            // Now get the full pathname for the Dos style current
            // directory
            //

            IsDevice = RtlIsDosDeviceName_Ustr(PathName);
            if ( IsDevice ) {
                return STATUS_NOT_A_DIRECTORY;
                }

            DosDirLength = RtlGetFullPathName_Ustr(
                                PathName,
                                DosDirLength,
                                DosDir.Buffer,
                                NULL,
                                NULL,
                                &InputPathType
                                );
            if ( !DosDirLength ) {
                return STATUS_OBJECT_NAME_INVALID;
                }

            DosDirCharCount = DosDirLength >> 1;


            //
            // Get the Nt filename of the new current directory
            //
            TranslationStatus = RtlDosPathNameToNtPathName_U(
                                    DosDir.Buffer,
                                    &NtFileName,
                                    NULL,
                                    NULL
                                    );

            if ( !TranslationStatus ) {
                return STATUS_OBJECT_NAME_INVALID;
                }
            FreeBuffer = NtFileName.Buffer;

            InitializeObjectAttributes(
                &Obja,
                &NtFileName,
                OBJ_CASE_INSENSITIVE | OBJ_INHERIT,
                NULL,
                NULL
                );

            //
            // If we are inheriting current directory, then
            // avoid the open
            //

            if ( ((ULONG_PTR)CurDir->Handle & OBJ_HANDLE_TAGBITS) ==  RTL_USER_PROC_CURDIR_INHERIT ) {
                NewDirectoryHandle = (HANDLE)((ULONG_PTR)CurDir->Handle & ~OBJ_HANDLE_TAGBITS);
                CurDir->Handle = NULL;

                //
                // Test to see if this is removable media. If so
                // tag the handle this may fail if the process was
                // created with inherit handles set to false
                //

                Status = NtQueryVolumeInformationFile(
                            NewDirectoryHandle,
                            &IoStatusBlock,
                            &DeviceInfo,
                            sizeof(DeviceInfo),
                            FileFsDeviceInformation
                            );
                if ( !NT_SUCCESS(Status) ) {
                    return RtlSetCurrentDirectory_U(PathName);
                    }
                else {
                    if ( DeviceInfo.Characteristics & FILE_REMOVABLE_MEDIA ) {
                        NewDirectoryHandle =(HANDLE)( (ULONG_PTR)NewDirectoryHandle | 1);
                        }
                    }

                }
            else {
                //
                // Open a handle to the current directory. Don't allow
                // deletes of the directory.
                //

                Status = NtOpenFile(
                            &NewDirectoryHandle,
                            FILE_TRAVERSE | SYNCHRONIZE,
                            &Obja,
                            &IoStatusBlock,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT
                            );

                if ( !NT_SUCCESS(Status) ) {
                    return Status;
                    }

                //
                // Test to see if this is removable media. If so
                // tag the handle
                //
                Status = NtQueryVolumeInformationFile(
                            NewDirectoryHandle,
                            &IoStatusBlock,
                            &DeviceInfo,
                            sizeof(DeviceInfo),
                            FileFsDeviceInformation
                            );
                if ( !NT_SUCCESS(Status) ) {
                    return Status;
                    }
                else {
                    if ( DeviceInfo.Characteristics & FILE_REMOVABLE_MEDIA ) {
                        NewDirectoryHandle =(HANDLE)( (ULONG_PTR)NewDirectoryHandle | 1);
                        }
                    }
                }

            //
            // If there is no trailing '\', than place one
            //

            DosDir.Length = (USHORT)DosDirLength;
            if ( DosDir.Buffer[DosDirCharCount-1] != L'\\') {
                DosDir.Buffer[DosDirCharCount] = L'\\';
                DosDir.Buffer[DosDirCharCount+1] = UNICODE_NULL;
                DosDir.Length += sizeof( UNICODE_NULL );
            }

            //
            // Now we are set to change to the new directory.
            //

            RtlMoveMemory( CurDir->DosPath.Buffer, DosDir.Buffer, DosDir.Length+sizeof(UNICODE_NULL) );
            CurDir->DosPath.Length = DosDir.Length;

            if ( CurDir->Handle ) {
                NtClose(CurDir->Handle);
                }
            CurDir->Handle = NewDirectoryHandle;
            NewDirectoryHandle = NULL;
            }
        finally {
            if ( DosDir.Buffer ) {
                RtlFreeHeap(RtlProcessHeap(), 0, DosDir.Buffer);
                }
            if ( FreeBuffer ) {
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                }
            if ( NewDirectoryHandle ) {
                NtClose(NewDirectoryHandle);
                }
            RtlReleasePebLock();
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return STATUS_ACCESS_VIOLATION;
        }
    return STATUS_SUCCESS;
}

RTL_PATH_TYPE
RtlDetermineDosPathNameType_U(
    IN PCWSTR DosFileName
    )

/*++

Routine Description:

    This function examines the Dos format file name and determines the
    type of file name (i.e.  UNC, DriveAbsolute, Current Directory
    rooted, or Relative.)

Arguments:

    DosFileName - Supplies the Dos format file name whose type is to be
        determined.

Return Value:

    RtlPathTypeUnknown - The path type can not be determined

    RtlPathTypeUncAbsolute - The path specifies a Unc absolute path
        in the format \\server-name\sharename\rest-of-path

    RtlPathTypeLocalDevice - The path specifies a local device in the format
        \\.\rest-of-path or \\?\rest-of-path.  This can be used for any device
        where the nt and Win32 names are the same. For example mailslots.

    RtlPathTypeRootLocalDevice - The path specifies the root of the local
        devices in the format \\. or \\?

    RtlPathTypeDriveAbsolute - The path specifies a drive letter absolute
        path in the form drive:\rest-of-path

    RtlPathTypeDriveRelative - The path specifies a drive letter relative
        path in the form drive:rest-of-path

    RtlPathTypeRooted - The path is rooted relative to the current disk
        designator (either Unc disk, or drive). The form is \rest-of-path.

    RtlPathTypeRelative - The path is relative (i.e. not absolute or rooted).

--*/

{
    RTL_PATH_TYPE ReturnValue;
    ASSERT(DosFileName != NULL);

    if (IS_PATH_SEPARATOR_U(*DosFileName)) {
        if ( IS_PATH_SEPARATOR_U(*(DosFileName+1)) ) {
            if ( DosFileName[2] == '.' || DosFileName[2] == '?') {
                if ( IS_PATH_SEPARATOR_U(*(DosFileName+3)) ){
                    ReturnValue = RtlPathTypeLocalDevice;
                    }
                else if ( (*(DosFileName+3)) == UNICODE_NULL ){
                    ReturnValue = RtlPathTypeRootLocalDevice;
                    }
                else {
                    ReturnValue = RtlPathTypeUncAbsolute;
                    }
                }
            else {
                ReturnValue = RtlPathTypeUncAbsolute;
                }
            }
        else {
            ReturnValue = RtlPathTypeRooted;
            }
        }
    else if ((*DosFileName) && (*(DosFileName+1)==L':')) {
        if (IS_PATH_SEPARATOR_U(*(DosFileName+2))) {
            ReturnValue = RtlPathTypeDriveAbsolute;
            }
        else  {
            ReturnValue = RtlPathTypeDriveRelative;
            }
        }
    else {
        ReturnValue = RtlPathTypeRelative;
        }

    return ReturnValue;
}

RTL_PATH_TYPE
NTAPI
RtlDetermineDosPathNameType_Ustr(
    IN PCUNICODE_STRING String
    )

/*++

Routine Description:

    This function examines the Dos format file name and determines the
    type of file name (i.e.  UNC, DriveAbsolute, Current Directory
    rooted, or Relative.)

Arguments:

    DosFileName - Supplies the Dos format file name whose type is to be
        determined.

Return Value:

    RtlPathTypeUnknown - The path type can not be determined

    RtlPathTypeUncAbsolute - The path specifies a Unc absolute path
        in the format \\server-name\sharename\rest-of-path

    RtlPathTypeLocalDevice - The path specifies a local device in the format
        \\.\rest-of-path or \\?\rest-of-path.  This can be used for any device
        where the nt and Win32 names are the same. For example mailslots.

    RtlPathTypeRootLocalDevice - The path specifies the root of the local
        devices in the format \\. or \\?

    RtlPathTypeDriveAbsolute - The path specifies a drive letter absolute
        path in the form drive:\rest-of-path

    RtlPathTypeDriveRelative - The path specifies a drive letter relative
        path in the form drive:rest-of-path

    RtlPathTypeRooted - The path is rooted relative to the current disk
        designator (either Unc disk, or drive). The form is \rest-of-path.

    RtlPathTypeRelative - The path is relative (i.e. not absolute or rooted).

--*/

{
    RTL_PATH_TYPE ReturnValue;
    const PCWSTR DosFileName = String->Buffer;

#define ENOUGH_CHARS(_cch) (String->Length >= ((_cch) * sizeof(WCHAR)))

    if ( ENOUGH_CHARS(1) && IS_PATH_SEPARATOR_U(*DosFileName) ) {
        if ( ENOUGH_CHARS(2) && IS_PATH_SEPARATOR_U(*(DosFileName+1)) ) {
            if ( ENOUGH_CHARS(3) && (DosFileName[2] == '.' ||
                                     DosFileName[2] == '?') ) {

                if ( ENOUGH_CHARS(4) && IS_PATH_SEPARATOR_U(*(DosFileName+3)) ){
                    // "\\.\" or "\\?\"
                    ReturnValue = RtlPathTypeLocalDevice;
                    }
                //
                // Bogosity ahead, the code is confusing length and nuls,
                // because it was copy/pasted from the PCWSTR version.
                //
                else if ( ENOUGH_CHARS(4) && (*(DosFileName+3)) == UNICODE_NULL ){
                    // "\\.\0" or \\?\0"
                    ReturnValue = RtlPathTypeRootLocalDevice;
                    }
                else {
                    // "\\.x" or "\\." or "\\?x" or "\\?"
                    ReturnValue = RtlPathTypeUncAbsolute;
                    }
                }
            else {
                // "\\x"
                ReturnValue = RtlPathTypeUncAbsolute;
                }
            }
        else {
            // "\x"
            ReturnValue = RtlPathTypeRooted;
            }
        }
    //
    // the "*DosFileName" is left over from the PCWSTR version
    // Win32 and DOS don't allow embedded nuls and much code limits
    // drive letters to strictly 7bit a-zA-Z so it's ok.
    //
    else if (ENOUGH_CHARS(2) && *DosFileName && *(DosFileName+1)==L':') {
        if (ENOUGH_CHARS(3) && IS_PATH_SEPARATOR_U(*(DosFileName+2))) {
            // "x:\"
            ReturnValue = RtlPathTypeDriveAbsolute;
            }
        else  {
            // "c:x"
            ReturnValue = RtlPathTypeDriveRelative;
            }
        }
    else {
        // "x", first char is not a slash / second char is not colon
        ReturnValue = RtlPathTypeRelative;
        }
    return ReturnValue;

#undef ENOUGH_CHARS
}

NTSTATUS
NTAPI
RtlpDetermineDosPathNameType4(
    IN ULONG            InFlags,
    IN PCUNICODE_STRING DosPath,
    OUT RTL_PATH_TYPE*  OutType,
    OUT ULONG*          OutFlags
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    RTL_PATH_TYPE PathType = 0;
    BOOLEAN Win32Nt = FALSE;
    BOOLEAN Win32NtUncAbsolute = FALSE;
    BOOLEAN Win32NtDriveAbsolute = FALSE;
    BOOLEAN IncompleteRoot = FALSE;
    RTL_PATH_TYPE PathTypeAfterWin32Nt = 0;

    if (OutType != NULL
        ) {
        *OutType = RtlPathTypeUnknown;
    }
    if (OutFlags != NULL
        ) {
        *OutFlags = 0;
    }
    if (
           !RTL_SOFT_VERIFY(DosPath != NULL)
        || !RTL_SOFT_VERIFY(OutType != NULL)
        || !RTL_SOFT_VERIFY(OutFlags != NULL)
        || !RTL_SOFT_VERIFY(
                (InFlags & ~(RTL_DETERMINE_DOS_PATH_NAME_TYPE_IN_FLAG_OLD | RTL_DETERMINE_DOS_PATH_NAME_TYPE_IN_FLAG_STRICT_WIN32NT))
                == 0)
        ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    PathType = RtlDetermineDosPathNameType_Ustr(DosPath);
    *OutType = PathType;
    if (InFlags & RTL_DETERMINE_DOS_PATH_NAME_TYPE_IN_FLAG_OLD)
        goto Exit;

    if (DosPath->Length == sizeof(L"\\\\") - sizeof(DosPath->Buffer[0])
        ) {
        IncompleteRoot = TRUE;
    }
    else if (RtlEqualUnicodeString(RTL_CONST_CAST(PUNICODE_STRING)(&RtlpWin32NtRoot), RTL_CONST_CAST(PUNICODE_STRING)(DosPath), TRUE)
        ) {
        IncompleteRoot = TRUE;
        Win32Nt = TRUE;
    }
    else if (RtlEqualUnicodeString(RTL_CONST_CAST(PUNICODE_STRING)(&RtlpWin32NtRootSlash), RTL_CONST_CAST(PUNICODE_STRING)(DosPath), TRUE)
        ) {
        IncompleteRoot = TRUE;
        Win32Nt = TRUE;
    }
    else if (RtlPrefixUnicodeString(RTL_CONST_CAST(PUNICODE_STRING)(&RtlpWin32NtRootSlash), RTL_CONST_CAST(PUNICODE_STRING)(DosPath), TRUE)
        ) {
        Win32Nt = TRUE;
    }

    if (Win32Nt) {
        if (RtlEqualUnicodeString(RTL_CONST_CAST(PUNICODE_STRING)(&RtlpWin32NtUncRoot), RTL_CONST_CAST(PUNICODE_STRING)(DosPath), TRUE)
            ) {
            IncompleteRoot = TRUE;
            Win32NtUncAbsolute = TRUE;
        }
        else if (RtlEqualUnicodeString(RTL_CONST_CAST(PUNICODE_STRING)(&RtlpWin32NtUncRootSlash), RTL_CONST_CAST(PUNICODE_STRING)(DosPath), TRUE)
            ) {
            IncompleteRoot = TRUE;
            Win32NtUncAbsolute = TRUE;
        }
        else if (RtlPrefixUnicodeString(RTL_CONST_CAST(PUNICODE_STRING)(&RtlpWin32NtUncRootSlash), RTL_CONST_CAST(PUNICODE_STRING)(DosPath), TRUE)
            ) {
            Win32NtUncAbsolute = TRUE;
        }
        if (Win32NtUncAbsolute
            ) {
            Win32NtDriveAbsolute = FALSE;
        } else if (!IncompleteRoot) {
            const RTL_STRING_LENGTH_TYPE i = RtlpWin32NtRootSlash.Length;
            UNICODE_STRING PathAfterWin32Nt = *DosPath;
            PathAfterWin32Nt.Buffer +=  i / sizeof(PathAfterWin32Nt.Buffer[0]);
            PathAfterWin32Nt.Length -= i;
            PathAfterWin32Nt.MaximumLength -= i;

            PathTypeAfterWin32Nt = RtlDetermineDosPathNameType_Ustr(&PathAfterWin32Nt);
            Win32NtDriveAbsolute = (PathTypeAfterWin32Nt == RtlPathTypeDriveAbsolute);

            if (InFlags & RTL_DETERMINE_DOS_PATH_NAME_TYPE_IN_FLAG_STRICT_WIN32NT
                ) {
                if (!RTL_SOFT_VERIFY(Win32NtDriveAbsolute
                    )) {
                    *OutFlags |= RTLP_DETERMINE_DOS_PATH_NAME_TYPE_OUT_FLAG_INVALID;
                    // we still succeed the function call
                }
            }
        }
    }

    ASSERT(RTLP_IMPLIES(Win32NtDriveAbsolute, Win32Nt));
    ASSERT(RTLP_IMPLIES(Win32NtUncAbsolute, Win32Nt));
    ASSERT(!(Win32NtUncAbsolute && Win32NtDriveAbsolute));

    if (IncompleteRoot)
        *OutFlags |= RTLP_DETERMINE_DOS_PATH_NAME_TYPE_OUT_FLAG_INCOMPLETE_ROOT;
    if (Win32Nt)
        *OutFlags |= RTLP_DETERMINE_DOS_PATH_NAME_TYPE_OUT_FLAG_WIN32NT;
    if (Win32NtUncAbsolute)
        *OutFlags |= RTLP_DETERMINE_DOS_PATH_NAME_TYPE_OUT_FLAG_WIN32NT_UNC_ABSOLUTE;
    if (Win32NtDriveAbsolute)
        *OutFlags |= RTLP_DETERMINE_DOS_PATH_NAME_TYPE_OUT_FLAG_WIN32NT_DRIVE_ABSOLUTE;

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

ULONG
RtlIsDosDeviceName_Ustr(
    IN PUNICODE_STRING DosFileName
    )

/*++

Routine Description:

    This function examines the Dos format file name and determines if it
    is a Dos device name (e.g. LPT1, etc.).  Valid Dos device names are:

        LPTn
        COMn
        PRN
        AUX
        NUL
        CON

    when n is a digit.  Trailing colon is ignored if present.

Arguments:

    DosFileName - Supplies the Dos format file name that is to be examined.

Return Value:

    0 - Specified Dos file name is not the name of a Dos device.

    > 0 - Specified Dos file name is the name of a Dos device and the
          return value is a ULONG where the high order 16 bits is the
          offset in the input buffer where the dos device name beings
          and the low order 16 bits is the length of the device name
          the length of the name (excluding any optional
          trailing colon).

--*/

{
    UNICODE_STRING UnicodeString;
    USHORT NumberOfCharacters;
    ULONG ReturnLength;
    ULONG ReturnOffset;
    LPWSTR p;
    USHORT ColonBias;
    RTL_PATH_TYPE PathType;
    WCHAR wch;

    ColonBias = 0;

    PathType = RtlDetermineDosPathNameType_U(DosFileName->Buffer);
    switch ( PathType ) {

    case RtlPathTypeLocalDevice:
        //
        // For Unc Absolute, Check for \\.\CON
        // since this really is not a device
        //

        if ( RtlEqualUnicodeString(DosFileName,&RtlpDosSlashCONDevice,TRUE) ) {
            return 0x00080006;
        }

        //
        // FALLTHRU
        //

    case RtlPathTypeUncAbsolute:
    case RtlPathTypeUnknown:
        return 0;
    }

    UnicodeString = *DosFileName;
    NumberOfCharacters = DosFileName->Length >> 1;

    if (NumberOfCharacters && DosFileName->Buffer[NumberOfCharacters-1] == L':') {
        UnicodeString.Length -= sizeof(WCHAR);
        NumberOfCharacters--;
        ColonBias = 1;
    }

    //
    // The above strip the trailing colon logic could have left us with 0
    // for NumberOfCharacters, so that needs to be tested
    //

    if ( NumberOfCharacters == 0 ) {
        return 0;
        }

    wch = UnicodeString.Buffer[NumberOfCharacters-1];
    while ( NumberOfCharacters && (wch == L'.' || wch == L' ') ) {
        UnicodeString.Length -= sizeof(WCHAR);
        NumberOfCharacters--;
        ColonBias++;
        wch = UnicodeString.Buffer[NumberOfCharacters-1];
    }

    ReturnLength = NumberOfCharacters << 1;

    //
    //  Walk backwards through the string finding the
    //  first slash or the beginning of the string.  We also stop
    //  at the drive: if it is present.
    //

    ReturnOffset = 0;
    if ( NumberOfCharacters ) {
        p = UnicodeString.Buffer + NumberOfCharacters-1;
        while ( p >= UnicodeString.Buffer ) {
            if ( *p == L'\\' || *p == L'/'
                 || (*p == L':' && p == UnicodeString.Buffer + 1)) {
                p++;

                //
                //  Get the first char of the file name and convert it to
                //  lower case.  This will be safe since we will be comparing
                //  it to only lower-case ASCII.
                //

                wch = (*p) | 0x20;

                //
                //  check to see if we possibly have a hit on
                //  lpt, prn, con, com, aux, or nul
                //

                if ( !(wch == L'l' || wch == L'c' || wch == L'p' || wch == L'a'
                       || wch == L'n')
                     ) {
                    return 0;
                    }
                ReturnOffset = (ULONG)((PSZ)p - (PSZ)UnicodeString.Buffer);
                RtlInitUnicodeString(&UnicodeString,p);
                NumberOfCharacters = UnicodeString.Length >> 1;
                NumberOfCharacters -= ColonBias;
                ReturnLength = NumberOfCharacters << 1;
                UnicodeString.Length -= ColonBias*sizeof(WCHAR);
                break;
                }
            p--;
            }

        wch = UnicodeString.Buffer[0] | 0x20;

        //
        // check to see if we possibly have a hit on
        // lpt, prn, con, com, aux, or nul
        //

        if ( !( wch == L'l' || wch == L'c' || wch == L'p' || wch == L'a'
                || wch == L'n' ) ) {
            return 0;
            }
        }

    //
    //  Now we need to see if we are dealing with a device name that has
    //  an extension or a stream name. If so, we need to limit the search to the
    //  file portion only
    //

    p = UnicodeString.Buffer;
    while (p < UnicodeString.Buffer + NumberOfCharacters && *p != L'.' && *p != L':') {
        p++;
    }

    //
    //  p either points past end of string or to a dot or :.  We back up over
    //  trailing spaces
    //

    while (p > UnicodeString.Buffer && p[-1] == L' ') {
        p--;
    }

    //
    //  p either points to the beginning of the string or p[-1] is
    //  the first non-space char found above.
    //

    NumberOfCharacters = (USHORT)(p - UnicodeString.Buffer);
    UnicodeString.Length = NumberOfCharacters * sizeof( WCHAR );

    if ( NumberOfCharacters == 4 && iswdigit(UnicodeString.Buffer[3] ) ) {
        if ( (WCHAR)UnicodeString.Buffer[3] == L'0') {
            return 0;
        } else {
            UnicodeString.Length -= sizeof(WCHAR);
            if ( RtlEqualUnicodeString(&UnicodeString,&RtlpDosLPTDevice,TRUE) ||
                 RtlEqualUnicodeString(&UnicodeString,&RtlpDosCOMDevice,TRUE) ) {
                ReturnLength = NumberOfCharacters << 1;
            } else {
                return 0;
            }
        }
    } else if ( NumberOfCharacters != 3 ) {
        return 0;
    } else if ( RtlEqualUnicodeString(&UnicodeString,&RtlpDosPRNDevice,TRUE) ) {
            ReturnLength = NumberOfCharacters << 1;
    } else if ( RtlEqualUnicodeString(&UnicodeString,&RtlpDosAUXDevice,TRUE) ) {
        ReturnLength = NumberOfCharacters << 1;
    } else if ( RtlEqualUnicodeString(&UnicodeString,&RtlpDosNULDevice,TRUE) ) {
        ReturnLength = NumberOfCharacters << 1;
    } else if ( RtlEqualUnicodeString(&UnicodeString,&RtlpDosCONDevice,TRUE) ) {
        ReturnLength = NumberOfCharacters << 1;
    } else {
        return 0;
    }

    return ReturnLength | (ReturnOffset << 16);
}

ULONG
RtlIsDosDeviceName_U(
    IN PWSTR DosFileName
    )
{
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString(&UnicodeString,DosFileName);

    return RtlIsDosDeviceName_Ustr(&UnicodeString);
}

NTSTATUS
RtlpCheckDeviceName(
    PUNICODE_STRING DevName,
    ULONG DeviceNameOffset,
    BOOLEAN* NameInvalid
    )
{
    PWSTR DevPath;
    NTSTATUS Status = STATUS_SUCCESS;

    DevPath = RtlAllocateHeap(RtlProcessHeap(), 0,DevName->Length);
    if (!DevPath) {
        *NameInvalid = FALSE;
        Status = STATUS_NO_MEMORY;
        goto Exit;
        }

    *NameInvalid = TRUE;
    try {

        RtlCopyMemory(DevPath,DevName->Buffer,DevName->Length);
        DevPath[DeviceNameOffset>>1]=L'.';
        DevPath[(DeviceNameOffset>>1)+1]=UNICODE_NULL;

        if (RtlDoesFileExists_U(DevPath) ) {
            *NameInvalid = FALSE;
            }
        else {
            *NameInvalid = TRUE;
            }

        }
    finally {
        RtlFreeHeap(RtlProcessHeap(), 0, DevPath);
        }

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}


//
//  We keep an open handle to the current directory on the current drive in order
//  to make relative opens faster.  
//
//  However, this current directory can become invalid under two circumstances:
//
//  1. The current drive is removable media.  The user may arbitrarily switch
//      media without our knowledge.  At this point, whatever information the
//      filesystem has about the media is now out of date.
//  2. The volume is dismounted by explicit system/user action.
//
//  We can ping (via FSCTL_IS_VOLUME_MOUNTED) the volume each time we want to
//  test to see if the current directory is still valid.  While a "cheap" call
//  we will end up doing it a lot.  We can reduce this frequency by only checking
//  when the media is known to be removable or when a dismount is known to have
//  occurred.  The Io system exports in USER_SHARED_DATA a count of dismounts
//  since boot.  We capture this and use it to decide if a dismount was performed.
//

ULONG RtlpSavedDismountCount = -1;

VOID
RtlpValidateCurrentDirectory(
    PCURDIR CurDir
    )

/*++

Routine Description:

    This function is used to validate the current directory for the process.
    The current directory can change in several ways, first, by replacing
    the media with one that has a different directory structure.  Second
    by performing a force-dismount.

Arguments:

    CurDir - Current directory structure for process

Return Value:

    None.

--*/

{
    NTSTATUS FsCtlStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    WCHAR TrimmedPath[4];
    UNICODE_STRING str;

    if (((ULONG_PTR)CurDir->Handle & 1) == 0
        && USER_SHARED_DATA->DismountCount == RtlpSavedDismountCount) {
        
        return;

    }
    //
    // Never been set yet.
    //
    if (CurDir->Handle == NULL) {
        return;
    }
    
    //
    // Call Nt to see if the volume that
    // contains the directory is still mounted.
    // If it is, then continue. Otherwise, trim
    // current directory to the root.
    //

    //
    //  We're updated as far as possible with the current dismount count
    //

    RtlpSavedDismountCount = USER_SHARED_DATA->DismountCount;
    
    FsCtlStatus = NtFsControlFile(
                                 CurDir->Handle,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &IoStatusBlock,
                                 FSCTL_IS_VOLUME_MOUNTED,
                                 NULL,
                                 0,
                                 NULL,
                                 0
                                 );

    if ( FsCtlStatus == STATUS_WRONG_VOLUME || FsCtlStatus == STATUS_VOLUME_DISMOUNTED) {

        //
        // Try to get back to where we were, failing that reset current directory
        // to the root of the current drive
        //

        NtClose( CurDir->Handle );
        CurDir->Handle = NULL;

        FsCtlStatus = RtlSetCurrentDirectory_U(&CurDir->DosPath);
        if ( !NT_SUCCESS(FsCtlStatus) ) {

            TrimmedPath[0] = CurDir->DosPath.Buffer[0];
            TrimmedPath[1] = CurDir->DosPath.Buffer[1];
            TrimmedPath[2] = CurDir->DosPath.Buffer[2];
            TrimmedPath[3] = UNICODE_NULL;
            RtlpResetDriveEnvironment( TrimmedPath[0] );
            RtlInitUnicodeString( &str, TrimmedPath );

            //
            //  This can still fail if the volume was hard dismounted. We tried.
            //  Ah well.
            //

            (VOID) RtlSetCurrentDirectory_U( &str );
        }

    }
}

ULONG
RtlGetFullPathName_Ustr(
    PUNICODE_STRING FileName,
    ULONG nBufferLength,
    PWSTR lpBuffer,
    PWSTR *lpFilePart OPTIONAL,
    PBOOLEAN NameInvalid,
    RTL_PATH_TYPE *InputPathType
    )

/*++

Routine Description:

    This function is used to return a fully qualified pathname
    corresponding to the specified unicode filename.  It does this by
    merging the current drive and directory together with the specified
    file name.  In addition to this, it calculates the address of the
    file name portion of the fully qualified pathname.

Arguments:

    lpFileName - Supplies the unicode file name of the file whose fully
        qualified pathname is to be returned.

    nBufferLength - Supplies the length in bytes of the buffer that is
        to receive the fully qualified path.

    lpBuffer - Returns the fully qualified pathname corresponding to the
        specified file.

    lpFilePart - Optional parameter that if specified, returns the
        address of the last component of the fully qualified pathname.

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating unicode null character.  If the return
    value is greater than nBufferLength, the return value is the size of
    the buffer required to hold the pathname.  The return value is zero
    if the function failed.

--*/

{
    ULONG DeviceNameLength;
    ULONG DeviceNameOffset;
    ULONG PrefixSourceLength;
    LONG PathNameLength;
    UCHAR CurDrive, NewDrive;
    WCHAR EnvVarNameBuffer[4];
    UNICODE_STRING EnvVarName;
    PWSTR Source,Dest;
    UNICODE_STRING Prefix;
    PCURDIR CurDir;
    ULONG MaximumLength;
    UNICODE_STRING FullPath;
    ULONG BackupIndex;
    RTL_PATH_TYPE PathType;
    NTSTATUS Status;
    BOOLEAN StripTrailingSlash;
    UNICODE_STRING UnicodeString;
    ULONG NumberOfCharacters;
    PWSTR lpFileName;
    WCHAR wch;
    PWCHAR pwch;
    ULONG i,j;

    if ( ARGUMENT_PRESENT(NameInvalid) ) {
        *NameInvalid = FALSE;
        }

    if ( nBufferLength > MAXUSHORT ) {
        nBufferLength = MAXUSHORT-2;
        }

    *InputPathType = RtlPathTypeUnknown;

    UnicodeString = *FileName;
    lpFileName = UnicodeString.Buffer;

    NumberOfCharacters = UnicodeString.Length >> 1;
    PathNameLength = UnicodeString.Length;

    if ( PathNameLength == 0 || UnicodeString.Buffer[0] == UNICODE_NULL ) {
        return 0;
        }
    else {

        //
        // trim trailing spaces to check for a null name
        //
        DeviceNameLength = PathNameLength;
        wch = UnicodeString.Buffer[(DeviceNameLength>>1) - 1];
        while ( DeviceNameLength && wch == L' ' ) {
            DeviceNameLength -= sizeof(WCHAR);
            if ( DeviceNameLength ) {
                wch = UnicodeString.Buffer[(DeviceNameLength>>1) - 1];
                }
            }
        if ( !DeviceNameLength ) {
            return 0;
            }
        }

    if ( lpFileName[NumberOfCharacters-1] == L'\\' || lpFileName[NumberOfCharacters-1] == L'/' ) {
        StripTrailingSlash = FALSE;
        }
    else {
        StripTrailingSlash = TRUE;
        }

    //
    // If pass Dos file name is a Dos device name, then turn it into
    // \\.\devicename and return its length.
    //

    DeviceNameLength = RtlIsDosDeviceName_Ustr(&UnicodeString);
    if ( DeviceNameLength ) {

        if ( ARGUMENT_PRESENT( lpFilePart ) ) {
            *lpFilePart = NULL;
            }

        DeviceNameOffset = DeviceNameLength >> 16;
        DeviceNameLength &= 0x0000ffff;

        if ( ARGUMENT_PRESENT(NameInvalid) && DeviceNameOffset ) {
            NTSTATUS Status;
            Status = RtlpCheckDeviceName(&UnicodeString, DeviceNameOffset, NameInvalid);
            if (*NameInvalid) {
                return 0;
                }
            }

        PathNameLength = DeviceNameLength + RtlpSlashSlashDot.Length;
        if ( PathNameLength < (LONG)nBufferLength ) {
            RtlMoveMemory(
                lpBuffer,
                RtlpSlashSlashDot.Buffer,
                RtlpSlashSlashDot.Length
                );
            RtlMoveMemory(
                (PVOID)((PUCHAR)lpBuffer+RtlpSlashSlashDot.Length),
                (PSZ)lpFileName+DeviceNameOffset,
                DeviceNameLength
                );

            RtlZeroMemory(
                (PVOID)((PUCHAR)lpBuffer+RtlpSlashSlashDot.Length+DeviceNameLength),
                sizeof(UNICODE_NULL)
                );

            return PathNameLength;
            }
        else {
            return PathNameLength+sizeof(UNICODE_NULL);
            }
        }

    //
    // Setup output string that points to callers buffer.
    //

    FullPath.MaximumLength = (USHORT)nBufferLength;
    FullPath.Length = 0;
    FullPath.Buffer = lpBuffer;
    RtlZeroMemory(lpBuffer,nBufferLength);
    //
    // Get a pointer to the current directory structure.
    //

    CurDir = &(NtCurrentPeb()->ProcessParameters->CurrentDirectory);


    //
    // Determine the type of Dos Path Name specified.
    //

    *InputPathType = PathType = RtlDetermineDosPathNameType_U(lpFileName);

    //
    // Determine the prefix and backup index.
    //
    //  Input        Prefix                     Backup Index
    //
    //  \\        -> \\,                            end of \\server\share
    //  \\.\      -> \\.\,                          4
    //  \\.       -> \\.                            3 (\\.)
    //  \         -> Drive: from CurDir.DosPath     3 (Drive:\)
    //  d:        -> Drive:\curdir from environment 3 (Drive:\)
    //  d:\       -> no prefix                      3 (Drive:\)
    //  any       -> CurDir.DosPath                 3 (Drive:\)
    //

    RtlAcquirePebLock();
    try {

        //
        // No prefixes yet.
        //

        Source = lpFileName;
        PrefixSourceLength = 0;
        Prefix.Length = 0;
        Prefix.MaximumLength = 0;
        Prefix.Buffer = NULL;

        switch (PathType) {
            case RtlPathTypeUncAbsolute :
                {
                    PWSTR UncPathPointer;
                    ULONG NumberOfPathSeparators;

                    //
                    // We want to scan the supplied path to determine where
                    // the "share" ends, and set BackupIndex to that point.
                    //

                    UncPathPointer = lpFileName + 2;
                    NumberOfPathSeparators = 0;
                    while (*UncPathPointer) {
                        if (IS_PATH_SEPARATOR_U(*UncPathPointer)) {

                            NumberOfPathSeparators++;

                            if (NumberOfPathSeparators == 2) {
                                break;
                                }
                            }

                        UncPathPointer++;

                        }

                    BackupIndex = (ULONG)(UncPathPointer - lpFileName);

                    //
                    // Unc name. prefix = \\server\share
                    //

                    PrefixSourceLength = BackupIndex << 1;

                    Source += BackupIndex;

                    //
                    //  There is no prefix to place into the buffer.
                    //  The entire path is in Source
                    //

                    }
                break;

            case RtlPathTypeLocalDevice :

                //
                // Local device name. prefix = "\\.\"
                //

                PrefixSourceLength = RtlpSlashSlashDot.Length;
                BackupIndex = 4;
                Source += BackupIndex;

                //
                //  There is no prefix to place into the buffer.
                //  The entire path is in Source
                //

                break;

            case RtlPathTypeRootLocalDevice :

                //
                // Local Device root. prefix = "\\.\"
                //

                Prefix = RtlpSlashSlashDot;
                Prefix.Length = (USHORT)(Prefix.Length - (USHORT)(2*sizeof(UNICODE_NULL)));
                PrefixSourceLength = Prefix.Length + sizeof(UNICODE_NULL);
                BackupIndex = 3;
                Source += BackupIndex;
                PathNameLength -= BackupIndex * sizeof( WCHAR );
                break;

            case RtlPathTypeDriveAbsolute :

                CurDrive = (UCHAR)RtlUpcaseUnicodeChar( CurDir->DosPath.Buffer[0] );
                NewDrive = (UCHAR)RtlUpcaseUnicodeChar( lpFileName[0] );
                if ( CurDrive == NewDrive ) {

                    RtlpValidateCurrentDirectory( CurDir );
                    
                }

                //
                // Dos drive absolute name
                //

                BackupIndex = 3;
                break;

            case RtlPathTypeDriveRelative :

                //
                // Dos drive relative name
                //

                CurDrive = (UCHAR)RtlUpcaseUnicodeChar( CurDir->DosPath.Buffer[0] );
                NewDrive = (UCHAR)RtlUpcaseUnicodeChar( lpFileName[0] );
                if ( CurDrive == NewDrive ) {

                    RtlpValidateCurrentDirectory( CurDir );

                    Prefix = *(PUNICODE_STRING)&CurDir->DosPath;

                }

                else {
                    RtlpCheckRelativeDrive((WCHAR)NewDrive);

                    EnvVarNameBuffer[0] = L'=';
                    EnvVarNameBuffer[1] = (WCHAR)NewDrive;
                    EnvVarNameBuffer[2] = L':';
                    EnvVarNameBuffer[3] = UNICODE_NULL;
                    RtlInitUnicodeString(&EnvVarName,EnvVarNameBuffer);

                    Prefix = FullPath;
                    Status = RtlQueryEnvironmentVariable_U( NULL,
                                                            &EnvVarName,
                                                            &Prefix
                                                          );
                    if ( !NT_SUCCESS( Status ) ) {
                        if (Status == STATUS_BUFFER_TOO_SMALL) {
                            return (ULONG)(Prefix.Length) + PathNameLength + 2;
                            }
                        else {
                            //
                            // Otherwise default to root directory of drive
                            //

                            Status = STATUS_SUCCESS;
                            EnvVarNameBuffer[0] = (WCHAR)NewDrive;
                            EnvVarNameBuffer[1] = L':';
                            EnvVarNameBuffer[2] = L'\\';
                            EnvVarNameBuffer[3] = UNICODE_NULL;
                            RtlInitUnicodeString(&Prefix,EnvVarNameBuffer);
                            }
                        }
                    else {
                            {
                            ULONG LastChar;

                            //
                            // Determine
                            // if a backslash needs to be added
                            //

                            LastChar = Prefix.Length >> 1;

                            if (LastChar > 3) {
                                Prefix.Buffer[ LastChar ] = L'\\';
                                Prefix.Length += sizeof(UNICODE_NULL);
                                }
                            }
                        }
                    }

                BackupIndex = 3;
                Source += 2;
                PathNameLength -= 2 * sizeof( WCHAR );
                break;

            case RtlPathTypeRooted :
                BackupIndex = RtlpComputeBackupIndex(CurDir);
                if ( BackupIndex != 3 ) {
                    Prefix = CurDir->DosPath;
                    Prefix.Length = (USHORT)(BackupIndex << 1);
                    }
                else {

                    //
                    // Rooted name. Prefix is drive portion of current directory
                    //

                    Prefix = CurDir->DosPath;
                    Prefix.Length = 2*sizeof(UNICODE_NULL);
                    }
                break;

            case RtlPathTypeRelative :

                RtlpValidateCurrentDirectory( CurDir );

                //
                // Current drive:directory relative name
                //

                Prefix = CurDir->DosPath;
                BackupIndex = RtlpComputeBackupIndex(CurDir);
                break;

            default:
                return 0;
            }

        //
        // Maximum length required is the length of the prefix plus
        // the length of the specified pathname. If the callers buffer
        // is not at least this large, then return an error.
        //

        MaximumLength = PathNameLength + Prefix.Length;

        if ( MaximumLength >= nBufferLength ) {
            if ( (NumberOfCharacters > 1) ||
                 (*lpFileName != L'.') ) {
                return MaximumLength+sizeof(UNICODE_NULL);
                }
            else {

                //
                // If we are expanding curdir, then remember the trailing '\'
                //

                if ( NumberOfCharacters == 1 && *lpFileName == L'.' ) {

                    //
                    // We are expanding .
                    //

                    if ( Prefix.Length == 6 ) {
                        if ( nBufferLength <= Prefix.Length ) {
                            return (ULONG)(Prefix.Length+(USHORT)sizeof(UNICODE_NULL));
                            }
                        }
                    else {
                        if ( nBufferLength < Prefix.Length ) {
                            return (ULONG)Prefix.Length;
                            }
                        else {
                            for(i=0,j=0;i<Prefix.Length;i+=sizeof(WCHAR),j++){
                                if ( Prefix.Buffer[j] == L'\\' ||
                                     Prefix.Buffer[j] == L'/' ) {

                                    FullPath.Buffer[j] = L'\\';
                                    }
                                else {
                                    FullPath.Buffer[j] = Prefix.Buffer[j];
                                    }
                                }
                                FullPath.Length = Prefix.Length-(USHORT)sizeof(L'\\');
                            goto skipit;
                            }
                        }
                    }
                else {
                    return MaximumLength;
                    }
                }
            }

        if (PrefixSourceLength || Prefix.Buffer != FullPath.Buffer) {
            //
            // Copy the prefix from the source string.
            //

            //RtlMoveMemory(FullPath.Buffer,lpFileName,PrefixSourceLength);

            for(i=0,j=0;i<PrefixSourceLength;i+=sizeof(WCHAR),j++){
                if ( lpFileName[j] == L'\\' ||
                     lpFileName[j] == L'/' ) {

                    FullPath.Buffer[j] = L'\\';
                    }
                else {
                    FullPath.Buffer[j] = lpFileName[j];
                    }
                }

            FullPath.Length = (USHORT)PrefixSourceLength;

            //
            // Append any additional prefix
            //

            for(i=0,j=0;i<Prefix.Length;i+=sizeof(WCHAR),j++){
                if ( Prefix.Buffer[j] == L'\\' ||
                     Prefix.Buffer[j] == L'/' ) {

                    FullPath.Buffer[j+(FullPath.Length>>1)] = L'\\';
                    }
                else {
                    FullPath.Buffer[j+(FullPath.Length>>1)] = Prefix.Buffer[j];
                    }
                }
            FullPath.Length += Prefix.Length;

            }
        else {
            FullPath.Length = Prefix.Length;
            }
skipit:
        Dest =  (PWSTR)((PUCHAR)FullPath.Buffer + FullPath.Length);
        *Dest = UNICODE_NULL;

        while ( *Source ) {
            switch ( *Source ) {

            case L'\\' :
            case L'/' :

                //
                // collapse multiple "\" characters. If the previous character was
                // a path character, skip it.
                //

                if  ( *(Dest-1) != L'\\' ) {
                    *Dest++ = L'\\';
                    }

                Source++;
                break;

            case '.' :

                //
                // Ignoring dot in a leading //./ has already been taken
                // care of by advancing Source above.
                //
                // Eat single dots as in /./ by simply skipping them
                //
                // Double dots back up one level as in /../
                //
                // Any other . is just a filename character
                //
                
                if ( IS_DOT_U(Source) ) {
                    Source++;
                    if (IS_PATH_SEPARATOR_U(*Source)) {
                        Source++;
                        }
                    break;
                    }
                else if ( IS_DOT_DOT_U(Source) ) {
                    //
                    // backup destination string looking for a '\'
                    //

                    while (*Dest != L'\\') {
                        *Dest = UNICODE_NULL;
                        Dest--;
                        }

                    //
                    // backup to previous component..
                    // \a\b\c\.. to \a\b
                    //

                    do {

                        //
                        // If we bump into root prefix, then
                        // stay at root
                        //

                        if ( Dest ==  FullPath.Buffer + (BackupIndex-1) ) {
                            break;
                            }

                        *Dest = UNICODE_NULL;
                        Dest--;

                        } while (*Dest != L'\\');
                    if ( Dest ==  FullPath.Buffer + (BackupIndex-1) ) {
                        Dest++;
                        }

                    //
                    // Advance source past ..
                    //

                    Source += 2;

                    break;
                    }

                //
                // Not a single dot or double-dot.  The dot we found begins
                // a file name so we treat this as a normal file name
                //
                // FALLTHRU
                //

            default:

                //
                // Copy the filename. Note that
                // null and /,\ will stop the copy. If any
                // charcter other than null or /,\ is encountered,
                // then the pathname is invalid.
                //

                //
                //  Copy up until NULL or path separator
                //

                while ( !IS_END_OF_COMPONENT_U(*Source) ) {
                    *Dest++ = *Source++;
                }

                
                //
                //  Once copied, we should do some processing for compatibility with Win9x.
                //  Win9x strips all trailing spaces and dots from the name.
                //  Nt4/Win2K strips only the last dot if its followed by a path separator.
                //
                //  Ideally, we'd do something reasonable like stripping all trailing spaces
                //  and dots (like Win9X).  However, IIS has a security model that's based
                //  on NAMES and not on objects.  This means that IIS needs to process names
                //  in the same way that we do.  They should use GetFullPathName and be done
                //  with it.  In any event, DON'T CHANGE THE CANONICALIZATION OF THE NAME
                //  HERE WITHOUTH FIRST GOING THROUGH IIS.
                //
                //  We do EXACTLY what Nt4 did: if there's a trailing dot AND we're at a path
                //  seperator, remove the trailing dot.
                //
                
                if (IS_PATH_SEPARATOR_U( *Source ) && Dest[-1] == L'.') {
                    Dest--;
                }

            }
        }

        *Dest = UNICODE_NULL;

        if ( StripTrailingSlash ) {
            if ( Dest > (FullPath.Buffer + BackupIndex ) && *(Dest-1) == L'\\' ) {
                Dest--;
                *Dest = UNICODE_NULL;
                }
            }
        FullPath.Length = (USHORT)(PtrToUlong(Dest) - PtrToUlong(FullPath.Buffer));

        //
        //  Strip trailing spaces and dots.
        //

        while (Dest > FullPath.Buffer && (Dest[-1] == L' ' || Dest[-1] == L'.')) {
            *--Dest = UNICODE_NULL;
            FullPath.Length -= sizeof( WCHAR );
        }

        if ( ARGUMENT_PRESENT( lpFilePart ) ) {

            //
            // Locate the file part...
            //

            Source = Dest-1;
            Dest = NULL;

            while(Source > FullPath.Buffer ) {
                if ( *Source == L'\\' ) {
                    Dest = Source + 1;
                    break;
                    }
                Source--;
                }

            if ( Dest && *Dest ) {

                //
                // If this is a UNC name, make sure filepart is past the backup index
                //
                if ( PathType == RtlPathTypeUncAbsolute ) {
                    if ( Dest < (FullPath.Buffer + BackupIndex ) ) {
                        *lpFilePart = NULL;
                        leave;
                        }
                    }
                *lpFilePart = Dest;
                }
            else {
                *lpFilePart = NULL;
                }
            }
        }
    finally {
        RtlReleasePebLock();
        }

    return (ULONG)FullPath.Length;
}

NTSTATUS
RtlGetFullPathName_UstrEx(
    PUNICODE_STRING FileName,
    PUNICODE_STRING StaticString,
    PUNICODE_STRING DynamicString,
    PUNICODE_STRING *StringUsed,
    SIZE_T *FilePartPrefixCch OPTIONAL,
    PBOOLEAN NameInvalid,
    RTL_PATH_TYPE *InputPathType,
    SIZE_T *BytesRequired OPTIONAL
    )

/*++

Routine Description:

    See a description of RtlGetFullPathName_Ustr() for a functional
    description.

    This function provides the same basic behavior as RtlGetFullPathName_Ustr(),
    but with easier support for dynamically allocated arbitrary path name
    buffers.

    One would think that this is the core implementation and the non-Ex()
    version would call the ...Ex() version, but that seems risky, and
    would only really help the performance of the case where a dynamic allocation
    is done.

--*/
{
    NTSTATUS Status;
    ULONG Length;
    PWSTR Buffer;
    ULONG BufferLength;
    PWSTR FilePart = NULL;
    UNICODE_STRING TempDynamicString;
    USHORT StaticBufferSize;

    if (StringUsed != NULL)
        *StringUsed = NULL;

    if (BytesRequired != NULL)
        *BytesRequired = 0;

    if (FilePartPrefixCch != NULL)
        *FilePartPrefixCch = 0;

    TempDynamicString.Buffer = NULL;

    if ((StaticString != NULL) && (DynamicString != NULL) && (StringUsed == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    StaticBufferSize = 0;

    if (StaticString != NULL) {
        StaticBufferSize = StaticString->MaximumLength;
    }

    // First try getting into the static string.
    Length = RtlGetFullPathName_Ustr(
        FileName,
        StaticBufferSize,
        StaticString->Buffer,
        &FilePart,
        NameInvalid,
        InputPathType);
    if (Length == 0) {
#if DBG
        DbgPrint("%s(%d) - RtlGetFullPathName_Ustr() returned 0\n", __FUNCTION__, __LINE__);
#endif // DBG
        Status = STATUS_OBJECT_NAME_INVALID;
        goto Exit;
    }

    if ((StaticString != NULL) && (Length < StaticBufferSize)) {
        // woohoo it worked.
        StaticString->Length = (USHORT) Length;

        if (FilePartPrefixCch != NULL) {
            *FilePartPrefixCch = (FilePart != NULL) ? (FilePart - StaticString->Buffer) : 0;
        }

        if (StringUsed != NULL)
            *StringUsed = StaticString;

        Status = STATUS_SUCCESS;
    } else if (DynamicString == NULL) {
        // The static buffer wasn't big enough and the caller doesn't want us to do
        // a dynamic allocation; the best we can hope for is to give them back a
        // reasonable size.

        if (BytesRequired != NULL) {
            *BytesRequired = Length;
        }

        Status = STATUS_BUFFER_TOO_SMALL;
        goto Exit;
    } else {
        // Not big enough... allocate some memory into the dynamic buffer.
        // But wait; we need to lock the Peb lock so that someone doesn't
        // change the process's current directory out from under us!

        RtlAcquirePebLock();
        __try {
            // Do it again with the peb lock taken so that we can get an accurate stable
            // length.
            Length = RtlGetFullPathName_Ustr(
                            FileName,
                            StaticBufferSize,
                            StaticString->Buffer,
                            &FilePart,
                            NameInvalid,
                            InputPathType);
            if (Length == 0) {
#if DBG
                DbgPrint("%s line %d: RtlGetFullPathName_Ustr() returned 0\n", __FUNCTION__, __LINE__);
#endif // DBG
                Status = STATUS_OBJECT_NAME_INVALID;
                goto Exit;
            }

            if ((StaticString != NULL) && (Length < StaticString->MaximumLength)) {
                // woohoo it worked; some voodoo is going on where the current directory
                // or something just changed prior to us acquiring the Peb lock.
                StaticString->Length = (USHORT) Length;

                if (FilePartPrefixCch != NULL) {
                    *FilePartPrefixCch = (FilePart != NULL) ? (FilePart - StaticString->Buffer) : 0;
                }

                if (StringUsed != NULL)
                    *StringUsed = StaticString;
            } else {
                // If it doesn't fit into a UNICODE string, we're in big trouble.
                if ((Length + sizeof(WCHAR)) > UNICODE_STRING_MAX_BYTES) {
                    Status = STATUS_NAME_TOO_LONG;
                    goto Exit;
                }

                TempDynamicString.MaximumLength = (USHORT) (Length + sizeof(WCHAR));

                TempDynamicString.Buffer = (RtlAllocateStringRoutine)(TempDynamicString.MaximumLength);
                if (TempDynamicString.Buffer == NULL) {
                    Status = STATUS_NO_MEMORY;
                    goto Exit;
                }

                Length = RtlGetFullPathName_Ustr(
                            FileName,
                            TempDynamicString.MaximumLength - sizeof(WCHAR),
                            TempDynamicString.Buffer,
                            &FilePart,
                            NameInvalid,
                            InputPathType);
                if (Length == 0) {
#if DBG
                    DbgPrint("%s line %d: RtlGetFullPathName_Ustr() returned 0\n", __FUNCTION__, __LINE__);
#endif // DBG
                    Status = STATUS_OBJECT_NAME_INVALID;
                    goto Exit;
                }

                // If this assert fires, it means that someone changed something that
                // RtlGetFullPathName_Ustr() uses to resolve the filename, even while
                // we're holding the Peb lock.  This is really bad and whoever is
                // trashing the PEB is resposible, not this code.
                ASSERT(Length < (TempDynamicString.MaximumLength - sizeof(WCHAR)));
                if (Length > (TempDynamicString.MaximumLength - sizeof(WCHAR))) {
                    Status = STATUS_INTERNAL_ERROR;
                    goto Exit;
                }

                if (FilePartPrefixCch != NULL) {
                    *FilePartPrefixCch = (FilePart != NULL) ? (FilePart - TempDynamicString.Buffer) : 0;
                }

                TempDynamicString.Buffer[Length / sizeof(WCHAR)] = UNICODE_NULL;

                DynamicString->Buffer = TempDynamicString.Buffer;
                DynamicString->Length = (USHORT) Length;
                DynamicString->MaximumLength = TempDynamicString.MaximumLength;

                if (StringUsed != NULL)
                    *StringUsed = DynamicString;

                TempDynamicString.Buffer = NULL;
            }

            Status = STATUS_SUCCESS;

        } __finally {
            RtlReleasePebLock();
        }
    }
Exit:
    if (TempDynamicString.Buffer != NULL) {
        (RtlFreeStringRoutine)(TempDynamicString.Buffer);
    }

#if DBG
    // This happens a lot for STATUS_NO_SUCH_FILE and STATUS_BUFFER_TOO_SMALL; we'll report any others
    if (NT_ERROR(Status) && (Status != STATUS_NO_SUCH_FILE) && (Status != STATUS_BUFFER_TOO_SMALL)) {
        DbgPrint("RTL: %s - failing on filename %wZ with status %08lx\n", __FUNCTION__, FileName, Status);
    }
#endif // DBG

    return Status;
}


ULONG
RtlGetFullPathName_U(
    PCWSTR lpFileName,
    ULONG nBufferLength,
    PWSTR lpBuffer,
    PWSTR *lpFilePart OPTIONAL
    )

{
    UNICODE_STRING UnicodeString;
    RTL_PATH_TYPE PathType;

    RtlInitUnicodeString(&UnicodeString,lpFileName);

    return RtlGetFullPathName_Ustr(&UnicodeString,nBufferLength,lpBuffer,lpFilePart,NULL,&PathType);
}

NTSTATUS
RtlpWin32NTNameToNtPathName_U(
    IN PUNICODE_STRING DosFileName,
    OUT PUNICODE_STRING NtFileName,
    OUT PWSTR *FilePart OPTIONAL,
    OUT PRTL_RELATIVE_NAME RelativeName OPTIONAL
    )
{

    PWSTR FullNtPathName = NULL;
    PWSTR Source,Dest;
    NTSTATUS Status = STATUS_SUCCESS;

    FullNtPathName = RtlAllocateHeap(
                        RtlProcessHeap(),
                        0,
                        DosFileName->Length-8+sizeof(UNICODE_NULL)+RtlpDosDevicesPrefix.Length
                        );
    if ( !FullNtPathName ) {
        Status = STATUS_NO_MEMORY;
        goto Exit;
        }

    //
    // Copy the full Win32/NT path next to the name prefix, skipping over
    // the \\?\ at the front of the path.
    //

    RtlMoveMemory(FullNtPathName,RtlpDosDevicesPrefix.Buffer,RtlpDosDevicesPrefix.Length);
    RtlMoveMemory((PUCHAR)FullNtPathName+RtlpDosDevicesPrefix.Length,
                  DosFileName->Buffer + 4,
                  DosFileName->Length - 8);

    //
    // Null terminate the path name to make strlen below happy.
    //


    NtFileName->Buffer = FullNtPathName;
    NtFileName->Length = (USHORT)(DosFileName->Length-8+RtlpDosDevicesPrefix.Length);
    NtFileName->MaximumLength = NtFileName->Length + sizeof(UNICODE_NULL);
    FullNtPathName[ NtFileName->Length >> 1 ] = UNICODE_NULL;

    //
    // Now we have the passed in path with \DosDevices\ prepended. Blow out the
    // relative name structure (if provided), and possibly compute filepart
    //

    if ( ARGUMENT_PRESENT(RelativeName) ) {

        //
        // If the current directory is a sub-string of the
        // Nt file name, and if a handle exists for the current
        // directory, then return the directory handle and name
        // relative to the directory.
        //

        RelativeName->RelativeName.Length = 0;
        RelativeName->RelativeName.MaximumLength = 0;
        RelativeName->RelativeName.Buffer = 0;
        RelativeName->ContainingDirectory = NULL;
        }

    if ( ARGUMENT_PRESENT( FilePart ) ) {

        //
        // Locate the file part...
        //

        Source = &FullNtPathName[ (NtFileName->Length-1) >> 1 ];
        Dest = NULL;

        while(Source > FullNtPathName ) {
            if ( *Source == L'\\' ) {
                Dest = Source + 1;
                break;
                }
            Source--;
            }

        if ( Dest && *Dest ) {
            *FilePart = Dest;
            }
        else {
            *FilePart = NULL;
            }
        }

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

BOOLEAN
RtlDosPathNameToNtPathName_Ustr(
    IN PCUNICODE_STRING DosFileNameString,
    OUT PUNICODE_STRING NtFileName,
    OUT PWSTR *FilePart OPTIONAL,
    OUT PRTL_RELATIVE_NAME RelativeName OPTIONAL
    )
/*++

Routine Description:

    A Dos pathname can be translated into an Nt style pathname
    using this function.

    This function is used only within the Base dll to translate Dos
    pathnames to Nt pathnames. Upon successful translation, the
    pointer (NtFileName->Buffer) points to memory from RtlProcessHeap()
    that contains the Nt version of the input dos file name.

Arguments:

    DosFileName - Supplies the unicode Dos style file name that is to be
        translated into an equivalent unicode Nt file name.

    NtFileName - Returns the address of memory in the RtlProcessHeap() that
        contains an NT filename that refers to the specified Dos file
        name.

    FilePart - Optional parameter that if specified, returns the
        trailing file portion of the file name.  A path of \foo\bar\x.x
        returns the address of x.x as the file part.

    RelativeName - An optional parameter, that if specified, returns
        a pathname relative to the current directory of the file. The
        length field of RelativeName->RelativeName is 0 if the relative
        name can not be used.

Return Value:

    TRUE - The path name translation was successful.  Once the caller is
        done with the translated name, the memory pointed to by
        NtFileName.Buffer should be returned to the RtlProcessHeap().

    FALSE - The operation failed.

Note:
    The buffers pointed to by RelativeName, FilePart, and NtFileName must ALL
    point within the same memory address.  If they don't, code that calls
    this routine will fail.

--*/

{

    ULONG BufferLength;
    ULONG DosPathLength;
    PWSTR FullNtPathName = NULL;
    PWSTR FullDosPathName = NULL;
    UNICODE_STRING Prefix;
    UNICODE_STRING UnicodeFilePart;
    UNICODE_STRING FullDosPathString;
    PCURDIR CurDir;
    RTL_PATH_TYPE DosPathType;
    RTL_PATH_TYPE InputDosPathType;
    ULONG DosPathNameOffset;
    ULONG FullDosPathNameLength;
    ULONG LastCharacter;
    UNICODE_STRING UnicodeString;
    BOOLEAN NameInvalid;
    WCHAR StaticDosBuffer[DOS_MAX_PATH_LENGTH + 1];
    BOOLEAN UseWin32Name, fRC;

    //
    // Calculate the size needed for the full pathname. Add in
    // space for the longest Nt prefix
    //

    BufferLength = sizeof(StaticDosBuffer);
    DosPathLength = (DOS_MAX_PATH_LENGTH << 1 );

    UnicodeString = *DosFileNameString;

    //
    // see if this is \\?\ form of name
    //
    if ( UnicodeString.Length > 8 && UnicodeString.Buffer[0] == '\\' &&
         UnicodeString.Buffer[1] == '\\' && UnicodeString.Buffer[2] == '?' &&
         UnicodeString.Buffer[3] == '\\' ) {

        UseWin32Name = TRUE;
    }
    else {
        UseWin32Name = FALSE;

        //
        // The dos name starts just after the longest Nt prefix
        //

        FullDosPathName = &StaticDosBuffer[0];

        BufferLength += RtlpLongestPrefix;

        //
        // Allocate space for the full Nt Name (including DOS name portion)
        //

        FullNtPathName = RtlAllocateHeap(RtlProcessHeap(), 0, BufferLength);

        if ( !FullNtPathName ) {
            return FALSE;
            }
        }

    RtlAcquirePebLock();
    fRC = TRUE;
    __try {
        __try {

            if ( UseWin32Name ) {
                NTSTATUS Status;

                Status = RtlpWin32NTNameToNtPathName_U(&UnicodeString,NtFileName,FilePart,RelativeName);
                fRC = NT_SUCCESS(Status);
                __leave;
            }

            FullDosPathNameLength = RtlGetFullPathName_Ustr(
                                        &UnicodeString,
                                        DosPathLength,
                                        FullDosPathName,
                                        FilePart,
                                        &NameInvalid,
                                        &InputDosPathType
                                        );
            if ( NameInvalid || !FullDosPathNameLength ||
                  FullDosPathNameLength > DosPathLength ) {
                fRC = FALSE;
                __leave;
            }

            //
            // Determine how to format prefix of FullNtPathName base on the
            // the type of Dos path name.  All Nt names begin in the \DosDevices
            // directory.
            //

            Prefix = RtlpDosDevicesPrefix;

            DosPathType = RtlDetermineDosPathNameType_U(FullDosPathName);

            switch (DosPathType) {
                case RtlPathTypeUncAbsolute :

                    //
                    // Unc name, use \DosDevices\UNC symbolic link to find
                    // redirector.  Skip of \\ in source Dos path.
                    //

                    Prefix = RtlpDosDevicesUncPrefix;
                    DosPathNameOffset = 2;
                    break;

                case RtlPathTypeLocalDevice :

                    //
                    // Local device name, so just use \DosDevices prefix and
                    // skip \\.\ in source Dos path.
                    //

                    DosPathNameOffset = 4;
                    break;

                case RtlPathTypeRootLocalDevice :

                    ASSERT( FALSE );
                    break;

                case RtlPathTypeDriveAbsolute :
                case RtlPathTypeDriveRelative :
                case RtlPathTypeRooted :
                case RtlPathTypeRelative :

                    //
                    // All drive references just use \DosDevices prefix and
                    // do not skip any of the characters in the source Dos path.
                    //

                    DosPathNameOffset = 0;
                    break;

                default:
                    ASSERT( FALSE );
            }

            //
            // Copy the full DOS path next to the name prefix, skipping over
            // the "\\" at the front of the UNC path or the "\\.\" at the front
            // of a device name.
            //

            RtlMoveMemory(FullNtPathName,Prefix.Buffer,Prefix.Length);
            RtlMoveMemory((PUCHAR)FullNtPathName+Prefix.Length,
                          FullDosPathName + DosPathNameOffset,
                          FullDosPathNameLength - (DosPathNameOffset<<1));

            //
            // Null terminate the path name to make strlen below happy.
            //


            NtFileName->Buffer = FullNtPathName;
            NtFileName->Length = (USHORT)(FullDosPathNameLength-(DosPathNameOffset<<1))+Prefix.Length;
            NtFileName->MaximumLength = (USHORT)BufferLength;
            LastCharacter = NtFileName->Length >> 1;
            FullNtPathName[ LastCharacter ] = UNICODE_NULL;


            //
            // Readjust the file part to point to the appropriate position within
            // the FullNtPathName buffer instead of inside the FullDosPathName
            // buffer
            //


            if ( ARGUMENT_PRESENT(FilePart) ) {
                if (*FilePart) {
                     RtlInitUnicodeString(&UnicodeFilePart,*FilePart);
                    *FilePart = &FullNtPathName[ LastCharacter ] - (UnicodeFilePart.Length >> 1);
                }
            }

            if ( ARGUMENT_PRESENT(RelativeName) ) {

                //
                // If the current directory is a sub-string of the
                // Nt file name, and if a handle exists for the current
                // directory, then return the directory handle and name
                // relative to the directory.
                //

                RelativeName->RelativeName.Length = 0;
                RelativeName->RelativeName.MaximumLength = 0;
                RelativeName->RelativeName.Buffer = 0;
                RelativeName->ContainingDirectory = NULL;

                if ( InputDosPathType == RtlPathTypeRelative ) {

                    CurDir = &(NtCurrentPeb()->ProcessParameters->CurrentDirectory);

                    if ( CurDir->Handle ) {

                        //
                        // Now compare curdir to full dos path. If curdir length is
                        // greater than full path. It is not a match. Otherwise,
                        // trim full path length to cur dir length and compare.
                        //

                        RtlInitUnicodeString(&FullDosPathString,FullDosPathName);
                        if ( CurDir->DosPath.Length <= FullDosPathString.Length ) {
                            FullDosPathString.Length = CurDir->DosPath.Length;
                            if ( RtlEqualUnicodeString(
                                    (PUNICODE_STRING)&CurDir->DosPath,
                                    &FullDosPathString,
                                    TRUE
                                    ) ) {

                                //
                                // The full dos pathname is a substring of the
                                // current directory.  Compute the start of the
                                // relativename.
                                //

                                RelativeName->RelativeName.Buffer = ((PUCHAR)FullNtPathName + Prefix.Length - (DosPathNameOffset<<1) + (CurDir->DosPath.Length));
                                RelativeName->RelativeName.Length = (USHORT)FullDosPathNameLength - (CurDir->DosPath.Length);
                                if ( *(PWSTR)(RelativeName->RelativeName.Buffer) == L'\\' ) {
                                    (PWSTR)(RelativeName->RelativeName.Buffer)++;
                                    RelativeName->RelativeName.Length -= 2;
                                }
                                RelativeName->RelativeName.MaximumLength = RelativeName->RelativeName.Length;
                                RelativeName->ContainingDirectory = CurDir->Handle;
                            }
                        }
                    }
                }
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
              fRC = FALSE;
        }
    }
    finally {
        if (fRC == FALSE && FullNtPathName != NULL) {
            RtlFreeHeap(RtlProcessHeap(), 0, FullNtPathName);
        }
        RtlReleasePebLock();
    }
    return fRC;
}

BOOLEAN
RtlDosPathNameToNtPathName_U(
    IN PCWSTR DosFileName,
    OUT PUNICODE_STRING NtFileName,
    OUT PWSTR *FilePart OPTIONAL,
    OUT PRTL_RELATIVE_NAME RelativeName OPTIONAL
    )
{
    UNICODE_STRING DosFileNameString;
    ULONG Length = 0;

    
    if (DosFileName != NULL) {
        Length = wcslen( DosFileName ) * sizeof( WCHAR );
        if (Length + sizeof( UNICODE_NULL ) >= UNICODE_STRING_MAX_BYTES) {
            return FALSE;
        }
        DosFileNameString.MaximumLength = (USHORT)(Length + sizeof( UNICODE_NULL ));
    } else {
        DosFileNameString.MaximumLength = 0;
    }
    
    DosFileNameString.Buffer = (PWSTR) DosFileName;
    DosFileNameString.Length = (USHORT)Length;
    
    return RtlDosPathNameToNtPathName_Ustr( &DosFileNameString, NtFileName, FilePart, RelativeName );
}

NTSTATUS
RtlDoesFileExist3(
    OUT PHANDLE         FileHandle,
    IN PCUNICODE_STRING FileNameString,
    IN ACCESS_MASK      DesiredAccess,
    IN ULONG            ShareAccess,
    IN ULONG            OpenOptions
    )
/*++
RtlDoesFileExist is "RtlDoesFileExist1"
RtlDoesFileExistEx is "RtlDoesFileExist2"

Supposedly NtOpenFile on unc paths is not reliable (per comments in RtlDoesFileExists_UstrEx).
Supposedly NtQueryAttributesFile on unc paths is not reliable (per that RtlDoesFileExists_UstrEx has to
    decide how to treat STATUS_ACCESS_DENIED and STATUS_SHARING_VIOLATION and per comments
    from Mike Grier. STATUS_SHARING_VIOLATION does imply exists, but it's up to the caller
    to decide what they really want to know..)

NtOpenFile to NT4 unc and random downlevel 3rd party filesystems / redirectors is also not reliable,
it needs the workarounds that kernel32.dll CreateFile supplies. This is a general
bug throughout ntdll.dll.
--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING NtFileName;
    PVOID FreeBuffer = NULL;
    FILE_ALL_INFORMATION FileInfo; // it feels safest to get all
                                   // information, like GetFileInformationByHandle does
    BOOLEAN DosPathToNtPathReturnValue;
    RTL_RELATIVE_NAME RelativeName;
    IO_STATUS_BLOCK IoStatusBlock;

    

    if (FileHandle != NULL) {
        *FileHandle = NULL;
    }

    

    if (FileHandle == NULL) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Exit;
    }
    if (FileNameString == NULL) {
        Status = STATUS_INVALID_PARAMETER_2;
        goto Exit;
    }

    

    DosPathToNtPathReturnValue = RtlDosPathNameToNtPathName_Ustr(
                    FileNameString,
                    &NtFileName,
                    NULL,
                    &RelativeName
                    );

    

    if ( !DosPathToNtPathReturnValue ) {
        Status = STATUS_UNSUCCESSFUL; // Blackcomb..
        goto Exit;
        }

    FreeBuffer = NtFileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        NtFileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    

    InitializeObjectAttributes(
        &Obja,
        &NtFileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    //
    // do we worry about synchronize / pending?
    //
    Status = NtOpenFile(FileHandle, DesiredAccess | FILE_READ_ATTRIBUTES, &Obja, &IoStatusBlock, ShareAccess, OpenOptions);
    if (!NT_SUCCESS(Status))
        goto Exit;
    
    Status = NtQueryInformationFile(*FileHandle, &IoStatusBlock, &FileInfo, sizeof(FileInfo), FileAllInformation);
    
    if (!NT_SUCCESS(Status)) {
        NtClose(*FileHandle);
        *FileHandle = NULL;
        goto Exit;
    }
    

    Status = STATUS_SUCCESS;
Exit:
    RtlFreeHeap(RtlProcessHeap(),0,FreeBuffer);
    
    return Status;
}

BOOLEAN
RtlDoesFileExists_UstrEx(
    IN PCUNICODE_STRING FileNameString,
    IN BOOLEAN TreatDeniedOrSharingAsHit
    )
/*++

Routine Description:

    This function checks to see if the specified unicode filename exists.

Arguments:

    FileName - Supplies the file name of the file to find.

Return Value:

    TRUE - The file was found.

    FALSE - The file was not found.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING NtFileName;
    BOOLEAN ReturnValue;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;
    FILE_BASIC_INFORMATION BasicInfo;

    ReturnValue = RtlDosPathNameToNtPathName_Ustr(
                    FileNameString,
                    &NtFileName,
                    NULL,
                    &RelativeName
                    );

    if ( !ReturnValue ) {
        return FALSE;
        }

    FreeBuffer = NtFileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        NtFileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &NtFileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    //
    // Query the file's attributes.  Note that the file cannot simply be opened
    // to determine whether or not it exists, as the NT LanMan redirector lies
    // on NtOpenFile to a Lan Manager server because it does not actually open
    // the file until an operation is performed on it.
    //

    Status = NtQueryAttributesFile(
                &Obja,
                &BasicInfo
                );
    RtlFreeHeap(RtlProcessHeap(),0,FreeBuffer);

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_SHARING_VIOLATION ||
             Status == STATUS_ACCESS_DENIED ) {
            if ( TreatDeniedOrSharingAsHit ) {
                ReturnValue = TRUE;
                }
            else {
                ReturnValue = FALSE;
                }
            }
        else {
            ReturnValue = FALSE;
            }
        }
    else {
        ReturnValue = TRUE;
        }
    return ReturnValue;
}

BOOLEAN
RtlDoesFileExists_UEx(
    IN PCWSTR FileName,
    IN BOOLEAN TreatDeniedOrSharingAsHit
    )
{
    UNICODE_STRING FileNameString;
    RtlInitUnicodeString(&FileNameString, FileName);
    return RtlDoesFileExists_UstrEx(&FileNameString, TreatDeniedOrSharingAsHit);
}

BOOLEAN
RtlDoesFileExists_U(
    IN PCWSTR FileName
    )

/*++

Routine Description:

    This function checks to see if the specified unicode filename exists.

Arguments:

    FileName - Supplies the file name of the file to find.

Return Value:

    TRUE - The file was found.

    FALSE - The file was not found.

--*/

{
    return RtlDoesFileExists_UEx(FileName,TRUE);
}

BOOLEAN
RtlDoesFileExists_UStr(
    IN PCUNICODE_STRING FileName
    )
/*
RtlDoesFileExists_UStr same as RtlDoesFileExists_U but takes a PCUNICODE_STRING instead of a PCWSTR,
saving a call to wcslen
*/
{
    return RtlDoesFileExists_UstrEx(FileName,TRUE);
}

ULONG
RtlDosSearchPath_U(
    IN PCWSTR lpPath,
    IN PCWSTR lpFileName,
    IN PCWSTR lpExtension OPTIONAL,
    IN ULONG nBufferLength,
    OUT PWSTR lpBuffer,
    OUT PWSTR *lpFilePart
    )

/*++

Routine Description:

    This function is used to search for a file specifying a search path
    and a filename.  It returns with a fully qualified pathname of the
    found file.

    This function is used to locate a file using the specified path.  If
    the file is found, its fully qualified pathname is returned.  In
    addition to this, it calculates the address of the file name portion
    of the fully qualified pathname.

Arguments:

    lpPath - Supplies the search path to be used when locating the file.

    lpFileName - Supplies the file name of the file to search for.

    lpExtension - An optional parameter, that if specified, supplies an
        extension to be added to the filename when doing the search.
        The extension is only added if the specified filename does not
        end with an extension.

    nBufferLength - Supplies the length in bytes of the buffer that is
        to receive the fully qualified path.

    lpBuffer - Returns the fully qualified pathname corresponding to the
        file that was found.

    lpFilePart - Optional parameter that if specified, returns the
        address of the last component of the fully qualified pathname.

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating null character.  If the return value is
    greater than nBufferLength, the return value is the size of the buffer
    required to hold the pathname.  The return value is zero if the
    function failed.


--*/

{

    PWSTR ComputedFileName;
    ULONG ExtensionLength;
    ULONG PathLength;
    ULONG FileLength;
    UNICODE_STRING Scratch;
    PCWSTR p;

    //
    // if the file name is not a relative name, then
    // return an if the file does not exist.
    //
    // If a fully qualified pathname is used in the search, then
    // allow access_denied or sharing violations to terminate the
    // search. This was the nt 3.1-4.0 behavior, and was changed for the
    // loader to handle cases where when walking through a search, we didn't
    // terminate the search early because of an inaccessible UNC path component
    // be restoring the old behavior in this case, we give the correct (access_denied)
    // error codes on fully qualified module lookups, but keep going when bumping
    // through search path components
    //

    if ( RtlDetermineDosPathNameType_U(lpFileName) != RtlPathTypeRelative ) {
        if (RtlDoesFileExists_UEx(lpFileName,TRUE) ) {
            PathLength = RtlGetFullPathName_U(
                           lpFileName,
                           nBufferLength,
                           lpBuffer,
                           lpFilePart
                           );
            return PathLength;
            }
        else {
            return 0;
            }
        }

    //
    // Determine if the file name contains an extension
    //
    ExtensionLength = 1;
    p = lpFileName;
    while (*p) {
        if ( *p == L'.' ) {
            ExtensionLength = 0;
            break;
            }
        p++;
        }

    //
    // If no extension was found, then determine the extension length
    // that should be used to search for the file
    //

    if ( ExtensionLength ) {
        if ( ARGUMENT_PRESENT(lpExtension) ) {
            RtlInitUnicodeString(&Scratch,lpExtension);
            ExtensionLength = Scratch.Length;
            }
        else {
            ExtensionLength = 0;
            }
        }

    //
    // Compute the file name length and the path length;
    //

    RtlInitUnicodeString(&Scratch,lpPath);
    PathLength = Scratch.Length;
    RtlInitUnicodeString(&Scratch,lpFileName);
    FileLength = Scratch.Length;

    ComputedFileName = RtlAllocateHeap(
                            RtlProcessHeap(), 0,
                            PathLength + FileLength + ExtensionLength + 3*sizeof(UNICODE_NULL)
                            );

    if ( !ComputedFileName ) {
        KdPrint(("%s: Failing due to out of memory (RtlAllocateHeap failure)\n", __FUNCTION__));
        return 0;
        }

    //
    // find ; 's in path and copy path component to computed file name
    //
    do {
        PWSTR Cursor;

        Cursor = ComputedFileName;
        while (*lpPath) {
            if (*lpPath == L';') {
                lpPath++;
                break;
                }
            *Cursor++ = *lpPath++;
            }

        if (Cursor != ComputedFileName &&
            Cursor [ -1 ] != L'\\' ) {
            *Cursor++ = L'\\';
            }
        if (*lpPath == UNICODE_NULL) {
            lpPath = NULL;
            }
        RtlMoveMemory(Cursor,lpFileName,FileLength);
        if ( ExtensionLength ) {
            RtlMoveMemory((PUCHAR)Cursor+FileLength,lpExtension,ExtensionLength+sizeof(UNICODE_NULL));
            }
        else {
            *(PWSTR)((PUCHAR)Cursor+FileLength) = UNICODE_NULL;
            }

        if (RtlDoesFileExists_UEx(ComputedFileName,FALSE) ) {
            PathLength = RtlGetFullPathName_U(
                           ComputedFileName,
                           nBufferLength,
                           lpBuffer,
                           lpFilePart
                           );
            RtlFreeHeap(RtlProcessHeap(), 0, ComputedFileName);
            return PathLength;
            }
        }
    while ( lpPath );

    RtlFreeHeap(RtlProcessHeap(), 0, ComputedFileName);
    return 0;
}

NTSTATUS
RtlDosSearchPath_Ustr(
    IN ULONG Flags,
    IN PCUNICODE_STRING Path,
    IN PCUNICODE_STRING FileName,
    IN PCUNICODE_STRING DefaultExtension OPTIONAL,
    OUT PUNICODE_STRING StaticString OPTIONAL,
    OUT PUNICODE_STRING DynamicString OPTIONAL,
    OUT PCUNICODE_STRING *FullFileNameOut OPTIONAL,
    OUT SIZE_T *FilePartPrefixCch OPTIONAL,
    OUT SIZE_T *BytesRequired OPTIONAL // includes space for trailing NULL
    )

/*++

Routine Description:

    This function is used to search for a file specifying a search path
    and a filename.  It returns with a fully qualified pathname of the
    found file.

    This function is used to locate a file using the specified path.  If
    the file is found, its fully qualified pathname is returned.  In
    addition to this, it calculates the address of the file name portion
    of the fully qualified pathname.

Arguments:

    Flags - Optional flags to affect the behavior of the path search.
        Use the logical or operator (|) to combine flags.
        Defined flags include:

        RTL_DOS_SEARCH_PATH_FLAG_APPLY_ISOLATION_REDIRECTION
            If the FileName passed in is a relative path, isolation
            redirection of the file path is applied prior to searching
            for a matching path.

    Path - search path to use when locating the file

    FileName - file name to search for

    DefaultExtension - Optional extension to apply to the file name
        if the file name does not include an extension.

    StaticString - Optional UNICODE_STRING which references an already
        allocated buffer which is used to construct the actual path
        of the file.

    DynamicString - Optional UNICODE_STRING which will be filled in with
        a dynamically allocated UNICODE_STRING if either StaticBuffer is
        not provided, or is not long enough to hold the resolved name.

        The dynamic buffer's size is reflected in the MaximumLength field
        of the UNICODE_STRING.  It will always exceed the Length of the
        string by at least two bytes, but may be even larger.

    FullFileNameOut - Optional pointer to UNICODE_STRING which points to
        the complete resolved file name.  This UNICODE_STRING is not
        allocated; it is either set equal to FileName, StaticBuffer or
        DynamicBuffer as appropriate.

Return Value:

     NTSTATUS indicating the disposition of the function.  If the file
     is redirected via activation context data, STATUS_SUCCESS is returned
     regardless of whether the file exists or not.  If the file does not
     exist in any of the directories referenced by the Path parameter,
     STATUS_NO_SUCH_FILE is returned.

--*/

{
    NTSTATUS Status;
    PWSTR Cursor;
    PWSTR EndMarker;
    SIZE_T MaximumPathSegmentLength = 0;
    SIZE_T BiggestPossibleFileName;
    USHORT DefaultExtensionLength = 0;
    RTL_PATH_TYPE PathType; // not used; required argument to RtlGetFullPathName_Ustr().
    UNICODE_STRING CandidateString;
    WCHAR StaticCandidateBuffer[DOS_MAX_PATH_LENGTH];

    CandidateString.Length = 0;
    CandidateString.MaximumLength = sizeof(StaticCandidateBuffer);
    CandidateString.Buffer = StaticCandidateBuffer;

    if (FullFileNameOut != NULL) {
        *FullFileNameOut = NULL;
    }

    if (BytesRequired != NULL) {
        *BytesRequired = 0;
    }

    if (FilePartPrefixCch != NULL) {
        *FilePartPrefixCch = 0;
    }

    if (DynamicString != NULL) {
        DynamicString->Length = 0;
        DynamicString->MaximumLength = 0;
        DynamicString->Buffer = NULL;
    }

    if (((Flags & ~(
                RTL_DOS_SEARCH_PATH_FLAG_APPLY_ISOLATION_REDIRECTION |
                RTL_DOS_SEARCH_PATH_FLAG_DISALLOW_DOT_RELATIVE_PATH_SEARCH |
                RTL_DOS_SEARCH_PATH_FLAG_APPLY_DEFAULT_EXTENSION_WHEN_NOT_RELATIVE_PATH_EVEN_IF_FILE_HAS_EXTENSION)) != 0) ||
        (Path == NULL) ||
        (FileName == NULL) ||
        ((StaticString != NULL) && (DynamicString != NULL) && (FullFileNameOut == NULL))) {
#if DBG
        DbgPrint("%s: Invalid parameters passed\n", __FUNCTION__);
#endif // DBG
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    PathType = RtlDetermineDosPathNameType_Ustr(FileName);

    // If the caller wants to disallow .\ and ..\ relative path searches, stop them!
    if ((Flags & RTL_DOS_SEARCH_PATH_FLAG_DISALLOW_DOT_RELATIVE_PATH_SEARCH) && (PathType == RtlPathTypeRelative)) {
        if (FileName->Length >= (2 * sizeof(WCHAR))) {
            if (FileName->Buffer[0] == L'.') {
                if (IS_PATH_SEPARATOR_U(FileName->Buffer[1])) {
                    PathType = RtlPathTypeUnknown;
                } else if ((FileName->Buffer[1] == L'.') &&
                           (FileName->Length >= (3 * sizeof(WCHAR))) &&
                           IS_PATH_SEPARATOR_U(FileName->Buffer[2])) {
                    PathType = RtlPathTypeUnknown;
                }
            }
        }
    }

    //
    // if the file name is not a relative name, then
    // return an if the file does not exist.
    //
    // If a fully qualified pathname is used in the search, then
    // allow access_denied or sharing violations to terminate the
    // search. This was the nt 3.1-4.0 behavior, and was changed for the
    // loader to handle cases where when walking through a search, we didn't
    // terminate the search early because of an inaccessible UNC path component
    // be restoring the old behavior in this case, we give the correct (access_denied)
    // error codes on fully qualified module lookups, but keep going when bumping
    // through search path components
    //

    if (PathType != RtlPathTypeRelative ) {
        if (RtlDoesFileExists_UstrEx(FileName, TRUE)) {
            Status = RtlGetFullPathName_UstrEx(
                            RTL_CONST_CAST(PUNICODE_STRING)(FileName),
                            StaticString,
                            DynamicString,
                            (PUNICODE_STRING *) FullFileNameOut,
                            FilePartPrefixCch,
                            NULL,
                            &PathType,
                            BytesRequired);
            if (!NT_SUCCESS(Status)) {
#if DBG
                if ((Status != STATUS_NO_SUCH_FILE) && (Status != STATUS_BUFFER_TOO_SMALL)) {
                    DbgPrint("%s: Failing because RtlGetFullPathName_UstrEx() on %wZ failed with %08lx\n", __FUNCTION__, FileName, Status);
                }
#endif // DBG
                goto Exit;
            }
        } else {
            //
            // The file wasn't there; let's try adding the default extension if we need to.
            //

            if ((DefaultExtension == NULL) || (DefaultExtension->Length == 0)) {
#if DBG
//                DbgPrint("%s: Failing because RtlDoesFileExists_UstrEx() on %wZ says it does not exist and there is no default extension to apply\n", __FUNCTION__, FileName);
#endif // DBG
                Status = STATUS_NO_SUCH_FILE;
                goto Exit;
            }

            DefaultExtensionLength = DefaultExtension->Length;

            // If they've asked for SearchPathW() bug compatibility mode, always apply the default
            // extension if the file isn't found, even if the file name has an extension.
            if (!(Flags & RTL_DOS_SEARCH_PATH_FLAG_APPLY_DEFAULT_EXTENSION_WHEN_NOT_RELATIVE_PATH_EVEN_IF_FILE_HAS_EXTENSION)) {
                if (FileName->Length != 0) {
                    Cursor = FileName->Buffer + (FileName->Length / sizeof(WCHAR));

                    while (Cursor != FileName->Buffer) {
                        const WCHAR wch = *--Cursor;

                        if (IS_PATH_SEPARATOR_U(wch)) {
                            // it's a slash; we have a filename without an extension...
                            break;
                        }

                        if (wch == L'.') {
                            // There was an extension.  We're just out of luck.
                            Status = STATUS_NO_SUCH_FILE;
                            goto Exit;
                        }
                    }
                }
            }

            // We need to move the filename into a different buffer.
            BiggestPossibleFileName = (FileName->Length + DefaultExtensionLength + sizeof(WCHAR));

            if (BiggestPossibleFileName > UNICODE_STRING_MAX_BYTES) {
#if DBG
                DbgPrint("%s: Failing because the filename plus extension (%Iu bytes) is too big\n", __FUNCTION__, BiggestPossibleFileName);
#endif // DBG
                Status = STATUS_NAME_TOO_LONG;
                goto Exit;
            }
            
            // If the buffer on the stack isn't big enough, allocate one from the heap
            if (BiggestPossibleFileName > CandidateString.MaximumLength) {
                CandidateString.MaximumLength = (USHORT) BiggestPossibleFileName;
                CandidateString.Buffer = (RtlAllocateStringRoutine)(CandidateString.MaximumLength);
                if (CandidateString.Buffer == NULL) {
#if DBG
                    DbgPrint("%s: Failing because allocating the dynamic filename buffer failed\n", __FUNCTION__);
#endif // DBG
                    Status = STATUS_NO_MEMORY;
                    goto Exit;
                }
            }

            RtlCopyMemory(CandidateString.Buffer, FileName->Buffer, FileName->Length);
            RtlCopyMemory(CandidateString.Buffer + (FileName->Length / sizeof(WCHAR)), DefaultExtension->Buffer, DefaultExtension->Length);
            CandidateString.Buffer[(FileName->Length + DefaultExtension->Length) / sizeof(WCHAR)] = UNICODE_NULL;
            CandidateString.Length = FileName->Length + DefaultExtension->Length;

            if (!RtlDoesFileExists_UstrEx(&CandidateString, TRUE)) {
                Status = STATUS_NO_SUCH_FILE;
                goto Exit;
            }

            Status = RtlGetFullPathName_UstrEx(
                            &CandidateString,
                            StaticString,
                            DynamicString,
                            (PUNICODE_STRING *) FullFileNameOut,
                            FilePartPrefixCch,
                            NULL,
                            &PathType,
                            BytesRequired);
            if (!NT_SUCCESS(Status)) {
#if DBG
                if (Status != STATUS_NO_SUCH_FILE) {
                    DbgPrint("%s: Failing on \"%wZ\" because RtlGetFullPathName_UstrEx() failed with status %08lx\n", __FUNCTION__, &CandidateString, Status);
                }
#endif // DBG
                goto Exit;
            }
        }

        Status = STATUS_SUCCESS;
        goto Exit;
    }
    
    // We know it's a relative path at this point.  Do we want to try side-by-side
    // isolation of the file?
    if (Flags & RTL_DOS_SEARCH_PATH_FLAG_APPLY_ISOLATION_REDIRECTION) {
        PUNICODE_STRING FullPathStringFound = NULL;

        Status = RtlDosApplyFileIsolationRedirection_Ustr(
            RTL_DOS_APPLY_FILE_REDIRECTION_USTR_FLAG_RESPECT_DOT_LOCAL, FileName, 
            DefaultExtension, StaticString, DynamicString, &FullPathStringFound, 
            NULL, FilePartPrefixCch, BytesRequired);
        if (NT_SUCCESS(Status)) {
            if (FullFileNameOut != NULL) {
                *FullFileNameOut = FullPathStringFound;
            }
            Status = STATUS_SUCCESS;
            goto Exit;
        }

        if (Status != STATUS_SXS_KEY_NOT_FOUND) {
#if DBG
            DbgPrint("%s: Failing because call to RtlDosApplyFileIsolationRedirection_Ustr() failed with status %wZ\n", __FUNCTION__, FileName);
#endif // DBG
            goto Exit;
        }
    }

    //
    // If a default extension was provided, see if we need to account for it
    //

    if (DefaultExtension != NULL) {
        DefaultExtensionLength = DefaultExtension->Length;

        if (FileName->Length != 0) {
            Cursor = FileName->Buffer + (FileName->Length / sizeof(WCHAR));

            while (Cursor != FileName->Buffer) {
                const WCHAR wch = *--Cursor;

                if (IS_PATH_SEPARATOR_U(wch)) {
                    // it's a slash; we have a filename without an extension...
                    break;
                }

                if (wch == L'.') {
                    // There's an extension; ignore the defualt.
                    DefaultExtension = NULL;
                    DefaultExtensionLength = 0;
                    break;
                }
            }
        }
    }

    if (Path->Length != 0) {
        USHORT CchThisSegment;
        PCWSTR LastCursor;

        Cursor = Path->Buffer + (Path->Length / sizeof(WCHAR));
        LastCursor = Cursor;

        while (Cursor != Path->Buffer) {
            if (*--Cursor == L';') {
                CchThisSegment = (USHORT) ((LastCursor - Cursor) - 1);

                if (CchThisSegment != 0) {
                    // If there is not a trailing slash, add one character
                    if (!IS_PATH_SEPARATOR_U(LastCursor[-1])) {
                        CchThisSegment++;
                    }
                }

                if (CchThisSegment > MaximumPathSegmentLength) {
                    MaximumPathSegmentLength = CchThisSegment;
                }

                // LastCursor now points to the semicolon...
                LastCursor = Cursor;
            }
        }

        CchThisSegment = (USHORT) (LastCursor - Cursor);
        if (CchThisSegment != 0) {
            if (!IS_PATH_SEPARATOR_U(LastCursor[-1])) {
                CchThisSegment++;
            }
        }

        if (CchThisSegment > MaximumPathSegmentLength) {
            MaximumPathSegmentLength = CchThisSegment;
        }

        // Convert from WCHARs to bytes
        MaximumPathSegmentLength *= sizeof(WCHAR);
    }

    BiggestPossibleFileName =
        MaximumPathSegmentLength +
        FileName->Length +
        DefaultExtensionLength +
        sizeof(WCHAR); // don't forget space for a trailing NULL...

    // It's all got to fit into a UNICODE_STRING at some point, so check that that's possible
    if (BiggestPossibleFileName > UNICODE_STRING_MAX_BYTES) {
#if DBG
        DbgPrint("%s: returning STATUS_NAME_TOO_LONG because the computed worst case file name length is %Iu bytes\n", __FUNCTION__, BiggestPossibleFileName);
#endif // DBG
        Status = STATUS_NAME_TOO_LONG;
        goto Exit;
    }

    // It's tempting to allocate the dynamic buffer here, but if it turns out that
    // the file is quickly found in one of the first segments that fits in the
    // static buffer, we'll have wasted a heap alloc.

    Cursor = Path->Buffer;
    EndMarker = Cursor + (Path->Length / sizeof(WCHAR));

    while (Cursor != EndMarker) {
        PWSTR BufferToFill = NULL;
        PWSTR BufferToFillCursor;
        PWSTR SegmentEnd = Cursor;
        USHORT SegmentSize;
        USHORT BytesToCopy;
        UNICODE_STRING DebugString;

        // Scan ahead for the end of the path buffer or the next semicolon
        while ((SegmentEnd != EndMarker) && (*SegmentEnd != L';'))
            SegmentEnd++;

        SegmentSize = (USHORT) ((SegmentEnd - Cursor) * sizeof(WCHAR));

        DebugString.Buffer = Cursor;
        DebugString.Length = SegmentSize;
        DebugString.MaximumLength = SegmentSize;

        BytesToCopy = SegmentSize;

        // Add space for a trailing slash if there isn't one.
        if ((SegmentSize != 0) && !IS_PATH_SEPARATOR_U(SegmentEnd[-1])) {
            SegmentSize += sizeof(WCHAR);
        }

        // If the string we're using for the candidates isn't big enough, allocate one that is.
        if (CandidateString.MaximumLength < (SegmentSize + FileName->Length + DefaultExtensionLength + sizeof(WCHAR))) {
            // If CandidateString is already a dynamic buffer, something's hosed because we should have allocated
            // the largest one needed the first time we outgrew the static one.
            ASSERT(CandidateString.Buffer == StaticCandidateBuffer);
            if (CandidateString.Buffer != StaticCandidateBuffer) {
#if DBG
                DbgPrint("%s: internal error #1; CandidateString.Buffer = %p; StaticCandidateBuffer = %p\n", __FUNCTION__, CandidateString.Buffer, StaticCandidateBuffer);
#endif // DBG
                Status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }

            // If this assert fires, there's either a code bug above where we computed the maximum
            // segment length, or someone's changing either the filename, default extension or
            // path around on us in another thread.  Performing a capture on the buffers seems like
            // massive overkill, so we'll just not overrun our buffers here.
            ASSERT((SegmentSize + FileName->Length + DefaultExtensionLength) < UNICODE_STRING_MAX_BYTES);
            if ((SegmentSize + FileName->Length + DefaultExtensionLength) > UNICODE_STRING_MAX_BYTES) {
#if DBG
                DbgPrint("%s: internal error #2; SegmentSize = %u, FileName->Length = %u, DefaultExtensionLength = %u\n", __FUNCTION__,
                    SegmentSize, FileName->Length, DefaultExtensionLength);
#endif // DBG
                Status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }

            CandidateString.MaximumLength = (USHORT) BiggestPossibleFileName;
            CandidateString.Buffer = (RtlAllocateStringRoutine)(CandidateString.MaximumLength);
            if (CandidateString.Buffer == NULL) {
#if DBG
                DbgPrint("%s: Unable to allocate %u byte buffer for path candidate\n", __FUNCTION__, CandidateString.MaximumLength);
#endif // DBG
                Status = STATUS_NO_MEMORY;
                goto Exit;
            }
        }

        RtlCopyMemory(
            CandidateString.Buffer,
            Cursor,
            BytesToCopy);

        BufferToFillCursor = CandidateString.Buffer + (BytesToCopy / sizeof(WCHAR));

        // Add a trailing slash if it was omitted. It's safe to index [-1] since
        // we know that SegmentSize != 0.
        if ((SegmentSize != 0) && (BytesToCopy != SegmentSize))
            *BufferToFillCursor++ = L'\\';

        RtlCopyMemory(
            BufferToFillCursor,
            FileName->Buffer,
            FileName->Length);
        BufferToFillCursor += (FileName->Length / sizeof(WCHAR));

        if (DefaultExtension != NULL) {
            RtlCopyMemory(
                BufferToFillCursor,
                DefaultExtension->Buffer,
                DefaultExtension->Length);

            BufferToFillCursor += (DefaultExtension->Length / sizeof(WCHAR));
        }

        // And top it off with a unicode null...
        *BufferToFillCursor = UNICODE_NULL;

        CandidateString.Length = (USHORT) ((BufferToFillCursor - CandidateString.Buffer) * sizeof(WCHAR));

        if (RtlDoesFileExists_UEx(CandidateString.Buffer, FALSE)) {
            // Run it through the path canonicalizer...
            Status = RtlGetFullPathName_UstrEx(
                            &CandidateString,
                            StaticString,
                            DynamicString,
                            (PUNICODE_STRING *) FullFileNameOut,
                            FilePartPrefixCch,
                            NULL,
                            &PathType,
                            BytesRequired);
            if (NT_SUCCESS(Status))
                Status = STATUS_SUCCESS;
            else {
#if DBG
                if ((Status != STATUS_NO_SUCH_FILE) && (Status != STATUS_BUFFER_TOO_SMALL)) {
                    DbgPrint("%s: Failing because we thought we found %wZ on the search path, but RtlGetFullPathName_UstrEx() returned %08lx\n", __FUNCTION__, FileName, Status);
                }
#endif // DBG
            }

            goto Exit;
        }

        if (SegmentEnd != EndMarker)
            Cursor = SegmentEnd + 1;
        else
            Cursor = SegmentEnd;
    }

    Status = STATUS_NO_SUCH_FILE;

Exit:
    if ((CandidateString.Buffer != NULL) &&
        (CandidateString.Buffer != StaticCandidateBuffer)) {
        RtlFreeUnicodeString(&CandidateString);
    }

    return Status;
}

VOID
RtlpCheckRelativeDrive(
    WCHAR NewDrive
    )

/*++

Routine Description:

    This function is called whenever we are asked to expand a non
    current directory drive relative name ( f:this\is\my\file ).  In
    this case, we validate the environment variable string to make sure
    the current directory at that drive is valid. If not, we trim back to
    the root.

Arguments:

    NewDrive - Supplies the drive to check

Return Value:

    None.

--*/

{

    WCHAR EnvVarValueBuffer[DOS_MAX_PATH_LENGTH+12]; // + sizeof (\DosDevices\)
    WCHAR EnvVarNameBuffer[4];
    UNICODE_STRING EnvVarName;
    UNICODE_STRING EnvValue;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE DirHandle;
    ULONG HardErrorValue;
    PTEB Teb;

    EnvVarNameBuffer[0] = L'=';
    EnvVarNameBuffer[1] = (WCHAR)NewDrive;
    EnvVarNameBuffer[2] = L':';
    EnvVarNameBuffer[3] = UNICODE_NULL;
    RtlInitUnicodeString(&EnvVarName,EnvVarNameBuffer);


    //
    // capture the value in a buffer that has space at the front for the dos devices
    // prefix
    //

    EnvValue.Length = 0;
    EnvValue.MaximumLength = DOS_MAX_PATH_LENGTH<<1;
    EnvValue.Buffer = &EnvVarValueBuffer[RtlpDosDevicesPrefix.Length>>1];

    Status = RtlQueryEnvironmentVariable_U( NULL,
                                            &EnvVarName,
                                            &EnvValue
                                          );
    if ( !NT_SUCCESS( Status ) ) {

        //
        // Otherwise default to root directory of drive
        //

        EnvValue.Buffer[0] = (WCHAR)NewDrive;
        EnvValue.Buffer[1] = L':';
        EnvValue.Buffer[2] = L'\\';
        EnvValue.Buffer[3] = UNICODE_NULL;
        EnvValue.Length = 6;
        }

    //
    // Form the NT name for this directory
    //

    EnvValue.Length = EnvValue.Length + RtlpDosDevicesPrefix.Length;
    EnvValue.MaximumLength = sizeof(EnvValue);
    EnvValue.Buffer = EnvVarValueBuffer;
    RtlCopyMemory(EnvVarValueBuffer,RtlpDosDevicesPrefix.Buffer,RtlpDosDevicesPrefix.Length);

    InitializeObjectAttributes(
        &Obja,
        &EnvValue,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );


    Teb = NtCurrentTeb();
    HardErrorValue = Teb->HardErrorsAreDisabled;
    Teb->HardErrorsAreDisabled = 1;

    Status = NtOpenFile(
                &DirHandle,
                SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT
                );

    Teb->HardErrorsAreDisabled = HardErrorValue;

    //
    // If the open succeeds, then the directory is valid... No need to do anything
    // further. If the open fails, then trim back the environment to the root.
    //

    if ( NT_SUCCESS(Status) ) {
        NtClose(DirHandle);
        return;
        }

    RtlpResetDriveEnvironment(NewDrive);
}

//
//  The expected calling sequence for RtlDosApplyFileIsolationRedirection_Ustr() is something
//  like this:
//
//  {
//      WCHAR Buffer[MAX_PATH];
//      UNICODE_STRING PreAllocatedString;
//      UNICODE_STRING DynamicallyAllocatedString;
//      PUNICODE_STRING FullPath;
//
//      PreAllocatedString.Length = 0;
//      PreAllocatedString.MaximumLength = sizeof(Buffer);
//      PreAllocatedString.Buffer = Buffer;
//
//      Status = RtlDosApplyFileIsolationRedirection_Ustr(
//                  Flags,    
//                  FileToCheck,
//                  DefaultExtensionToApply, // for example ".DLL"
//                  &PreAllocatedString,
//                  &DynamicallyAllocatedString,
//                  &FullPath);
//      if (NT_ERROR(Status)) return Status;
//      // now code uses FullPath as the complete path name...
//
//      // In exit paths, always free the dynamic string:
//      RtlFreeUnicodeString(&DynamicallyAllocatedString);
//  }
//

NTSTATUS
RtlDosApplyFileIsolationRedirection_Ustr(
    ULONG Flags,
    PCUNICODE_STRING FileNameIn,
    PCUNICODE_STRING DefaultExtension,
    PUNICODE_STRING PreAllocatedString,
    PUNICODE_STRING DynamicallyAllocatedString,
    PUNICODE_STRING *FullPath,
    ULONG  *OutFlags,
    SIZE_T *FilePartPrefixCch,
    SIZE_T *BytesRequired    
    )
{
    NTSTATUS Status;
    ACTIVATION_CONTEXT_SECTION_KEYED_DATA askd = {sizeof(askd)};
    PUNICODE_STRING TempString = NULL;
    UNICODE_STRING TempDynamicString;
    ULONG BytesLeft;
    ULONG RealTotalPathLength;
    ULONG i;
    const ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION UNALIGNED * DllRedirData;
    const ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT UNALIGNED * PathSegmentArray;
    PCUNICODE_STRING FileName = NULL;
    UNICODE_STRING FileNameWithExtension;
    WCHAR FileNameWithExtensionBuffer[DOS_MAX_PATH_LENGTH/4];
    PWSTR Cursor;
    PACTIVATION_CONTEXT ActivationContext = NULL;
    PCUNICODE_STRING AssemblyStorageRoot = NULL;
    WCHAR ExpandedTemporaryBuffer[DOS_MAX_PATH_LENGTH];
    UNICODE_STRING ExpandedTemporaryString;
    UNICODE_STRING DllNameUnderLocalDirString = { 0, 0, NULL };
    RTL_PATH_TYPE PathType = 0;
    PCUNICODE_STRING LocalDllNameString = NULL;

#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "SXS: Entered %s\n", __FUNCTION__);
#endif // DBG_SXS

    if (DynamicallyAllocatedString != NULL) {
        DynamicallyAllocatedString->Length = 0;
        DynamicallyAllocatedString->MaximumLength = 0;
        DynamicallyAllocatedString->Buffer = NULL;
    }

    if (OutFlags != NULL)
        *OutFlags = 0;

    if (FilePartPrefixCch != NULL)
        *FilePartPrefixCch = 0;

    if (BytesRequired != NULL)
        *BytesRequired = 0;

    TempDynamicString.Length = 0;
    TempDynamicString.MaximumLength = 0;
    TempDynamicString.Buffer = NULL;

    ExpandedTemporaryString.Length = 0;
    ExpandedTemporaryString.MaximumLength = sizeof(ExpandedTemporaryBuffer);
    ExpandedTemporaryString.Buffer = ExpandedTemporaryBuffer;

    FileNameWithExtension.Buffer = NULL;

    // Valid input conditions:
    //  1. You have to have a filename
    //  2. If you specify both the preallocated buffer and the dynamically
    //      allocated buffer, you need the FullPath parameter to detect
    //      which was actually populated.
    //  3. If you ask for the file part prefix cch, you need an output
    //      buffer; otherwise you can't know what the cch is relative to.
    if (((Flags & ~(RTL_DOS_APPLY_FILE_REDIRECTION_USTR_FLAG_RESPECT_DOT_LOCAL)) != 0) || 
        (FileNameIn == NULL) ||         
        ((PreAllocatedString == NULL) && (DynamicallyAllocatedString == NULL) && (FilePartPrefixCch != NULL)) ||
        ((PreAllocatedString != NULL) &&
         (DynamicallyAllocatedString != NULL) &&
         (FullPath == NULL))) {

#if DBG
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "%s - invalid parameter(s)\n"
            "   FileNameIn = %p\n"
            "   PreAllocatedString = %p\n"
            "   DynamicallyAllocatedString = %p\n"
            "   FullPath = %p\n"
            "   FilePartPrefixCch = %p\n",
            __FUNCTION__,
            FileNameIn,
            PreAllocatedString,
            DynamicallyAllocatedString,
            FullPath,
            FilePartPrefixCch);
#endif // DBG

        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    PathType = RtlDetermineDosPathNameType_Ustr(FileNameIn);
    if (PathType!= RtlPathTypeRelative) {

        // 
        // We only redirect relative paths for actctx; bypass all extra work for non-relative paths
        // but for local file, we need verify its existence of those files.
        //

        if ((PathType == RtlPathTypeDriveAbsolute) || (PathType == RtlPathTypeUncAbsolute))
        {
            // check the existence of the local
            PPEB pPeb = NtCurrentPeb();
            if ((pPeb != NULL) && (pPeb->ProcessParameters != NULL) && (pPeb->ProcessParameters->Flags & RTL_USER_PROC_DLL_REDIRECTION_LOCAL))  // there is .local 
            {
                // check whether this file is under the app directory
                const USHORT cbFullImageNameLength = pPeb->ProcessParameters->ImagePathName.Length;
                const LPWSTR pFullImageName = (PWSTR)pPeb->ProcessParameters->ImagePathName.Buffer;
                LPWSTR p, p1, t, t1;
                USHORT cbPathLength, cbDllPathLength, cbApplicationPathLength;               

                if (pFullImageName == NULL)
                    goto SxsKeyNotFound;

                p = pFullImageName + cbFullImageNameLength/sizeof(WCHAR) - 1; // point to last character of this name
                p1 = NULL;
                while (p != pFullImageName) {
                    if (*p == (WCHAR)'\\') {
                        p1 = p + 1;
                        break;
                    }
                    p-- ;
                }

                ASSERT(p1 != NULL);
                cbApplicationPathLength = (USHORT)(p1 - pFullImageName) * sizeof(WCHAR); 

                t = FileNameIn->Buffer + FileNameIn->Length / sizeof(WCHAR) -1; // point to last char of this full-qualified filename
                t1 = NULL;
                while (t != FileNameIn->Buffer ) {
                    if (*t == (WCHAR)'\\') {
                        t1 = t + 1;
                        break;
                    }
                    t-- ;
                }
                ASSERT(t1 != NULL);
                cbDllPathLength = (USHORT)(t1 - FileNameIn->Buffer) * sizeof(WCHAR); 
                
                // comparison the path
                if (cbDllPathLength == cbApplicationPathLength)
                {
                    UNICODE_STRING ustrAppPath, ustrDllPath; 
                    ustrAppPath.Buffer = pFullImageName;
                    ustrAppPath.Length = cbApplicationPathLength;
                    ustrAppPath.MaximumLength = cbApplicationPathLength;

                    ustrDllPath.Buffer = FileNameIn->Buffer;
                    ustrDllPath.Length = cbDllPathLength;
                    ustrDllPath.MaximumLength = cbDllPathLength;

                    if (RtlCompareUnicodeString(&ustrAppPath, &ustrDllPath, TRUE) == 0 )
                    {
                        // .local and local binary
                        LocalDllNameString = FileNameIn;
                        goto CopyIntoOutBuffer;
                    }
                }
            
                // for file name with a fullly qualified path, which is not the app dir, 
                // we need check the appdir and appdir\app.exe.local\ whether a file with the same name exists, 
                // If so, it is redired. Just like a relative-path filename
            
                goto DoAllWork; // only for .local case
            }
        }
SxsKeyNotFound:
        Status = STATUS_SXS_KEY_NOT_FOUND;
        goto Exit;
    }

DoAllWork:
    // See if we need to default the extension...
    if ((DefaultExtension != NULL) && (DefaultExtension->Length != 0)) {
        SIZE_T BytesRequired;

        if (FileNameIn->Length >= sizeof(WCHAR)) {
            Cursor = FileNameIn->Buffer + ((FileNameIn->Length / sizeof(WCHAR)) - 1);

            while (Cursor >= FileNameIn->Buffer) {
                const WCHAR wch = *Cursor--;

                if (IS_PATH_SEPARATOR_U(wch)) {
                    // we've come to the end of the last path segment; break out.
                    break;
                }

                if (wch == L'.') {
                    // There's an extension; don't default anything.
                    DefaultExtension = NULL;
                    break;
                }
            }
        }

        // If it's still not null, we have some work to do.
        if (DefaultExtension != NULL) {
            BytesRequired = FileNameIn->Length + DefaultExtension->Length + sizeof(WCHAR);

            if (BytesRequired > UNICODE_STRING_MAX_BYTES) {
                Status = STATUS_NAME_TOO_LONG;
                goto Exit;
            }

            if (BytesRequired > sizeof(FileNameWithExtensionBuffer)) {
                FileNameWithExtension.Buffer = (RtlAllocateStringRoutine)(BytesRequired);
                if (FileNameWithExtension.Buffer == NULL) {
                    Status = STATUS_NO_MEMORY;
                    goto Exit;
                }

                FileNameWithExtension.MaximumLength = (USHORT) BytesRequired;
            } else {
                FileNameWithExtension.Buffer = FileNameWithExtensionBuffer;
                FileNameWithExtension.MaximumLength = sizeof(FileNameWithExtensionBuffer);
            }

            FileNameWithExtension.Length = ((USHORT) BytesRequired - sizeof(WCHAR));

            RtlCopyMemory(
                FileNameWithExtension.Buffer,
                FileNameIn->Buffer,
                FileNameIn->Length);
            RtlCopyMemory(
                FileNameWithExtension.Buffer + (FileNameIn->Length / sizeof(WCHAR)),
                DefaultExtension->Buffer,
                DefaultExtension->Length);
            FileNameWithExtension.Buffer[(FileNameIn->Length + DefaultExtension->Length) / sizeof(WCHAR)] = UNICODE_NULL;

            FileName = &FileNameWithExtension;
        }
    }
    
    // If we didn't munge it, use the pointer to the filename passed in
    if (FileName == NULL) {
        FileName = FileNameIn;
    }


    //
    // Before the actctx is searched, check whether .local is respected. 
    //      1) if .local is respected
    //      2)     get the .local filename
    //      3)     if the .local file exist, 
    //      4)         return the local filename
    //      5)      endif
    //      6)  endif

    if ((Flags & RTL_DOS_APPLY_FILE_REDIRECTION_USTR_FLAG_RESPECT_DOT_LOCAL) && 
            (NtCurrentPeb()->ProcessParameters != NULL) &&
            (NtCurrentPeb()->ProcessParameters->Flags & RTL_USER_PROC_DLL_REDIRECTION_LOCAL))
    {
        BOOLEAN fLocalExist = FALSE;        
        //
        // \x\foo.exe
        // ExpandedTemporaryString is \x\bar.dll
        // DllNameUnderLocalDirString is \x\foo.exe.local\bar.dll
        //
        Status = RtlComputePrivatizedDllName_U(FileName, &ExpandedTemporaryString, &DllNameUnderLocalDirString);
        if(!NT_SUCCESS(Status))             
            goto Exit;

#if DBG && 0
        {
            BOOLEAN Boolean;
            NTSTATUS Status;
            HANDLE Handle = NULL;
            const PCUNICODE_STRING Files[] = { &DllNameUnderLocalDirString, &ExpandedTemporaryString };
            ULONG i;

            for (i = 0 ; i != RTL_NUMBER_OF(Files) ; ++i) {
                const PCUNICODE_STRING File = Files[i];
                
                Boolean = RtlDoesFileExists_UStr(File);
                
                
                Status = RtlDoesFileExist3(&Handle, File, FILE_GENERIC_READ, FILE_SHARE_READ, FILE_NON_DIRECTORY_FILE);
                DbgPrint("RtlDoesFileExists_UStr(%wZ):%s\n", File, Boolean ? "true" : "false");
                
                DbgPrint("RtlDoesFileExist3(%wZ):%x\n", File, Status);
                
                if (Handle != NULL) {
                    NtClose(Handle);
                    Handle = NULL;
                }
            }
        }        
#endif
        if (RtlDoesFileExists_UStr(&DllNameUnderLocalDirString))// there is a local dll, use it
        {
            LocalDllNameString = &DllNameUnderLocalDirString;
        }
        else if (RtlDoesFileExists_UStr(&ExpandedTemporaryString))// there is a local dll, use it
        {
            LocalDllNameString = &ExpandedTemporaryString;
        }
CopyIntoOutBuffer:
        // 
        // we have found the .local files 
        //
        if (LocalDllNameString != NULL)
        {            
            if ((PreAllocatedString == NULL) && (DynamicallyAllocatedString == NULL)) 
            {
                Status = STATUS_SUCCESS;
                // This was just an existence test.  return the successful status.
                goto Exit;
            }

            if ((DynamicallyAllocatedString == NULL) &&
                (PreAllocatedString->MaximumLength < (LocalDllNameString->Length + sizeof(WCHAR)))) {

                if (BytesRequired != NULL)
                    *BytesRequired = (LocalDllNameString->Length + sizeof(WCHAR));

                Status = STATUS_BUFFER_TOO_SMALL;
                goto Exit;
            }


            if ((PreAllocatedString == NULL) ||
                (PreAllocatedString->MaximumLength < (LocalDllNameString->Length + sizeof(WCHAR)))) 
            {
                TempDynamicString.Buffer = (RtlAllocateStringRoutine)(LocalDllNameString->Length + sizeof(WCHAR));

                if (TempDynamicString.Buffer == NULL) 
                {
                    Status = STATUS_NO_MEMORY;
                    goto Exit;
                }

                TempDynamicString.MaximumLength = (USHORT) (LocalDllNameString->Length + sizeof(WCHAR));
                TempString = &TempDynamicString;
            } else 
            {
                TempString = PreAllocatedString;
            }

            RtlCopyMemory(TempString->Buffer, LocalDllNameString->Buffer, LocalDllNameString->Length);
            TempString->Length = (USHORT)LocalDllNameString->Length;
            TempString->Buffer[TempString->Length / sizeof(WCHAR)] = 0;
            if (OutFlags)
                *OutFlags  |= RTL_DOS_APPLY_FILE_REDIRECTION_USTR_OUTFLAG_DOT_LOCAL_REDIRECT;
            goto Done;
        }
    }

    Status = RtlFindActivationContextSectionString(
                    FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ACTIVATION_CONTEXT
                    | FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_FLAGS,
                    NULL,
                    ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION,
                    FileName,
                    &askd);
    if (!NT_SUCCESS(Status)) {
        // Map section not found back to key not found so that callers don't 
        // have to worry about sections being present vs. the lookup key
        // being present.
        if (Status == STATUS_SXS_SECTION_NOT_FOUND)
            Status = STATUS_SXS_KEY_NOT_FOUND;

        if (Status != STATUS_SXS_KEY_NOT_FOUND) {
#if DBG
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s - RtlFindActivationContextSectionString() returned ntstatus 0x%08lx\n",
                __FUNCTION__,
                Status);
#endif // DBG
        }

        goto Exit;
    }

    ActivationContext = askd.ActivationContext;

    if ((PreAllocatedString == NULL) && (DynamicallyAllocatedString == NULL)) {
        Status = STATUS_SUCCESS;
        // This was just an existence test.  return the successful status.
        goto Exit;
    }

    if ((askd.Length < sizeof(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION)) ||
        (askd.DataFormatVersion != ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_FORMAT_WHISTLER)) {
#if DBG
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s - Length or data format version of dll redirection data invalid.\n",
            __FUNCTION__);
#endif // DBG
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    DllRedirData = (const ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION UNALIGNED *) askd.Data;

    // If the entry requires path root resolution, do so!
    if (DllRedirData->Flags & ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_OMITS_ASSEMBLY_ROOT) {
        NTSTATUS InnerStatus = STATUS_SUCCESS;

        // There's no need to support both a dynamic root and environment variable
        // expansion.
        if (DllRedirData->Flags & ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_EXPAND) {
            Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
            goto Exit;
        }

        Status = RtlGetAssemblyStorageRoot(
                        ((askd.Flags & ACTIVATION_CONTEXT_SECTION_KEYED_DATA_FLAG_FOUND_IN_PROCESS_DEFAULT)
                        ? RTL_GET_ASSEMBLY_STORAGE_ROOT_FLAG_ACTIVATION_CONTEXT_USE_PROCESS_DEFAULT
                        : 0)
                        | ((askd.Flags & ACTIVATION_CONTEXT_SECTION_KEYED_DATA_FLAG_FOUND_IN_SYSTEM_DEFAULT)
                        ? RTL_GET_ASSEMBLY_STORAGE_ROOT_FLAG_ACTIVATION_CONTEXT_USE_SYSTEM_DEFAULT
                        : 0),
                        ActivationContext,
                        askd.AssemblyRosterIndex,
                        &AssemblyStorageRoot,
                        &RtlpAssemblyStorageMapResolutionDefaultCallback,
                        (PVOID) &InnerStatus);
        if (NT_ERROR(Status)) {
            if (Status == STATUS_CANCELLED) {
                if (NT_ERROR(InnerStatus)) {
                    Status = InnerStatus;
                }
            }

            goto Exit;
        }
    }

    RealTotalPathLength = DllRedirData->TotalPathLength;

    if (!(DllRedirData->Flags & ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_INCLUDES_BASE_NAME))
        RealTotalPathLength += FileName->Length;

    if (AssemblyStorageRoot != NULL)
        RealTotalPathLength += AssemblyStorageRoot->Length;

    // If the path doesn't fit into the statically allocated buffer and there isn't a dynamic one,
    // we're in trouble.
    if ((DynamicallyAllocatedString == NULL) &&
        (PreAllocatedString->MaximumLength < (RealTotalPathLength + sizeof(WCHAR)))) {

        if (BytesRequired != NULL)
            *BytesRequired = (RealTotalPathLength + sizeof(WCHAR));

        Status = STATUS_BUFFER_TOO_SMALL;
        goto Exit;
    }

    // Allocate the dynamic string if we need to...
    if ((PreAllocatedString == NULL) ||
        (PreAllocatedString->MaximumLength < (RealTotalPathLength + sizeof(WCHAR)))) {
        TempDynamicString.Buffer = (RtlAllocateStringRoutine)(RealTotalPathLength + sizeof(WCHAR));

        if (TempDynamicString.Buffer == NULL) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }

        TempDynamicString.MaximumLength = (USHORT) (RealTotalPathLength + sizeof(WCHAR));

        TempString = &TempDynamicString;
    } else {
        TempString = PreAllocatedString;
    }

    Cursor = TempString->Buffer;
    // Account for the trailing null character in BytesLeft up front...
    BytesLeft = TempString->MaximumLength - sizeof(WCHAR);

    // If the path segment list extends beyond the section, we're outta here
    if ((((ULONG) DllRedirData->PathSegmentOffset) > askd.SectionTotalLength) ||
        (((ULONG) (DllRedirData->PathSegmentOffset + (DllRedirData->PathSegmentCount * sizeof(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT)))) > askd.SectionTotalLength)) {
#if DBG
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s - Path segment array extends beyond section limits\n",
            __FUNCTION__);
#endif // DBG
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    // If we have a dynamically obtained storage root, put it in the buffer first.
    if (AssemblyStorageRoot != NULL) {
        USHORT Length = AssemblyStorageRoot->Length; // capture the value so that we don't possibly overwrite the buffer

        if (BytesLeft < Length) {
            Status = STATUS_INTERNAL_ERROR; // someone's playing tricks on us with the unicode string
            goto Exit;
        }

        RtlCopyMemory(Cursor, AssemblyStorageRoot->Buffer, Length);

        Cursor = (PWSTR) (((ULONG_PTR) Cursor) + Length);
        BytesLeft -= Length;
    }

    PathSegmentArray = (PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT) (((ULONG_PTR) askd.SectionBase) + DllRedirData->PathSegmentOffset);

    for (i=0; i<DllRedirData->PathSegmentCount; i++)
    {
        // It would seem that we could just report insufficient buffer here, but the total
        // size checked earlier indicated that the FullPath variable was big enough;
        // the data structure is hosed.
        if (BytesLeft < PathSegmentArray[i].Length) {
#if DBG
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s - path segment %lu overflowed buffer\n",
                __FUNCTION__, i);
#endif // DBG
            Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
            goto Exit;
        }

        // If the character array is outside the bounds of the section, something's hosed.
        if ((((ULONG) PathSegmentArray[i].Offset) > askd.SectionTotalLength) ||
            (((ULONG) (PathSegmentArray[i].Offset + PathSegmentArray[i].Length)) > askd.SectionTotalLength)) {
#if DBG
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s - path segment %lu at %p (offset: %ld, length: %lu, bounds: %lu) buffer is outside section bounds\n",
                __FUNCTION__,
                i,
                &PathSegmentArray[i].Offset,
                PathSegmentArray[i].Offset,
                PathSegmentArray[i].Length,
                askd.SectionTotalLength);
#endif // DBG
            Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
            goto Exit;
        }

        RtlCopyMemory(
            Cursor,
            (PVOID) (((ULONG_PTR) askd.SectionBase) + PathSegmentArray[i].Offset),
            PathSegmentArray[i].Length);

        Cursor += (PathSegmentArray[i].Length / sizeof(WCHAR));
        BytesLeft -= PathSegmentArray[i].Length;
    }

    if (!(DllRedirData->Flags & ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_INCLUDES_BASE_NAME)) {
        if (BytesLeft < FileName->Length) {
#if DBG
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s - appending base file name overflowed buffer\n",
                __FUNCTION__);
#endif // DBG
            Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
            goto Exit;
        }

        RtlCopyMemory(
            Cursor,
            FileName->Buffer,
            FileName->Length);

        Cursor += (FileName->Length / sizeof(WCHAR));
        BytesLeft -= FileName->Length;
    }

    *Cursor = L'\0';

    TempString->Length = (USHORT) (((ULONG_PTR) Cursor) - ((ULONG_PTR) TempString->Buffer));

    // Apply any environment strings as necessary...
    if (DllRedirData->Flags & ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_EXPAND) {
        ULONG ExpandedStringLength;

        ExpandedTemporaryString.Length = 0;
        ExpandedTemporaryString.MaximumLength = sizeof(ExpandedTemporaryBuffer) - sizeof(WCHAR);
        ExpandedTemporaryString.Buffer = ExpandedTemporaryBuffer;

        Status = RtlExpandEnvironmentStrings_U(NULL, TempString, &ExpandedTemporaryString, &ExpandedStringLength);
        if (NT_ERROR(Status)) {
            if (Status != STATUS_BUFFER_TOO_SMALL)
                goto Exit;

            // If it expands to something larger than UNICODE_MAX_BYTES, there's no hope.
            if (ExpandedStringLength > UNICODE_STRING_MAX_BYTES) {
                Status = STATUS_NAME_TOO_LONG;
                goto Exit;
            }

            ExpandedTemporaryString.Buffer = (RtlAllocateStringRoutine)(ExpandedStringLength);
            if (ExpandedTemporaryString.Buffer == NULL) {
                Status = STATUS_NO_MEMORY;
                goto Exit;
            }

            // This cast is OK because we already range checked the value.
            ExpandedTemporaryString.MaximumLength = (USHORT) ExpandedStringLength;
            ExpandedTemporaryString.Length = 0;

            Status = RtlExpandEnvironmentStrings_U(NULL, TempString, &ExpandedTemporaryString, &ExpandedStringLength);
            if (NT_ERROR(Status))
                goto Exit;

            ExpandedTemporaryString.Buffer[ExpandedTemporaryString.Length / sizeof(WCHAR)] = L'\0';

            // Now move this thing into the caller's buffer
            if ((PreAllocatedString != NULL) && (PreAllocatedString->MaximumLength >= ExpandedTemporaryString.MaximumLength)) {
                // It does.  Just copy the bits and let's go.
                RtlCopyMemory(
                    PreAllocatedString->Buffer,
                    ExpandedTemporaryString.Buffer,
                    ExpandedTemporaryString.MaximumLength); // MaximumLength because it includes the trailing null character
                PreAllocatedString->Length = ExpandedTemporaryString.Length;
                TempString = PreAllocatedString;
            } else if (DynamicallyAllocatedString != NULL) {
                // If they can take a dynamic string, we'll use this one.
                TempString = &ExpandedTemporaryString;
            } else {
                // Just plain no room.
                if (BytesRequired != NULL)
                    *BytesRequired = ExpandedTemporaryString.MaximumLength;

                Status = STATUS_BUFFER_TOO_SMALL;
                goto Exit;
            }
        } else {
            ExpandedTemporaryString.Buffer[ExpandedTemporaryString.Length / sizeof(WCHAR)] = L'\0';

            // Hey, it succeeded!  Let's see if we can fit this into the output static string.
            if ((PreAllocatedString != NULL) && ((ExpandedTemporaryString.Length + sizeof(WCHAR)) < PreAllocatedString->MaximumLength)) {
                // It fits!
                RtlCopyMemory(
                    PreAllocatedString->Buffer,
                    ExpandedTemporaryBuffer,
                    ExpandedTemporaryString.Length + sizeof(WCHAR));
                PreAllocatedString->Length = ExpandedTemporaryString.Length;
            } else {
                // Let's make a dynamic string.  It's possible that we already have a dynamic string
                // but the chance is pretty darned remote so I won't optimize for it.  -mgrier

                if ((ExpandedTemporaryString.Length + sizeof(WCHAR)) > UNICODE_STRING_MAX_BYTES) {
                    Status = STATUS_NAME_TOO_LONG;
                    goto Exit;
                }

                ExpandedTemporaryString.MaximumLength = (USHORT) (ExpandedTemporaryString.Length + sizeof(WCHAR));
                ExpandedTemporaryString.Buffer = (RtlAllocateStringRoutine)(ExpandedTemporaryString.MaximumLength);
                if (ExpandedTemporaryString.Buffer == NULL) {
                    Status = STATUS_NO_MEMORY;
                    goto Exit;
                }

                RtlCopyMemory(
                    ExpandedTemporaryString.Buffer,
                    ExpandedTemporaryBuffer,
                    ExpandedTemporaryString.MaximumLength);

                TempString = &ExpandedTemporaryString;
            }
        }
    }
    if (OutFlags)
        *OutFlags |= RTL_DOS_APPLY_FILE_REDIRECTION_USTR_OUTFLAG_ACTCTX_REDIRECT;

Done:

    if (FilePartPrefixCch != NULL) {
        //
        // set Cursor at the end of the unicode string
        //
        Cursor = TempString->Buffer + TempString->Length;
        while (Cursor != TempString->Buffer) {
            if (IS_PATH_SEPARATOR_U(*Cursor)) {
                break;
            }
            Cursor--;
        }

        *FilePartPrefixCch = (Cursor - TempString->Buffer) + 1;
    }

    if (TempString != PreAllocatedString)         
    {
        *DynamicallyAllocatedString = *TempString;

        //
        // TempString->Buffer is dynamically allocated, and this memory would be 
        // passed to caller, so set it to be NULL to avoid to be freed;
        //       
        TempDynamicString.Buffer = NULL;

        if (FullPath != NULL) 
            *FullPath = DynamicallyAllocatedString;        
    }
    else 
        if (FullPath != NULL)
            *FullPath = PreAllocatedString;
    
    Status = STATUS_SUCCESS;

Exit:
    if (DllNameUnderLocalDirString.Buffer != NULL)
        (RtlFreeStringRoutine)(DllNameUnderLocalDirString.Buffer);

    if (TempDynamicString.Buffer != NULL) {
        (RtlFreeStringRoutine)(TempDynamicString.Buffer);
    }

    if ((FileNameWithExtension.Buffer != NULL) && (FileNameWithExtension.Buffer != FileNameWithExtensionBuffer)) {
        (RtlFreeStringRoutine)(FileNameWithExtension.Buffer);
    }

    if ((ExpandedTemporaryString.Buffer != NULL) && (ExpandedTemporaryString.Buffer != ExpandedTemporaryBuffer)) {
        (RtlFreeStringRoutine)(ExpandedTemporaryString.Buffer);
    }

    if (ActivationContext != NULL)
        RtlReleaseActivationContext(ActivationContext);

    return Status;
}

#define RTLP_LAST_PATH_ELEMENT_PATH_TYPE_FULL_DOS_OR_NT   (0x00000001)
#define RTLP_LAST_PATH_ELEMENT_PATH_TYPE_FULL_DOS         (0x00000002)
#define RTLP_LAST_PATH_ELEMENT_PATH_TYPE_NT               (0x00000003)
#define RTLP_LAST_PATH_ELEMENT_PATH_TYPE_DOS              (0x00000004)

NTSTATUS
NTAPI
RtlpGetLengthWithoutLastPathElement(
    IN  ULONG            Flags,
    IN  ULONG            PathType,
    IN  PCUNICODE_STRING Path,
    OUT ULONG*           LengthOut
    )
/*++

Routine Description:

    Report how long Path would be if you remove its last element.
    This is much simpler than RtlRemoveLastDosPathElement.
    It is used to implement the other RtlRemoveLast*PathElement.

Arguments:

    Flags - room for future expansion
    Path - the path is is an NT path or a full DOS path; the various relative DOS
        path types do not work, see RtlRemoveLastDosPathElement for them.

Return Value:

    STATUS_SUCCESS - the usual hunky-dory
    STATUS_NO_MEMORY - the usual stress
    STATUS_INVALID_PARAMETER - the usual bug

--*/
{
    ULONG Index = 0;
    ULONG Length = 0;
    NTSTATUS Status = STATUS_SUCCESS;
    RTL_PATH_TYPE DosPathType = RtlPathTypeUnknown;
    ULONG DosPathFlags = 0;
    const RTL_PATH_TYPE* AllowedPathTypes;
    ULONG AllowedDosPathTypeBits =   (1UL << RtlPathTypeRooted)
                                   | (1UL << RtlPathTypeUncAbsolute)
                                   | (1UL << RtlPathTypeDriveAbsolute)
                                   | (1UL << RtlPathTypeLocalDevice)     // "\\?\"
                                   | (1UL << RtlPathTypeRootLocalDevice) // "\\?"
                                   ;
    WCHAR PathSeperators[2] = { '/', '\\' };

#define LOCAL_IS_PATH_SEPERATOR(ch_) ((ch_) == PathSeperators[0] || (ch_) == PathSeperators[1])

    if (LengthOut != NULL) {
        *LengthOut = 0;
    }

    if (   !RTL_SOFT_VERIFY(Path != NULL)
        || !RTL_SOFT_VERIFY(Flags == 0)
        || !RTL_SOFT_VERIFY(LengthOut != NULL)
        ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Length = RTL_STRING_GET_LENGTH_CHARS(Path);

    switch (PathType)
    {
    default:
    case RTLP_LAST_PATH_ELEMENT_PATH_TYPE_DOS:
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    case RTLP_LAST_PATH_ELEMENT_PATH_TYPE_NT:
        //
        // RtlpDetermineDosPathNameType4 calls it "rooted"
        // only backslashes are seperators
        // path must start with backslash
        // second char must not be backslash
        //
        AllowedDosPathTypeBits = (1UL << RtlPathTypeRooted);
        PathSeperators[0] = '\\';
        if (Length > 0 && Path->Buffer[0] != '\\'
            ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
        if (Length > 1 && Path->Buffer[1] == '\\'
            ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
        break;
    case RTLP_LAST_PATH_ELEMENT_PATH_TYPE_FULL_DOS:
        AllowedDosPathTypeBits &= ~(1UL << RtlPathTypeRooted);
        break;
    case RTLP_LAST_PATH_ELEMENT_PATH_TYPE_FULL_DOS_OR_NT:
        break;
    }

    if (Length == 0) {
        goto Exit;
    }

    if (!RTL_SOFT_VERIFY(NT_SUCCESS(Status = RtlpDetermineDosPathNameType4(RTL_DETERMINE_DOS_PATH_NAME_TYPE_IN_FLAG_STRICT_WIN32NT, Path, &DosPathType, &DosPathFlags)))) {
        goto Exit;
    }
    if (!RTL_SOFT_VERIFY((1UL << DosPathType) & AllowedDosPathTypeBits)
        ) {
        //KdPrintEx();
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (!RTL_SOFT_VERIFY(
           (PathType & RTLP_DETERMINE_DOS_PATH_NAME_TYPE_OUT_FLAG_INVALID) == 0
            )) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    // skip one or more trailing path seperators
    for ( ; Length != 0 && LOCAL_IS_PATH_SEPERATOR(Path->Buffer[Length - 1]) ; --Length) {
        // nothing
    }
    // skip trailing path element
    for ( ; Length != 0 && !LOCAL_IS_PATH_SEPERATOR(Path->Buffer[Length - 1]) ; --Length) {
        // nothing
    }
    // skip one or more in between path seperators
    for ( ; Length != 0 && LOCAL_IS_PATH_SEPERATOR(Path->Buffer[Length - 1]) ; --Length) {
        // nothing
    }
    // put back a trailing path seperator, for the sake of c:\ vs. c:
    if (Length != 0) {
        ++Length;
    }

    //
    // Should optionally check for "bad dos roots" here.
    //

    *LengthOut = Length;
    Status = STATUS_SUCCESS;
Exit:
    return Status;
#undef LOCAL_IS_PATH_SEPERATOR
}

NTSTATUS
NTAPI
RtlGetLengthWithoutLastNtPathElement(
    IN  ULONG            Flags,
    IN  PCUNICODE_STRING Path,
    OUT ULONG*           LengthOut
    )
/*++

Routine Description:

    Report how long Path would be if you remove its last element.

Arguments:

    Flags - room for future expansion
    Path - the path is is an NT path; the various DOS path types
        do not work, see RtlRemoveLastDosPathElement for them.

Return Value:

    STATUS_SUCCESS - the usual hunky-dory
    STATUS_NO_MEMORY - the usual stress
    STATUS_INVALID_PARAMETER - the usual bug

--*/
{
    NTSTATUS Status = RtlpGetLengthWithoutLastPathElement(Flags, RTLP_LAST_PATH_ELEMENT_PATH_TYPE_NT, Path, LengthOut);
    return Status;
}

NTSTATUS
NTAPI
RtlGetLengthWithoutLastFullDosOrNtPathElement(
    IN  ULONG            Flags,
    IN  PCUNICODE_STRING Path,
    OUT ULONG*           LengthOut
    )
/*++

Routine Description:

    Report how long Path would be if you remove its last element.

Arguments:

    Flags - room for future expansion
    Path - the path is is an NT path; the various DOS path types
        do not work, see RtlRemoveLastDosPathElement for them.

Return Value:

    STATUS_SUCCESS - the usual hunky-dory
    STATUS_NO_MEMORY - the usual stress
    STATUS_INVALID_PARAMETER - the usual bug

--*/
{
    NTSTATUS Status = RtlpGetLengthWithoutLastPathElement(Flags, RTLP_LAST_PATH_ELEMENT_PATH_TYPE_FULL_DOS_OR_NT, Path, LengthOut);
    return Status;
}

CONST CHAR*
RtlpDbgBadDosRootPathTypeToString(
    IN ULONG         Flags,
    IN ULONG         RootType
    )
/*++

Routine Description:

  An aid to writing DbgPrint code.
    
Arguments:

    Flags - room for future binary compatible expansion

    RootType - fairly specifically what the string is
        RTLP_BAD_DOS_ROOT_PATH_WIN32NT_PREFIX       - \\? or \\?\
        RTLP_BAD_DOS_ROOT_PATH_WIN32NT_UNC_PREFIX   - \\?\unc or \\?\unc\
        RTLP_BAD_DOS_ROOT_PATH_NT_PATH              - \??\ but this i only a rough check
        RTLP_BAD_DOS_ROOT_PATH_MACHINE_NO_SHARE     - \\machine or \\?\unc\machine
        RTLP_GOOD_DOS_ROOT_PATH                     - none of the above, seems ok

Return Value:

    strings like those that describe RootType or "unknown" or empty in free builds
--*/
{
    CONST CHAR* s = "";
#if DBG
    if (Flags != 0) {
        DbgPrint("Invalid parameter to %s ignored\n", __FUNCTION__);
    }
    switch (RootType
        ) {
        case RTLP_GOOD_DOS_ROOT_PATH                  : s = "good"; break;
        case RTLP_BAD_DOS_ROOT_PATH_WIN32NT_PREFIX    : s = "\\\\?\\"; break;
        case RTLP_BAD_DOS_ROOT_PATH_WIN32NT_UNC_PREFIX: s = "\\\\?\\unc"; break;
        case RTLP_BAD_DOS_ROOT_PATH_NT_PATH           : s = "\\??\\"; break;
        case RTLP_BAD_DOS_ROOT_PATH_MACHINE_NO_SHARE  : s = "\\\\machine or \\\\?\\unc\\machine"; break;
        default:
            s = "unknown";
            DbgPrint("Invalid parameter %0x08Ix to %s ignored\n", RootType, __FUNCTION__);
            break;

    }
#endif
    return s;
}

NTSTATUS
RtlpCheckForBadDosRootPath(
    IN ULONG             Flags,
    IN PCUNICODE_STRING  Path,
    OUT ULONG*           RootType
    )
/*++

Routine Description:

    
Arguments:

    Flags - room for future binary compatible expansion

    Path - the path to be checked

    RootType - fairly specifically what the string is
        RTLP_BAD_DOS_ROOT_PATH_WIN32NT_PREFIX       - \\? or \\?\
        RTLP_BAD_DOS_ROOT_PATH_WIN32NT_UNC_PREFIX   - \\?\unc or \\?\unc\
        RTLP_BAD_DOS_ROOT_PATH_NT_PATH              - \??\ but this i only a rough check
        RTLP_BAD_DOS_ROOT_PATH_MACHINE_NO_SHARE     - \\machine or \\?\unc\machine
        RTLP_GOOD_DOS_ROOT_PATH                     - none of the above, seems ok

Return Value:

    STATUS_SUCCESS - 
    STATUS_INVALID_PARAMETER -
        Path is NULL
        or Flags uses undefined values
--*/
{
    ULONG Length = 0;
    ULONG Index = 0;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN Unc = FALSE;
    BOOLEAN Unc1 = FALSE;
    BOOLEAN Unc2 = FALSE;
    ULONG PiecesSeen = 0;

    if (RootType != NULL) {
        *RootType = 0;
    }

    if (   !RTL_SOFT_VERIFY(Path != NULL)
        || !RTL_SOFT_VERIFY(RootType != NULL)
        || !RTL_SOFT_VERIFY(Flags == 0)
        ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Length = Path->Length / sizeof(Path->Buffer[0]);

    if (Length < 3 || !RTL_IS_PATH_SEPERATOR(Path->Buffer[0])) {
        *RootType = RTLP_GOOD_DOS_ROOT_PATH;
        goto Exit;
    }

    // prefix \??\ (heuristic, doesn't catch many NT paths)
    if (RtlPrefixUnicodeString(RTL_CONST_CAST(PUNICODE_STRING)(&RtlpDosDevicesPrefix), RTL_CONST_CAST(PUNICODE_STRING)(Path), TRUE)) {
        *RootType = RTLP_BAD_DOS_ROOT_PATH_NT_PATH;
        goto Exit;
    }

    if (!RTL_IS_PATH_SEPERATOR(Path->Buffer[1])) {
        *RootType = RTLP_GOOD_DOS_ROOT_PATH;
        goto Exit;
    }

    // == \\?
    if (RtlEqualUnicodeString(Path, &RtlpWin32NtRoot, TRUE)) {
        *RootType = RTLP_BAD_DOS_ROOT_PATH_WIN32NT_PREFIX;
        goto Exit;
    }
    if (RtlEqualUnicodeString(Path, &RtlpWin32NtRootSlash, TRUE)) {
        *RootType = RTLP_BAD_DOS_ROOT_PATH_WIN32NT_PREFIX;
        goto Exit;
    }

    // == \\?\unc
    if (RtlEqualUnicodeString(Path, &RtlpWin32NtUncRoot, TRUE)) {
        *RootType = RTLP_BAD_DOS_ROOT_PATH_WIN32NT_UNC_PREFIX;
        goto Exit;
    }
    if (RtlEqualUnicodeString(Path, &RtlpWin32NtUncRootSlash, TRUE)) {
        *RootType = RTLP_BAD_DOS_ROOT_PATH_WIN32NT_UNC_PREFIX;
        goto Exit;
    }

    // prefix \\ or \\?\unc
    // must check the longer string first, or avoid the short circuit (| instead of ||)
    Unc =  (Unc1 = RtlPrefixUnicodeString(RTL_CONST_CAST(PUNICODE_STRING)(&RtlpWin32NtUncRootSlash), RTL_CONST_CAST(PUNICODE_STRING)(Path), TRUE))
        || (Unc2 = RTL_IS_PATH_SEPERATOR(Path->Buffer[1]));
    if (!Unc)  {
        *RootType = RTLP_GOOD_DOS_ROOT_PATH;
        goto Exit;
    }

    //
    // it's unc, see if it is only a machine (note that it'd be really nice if FindFirstFile(\\machine\*)
    // just worked and we didn't have to care..)
    //
    
    // point index at a slash that precedes the machine, anywhere in the run of slashes,
    // but after the \\? stuff
    if (Unc1) {
        Index = (RtlpWin32NtUncRootSlash.Length / sizeof(RtlpWin32NtUncRootSlash.Buffer[0])) - 1;
    } else {
        ASSERT(Unc2);
        Index = 1;
    }
    ASSERT(RTL_IS_PATH_SEPERATOR(Path->Buffer[Index]));
    Length = Path->Length/ sizeof(Path->Buffer[0]);

    //
    // skip leading slashes
    //
    for ( ; Index < Length && RTL_IS_PATH_SEPERATOR(Path->Buffer[Index]) ; ++Index) {
        PiecesSeen |= 1;
    }
    // skip the machine name
    for ( ; Index < Length && !RTL_IS_PATH_SEPERATOR(Path->Buffer[Index]) ; ++Index) {
        PiecesSeen |= 2;
    }
    // skip the slashes between machine and share
    for ( ; Index < Length && RTL_IS_PATH_SEPERATOR(Path->Buffer[Index]) ; ++Index) {
        PiecesSeen |= 4;
    }
    // skip the share (make sure it's at least one char)
    for ( ; Index < Length && !RTL_IS_PATH_SEPERATOR(Path->Buffer[Index]) ; ++Index) {
        PiecesSeen |= 8;
        break;
    }
    if (PiecesSeen != 0xF) {
        *RootType = RTLP_BAD_DOS_ROOT_PATH_MACHINE_NO_SHARE;
        goto Exit;
    }

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

NTSTATUS
NTAPI
RtlpBadDosRootPathToEmptyString(
    IN     ULONG            Flags,
    IN OUT PUNICODE_STRING  Path
    )
/*++

Routine Description:

    
Arguments:

    Flags - room for future binary compatible expansion

    Path - the path to be checked and possibly emptied

Return Value:

    STATUS_SUCCESS - 
    STATUS_INVALID_PARAMETER -
        Path is NULL
        or Flags uses undefined values
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG     RootType = 0;

    if (!NT_SUCCESS(Status = RtlpCheckForBadDosRootPath(0, Path, &RootType))) {
        goto Exit;
    }
    //
    // this is not invalid parameter, our contract is we go \\machine\share to empty
    // \\?\c: to empty, etc.
    //
    if (RootType != RTLP_GOOD_DOS_ROOT_PATH) {
        if (RootType == RTLP_BAD_DOS_ROOT_PATH_NT_PATH) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
        Path->Length = 0;
    }
    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

NTSTATUS
NTAPI
RtlGetLengthWithoutLastFullDosPathElement(
    IN  ULONG            Flags,
    IN  PCUNICODE_STRING Path,
    OUT ULONG*           LengthOut
    )
/*++

Routine Description:

    Given a fulldospath, like c:\, \\machine\share, \\?\unc\machine\share, \\?\c:,
    return (in an out parameter) the length if the last element was cut off.

Arguments:

    Flags - room for future binary compatible expansion

    Path - the path to be truncating

    LengthOut - the length if the last path element is removed

Return Value:

    STATUS_SUCCESS - 
    STATUS_INVALID_PARAMETER -
        Path is NULL
        or LengthOut is NULL
        or Flags uses undefined values
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING CheckRootString = { 0 };

    //
    // parameter validation is done in RtlpGetLengthWithoutLastPathElement
    //

    Status = RtlpGetLengthWithoutLastPathElement(Flags, RTLP_LAST_PATH_ELEMENT_PATH_TYPE_FULL_DOS, Path, LengthOut);
    if (!(NT_SUCCESS(Status))) {
        goto Exit;
    }

    CheckRootString.Buffer = Path->Buffer;
    CheckRootString.Length = (USHORT)(*LengthOut * sizeof(*Path->Buffer));
    CheckRootString.MaximumLength = CheckRootString.Length;
    if (!NT_SUCCESS(Status = RtlpBadDosRootPathToEmptyString(0, &CheckRootString))) {
        goto Exit;
    }
    *LengthOut = RTL_STRING_GET_LENGTH_CHARS(&CheckRootString);

    Status = STATUS_SUCCESS;
Exit:
    KdPrintEx((
        DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status),
        "%s(%d):%s(%wZ): 0x%08lx\n", __FILE__, __LINE__, __FUNCTION__, Path, Status));
    return Status;
}

NTSTATUS
NTAPI
RtlAppendPathElement(
    IN     ULONG                      Flags,
    IN OUT PRTL_UNICODE_STRING_BUFFER Path,
    PCUNICODE_STRING                  ConstElement
    )
/*++

Routine Description:

    This function appends a path element to a path.
    For now, like:
        typedef PRTL_UNICODE_STRING_BUFFER PRTL_MUTABLE_PATH;
        typedef PCUNICODE_STRING           PCRTL_CONSTANT_PATH_ELEMENT;
    Maybe something higher level in the future.
    
    The result with regard to trailing slashes aims to be similar to the inputs.
    If either Path or ConstElement contains a trailing slash, the result has a trailing slash.
    The character used for the in between and trailing slash is picked among the existing
    slashes in the strings.

Arguments:

    Flags - the ever popular "room for future binary compatible expansion"

    Path -
        a string representing a path using \\ or / as seperators

    ConstElement -
        a string representing a path element
        this can actually contain multiple \\ or / delimited path elements
          only the start and end of the string are examined for slashes

Return Value:

    STATUS_SUCCESS - 
    STATUS_INVALID_PARAMETER -
        Path is NULL
        or LengthOut is NULL
    STATUS_NO_MEMORY - RtlHeapAllocate failed
    STATUS_NAME_TOO_LONG - the resulting string does not fit in a UNICODE_STRING, due to its
        use of USHORT instead of ULONG or SIZE_T
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING InBetweenSlashString = RtlpEmptyString;
    UNICODE_STRING TrailingSlashString =  RtlpEmptyString;
    WCHAR Slashes[] = {0,0,0,0};
    ULONG i;
    UNICODE_STRING PathsToAppend[3]; // possible slash, element, possible slash
    WCHAR PathSeperators[2] = { '/', '\\' };

#define LOCAL_IS_PATH_SEPERATOR(ch_) ((ch_) == PathSeperators[0] || (ch_) == PathSeperators[1])

    if (   !RTL_SOFT_VERIFY((Flags & ~(RTL_APPEND_PATH_ELEMENT_ONLY_BACKSLASH_IS_SEPERATOR)) == 0)
        || !RTL_SOFT_VERIFY(Path != NULL)
        || !RTL_SOFT_VERIFY(ConstElement != NULL)
        ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if ((Flags & RTL_APPEND_PATH_ELEMENT_ONLY_BACKSLASH_IS_SEPERATOR) != 0) {
        PathSeperators[0] = '\\';
    }

    if (ConstElement->Length != 0) {

        UNICODE_STRING Element = *ConstElement;

        //
        // Note leading and trailing slashes on the inputs.
        // So that we know if an in-between slash is needed, and if a trailing slash is needed,
        // and to guide what sort of slash to place.
        //
        i = 0;
        if (Path->String.Length != 0) {
            ULONG j;
            ULONG Length = Path->String.Length / sizeof(WCHAR);
            //
            // for the sake for dos drive paths, check the first three chars for a slash
            //
            for (j = 0 ; j < 3 && j  < Length ; ++j) {
                if (LOCAL_IS_PATH_SEPERATOR(Path->String.Buffer[j])) {
                    Slashes[i] = Path->String.Buffer[0];
                    break;
                }
            }
            i += 1;
            if (LOCAL_IS_PATH_SEPERATOR(Path->String.Buffer[Path->String.Length/sizeof(WCHAR) - 1])) {
                Slashes[i] = Path->String.Buffer[Path->String.Length/sizeof(WCHAR) - 1];
            }
        }
        i = 2;
        if (LOCAL_IS_PATH_SEPERATOR(Element.Buffer[0])) {
            Slashes[i] = Element.Buffer[0];
        }
        i += 1;
        if (LOCAL_IS_PATH_SEPERATOR(Element.Buffer[Element.Length/sizeof(WCHAR) - 1])) {
            Slashes[i] = Element.Buffer[Element.Length/sizeof(WCHAR) - 1];
        }

        if (!Slashes[1] && !Slashes[2]) {
            //
            // first string lacks trailing slash and second string lacks leading slash,
            // must insert one; we favor the types we have, otherwise use a default
            //
            InBetweenSlashString.Length = sizeof(WCHAR);
            InBetweenSlashString.Buffer = RtlPathSeperatorString.Buffer;
            if ((Flags & RTL_APPEND_PATH_ELEMENT_ONLY_BACKSLASH_IS_SEPERATOR) == 0) {
                if (Slashes[3]) {
                    InBetweenSlashString.Buffer = &Slashes[3];
                } else if (Slashes[0]) {
                    InBetweenSlashString.Buffer = &Slashes[0];
                }
            }
        }

        if (Slashes[1] && !Slashes[3]) {
            //
            // first string has a trailing slash and second string does not,
            // must add one, the same type
            //
            TrailingSlashString.Length = sizeof(WCHAR);
            if ((Flags & RTL_APPEND_PATH_ELEMENT_ONLY_BACKSLASH_IS_SEPERATOR) == 0) {
                TrailingSlashString.Buffer = &Slashes[1];
            } else {
                TrailingSlashString.Buffer = RtlPathSeperatorString.Buffer;
            }
        }

        if (Slashes[1] && Slashes[2]) {
            //
            // have both trailing and leading slash, remove leading
            //
            Element.Buffer += 1;
            Element.Length -= sizeof(WCHAR);
            Element.MaximumLength -= sizeof(WCHAR);
        }

        i = 0;
        PathsToAppend[i++] = InBetweenSlashString;
        PathsToAppend[i++] = Element;
        PathsToAppend[i++] = TrailingSlashString;
        Status = RtlMultiAppendUnicodeStringBuffer(Path, RTL_NUMBER_OF(PathsToAppend), PathsToAppend);
        if (!NT_SUCCESS(Status))
            goto Exit;
    }
    Status = STATUS_SUCCESS;
Exit:
    KdPrintEx((
        DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status),
        "%s(%d):%s(%wZ, %wZ): 0x%08lx\n", __FILE__, __LINE__, __FUNCTION__, Path ? &Path->String : NULL, ConstElement, Status));
    return Status;
#undef LOCAL_IS_PATH_SEPERATOR
}

NTSTATUS
NTAPI
RtlGetLengthWithoutTrailingPathSeperators(
    IN  ULONG            Flags,
    IN  PCUNICODE_STRING Path,
    OUT ULONG*           LengthOut
    )
/*++

Routine Description:

    This function computes the length of the string (in characters) if
    trailing path seperators (\\ and /) are removed.

Arguments:

    Path -
        a string representing a path using \\ or / as seperators

    LengthOut -
        the length of String (in characters) having removed trailing characters

Return Value:

    STATUS_SUCCESS - 
    STATUS_INVALID_PARAMETER -
        Path is NULL
        or LengthOut is NULL
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index = 0;
    ULONG Length = 0;

    if (LengthOut != NULL) {
        //
        // Arguably this should be Path->Length / sizeof(*Path->Buffer), but as long
        // as the callstack is all high quality code, it doesn't matter.
        //
        *LengthOut = 0;
    }
    if (   !RTL_SOFT_VERIFY(Path != NULL)
        || !RTL_SOFT_VERIFY(LengthOut != NULL)
        || !RTL_SOFT_VERIFY(Flags == 0)
        ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    Length = Path->Length / sizeof(*Path->Buffer);
    for (Index = Length ; Index != 0 ; --Index) {
        if (!RTL_IS_PATH_SEPERATOR(Path->Buffer[Index - 1])) {
            break;
        }
    }
    //*LengthOut = (Length - Index);
    *LengthOut = Index;
    Status = STATUS_SUCCESS;
Exit:
    KdPrintEx((
        DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status),
        "%s(%d):%s(%wZ): 0x%08lx\n", __FILE__, __LINE__, __FUNCTION__, Path, Status));
    return Status;
}

NTSTATUS
NTAPI
RtlpApplyLengthFunction(
    IN ULONG     Flags,
    IN SIZE_T    SizeOfStruct,
    IN OUT PVOID UnicodeStringOrUnicodeStringBuffer,
    NTSTATUS (NTAPI* LengthFunction)(ULONG, PCUNICODE_STRING, ULONG*)
    )
/*++

Routine Description:

    This function is common code for patterns like
        #define RtlRemoveTrailingPathSeperators(Path_) \
            (RtlpApplyLengthFunction((Path_), sizeof(*(Path_)), RtlGetLengthWithoutTrailingPathSeperators))

    #define RtlRemoveLastPathElement(Path_) \
        (RtlpApplyLengthFunction((Path_), sizeof(*(Path_)), RtlGetLengthWithoutLastPathElement))

    Note that shortening a UNICODE_STRING only changes the length, whereas
    shortening a RTL_UNICODE_STRING_BUFFER writes a terminal nul.

    I expect this pattern will be less error prone than having clients pass the UNICODE_STRING
    contained in the RTL_UNICODE_STRING_BUFFER followed by calling RTL_NUL_TERMINATE_STRING.

    And, that pattern cannot be inlined with a macro while also preserving that we
    return an NTSTATUS.

Arguments:

    Flags - the ever popular "room for future binary compatible expansion"

    UnicodeStringOrUnicodeStringBuffer - 
        a PUNICODE_STRING or PRTL_UNICODE_STRING_BUFFER, as indicated by
        SizeOfStruct

    SizeOfStruct - 
        a rough type indicator of UnicodeStringOrUnicodeStringBuffer, to allow for overloading in C

    LengthFunction -
        computes a length for UnicodeStringOrUnicodeStringBuffer to be shortened too

Return Value:

    STATUS_SUCCESS - 
    STATUS_INVALID_PARAMETER -
        SizeOfStruct not one of the expected sizes
        or LengthFunction is NULL
        or UnicodeStringOrUnicodeStringBuffer is NULL


--*/
{
    PUNICODE_STRING UnicodeString = NULL;
    PRTL_UNICODE_STRING_BUFFER UnicodeStringBuffer = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Length = 0;

    if (!RTL_SOFT_VERIFY(UnicodeStringOrUnicodeStringBuffer != NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (!RTL_SOFT_VERIFY(LengthFunction != NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (!RTL_SOFT_VERIFY(Flags == 0)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    switch (SizeOfStruct)
    {
        default:
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        case sizeof(*UnicodeString):
            UnicodeString = UnicodeStringOrUnicodeStringBuffer;
            break;
        case sizeof(*UnicodeStringBuffer):
            UnicodeStringBuffer = UnicodeStringOrUnicodeStringBuffer;
            UnicodeString = &UnicodeStringBuffer->String;
            break;
    }

    Status = (*LengthFunction)(Flags, UnicodeString, &Length);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }
    UnicodeString->Length = (USHORT)(Length * sizeof(UnicodeString->Buffer[0]));
    if (UnicodeStringBuffer != NULL) {
        RTL_NUL_TERMINATE_STRING(UnicodeString);
    }
    Status = STATUS_SUCCESS;
Exit:
    KdPrintEx((
        DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status),
        "%s(%d):%s(%wZ): 0x%08lx\n", __FILE__, __LINE__, __FUNCTION__, UnicodeString, Status));
    return Status;
}

NTSTATUS
NTAPI
RtlNtPathNameToDosPathName(
    IN     ULONG                      Flags,
    IN OUT PRTL_UNICODE_STRING_BUFFER Path,
    OUT    ULONG*                     Disposition OPTIONAL,
    IN OUT PWSTR*                     FilePart OPTIONAL
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    SIZE_T NtFilePartOffset = 0;
    SIZE_T DosFilePartOffset = 0;
    BOOLEAN Unc = FALSE;
    const static UNICODE_STRING DosUncPrefix = RTL_CONSTANT_STRING(L"\\\\");
    PCUNICODE_STRING NtPrefix = NULL;
    PCUNICODE_STRING DosPrefix = NULL;
    RTL_STRING_LENGTH_TYPE Cch = 0;

    if (ARGUMENT_PRESENT(Disposition)) {
        *Disposition = 0;
    }

    if (   !RTL_SOFT_VERIFY(Path != NULL)
        || !RTL_SOFT_VERIFY(Flags == 0)
        ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (ARGUMENT_PRESENT(FilePart) && *FilePart != NULL) {
        NtFilePartOffset = *FilePart - Path->String.Buffer;
        if (!RTL_SOFT_VERIFY(NtFilePartOffset < RTL_STRING_GET_LENGTH_CHARS(&Path->String))
            ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
    }

    if (RtlPrefixUnicodeString(RTL_CONST_CAST(PUNICODE_STRING)(&RtlpDosDevicesUncPrefix), &Path->String, TRUE)
        ) {
        NtPrefix = &RtlpDosDevicesUncPrefix;
        DosPrefix = &DosUncPrefix;
        if (ARGUMENT_PRESENT(Disposition)) {
            *Disposition = RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_UNC;
        }
    }
    else if (RtlPrefixUnicodeString(RTL_CONST_CAST(PUNICODE_STRING)(&RtlpDosDevicesPrefix), &Path->String, TRUE)
        ) {
        NtPrefix = &RtlpDosDevicesPrefix;
        DosPrefix = &RtlpEmptyString;
        if (ARGUMENT_PRESENT(Disposition)) {
            *Disposition = RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_DRIVE;
        }
    }
    else {
        //
        // It is not recognizably an Nt path produced by RtlDosPathNameToNtPathName_U.
        //
        if (ARGUMENT_PRESENT(Disposition)) {
            RTL_PATH_TYPE PathType = RtlDetermineDosPathNameType_Ustr(&Path->String);
            switch (PathType) {
                case RtlPathTypeUnknown:
                case RtlPathTypeRooted: // NT paths are identified as this
                    *Disposition = RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_AMBIGUOUS;
                    break;

                //
                // "already" dospaths, but not gotten from this function, let's
                // give a less good disposition
                //
                case RtlPathTypeDriveRelative:
                case RtlPathTypeRelative:
                    *Disposition = RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_AMBIGUOUS;
                    break;

                // these are pretty clearly dospaths already
                case RtlPathTypeUncAbsolute:
                case RtlPathTypeDriveAbsolute:
                case RtlPathTypeLocalDevice: // "\\?\" or "\\.\" or "\\?\blah" or "\\.\blah" 
                case RtlPathTypeRootLocalDevice: // "\\?" or "\\."
                    *Disposition = RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_ALREADY_DOS;
                    break;
            }
        }
        goto Exit;
    }

    Cch =
              RTL_STRING_GET_LENGTH_CHARS(&Path->String)
            + RTL_STRING_GET_LENGTH_CHARS(DosPrefix)
            - RTL_STRING_GET_LENGTH_CHARS(NtPrefix);

    Status =
        RtlEnsureUnicodeStringBufferSizeChars(Path, Cch);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    //
    // overlapping buffer shuffle...careful.
    //
    RtlMoveMemory(
        Path->String.Buffer + RTL_STRING_GET_LENGTH_CHARS(DosPrefix),
        Path->String.Buffer + RTL_STRING_GET_LENGTH_CHARS(NtPrefix),
        Path->String.Length - NtPrefix->Length
        );
    RtlMoveMemory(
        Path->String.Buffer,
        DosPrefix->Buffer,
        DosPrefix->Length
        );
    Path->String.Length = Cch * sizeof(Path->String.Buffer[0]);
    RTL_NUL_TERMINATE_STRING(&Path->String);

    if (NtFilePartOffset != 0) {
        // review/test..
        *FilePart = Path->String.Buffer + (NtFilePartOffset - RTL_STRING_GET_LENGTH_CHARS(NtPrefix) + RTL_STRING_GET_LENGTH_CHARS(DosPrefix));
    }
    Status = STATUS_SUCCESS;
Exit:
    KdPrintEx((
        DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status),
        "%s(%d):%s(%wZ): 0x%08lx\n", __FILE__, __LINE__, __FUNCTION__, Path, Status));
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\ldrp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ldrp.h

Abstract:

    Private types... for executive portion of loader

Author:

    Mark Lucovsky (markl) 26-Mar-1990

Revision History:

--*/

#ifndef _LDRP_
#define _LDRP_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <string.h>
#define NOEXTAPI
#include "wdbgexts.h"
#include <ntdbg.h>
#include <sxstypes.h>

#if defined(_WIN64)
extern INVERTED_FUNCTION_TABLE LdrpInvertedFunctionTable;
#endif

#if DBG
#define LdrpShouldDbgPrintStatus(st) \
    (!NT_SUCCESS(st) \
        && (ShowSnaps \
            || (   (st) != STATUS_NO_SUCH_FILE \
                && (st) != STATUS_DLL_NOT_FOUND \
                && (st) != STATUS_OBJECT_NAME_NOT_FOUND \
                )))
#else
#define LdrpShouldDbgPrintStatus(st) (FALSE)
#endif

#if DBG
#define LDR_ERROR_DPFLTR DPFLTR_ERROR_LEVEL
#else
#define LDR_ERROR_DPFLTR ((ShowSnaps || ShowErrors) ? DPFLTR_ERROR_LEVEL : DPFLTR_INFO_LEVEL)
#endif // DBG

extern BOOLEAN LdrpImageHasTls;
extern UNICODE_STRING LdrpDefaultPath;
HANDLE LdrpKnownDllObjectDirectory;
#define LDRP_MAX_KNOWN_PATH 128
WCHAR LdrpKnownDllPathBuffer[LDRP_MAX_KNOWN_PATH];
UNICODE_STRING LdrpKnownDllPath;
extern PLDR_MANIFEST_PROBER_ROUTINE LdrpManifestProberRoutine;
extern PLDR_APP_COMPAT_DLL_REDIRECTION_CALLBACK_FUNCTION LdrpAppCompatDllRedirectionCallbackFunction;
extern PVOID LdrpAppCompatDllRedirectionCallbackData;
extern PVOID LdrpHeap;
extern RTL_CRITICAL_SECTION LdrpLoaderLock;
extern PCUNICODE_STRING LdrpTopLevelDllBeingLoaded;
extern PTEB LdrpTopLevelDllBeingLoadedTeb;
extern BOOLEAN LdrpBreakOnExceptions;
extern PLDR_DATA_TABLE_ENTRY LdrpNtDllDataTableEntry;
extern PLDR_DATA_TABLE_ENTRY LdrpCurrentDllInitializer;
extern BOOLEAN LdrpShowInitRoutines;
extern BOOLEAN LdrpShowRecursiveDllLoads;
extern BOOLEAN LdrpBreakOnRecursiveDllLoads;
extern BOOLEAN LdrpLoaderLockAcquisionCount;


#define ASCII_CHAR_IS_N(_ch) (((_ch) == 'n') || ((_ch) == 'N'))
#define ASCII_CHAR_IS_T(_ch) (((_ch) == 't') || ((_ch) == 'T'))
#define ASCII_CHAR_IS_D(_ch) (((_ch) == 'd') || ((_ch) == 'D'))
#define ASCII_CHAR_IS_L(_ch) (((_ch) == 'l') || ((_ch) == 'L'))
#define ASCII_CHAR_IS_DOT(_ch) ((_ch) == '.')

#define ASCII_STRING_IS_NTDLL(_p) \
    ((_p) != NULL) && \
    (((_p)->Length == (5 * sizeof(CHAR))) && \
     (ASCII_CHAR_IS_N((_p)->Buffer[0]) && \
      ASCII_CHAR_IS_T((_p)->Buffer[1]) && \
      ASCII_CHAR_IS_D((_p)->Buffer[2]) && \
      ASCII_CHAR_IS_L((_p)->Buffer[3]) && \
      ASCII_CHAR_IS_L((_p)->Buffer[4])) || \
     ((_p)->Length == ((5 + 1 + 3) * sizeof(CHAR))) && \
     (ASCII_CHAR_IS_N((_p)->Buffer[0]) && \
      ASCII_CHAR_IS_T((_p)->Buffer[1]) && \
      ASCII_CHAR_IS_D((_p)->Buffer[2]) && \
      ASCII_CHAR_IS_L((_p)->Buffer[3]) && \
      ASCII_CHAR_IS_L((_p)->Buffer[4]) && \
      ASCII_CHAR_IS_DOT((_p)->Buffer[5]) && \
      ASCII_CHAR_IS_D((_p)->Buffer[6]) && \
      ASCII_CHAR_IS_L((_p)->Buffer[7]) && \
      ASCII_CHAR_IS_L((_p)->Buffer[8])))
      
//
// + 1 is to preserve that code was using 266
// after explaining why it should be 265. Note
// that sizeof("") includes a nul.
//   DOS_MAX_PATH_LENGTH is 260 (Win32 MAX_PATH)
//   LDR_MAX_PATH is 266
// We will be removing path length limits in the
// ldr in the future.
//
// a-JayK August 2000
//

#define LDR_MAX_PATH (DOS_MAX_PATH_LENGTH + sizeof("\\??\\") + 1)

LIST_ENTRY RtlpCalloutEntryList;

#if defined(_AMD64_) || defined(_IA64_)

extern LIST_ENTRY RtlpDynamicFunctionTable;

#endif

RTL_CRITICAL_SECTION RtlpCalloutEntryLock;

typedef struct _LDRP_DLL_NOTIFICATION_BLOCK {
    LIST_ENTRY Links;
    PLDR_DLL_NOTIFICATION_FUNCTION NotificationFunction;
    PVOID Context;
} LDRP_DLL_NOTIFICATION_BLOCK, *PLDRP_DLL_NOTIFICATION_BLOCK;

//
//  Synchronized via LdrpLoaderLock
//

LIST_ENTRY LdrpDllNotificationList;

#define LDR_NUMBER_OF(x) (sizeof(x) / sizeof((x)[0]))

#if defined (BUILD_WOW6432)
NTSTATUS
LdrpWx86FormatVirtualImage(
    IN PUNICODE_STRING DosImagePathName OPTIONAL,
    IN PIMAGE_NT_HEADERS32 NtHeaders,
    IN PVOID DllBase
    );

NTSTATUS
Wx86SetRelocatedSharedProtection (
    IN PVOID Base,
    IN BOOLEAN Reset
    );

ULONG
LdrpWx86RelocatedFixupDiff(
    IN PUCHAR ImageBase,
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN ULONG  Offset
    );

BOOLEAN
LdrpWx86DllHasRelocatedSharedSection(
    IN PUCHAR ImageBase);

#define NATIVE_PAGE_SIZE  0x2000
#define NATIVE_PAGE_SHIFT 13L
#define NATIVE_BYTES_TO_PAGES(Size)  ((ULONG)((ULONG_PTR)(Size) >> NATIVE_PAGE_SHIFT) + \
                                    (((ULONG)(Size) & (NATIVE_PAGE_SIZE - 1)) != 0))
#else
#define NATIVE_PAGE_SIZE  PAGE_SIZE
#define NATIVE_PAGE_SHIFT PAGE_SHIFT
#define NATIVE_BYTES_TO_PAGES(Size) BYTES_TO_PAGES(Size)
#endif

VOID
RtlpWaitForCriticalSection (
    IN PRTL_CRITICAL_SECTION CriticalSection
    );

VOID
RtlpUnWaitCriticalSection (
    IN PRTL_CRITICAL_SECTION CriticalSection
    );

#define LDRP_HASH_TABLE_SIZE 32
#define LDRP_HASH_MASK       (LDRP_HASH_TABLE_SIZE-1)
#define LDRP_COMPUTE_HASH_INDEX(wch) ( (RtlUpcaseUnicodeChar((wch)) - (WCHAR)'A') & LDRP_HASH_MASK )
LIST_ENTRY LdrpHashTable[LDRP_HASH_TABLE_SIZE];


// LDRP_BAD_DLL Sundown: sign-extended value.
#define LDRP_BAD_DLL LongToPtr(0xffbadd11)

LIST_ENTRY LdrpDefaultPathCache;
typedef struct _LDRP_PATH_CACHE {
    LIST_ENTRY Links;
    UNICODE_STRING Component;
    HANDLE Directory;
} LDRP_PATH_CACHE, *PLDRP_PATH_CACHE;


NTSTATUS
LdrpSnapIAT(
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry_Export,
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry_Import,
    IN PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor,
    IN BOOLEAN SnapForwardersOnly
    );

NTSTATUS
LdrpSnapThunk(
    IN PVOID DllBase,
    IN PVOID ImageBase,
    IN PIMAGE_THUNK_DATA OriginalThunk,
    IN OUT PIMAGE_THUNK_DATA Thunk,
    IN PIMAGE_EXPORT_DIRECTORY ExportDirectory,
    IN ULONG ExportSize,
    IN BOOLEAN StaticSnap,
    IN PSZ DllName OPTIONAL
    );

USHORT
LdrpNameToOrdinal(
    IN PSZ Name,
    IN ULONG NumberOfNames,
    IN PVOID DllBase,
    IN PULONG NameTableBase,
    IN PUSHORT NameOrdinalTableBase
    );

PLDR_DATA_TABLE_ENTRY
LdrpAllocateDataTableEntry(
    IN PVOID DllBase
    );

VOID
LdrpDeallocateDataTableEntry(
    IN PLDR_DATA_TABLE_ENTRY Entry
    );

VOID
LdrpFinalizeAndDeallocateDataTableEntry(
    IN PLDR_DATA_TABLE_ENTRY Entry
    );

BOOLEAN
LdrpCheckForLoadedDll(
    IN PWSTR DllPath OPTIONAL,
    IN PUNICODE_STRING DllName,
    IN BOOLEAN StaticLink,
    IN BOOLEAN Redirected,
    OUT PLDR_DATA_TABLE_ENTRY *LdrDataTableEntry
    );

BOOLEAN
LdrpCheckForLoadedDllHandle(
    IN PVOID DllHandle,
    OUT PLDR_DATA_TABLE_ENTRY *LdrDataTableEntry
    );

NTSTATUS
LdrpMapDll(
    IN PWSTR DllPath OPTIONAL,
    IN PWSTR DllName,
    IN PULONG DllCharacteristics OPTIONAL,
    IN BOOLEAN StaticLink,
    IN BOOLEAN Redirected,
    OUT PLDR_DATA_TABLE_ENTRY *LdrDataTableEntry
    );

NTSTATUS
LdrpWalkImportDescriptor(
    IN PWSTR DllPath OPTIONAL,
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    );

NTSTATUS
LdrpRunInitializeRoutines(
    IN PCONTEXT Context OPTIONAL
    );

int
LdrpInitializeProcessWrapperFilter(
    IN const struct _EXCEPTION_POINTERS *ExceptionPointers
    );

int
LdrpGenericExceptionFilter(
    IN const struct _EXCEPTION_POINTERS *ExceptionPointers,
    IN PCSTR FunctionName
    );


//
//  These functions are VOID because they should really never be able to fail.
//
//  In the current implementation, they do perform ANSI -> UNICODE conversions
//  which may fail in the current code page (may have been changed since when
//  the DLL was loaded) and apply Fusion DLL redirection to DLLs which can
//  require a large filename buffer than is allocated on the stack.
//
//  These cases are ignored for now.  Both problems should be fixed by
//  reworking the LDR_DATA_TABLE_ENTRY to have an array of pointers to the
//  downstream LDR_DATA_TABLE_ENTRY structs and not have to do any work
//  later on, but that's a lot of work for now; the ANSI -> UNICODE thing
//  has been there for ages and in practice, the paths that Fusion
//  redirects to have to fix in DOS_MAX_PATH_LENGTH, so we'll emit some
//  debug spew in the failure case, but ignore the failures.
//
//  I started both fixes (returning status or allocating the array
//  at dll load time) but neither are trivial.  Returning a status will just
//  make FreeLibrary() fail and leave the refcounts of the DLLs after the
//  one that failed inconsistent.  Allocating the array is nontrivial
//  to do it the right way where the LDR_DATA_TABLE_ENTRY and the array
//  are allocated in a single allocation, and having the loader make more
//  even heap allocations seems like the wrong thing to do.
//
//  -mgrier 11/20/2000
//


/*
VOID
LdrpReferenceLoadedDll(
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    );

VOID
LdrpDereferenceLoadedDll(
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    );

VOID
LdrpPinLoadedDll(
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    );
*/
#define LdrpReferenceLoadedDll(LdrDataTableEntry) LdrpUpdateLoadCount2(LdrDataTableEntry, LDRP_UPDATE_LOAD_COUNT_INCREMENT)
#define LdrpDereferenceLoadedDll(LdrDataTableEntry) LdrpUpdateLoadCount2(LdrDataTableEntry, LDRP_UPDATE_LOAD_COUNT_DECREMENT)
#define LdrpPinLoadedDll(LdrDataTableEntry) LdrpUpdateLoadCount2(LdrDataTableEntry, LDRP_UPDATE_LOAD_COUNT_PIN)

#define LDRP_UPDATE_LOAD_COUNT_INCREMENT (1)
#define LDRP_UPDATE_LOAD_COUNT_DECREMENT (2)
#define LDRP_UPDATE_LOAD_COUNT_PIN       (3)

VOID
LdrpUpdateLoadCount3(
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry,
    IN ULONG UpdateCountHow,
    IN OUT PUNICODE_STRING PreAllocatedRedirectionBuffer OPTIONAL
    );

VOID
LdrpUpdateLoadCount2(
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry,
    IN ULONG UpdateCountHow
    );

NTSTATUS
LdrpInitializeProcess(
    IN PCONTEXT Context OPTIONAL,
    IN PVOID SystemDllBase,
    IN PUNICODE_STRING UnicodeImageName,
    IN BOOLEAN UseCOR,
    IN BOOLEAN ImageFileOptionsPresent
    );

VOID
LdrpInitialize(
    IN PCONTEXT Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
LdrpInsertMemoryTableEntry(
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    );

NTSTATUS
LdrpResolveDllName(
    IN PWSTR DllPath OPTIONAL,
    IN PWSTR DllName,
    IN BOOLEAN Redirected,
    OUT PUNICODE_STRING FullDllName,
    OUT PUNICODE_STRING BaseDllName,
    OUT PHANDLE DllFile
    );

NTSTATUS
LdrpResolveDllNameForAppPrivateRedirection(
    IN PCUNICODE_STRING DllName,
    OUT PUNICODE_STRING FullDllName
    );

NTSTATUS
LdrpCreateDllSection(
    IN PUNICODE_STRING FullDllName,
    IN HANDLE DllFile,
    IN PUNICODE_STRING BaseName,
    IN PULONG DllCharacteristics OPTIONAL,
    OUT PHANDLE SectionHandle
    );

VOID
LdrpInitializePathCache(
    VOID
    );

PVOID
LdrpFetchAddressOfEntryPoint(
    IN PVOID Base
    );

NTSTATUS
LdrpCheckForKnownDll(
    IN PWSTR DllName,
    OUT PUNICODE_STRING FullDllName,
    OUT PUNICODE_STRING BaseDllName,
    OUT HANDLE *Section
    );

NTSTATUS
LdrpSetProtection(
    IN PVOID Base,
    IN BOOLEAN Reset,
    IN BOOLEAN StaticLink
    );

#if DBG
ULONG LdrpCompareCount;
ULONG LdrpSnapBypass;
ULONG LdrpNormalSnap;
ULONG LdrpSectionOpens;
ULONG LdrpSectionCreates;
ULONG LdrpSectionMaps;
ULONG LdrpSectionRelocates;
BOOLEAN LdrpDisplayLoadTime;
LARGE_INTEGER BeginTime, InitcTime, InitbTime, IniteTime, EndTime, ElapsedTime, Interval;

#endif // DBG

extern BOOLEAN ShowSnaps;
extern BOOLEAN ShowErrors;
BOOLEAN RtlpTimoutDisable;
LARGE_INTEGER RtlpTimeout;
ULONG NtGlobalFlag;
LIST_ENTRY RtlCriticalSectionList;
RTL_CRITICAL_SECTION RtlCriticalSectionLock;
BOOLEAN LdrpShutdownInProgress;
extern BOOLEAN LdrpInLdrInit;
extern BOOLEAN LdrpLdrDatabaseIsSetup;
extern BOOLEAN LdrpVerifyDlls;
extern BOOLEAN LdrpShutdownInProgress;
extern BOOLEAN LdrpImageHasTls;
extern BOOLEAN LdrpVerifyDlls;

PLDR_DATA_TABLE_ENTRY LdrpImageEntry;
LIST_ENTRY LdrpUnloadHead;
BOOLEAN LdrpActiveUnloadCount;
PLDR_DATA_TABLE_ENTRY LdrpGetModuleHandleCache;
PLDR_DATA_TABLE_ENTRY LdrpLoadedDllHandleCache;
ULONG LdrpFatalHardErrorCount;
UNICODE_STRING LdrpDefaultPath;
RTL_CRITICAL_SECTION FastPebLock;
HANDLE LdrpShutdownThreadId;
PLDR_DATA_TABLE_ENTRY LdrpImageEntry;
ULONG LdrpNumberOfProcessors;
extern UNICODE_STRING DefaultExtension;
extern UNICODE_STRING User32String;
extern UNICODE_STRING Kernel32String;

typedef struct _LDRP_TLS_ENTRY {
    LIST_ENTRY Links;
    IMAGE_TLS_DIRECTORY Tls;
} LDRP_TLS_ENTRY, *PLDRP_TLS_ENTRY;

LIST_ENTRY LdrpTlsList;
ULONG LdrpNumberOfTlsEntries;

NTSTATUS
LdrpInitializeTls(
        VOID
        );

NTSTATUS
LdrpAllocateTls(
        VOID
        );
VOID
LdrpFreeTls(
        VOID
        );

VOID
LdrpCallTlsInitializers(
    PVOID DllBase,
    ULONG Reason
    );

NTSTATUS
LdrpAllocateUnicodeString(
    OUT PUNICODE_STRING StringOut,
    IN USHORT Length
    );

NTSTATUS
LdrpCopyUnicodeString(
    OUT PUNICODE_STRING StringOut,
    IN PCUNICODE_STRING StringIn
    );

VOID
LdrpFreeUnicodeString(
    IN OUT PUNICODE_STRING String
    );

VOID
LdrpEnsureLoaderLockIsHeld(
    VOID
    );

#define LDRP_LOAD_DLL_FLAG_DLL_IS_REDIRECTED (0x00000001)

NTSTATUS
LdrpLoadDll(
    IN ULONG Flags OPTIONAL,
    IN PWSTR DllPath OPTIONAL,
    IN PULONG DllCharacteristics OPTIONAL,
    IN PUNICODE_STRING DllName,
    OUT PVOID *DllHandle,
    IN BOOLEAN RunInitRoutines
    );

NTSTATUS
NTAPI
LdrpGetProcedureAddress(
    IN PVOID DllHandle,
    IN CONST ANSI_STRING* ProcedureName OPTIONAL,
    IN ULONG ProcedureNumber OPTIONAL,
    OUT PVOID *ProcedureAddress,
    IN BOOLEAN RunInitRoutines
    );

PLIST_ENTRY
RtlpLockProcessHeapsList( VOID );


VOID
RtlpUnlockProcessHeapsList( VOID );

BOOLEAN
RtlpSerializeHeap(
    IN PVOID HeapHandle
    );

ULONG NtdllBaseTag;

#define MAKE_TAG( t ) (RTL_HEAP_MAKE_TAG( NtdllBaseTag, t ))

#define CSR_TAG 0
#define LDR_TAG 1
#define CURDIR_TAG 2
#define TLS_TAG 3
#define DBG_TAG 4
#define SE_TAG 5
#define TEMP_TAG 6
#define ATOM_TAG 7

PVOID
LdrpDefineDllTag(
    PWSTR TagName,
    PUSHORT TagIndex
    );

#define LDRP_ACTIVATE_ACTIVATION_CONTEXT(LdrpDllActivateActivationContext_TableEntry) \
    { \
        RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME LdrpDllActivateActivationContext_ActivationFrame = \
            {   sizeof(LdrpDllActivateActivationContext_ActivationFrame), \
                RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER \
            }; \
     \
        RtlActivateActivationContextUnsafeFast(&LdrpDllActivateActivationContext_ActivationFrame, LdrpDllActivateActivationContext_TableEntry->EntryPointActivationContext); \
        __try {

#define LDRP_DEACTIVATE_ACTIVATION_CONTEXT() \
        } __finally { \
            RtlDeactivateActivationContextUnsafeFast(&LdrpDllActivateActivationContext_ActivationFrame); \
        } \
    }

#if defined(_X86_)
BOOLEAN
LdrpCallInitRoutine(
    IN PDLL_INIT_ROUTINE InitRoutine,
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    );
#else

#define LdrpCallInitRoutine(InitRoutine, DllHandle, Reason, Context)    \
    (InitRoutine)((DllHandle), (Reason), (Context))

#endif

NTSTATUS
LdrpCorValidateImage(
    IN OUT PVOID *pImageBase,
    IN LPWSTR ImageName
    );

VOID
LdrpCorUnloadImage(
    IN PVOID ImageBase
    );

VOID
LdrpCorReplaceStartContext(
    IN PCONTEXT Context
    );

typedef VOID (*PCOR_EXE_MAIN)(VOID);
extern PCOR_EXE_MAIN CorExeMain;

VOID
LdrpSendDllUnloadedNotifications(
    PLDR_DATA_TABLE_ENTRY Entry,
    ULONG Flags
    );

VOID
LdrpSendDllLoadedNotifications(
    PLDR_DATA_TABLE_ENTRY Entry,
    ULONG Flags
    );

//
// The prototypes for the shim engine callback
//

typedef void (*PFNSE_INSTALLBEFOREINIT)(PUNICODE_STRING UnicodeImageName,
                                        PVOID           pShimExeData);

typedef BOOLEAN (*PFNSE_INSTALLAFTERINIT)(PUNICODE_STRING UnicodeImageName,
                                          PVOID           pShimExeData);

typedef void (*PFNSE_DLLLOADED)(PLDR_DATA_TABLE_ENTRY LdrEntry);

typedef void (*PFNSE_DLLUNLOADED)(PLDR_DATA_TABLE_ENTRY LdrEntry);

typedef void (*PFNSE_GETPROCADDRESS)(PVOID* pProcAddress);

typedef int (*PFNSE_ISSHIMDLL)(PVOID pDllBase);

typedef void (*PFNSE_PROCESSDYING)(void);

//
// Private function from ntos\rtl\stktrace.c needed to pickup the real address
// of a stack trace given an index.
//

PVOID
RtlpGetStackTraceAddress (
    USHORT Index
    );

//
// Function defined in ntos\rtl\stktrace.c needed to speedup
// RtlCaptureStackContext on x86.
//

VOID
RtlpStkMarkDllRange (
    PLDR_DATA_TABLE_ENTRY DllEntry
    );

VOID
RtlpCheckForCriticalSectionsInMemoryRange(
    IN PVOID StartAddress,
    IN SIZE_T RegionSize,
    IN PVOID Information
    );

//
// resource.c
//

extern BOOLEAN RtlpCriticalSectionVerifier;

BOOLEAN
RtlpCreateCriticalSectionSem(
    IN PRTL_CRITICAL_SECTION CriticalSection
    );

//
// Application verifier
//

#include "avrfp.h"

#endif // _LDRP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\importtablehash.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ImportTableHash.c

Abstract:

    This module contains hash computation routine 
    RtlComputeImportTableHash to compute the hash 
    based on the import table of an exe.

Author:

    Vishnu Patankar (VishnuP) 31-May-2001

Revision History:

--*/

#include "ImportTableHash.h"

NTSTATUS
RtlComputeImportTableHash(
    IN  HANDLE hFile,
    IN  PCHAR Hash,
    IN  ULONG ImportTableHashRevision
    )
/*++

Routine Description:

    This routine computes the limited MD5 hash.
    
    First, the image is memory mapped and a canonical 
    sorted list of module name and function name is created
    from the exe's import table.
    
    Second, the hash value is computed using the canonical
    information.
    
Arguments:

    hFile       -   the handle of the file to compute the hash for
    
    Hash        -   the hash value returned - this has to be atleast 16 bytes long
    
    ImportTableHashRevision -   the revision of the computation method for compatibility
                                only ITH_REVISION_1 is supported today

Return Value:

    The status of the hash computation.

--*/
{
    PIMPORTTABLEP_SORTED_LIST_ENTRY pTemp = NULL;
    PIMPORTTABLEP_SORTED_LIST_ENTRY ListEntry = NULL;
    PIMPORTTABLEP_SORTED_LIST_ENTRY ImportedNameList = NULL;
    PIMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY FunctionListEntry;
    
    ULONG ImportDescriptorSize = 0;
    HANDLE hMap = INVALID_HANDLE_VALUE;
    LPVOID FileMapping = NULL;
    PIMAGE_THUNK_DATA OriginalFirstThunk;
    PIMAGE_IMPORT_BY_NAME AddressOfData;
    PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor;
    ACCESS_MASK DesiredAccess;
    ULONG AllocationAttributes;
    DWORD flProtect = PAGE_READONLY;
    LARGE_INTEGER SectionOffset;
    SIZE_T ViewSize;
    
    NTSTATUS    Status = STATUS_SUCCESS;

    if ( ITH_REVISION_1 != ImportTableHashRevision ) {
        Status = STATUS_UNKNOWN_REVISION;
        goto ExitHandler;
    }

    //
    // Unwrap CreateFileMappingW (since that API is not available in ntdll.dll)
    //

    DesiredAccess = STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ;
    AllocationAttributes = flProtect & (SEC_FILE | SEC_IMAGE | SEC_RESERVE | SEC_COMMIT | SEC_NOCACHE);
    flProtect ^= AllocationAttributes;

    if (AllocationAttributes == 0) {
        AllocationAttributes = SEC_COMMIT;        
    }

    Status = NtCreateSection(
                &hMap,
                DesiredAccess,
                NULL,
                NULL,
                flProtect,
                AllocationAttributes,
                hFile
                );

    if ( hMap == INVALID_HANDLE_VALUE || !NT_SUCCESS(Status) ) {

        Status = STATUS_INVALID_HANDLE;
        goto ExitHandler;
    }
    


    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;
    ViewSize = 0;
        
    Status = NtMapViewOfSection(
                hMap,
                NtCurrentProcess(),
                &FileMapping,
                0L,
                0L,
                &SectionOffset,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_READONLY
                );

    if (FileMapping == NULL || !NT_SUCCESS(Status) ) {

        Status = STATUS_NOT_MAPPED_VIEW;
        goto ExitHandler;
    }

    ImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)RtlImageDirectoryEntryToData (
                                                                              FileMapping,
                                                                              FALSE,
                                                                              IMAGE_DIRECTORY_ENTRY_IMPORT,
                                                                              &ImportDescriptorSize
                                                                              );

    if (ImportDescriptor == NULL) {

        Status = STATUS_RESOURCE_DATA_NOT_FOUND;
        goto ExitHandler;
    }

    //
    // outer loop that iterates over all modules in the import table of the exe
    //

    while ((ImportDescriptor->Name != 0) && (ImportDescriptor->FirstThunk != 0)) {

        PSZ ImportName = (PSZ)RtlAddressInSectionTable(
                                                      RtlImageNtHeader(FileMapping),
                                                      FileMapping,
                                                      ImportDescriptor->Name
                                                      );

        if ( ImportName == NULL ) {

            Status = STATUS_RESOURCE_NAME_NOT_FOUND;
            goto ExitHandler;
        }


        ListEntry = (PIMPORTTABLEP_SORTED_LIST_ENTRY)RtlAllocateHeap(RtlProcessHeap(), 0, sizeof( IMPORTTABLEP_SORTED_LIST_ENTRY ));

        if ( ListEntry == NULL ) {

            Status = STATUS_NO_MEMORY;
            goto ExitHandler;

        }

        ListEntry->String       = ImportName;
        ListEntry->FunctionList = NULL;
        ListEntry->Next         = NULL;

        ImportTablepInsertModuleSorted( ListEntry, &ImportedNameList );

        OriginalFirstThunk = (PIMAGE_THUNK_DATA)RtlAddressInSectionTable(
                                                                        RtlImageNtHeader(FileMapping),
                                                                        FileMapping,
                                                                        ImportDescriptor->OriginalFirstThunk
                                                                        );

        //
        // inner loop that iterates over all functions for a given module
        //
        
        while (OriginalFirstThunk->u1.Ordinal) {

            if (!IMAGE_SNAP_BY_ORDINAL( OriginalFirstThunk->u1.Ordinal)) {

                AddressOfData = (PIMAGE_IMPORT_BY_NAME)RtlAddressInSectionTable(
                                                                               RtlImageNtHeader(FileMapping),
                                                                               FileMapping,
                                                                               (ULONG)OriginalFirstThunk->u1.AddressOfData
                                                                               );

                if ( AddressOfData == NULL || AddressOfData->Name == NULL ) {

                    Status = STATUS_RESOURCE_NAME_NOT_FOUND;
                    goto ExitHandler;

                }

                FunctionListEntry = (PIMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY)RtlAllocateHeap(RtlProcessHeap(), 0, sizeof( IMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY ));
                
                if (FunctionListEntry == NULL ) {

                    Status = STATUS_NO_MEMORY;
                    goto ExitHandler;
                }


                FunctionListEntry->Next   = NULL;
                FunctionListEntry->String = (PSZ)AddressOfData->Name;

                ImportTablepInsertFunctionSorted( FunctionListEntry, &ListEntry->FunctionList );
            }

            OriginalFirstThunk++;
        }


        ImportDescriptor++;
    }

    //
    // finally hash the canonical information (sorted module and sorted function list)
    //

    Status = ImportTablepHashCanonicalLists( ImportedNameList, Hash );

ExitHandler:

    ImportTablepFreeModuleSorted( ImportedNameList );

    if (FileMapping) {

        NTSTATUS    StatusUnmap;
        //
        // unwrap UnmapViewOfFile (since that API is not available in ntdll.dll)
        //

        StatusUnmap = NtUnmapViewOfSection(NtCurrentProcess(),(PVOID)FileMapping);

        if ( !NT_SUCCESS(StatusUnmap) ) {
            if (StatusUnmap == STATUS_INVALID_PAGE_PROTECTION) {

                //
                // Unlock any pages that were locked with MmSecureVirtualMemory.
                // This is useful for SANs.
                //

                if (RtlFlushSecureMemoryCache((PVOID)FileMapping, 0)) {
                    StatusUnmap = NtUnmapViewOfSection(NtCurrentProcess(),
                                                  (PVOID)FileMapping
                                                 );

                }

            }

        }

    }

    if (hMap != INVALID_HANDLE_VALUE ) {
        NtClose(hMap);
    }

    return Status;
}


VOID
ImportTablepInsertFunctionSorted(
    IN  PIMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY   pFunctionName,
    OUT PIMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY * ppFunctionNameList
    )
/*++

Routine Description:

    This routine inserts a function name in a sorted order.

Arguments:

    pFunctionName       -   name of the function
    
    ppFunctionNameList  -   pointer to the head of the function list to be updated

Return Value:

    None:

--*/
{

    PIMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY pPrev;
    PIMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY pTemp;

    //
    // Special case, list is empty, insert at the front.
    //
    
    if (*ppFunctionNameList == NULL
           || _stricmp((*ppFunctionNameList)->String, pFunctionName->String) > 0) {

        pFunctionName->Next = *ppFunctionNameList;
        *ppFunctionNameList = pFunctionName;
        return;
    }

    pPrev = *ppFunctionNameList;
    pTemp = (*ppFunctionNameList)->Next;

    while (pTemp) {

        if (_stricmp(pTemp->String, pFunctionName->String) >= 0) {
            pFunctionName->Next = pTemp;
            pPrev->Next = pFunctionName;
            return;
        }

        pPrev = pTemp;
        pTemp = pTemp->Next;
    }

    pFunctionName->Next = NULL;
    pPrev->Next = pFunctionName;

    return;

}

VOID
ImportTablepInsertModuleSorted(
    IN PIMPORTTABLEP_SORTED_LIST_ENTRY   pImportName,
    OUT PIMPORTTABLEP_SORTED_LIST_ENTRY * ppImportNameList
    )
/*++

Routine Description:

    This routine inserts a module name (dll) in a sorted order.

Arguments:

    pImportName         -   the import name that needs to be inserted
       
    ppImportNameList    -   pointer to the head of the list to be updated

Return Value:

    None:

--*/
{

    PIMPORTTABLEP_SORTED_LIST_ENTRY pPrev;
    PIMPORTTABLEP_SORTED_LIST_ENTRY pTemp;
    
    //
    // Special case, list is empty, insert at the front.
    //
    
    if (*ppImportNameList == NULL
           || _stricmp((*ppImportNameList)->String, pImportName->String) > 0) {

        pImportName->Next = *ppImportNameList;
        *ppImportNameList = pImportName;
        return;
    }

    pPrev = *ppImportNameList;
    pTemp = (*ppImportNameList)->Next;

    while (pTemp) {

        if (_stricmp(pTemp->String, pImportName->String) >= 0) {
            pImportName->Next = pTemp;
            pPrev->Next = pImportName;
            return;
        }

        pPrev = pTemp;
        pTemp = pTemp->Next;
    }

    pImportName->Next = NULL;
    pPrev->Next = pImportName;

    return;
}

static HANDLE AdvApi32ModuleHandle = (HANDLE) (ULONG_PTR) -1;

NTSTATUS
ImportTablepHashCanonicalLists( 
    IN  PIMPORTTABLEP_SORTED_LIST_ENTRY ImportedNameList, 
    OUT PBYTE Hash
    )

/*++

Routine Description:

    This routine computes the hash values from a given import list. 
    
    advapi32.dll is dynamically loaded - once only per process,
    and the crypto APIs are used to compute the hash value.

Arguments:

    ImportedNameList    -   the head of the module name/function name list
    
    Hash                -   the buffer to use to fill in the hash value

Return Value:

    STATUS_SUCCESS if the hash value is calculated, otherwise the error status

--*/                                                                          

{

    NTSTATUS Status = STATUS_SUCCESS;
    DWORD dwHashedDataLength = 0;
    PIMPORTTABLEP_SORTED_LIST_ENTRY pTemp;
    
    HCRYPTHASH hHash;
    HCRYPTPROV hProvVerify;
    
    typedef BOOL (WINAPI *CryptAcquireContextW) (
                                                HCRYPTPROV *phProv,
                                                LPCWSTR szContainer,
                                                LPCWSTR szProvider,
                                                DWORD dwProvType,
                                                DWORD dwFlags
                                                );

    typedef BOOL (WINAPI *CryptCreateHash) (
                                            HCRYPTPROV hProv,
                                            ALG_ID Algid,
                                            HCRYPTKEY hKey,
                                            DWORD dwFlags,
                                            HCRYPTHASH *phHash
                                            );

    typedef BOOL (WINAPI *CryptHashData) (
                                            HCRYPTHASH hHash,
                                            CONST BYTE *pbData,
                                            DWORD dwDataLen,
                                            DWORD dwFlags
                                            );

    typedef BOOL (WINAPI *CryptGetHashParam) (
                                              HCRYPTHASH hHash,
                                              DWORD dwParam,
                                              BYTE *pbData,
                                              DWORD *pdwDataLen,
                                              DWORD dwFlags
                                            );

    const static UNICODE_STRING ModuleName =
        RTL_CONSTANT_STRING(L"ADVAPI32.DLL");

    const static ANSI_STRING ProcedureNameCryptAcquireContext =
        RTL_CONSTANT_STRING("CryptAcquireContextW");

    const static ANSI_STRING ProcedureNameCryptCreateHash =
        RTL_CONSTANT_STRING("CryptCreateHash");
         
    const static ANSI_STRING ProcedureNameCryptHashData =
        RTL_CONSTANT_STRING("CryptHashData");
    
    const static ANSI_STRING ProcedureNameCryptGetHashParam =
        RTL_CONSTANT_STRING("CryptGetHashParam");

    static CryptAcquireContextW lpfnCryptAcquireContextW;
    static CryptCreateHash      lpfnCryptCreateHash;
    static CryptHashData        lpfnCryptHashData;
    static CryptGetHashParam    lpfnCryptGetHashParam;

    if (AdvApi32ModuleHandle == NULL) {
        
        //
        // We tried to load ADVAPI32.DLL once before, but failed.
        //
        
        Status = STATUS_ENTRYPOINT_NOT_FOUND;
        goto ExitHandler;
    }

    if (AdvApi32ModuleHandle == LongToHandle(-1)) {
        
        HANDLE TempModuleHandle;
        
        //
        // Load advapi32.dll for crypt functions.  We'll pass a special flag in
        // DllCharacteristics to eliminate WinSafer checking on advapi.
        //

        {
            ULONG DllCharacteristics = IMAGE_FILE_SYSTEM;
            
            Status = LdrLoadDll(UNICODE_NULL,
                                &DllCharacteristics,
                                (PUNICODE_STRING) &ModuleName,
                                &TempModuleHandle);
            
            if (!NT_SUCCESS(Status)) {
                Status = STATUS_DLL_NOT_FOUND;
                AdvApi32ModuleHandle = NULL;
                goto ExitHandler;
            }
        }

        //
        // Get function pointers to the APIs that we'll need.  If we fail
        // to get pointers for any of them, then just unload advapi and
        // ignore all future attempts to load it within this process.
        //

        Status = LdrGetProcedureAddress(
                                       TempModuleHandle,
                                       (PANSI_STRING) &ProcedureNameCryptAcquireContext,
                                       0,
                                       (PVOID*)&lpfnCryptAcquireContextW);

        if (!NT_SUCCESS(Status) || !lpfnCryptAcquireContextW) {
            //
            // Couldn't get the fn ptr. Make sure we won't try again
            //
AdvapiLoadFailure:
            LdrUnloadDll(TempModuleHandle);
            AdvApi32ModuleHandle = NULL;
            Status = STATUS_ENTRYPOINT_NOT_FOUND;
            goto ExitHandler;
        }

        Status = LdrGetProcedureAddress(
                                       TempModuleHandle,
                                       (PANSI_STRING) &ProcedureNameCryptCreateHash,
                                       0,
                                       (PVOID*)&lpfnCryptCreateHash);

        if (!NT_SUCCESS(Status) || !lpfnCryptCreateHash) {
            goto AdvapiLoadFailure;
        }

        Status = LdrGetProcedureAddress(
                                       TempModuleHandle,
                                       (PANSI_STRING) &ProcedureNameCryptHashData,
                                       0,
                                       (PVOID*)&lpfnCryptHashData);

        if (!NT_SUCCESS(Status) || !lpfnCryptHashData) {
            goto AdvapiLoadFailure;
        }

        Status = LdrGetProcedureAddress(
                                       TempModuleHandle,
                                       (PANSI_STRING) &ProcedureNameCryptGetHashParam,
                                       0,
                                       (PVOID*)&lpfnCryptGetHashParam);

        if (!NT_SUCCESS(Status) || !lpfnCryptGetHashParam) {
            goto AdvapiLoadFailure;
        }

        AdvApi32ModuleHandle = TempModuleHandle;
    }

    ASSERT(lpfnCryptAcquireContextW != NULL);

    if (!lpfnCryptAcquireContextW(&hProvVerify, 
                                  NULL, 
                                  MS_DEF_PROV_W, 
                                  PROV_RSA_FULL, 
                                  CRYPT_VERIFYCONTEXT | CRYPT_SILENT)) {

        Status = STATUS_NOT_IMPLEMENTED;
        goto ExitHandler;
    }

    ASSERT(lpfnCryptCreateHash != NULL);

    if (!lpfnCryptCreateHash( hProvVerify, 
                              CALG_MD5, 
                              0, 
                              0, 
                              &hHash )) {

        Status = STATUS_NOT_IMPLEMENTED;
        goto ExitHandler;

    }

    //
    // Loop though all of the module names and function names and create a hash
    //

    pTemp = ImportedNameList;

    //
    // loop through each module
    //

    while (pTemp != NULL) {

        PIMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY pTemp2 = pTemp->FunctionList;

        ASSERT(lpfnCryptHashData != NULL);

        if (!lpfnCryptHashData( hHash, 
                                (PBYTE)(pTemp->String), 
                                strlen( pTemp->String ), 
                                0)) {

            Status = STATUS_NOT_IMPLEMENTED;
            goto ExitHandler;

        }

        //
        // loop through each function
        //
        
        while (pTemp2 != NULL) {

            ASSERT(lpfnCryptHashData != NULL);

            if (!lpfnCryptHashData( hHash, 
                                    (PBYTE)(pTemp2->String), 
                                    strlen( pTemp2->String ), 
                                    0)) {

                Status = STATUS_NOT_IMPLEMENTED;
                goto ExitHandler;

            }

            pTemp2 = pTemp2->Next;

        }

        pTemp = pTemp->Next;

    }

    dwHashedDataLength = IMPORT_TABLE_MAX_HASH_SIZE;

    ASSERT(lpfnCryptGetHashParam != NULL);

    if (!lpfnCryptGetHashParam( hHash, 
                                HP_HASHVAL, 
                                Hash, 
                                &dwHashedDataLength, 
                                0 )) {

        Status = STATUS_NOT_IMPLEMENTED;
    
    }


ExitHandler:

    return Status;

}

VOID
ImportTablepFreeModuleSorted(
    IN PIMPORTTABLEP_SORTED_LIST_ENTRY pImportNameList
    )
/*++

Routine Description:

    This routine frees the entire module/function list.

Arguments:

    pImportNameList -   head of the two level singly linked list

Return Value:
    
    None:

--*/
{
    PIMPORTTABLEP_SORTED_LIST_ENTRY pToFree, pTemp;

    if ( !pImportNameList ) {
        return;
    }

    pToFree = pImportNameList;
    pTemp = pToFree->Next;

    while ( pToFree ) {

        ImportTablepFreeFunctionSorted( pToFree->FunctionList );
            
        RtlFreeHeap(RtlProcessHeap(), 0, pToFree);

        pToFree = pTemp;

        if ( pTemp ) {
            pTemp = pTemp->Next;
        }

    }

    return;

}

VOID
ImportTablepFreeFunctionSorted(
    IN PIMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY pFunctionNameList
    )
/*++

Routine Description:

    This routine frees function list.

Arguments:

    pFunctionNameList -   head of function name list

Return Value:
    
    None:

--*/
{
    PIMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY pToFree, pTemp;

    if ( !pFunctionNameList ) {
        return;
    }

    pToFree = pFunctionNameList;
    pTemp = pToFree->Next;

    while ( pToFree ) {
            
        RtlFreeHeap(RtlProcessHeap(), 0, pToFree);

        pToFree = pTemp;

        if ( pTemp ) {
            pTemp = pTemp->Next;
        }

    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\ldrapi.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ldrapi.c

Abstract:

    This module implements the Ldr APIs that can be linked with
    an application to perform loader services. All of the APIs in
    this component are implemented in a DLL. They are not part of the
    DLL snap procedure.

Author:

    Mike O'Leary (mikeol) 23-Mar-1990

Revision History:

--*/

#include "ldrp.h"
#include "ntos.h"
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "objidl.h"
#include <windows.h>
#include <apcompat.h>
#include <shimhapi.h>

#if defined(_WIN64)
#include <wow64t.h>
#endif // defined(_WIN64)

#define ULONG_PTR_IZE(_x) ((ULONG_PTR) (_x))
#define ULONG_PTR_IZE_SHIFT_AND_MASK(_x, _shift, _mask) ((ULONG_PTR) ((ULONG_PTR_IZE((_x)) & (_mask)) << (_shift)))

#define CHAR_BITS 8

#define LOADER_LOCK_COOKIE_TYPE_BIT_LENGTH (4)
#define LOADER_LOCK_COOKIE_TYPE_BIT_OFFSET ((CHAR_BITS * sizeof(PVOID)) - LOADER_LOCK_COOKIE_TYPE_BIT_LENGTH)
#define LOADER_LOCK_COOKIE_TYPE_BIT_MASK ((1 << LOADER_LOCK_COOKIE_TYPE_BIT_LENGTH) - 1)

#define LOADER_LOCK_COOKIE_TID_BIT_LENGTH (12)
#define LOADER_LOCK_COOKIE_TID_BIT_OFFSET (LOADER_LOCK_COOKIE_TYPE_BIT_OFFSET - LOADER_LOCK_COOKIE_TID_BIT_LENGTH)
#define LOADER_LOCK_COOKIE_TID_BIT_MASK ((1 << LOADER_LOCK_COOKIE_TID_BIT_LENGTH) - 1)

#define LOADER_LOCK_COOKIE_CODE_BIT_LENGTH (16)
#define LOADER_LOCK_COOKIE_CODE_BIT_OFFSET (0)
#define LOADER_LOCK_COOKIE_CODE_BIT_MASK ((1 << LOADER_LOCK_COOKIE_CODE_BIT_LENGTH) - 1)

#define MAKE_LOADER_LOCK_COOKIE(_type, _code) \
    ((ULONG_PTR) (ULONG_PTR_IZE_SHIFT_AND_MASK((_type), LOADER_LOCK_COOKIE_TYPE_BIT_OFFSET, LOADER_LOCK_COOKIE_TYPE_BIT_MASK) | \
                  ULONG_PTR_IZE_SHIFT_AND_MASK((HandleToUlong((NtCurrentTeb())->ClientId.UniqueThread)), LOADER_LOCK_COOKIE_TID_BIT_OFFSET, LOADER_LOCK_COOKIE_TID_BIT_MASK) | \
                  ULONG_PTR_IZE_SHIFT_AND_MASK((_code), LOADER_LOCK_COOKIE_CODE_BIT_OFFSET, LOADER_LOCK_COOKIE_CODE_BIT_MASK)))

#define EXTRACT_LOADER_LOCK_COOKIE_FIELD(_cookie, _shift, _mask) ((((ULONG_PTR) (_cookie)) >> (_shift)) & (_mask))
#define EXTRACT_LOADER_LOCK_COOKIE_TYPE(_cookie) EXTRACT_LOADER_LOCK_COOKIE_FIELD((_cookie), LOADER_LOCK_COOKIE_TYPE_BIT_OFFSET, LOADER_LOCK_COOKIE_TYPE_BIT_MASK)
#define EXTRACT_LOADER_LOCK_COOKIE_TID(_cookie) EXTRACT_LOADER_LOCK_COOKIE_FIELD((_cookie), LOADER_LOCK_COOKIE_TID_BIT_OFFSET, LOADER_LOCK_COOKIE_TID_BIT_MASK)

#define LOADER_LOCK_COOKIE_TYPE_NORMAL (0)

LONG LdrpLoaderLockAcquisitionCount;

// Note the case inconsistency is due to preserving case from earlier versions.
WCHAR DllExtension[] = L".dll";
static UNICODE_STRING DefaultExtension = RTL_CONSTANT_STRING(L".DLL");

PLDR_MANIFEST_PROBER_ROUTINE LdrpManifestProberRoutine = NULL;

extern PFNSE_DLLLOADED         g_pfnSE_DllLoaded;
extern PFNSE_DLLUNLOADED       g_pfnSE_DllUnloaded;
extern PFNSE_GETPROCADDRESS    g_pfnSE_GetProcAddress;

PLDR_APP_COMPAT_DLL_REDIRECTION_CALLBACK_FUNCTION LdrpAppCompatDllRedirectionCallbackFunction = NULL;
PVOID LdrpAppCompatDllRedirectionCallbackData = NULL;
BOOLEAN LdrpShowRecursiveDllLoads;
BOOLEAN LdrpBreakOnRecursiveDllLoads;
PLDR_DATA_TABLE_ENTRY LdrpCurrentDllInitializer;

VOID
RtlpDphDisableFaultInjection (
    );

VOID
RtlpDphEnableFaultInjection (
    );

ULONG
LdrpClearLoadInProgress(
    VOID
    );

NTSTATUS
LdrLoadDll (
    IN PWSTR DllPath OPTIONAL,
    IN PULONG DllCharacteristics OPTIONAL,
    IN PUNICODE_STRING DllName,
    OUT PVOID *DllHandle
    )

/*++

Routine Description:

    This function loads a DLL into the calling process address space.

Arguments:

    DllPath - Supplies the search path to be used to locate the DLL.

    DllCharacteristics - Supplies an optional DLL characteristics flag,
        that if specified is used to match against the dll being loaded.

    DllName - Supplies the name of the DLL to load.

    DllHandle - Returns a handle to the loaded DLL.

Return Value:

    TBD

--*/
{
    NTSTATUS Status;
    WCHAR StaticRedirectedDllNameBuffer[DOS_MAX_PATH_LENGTH];
    UNICODE_STRING StaticRedirectedDllName;
    UNICODE_STRING DynamicRedirectedDllName = {0};
    ULONG LdrpLoadDllFlags = 0;
    PCUNICODE_STRING OldTopLevelDllBeingLoaded = NULL;
    PVOID LockCookie = NULL;

    //
    // We need to disable page heap fault injection while loader is active.
    // This is important so that we avoid lots of hits(failures) in this
    // area. The Disable/Enable function have basically zero impact on
    // performance because they just increment/decrement a lock variable
    // that is checked when an actual allocation is performed (page heap
    // needs to be enabled for that).
    //

    RtlpDphDisableFaultInjection ();

    StaticRedirectedDllName.Length = 0;
    StaticRedirectedDllName.MaximumLength = sizeof(StaticRedirectedDllNameBuffer);
    StaticRedirectedDllName.Buffer = StaticRedirectedDllNameBuffer;

    Status = RtlDosApplyFileIsolationRedirection_Ustr(
                RTL_DOS_APPLY_FILE_REDIRECTION_USTR_FLAG_RESPECT_DOT_LOCAL,
                DllName,                    // dll name to look up
                &DefaultExtension,
                &StaticRedirectedDllName,
                &DynamicRedirectedDllName,
                &DllName,
                NULL,
                NULL,                       // not interested in where the filename starts
                NULL);                      // not interested in bytes required if we only had a static string
    if (NT_SUCCESS(Status)) {
        LdrpLoadDllFlags |= LDRP_LOAD_DLL_FLAG_DLL_IS_REDIRECTED;
    } else if (Status != STATUS_SXS_KEY_NOT_FOUND) {
#if DBG
        DbgPrint("%s(%wZ): RtlDosApplyFileIsolationRedirection_Ustr() failed with status %08lx\n", __FUNCTION__, DllName, Status);
#endif // DBG
        goto Exit;
    }

    LdrLockLoaderLock(LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, NULL, &LockCookie);
    __try {
        OldTopLevelDllBeingLoaded = LdrpTopLevelDllBeingLoaded;

        if (OldTopLevelDllBeingLoaded) {
            if (ShowSnaps || LdrpShowRecursiveDllLoads || LdrpBreakOnRecursiveDllLoads) {
                DbgPrint(
                    "[%lx,%lx] LDR: Recursive DLL load\n",
                    HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess),
                    HandleToULong(NtCurrentTeb()->ClientId.UniqueThread));

                DbgPrint(
                    "[%lx,%lx]   Previous DLL being loaded: \"%wZ\"\n",
                    HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess),
                    HandleToULong(NtCurrentTeb()->ClientId.UniqueThread),
                    OldTopLevelDllBeingLoaded);

                DbgPrint(
                    "[%lx,%lx]   DLL being requested: \"%wZ\"\n",
                    HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess),
                    HandleToULong(NtCurrentTeb()->ClientId.UniqueThread),
                    DllName);

                if (LdrpCurrentDllInitializer != NULL) {
                    DbgPrint(
                        "[%lx,%lx]   DLL whose initializer was currently running: \"%wZ\"\n",
                        HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess),
                        HandleToULong(NtCurrentTeb()->ClientId.UniqueThread),
                        &LdrpCurrentDllInitializer->FullDllName);
                } else {
                    DbgPrint(
                        "[%lx,%lx]   No DLL initializer was running\n",
                        HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess),
                        HandleToULong(NtCurrentTeb()->ClientId.UniqueThread));
                }
            }
        }

        LdrpTopLevelDllBeingLoaded = DllName;
        Status = LdrpLoadDll(LdrpLoadDllFlags, DllPath, DllCharacteristics, DllName, DllHandle, TRUE);
        if (!NT_SUCCESS(Status)) {
            if ((Status != STATUS_NO_SUCH_FILE) &&
                (Status != STATUS_DLL_NOT_FOUND) &&
                (Status != STATUS_OBJECT_NAME_NOT_FOUND)) {

                // Dll initialization failure is common enough that we won't want to print unless snaps are turned on.
                if (ShowSnaps || (Status != STATUS_DLL_INIT_FAILED)) {
                    DbgPrintEx(
                        DPFLTR_LDR_ID,
                        LDR_ERROR_DPFLTR,
                        "LDR: %s - failing because LdrpLoadDll(%wZ) returned status %x\n",
                        __FUNCTION__,
                        DllName,
                        Status);
                }
            }

            goto Exit;
        }
    } __finally {
        LdrpTopLevelDllBeingLoaded = OldTopLevelDllBeingLoaded;
        LdrUnlockLoaderLock(LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, LockCookie);
    }

    Status = STATUS_SUCCESS;

Exit:
    if (DynamicRedirectedDllName.Buffer != NULL)
        RtlFreeUnicodeString(&DynamicRedirectedDllName);

    //
    // Reenable page heap fault injection.
    //

    RtlpDphEnableFaultInjection ();

    return Status;
}

NTSTATUS
NTAPI
LdrpLoadDll(
    ULONG Flags OPTIONAL,
    IN PWSTR DllPath OPTIONAL,
    IN PULONG DllCharacteristics OPTIONAL,
    IN PUNICODE_STRING DllName,
    OUT PVOID *DllHandle,
    IN BOOLEAN RunInitRoutines
    )
{
    PPEB Peb;
    PTEB Teb;
    NTSTATUS st;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    PWSTR ActualDllName;
    PWCH p, pp;
    UNICODE_STRING ActualDllNameStr;
    WCHAR FreeBuffer[LDR_MAX_PATH + 1];
    BOOLEAN Redirected = ((Flags & LDRP_LOAD_DLL_FLAG_DLL_IS_REDIRECTED) != 0);
    const InLdrInit = LdrpInLdrInit;
    PVOID LockCookie = NULL;

    Peb = NtCurrentPeb();
    Teb = NtCurrentTeb();

    st = STATUS_SUCCESS;

    //
    // Except during process initializeation, grab loader lock and Snap All Links to specified DLL
    //

    if (!InLdrInit)
        RtlEnterCriticalSection(&LdrpLoaderLock);

    try {
        p = DllName->Buffer;
        pp = NULL;
        while (*p) {
            if (*p++ == (WCHAR)'.') {
                //
                // pp will point to first character after last '.'
                //
                pp = p;
                }
            }


        ActualDllName = FreeBuffer;
        if ( DllName->Length >= sizeof(FreeBuffer)) {
            return STATUS_NAME_TOO_LONG;
            }
        RtlMoveMemory(ActualDllName, DllName->Buffer, DllName->Length);


        if (!pp || *pp == (WCHAR)'\\') {
            //
            // No extension found (just ..\)
            //
            if (DllName->Length + sizeof(DllExtension) >= sizeof(FreeBuffer)) {
                DbgPrintEx(
                    DPFLTR_LDR_ID,
                    LDR_ERROR_DPFLTR,
                    "LDR: %s - Dll name missing extension; with extension added the length is too long\n"
                    "   DllName: (@ %p) \"%wZ\"\n"
                    "   DllName->Length: %u\n",
                    __FUNCTION__,
                    DllName, DllName,
                    DllName->Length);

                return STATUS_NAME_TOO_LONG;
            }

            RtlMoveMemory((PCHAR)ActualDllName+DllName->Length, DllExtension, sizeof(DllExtension));
        } else
            ActualDllName[DllName->Length >> 1] = UNICODE_NULL;

        if (ShowSnaps) {
            DbgPrint("LDR: LdrLoadDll, loading %ws from %ws\n",
                     ActualDllName,
                     ARGUMENT_PRESENT(DllPath) ? DllPath : L""
                     );
            }


        RtlInitUnicodeString(&ActualDllNameStr,ActualDllName);
        ActualDllNameStr.MaximumLength = sizeof(FreeBuffer);

        if (!LdrpCheckForLoadedDll( DllPath,
                                    &ActualDllNameStr,
                                    FALSE,
                                    Redirected,
                                    &LdrDataTableEntry)) {
            st = LdrpMapDll(DllPath,
                            ActualDllName,
                            DllCharacteristics,
                            FALSE,
                            Redirected,
                            &LdrDataTableEntry);

            if (!NT_SUCCESS(st))
                return st;

            //
            // Register dll with the stack tracing module.
            // This is used for getting reliable stack traces on X86.
            //

#if defined(_X86_)
            RtlpStkMarkDllRange (LdrDataTableEntry);
#endif

            if (ARGUMENT_PRESENT( DllCharacteristics ) &&
                *DllCharacteristics & IMAGE_FILE_EXECUTABLE_IMAGE) {
                LdrDataTableEntry->EntryPoint = 0;
                LdrDataTableEntry->Flags &= ~LDRP_IMAGE_DLL;
            }

            //
            // and walk the import descriptor.
            //

            if (LdrDataTableEntry->Flags & LDRP_IMAGE_DLL) {

                try {
                    //
                    // if the image is COR-ILONLY, then don't walk the import descriptor 
                    // as it is assumed that it only imports %windir%\system32\mscoree.dll, otherwise
                    // walk the import descriptor table of the dll.
                    //

                    if ((LdrDataTableEntry->Flags & LDRP_COR_IMAGE) == 0) {
                        st = LdrpWalkImportDescriptor(
                                  DllPath,
                                  LdrDataTableEntry
                                  );
                    }
                } __except(LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
                    st = GetExceptionCode();
                    DbgPrintEx(
                        DPFLTR_LDR_ID,
                        LDR_ERROR_DPFLTR,
                        "LDR: %s - Exception %x thrown by LdrpWalkImportDescriptor\n",
                        __FUNCTION__,
                        st);
                }

                if ( LdrDataTableEntry->LoadCount != 0xffff )
                    LdrDataTableEntry->LoadCount++;

                LdrpReferenceLoadedDll(LdrDataTableEntry);

                if (!NT_SUCCESS(st)) {
                    LdrDataTableEntry->EntryPoint = NULL;
                    InsertTailList(
                        &NtCurrentPeb()->Ldr->InInitializationOrderModuleList,
                        &LdrDataTableEntry->InInitializationOrderLinks);

                    LdrpClearLoadInProgress();

                    if (ShowSnaps)
                        DbgPrint("LDR: Unloading %wZ due to error %x walking import descriptors\n", DllName, st);

                    LdrUnloadDll((PVOID)LdrDataTableEntry->DllBase);

                    return st;
                    }
                }
            else {
                if ( LdrDataTableEntry->LoadCount != 0xffff ) {
                    LdrDataTableEntry->LoadCount++;
                    }
                }

            //
            // Add init routine to list
            //

            InsertTailList(&NtCurrentPeb()->Ldr->InInitializationOrderModuleList,
                           &LdrDataTableEntry->InInitializationOrderLinks);


            //
            // If the loader data base is not fully setup, this load was because
            // of a forwarder in the static load set. Can't run init routines
            // yet because the load counts are NOT set
            //

            if ( RunInitRoutines && LdrpLdrDatabaseIsSetup ) {

                //
                // Shim engine callback. This is the chance to patch
                // dynamically loaded modules.
                //

                if (g_pfnSE_DllLoaded != NULL) {
                    (*g_pfnSE_DllLoaded)(LdrDataTableEntry);
                }

                try {

                    st = LdrpRunInitializeRoutines(NULL);
                    if ( !NT_SUCCESS(st) ) {
                        if (ShowSnaps) {
                            DbgPrint("LDR: Unloading %wZ because either its init routine or one of its static imports failed; status = 0x%08lx", DllName, st);
                        }

                        LdrUnloadDll((PVOID)LdrDataTableEntry->DllBase);
                        }
                    }
                __except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
                    st = GetExceptionCode();

                    DbgPrintEx(
                        DPFLTR_LDR_ID,
                        LDR_ERROR_DPFLTR,
                        "LDR: %s - Exception %08lx thrown running initialization routines for %wZ\n",
                        __FUNCTION__,
                        st,
                        &LdrDataTableEntry->FullDllName);

                    LdrUnloadDll((PVOID)LdrDataTableEntry->DllBase);

                    return st;
                    }
                }
            else {
                st = STATUS_SUCCESS;
                }

            }
        else {

            //
            // Count it. And everything that it imports.
            //

            if ( LdrDataTableEntry->Flags & LDRP_IMAGE_DLL &&
                 LdrDataTableEntry->LoadCount != 0xffff  ) {

                LdrDataTableEntry->LoadCount++;

                LdrpReferenceLoadedDll(LdrDataTableEntry);

                //
                // Now clear the Load in progress bits
                //

                LdrpClearLoadInProgress();

                }
            else {
                if ( LdrDataTableEntry->LoadCount != 0xffff ) {
                    LdrDataTableEntry->LoadCount++;
                    }
                }
            }
        }
    __finally {
        if (!InLdrInit)
            RtlLeaveCriticalSection(&LdrpLoaderLock);
    }

    if (NT_SUCCESS(st))
        *DllHandle = (PVOID)LdrDataTableEntry->DllBase;
    else
        *DllHandle = NULL;

    return st;
}

NTSTATUS
LdrGetDllHandle(
    IN PWSTR DllPath OPTIONAL,
    IN PULONG DllCharacteristics OPTIONAL,
    IN PUNICODE_STRING DllName,
    OUT PVOID *DllHandle
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    //
    // Preserve the old behavior.
    //
    ULONG Flags = LDR_GET_DLL_HANDLE_EX_UNCHANGED_REFCOUNT;

    Status = LdrGetDllHandleEx(Flags, DllPath, DllCharacteristics, DllName, DllHandle);

    return Status;
}

NTSTATUS
LdrGetDllHandleEx(
    IN ULONG Flags,
    IN PWSTR DllPath OPTIONAL,
    IN PULONG DllCharacteristics OPTIONAL,
    IN PUNICODE_STRING DllName,
    OUT PVOID *DllHandle OPTIONAL
    )

/*++

Routine Description:

    This function locates the specified DLL and returns its handle.

Arguments:

    Flags - various bits to affect the behavior

        default: the returned handle is addrefed

        LDR_GET_DLL_HANDLE_EX_PIN - the dll will not be unloaded until
                the process exits

        LDR_GET_DLL_HANDLE_EX_UNCHANGED_REFCOUNT - the dll's reference
                count is not changed

    DllPath - Supplies the search path to be used to locate the DLL.

    DllCharacteristics - Supplies an optional DLL characteristics flag,
        that if specified is used to match against the dll being loaded.
        The currently supported flags are:

            IMAGE_FILE_EXECUTABLE_IMAGE - indicates that imported dll
                referenced by the DLL being loaded should not be followed.
                This corresponds to DONT_RESOLVE_DLL_REFERENCES

            IMAGE_FILE_SYSTEM - indicates that the DLL is a known trusted
                system component and that WinSafer sandbox checking
                should not be performed on the DLL before loading it.

    DllName - Supplies the name of the DLL to load.

    DllHandle - Returns a handle to the loaded DLL.

Return Value:

    TBD

--*/

{
    NTSTATUS st;
    PTEB Teb = NtCurrentTeb();
    PPEB Peb = NtCurrentPeb();
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry = NULL;
    PWSTR ActualDllName;
    PWCH p, pp, pEnd;
    UNICODE_STRING ActualDllNameStr;
    // These two are made static because we only use them when we have the loader 
    // lock, and it also reduces the stack by 260*4 bytes.
    static WCHAR FreeBuffer[LDR_MAX_PATH + 1];
    static WCHAR StaticRedirectedDllNameBuffer[DOS_MAX_PATH_LENGTH];
    UNICODE_STRING StaticRedirectedDllName = {0, 0, NULL};
    UNICODE_STRING DynamicRedirectedDllName = {0, 0, NULL};
    BOOLEAN Redirected = FALSE;
    BOOLEAN HoldingLoaderLock = FALSE;
    const BOOLEAN InLdrInit = LdrpInLdrInit;
    PVOID LockCookie = NULL;
    const ULONG ValidFlags = LDR_GET_DLL_HANDLE_EX_PIN | LDR_GET_DLL_HANDLE_EX_UNCHANGED_REFCOUNT;    

    __try {

        if (DllHandle != NULL) {
            *DllHandle = NULL;
        }

        if (Flags & ~ValidFlags) {
            st = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        //
        // DllHandle is optional if you are pinning the .dll, otherwise it is mandatory.
        //
        if (DllHandle == NULL
            && (Flags & LDR_GET_DLL_HANDLE_EX_PIN) == 0
            ) {
            st = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        if (   (Flags & LDR_GET_DLL_HANDLE_EX_PIN)
            && (Flags & LDR_GET_DLL_HANDLE_EX_UNCHANGED_REFCOUNT)
            ) {
            st = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        //
        // Grab Ldr lock
        //

        if (!InLdrInit) {
            st = LdrLockLoaderLock(0, NULL, &LockCookie);
            if (!NT_SUCCESS(st))
                goto Exit;
            HoldingLoaderLock = TRUE;
        }

#if DBG
        ASSERT( FreeBuffer[0] == UNICODE_NULL
            || (LdrpShutdownInProgress && LdrpShutdownThreadId == NtCurrentTeb()->ClientId.UniqueThread));
        ASSERT( StaticRedirectedDllNameBuffer[0] == UNICODE_NULL
            || (LdrpShutdownInProgress && LdrpShutdownThreadId == NtCurrentTeb()->ClientId.UniqueThread));
        FreeBuffer[0] = L' ';
        StaticRedirectedDllNameBuffer[0] = L' ';
#endif

        StaticRedirectedDllName.Length = 0;
        StaticRedirectedDllName.MaximumLength = sizeof(StaticRedirectedDllNameBuffer);
        StaticRedirectedDllName.Buffer = StaticRedirectedDllNameBuffer;

        st = RtlDosApplyFileIsolationRedirection_Ustr(
                    RTL_DOS_APPLY_FILE_REDIRECTION_USTR_FLAG_RESPECT_DOT_LOCAL,
                    DllName,
                    &DefaultExtension,
                    &StaticRedirectedDllName,
                    &DynamicRedirectedDllName,
                    &DllName,
                    NULL,
                    NULL,
                    NULL);
        if (NT_SUCCESS(st)) {
            Redirected = TRUE;
        } else if (st != STATUS_SXS_KEY_NOT_FOUND) {
            // Something unusual and bad happened.
            __leave;
        }

        st = STATUS_DLL_NOT_FOUND;

        if ( LdrpGetModuleHandleCache ) {
            if (Redirected) {
                if (((LdrpGetModuleHandleCache->Flags & LDRP_REDIRECTED) != 0) &&
                    RtlEqualUnicodeString(DllName, &LdrpGetModuleHandleCache->FullDllName, TRUE)) {

                    LdrDataTableEntry = LdrpGetModuleHandleCache;
                    st = STATUS_SUCCESS;
                    goto Exit;
                }
            } else {
                // Not redirected...
                if (((LdrpGetModuleHandleCache->Flags & LDRP_REDIRECTED) == 0) &&
                    RtlEqualUnicodeString(DllName, &LdrpGetModuleHandleCache->BaseDllName, TRUE)) {

                    LdrDataTableEntry = LdrpGetModuleHandleCache;
                    st = STATUS_SUCCESS;
                    goto Exit;
                }
            }
        }

        p = DllName->Buffer;
        pEnd = p + (DllName->Length / sizeof(WCHAR));

        pp = NULL;

        while (p != pEnd) {
            if (*p++ == L'.') {
                 //
                 // pp will point to first character after last '.'
                 //
                 pp = p;
            }
        }

        ActualDllName = FreeBuffer;
        if ( DllName->Length >= sizeof(FreeBuffer)) {
            st = STATUS_NAME_TOO_LONG;
            __leave;
        }

        RtlCopyMemory(ActualDllName, DllName->Buffer, DllName->Length);

        if ((pp == NULL) || (*pp == L'\\') || (*pp == L'/')) {
            //
            // No extension found (just ..\)
            //

            if ( DllName->Length + (5 * sizeof(WCHAR)) >= sizeof(FreeBuffer) ) {
                st = STATUS_NAME_TOO_LONG;
                __leave;
            }

            RtlCopyMemory(((PCHAR)ActualDllName) + DllName->Length, DllExtension, sizeof(DllExtension));
        } else {
            //
            // see if the name ends in . If it does, trim out the trailing
            // .
            //

            if ((DllName->Length != 0) && (ActualDllName[(DllName->Length / sizeof(WCHAR)) - 1] == L'.')) {
                DllName->Length -= sizeof(WCHAR);
            }

            ActualDllName[DllName->Length / sizeof(WCHAR)] = UNICODE_NULL;
        }


        //
        // Check the LdrTable to see if Dll has already been loaded
        // into this image.
        //

        RtlInitUnicodeString(&ActualDllNameStr,ActualDllName);
        ActualDllNameStr.MaximumLength = sizeof(FreeBuffer);

        if (ShowSnaps) {
            DbgPrint(
                "LDR: LdrGetDllHandle, searching for %ws from %ws\n",
                ActualDllName,
                ARGUMENT_PRESENT(DllPath) ? (DllPath == (PWSTR)1 ? L"" : DllPath) : L""
                );
        }

        //
        // sort of a hack, but done to speed up GetModuleHandle. kernel32
        // now does a two pass call here to avoid computing
        // process dll path
        //

        if (LdrpCheckForLoadedDll(DllPath,
                                  &ActualDllNameStr,
                                  (BOOLEAN)(DllPath == (PWSTR)1 ? TRUE : FALSE),
                                  Redirected,
                                  &LdrDataTableEntry)) {
            LdrpGetModuleHandleCache = LdrDataTableEntry;
            st = STATUS_SUCCESS;
            goto Exit;
        }
        LdrDataTableEntry = NULL;
        RTL_SOFT_ASSERT(st == STATUS_DLL_NOT_FOUND);
Exit:
        ASSERT((LdrDataTableEntry != NULL) == NT_SUCCESS(st));
        if (LdrDataTableEntry != NULL && NT_SUCCESS(st)) {
            //
            // It's standard gross procedure to put the check for 0xffff,
            // and the updaates of the root LoadCount outside the
            // call to LdrpUpdateLoadCount..
            //
            if (LdrDataTableEntry->LoadCount != 0xffff) {

                if ((Flags & LDR_GET_DLL_HANDLE_EX_UNCHANGED_REFCOUNT) != 0
                    ){
                    // nothing
                }
                else {
                    if (Flags & LDR_GET_DLL_HANDLE_EX_PIN) {
                        LdrDataTableEntry->LoadCount = 0xffff;
                        LdrpPinLoadedDll(LdrDataTableEntry);
                    }
                    else {
                        LdrDataTableEntry->LoadCount++;
                        LdrpReferenceLoadedDll(LdrDataTableEntry);
                    }
                    LdrpClearLoadInProgress();
                }
            }
            if (DllHandle != NULL
                ) {
                *DllHandle = (PVOID)LdrDataTableEntry->DllBase;
            }
        }
        if (DynamicRedirectedDllName.Buffer != NULL)
            RtlFreeUnicodeString(&DynamicRedirectedDllName);
    } __finally {
#if DBG    
        FreeBuffer[0] = UNICODE_NULL;
        StaticRedirectedDllNameBuffer[0] = UNICODE_NULL;
#endif        
        if (HoldingLoaderLock) {
            LdrUnlockLoaderLock(LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, LockCookie);
            HoldingLoaderLock = FALSE;
        }
    }
    return st;
}

NTSTATUS
LdrDisableThreadCalloutsForDll (
    IN PVOID DllHandle
    )

/*++

Routine Description:

    This function disables thread attach and detach notification
    for the specified DLL.

Arguments:

    DllHandle - Supplies a handle to the DLL to disable.

Return Value:

    TBD

--*/

{
    NTSTATUS st = STATUS_SUCCESS;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry = NULL;
    const BOOLEAN InLdrInit = LdrpInLdrInit;
    BOOL HoldingLoaderLock = FALSE;
    PVOID LockCookie = NULL;

    if ( LdrpShutdownInProgress ) {
        return STATUS_SUCCESS;
        }

    try {

        if ( InLdrInit == FALSE ) {
            st = LdrLockLoaderLock(0, NULL, &LockCookie);
            if (!NT_SUCCESS(st))
                goto Exit;
            HoldingLoaderLock = TRUE;
            }

        if (LdrpCheckForLoadedDllHandle(DllHandle, &LdrDataTableEntry)) {
            if ( LdrDataTableEntry->TlsIndex ) {
                st = STATUS_DLL_NOT_FOUND;
                }
            else {
                LdrDataTableEntry->Flags |= LDRP_DONT_CALL_FOR_THREADS;
                }
            }
Exit:
        ;
    }
    finally {
        if (HoldingLoaderLock) {
            LdrUnlockLoaderLock(LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, LockCookie);
            HoldingLoaderLock = FALSE;
            }
        }
    return st;
}

NTSTATUS
LdrUnloadDll (
    IN PVOID DllHandle
    )

/*++

Routine Description:

    This function unloads the DLL from the specified process

Arguments:

    DllHandle - Supplies a handle to the DLL to unload.

Return Value:

    TBD

--*/

{
    NTSTATUS st;
    PPEB Peb;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    PLDR_DATA_TABLE_ENTRY Entry;
    PDLL_INIT_ROUTINE InitRoutine;
    LIST_ENTRY LocalUnloadHead;
    PLIST_ENTRY Next;
    ULONG Cor20HeaderSize;
    PIMAGE_COR20_HEADER *Cor20Header;

    Peb = NtCurrentPeb();
    st = STATUS_SUCCESS;

    try {

        //
        // Grab Peb lock and decrement reference count of all affected DLLs
        //


        if (!LdrpInLdrInit)
            RtlEnterCriticalSection(&LdrpLoaderLock);

        LdrpActiveUnloadCount++;

    if ( LdrpShutdownInProgress ) {
        goto leave_finally;
        }

        if (!LdrpCheckForLoadedDllHandle(DllHandle, &LdrDataTableEntry)) {
            st = STATUS_DLL_NOT_FOUND;
            goto leave_finally;
        }

        //
        // Now that we have the data table entry, unload it
        //

        if ( LdrDataTableEntry->LoadCount != 0xffff ) {
            LdrDataTableEntry->LoadCount--;
            if ( LdrDataTableEntry->Flags & LDRP_IMAGE_DLL ) {
                RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame = { sizeof(Frame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };

                RtlActivateActivationContextUnsafeFast(&Frame, LdrDataTableEntry->EntryPointActivationContext);
                __try {
                    LdrpDereferenceLoadedDll(LdrDataTableEntry);
                } __finally {
                    RtlDeactivateActivationContextUnsafeFast(&Frame);
                }
            }
        } else {

            //
            // if the load count is 0xffff, then we do not need to recurse
            // through this DLL's import table.
            //
            // Additionally, we don't have to scan more LoadCount == 0
            // modules since nothing could have happened as a result of a free on this
            // DLL.

            goto leave_finally;
        }

        //
        // Now process init routines and then in a second pass, unload
        // DLLs
        //

        if (ShowSnaps) {
            DbgPrint("LDR: UNINIT LIST\n");
        }

        if (LdrpActiveUnloadCount == 1 ) {
            InitializeListHead(&LdrpUnloadHead);
            }

        //
        // Go in reverse order initialization order and build
        // the unload list
        //

        Next = Peb->Ldr->InInitializationOrderModuleList.Blink;
        while ( Next != &Peb->Ldr->InInitializationOrderModuleList) {
            LdrDataTableEntry
                = (PLDR_DATA_TABLE_ENTRY)
                  (CONTAINING_RECORD(Next,LDR_DATA_TABLE_ENTRY,InInitializationOrderLinks));

            Next = Next->Blink;
            LdrDataTableEntry->Flags &= ~LDRP_UNLOAD_IN_PROGRESS;

            if (LdrDataTableEntry->LoadCount == 0) {

                if (ShowSnaps) {
                      DbgPrint("          (%d) [%ws] %ws (%lx) deinit %lx\n",
                              LdrpActiveUnloadCount,
                              LdrDataTableEntry->BaseDllName.Buffer,
                              LdrDataTableEntry->FullDllName.Buffer,
                              (ULONG)LdrDataTableEntry->LoadCount,
                              LdrDataTableEntry->EntryPoint
                              );
                }

                Entry = LdrDataTableEntry;

                //
                // Shim engine callback. Remove it from the shim list of hooked modules
                //

                if (g_pfnSE_DllUnloaded != NULL) {
                    (*g_pfnSE_DllUnloaded)(Entry);
                }

                RemoveEntryList(&Entry->InInitializationOrderLinks);
                RemoveEntryList(&Entry->InMemoryOrderLinks);
                RemoveEntryList(&Entry->HashLinks);

                if ( LdrpActiveUnloadCount > 1 ) {
                    LdrpLoadedDllHandleCache = NULL;
                    Entry->InMemoryOrderLinks.Flink = NULL;
                    }
                InsertTailList(&LdrpUnloadHead,&Entry->HashLinks);
            }
        }
        //
        // End of new code
        //

        //
        // We only do init routine call's and module free's at the top level,
        // so if the active count is > 1, just return
        //

        if (LdrpActiveUnloadCount > 1 ) {
            goto leave_finally;
            }

        //
        // Now that the unload list is built, walk through the unload
        // list in order and call the init routine. The dll must remain
        // on the InLoadOrderLinks so that the pctoheader stuff will
        // still work
        //

        InitializeListHead(&LocalUnloadHead);
        Entry = NULL;
        Next = LdrpUnloadHead.Flink;
        while ( Next != &LdrpUnloadHead ) {
top:
            if ( Entry ) {

#if defined(_AMD64_) // || defined(_IA64_)


                RtlRemoveInvertedFunctionTable(&LdrpInvertedFunctionTable,
                                               Entry->DllBase);

#endif

                RemoveEntryList(&(Entry->InLoadOrderLinks));
                Entry = NULL;
                Next = LdrpUnloadHead.Flink;
                if (Next == &LdrpUnloadHead ) {
                    goto bottom;
                    }
            }
            LdrDataTableEntry
                = (PLDR_DATA_TABLE_ENTRY)
                  (CONTAINING_RECORD(Next,LDR_DATA_TABLE_ENTRY,HashLinks));

            //
            // Remove dll from the global unload list and place
            // on the local unload list. This is because the global list
            // can change during the callout to the init routine
            //

            Entry = LdrDataTableEntry;
            LdrpLoadedDllHandleCache = NULL;
            Entry->InMemoryOrderLinks.Flink = NULL;

            RemoveEntryList(&Entry->HashLinks);
            InsertTailList(&LocalUnloadHead,&Entry->HashLinks);

            //
            // If the function has an init routine, call it.
            //

            InitRoutine = (PDLL_INIT_ROUTINE)LdrDataTableEntry->EntryPoint;

            if (InitRoutine && (LdrDataTableEntry->Flags & LDRP_PROCESS_ATTACH_CALLED) ) {
                try {
                    if (ShowSnaps) {
                        DbgPrint("LDR: Calling deinit %lx\n",InitRoutine);
                        }

                    LDRP_ACTIVATE_ACTIVATION_CONTEXT(LdrDataTableEntry);
                    LdrpCallInitRoutine(InitRoutine,
                                        LdrDataTableEntry->DllBase,
                                        DLL_PROCESS_DETACH,
                                        NULL);
                    LDRP_DEACTIVATE_ACTIVATION_CONTEXT();

#if defined(_AMD64_) // || defined(_IA64_)


                    RtlRemoveInvertedFunctionTable(&LdrpInvertedFunctionTable,
                                                   Entry->DllBase);

#endif

                    RemoveEntryList(&Entry->InLoadOrderLinks);
                    Entry = NULL;
                    Next = LdrpUnloadHead.Flink;
                    }
                except(LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)){
                    DbgPrintEx(
                        DPFLTR_LDR_ID,
                        LDR_ERROR_DPFLTR,
                        "LDR: %s - exception %08lx caught while sending DLL_PROCESS_DETACH\n",
                        __FUNCTION__,
                        GetExceptionCode());

                    DbgPrintEx(
                        DPFLTR_LDR_ID,
                        LDR_ERROR_DPFLTR,
                        "   Dll Name: %wZ\n",
                        &LdrDataTableEntry->FullDllName);

                    DbgPrintEx(
                        DPFLTR_LDR_ID,
                        LDR_ERROR_DPFLTR,
                        "   InitRoutine: %p\n",
                        InitRoutine);

                    goto top;
                    }
            } else {

#if defined(_AMD64_) // || defined(_IA64_)


                RtlRemoveInvertedFunctionTable(&LdrpInvertedFunctionTable,
                                               Entry->DllBase);

#endif

                RemoveEntryList(&(Entry->InLoadOrderLinks));
                Entry = NULL;
                Next = LdrpUnloadHead.Flink;
            }
        }
bottom:

        //
        // Now, go through the modules and unmap them
        //

        Next = LocalUnloadHead.Flink;
        while ( Next != &LocalUnloadHead ) {
            LdrDataTableEntry
                = (PLDR_DATA_TABLE_ENTRY)
                  (CONTAINING_RECORD(Next,LDR_DATA_TABLE_ENTRY,HashLinks));

            Next = Next->Flink;
            Entry = LdrDataTableEntry;

            //
            // Now that we called the all the init routines with `detach' 
            // there is no excuse if we find a live CS in that region.
            //
            // Note: gdi32.dll's critical sections are deleted only on
            // user32.dll'd DllMain( DLL_PROCESS_DETACH ) so we cannot 
            // do this check prior to this point.
            //

            RtlpCheckForCriticalSectionsInMemoryRange (LdrDataTableEntry->DllBase,
                                                       LdrDataTableEntry->SizeOfImage,
                                                       (PVOID)LdrDataTableEntry);

            //
            // Notify verifier that a dll will be unloaded.
            //

            if (NtCurrentPeb()->NtGlobalFlag & FLG_APPLICATION_VERIFIER) {
                AVrfDllUnloadNotification (LdrDataTableEntry);
            }

            //
            // Unmap this DLL.
            //

            if (ShowSnaps) {
                  DbgPrint("LDR: Unmapping [%ws]\n",
                          LdrDataTableEntry->BaseDllName.Buffer
                          );
                }
            

            Cor20Header =  RtlImageDirectoryEntryToData(Entry->DllBase,
                                                        TRUE,
                                                        IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR,
                                                        &Cor20HeaderSize);
            if (Cor20Header != NULL) {
                LdrpCorUnloadImage(Entry->DllBase);
            }
            if (!(Entry->Flags & LDRP_COR_OWNS_UNMAP)) {
                st = NtUnmapViewOfSection(NtCurrentProcess(),Entry->DllBase);
                ASSERT(NT_SUCCESS(st));
            }

            LdrUnloadAlternateResourceModule(Entry->DllBase);

            LdrpSendDllUnloadedNotifications(Entry, (LdrpShutdownInProgress ? LDR_DLL_UNLOADED_FLAG_PROCESS_TERMINATION : 0));

            LdrpFinalizeAndDeallocateDataTableEntry(Entry);

            if ( Entry == LdrpGetModuleHandleCache ) {
                LdrpGetModuleHandleCache = NULL;
                }
            }

leave_finally:;
        }
    finally {
        LdrpActiveUnloadCount--;
        if (!LdrpInLdrInit)
            RtlLeaveCriticalSection(&LdrpLoaderLock);
        }
    return st;
}

NTSTATUS
LdrGetProcedureAddress (
    IN PVOID DllHandle,
    IN CONST ANSI_STRING* ProcedureName OPTIONAL,
    IN ULONG ProcedureNumber OPTIONAL,
    OUT PVOID *ProcedureAddress
    )
{
    return LdrpGetProcedureAddress(DllHandle,ProcedureName,ProcedureNumber,ProcedureAddress,TRUE);
}

NTSTATUS
LdrpGetProcedureAddress (
    IN PVOID DllHandle,
    IN CONST ANSI_STRING* ProcedureName OPTIONAL,
    IN ULONG ProcedureNumber OPTIONAL,
    OUT PVOID *ProcedureAddress,
    IN BOOLEAN RunInitRoutines
    )

/*++

Routine Description:

    This function locates the address of the specified procedure in the
    specified DLL and returns its address.

Arguments:

    DllHandle - Supplies a handle to the DLL that the address is being
        looked up in.

    ProcedureName - Supplies that address of a string that contains the
        name of the procedure to lookup in the DLL.  If this argument is
        not specified, then the ProcedureNumber is used.

    ProcedureNumber - Supplies the procedure number to lookup.  If
        ProcedureName is specified, then this argument is ignored.
        Otherwise, it specifies the procedure ordinal number to locate
        in the DLL.

    ProcedureAddress - Returns the address of the procedure found in
        the DLL.

Return Value:

    TBD

--*/

{
    NTSTATUS st;
    UCHAR FunctionNameBuffer[64];
    ULONG cb, ExportSize;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    IMAGE_THUNK_DATA Thunk;
    PVOID ImageBase;
    PIMAGE_IMPORT_BY_NAME FunctionName;
    PIMAGE_EXPORT_DIRECTORY ExportDirectory;
    PLIST_ENTRY Next;

    if (ShowSnaps) {
        DbgPrint("LDR: LdrGetProcedureAddress by ");
    }

    FunctionName = NULL;
    if ( ARGUMENT_PRESENT(ProcedureName) ) {

        if (ShowSnaps) {
            DbgPrint("NAME - %s\n", ProcedureName->Buffer);
        }

        if (ProcedureName->Length >= sizeof( FunctionNameBuffer )-1 ) {
            FunctionName = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TEMP_TAG ),ProcedureName->Length+1+sizeof(USHORT));
            if ( !FunctionName ) {
                return STATUS_INVALID_PARAMETER;
                }
        } else {
            FunctionName = (PIMAGE_IMPORT_BY_NAME) FunctionNameBuffer;
        }

        FunctionName->Hint = 0;

        cb = ProcedureName->Length;

        RtlCopyMemory (FunctionName->Name, ProcedureName->Buffer, cb);

        FunctionName->Name[cb] = '\0';

        //
        // Make sure we don't pass in address with high bit set so we
        // can still use it as ordinal flag
        //

        ImageBase = FunctionName;
        Thunk.u1.AddressOfData = 0;

    } else {
            ImageBase = NULL;
             if (ShowSnaps) {
                 DbgPrint("ORDINAL - %lx\n", ProcedureNumber);
             }

             if (ProcedureNumber) {
                 Thunk.u1.Ordinal = ProcedureNumber | IMAGE_ORDINAL_FLAG;
             } else {
                      return STATUS_INVALID_PARAMETER;
                    }
          }

    if (!LdrpInLdrInit)
        RtlEnterCriticalSection(&LdrpLoaderLock);

    try {

        if (!LdrpCheckForLoadedDllHandle(DllHandle, &LdrDataTableEntry)) {
            st = STATUS_DLL_NOT_FOUND;
            return st;
        }

        ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData(
                           LdrDataTableEntry->DllBase,
                           TRUE,
                           IMAGE_DIRECTORY_ENTRY_EXPORT,
                           &ExportSize
                           );

        if (!ExportDirectory) {
            return STATUS_PROCEDURE_NOT_FOUND;
        }

        st = LdrpSnapThunk(LdrDataTableEntry->DllBase,
                           ImageBase,
                           &Thunk,
                           &Thunk,
                           ExportDirectory,
                           ExportSize,
                           FALSE,
                           NULL
                          );

        if ( RunInitRoutines ) {
            PLDR_DATA_TABLE_ENTRY LdrInitEntry;

            //
            // Look at last entry in init order list. If entry processed
            // flag is not set, then a forwarded dll was loaded during the
            // getprocaddr call and we need to run init routines
            //

            Next = NtCurrentPeb()->Ldr->InInitializationOrderModuleList.Blink;
            LdrInitEntry = CONTAINING_RECORD(Next, LDR_DATA_TABLE_ENTRY, InInitializationOrderLinks);
            if ( !(LdrInitEntry->Flags & LDRP_ENTRY_PROCESSED) ) {
                
                //
                // Shim engine callback. This is the chance to patch
                // dynamically loaded modules.
                //

                /*
                if (g_pfnSE_DllLoaded != NULL) {
                    (*g_pfnSE_DllLoaded)(NULL);
                }
                */
                
                try {
                    st = LdrpRunInitializeRoutines(NULL);
                    }
                except(LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
                    st = GetExceptionCode();

                    DbgPrintEx(
                        DPFLTR_LDR_ID,
                        LDR_ERROR_DPFLTR,
                        "LDR: %s - Exception %x thrown by LdrpRunInitializeRoutines\n",
                        __FUNCTION__,
                        st);
                    }

                }
            }

        if ( NT_SUCCESS(st) ) {
            *ProcedureAddress = (PVOID)Thunk.u1.Function;

            //
            // Shim engine callback. Modify the address of the procedure if needed
            //

            if (g_pfnSE_GetProcAddress != NULL) {
                (*g_pfnSE_GetProcAddress)(ProcedureAddress);
                }

            }
    } finally {
        if ( FunctionName && (FunctionName != (PIMAGE_IMPORT_BY_NAME) FunctionNameBuffer) ) {
            RtlFreeHeap(RtlProcessHeap(),0,FunctionName);
            }

        if (!LdrpInLdrInit)
            RtlLeaveCriticalSection(&LdrpLoaderLock);
    }
    return st;
}

NTSTATUS
NTAPI
LdrVerifyImageMatchesChecksum (
    IN HANDLE ImageFileHandle,      
    IN PLDR_IMPORT_MODULE_CALLBACK ImportCallbackRoutine OPTIONAL,
    IN PVOID ImportCallbackParameter,
    OUT PUSHORT ImageCharacteristics OPTIONAL
    )
{
    NTSTATUS Status;
    HANDLE Section;
    PVOID ViewBase;
    SIZE_T ViewSize;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_STANDARD_INFORMATION StandardInfo;
    PIMAGE_SECTION_HEADER LastRvaSection;
    BOOLEAN b;
    BOOLEAN JustDoSideEffects;

    //
    // stevewo added all sorts of side effects to this API. We want to stop
    // doing checksums for known dll's, but really want the sideeffects
    // (ImageCharacteristics write, and Import descriptor walk).
    //

    if ( (UINT_PTR) ImageFileHandle & 1 ) {
        JustDoSideEffects = TRUE;
        }
    else {
        JustDoSideEffects = FALSE;
        }

    Status = NtCreateSection(
                &Section,
                SECTION_MAP_EXECUTE,
                NULL,
                NULL,
                PAGE_EXECUTE,
                SEC_COMMIT,
                ImageFileHandle
                );
    if ( !NT_SUCCESS(Status) ) {
        return Status;
        }

    ViewBase = NULL;
    ViewSize = 0;

    Status = NtMapViewOfSection(
                Section,
                NtCurrentProcess(),
                (PVOID *)&ViewBase,
                0L,
                0L,
                NULL,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_EXECUTE
                );

    if ( !NT_SUCCESS(Status) ) {
        NtClose(Section);
        return Status;
        }

    //
    // now the image is mapped as a data file... Calculate it's size and then
    // check it's checksum
    //

    Status = NtQueryInformationFile(
                ImageFileHandle,
                &IoStatusBlock,
                &StandardInfo,
                sizeof(StandardInfo),
                FileStandardInformation
                );

    if ( !NT_SUCCESS(Status) ) {
        NtUnmapViewOfSection(NtCurrentProcess(),ViewBase);
        NtClose(Section);
        return Status;
        }

    try {
        if ( JustDoSideEffects ) {
            b = TRUE;
            }
        else {
            b = LdrVerifyMappedImageMatchesChecksum(ViewBase,StandardInfo.EndOfFile.LowPart);
            }
        if (b && ARGUMENT_PRESENT( ImportCallbackRoutine )) {
            PIMAGE_NT_HEADERS NtHeaders;
            PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor;
            ULONG ImportSize;
            PCHAR ImportName;

            //
            // Caller wants to enumerate the import descriptors while we have
            // the image mapped.  Call back to their routine for each module
            // name in the import descriptor table.
            //
            LastRvaSection = NULL;
            NtHeaders = RtlImageNtHeader( ViewBase );
            if (ARGUMENT_PRESENT( ImageCharacteristics )) {
                *ImageCharacteristics = NtHeaders->FileHeader.Characteristics;
                }

            ImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)
                RtlImageDirectoryEntryToData( ViewBase,
                                              FALSE,
                                              IMAGE_DIRECTORY_ENTRY_IMPORT,
                                              &ImportSize
                                            );
            if (ImportDescriptor != NULL) {
                while (ImportDescriptor->Name) {
                    ImportName = (PSZ)RtlImageRvaToVa( NtHeaders,
                                                       ViewBase,
                                                       ImportDescriptor->Name,
                                                       &LastRvaSection
                                                     );
                    (*ImportCallbackRoutine)( ImportCallbackParameter, ImportName );
                    ImportDescriptor += 1;
                    }
                }
            }
        }
    except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s - caught exception %08lx while checking image checksums\n",
            __FUNCTION__,
            GetExceptionCode());

        NtUnmapViewOfSection(NtCurrentProcess(),ViewBase);
        NtClose(Section);
        return STATUS_IMAGE_CHECKSUM_MISMATCH;
        }
    NtUnmapViewOfSection(NtCurrentProcess(),ViewBase);
    NtClose(Section);
    if ( !b ) {
        Status = STATUS_IMAGE_CHECKSUM_MISMATCH;
        }
    return Status;
}

NTSTATUS 
LdrReadMemory(
    IN HANDLE Process OPTIONAL,
    IN PVOID BaseAddress,
    IN OUT PVOID Buffer,
    IN SIZE_T Size)
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (ARGUMENT_PRESENT( Process )) {
        SIZE_T nRead;
        Status = NtReadVirtualMemory(Process, BaseAddress, Buffer, Size, &nRead);

        if (NT_SUCCESS( Status ) && (Size != nRead)) {
            Status = STATUS_UNSUCCESSFUL;
        }
    }
    else {
        __try {
            RtlCopyMemory(Buffer, BaseAddress, Size);
        }
        __except(LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - exception %08lx caught while copying %u bytes from %p to %p\n",
                __FUNCTION__,
                GetExceptionCode(),
                BaseAddress,
                Buffer);

            if (NT_SUCCESS(Status = GetExceptionCode())) {
                Status = STATUS_UNSUCCESSFUL;
            }
        }
    }
    return Status;
}

NTSTATUS 
LdrGetModuleName(
    IN HANDLE Process OPTIONAL,
    IN PUNICODE_STRING LdrFullDllName,
    IN OUT PRTL_PROCESS_MODULE_INFORMATION ModuleInfo,
    IN BOOL Wow64Redirect)
{
    NTSTATUS Status;
    UNICODE_STRING FullDllName;
    ANSI_STRING AnsiString;
    PCHAR s;
    WCHAR Buffer[ LDR_NUMBER_OF(ModuleInfo->FullPathName) + 1];
    USHORT Length = (USHORT)min(LdrFullDllName->Length, 
                                sizeof(Buffer) - sizeof(Buffer[0]));

    Status = LdrReadMemory(Process, 
                           LdrFullDllName->Buffer, 
                           Buffer,
                           Length);

    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    Buffer[LDR_NUMBER_OF(Buffer) - 1] = UNICODE_NULL;  // Ensure NULL termination
    
#if defined(_WIN64)
    if (Wow64Redirect) {
    
        C_ASSERT( WOW64_SYSTEM_DIRECTORY_U_SIZE == 
                  (sizeof(L"system32") - sizeof(WCHAR)));
                  
        // including preceding '\\' if exists
        SIZE_T System32Offset = wcslen(USER_SHARED_DATA->NtSystemRoot);
        ASSERT(System32Offset != 0);
        
        if (USER_SHARED_DATA->NtSystemRoot[System32Offset - 1] == L'\\') {
            --System32Offset;
        }

        if (!_wcsnicmp(Buffer, USER_SHARED_DATA->NtSystemRoot, System32Offset) &&
            !_wcsnicmp(Buffer + System32Offset, 
                       L"\\system32", 
                       WOW64_SYSTEM_DIRECTORY_U_SIZE / sizeof(WCHAR) + 1)) {
                       
            RtlCopyMemory(Buffer + System32Offset + 1,
                          WOW64_SYSTEM_DIRECTORY_U,
                          WOW64_SYSTEM_DIRECTORY_U_SIZE);
        }
    }
#endif // defined(_WIN64)
    
    FullDllName.Buffer = Buffer;
    FullDllName.Length = FullDllName.MaximumLength = Length;

    AnsiString.Buffer = (PCHAR)ModuleInfo->FullPathName;
    AnsiString.Length = 0;
    AnsiString.MaximumLength = sizeof( ModuleInfo->FullPathName );

    RtlUnicodeStringToAnsiString(&AnsiString,
                                 &FullDllName,
                                 FALSE);

    s = AnsiString.Buffer + AnsiString.Length;
    while (s > AnsiString.Buffer && *--s) {
        if (*s == (UCHAR)OBJ_NAME_PATH_SEPARATOR) {
            s++;
            break;
        }
    }

    ModuleInfo->OffsetToFileName = (USHORT)(s - AnsiString.Buffer);
    return STATUS_SUCCESS;
}

NTSTATUS
LdrQueryProcessPeb(
    IN HANDLE Process OPTIONAL,
    IN OUT PPEB* Peb)
{
    NTSTATUS Status;
    if (ARGUMENT_PRESENT( Process )) {
        PROCESS_BASIC_INFORMATION BasicInfo;

        Status = NtQueryInformationProcess(Process, 
                                           ProcessBasicInformation,
                                           &BasicInfo, sizeof(BasicInfo),
                                           NULL);

        if (NT_SUCCESS( Status )) {
            *Peb = BasicInfo.PebBaseAddress;
        }
    }
    else {
        *Peb = NtCurrentPeb();
        Status = STATUS_SUCCESS;
    }

    return Status;
}

NTSTATUS
LdrQueryInLoadOrderModuleList(
    IN HANDLE Process OPTIONAL,
    IN OUT PLIST_ENTRY* Head,
    IN OUT PLIST_ENTRY* InInitOrderHead OPTIONAL)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PPEB Peb;
    PPEB_LDR_DATA Ldr;

    Status = LdrQueryProcessPeb( Process, &Peb );

    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    if (!Peb) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Ldr = Peb->Ldr
    //

    Status = LdrReadMemory( Process, 
                            &Peb->Ldr, 
                            &Ldr, sizeof(Ldr));

    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    if (!Ldr) {
        if (ARGUMENT_PRESENT( Process )) {
            *Head = NULL;
            return STATUS_SUCCESS;
        }
        else {
            return STATUS_UNSUCCESSFUL;
        }
    }

    *Head = &Ldr->InLoadOrderModuleList;

    if (ARGUMENT_PRESENT( InInitOrderHead )) {
        *InInitOrderHead = &Ldr->InInitializationOrderModuleList;
    }

    return Status;
}

NTSTATUS 
LdrQueryNextListEntry(
    IN HANDLE Process OPTIONAL,
    IN PLIST_ENTRY Head,
    IN OUT PLIST_ENTRY* Tail)
{
    NTSTATUS Status = STATUS_SUCCESS;

    Status = LdrReadMemory(Process, 
                           &Head->Flink, 
                           Tail, sizeof(*Tail));
    return Status;
}

NTSTATUS
LdrQueryModuleInfoFromLdrEntry(
    IN HANDLE Process OPTIONAL,
    IN PRTL_PROCESS_MODULES ModuleInformation, 
    IN OUT PRTL_PROCESS_MODULE_INFORMATION ModuleInfo,
    IN PLIST_ENTRY LdrEntry,
    IN PLIST_ENTRY InitOrderList)
{
    NTSTATUS Status;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntryPtr;
    LDR_DATA_TABLE_ENTRY LdrDataTableEntry;

    ANSI_STRING AnsiString;
    PCHAR s;

    LdrDataTableEntryPtr = CONTAINING_RECORD(LdrEntry, 
                                             LDR_DATA_TABLE_ENTRY, 
                                             InLoadOrderLinks);

    Status = LdrReadMemory(Process, 
                           LdrEntry, 
                           &LdrDataTableEntry, 
                           sizeof(LdrDataTableEntry));

    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    ModuleInfo->ImageBase = LdrDataTableEntry.DllBase;
    ModuleInfo->ImageSize = LdrDataTableEntry.SizeOfImage;
    ModuleInfo->Flags     = LdrDataTableEntry.Flags;
    ModuleInfo->LoadCount = LdrDataTableEntry.LoadCount;
    
    if (!ARGUMENT_PRESENT( Process )) {
        UINT LoopDetectorCount = 10240;  // 10K modules max
        PLIST_ENTRY Next1 = InitOrderList->Flink;

        while ( Next1 != InitOrderList ) {
            PLDR_DATA_TABLE_ENTRY Entry1 = 
                CONTAINING_RECORD(Next1,
                                  LDR_DATA_TABLE_ENTRY,
                                  InInitializationOrderLinks);

            ModuleInfo->InitOrderIndex++;

            if ((LdrDataTableEntryPtr == Entry1) ||
                (!LoopDetectorCount--)) 
            {
                break;
            }

            Next1 = Next1->Flink;
        } 
    }

    Status = LdrGetModuleName(Process, 
                              &LdrDataTableEntry.FullDllName, 
                              ModuleInfo, 
                              FALSE);

    return Status;
}

PRTL_CRITICAL_SECTION
LdrQueryModuleInfoLocalLoaderLock(VOID)
{
    PRTL_CRITICAL_SECTION LoaderLock = NULL;

    if (!LdrpInLdrInit) {
        LoaderLock = &LdrpLoaderLock;

        if (LoaderLock != NULL)
            RtlEnterCriticalSection(LoaderLock);
    }

    return LoaderLock;
}

VOID
LdrQueryModuleInfoLocalLoaderUnlock(
    IN PRTL_CRITICAL_SECTION LoaderLock)
{
    if (LoaderLock) {
        RtlLeaveCriticalSection(LoaderLock);
    }
}

#if defined(_WIN64)
NTSTATUS
LdrQueryProcessPeb32(
    IN HANDLE Process OPTIONAL,
    IN OUT PPEB32* Peb)
{
    NTSTATUS Status;
    Status = NtQueryInformationProcess(ARGUMENT_PRESENT( Process ) ? 
                                            Process : NtCurrentProcess(),
                                       ProcessWow64Information,
                                       Peb, sizeof(*Peb),
                                       NULL);
    return Status;
}

NTSTATUS
LdrQueryInLoadOrderModuleList32(
    IN HANDLE Process OPTIONAL,
    IN OUT PLIST_ENTRY32* Head,
    IN OUT PLIST_ENTRY32* InInitOrderHead OPTIONAL)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PPEB32 Peb;
    PPEB_LDR_DATA32 Ldr;
    ULONG32 Ptr32;

    Status = LdrQueryProcessPeb32( Process, &Peb );

    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    if (!Peb) {
        //
        // May be process just don't have 32bit peb
        //

        *Head = NULL;
        return STATUS_SUCCESS;
    }

    //
    // Ldr = Peb->Ldr
    //

    Status = LdrReadMemory(Process, 
                           &Peb->Ldr, 
                           &Ptr32, sizeof(Ptr32));

    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    Ldr = (PPEB_LDR_DATA32)(ULONG_PTR)Ptr32;

    if (!Ldr) {
        *Head = NULL;
        return STATUS_SUCCESS;
    }

    *Head = &Ldr->InLoadOrderModuleList;

    if (ARGUMENT_PRESENT( InInitOrderHead )) {
        *InInitOrderHead = &Ldr->InInitializationOrderModuleList;
    }

    return Status;
}

NTSTATUS 
LdrQueryNextListEntry32(
    IN HANDLE Process OPTIONAL,
    IN PLIST_ENTRY32 Head,
    IN OUT PLIST_ENTRY32* Tail)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG32 Ptr32;

    Status = LdrReadMemory(Process, 
                           &Head->Flink, 
                           &Ptr32, sizeof(Ptr32));

    *Tail = (PLIST_ENTRY32)(ULONG_PTR)Ptr32;

    return Status;
}

NTSTATUS
LdrQueryModuleInfoFromLdrEntry32(
    IN HANDLE Process OPTIONAL,
    IN PRTL_PROCESS_MODULES ModuleInformation, 
    IN OUT PRTL_PROCESS_MODULE_INFORMATION ModuleInfo,
    IN PLIST_ENTRY32 LdrEntry,
    IN PLIST_ENTRY32 InitOrderList)
{
    NTSTATUS Status;
    PLDR_DATA_TABLE_ENTRY32 LdrDataTableEntryPtr;
    LDR_DATA_TABLE_ENTRY32 LdrDataTableEntry;
    UNICODE_STRING FullDllName;

    LdrDataTableEntryPtr = CONTAINING_RECORD(LdrEntry,
                                             LDR_DATA_TABLE_ENTRY32,
                                             InLoadOrderLinks);

    Status = LdrReadMemory(Process, 
                           LdrEntry, 
                           &LdrDataTableEntry, 
                           sizeof(LdrDataTableEntry));

    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    ModuleInfo->ImageBase = (PVOID)(ULONG_PTR)
                            LdrDataTableEntry.DllBase;
    ModuleInfo->ImageSize = LdrDataTableEntry.SizeOfImage;
    ModuleInfo->Flags     = LdrDataTableEntry.Flags;
    ModuleInfo->LoadCount = LdrDataTableEntry.LoadCount;

    if (!ARGUMENT_PRESENT( Process )) {
        UINT LoopDetectorCount = 500;
        PLIST_ENTRY32 Next1 = (PLIST_ENTRY32)(ULONG_PTR)
            (InitOrderList->Flink);

        while ( Next1 != InitOrderList ) {
            PLDR_DATA_TABLE_ENTRY32 Entry1 = 
                CONTAINING_RECORD(Next1,
                                  LDR_DATA_TABLE_ENTRY32,
                                  InInitializationOrderLinks);

            ModuleInfo->InitOrderIndex++;

            if ((LdrDataTableEntryPtr == Entry1) ||
                (!LoopDetectorCount--)) 
            {
                break;
            }

            Next1 = (PLIST_ENTRY32)(ULONG_PTR)(Next1->Flink);
        }
    }

    FullDllName.Buffer = (PWSTR)(ULONG_PTR)LdrDataTableEntry.FullDllName.Buffer;
    FullDllName.Length = LdrDataTableEntry.FullDllName.Length;
    FullDllName.MaximumLength = LdrDataTableEntry.FullDllName.MaximumLength;

    Status = LdrGetModuleName(Process, &FullDllName, ModuleInfo, TRUE);

    return Status;
}

PRTL_CRITICAL_SECTION32
LdrQueryModuleInfoLocalLoaderLock32(VOID)
{
    return NULL;
}

VOID
LdrQueryModuleInfoLocalLoaderUnlock32(
    PRTL_CRITICAL_SECTION32 LoaderLock)
{
}

#endif // defined(_WIN64)

typedef 
NTSTATUS
(*PLDR_QUERY_IN_LOAD_ORDER_MODULE_LIST)(
    IN HANDLE Process OPTIONAL,
    IN OUT PLIST_ENTRY* Head,
    IN OUT PLIST_ENTRY* InInitOrderHead OPTIONAL);

typedef NTSTATUS 
(*PLDR_QUERY_NEXT_LIST_ENTRY)(
    IN HANDLE Process OPTIONAL,
    IN PLIST_ENTRY Head,
    IN OUT PLIST_ENTRY* Tail);

typedef 
NTSTATUS
(*PLDR_QUERY_MODULE_INFO_FROM_LDR_ENTRY)(
    IN HANDLE Process OPTIONAL,
    IN PRTL_PROCESS_MODULES ModuleInformation, 
    IN OUT PRTL_PROCESS_MODULE_INFORMATION ModuleInfo,
    IN PLIST_ENTRY LdrEntry,
    IN PLIST_ENTRY InitOrderList);

typedef
PRTL_CRITICAL_SECTION
(*PLDR_QUERY_MODULE_INFO_LOCAL_LOADER_LOCK)(VOID);

typedef
VOID
(*PLDR_QUERY_MODULE_INFO_LOCAL_LOADER_UNLOCK)(PRTL_CRITICAL_SECTION);

static struct {
    PLDR_QUERY_IN_LOAD_ORDER_MODULE_LIST LdrQueryInLoadOrderModuleList;
    PLDR_QUERY_NEXT_LIST_ENTRY LdrQueryNextListEntry;
    PLDR_QUERY_MODULE_INFO_FROM_LDR_ENTRY LdrQueryModuleInfoFromLdrEntry;
    PLDR_QUERY_MODULE_INFO_LOCAL_LOADER_LOCK LdrQueryModuleInfoLocalLoaderLock;
    PLDR_QUERY_MODULE_INFO_LOCAL_LOADER_UNLOCK LdrQueryModuleInfoLocalLoaderUnlock;
} LdrQueryMethods[] = {
    { 
        LdrQueryInLoadOrderModuleList, 
        LdrQueryNextListEntry, 
        LdrQueryModuleInfoFromLdrEntry,
        LdrQueryModuleInfoLocalLoaderLock,
        LdrQueryModuleInfoLocalLoaderUnlock
    }
#if defined(_WIN64)
    ,
    { 
        (PLDR_QUERY_IN_LOAD_ORDER_MODULE_LIST)LdrQueryInLoadOrderModuleList32,
        (PLDR_QUERY_NEXT_LIST_ENTRY)LdrQueryNextListEntry32,
        (PLDR_QUERY_MODULE_INFO_FROM_LDR_ENTRY)LdrQueryModuleInfoFromLdrEntry32,
        (PLDR_QUERY_MODULE_INFO_LOCAL_LOADER_LOCK)LdrQueryModuleInfoLocalLoaderLock32,
        (PLDR_QUERY_MODULE_INFO_LOCAL_LOADER_UNLOCK)LdrQueryModuleInfoLocalLoaderUnlock32
    }
#endif defined(_WIN64)
}; 

NTSTATUS
LdrQueryProcessModuleInformationEx(
    IN HANDLE Process OPTIONAL,
    IN ULONG_PTR Flags OPTIONAL,
    OUT PRTL_PROCESS_MODULES ModuleInformation,
    IN ULONG ModuleInformationLength,
    OUT PULONG ReturnLength OPTIONAL)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PRTL_CRITICAL_SECTION LoaderLock = NULL;
    SIZE_T mid;

    ULONG RequiredLength = FIELD_OFFSET( RTL_PROCESS_MODULES, Modules );

    PLIST_ENTRY List;
    PLIST_ENTRY InInitOrderList;

    PRTL_PROCESS_MODULE_INFORMATION ModuleInfo;
    
    if (ModuleInformationLength < RequiredLength) {
        Status = STATUS_INFO_LENGTH_MISMATCH;
        ModuleInfo = NULL;
    }
    else {
        ModuleInformation->NumberOfModules = 0;
        ModuleInfo = &ModuleInformation->Modules[ 0 ];
        Status = STATUS_SUCCESS;
    }

    for (mid = 0; 
         mid < (ARGUMENT_PRESENT( Flags ) ? LDR_NUMBER_OF(LdrQueryMethods) : 1); 
         ++mid) 
    {
        NTSTATUS Status1;
        PLIST_ENTRY Entry;

        __try {
            UINT LoopDetectorCount = 10240; // allow not more than 10K modules

            if ( !ARGUMENT_PRESENT( Process )) {
                LoaderLock = LdrQueryMethods[mid].LdrQueryModuleInfoLocalLoaderLock();
            } 

            Status1 = LdrQueryMethods[mid].LdrQueryInLoadOrderModuleList(Process, &List, &InInitOrderList);

            if (!NT_SUCCESS( Status1 )) {
                return Status1;
            }

            if (!List) {
                return Status;
            }

            Status1 = LdrQueryMethods[mid].LdrQueryNextListEntry(Process, 
                                                                 List, 
                                                                 &Entry);
            if (!NT_SUCCESS( Status1 )) {
                return Status1;
            }

            while (Entry != List) {
                if (!LoopDetectorCount--) {
                    return STATUS_FAIL_CHECK;
                }

                RequiredLength += sizeof( RTL_PROCESS_MODULE_INFORMATION );

                if (ModuleInformationLength < RequiredLength) {
                    Status = STATUS_INFO_LENGTH_MISMATCH;
                }
                else {
                    Status1 = LdrQueryMethods[mid].LdrQueryModuleInfoFromLdrEntry(Process, 
                                                                                  ModuleInformation, 
                                                                                  ModuleInfo, 
                                                                                  Entry, InInitOrderList);

                    if (!NT_SUCCESS( Status1 )) {
                        return Status1;
                    }

                    ModuleInfo++;
                }

                if (ModuleInformation != NULL) {
                    ModuleInformation->NumberOfModules++;
                }

                Status1 = LdrQueryMethods[mid].LdrQueryNextListEntry(Process, 
                                                                     Entry, 
                                                                     &Entry);

                if (!NT_SUCCESS( Status1 )) {
                    return Status1;
                }

            } // while
        }
        __finally {
            if (LoaderLock) {
                LdrQueryMethods[mid].LdrQueryModuleInfoLocalLoaderUnlock(LoaderLock);
            }

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = RequiredLength;
            }
        }
    } // for

    return Status;
}

NTSTATUS
LdrQueryProcessModuleInformation(
    OUT PRTL_PROCESS_MODULES ModuleInformation,
    IN ULONG ModuleInformationLength,
    OUT PULONG ReturnLength OPTIONAL)
{
    return LdrQueryProcessModuleInformationEx(NULL, 
                                              0,
                                              ModuleInformation, 
                                              ModuleInformationLength, 
                                              ReturnLength);
}


#if defined(MIPS)
VOID
LdrProcessStarterHelper(
    IN PPROCESS_STARTER_ROUTINE ProcessStarter,
    IN PVOID RealStartAddress
    )

/*++

Routine Description:

    This function is used to call the code that calls the initial entry point
    of a win32 process. On all other platforms, this wrapper is not used since
    they can cope with a process entrypoint being in kernel32 prior to it being
    mapped.

Arguments:

    ProcessStarter - Supplies the address of the function in Kernel32 that ends up
        calling the real process entrypoint

    RealStartAddress - Supplies the real start address of the process
    .

Return Value:

    None.

--*/

{
    (ProcessStarter)(RealStartAddress);
    NtTerminateProcess(NtCurrentProcess(),0);
}

#endif

NTSTATUS
NTAPI
LdrRegisterDllNotification(
    ULONG Flags,
    PLDR_DLL_NOTIFICATION_FUNCTION NotificationFunction,
    PVOID Context,
    PVOID *Cookie
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLDRP_DLL_NOTIFICATION_BLOCK NotificationBlock = NULL;
    BOOLEAN HoldingLoaderLock = FALSE;
    const BOOLEAN InLdrInit = LdrpInLdrInit;
    PVOID LockCookie = NULL;

    __try {
        if (Cookie != NULL)
            *Cookie = NULL;

        if ((Flags != 0) ||
            (Cookie == NULL) ||
            (NotificationFunction == NULL)) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        NotificationBlock = (PLDRP_DLL_NOTIFICATION_BLOCK)
                RtlAllocateHeap(RtlProcessHeap(), 0, sizeof(LDRP_DLL_NOTIFICATION_BLOCK));
        if (NotificationBlock == NULL) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }

        NotificationBlock->NotificationFunction = NotificationFunction;
        NotificationBlock->Context = Context;

        if (!InLdrInit) {
            __try {
                Status = LdrLockLoaderLock(0, NULL, &LockCookie);
                if (!NT_SUCCESS(Status))
                    goto Exit;
                HoldingLoaderLock = TRUE;
            } __except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
                Status = GetExceptionCode();
                goto Exit;
            }
        }

        InsertTailList(&LdrpDllNotificationList, &NotificationBlock->Links);

        *Cookie = (PVOID) NotificationBlock;
        NotificationBlock = NULL;

        Status = STATUS_SUCCESS;
Exit:
        ;
    } __finally {
        if (HoldingLoaderLock) {
            LdrUnlockLoaderLock(LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, LockCookie);
            HoldingLoaderLock = FALSE;
        }
        if (NotificationBlock != NULL)
            RtlFreeHeap(RtlProcessHeap(), 0, NotificationBlock);
    }
    return Status;
}

NTSTATUS
NTAPI
LdrUnregisterDllNotification(
    PVOID Cookie
    )
{
    PLDRP_DLL_NOTIFICATION_BLOCK NotificationBlock = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN HoldingLoaderLock = FALSE;
    const BOOLEAN InLdrInit = LdrpInLdrInit;
    PVOID LockCookie = NULL;

    __try {
        if (Cookie == NULL
            ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        if (!InLdrInit) {
            __try {
                Status = LdrLockLoaderLock(0, NULL, &LockCookie);
                if (!NT_SUCCESS(Status))
                    goto Exit;
                HoldingLoaderLock = TRUE;
            } __except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
                Status = GetExceptionCode();
                goto Exit;
            }
        }

        NotificationBlock = CONTAINING_RECORD(LdrpDllNotificationList.Flink, LDRP_DLL_NOTIFICATION_BLOCK, Links);

        while (&NotificationBlock->Links != &LdrpDllNotificationList) {
            if (NotificationBlock == Cookie)
                break;
            NotificationBlock = CONTAINING_RECORD(NotificationBlock->Links.Flink, LDRP_DLL_NOTIFICATION_BLOCK, Links);
        }

        if (&NotificationBlock->Links != &LdrpDllNotificationList) {
            RemoveEntryList(&NotificationBlock->Links);
            RtlFreeHeap(RtlProcessHeap(), 0, NotificationBlock);
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_NOT_FOUND;
        }
Exit:
        ;
    } __finally {
        if (HoldingLoaderLock) {
            LdrUnlockLoaderLock(LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, LockCookie);
            HoldingLoaderLock = FALSE;
        }
    }
    return Status;
}

VOID
LdrpSendDllUnloadedNotifications(
    PLDR_DATA_TABLE_ENTRY Entry,
    ULONG Flags
    )
{
    PLIST_ENTRY Next;
    LDR_DLL_NOTIFICATION_DATA Data;

    Data.Unloaded.Flags = Flags;
    Data.Unloaded.FullDllName = &Entry->FullDllName;
    Data.Unloaded.BaseDllName = &Entry->BaseDllName;
    Data.Unloaded.DllBase = Entry->DllBase;
    Data.Unloaded.SizeOfImage = Entry->SizeOfImage;

    Next = LdrpDllNotificationList.Flink;

    while (Next != &LdrpDllNotificationList) {
        PLDRP_DLL_NOTIFICATION_BLOCK Block = CONTAINING_RECORD(Next, LDRP_DLL_NOTIFICATION_BLOCK, Links);
        __try {
            (*Block->NotificationFunction)(LDR_DLL_NOTIFICATION_REASON_UNLOADED, &Data, Block->Context);
        } __except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
            // just go on to the next one...
        }
        Next = Next->Flink;
    }
}

VOID
LdrpSendDllLoadedNotifications(
    PLDR_DATA_TABLE_ENTRY Entry,
    ULONG Flags
    )
{
    PLIST_ENTRY Next;
    LDR_DLL_NOTIFICATION_DATA Data;

    Data.Loaded.Flags = Flags;
    Data.Loaded.FullDllName = &Entry->FullDllName;
    Data.Loaded.BaseDllName = &Entry->BaseDllName;
    Data.Loaded.DllBase = Entry->DllBase;
    Data.Loaded.SizeOfImage = Entry->SizeOfImage;

    Next = LdrpDllNotificationList.Flink;

    while (Next != &LdrpDllNotificationList) {
        PLDRP_DLL_NOTIFICATION_BLOCK Block = CONTAINING_RECORD(Next, LDRP_DLL_NOTIFICATION_BLOCK, Links);
        __try {
            (*Block->NotificationFunction)(LDR_DLL_NOTIFICATION_REASON_LOADED, &Data, Block->Context);
        } __except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
            // just go on to the next one...
        }
        Next = Next->Flink;
    }
}

BOOLEAN
NTAPI
RtlDllShutdownInProgress (
    VOID
    )
/*++

Routine Description:

    This routine returns the status of DLL shutdown.

Arguments:

    None

Return Value:

    BOOLEAN - TRUE: Shutdown is in progress, FALSE: Shutdown is not currently in progress.

--*/
{
    if (LdrpShutdownInProgress) {
        return TRUE;
    } else {
        return FALSE;
    }
}

NTSTATUS
NTAPI
LdrLockLoaderLock(
    ULONG Flags,
    ULONG *Disposition,
    PVOID *Cookie
    )
{
    NTSTATUS Status;
    PRTL_CRITICAL_SECTION LoaderLock;
    const BOOLEAN InLdrInit = LdrpInLdrInit;

    if (Disposition != NULL)
        *Disposition = LDR_LOCK_LOADER_LOCK_DISPOSITION_INVALID;

    if (Cookie != NULL)
        *Cookie = NULL;

    if ((Flags & ~(LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY | LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS)) != 0) {
        if (Flags & LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS)
            RtlRaiseStatus(STATUS_INVALID_PARAMETER_1);

        Status = STATUS_INVALID_PARAMETER_1;
        goto Exit;
    }

    if (Cookie == NULL) {
        if (Flags & LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS)
            RtlRaiseStatus(STATUS_INVALID_PARAMETER_3);

        Status = STATUS_INVALID_PARAMETER_3;
        goto Exit;
    }

    // If you hit this assertion failure, you specified that you only wanted to
    // try acquiring the lock, but you forgot to specify a Disposition out where
    // this function could indicate whether the lock was actually acquired.
    ASSERT((Disposition != NULL) || !(Flags & LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY));

    if ((Flags & LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY) &&
        (Disposition == NULL)) {
        if (Flags & LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS)
            RtlRaiseStatus(STATUS_INVALID_PARAMETER_2);

        Status = STATUS_INVALID_PARAMETER_2;
        goto Exit;
    }

    if (InLdrInit) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }

    if (Flags & LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS) {
        if (Flags & LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY) {
            if (RtlTryEnterCriticalSection(&LdrpLoaderLock)) {
                *Cookie = (PVOID) MAKE_LOADER_LOCK_COOKIE(LOADER_LOCK_COOKIE_TYPE_NORMAL, InterlockedIncrement(&LdrpLoaderLockAcquisitionCount));
                *Disposition = LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_ACQUIRED;
            } else {
                *Disposition = LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_NOT_ACQUIRED;
            }
        } else {
            RtlEnterCriticalSection(&LdrpLoaderLock);
            if (Disposition != NULL) {
                *Disposition = LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_ACQUIRED;
            }
            *Cookie = (PVOID) MAKE_LOADER_LOCK_COOKIE(LOADER_LOCK_COOKIE_TYPE_NORMAL, InterlockedIncrement(&LdrpLoaderLockAcquisitionCount));
        }
    } else {
        __try {
            if (Flags & LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY) {
                if (RtlTryEnterCriticalSection(&LdrpLoaderLock)) {
                    *Disposition = LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_ACQUIRED;
                    *Cookie = (PVOID) MAKE_LOADER_LOCK_COOKIE(LOADER_LOCK_COOKIE_TYPE_NORMAL, InterlockedIncrement(&LdrpLoaderLockAcquisitionCount));
                } else {
                    *Disposition = LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_NOT_ACQUIRED;
                }
            } else {
                RtlEnterCriticalSection(&LdrpLoaderLock);
                if (Disposition != NULL) {
                    *Disposition = LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_ACQUIRED;
                }
                *Cookie = (PVOID) MAKE_LOADER_LOCK_COOKIE(LOADER_LOCK_COOKIE_TYPE_NORMAL, InterlockedIncrement(&LdrpLoaderLockAcquisitionCount));
            }
        } __except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
            Status = GetExceptionCode();
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - Caught exception %08lx\n",
                __FUNCTION__,
                Status);
            goto Exit;
        }
    }

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

NTSTATUS
NTAPI
LdrUnlockLoaderLock(
    ULONG Flags,
    PVOID CookieIn
    )
{
    NTSTATUS Status;
    const ULONG_PTR Cookie = (ULONG_PTR) CookieIn;

    if ((Flags & ~(LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS)) != 0) {
        if (Flags & LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS)
            RtlRaiseStatus(STATUS_INVALID_PARAMETER_1);

        Status = STATUS_INVALID_PARAMETER_1;
        goto Exit;
    }

    if (CookieIn == NULL) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }

    // A little validation on the cookie...
    if (EXTRACT_LOADER_LOCK_COOKIE_TYPE(Cookie) != LOADER_LOCK_COOKIE_TYPE_NORMAL) {
        if (Flags & LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS)
            RtlRaiseStatus(STATUS_INVALID_PARAMETER_2);

        Status = STATUS_INVALID_PARAMETER_2;
        goto Exit;
    }

    if (EXTRACT_LOADER_LOCK_COOKIE_TID(Cookie) != (HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread) & LOADER_LOCK_COOKIE_TID_BIT_MASK)) {
        if (Flags & LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS)
            RtlRaiseStatus(STATUS_INVALID_PARAMETER_2);

        Status = STATUS_INVALID_PARAMETER_2;
        goto Exit;
    }

    if (Flags & LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS) {
        RtlLeaveCriticalSection(&LdrpLoaderLock);
    } else {
        __try {
            RtlLeaveCriticalSection(&LdrpLoaderLock);
        } __except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
            Status = GetExceptionCode();
            goto Exit;
        }
    }

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

NTSTATUS
NTAPI
LdrDoesCurrentThreadOwnLoaderLock(
    BOOLEAN *DoesOwnLock
    )
{
    NTSTATUS Status;
    PTEB Teb;

    if (DoesOwnLock != NULL)
        *DoesOwnLock = FALSE;

    if (DoesOwnLock == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Teb = NtCurrentTeb();

    if (LdrpLoaderLock.OwningThread == Teb->ClientId.UniqueThread)
        *DoesOwnLock = TRUE;

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}


NTSTATUS
NTAPI
LdrEnumerateLoadedModules(
    ULONG Flags,
    PLDR_LOADED_MODULE_ENUMERATION_CALLBACK_FUNCTION CallbackFunction,
    PVOID Context
    )
{
    NTSTATUS Status;
    BOOLEAN LoaderLockLocked = FALSE;
    PLIST_ENTRY LoadOrderListHead = NULL;
    PLIST_ENTRY ListEntry;
    BOOLEAN StopEnumeration = FALSE;
    PVOID   LockCookie = NULL;

    if ((Flags != 0) ||
        (CallbackFunction == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Status = LdrLockLoaderLock(0, NULL, &LockCookie);
    if (!NT_SUCCESS(Status))
        goto Exit;

    LoaderLockLocked = TRUE;
    LoadOrderListHead = &NtCurrentPeb()->Ldr->InLoadOrderModuleList;

    ListEntry = LoadOrderListHead->Flink;

    while (ListEntry != LoadOrderListHead) {
        __try {
            (*CallbackFunction)(
                CONTAINING_RECORD(ListEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks),
                Context,
                &StopEnumeration);
        } __except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
            Status = GetExceptionCode();
            goto Exit;
        }

        if (StopEnumeration)
            break;

        ListEntry = ListEntry->Flink;
    }

    Status = LdrUnlockLoaderLock(0, LockCookie);
    LoaderLockLocked = FALSE;
    if (!NT_SUCCESS(Status))
        goto Exit;

    Status = STATUS_SUCCESS;
Exit:
    if (LoaderLockLocked) {
        NTSTATUS Status2 = LdrUnlockLoaderLock(0, LockCookie);
        ASSERT(NT_SUCCESS(Status2));
    }

    return Status;
}

NTSTATUS
NTAPI
LdrAddRefDll(
    ULONG               Flags,
    PVOID               DllHandle
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry = NULL;
    const BOOLEAN InLdrInit = LdrpInLdrInit;
    PVOID LockCookie = NULL;
    BOOLEAN HoldingLoaderLock = FALSE;
    const ULONG ValidFlags = LDR_ADDREF_DLL_PIN;

    __try {

        if (Flags & ~ValidFlags
            ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
        if (!InLdrInit
            ) {
            Status = LdrLockLoaderLock(0, NULL, &LockCookie);
            if (!NT_SUCCESS(Status))
                goto Exit;
            HoldingLoaderLock = TRUE;
        }
        if (!LdrpCheckForLoadedDllHandle(DllHandle, &LdrDataTableEntry)
            ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
        if (!RTL_SOFT_VERIFY(LdrDataTableEntry != NULL)
            ) {
            Status = STATUS_INTERNAL_ERROR;
            goto Exit;
        }
        //
        // Gross. Everyone inlines the first part..
        //
        if (LdrDataTableEntry->LoadCount != 0xffff) {
            if (Flags & LDR_ADDREF_DLL_PIN
                ) {
                LdrDataTableEntry->LoadCount = 0xffff;
                LdrpPinLoadedDll(LdrDataTableEntry);
            } else {
                LdrDataTableEntry->LoadCount++;
                LdrpReferenceLoadedDll(LdrDataTableEntry);
            }
            LdrpClearLoadInProgress();
        }
Exit:
        if (LdrpShouldDbgPrintStatus(Status)
            ) {
            DbgPrint("LDR: "__FUNCTION__"(%p) 0x%08lx\n", DllHandle, Status);
        }
    } __finally {
        if (HoldingLoaderLock) {
            LdrUnlockLoaderLock(LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, LockCookie);
            HoldingLoaderLock = FALSE;
        }
    }
    return Status;
}

VOID
NTAPI
LdrSetDllManifestProber(
    IN PLDR_MANIFEST_PROBER_ROUTINE ManifestProberRoutine
    )
{
    LdrpManifestProberRoutine = ManifestProberRoutine;
}

NTSTATUS
NTAPI
LdrSetAppCompatDllRedirectionCallback(
    IN ULONG Flags,
    IN PLDR_APP_COMPAT_DLL_REDIRECTION_CALLBACK_FUNCTION CallbackFunction,
    IN PVOID CallbackData
    )
/*++

Routine Description:

    This routine allows the application compatibility facility to set a callback
    function that it can use to redirect DLL loads wherever it wants them to go.

Arguments:

    Flags - None defined now; must be zero.

    CallbackFunction - Function pointer to function which is called to resolve
        path names prior to actually loading the DLL.

    CallbackData - PVOID value passed through to the CallbackFunction when it is
        called.

Return Value:

    NTSTATUS indicating the success/failure of the function.

--*/
{
    NTSTATUS st = STATUS_INTERNAL_ERROR;
    PVOID LockCookie = NULL;

    if (Flags != 0) {
        st = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    LdrLockLoaderLock(LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, NULL, &LockCookie);
    __try {
        LdrpAppCompatDllRedirectionCallbackFunction = CallbackFunction;
        LdrpAppCompatDllRedirectionCallbackData = CallbackData;
    } __finally {
        LdrUnlockLoaderLock(LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, LockCookie);
    }

    st = STATUS_SUCCESS;
Exit:
    return st;
}

PTEB LdrpTopLevelDllBeingLoadedTeb=NULL;

BOOLEAN
RtlIsThreadWithinLoaderCallout (
    VOID
    )
{
    if (LdrpTopLevelDllBeingLoadedTeb == NtCurrentTeb ()) {
        return TRUE;
    } else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\ldrinit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ldrinit.c

Abstract:

    This module implements loader initialization.

Author:

    Mike O'Leary (mikeol) 26-Mar-1990

Revision History:

--*/

#include <ntos.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <heap.h>
#include <heappage.h>
#include <apcompat.h>
#include "ldrp.h"
#include <ctype.h>
#include <windows.h>

BOOLEAN LdrpShutdownInProgress = FALSE;
BOOLEAN LdrpImageHasTls = FALSE;
BOOLEAN LdrpVerifyDlls = FALSE;
BOOLEAN LdrpLdrDatabaseIsSetup = FALSE;
BOOLEAN LdrpInLdrInit = FALSE;
BOOLEAN LdrpShouldCreateStackTraceDb = FALSE;

BOOLEAN ShowSnaps = FALSE;
BOOLEAN ShowErrors = FALSE;

#if defined(_WIN64)
PVOID Wow64Handle;
ULONG UseWOW64;
typedef VOID (*tWOW64LdrpInitialize)(IN PCONTEXT Context);
tWOW64LdrpInitialize Wow64LdrpInitialize;
PVOID Wow64PrepareForException;
PVOID Wow64ApcRoutine;
INVERTED_FUNCTION_TABLE LdrpInvertedFunctionTable = {
    0, MAXIMUM_INVERTED_FUNCTION_TABLE_SIZE, FALSE};
#endif

typedef NTSTATUS (*PCOR_VALIDATE_IMAGE)(PVOID *pImageBase, LPWSTR ImageName);
typedef VOID (*PCOR_IMAGE_UNLOADING)(PVOID ImageBase);

PVOID Cor20DllHandle;
PCOR_VALIDATE_IMAGE CorValidateImage;
PCOR_IMAGE_UNLOADING CorImageUnloading;
PCOR_EXE_MAIN CorExeMain;
DWORD CorImageCount;

#define SLASH_SYSTEM32_SLASH L"\\system32\\"
#define MSCOREE_DLL          L"mscoree.dll"
extern const WCHAR SlashSystem32SlashMscoreeDllWCharArray[] = SLASH_SYSTEM32_SLASH MSCOREE_DLL;
extern const UNICODE_STRING SlashSystem32SlashMscoreeDllString =
{
    sizeof(SlashSystem32SlashMscoreeDllWCharArray) - sizeof(SlashSystem32SlashMscoreeDllWCharArray[0]),
    sizeof(SlashSystem32SlashMscoreeDllWCharArray),
    (PWSTR)SlashSystem32SlashMscoreeDllWCharArray
};

PVOID NtDllBase;
static const UNICODE_STRING NtDllName = RTL_CONSTANT_STRING(L"ntdll.dll");

#define DLL_REDIRECTION_LOCAL_SUFFIX L".Local"

extern ULONG RtlpDisableHeapLookaside;  // defined in rtl\heap.c
extern ULONG RtlpShutdownProcessFlags;

extern void ShutDownWmiHandles();
extern void CleanOnThreadExit();
extern ULONG WmipInitializeDll(void);
extern void WmipDeinitializeDll();

#if defined (_X86_)
void
LdrpValidateImageForMp(
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    );
#endif

PFNSE_INSTALLBEFOREINIT g_pfnSE_InstallBeforeInit;
PFNSE_INSTALLAFTERINIT  g_pfnSE_InstallAfterInit;
PFNSE_DLLLOADED         g_pfnSE_DllLoaded;
PFNSE_DLLUNLOADED       g_pfnSE_DllUnloaded;
PFNSE_GETPROCADDRESS    g_pfnSE_GetProcAddress;
PFNSE_ISSHIMDLL         g_pfnSE_IsShimDll;
PFNSE_PROCESSDYING      g_pfnSE_ProcessDying;

PVOID g_pShimEngineModule;

BOOL g_LdrBreakOnLdrpInitializeProcessFailure = FALSE;

PLDR_DATA_TABLE_ENTRY LdrpNtDllDataTableEntry;

#if DBG
// Debug helpers to figure out where in LdrpInitializeProcess() things go south
PCSTR g_LdrFunction;
LONG g_LdrLine;

#define LDRP_CHECKPOINT() do { g_LdrFunction = __FUNCTION__; g_LdrLine = __LINE__; } while (0)

#else

#define LDRP_CHECKPOINT() /* nothing */

#endif // DBG


//
//  Defined in heappriv.h
//

VOID
RtlDetectHeapLeaks();

VOID
LdrpRelocateStartContext (
    IN PCONTEXT Context,
    IN LONG_PTR Diff
    );

NTSTATUS
LdrpForkProcess( VOID );

VOID
LdrpInitializeThread(
    IN PCONTEXT Context
    );

NTSTATUS
LdrpOpenImageFileOptionsKey(
    IN PUNICODE_STRING ImagePathName,
    OUT PHANDLE KeyHandle
    );

VOID
LdrpInitializeApplicationVerifierPackage (
    PUNICODE_STRING UnicodeImageName,
    PPEB Peb,
    BOOLEAN EnabledSystemWide,
    BOOLEAN OptionsKeyPresent
    );

BOOLEAN
LdrpInitializeExecutionOptions (
    PUNICODE_STRING UnicodeImageName,
    PPEB Peb
    );

NTSTATUS
LdrpQueryImageFileKeyOption(
    IN HANDLE KeyHandle,
    IN PWSTR OptionName,
    IN ULONG Type,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG ResultSize OPTIONAL
    );

NTSTATUS
LdrpTouchThreadStack (
    SIZE_T EnforcedStackCommit
    );

NTSTATUS
LdrpEnforceExecuteForCurrentThreadStack (
    );

BOOLEAN
NtdllOkayToLockRoutine(
    IN PVOID Lock
    );

NTSTATUS
RtlpInitDeferedCriticalSection( VOID );

VOID
LdrQueryApplicationCompatibilityGoo(
    IN PUNICODE_STRING UnicodeImageName,
    IN BOOLEAN ImageFileOptionsPresent
    );

NTSTATUS
LdrFindAppCompatVariableInfo(
    IN  ULONG dwTypeSeeking,
    OUT PAPP_VARIABLE_INFO *AppVariableInfo
    );

NTSTATUS
LdrpSearchResourceSection_U(
    IN PVOID DllHandle,
    IN PULONG_PTR ResourceIdPath,
    IN ULONG ResourceIdPathLength,
    IN ULONG Flags,
    OUT PVOID *ResourceDirectoryOrData
    );

NTSTATUS
LdrpAccessResourceData(
    IN PVOID DllHandle,
    IN PIMAGE_RESOURCE_DATA_ENTRY ResourceDataEntry,
    OUT PVOID *Address OPTIONAL,
    OUT PULONG Size OPTIONAL
    );

PVOID
NtdllpAllocateStringRoutine(
    SIZE_T NumberOfBytes
    )
{
    return RtlAllocateHeap(RtlProcessHeap(), 0, NumberOfBytes);
}

VOID
NtdllpFreeStringRoutine(
    PVOID Buffer
    )
{
    RtlFreeHeap(RtlProcessHeap(), 0, Buffer);
}

const PRTL_ALLOCATE_STRING_ROUTINE RtlAllocateStringRoutine = NtdllpAllocateStringRoutine;
const PRTL_FREE_STRING_ROUTINE RtlFreeStringRoutine = NtdllpFreeStringRoutine;
RTL_BITMAP TlsBitMap;
RTL_BITMAP TlsExpansionBitMap;

RTL_CRITICAL_SECTION_DEBUG LoaderLockDebug;

RTL_CRITICAL_SECTION LdrpLoaderLock = {
    &LoaderLockDebug,
    -1
    };

BOOLEAN LoaderLockInitialized;

PVOID LdrpHeap;

VOID
LdrpInitializationFailure(
    IN NTSTATUS FailureCode
    )
{
    NTSTATUS ErrorStatus;
    ULONG_PTR ErrorParameter;
    ULONG ErrorResponse;

#if DBG
    DbgPrint("LDR: Process initialization failure; NTSTATUS = %08lx\n"
             "     Function: %s\n"
             "     Line: %d\n", FailureCode, g_LdrFunction, g_LdrLine);
#endif // DBG

    if ( LdrpFatalHardErrorCount ) {
        return;
        }

    //
    // Its error time...
    //
    ErrorParameter = (ULONG_PTR)FailureCode;
    ErrorStatus = NtRaiseHardError(
                    STATUS_APP_INIT_FAILURE,
                    1,
                    0,
                    &ErrorParameter,
                    OptionOk,
                    &ErrorResponse
                    );
}

INT
LdrpInitializeProcessWrapperFilter(
    const struct _EXCEPTION_POINTERS *ExceptionPointers
    )
/*++

Routine Description:

    Exception filter function used in __try block around invocation of
    LdrpInitializeProcess() so that if LdrpInitializeProcess() fails,
    we can set a breakpoint here and see why instead of just catching
    the exception and propogating the status.

Arguments:

    ExceptionCode
        Code returned from GetExceptionCode() in the __except()

    ExceptionPointers
        Pointer to exception information returned by GetExceptionInformation() in the __except()

Return Value:

    EXCEPTION_EXECUTE_HANDLER

--*/
{
    if (DBG || g_LdrBreakOnLdrpInitializeProcessFailure) {
        DbgPrint("LDR: LdrpInitializeProcess() threw an exception: %08lx\n"
                 "     Exception record: %p\n"
                 "     Context record: %p\n"
                 "     Last checkpoint: %s line %d\n",
                 ExceptionPointers->ExceptionRecord->ExceptionCode,
                 ExceptionPointers->ExceptionRecord,
                 ExceptionPointers->ContextRecord,
#if DBG
                 g_LdrFunction, g_LdrLine);
#else
                 "free build; no checkpoint info available", 0);
#endif // DBG
        if (g_LdrBreakOnLdrpInitializeProcessFailure)
            DbgBreakPoint();
    }

    return EXCEPTION_EXECUTE_HANDLER;
}


VOID
LdrpInitialize (
    IN PCONTEXT Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This function is called as a User-Mode APC routine as the first
    user-mode code executed by a new thread. It's function is to initialize
    loader context, perform module initialization callouts...

Arguments:

    Context - Supplies an optional context buffer that will be restore
              after all DLL initialization has been completed.  If this
              parameter is NULL then this is a dynamic snap of this module.
              Otherwise this is a static snap prior to the user process
              gaining control.

    SystemArgument1 - Supplies the base address of the System Dll.

    SystemArgument2 - not used.

Return Value:

    None.

--*/

{
    NTSTATUS st, InitStatus;
    PPEB Peb;
    PTEB Teb;
    UNICODE_STRING UnicodeImageName;
    MEMORY_BASIC_INFORMATION MemInfo;
    BOOLEAN AlreadyFailed;
    BOOLEAN ImageFileOptionsPresent = FALSE;
    LARGE_INTEGER DelayValue;
    BOOLEAN UseCOR;
#if defined(_WIN64)
    PIMAGE_NT_HEADERS NtHeader;
#else
    IMAGE_COR20_HEADER *Cor20Header;
    ULONG Cor20HeaderSize;
#endif
    PWSTR pw;

    LDRP_CHECKPOINT();

    SystemArgument2;

    AlreadyFailed = FALSE;
    UseCOR = FALSE;
    Peb = NtCurrentPeb();
    Teb = NtCurrentTeb();

    if (!Peb->Ldr) {

        //
        // if `Peb->Ldr' is null then we are executing this for the first thread
        // in the process. This is the right moment to initialize process-wide
        // things.
        //

        LDRP_CHECKPOINT();

        //
        // Figure out process name
        //

        pw = Peb->ProcessParameters->ImagePathName.Buffer;
        if (!(Peb->ProcessParameters->Flags & RTL_USER_PROC_PARAMS_NORMALIZED)) {
            pw = (PWSTR)((PCHAR)pw + (ULONG_PTR)(Peb->ProcessParameters));
        }

        UnicodeImageName.Buffer = pw;
        UnicodeImageName.Length = Peb->ProcessParameters->ImagePathName.Length;
        UnicodeImageName.MaximumLength = UnicodeImageName.Length + sizeof(WCHAR);

        //
        // Parse `image file execution options' registry values if there are any.
        //

        ImageFileOptionsPresent = LdrpInitializeExecutionOptions (&UnicodeImageName,
                                                                  Peb);

#if defined(_WIN64)
        NtHeader = RtlImageNtHeader(Peb->ImageBaseAddress);
        if (NtHeader && (NtHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)) {

            ULONG_PTR Wow64Info;

            //
            // 64-bit loader, but the exe image is 32-bit.  If
            // the Wow64Information is nonzero then use WOW64.
            // Othewise the image is a COM+ ILONLY image with
            // 32BITREQUIRED not set - the memory manager has
            // already checked the COR header and decided to
            // run the image in a full 64-bit process.
            //

            LDRP_CHECKPOINT();

            st = NtQueryInformationProcess(NtCurrentProcess(),
                                           ProcessWow64Information,
                                           &Wow64Info,
                                           sizeof(Wow64Info),
                                           NULL);
            if (!NT_SUCCESS(st)) {
                LdrpInitializationFailure(st);
                RtlRaiseStatus(st);
                return;
            }

            if (Wow64Info) {
                UseWOW64 = TRUE;
            }
            else {
                UseCOR = TRUE;
            }
        }
#else
        Cor20Header = RtlImageDirectoryEntryToData(Peb->ImageBaseAddress,
                                                   TRUE,
                                                   IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR,
                                                   &Cor20HeaderSize);
        if (Cor20Header) {
            UseCOR = TRUE;
        }
#endif
    }

    LDRP_CHECKPOINT();

    //
    // Serialize for here on out
    //

    Peb->LoaderLock = (PVOID) &LdrpLoaderLock;

    if (!RtlTryEnterCriticalSection(&LdrpLoaderLock)) {
        if (LoaderLockInitialized)
            RtlEnterCriticalSection(&LdrpLoaderLock);
        else {

            //
            // drop into a 30ms delay loop
            //

            DelayValue.QuadPart = Int32x32To64( 30, -10000 );
            while (!LoaderLockInitialized) {
                NTSTATUS st2 = NtDelayExecution(FALSE, &DelayValue);
                if (!NT_SUCCESS(st2)) {
                    DbgPrintEx(
                        DPFLTR_LDR_ID,
                        LDR_ERROR_DPFLTR,
                        "LDR: ***NONFATAL*** %s - call to NtDelayExecution waiting on loader lock failed; ntstatus = %x\n",
                        __FUNCTION__,
                        st2);
                }
            }

            RtlEnterCriticalSection(&LdrpLoaderLock);
        }
    }

    LDRP_CHECKPOINT();

    if (Teb->DeallocationStack == NULL) {

        LDRP_CHECKPOINT();

        st = NtQueryVirtualMemory(
                                 NtCurrentProcess(),
                                 Teb->NtTib.StackLimit,
                                 MemoryBasicInformation,
                                 (PVOID)&MemInfo,
                                 sizeof(MemInfo),
                                 NULL);
        if (!NT_SUCCESS(st)) {
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - Call to NtQueryVirtualMemory failed with ntstaus %x\n",
                __FUNCTION__,
                st);

            LdrpInitializationFailure(st);
            RtlRaiseStatus(st);
            return;
        } else {
            Teb->DeallocationStack = MemInfo.AllocationBase;
#if defined(_IA64_)
            Teb->DeallocationBStore = (PVOID)((ULONG_PTR)MemInfo.AllocationBase + MemInfo.RegionSize);
#endif // defined(_IA64_)
        }
    }

    InitStatus = STATUS_SUCCESS;

    LDRP_CHECKPOINT();

    __try {

        if (!Peb->Ldr) {

            //
            // We execute in the first thread of the process. We will do
            // some more process-wide initialization.
            //

            LdrpInLdrInit = TRUE;

#if DBG
            //
            // Time the load.
            //

            if (LdrpDisplayLoadTime) {
                NtQueryPerformanceCounter(&BeginTime, NULL);
            }
#endif // DBG

            __try {
                LDRP_CHECKPOINT();

                InitStatus = LdrpInitializeProcess (Context,
                                                    SystemArgument1,
                                                    &UnicodeImageName,
                                                    UseCOR,
                                                    ImageFileOptionsPresent);

                if (!NT_SUCCESS(InitStatus))
                    DbgPrintEx(
                        DPFLTR_LDR_ID,
                        LDR_ERROR_DPFLTR,
                        "LDR: %s - call to LdrpInitializeProcess() failed with ntstatus %x\n",
                        __FUNCTION__, InitStatus);

                //
                // Make sure main thread gets the requested precommited stack size
                // if such a value was specified system-wide or for this process.
                // This is a good point to do this since we just initialized the
                // process (among other things support for exception dispatching).
                //

                if (NT_SUCCESS(InitStatus) && Peb->MinimumStackCommit) {

                    InitStatus = LdrpTouchThreadStack (Peb->MinimumStackCommit);
                }

                LDRP_CHECKPOINT();
            }
            __except ( LdrpInitializeProcessWrapperFilter(GetExceptionInformation()) ) {
                InitStatus = GetExceptionCode();
                AlreadyFailed = TRUE;
                LdrpInitializationFailure(GetExceptionCode());
                LdrpInitializationFailure(InitStatus);
            }

#if DBG
            if (LdrpDisplayLoadTime) {

                NtQueryPerformanceCounter(&EndTime, NULL);
                NtQueryPerformanceCounter(&ElapsedTime, &Interval);
                ElapsedTime.QuadPart = EndTime.QuadPart - BeginTime.QuadPart;

                DbgPrint("\nLoadTime %ld In units of %ld cycles/second \n",
                         ElapsedTime.LowPart,
                         Interval.LowPart
                        );

                ElapsedTime.QuadPart = EndTime.QuadPart - InitbTime.QuadPart;
                DbgPrint("InitTime %ld\n",
                         ElapsedTime.LowPart
                        );
                DbgPrint("Compares %d Bypasses %d Normal Snaps %d\nSecOpens %d SecCreates %d Maps %d Relocates %d\n",
                         LdrpCompareCount,
                         LdrpSnapBypass,
                         LdrpNormalSnap,
                         LdrpSectionOpens,
                         LdrpSectionCreates,
                         LdrpSectionMaps,
                         LdrpSectionRelocates
                        );
            }
#endif // DBG
        }
        else {

            if ( Peb->InheritedAddressSpace ) {
                InitStatus = LdrpForkProcess();
            } else {

#if defined(_WIN64)

                //
                // Load in WOW64 if the image is supposed to run simulated
                //

                if (UseWOW64) {

                    RtlLeaveCriticalSection(&LdrpLoaderLock);
                    (*Wow64LdrpInitialize)(Context);
                    // This never returns.  It will destroy the process.
                }
#endif
                LdrpInitializeThread(Context);
            }
        }

        //
        // The current thread is completely initialized. We will make sure
        // now that its stack has the right execute options. We avoid doing
        // this for Wow64 processes.
        //

#if defined(_WIN64)
        if (! UseWOW64) {
#endif
            if (Peb->ExecuteOptions & (MEM_EXECUTE_OPTION_STACK | MEM_EXECUTE_OPTION_DATA)) {
                LdrpEnforceExecuteForCurrentThreadStack ();
            }
#if defined(_WIN64)
        }
#endif

    } __finally {
        LdrpInLdrInit = FALSE;
        RtlLeaveCriticalSection(&LdrpLoaderLock);
    }

    NtTestAlert();

    if (!NT_SUCCESS(InitStatus)) {
        if ( AlreadyFailed == FALSE ) {
            LdrpInitializationFailure(InitStatus);
        }

        RtlRaiseStatus(InitStatus);
    }
}

NTSTATUS
LdrpForkProcess( VOID )
{
    NTSTATUS st;
    PPEB Peb;

    Peb = NtCurrentPeb();

    //
    // Initialize the critical section package.
    //

    st = RtlpInitDeferedCriticalSection();
    if (!NT_SUCCESS (st)) {
        return st;
    }

    InsertTailList(&RtlCriticalSectionList, &LdrpLoaderLock.DebugInfo->ProcessLocksList);
    LdrpLoaderLock.DebugInfo->CriticalSection = &LdrpLoaderLock;
    LoaderLockInitialized = TRUE;

    st = RtlInitializeCriticalSection(&FastPebLock);
    if ( !NT_SUCCESS(st) ) {
        RtlRaiseStatus(st);
        }
    Peb->FastPebLock = &FastPebLock;
    Peb->FastPebLockRoutine = (PVOID)&RtlEnterCriticalSection;
    Peb->FastPebUnlockRoutine = (PVOID)&RtlLeaveCriticalSection;
    Peb->InheritedAddressSpace = FALSE;
    RtlInitializeHeapManager();
    Peb->ProcessHeap = RtlCreateHeap( HEAP_GROWABLE,    // Flags
                                      NULL,             // HeapBase
                                      64 * 1024,        // ReserveSize
                                      4096,             // CommitSize
                                      NULL,             // Lock to use for serialization
                                      NULL              // GrowthThreshold
                                    );
    if (Peb->ProcessHeap == NULL) {
        return STATUS_NO_MEMORY;
    }

    return st;
}

void
LdrpGetShimEngineInterface(
    void
    )
{
    STRING strProcName;

    //
    // Get the interface to the shim engine.
    //
    RtlInitString(&strProcName, "SE_InstallBeforeInit");
    LdrpGetProcedureAddress(g_pShimEngineModule, &strProcName, 0, (PVOID*)&g_pfnSE_InstallBeforeInit, FALSE);

    RtlInitString(&strProcName, "SE_InstallAfterInit");
    LdrpGetProcedureAddress(g_pShimEngineModule, &strProcName, 0, (PVOID*)&g_pfnSE_InstallAfterInit, FALSE);

    RtlInitString(&strProcName, "SE_DllLoaded");
    LdrpGetProcedureAddress(g_pShimEngineModule, &strProcName, 0, (PVOID*)&g_pfnSE_DllLoaded, FALSE);

    RtlInitString(&strProcName, "SE_DllUnloaded");
    LdrpGetProcedureAddress(g_pShimEngineModule, &strProcName, 0, (PVOID*)&g_pfnSE_DllUnloaded, FALSE);

    RtlInitString(&strProcName, "SE_GetProcAddress");
    LdrpGetProcedureAddress(g_pShimEngineModule, &strProcName, 0, (PVOID*)&g_pfnSE_GetProcAddress, FALSE);

    RtlInitString(&strProcName, "SE_IsShimDll");
    LdrpGetProcedureAddress(g_pShimEngineModule, &strProcName, 0, (PVOID*)&g_pfnSE_IsShimDll, FALSE);

    RtlInitString(&strProcName, "SE_ProcessDying");
    LdrpGetProcedureAddress(g_pShimEngineModule, &strProcName, 0, (PVOID*)&g_pfnSE_ProcessDying, FALSE);
}

BOOL
LdrInitShimEngineDynamic(
    PVOID pShimEngineModule
    )
{
    PVOID    LockCookie = NULL;
    NTSTATUS Status;
    BOOL     bSuccess   = FALSE;

    Status = LdrLockLoaderLock(0, NULL, &LockCookie);
    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    if (g_pShimEngineModule != NULL) {
        //
        // cannot overwrite -- we have succeeded however
        // since the interface has already been acquired
        //
        bSuccess = TRUE;
        goto Exit;
    }

    //
    // set the global shim engine ptr
    //
    g_pShimEngineModule = pShimEngineModule;

    //
    // get shimengine interface
    //
    LdrpGetShimEngineInterface();

    bSuccess = TRUE;

Exit:

    Status = LdrUnlockLoaderLock(0, LockCookie);
    ASSERT(NT_SUCCESS(Status));

    return bSuccess;
}


void
LdrpLoadShimEngine(
    WCHAR*          pwszShimEngine,
    PUNICODE_STRING pstrExeFullPath,
    PVOID           pAppCompatExeData
    )
{
    ANSI_STRING    strProcName;
    UNICODE_STRING strEngine;
    NTSTATUS       status;
    PPEB           Peb = NtCurrentPeb();

    RtlInitUnicodeString(&strEngine, pwszShimEngine);

    //
    // Load the specified shim engine.
    //
    status = LdrpLoadDll(0, UNICODE_NULL, NULL, &strEngine, &g_pShimEngineModule, FALSE);

    if (!NT_SUCCESS(status)) {
#if DBG
        DbgPrint("LDR: Couldn't load the shim engine\n");
#endif
        return;
        }

    LdrpGetShimEngineInterface();

    //
    // Call the shim engine to give it a chance to initialize.
    //
    if (g_pfnSE_InstallBeforeInit != NULL) {
        (*g_pfnSE_InstallBeforeInit)(pstrExeFullPath, pAppCompatExeData);
        }
}

void
LdrpUnloadShimEngine(
    void
    )
{
    LdrUnloadDll(g_pShimEngineModule);

    g_pfnSE_InstallBeforeInit = NULL;
    g_pfnSE_InstallAfterInit  = NULL;
    g_pfnSE_DllLoaded         = NULL;
    g_pfnSE_DllUnloaded       = NULL;
    g_pfnSE_GetProcAddress    = NULL;
    g_pfnSE_IsShimDll         = NULL;
    g_pfnSE_ProcessDying      = NULL;

    g_pShimEngineModule = NULL;
}

NTSTATUS
LdrpInitializeProcess (
    IN PCONTEXT Context OPTIONAL,
    IN PVOID SystemDllBase,
    IN PUNICODE_STRING UnicodeImageName,
    IN BOOLEAN UseCOR,
    IN BOOLEAN ImageFileOptionsPresent
    )

/*++

Routine Description:

    This function initializes the loader for the process.
    This includes:

        - Initializing the loader data table

        - Connecting to the loader subsystem

        - Initializing all staticly linked DLLs

Arguments:

    Context - Supplies an optional context buffer that will be restore
              after all DLL initialization has been completed.  If this
              parameter is NULL then this is a dynamic snap of this module.
              Otherwise this is a static snap prior to the user process
              gaining control.

    SystemDllBase - Supplies the base address of the system dll.

    UnicodeImageName - Base name + extension of the image

    UseCOR - TRUE if the image is a COM+ runtime image, FALSE otherwise

    ImageFileOptionsPresent - Hint about existing any ImageFileExecutionOption key.
            If the key is missing the ApplicationCompatibilityGoo and
            DebugProcessHeapOnly entries won't be checked again.

Return Value:

    Status value

--*/

{
    PPEB Peb;
    NTSTATUS st;
    PWCH p, pp;
    UNICODE_STRING CurDir;
    UNICODE_STRING FullImageName;
    UNICODE_STRING CommandLine;
    ULONG DebugProcessHeapOnly = 0 ;
    HANDLE LinkHandle;
    static WCHAR SystemDllPathBuffer[DOS_MAX_PATH_LENGTH];
    UNICODE_STRING SystemDllPath;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    UNICODE_STRING Unicode;
    OBJECT_ATTRIBUTES Obja;
    BOOLEAN StaticCurDir = FALSE;
    ULONG i;
    PIMAGE_NT_HEADERS NtHeader;
    PIMAGE_LOAD_CONFIG_DIRECTORY ImageConfigData;
    ULONG ProcessHeapFlags;
    RTL_HEAP_PARAMETERS HeapParameters;
    NLSTABLEINFO InitTableInfo;
    LARGE_INTEGER LongTimeout;
    UNICODE_STRING NtSystemRoot;
    LONG_PTR Diff;
    ULONG_PTR OldBase;
    PWSTR pw ;
    PVOID pAppCompatExeData;

    UNICODE_STRING ImagePathName; // for .local dll redirection, xwu
    PWCHAR ImagePathNameBuffer = NULL;
    BOOL DotLocalExists = FALSE;

    typedef NTSTATUS (NTAPI * PKERNEL32_PROCESS_INIT_POST_IMPORT_FUNCTION)();
    PKERNEL32_PROCESS_INIT_POST_IMPORT_FUNCTION Kernel32ProcessInitPostImportFunction = NULL;
    const ANSI_STRING Kernel32ProcessInitPostImportFunctionName = RTL_CONSTANT_STRING("BaseProcessInitPostImport");

    LDRP_CHECKPOINT();

    NtDllBase = SystemDllBase;

    Peb = NtCurrentPeb();
    NtHeader = RtlImageNtHeader( Peb->ImageBaseAddress );

    if (!NtHeader) {
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s - failing because we were unable to map the image base address (%p) to the PIMAGE_NT_HEADERS\n",
            __FUNCTION__,
            Peb->ImageBaseAddress);

        return STATUS_INVALID_IMAGE_FORMAT;
    }

    LDRP_CHECKPOINT();

    if (
#if defined(_WIN64)
        NtHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC &&
#endif
        NtHeader->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_NATIVE ) {

        //
        // Native subsystems load slower, but validate their DLLs
        // This is to help CSR detect bad images faster
        //

        LdrpVerifyDlls = TRUE;

        }

    //
    // capture app compat data and clear shim data field
    //

#if defined(_WIN64)
    //
    // If this is an x86 image, then let 32-bit ntdll read
    // and reset the appcompat pointer
    //

    if (UseWOW64 == FALSE)
#endif
    {
        pAppCompatExeData = Peb->pShimData;
        Peb->pShimData = NULL;
    }

#if defined(BUILD_WOW6432)
    {
        //
        // The process is running in WOW64.  Sort out the optional header
        // format and reformat the image if its page size is smaller than
        // the native page size.
        //
        PIMAGE_NT_HEADERS32 NtHeader32 = (PIMAGE_NT_HEADERS32)NtHeader;

        st = STATUS_SUCCESS;

        if (NtHeader32->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 &&
            NtHeader32->OptionalHeader.SectionAlignment < NATIVE_PAGE_SIZE &&
            !NT_SUCCESS(st = LdrpWx86FormatVirtualImage(NULL,
                                 NtHeader32,
                                 Peb->ImageBaseAddress
                                 ))) {
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - failing wow64 process initialization because:\n"
                "   FileHeader.Machine (%u) != IMAGE_FILE_MACHINE_I386 (%u) or\n"
                "   OptionalHeader.SectionAlignment (%u) >= NATIVE_PAGE_SIZE (%u) or\n"
                "   LdrpWxFormatVirtualImage failed (ntstatus %x)\n",
                __FUNCTION__,
                NtHeader32->FileHeader.Machine, IMAGE_FILE_MACHINE_I386,
                NtHeader32->OptionalHeader.SectionAlignment, NATIVE_PAGE_SIZE,
                st);

            if (st == STATUS_SUCCESS)
                st = STATUS_INVALID_IMAGE_FORMAT;

            return st;
        }
    }
#endif

    LdrpNumberOfProcessors = Peb->NumberOfProcessors;
    RtlpTimeout = Peb->CriticalSectionTimeout;
    LongTimeout.QuadPart = Int32x32To64( 3600, -10000000 );

    if (ProcessParameters = RtlNormalizeProcessParams(Peb->ProcessParameters)) {
        FullImageName = ProcessParameters->ImagePathName;
        CommandLine = ProcessParameters->CommandLine;
    } else {
        RtlInitEmptyUnicodeString(&FullImageName, NULL, 0);
        RtlInitEmptyUnicodeString(&CommandLine, NULL, 0);
    }

    LDRP_CHECKPOINT();

    RtlInitNlsTables(
        Peb->AnsiCodePageData,
        Peb->OemCodePageData,
        Peb->UnicodeCaseTableData,
        &InitTableInfo);

    RtlResetRtlTranslations(&InitTableInfo);

#if defined(_WIN64)
    if (UseWOW64 || UseCOR) {
        //
        // Ignore image config data when initializing the 64-bit loader.
        // The 32-bit loader in ntdll32 will look at the config data
        // and do the right thing.
        //
        ImageConfigData = NULL;
    } else
#endif
    {

        ImageConfigData = RtlImageDirectoryEntryToData( Peb->ImageBaseAddress,
                                                        TRUE,
                                                        IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,
                                                        &i
                                                      );
    }

    RtlZeroMemory( &HeapParameters, sizeof( HeapParameters ) );
    ProcessHeapFlags = HEAP_GROWABLE | HEAP_CLASS_0;
    HeapParameters.Length = sizeof( HeapParameters );
    if (ImageConfigData != NULL && i == sizeof( *ImageConfigData )) {
        Peb->NtGlobalFlag &= ~ImageConfigData->GlobalFlagsClear;
        Peb->NtGlobalFlag |= ImageConfigData->GlobalFlagsSet;

        if (ImageConfigData->CriticalSectionDefaultTimeout != 0) {
            //
            // Convert from milliseconds to NT time scale (100ns)
            //
            RtlpTimeout.QuadPart = Int32x32To64( (LONG)ImageConfigData->CriticalSectionDefaultTimeout,
                                                 -10000);

            }

        if (ImageConfigData->ProcessHeapFlags != 0) {
            ProcessHeapFlags = ImageConfigData->ProcessHeapFlags;
            }

        if (ImageConfigData->DeCommitFreeBlockThreshold != 0) {
            HeapParameters.DeCommitFreeBlockThreshold = ImageConfigData->DeCommitFreeBlockThreshold;
            }

        if (ImageConfigData->DeCommitTotalFreeThreshold != 0) {
            HeapParameters.DeCommitTotalFreeThreshold = ImageConfigData->DeCommitTotalFreeThreshold;
            }

        if (ImageConfigData->MaximumAllocationSize != 0) {
            HeapParameters.MaximumAllocationSize = ImageConfigData->MaximumAllocationSize;
            }

        if (ImageConfigData->VirtualMemoryThreshold != 0) {
            HeapParameters.VirtualMemoryThreshold = ImageConfigData->VirtualMemoryThreshold;
            }
        }

//    //
//    // Check if the image has the fast heap flag set
//    //
//
//    if (NtHeader->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_FAST_HEAP) {
//        RtlpDisableHeapLookaside = 0;
//    } else {
//        RtlpDisableHeapLookaside = 1;
//    }

    LDRP_CHECKPOINT();

    ShowSnaps = ((FLG_SHOW_LDR_SNAPS & Peb->NtGlobalFlag) != 0);

    //
    // This field is non-zero if the image file that was used to create this
    // process contained a non-zero value in its image header.  If so, then
    // set the affinity mask for the process using this value.  It could also
    // be non-zero if the parent process created us suspended and poked our
    // PEB with a non-zero value before resuming.
    //
    if (Peb->ImageProcessAffinityMask) {
        st = NtSetInformationProcess( NtCurrentProcess(),
                                      ProcessAffinityMask,
                                      &Peb->ImageProcessAffinityMask,
                                      sizeof( Peb->ImageProcessAffinityMask )
                                    );
        if (NT_SUCCESS( st )) {
            KdPrint(( "LDR: Using ProcessAffinityMask of 0x%Ix from image.\n",
                      Peb->ImageProcessAffinityMask
                   ));
            }
        else {
            KdPrint(( "LDR: Failed to set ProcessAffinityMask of 0x%Ix from image (Status == %08x).\n",
                      Peb->ImageProcessAffinityMask, st
                   ));
            }
        }

    if (RtlpTimeout.QuadPart < LongTimeout.QuadPart) {
        RtlpTimoutDisable = TRUE;
        }

    if (ShowSnaps) {
        DbgPrint( "LDR: PID: 0x%x started - '%wZ'\n",
                  NtCurrentTeb()->ClientId.UniqueProcess,
                  &CommandLine
                );
    }

    LDRP_CHECKPOINT();

    for(i=0;i<LDRP_HASH_TABLE_SIZE;i++) {
        InitializeListHead(&LdrpHashTable[i]);
    }

    //
    // Initialize the critical section package.
    //

    LDRP_CHECKPOINT();

    st = RtlpInitDeferedCriticalSection();
    if (!NT_SUCCESS (st)) {
        return st;
    }

    Peb->TlsBitmap = (PVOID)&TlsBitMap;
    Peb->TlsExpansionBitmap = (PVOID)&TlsExpansionBitMap;

    RtlInitializeBitMap (
        &TlsBitMap,
        &Peb->TlsBitmapBits[0],
        RTL_BITS_OF(Peb->TlsBitmapBits)
        );

    RtlInitializeBitMap (
        &TlsExpansionBitMap,
        &Peb->TlsExpansionBitmapBits[0],
        RTL_BITS_OF(Peb->TlsExpansionBitmapBits)
        );

    InsertTailList(&RtlCriticalSectionList, &LdrpLoaderLock.DebugInfo->ProcessLocksList);

    LdrpLoaderLock.DebugInfo->CriticalSection = &LdrpLoaderLock;
    LoaderLockInitialized = TRUE;

    LDRP_CHECKPOINT();

    //
    // Initialize the stack trace data base if requested
    //

    if ((Peb->NtGlobalFlag & FLG_USER_STACK_TRACE_DB)
        || LdrpShouldCreateStackTraceDb) {

        PVOID BaseAddress = NULL;
        SIZE_T ReserveSize = 8 * RTL_MEG;

        st = LdrQueryImageFileExecutionOptions(UnicodeImageName,
                                               L"StackTraceDatabaseSizeInMb",
                                               REG_DWORD,
                                               &ReserveSize,
                                               sizeof(ReserveSize),
                                               NULL
                                               );

        //
        // Sanity check the value read from registry.
        //

        if (! NT_SUCCESS(st)) {
            ReserveSize = 8 * RTL_MEG;
        }
        else {
            if (ReserveSize < 8) {
                ReserveSize = 8 * RTL_MEG;
            }
            else  if (ReserveSize > 128) {
                ReserveSize = 128 * RTL_MEG;
            }
            else {
                ReserveSize *=  RTL_MEG;
            }

            DbgPrint( "LDR: Stack trace database size is %u Mb \n", ReserveSize / RTL_MEG);
        }

        st = NtAllocateVirtualMemory( NtCurrentProcess(),
            (PVOID *)&BaseAddress,
            0,
            &ReserveSize,
            MEM_RESERVE,
            PAGE_READWRITE);
        if (NT_SUCCESS(st)) {
            st = RtlInitializeStackTraceDataBase( BaseAddress,
                0,
                ReserveSize
                );
            if ( !NT_SUCCESS( st ) ) {
                NtFreeVirtualMemory( NtCurrentProcess(),
                    (PVOID *)&BaseAddress,
                    &ReserveSize,
                    MEM_RELEASE
                    );
            }
            else {

                //
                // If the stack trace db is not created due to page heap
                // enabling then we can set the NT heap debugging flags.
                // If we create it due to page heap then we should not
                // enable these flags because page heap and NT debug heap
                // do not coexist peacefully.
                //

                if (! LdrpShouldCreateStackTraceDb) {
                    Peb->NtGlobalFlag |= FLG_HEAP_VALIDATE_PARAMETERS;
                }
            }
        }
    }

    //
    // Initialize the loader data based in the PEB.
    //

    st = RtlInitializeCriticalSection(&FastPebLock);
    if ( !NT_SUCCESS(st) ) {
        return st;
        }

    st = RtlInitializeCriticalSection(&RtlpCalloutEntryLock);
    if ( !NT_SUCCESS(st) ) {
        return st;
        }

    //
    // Initialize the Wmi stuff.
    //

    WmipInitializeDll();

    InitializeListHead(&RtlpCalloutEntryList);

#if defined(_AMD64_) || defined(_IA64_)

    InitializeListHead(&RtlpDynamicFunctionTable);

#endif

    InitializeListHead(&LdrpDllNotificationList);

    Peb->FastPebLock = &FastPebLock;
    Peb->FastPebLockRoutine = (PVOID)&RtlEnterCriticalSection;
    Peb->FastPebUnlockRoutine = (PVOID)&RtlLeaveCriticalSection;

    LDRP_CHECKPOINT();

    RtlInitializeHeapManager();

    LDRP_CHECKPOINT();

#if defined(_WIN64)
    if ((UseWOW64) ||
        (NtHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)) {

        //
        // Create a heap using all defaults.  The 32-bit process heap
        // will be created later by ntdll32 using the parameters from the exe.
        //
        Peb->ProcessHeap = RtlCreateHeap( ProcessHeapFlags,
                                          NULL,
                                          0,
                                          0,
                                          NULL,
                                          &HeapParameters
                                        );
    } else
#endif
    {

        if (NtHeader->OptionalHeader.MajorSubsystemVersion <= 3 &&
            NtHeader->OptionalHeader.MinorSubsystemVersion < 51
           ) {
            ProcessHeapFlags |= HEAP_CREATE_ALIGN_16;
            }

        Peb->ProcessHeap = RtlCreateHeap( ProcessHeapFlags,
                                          NULL,
                                          NtHeader->OptionalHeader.SizeOfHeapReserve,
                                          NtHeader->OptionalHeader.SizeOfHeapCommit,
                                          NULL,             // Lock to use for serialization
                                          &HeapParameters);
    }

    if (Peb->ProcessHeap == NULL) {
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s - unable to create process heap\n",
            __FUNCTION__);

        return STATUS_NO_MEMORY;
    }

    {
        //
        // Create the loader private heap.
        //
        RTL_HEAP_PARAMETERS LdrpHeapParameters;
        RtlZeroMemory( &LdrpHeapParameters, sizeof(LdrpHeapParameters));
        LdrpHeapParameters.Length = sizeof(LdrpHeapParameters);
        LdrpHeap = RtlCreateHeap(
                        HEAP_GROWABLE | HEAP_CLASS_1,
                        NULL,
                        64 * 1024, // 0 is ok here, 64k is a chosen tuned number
                        24 * 1024, // 0 is ok here, 24k is a chosen tuned number
                        NULL,
                        &LdrpHeapParameters);

        if (LdrpHeap == NULL) {
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s failing process initialization due to inability to create loader private heap.\n",
                __FUNCTION__);
            return STATUS_NO_MEMORY;
        }
    }
    LDRP_CHECKPOINT();

    NtdllBaseTag = RtlCreateTagHeap( Peb->ProcessHeap,
                                     0,
                                     L"NTDLL!",
                                     L"!Process\0"                  // Heap Name
                                     L"CSRSS Client\0"
                                     L"LDR Database\0"
                                     L"Current Directory\0"
                                     L"TLS Storage\0"
                                     L"DBGSS Client\0"
                                     L"SE Temporary\0"
                                     L"Temporary\0"
                                     L"LocalAtom\0"
                                   );

    RtlInitializeAtomPackage( MAKE_TAG( ATOM_TAG ) );

    LDRP_CHECKPOINT();

    //
    // Allow only the process heap to have page allocations turned on
    //

    if (ImageFileOptionsPresent) {

        st = LdrQueryImageFileExecutionOptions( UnicodeImageName,
                                                L"DebugProcessHeapOnly",
                                                REG_DWORD,
                                                &DebugProcessHeapOnly,
                                                sizeof( DebugProcessHeapOnly ),
                                                NULL
                                              );
        if (NT_SUCCESS( st )) {
            if ( RtlpDebugPageHeap &&
                 ( DebugProcessHeapOnly != 0 ) ) {

                RtlpDebugPageHeap = FALSE ;
            }
        }
    }

    LDRP_CHECKPOINT();

    SystemDllPath.Buffer = SystemDllPathBuffer;
    SystemDllPath.Length = 0;
    SystemDllPath.MaximumLength = sizeof(SystemDllPathBuffer);

    RtlInitUnicodeString( &NtSystemRoot, USER_SHARED_DATA->NtSystemRoot );
    RtlAppendUnicodeStringToString( &SystemDllPath, &NtSystemRoot );
    RtlAppendUnicodeToString( &SystemDllPath, L"\\System32\\" );

    RtlInitUnicodeString(&Unicode, L"\\KnownDlls");
    InitializeObjectAttributes( &Obja,
                                  &Unicode,
                                  OBJ_CASE_INSENSITIVE,
                                  NULL,
                                  NULL
                                );
    st = NtOpenDirectoryObject(
            &LdrpKnownDllObjectDirectory,
            DIRECTORY_QUERY | DIRECTORY_TRAVERSE,
            &Obja);
    if ( !NT_SUCCESS(st) ) {
        LdrpKnownDllObjectDirectory = NULL;
        // KnownDlls directory doesn't exist - assume it's system32.
        RtlInitUnicodeString(&LdrpKnownDllPath, SystemDllPath.Buffer);
        LdrpKnownDllPath.Length -= sizeof(WCHAR);    // remove trailing '\'
    } else {

        //
        // Open up the known dll pathname link
        // and query its value
        //

        RtlInitUnicodeString(&Unicode, L"KnownDllPath");
        InitializeObjectAttributes( &Obja,
                                      &Unicode,
                                      OBJ_CASE_INSENSITIVE,
                                      LdrpKnownDllObjectDirectory,
                                      NULL
                                    );
        st = NtOpenSymbolicLinkObject( &LinkHandle,
                                       SYMBOLIC_LINK_QUERY,
                                       &Obja
                                     );
        if (NT_SUCCESS( st )) {
            LdrpKnownDllPath.Length = 0;
            LdrpKnownDllPath.MaximumLength = sizeof(LdrpKnownDllPathBuffer);
            LdrpKnownDllPath.Buffer = LdrpKnownDllPathBuffer;
            st = NtQuerySymbolicLinkObject( LinkHandle,
                                            &LdrpKnownDllPath,
                                            NULL
                                          );
            NtClose(LinkHandle);
            if ( !NT_SUCCESS(st) ) {
                DbgPrintEx(
                    DPFLTR_LDR_ID,
                    LDR_ERROR_DPFLTR,
                    "LDR: %s - failed call to NtQuerySymbolicLinkObject with status %x\n",
                    __FUNCTION__,
                    st);

                return st;
            }
        } else {
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - failed call to NtOpenSymbolicLinkObject with status %x\n",
                __FUNCTION__,
                st);
            return st;
        }
    }

    LDRP_CHECKPOINT();

    if (ProcessParameters) {

        //
        // If the process was created with process parameters,
        // then extract:
        //
        //      - Library Search Path
        //
        //      - Starting Current Directory
        //

        if (ProcessParameters->DllPath.Length)
            LdrpDefaultPath = ProcessParameters->DllPath;
        else
            LdrpInitializationFailure(STATUS_INVALID_PARAMETER);

        StaticCurDir = TRUE;
        CurDir = ProcessParameters->CurrentDirectory.DosPath;

#define DRIVE_ROOT_DIRECTORY_LENGTH 3 /* (sizeof("X:\\") - 1) */
        if (CurDir.Buffer == NULL || CurDir.Buffer[ 0 ] == UNICODE_NULL || CurDir.Length == 0) {
            CurDir.Buffer = (RtlAllocateStringRoutine)((DRIVE_ROOT_DIRECTORY_LENGTH + 1) * sizeof(WCHAR));
            if (CurDir.Buffer == NULL) {
                DbgPrintEx(
                    DPFLTR_LDR_ID,
                    LDR_ERROR_DPFLTR,
                    "LDR: %s - unable to allocate current working directory buffer\n",
                    __FUNCTION__);

                RtlRaiseStatus(STATUS_NO_MEMORY);
            }

            RtlMoveMemory( CurDir.Buffer,
                           USER_SHARED_DATA->NtSystemRoot,
                           DRIVE_ROOT_DIRECTORY_LENGTH * sizeof( WCHAR )
                         );
            CurDir.Buffer[ DRIVE_ROOT_DIRECTORY_LENGTH ] = UNICODE_NULL;
        }
    }

    //
    // Make sure the module data base is initialized before we take any
    // exceptions.
    //

    LDRP_CHECKPOINT();

    Peb->Ldr = RtlAllocateHeap(LdrpHeap, MAKE_TAG( LDR_TAG ), sizeof(PEB_LDR_DATA));
    if (!Peb->Ldr) {
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s - failed to allocate PEB_LDR_DATA\n",
            __FUNCTION__);

        RtlRaiseStatus(STATUS_NO_MEMORY);
    }

    Peb->Ldr->Length = sizeof(PEB_LDR_DATA);
    Peb->Ldr->Initialized = TRUE;
    Peb->Ldr->SsHandle = NULL;
    Peb->Ldr->EntryInProgress = NULL;

    InitializeListHead(&Peb->Ldr->InLoadOrderModuleList);
    InitializeListHead(&Peb->Ldr->InMemoryOrderModuleList);
    InitializeListHead(&Peb->Ldr->InInitializationOrderModuleList);

    //
    // Allocate the first data table entry for the image. Since we
    // have already mapped this one, we need to do the allocation by hand.
    // Its characteristics identify it as not a Dll, but it is linked
    // into the table so that pc correlation searching doesn't have to
    // be special cased.
    //

    LDRP_CHECKPOINT();
    LdrDataTableEntry = LdrpImageEntry = LdrpAllocateDataTableEntry(Peb->ImageBaseAddress);
    if (LdrDataTableEntry == NULL) {
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s - failing process initialization due to inability allocate \"%wZ\"'s LDR_DATA_TABLE_ENTRY\n",
            __FUNCTION__,
            &FullImageName);

        RtlRaiseStatus(STATUS_NO_MEMORY);
    }

    LdrDataTableEntry->LoadCount = (USHORT)0xffff;
    LdrDataTableEntry->EntryPoint = LdrpFetchAddressOfEntryPoint(LdrDataTableEntry->DllBase);
    LdrDataTableEntry->FullDllName = FullImageName;
    LdrDataTableEntry->Flags = (UseCOR) ? LDRP_COR_IMAGE : 0;
    LdrDataTableEntry->EntryPointActivationContext = NULL;

    // p = strrchr(FullImageName, '\\');
    // but not necessarily null terminated
    pp = UNICODE_NULL;
    p = FullImageName.Buffer;
    while (*p) {
        if (*p++ == (WCHAR)'\\') {
            pp = p;
        }
    }

    if (pp != NULL) {
        LdrDataTableEntry->BaseDllName.Length = (USHORT)((ULONG_PTR)p - (ULONG_PTR)pp);
        LdrDataTableEntry->BaseDllName.MaximumLength = LdrDataTableEntry->BaseDllName.Length + sizeof(WCHAR);
        LdrDataTableEntry->BaseDllName.Buffer =
            (PWSTR)
                (((ULONG_PTR) LdrDataTableEntry->FullDllName.Buffer) +
                    (LdrDataTableEntry->FullDllName.Length - LdrDataTableEntry->BaseDllName.Length));

    } else {
        LdrDataTableEntry->BaseDllName = LdrDataTableEntry->FullDllName;
    }

    LdrpInsertMemoryTableEntry(LdrDataTableEntry);

    LdrDataTableEntry->Flags |= LDRP_ENTRY_PROCESSED;

    //
    // The process references the system DLL, so map this one next. Since
    // we have already mapped this one, we need to do the allocation by
    // hand. Since every application will be statically linked to the
    // system Dll, we'll keep the LoadCount initialized to 0.
    //

    LdrDataTableEntry = LdrpAllocateDataTableEntry(SystemDllBase);
    if (LdrDataTableEntry == NULL) {
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s - failing process initialization due to inability to allocate NTDLL's LDR_DATA_TABLE_ENTRY\n",
            __FUNCTION__);

        RtlRaiseStatus(STATUS_NO_MEMORY);
    }

    LdrDataTableEntry->Flags = (USHORT)LDRP_IMAGE_DLL;
    LdrDataTableEntry->EntryPoint = LdrpFetchAddressOfEntryPoint(LdrDataTableEntry->DllBase);
    LdrDataTableEntry->LoadCount = (USHORT)0xffff;
    LdrDataTableEntry->EntryPointActivationContext = NULL;

    LdrDataTableEntry->FullDllName = SystemDllPath;
    RtlAppendUnicodeStringToString(&LdrDataTableEntry->FullDllName, &NtDllName);
    LdrDataTableEntry->BaseDllName = NtDllName;

    LdrpInsertMemoryTableEntry(LdrDataTableEntry);

#if defined(_AMD64_) // || defined(_IA64_)

    RtlInitializeHistoryTable();

#endif

    LdrpNtDllDataTableEntry = LdrDataTableEntry;

    if (ShowSnaps) {
        DbgPrint( "LDR: NEW PROCESS\n" );
        DbgPrint( "     Image Path: %wZ (%wZ)\n",
                  &LdrpImageEntry->FullDllName,
                  &LdrpImageEntry->BaseDllName
                );
        DbgPrint( "     Current Directory: %wZ\n", &CurDir );
        DbgPrint( "     Search Path: %wZ\n", &LdrpDefaultPath );
    }



    //
    // Add init routine to list
    //

    InsertHeadList(&Peb->Ldr->InInitializationOrderModuleList,
                   &LdrDataTableEntry->InInitializationOrderLinks);

    //
    // Inherit the current directory
    //

    LDRP_CHECKPOINT();
    st = RtlSetCurrentDirectory_U(&CurDir);
    if (!NT_SUCCESS(st)) {
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s - unable to set current directory to \"%wZ\"; status = %x\n",
            __FUNCTION__,
            &CurDir,
            st);

        if (!StaticCurDir)
            RtlFreeUnicodeString(&CurDir);

        CurDir = NtSystemRoot;
        st = RtlSetCurrentDirectory_U(&CurDir);
        if (!NT_SUCCESS(st))
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - unable to set current directory to NtSystemRoot; status = %x\n",
                __FUNCTION__,
                &CurDir);
        }
    else {
        if ( !StaticCurDir ) {
            RtlFreeUnicodeString(&CurDir);
            }
        }
    if (ProcessParameters->Flags & RTL_USER_PROC_APP_MANIFEST_PRESENT) {
        // Application manifests prevent .local detection.
        //
        // Note that we don't clear the flag so that someone like app compat
        // can forcibly set it to reenable .local + app manifest behavior.
    } else {
        //
        // Fusion 1.0 fixup : check the existence of .local, and set
        // a flag in PPeb->ProcessParameters.Flags
        //
        // Setup the global for this process that decides whether we want DLL
        // redirection on or not. LoadLibrary() and GetModuleHandle() look at this
        // boolean.

        ImagePathName.Length = ProcessParameters->ImagePathName.Length ;
        ImagePathName.MaximumLength =  ProcessParameters->ImagePathName.Length + sizeof(DLL_REDIRECTION_LOCAL_SUFFIX);
        ImagePathNameBuffer = (PWCHAR) RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TEMP_TAG ), ImagePathName.MaximumLength);
        if (ImagePathNameBuffer == NULL) {
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - unable to allocate heap for the image's .local path\n",
                __FUNCTION__);

            return STATUS_NO_MEMORY;
        }

        pw = (PWSTR)ProcessParameters->ImagePathName.Buffer;
        if (!(ProcessParameters->Flags & RTL_USER_PROC_PARAMS_NORMALIZED)) {
            pw = (PWSTR)((PCHAR)pw + (ULONG_PTR)(ProcessParameters));
        }

        RtlCopyMemory(ImagePathNameBuffer, pw,ProcessParameters->ImagePathName.Length);

        ImagePathName.Buffer = ImagePathNameBuffer;

        // Now append the suffix:
        st = RtlAppendUnicodeToString(&ImagePathName, DLL_REDIRECTION_LOCAL_SUFFIX);
        if (!NT_SUCCESS(st)) {
    #if DBG
            DbgPrint("RtlAppendUnicodeToString fails with status %lx\n", st);
    #endif
            RtlFreeHeap(RtlProcessHeap(), 0, ImagePathNameBuffer);
            return st;
        }

        // RtlDoesFileExists_U() wants a null-terminated string.
        ImagePathNameBuffer[ImagePathName.Length / sizeof(WCHAR)] = UNICODE_NULL;
        DotLocalExists = RtlDoesFileExists_U(ImagePathNameBuffer);

        if (DotLocalExists)  // set the flag in Peb->ProcessParameters->flags
            ProcessParameters->Flags |=  RTL_USER_PROC_DLL_REDIRECTION_LOCAL ;

        RtlFreeHeap(RtlProcessHeap(), 0, ImagePathNameBuffer); //cleanup
    }

    //
    // Second round of application verifier initialization. We need to split
    // this into two phases because some verifier things must happen very early
    // in the game and other things rely on other things being already initialized
    // (exception dispatching, system heap, etc.).
    //

    if (Peb->NtGlobalFlag & FLG_APPLICATION_VERIFIER) {
        AVrfInitializeVerifier (FALSE, NULL, 1);
    }

#if defined(_WIN64)
    //
    // Load in WOW64 if the image is supposed to run simulated
    //
    if (UseWOW64) {
        /*CONST*/ static UNICODE_STRING Wow64DllName = RTL_CONSTANT_STRING(L"wow64.dll");
        CONST static ANSI_STRING Wow64LdrpInitializeProcName = RTL_CONSTANT_STRING("Wow64LdrpInitialize");
        CONST static ANSI_STRING Wow64PrepareForExceptionProcName = RTL_CONSTANT_STRING("Wow64PrepareForException");
        CONST static ANSI_STRING Wow64ApcRoutineProcName = RTL_CONSTANT_STRING("Wow64ApcRoutine");

        st = LdrLoadDll(NULL, NULL, &Wow64DllName, &Wow64Handle);
        if (!NT_SUCCESS(st)) {
            if (ShowSnaps) {
                DbgPrint("LDR: wow64.dll not found.  Status=%x\n", st);
            }
            return st;
        }

        //
        // Get the entrypoints.  They are roughly cloned from ntos\ps\psinit.c
        // PspInitSystemDll().
        //
        st = LdrGetProcedureAddress(Wow64Handle,
                                    &Wow64LdrpInitializeProcName,
                                    0,
                                    (PVOID *)&Wow64LdrpInitialize);
        if (!NT_SUCCESS(st)) {
            if (ShowSnaps) {
                DbgPrint("LDR: Wow64LdrpInitialize not found.  Status=%x\n", st);
            }
            return st;
        }

        st = LdrGetProcedureAddress(Wow64Handle,
                                    &Wow64PrepareForExceptionProcName,
                                    0,
                                    (PVOID *)&Wow64PrepareForException);
        if (!NT_SUCCESS(st)) {
            if (ShowSnaps) {
                DbgPrint("LDR: Wow64PrepareForException not found.  Status=%x\n", st);
            }
            return st;
        }

        st = LdrGetProcedureAddress(Wow64Handle,
                                    &Wow64ApcRoutineProcName,
                                    0,
                                    (PVOID *)&Wow64ApcRoutine);
        if (!NT_SUCCESS(st)) {
            if (ShowSnaps) {
                DbgPrint("LDR: Wow64ApcRoutine not found.  Status=%x\n", st);
            }
            return st;
        }

        //
        // Now that all DLLs are loaded, if the process is being debugged,
        // signal the debugger with an exception
        //

        if ( Peb->BeingDebugged ) {
             DbgBreakPoint();
        }

        //
        // Release the loaderlock now - this thread doesn't need it any more.
        //
        RtlLeaveCriticalSection(&LdrpLoaderLock);

        //
        // Call wow64 to load and run 32-bit ntdll.dll.
        //
        (*Wow64LdrpInitialize)(Context);
        // This never returns.  It will destroy the process.
    }
#endif

    LDRP_CHECKPOINT();

    //
    // Check if image is COM+.
    //

    if (UseCOR) {
        //
        // The image is COM+ so notify the runtime that the image was loaded
        // and allow it to verify the image for correctness.
        //
        PVOID OriginalViewBase = Peb->ImageBaseAddress;

        st = LdrpCorValidateImage(&Peb->ImageBaseAddress,
                                  LdrpImageEntry->FullDllName.Buffer);
        if (!NT_SUCCESS(st)) {
            return st;
        }
        if (OriginalViewBase != Peb->ImageBaseAddress) {
            //
            // Mscoree has substituted a new image at a new base in place
            // of the original image.  Unmap the original image and use
            // the new image from now on.
            //
            NtUnmapViewOfSection(NtCurrentProcess(), OriginalViewBase);
            NtHeader = RtlImageNtHeader(Peb->ImageBaseAddress);
            if (!NtHeader) {
                LdrpCorUnloadImage(Peb->ImageBaseAddress);
                return STATUS_INVALID_IMAGE_FORMAT;
            }
            // Update the exe's LDR_DATA_TABLE_ENTRY
            LdrpImageEntry->DllBase = Peb->ImageBaseAddress;
            LdrpImageEntry->EntryPoint = LdrpFetchAddressOfEntryPoint(LdrpImageEntry->DllBase);
        }
        // Edit the initial instruction pointer to point into mscoree.dll
        LdrpCorReplaceStartContext(Context);
    }

    LDRP_CHECKPOINT();

    // If this is a windows subsystem app, load kernel32 so that it can handle processing
    // activation contexts found in DLLs and the .exe.

    if ((NtHeader->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_GUI) ||
        (NtHeader->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_CUI)) {
        UNICODE_STRING Kernel32DllName = RTL_CONSTANT_STRING(L"kernel32.dll");
        PVOID Kernel32Handle;

        st = LdrpLoadDll(
                0,                  // Flags
                NULL,               // DllPath
                NULL,               // DllCharacteristics
                &Kernel32DllName,   // DllName
                &Kernel32Handle,    // DllHandle
                TRUE);             // RunInitRoutines
        if (!NT_SUCCESS(st)) {
            if (ShowSnaps) {
                DbgPrint("LDR: Unable to load kernel32.dll.  Status=%x\n", st);
            }
            return st;
        }

        st = LdrGetProcedureAddress(Kernel32Handle, &Kernel32ProcessInitPostImportFunctionName, 0, (PVOID *) &Kernel32ProcessInitPostImportFunction);
        if (!NT_SUCCESS(st)) {
            if (ShowSnaps) {
                DbgPrint(
                    "LDR: Failed to find post-import process init function in kernel32; ntstatus 0x%08lx\n", st);
            }
            Kernel32ProcessInitPostImportFunction = NULL;

            if (st != STATUS_PROCEDURE_NOT_FOUND)
                return st;
        }
    }

    LDRP_CHECKPOINT();

    st = LdrpWalkImportDescriptor(LdrpDefaultPath.Buffer, LdrpImageEntry);
    if (!NT_SUCCESS(st))
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s - call to LdrpWalkImportDescriptor failed with status %x\n",
            __FUNCTION__,
            st);

    LDRP_CHECKPOINT();

    if ((PVOID)NtHeader->OptionalHeader.ImageBase != Peb->ImageBaseAddress) {

        //
        // The executable is not at its original address.  It must be
        // relocated now.
        //

        PVOID ViewBase;
        NTSTATUS status;

        ViewBase = Peb->ImageBaseAddress;

        status = LdrpSetProtection(ViewBase, FALSE, TRUE);

        if (!NT_SUCCESS(status)) {
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - call to LdrpSetProtection(%p, FALSE, TRUE) failed with status %x\n",
                __FUNCTION__,
                ViewBase,
                status);

            return status;
        }

        status = LdrRelocateImage(ViewBase,
                    "LDR",
                    STATUS_SUCCESS,
                    STATUS_CONFLICTING_ADDRESSES,
                    STATUS_INVALID_IMAGE_FORMAT
                    );

        if (!NT_SUCCESS(status)) {
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - call to LdrRelocateImage failed with status %x\n",
                __FUNCTION__,
                status);

            return status;
        }

        //
        // Update the initial thread context record as per the relocation.
        //

        if (Context) {

            OldBase = NtHeader->OptionalHeader.ImageBase;
            Diff = (PCHAR)ViewBase - (PCHAR)OldBase;

            LdrpRelocateStartContext(Context, Diff);
        }

        status = LdrpSetProtection(ViewBase, TRUE, TRUE);
        if (!NT_SUCCESS(status)) {
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - call to LdrpSetProtection(%p, TRUE, TRUE) failed with status %x\n",
                __FUNCTION__,
                ViewBase,
                status);

            return status;
        }
    }

    LDRP_CHECKPOINT();

    LdrpReferenceLoadedDll(LdrpImageEntry);

    //
    // Lock the loaded DLLs to prevent dlls that back link to the exe to
    // cause problems when they are unloaded.
    //

    {
        PLDR_DATA_TABLE_ENTRY Entry;
        PLIST_ENTRY Head,Next;

        Head = &Peb->Ldr->InLoadOrderModuleList;
        Next = Head->Flink;

        while ( Next != Head ) {
            Entry = CONTAINING_RECORD(Next, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
            Entry->LoadCount = 0xffff;
            Next = Next->Flink;
        }
    }

    //
    // All static DLLs are now pinned in place. No init routines have been run yet
    //

    LdrpLdrDatabaseIsSetup = TRUE;


    if (!NT_SUCCESS(st)) {
#if DBG
        DbgPrint("LDR: Initialize of image failed. Returning Error Status 0x%lx\n", st);
#endif
        return st;
    }

    LDRP_CHECKPOINT();

    if ( !NT_SUCCESS(st = LdrpInitializeTls()) ) {
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s - failed to initialize TLS slots; status %x\n",
            __FUNCTION__,
            st);

        return st;
    }

    //
    // Register initial dll ranges with the stack tracing module.
    // This is used for getting reliable stack traces on X86.
    //

#if defined(_X86_)
    {

        PLIST_ENTRY Current, Start;
        PLDR_DATA_TABLE_ENTRY Entry;

        Start = &(NtCurrentPeb()->Ldr->InMemoryOrderModuleList);
        Current = Start->Flink;

        while (Current != Start) {

            Entry = CONTAINING_RECORD (Current,
                                       LDR_DATA_TABLE_ENTRY,
                                       InMemoryOrderLinks);

            RtlpStkMarkDllRange (Entry);
            Current = Current->Flink;
        }
    }
#endif

    //
    // Now that all DLLs are loaded, if the process is being debugged,
    // signal the debugger with an exception
    //

    if (Peb->BeingDebugged) {
         DbgBreakPoint();
         ShowSnaps = ((FLG_SHOW_LDR_SNAPS & Peb->NtGlobalFlag) != 0);
    }

    LDRP_CHECKPOINT();

#if defined (_X86_)
    if ( LdrpNumberOfProcessors > 1 ) {
        LdrpValidateImageForMp(LdrDataTableEntry);
    }
#endif

#if DBG
    if (LdrpDisplayLoadTime) {
        NtQueryPerformanceCounter(&InitbTime, NULL);
    }
#endif // DBG

    //
    // Check for shimmed apps if necessary
    //
    if (pAppCompatExeData != NULL) {

        Peb->AppCompatInfo = NULL;

        //
        // The name of the engine is the first thing in the appcompat structure.
        //
        LdrpLoadShimEngine((WCHAR*)pAppCompatExeData, UnicodeImageName, pAppCompatExeData);
        }
    else {
        //
        // Get all application goo here (hacks, flags, etc.)
        //
        LdrQueryApplicationCompatibilityGoo(UnicodeImageName, ImageFileOptionsPresent);
        }

    LDRP_CHECKPOINT();

    if (Kernel32ProcessInitPostImportFunction != NULL) {
        st = (*Kernel32ProcessInitPostImportFunction)();
        if (!NT_SUCCESS(st)) {
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - Failed running kernel32 post-import function; status 0x%08lx\n",
                __FUNCTION__,
                st);

            return st;
        }
    }

    LDRP_CHECKPOINT();

    st = LdrpRunInitializeRoutines(Context);
    if (!NT_SUCCESS(st)) {
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s - Failed running initialization routines; status %x\n",
            __FUNCTION__,
            st);

        return st;
    }

    //
    // Shim engine callback.
    //
    if (g_pfnSE_InstallAfterInit != NULL) {
        if (!(*g_pfnSE_InstallAfterInit)(UnicodeImageName, pAppCompatExeData)) {
            LdrpUnloadShimEngine();
        }
    }

    if ( NT_SUCCESS(st) && Peb->PostProcessInitRoutine ) {
        (Peb->PostProcessInitRoutine)();
    }

    LDRP_CHECKPOINT();

    return STATUS_SUCCESS;
}

VOID
LdrShutdownProcess (
    VOID
    )

/*++

Routine Description:

    This function is called by a process that is terminating cleanly.
    It's purpose is to call all of the processes DLLs to notify them
    that the process is detaching.

Arguments:

    None

Return Value:

    None.

--*/

{
    PPEB Peb;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    PDLL_INIT_ROUTINE InitRoutine;
    PLIST_ENTRY Next;

    //
    // only unload once ! DllTerm routines might call exit process in fatal situations
    //

    if ( LdrpShutdownInProgress ) {
        return;
        }

    //
    // notify the shim engine that the process is exiting
    //

    if ( g_pfnSE_ProcessDying ) {
        (*g_pfnSE_ProcessDying)();
        }

    RtlDetectHeapLeaks();

    Peb = NtCurrentPeb();

    if (ShowSnaps) {
        UNICODE_STRING CommandLine;

        CommandLine = Peb->ProcessParameters->CommandLine;
        if (!(Peb->ProcessParameters->Flags & RTL_USER_PROC_PARAMS_NORMALIZED)) {
            CommandLine.Buffer = (PWSTR)((PCHAR)CommandLine.Buffer + (ULONG_PTR)(Peb->ProcessParameters));
        }

        DbgPrint( "LDR: PID: 0x%x finished - '%wZ'\n",
                  NtCurrentTeb()->ClientId.UniqueProcess,
                  &CommandLine
                );
    }

    LdrpShutdownThreadId = NtCurrentTeb()->ClientId.UniqueThread;
    LdrpShutdownInProgress = TRUE;
    RtlEnterCriticalSection(&LdrpLoaderLock);

    try {

        //
        // ISSUE: 399703: SilviuC: check for process heap lock does not offer enough protection
        // The if below is not enough to prevent deadlocks in dll init code due to waiting
        // for critical sections orphaned by terminating all threads (except this one).
        // A better way to implement this would be to iterate all critical sections and
        // figure out if any of them is abandoned with an owner thread different than
        // this one. If yes then we probably should not call dll init routines.
        // The way this code is implemented right now it is basically a Russian roullette
        // waiting for deadlocks to happen.
        //
        // Check to see if the heap is locked. If so, do not do ANY
        // dll processing since it is very likely that a dll will need
        // to do heap operations, but that the heap is not in good shape.
        // ExitProcess called in a very active app can leave threads terminated
        // in the middle of the heap code or in other very bad places. Checking the
        // heap lock is a good indication that the process was very active when it
        // called ExitProcess
        //

        if ( RtlpHeapIsLocked( RtlProcessHeap() )) {
            ;
            }
        else {

            //
            //If tracing was ever turned on then cleanup the things here.
            //

            if(USER_SHARED_DATA->TraceLogging){
            ShutDownWmiHandles();
            }

            //
            // Now Deinitialize the Wmi stuff
            //

            WmipDeinitializeDll();


            //
            // IMPORTANT NOTE. We cannot do heap validation here no matter how much
            // we would like it because we have just terminated unconditionally all
            // other threads and this could have left heaps in some weird state. For
            // instance a heap might have been destroyed but we did not manage to get
            // it out of the process heap list and we will still try to validate it.
            // In the future all this type of code should be implemented in appverifier.
            //

            //
            // Go in reverse order initialization order and build
            // the unload list
            //

            Next = Peb->Ldr->InInitializationOrderModuleList.Blink;
            while ( Next != &Peb->Ldr->InInitializationOrderModuleList) {
                LdrDataTableEntry
                    = (PLDR_DATA_TABLE_ENTRY)
                      (CONTAINING_RECORD(Next,LDR_DATA_TABLE_ENTRY,InInitializationOrderLinks));

                Next = Next->Blink;

                //
                // Walk through the entire list looking for
                // entries. For each entry, that has an init
                // routine, call it.
                //

                if (Peb->ImageBaseAddress != LdrDataTableEntry->DllBase) {
                    InitRoutine = (PDLL_INIT_ROUTINE)LdrDataTableEntry->EntryPoint;
                    if (InitRoutine && (LdrDataTableEntry->Flags & LDRP_PROCESS_ATTACH_CALLED) ) {
                        LDRP_ACTIVATE_ACTIVATION_CONTEXT(LdrDataTableEntry);
                        if ( LdrDataTableEntry->TlsIndex) {
                            LdrpCallTlsInitializers(LdrDataTableEntry->DllBase,DLL_PROCESS_DETACH);
                            }

                        LdrpCallInitRoutine(InitRoutine,
                                            LdrDataTableEntry->DllBase,
                                            DLL_PROCESS_DETACH,
                                            (PVOID)1);
                        LDRP_DEACTIVATE_ACTIVATION_CONTEXT();
                        }
                    }
                }

            //
            // If the image has tls than call its initializers
            //

            if ( LdrpImageHasTls ) {
                LDRP_ACTIVATE_ACTIVATION_CONTEXT(LdrpImageEntry);
                LdrpCallTlsInitializers(NtCurrentPeb()->ImageBaseAddress,DLL_PROCESS_DETACH);
                LDRP_DEACTIVATE_ACTIVATION_CONTEXT();
                }
            }

    } finally {
        RtlLeaveCriticalSection(&LdrpLoaderLock);
    }

}

VOID
LdrShutdownThread (
    VOID
    )

/*++

Routine Description:

    This function is called by a thread that is terminating cleanly.
    It's purpose is to call all of the processes DLLs to notify them
    that the thread is detaching.

Arguments:

    None

Return Value:

    None.

--*/

{
    PPEB Peb;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    PDLL_INIT_ROUTINE InitRoutine;
    PLIST_ENTRY Next;

    Peb = NtCurrentPeb();

    RtlEnterCriticalSection(&LdrpLoaderLock);
    __try {


        //
        // If the heap tracing was ever turned on then do the cleaning stuff here.
        //

        if(USER_SHARED_DATA->TraceLogging){
            CleanOnThreadExit();
        }


        //
        // If the heap tracing was ever turned on then do the cleaning stuff here.
        //

        if(USER_SHARED_DATA->TraceLogging){
            CleanOnThreadExit();
        }


        //
        // Go in reverse order initialization order and build
        // the unload list
        //

        Next = Peb->Ldr->InInitializationOrderModuleList.Blink;
        while ( Next != &Peb->Ldr->InInitializationOrderModuleList) {
            LdrDataTableEntry
                = (PLDR_DATA_TABLE_ENTRY)
                  (CONTAINING_RECORD(Next,LDR_DATA_TABLE_ENTRY,InInitializationOrderLinks));

            Next = Next->Blink;

            //
            // Walk through the entire list looking for
            // entries. For each entry, that has an init
            // routine, call it.
            //

            if (Peb->ImageBaseAddress != LdrDataTableEntry->DllBase) {
                if ( !(LdrDataTableEntry->Flags & LDRP_DONT_CALL_FOR_THREADS)) {
                    InitRoutine = (PDLL_INIT_ROUTINE)LdrDataTableEntry->EntryPoint;
                    if (InitRoutine && (LdrDataTableEntry->Flags & LDRP_PROCESS_ATTACH_CALLED) ) {
                        if (LdrDataTableEntry->Flags & LDRP_IMAGE_DLL) {
                            LDRP_ACTIVATE_ACTIVATION_CONTEXT(LdrDataTableEntry);
                            if ( LdrDataTableEntry->TlsIndex ) {
                                LdrpCallTlsInitializers(LdrDataTableEntry->DllBase,DLL_THREAD_DETACH);
                            }

                            LdrpCallInitRoutine(InitRoutine,
                                                LdrDataTableEntry->DllBase,
                                                DLL_THREAD_DETACH,
                                                NULL);
                            LDRP_DEACTIVATE_ACTIVATION_CONTEXT();
                        }
                    }
                }
            }
        }

        //
        // If the image has tls than call its initializers
        //

        if ( LdrpImageHasTls ) {
            LDRP_ACTIVATE_ACTIVATION_CONTEXT(LdrpImageEntry);
            LdrpCallTlsInitializers(NtCurrentPeb()->ImageBaseAddress,DLL_THREAD_DETACH);
            LDRP_DEACTIVATE_ACTIVATION_CONTEXT();
        }
        LdrpFreeTls();
    } __finally {
        RtlLeaveCriticalSection(&LdrpLoaderLock);
    }
}

VOID
LdrpInitializeThread(
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called by a thread that is terminating cleanly.
    It's purpose is to call all of the processes DLLs to notify them
    that the thread is detaching.

Arguments:

    Context - Context that will be restored after loader initializes.

Return Value:

    None.

--*/

{
    PPEB Peb;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    PDLL_INIT_ROUTINE InitRoutine;
    PLIST_ENTRY Next;

    Peb = NtCurrentPeb();

    if ( LdrpShutdownInProgress ) {
        return;
        }

    LdrpAllocateTls();

    Next = Peb->Ldr->InMemoryOrderModuleList.Flink;
    while (Next != &Peb->Ldr->InMemoryOrderModuleList) {
        LdrDataTableEntry
            = (PLDR_DATA_TABLE_ENTRY)
              (CONTAINING_RECORD(Next, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks));

        //
        // Walk through the entire list looking for
        // entries. For each entry, that has an init
        // routine, call it.
        //
        if (Peb->ImageBaseAddress != LdrDataTableEntry->DllBase) {
            if ( !(LdrDataTableEntry->Flags & LDRP_DONT_CALL_FOR_THREADS)) {
                InitRoutine = (PDLL_INIT_ROUTINE)LdrDataTableEntry->EntryPoint;
                if (InitRoutine && (LdrDataTableEntry->Flags & LDRP_PROCESS_ATTACH_CALLED) ) {
                    if (LdrDataTableEntry->Flags & LDRP_IMAGE_DLL) {
                        LDRP_ACTIVATE_ACTIVATION_CONTEXT(LdrDataTableEntry);
                        if ( LdrDataTableEntry->TlsIndex ) {
                            if ( !LdrpShutdownInProgress ) {
                                LdrpCallTlsInitializers(LdrDataTableEntry->DllBase,DLL_THREAD_ATTACH);
                            }
                        }
                        if ( !LdrpShutdownInProgress ) {
                            LdrpCallInitRoutine(InitRoutine,
                                                LdrDataTableEntry->DllBase,
                                                DLL_THREAD_ATTACH,
                                                NULL);
                        }
                        LDRP_DEACTIVATE_ACTIVATION_CONTEXT();
                    }
                }
            }
        }
        Next = Next->Flink;
    }

    //
    // If the image has tls than call its initializers
    //

    if ( LdrpImageHasTls && !LdrpShutdownInProgress ) {
        LDRP_ACTIVATE_ACTIVATION_CONTEXT(LdrpImageEntry);
        LdrpCallTlsInitializers(NtCurrentPeb()->ImageBaseAddress,DLL_THREAD_ATTACH);
        LDRP_DEACTIVATE_ACTIVATION_CONTEXT();
    }
}

NTSTATUS
LdrpOpenImageFileOptionsKey(
    IN PUNICODE_STRING ImagePathName,
    OUT PHANDLE KeyHandle
    )
{
    UNICODE_STRING UnicodeString;
    PWSTR pw;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING KeyPath;
    WCHAR KeyPathBuffer[ DOS_MAX_COMPONENT_LENGTH + 100 ];

    KeyPath.Buffer = KeyPathBuffer;
    KeyPath.Length = 0;
    KeyPath.MaximumLength = sizeof( KeyPathBuffer );

    RtlAppendUnicodeToString( &KeyPath,
                              L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\"
                            );

    UnicodeString = *ImagePathName;
    pw = (PWSTR)((PCHAR)UnicodeString.Buffer + UnicodeString.Length);
    UnicodeString.MaximumLength = UnicodeString.Length;
    while (UnicodeString.Length != 0) {
        if (pw[ -1 ] == OBJ_NAME_PATH_SEPARATOR) {
            break;
            }
        pw--;
        UnicodeString.Length -= sizeof( *pw );
        }
    UnicodeString.Buffer = pw;
    UnicodeString.Length = UnicodeString.MaximumLength - UnicodeString.Length;

    RtlAppendUnicodeStringToString( &KeyPath, &UnicodeString );

    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyPath,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    return NtOpenKey( KeyHandle,
                      GENERIC_READ,
                      &ObjectAttributes
                    );
}

NTSTATUS
LdrpQueryImageFileKeyOption(
    IN HANDLE KeyHandle,
    IN PWSTR OptionName,
    IN ULONG Type,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG ResultSize OPTIONAL
    )
{
    BOOLEAN bNeedToFree=FALSE;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    ULONG KeyValueBuffer[ 256 ];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    ULONG AllocLength;
    ULONG ResultLength;

    RtlInitUnicodeString( &UnicodeString, OptionName );
    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)&KeyValueBuffer;
    Status = NtQueryValueKey( KeyHandle,
                              &UnicodeString,
                              KeyValuePartialInformation,
                              KeyValueInformation,
                              sizeof( KeyValueBuffer ),
                              &ResultLength
                            );
    if (Status == STATUS_BUFFER_OVERFLOW) {

        //
        // This function can be called before the process heap gets created
        // therefore we need to protect against this case. The majority of the
        // code will not hit this code path because they read just strings
        // containing hex numbers and for this the size of KeyValueBuffer is
        // more than sufficient.
        //

        if (RtlProcessHeap()) {

            AllocLength = sizeof( *KeyValueInformation ) +
                KeyValueInformation->DataLength;
            KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)
            RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TEMP_TAG ), AllocLength);

            if (KeyValueInformation == NULL) {
                Status = STATUS_NO_MEMORY;
            }
            else {
                bNeedToFree = TRUE;
                Status = NtQueryValueKey( KeyHandle,
                    &UnicodeString,
                    KeyValuePartialInformation,
                    KeyValueInformation,
                    AllocLength,
                    &ResultLength
                    );
            }
        }
        else {

            Status = STATUS_NO_MEMORY;
        }
    }

    if (NT_SUCCESS( Status )) {
        if (KeyValueInformation->Type == REG_BINARY) {
            if ((Buffer) &&
                (KeyValueInformation->DataLength <= BufferSize)) {
                RtlMoveMemory( Buffer, &KeyValueInformation->Data, KeyValueInformation->DataLength);
                }
            else {
                Status = STATUS_BUFFER_OVERFLOW;
                }
            if (ARGUMENT_PRESENT( ResultSize )) {
                *ResultSize = KeyValueInformation->DataLength;
                }
            }
        else if (KeyValueInformation->Type == REG_DWORD) {

            if (Type != REG_DWORD) {
                Status = STATUS_OBJECT_TYPE_MISMATCH;
            }
            else {
                if ((Buffer)
                    && (BufferSize == sizeof(ULONG))
                    && (KeyValueInformation->DataLength == BufferSize)) {

                    RtlMoveMemory( Buffer, &KeyValueInformation->Data, KeyValueInformation->DataLength);
                }
                else {
                    Status = STATUS_BUFFER_OVERFLOW;
                }

                if (ARGUMENT_PRESENT( ResultSize )) {
                    *ResultSize = KeyValueInformation->DataLength;
                }
            }
        }
        else if (KeyValueInformation->Type != REG_SZ) {
            Status = STATUS_OBJECT_TYPE_MISMATCH;
            }
        else {
            if (Type == REG_DWORD) {
                if (BufferSize != sizeof( ULONG )) {
                    BufferSize = 0;
                    Status = STATUS_INFO_LENGTH_MISMATCH;
                    }
                else {
                    UnicodeString.Buffer = (PWSTR)&KeyValueInformation->Data;
                    UnicodeString.Length = (USHORT)
                        (KeyValueInformation->DataLength - sizeof( UNICODE_NULL ));
                    UnicodeString.MaximumLength = (USHORT)KeyValueInformation->DataLength;
                    Status = RtlUnicodeStringToInteger( &UnicodeString, 0, (PULONG)Buffer );
                    }
                }
            else {
                if (KeyValueInformation->DataLength > BufferSize) {
                    Status = STATUS_BUFFER_OVERFLOW;
                    }
                else {
                    BufferSize = KeyValueInformation->DataLength;
                    }

                RtlMoveMemory( Buffer, &KeyValueInformation->Data, BufferSize );
                }

            if (ARGUMENT_PRESENT( ResultSize )) {
                *ResultSize = BufferSize;
                }
            }
        }

    if (bNeedToFree)
        RtlFreeHeap(RtlProcessHeap(), 0, KeyValueInformation);

    return Status;
}

NTSTATUS
LdrQueryImageFileExecutionOptions(
    IN PUNICODE_STRING ImagePathName,
    IN PWSTR OptionName,
    IN ULONG Type,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG ResultSize OPTIONAL
    )
{
    NTSTATUS Status;
    HANDLE KeyHandle;

    Status = LdrpOpenImageFileOptionsKey( ImagePathName,
                                          &KeyHandle );

    if (NT_SUCCESS( Status )) {

        Status = LdrpQueryImageFileKeyOption( KeyHandle,
                                              OptionName,
                                              Type,
                                              Buffer,
                                              BufferSize,
                                              ResultSize
                                            );

        NtClose( KeyHandle );
    }

    return Status;
}


NTSTATUS
LdrpInitializeTls(
        VOID
        )
{
    PLDR_DATA_TABLE_ENTRY Entry;
    PLIST_ENTRY Head,Next;
    PIMAGE_TLS_DIRECTORY TlsImage;
    PLDRP_TLS_ENTRY TlsEntry;
    ULONG TlsSize;
    BOOLEAN FirstTimeThru = TRUE;

    InitializeListHead(&LdrpTlsList);

    //
    // Walk through the loaded modules an look for TLS. If we find TLS,
    // lock in the module and add to the TLS chain.
    //

    Head = &NtCurrentPeb()->Ldr->InLoadOrderModuleList;
    Next = Head->Flink;

    while ( Next != Head ) {
        Entry = CONTAINING_RECORD(Next, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
        Next = Next->Flink;

        TlsImage = (PIMAGE_TLS_DIRECTORY)RtlImageDirectoryEntryToData(
                           Entry->DllBase,
                           TRUE,
                           IMAGE_DIRECTORY_ENTRY_TLS,
                           &TlsSize
                           );

        //
        // mark whether or not the image file has TLS
        //

        if ( FirstTimeThru ) {
            FirstTimeThru = FALSE;
            if ( TlsImage && !LdrpImageHasTls) {
                RtlpSerializeHeap( RtlProcessHeap() );
                LdrpImageHasTls = TRUE;
                }
            }

        if ( TlsImage ) {
            if (ShowSnaps) {
                DbgPrint( "LDR: Tls Found in %wZ at %p\n",
                            &Entry->BaseDllName,
                            TlsImage
                        );
                }

            TlsEntry = RtlAllocateHeap(RtlProcessHeap(),MAKE_TAG( TLS_TAG ),sizeof(*TlsEntry));
            if ( !TlsEntry ) {
                return STATUS_NO_MEMORY;
                }

            //
            // Since this DLL has TLS, lock it in
            //

            Entry->LoadCount = (USHORT)0xffff;

            //
            // Mark this as having thread local storage
            //

            Entry->TlsIndex = (USHORT)0xffff;

            TlsEntry->Tls = *TlsImage;
            InsertTailList(&LdrpTlsList,&TlsEntry->Links);

            //
            // Update the index for this dll's thread local storage
            //


            *(PLONG)TlsEntry->Tls.AddressOfIndex = LdrpNumberOfTlsEntries;
            TlsEntry->Tls.Characteristics = LdrpNumberOfTlsEntries++;
            }
        }

    //
    // We now have walked through all static DLLs and know
    // all DLLs that reference thread local storage. Now we
    // just have to allocate the thread local storage for the current
    // thread and for all subsequent threads
    //

    return LdrpAllocateTls();
}

NTSTATUS
LdrpAllocateTls(
    VOID
    )
{
    PTEB Teb;
    PLIST_ENTRY Head, Next;
    PLDRP_TLS_ENTRY TlsEntry;
    PVOID *TlsVector;

    Teb = NtCurrentTeb();

    //
    // Allocate the array of thread local storage pointers
    //

    if ( LdrpNumberOfTlsEntries ) {
        TlsVector = RtlAllocateHeap(RtlProcessHeap(),MAKE_TAG( TLS_TAG ),sizeof(PVOID)*LdrpNumberOfTlsEntries);
        if ( !TlsVector ) {
            return STATUS_NO_MEMORY;
            }

        Teb->ThreadLocalStoragePointer = TlsVector;
        Head = &LdrpTlsList;
        Next = Head->Flink;

        while ( Next != Head ) {
            TlsEntry = CONTAINING_RECORD(Next, LDRP_TLS_ENTRY, Links);
            Next = Next->Flink;
            TlsVector[TlsEntry->Tls.Characteristics] = RtlAllocateHeap(
                                                        RtlProcessHeap(),
                                                        MAKE_TAG( TLS_TAG ),
                                                        TlsEntry->Tls.EndAddressOfRawData - TlsEntry->Tls.StartAddressOfRawData
                                                        );
            if (!TlsVector[TlsEntry->Tls.Characteristics] ) {
                return STATUS_NO_MEMORY;
                }

            if (ShowSnaps) {
                DbgPrint("LDR: TlsVector %x Index %d = %x copied from %x to %x\n",
                    TlsVector,
                    TlsEntry->Tls.Characteristics,
                    &TlsVector[TlsEntry->Tls.Characteristics],
                    TlsEntry->Tls.StartAddressOfRawData,
                    TlsVector[TlsEntry->Tls.Characteristics]
                    );
                }

            RtlCopyMemory(
                TlsVector[TlsEntry->Tls.Characteristics],
                (PVOID)TlsEntry->Tls.StartAddressOfRawData,
                TlsEntry->Tls.EndAddressOfRawData - TlsEntry->Tls.StartAddressOfRawData
                );

            //
            // Do the TLS Callouts
            //

            }
        }
    return STATUS_SUCCESS;
}

VOID
LdrpFreeTls(
    VOID
    )
{
    PTEB Teb;
    PLIST_ENTRY Head, Next;
    PLDRP_TLS_ENTRY TlsEntry;
    PVOID *TlsVector;

    Teb = NtCurrentTeb();

    TlsVector = Teb->ThreadLocalStoragePointer;

    if ( TlsVector ) {
        Head = &LdrpTlsList;
        Next = Head->Flink;

        while ( Next != Head ) {
            TlsEntry = CONTAINING_RECORD(Next, LDRP_TLS_ENTRY, Links);
            Next = Next->Flink;

            //
            // Do the TLS callouts
            //

            if ( TlsVector[TlsEntry->Tls.Characteristics] ) {
                RtlFreeHeap(
                    RtlProcessHeap(),
                    0,
                    TlsVector[TlsEntry->Tls.Characteristics]
                    );

                }
            }

        RtlFreeHeap(
            RtlProcessHeap(),
            0,
            TlsVector
            );
        }
}

VOID
LdrpCallTlsInitializers(
    PVOID DllBase,
    ULONG Reason
    )
{
    PIMAGE_TLS_DIRECTORY TlsImage;
    ULONG TlsSize;
    PIMAGE_TLS_CALLBACK *CallBackArray;
    PIMAGE_TLS_CALLBACK InitRoutine;

    TlsImage = (PIMAGE_TLS_DIRECTORY)RtlImageDirectoryEntryToData(
                       DllBase,
                       TRUE,
                       IMAGE_DIRECTORY_ENTRY_TLS,
                       &TlsSize
                       );


    try {
        if ( TlsImage ) {
            CallBackArray = (PIMAGE_TLS_CALLBACK *)TlsImage->AddressOfCallBacks;
            if ( CallBackArray ) {
                if (ShowSnaps) {
                    DbgPrint( "LDR: Tls Callbacks Found. Imagebase %p Tls %p CallBacks %p\n",
                                DllBase,
                                TlsImage,
                                CallBackArray
                            );
                    }

                while(*CallBackArray){
                    InitRoutine = *CallBackArray++;

                    if (ShowSnaps) {
                        DbgPrint( "LDR: Calling Tls Callback Imagebase %p Function %p\n",
                                    DllBase,
                                    InitRoutine
                                );
                        }

                    LdrpCallInitRoutine((PDLL_INIT_ROUTINE)InitRoutine,
                                        DllBase,
                                        Reason,
                                        0);
                    }
                }
            }
        }
    except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s - caught exception %08lx calling TLS callbacks\n",
            __FUNCTION__,
            GetExceptionCode());
        ;
        }
}



ULONG GetNextCommaValue( IN OUT WCHAR **p, IN OUT ULONG *len )
{
    ULONG Number = 0;

    while (*len && (UNICODE_NULL != **p) && **p != L',')
    {
        // Let's ignore spaces
        if ( L' ' != **p )
        {
            Number = (Number * 10) + ( (ULONG)**p - L'0' );
        }

        (*p)++;
        (*len)--;
    }

    //
    // If we're at a comma, get past it for the next call
    //
    if ( L',' == **p )
    {
        (*p)++;
        (*len)--;
    }

    return Number;
}



VOID
LdrQueryApplicationCompatibilityGoo(
    IN PUNICODE_STRING UnicodeImageName,
    IN BOOLEAN ImageFileOptionsPresent
    )

/*++

Routine Description:

    This function is called by LdrpInitialize after its initialized the
    process.  It's purpose is to query any application specific flags,
    hacks, etc.  If any app specific information is found, its hung off
    the PEB for other components to test against.

    Besides setting hanging the AppCompatInfo struct off the PEB, the
    only other action that will occur in here is setting OS version
    numbers in the PEB if the appropriate Version lie app flag is set.

Arguments:

    UnicodeImageName - Actual image name (including path)

Return Value:

    None.

--*/

{
    PPEB Peb;
    PVOID ResourceInfo;
    ULONG TotalGooLength;
    ULONG AppCompatLength;
    ULONG ResultSize;
    ULONG ResourceSize;
    ULONG InputCompareLength;
    ULONG OutputCompareLength;
    LANGID LangId;
    NTSTATUS st;
    BOOLEAN bImageContainsVersionResourceInfo;
    ULONG_PTR IdPath[3];
    APP_COMPAT_GOO LocalAppCompatGoo;
    PAPP_COMPAT_GOO AppCompatGoo;
    PAPP_COMPAT_INFO AppCompatInfo;
    PAPP_VARIABLE_INFO AppVariableInfo;
    PPRE_APP_COMPAT_INFO AppCompatEntry;
    PIMAGE_RESOURCE_DATA_ENTRY DataEntry;
    PEFFICIENTOSVERSIONINFOEXW OSVerInfo;
    UNICODE_STRING EnvName;
    UNICODE_STRING EnvValue;
    WCHAR *NewCSDString;
    WCHAR TempString[ 128 ];   // is the size of szCSDVersion in OSVERSIONINFOW
    BOOLEAN fNewCSDVersionBuffer = FALSE;

    struct {
        USHORT TotalSize;
        USHORT DataSize;
        USHORT Type;
        WCHAR Name[16];              // L"VS_VERSION_INFO" + unicode nul
    } *Resource;


    //
    // Check execution options to see if there's any Goo for this app.
    // We purposely feed a small struct to LdrQueryImageFileExecOptions,
    // so that it can come back with success/failure, and if success we see
    // how much we need to alloc.  As the results coming back will be of
    // variable length.
    //
    Peb = NtCurrentPeb();
    Peb->AppCompatInfo = NULL;
    Peb->AppCompatFlags.QuadPart = 0;

    if ( ImageFileOptionsPresent ) {

        st = LdrQueryImageFileExecutionOptions( UnicodeImageName,
                                                L"ApplicationGoo",
                                                REG_BINARY,
                                                &LocalAppCompatGoo,
                                                sizeof(APP_COMPAT_GOO),
                                                &ResultSize
                                              );

        //
        // If there's an entry there, we're guaranteed to get overflow error.
        //
        if (st == STATUS_BUFFER_OVERFLOW) {

            //
            // Something is there, alloc memory for the "Pre" Goo struct right now
            //
            AppCompatGoo =
                RtlAllocateHeap(Peb->ProcessHeap, HEAP_ZERO_MEMORY, ResultSize);

            if (!AppCompatGoo) {
                return;
            }

            //
            // Now that we've got the memory, hit it again
            //
            st = LdrQueryImageFileExecutionOptions( UnicodeImageName,
                                                    L"ApplicationGoo",
                                                    REG_BINARY,
                                                    AppCompatGoo,
                                                    ResultSize,
                                                    &ResultSize
                                                  );

            if (!NT_SUCCESS( st )) {
                RtlFreeHeap(Peb->ProcessHeap, 0, AppCompatGoo);
                return;
            }

            //
            // Got a hit on this key, however we don't know fer sure that its
            // an exact match.  There could be multiple App Compat entries
            // within this Goo.  So we get the version resource information out
            // of the Image hdr (if avail) and later we compare it against all of
            // the entries found within the Goo hoping for a match.
            //
            // Need Language Id in order to query the resource info
            //
            bImageContainsVersionResourceInfo = FALSE;
    //        NtQueryDefaultUILanguage(&LangId);
            IdPath[0] = 16;                             // RT_VERSION
            IdPath[1] = 1;                              // VS_VERSION_INFO
            IdPath[2] = 0; // LangId;

            //
            // Search for version resource information
            //
            try {
                st = LdrpSearchResourceSection_U(
                        Peb->ImageBaseAddress,
                        IdPath,
                        3,
                        0,
                        &DataEntry
                        );

            } except(LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
                st = STATUS_UNSUCCESSFUL;
            }

            if (NT_SUCCESS( st )) {

                //
                // Give us a pointer to the resource information
                //
                try {
                    st = LdrpAccessResourceData(
                            Peb->ImageBaseAddress,
                            DataEntry,
                            &Resource,
                            &ResourceSize
                            );

                } except(LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
                    st = STATUS_UNSUCCESSFUL;
                }

                if (NT_SUCCESS( st )) {
                    bImageContainsVersionResourceInfo = TRUE;
                }

            }

            //
            // Now that we either have (or have not) the version resource info,
            // bounce down each app compat entry looking for a match.  If there
            // wasn't any version resource info in the image hdr, its going to be
            // an automatic match to an entry that also doesn't have anything for
            // its version resource info.  Obviously there can be only one of these
            // "empty" entries within the Goo (as the first one will always be
            // matched first.
            //
            st = STATUS_SUCCESS;
            AppCompatEntry = AppCompatGoo->AppCompatEntry;
            TotalGooLength =
                AppCompatGoo->dwTotalGooSize - sizeof(AppCompatGoo->dwTotalGooSize);
            while (TotalGooLength) {

                try {

                    //
                    // Compare what we're told to by the resource info size.  The
                    // ResourceInfo (if avail) is directly behind the AppCompatEntry
                    //
                    InputCompareLength = AppCompatEntry->dwResourceInfoSize;
                    ResourceInfo = AppCompatEntry + 1;
                    if (bImageContainsVersionResourceInfo) {

                        if (InputCompareLength > Resource->TotalSize) {
                            InputCompareLength = Resource->TotalSize;
                        }

                        OutputCompareLength = \
                            (ULONG)RtlCompareMemory(
                                ResourceInfo,
                                Resource,
                                InputCompareLength
                                );

                    }

                    //
                    // In this case, we don't have any version resource info in
                    // the image header, so set OutputCompareLength to zero.
                    // If InputCompareLength was set to zero (above) due to the
                    // AppCompatEntry also having no version resource info, then
                    // the test will succeed (below) and we've found our match.
                    // Otherwise, this is not the same app and it won't be a match.
                    //
                    else {
                        OutputCompareLength = 0;
                    }

                } except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
                    st = STATUS_UNSUCCESSFUL;
                }

                if ((!NT_SUCCESS( st )) ||
                    (InputCompareLength != OutputCompareLength)) {

                    //
                    // Wasn't a match for some reason or another, goto next entry
                    //
                    TotalGooLength -= AppCompatEntry->dwEntryTotalSize;
                    (PUCHAR) AppCompatEntry += AppCompatEntry->dwEntryTotalSize;
                    continue;
                }

                //
                // We're a match!!!  Now we have to create the final "Post"
                // app compat structure that will be used by everyone to follow.
                // This guy hangs off the Peb and it doesn't have the resource
                // info still lying around in there.
                //
                AppCompatLength = AppCompatEntry->dwEntryTotalSize;
                AppCompatLength -= AppCompatEntry->dwResourceInfoSize;
                Peb->AppCompatInfo = \
                    RtlAllocateHeap(Peb->ProcessHeap, HEAP_ZERO_MEMORY, AppCompatLength);

                if (!Peb->AppCompatInfo) {
                    break;
                }

                AppCompatInfo = Peb->AppCompatInfo;
                AppCompatInfo->dwTotalSize = AppCompatLength;

                //
                // Copy what was beyond the resource info to near the top starting at
                // the Application compat flags.
                //
                RtlMoveMemory(
                    &AppCompatInfo->CompatibilityFlags,
                    (PUCHAR) ResourceInfo + AppCompatEntry->dwResourceInfoSize,
                    AppCompatInfo->dwTotalSize - FIELD_OFFSET(APP_COMPAT_INFO, CompatibilityFlags)
                    );

                //
                // Copy the flags into the PEB. Temporary until we remove the compat goo altogether.
                //
                Peb->AppCompatFlags.QuadPart = AppCompatInfo->CompatibilityFlags.QuadPart;

                //
                // Now that we've created the "Post" app compat info struct to be
                // used by everyone, we need to check if version lying for this
                // app is requested.  If so, we need to stuff the Peb right now.
                //
                if (AppCompatInfo->CompatibilityFlags.QuadPart & KACF_VERSIONLIE) {

                    //
                    // Find the variable version lie struct somwhere within
                    //
                    if( STATUS_SUCCESS != LdrFindAppCompatVariableInfo(AVT_OSVERSIONINFO, &AppVariableInfo)) {
                        break;
                    }

                    //
                    // The variable length information itself comes at the end
                    // of the normal struct and could be of any aribitrary length
                    //
                    AppVariableInfo++;
                    OSVerInfo = (PEFFICIENTOSVERSIONINFOEXW) AppVariableInfo;
                    Peb->OSMajorVersion = OSVerInfo->dwMajorVersion;
                    Peb->OSMinorVersion = OSVerInfo->dwMinorVersion;
                    Peb->OSBuildNumber = (USHORT) OSVerInfo->dwBuildNumber;
                    Peb->OSCSDVersion = (OSVerInfo->wServicePackMajor << 8) & 0xFF00;
                    Peb->OSCSDVersion |= OSVerInfo->wServicePackMinor;
                    Peb->OSPlatformId = OSVerInfo->dwPlatformId;

                    Peb->CSDVersion.Length = (USHORT)wcslen(&OSVerInfo->szCSDVersion[0])*sizeof(WCHAR);
                    Peb->CSDVersion.MaximumLength = Peb->CSDVersion.Length + sizeof(WCHAR);
                    Peb->CSDVersion.Buffer =
                        RtlAllocateHeap(
                            Peb->ProcessHeap,
                            HEAP_ZERO_MEMORY,
                            Peb->CSDVersion.MaximumLength
                            );

                    if (!Peb->CSDVersion.Buffer) {
                        break;
                    }
                    wcscpy(Peb->CSDVersion.Buffer, &OSVerInfo->szCSDVersion[0]);
                    fNewCSDVersionBuffer = TRUE;
                }

                break;

            }

            RtlFreeHeap(Peb->ProcessHeap, 0, AppCompatGoo);
        }
    }

    //
    // Only look at the ENV stuff if haven't already gotten new version info from the registry
    //
    if ( FALSE == fNewCSDVersionBuffer )
    {
        //
        // The format of this string is:
        // _COMPAT_VER_NNN = MajOSVer, MinOSVer, OSBldNum, MajCSD, MinCSD, PlatformID, CSDString
        //  eg:  _COMPAT_VER_NNN=4,0,1381,3,0,2,Service Pack 3
        //   (for NT 4 SP3)

        RtlInitUnicodeString(&EnvName, L"_COMPAT_VER_NNN");

        EnvValue.Buffer = TempString;
        EnvValue.Length = 0;
        EnvValue.MaximumLength = sizeof(TempString);


        st = RtlQueryEnvironmentVariable_U(
            NULL,
            &EnvName,
            &EnvValue
            );

        //
        // One of the possible error codes is BUFFER_TOO_SMALL - this indicates a
        // string that's wacko - they should not be larger than the size we define/expect
        // In this case, we'll ignore that string
        //
        if ( STATUS_SUCCESS == st )
        {
            WCHAR *p = EnvValue.Buffer;
            WCHAR *NewSPString;
            ULONG len = EnvValue.Length / sizeof(WCHAR);  // (Length is bytes, not chars)

            //
            // Ok, someone wants different version info.
            //
            Peb->OSMajorVersion = GetNextCommaValue( &p, &len );
            Peb->OSMinorVersion = GetNextCommaValue( &p, &len );
            Peb->OSBuildNumber = (USHORT)GetNextCommaValue( &p, &len );
            Peb->OSCSDVersion = (USHORT)(GetNextCommaValue( &p, &len )) << 8;
            Peb->OSCSDVersion |= (USHORT)GetNextCommaValue( &p, &len );
            Peb->OSPlatformId = GetNextCommaValue( &p, &len );


            //
            // Need to free the old buffer if there is one...
            //
            if ( fNewCSDVersionBuffer )
            {
                RtlFreeHeap( Peb->ProcessHeap, 0, Peb->CSDVersion.Buffer );
                Peb->CSDVersion.Buffer = NULL;
            }

            if ( len )
            {
                NewCSDString =
                        RtlAllocateHeap(
                            Peb->ProcessHeap,
                            HEAP_ZERO_MEMORY,
                            ( len + 1 ) * sizeof(WCHAR)
                            );

                if ( NULL == NewCSDString )
                {
                    return;
                }

                //
                // Now copy the string to memory that we'll keep
                //
                // We do a movemem here rather than a string copy because current comments in
                // RtlQueryEnvironmentVariable() indicate that in an edge case, we might not
                // have a trailing NULL - berniem 7/7/1999
                //
                RtlMoveMemory( NewCSDString, p, len * sizeof(WCHAR) );

            }
            else
            {
                NewCSDString = NULL;
            }

            RtlInitUnicodeString( &(Peb->CSDVersion), NewCSDString );

        }
    }

    return;
}


NTSTATUS
LdrFindAppCompatVariableInfo(
    IN  ULONG dwTypeSeeking,
    OUT PAPP_VARIABLE_INFO *AppVariableInfo
    )

/*++

Routine Description:

    This function is used to find a variable length struct by its type.
    The caller specifies what type its looking for and this function chews
    thru all the variable length structs to find it.  If it does it returns
    the pointer and TRUE, else FALSE.

Arguments:

    dwTypeSeeking - AVT that you are looking for

    AppVariableInfo - pointer to pointer of variable info to be returned

Return Value:

    TRUE or FALSE if entry is found

--*/

{
    PPEB Peb;
    ULONG TotalSize;
    ULONG CurOffset;
    PAPP_VARIABLE_INFO pCurrentEntry;

    Peb = NtCurrentPeb();
    if (Peb->AppCompatInfo) {

        //
        // Since we're not dealing with a fixed-size structure, TotalSize
        // will keep us from running off the end of the data list
        //
        TotalSize = ((PAPP_COMPAT_INFO) Peb->AppCompatInfo)->dwTotalSize;

        //
        // The first variable structure (if there is one) will start
        // immediately after the fixed stuff
        //
        CurOffset = sizeof(APP_COMPAT_INFO);

        while (CurOffset < TotalSize) {

            pCurrentEntry = (PAPP_VARIABLE_INFO) ((PUCHAR)(Peb->AppCompatInfo) + CurOffset);

            //
            // Have we found what we're looking for?
            //
            if (dwTypeSeeking == pCurrentEntry->dwVariableType) {
                *AppVariableInfo = pCurrentEntry;
                return (STATUS_SUCCESS);
            }

            //
            // Let's go look at the next blob
            //
            CurOffset += (ULONG)(pCurrentEntry->dwVariableInfoSize);
        }

    }

    return (STATUS_NOT_FOUND);
}


NTSTATUS
LdrpCorValidateImage(
    IN OUT PVOID *pImageBase,
    IN LPWSTR ImageName
    )
{
    NTSTATUS st;
    UNICODE_STRING SystemRoot;
    UNICODE_STRING MscoreePath;
    WCHAR PathBuffer [ 128 ];

    //
    // Load %windir%\system32\mscoree.dll and hold onto it until all COM+ images are unloaded.
    //

    MscoreePath.Buffer = PathBuffer;
    MscoreePath.Length = 0;
    MscoreePath.MaximumLength = sizeof (PathBuffer);

    RtlInitUnicodeString (&SystemRoot, USER_SHARED_DATA->NtSystemRoot);

    st = RtlAppendUnicodeStringToString (&MscoreePath, &SystemRoot);
    if (NT_SUCCESS (st)) {
        st = RtlAppendUnicodeStringToString (&MscoreePath, &SlashSystem32SlashMscoreeDllString);

        if (NT_SUCCESS (st)) {
            st = LdrLoadDll (NULL, NULL, &MscoreePath, &Cor20DllHandle);
        }
    }

    if (!NT_SUCCESS (st)) {
        if (ShowSnaps) {
            DbgPrint("LDR: failed to load mscoree.dll, status=%x\n", st);
        }
        return st;
    }

    if (CorImageCount == 0) {
        //
        // Load mscoree.dll and hold onto it until all COM+ images are unloaded.
        //
        CONST static ANSI_STRING CorValidateImageFuncName = RTL_CONSTANT_STRING("_CorValidateImage");
        CONST static ANSI_STRING CorImageUnloadingFuncName = RTL_CONSTANT_STRING("_CorImageUnloading");
        CONST static ANSI_STRING CorExeMainFuncName = RTL_CONSTANT_STRING("_CorExeMain");

        st = LdrGetProcedureAddress(Cor20DllHandle, &CorValidateImageFuncName, 0, (PVOID *)&CorValidateImage);
        if (!NT_SUCCESS(st)) {
            LdrUnloadDll(Cor20DllHandle);
            return st;
        }
        st = LdrGetProcedureAddress(Cor20DllHandle, &CorImageUnloadingFuncName, 0, (PVOID *)&CorImageUnloading);
        if (!NT_SUCCESS(st)) {
            LdrUnloadDll(Cor20DllHandle);
            return st;
        }
        st = LdrGetProcedureAddress(Cor20DllHandle, &CorExeMainFuncName, 0, (PVOID *)&CorExeMain);
        if (!NT_SUCCESS(st)) {
            LdrUnloadDll(Cor20DllHandle);
            return st;
        }
    }

    //
    // Call mscoree to validate the image
    //
    st = (*CorValidateImage)(pImageBase, ImageName);

    if (NT_SUCCESS(st)) {
        //
        // Success - bump the count of valid COM+ images
        //
        CorImageCount++;
    } else if (CorImageCount == 0) {
        //
        // Failure, and no other COM+ images are loaded, so unload mscoree.
        //
        LdrUnloadDll(Cor20DllHandle);
    }
    return st;
}

VOID
LdrpCorUnloadImage(
    IN PVOID ImageBase
    )
{
    //
    // Notify mscoree that the image is about be unmapped
    //
    (*CorImageUnloading)(ImageBase);

    if (--CorImageCount) {
        // The count of loaded COM+ images is zero, so unload mscoree
        LdrUnloadDll(Cor20DllHandle);
    }
}


VOID
LdrpInitializeApplicationVerifierPackage (
    PUNICODE_STRING UnicodeImageName,
    PPEB Peb,
    BOOLEAN EnabledSystemWide,
    BOOLEAN OptionsKeyPresent
    )
{
    ULONG SavedPageHeapFlags;

    //
    // If we are in safe boot mode we ignore all verification
    // options.
    //

    if (USER_SHARED_DATA->SafeBootMode) {

        Peb->NtGlobalFlag &= ~FLG_APPLICATION_VERIFIER;
        Peb->NtGlobalFlag &= ~FLG_HEAP_PAGE_ALLOCS;

        return;
    }

    //
    // Call into the verifier proper.
    //
    // SilviuC: in time (soon) all should migrate in there.
    //

    if ((Peb->NtGlobalFlag & FLG_APPLICATION_VERIFIER)) {

        AVrfInitializeVerifier (EnabledSystemWide,
                                UnicodeImageName,
                                0);
    }

    //
    // Note that if application verifier was on this enabled also
    // page heap.
    //

    if ((Peb->NtGlobalFlag & FLG_HEAP_PAGE_ALLOCS)) {

        //
        // We will enable page heap (RtlpDebugPageHeap) only after
        // all other initializations for page heap are finished.
        //
        // No matter if the user mode stack trace database flag is set
        // or not we will create the database. Page heap is so often
        // used with +ust flag (traces) that it makes sense to tie
        // them together.
        //

        LdrpShouldCreateStackTraceDb = TRUE;

        //
        // If page heap is enabled we need to disable any flag that
        // might force creation of debug heaps for normal NT heaps.
        // This is due to a dependency between page heap and NT heap
        // where the page heap within PageHeapCreate tries to create
        // a normal NT heap to accomodate some of the allocations.
        // If we do not disable these flags we will get an infinite
        // recursion between RtlpDebugPageHeapCreate and RtlCreateHeap.
        //

        Peb->NtGlobalFlag &=
            ~( FLG_HEAP_ENABLE_TAGGING      |
               FLG_HEAP_ENABLE_TAG_BY_DLL   |
               FLG_HEAP_ENABLE_TAIL_CHECK   |
               FLG_HEAP_ENABLE_FREE_CHECK   |
               FLG_HEAP_VALIDATE_PARAMETERS |
               FLG_HEAP_VALIDATE_ALL        |
               FLG_USER_STACK_TRACE_DB      );

        //
        // Read page heap per process global flags. If we fail
        // to read a value, the default ones are kept.
        //

        SavedPageHeapFlags = RtlpDphGlobalFlags;
        RtlpDphGlobalFlags = 0xFFFFFFFF;

        if (OptionsKeyPresent) {

            LdrQueryImageFileExecutionOptions(UnicodeImageName,
                                              L"PageHeapFlags",
                                              REG_DWORD,
                                              &RtlpDphGlobalFlags,
                                              sizeof(RtlpDphGlobalFlags),
                                              NULL);
        }

        //
        // If app_verifier flag is on and there are no special settings for
        // page heap then we will use full page heap with stack trace collection.
        //

        if ((Peb->NtGlobalFlag & FLG_APPLICATION_VERIFIER)) {

            if (RtlpDphGlobalFlags == 0xFFFFFFFF) {

                //
                // We did not pick up new settings from registry.
                //

                RtlpDphGlobalFlags = SavedPageHeapFlags;
            }
        }
        else {

            //
            // Restore page heap options if we did not pick up new
            // settings from registry.
            //

            if (RtlpDphGlobalFlags == 0xFFFFFFFF) {

                RtlpDphGlobalFlags = SavedPageHeapFlags;
            }
        }

        //
        // If page heap is enabled and we have an image options key
        // read more page heap paramters.
        //

        if (OptionsKeyPresent) {

            LdrQueryImageFileExecutionOptions(
                UnicodeImageName,
                L"PageHeapSizeRangeStart",
                REG_DWORD,
                &RtlpDphSizeRangeStart,
                sizeof(RtlpDphSizeRangeStart),
                NULL
                );

            LdrQueryImageFileExecutionOptions(
                UnicodeImageName,
                L"PageHeapSizeRangeEnd",
                REG_DWORD,
                &RtlpDphSizeRangeEnd,
                sizeof(RtlpDphSizeRangeEnd),
                NULL
                );

            LdrQueryImageFileExecutionOptions(
                UnicodeImageName,
                L"PageHeapRandomProbability",
                REG_DWORD,
                &RtlpDphRandomProbability,
                sizeof(RtlpDphRandomProbability),
                NULL
                );

            LdrQueryImageFileExecutionOptions(
                UnicodeImageName,
                L"PageHeapFaultProbability",
                REG_DWORD,
                &RtlpDphFaultProbability,
                sizeof(RtlpDphFaultProbability),
                NULL
                );

            LdrQueryImageFileExecutionOptions(
                UnicodeImageName,
                L"PageHeapFaultTimeOut",
                REG_DWORD,
                &RtlpDphFaultTimeOut,
                sizeof(RtlpDphFaultTimeOut),
                NULL
                );

            //
            // The two values below should be read as PVOIDs so that
            // this works on 64-bit architetures. However since this
            // feature relies on good stack traces and since we can get
            // reliable stack traces only on X86 architectures we will
            // leave it as it is.
            //

            LdrQueryImageFileExecutionOptions(
                UnicodeImageName,
                L"PageHeapDllRangeStart",
                REG_DWORD,
                &RtlpDphDllRangeStart,
                sizeof(RtlpDphDllRangeStart),
                NULL
                );

            LdrQueryImageFileExecutionOptions(
                UnicodeImageName,
                L"PageHeapDllRangeEnd",
                REG_DWORD,
                &RtlpDphDllRangeEnd,
                sizeof(RtlpDphDllRangeEnd),
                NULL
                );

            LdrQueryImageFileExecutionOptions(
                UnicodeImageName,
                L"PageHeapTargetDlls",
                REG_SZ,
                &RtlpDphTargetDlls,
                512,
                NULL
                );

        }

        //
        //  Turn on BOOLEAN RtlpDebugPageHeap to indicate that
        //  new heaps should be created with debug page heap manager
        //  when possible.
        //

        RtlpDebugPageHeap = TRUE;
    }
}


NTSTATUS
LdrpTouchThreadStack (
    SIZE_T EnforcedStackCommit
    )
/*++

Routine description:

    This routine is called if precommitted stacks are enforced for the process.
    It will determine how much stack needs to be touched (therefore committed)
    and then it will touch it. For any kind of error (e.g. stack overflow for
    out of memory conditions it will return STATUS_NO_MEMORY.

Parameters:

    EnforcedStackCommit - the amount of committed stack that should be enforced
        for the main thread. This value can be decreased in reality if it goes
        over the virtual region reserved for the stack. It is not worth
        taking care of this special case because it will require either switching
        the stack or support in the target process for detecting the enforced
        stack commit requirement. The image can always be changed to have a bigger
        stack reserve.

Return value:

    STATUS_SUCCESS if the stack was successfully touched and STATUS_NO_MEMORY
    otherwise.

--*/
{
    ULONG_PTR TouchAddress;
    ULONG_PTR TouchLimit;
    ULONG_PTR LowStackLimit;
    ULONG_PTR HighStackLimit;
    NTSTATUS Status;
    MEMORY_BASIC_INFORMATION MemoryInformation;
    SIZE_T ReturnLength;

    try {

        Status = NtQueryVirtualMemory (NtCurrentProcess(),
                                       NtCurrentTeb()->NtTib.StackLimit,
                                       MemoryBasicInformation,
                                       &MemoryInformation,
                                       sizeof MemoryInformation,
                                       &ReturnLength);

        if (! NT_SUCCESS(Status)) {
            return Status;
        }

        LowStackLimit = (ULONG_PTR)(MemoryInformation.AllocationBase);
        LowStackLimit += 3 * PAGE_SIZE;

        HighStackLimit = (ULONG_PTR)(NtCurrentTeb()->NtTib.StackBase);
        TouchAddress =  HighStackLimit - PAGE_SIZE;

        if (TouchAddress > EnforcedStackCommit) {

            if (TouchAddress - EnforcedStackCommit > LowStackLimit) {
                TouchLimit = TouchAddress - EnforcedStackCommit;
            }
            else {
                TouchLimit = LowStackLimit;
            }
        }
        else {

            TouchLimit = LowStackLimit;
        }

        while (TouchAddress >= TouchLimit) {

            *((volatile UCHAR * const) TouchAddress);
            TouchAddress -= PAGE_SIZE;
        }
    }
    except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {

        //
        // If we get a stack overflow we will report it as no memory.
        //

        return STATUS_NO_MEMORY;
    }

    return STATUS_SUCCESS;
}


BOOLEAN
LdrpInitializeExecutionOptions (
    PUNICODE_STRING UnicodeImageName,
    PPEB Peb
    )
/*++

Routine description:

    This routine reads the `image file execution options' key for the
    current process and interprets all the values under the key.

Parameters:



Return value:

    True if there is a registry key for this process.

--*/
{
    NTSTATUS st;
    BOOLEAN ImageFileOptionsPresent = FALSE;
    HANDLE KeyHandle;

    //
    // Open the "Image File Execution Options" key for this program.
    //

    st = LdrpOpenImageFileOptionsKey( UnicodeImageName,
                                      &KeyHandle );

    if (NT_SUCCESS(st)) {

        //
        // We have image file execution options for this process
        //

        ImageFileOptionsPresent = TRUE;

        //
        //  Hack for NT4 SP4.  So we don't overload another GlobalFlag
        //  bit that we have to be "compatible" with for NT5, look for
        //  another value named "DisableHeapLookaside".
        //

        LdrpQueryImageFileKeyOption( KeyHandle,
                                     L"DisableHeapLookaside",
                                     REG_DWORD,
                                     &RtlpDisableHeapLookaside,
                                     sizeof( RtlpDisableHeapLookaside ),
                                     NULL
                                   );

        //
        // Verification options during process shutdown (heap leaks, etc.).
        //

        LdrpQueryImageFileKeyOption( KeyHandle,
                                     L"ShutdownFlags",
                                     REG_DWORD,
                                     &RtlpShutdownProcessFlags,
                                     sizeof( RtlpShutdownProcessFlags ),
                                     NULL
                                   );

        //
        // Check if there is a minimal stack commit enforced
        // for this image. This will affect all threads but the
        // one executing this code (initial thread).
        //

        {
            DWORD MinimumStackCommitInBytes = 0;

            LdrpQueryImageFileKeyOption( KeyHandle,
                                         L"MinimumStackCommitInBytes",
                                         REG_DWORD,
                                         &MinimumStackCommitInBytes,
                                         sizeof( MinimumStackCommitInBytes ),
                                         NULL
                                       );

            if (Peb->MinimumStackCommit < (SIZE_T)MinimumStackCommitInBytes) {
                Peb->MinimumStackCommit = (SIZE_T)MinimumStackCommitInBytes;
            }
        }

        //
        // Check if ExecuteOptions is specified for this image. If yes
        // we will transfer the options into the PEB. Later we will
        // make sure the stack region has exactly the protection
        // requested.
        //

        {
            ULONG ExecuteOptions;

            LdrpQueryImageFileKeyOption (KeyHandle,
                                         L"ExecuteOptions",
                                         REG_DWORD,
                                         &(ExecuteOptions),
                                         sizeof (ExecuteOptions),
                                         NULL);

            Peb->ExecuteOptions = ExecuteOptions & (MEM_EXECUTE_OPTION_STACK | MEM_EXECUTE_OPTION_DATA);
        }

        //
        // Pickup the global_flags value from registry
        //

        {
            BOOLEAN EnabledSystemWide = FALSE;
            ULONG ProcessFlags;

            if ((Peb->NtGlobalFlag & FLG_APPLICATION_VERIFIER)) {
                EnabledSystemWide = TRUE;
            }

            st = LdrpQueryImageFileKeyOption (KeyHandle,
                                              L"GlobalFlag",
                                              REG_DWORD,
                                              &ProcessFlags,
                                              sizeof( Peb->NtGlobalFlag ),
                                              NULL);

            //
            // If we read a global value whatever is in there will
            // take precedence over the systemwide settings. Only if no
            // value is read the systemwide setting will kick in.
            //

            if (NT_SUCCESS(st)) {
                Peb->NtGlobalFlag = ProcessFlags;
            }

            //
            // If pageheap or appverifier is enabled we need to initialize the
            // verifier package.
            //

            if ((Peb->NtGlobalFlag & (FLG_APPLICATION_VERIFIER | FLG_HEAP_PAGE_ALLOCS))) {

                LdrpInitializeApplicationVerifierPackage (UnicodeImageName,
                                                          Peb,
                                                          EnabledSystemWide,
                                                          TRUE);
            }
        }

        NtClose(KeyHandle);
    }
    else {

        //
        // We do not have image file execution options for this process
        //
        // If pageheap or appverifier is enabled system-wide we will enable
        // them with default settings and ignore the options used when
        // running process under debugger. If these are not set and process
        // runs under debugger we will enable a few extra things (e.g. debug heap).
        //

        if ((Peb->NtGlobalFlag & (FLG_APPLICATION_VERIFIER | FLG_HEAP_PAGE_ALLOCS))) {

            LdrpInitializeApplicationVerifierPackage (UnicodeImageName,
                                                      Peb,
                                                      TRUE,
                                                      FALSE);
        }
        else {

            if (Peb->BeingDebugged) {

                UNICODE_STRING DebugVarName, DebugVarValue;
                WCHAR TempString[ 16 ];
                BOOLEAN UseDebugHeap = TRUE;

                RtlInitUnicodeString(&DebugVarName, L"_NO_DEBUG_HEAP");

                DebugVarValue.Buffer = TempString;
                DebugVarValue.Length = 0;
                DebugVarValue.MaximumLength = sizeof(TempString);

                //
                //  The PebLockRoutine is not initialized at this point
                //  We need to pass the explicit environment block.
                //

                st = RtlQueryEnvironmentVariable_U(
                                                  Peb->ProcessParameters->Environment,
                                                  &DebugVarName,
                                                  &DebugVarValue
                                                  );

                if (NT_SUCCESS(st)) {

                    ULONG ULongValue;

                    st = RtlUnicodeStringToInteger( &DebugVarValue, 0, &ULongValue );

                    if (NT_SUCCESS(st) && ULongValue) {

                        UseDebugHeap = FALSE;
                    }
                }

                if (UseDebugHeap) {

                    Peb->NtGlobalFlag |= FLG_HEAP_ENABLE_FREE_CHECK |
                                         FLG_HEAP_ENABLE_TAIL_CHECK |
                                         FLG_HEAP_VALIDATE_PARAMETERS;
                }
            }
        }
    }

    return ImageFileOptionsPresent;
}


NTSTATUS
LdrpEnforceExecuteForCurrentThreadStack (
    )
/*++

Routine description:

    This routine is called if execute rights must be granted for the
    current thread's stack. It will determine the committed area of the
    stack and add execute flag. It will also examine the rights for the
    guard page on top of the stack. The reserved portion of the stack does
    not need to be changed because once MEM_EXECUTE_OPTION_STACK is enabled
    in the PEB the memory manager will take care of OR-ing the execute flag
    for every new commit.

    The function is also called if we have DATA execution but we do not want
    STACK execution. In this case  by default (due to DATA) any committed
    area gets execute right and we want to revert this for stack areas.

    Note. Even if the process has data execution set the stack might not have
    the correct settings because the stack sometimes is allocated in a different
    process (this is the case for the first thread of a process and for remote
    threads).

Parameters:

    None.

Return value:

    STATUS_SUCCESS if we successfully changed execute rights.

--*/
{
    MEMORY_BASIC_INFORMATION MemoryInformation;
    NTSTATUS Status;
    SIZE_T Length;
    ULONG_PTR Address;
    SIZE_T Size;
    ULONG StackProtect;
    ULONG OldProtect;
    ULONG ExecuteOptions;
    PTEB Teb;

    ExecuteOptions = NtCurrentPeb()->ExecuteOptions;
    ExecuteOptions &= (MEM_EXECUTE_OPTION_STACK | MEM_EXECUTE_OPTION_DATA);
    ASSERT (ExecuteOptions != 0);

    if (ExecuteOptions & MEM_EXECUTE_OPTION_STACK) {

        //
        // Data = X and Stack = 1: we need to set EXECUTE bit on the stack
        // Even if Data = 1 we cannot be sure the stack has the right
        // protection because it could have been allocated in a different
        // process.
        //

        StackProtect = PAGE_EXECUTE_READWRITE;
    }
    else {

        //
        // Data = 1 and Stack = 0: we need to reset EXECUTE bit on the stack.
        // Again it might be that Data is one but the stack does not have
        // execution rights if this was a cross-process allocation.
        //

        StackProtect = PAGE_READWRITE;
        ASSERT ((ExecuteOptions & MEM_EXECUTE_OPTION_DATA) != 0);
    }

    Teb = NtCurrentTeb();

    //
    // Set the protection for the committed portion of the stack. Note
    // that we cannot query the region and conclude there is nothing to do
    // if execute bit is set for the bottom page of the stack (the one near
    // the guard page) because the stack at this stage can have two regions:
    // an upper one created by a parent process (this will not have execute bit
    // set) and a lower portion that was created due to stack extensions (this
    // one will have execute bit set). Therefore we will move directly to setting
    // the new desired protection.
    //

    Address = (ULONG_PTR)(Teb->NtTib.StackLimit);
    Size = (ULONG_PTR)(Teb->NtTib.StackBase) - (ULONG_PTR)(Teb->NtTib.StackLimit);

    Status = NtProtectVirtualMemory (NtCurrentProcess(),
                                     (PVOID)&Address,
                                     &Size,
                                     StackProtect,
                                     &OldProtect);

    if (! NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Check protection for the guard page of the stack. If the
    // protection is correct we will avoid a more expensive protect()
    // call.
    //

    Address = Address - PAGE_SIZE;

    Status = NtQueryVirtualMemory (NtCurrentProcess(),
                                   (PVOID)Address,
                                   MemoryBasicInformation,
                                   &MemoryInformation,
                                   sizeof MemoryInformation,
                                   &Length);

    if (! NT_SUCCESS(Status)) {
        return Status;
    }

    ASSERT (MemoryInformation.AllocationBase == Teb->DeallocationStack);
    ASSERT (MemoryInformation.BaseAddress == (PVOID)Address);
    ASSERT ((MemoryInformation.Protect & PAGE_GUARD) != 0);

    if (MemoryInformation.Protect != (StackProtect | PAGE_GUARD)) {

        //
        // Set the proper protection flags for the guard page of the stack.
        //

        Size = PAGE_SIZE;
        ASSERT (MemoryInformation.RegionSize == Size);

        Status = NtProtectVirtualMemory (NtCurrentProcess(),
                                         (PVOID)&Address,
                                         &Size,
                                         StackProtect | PAGE_GUARD,
                                         &OldProtect);

        if (! NT_SUCCESS(Status)) {
            return Status;
        }

        ASSERT (OldProtect == MemoryInformation.Protect);
    }

    return STATUS_SUCCESS;
}

#include <ntverp.h>
ULONG NtMajorVersion = VER_PRODUCTMAJORVERSION;
ULONG NtMinorVersion = VER_PRODUCTMINORVERSION;
#if DBG
ULONG NtBuildNumber = VER_PRODUCTBUILD | 0xC0000000;
#else
ULONG NtBuildNumber = VER_PRODUCTBUILD | 0xF0000000;
#endif

VOID
RtlGetNtVersionNumbers(
    ULONG *pNtMajorVersion,
    ULONG *pNtMinorVersion,
    ULONG *pNtBuildNumber
    )
/*++

Routine description:

    This routine will return the real OS build number, major and minor version
    as compiled.  It's used by code that needs to get a real version number
    that can't be easily spoofed.

Parameters:

    pNtMajorVersion - Pointer to ULONG that will hold major version.
    pNtMinorVersion - Pointer to ULONG that will hold minor version.
    pNtBuildNumber  - Pointer to ULONG that will hold the build number (with 'C' or 'F' in high nibble to indicate free/checked)

Return value:

    None

--*/
{
    if (pNtMajorVersion)
        *pNtMajorVersion = NtMajorVersion;
    if (pNtMinorVersion)
        *pNtMinorVersion = NtMinorVersion;
    if (pNtBuildNumber)
        *pNtBuildNumber  = NtBuildNumber;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\ldrsnap.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ldrsnap.c

Abstract:

    This module implements the guts of the Ldr Dll Snap Routine.
    This code is executed only in user mode; the kernel mode
    loader is implemented as part of the memory manager kernel
    component.

Author:

    Mike O'Leary (mikeol) 23-Mar-1990

Revision History:

    Michael Grier (mgrier) 5/4/2000

        Isolate static (import) library loads when activation contexts
        are used to redirect so that a dynamically loaded library
        does not bind to whatever component dll may already be
        loaded for the process.  When redirection is in effect,
        the full path names of the loads must match, not just the
        base names of the dlls.

        Also clean up path allocation policy so that we should be
        clean for 64k paths in the loader.

--*/

#define LDRDBG 0

#include "ntos.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <heap.h>
#include <winsnmp.h>
#include <winsafer.h>
#include "ldrp.h"
#include <sxstypes.h>
#include <ntrtlpath.h>

#define DLL_EXTENSION L".DLL"
#define DLL_REDIRECTION_LOCAL_SUFFIX L".Local"
UNICODE_STRING DefaultExtension = RTL_CONSTANT_STRING(L".DLL");
UNICODE_STRING User32String = RTL_CONSTANT_STRING(L"user32.dll");
UNICODE_STRING Kernel32String = RTL_CONSTANT_STRING(L"kernel32.dll");

#if DBG // DBG
PUCHAR MonthOfYear[] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun",
                         "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
PUCHAR DaysOfWeek[] =  { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
LARGE_INTEGER MapBeginTime, MapEndTime, MapElapsedTime;
#endif // DBG

PCUNICODE_STRING LdrpTopLevelDllBeingLoaded;
BOOLEAN LdrpShowInitRoutines = FALSE;

#if defined (_ALPHA_)
VOID
AlphaFindArchitectureFixups(
    PIMAGE_NT_HEADERS NtHeaders,
    PVOID ViewBase,
    BOOLEAN StaticLink
    );
#endif

#if defined(_WIN64)
extern ULONG UseWOW64;
#endif


#if defined (_X86_)
extern PVOID LdrpLockPrefixTable;

//
// Specify address of kernel32 lock prefixes
//
IMAGE_LOAD_CONFIG_DIRECTORY _load_config_used = {
    0,                             // Reserved
    0,                             // Reserved
    0,                             // Reserved
    0,                             // Reserved
    0,                             // GlobalFlagsClear
    0,                             // GlobalFlagsSet
    0,                             // CriticalSectionTimeout (milliseconds)
    0,                             // DeCommitFreeBlockThreshold
    0,                             // DeCommitTotalFreeThreshold
    (ULONG_PTR) &LdrpLockPrefixTable,  // LockPrefixTable
    0, 0, 0, 0, 0, 0, 0            // Reserved
};

void
LdrpValidateImageForMp(
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    )
{
    PIMAGE_LOAD_CONFIG_DIRECTORY ImageConfigData;
    ULONG i;
    PUCHAR *pb;
    ULONG ErrorParameters;
    ULONG ErrorResponse;

    //
    // If we are on an MP system and the DLL has image config info, check to see
    // if it has a lock prefix table and make sure the locks have not been converted
    // to NOPs
    //

    ImageConfigData = RtlImageDirectoryEntryToData( LdrDataTableEntry->DllBase,
                                                    TRUE,
                                                    IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,
                                                    &i
                                                  );

    if (ImageConfigData != NULL &&
        i == sizeof( *ImageConfigData ) &&
        ImageConfigData->LockPrefixTable ) {
            pb = (PUCHAR *)ImageConfigData->LockPrefixTable;
            while ( *pb ) {
                if ( **pb == (UCHAR)0x90 ) {

                    if ( LdrpNumberOfProcessors > 1 ) {

                        //
                        // Hard error time. One of the know DLL's is corrupt !
                        //

                        ErrorParameters = (ULONG)&LdrDataTableEntry->BaseDllName;

                        NtRaiseHardError(
                            STATUS_IMAGE_MP_UP_MISMATCH,
                            1,
                            1,
                            &ErrorParameters,
                            OptionOk,
                            &ErrorResponse
                            );

                        if ( LdrpInLdrInit ) {
                            LdrpFatalHardErrorCount++;
                            }

                        }
                    }
                pb++;
                }
        }
}
#endif

NTSTATUS
LdrpWalkImportDescriptor (
    IN PWSTR DllPath OPTIONAL,
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    );


NTSTATUS
LdrpLoadImportModule(
    IN PWSTR DllPath OPTIONAL,
    IN LPSTR ImportName,
    IN PVOID DllBaseImporter,
    OUT PLDR_DATA_TABLE_ENTRY *DataTableEntry,
    OUT PBOOLEAN AlreadyLoaded
    )
{
    NTSTATUS st;
    ANSI_STRING AnsiString;
    PUNICODE_STRING ImportDescriptorName_U;
    WCHAR StaticRedirectedDllNameBuffer[DOS_MAX_PATH_LENGTH];
    UNICODE_STRING StaticRedirectedDllName;
    UNICODE_STRING DynamicRedirectedDllName;
    BOOLEAN Redirected = FALSE;

    DynamicRedirectedDllName.Buffer = NULL;

    ImportDescriptorName_U = &NtCurrentTeb()->StaticUnicodeString;
    RtlInitAnsiString(&AnsiString, ImportName);
    st = RtlAnsiStringToUnicodeString(ImportDescriptorName_U, &AnsiString, FALSE);
    if (!NT_SUCCESS(st)) {
        goto Exit;
    }

    //
    // If the module name has no '.' in the name then it can't have an extension.
    // Add .dll in this case as 9x does this and some apps rely on it.
    //
    if (strchr (ImportName, '.') == NULL) {
        RtlAppendUnicodeToString (ImportDescriptorName_U, L".dll");
    }

    RtlInitUnicodeString(&DynamicRedirectedDllName, NULL);

    StaticRedirectedDllName.Length = 0;
    StaticRedirectedDllName.MaximumLength = sizeof(StaticRedirectedDllNameBuffer);
    StaticRedirectedDllName.Buffer = StaticRedirectedDllNameBuffer;

    st = RtlDosApplyFileIsolationRedirection_Ustr(
                RTL_DOS_APPLY_FILE_REDIRECTION_USTR_FLAG_RESPECT_DOT_LOCAL,
                ImportDescriptorName_U,
                &DefaultExtension,
                &StaticRedirectedDllName,
                &DynamicRedirectedDllName,
                &ImportDescriptorName_U,
                NULL,
                NULL,
                NULL);
    if (NT_SUCCESS(st)){
        Redirected = TRUE;
    } else if (st != STATUS_SXS_KEY_NOT_FOUND) {
        if (ShowSnaps) {
            DbgPrint("LDR: %s - RtlDosApplyFileIsolationRedirection_Ustr failed with status %x\n", __FUNCTION__, st);
        }

        goto Exit;
    }

    st = STATUS_SUCCESS;

    //
    // Check the LdrTable to see if Dll has already been mapped
    // into this image. If not, map it.
    //

    if (LdrpCheckForLoadedDll( DllPath,
                               ImportDescriptorName_U,
                               TRUE,
                               Redirected,
                               DataTableEntry)) {
        *AlreadyLoaded = TRUE;
    } else {
        *AlreadyLoaded = FALSE;

        st = LdrpMapDll(DllPath,
                        ImportDescriptorName_U->Buffer,
                        NULL,       // MOOCOW
                        TRUE,
                        Redirected,
                        DataTableEntry
                        );

        if (!NT_SUCCESS(st)) {
            if (ShowSnaps) {
                DbgPrint("LDR: %s - LdrpMapDll(%p, %ls, NULL, TRUE, %d, %p) failed with status %x\n", __FUNCTION__, DllPath, ImportDescriptorName_U->Buffer, Redirected, DataTableEntry, st);
            }

            goto Exit;
        }
        
        //
        // Register dll with the stack tracing module.
        // This is used for getting reliable stack traces on X86.
        //

#if defined(_X86_)
        RtlpStkMarkDllRange (*DataTableEntry);
#endif

        st = LdrpWalkImportDescriptor(
                DllPath,
                *DataTableEntry
                );
        if (!NT_SUCCESS(st)) {
            if (ShowSnaps) {
                DbgPrint("LDR: %s - LdrpWalkImportDescriptor [dll %ls]  failed with status %x\n", __FUNCTION__, ImportDescriptorName_U->Buffer, st);
            }
            InsertTailList(&NtCurrentPeb()->Ldr->InInitializationOrderModuleList,
                           &(*DataTableEntry)->InInitializationOrderLinks);
        }
    }

Exit:
    if (DynamicRedirectedDllName.Buffer != NULL)
        RtlFreeUnicodeString(&DynamicRedirectedDllName);

    return st;
}

NTSTATUS
LdrpHandleOneNewFormatImportDescriptor(
    IN PPEB Peb,
    IN PWSTR DllPath OPTIONAL,
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry,
    PIMAGE_BOUND_IMPORT_DESCRIPTOR *NewImportDescriptorInOut,
    PSZ NewImportStringBase
    )
{
    NTSTATUS st = STATUS_INTERNAL_ERROR;

    PIMAGE_BOUND_IMPORT_DESCRIPTOR NewImportDescriptor = *NewImportDescriptorInOut;
    PIMAGE_BOUND_FORWARDER_REF NewImportForwarder;
    PSZ ImportName, NewImportName, NewFwdImportName;
    BOOLEAN AlreadyLoaded = FALSE;
    BOOLEAN StaleBinding = FALSE;
    PLDR_DATA_TABLE_ENTRY DataTableEntry, FwdDataTableEntry;
    ULONG i;
    PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor;
    ULONG ImportSize, NewImportSize;

    NewImportName = NewImportStringBase + NewImportDescriptor->OffsetModuleName;

    if (ShowSnaps)
        DbgPrint("LDR: %wZ bound to %s\n", &LdrDataTableEntry->BaseDllName, NewImportName);

    st = LdrpLoadImportModule(
            DllPath,
            NewImportName,
            LdrDataTableEntry->DllBase,
            &DataTableEntry,
            &AlreadyLoaded);

    if (!NT_SUCCESS(st)) {
        if (ShowSnaps)
            DbgPrint("LDR: %wZ failed to load import module %s; status = %x\n", &LdrDataTableEntry->BaseDllName, NewImportName, st);

        goto Exit;
    }

    //
    // Add to initialization list.
    //

    if (!AlreadyLoaded)
        InsertTailList(&Peb->Ldr->InInitializationOrderModuleList, &DataTableEntry->InInitializationOrderLinks);

    if ((NewImportDescriptor->TimeDateStamp != DataTableEntry->TimeDateStamp) ||
        (DataTableEntry->Flags & LDRP_IMAGE_NOT_AT_BASE)) {
        if (ShowSnaps)
            DbgPrint("LDR: %wZ has stale binding to %s\n", &LdrDataTableEntry->BaseDllName, NewImportName);

        StaleBinding = TRUE;
    } else {
#if DBG
        LdrpSnapBypass++;
#endif
        if (ShowSnaps)
            DbgPrint("LDR: %wZ has correct binding to %s\n", &LdrDataTableEntry->BaseDllName, NewImportName);

        StaleBinding = FALSE;
    }

    NewImportForwarder = (PIMAGE_BOUND_FORWARDER_REF) (NewImportDescriptor + 1);
    for (i=0; i<NewImportDescriptor->NumberOfModuleForwarderRefs; i++) {
        NewFwdImportName = NewImportStringBase + NewImportForwarder->OffsetModuleName;
        if (ShowSnaps) {
            DbgPrint("LDR: %wZ bound to %s via forwarder(s) from %wZ\n",
                &LdrDataTableEntry->BaseDllName,
                NewFwdImportName,
                &DataTableEntry->BaseDllName);
        }

        st = LdrpLoadImportModule( DllPath,
                                   NewFwdImportName,
                                   LdrDataTableEntry->DllBase,
                                   &FwdDataTableEntry,
                                   &AlreadyLoaded
                                   );
        if ( NT_SUCCESS(st) ) {
            if (!AlreadyLoaded)
                InsertTailList(&Peb->Ldr->InInitializationOrderModuleList, &FwdDataTableEntry->InInitializationOrderLinks);
        }

        if ( (!NT_SUCCESS(st)) ||
             (NewImportForwarder->TimeDateStamp != FwdDataTableEntry->TimeDateStamp) ||
             (FwdDataTableEntry->Flags & LDRP_IMAGE_NOT_AT_BASE)) {
            if (ShowSnaps)
                DbgPrint("LDR: %wZ has stale binding to %s\n", &LdrDataTableEntry->BaseDllName, NewFwdImportName);

            StaleBinding = TRUE;
        } else {
#if DBG
            LdrpSnapBypass++;
#endif
            if (ShowSnaps) {
                DbgPrint("LDR: %wZ has correct binding to %s\n",
                        &LdrDataTableEntry->BaseDllName,
                        NewFwdImportName
                        );
            }
        }

        NewImportForwarder += 1;
    }

    NewImportDescriptor = (PIMAGE_BOUND_IMPORT_DESCRIPTOR) NewImportForwarder;

    if (StaleBinding) {
#if DBG
        LdrpNormalSnap++;
#endif
        //
        // Find the unbound import descriptor that matches this bound
        // import descriptor
        //

        ImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)RtlImageDirectoryEntryToData(
                            LdrDataTableEntry->DllBase,
                            TRUE,
                            IMAGE_DIRECTORY_ENTRY_IMPORT,
                            &ImportSize);

        while (ImportDescriptor->Name != 0) {
            ImportName = (PSZ)((ULONG_PTR)LdrDataTableEntry->DllBase + ImportDescriptor->Name);
            if (_stricmp(ImportName, NewImportName) == 0)
                break;

            ImportDescriptor += 1;
        }

        if (ImportDescriptor->Name == 0) {
            if (ShowSnaps)
                DbgPrint("LDR: LdrpWalkImportTable - failing with STATUS_OBJECT_NAME_INVALID due to no import descriptor name\n");

            st = STATUS_OBJECT_NAME_INVALID;
            goto Exit;
        }

        if (ShowSnaps)
            DbgPrint("LDR: Stale Bind %s from %wZ\n", ImportName, &LdrDataTableEntry->BaseDllName);

        st = LdrpSnapIAT(
                DataTableEntry,
                LdrDataTableEntry,
                ImportDescriptor,
                FALSE);
        if (!NT_SUCCESS(st)) {
            if (ShowSnaps)
                DbgPrint("LDR: LdrpWalkImportTable - LdrpSnapIAT failed with status %x\n", st);
            
            goto Exit;
        }
    }

    st = STATUS_SUCCESS;

Exit:
    *NewImportDescriptorInOut = NewImportDescriptor;
    return st;
}

NTSTATUS
LdrpHandleNewFormatImportDescriptors(
    IN PPEB Peb,
    IN PWSTR DllPath OPTIONAL,
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry,
    PIMAGE_BOUND_IMPORT_DESCRIPTOR NewImportDescriptor
    )
{
    NTSTATUS st = STATUS_INTERNAL_ERROR;
    PSZ NewImportStringBase;

    NewImportStringBase = (LPSTR) NewImportDescriptor;
    while (NewImportDescriptor->OffsetModuleName) {
        st = LdrpHandleOneNewFormatImportDescriptor(Peb, DllPath, LdrDataTableEntry, &NewImportDescriptor, NewImportStringBase);
        if (!NT_SUCCESS(st))
            goto Exit;
    }

    st = STATUS_SUCCESS;
Exit:
    return st;
}

NTSTATUS
LdrpHandleOneOldFormatImportDescriptor(
    IN PPEB Peb,
    IN PWSTR DllPath OPTIONAL,
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry,
    PIMAGE_IMPORT_DESCRIPTOR *ImportDescriptorInOut
    )
{
    NTSTATUS st = STATUS_INTERNAL_ERROR;
    PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor = *ImportDescriptorInOut;
    PIMAGE_THUNK_DATA FirstThunk = NULL;
    PSTR ImportName = NULL;
    PLDR_DATA_TABLE_ENTRY DataTableEntry = NULL;
    BOOLEAN AlreadyLoaded = FALSE;
    BOOLEAN SnapForwardersOnly = FALSE;
    ImportName = (PSZ)((ULONG_PTR)LdrDataTableEntry->DllBase + ImportDescriptor->Name);

    //
    // check for import that has no references
    //

    FirstThunk = (PIMAGE_THUNK_DATA) ((ULONG_PTR)LdrDataTableEntry->DllBase + ImportDescriptor->FirstThunk);
    if (FirstThunk->u1.Function != 0) {
        if (ShowSnaps)
            DbgPrint("LDR: %s used by %wZ\n", ImportName, &LdrDataTableEntry->BaseDllName);

        st = LdrpLoadImportModule( DllPath,
                                   ImportName,
                                   LdrDataTableEntry->DllBase,
                                   &DataTableEntry,
                                   &AlreadyLoaded);
        if (!NT_SUCCESS(st)) {
            if (ShowSnaps)
                DbgPrint("LDR: LdrpWalkImportTable - LdrpLoadImportModule failed on import %s with status %x\n", ImportName, st);

            goto Exit;
        }

        if (ShowSnaps)
            DbgPrint("LDR: Snapping imports for %wZ from %s\n", &LdrDataTableEntry->BaseDllName, ImportName);

        //
        // If the image has been bound and the import date stamp
        // matches the date time stamp in the export modules header,
        // and the image was mapped at it's prefered base address,
        // then we are done.
        //

        SnapForwardersOnly = FALSE;

        //
        // This code segment is an optimization path,
        // which has never been executed or tested.  The missing
        // parentheses around
        //    DataTableEntry->Flags & LDRP_IMAGE_NOT_AT_BASE
        // cause the entire test condition statement to evaluate to
        // false since "!" has higher precedence that "&" and
        // LDRP_IMAGE_NOT_AT_BASE = 0x00200000.
        // Hence, this code segment is unreachable.
        // The correct conditional statement should of been:
        //    ( !(DataTableEntry->Flags & LDRP_IMAGE_NOT_AT_BASE) )
        //
        // Since this code is an optimization path that would of been
        // executed infrequently by certain legacy formats, and this
        // code has never been executed or tested, the team decided not
        // to fix the test condition.  This decision does not alter
        // any functionality of previous versions of the ldr.
        //
        // if ( ImportDescriptor->OriginalFirstThunk ) {
        //     if ( ImportDescriptor->TimeDateStamp &&
        //          ImportDescriptor->TimeDateStamp == DataTableEntry->TimeDateStamp &&
        //          (! DataTableEntry->Flags & LDRP_IMAGE_NOT_AT_BASE) ) {
        // #if DBG
        //                     LdrpSnapBypass++;
        // #endif
        //         if (ShowSnaps) {
        //             DbgPrint("LDR: Snap bypass %s from %wZ\n",
        //                 ImportName,
        //                 &LdrDataTableEntry->BaseDllName
        //                 );
        //         }
        //
        //         if (ImportDescriptor->ForwarderChain == -1) {
        //             goto bypass_snap;
        //             }
        //
        //         SnapForwardersOnly = TRUE;
        //
        //         }
        // }

#if DBG
        LdrpNormalSnap++;
#endif
        //
        // Add to initialization list.
        //

        if (!AlreadyLoaded)
            InsertTailList(&Peb->Ldr->InInitializationOrderModuleList, &DataTableEntry->InInitializationOrderLinks);

        st = LdrpSnapIAT(
                DataTableEntry,
                LdrDataTableEntry,
                ImportDescriptor,
                SnapForwardersOnly);
        if (!NT_SUCCESS(st)) {
            if (ShowSnaps)
                DbgPrint("LDR: LdrpWalkImportTable - LdrpSnapIAT #2 failed with status %x\n", st);

            goto Exit;
        }

        AlreadyLoaded = TRUE;

        // See comment above.  Snap is always taken, so bypass_snap
        // never gets reference during execution.
// bypass_snap:

        //
        // Add to initialization list.
        //

        if (!AlreadyLoaded)
            InsertTailList(&Peb->Ldr->InInitializationOrderModuleList, &DataTableEntry->InInitializationOrderLinks);
    }

    ++ImportDescriptor;

    st = STATUS_SUCCESS;
Exit:
    *ImportDescriptorInOut = ImportDescriptor;
    return st;
}

NTSTATUS
LdrpHandleOldFormatImportDescriptors(
    IN PPEB Peb,
    IN PWSTR DllPath OPTIONAL,
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry,
    PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor
    )
{
    NTSTATUS st = STATUS_INTERNAL_ERROR;

    //
    // For each DLL used by this DLL, load the dll. Then snap
    // the IAT, and call the DLL's init routine.
    //

    while (ImportDescriptor->Name && ImportDescriptor->FirstThunk) {
        st = LdrpHandleOneOldFormatImportDescriptor(Peb, DllPath, LdrDataTableEntry, &ImportDescriptor);
        if (!NT_SUCCESS(st))
            goto Exit;
    }

    st = STATUS_SUCCESS;
Exit:
    return st;
}

NTSTATUS
LdrpMungHeapImportsForTagging(
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    )
{
    NTSTATUS st = STATUS_INTERNAL_ERROR;
    PVOID IATBase;
    SIZE_T BigIATSize;
    ULONG  LittleIATSize;
    PVOID *ProcAddresses;
    ULONG NumberOfProcAddresses;
    ULONG OldProtect;
    USHORT TagIndex;

    //
    // Determine the location and size of the IAT.  If found, scan the
    // IAT address to see if any are pointing to RtlAllocateHeap.  If so
    // replace when with a pointer to a unique thunk function that will
    // replace the tag with a unique tag for this image.
    //

    IATBase = RtlImageDirectoryEntryToData( LdrDataTableEntry->DllBase,
                                            TRUE,
                                            IMAGE_DIRECTORY_ENTRY_IAT,
                                            &LittleIATSize
                                          );

    if (IATBase != NULL) {

        BigIATSize = LittleIATSize;

        st = NtProtectVirtualMemory( NtCurrentProcess(),
                                     &IATBase,
                                     &BigIATSize,
                                     PAGE_READWRITE,
                                     &OldProtect);
        if (!NT_SUCCESS(st)) {
            DbgPrint( "LDR: Unable to unprotect IAT to enable tagging by DLL.\n");
            st = STATUS_SUCCESS;
            goto Exit;
        }

        ProcAddresses = (PVOID *)IATBase;
        NumberOfProcAddresses = (ULONG)(BigIATSize / sizeof(PVOID));

        while (NumberOfProcAddresses--) {
            if (*ProcAddresses == RtlAllocateHeap) {
                *ProcAddresses = LdrpDefineDllTag(LdrDataTableEntry->BaseDllName.Buffer, &TagIndex);
                if (*ProcAddresses == NULL)
                    *ProcAddresses = RtlAllocateHeap;
            }

            ProcAddresses += 1;
        }

        NtProtectVirtualMemory( NtCurrentProcess(),
                                &IATBase,
                                &BigIATSize,
                                OldProtect,
                                &OldProtect);
    }

    st = STATUS_SUCCESS;
Exit:
    return st;

}


NTSTATUS
LdrpWalkImportDescriptor (
    IN PWSTR DllPath OPTIONAL,
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    )

/*++

Routine Description:

    This is a recursive routine which walks the Import Descriptor
    Table and loads each DLL that is referenced.

Arguments:

    DllPath - Supplies an optional search path to be used to locate
        the DLL.

    LdrDataTableEntry - Supplies the address of the data table entry
        to initialize.

Return Value:

    Status value.

--*/

{
    ULONG ImportSize, NewImportSize;
    PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor = NULL;
    PIMAGE_BOUND_IMPORT_DESCRIPTOR NewImportDescriptor = NULL;
    NTSTATUS st;
    CONST PPEB Peb = NtCurrentPeb();
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME ActivationFrame = { sizeof(ActivationFrame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };
    CONST PLDR_DATA_TABLE_ENTRY Entry = LdrDataTableEntry;

    if (LdrpManifestProberRoutine != NULL) {
        PVOID SavedEntry = Peb->Ldr->EntryInProgress;

        __try {

            //
            // don't check .exes that have id 1 manifest, id 1 in an .exe makes Peb->ActivationContextData not NULL
            //
            if (Peb->ActivationContextData == NULL || LdrDataTableEntry != LdrpImageEntry) {
                CONST PVOID ViewBase = LdrDataTableEntry->DllBase;
                PVOID ResourceViewBase = ViewBase;
                NTSTATUS stTemp;
                PCWSTR DllName;
    #if defined(_WIN64)
                PIMAGE_NT_HEADERS NtHeaders = RtlImageNtHeader(ViewBase);
                if (NtHeaders->OptionalHeader.SectionAlignment < NATIVE_PAGE_SIZE) {
                    ResourceViewBase = LDR_VIEW_TO_DATAFILE(ViewBase);
                }
    #endif
                DllName = Entry->FullDllName.Buffer;
                //
                // RtlCreateUserProcess() causes this.
                //
                if (LdrDataTableEntry == LdrpImageEntry &&
                    DllName[0] == L'\\' &&
                    DllName[1] == L'?' &&
                    DllName[2] == L'?' &&
                    DllName[3] == L'\\' &&
                    DllName[4] != UNICODE_NULL &&
                    DllName[5] == ':' &&
                    DllName[6] == L'\\'
                    ) {
                    DllName += 4;
                }

                Peb->Ldr->EntryInProgress = Entry;

                stTemp = (*LdrpManifestProberRoutine)(ResourceViewBase, DllName, &Entry->EntryPointActivationContext);
                if (!NT_SUCCESS(stTemp)) {
                    if ((stTemp != STATUS_NO_SUCH_FILE) &&
                        (stTemp != STATUS_RESOURCE_DATA_NOT_FOUND) &&
                        (stTemp != STATUS_RESOURCE_TYPE_NOT_FOUND) &&
                        (stTemp != STATUS_RESOURCE_LANG_NOT_FOUND) &&
                        (stTemp != STATUS_RESOURCE_NAME_NOT_FOUND)) {
                        DbgPrintEx(
                            DPFLTR_SXS_ID,
                            DPFLTR_ERROR_LEVEL,
                            "LDR: LdrpWalkImportDescriptor() failed to probe %wZ for its manifest, ntstatus 0x%08lx\n", &LdrDataTableEntry->FullDllName, stTemp);
                        st = stTemp;
                        goto Exit;
                    }
                }
            }
        } __finally {
            Peb->Ldr->EntryInProgress = SavedEntry;
        }
    }

    // If we didn't start a private activation context for the DLL, let's use the currently/previously active one.
    if (Entry->EntryPointActivationContext == NULL) {
        st = RtlGetActiveActivationContext((PACTIVATION_CONTEXT *) &LdrDataTableEntry->EntryPointActivationContext);
        if (!NT_SUCCESS(st)) {
#if DBG
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "LDR: RtlGetActiveActivationContext() failed; ntstatus = 0x%08lx\n", st);
#endif
            goto Exit;
        }
    }

    RtlActivateActivationContextUnsafeFast(&ActivationFrame, LdrDataTableEntry->EntryPointActivationContext);

    __try {
        //
        // See if there is a bound import table.  If so, walk that to
        // verify if the binding is good.  If so, then succeed with
        // having touched the .idata section, as all the information
        // in the bound imports table is stored in the header.  If any
        // are stale, then fall out into the unbound case.
        //
        // Don't allow binding to redirected .dlls, because the Bind machinery
        // is too weak. It breaks when different files with the same leaf name
        // are built at the same time. This has been seen to happen,
        // with comctl32.dll and comctlv6.dll on September 30, 2000. a-JayK
        //
        if ((LdrDataTableEntry->Flags & LDRP_REDIRECTED) == 0) {
            NewImportDescriptor = (PIMAGE_BOUND_IMPORT_DESCRIPTOR)RtlImageDirectoryEntryToData(
                                   LdrDataTableEntry->DllBase,
                                   TRUE,
                                   IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT,
                                   &NewImportSize
                                   );
        }

        ImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)RtlImageDirectoryEntryToData(
                            LdrDataTableEntry->DllBase,
                            TRUE,
                            IMAGE_DIRECTORY_ENTRY_IMPORT,
                            &ImportSize
                            );


        if (NewImportDescriptor != NULL) {
            st = LdrpHandleNewFormatImportDescriptors(Peb, DllPath, LdrDataTableEntry, NewImportDescriptor);
            if (!NT_SUCCESS(st))
                goto Exit;
        } else if (ImportDescriptor != NULL) {
            st = LdrpHandleOldFormatImportDescriptors(Peb, DllPath, LdrDataTableEntry, ImportDescriptor);
            if (!NT_SUCCESS(st))
                goto Exit;
        }

        if (Peb->NtGlobalFlag & FLG_HEAP_ENABLE_TAG_BY_DLL) {
            st = LdrpMungHeapImportsForTagging(LdrDataTableEntry);
            if (!NT_SUCCESS(st))
                goto Exit;
        }

        //
        // Notify page heap per dll part of verifier that a dll got loaded.
        // It is important to call this before the main verifier hook so that
        // heap related imports are redirected before any redirection from
        // verifier providers. In time all this logic should move into
        // verifier.dll.
        //

        if (Peb->NtGlobalFlag & FLG_HEAP_PAGE_ALLOCS) {
            AVrfPageHeapDllNotification (LdrDataTableEntry);
        }

        //
        // Notify verifier that a dll got loaded.
        //

        if (Peb->NtGlobalFlag & FLG_APPLICATION_VERIFIER) {
            AVrfDllLoadNotification (LdrDataTableEntry);
        }
    } __finally {
        RtlDeactivateActivationContextUnsafeFast(&ActivationFrame);
    }

    st = STATUS_SUCCESS;
Exit:
    return st;
}


ULONG
LdrpClearLoadInProgress(
    VOID
    )
{
    PLIST_ENTRY Head, Next;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    ULONG i;

    Head = &NtCurrentPeb()->Ldr->InInitializationOrderModuleList;
    Next = Head->Flink;
    i = 0;
    while ( Next != Head ) {
        LdrDataTableEntry = CONTAINING_RECORD(Next, LDR_DATA_TABLE_ENTRY, InInitializationOrderLinks);
        LdrDataTableEntry->Flags &= ~LDRP_LOAD_IN_PROGRESS;

        //
        // return the number of entries that have not been processed, but
        // have init routines
        //

        if ( !(LdrDataTableEntry->Flags & LDRP_ENTRY_PROCESSED) && LdrDataTableEntry->EntryPoint) {
            i++;
            }

        Next = Next->Flink;
        }
    return i;
}

NTSTATUS
LdrpRunInitializeRoutines(
    IN PCONTEXT Context OPTIONAL
    )
{
    PLIST_ENTRY Head, Next;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    PLDR_DATA_TABLE_ENTRY *LdrDataTableBase;
    PDLL_INIT_ROUTINE InitRoutine;
    BOOLEAN InitStatus;
    ULONG NumberOfRoutines;
    ULONG i;
    NTSTATUS Status;
    ULONG BreakOnDllLoad;
    PLDR_DATA_TABLE_ENTRY StackLdrDataTable[16];
    PTEB OldTopLevelDllBeingLoadedTeb;

    LdrpEnsureLoaderLockIsHeld();

    //
    // Run the Init routines
    //

    //
    // capture the entries that have init routines
    //

    NumberOfRoutines = LdrpClearLoadInProgress();

    if (NumberOfRoutines != 0) {
        if (NumberOfRoutines <= RTL_NUMBER_OF(StackLdrDataTable))
            LdrDataTableBase = StackLdrDataTable;
        else {
            LdrDataTableBase = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TEMP_TAG), NumberOfRoutines * sizeof(PLDR_DATA_TABLE_ENTRY));
            if (LdrDataTableBase == NULL) {
                DbgPrintEx(
                    DPFLTR_LDR_ID,
                    LDR_ERROR_DPFLTR,
                    "LDR: %s - failed to allocate dynamic array of %u DLL initializers to run\n",
                    __FUNCTION__,
                    NumberOfRoutines);

                return STATUS_NO_MEMORY;
            }
        }
    } else
        LdrDataTableBase = NULL;

    Head = &NtCurrentPeb()->Ldr->InInitializationOrderModuleList;
    Next = Head->Flink;

    if (ShowSnaps || LdrpShowInitRoutines) {
        DbgPrint("[%x,%x] LDR: Real INIT LIST for process %wZ pid %u 0x%x\n",
            HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess),
            HandleToULong(NtCurrentTeb()->ClientId.UniqueThread),
            &NtCurrentPeb()->ProcessParameters->ImagePathName,
            HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess),
            HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess)
            );
    }

    i = 0;
    while ( Next != Head ) {
        LdrDataTableEntry = CONTAINING_RECORD(Next, LDR_DATA_TABLE_ENTRY, InInitializationOrderLinks);

        if (LdrDataTableBase && !(LdrDataTableEntry->Flags & LDRP_ENTRY_PROCESSED) && LdrDataTableEntry->EntryPoint) {
            ASSERT(i < NumberOfRoutines);
            LdrDataTableBase[i] = LdrDataTableEntry;

            if (ShowSnaps || LdrpShowInitRoutines) {
                DbgPrint("[%x,%x]    %wZ init routine %p\n",
                    HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess),
                    HandleToULong(NtCurrentTeb()->ClientId.UniqueThread),
                    &LdrDataTableEntry->FullDllName,
                    LdrDataTableEntry->EntryPoint);
            }

            i++;
        }
        LdrDataTableEntry->Flags |= LDRP_ENTRY_PROCESSED;

        Next = Next->Flink;
    }

    ASSERT(i == NumberOfRoutines);

    if (LdrDataTableBase == NULL) {
        return STATUS_SUCCESS;
    }

    i = 0;

    OldTopLevelDllBeingLoadedTeb = LdrpTopLevelDllBeingLoadedTeb;
    LdrpTopLevelDllBeingLoadedTeb = NtCurrentTeb();

    try {
        while ( i < NumberOfRoutines ) {
            LdrDataTableEntry = LdrDataTableBase[i];
            i++;
            InitRoutine = (PDLL_INIT_ROUTINE)LdrDataTableEntry->EntryPoint;

            //
            // Walk through the entire list looking for un-processed
            // entries. For each entry, set the processed flag
            // and optionally call it's init routine
            //

            BreakOnDllLoad = 0;
#if DBG
            if (TRUE)
#else
            if (NtCurrentPeb()->BeingDebugged || NtCurrentPeb()->ReadImageFileExecOptions)
#endif
            {
                Status = LdrQueryImageFileExecutionOptions( &LdrDataTableEntry->BaseDllName,
                                                            L"BreakOnDllLoad",
                                                            REG_DWORD,
                                                            &BreakOnDllLoad,
                                                            sizeof( BreakOnDllLoad ),
                                                            NULL
                                                          );
                if (!NT_SUCCESS( Status )) {
                    BreakOnDllLoad = 0;
                    }
                }

            if (BreakOnDllLoad) {
                if (ShowSnaps) {
                    DbgPrint( "LDR: %wZ loaded.", &LdrDataTableEntry->BaseDllName );
                    DbgPrint( " - About to call init routine at %p\n", InitRoutine );
                    }
                DbgBreakPoint();

            } else if (ShowSnaps) {
                if ( InitRoutine ) {
                    DbgPrint( "[%x,%x] LDR: %wZ loaded",
                        HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess),
                        HandleToULong(NtCurrentTeb()->ClientId.UniqueThread),
                        &LdrDataTableEntry->BaseDllName);

                    DbgPrint(" - Calling init routine at %p\n", InitRoutine);
                }
            }

            if ( InitRoutine ) {
                PLDR_DATA_TABLE_ENTRY SavedInitializer = LdrpCurrentDllInitializer;
                LdrpCurrentDllInitializer = LdrDataTableEntry;

                __try {
                    LDRP_ACTIVATE_ACTIVATION_CONTEXT(LdrDataTableEntry);
                    //
                    // If the DLL has TLS data, then call the optional initializers
                    //
                    if ((LdrDataTableEntry->TlsIndex != 0) && (Context != NULL))
                        LdrpCallTlsInitializers(LdrDataTableEntry->DllBase,DLL_PROCESS_ATTACH);

                    if (LdrpShowInitRoutines) {
                        DbgPrint("[%x,%x] LDR: calling init routine %p for DLL_PROCESS_ATTACH\n",
                            HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess),
                            HandleToULong(NtCurrentTeb()->ClientId.UniqueThread),
                            InitRoutine);
                    }

                    InitStatus = LdrpCallInitRoutine(InitRoutine,
                                                     LdrDataTableEntry->DllBase,
                                                     DLL_PROCESS_ATTACH,
                                                     Context);
                    LDRP_DEACTIVATE_ACTIVATION_CONTEXT();
                } __finally {
                    LdrpCurrentDllInitializer = SavedInitializer;
                }

                LdrDataTableEntry->Flags |= LDRP_PROCESS_ATTACH_CALLED;

                if (!InitStatus) {
                    DbgPrintEx(
                        DPFLTR_LDR_ID,
                        LDR_ERROR_DPFLTR,
                        "[%x,%x] LDR: DLL_PROCESS_ATTACH for dll \"%wZ\" (InitRoutine: %p) failed\n",
                        HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess),
                        HandleToULong(NtCurrentTeb()->ClientId.UniqueThread),
                        &LdrDataTableEntry->FullDllName,
                        InitRoutine);

                    return STATUS_DLL_INIT_FAILED;
                }
            }
        }

        //
        // If the image has tls than call its initializers
        //

        if (LdrpImageHasTls && (Context != NULL))
        {
            LDRP_ACTIVATE_ACTIVATION_CONTEXT(LdrpImageEntry);
            LdrpCallTlsInitializers(NtCurrentPeb()->ImageBaseAddress,DLL_PROCESS_ATTACH);

            LDRP_DEACTIVATE_ACTIVATION_CONTEXT();
        }
    } finally {
        LdrpTopLevelDllBeingLoadedTeb = OldTopLevelDllBeingLoadedTeb;

        if ((LdrDataTableBase != NULL) &&
            (LdrDataTableBase != StackLdrDataTable))
            RtlFreeHeap(RtlProcessHeap(),0,LdrDataTableBase);
    }

    return STATUS_SUCCESS;
}

BOOLEAN
LdrpCheckForLoadedDll (
    IN PWSTR DllPath OPTIONAL,
    IN PUNICODE_STRING DllName,
    IN BOOLEAN StaticLink,
    IN BOOLEAN Redirected,
    OUT PLDR_DATA_TABLE_ENTRY *LdrDataTableEntry
    )

/*++

Routine Description:

    This function scans the loader data table looking to see if
    the specified DLL has already been mapped into the image. If
    the dll has been loaded, the address of its data table entry
    is returned.

Arguments:

    DllPath - Supplies an optional search path used to locate the DLL.

    DllName - Supplies the name to search for.

    StaticLink - TRUE if performing a static link.

    LdrDataTableEntry - Returns the address of the loader data table
        entry that describes the first dll section that implements the
        dll.

Return Value:

    TRUE- The dll is already loaded.  The address of the data table
        entries that implement the dll, and the number of data table
        entries are returned.

    FALSE - The dll is not already mapped.

--*/

{
    BOOLEAN Result = FALSE;
    PLDR_DATA_TABLE_ENTRY Entry;
    PLIST_ENTRY Head, Next;
    UNICODE_STRING FullDllName;
    HANDLE DllFile;
    BOOLEAN HardCodedPath;
    PWCH p;
    ULONG i;
    WCHAR FullDllNameStaticBuffer[LDR_MAX_PATH];
    UNICODE_STRING FullDllNameDynamicString;
    ULONG Length = 0;
    PWCH src,dest;
    NTSTATUS Status;

    FullDllNameDynamicString.Buffer = NULL;

    if (!DllName->Buffer || !DllName->Buffer[0]) {
        goto alldone;
    }

    Status = STATUS_SUCCESS; // just in case anyone asks...

    //
    // for static links, just go to the hash table
    //
staticlink:
    if ( StaticLink ) {

        // If this is a redirected static load, the dll name is a fully qualified path.  The
        // hash table is maintained based on the first character of the base dll name, so find
        // the base dll name.
        if (Redirected) {
            PWSTR LastChar = DllName->Buffer + (DllName->Length / sizeof(WCHAR)) - (DllName->Length == 0 ? 0 : 1);

            while (LastChar != DllName->Buffer) {
                const WCHAR wch = *LastChar;

                if ((wch == L'\\') || (wch == L'/'))
                    break;

                LastChar--;
            }

            // This assert ignores the "possibility" that the first and only slash is the first character, but that's
            // an error, too.  The redirection should be a complete DOS path.
            ASSERTMSG(
                "Redirected DLL name does not have full path; either caller lied or redirection info is in error",
                LastChar != DllName->Buffer);

            if (LastChar == DllName->Buffer) {
                if (ShowSnaps) {
                    DbgPrint("LDR: Failing LdrpCheckForLoadedDll because redirected DLL name %wZ does not include a slash\n", DllName);
                }

                Result = FALSE;
                goto alldone;
            }

            LastChar++;

            i = LDRP_COMPUTE_HASH_INDEX(*LastChar);
        } else {
            i = LDRP_COMPUTE_HASH_INDEX(DllName->Buffer[0]);
        }

        Head = &LdrpHashTable[i];
        Next = Head->Flink;
        while ( Next != Head ) {
            Entry = CONTAINING_RECORD(Next, LDR_DATA_TABLE_ENTRY, HashLinks);
#if DBG
            LdrpCompareCount++;
#endif            
            // Redirected static loads never match unredirected entries and vice versa
            if (Redirected) {
                if (((Entry->Flags & LDRP_REDIRECTED) != 0) &&
                    RtlEqualUnicodeString(DllName, &Entry->FullDllName, TRUE)) {
                    *LdrDataTableEntry = Entry;
                    Result = TRUE;
                    goto alldone;
                }
            } else {
                // Not redirected...
                if (((Entry->Flags & LDRP_REDIRECTED) == 0) &&
                    RtlEqualUnicodeString(DllName, &Entry->BaseDllName, TRUE)) {
                    *LdrDataTableEntry = Entry;
                    Result = TRUE;
                    goto alldone;
                }
            }

            Next = Next->Flink;
            }
        }

    if ( StaticLink ) {
        Result = FALSE;
        goto alldone;
        }

    //
    // If the dll name contained a hard coded path
    // (dynamic link only), then the fully qualified
    // name needs to be compared to make sure we
    // have the correct dll.
    //

    p = DllName->Buffer;
    HardCodedPath = FALSE;

    if (Redirected) {
        HardCodedPath = TRUE;
        FullDllName.Length = DllName->Length;
        FullDllName.MaximumLength = DllName->MaximumLength;
        FullDllName.Buffer = DllName->Buffer;
    } else {
        while (*p) {
            const WCHAR wch = *p++;
            if (wch == (WCHAR)'\\' || wch == (WCHAR)'/' ) {

                HardCodedPath = TRUE;

                //
                // We have a hard coded path, so we have to search path
                // for the DLL. We need the full DLL name so we can

                FullDllName.Buffer = FullDllNameStaticBuffer;

                Length = RtlDosSearchPath_U(
                            ARGUMENT_PRESENT(DllPath) ? DllPath : LdrpDefaultPath.Buffer,
                            DllName->Buffer,
                            NULL,
                            sizeof(FullDllNameStaticBuffer)-sizeof(UNICODE_NULL),
                            FullDllName.Buffer,
                            NULL
                            );

                if (Length == 0) {
                    if (ShowSnaps) {
                        DbgPrint("LDR: LdrpCheckForLoadedDll - Unable To Locate ");
                        DbgPrint("%ws from %ws\n",
                            DllName->Buffer,
                            ARGUMENT_PRESENT(DllPath) ? DllPath : LdrpDefaultPath.Buffer
                            );
                    }

                    Result = FALSE;
                    goto alldone;
                }

                if ((Length + sizeof(WCHAR)) > sizeof(FullDllNameStaticBuffer)) {
                    if (Length > UNICODE_STRING_MAX_BYTES) {
                        if (ShowSnaps) {
                            DbgPrint("LDR: LdrpCheckForLoadedDll - Failing load of ");
                            DbgPrint("%wZ from %ws", DllName, ARGUMENT_PRESENT(DllPath) ? DllPath : LdrpDefaultPath.Buffer);
                            DbgPrint(" because path search required %u bytes\n", Length + sizeof(WCHAR));
                        }

                        Result = FALSE;
                        goto alldone;
                    }

                    FullDllNameDynamicString.Buffer = (RtlAllocateStringRoutine)(Length + sizeof(WCHAR));
                    if (FullDllNameDynamicString.Buffer == NULL) {
                        if (ShowSnaps) {
                            DbgPrint("LDR: LdrpCheckForLoadedDll - Failing load of %wZ because we could not dynamically allocate its full dll path buffer\n", DllName);
                        }
                        Result = FALSE;
                        goto alldone;
                    }

                    FullDllNameDynamicString.MaximumLength = (USHORT) (Length + sizeof(WCHAR));
                    FullDllNameDynamicString.Length = 0;

                    Length = RtlDosSearchPath_U(
                            ARGUMENT_PRESENT(DllPath) ? DllPath : LdrpDefaultPath.Buffer,
                            DllName->Buffer,
                            NULL,
                            Length,
                            FullDllNameDynamicString.Buffer,
                            NULL
                            );
                    if ((Length == 0) || ((Length + sizeof(WCHAR)) > FullDllNameDynamicString.MaximumLength)) {
                        if (ShowSnaps) {
                            DbgPrint("LDR: LdrpCheckForLoadedDll - Failing load of %wZ because searching path into dynamic buffer failed; buffer size: returned length: %lu\n",
                                DllName, FullDllNameDynamicString.MaximumLength, Length);
                        }

                        Result = FALSE;
                        goto alldone;
                    }

                    FullDllName.Buffer = FullDllNameDynamicString.Buffer;
                }

                FullDllName.Buffer[Length / sizeof(WCHAR)] = UNICODE_NULL;

                FullDllName.Length = (USHORT)Length;
                FullDllName.MaximumLength = FullDllName.Length + (USHORT)sizeof(UNICODE_NULL);
                break;
            }
        }
    }

    //
    // if this is a dynamic load lib, and there is not a hard
    // coded path, then go to the static lib hash table for resolution
    //

    if ( !HardCodedPath ) {
        // If we're redirecting this DLL, don't check if there's another DLL by the same name already loaded.
        if (NT_SUCCESS(RtlFindActivationContextSectionString(0, NULL, ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION, DllName, NULL)))
            return FALSE;

        StaticLink = TRUE;

        goto staticlink;
        }

    Result = FALSE;
    Head = &NtCurrentPeb()->Ldr->InLoadOrderModuleList;
    Next = Head->Flink;

    while ( Next != Head ) {
        Entry = CONTAINING_RECORD(Next, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
        Next = Next->Flink;

        //
        // when we unload, the memory order links flink field is nulled.
        // this is used to skip the entry pending list removal.
        //

        if ( !Entry->InMemoryOrderLinks.Flink ) {
            continue;
        }

        // Since this is a full string comparison, we don't worry about redirection - we don't
        // want to load the dll from a particular path more than once just because one of them
        // explicitly (and erroneously) specified the magic side-by-side location of the
        // DLL and the other loaded it via side-by-side isolation automagically.
        if (RtlEqualUnicodeString(
                &FullDllName,
                &Entry->FullDllName,
                TRUE
                ) ) {

                Result = TRUE;
                *LdrDataTableEntry = Entry;
                break;
            }
        }

    if ( !Result ) {

        //
        // no names matched. This might be a long short name mismatch or
        // any kind of alias pathname. Deal with this by opening and mapping
        // full dll name and then repeat the scan this time checking for
        // timedatestamp matches
        //

        HANDLE File;
        HANDLE Section;
        NTSTATUS st;
        OBJECT_ATTRIBUTES ObjectAttributes;
        IO_STATUS_BLOCK IoStatus;
        PVOID ViewBase;
        SIZE_T ViewSize;
        PIMAGE_NT_HEADERS NtHeadersSrc,NtHeadersE;
        UNICODE_STRING NtFileName;


        if (!RtlDosPathNameToNtPathName_U( FullDllName.Buffer,
                                           &NtFileName,
                                           NULL,
                                           NULL
                                         )
           ) {
            goto alldone;
            }

        InitializeObjectAttributes(
            &ObjectAttributes,
            &NtFileName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        st = NtOpenFile(
                &File,
                SYNCHRONIZE | FILE_EXECUTE,
                &ObjectAttributes,
                &IoStatus,
                FILE_SHARE_READ | FILE_SHARE_DELETE,
                FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT
                );
        RtlFreeHeap(RtlProcessHeap(), 0, NtFileName.Buffer);

        if (!NT_SUCCESS(st)) {
            goto alldone;
            }

        st = NtCreateSection(
                &Section,
                SECTION_MAP_READ | SECTION_MAP_EXECUTE | SECTION_MAP_WRITE,
                NULL,
                NULL,
                PAGE_EXECUTE,
                SEC_COMMIT,
                File
                );
        NtClose( File );

        if (!NT_SUCCESS(st)) {
            goto alldone;
            }

        ViewBase = NULL;
        ViewSize = 0;
        st = NtMapViewOfSection(
                Section,
                NtCurrentProcess(),
                (PVOID *)&ViewBase,
                0L,
                0L,
                NULL,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_EXECUTE
                );
        NtClose(Section);
        if (!NT_SUCCESS(st)) {
            goto alldone;
            }

        //
        // The section is mapped. Now find the headers
        //
        NtHeadersSrc = RtlImageNtHeader(ViewBase);
        if ( !NtHeadersSrc ) {
            NtUnmapViewOfSection(NtCurrentProcess(),ViewBase);
            goto alldone;
            }
        Head = &NtCurrentPeb()->Ldr->InLoadOrderModuleList;
        Next = Head->Flink;

        while ( Next != Head ) {
            Entry = CONTAINING_RECORD(Next, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
            Next = Next->Flink;

            //
            // when we unload, the memory order links flink field is nulled.
            // this is used to skip the entry pending list removal.
            //

            if ( !Entry->InMemoryOrderLinks.Flink ) {
                continue;
            }

            try {
                if ( Entry->TimeDateStamp == NtHeadersSrc->FileHeader.TimeDateStamp &&
                     Entry->SizeOfImage == NtHeadersSrc->OptionalHeader.SizeOfImage ) {

                    //
                    // there is a very good chance we have an image match. Check the
                    // entire file header and optional header. If they match, declare
                    // this a match
                    //

                    NtHeadersE = RtlImageNtHeader(Entry->DllBase);

                    if ( RtlCompareMemory(NtHeadersE,NtHeadersSrc,sizeof(*NtHeadersE)) ) {

                        //
                        // Now that it looks like we have a match, compare
                        // volume serial number's and file index's
                        //

                        st = NtAreMappedFilesTheSame(Entry->DllBase,ViewBase);

                        if ( !NT_SUCCESS(st) ) {
                            continue;
                            }
                        else {
                            Result = TRUE;
                            *LdrDataTableEntry = Entry;
                            break;
                            }
                        }
                    }
                }
            except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
                DbgPrintEx(
                    DPFLTR_LDR_ID,
                    LDR_ERROR_DPFLTR,
                    "LDR: %s - Caught exception %08lx\n",
                    __FUNCTION__,
                    GetExceptionCode());

                break;
                }
            }
        NtUnmapViewOfSection(NtCurrentProcess(),ViewBase);
        }

alldone:
    if (FullDllNameDynamicString.Buffer != NULL) {
        RtlFreeUnicodeString(&FullDllNameDynamicString);
    }

    return Result;
}


BOOLEAN
LdrpCheckForLoadedDllHandle (
    IN PVOID DllHandle,
    OUT PLDR_DATA_TABLE_ENTRY *LdrDataTableEntry
    )

/*++

Routine Description:

    This function scans the loader data table looking to see if
    the specified DLL has already been mapped into the image address
    space. If the dll has been loaded, the address of its data table
    entry that describes the dll is returned.

Arguments:

    DllHandle - Supplies the DllHandle of the DLL being searched for.

    LdrDataTableEntry - Returns the address of the loader data table
        entry that describes the dll.

Return Value:

    TRUE- The dll is loaded.  The address of the data table entry is
        returned.

    FALSE - The dll is not loaded.

--*/

{
    PLDR_DATA_TABLE_ENTRY Entry;
    PLIST_ENTRY Head,Next;

    if ( LdrpLoadedDllHandleCache &&
        (PVOID) LdrpLoadedDllHandleCache->DllBase == DllHandle ) {
        *LdrDataTableEntry = LdrpLoadedDllHandleCache;
        return TRUE;
        }

    Head = &NtCurrentPeb()->Ldr->InLoadOrderModuleList;
    Next = Head->Flink;

    while ( Next != Head ) {
        Entry = CONTAINING_RECORD(Next, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
        Next = Next->Flink;
        //
        // when we unload, the memory order links flink field is nulled.
        // this is used to skip the entry pending list removal.
        //

        if ( !Entry->InMemoryOrderLinks.Flink ) {
            continue;
        }

        if (DllHandle == (PVOID)Entry->DllBase ){
            LdrpLoadedDllHandleCache = Entry;
            *LdrDataTableEntry = Entry;
            return TRUE;
        }
    }
    return FALSE;
}

NTSTATUS
LdrpCheckCorImage (
    IN PIMAGE_COR20_HEADER Cor20Header,
    IN PUNICODE_STRING FullDllName,
    IN OUT PVOID *ViewBase,
    OUT PBOOLEAN Cor20ILOnly
    )

{
    PIMAGE_NT_HEADERS NtHeaders;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PVOID OriginalViewBase = *ViewBase;

    
    if (Cor20Header) {

#if defined(_WIN64)
        
        //
        // Validate that the COM+ image contains the right flags
        //
        if ((Cor20Header->Flags & (COMIMAGE_FLAGS_32BITREQUIRED | COMIMAGE_FLAGS_ILONLY)) != COMIMAGE_FLAGS_ILONLY) {
            
            if (ShowSnaps) {
                DbgPrint("LDR: COM+ image (dll) flags %lx didn't specify ILONLY\n", Cor20Header->Flags);
            }

            NtStatus = STATUS_INVALID_IMAGE_FORMAT;
            goto return_result;
        }
#endif

        //
        // The image is COM+ so notify the runtime that the image was loaded
        // and allow it to verify the image for correctness.
        //

        NtStatus = LdrpCorValidateImage(ViewBase, FullDllName->Buffer);
        if (!NT_SUCCESS (NtStatus)) {
            
            //
            // Image is bad, or mscoree failed, etc.
            //

            *ViewBase = OriginalViewBase;
            goto return_result;
        }
        
        //
        // Indicates it's an ILONLY image if the flag is set in the header.
        //

        if ((Cor20Header->Flags & COMIMAGE_FLAGS_ILONLY) == COMIMAGE_FLAGS_ILONLY) {
            *Cor20ILOnly = TRUE;
        }

        if (*ViewBase != OriginalViewBase) {
            
            //
            // Mscoree has substituted a new image at a new base in place
            // of the original image.  Unmap the original image and use
            // the new image from now on.
            //

            NtUnmapViewOfSection(NtCurrentProcess(), OriginalViewBase);
            NtHeaders = RtlImageNtHeader(*ViewBase);
            
            if (!NtHeaders) {

                NtStatus = STATUS_INVALID_IMAGE_FORMAT;
                goto return_result;
            }
        }
    }

return_result:

    return NtStatus;
}


NTSTATUS
LdrpMapDll(
    IN PWSTR DllPath OPTIONAL,
    IN PWSTR DllName,
    IN PULONG DllCharacteristics OPTIONAL,
    IN BOOLEAN StaticLink,
    IN BOOLEAN Redirected,
    OUT PLDR_DATA_TABLE_ENTRY *LdrDataTableEntry
    )

/*++

Routine Description:

    This routine maps the DLL into the users address space.

Arguments:

    DllPath - Supplies an optional search path to be used to locate the DLL.

    DllName - Supplies the name of the DLL to load.

    StaticLink - TRUE if this DLL has a static link to it.

    LdrDataTableEntry - Supplies the address of the data table entry.

Return Value:

    Status value.

--*/

{
    NTSTATUS st = STATUS_INTERNAL_ERROR;
    PVOID ViewBase = NULL;
    PTEB Teb = NtCurrentTeb();
    SIZE_T ViewSize;
    HANDLE Section, DllFile;
    UNICODE_STRING FullDllName, BaseDllName;
    UNICODE_STRING NtFileName;
    PLDR_DATA_TABLE_ENTRY Entry;
    PIMAGE_NT_HEADERS NtHeaders;
    PVOID ArbitraryUserPointer;
    BOOLEAN KnownDll;
    UNICODE_STRING CollidingDll;
    PUCHAR ImageBase, ImageBounds, ScanBase, ScanTop;
    PLDR_DATA_TABLE_ENTRY ScanEntry;
    PLIST_ENTRY ScanHead,ScanNext;
    BOOLEAN CollidingDllFound;
    NTSTATUS ErrorStatus;
    ULONG_PTR ErrorParameters[2];
    ULONG ErrorResponse;
    IMAGE_COR20_HEADER *Cor20Header;
    ULONG Cor20HeaderSize;
    BOOLEAN Cor20ILOnly = FALSE;
    PVOID OriginalViewBase;
    NTSTATUS stTemp;
    PWSTR AppCompatDllName = NULL;

    //
    // Get section handle of DLL being snapped
    //

#if LDRDBG
    if (ShowSnaps) {
        DbgPrint("LDR: LdrpMapDll: Image Name %ws, Search Path %ws\n",
                DllName,
                ARGUMENT_PRESENT(DllPath) ? DllPath : L""
                );
    }
#endif

    Entry = NULL;
    KnownDll = FALSE;
    Section = NULL;

    LdrpEnsureLoaderLockIsHeld();

    // No capturing etc. of the globals since we "know" that the loader lock is taken to synchronize access.
    if (LdrpAppCompatDllRedirectionCallbackFunction != NULL) {
        st = (*LdrpAppCompatDllRedirectionCallbackFunction)(
                0,              // Flags - reserved for the future
                DllName,
                DllPath,
                DllCharacteristics,
                LdrpAppCompatDllRedirectionCallbackData,
                &AppCompatDllName);
        if (!NT_SUCCESS(st)) {
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - call back to app compat redirection function @ %p (cb data: %p) failed with status %x\n",
                __FUNCTION__,
                LdrpAppCompatDllRedirectionCallbackFunction,
                LdrpAppCompatDllRedirectionCallbackData,
                st);

            goto Exit;
        }

        if (AppCompatDllName != NULL) {
            Redirected = TRUE;
            DllName = AppCompatDllName;
        }
    }

    if ((LdrpKnownDllObjectDirectory != NULL) && !Redirected) {
        PCWCH p = DllName;
        WCHAR wch;

        //
        // Skip the KnownDll check if this is an explicit path.
        //

        while ((wch = *p) != L'\0') {
            p++;
            if (RTL_IS_PATH_SEPARATOR(wch))
                break;
        }

        // If we hit the end of the string, there must have not been a path separator.
        if (wch == L'\0') {
            st = LdrpCheckForKnownDll(DllName, &FullDllName, &BaseDllName, &Section);
            if ((!NT_SUCCESS(st)) && (st != STATUS_DLL_NOT_FOUND)) {
                DbgPrintEx(
                    DPFLTR_LDR_ID,
                    LDR_ERROR_DPFLTR,
                    "LDR: %s - call to LdrpCheckForKnownDll(\"%ws\", ...) failed with status %x\n",
                    __FUNCTION__,
                    DllName,
                    st);

                goto Exit;
            }
        }
    }

    if (Section == NULL) {
        st = LdrpResolveDllName(DllPath, DllName, Redirected, &FullDllName, &BaseDllName, &DllFile);
        if (!NT_SUCCESS(st)) {
            if (st == STATUS_DLL_NOT_FOUND) {
                if (StaticLink) {
                    UNICODE_STRING ErrorDllName, ErrorDllPath;
                    PUNICODE_STRING ErrorStrings[2] = { &ErrorDllName, &ErrorDllPath };
                    ULONG ErrorResponse;

                    RtlInitUnicodeString(&ErrorDllName,DllName);
                    RtlInitUnicodeString(&ErrorDllPath,ARGUMENT_PRESENT(DllPath) ? DllPath : LdrpDefaultPath.Buffer);

                    NtRaiseHardError(
                        STATUS_DLL_NOT_FOUND,
                        2,              // Number of error strings
                        0x00000003,
                        (PULONG_PTR)ErrorStrings,
                        OptionOk,
                        &ErrorResponse);

                    if (LdrpInLdrInit)
                        LdrpFatalHardErrorCount++;
                }
            } else {
                DbgPrintEx(
                    DPFLTR_LDR_ID,
                    LDR_ERROR_DPFLTR,
                    "LDR: %s - call to LdrpResolveDllName on dll \"%ws\" failed with status %x\n",
                    __FUNCTION__,
                    DllName,
                    st);
            }



            goto Exit;
        }

        if (ShowSnaps) {
            PSZ type;
            PSZ type2;
            type = StaticLink ? "STATIC" : "DYNAMIC";
            type2 = Redirected ? "REDIRECTED" : "NON_REDIRECTED";

            DbgPrint(
                "LDR: Loading (%s, %s) %wZ\n",
                type,
                type2,
                &FullDllName);
        }

        if (!RtlDosPathNameToNtPathName_U(
                FullDllName.Buffer,
                &NtFileName,
                NULL,
                NULL)) {
            st = STATUS_OBJECT_PATH_SYNTAX_BAD;
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - call to RtlDosPathNameToNtPathName_U on path \"%wZ\" failed; returning status %x\n",
                __FUNCTION__,
                &FullDllName,
                st);
            goto Exit;
        }

        st = LdrpCreateDllSection(&NtFileName,
                                  DllFile,
                                  &BaseDllName,
                                  DllCharacteristics,
                                  &Section);

        if (!NT_SUCCESS(st)) {
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - LdrpCreateDllSection (%wZ) failed with status %x\n",
                __FUNCTION__,
                &NtFileName,
                st);

            LdrpFreeUnicodeString(&FullDllName);
            // We do not free BaseDllName since it's just a substring of FullDllName.

            RtlFreeHeap(RtlProcessHeap(), 0, NtFileName.Buffer);
            goto Exit;
        }
        RtlFreeHeap(RtlProcessHeap(), 0, NtFileName.Buffer);
#if DBG
        LdrpSectionCreates++;
#endif
    } else {
        KnownDll = TRUE;
    }

    ViewBase = NULL;
    ViewSize = 0;

#if DBG
    LdrpSectionMaps++;
    if (LdrpDisplayLoadTime) {
        NtQueryPerformanceCounter(&MapBeginTime, NULL);
    }
#endif

    //
    // arrange for debugger to pick up the image name
    //

    ArbitraryUserPointer = Teb->NtTib.ArbitraryUserPointer;
    Teb->NtTib.ArbitraryUserPointer = (PVOID)FullDllName.Buffer;
    st = NtMapViewOfSection(
            Section,
            NtCurrentProcess(),
            (PVOID *)&ViewBase,
            0L,
            0L,
            NULL,
            &ViewSize,
            ViewShare,
            0L,
            PAGE_READWRITE
            );
    Teb->NtTib.ArbitraryUserPointer = ArbitraryUserPointer;

    if (!NT_SUCCESS(st)) {
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s - failed to map view of section; status = %x\n",
            __FUNCTION__,
            st);

        goto Exit;
    }

    NtHeaders = RtlImageNtHeader(ViewBase);
    if ( !NtHeaders ) {
        NtUnmapViewOfSection(NtCurrentProcess(),ViewBase);
        st = STATUS_INVALID_IMAGE_FORMAT;
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s - unable to map ViewBase (%p) to image headers; failing with status %x\n",
            __FUNCTION__,
            ViewBase,
            st);
        goto Exit;
        }

#if _WIN64
    if (st != STATUS_IMAGE_NOT_AT_BASE &&
        (NtCurrentPeb()->NtGlobalFlag & FLG_LDR_TOP_DOWN) &&
        !(NtHeaders->FileHeader.Characteristics & IMAGE_FILE_RELOCS_STRIPPED)) {

        // The image was loaded at its preferred base and has relocs.  Map
        // it again using the default ViewBase.  This will collide with the
        // initial mapping, and force the mm to choose a new base address.
        // On Win64, the mm will do this top-down, forcing the DLL to
        // be mapped above 4gb if possible, to catch pointer truncations.
        PCUNICODE_STRING SystemDll;
        PVOID AlternateViewBase;
        ULONG_PTR AlternateViewSize;
        NTSTATUS AlternateSt;
        BOOLEAN LoadTopDown;

        LoadTopDown = TRUE;
        SystemDll = &User32String;
        if (RtlEqualUnicodeString(&BaseDllName, &User32String, TRUE)) {
            LoadTopDown = FALSE;
        } else {
            SystemDll = &Kernel32String;
            if (RtlEqualUnicodeString(&BaseDllName, &Kernel32String, TRUE)) {
                LoadTopDown = FALSE;
            }
        }
        if (LoadTopDown) {
            //
            // Map the image again.  It will collide with itself, and
            // the 64-bit mm will find a new base address for it,
            // working top-down
            //
            AlternateViewBase = NULL;
            AlternateViewSize = 0;
            ArbitraryUserPointer = Teb->NtTib.ArbitraryUserPointer;
            Teb->NtTib.ArbitraryUserPointer = (PVOID)FullDllName.Buffer;
            AlternateSt = NtMapViewOfSection(
                    Section,
                    NtCurrentProcess(),
                    (PVOID *)&AlternateViewBase,
                    0L,
                    0L,
                    NULL,
                    &AlternateViewSize,
                    ViewShare,
                    0L,
                    PAGE_READWRITE
                    );
            Teb->NtTib.ArbitraryUserPointer = ArbitraryUserPointer;
            if (NT_SUCCESS(AlternateSt)) {
                //
                // Success.  Unmap the original image from the low
                // part of the address space and keep the new mapping
                // which was allocated top-down.
                //
                NtUnmapViewOfSection(NtCurrentProcess(), ViewBase);
                ViewSize = AlternateViewSize;
                ViewBase = AlternateViewBase;
                NtHeaders = RtlImageNtHeader(ViewBase);
                st = AlternateSt;
                if ( !NtHeaders ) {
                    NtUnmapViewOfSection(NtCurrentProcess(),AlternateViewBase);
                    NtUnmapViewOfSection(NtCurrentProcess(),ViewBase);
                    st = STATUS_INVALID_IMAGE_FORMAT;
                    goto Exit;
                }
            }
        }
    }
#endif

#if defined (BUILD_WOW6432)
    if (NtHeaders->OptionalHeader.SectionAlignment < NATIVE_PAGE_SIZE) {
        if (!NT_SUCCESS(stTemp = LdrpWx86FormatVirtualImage(&FullDllName, (PIMAGE_NT_HEADERS32)NtHeaders, ViewBase))) {
            st = stTemp;
            DbgPrintEx(
                DPFLTR_LDR_ID,
                LDR_ERROR_DPFLTR,
                "LDR: %s - Call to LdrpWx86FormatVirtualImage(%ls) failed with status 0x%08lx\n",
                __FUNCTION__,
                FullDllName.Buffer,
                st);

            goto Exit;
        }
    }
#endif

    Cor20Header = RtlImageDirectoryEntryToData(ViewBase,
                                               TRUE,
                                               IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR,
                                               &Cor20HeaderSize);
    OriginalViewBase = ViewBase;

    //
    // if this is an IL_ONLY image, then validate the image now
    //

    if ((Cor20Header != NULL) && 
        ((Cor20Header->Flags & COMIMAGE_FLAGS_ILONLY) != 0)) {
        
        // This is wacky but code later on depends on the fact that st *was* STATUS_IMAGE_MACHINE_TYPE_MISMATCH
        // and got overwritten with STATUS_SUCCESS.  This in effect means that COR images can never have
        // relocation information.  -mgrier 5/21/2001, XP Bug #400007.
        st = LdrpCheckCorImage (Cor20Header,
                                &FullDllName,
                                &ViewBase,
                                &Cor20ILOnly);

        if (!NT_SUCCESS(st))
            goto Exit;
    }


#if DBG
    if (LdrpDisplayLoadTime) {
        NtQueryPerformanceCounter(&MapEndTime, NULL);
        MapElapsedTime.QuadPart = MapEndTime.QuadPart - MapBeginTime.QuadPart;
        DbgPrint("Map View of Section Time %ld %ws\n", MapElapsedTime.LowPart, DllName);
    }
#endif

    //
    // Allocate a data table entry.
    //

    Entry = LdrpAllocateDataTableEntry(ViewBase);

    if (!Entry) {
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s - failed to allocate new data table entry for %p\n",
            __FUNCTION__,
            ViewBase);

        st = STATUS_NO_MEMORY;
        goto Exit;
    }

    Entry->Flags = 0;

    if (StaticLink)
        Entry->Flags |= LDRP_STATIC_LINK;

    if (Redirected)
        Entry->Flags |= LDRP_REDIRECTED;

    Entry->LoadCount = 0;

    Entry->FullDllName = FullDllName;
    FullDllName.Length = 0;
    FullDllName.MaximumLength = 0;
    FullDllName.Buffer = NULL;

    Entry->BaseDllName = BaseDllName;
    BaseDllName.Length = 0;
    BaseDllName.MaximumLength = 0;
    BaseDllName.Buffer = NULL;

    Entry->EntryPoint = LdrpFetchAddressOfEntryPoint(Entry->DllBase);

#if LDRDBG
    if (ShowSnaps)
        DbgPrint(
            "LDR: LdrpMapDll: Full Name %wZ, Base Name %wZ\n",
            &Entry->FullDllName,
            &Entry->BaseDllName);
#endif

    LdrpInsertMemoryTableEntry(Entry);

    LdrpSendDllLoadedNotifications(Entry, (st == STATUS_IMAGE_NOT_AT_BASE) ? LDR_DLL_LOADED_FLAG_RELOCATED : 0);

    if ( st == STATUS_IMAGE_MACHINE_TYPE_MISMATCH ) {

        PIMAGE_NT_HEADERS ImageHeader = RtlImageNtHeader( NtCurrentPeb()->ImageBaseAddress );

        //
        // apps compiled for NT 3.x and below can load cross architecture
        // images
        //

        ErrorStatus = STATUS_SUCCESS;
        ErrorResponse = ResponseCancel;

        if ( ImageHeader->OptionalHeader.MajorSubsystemVersion <= 3 ) {

            Entry->EntryPoint = 0;

            //
            // Hard Error Time
            //

            //
            // Its error time...
            //

            ErrorParameters[0] = (ULONG_PTR)&FullDllName;

            ErrorStatus = NtRaiseHardError(
                            STATUS_IMAGE_MACHINE_TYPE_MISMATCH,
                            1,
                            1,
                            ErrorParameters,
                            OptionOkCancel,
                            &ErrorResponse
                            );
            }
        if ( NT_SUCCESS(ErrorStatus) && ErrorResponse == ResponseCancel ) {


#if defined(_AMD64_) // || defined(_IA64_)


            RtlRemoveInvertedFunctionTable(&LdrpInvertedFunctionTable,
                                           Entry->DllBase);

#endif

            RemoveEntryList(&Entry->InLoadOrderLinks);
            RemoveEntryList(&Entry->InMemoryOrderLinks);
            RemoveEntryList(&Entry->HashLinks);
            LdrpDeallocateDataTableEntry(Entry);

            if ( ImageHeader->OptionalHeader.MajorSubsystemVersion <= 3 ) {
                if ( LdrpInLdrInit ) {
                    LdrpFatalHardErrorCount++;
                    }
                }
            st = STATUS_INVALID_IMAGE_FORMAT;
            goto Exit;
            }
        }
    else {
        if (NtHeaders->FileHeader.Characteristics & IMAGE_FILE_DLL) {
            Entry->Flags |= LDRP_IMAGE_DLL;
            }

        if (!(Entry->Flags & LDRP_IMAGE_DLL)) {
            Entry->EntryPoint = 0;
            }
        }

    *LdrDataTableEntry = Entry;

    if (st == STATUS_IMAGE_NOT_AT_BASE) {

        Entry->Flags |= LDRP_IMAGE_NOT_AT_BASE;

        //
        // now find the colliding dll. If we can not find a dll,
        // then the colliding dll must be dynamic memory
        //

        ImageBase = (PUCHAR)NtHeaders->OptionalHeader.ImageBase;
        ImageBounds = ImageBase + ViewSize;

        CollidingDllFound = FALSE;

        ScanHead = &NtCurrentPeb()->Ldr->InLoadOrderModuleList;
        ScanNext = ScanHead->Flink;

        while ( ScanNext != ScanHead ) {
            ScanEntry = CONTAINING_RECORD(ScanNext, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
            ScanNext = ScanNext->Flink;

            ScanBase = (PUCHAR)ScanEntry->DllBase;
            ScanTop = ScanBase + ScanEntry->SizeOfImage;

            //
            // when we unload, the memory order links flink field is nulled.
            // this is used to skip the entry pending list removal.
            //

            if ( !ScanEntry->InMemoryOrderLinks.Flink ) {
                continue;
                }

            //
            // See if the base address of the scan image is within the relocating dll
            // or if the top address of the scan image is within the relocating dll
            //

            if ( (ImageBase >= ScanBase && ImageBase <= ScanTop)

                 ||

                 (ImageBounds >= ScanBase && ImageBounds <= ScanTop)

                 ||

                 (ScanBase >= ImageBase && ScanBase <= ImageBounds)

                 ){

                CollidingDllFound = TRUE;
                CollidingDll = ScanEntry->FullDllName;
                break;
                }
            }

        if ( !CollidingDllFound ) {
            RtlInitUnicodeString(&CollidingDll, L"Dynamically Allocated Memory");
            }

#if DBG
        if ( BeginTime.LowPart || BeginTime.HighPart ) {
            DbgPrint(
                "\nLDR: %s Relocating Image Name %ws\n",
                __FUNCTION__,
                DllName
                );
        }
        LdrpSectionRelocates++;
#endif

        if (Entry->Flags & LDRP_IMAGE_DLL) {

            BOOLEAN AllowRelocation;
            PCUNICODE_STRING SystemDll;

            if (!(NtHeaders->FileHeader.Characteristics & IMAGE_FILE_RELOCS_STRIPPED)) {
                PVOID pBaseRelocs;
                ULONG BaseRelocCountBytes = 0;

                //
                // If the image doesn't have the reloc stripped bit set and there's no
                // relocs in the data directory, allow this through.  This is probably
                // a pure forwarder dll or data w/o relocs.
                //

                pBaseRelocs = RtlImageDirectoryEntryToData(
                        ViewBase, TRUE, IMAGE_DIRECTORY_ENTRY_BASERELOC, &BaseRelocCountBytes);

                if (!pBaseRelocs && !BaseRelocCountBytes)
                    goto NoRelocNeeded;
            }

            //
            // decide whether or not to allow the relocation
            // certain system dll's like user32 and kernel32 are not relocatable
            // since addresses within these dll's are not always stored per process
            // do not allow these dll's to be relocated
            //

            AllowRelocation = TRUE;
            SystemDll = &User32String;
            if ( RtlEqualUnicodeString(&Entry->BaseDllName, SystemDll, TRUE)) {
                AllowRelocation = FALSE;
            } else {
                SystemDll = &Kernel32String;
                if (RtlEqualUnicodeString(&Entry->BaseDllName, SystemDll, TRUE))
                    AllowRelocation = FALSE;
            }

            if ( !AllowRelocation && KnownDll ) {

                //
                // totally disallow the relocation since this is a knowndll
                // that matches our system binaries and is being relocated
                //

                //
                // Hard Error Time
                //

                ErrorParameters[0] = (ULONG_PTR)SystemDll;
                ErrorParameters[1] = (ULONG_PTR)&CollidingDll;

                NtRaiseHardError(
                    STATUS_ILLEGAL_DLL_RELOCATION,
                    2,
                    3,
                    ErrorParameters,
                    OptionOk,
                    &ErrorResponse);

                if ( LdrpInLdrInit ) {
                    LdrpFatalHardErrorCount++;
                }

                st = STATUS_CONFLICTING_ADDRESSES;
                goto skipreloc;
            }

            st = LdrpSetProtection(ViewBase, FALSE, StaticLink );
            if (NT_SUCCESS(st)) {
                __try {
                    st = LdrRelocateImage(ViewBase,
                                "LDR",
                                STATUS_SUCCESS,
                                STATUS_CONFLICTING_ADDRESSES,
                                STATUS_INVALID_IMAGE_FORMAT);
                } __except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
                    st = GetExceptionCode();
                }

                if (NT_SUCCESS(st)) {
                    //
                    // If we did relocations, then map the section again.
                    // this will force the debug event
                    //

                    //
                    // arrange for debugger to pick up the image name
                    //

                    ArbitraryUserPointer = Teb->NtTib.ArbitraryUserPointer;
                    Teb->NtTib.ArbitraryUserPointer = (PVOID)FullDllName.Buffer;

                    st = NtMapViewOfSection(
                        Section,
                        NtCurrentProcess(),
                        (PVOID *)&ViewBase,
                        0L,
                        0L,
                        NULL,
                        &ViewSize,
                        ViewShare,
                        0L,
                        PAGE_READWRITE);

                    if ((st != STATUS_CONFLICTING_ADDRESSES) && !NT_SUCCESS(st)) {
                        DbgPrintEx(
                            DPFLTR_LDR_ID,
                            LDR_ERROR_DPFLTR,
                            "[%x,%x] LDR: Failed to map view of section; ntstatus = %x\n",
                            HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess),
                            HandleToULong(NtCurrentTeb()->ClientId.UniqueThread),
                            st);

                        goto Exit;
                    }

                    Teb->NtTib.ArbitraryUserPointer = ArbitraryUserPointer;

                    st = LdrpSetProtection(ViewBase, TRUE, StaticLink);
                }
            }
skipreloc:
            //
            // if the set protection failed, or if the relocation failed, then
            // remove the partially loaded dll from the lists and clear entry
            // that it has been freed.
            //

            if ( !NT_SUCCESS(st) ) {

#if defined(_AMD64_) // || defined(_IA64_)


                RtlRemoveInvertedFunctionTable(&LdrpInvertedFunctionTable,
                                               Entry->DllBase);

#endif

                RemoveEntryList(&Entry->InLoadOrderLinks);
                RemoveEntryList(&Entry->InMemoryOrderLinks);
                RemoveEntryList(&Entry->HashLinks);
                if (ShowSnaps) {
                    DbgPrint("LDR: Fixups unsuccessfully re-applied @ %p\n",
                           ViewBase);
                }
                goto Exit;
            }

            if (ShowSnaps) {                
                DbgPrint("LDR: Fixups successfully re-applied @ %p\n",
                       ViewBase);               
            }
        } else {
NoRelocNeeded:
            st = STATUS_SUCCESS;

            //
            // arrange for debugger to pick up the image name
            //

            ArbitraryUserPointer = Teb->NtTib.ArbitraryUserPointer;
            Teb->NtTib.ArbitraryUserPointer = (PVOID)FullDllName.Buffer;

            st = NtMapViewOfSection(
                Section,
                NtCurrentProcess(),
                (PVOID *)&ViewBase,
                0L,
                0L,
                NULL,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_READWRITE
                );
            Teb->NtTib.ArbitraryUserPointer = ArbitraryUserPointer;

            // If the thing was relocated, we get back the failure status STATUS_CONFLICTING_ADDRESSES
            // but of all the strange things, the relocations aren't done.  I have questions in to folks
            // asking about this behavior but who knows how many legacy apps depend on dlls that statically
            // link to EXEs which from time to time are not loaded at their default addresses.  -mgrier 4/9/2001
            if ((st != STATUS_CONFLICTING_ADDRESSES) && !NT_SUCCESS(st))
                DbgPrintEx(
                    DPFLTR_LDR_ID,
                    LDR_ERROR_DPFLTR,
                    "[%x,%x] LDR: %s - NtMapViewOfSection on no reloc needed dll failed with status %x\n",
                    HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess),
                    HandleToULong(NtCurrentTeb()->ClientId.UniqueThread),
                    __FUNCTION__,
                    st);
            else
                st = STATUS_SUCCESS;

            if (ShowSnaps)
                DbgPrint("LDR: Fixups won't be re-applied to non-Dll @ %p\n", ViewBase);
        }
    }

    //
    // if this is NOT an IL_ONLY image, then validate the image now after applying the
    // fixups
    //

    if ((Cor20Header != NULL) && 
        ((Cor20Header->Flags & COMIMAGE_FLAGS_ILONLY) == 0)) {
        
        st = LdrpCheckCorImage (Cor20Header,
                                &FullDllName,
                                &ViewBase,
                                &Cor20ILOnly);
        if (!NT_SUCCESS (st)) {
            goto Exit;
        }
    }

    if (Cor20ILOnly) {
        Entry->Flags |= LDRP_COR_IMAGE;
    }

    if (ViewBase != OriginalViewBase) {
        Entry->Flags |= LDRP_COR_OWNS_UNMAP;
    }

#if defined (_ALPHA_)
    //
    // Find and apply Alpha architecture fixups for this dll
    //
    if (Entry->Flags & LDRP_IMAGE_DLL)
        AlphaFindArchitectureFixups(NtHeaders, ViewBase, StaticLink);
#endif

#if defined(_X86_)
    if ( LdrpNumberOfProcessors > 1 && (Entry->Flags & LDRP_IMAGE_DLL) ) {
        LdrpValidateImageForMp(Entry);
        }
#endif

    ViewBase = NULL;

Exit:
    if (ViewBase != NULL) {
        if (Cor20ILOnly)
            LdrpCorUnloadImage(ViewBase);

        if (ViewBase == OriginalViewBase)
            NtUnmapViewOfSection(NtCurrentProcess(),ViewBase);
    }

    if (Section != NULL)
        NtClose(Section);

    if (AppCompatDllName != NULL)
        (*RtlFreeStringRoutine)(AppCompatDllName);

    if (FullDllName.Buffer != NULL)
        LdrpFreeUnicodeString(&FullDllName);

#if DBG
    if (!NT_SUCCESS(st) && (ShowSnaps || st != STATUS_DLL_NOT_FOUND))
        DbgPrint("LDR: %s(%ws) failing 0x%lx\n", __FUNCTION__, DllName, st);
#endif

    return st;
}

#if defined (_ALPHA_)

#define asm __asm
#pragma intrinsic (__asm)

VOID
AlphaApplyArchitectureFixups(
    IN PIMAGE_ARCHITECTURE_HEADER ArchHeader,
    IN ULONG ArchHeaderByteSize,
    IN ULONG_PTR BaseAddr
    )

/*++

Routine Description:

    This applies the Alpha architecture enhancement fixups. If an image contains
    a .arch section, then the image/dll, if running on a newer chip, may
    be eligible to take advantage of new instructions. Check the replacement
    constraints vs. chip capabilities and apply fixup if warranted.


Arguments:

    ArchHeader - Supplies a pointer to the first architecture specific
        fixup header record.

    ArchHeaderByteSize - Supplies the size (in bytes) of the
        Architecture headers to be processed.

    BaseAddr - Base address to be added to RVA's in architecture section

Return Value:

    None.

--*/

{
    ULONG Count, Entry;
    ULONG SystemAmask;
    ULONG ReplacementInstruction;
    PIMAGE_ARCHITECTURE_HEADER ArchHeaderEnd;
    PIMAGE_ARCHITECTURE_ENTRY ArchEntry;

    // Figure out the end value for ArchHeader

    ArchHeaderEnd = (PIMAGE_ARCHITECTURE_HEADER)((PCHAR)ArchHeader + ArchHeaderByteSize);
    //
    // Get the architecture mask and implementation version
    // of the running system
    //

    while (*(PULONGLONG)ArchHeader == 0L)
        ArchHeader++; // skip over quadwords of zero

    SystemAmask = ~asm("amask $16, $0", -1);

    while ((*(PULONGLONG)ArchHeader != 0xffffffffL) && (ArchHeader < ArchHeaderEnd)) {
        if (*(PULONGLONG)ArchHeader != 0L) { // maybe zero's intermixed
#if DBG && ARCH_DBG
            DbgPrint("ARCH: Amask=0x%x, Current Header=0x%08x, Shift=%d, Value=%d\n",
                    SystemAmask, *ArchHeader,
                    ArchHeader->AmaskShift, ArchHeader->AmaskValue);
#endif
            if (((SystemAmask >> ArchHeader->AmaskShift) & 1) != ArchHeader->AmaskValue) {

                //
                // fixup needed
                //

                PIMAGE_ARCHITECTURE_ENTRY ArchEntry;

                ArchEntry = (PIMAGE_ARCHITECTURE_ENTRY)(ArchHeader->FirstEntryRVA + BaseAddr);

                while (*(PULONGLONG)ArchEntry != 0xffffffffL) {

                    if (*(PULONGLONG)ArchEntry != 0L) { // maybe zero's intermixed
#if DBG && ARCH_DBG
                        DbgPrint("ARCH: 0x%08x -> 0x%08x\n",
                                 *(PALPHA_INSTRUCTION)(ArchEntry->FixupInstRVA + BaseAddr),
                                 ArchEntry->NewInst
                                );
#endif
                        *(ULONG *)(ArchEntry->FixupInstRVA + BaseAddr) = ArchEntry->NewInst;
                    }
                    ArchEntry++;
                }
            } // if this header describes fixups for this machine
        }
        ArchHeader++;
    }
}

VOID
AlphaFindArchitectureFixups(
    PIMAGE_NT_HEADERS NtHeaders,
    PVOID ViewBase,
    BOOLEAN StaticLink
    )

/*++

Routine Description:

    This routine runs through a mapped image/dll looking for an architecture
    enhancement section (.arch). If found, it applies the architecture
    fixups.


Arguments:

    NtHeaders   - the NT header for this image or dll.
    ViewBase    - the Mapped view base used for page protection munging.
    StaticLink  - TRUE if this DLL has a static link to it

Return Value:

    None.

--*/

{
    ULONG Size;
    PIMAGE_ARCHITECTURE_HEADER ImageArchData;

    if (NtHeaders->FileHeader.Machine != IMAGE_FILE_MACHINE_ALPHA) {
        //
        // If the image isnt Alpha, don't try to find/apply Alpha fixups.
        // The image may be an x86 image linked with the x86 Watcom
        // linker which stuffed its version number in the .arch directory
        // entry in the image, fooling the Alpha .arch checker.
        //
        return;
    }

    ImageArchData =
        (PIMAGE_ARCHITECTURE_HEADER)RtlImageDirectoryEntryToData(
                                ViewBase,
                                TRUE,
                                IMAGE_DIRECTORY_ENTRY_ARCHITECTURE,
                                &Size
                                );
    if (ImageArchData) {
        NTSTATUS st;

        st = LdrpSetProtection(ViewBase, FALSE, StaticLink); // access to r/w

        if (NT_SUCCESS(st)) {
            AlphaApplyArchitectureFixups(ImageArchData, Size, (ULONG_PTR)ViewBase);
            LdrpSetProtection(ViewBase, TRUE, StaticLink); // back to r/o
        }
    }
}
#endif




//#define SAFER_DEBUGGING
//#define SAFER_ERRORS_ARE_FATAL


NTSTATUS
LdrpCodeAuthzCheckDllAllowed(
    IN PUNICODE_STRING  FileName,
    IN HANDLE           FileImageHandle
    )
/*++

Routine Description:

    This routine dynamically loads ADVAPI32.DLL and obtains entry points
    to the WinSafer sandboxing APIs, so that the trustworthiness of the
    requested library can be determined.  Libraries that are equally
    or greater "trusted" than the Access Token of the process loading
    the library are allowed to be loaded.  Libraries that are less
    trusted than the process will be denied.

    Care must be taken to ensure that this function is kept threadsafe
    without requiring the use of critical sections.  In particular,
    the usage of the variable "AdvApi32ModuleHandleMaster" needs to be
    accessed only through a copy, since it may be changed unexpected by
    another thread.

Arguments:

    FileName - the fully qualified NT filename of the library being loaded.
        The filename will be used to perform path validation checks.

    FileImageHandle - the opened file handle of the library being loaded.
        This handle will be used to read the contents of the library to
        perform size and hash validation checks by WinSafer.

Return Value:

    STATUS_SUCCESS - the library is of equal or greater trustworthiness
        than that process it is being loaded into, and should be allowed.

    STATUS_NOT_FOUND - the library does not have a trust level configured
        and no default rule in in effect (treat same as STATUS_SUCCESS).

    STATUS_ACCESS_DENIED - the library is less trustworthy than the
        process and the load should be denied.

    Other non-success - an error occurred trying to load/determine the
        trust of the library, so the load should be denied.
        (including STATUS_ENTRY_POINT_NOT_FOUND)

--*/
{


#define SAFER_USER_KEY_NAME L"\\Software\\Policies\\Microsoft\\Windows\\Safer\\CodeIdentifiers"

    typedef BOOL (WINAPI *ComputeAccessTokenFromCodeAuthzLevelT) (
        IN SAFER_LEVEL_HANDLE      LevelObject,
        IN HANDLE           InAccessToken         OPTIONAL,
        OUT PHANDLE         OutAccessToken,
        IN DWORD            dwFlags,
        IN LPVOID           lpReserved
        );

    typedef BOOL (WINAPI *IdentifyCodeAuthzLevelWT) (
        IN DWORD                dwCheckFlags,
        IN PSAFER_CODE_PROPERTIES    CodeProperties,
        OUT SAFER_LEVEL_HANDLE        *pLevelObject,
        IN LPVOID               lpReserved
        );

    typedef BOOL (WINAPI *CloseCodeAuthzLevelT) (
        IN SAFER_LEVEL_HANDLE      hLevelObject);

    NTSTATUS Status;
    SAFER_LEVEL_HANDLE hAuthzLevel = NULL;
    SAFER_CODE_PROPERTIES codeproperties;
    DWORD dwCompareResult = 0;
    HANDLE hProcessToken= NULL;
    HANDLE TempAdvApi32Handle = NULL;

    const static SID_IDENTIFIER_AUTHORITY NtAuthority =
            SECURITY_NT_AUTHORITY;
    const static UNICODE_STRING UnicodeSafeBootKeyName =
        RTL_CONSTANT_STRING(L"\\Registry\\MACHINE\\System\\CurrentControlSet\\Control\\SafeBoot\\Option");
    const static UNICODE_STRING UnicodeSafeBootValueName =
        RTL_CONSTANT_STRING(L"OptionValue");
    const static OBJECT_ATTRIBUTES ObjectAttributesSafeBoot =
        RTL_CONSTANT_OBJECT_ATTRIBUTES(&UnicodeSafeBootKeyName, OBJ_CASE_INSENSITIVE);
    const static UNICODE_STRING UnicodeKeyName =
        RTL_CONSTANT_STRING(L"\\Registry\\Machine\\Software\\Policies\\Microsoft\\Windows\\Safer\\CodeIdentifiers");
    const static UNICODE_STRING UnicodeTransparentValueName =
        RTL_CONSTANT_STRING(L"TransparentEnabled");
    const static OBJECT_ATTRIBUTES ObjectAttributesCodeIdentifiers =
        RTL_CONSTANT_OBJECT_ATTRIBUTES(&UnicodeKeyName, OBJ_CASE_INSENSITIVE);
    const static UNICODE_STRING ModuleNameAdvapi =
        RTL_CONSTANT_STRING(L"ADVAPI32.DLL");
    const static ANSI_STRING ProcedureNameIdentify =
        RTL_CONSTANT_STRING("SaferIdentifyLevel");
    const static ANSI_STRING ProcedureNameCompute =
        RTL_CONSTANT_STRING("SaferComputeTokenFromLevel");
    const static ANSI_STRING ProcedureNameClose =
        RTL_CONSTANT_STRING("SaferCloseLevel");

    static volatile HANDLE AdvApi32ModuleHandleMaster = (HANDLE) (ULONG_PTR) -1;
    static IdentifyCodeAuthzLevelWT lpfnIdentifyCodeAuthzLevelW;
    static ComputeAccessTokenFromCodeAuthzLevelT
            lpfnComputeAccessTokenFromCodeAuthzLevel;
    static CloseCodeAuthzLevelT lpfnCloseCodeAuthzLevel;


    PIMAGE_NT_HEADERS NtHeader;

    NtHeader = RtlImageNtHeader(NtCurrentPeb()->ImageBaseAddress);

    // Check for NULL header.

    if (!NtHeader) {
        return STATUS_SUCCESS;
    }

    // Continue only if this is a windows subsystem app. We run into all sorts
    // of problems because kernel32 might not initialize for others.

    if (!((NtHeader->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_GUI) ||
        (NtHeader->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_CUI))) {
        return STATUS_SUCCESS;
    }

    //
    // If either of these two cases are true, then we should bail out
    // as quickly as possible because we know that WinSafer evaluations
    // should definitely not occur for this process anymore.
    //
    TempAdvApi32Handle = AdvApi32ModuleHandleMaster;
    if (TempAdvApi32Handle == NULL) {
        // We tried to load ADVAPI32.DLL once before, but failed.
        Status = STATUS_ACCESS_DENIED;
        goto ExitHandler;
    } else if (TempAdvApi32Handle == LongToHandle(-2)) {
        // Indicates that DLL checking should never be done for this process.
        Status = STATUS_SUCCESS;
        goto ExitHandler;
    }


    //
    // Open a handle to the current process's access token.
    // We care only about the process token, and not the
    // thread impersonation token.
    //
    Status = NtOpenProcessToken(
                    NtCurrentProcess(),
                    TOKEN_QUERY,
                    &hProcessToken);
    if (!NT_SUCCESS(Status)) {
#ifdef SAFER_ERRORS_ARE_FATAL
        AdvApi32ModuleHandleMaster = NULL;
        Status = STATUS_ACCESS_DENIED;
#else
        AdvApi32ModuleHandleMaster = LongToHandle(-2);
        Status = STATUS_SUCCESS;
#endif
        goto ExitHandler;
    }


    //
    // If this is our first time through here, then we need to
    // load ADVAPI32.DLL and get pointers to our functions.
    //
    if (TempAdvApi32Handle == LongToHandle(-1))
    {
        static LONG LoadInProgress = 0;


        //
        // We need to prevent multiple threads from simultaneously
        // getting stuck and trying to load advapi at the same time.
        //
        if (InterlockedCompareExchange(&LoadInProgress, 1, 0) != 0) {
            Status = STATUS_SUCCESS;
            goto ExitHandler2;
        }

        //
        // Check if this process's access token is running as
        // the Local SYSTEM account, and disable enforcement if so.
        //
        {
            BYTE tokenuserbuff[sizeof(TOKEN_USER) + 128];
            PTOKEN_USER ptokenuser = (PTOKEN_USER) tokenuserbuff;
            BYTE localsystembuff[128];
            PSID LocalSystemSid = (PSID) localsystembuff;
            ULONG ulReturnLength;


            Status = NtQueryInformationToken(
                            hProcessToken, TokenUser,
                            tokenuserbuff, sizeof(tokenuserbuff),
                            &ulReturnLength);
            if (NT_SUCCESS(Status)) {
                Status = RtlInitializeSid(
                            LocalSystemSid,
                            (PSID_IDENTIFIER_AUTHORITY) &NtAuthority, 1);
                ASSERTMSG("InitializeSid should not fail.", NT_SUCCESS(Status));
                *RtlSubAuthoritySid(LocalSystemSid, 0) = SECURITY_LOCAL_SYSTEM_RID;

                if (RtlEqualSid(ptokenuser->User.Sid, LocalSystemSid)) {
                    goto FailSuccessfully;
                }
            }
        }


        //
        // If we are booting in safe mode and the user is a member of
        // the local Administrators group, then disable enforcement.
        // Notice that Windows itself does not perform any implicit
        // restriction of only allowing Administrators to log in during
        // Safe mode boot, so we must perform the test ourself.
        //
        {
            HANDLE hKeySafeBoot;
            BYTE QueryBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 64];
            PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo =
                (PKEY_VALUE_PARTIAL_INFORMATION) QueryBuffer;
            DWORD dwActualSize;
            BOOLEAN bSafeModeBoot = FALSE;

            // We open the key for SET access (in addition to QUERY)
            // because only Administrators should be able to modify values
            // under this key.  This allows us to combine our test of
            // being an Administrator and having booted in Safe mode.
            Status = NtOpenKey(&hKeySafeBoot, KEY_QUERY_VALUE | KEY_SET_VALUE,
                               (POBJECT_ATTRIBUTES) &ObjectAttributesSafeBoot);
            if (NT_SUCCESS(Status)) {
                Status = NtQueryValueKey(
                            hKeySafeBoot,
                            (PUNICODE_STRING) &UnicodeSafeBootValueName,
                            KeyValuePartialInformation,
                            pKeyValueInfo,
                            sizeof(QueryBuffer),
                            &dwActualSize);
                NtClose(hKeySafeBoot);
                if (NT_SUCCESS(Status)) {
                    if (pKeyValueInfo->Type == REG_DWORD &&
                        pKeyValueInfo->DataLength == sizeof(DWORD) &&
                        *((PDWORD) pKeyValueInfo->Data) > 0) {
                        bSafeModeBoot = TRUE;
                    }
                }
            }

            if (bSafeModeBoot) {
FailSuccessfully:
                AdvApi32ModuleHandleMaster = LongToHandle(-2);
                Status = STATUS_SUCCESS;
                goto ExitHandler2;
            }
        }



        //
        // Allow a way for policy to enable whether transparent
        // enforcement should be enabled or not (default to disable).
        // Note that the following values have meanings:
        //      0 = Transparent WinSafer enforcement disabled.
        //      1 = means enable transparent EXE enforcement
        //     >1 = means enable transparent EXE and DLL enforcement.
        //
        {
            // BUG 240635: change to use existence of policy instead.
            HANDLE hKeyEnabled;
            BYTE QueryBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 64];
            PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo =
                (PKEY_VALUE_PARTIAL_INFORMATION) QueryBuffer;
            DWORD dwActualSize;
            BOOLEAN bPolicyEnabled = FALSE;

            Status = NtOpenKey(&hKeyEnabled, KEY_QUERY_VALUE,
                               (POBJECT_ATTRIBUTES) &ObjectAttributesCodeIdentifiers);
            if (NT_SUCCESS(Status)) {
                Status = NtQueryValueKey(
                            hKeyEnabled,
                            (PUNICODE_STRING) &UnicodeTransparentValueName,
                            KeyValuePartialInformation,
                            pKeyValueInfo, sizeof(QueryBuffer), &dwActualSize);
                NtClose(hKeyEnabled);
                if (NT_SUCCESS(Status)) {
                    if (pKeyValueInfo->Type == REG_DWORD &&
                        pKeyValueInfo->DataLength == sizeof(DWORD) &&
                        *((PDWORD) pKeyValueInfo->Data) > 1) {
                        bPolicyEnabled = TRUE;
                    }
                }
            }


            //
            // There was no machine policy. Check if user policy is enabled.
            //

            if (!bPolicyEnabled) {
                UNICODE_STRING CurrentUserKeyPath;
                UNICODE_STRING SubKeyNameUser;
                OBJECT_ATTRIBUTES ObjectAttributesUser;

                //
                // Get the prefix for the user key.
                //

                Status = RtlFormatCurrentUserKeyPath( &CurrentUserKeyPath );

                if (NT_SUCCESS( Status ) ) {

                    SubKeyNameUser.Length = 0;
                    SubKeyNameUser.MaximumLength = CurrentUserKeyPath.Length + 
                                                   sizeof(WCHAR) + 
                                                   sizeof(SAFER_USER_KEY_NAME); 

                    //
                    // Allocate memory big enough to hold the unicode string.
                    //

                    SubKeyNameUser.Buffer = RtlAllocateHeap( 
                                                RtlProcessHeap(),
                                                MAKE_TAG( TEMP_TAG ),
                                                SubKeyNameUser.MaximumLength);

                    if (SubKeyNameUser.Buffer != NULL) {

                        //
                        // Copy the prefix into the string.
                        // This is of the type Registry\S-1-5-21-xxx-xxx-xxx-xxx.
                        //

                        Status = RtlAppendUnicodeStringToString(
                                    &SubKeyNameUser, 
                                    &CurrentUserKeyPath );

                        if (NT_SUCCESS( Status ) ) {

                            //
                            // Append the Safer suffix.
                            //

                            Status = RtlAppendUnicodeToString( 
                                         &SubKeyNameUser,
                                         SAFER_USER_KEY_NAME );

                            if (NT_SUCCESS( Status ) ) {

                                InitializeObjectAttributes(
                                    &ObjectAttributesUser,
                                    &SubKeyNameUser,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL
                                );

                                Status = NtOpenKey( &hKeyEnabled,KEY_QUERY_VALUE,
                                             (POBJECT_ATTRIBUTES) &ObjectAttributesUser);

                                if (NT_SUCCESS(Status)) {
                                    Status = NtQueryValueKey(
                                                hKeyEnabled,
                                                (PUNICODE_STRING) &UnicodeTransparentValueName,
                                                KeyValuePartialInformation,
                                                pKeyValueInfo, sizeof(QueryBuffer), &dwActualSize);

                                    if (NT_SUCCESS(Status)) {
                                        if (pKeyValueInfo->Type == REG_DWORD &&
                                            pKeyValueInfo->DataLength == sizeof(DWORD) &&
                                            *((PDWORD) pKeyValueInfo->Data) > 1) {
                                            bPolicyEnabled = TRUE;
                                        }
                                    }
                                }
                            }

                        }
                        RtlFreeHeap(RtlProcessHeap(), 0, SubKeyNameUser.Buffer);
                    }
                    RtlFreeUnicodeString( &CurrentUserKeyPath );
                }
            }



            if (!bPolicyEnabled) {
                goto FailSuccessfully;
            }
        }


        //
        // Finally load the library.  We'll pass a special flag in
        // DllCharacteristics to eliminate WinSafer checking on advapi
        // itself, but that (currently) doesn't affect dependent DLLs
        // so we still depend on the above LoadInProgress flag to
        // prevent unintended recursion.
        //
        {
            // BUG 241835: the WinSafer supression doesn't affect dependencies.
            ULONG DllCharacteristics = IMAGE_FILE_SYSTEM;
            Status = LdrLoadDll(UNICODE_NULL,
                                &DllCharacteristics,  // prevents recursion too
                                (PUNICODE_STRING) &ModuleNameAdvapi,
                                &TempAdvApi32Handle);
            if (!NT_SUCCESS(Status)) {
                #if DBG
                DbgPrint("LDR: AuthzCheck: load failure on advapi (Status=%d) inside %d for %wZ\n",
                         Status, HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess), FileName);
                #endif
                AdvApi32ModuleHandleMaster = NULL;
                Status = STATUS_ENTRYPOINT_NOT_FOUND;
                goto ExitHandler2;
            }
        }



        //
        // Get function pointers to the APIs that we'll need.  If we fail
        // to get pointers for any of them, then just unload advapi and
        // ignore all future attempts to load it within this process.
        //
        Status = LdrpGetProcedureAddress(
                TempAdvApi32Handle,
                (PANSI_STRING) &ProcedureNameIdentify,
                0,
                (PVOID*)&lpfnIdentifyCodeAuthzLevelW, 
                FALSE);

        if (!NT_SUCCESS(Status) || !lpfnIdentifyCodeAuthzLevelW) {
            #if DBG
            DbgPrint("LDR: AuthzCheck: advapi getprocaddress identify (Status=%X) inside %d for %wZ\n",
                     Status, HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess), FileName);
            #endif
            LdrUnloadDll(TempAdvApi32Handle);
            AdvApi32ModuleHandleMaster = NULL;
            Status = STATUS_ENTRYPOINT_NOT_FOUND;
            goto ExitHandler2;
        }

        Status = LdrpGetProcedureAddress(
                TempAdvApi32Handle,
                (PANSI_STRING) &ProcedureNameCompute,
                0,
                (PVOID*)&lpfnComputeAccessTokenFromCodeAuthzLevel,
                FALSE);

        if (!NT_SUCCESS(Status) ||
            !lpfnComputeAccessTokenFromCodeAuthzLevel) {
            #if DBG
            DbgPrint("LDR: AuthzCheck: advapi getprocaddress compute (Status=%X) inside %d for %wZ\n",
                     Status, HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess), FileName);
            #endif
            LdrUnloadDll(TempAdvApi32Handle);
            AdvApi32ModuleHandleMaster = NULL;
            Status = STATUS_ENTRYPOINT_NOT_FOUND;
            goto ExitHandler2;
        }

        Status = LdrpGetProcedureAddress(
                TempAdvApi32Handle,
                (PANSI_STRING) &ProcedureNameClose,
                0,
                (PVOID*)&lpfnCloseCodeAuthzLevel,
                FALSE);

        if (!NT_SUCCESS(Status) || !lpfnCloseCodeAuthzLevel) {
            #if DBG
            DbgPrint("LDR: AuthzCheck: advapi getprocaddress close (Status=%X) inside %d for %wZ\n",
                     Status, HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess), FileName);
            #endif
            LdrUnloadDll(TempAdvApi32Handle);
            AdvApi32ModuleHandleMaster = NULL;
            Status = STATUS_ENTRYPOINT_NOT_FOUND;
            goto ExitHandler2;
        }
        AdvApi32ModuleHandleMaster = TempAdvApi32Handle;
    }


    //
    // Prepare the code properties struct.
    //
    RtlZeroMemory(&codeproperties, sizeof(codeproperties));
    codeproperties.cbSize = sizeof(codeproperties);
    codeproperties.dwCheckFlags =
            (SAFER_CRITERIA_IMAGEPATH | SAFER_CRITERIA_IMAGEHASH |
             SAFER_CRITERIA_IMAGEPATH_NT);
    ASSERTMSG("FileName not null terminated",
              FileName->Buffer[FileName->Length / sizeof(WCHAR)] == UNICODE_NULL);
    codeproperties.ImagePath = FileName->Buffer;
    codeproperties.hImageFileHandle = FileImageHandle;


    //
    // Ask the system to find the Authorization Level that classifies it.
    //
    ASSERT(lpfnIdentifyCodeAuthzLevelW != NULL);
    if (lpfnIdentifyCodeAuthzLevelW(
            1,                      // 1 structure
            &codeproperties,        // details to identify
            &hAuthzLevel,           // Safer level
            NULL))                  // reserved.
    {
        //
        // We found an Authorization Level applicable to this application.
        // See if this Level represents something less trusted than us.
        //

        ASSERT(lpfnComputeAccessTokenFromCodeAuthzLevel != NULL);
        if (!lpfnComputeAccessTokenFromCodeAuthzLevel(
                hAuthzLevel,                // Safer Level
                hProcessToken,              // source token.
                NULL,                       // output token not used for compare.
                SAFER_TOKEN_COMPARE_ONLY,    // we want to compare
                &dwCompareResult))          // reserved
        {
            // failed to compare, for some reason.
            #if DBG
            DbgPrint("LDR: AuthzCheck: compute failed in %d for %wZ\n",
                     HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess), FileName);
            #endif
            Status = STATUS_ACCESS_DENIED;
        } else if (dwCompareResult == -1) {
            // less privileged, deny access.
            #ifdef SAFER_DEBUGGING
            DbgPrint("LDR: AuthzCheck: compute access denied in %d for %wZ\n",
                     HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess), FileName);
            #endif
            Status = STATUS_ACCESS_DENIED;
        } else {
            // greater or equally privileged, allow access to load.
            #ifdef SAFER_DEBUGGING
            DbgPrint("LDR: AuthzCheck: compute access ok in %d for %wZ\n",
                     HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess), FileName);
            #endif
            Status = STATUS_SUCCESS;
        }

        ASSERT(lpfnCloseCodeAuthzLevel != NULL);
        lpfnCloseCodeAuthzLevel(hAuthzLevel);

    } else {
        // No authorization level found for this DLL, and the
        // policy does not have a Default Level in effect.
        Status = STATUS_NOT_FOUND;
    }

ExitHandler2:
    NtClose(hProcessToken);

ExitHandler:
    return Status;
}




NTSTATUS
LdrpCreateDllSection(
    IN PUNICODE_STRING NtFullDllName,
    IN HANDLE DllFile,
    IN PUNICODE_STRING BaseName,
    IN PULONG DllCharacteristics OPTIONAL,
    OUT PHANDLE SectionHandle
    )
{
    HANDLE File;
    HANDLE Section;
    NTSTATUS st;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;
    SECTION_IMAGE_INFORMATION ImageInformation;

    if ( !DllFile ) {
        //
        // Since ntsdk does not search paths well, we can't use
        // relative object names
        //

        InitializeObjectAttributes(
            &ObjectAttributes,
            NtFullDllName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        st = NtOpenFile(
                &File,
                SYNCHRONIZE | FILE_EXECUTE,
                &ObjectAttributes,
                &IoStatus,
                FILE_SHARE_READ | FILE_SHARE_DELETE,
                FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT
                );
        if (!NT_SUCCESS(st)) {
            if (ShowSnaps) {
                DbgPrint("LDR: %s - NtOpenFile failed; status = %x\n", __FUNCTION__, st);
            }
            *SectionHandle = NULL;
            return st;
        }

    } else {
             File = DllFile;
           }



    //
    // Create a memory section of the library file's contents.
    //
    st = NtCreateSection(
            SectionHandle,
            SECTION_MAP_READ | SECTION_MAP_EXECUTE | SECTION_MAP_WRITE | SECTION_QUERY,
            NULL,
            NULL,
            PAGE_EXECUTE,
            SEC_IMAGE,
            File
            );

    if (!NT_SUCCESS(st)) {

        //
        // hard error time
        //

        ULONG_PTR ErrorParameters[1];
        ULONG ErrorResponse;

        *SectionHandle = NULL;
        ErrorParameters[0] = (ULONG_PTR)NtFullDllName;

        NtRaiseHardError(
          STATUS_INVALID_IMAGE_FORMAT,
          1,
          1,
          ErrorParameters,
          OptionOk,
          &ErrorResponse);

        if ( LdrpInLdrInit ) 
            LdrpFatalHardErrorCount++;


#if DBG
        if (st != STATUS_INVALID_IMAGE_NE_FORMAT &&
            st != STATUS_INVALID_IMAGE_LE_FORMAT &&
            st != STATUS_INVALID_IMAGE_WIN_16    &&
            st != STATUS_INVALID_IMAGE_WIN_32    &&
            st != STATUS_INVALID_IMAGE_WIN_64    &&
            LdrpShouldDbgPrintStatus(st)
           ) {
            DbgPrint("LDR: " __FUNCTION__ " - NtCreateSection %wZ failed. Status == 0x%08lx\n",
                     NtFullDllName,
                     st
                    );
        }
#endif
    }

    else {

        if (ARGUMENT_PRESENT(DllCharacteristics) &&
            (*DllCharacteristics & IMAGE_FILE_SYSTEM)) {
#if DBG
            DbgPrint("LDR: WinSafer AuthzCheck on %wZ skipped by request\n",
                     &NtFullDllName);
#endif
        } else {

            //
            //  WOW64 processes should not load 64-bit dlls (advapi32.dll)
            //  but the dll's will get SAFERized when the 
            //  32-bit load kicks in
            //

#if defined(_WIN64)
            if ( UseWOW64 == FALSE ) {
#endif

                //
                // Ask the WinSafer code authorization sandboxing
                // infrastructure if the library load should be permitted.
                //

                //
                // The Winsafer check is moved here since the IMAGE_LOADER_FLAGS_COMPLUS
                // information from the image will be made available shortly.
                //

                //
                // Query the section to determine whether or not this is a .NET image.
                // On failure to query, the error will be returned
                //

                st = NtQuerySection(
                                   *SectionHandle,
                                   SectionImageInformation,
                                   &ImageInformation,
                                   sizeof( ImageInformation ),
                                   NULL
                                   );

                if (!NT_SUCCESS( st )) {
                    NtClose(*SectionHandle);
                    *SectionHandle = NULL;
                    NtClose( File );
                    return st;
                }

                if (((ImageInformation.LoaderFlags & IMAGE_LOADER_FLAGS_COMPLUS) == 0)) {

                    st = LdrpCodeAuthzCheckDllAllowed(NtFullDllName, File);
                    if (st != STATUS_NOT_FOUND && !NT_SUCCESS(st)) {
#if !DBG
                        if (ShowSnaps)
#endif
                        {
                            DbgPrint("LDR: Loading of (%wZ) blocked by WinSafer\n",
                                     &NtFullDllName
                                    );
                        }
                        NtClose(*SectionHandle);
                        *SectionHandle = NULL;
                        NtClose( File );
                        return st;
                    }
                    st = STATUS_SUCCESS;
                }
#if defined(_WIN64)        
            }
#endif
        }
    }

    NtClose( File );
    
    return st;
}

NTSTATUS
LdrpSnapIAT (
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry_Export,
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry_Import,
    IN PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor,
    IN BOOLEAN SnapForwardersOnly
    )

/*++

Routine Description:

    This function snaps the Import Address Table for this
    Import Descriptor.

Arguments:

    LdrDataTableEntry_Export - Information about the image to import from.

    LdrDataTableEntry_Import - Information about the image to import to.

    ImportDescriptor - Contains a pointer to the IAT to snap.

    SnapForwardersOnly - TRUE if just snapping forwarders only.

Return Value:

    Status value

--*/

{
    PPEB Peb;
    NTSTATUS st;
    ULONG ExportSize;
    PIMAGE_EXPORT_DIRECTORY ExportDirectory;
    PIMAGE_THUNK_DATA Thunk, OriginalThunk;
    PSZ ImportName;
    ULONG ForwarderChain;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_SECTION_HEADER NtSection;
    ULONG i, Rva;
    PVOID IATBase;
    SIZE_T IATSize;
    ULONG LittleIATSize;
    ULONG OldProtect;

    Peb = NtCurrentPeb();

    ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData(
                       LdrDataTableEntry_Export->DllBase,
                       TRUE,
                       IMAGE_DIRECTORY_ENTRY_EXPORT,
                       &ExportSize
                       );

    if (!ExportDirectory) {
        KdPrint(("LDR: %wZ doesn't contain an EXPORT table\n", &LdrDataTableEntry_Export->BaseDllName));
        return STATUS_INVALID_IMAGE_FORMAT;
        }

    //
    // Determine the location and size of the IAT.  If the linker did
    // not tell use explicitly, then use the location and size of the
    // image section that contains the import table.
    //

    IATBase = RtlImageDirectoryEntryToData( LdrDataTableEntry_Import->DllBase,
                                            TRUE,
                                            IMAGE_DIRECTORY_ENTRY_IAT,
                                            &LittleIATSize
                                          );
    if (IATBase == NULL) {
        NtHeaders = RtlImageNtHeader( LdrDataTableEntry_Import->DllBase );
        if (! NtHeaders) {
            return STATUS_INVALID_IMAGE_FORMAT;
        }
        NtSection = IMAGE_FIRST_SECTION( NtHeaders );
        Rva = NtHeaders->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_IMPORT ].VirtualAddress;
        if (Rva != 0) {
            for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {
                if (Rva >= NtSection->VirtualAddress &&
                    Rva < (NtSection->VirtualAddress + NtSection->SizeOfRawData)
                   ) {
                    IATBase = (PVOID)
                        ((ULONG_PTR)(LdrDataTableEntry_Import->DllBase) + NtSection->VirtualAddress);

                    LittleIATSize = NtSection->Misc.VirtualSize;
                    if (LittleIATSize == 0) {
                        LittleIATSize = NtSection->SizeOfRawData;
                        }
                    break;
                    }

                ++NtSection;
                }
            }

        if (IATBase == NULL) {
            KdPrint(( "LDR: Unable to unprotect IAT for %wZ (Image Base %p)\n",
                      &LdrDataTableEntry_Import->BaseDllName,
                      LdrDataTableEntry_Import->DllBase
                   ));
            return STATUS_INVALID_IMAGE_FORMAT;
            }
        }
    IATSize = LittleIATSize;

    st = NtProtectVirtualMemory( NtCurrentProcess(),
                                 &IATBase,
                                 &IATSize,
                                 PAGE_READWRITE,
                                 &OldProtect
                               );
    if (!NT_SUCCESS(st)) {
        KdPrint(( "LDR: Unable to unprotect IAT for %wZ (Status %x)\n",
                  &LdrDataTableEntry_Import->BaseDllName,
                  st
               ));
        return st;
        }

    //
    // If just snapping forwarded entries, walk that list
    //
    if (SnapForwardersOnly) {
        ImportName = (PSZ)((ULONG_PTR)LdrDataTableEntry_Import->DllBase + ImportDescriptor->Name);
        ForwarderChain = ImportDescriptor->ForwarderChain;
        while (ForwarderChain != -1) {
            OriginalThunk = (PIMAGE_THUNK_DATA)((ULONG_PTR)LdrDataTableEntry_Import->DllBase +
                            ImportDescriptor->OriginalFirstThunk +
                            (ForwarderChain * sizeof(IMAGE_THUNK_DATA)));
            Thunk = (PIMAGE_THUNK_DATA)((ULONG_PTR)LdrDataTableEntry_Import->DllBase +
                            ImportDescriptor->FirstThunk +
                            (ForwarderChain * sizeof(IMAGE_THUNK_DATA)));
            ForwarderChain = (ULONG) Thunk->u1.Ordinal;
            try {
                st = LdrpSnapThunk(LdrDataTableEntry_Export->DllBase,
                        LdrDataTableEntry_Import->DllBase,
                        OriginalThunk,
                        Thunk,
                        ExportDirectory,
                        ExportSize,
                        TRUE,
                        ImportName
                        );
                Thunk++;
                }
            except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
                st = GetExceptionCode();
                DbgPrintEx(
                    DPFLTR_LDR_ID,
                    LDR_ERROR_DPFLTR,
                    "LDR: %s - caught exception %08lx snapping thunks (#1)\n",
                    __FUNCTION__,
                    st);
                }
            if (!NT_SUCCESS(st) ) {
                break;
                }
            }
        }
    else

    //
    // Otherwise, walk through the IAT and snap all the thunks.
    //

    if ( ImportDescriptor->FirstThunk ) {
        Thunk = (PIMAGE_THUNK_DATA)((ULONG_PTR)LdrDataTableEntry_Import->DllBase + ImportDescriptor->FirstThunk);

        NtHeaders = RtlImageNtHeader( LdrDataTableEntry_Import->DllBase );
        //
        // If the OriginalFirstThunk field does not point inside the image, then ignore
        // it.  This is will detect bogus Borland Linker 2.25 images that did not fill
        // this field in.
        //

        if (ImportDescriptor->Characteristics < NtHeaders->OptionalHeader.SizeOfHeaders ||
            ImportDescriptor->Characteristics >= NtHeaders->OptionalHeader.SizeOfImage
           ) {
            OriginalThunk = Thunk;
        } else {
            OriginalThunk = (PIMAGE_THUNK_DATA)((ULONG_PTR)LdrDataTableEntry_Import->DllBase +
                            ImportDescriptor->OriginalFirstThunk);
        }
        ImportName = (PSZ)((ULONG_PTR)LdrDataTableEntry_Import->DllBase + ImportDescriptor->Name);
        while (OriginalThunk->u1.AddressOfData) {
            try {
                st = LdrpSnapThunk(LdrDataTableEntry_Export->DllBase,
                        LdrDataTableEntry_Import->DllBase,
                        OriginalThunk,
                        Thunk,
                        ExportDirectory,
                        ExportSize,
                        TRUE,
                        ImportName
                        );
                OriginalThunk++;
                Thunk++;
                }
            except (LdrpGenericExceptionFilter(GetExceptionInformation(), __FUNCTION__)) {
                st = GetExceptionCode();
                DbgPrintEx(
                    DPFLTR_LDR_ID,
                    LDR_ERROR_DPFLTR,
                    "LDR: %s - caught exception %08lx snapping thunks (#2)\n",
                    __FUNCTION__,
                    st);
                }

            if (!NT_SUCCESS(st) ) {
                break;
                }
            }
        }

    //
    // Restore protection for IAT and flush instruction cache.
    //

    NtProtectVirtualMemory( NtCurrentProcess(),
                            &IATBase,
                            &IATSize,
                            OldProtect,
                            &OldProtect
                          );
    NtFlushInstructionCache( NtCurrentProcess(), IATBase, LittleIATSize );

    return st;
}

NTSTATUS
LdrpSnapThunk (
    IN PVOID DllBase,
    IN PVOID ImageBase,
    IN PIMAGE_THUNK_DATA OriginalThunk,
    IN OUT PIMAGE_THUNK_DATA Thunk,
    IN PIMAGE_EXPORT_DIRECTORY ExportDirectory,
    IN ULONG ExportSize,
    IN BOOLEAN StaticSnap,
    IN PSZ DllName
    )

/*++

Routine Description:

    This function snaps a thunk using the specified Export Section data.
    If the section data does not support the thunk, then the thunk is
    partially snapped (Dll field is still non-null, but snap address is
    set).

Arguments:

    DllBase - Base of Dll.

    ImageBase - Base of image that contains the thunks to snap.

    Thunk - On input, supplies the thunk to snap.  When successfully
        snapped, the function field is set to point to the address in
        the DLL, and the DLL field is set to NULL.

    ExportDirectory - Supplies the Export Section data from a DLL.

    StaticSnap - If TRUE, then loader is attempting a static snap,
                 and any ordinal/name lookup failure will be reported.

Return Value:

    STATUS_SUCCESS or STATUS_PROCEDURE_NOT_FOUND

--*/

{
    BOOLEAN Ordinal;
    USHORT OrdinalNumber;
    ULONG OriginalOrdinalNumber;
    PIMAGE_IMPORT_BY_NAME AddressOfData;
    PULONG NameTableBase;
    PUSHORT NameOrdinalTableBase;
    PULONG Addr;
    USHORT HintIndex;
    NTSTATUS st;
    PSZ ImportString;

    //
    // Determine if snap is by name, or by ordinal
    //

    Ordinal = (BOOLEAN)IMAGE_SNAP_BY_ORDINAL(OriginalThunk->u1.Ordinal);

    if (Ordinal) {
        OriginalOrdinalNumber = (ULONG)IMAGE_ORDINAL(OriginalThunk->u1.Ordinal);
        OrdinalNumber = (USHORT)(OriginalOrdinalNumber - ExportDirectory->Base);
    } else {

             //
             // This should never happen, because we will only be called if either
             // Ordinal is set or ImageBase is not NULL.  But to satisfy prefix...
             //
             if (ImageBase == NULL) {
#if LDRDBG
                DbgPrint("LDR: ImageBase=NULL and !Ordinal\n");
#endif
                return STATUS_PROCEDURE_NOT_FOUND;
             }

             //
             // Change AddressOfData from an RVA to a VA.
             //

             AddressOfData = (PIMAGE_IMPORT_BY_NAME)((ULONG_PTR)ImageBase + ((ULONG_PTR)OriginalThunk->u1.AddressOfData & 0xffffffff));
             ImportString = (PSZ)AddressOfData->Name;

             //
             // Lookup Name in NameTable
             //

             NameTableBase = (PULONG)((ULONG_PTR)DllBase + (ULONG)ExportDirectory->AddressOfNames);
             NameOrdinalTableBase = (PUSHORT)((ULONG_PTR)DllBase + (ULONG)ExportDirectory->AddressOfNameOrdinals);

             //
             // Before dropping into binary search, see if
             // the hint index results in a successful
             // match. If the hint index is zero, then
             // drop into binary search.
             //

             HintIndex = AddressOfData->Hint;
             if ((ULONG)HintIndex < ExportDirectory->NumberOfNames &&
                 !strcmp(ImportString, (PSZ)((ULONG_PTR)DllBase + NameTableBase[HintIndex]))) {
                 OrdinalNumber = NameOrdinalTableBase[HintIndex];
#if LDRDBG
                 if (ShowSnaps) {
                     DbgPrint("LDR: Snapping %s\n", ImportString);
                 }
#endif
             } else {
#if LDRDBG
                      if (HintIndex) {
                          DbgPrint("LDR: Warning HintIndex Failure. Name %s (%lx) Hint 0x%lx\n",
                              ImportString,
                              (ULONG)ImportString,
                              (ULONG)HintIndex
                              );
                      }
#endif
                      OrdinalNumber = LdrpNameToOrdinal(
                                        ImportString,
                                        ExportDirectory->NumberOfNames,
                                        DllBase,
                                        NameTableBase,
                                        NameOrdinalTableBase
                                        );
                    }
           }

    //
    // If OrdinalNumber is not within the Export Address Table,
    // then DLL does not implement function. Snap to LDRP_BAD_DLL.
    //

    if ((ULONG)OrdinalNumber >= ExportDirectory->NumberOfFunctions) {
baddllref:
#if DBG
        if (StaticSnap) {
            if (Ordinal) {
                DbgPrint("LDR: Can't locate ordinal 0x%lx\n", OriginalOrdinalNumber);
                }
            else {
                DbgPrint("LDR: Can't locate %s\n", ImportString);
                }
        }
#endif
        if ( StaticSnap ) {
            //
            // Hard Error Time
            //

            ULONG_PTR ErrorParameters[3];
            UNICODE_STRING ErrorDllName, ErrorEntryPointName;
            ANSI_STRING AnsiScratch;
            ULONG ParameterStringMask;
            ULONG ErrorResponse;

            RtlInitAnsiString(&AnsiScratch,DllName ? DllName : "Unknown");
            RtlAnsiStringToUnicodeString(&ErrorDllName,&AnsiScratch,TRUE);
            ErrorParameters[1] = (ULONG_PTR)&ErrorDllName;
            ParameterStringMask = 2;

            if ( Ordinal ) {
                ErrorParameters[0] = OriginalOrdinalNumber;
                }
            else {
                RtlInitAnsiString(&AnsiScratch,ImportString);
                RtlAnsiStringToUnicodeString(&ErrorEntryPointName,&AnsiScratch,TRUE);
                ErrorParameters[0] = (ULONG_PTR)&ErrorEntryPointName;
                ParameterStringMask = 3;
                }


            NtRaiseHardError(
              Ordinal ? STATUS_ORDINAL_NOT_FOUND : STATUS_ENTRYPOINT_NOT_FOUND,
              2,
              ParameterStringMask,
              ErrorParameters,
              OptionOk,
              &ErrorResponse
              );

            if ( LdrpInLdrInit ) {
                LdrpFatalHardErrorCount++;
                }
            RtlFreeUnicodeString(&ErrorDllName);
            if ( !Ordinal ) {
                RtlFreeUnicodeString(&ErrorEntryPointName);
                RtlRaiseStatus(STATUS_ENTRYPOINT_NOT_FOUND);
                }
            RtlRaiseStatus(STATUS_ORDINAL_NOT_FOUND);
            }
        Thunk->u1.Function = (ULONG_PTR)LDRP_BAD_DLL;
        st = Ordinal ? STATUS_ORDINAL_NOT_FOUND : STATUS_ENTRYPOINT_NOT_FOUND;
    } else {
             Addr = (PULONG)((ULONG_PTR)DllBase + (ULONG)ExportDirectory->AddressOfFunctions);
             Thunk->u1.Function = ((ULONG_PTR)DllBase + Addr[OrdinalNumber]);
             if (Thunk->u1.Function > (ULONG_PTR)ExportDirectory &&
                 Thunk->u1.Function < ((ULONG_PTR)ExportDirectory + ExportSize)) {
                UNICODE_STRING UnicodeString;
                ANSI_STRING ForwardDllName;
                PVOID ForwardDllHandle;
                PANSI_STRING ForwardProcName;
                ULONG ForwardProcOrdinal;

                ImportString = (PSZ)Thunk->u1.Function;
                ForwardDllName.Buffer = ImportString,
                ForwardDllName.Length = (USHORT)(strchr(ImportString, '.') - ImportString);
                ForwardDllName.MaximumLength = ForwardDllName.Length;

                // Most forwarders seem to point to NTDLL and since we know that every
                // process has ntdll already loaded and pinned let's optimize away all
                // the calls to load it.  I was debugging the loader and there are just
                // a rediculous number of loads of ntdll.  -mgrier 4/8/2001
                if (ASCII_STRING_IS_NTDLL(&ForwardDllName)) {
                    ForwardDllHandle = LdrpNtDllDataTableEntry->DllBase;
                    st = STATUS_SUCCESS;
                } else {
                    st = RtlAnsiStringToUnicodeString(&UnicodeString, &ForwardDllName, TRUE);

                    if (NT_SUCCESS(st)) {
                        UNICODE_STRING AnotherUnicodeString = {0, 0, NULL};
                        PUNICODE_STRING UnicodeStringToUse = &UnicodeString;
                        ULONG LdrpLoadDllFlags = 0;

                        st = RtlDosApplyFileIsolationRedirection_Ustr(
                                RTL_DOS_APPLY_FILE_REDIRECTION_USTR_FLAG_RESPECT_DOT_LOCAL,
                                &UnicodeString,
                                &DefaultExtension,
                                NULL,
                                &AnotherUnicodeString,
                                &UnicodeStringToUse,
                                NULL,
                                NULL,
                                NULL);

                        if (NT_SUCCESS(st)) {
                            LdrpLoadDllFlags |= LDRP_LOAD_DLL_FLAG_DLL_IS_REDIRECTED;
                        }

                        if (st == STATUS_SXS_KEY_NOT_FOUND) {
                            st = STATUS_SUCCESS;
                        }

                        if (NT_SUCCESS(st)) {
                            st = LdrpLoadDll(LdrpLoadDllFlags, NULL, NULL, UnicodeStringToUse, &ForwardDllHandle, FALSE);
                        }

                        if (AnotherUnicodeString.Buffer != NULL)
                            RtlFreeUnicodeString(&AnotherUnicodeString);

                        RtlFreeUnicodeString(&UnicodeString);
                    }
                }

                if (!NT_SUCCESS(st)) {
                    goto baddllref;
                }

                RtlInitAnsiString( &ForwardDllName,
                                   ImportString + ForwardDllName.Length + 1
                                 );
                if (ForwardDllName.Length > 1 &&
                    *ForwardDllName.Buffer == '#'
                   ) {
                    ForwardProcName = NULL;
                    st = RtlCharToInteger( ForwardDllName.Buffer+1,
                                           0,
                                           &ForwardProcOrdinal
                                         );
                    if (!NT_SUCCESS(st)) {
                        goto baddllref;
                        }
                    }
                else {
                    ForwardProcName = &ForwardDllName;

                    //
                    // Following line is not needed since this is a by name lookup
                    //
                    //
                    //ForwardProcOrdinal = (ULONG)&ForwardDllName;
                    //
                    }

                st = LdrpGetProcedureAddress( ForwardDllHandle,
                                              ForwardProcName,
                                              ForwardProcOrdinal,
                                              (PVOID*)&Thunk->u1.Function,
                                              FALSE
                                            );
                if (!NT_SUCCESS(st)) {
                    goto baddllref;
                    }
                }
             else {
                if ( !Addr[OrdinalNumber] ) {
                    goto baddllref;
                    }
             }
             st = STATUS_SUCCESS;
           }
    return st;
}

USHORT
LdrpNameToOrdinal (
    IN PSZ Name,
    IN ULONG NumberOfNames,
    IN PVOID DllBase,
    IN PULONG NameTableBase,
    IN PUSHORT NameOrdinalTableBase
    )
{
    LONG High;
    LONG Low;
    LONG Middle;
    LONG Result;

    //
    // Lookup the import name in the name table using a binary search.
    //

    Low = 0;
    High = NumberOfNames - 1;
    while (High >= Low) {

        //
        // Compute the next probe index and compare the import name
        // with the export name entry.
        //

        Middle = (Low + High) >> 1;
        Result = strcmp(Name, (PCHAR)((ULONG_PTR)DllBase + NameTableBase[Middle]));

        if (Result < 0) {
            High = Middle - 1;

        } else if (Result > 0) {
            Low = Middle + 1;

        } else {
            break;
        }
    }

    //
    // If the high index is less than the low index, then a matching
    // table entry was not found. Otherwise, get the ordinal number
    // from the ordinal table.
    //

    if (High < Low) {
        return (USHORT)-1;
    } else {
        return NameOrdinalTableBase[Middle];
    }

}

#if 0

VOID
LdrpReferenceLoadedDll(
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    )
{
    WCHAR PreAllocatedStringBuffer[DOS_MAX_PATH_LENGTH];
    UNICODE_STRING PreAllocatedString = {0, sizeof(PreAllocatedStringBuffer), PreAllocatedStringBuffer};

    LdrpUpdateLoadCount(LdrDataTableEntry, LDRP_UPDATE_LOAD_COUNT_INCREMENT, &PreAllocatedString);
}

VOID
LdrpDereferenceLoadedDll(
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    )
{
    WCHAR PreAllocatedStringBuffer[DOS_MAX_PATH_LENGTH];
    UNICODE_STRING PreAllocatedString = {0, sizeof(PreAllocatedStringBuffer), PreAllocatedStringBuffer};

    LdrpUpdateLoadCount(LdrDataTableEntry, LDRP_UPDATE_LOAD_COUNT_DECREMENT, &PreAllocatedString);
}

VOID
LdrpPinLoadedDll(
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    )
{
    WCHAR PreAllocatedStringBuffer[DOS_MAX_PATH_LENGTH];
    UNICODE_STRING PreAllocatedString = {0, sizeof(PreAllocatedStringBuffer), PreAllocatedStringBuffer};

    LdrpUpdateLoadCount(LdrDataTableEntry, LDRP_UPDATE_LOAD_COUNT_PIN, &PreAllocatedString);
}

#endif

VOID
LdrpUpdateLoadCount2(
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry,
    IN ULONG UpdateCountHow
    )
{
    WCHAR PreAllocatedStringBuffer[DOS_MAX_PATH_LENGTH];
    UNICODE_STRING PreAllocatedString = {0, sizeof(PreAllocatedStringBuffer), PreAllocatedStringBuffer};

    LdrpUpdateLoadCount3(LdrDataTableEntry, UpdateCountHow, &PreAllocatedString);
}

VOID
LdrpUpdateLoadCount3(
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry,
    IN ULONG UpdateCountHow,
    IN OUT PUNICODE_STRING PreAllocatedRedirectionBuffer OPTIONAL
    )
/*++

Routine Description:

    This function dereferences a loaded DLL adjusting its reference
    count.  It then dereferences each dll referenced by this dll.

Arguments:

    LdrDataTableEntry - Supplies the address of the DLL to dereference

    UpdateCountHow - 
        LDRP_UPDATE_LOAD_COUNT_INCREMENT add one
        LDRP_UPDATE_LOAD_COUNT_DECREMENT subtract one
        LDRP_UPDATE_LOAD_COUNT_PIN       set to 0xffff

    PreAllocatedRedirectionBuffer - optional pointer to a caller-allocated
        (usually on the stack) fixed-sized buffer to use for redirection
        to avoid having a large buffer on our stack used during recursion.

Return Value:

    None.

--*/

{
    PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor;
    PIMAGE_BOUND_IMPORT_DESCRIPTOR NewImportDescriptor;
    PIMAGE_BOUND_FORWARDER_REF NewImportForwarder;
    PSZ ImportName, NewImportStringBase;
    ULONG i, ImportSize, NewImportSize;
    ANSI_STRING AnsiString;
    PUNICODE_STRING ImportDescriptorName_U;
    PUNICODE_STRING ImportDescriptorNameToUse; // overrides ImportDescriptorName_U when redirection is turned on for a DLL
    PLDR_DATA_TABLE_ENTRY Entry;
    NTSTATUS st;
    PIMAGE_THUNK_DATA FirstThunk;
    UNICODE_STRING DynamicRedirectionString;
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME ActivationFrame = { sizeof(ActivationFrame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };

    RtlActivateActivationContextUnsafeFast(&ActivationFrame, LdrDataTableEntry->EntryPointActivationContext);
    __try {
        switch (UpdateCountHow
            ) {
            case LDRP_UPDATE_LOAD_COUNT_PIN:
            case LDRP_UPDATE_LOAD_COUNT_INCREMENT:
                if (LdrDataTableEntry->Flags & LDRP_LOAD_IN_PROGRESS) {
                    return;
                } else {
                    LdrDataTableEntry->Flags |= LDRP_LOAD_IN_PROGRESS;
                }
                break;
            case LDRP_UPDATE_LOAD_COUNT_DECREMENT:
                if (LdrDataTableEntry->Flags & LDRP_UNLOAD_IN_PROGRESS) {
                    return;
                } else {
                    LdrDataTableEntry->Flags |= LDRP_UNLOAD_IN_PROGRESS;
                }
                break;
        }

        //
        // For each DLL used by this DLL, reference or dereference the DLL.
        //

        if (LdrDataTableEntry->Flags & LDRP_COR_IMAGE) {
            //
            // The image is COR.  Ignore its import table and make it import
            // mscoree only.
            //
            UNICODE_STRING ImportName = RTL_CONSTANT_STRING(L"mscoree.dll");

            if (LdrpCheckForLoadedDll( NULL,
                                       &ImportName,
                                       TRUE,
                                       FALSE,
                                       &Entry
                                     )
               ) {
                if ( Entry->LoadCount != 0xffff ) {
                    PCSTR SnapString = NULL;
                    switch (UpdateCountHow) {
                    case LDRP_UPDATE_LOAD_COUNT_PIN:
                        Entry->LoadCount = 0xffff;
                        SnapString = "Pin";
                        break;
                    case LDRP_UPDATE_LOAD_COUNT_INCREMENT:
                        Entry->LoadCount++;
                        SnapString = "Refcount";
                        break;
                    case LDRP_UPDATE_LOAD_COUNT_DECREMENT:
                        Entry->LoadCount--;
                        SnapString = "Derefcount";
                        break;
                    }
                    if (ShowSnaps) {
                        DbgPrint("LDR: %s %wZ (%lx)\n",
                                SnapString,
                                &ImportName,
                                (ULONG)Entry->LoadCount
                                );
                    }
                }
                LdrpUpdateLoadCount3(Entry, UpdateCountHow, PreAllocatedRedirectionBuffer);
            }
            return;
        }

        ImportDescriptorName_U = &NtCurrentTeb()->StaticUnicodeString;

        //
        // See if there is a bound import table.  If so, walk that to
        // determine DLL names to reference or dereference.  Avoids touching
        // the .idata section
        //
        NewImportDescriptor = (PIMAGE_BOUND_IMPORT_DESCRIPTOR)RtlImageDirectoryEntryToData(
                               LdrDataTableEntry->DllBase,
                               TRUE,
                               IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT,
                               &NewImportSize
                               );
        if (NewImportDescriptor) {
            switch (UpdateCountHow) {
                case LDRP_UPDATE_LOAD_COUNT_INCREMENT:
                case LDRP_UPDATE_LOAD_COUNT_PIN:
                    LdrDataTableEntry->Flags |= LDRP_LOAD_IN_PROGRESS;
                    break;
                case LDRP_UPDATE_LOAD_COUNT_DECREMENT:
                    LdrDataTableEntry->Flags |= LDRP_UNLOAD_IN_PROGRESS;
                    break;
            }
            NewImportStringBase = (LPSTR)NewImportDescriptor;
            while (NewImportDescriptor->OffsetModuleName) {
                ImportName = NewImportStringBase +
                             NewImportDescriptor->OffsetModuleName;
                RtlInitAnsiString(&AnsiString, ImportName);
                st = RtlAnsiStringToUnicodeString(ImportDescriptorName_U, &AnsiString, FALSE);
                if ( NT_SUCCESS(st) ) {
                    BOOLEAN Redirected = FALSE;

                    ImportDescriptorNameToUse = ImportDescriptorName_U;
                    DynamicRedirectionString.Buffer = NULL;

                    st = RtlDosApplyFileIsolationRedirection_Ustr(
                            RTL_DOS_APPLY_FILE_REDIRECTION_USTR_FLAG_RESPECT_DOT_LOCAL,
                            ImportDescriptorName_U,
                            &DefaultExtension,
                            PreAllocatedRedirectionBuffer,
                            &DynamicRedirectionString,
                            &ImportDescriptorNameToUse,
                            NULL,
                            NULL,
                            NULL);
                    if (NT_SUCCESS(st)) {
                        Redirected = TRUE;
                    } else if (st == STATUS_SXS_KEY_NOT_FOUND) {
                        st = STATUS_SUCCESS;
                    }

                    if (NT_SUCCESS(st)) {
                        if (LdrpCheckForLoadedDll( NULL,
                                                   ImportDescriptorNameToUse,
                                                   TRUE,
                                                   Redirected,
                                                   &Entry
                                                 )
                           ) {
                            if ( Entry->LoadCount != 0xffff ) {
                                PCSTR SnapString = NULL;
                                switch (UpdateCountHow) {
                                case LDRP_UPDATE_LOAD_COUNT_PIN:
                                    Entry->LoadCount = 0xffff;
                                    SnapString = "Pin";
                                    break;
                                case LDRP_UPDATE_LOAD_COUNT_INCREMENT:
                                    Entry->LoadCount++;
                                    SnapString = "Refcount";
                                    break;
                                case LDRP_UPDATE_LOAD_COUNT_DECREMENT:
                                    Entry->LoadCount--;
                                    SnapString = "Derefcount";
                                    break;
                                }
                                if (ShowSnaps) {
                                    DbgPrint("LDR: %s %wZ (%lx)\n",
                                            SnapString,
                                            ImportDescriptorNameToUse,
                                            (ULONG)Entry->LoadCount
                                            );
                                }
                            }
                            LdrpUpdateLoadCount3(Entry, UpdateCountHow, PreAllocatedRedirectionBuffer);
                        }

                        if (DynamicRedirectionString.Buffer != NULL)
                            RtlFreeUnicodeString(&DynamicRedirectionString);
                    }
                }

                NewImportForwarder = (PIMAGE_BOUND_FORWARDER_REF)(NewImportDescriptor+1);
                for (i=0; i<NewImportDescriptor->NumberOfModuleForwarderRefs; i++) {
                    ImportName = NewImportStringBase +
                                 NewImportForwarder->OffsetModuleName;

                    RtlInitAnsiString(&AnsiString, ImportName);
                    st = RtlAnsiStringToUnicodeString(ImportDescriptorName_U, &AnsiString, FALSE);
                    if ( NT_SUCCESS(st) ) {
                        BOOLEAN Redirected = FALSE;

                        ImportDescriptorNameToUse = ImportDescriptorName_U;
                        DynamicRedirectionString.Buffer = NULL;

                        st = RtlDosApplyFileIsolationRedirection_Ustr(
                                RTL_DOS_APPLY_FILE_REDIRECTION_USTR_FLAG_RESPECT_DOT_LOCAL,
                                ImportDescriptorName_U,
                                &DefaultExtension,
                                PreAllocatedRedirectionBuffer,
                                &DynamicRedirectionString,
                                &ImportDescriptorNameToUse,
                                NULL,
                                NULL,
                                NULL);
                        if (NT_SUCCESS(st)) {
                            Redirected = TRUE;
                        } else if (st == STATUS_SXS_KEY_NOT_FOUND) {
                            st = STATUS_SUCCESS;
                        }

                        if (NT_SUCCESS(st)) {
                            if (LdrpCheckForLoadedDll( NULL,
                                                       ImportDescriptorNameToUse,
                                                       TRUE,
                                                       Redirected,
                                                       &Entry
                                                     )
                               ) {
                                if ( Entry->LoadCount != 0xffff ) {
                                    PCSTR SnapString = NULL;
                                    switch (UpdateCountHow) {
                                    case LDRP_UPDATE_LOAD_COUNT_PIN:
                                        Entry->LoadCount = 0xffff;
                                        SnapString = "Pin";
                                        break;
                                    case LDRP_UPDATE_LOAD_COUNT_INCREMENT:
                                        Entry->LoadCount++;
                                        SnapString = "Refcount";
                                        break;
                                    case LDRP_UPDATE_LOAD_COUNT_DECREMENT:
                                        Entry->LoadCount--;
                                        SnapString = "Derefcount";
                                        break;
                                    }
                                    if (ShowSnaps) {
                                        DbgPrint("LDR: %s %wZ (%lx)\n",
                                                SnapString,
                                                ImportDescriptorNameToUse,
                                                (ULONG)Entry->LoadCount
                                                );
                                    }
                                }
                                LdrpUpdateLoadCount3(Entry, UpdateCountHow, PreAllocatedRedirectionBuffer);
                            }

                            if (DynamicRedirectionString.Buffer != NULL)
                                RtlFreeUnicodeString(&DynamicRedirectionString);
                        }
                    }

                    NewImportForwarder += 1;
                }

                NewImportDescriptor = (PIMAGE_BOUND_IMPORT_DESCRIPTOR)NewImportForwarder;
            }

            return;
        }

        ImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)RtlImageDirectoryEntryToData(
                            LdrDataTableEntry->DllBase,
                            TRUE,
                            IMAGE_DIRECTORY_ENTRY_IMPORT,
                            &ImportSize
                            );
        if (ImportDescriptor) {

            while (ImportDescriptor->Name && ImportDescriptor->FirstThunk) {

                //
                // Match code in walk that skips references like this. IE3 had
                // some dll's with these bogus links to url.dll. On load, the url.dll
                // ref was skipped. On unload, it was not skipped because
                // this code was missing.
                //
                // Since the skip logic is only in the old style import
                // descriptor path, it is only duplicated here.
                //
                // check for import that has no references
                //
                FirstThunk = (PIMAGE_THUNK_DATA)((ULONG_PTR)LdrDataTableEntry->DllBase + ImportDescriptor->FirstThunk);
                if ( !FirstThunk->u1.Function ) {
                    goto skipskippedimport;
                    }

                ImportName = (PSZ)((ULONG_PTR)LdrDataTableEntry->DllBase + ImportDescriptor->Name);

                RtlInitAnsiString(&AnsiString, ImportName);
                st = RtlAnsiStringToUnicodeString(ImportDescriptorName_U, &AnsiString, FALSE);
                if ( NT_SUCCESS(st) ) {
                    BOOLEAN Redirected = FALSE;                    

                    ImportDescriptorNameToUse = ImportDescriptorName_U;
                    DynamicRedirectionString.Buffer = NULL;

                    st = RtlDosApplyFileIsolationRedirection_Ustr(
                            RTL_DOS_APPLY_FILE_REDIRECTION_USTR_FLAG_RESPECT_DOT_LOCAL,
                            ImportDescriptorName_U,
                            &DefaultExtension,
                            PreAllocatedRedirectionBuffer,
                            &DynamicRedirectionString,
                            &ImportDescriptorNameToUse,
                            NULL,
                            NULL,
                            NULL);
                    if (NT_SUCCESS(st)) {
                        Redirected = TRUE;
                    } else if (st == STATUS_SXS_KEY_NOT_FOUND) {
                        st = STATUS_SUCCESS;
                    }

                    if (NT_SUCCESS(st)) {
                        if (LdrpCheckForLoadedDll( NULL,
                                                   ImportDescriptorNameToUse,
                                                   TRUE,
                                                   Redirected,
                                                   &Entry
                                                 )
                           ) {
                            if ( Entry->LoadCount != 0xffff ) {
                                PCSTR SnapString = NULL;
                                switch (UpdateCountHow) {
                                case LDRP_UPDATE_LOAD_COUNT_PIN:
                                    Entry->LoadCount = 0xffff;
                                    SnapString = "Pin";
                                    break;
                                case LDRP_UPDATE_LOAD_COUNT_INCREMENT:
                                    Entry->LoadCount++;
                                    SnapString = "Refcount";
                                    break;
                                case LDRP_UPDATE_LOAD_COUNT_DECREMENT:
                                    Entry->LoadCount--;
                                    SnapString = "Derefcount";
                                    break;
                                }
                                if (ShowSnaps) {
                                    DbgPrint("LDR: %s %wZ (%lx)\n",
                                            SnapString,
                                            ImportDescriptorNameToUse,
                                            (ULONG)Entry->LoadCount
                                            );
                                }
                            }
                            LdrpUpdateLoadCount3(Entry, UpdateCountHow, PreAllocatedRedirectionBuffer);
                        }

                        if (DynamicRedirectionString.Buffer != NULL) {
                            RtlFreeUnicodeString(&DynamicRedirectionString);
                        }
                    }
                }
    skipskippedimport:
                ++ImportDescriptor;
            }
        }
    } __finally {
        RtlDeactivateActivationContextUnsafeFast(&ActivationFrame);
    }
}

VOID
LdrpInsertMemoryTableEntry (
    IN PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    )

/*++

Routine Description:

    This function inserts a loader data table entry into the
    list of loaded modules for this process. The insertion is
    done in "image memory base order".

Arguments:

    LdrDataTableEntry - Supplies the address of the loader data table
        entry to insert in the list of loaded modules for this process.

Return Value:

    None.

--*/
{
    PPEB_LDR_DATA Ldr;
    ULONG i;

    Ldr = NtCurrentPeb()->Ldr;

    i = LDRP_COMPUTE_HASH_INDEX(LdrDataTableEntry->BaseDllName.Buffer[0]);
    InsertTailList(&LdrpHashTable[i],&LdrDataTableEntry->HashLinks);
    InsertTailList(&Ldr->InLoadOrderModuleList, &LdrDataTableEntry->InLoadOrderLinks);

#if defined(_AMD64_) // || defined(_IA64_)

    RtlInsertInvertedFunctionTable(&LdrpInvertedFunctionTable,
                                   LdrDataTableEntry->DllBase,
                                   LdrDataTableEntry->SizeOfImage);

#endif

    InsertTailList(&Ldr->InMemoryOrderModuleList, &LdrDataTableEntry->InMemoryOrderLinks);
}


NTSTATUS
LdrpResolveDllName (
    IN PWSTR DllPath OPTIONAL,
    IN PWSTR DllName,
    IN BOOLEAN Redirected,
    OUT PUNICODE_STRING FullDllNameOut,
    OUT PUNICODE_STRING BaseDllNameOut,
    OUT PHANDLE DllFile
    )

/*++

Routine Description:

    This function computes the DLL pathname and base dll name (the
    unqualified, extensionless portion of the file name) for the specified
    DLL.

Arguments:

    DllPath - Supplies the DLL search path.

    DllName - Supplies the name of the DLL.

    FullDllName - Returns the fully qualified pathname of the
        DLL. The Buffer field of this string is dynamically
        allocated from the loader heap.

    BaseDLLName - Returns the base dll name of the dll.  The base name
        is the file name portion of the dll path without the trailing
        extension. The Buffer field of this string points into the
        FullDllName since the one is a substring of the other.

    DllFile - Returns an open handle to the DLL file. This parameter may
        still be NULL even upon success.

Return Value:

    TRUE - The operation was successful. A DLL file was found, and the
        FullDllName->Buffer & BaseDllName->Buffer field points to the
        base of process heap allocated memory.

    FALSE - The DLL could not be found.

--*/

{
    PWCH p, pp;
    PWCH FullBuffer = NULL;
    NTSTATUS st = STATUS_INTERNAL_ERROR;
    UNICODE_STRING DllNameString = { 0, 0, NULL };
    UNICODE_STRING FullDllName = { 0, 0, NULL };
    UNICODE_STRING BaseDllName = { 0, 0, NULL };
    USHORT PrefixLength = 0;
    PCWSTR EffectiveDllPath = (DllPath != NULL) ? DllPath : LdrpDefaultPath.Buffer;
    WCHAR TempBuffer[40]; // Arbitrary short length so most d:\windows\system32\foobar.dll loads don't need to search the search path twice

    if (DllFile != NULL)
        *DllFile = NULL;

    if (FullDllNameOut != NULL) {
        FullDllNameOut->Length = 0;
        FullDllNameOut->MaximumLength = 0;
        FullDllNameOut->Buffer = NULL;
    }

    if (BaseDllNameOut != NULL) {
        BaseDllNameOut->Length = 0;
        BaseDllNameOut->MaximumLength = 0;
        BaseDllNameOut->Buffer = NULL;
    }

    if ((DllFile == NULL) ||
        (FullDllNameOut == NULL) ||
        (BaseDllNameOut == NULL)) {
        st = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    RtlInitUnicodeString(&DllNameString, DllName);

    // Look for ".local" redirection for this DLL.
    st = LdrpResolveDllNameForAppPrivateRedirection(&DllNameString, &FullDllName);
    if (!NT_SUCCESS(st)) {
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s failed calling LdrpResolveDllNameForAppPrivateRediretion with status %lx\n",
            __FUNCTION__,
            st);
        goto Exit;
    }

    // .local always wins, so only search other solutions if that wasn't the answer.
    if (FullDllName.Length == 0) {
        if (Redirected) {
            // If the path was redirected, we assume that DllNameString is an absolute path to
            // the DLL so there's nothing more to do.
            st = LdrpCopyUnicodeString(&FullDllName, &DllNameString);
            if (!NT_SUCCESS(st)) {
                DbgPrintEx(
                    DPFLTR_LDR_ID,
                    LDR_ERROR_DPFLTR,
                    "LDR: %s failed call to LdrpCopyUnicodeString() in redirected case; status = %lx\n",
                    __FUNCTION__,
                    st);
                goto Exit;
            }
        } else {
            ULONG Length;

            // Having an excessively long buffer could break code later that assumes
            // that comparisons against the size of the buffer ensure that casting
            // to USHORT is safe.
            ASSERT(sizeof(TempBuffer) <= UNICODE_STRING_MAX_BYTES);

            // Not redirected; search the search path.
            Length = RtlDosSearchPath_U(
                        EffectiveDllPath,
                        DllName,
                        NULL,
                        sizeof(TempBuffer),
                        TempBuffer,
                        NULL);

            if (Length == 0) {
                if (ShowSnaps) {
                    DbgPrintEx(
                        DPFLTR_LDR_ID,
                        LDR_ERROR_DPFLTR,
                        "LDR: %s - call to RtlDosSearchPath_U failed\n",
                        __FUNCTION__);

                    DbgPrintEx(
                        DPFLTR_LDR_ID,
                        LDR_ERROR_DPFLTR,
                        "   DllName: \"%ws\"\n",
                        DllName);

                    DbgPrintEx(
                        DPFLTR_LDR_ID,
                        LDR_ERROR_DPFLTR,
                        "   Path: \"%ws\"\n",
                        EffectiveDllPath);
                }

                st = STATUS_DLL_NOT_FOUND;
                goto Exit;
            }

            if (Length > UNICODE_STRING_MAX_BYTES) {
                if (ShowSnaps)
                    DbgPrint(
                        "LDR: LdrResolveDllName - Failing resolution because found path too long (%u bytes; max is %u bytes)\n",
                        Length,
                        UNICODE_STRING_MAX_BYTES);
                st = STATUS_NAME_TOO_LONG;
                goto Exit;
            }

            st = LdrpAllocateUnicodeString(&FullDllName, (USHORT) Length);
            if (!NT_SUCCESS(st)) {
                DbgPrintEx(
                    DPFLTR_LDR_ID,
                    LDR_ERROR_DPFLTR,
                    "LDR: %s - failed to allocate string for full dll name; length requested: %u\n",
                    __FUNCTION__,
                    Length);

                goto Exit;
            }

            // If the original stack buffer wasn't large enough, use the dynamically allocated one.
            if (Length > sizeof(TempBuffer)) {
                ULONG Length2 = RtlDosSearchPath_U(
                            EffectiveDllPath,
                            DllName,
                            NULL,
                            FullDllName.MaximumLength,
                            FullDllName.Buffer,
                            NULL);

                FullDllName.Length = (USHORT) Length2;

                // It's entirely possible that in a race condition here, the size of the filename required is
                // even longer.
                if (Length2 == 0) {
                    if (ShowSnaps) {
                        DbgPrintEx(
                            DPFLTR_LDR_ID,
                            LDR_ERROR_DPFLTR,
                            "LDR: %s - call to RtlDosSearchPath_U failed\n",
                            __FUNCTION__);

                        DbgPrintEx(
                            DPFLTR_LDR_ID,
                            LDR_ERROR_DPFLTR,
                            "   DllName: \"%ws\"\n",
                            DllName);

                        DbgPrintEx(
                            DPFLTR_LDR_ID,
                            LDR_ERROR_DPFLTR,
                            "   Path: \"%ws\"\n",
                            EffectiveDllPath);
                    }

                    LdrpFreeUnicodeString(&FullDllName);
                    st = STATUS_DLL_NOT_FOUND;
                    goto Exit;
                } else if (Length2 > FullDllName.MaximumLength) {
                    if (ShowSnaps)
                        DbgPrint(
                            "LDR: %s - Required path length required for %ws changed from %lu to %lu; try launching the app again.\n",
                            __FUNCTION__,
                            DllName,
                            Length,
                            Length2);

                    LdrpFreeUnicodeString(&FullDllName);
                    st = STATUS_DLL_NOT_FOUND;
                    goto Exit;
                } else if (Length2 < Length) {
                    // If the name shrunk, the trailing null character won't be there, so we put it
                    // in ourselves...
                    FullDllName.Buffer[Length2 / sizeof(WCHAR)] = L'\0';
                }
            } else {
                // Note that LdrpAllocateUnicodeString() already put the null at the character after "Length".
                FullDllName.Length = (USHORT) Length;
                RtlCopyMemory(FullDllName.Buffer, TempBuffer, Length);
            }
        }
    }

    *FullDllNameOut = FullDllName;

    RtlInitEmptyUnicodeString(&FullDllName, NULL, 0);

    //
    // Compute Length of base dll name
    //

    st = RtlFindCharInUnicodeString(
            RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END,
            FullDllNameOut,
            &RtlDosPathSeperatorsString,
            &PrefixLength);
    if (st == STATUS_NOT_FOUND) {
        *BaseDllNameOut = *FullDllNameOut;
    } else if (!NT_SUCCESS(st)) {
        DbgPrintEx(
            DPFLTR_LDR_ID,
            LDR_ERROR_DPFLTR,
            "LDR: %s - failing because RtlFindCharInUnicodeString failed with status %x\n",
            __FUNCTION__,
            st);

        goto Exit;
    } else {
        // The prefixlength is the number of bytes prior to the path separator.  We also want to skip
        // the path separator.
        PrefixLength += sizeof(WCHAR);

        BaseDllNameOut->Length = FullDllNameOut->Length - PrefixLength;
        BaseDllNameOut->MaximumLength = FullDllNameOut->MaximumLength - PrefixLength;
        BaseDllNameOut->Buffer = (PWSTR) (((ULONG_PTR) FullDllNameOut->Buffer) + PrefixLength);
    }

    st = STATUS_SUCCESS;

Exit:
    ASSERT(st != STATUS_INTERNAL_ERROR);

    return st;
}


PVOID
LdrpFetchAddressOfEntryPoint (
    IN PVOID Base
    )

/*++

Routine Description:

    This function returns the address of the initialization routine.

Arguments:

    Base - Base of image.

Return Value:

    Status value

--*/

{
    PIMAGE_NT_HEADERS NtHeaders;
    ULONG_PTR ep;

    NtHeaders = RtlImageNtHeader(Base);
    if (NtHeaders == NULL)
        return NULL;

    ep = NtHeaders->OptionalHeader.AddressOfEntryPoint;
    if (ep != 0)
        ep += (ULONG_PTR) Base;

    return (PVOID) ep;
}

NTSTATUS
LdrpCheckForKnownDll(
    IN PWSTR DllName,
    OUT PUNICODE_STRING FullDllNameOut,
    OUT PUNICODE_STRING BaseDllNameOut,
    OUT HANDLE *SectionOut
    )

/*++

Routine Description:

    This function checks to see if the specified DLL is a known DLL.
    It assumes it is only called for static DLL's, and when
    the known DLL directory structure has been set up.

Arguments:

    DllName - Supplies the name of the DLL.

    FullDllName - Returns the fully qualified pathname of the
        DLL. The Buffer field of this string is dynamically
        allocated from the processes heap.

    BaseDLLName - Returns the base dll name of the dll.  The base name
        is the file name portion of the dll path without the trailing
        extension. The Buffer field of this string is dynamically
        allocated from the processes heap.

Return Value:

    NON-NULL - Returns an open handle to the section associated with
        the DLL.

    NULL - The DLL is not known.

--*/

{
    UNICODE_STRING Unicode;
    HANDLE Section = NULL;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    PSZ p;
    PWSTR pw;
    ULONG FullLength = 0;
    UNICODE_STRING FullDllName = { 0, 0, NULL };

    if (SectionOut != NULL)
        *SectionOut = NULL;

    if (FullDllNameOut != NULL) {
        FullDllNameOut->Length = 0;
        FullDllNameOut->MaximumLength = 0;
        FullDllNameOut->Buffer = NULL;
    }

    if (BaseDllNameOut != NULL) {
        BaseDllNameOut->Length = 0;
        BaseDllNameOut->MaximumLength = 0;
        BaseDllNameOut->Buffer = NULL;
    }

    if ((SectionOut == NULL) ||
        (FullDllNameOut == NULL) ||
        (BaseDllNameOut == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    LdrpEnsureLoaderLockIsHeld();

    //
    // calculate base name
    //

    RtlInitUnicodeString(&Unicode, DllName);

    //check DLL_REDIRECTION by .local file
    if ((NtCurrentPeb()->ProcessParameters != NULL) &&
        (NtCurrentPeb()->ProcessParameters->Flags & RTL_USER_PROC_DLL_REDIRECTION_LOCAL) &&
        (Unicode.Length != 0)) { // dll redirection with .local
        UNICODE_STRING NewDllNameUnderImageDir, NewDllNameUnderLocalDir;
        static WCHAR DllNameUnderImageDirBuffer[DOS_MAX_PATH_LENGTH];
        static WCHAR DllNameUnderLocalDirBuffer[DOS_MAX_PATH_LENGTH];
        BOOLEAN fIsKnownDll = TRUE;  // not know yet,

        NewDllNameUnderImageDir.Buffer = DllNameUnderImageDirBuffer;
        NewDllNameUnderImageDir.Length = 0 ;
        NewDllNameUnderImageDir.MaximumLength = sizeof(DllNameUnderImageDirBuffer) ;

        NewDllNameUnderLocalDir.Buffer = DllNameUnderLocalDirBuffer;
        NewDllNameUnderLocalDir.Length = 0 ;
        NewDllNameUnderLocalDir.MaximumLength = sizeof(DllNameUnderLocalDirBuffer) ;

        Status = RtlComputePrivatizedDllName_U(&Unicode, &NewDllNameUnderImageDir, &NewDllNameUnderLocalDir) ;
        if(!NT_SUCCESS(Status))
            goto Exit;

        if ((RtlDoesFileExists_U(NewDllNameUnderLocalDir.Buffer)) ||
            (RtlDoesFileExists_U(NewDllNameUnderImageDir.Buffer)))
            fIsKnownDll = FALSE;

        //cleanup
        if (NewDllNameUnderLocalDir.Buffer != DllNameUnderLocalDirBuffer)
            (*RtlFreeStringRoutine)(NewDllNameUnderLocalDir.Buffer);

        if (NewDllNameUnderImageDir.Buffer != DllNameUnderImageDirBuffer)
            (*RtlFreeStringRoutine)(NewDllNameUnderImageDir.Buffer);

        if (!fIsKnownDll) { // must not be a known dll
            Status = STATUS_SUCCESS;
            goto Exit;
        }
    }

    // If the DLL is being redirected via Fusion/Side-by-Side support, don't bother with the
    // KnownDLL mechanism.
    Status = RtlFindActivationContextSectionString(
            0,              // flags - none for now
            NULL,           // default section group
            ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION,
            &Unicode,       // string to look for
            NULL);          // we don't want any data back, just look for existence

    if ((Status != STATUS_SXS_SECTION_NOT_FOUND) &&
        (Status != STATUS_SXS_KEY_NOT_FOUND))
    {
        if (!NT_SUCCESS(Status))
            goto Exit;

        Status = STATUS_SUCCESS;
        goto Exit;
    }

    //
    // now compute the full name for the dll
    //

    FullLength = LdrpKnownDllPath.Length +  // path prefix e.g. c:\windows\system32
                 RtlCanonicalDosPathSeperatorString.Length +
                 Unicode.Length; // base

    if (FullLength > UNICODE_STRING_MAX_BYTES) {
        Status = STATUS_NAME_TOO_LONG;
        goto Exit;
    }

    Status = LdrpAllocateUnicodeString(&FullDllName, (USHORT) FullLength);
    if (!NT_SUCCESS(Status))
        goto Exit;

    RtlAppendUnicodeStringToString(&FullDllName, &LdrpKnownDllPath);
    RtlAppendUnicodeStringToString(&FullDllName, &RtlCanonicalDosPathSeperatorString);
    RtlAppendUnicodeStringToString(&FullDllName, &Unicode);

    ASSERT(FullDllName.Length == FullLength);

    //
    // open the section object
    //

    InitializeObjectAttributes(
        &Obja,
        &Unicode,
        OBJ_CASE_INSENSITIVE,
        LdrpKnownDllObjectDirectory,
        NULL
        );

    Status = NtOpenSection(
            &Section,
            SECTION_MAP_READ | SECTION_MAP_EXECUTE | SECTION_MAP_WRITE,
            &Obja);

    if (!NT_SUCCESS(Status)) {
        // STATUS_OBJECT_NAME_NOT_FOUND is the expected reason to fail, so it's OK
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
            Status = STATUS_SUCCESS;

        goto Exit;
    }

#if DBG
    LdrpSectionOpens++;
#endif // DBG

    BaseDllNameOut->Length = Unicode.Length;
    BaseDllNameOut->MaximumLength = Unicode.Length + sizeof(WCHAR);
    BaseDllNameOut->Buffer = (PWSTR) (((ULONG_PTR) FullDllName.Buffer) + (FullDllName.Length - Unicode.Length));

    *FullDllNameOut = FullDllName;
    FullDllName.Length = 0;
    FullDllName.MaximumLength = 0;
    FullDllName.Buffer = NULL;

    *SectionOut = Section;
    Section = NULL;

    Status = STATUS_SUCCESS;

Exit:
    if (Section != NULL)
        NtClose(Section);

    if (FullDllName.Buffer != NULL)
        LdrpFreeUnicodeString(&FullDllName);

    return Status;
}

NTSTATUS
LdrpSetProtection (
    IN PVOID Base,
    IN BOOLEAN Reset,
    IN BOOLEAN StaticLink
    )

/*++

Routine Description:

    This function loops thru the images sections/objects, setting
    all sections/objects marked r/o to r/w. It also resets the
    original section/object protections.

Arguments:

    Base - Base of image.

    Reset - If TRUE, reset section/object protection to original
            protection described by the section/object headers.
            If FALSE, then set all sections/objects to r/w.

    StaticLink - TRUE if this is a static link.

Return Value:

    SUCCESS or reason NtProtectVirtualMemory failed.

--*/

{
    HANDLE CurrentProcessHandle;
    SIZE_T RegionSize;
    ULONG NewProtect, OldProtect;
    PVOID VirtualAddress;
    ULONG i;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_SECTION_HEADER SectionHeader;
    NTSTATUS st;

    CurrentProcessHandle = NtCurrentProcess();

    NtHeaders = RtlImageNtHeader(Base);

    if (! NtHeaders) {
        return STATUS_INVALID_IMAGE_FORMAT;
    }

#if defined(BUILD_WOW6432)
    if (NtHeaders->OptionalHeader.SectionAlignment < NATIVE_PAGE_SIZE) {
        //
        // if SectionAlignment < PAGE_SIZE the entire image is
        // exec-copy on write, so we have nothing to do.
        //
        return STATUS_SUCCESS;
        }
#endif

    SectionHeader = (PIMAGE_SECTION_HEADER)((ULONG_PTR)NtHeaders + sizeof(ULONG) +
                        sizeof(IMAGE_FILE_HEADER) +
                        NtHeaders->FileHeader.SizeOfOptionalHeader
                        );

    for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {
        if (!(SectionHeader->Characteristics & IMAGE_SCN_MEM_WRITE) &&
             (SectionHeader->SizeOfRawData))
         {
            //
            // Object isn't writeable and has a non-zero on disk size, change it.
            //
            if (Reset) {
                if (SectionHeader->Characteristics & IMAGE_SCN_MEM_EXECUTE) {
                    NewProtect = PAGE_EXECUTE;
                } else {
                         NewProtect = PAGE_READONLY;
                }
                NewProtect |= (SectionHeader->Characteristics & IMAGE_SCN_MEM_NOT_CACHED) ? PAGE_NOCACHE : 0;
            } else {
                NewProtect = PAGE_READWRITE;
            }
            VirtualAddress = (PVOID)((ULONG_PTR)Base + SectionHeader->VirtualAddress);
            RegionSize = SectionHeader->SizeOfRawData;

            if (RegionSize != 0) {
                st = NtProtectVirtualMemory(CurrentProcessHandle, &VirtualAddress,
                              &RegionSize, NewProtect, &OldProtect);

                if (!NT_SUCCESS(st)) {
                    return st;
                }
            }

        }
        ++SectionHeader;
    }

    if (Reset) {
        NtFlushInstructionCache(NtCurrentProcess(), NULL, 0);
    }
    return STATUS_SUCCESS;
}

NTSTATUS
LdrpResolveDllNameForAppPrivateRedirection(
    PCUNICODE_STRING DllNameString,
    PUNICODE_STRING FullDllName
    )
/*++

Routine Description:

    This function takes a DLL name that's to be loaded, and if there was
    a .local file in the app dir to cause redirection, returns the full
    path to the file.

Arguments:

    DllNameString - Name of the DLL under consideration.  May be a full or
        partially qualified path.

    FullDllName - output string.  Must be deallocated using
        LdrpFreeUnicodeString().  If no redirection was present, the
        length will be left zero.

Return Value:

    NTSTATUS indicating the success/failure of this function.

--*/

{
    NTSTATUS st = STATUS_INTERNAL_ERROR;

    UNICODE_STRING FullDllNameUnderImageDir;
    UNICODE_STRING FullDllNameUnderLocalDir;

    // These two are static to relieve some stack size issues; this function is only called with the
    // loader lock taken so access is properly synchronized.
    static WCHAR DllNameUnderImageDirBuffer[DOS_MAX_PATH_LENGTH];
    static WCHAR DllNameUnderLocalDirBuffer[DOS_MAX_PATH_LENGTH];

    // Initialize these so that cleanup at the Exit: label an always just check whether
    // they're not null and don't point to the static buffers and then free them.

    FullDllNameUnderImageDir.Buffer = DllNameUnderImageDirBuffer;
    FullDllNameUnderImageDir.Length = 0 ;
    FullDllNameUnderImageDir.MaximumLength = sizeof(DllNameUnderImageDirBuffer);

    FullDllNameUnderLocalDir.Buffer = DllNameUnderLocalDirBuffer;
    FullDllNameUnderLocalDir.Length = 0 ;
    FullDllNameUnderLocalDir.MaximumLength = sizeof(DllNameUnderLocalDirBuffer);

    if (FullDllName != NULL) {
        FullDllName->Length = 0;
        FullDllName->MaximumLength = 0;
        FullDllName->Buffer = NULL;
    }

    if ((FullDllName == NULL) ||
        (DllNameString == NULL)) {
        st = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    st = RtlValidateUnicodeString(0, DllNameString);
    if (!NT_SUCCESS(st))
        goto Exit;

    if ((NtCurrentPeb()->ProcessParameters != NULL) &&
        (NtCurrentPeb()->ProcessParameters->Flags & RTL_USER_PROC_DLL_REDIRECTION_LOCAL) &&
        (DllNameString->Length != 0)) { // dll redirection with .local
        st = RtlComputePrivatizedDllName_U(DllNameString, &FullDllNameUnderImageDir, &FullDllNameUnderLocalDir);
        if(!NT_SUCCESS(st)) {
            DbgPrintEx(
                DPFLTR_LDR_ID,
                DPFLTR_ERROR_LEVEL,
                "LDR: %s call to RtlComputePrivatizedDllName_U() failed with status %lx\n",
                __FUNCTION__,
                st);
            goto Exit;
        }

        if (RtlDoesFileExists_U(FullDllNameUnderLocalDir.Buffer)) {// there is a local dll, use it
            st = LdrpCopyUnicodeString(FullDllName, &FullDllNameUnderLocalDir);
            if (!NT_SUCCESS(st)) {
                if (ShowSnaps)
                    DbgPrintEx(
                        DPFLTR_LDR_ID,
                        DPFLTR_ERROR_LEVEL,
                        "LDR: %s calling LdrpCopyUnicodeString() failed; exiting with status %lx\n",
                        __FUNCTION__,
                        st);

                goto Exit;
            }
        } else if (RtlDoesFileExists_U(FullDllNameUnderImageDir.Buffer)) { // there is a local dll, use it
            st = LdrpCopyUnicodeString(FullDllName, &FullDllNameUnderImageDir);
            if (!NT_SUCCESS(st)) {
                if (ShowSnaps)
                    DbgPrintEx(
                        DPFLTR_LDR_ID,
                        DPFLTR_ERROR_LEVEL,
                        "LDR: %s calling LdrpCopyUnicodeString() failed; exiting with status %lx\n",
                        __FUNCTION__,
                        st);

                goto Exit;
            }
        }
    }

    st = STATUS_SUCCESS;
Exit:
    if ((FullDllNameUnderImageDir.Buffer != NULL) &&
        (FullDllNameUnderImageDir.Buffer != DllNameUnderImageDirBuffer))
        (*RtlFreeStringRoutine)(FullDllNameUnderImageDir.Buffer);

    if ((FullDllNameUnderLocalDir.Buffer != NULL) &&
        (FullDllNameUnderLocalDir.Buffer != DllNameUnderLocalDirBuffer))
        (*RtlFreeStringRoutine)(FullDllNameUnderLocalDir.Buffer);

    return st;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\ldrutil.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ldrutil.c

Abstract:

    This module implements utility functions used by the NT loader.

    It was forked from the ldrsnap.c source file since ldrsnap.c
    was growing enourmous.

Author:

    Michael Grier (MGrier) 04-Apr-2001, derived mostly from
        Mike O'Leary (mikeol) 23-Mar-1990

Revision History:

--*/

#define LDRDBG 0

#include "ntos.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntpsapi.h>
#include <heap.h>
#include "ldrp.h"
#include "sxstypes.h"
#include <limits.h>

#define DLL_EXTENSION L".DLL"
#define DLL_REDIRECTION_LOCAL_SUFFIX L".Local"

#define INVALID_HANDLE_VALUE ((HANDLE) ((LONG_PTR) -1))

BOOLEAN LdrpBreakOnExceptions = FALSE;

PLDR_DATA_TABLE_ENTRY
LdrpAllocateDataTableEntry(
    IN PVOID DllBase
    )

/*++

Routine Description:

    This function allocates an entry in the loader data table. If the
    table is going to overflow, then a new table is allocated.

Arguments:

    DllBase - Supplies the address of the base of the DLL Image.
        be added to the loader data table.

Return Value:

    Returns the address of the allocated loader data table entry

--*/

{
    PLDR_DATA_TABLE_ENTRY Entry;
    PIMAGE_NT_HEADERS NtHeaders;

    NtHeaders = RtlImageNtHeader(DllBase);

    Entry = NULL;
    if ( NtHeaders ) {
        Entry = RtlAllocateHeap(LdrpHeap, MAKE_TAG( LDR_TAG ) | HEAP_ZERO_MEMORY, sizeof(*Entry));
        if ( Entry ) {
            Entry->DllBase = DllBase;
            Entry->SizeOfImage = NtHeaders->OptionalHeader.SizeOfImage;
            Entry->TimeDateStamp = NtHeaders->FileHeader.TimeDateStamp;
        }
    }
    return Entry;
}

VOID
LdrpDeallocateDataTableEntry(
    IN PLDR_DATA_TABLE_ENTRY Entry
    )
{
    if (Entry != NULL)
        RtlFreeHeap(LdrpHeap, 0, Entry);
}

VOID
LdrpFinalizeAndDeallocateDataTableEntry(
    IN PLDR_DATA_TABLE_ENTRY Entry
    )
{
    if (Entry != NULL) {
        if ((Entry->EntryPointActivationContext != NULL) &&
            (Entry->EntryPointActivationContext != INVALID_HANDLE_VALUE)) {
            RtlReleaseActivationContext(Entry->EntryPointActivationContext);
            Entry->EntryPointActivationContext = INVALID_HANDLE_VALUE;
        }

        if (Entry->FullDllName.Buffer != NULL) {
            LdrpFreeUnicodeString(&Entry->FullDllName);

            RtlInitEmptyUnicodeString(&Entry->FullDllName, NULL, 0);
            RtlInitEmptyUnicodeString(&Entry->BaseDllName, NULL, 0);
        }

        LdrpDeallocateDataTableEntry(Entry);
    }

}

NTSTATUS
RtlComputePrivatizedDllName_U(
    IN PCUNICODE_STRING DllName,
    IN OUT PUNICODE_STRING NewDllNameUnderImageDir,
    IN OUT PUNICODE_STRING NewDllNameUnderLocalDir
    )

/*++

Routine Description:

    This function computes a fully qualified path to a DLL name. It takes
    the path of the current process and the base name from DllName and
    puts these together. DllName can have '\' or '/' as separator.

Arguments:

    DllName - Points to a string that names the library file. This can be
        a fully qualified name or just a base name. We will parse for the base
        name (the portion after the last '\' or '/' char. Caller guarantees that
        DllName->Buffer is not a NULL pointer!

    NewDllName - Has fully qualified path based on GetModuleFileNameW(NULL...)
        and the base name from above.

Return Value:

    NTSTATUS: Currently: STATUS_NO_MEMORY or STATUS_SUCCESS.

--*/

{
    LPWSTR p, pp, pp1, pp2;
    PWSTR  Dot;
    LPWSTR pFullImageName;
    USHORT cbFullImageNameLength;
    USHORT cbFullImagePathLengthWithTrailingSlash, cbDllFileNameLengthWithTrailingNULL;
    USHORT cbDllNameUnderImageDir, cbDllNameUnderLocalDir;
    ULONG  cbStringLength;
    PWSTR  Cursor = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    LPWSTR pDllNameUnderImageDir = NULL;
    LPWSTR pDllNameUnderLocalDir = NULL;
    LPCWSTR pBuf1 = NewDllNameUnderImageDir->Buffer;
    LPCWSTR pBuf2 = NewDllNameUnderLocalDir->Buffer;

    cbFullImageNameLength = NtCurrentPeb()->ProcessParameters->ImagePathName.Length;
    pFullImageName = (PWSTR)NtCurrentPeb()->ProcessParameters->ImagePathName.Buffer;

    if (!(NtCurrentPeb()->ProcessParameters->Flags & RTL_USER_PROC_PARAMS_NORMALIZED)) {
        pFullImageName = (PWSTR)((PCHAR)pFullImageName + (ULONG_PTR)(NtCurrentPeb()->ProcessParameters));
    }

    ASSERT(pFullImageName != NULL);

    // Find the end of the EXE path (start of its base-name) in pp1.
    // Size1 is number of bytes;

    p = pFullImageName + cbFullImageNameLength/sizeof(WCHAR) - 1; // point to last character of this name
    pp1 = NULL;
    while (p != pFullImageName) {
        if (RTL_IS_PATH_SEPARATOR(*p)) {
            pp1 = p + 1;
            break;
        }
        p-- ;
    }

    // Find the basename portion of the DLL to be loaded in pp2 and the
    // last '.' character if present in the basename.
    pp2 = DllName->Buffer;
    Dot = NULL ;
    if (DllName->Length) {
        ASSERT(RTL_STRING_IS_NUL_TERMINATED(DllName)); // temporary debugging
        p = DllName->Buffer + (DllName->Length>>1) - 1; // point to last char
        while (p != DllName->Buffer) {
            if (*p == (WCHAR) '.') {
                if (!Dot) {
                    Dot = p ;
                    }
                }
            else {
                if ((*p == (WCHAR) '\\') || (*p == (WCHAR) '/')) {
                    pp2 = p + 1;
                    break;
                    }
                }
            p--;
        }
    }

    // Create a fully qualified path to the DLL name (using pp1 and pp2)

    // Number of bytes (not including NULL or EXE/process folder)
    if (((pp1 - pFullImageName) * sizeof(WCHAR)) > ULONG_MAX) {
            DbgPrint("ntdll: wants more than ULONG_MAX bytes \n");
            goto Exit;
    }

    cbStringLength = (ULONG)((pp1 - pFullImageName) * sizeof(WCHAR));
    if ( cbStringLength > UNICODE_STRING_MAX_BYTES ) {
        status = STATUS_NAME_TOO_LONG;
        goto Exit;
    }

    cbFullImagePathLengthWithTrailingSlash = (USHORT)cbStringLength;

    // Number of bytes in base DLL name (including trailing null char)
    cbDllFileNameLengthWithTrailingNULL = (USHORT)(DllName->Length + sizeof(WCHAR) - ((pp2 - DllName->Buffer) * sizeof(WCHAR)));

    cbStringLength = cbFullImagePathLengthWithTrailingSlash
                     + cbDllFileNameLengthWithTrailingNULL;

    // Allocate room for L".DLL"
    if (Dot == NULL)
        cbStringLength  += sizeof(DLL_EXTENSION) - sizeof(WCHAR);

    if ( cbStringLength > UNICODE_STRING_MAX_BYTES ) {
        status = STATUS_NAME_TOO_LONG;
        goto Exit;
    }

    cbDllNameUnderImageDir = (USHORT)cbStringLength;

    if (cbDllNameUnderImageDir > NewDllNameUnderImageDir->MaximumLength) {
        pDllNameUnderImageDir = (*RtlAllocateStringRoutine)(cbDllNameUnderImageDir);
        if (pDllNameUnderImageDir == NULL) {
            status = STATUS_NO_MEMORY ;
            goto Exit;
        }
    }else
        pDllNameUnderImageDir = NewDllNameUnderImageDir->Buffer;

    Cursor = pDllNameUnderImageDir;
    RtlCopyMemory(Cursor, pFullImageName, cbFullImagePathLengthWithTrailingSlash);
    Cursor = pDllNameUnderImageDir + cbFullImagePathLengthWithTrailingSlash / sizeof(WCHAR);

    RtlCopyMemory(Cursor, pp2, cbDllFileNameLengthWithTrailingNULL - sizeof(WCHAR)) ;
    Cursor += (cbDllFileNameLengthWithTrailingNULL - sizeof(WCHAR)) / sizeof(WCHAR);

    if (!Dot) {
            // If there is no '.' in the basename add the ".DLL" to it.
            //
            //  The -1 will work just as well as - sizeof(WCHAR) as we are dividing by
            // sizeof(WCHAR) and it will be rounded down correctly as Size1 and Size2 are
            // even. The -1 could be more optimal than subtracting sizeof(WCHAR)
            //
            RtlCopyMemory(Cursor, DLL_EXTENSION, sizeof(DLL_EXTENSION));
            cbDllFileNameLengthWithTrailingNULL += sizeof(DLL_EXTENSION) - sizeof(WCHAR) ; // Mark base name as being 8 bytes bigger.
    } else
        *Cursor = L'\0';

    cbStringLength = cbFullImageNameLength
                + sizeof(DLL_REDIRECTION_LOCAL_SUFFIX) - sizeof(WCHAR) //.local
                + sizeof(WCHAR) // "\\"
                + cbDllFileNameLengthWithTrailingNULL;

    if (cbStringLength > UNICODE_STRING_MAX_BYTES) {
        status = STATUS_NAME_TOO_LONG;
        goto Exit;
    }

    cbDllNameUnderLocalDir = (USHORT)cbStringLength;

    if ( cbDllNameUnderLocalDir > NewDllNameUnderLocalDir->MaximumLength) {
        pDllNameUnderLocalDir = (RtlAllocateStringRoutine)(cbDllNameUnderLocalDir);
        if (!pDllNameUnderLocalDir) {
            status = STATUS_NO_MEMORY ;
            goto Exit;
        }
    }else
        pDllNameUnderLocalDir = NewDllNameUnderLocalDir->Buffer;

    Cursor = pDllNameUnderLocalDir;
    RtlCopyMemory(Cursor, pFullImageName, cbFullImageNameLength);
    Cursor = pDllNameUnderLocalDir + cbFullImageNameLength / sizeof(WCHAR);

    RtlCopyMemory(Cursor, DLL_REDIRECTION_LOCAL_SUFFIX, sizeof(DLL_REDIRECTION_LOCAL_SUFFIX) - sizeof(WCHAR)) ;
    Cursor += (sizeof(DLL_REDIRECTION_LOCAL_SUFFIX) - sizeof(WCHAR)) / sizeof(WCHAR);

    *Cursor = L'\\';
    Cursor += 1;

    RtlCopyMemory(Cursor,
                  pDllNameUnderImageDir + cbFullImagePathLengthWithTrailingSlash/sizeof(WCHAR),
                  cbDllFileNameLengthWithTrailingNULL) ;


    NewDllNameUnderImageDir->Buffer = pDllNameUnderImageDir ;
    if ( pDllNameUnderImageDir != pBuf1) // if memory is not-reallocated, MaximumLength should be untouched
        NewDllNameUnderImageDir->MaximumLength =  cbFullImagePathLengthWithTrailingSlash + cbDllFileNameLengthWithTrailingNULL;
    NewDllNameUnderImageDir->Length = (USHORT)(cbDllNameUnderImageDir - sizeof(WCHAR));


    NewDllNameUnderLocalDir->Buffer = pDllNameUnderLocalDir;
    if (pDllNameUnderLocalDir != pBuf2)
        NewDllNameUnderLocalDir->MaximumLength = cbDllNameUnderLocalDir;
    NewDllNameUnderLocalDir->Length = (USHORT)(cbDllNameUnderLocalDir - sizeof(WCHAR));

    status = STATUS_SUCCESS ;

Exit:
    if (!NT_SUCCESS(status)) {
        if (pDllNameUnderImageDir != pBuf1)
           (RtlFreeStringRoutine)(pDllNameUnderImageDir);
        if (pDllNameUnderLocalDir != pBuf2)
           (RtlFreeStringRoutine)(pDllNameUnderLocalDir);
    }

    return status;
}

NTSTATUS
LdrpAllocateUnicodeString(
    OUT PUNICODE_STRING StringOut,
    IN USHORT Length
    )
/*++

Routine Description:

    This routine allocates space for a UNICODE_STRING from the loader
    private heap.

Arguments:

    StringOut - Pointer to UNICODE_STRING in which the information about
        the allocated string is written.  Any previous contents of StringOut
        are overwritten and lost.

    Length - length, in bytes, of the string which StringOut must be able
        to hold.

Return Value:

    NTSTATUS indicating success or failure of this function.  In general
    the only reasons it fails are STATUS_NO_MEMORY when the heap allocation
    cannot be performed or STATUS_INVALID_PARAMETER when an invalid parameter
    value is passed in.

--*/
{
    NTSTATUS st = STATUS_INTERNAL_ERROR; // returned if someone messes up and forgets to otherwise set it

    if (StringOut != NULL) {
        StringOut->Length = 0;
        StringOut->MaximumLength = 0;
        StringOut->Buffer = NULL;
    }

    if ((StringOut == NULL) ||
        ((Length % sizeof(WCHAR)) != 0)) {
        st = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    StringOut->Buffer = RtlAllocateHeap(LdrpHeap, 0, Length + sizeof(WCHAR));
    if (StringOut->Buffer == NULL) {
        st = STATUS_NO_MEMORY;
        goto Exit;
    }

    StringOut->Buffer[Length / sizeof(WCHAR)] = L'\0';
    StringOut->Length = 0;

    // If the true length of the buffer can be represted in 16 bits, store it; otherwise
    // store the biggest number we can.
    if (Length != UNICODE_STRING_MAX_BYTES)
        StringOut->MaximumLength = Length + sizeof(WCHAR);
    else
        StringOut->MaximumLength = Length;

    st = STATUS_SUCCESS;
Exit:
    return st;
}


NTSTATUS
LdrpCopyUnicodeString(
    OUT PUNICODE_STRING StringOut,
    IN PCUNICODE_STRING StringIn
    )
/*++

Routine Description:

    This function makes a copy of a unicode string; the important aspect
    of it is that the string is allocated from the loader private heap.

Arguments:

    StringOut - Pointer to UNICODE_STRING in which the information about
        the copied string is written.  Any previous contents of StringOut
        are overwritten and lost.

    StringIn - Pointer to constant UNICODE_STRING which is copied.

Return Value:

    NTSTATUS indicating success or failure of this function.  In general
    the only reason it fails is STATUS_NO_MEMORY when the heap allocation
    cannot be performed.

--*/

{
    NTSTATUS st = STATUS_INTERNAL_ERROR;
    ULONG BytesNeeded = 0;

    if (StringOut != NULL) {
        StringOut->Length = 0;
        StringOut->MaximumLength = 0;
        StringOut->Buffer = NULL;
    }

    if ((StringOut == NULL) ||
        (StringIn == NULL)) {
        st = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    st = RtlValidateUnicodeString(0, StringIn);
    if (!NT_SUCCESS(st))
        goto Exit;

    st = LdrpAllocateUnicodeString(StringOut, StringIn->Length);
    if (!NT_SUCCESS(st))
        goto Exit;

    RtlCopyMemory(StringOut->Buffer, StringIn->Buffer, StringIn->Length);
    StringOut->Length = StringIn->Length;

    st = STATUS_SUCCESS;
Exit:
    return st;
}

VOID
LdrpFreeUnicodeString(
    IN OUT PUNICODE_STRING StringIn
    )
/*++

Routine Description:

    This function deallocates a string that was allocated using
    LdrpCopyUnicodeString.

Arguments:

    String - Pointer to UNICODE_STRING which is to be freed.  On exit,
                all the members are set to 0/null as appropriate.

Return Value:

    None

--*/

{
    if (StringIn != NULL) {
        if (StringIn->Buffer != NULL) {
            RtlFreeHeap(LdrpHeap, 0, StringIn->Buffer);
        }

        StringIn->Length = 0;
        StringIn->MaximumLength = 0;
        StringIn->Buffer = NULL;
    }
}

VOID
LdrpEnsureLoaderLockIsHeld(
    VOID
    )
{
    BOOLEAN LoaderLockIsHeld =
        ((LdrpInLdrInit) ||
         ((LdrpShutdownInProgress) &&
          (LdrpShutdownThreadId == NtCurrentTeb()->ClientId.UniqueThread)) ||
         (LdrpLoaderLock.OwningThread == NtCurrentTeb()->ClientId.UniqueThread));

    ASSERT(LoaderLockIsHeld);

    if (!LoaderLockIsHeld)
        RtlRaiseStatus(STATUS_NOT_LOCKED);
}

int
LdrpGenericExceptionFilter(
    IN const struct _EXCEPTION_POINTERS *ExceptionPointers,
    IN PCSTR FunctionName
    )
/*++

Routine Description:

    Exception filter function used in __try block throughout the loader
    code instead of just specifying __except(EXCEPTION_EXECUTE_HANDLER).

Arguments:

    ExceptionPointers
        Pointer to exception information returned by GetExceptionInformation() in the __except()

    FunctionName
        Name of the function in which the __try block appears.


Return Value:

    EXCEPTION_EXECUTE_HANDLER

--*/
{
    const ULONG ExceptionCode = ExceptionPointers->ExceptionRecord->ExceptionCode;

    DbgPrintEx(
        DPFLTR_LDR_ID,
        LDR_ERROR_DPFLTR,
        "LDR: exception %08lx thrown within function %s\n"
        "   Exception record: %p\n"
        "   Context record: %p\n",
        ExceptionCode, FunctionName,
        ExceptionPointers->ExceptionRecord,
        ExceptionPointers->ContextRecord);

#ifdef _X86_
    // It would be nice to have a generic context dumper but right now I'm just trying to
    // debug X86 and this is the quick thing to do.  -mgrier 4/8/2001
    DbgPrintEx(
        DPFLTR_LDR_ID,
        LDR_ERROR_DPFLTR,
        "   Context->Eip = %p\n"
        "   Context->Ebp = %p\n"
        "   Context->Esp = %p\n",
        ExceptionPointers->ContextRecord->Eip,
        ExceptionPointers->ContextRecord->Ebp,
        ExceptionPointers->ContextRecord->Esp);
#endif // _X86_

    if (LdrpBreakOnExceptions) {
        char Response[2];

        for (;;) {
            DbgPrint("\n***Exception thrown within loader***\n");
            DbgPrompt(
                "Break repeatedly, break Once, Ignore, terminate Process or terminate Thread (boipt)? ",
                Response,
                sizeof(Response));

            switch (Response[0]) {
            case 'b':
            case 'B':
            case 'o':
            case 'O':
                DbgPrint("Execute '.cxr %p' to dump context\n", ExceptionPointers->ContextRecord);

                DbgBreakPoint();

                if ((Response[0] == 'o') || (Response[0] == 'O'))
                    return EXCEPTION_EXECUTE_HANDLER;

            case 'I':
            case 'i':
                return EXCEPTION_EXECUTE_HANDLER;

            case 'P':
            case 'p':
                NtTerminateProcess( NtCurrentProcess(), ExceptionCode);
                break;

            case 'T':
            case 't':
                NtTerminateThread( NtCurrentThread(), ExceptionCode);
                break;
            }
        }
    }

    return EXCEPTION_EXECUTE_HANDLER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\ldrwx86.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ldrwx86.c

Abstract:

    This module implements the wx86 specific ldr functions.

Author:

    13-Jan-1995 Jonle , created

Revision History:

    15-Oct-1998 CBiks   Modified the code that throws the architecture
                        mismatch exception so the exception is only
                        thrown for NT 3,0 and lower executables.  This was
                        changed to make the Wx86 loader behave like the
                        real loader, which does not throw this exception.

                        Also added a call to the cleanup function when
                        LdrpWx86LoadDll() fails.  There were cases where the
                        CPU failed to initialize but the Wx86 global pointers
                        were not cleared and pointed to a invalid memory because
                        wx86.dll was unloaded.
                        
    13-Mar-2001 SamerA  Fix sharing of varialbes inside a SHARED read/write section.
    
    20-May-2001 SamerA  Fix mapping of image sections that have their PointerToRawData
                        RVA overlap with other sections virtual addresses.
                        (Fixed corel's WP2002 intro.exe)
    
    24-Oct-2001 SamerA  Correct calculation of variables offsets inside the relocated
                        shared section.                    
--*/

#include "ntos.h"
#include "ldrp.h"

#define PAGE_SIZE_X86   (0x1000)

#if defined(BUILD_WOW6432)


//   
// From mi\mi.h:
//

#define MI_ROUND_TO_SIZE(LENGTH,ALIGNMENT)     \
                    (((LENGTH) + ((ALIGNMENT) - 1)) & ~((ALIGNMENT) - 1))
                    
PIMAGE_BASE_RELOCATION LdrpWx86ProcessRelocationBlock(
    IN ULONG_PTR VA,
    IN PUCHAR ImageBase,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN ULONG Diff,
    IN ULONG_PTR SectionStartVA,
    IN ULONG_PTR SectionEndVA);

NTSTATUS 
FixupBlockList(
    IN PUCHAR ImageBase);

VOID 
FixupSectionHeader(
    IN PUCHAR ImageBase);


NTSTATUS
LdrpWx86FixupExportedSharedSection (
    IN PVOID ImageBase,
    IN PIMAGE_NT_HEADERS NtHeaders
    );


BOOLEAN
LdrpWx86DetectSectionOverlap (
    IN PVOID ImageBase,
    IN PIMAGE_NT_HEADERS NtHeaders
    )
{
    PIMAGE_SECTION_HEADER SectionHeader;
    ULONG SrcRawData;
    ULONG SrcEndRawData;
    ULONG OverlapData;
    ULONG EndOverlapData;
    ULONG SrcSize;
    ULONG Section;
    ULONG SectionCheck;
    ULONG Count;
    BOOLEAN Result = FALSE;


    //
    // Run through the section and see if any one need to be moved down (higher in address space),
    // then for each one of those, check if it overlap with any section
    // that has already been moved up.
    //

    SectionHeader = IMAGE_FIRST_SECTION (NtHeaders);

    for (Section = NtHeaders->FileHeader.NumberOfSections-1, Count=0 ; 
         Count < NtHeaders->FileHeader.NumberOfSections ; Section--, Count++) {

        SrcRawData = SectionHeader[Section].PointerToRawData;
        SrcSize = SectionHeader[Section].SizeOfRawData;
        if ((SectionHeader[Section].Misc.VirtualSize > 0) &&
            (SrcRawData > MI_ROUND_TO_SIZE(SectionHeader[Section].Misc.VirtualSize, PAGE_SIZE_X86))) {
           SrcRawData = MI_ROUND_TO_SIZE(SectionHeader[Section].Misc.VirtualSize, PAGE_SIZE_X86);
        }

        if (SectionHeader[Section].VirtualAddress <= SrcRawData) {
            break;
        }
        
        SrcEndRawData = SrcRawData + SrcSize;

        //
        // This section needs to be moved down
        //
        for (SectionCheck = 0 ; SectionCheck < NtHeaders->FileHeader.NumberOfSections ; SectionCheck++) {

            if (Section == SectionCheck) {
                continue;
            }

            OverlapData = SectionHeader[SectionCheck].PointerToRawData;
            SrcSize = SectionHeader[SectionCheck].SizeOfRawData;
            if ((SectionHeader[SectionCheck].Misc.VirtualSize > 0) &&
                (SrcRawData > MI_ROUND_TO_SIZE(SectionHeader[SectionCheck].Misc.VirtualSize, PAGE_SIZE_X86))) {
               SrcRawData = MI_ROUND_TO_SIZE(SectionHeader[SectionCheck].Misc.VirtualSize, PAGE_SIZE_X86);
            }

            if (SectionHeader[SectionCheck].VirtualAddress > OverlapData) {
                break;
            }

            if (((SrcRawData >= SectionHeader[SectionCheck].VirtualAddress) && 
                (SrcRawData < (SectionHeader[SectionCheck].VirtualAddress + SrcSize))) || 
                ((SrcEndRawData >= SectionHeader[SectionCheck].VirtualAddress) &&
                 (SrcEndRawData < (SectionHeader[SectionCheck].VirtualAddress + SrcSize)))) {

                Result = TRUE;
                break;
            }
        }

        if (Result == TRUE) {
            break;
        }

    }

    return Result;
}

NTSTATUS
LdrpWx86CheckVirtualSectionOverlap (
    IN PUNICODE_STRING ImageName OPTIONAL,
    IN PVOID ImageBase,
    IN PIMAGE_NT_HEADERS NtHeaders,
    OUT PVOID *SrcImageMap
    )

/*++

Routine Description:


    This function goes through the image sections based at ImageBase and looks
    for any overlap between the section physical locations and their updated virtual
    locations.

Arguments:

    ImageName - Unicode string pointer to the full path to the image.
    
    ImageBase - Base of image.

    SrcImageMap - Pointer to pointer to receive a base pointer to the image mapped
        as read-only pages inside this process. The mapped pages need to be released
        when done.

Return Value:

    NTSTATUS.

--*/

{
    PUNICODE_STRING NtPathName;
    PVOID FreeBuffer;
    BOOLEAN Result;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PVOID ViewBase;
    SIZE_T ViewSize;
    LARGE_INTEGER SectionOffset;
    UCHAR Buffer[ DOS_MAX_PATH_LENGTH ];
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;


    //
    // Check for any overlap inside the image.
    //
    
    Result = LdrpWx86DetectSectionOverlap (ImageBase, NtHeaders);

    if (Result == FALSE) {
        return NtStatus;
    }

    FreeBuffer = NULL;

    //
    // Make sure we have a path.
    //
    
    NtPathName = (PUNICODE_STRING)Buffer;
    if (ARGUMENT_PRESENT (ImageName) == 0) {

        NtStatus = NtQueryInformationProcess(
                       NtCurrentProcess(),
                       ProcessImageFileName,
                       NtPathName,
                       sizeof (Buffer),
                       NULL
                       );
    } else {

        Result = RtlDosPathNameToNtPathName_U(
                     ImageName->Buffer,
                     NtPathName,
                     NULL,
                     NULL
                     );
        
        if (Result != FALSE) {
            
            FreeBuffer = NtPathName->Buffer;
            NtStatus = STATUS_SUCCESS;
        }
    }

    if (NT_SUCCESS (NtStatus)) {

        InitializeObjectAttributes(
            &ObjectAttributes,
            NtPathName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );


        NtStatus = NtCreateFile(
                       &FileHandle,
                       (ACCESS_MASK) GENERIC_READ | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                       &ObjectAttributes,
                       &IoStatusBlock,
                       NULL,
                       0L,
                       FILE_SHARE_READ | FILE_SHARE_DELETE,
                       FILE_OPEN,
                       0L,
                       NULL,
                       0L
                       );

        if (FreeBuffer != NULL) {
            RtlFreeHeap (RtlProcessHeap(), 0, FreeBuffer);
        }

        if (NT_SUCCESS (NtStatus)) {

            NtStatus = NtCreateSection(
                           &MappingHandle,
                           STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ,
                           NULL,
                           NULL,
                           PAGE_READONLY,
                           SEC_COMMIT,
                           FileHandle
                           );

            NtClose (FileHandle);

            if (NT_SUCCESS (NtStatus)) {

                SectionOffset.LowPart = 0;
                SectionOffset.HighPart = 0;
                ViewSize = 0;
                ViewBase = NULL;

                NtStatus = NtMapViewOfSection(
                               MappingHandle,
                               NtCurrentProcess(),
                               &ViewBase,
                               0L,
                               0L,
                               &SectionOffset,
                               &ViewSize,
                               ViewShare,
                               0L,
                               PAGE_READONLY
                               );

                NtClose (MappingHandle);

                if (NT_SUCCESS (NtStatus)) {
                    *SrcImageMap = ViewBase;
                }
            }
        }
    }

    return NtStatus;
}




NTSTATUS
Wx86SetRelocatedSharedProtection (
    IN PVOID Base,
    IN BOOLEAN Reset
    )

/*++

Routine Description:


    This function loops thru the images sections/objects, setting
    all relocated shared sections/objects marked r/o to r/w. It also resets the
    original section/object protections.

Arguments:

    Base - Base of image.

    Reset - If TRUE, reset section/object protection to original
            protection described by the section/object headers.
            If FALSE, then set all sections/objects to r/w.

Return Value:

    SUCCESS or reason NtProtectVirtualMemory failed.

--*/

{
    HANDLE CurrentProcessHandle;
    SIZE_T RegionSize;
    ULONG NewProtect, OldProtect;
    PVOID VirtualAddress;
    ULONG i;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_SECTION_HEADER SectionHeader;
    NTSTATUS st;
    ULONG NumberOfSharedDataPages;
    SIZE_T NumberOfNativePagesForImage;

    CurrentProcessHandle = NtCurrentProcess();

    NtHeaders = RtlImageNtHeader(Base);

    SectionHeader = (PIMAGE_SECTION_HEADER)((ULONG_PTR)NtHeaders + sizeof(ULONG) +
                        sizeof(IMAGE_FILE_HEADER) +
                        NtHeaders->FileHeader.SizeOfOptionalHeader
                        );

    NumberOfSharedDataPages = 0;
    NumberOfNativePagesForImage =
        NATIVE_BYTES_TO_PAGES (NtHeaders->OptionalHeader.SizeOfImage);

    for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++, SectionHeader++) {
        
        RegionSize = SectionHeader->SizeOfRawData;
        if ((SectionHeader->Characteristics & IMAGE_SCN_MEM_SHARED) && 
            (!(SectionHeader->Characteristics & IMAGE_SCN_MEM_EXECUTE) ||
             (SectionHeader->Characteristics & IMAGE_SCN_MEM_WRITE)) &&
            (RegionSize != 0)) {
            
            VirtualAddress = (PVOID)((ULONG_PTR)Base + 
                                    ((NumberOfNativePagesForImage + NumberOfSharedDataPages) << NATIVE_PAGE_SHIFT));
            NumberOfNativePagesForImage +=  MI_ROUND_TO_SIZE (RegionSize, NATIVE_PAGE_SIZE) >> NATIVE_PAGE_SHIFT;

            if (!(SectionHeader->Characteristics & IMAGE_SCN_MEM_WRITE)) {
                //
                // Object isn't writeable, so change it.
                //
                if (Reset) {
                    if (SectionHeader->Characteristics & IMAGE_SCN_MEM_EXECUTE) {
                        NewProtect = PAGE_EXECUTE;
                    } 
                    else {
                        NewProtect = PAGE_READONLY;
                    }
                    NewProtect |= (SectionHeader->Characteristics & IMAGE_SCN_MEM_NOT_CACHED) ? PAGE_NOCACHE : 0;
                } 
                else {
                    NewProtect = PAGE_READWRITE;
                }

                st = NtProtectVirtualMemory(CurrentProcessHandle, &VirtualAddress,
                                            &RegionSize, NewProtect, &OldProtect);

                if (!NT_SUCCESS(st)) {
                    return st;
                }
            }
        }
    }

    if (Reset) {
        NtFlushInstructionCache(NtCurrentProcess(), 
                                Base, 
                                NumberOfNativePagesForImage << NATIVE_PAGE_SHIFT
                               );
    }

    return STATUS_SUCCESS;
}

NTSTATUS
LdrpWx86FormatVirtualImage(
    IN PUNICODE_STRING DosImagePathName,
    IN PIMAGE_NT_HEADERS32 NtHeaders,
    IN PVOID DllBase
    )
{
   PIMAGE_SECTION_HEADER SectionTable, Section, LastSection, FirstSection;
   ULONG VirtualImageSize;
   PUCHAR NextVirtualAddress, SrcVirtualAddress, DestVirtualAddress;
   PUCHAR ImageBase= DllBase;
   LONG Size;
   ULONG NumberOfSharedDataPages;
   ULONG NumberOfNativePagesForImage;
   ULONG NumberOfExtraPagesForImage;
   ULONG_PTR PreferredImageBase;
   BOOLEAN ImageHasRelocatedSharedSection = FALSE;
   ULONG SubSectionSize;
   PVOID AlternateBase;
   NTSTATUS st;

   
   AlternateBase = NULL;
   st = LdrpWx86CheckVirtualSectionOverlap (DosImagePathName,
                                            DllBase,
                                            NtHeaders,
                                            &AlternateBase
                                            );

   st = Wx86SetRelocatedSharedProtection(DllBase, FALSE);
   if (!NT_SUCCESS(st)) {
       DbgPrint("Wx86SetRelocatedSharedProtection failed with return status %x\n", st);
       Wx86SetRelocatedSharedProtection(DllBase, TRUE);
       if (AlternateBase != NULL) {
           NtUnmapViewOfSection (NtCurrentProcess(), AlternateBase);
       }
       return st;
   }

   //
   // Copy each section from its raw file address to its virtual address
   //

   SectionTable = IMAGE_FIRST_SECTION(NtHeaders);
   LastSection = SectionTable + NtHeaders->FileHeader.NumberOfSections;

   if (SectionTable->PointerToRawData == SectionTable->VirtualAddress) {
       // If the first section does not need to be moved then we exclude it
       // from consideration in passes 1 and 2
       FirstSection = SectionTable + 1;
       }
   else {
       FirstSection = SectionTable;
       }

   //
   // First pass starts at the top and works down moving up each section that
   // is to be moved up.
   //
   Section = FirstSection;
   while (Section < LastSection) {
       SrcVirtualAddress = ImageBase + Section->PointerToRawData;
       DestVirtualAddress = Section->VirtualAddress + ImageBase;

       if (DestVirtualAddress > SrcVirtualAddress) {
           // Section needs to be moved down
           break;
           }

       // Section needs to be moved up
      if (Section->SizeOfRawData != 0) {
          if (Section->PointerToRawData != 0) {
              RtlMoveMemory(DestVirtualAddress,
                            SrcVirtualAddress,
                            Section->SizeOfRawData);
              }
          }
      else {
          Section->PointerToRawData = 0;
          }

       Section++;
       }

   //
   // Second pass is from the end of the image and work backwards since src and
   // dst overlap
   //
   Section = --LastSection;
   NextVirtualAddress = ImageBase + NtHeaders->OptionalHeader.SizeOfImage;

   while (Section >= FirstSection) {
       SrcVirtualAddress = ImageBase + Section->PointerToRawData;
       DestVirtualAddress = Section->VirtualAddress + ImageBase;

       //
       // Compute the subsection size.  The mm is really flexible here...
       // it will allow a SizeOfRawData that far exceeds the virtual size,
       // so we can't trust that.  If that happens, just use the page-aligned
       // virtual size, since that is all that the mm will map in.
       //
       SubSectionSize = Section->SizeOfRawData;
       if (Section->Misc.VirtualSize &&
           SubSectionSize > MI_ROUND_TO_SIZE(Section->Misc.VirtualSize, PAGE_SIZE_X86)) {
          SubSectionSize = MI_ROUND_TO_SIZE(Section->Misc.VirtualSize, PAGE_SIZE_X86);
       }

      //
      // ensure Virtual section doesn't overlap the next section
      //
      if (DestVirtualAddress + SubSectionSize > NextVirtualAddress) {
          Wx86SetRelocatedSharedProtection(DllBase, TRUE);
          if (AlternateBase != NULL) {
              NtUnmapViewOfSection (NtCurrentProcess(), AlternateBase);
          }
          return STATUS_INVALID_IMAGE_FORMAT;
          }

       if (DestVirtualAddress < SrcVirtualAddress) {
           // Section needs to be moved up
           break;
           }

       // Section needs to be moved down
      if (Section->SizeOfRawData != 0) {
          if (Section->PointerToRawData != 0) {
              RtlMoveMemory(DestVirtualAddress,
                     (AlternateBase != NULL) ? 
                            ((PCHAR)AlternateBase + Section->PointerToRawData) : SrcVirtualAddress,
                     SubSectionSize);
              }
          }
      else {
          Section->PointerToRawData = 0;
          }

       NextVirtualAddress = DestVirtualAddress;
       Section--;
       }

   //
   // Third pass is for zeroing out any memory left between the end of a
   // section and the end of the page. We'll do this from end to top
   //
   Section = LastSection;
   NextVirtualAddress = ImageBase + NtHeaders->OptionalHeader.SizeOfImage;

   NumberOfSharedDataPages = 0;  
   while (Section >= SectionTable) {
       DestVirtualAddress = Section->VirtualAddress + ImageBase;

      //
      // Shared Data sections cannot be shared, because of
      // page misalignment, and are treated as Exec- Copy on Write.
      //
       if ((Section->Characteristics & IMAGE_SCN_MEM_SHARED) && 
           (!(Section->Characteristics & IMAGE_SCN_MEM_EXECUTE) ||
            (Section->Characteristics & IMAGE_SCN_MEM_WRITE))) {
          ImageHasRelocatedSharedSection = TRUE;
#if 0
          DbgPrint("Unsuported IMAGE_SCN_MEM_SHARED %x\n",
                   Section->Characteristics
                   );
#endif
      }

      //
      // If section was empty zero it out
      //
      if (Section->SizeOfRawData != 0) {
          if (Section->PointerToRawData == 0) {
              RtlZeroMemory(DestVirtualAddress,
                            Section->SizeOfRawData
                            );
              }
          }


      SubSectionSize = Section->SizeOfRawData;
      if (Section->Misc.VirtualSize &&
          SubSectionSize > MI_ROUND_TO_SIZE(Section->Misc.VirtualSize, PAGE_SIZE_X86)) {
          SubSectionSize = MI_ROUND_TO_SIZE(Section->Misc.VirtualSize, PAGE_SIZE_X86);
      }


      //
      // Zero out remaining bytes up to the next section
      //
      RtlZeroMemory(DestVirtualAddress + Section->SizeOfRawData,
                    (ULONG)(NextVirtualAddress - DestVirtualAddress - SubSectionSize)
                    );

       NextVirtualAddress = DestVirtualAddress;
       Section--;
       }

   //
   // Unmap the alternate base if it is there
   //
   if (AlternateBase != NULL) {
       NtUnmapViewOfSection (NtCurrentProcess(), AlternateBase);
   }

   // Pass 4: if the dll has any shared sections, change the shared data
   // references to point to additional shared pages at the end of the image.
   //
   // Note that our fixups are applied assuming that the dll is loaded at
   // its preferred base; if it is loaded at some other address, it will
   // be relocated again along will al other addresses.


   if (!ImageHasRelocatedSharedSection) {
       goto LdrwWx86FormatVirtualImageDone;
   }



   st = FixupBlockList(DllBase);
   if (!NT_SUCCESS(st)) {
       Wx86SetRelocatedSharedProtection(DllBase, TRUE);
       return st;
   }

   NumberOfNativePagesForImage =
        NATIVE_BYTES_TO_PAGES (NtHeaders->OptionalHeader.SizeOfImage);
   NumberOfExtraPagesForImage = 0;

   // Account for raw data that extends beyond SizeOfImage

   for (Section = SectionTable; Section <= LastSection; Section++)
   {
       ULONG EndOfSection;
       ULONG ExtraPages;
       ULONG ImagePages = NATIVE_BYTES_TO_PAGES (NtHeaders->OptionalHeader.SizeOfImage);
       
       EndOfSection = Section->PointerToRawData + Section->SizeOfRawData;
       
       if (NATIVE_BYTES_TO_PAGES (EndOfSection) > ImagePages) {
           
           ExtraPages = NATIVE_BYTES_TO_PAGES (EndOfSection) - ImagePages;
           if (ExtraPages > NumberOfExtraPagesForImage) {
               NumberOfExtraPagesForImage = ExtraPages;
           }
       }
   }

   PreferredImageBase = NtHeaders->OptionalHeader.ImageBase;

   NumberOfNativePagesForImage += NumberOfExtraPagesForImage;
   NumberOfSharedDataPages = 0;
   for (Section = SectionTable; Section <= LastSection; Section++)
   {
        ULONG bFirst = 1;

        if ((Section->Characteristics & IMAGE_SCN_MEM_SHARED) && 
            (!(Section->Characteristics & IMAGE_SCN_MEM_EXECUTE) ||
             (Section->Characteristics & IMAGE_SCN_MEM_WRITE))) 
        {
            PIMAGE_BASE_RELOCATION NextBlock;
            PUSHORT NextOffset;
            ULONG TotalBytes;
            ULONG SizeOfBlock;
            ULONG_PTR VA;
            ULONG_PTR SectionStartVA;
            ULONG_PTR SectionEndVA;
            ULONG SectionVirtualSize;
            ULONG Diff;

            SectionVirtualSize = Section->Misc.VirtualSize;
            if (SectionVirtualSize == 0)
            {
                SectionVirtualSize = Section->SizeOfRawData;
            }

            SectionStartVA = PreferredImageBase + Section->VirtualAddress;
            SectionEndVA = SectionStartVA + SectionVirtualSize;


            NextBlock = RtlImageDirectoryEntryToData(DllBase, TRUE,
                                        IMAGE_DIRECTORY_ENTRY_BASERELOC,
                                        &TotalBytes);
            if (!NextBlock || !TotalBytes)
            {
                // Note that if this fails, it should fail in the very
                // first iteration and no fixups would have been performed

                if (!bFirst)
                {
                    // Trouble
                    if (ShowSnaps)
                    {
                        DbgPrint("LdrpWx86FormatVirtualImage: failure "
                        "after relocating some sections for image at %x\n",
                                DllBase);
                    }
                    Wx86SetRelocatedSharedProtection(DllBase, TRUE);
                    return STATUS_INVALID_IMAGE_FORMAT;
                }

                if (ShowSnaps)
                {
                    DbgPrint("LdrpWx86FormatVirtualImage: No fixup info "
                                "for image at %x; private sections will be "
                                "used for shared data sections.\n",
                            DllBase);
                }
                break;
            }

            bFirst = 0;

            Diff = (NumberOfNativePagesForImage +
                                NumberOfSharedDataPages) << NATIVE_PAGE_SHIFT;
            Diff -= (ULONG) (SectionStartVA - PreferredImageBase);

            if (ShowSnaps)
            {
                DbgPrint("LdrpWx86FormatVirtualImage: Relocating shared "
                         "data for shared data section 0x%x of image "
                         "at %x by 0x%lx bytes\n",
                         Section - SectionTable + 1, DllBase, Diff);
            }

            while (TotalBytes)
            {
                SizeOfBlock = NextBlock->SizeOfBlock;
                if (SizeOfBlock == 0) {
                    
                    if (ShowSnaps) {
                        DbgPrint("Image at %lx contains invalid block size. Stopping fixups\n", 
                                 ImageBase);
                    }
                    break;
                }
                TotalBytes -= SizeOfBlock;
                SizeOfBlock -= sizeof(IMAGE_BASE_RELOCATION);
                SizeOfBlock /= sizeof(USHORT);
                NextOffset = (PUSHORT) ((PCHAR)NextBlock +
                                        sizeof(IMAGE_BASE_RELOCATION));
                VA = (ULONG_PTR) DllBase + NextBlock->VirtualAddress;

                NextBlock = LdrpWx86ProcessRelocationBlock(VA, DllBase, SizeOfBlock,
                                                        NextOffset,
                                                        Diff,
                                                        SectionStartVA,
                                                        SectionEndVA);
                if (NextBlock == NULL)
                {
                    // Trouble
                    if (ShowSnaps)
                    {
                        DbgPrint("LdrpWx86FormatVirtualImage: failure "
                        "after relocating some sections for image at %x; "
                        "Relocation information invalid\n",
                                DllBase);
                    }
                    Wx86SetRelocatedSharedProtection(DllBase, TRUE);
                    return STATUS_INVALID_IMAGE_FORMAT;
                }
            }
            NumberOfSharedDataPages += MI_ROUND_TO_SIZE (SectionVirtualSize,
                                                        NATIVE_PAGE_SIZE) >>
                                                        NATIVE_PAGE_SHIFT;

        }
   }


   //
   // If any of the variables inside the shared section is exported, then
   // we need to fix up its RVA to point to the proper location at
   // the end of the image.
   //

   LdrpWx86FixupExportedSharedSection (
       DllBase,
       NtHeaders
       );



LdrwWx86FormatVirtualImageDone:
   //
   // Zero out first section's Raw Data up to its VirtualAddress
   //
   if (SectionTable->PointerToRawData != 0) {
       DestVirtualAddress = SectionTable->PointerToRawData + ImageBase;
       Size = (LONG)(NextVirtualAddress - DestVirtualAddress);
       if (Size > 0) {
           RtlZeroMemory(DestVirtualAddress,
                     (ULONG)Size
                     );
           }
   }

   Wx86SetRelocatedSharedProtection(DllBase, TRUE);
   return STATUS_SUCCESS;

}


NTSTATUS
LdrpWx86FixupExportedSharedSection (
    IN PVOID ImageBase,
    IN PIMAGE_NT_HEADERS NtHeaders
    )

/*++

Routine Description:


    This function goes through the exported entries from this module,
    and relocates (fixup) any address that lie inside any shared
    read/write to the end of the image.

Arguments:

    ImageBase - Virtual address for image base.
    
    NtHeaders - Address of the image's header.

Return Value:

    NTSTATUS.

--*/

{
    PIMAGE_EXPORT_DIRECTORY ImageExportDirectory;
    ULONG TotalBytes;
    ULONG SharedRelocFixup;
    ULONG Export;
    PULONG ExportEntry;
    NTSTATUS NtStatus = STATUS_SUCCESS;


    ImageExportDirectory = RtlImageDirectoryEntryToData (
        ImageBase, 
        TRUE,                                            
        IMAGE_DIRECTORY_ENTRY_EXPORT,
        &TotalBytes);

    if ((ImageExportDirectory == NULL) || (TotalBytes == 0)) {
        return NtStatus;
    }

    ExportEntry = (PULONG)((ULONG)ImageBase + ImageExportDirectory->AddressOfFunctions);

    for (Export = 0 ; Export < ImageExportDirectory->NumberOfFunctions ; Export++) {

        SharedRelocFixup = LdrpWx86RelocatedFixupDiff (
            ImageBase,
            NtHeaders,
            ExportEntry[Export]
            );

        if (SharedRelocFixup != 0) {

            if (ShowSnaps) {
                DbgPrint("LdrpWx86FixupExportedSharedSection: Changing export Export[%lx] from %lx to %lx\n", 
                         Export, 
                         ExportEntry[Export], 
                         ExportEntry [Export] + SharedRelocFixup);
            }
            ExportEntry [Export] += SharedRelocFixup;
        }

    }

    return NtStatus;
}

////////////////////////////////////////////////////

ULONG
LdrpWx86RelocatedFixupDiff(
    IN PUCHAR ImageBase,
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN ULONG  Offset
    )
{
   PIMAGE_SECTION_HEADER SectionHeader;
   ULONG i;
   ULONG NumberOfSharedDataPages;
   ULONG NumberOfNativePagesForImage;
   ULONG Diff = 0;
   ULONG_PTR FixupAddr = (ULONG_PTR)(ImageBase + Offset);

   SectionHeader = (PIMAGE_SECTION_HEADER)((ULONG_PTR)NtHeaders + sizeof(ULONG) +
                    sizeof(IMAGE_FILE_HEADER) +
                    NtHeaders->FileHeader.SizeOfOptionalHeader
                    );

   NumberOfNativePagesForImage =
        NATIVE_BYTES_TO_PAGES (NtHeaders->OptionalHeader.SizeOfImage);
   NumberOfSharedDataPages = 0;

   for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++, SectionHeader++) 
   {
       ULONG_PTR SectionStartVA;
       ULONG_PTR SectionEndVA;
       ULONG SectionVirtualSize;

       SectionVirtualSize = SectionHeader->Misc.VirtualSize;
       if (SectionVirtualSize == 0) {
           SectionVirtualSize = SectionHeader->SizeOfRawData;
       }

       SectionStartVA = (ULONG_PTR)ImageBase + SectionHeader->VirtualAddress;
       SectionEndVA = SectionStartVA + SectionVirtualSize;

       if (((ULONG_PTR)FixupAddr >= SectionStartVA) && ((ULONG_PTR)FixupAddr <= SectionEndVA)) {
           if ((SectionHeader->Characteristics & IMAGE_SCN_MEM_SHARED) && 
               (!(SectionHeader->Characteristics & IMAGE_SCN_MEM_EXECUTE) ||
                (SectionHeader->Characteristics & IMAGE_SCN_MEM_WRITE))) {
               Diff = (NumberOfNativePagesForImage +
                       NumberOfSharedDataPages) << NATIVE_PAGE_SHIFT;
               Diff -= (ULONG)SectionHeader->VirtualAddress;
           }
           break;
       }
 
       if ((SectionHeader->Characteristics & IMAGE_SCN_MEM_SHARED) && 
           (!(SectionHeader->Characteristics & IMAGE_SCN_MEM_EXECUTE) ||
            (SectionHeader->Characteristics & IMAGE_SCN_MEM_WRITE))) {
           NumberOfSharedDataPages += MI_ROUND_TO_SIZE (SectionVirtualSize,
                                                        NATIVE_PAGE_SIZE) >>
                                                        NATIVE_PAGE_SHIFT;
       }
   }

   return Diff;
}


NTSTATUS 
FixupBlockList(
    IN PUCHAR ImageBase)
{
   PIMAGE_BASE_RELOCATION NextBlock;
   PUSHORT NextOffset;
   ULONG TotalBytes;
   ULONG SizeOfBlock;
   PIMAGE_NT_HEADERS NtHeaders;

   NTSTATUS st;

   NextBlock = RtlImageDirectoryEntryToData(ImageBase, TRUE,
                                            IMAGE_DIRECTORY_ENTRY_BASERELOC,
                                            &TotalBytes);

   if (!NextBlock || !TotalBytes) {
       if (ShowSnaps) {
           DbgPrint("LdrpWx86FixupBlockList: No fixup info "
                    "for image at %x; private sections will be "
                    "used for shared data sections.\n",
                    ImageBase);
       }
       return STATUS_SUCCESS;
   }

   NtHeaders = RtlImageNtHeader (ImageBase);

   while (TotalBytes) {
       
       SizeOfBlock = NextBlock->SizeOfBlock;
       
       if (SizeOfBlock == 0) {

           if (ShowSnaps) {
               DbgPrint("Image at %lx contains invalid block size. Stopping fixups\n", 
                        ImageBase);
           }
           break;
       }
       TotalBytes -= SizeOfBlock;
       SizeOfBlock -= sizeof(IMAGE_BASE_RELOCATION);
       SizeOfBlock /= sizeof(USHORT);
       NextOffset = (PUSHORT) ((PCHAR)NextBlock +
                               sizeof(IMAGE_BASE_RELOCATION));
       
       NextBlock->VirtualAddress += LdrpWx86RelocatedFixupDiff (
           ImageBase, 
           NtHeaders,
           NextBlock->VirtualAddress
           );

       while (SizeOfBlock--) {
           switch ((*NextOffset) >> 12) {
               case IMAGE_REL_BASED_HIGHLOW :
               case IMAGE_REL_BASED_HIGH :
               case IMAGE_REL_BASED_LOW :
                   break;

               case IMAGE_REL_BASED_HIGHADJ :
                   ++NextOffset;
                   --SizeOfBlock;
                   break;

               case IMAGE_REL_BASED_IA64_IMM64:
               case IMAGE_REL_BASED_DIR64:
               case IMAGE_REL_BASED_MIPS_JMPADDR :
               case IMAGE_REL_BASED_ABSOLUTE :
               case IMAGE_REL_BASED_SECTION :
               case IMAGE_REL_BASED_REL32 :
                   break;

               default :
                   return STATUS_INVALID_IMAGE_FORMAT;
           }
           ++NextOffset;
       }

       NextBlock = (PIMAGE_BASE_RELOCATION)NextOffset;

       if (NextBlock == NULL) {
           // Trouble
           if (ShowSnaps) {
               DbgPrint("LdrpWx86FixupBlockList: failure "
                        "after relocating some sections for image at %x; "
                        "Relocation information invalid\n",
                        ImageBase);
           }
           return STATUS_INVALID_IMAGE_FORMAT;
      }
   }

   return STATUS_SUCCESS;
}


BOOLEAN
LdrpWx86DllHasRelocatedSharedSection(
    IN PUCHAR ImageBase)
{
   PIMAGE_SECTION_HEADER SectionHeader;
   ULONG i;
   PIMAGE_NT_HEADERS32 NtHeaders = (PIMAGE_NT_HEADERS32)RtlImageNtHeader(ImageBase);

   SectionHeader = (PIMAGE_SECTION_HEADER)((ULONG_PTR)NtHeaders + sizeof(ULONG) +
                    sizeof(IMAGE_FILE_HEADER) +
                    NtHeaders->FileHeader.SizeOfOptionalHeader
                    );

   for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++, SectionHeader++) 
   {
       if ((SectionHeader->Characteristics & IMAGE_SCN_MEM_SHARED) && 
           (!(SectionHeader->Characteristics & IMAGE_SCN_MEM_EXECUTE) ||
            (SectionHeader->Characteristics & IMAGE_SCN_MEM_WRITE))) {
           return TRUE;
       }
   }

   return FALSE;
}


////////////////////////////////////////////////

// Following fn is adapted from rtl\ldrreloc.c; it should be updated when
// that function changes. Eliminated 64 bit address relocations.
//
// Note: Instead of calling this routine, we could call
//     LdrpProcessRelocationBlock(VA, 1, NextOffset, Diff)
//
// but we should do that only if the address to be relocated is between
// SectionStartVA and SectionEndVA. So we would have to replicate all the
// code in the switch stmt below that computes the address of the data item -
// which is pretty much the entire function. So we chose to replicate the
// function as it was and change it to make the test.

PIMAGE_BASE_RELOCATION LdrpWx86ProcessRelocationBlock(
    IN ULONG_PTR VA,
    IN PUCHAR ImageBase,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN ULONG Diff,
    IN ULONG_PTR SectionStartVA,
    IN ULONG_PTR SectionEndVA)
{
    PUCHAR FixupVA;
    USHORT Offset;
    LONG Temp;
    ULONG_PTR DataVA;


    while (SizeOfBlock--) {

       Offset = *NextOffset & (USHORT)0xfff;
       FixupVA = (PUCHAR)(VA + Offset);
       //
       // Apply the fixups.
       //

       switch ((*NextOffset) >> 12) {

            case IMAGE_REL_BASED_HIGHLOW :
                //
                // HighLow - (32-bits) relocate the high and low half
                //      of an address.
                //
                Temp = *(LONG UNALIGNED *)FixupVA;
                DataVA = (ULONG_PTR) Temp;
                if (DataVA >= SectionStartVA && DataVA <= SectionEndVA)
                {
                    Temp += (ULONG) Diff;
                    *(LONG UNALIGNED *)FixupVA = Temp;
                }

                break;

            case IMAGE_REL_BASED_HIGH :
                //
                // High - (16-bits) relocate the high half of an address.
                //
                Temp = *(PUSHORT)FixupVA << 16;
                DataVA = (ULONG_PTR) Temp;
                if (DataVA >= SectionStartVA && DataVA <= SectionEndVA)
                {
                    Temp += (ULONG) Diff;
                    *(PUSHORT)FixupVA = (USHORT)(Temp >> 16);
                }
                break;

            case IMAGE_REL_BASED_HIGHADJ :
                //
                // Adjust high - (16-bits) relocate the high half of an
                //      address and adjust for sign extension of low half.
                //
                Temp = *(PUSHORT)FixupVA << 16;
                ++NextOffset;
                --SizeOfBlock;
                Temp += (LONG)(*(PSHORT)NextOffset);
                DataVA = (ULONG_PTR) Temp;
                if (DataVA >= SectionStartVA && DataVA <= SectionEndVA)
                {
                    Temp += (ULONG) Diff;
                    Temp += 0x8000;
                    *(PUSHORT)FixupVA = (USHORT)(Temp >> 16);
                }
                break;

            case IMAGE_REL_BASED_LOW :
                //
                // Low - (16-bit) relocate the low half of an address.
                //
                Temp = *(PSHORT)FixupVA;
                DataVA = (ULONG_PTR) Temp;
                if (DataVA >= SectionStartVA && DataVA <= SectionEndVA)
                {
                    Temp += (ULONG) Diff;
                    *(PUSHORT)FixupVA = (USHORT)Temp;
                }
                break;

            case IMAGE_REL_BASED_IA64_IMM64:

                //
                // Align it to bundle address before fixing up the
                // 64-bit immediate value of the movl instruction.
                //

                // No need to support

                break;

            case IMAGE_REL_BASED_DIR64:

                //
                // Update 32-bit address
                //

                // No need to support

                break;

            case IMAGE_REL_BASED_MIPS_JMPADDR :
                //
                // JumpAddress - (32-bits) relocate a MIPS jump address.
                //

                // No need to support
                break;

            case IMAGE_REL_BASED_ABSOLUTE :
                //
                // Absolute - no fixup required.
                //
                break;

            case IMAGE_REL_BASED_SECTION :
                //
                // Section Relative reloc.  Ignore for now.
                //
                break;

            case IMAGE_REL_BASED_REL32 :
                //
                // Relative intrasection. Ignore for now.
                //
                break;

            default :
                //
                // Illegal - illegal relocation type.
                //

                return (PIMAGE_BASE_RELOCATION)NULL;
       }
       ++NextOffset;
    }
    return (PIMAGE_BASE_RELOCATION)NextOffset;
}

#endif  // BUILD_WOW6432
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\importtablehash.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ImportTableHash.h

Abstract:

    This module contains hash computation routine 
    RtlComputeImportTableHash to compute the hash 
    based on the import table of an exe.
    

Author:

    Vishnu Patankar (vishnup) 31-May-2001

Revision History:


--*/

#ifndef _ITH_
#define _ITH_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <process.h>
#include <stdlib.h>
#include <string.h>

//
// MD5 hashes are of size 16 bytes
//

#define ITH_REVISION_1  1

#define IMPORT_TABLE_MAX_HASH_SIZE 16

typedef struct _IMPORTTABLEP_IMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY {
    struct _IMPORTTABLEP_IMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY  *Next;
    PSZ String;
} IMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY, *PIMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY;

typedef struct _IMPORTTABLEP_IMPORTTABLEP_SORTED_LIST_ENTRY {
    struct _IMPORTTABLEP_IMPORTTABLEP_SORTED_LIST_ENTRY *Next;
    PSZ String;
    PIMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY FunctionList;
} IMPORTTABLEP_SORTED_LIST_ENTRY, *PIMPORTTABLEP_SORTED_LIST_ENTRY;

VOID
ImportTablepInsertModuleSorted(
    IN PIMPORTTABLEP_SORTED_LIST_ENTRY   pImportName,
    OUT PIMPORTTABLEP_SORTED_LIST_ENTRY * ppImportNameList
    );

VOID
ImportTablepFreeModuleSorted(
    IN PIMPORTTABLEP_SORTED_LIST_ENTRY pImportNameList
    );

VOID
ImportTablepInsertFunctionSorted(
    IN  PIMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY   pFunctionName,
    OUT PIMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY * ppFunctionNameList
    );

VOID
ImportTablepFreeFunctionSorted(
    IN PIMPORTTABLEP_SORTED_FUNCTION_LIST_ENTRY pFunctionNameList
    );

NTSTATUS
ImportTablepHashCanonicalLists( 
    IN  PIMPORTTABLEP_SORTED_LIST_ENTRY ImportedNameList, 
    OUT PBYTE Hash
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\ntdll.inc ===
!if defined(BUILD_CHECKED_KERNEL)
NTDEBUG=ntsd
FREEBUILD=0
!endif

!include $(PROJECT_ROOT)\prerelease.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\lpcsvr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       lpcsvr.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-12-97   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __LPCSVR_H__
#define __LPCSVR_H__

struct _LPCSVR_MESSAGE ;

typedef struct _LPCSVR_SERVER {
    LARGE_INTEGER Timeout ;         // Default Timeout
    RTL_CRITICAL_SECTION Lock ;     // Lock
    LPCSVR_INITIALIZE Init ;        // Callback functions
    LIST_ENTRY ContextList ;        // List of active contexts
    ULONG ContextCount ;            // Count of contexts
    HANDLE Port ;                   // Server Port
    HANDLE WaitHandle ;             // Thread pool handle
    ULONG Flags ;                   // Flags (below)
    ULONG MessageSize ;             // Size for a message
    struct _LPCSVR_MESSAGE * MessagePool ; // List of message buffers
    ULONG MessagePoolSize ;         // Number of messages
    ULONG MessagePoolLimit ;        // max # messages
    ULONG ReceiveThreads ;          // Number of threads with Recieve pending
    HANDLE ShutdownEvent ;          // Event to signal during shutdown
} LPCSVR_SERVER, * PLPCSVR_SERVER ;

#define LPCSVR_WAITABLE         0x00000001
#define LPCSVR_SHUTDOWN_PENDING 0x00000002
#define LPCSVR_SYNCHRONOUS      0x00000004


typedef struct _LPCSVR_CONTEXT {
    LIST_ENTRY List ;
    PLPCSVR_SERVER Server ;
    HANDLE CommPort ;
    LONG RefCount ;
    UCHAR PrivateContext[ 4 ];
} LPCSVR_CONTEXT, * PLPCSVR_CONTEXT ;

typedef struct _LPCSVR_MESSAGE {
    union {
        struct _LPCSVR_MESSAGE * Next ;
        struct _LPCSVR_CONTEXT * Context ;
    } Header ;

    PORT_MESSAGE Message ;

} LPCSVR_MESSAGE, * PLPCSVR_MESSAGE ;



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\pch.cxx ===
#define RTL_DECLARE_STREAMS 1
#define RTL_DECLARE_MEMORY_STREAM 1
#define RTL_DECLARE_FILE_STREAM 1

extern "C" {
#include <nt.h>
#include <ntioapi.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <ddeml.h>      // for CP_WINUNICODE

#include <objidl.h>
#include <propidl.h>

extern "C"
{
#include <propapi.h>
}

#include <stgprop.h>

class PMemoryAllocator;
#include <propstm.hxx>
#include <align.hxx>
#include <sstream.hxx>

#include "propmac.hxx"
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\ntnap.h ===
/*++
Copyright (c) 1991  Microsoft Corporation

Module Name:

    ntnap.h

Abstract:

    This module contains the data structure decalrations for
    profiling of NT API's.

Author:

    Russ Blake (russbl) 22-Apr-1991

Revision History:

--*/

//
// Initialization of minimum times
//

#define MAX_LONG  0x7FFFFFFFL
#define MAX_ULONG 0xFFFFFFFFL

//
// Timer calibration
//

#define NUM_ITERATIONS		      2000  // Number of iterations
#define MIN_ACCEPTABLEOVERHEAD		10  // Minimum overhead allowed
#define NAP_CALIBRATION_SERVICE_NUMBER	-1L // Calibration Routine Number

typedef struct _NAPCONTROL {

    //
    // The following assures the area will be initialized only once.
    // Note: Assumes the section is given to us zero filled.
    //

    BOOLEAN Initialized;

    //
    // Profiling control.  If NapPaused > 0, NapRecordInfo will
    // collect no data.  Used to keep initialization and dumping
    // of data itself from being profiled.
    //

    BOOLEAN Paused;

} NAPCONTROL, *PNAPCONTROL;



extern PCHAR NapNames[];

//
// Called internally
//

VOID	 NapDllInit		(VOID);
VOID	 NapRecordInfo		(IN ULONG, IN LARGE_INTEGER[]);
NTSTATUS NapCreateDataSection	(PNAPCONTROL *);

//
// Called by us
//

extern VOID NapCalibrate	(VOID);
extern VOID NapSpinOnSpinLock  (ULONG *);
extern VOID NapReleaseSpinLock	(ULONG *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\lpcsvr.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       lpcsvr.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-12-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include <ntos.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "lpcsvr.h"

#define RtlpLpcLockServer( s ) RtlEnterCriticalSection( &s->Lock );
#define RtlpLpcUnlockServer( s ) RtlLeaveCriticalSection( &s->Lock );

#define RtlpLpcContextFromClient( p ) ( CONTAINING_RECORD( p, LPCSVR_CONTEXT, PrivateContext ) )

//+---------------------------------------------------------------------------
//
//  Function:   RtlpLpcDerefContext
//
//  Synopsis:   Deref the context.  If this context is being cleaned up after
//              the server has been deleted, then the message is freed directly,
//              rather than being released to the general queue.
//
//  Arguments:  [Context] --
//              [Message] --
//
//  History:    2-06-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
RtlpLpcDerefContext(
    PLPCSVR_CONTEXT Context,
    PLPCSVR_MESSAGE Message
    )
{
    PLPCSVR_SERVER Server ;

    Server = Context->Server ;

    if ( InterlockedDecrement( &Context->RefCount ) < 0 )
    {
        //
        // All gone, time to clean up:
        //

        RtlpLpcLockServer( Server );

        if ( Context->List.Flink )
        {
            RemoveEntryList( &Context->List );

            Server->ContextCount -- ;

        }
        else
        {
            if ( Message )
            {
                RtlFreeHeap( RtlProcessHeap(),
                             0,
                             Message );
            }
        }

        RtlpLpcUnlockServer( Server );

        if ( Context->CommPort )
        {
            NtClose( Context->CommPort );
        }

        RtlFreeHeap( RtlProcessHeap(),
                     0,
                     Context );
    }
    else
    {
        RtlpLpcLockServer( Server );

        Server->MessagePoolSize++ ;

        if ( Server->MessagePoolSize < Server->MessagePoolLimit )
        {
            Message->Header.Next = Server->MessagePool ;

            Server->MessagePool = Message ;
        }
        else
        {
            Server->MessagePoolSize-- ;

            RtlFreeHeap( RtlProcessHeap(),
                         0,
                         Message );

        }

        RtlpLpcUnlockServer( Server );
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   RtlpLpcWorkerThread
//
//  Synopsis:   General worker thread
//
//  Arguments:  [Parameter] --
//
//  History:    2-06-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


VOID
RtlpLpcWorkerThread(
    PVOID Parameter
    )
{
    PLPCSVR_MESSAGE Message ;
    PLPCSVR_CONTEXT Context ;
    NTSTATUS Status ;
    BOOLEAN Accept ;

    Message = (PLPCSVR_MESSAGE) Parameter ;

    Context = Message->Header.Context ;

    switch ( Message->Message.u2.s2.Type & 0xF )
    {
        case LPC_REQUEST:
        case LPC_DATAGRAM:
            DbgPrint("Calling Server's Request function\n");
            Status = Context->Server->Init.RequestFn(
                                &Context->PrivateContext,
                                &Message->Message,
                                &Message->Message
                                );

            if ( NT_SUCCESS( Status ) )
            {
                Status = NtReplyPort( Context->CommPort,
                                      &Message->Message );

                if ( !NT_SUCCESS( Status ) )
                {
                    //
                    // See what happened.  The client may have gone away already.
                    //

                    break;

                }
            }
            break;

        case LPC_CONNECTION_REQUEST:
            DbgPrint("Calling Server's Connect function\n");
            Status = Context->Server->Init.ConnectFn(
                                &Context->PrivateContext,
                                &Message->Message,
                                &Accept
                                );

            //
            // If the comm port is still null, then do the accept.  Otherwise, the
            // server called RtlAcceptConnectPort() explicitly, to set up a view.
            //

            if ( NT_SUCCESS( Status ) )
            {
                if ( Context->CommPort == NULL )
                {
                    Status = NtAcceptConnectPort(
                                    &Context->CommPort,
                                    Context,
                                    &Message->Message,
                                    Accept,
                                    NULL,
                                    NULL );

                    if ( !Accept )
                    {
                        //
                        // Yank the context out of the list, since it is worthless
                        //

                        Context->RefCount = 0 ;

                    }
                    else
                    {
                        Status = NtCompleteConnectPort( Context->CommPort );
                    }
                }

            }
            else
            {
                Status = NtAcceptConnectPort(
                            &Context->CommPort,
                            NULL,
                            &Message->Message,
                            FALSE,
                            NULL,
                            NULL );

                Context->RefCount = 0 ;

            }

            break;

        case LPC_CLIENT_DIED:
            DbgPrint( "Calling Server's Rundown function\n" );
            Status = Context->Server->Init.RundownFn(
                                    &Context->PrivateContext,
                                    &Message->Message
                                    );

            InterlockedDecrement( &Context->RefCount );

            break;

        default:
            //
            // An unexpected message came through.  Normal LPC servers
            // don't handle the other types of messages.  Drop it.
            //

            break;
    }

    RtlpLpcDerefContext( Context, Message );

    return ;


}

VOID
RtlpLpcServerCallback(
    PVOID Parameter,
    BOOLEAN TimedOut
    )
{
    PLPCSVR_SERVER Server ;
    NTSTATUS Status ;
    PLPCSVR_MESSAGE Message ;
    PLPCSVR_CONTEXT Context ;
    PLARGE_INTEGER RealTimeout ;
    LPCSVR_FILTER_RESULT FilterResult ;

    Server = (PLPCSVR_SERVER) Parameter ;

    if ( Server->WaitHandle )
    {
        Server->WaitHandle = NULL ;
    }

    while ( 1 )
    {
        DbgPrint("Entering LPC server\n" );

        RtlpLpcLockServer( Server );

        if ( Server->Flags & LPCSVR_SHUTDOWN_PENDING )
        {
            break;
        }

        if ( Server->MessagePool )
        {
            Message = Server->MessagePool ;
            Server->MessagePool = Message->Header.Next ;
        }
        else
        {
            Message = RtlAllocateHeap( RtlProcessHeap(),
                                       0,
                                       Server->MessageSize );

        }

        RtlpLpcUnlockServer( Server );

        if ( !Message )
        {
            LARGE_INTEGER SleepInterval ;

            SleepInterval.QuadPart = 125 * 10000 ;

            NtDelayExecution( FALSE, &SleepInterval );
            continue;
        }


        if ( Server->Timeout.QuadPart )
        {
            RealTimeout = &Server->Timeout ;
        }
        else
        {
            RealTimeout = NULL ;
        }

        Status = NtReplyWaitReceivePortEx(
                        Server->Port,
                        &Context,
                        NULL,
                        &Message->Message,
                        RealTimeout );

        DbgPrint("Server: NtReplyWaitReceivePort completed with %x\n", Status );

        if ( NT_SUCCESS( Status ) )
        {
            //
            // If we timed out, nobody was waiting for us:
            //

            if ( Status == STATUS_TIMEOUT )
            {
                //
                // Set up a general wait that will call back to this function
                // when ready.
                //

                RtlpLpcLockServer( Server );

                if ( ( Server->Flags & LPCSVR_SHUTDOWN_PENDING ) == 0 )
                {

                    Status = RtlRegisterWait( &Server->WaitHandle,
                                              Server->Port,
                                              RtlpLpcServerCallback,
                                              Server,
                                              0xFFFFFFFF,
                                              WT_EXECUTEONLYONCE );
                }

                RtlpLpcUnlockServer( Server );

                break;

            }

            if ( Status == STATUS_SUCCESS )
            {
                if ( Context )
                {
                    InterlockedIncrement( &Context->RefCount );
                }
                else
                {
                    //
                    // New connection.  Create a new context record
                    //

                    Context = RtlAllocateHeap( RtlProcessHeap(),
                                               0,
                                               sizeof( LPCSVR_CONTEXT ) +
                                                    Server->Init.ContextSize );

                    if ( !Context )
                    {
                        HANDLE Bogus ;

                        Status = NtAcceptConnectPort(
                                    &Bogus,
                                    NULL,
                                    &Message->Message,
                                    FALSE,
                                    NULL,
                                    NULL );

                        RtlpLpcLockServer( Server );

                        Message->Header.Next = Server->MessagePool ;
                        Server->MessagePool = Message ;

                        RtlpLpcUnlockServer( Server );

                        continue;
                    }

                    Context->Server = Server ;
                    Context->RefCount = 1 ;
                    Context->CommPort = NULL ;

                    RtlpLpcLockServer( Server );

                    InsertTailList( &Server->ContextList, &Context->List );
                    Server->ContextCount++ ;

                    RtlpLpcUnlockServer( Server );
                }


                Message->Header.Context = Context ;

                FilterResult = LpcFilterAsync ;

                if ( Server->Init.FilterFn )
                {
                    FilterResult = Server->Init.FilterFn( Context, &Message->Message );

                    if (FilterResult == LpcFilterDrop )
                    {
                        RtlpLpcDerefContext( Context, Message );

                        continue;

                    }
                }

                if ( (Server->Flags & LPCSVR_SYNCHRONOUS) ||
                     (FilterResult == LpcFilterSync) )
                {
                    RtlpLpcWorkerThread( Message );
                }
                else
                {
                    RtlQueueWorkItem( RtlpLpcWorkerThread,
                                      Message,
                                      0 );

                }
            }
        }
        else
        {
            //
            // Error?  Better shut down...
            //

            break;
        }

    }

}

NTSTATUS
RtlCreateLpcServer(
    POBJECT_ATTRIBUTES PortName,
    PLPCSVR_INITIALIZE Init,
    PLARGE_INTEGER IdleTimeout,
    ULONG MessageSize,
    ULONG Options,
    PVOID * LpcServer
    )
{
    PLPCSVR_SERVER Server ;
    NTSTATUS Status ;
    HANDLE Thread ;
    CLIENT_ID Id ;

    *LpcServer = NULL ;

    Server = RtlAllocateHeap( RtlProcessHeap(),
                              0,
                              sizeof( LPCSVR_SERVER ) );

    if ( !Server ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = RtlInitializeCriticalSectionAndSpinCount (&Server->Lock,
                                                       1000);
    if (!NT_SUCCESS (Status)) {
        RtlFreeHeap( RtlProcessHeap(), 0, Server );
        return Status;
    }

    InitializeListHead( &Server->ContextList );
    Server->ContextCount = 0;

    Server->Init = *Init;
    if ( !IdleTimeout ) {
        Server->Timeout.QuadPart = 0;
    } else {
        Server->Timeout = *IdleTimeout;
    }

    Server->MessageSize = MessageSize + sizeof( LPCSVR_MESSAGE ) -
                            sizeof( PORT_MESSAGE );

    Server->MessagePool = 0;
    Server->MessagePoolSize = 0;
    Server->MessagePoolLimit = 4;

    Server->Flags = Options;

    //
    // Create the LPC port:
    //

    Status = NtCreateWaitablePort(
                            &Server->Port,
                            PortName,
                            MessageSize,
                            MessageSize,
                            MessageSize * 4
                            );

    if ( !NT_SUCCESS( Status ) )
    {
        RtlDeleteCriticalSection( &Server->Lock );
        RtlFreeHeap( RtlProcessHeap(), 0, Server );
        return Status;
    }


    //
    // Now, post the handle over to a wait queue
    //
    Status = RtlRegisterWait(
                        &Server->WaitHandle,
                        Server->Port,
                        RtlpLpcServerCallback,
                        Server,
                        0xFFFFFFFF,
                        WT_EXECUTEONLYONCE
                        );

    if (!NT_SUCCESS (Status)) {
        NtClose (Server->Port);
        RtlDeleteCriticalSection( &Server->Lock );
        RtlFreeHeap( RtlProcessHeap(), 0, Server );
        return Status;
    }

    *LpcServer = Server;
    return Status;
}


NTSTATUS
RtlShutdownLpcServer(
    PVOID LpcServer
    )
{
    PLPCSVR_SERVER Server ;
    OBJECT_ATTRIBUTES ObjA ;
    PLIST_ENTRY Scan ;
    PLPCSVR_CONTEXT Context ;
    PLPCSVR_MESSAGE Message ;
    NTSTATUS Status ;

    Server = (PLPCSVR_SERVER) LpcServer ;

    RtlpLpcLockServer( Server );

    if ( Server->Flags & LPCSVR_SHUTDOWN_PENDING )
    {
        RtlpLpcUnlockServer( Server );

        return STATUS_PENDING ;
    }

    if ( Server->WaitHandle )
    {
        RtlDeregisterWait( Server->WaitHandle );

        Server->WaitHandle = NULL ;
    }

    if ( Server->Timeout.QuadPart == 0 )
    {
        RtlpLpcUnlockServer( Server );

        return STATUS_NOT_IMPLEMENTED ;
    }

    //
    // If there are receives still pending, we have to sync
    // with those threads.  To do so, we will tag the shutdown
    // flag, and then wait the timeout amount.
    //

    if ( Server->ReceiveThreads != 0 )
    {

        InitializeObjectAttributes( &ObjA,
                                    NULL,
                                    0,
                                    0,
                                    0 );

        Status = NtCreateEvent( &Server->ShutdownEvent,
                                EVENT_ALL_ACCESS,
                                &ObjA,
                                NotificationEvent,
                                FALSE );

        if ( !NT_SUCCESS( Status ) )
        {
            RtlpLpcUnlockServer( Server );

            return Status ;

        }

        Server->Flags |= LPCSVR_SHUTDOWN_PENDING ;

        RtlpLpcUnlockServer( Server );

        Status = NtWaitForSingleObject(
                            Server->ShutdownEvent,
                            FALSE,
                            &Server->Timeout );

        if ( Status == STATUS_TIMEOUT )
        {
            //
            // Hmm, the LPC server thread is hung somewhere,
            // press on
            //
        }

        RtlpLpcLockServer( Server );

        NtClose( Server->ShutdownEvent );

        Server->ShutdownEvent = NULL ;

    }
    else
    {
        Server->Flags |= LPCSVR_SHUTDOWN_PENDING ;
    }

    //
    // The server object is locked, and there are no receives
    // pending.  Or, the receives appear hung.  Skim through the
    // context list, calling the server code.  The disconnect
    // message is NULL, indicating that this is a server initiated
    // shutdown.
    //


    while ( ! IsListEmpty( &Server->ContextList ) )
    {
        Scan = RemoveHeadList( &Server->ContextList );

        Context = CONTAINING_RECORD( Scan, LPCSVR_CONTEXT, List );

        Status = Server->Init.RundownFn(
                                Context->PrivateContext,
                                NULL );

        Context->List.Flink = NULL ;

        RtlpLpcDerefContext( Context, NULL );

    }

    //
    // All contexts have been deleted:  clean up the messages
    //

    while ( Server->MessagePool )
    {
        Message = Server->MessagePool ;

        Server->MessagePool = Message ;

        RtlFreeHeap( RtlProcessHeap(),
                     0,
                     Message );
    }


    //
    // Clean up server objects
    //

    return(STATUS_SUCCESS);

}

NTSTATUS
RtlImpersonateLpcClient(
    PVOID Context,
    PPORT_MESSAGE Message
    )
{
    PLPCSVR_CONTEXT LpcContext ;

    LpcContext = RtlpLpcContextFromClient( Context );

    return NtImpersonateClientOfPort(
                    LpcContext->CommPort,
                    Message );

}

NTSTATUS
RtlCallbackLpcClient(
    PVOID Context,
    PPORT_MESSAGE Request,
    PPORT_MESSAGE Callback
    )
{
    NTSTATUS Status ;
    PLPCSVR_CONTEXT LpcContext ;

    if ( Request != Callback )
    {
        Callback->ClientId = Request->ClientId ;
        Callback->MessageId = Request->MessageId ;
    }

    LpcContext = RtlpLpcContextFromClient( Context );

    Status = NtRequestWaitReplyPort(
                    LpcContext->CommPort,
                    Callback,
                    Callback
                    );

    return Status ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\memstm.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    memstm.c

Abstract:

    This modules implements IStream over a block of memory.

Author:

    Jay Krell (a-JayK) June 2000

Revision History:

--*/

#define RTL_DECLARE_STREAMS 1
#define RTL_DECLARE_MEMORY_STREAM 1
#include "ntos.h"
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "objidl.h"

#define RTLP_MEMORY_STREAM_NOT_IMPL(x) \
  ASSERT(MemoryStream != NULL); \
  KdPrintEx((DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "NTDLL: %s() E_NOTIMPL", __FUNCTION__)); \
  return E_NOTIMPL;

#if !defined(RTLP_MEMORY_STREAM_HRESULT_FROM_STATUS)
  #if defined(RTLP_HRESULT_FROM_STATUS)
    #define RTLP_MEMORY_STREAM_HRESULT_FROM_STATUS(x) RTLP_HRESULT_FROM_STATUS(x)
  #else
    #define RTLP_MEMORY_STREAM_HRESULT_FROM_STATUS(x) HRESULT_FROM_WIN32(RtlNtStatusToDosErrorNoTeb(x))
    //#define RTLP_MEMORY_STREAM_HRESULT_FROM_STATUS(x) HRESULT_FROM_WIN32(RtlNtStatusToDosError(x))
    //#define RTLP_MEMORY_STREAM_HRESULT_FROM_STATUS(x)   HRESULT_FROM_NT(x)
  #endif
#endif

#define DPFLTR_LEVEL_HRESULT(x) (SUCCEEDED(x) ? DPFLTR_TRACE_LEVEL : DPFLTR_ERROR_LEVEL)

const static RTL_STREAM_VTABLE_TEMPLATE(RTL_MEMORY_STREAM_WITH_VTABLE)
MemoryStreamVTable =
{
    RtlQueryInterfaceMemoryStream,
    RtlAddRefMemoryStream,
    RtlReleaseMemoryStream,
    RtlReadMemoryStream,
    RtlWriteMemoryStream,
    RtlSeekMemoryStream,
    RtlSetMemoryStreamSize,
    RtlCopyMemoryStreamTo,
    RtlCommitMemoryStream,
    RtlRevertMemoryStream,
    RtlLockMemoryStreamRegion,
    RtlUnlockMemoryStreamRegion,
    RtlStatMemoryStream,
    RtlCloneMemoryStream
};

const static RTL_STREAM_VTABLE_TEMPLATE(RTL_OUT_OF_PROCESS_MEMORY_STREAM_WITH_VTABLE)
OutOfProcessMemoryStreamVTable =
{
    RtlQueryInterfaceOutOfProcessMemoryStream,
    RtlAddRefOutOfProcessMemoryStream,
    RtlReleaseOutOfProcessMemoryStream,
    RtlReadOutOfProcessMemoryStream,
    RtlWriteOutOfProcessMemoryStream,
    RtlSeekOutOfProcessMemoryStream,
    RtlSetOutOfProcessMemoryStreamSize,
    RtlCopyOutOfProcessMemoryStreamTo,
    RtlCommitOutOfProcessMemoryStream,
    RtlRevertOutOfProcessMemoryStream,
    RtlLockOutOfProcessMemoryStreamRegion,
    RtlUnlockOutOfProcessMemoryStreamRegion,
    RtlStatOutOfProcessMemoryStream,
    RtlCloneOutOfProcessMemoryStream
};

VOID
STDMETHODCALLTYPE
RtlInitOutOfProcessMemoryStream(
    PRTL_OUT_OF_PROCESS_MEMORY_STREAM_WITH_VTABLE MemoryStream
    )
{
    ASSERT(MemoryStream != NULL);
    RtlZeroMemory(&MemoryStream->Data, sizeof(MemoryStream->Data));
    MemoryStream->Data.FinalRelease = RtlFinalReleaseOutOfProcessMemoryStream;
    MemoryStream->StreamVTable = (const IStreamVtbl*)&OutOfProcessMemoryStreamVTable;
}

VOID
STDMETHODCALLTYPE
RtlFinalReleaseOutOfProcessMemoryStream(
    PRTL_OUT_OF_PROCESS_MEMORY_STREAM_WITH_VTABLE MemoryStream
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ASSERT(MemoryStream != NULL);
    if (MemoryStream->Data.Process != NULL) {
        Status = NtClose(MemoryStream->Data.Process);
        RTL_SOFT_ASSERT(NT_SUCCESS(Status));
        MemoryStream->Data.Process = NULL;
    }
}

VOID
STDMETHODCALLTYPE
RtlInitMemoryStream(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream
    )
{
    ASSERT(MemoryStream != NULL);
    RtlZeroMemory(&MemoryStream->Data, sizeof(MemoryStream->Data));
    MemoryStream->StreamVTable = (const IStreamVtbl*)&MemoryStreamVTable;
}

ULONG
STDMETHODCALLTYPE
RtlAddRefMemoryStream(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream
    )
{
    LONG ReferenceCount;

    KdPrintEx((
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "NTDLL: %s() beginning, refcount is %ld\n",
        __FUNCTION__,
        MemoryStream->Data.ReferenceCount
        ));
    ASSERT(MemoryStream != NULL);

    ReferenceCount = InterlockedIncrement(&MemoryStream->Data.ReferenceCount);
    return ReferenceCount;
}

ULONG
STDMETHODCALLTYPE
RtlReleaseMemoryStream(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream
    )
{
    LONG ReferenceCount;
    ASSERT(MemoryStream != NULL);

    KdPrintEx((
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "NTDLL: %s() beginning, refcount is %ld\n",
        __FUNCTION__,
        MemoryStream->Data.ReferenceCount
        ));

    ReferenceCount = InterlockedDecrement(&MemoryStream->Data.ReferenceCount);
    if (ReferenceCount == 0 && MemoryStream->Data.FinalRelease != NULL) {
        MemoryStream->Data.FinalRelease(MemoryStream);
    }
    return ReferenceCount;
}

HRESULT
STDMETHODCALLTYPE
RtlQueryInterfaceMemoryStream(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream,
    const IID*                     Interface,
    PVOID*                         Object
    )
{
    KdPrintEx((DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "NTDLL: %s() beginning\n", __FUNCTION__));
    ASSERT(MemoryStream != NULL);
    ASSERT(Interface != NULL);
    ASSERT(Object != NULL);

    if (IsEqualGUID(Interface, &IID_IUnknown)
        || IsEqualGUID(Interface, &IID_IStream)
        || IsEqualGUID(Interface, &IID_ISequentialStream)
        )
    {
        InterlockedIncrement(&MemoryStream->Data.ReferenceCount);
        *Object = (IStream*)(&MemoryStream->StreamVTable);
        return NOERROR;
    }
    return E_NOINTERFACE;
}

HRESULT
STDMETHODCALLTYPE
RtlReadOutOfProcessMemoryStream(
    PRTL_OUT_OF_PROCESS_MEMORY_STREAM_WITH_VTABLE MemoryStream,
    PVOID              Buffer,
    ULONG              BytesToRead,
    ULONG*             BytesRead
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    HRESULT Hr = NOERROR;
    const SIZE_T BytesRemaining = (MemoryStream->Data.End - MemoryStream->Data.Current);
    SIZE_T NumberOfBytesReadSizeT = 0;

    KdPrintEx((DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "NTDLL: %s() beginning\n",  __FUNCTION__));
    ASSERT(MemoryStream != NULL);

    if (BytesRemaining < BytesToRead) {
        BytesToRead = (ULONG)BytesRemaining;
    }
    Status = NtReadVirtualMemory(
        MemoryStream->Data.Process,
        MemoryStream->Data.Current,
        Buffer,
        BytesToRead,
        &NumberOfBytesReadSizeT);
    if (Status == STATUS_PARTIAL_COPY) {
        Status = STATUS_SUCCESS;
        }
    if (!NT_SUCCESS(Status)) {
        Hr = RTLP_MEMORY_STREAM_HRESULT_FROM_STATUS(Status);
        goto Exit;
    }
    MemoryStream->Data.Current += NumberOfBytesReadSizeT;
    *BytesRead = (ULONG)NumberOfBytesReadSizeT;
Exit:
    KdPrintEx((
        DPFLTR_SXS_ID,
        DPFLTR_LEVEL_HRESULT(Hr),
        "NTDLL: %s(BytesRead:%lu) exiting 0x%08lx\n",
        __FUNCTION__,
        (BytesRead != NULL) ? *BytesRead : 0,
        Hr
        ));
    return Hr;
}

HRESULT
STDMETHODCALLTYPE
RtlReadMemoryStream(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream,
    PVOID              Buffer,
    ULONG              BytesToRead,
    ULONG*             BytesRead
    )
{
    HRESULT Hr = NOERROR;
    const SIZE_T BytesRemaining = (MemoryStream->Data.End - MemoryStream->Data.Current);

    KdPrintEx((DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "NTDLL: %s() beginning\n",  __FUNCTION__));
    ASSERT(MemoryStream != NULL);

    ASSERT(MemoryStream != NULL);
    ASSERT(MemoryStream->Data.End >= MemoryStream->Data.Current);

    if (BytesRemaining < BytesToRead) {
        BytesToRead = (ULONG)BytesRemaining;
    }
    RtlCopyMemory(Buffer, MemoryStream->Data.Current, BytesToRead);
    MemoryStream->Data.Current += BytesToRead;
    *BytesRead = BytesToRead;

    KdPrintEx((
        DPFLTR_SXS_ID,
        DPFLTR_LEVEL_HRESULT(Hr),
        "NTDLL: %s(BytesRead:%lu) exiting 0x%08lx\n",
        __FUNCTION__,
        (BytesRead != NULL) ? *BytesRead : 0,
        Hr
        ));
    return Hr;
}

HRESULT
STDMETHODCALLTYPE
RtlWriteMemoryStream(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream,
    const VOID*      Buffer,
    ULONG            BytesToWrite,
    ULONG*           BytesWritten
    )
{
    RTLP_MEMORY_STREAM_NOT_IMPL(Write);
}

HRESULT
STDMETHODCALLTYPE
RtlSeekMemoryStream(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream,
    LARGE_INTEGER      Distance,
    DWORD              Origin,
    ULARGE_INTEGER*    NewPosition
    )
{
    HRESULT Hr = NOERROR;
    PUCHAR  NewPointer;

    KdPrintEx((DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "NTDLL: %s() beginning\n",  __FUNCTION__));
    ASSERT(MemoryStream != NULL);

    //
    // "It is not, however, an error to seek past the end of the stream.
    // Seeking past the end of the stream is useful for subsequent write
    // operations, as the stream will at that time be extended to the seek
    // position immediately before the write is done."
    //
    // As long as we don't allow writing, we are not going to allow this.
    //

    switch (Origin) {
    case STREAM_SEEK_SET:
        NewPointer = MemoryStream->Data.Begin + Distance.QuadPart;
        break;
    case STREAM_SEEK_CUR:
        NewPointer = MemoryStream->Data.Current + Distance.QuadPart;
        break;
    case STREAM_SEEK_END:
        NewPointer = MemoryStream->Data.End - Distance.QuadPart;
        break;
    default:
        Hr = STG_E_INVALIDFUNCTION;
        goto Exit;
    }
   
    if (NewPointer < MemoryStream->Data.Begin || NewPointer > MemoryStream->Data.End) {
        Hr = STG_E_INVALIDPOINTER;
        goto Exit;
    }

    MemoryStream->Data.Current = NewPointer;
    NewPosition->QuadPart = NewPointer - MemoryStream->Data.Begin;
    Hr = NOERROR;
Exit:
    KdPrintEx((DPFLTR_SXS_ID, DPFLTR_LEVEL_HRESULT(Hr), "NTDLL: %s() exiting 0x%08lx\n", __FUNCTION__, Hr));
    return Hr;
}

HRESULT
STDMETHODCALLTYPE
RtlSetMemoryStreamSize(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream,
    ULARGE_INTEGER     NewSize
    )
{
    RTLP_MEMORY_STREAM_NOT_IMPL(SetSize);
}

HRESULT
STDMETHODCALLTYPE
RtlCopyOutOfProcessMemoryStreamTo(
    PRTL_OUT_OF_PROCESS_MEMORY_STREAM_WITH_VTABLE MemoryStream,
    IStream*           AnotherStream,
    ULARGE_INTEGER     NumberOfBytesToCopyLargeInteger,
    ULARGE_INTEGER*    NumberOfBytesRead,
    ULARGE_INTEGER*    NumberOfBytesWrittenLargeInteger
    )
{
    RTLP_MEMORY_STREAM_NOT_IMPL(CopyTo);
}
 
HRESULT
STDMETHODCALLTYPE
RtlCopyMemoryStreamTo(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream,
    IStream*           AnotherStream,
    ULARGE_INTEGER     NumberOfBytesToCopyLargeInteger,
    ULARGE_INTEGER*    NumberOfBytesRead,
    ULARGE_INTEGER*    NumberOfBytesWrittenLargeInteger
    )
{
    HRESULT Hr = NOERROR;
    ULONG  NumberOfBytesToCopyUlong = 0;
    ULONG  NumberOfBytesWrittenUlong = 0;
    const SIZE_T BytesRemaining = (MemoryStream->Data.End - MemoryStream->Data.Current);

    KdPrintEx((DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "NTDLL: %s() beginning\n",  __FUNCTION__));
    ASSERT(MemoryStream != NULL);

    if (NumberOfBytesToCopyLargeInteger.HighPart != 0) {
        NumberOfBytesToCopyUlong = MAXULONG;
    } else {
        NumberOfBytesToCopyUlong = (ULONG)NumberOfBytesToCopyLargeInteger.QuadPart;
    }

    if (BytesRemaining < NumberOfBytesToCopyUlong) {
        NumberOfBytesToCopyUlong = (ULONG)BytesRemaining;
    }

    Hr = AnotherStream->lpVtbl->Write(AnotherStream, MemoryStream->Data.Current, NumberOfBytesToCopyUlong, &NumberOfBytesWrittenUlong);
    if (FAILED(Hr)) {
        NumberOfBytesRead->QuadPart = 0;
        NumberOfBytesWrittenLargeInteger->QuadPart = 0;
    } else {
        NumberOfBytesRead->QuadPart = NumberOfBytesWrittenUlong;
        NumberOfBytesWrittenLargeInteger->QuadPart = NumberOfBytesWrittenUlong;
    }
    Hr = NOERROR;
//Exit:
    KdPrintEx((DPFLTR_SXS_ID, DPFLTR_LEVEL_HRESULT(Hr), "NTDLL: %s() exiting 0x%08lx\n", __FUNCTION__, Hr));
    return Hr;
}

HRESULT
STDMETHODCALLTYPE
RtlCommitMemoryStream(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream,
    ULONG              Flags
    )
{
    RTLP_MEMORY_STREAM_NOT_IMPL(Commit);
}

HRESULT
STDMETHODCALLTYPE
RtlRevertMemoryStream(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream
    )
{
    RTLP_MEMORY_STREAM_NOT_IMPL(Revert);
}

HRESULT
STDMETHODCALLTYPE
RtlLockMemoryStreamRegion(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream,
    ULARGE_INTEGER     Offset,
    ULARGE_INTEGER     NumberOfBytes,
    ULONG              LockType
    )
{
    RTLP_MEMORY_STREAM_NOT_IMPL(LockRegion);
}

HRESULT
STDMETHODCALLTYPE
RtlUnlockMemoryStreamRegion(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream,
    ULARGE_INTEGER     Offset,
    ULARGE_INTEGER     NumberOfBytes,
    ULONG              LockType
    )
{
    RTLP_MEMORY_STREAM_NOT_IMPL(UnlockRegion);
}

HRESULT
STDMETHODCALLTYPE
RtlStatMemoryStream(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream,
    STATSTG*           StatusInformation,
    ULONG              Flags
    )
{
    HRESULT hr = NOERROR;

    KdPrintEx((DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "NTDLL: %s() beginning\n",  __FUNCTION__));
    ASSERT(MemoryStream != NULL);

    if (StatusInformation == NULL) {
        hr = STG_E_INVALIDPOINTER;
        goto Exit;
    }

    if (Flags != STATFLAG_NONAME) {
        hr = STG_E_INVALIDFLAG;
        goto Exit;
    }

    StatusInformation->pwcsName = NULL;
    StatusInformation->type = STGTY_STREAM;
    StatusInformation->cbSize.QuadPart = ((ULONG_PTR) MemoryStream->Data.End) - ((ULONG_PTR) MemoryStream->Data.Begin);
    StatusInformation->mtime.dwLowDateTime = 0;
    StatusInformation->mtime.dwHighDateTime = 0;
    StatusInformation->ctime.dwLowDateTime = 0;
    StatusInformation->ctime.dwHighDateTime = 0;
    StatusInformation->atime.dwLowDateTime = 0;
    StatusInformation->atime.dwHighDateTime = 0;
    StatusInformation->grfMode = STGM_READ;
    StatusInformation->grfLocksSupported = 0;
    StatusInformation->clsid = CLSID_NULL;
    StatusInformation->grfStateBits = 0;
    StatusInformation->reserved = 0;

    hr = NOERROR;

Exit:
    KdPrintEx((DPFLTR_SXS_ID, DPFLTR_LEVEL_HRESULT(hr), "NTDLL: %s() exiting 0x%08lx\n", __FUNCTION__, hr));

    return hr;
}

HRESULT
STDMETHODCALLTYPE
RtlCloneMemoryStream(
    PRTL_MEMORY_STREAM_WITH_VTABLE MemoryStream,
    IStream**          NewStream
    )
{
    RTLP_MEMORY_STREAM_NOT_IMPL(Clone);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\ntnap.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ntnap.c

Abstract:

    This module contains the routines for initializing and performing
    profiling of NT API's.

Author:

    Russ Blake (russbl) 22-Apr-1991

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <string.h>

#include "ntnapdef.h"
#include "ntnap.h"

//
// Initialization control: only want to initialize once; this
// prevents multiple initializations before data segment and
// global control are initialized.
//

BOOLEAN NapInitialized = FALSE;

//
// Counter frequency constant
//

LARGE_INTEGER NapFrequency;

//
// Profiling data structures
//

PNAPCONTROL NapControl = NULL;

//
// The following array is indexed by Service Number + 1.  Service
// Number -1 (element 0 of the following array) is reserved for
// calibration.  Initialization of this to NULL kicks off the
// NapDllInit sequence to create or open the data section.
//

PNAPDATA NapProfilingData = NULL;


VOID
NapDllInit (
    VOID
    )

/*++

Routine Description:

    NapDllInit() is called before calling any profiling api.  It
    initializes profiling for the NT native API's.

    NOTE:  Initialization occurs only once and is controlled by
	   the NapInitDone global flag.

Arguments:

    None

Return Value:

    None

--*/

{
    ULONG i;
    LARGE_INTEGER CurrentCounter;

    if (!NapInitialized) {

	//
	// Instance data for this process's ntdll.dll not yet initialized.
	//

	NapInitialized = TRUE;

	//
	// Get Counter frequency (current counter value is thrown away)
	// This call is not profiled because NapControl == NULL here.
	//

	NtQueryPerformanceCounter(&CurrentCounter,
				  &NapFrequency);

	//
	// Allocate or open data section for api profiling data.
	//

	if (NT_SUCCESS(NapCreateDataSection(&NapControl))) {

	    NapProfilingData = (PNAPDATA)(NapControl + 1);

	    if (!NapControl->Initialized) {

		//
		// We are the first process to get here: we jsut
		// allocated the section, so must initialize it.
		//

		NapControl->Initialized = TRUE;

		NapControl->Paused = 0;

		//
		// Clear the data area used for calibration data.
		//

		NapProfilingData[0].NapLock = 0L;
		NapProfilingData[0].Calls = 0L;
		NapProfilingData[0].TimingErrors = 0L;
		NapProfilingData[0].TotalTime.HighPart = 0L;
		NapProfilingData[0].TotalTime.LowPart = 0L;
		NapProfilingData[0].FirstTime.HighPart = 0L;
		NapProfilingData[0].FirstTime.LowPart = 0L;
		NapProfilingData[0].MaxTime.HighPart = 0L;
		NapProfilingData[0].MaxTime.LowPart = 0L;
		NapProfilingData[0].MinTime.HighPart = MAX_LONG;
		NapProfilingData[0].MinTime.LowPart = MAX_ULONG;

		//
		// Clear the rest of the data collection area
		//

		NapClearData();

		//
		//   Calibrate time overhead from profiling.  We care mostly
		//   about the minimum time here, to avoid extra time from
		//   interrupts etc.
		//

		for (i=0; i<NUM_ITERATIONS; i++) {
		    NapCalibrate();
		}
	    }
	}
    }
}




NTSTATUS
NapCreateDataSection(
    PNAPCONTROL *NapSectionPointer
    )
/*++

Routine Description:

    NapCreateData() is called to create the profiling data section.
    One section, named "\NapDataSection", is used for the whole system.
    It is accessible by anyone, so don't mess it up.

Arguments:

    NapSectionPointer - a pointer to a pointer which will be set to
			to point to the beginning of the section.

Return Value:

    Status

--*/


{
    NTSTATUS Status;
    HANDLE NapSectionHandle;
    HANDLE MyProcess;
    STRING NapSectionName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LARGE_INTEGER AllocationSize;
    ULONG ViewSize;
    PNAPCONTROL SectionPointer;

    //
    // Initialize object attributes for the dump file
    //

    NapSectionName.Length = 15;
    NapSectionName.MaximumLength = 15;
    NapSectionName.Buffer = "\\NapDataSection";

    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectAttributes.ObjectName = &NapSectionName;
    ObjectAttributes.RootDirectory = NULL;
    ObjectAttributes.SecurityDescriptor = NULL;
    ObjectAttributes.SecurityQualityOfService = NULL;
    ObjectAttributes.Attributes = OBJ_OPENIF |
				  OBJ_CASE_INSENSITIVE;


    AllocationSize.HighPart = 0;
    AllocationSize.LowPart = (NAP_API_COUNT + 1) * sizeof(NAPDATA);

    Status = NtCreateSection(&NapSectionHandle,
			     SECTION_MAP_READ |
			     SECTION_MAP_WRITE,
			     &ObjectAttributes,
			     &AllocationSize,
			     PAGE_READWRITE,
			     SEC_COMMIT,
			     NULL);

    if (NT_SUCCESS(Status)) {

	MyProcess = NtCurrentProcess();

	ViewSize = AllocationSize.LowPart;

	SectionPointer = NULL;

	Status = NtMapViewOfSection(NapSectionHandle,
				    MyProcess,
				    (PVOID *)&SectionPointer,
				    0,
				    AllocationSize.LowPart,
				    NULL,
				    &ViewSize,
				    ViewUnmap,
				    MEM_TOP_DOWN,
				    PAGE_READWRITE);

	*NapSectionPointer = SectionPointer;
    }

    return(Status);
}




VOID
NapRecordInfo (
    IN ULONG ServiceNumber,
    IN LARGE_INTEGER Counters[]
    )

/*++

Routine Description:

    NapRecordInfo() is called after the API being measured has
    returned, and the value of the performance counter has been
    obtained.

    NOTE:  Initialization occurs only once and is controlled by
	   the NapInitDone global flag.

Arguments:

    ServiceNumber - the number of the service being measured.
		    -1 is reserved for calibration.

    Counters	  - a pointer to the value of the counter after the call
		    to the measured routine.  Followed immediately
		    in memory by the value of the counter before the
		    call to the measured routine.

Return Value:

    None

--*/


{
    LARGE_INTEGER ElapsedTime;
    LARGE_INTEGER Difference;


    //
    // First make sure we have been initialized
    //

    if (NapControl != NULL) {

	//
	// Check to be sure profiling is not paused

	if (NapControl->Paused == 0) {

	    //
	    // Since ServiceNumber -1 is used for calibration, bump same
	    // so indexes start at 0.
	    //

	    ServiceNumber++;

	    //
	    // Prevent others from changing data at the same time
	    // we are.
	    //

	    NapAcquireSpinLock(&(NapProfilingData[ServiceNumber].NapLock));

	    //
	    // Record API info
	    //

	    NapProfilingData[ServiceNumber].Calls++;

	    //
	    // Elapsed time is end time minus start time
	    //

	    ElapsedTime =
		RtlLargeIntegerSubtract(Counters[0],Counters[1]);

	    //
	    // Now add elapsed time to total time
	    //

	    NapProfilingData[ServiceNumber].TotalTime =
		RtlLargeIntegerAdd(NapProfilingData[ServiceNumber].TotalTime,
				   ElapsedTime);

	    if (NapProfilingData[ServiceNumber].Calls == 1) {
		NapProfilingData[ServiceNumber].FirstTime = ElapsedTime;
	    }
	    else {
		Difference =
		    RtlLargeIntegerSubtract(
			NapProfilingData[ServiceNumber].MaxTime,
			ElapsedTime);
		if (Difference.HighPart < 0) {

		    //
		    // A new maximum was attained
		    //

		    NapProfilingData[ServiceNumber].MaxTime = ElapsedTime;

		}
		Difference =
		    RtlLargeIntegerSubtract(
			ElapsedTime,
			NapProfilingData[ServiceNumber].MinTime);
		if (Difference.HighPart < 0) {

		    //
		    // A new minimum was attained
		    //

		    NapProfilingData[ServiceNumber].MinTime = ElapsedTime;
		}
	    }

	    NapReleaseSpinLock(&(NapProfilingData[ServiceNumber].NapLock));
	}
    }
}



NTSTATUS
NapClearData (
    VOID
    )

/*++

Routine Description:

    NapClearData() is called to clear all the counters and timers.
    The calibration counters are not cleared.  For the rest,
    if not previously collected, the data will be lost.

Arguments:

    None

Return Value:

    Status

--*/

{
    ULONG ServiceNumber;

    //
    // Initialize the first one after the calibration data
    //

    NapAcquireSpinLock(&(NapProfilingData[1].NapLock));

    NapProfilingData[1].Calls = 0L;
    NapProfilingData[1].TimingErrors = 0L;
    NapProfilingData[1].TotalTime.HighPart = 0L;
    NapProfilingData[1].TotalTime.LowPart = 0L;
    NapProfilingData[1].FirstTime.HighPart = 0L;
    NapProfilingData[1].FirstTime.LowPart = 0L;
    NapProfilingData[1].MaxTime.HighPart = 0L;
    NapProfilingData[1].MaxTime.LowPart = 0L;
    NapProfilingData[1].MinTime.HighPart = MAX_LONG;
    NapProfilingData[1].MinTime.LowPart = MAX_ULONG;

    //
    // Now use the initialized first one to initialize the rest
    //


    for (ServiceNumber = 2; ServiceNumber <= NAP_API_COUNT; ServiceNumber++) {

	NapAcquireSpinLock(&(NapProfilingData[ServiceNumber].NapLock));

	NapProfilingData[ServiceNumber] = NapProfilingData[1];

	NapReleaseSpinLock(&(NapProfilingData[ServiceNumber].NapLock));
    }

    NapReleaseSpinLock(&(NapProfilingData[1].NapLock));

    return(STATUS_SUCCESS);
}



NTSTATUS
NapRetrieveData (
    OUT NAPDATA *NapApiData,
    OUT PCHAR **NapApiNames,
    OUT PLARGE_INTEGER *NapCounterFrequency
    )

/*++

Routine Description:

    NapRetrieveData() is called to get all the relevant data
    about API's that have been profiled.  It is wise to call
    NapPause() before calling this, and NapResume() afterwards.
    Can't just do these in here, 'cause you may be doing stuff outside
    of this call you don't want profiled.

Arguments:

    NapApiData - a pointer to a buffer to which is copied
		 the array of counters; must be large enough for
		 NAP_API_COUNT+1; call NapGetApiCount to obtain needed
		 size.

    NapApiNames - a pointer to which is copied a pointer to
		  an array of pointers to API names

    NapCounterFrequency - a buffer to which is copied the frequency
			  of the performance counter

Return Value:

    Status

--*/

{
    ULONG ServiceNumber;

    *NapApiNames = NapNames;

    *NapCounterFrequency = &NapFrequency;

    for (ServiceNumber = 0; ServiceNumber <= NAP_API_COUNT; ServiceNumber++) {

	NapAcquireSpinLock(&(NapProfilingData[ServiceNumber].NapLock));

	NapApiData[ServiceNumber] = NapProfilingData[ServiceNumber];

	NapReleaseSpinLock(&(NapProfilingData[ServiceNumber].NapLock));
	NapReleaseSpinLock(&(NapApiData[ServiceNumber].NapLock));
    }

    return(STATUS_SUCCESS);
}



NTSTATUS
NapGetApiCount (
    OUT PULONG NapApiCount
    )

/*++

Routine Description:

    NapGetApiCount() is called to get the number of API's which are
    being profiled.  This can then be used to allocate an array for
    receiving the data from NapReturnData.

Arguments:

    NapApiCount - A pointer throug which the count is returned.

Return Value:

    Status

--*/


{

    *NapApiCount = NAP_API_COUNT;

    return(STATUS_SUCCESS);

}




NTSTATUS
NapPause (
    VOID
    )

/*++

Routine Description:

    NapPause() is called to temporarily cease data collection.
    Data collection is resumed by a companion call to NapResume.

Arguments:

    None

Return Value:

    Status

--*/


{
    NapControl->Paused++;

    return(STATUS_SUCCESS);
}


NTSTATUS
NapResume (
    VOID
    )

/*++

Routine Description:

    NapResume() is called to resume data collection after a companion
    call to NapPause.

Arguments:

    None

Return Value:

    Status

--*/


{
    NapControl->Paused--;

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\ntdllp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ntdllp.h

Abstract:

    Private definitions for ntdll.

Author:

    Michael J. Grier (mgrier) 6/30/2000

Revision History:

--*/

#ifndef _NTDLLP_
#define _NTDLLP_

#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <string.h>
#include <sxstypes.h>
#include <ntrtlpath.h>

VOID
NTAPI
RtlpAssemblyStorageMapResolutionDefaultCallback(
    ULONG Reason,
    PASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_DATA Data,
    PVOID Context
    );

NTSTATUS
RtlpGetAssemblyStorageMapRootLocation(
    HANDLE KeyHandle,
    PCUNICODE_STRING SubKeyName,
    PUNICODE_STRING Root
    );

VOID
RtlpCheckRelativeDrive(
    WCHAR NewDrive
    );

ULONG
RtlIsDosDeviceName_Ustr(
    IN PUNICODE_STRING DosFileName
    );

ULONG
RtlGetFullPathName_Ustr(
    PUNICODE_STRING FileName,
    ULONG nBufferLength,
    PWSTR lpBuffer,
    PWSTR *lpFilePart OPTIONAL,
    PBOOLEAN NameInvalid,
    RTL_PATH_TYPE *InputPathType
    );

NTSTATUS
RtlGetFullPathName_UstrEx(
    PUNICODE_STRING FileName,
    PUNICODE_STRING StaticString,
    PUNICODE_STRING DynamicString,
    PUNICODE_STRING *StringUsed,
    SIZE_T *FilePartPrefixCch OPTIONAL,
    PBOOLEAN NameInvalid,
    RTL_PATH_TYPE *InputPathType,
    OUT SIZE_T *BytesRequired OPTIONAL
    );

ULONG
RtlpComputeBackupIndex(
    IN PCURDIR CurDir
    );

ULONG
RtlGetLongestNtPathLength(
    VOID
    );

VOID
RtlpResetDriveEnvironment(
    IN WCHAR DriveLetter
    );

VOID
RtlpValidateCurrentDirectory(
    PCURDIR CurDir
    );

NTSTATUS
RtlpCheckDeviceName(
    PUNICODE_STRING DevName,
    ULONG DeviceNameOffset,
    BOOLEAN* NameInvalid
    );

NTSTATUS
RtlpWin32NTNameToNtPathName_U(
    IN PUNICODE_STRING DosFileName,
    OUT PUNICODE_STRING NtFileName,
    OUT PWSTR *FilePart OPTIONAL,
    OUT PRTL_RELATIVE_NAME RelativeName OPTIONAL
    );

#define RTLP_GOOD_DOS_ROOT_PATH                                            0
#define RTLP_BAD_DOS_ROOT_PATH_WIN32NT_PREFIX                              1 /* \\?\ */
#define RTLP_BAD_DOS_ROOT_PATH_WIN32NT_UNC_PREFIX                          2 /* \\?\unc */
#define RTLP_BAD_DOS_ROOT_PATH_NT_PATH                                     3 /* \??\, this is only rough */
#define RTLP_BAD_DOS_ROOT_PATH_MACHINE_NO_SHARE                            4 /* \\machine or \\?\unc\machine */

CONST CHAR*
RtlpDbgBadDosRootPathTypeToString(
    IN ULONG     Flags,
    IN ULONG     RootType
    );

NTSTATUS
RtlpCheckForBadDosRootPath(
    IN ULONG             Flags,
    IN PCUNICODE_STRING  RootString,
    OUT ULONG*           RootType
    );

NTSTATUS
NTAPI
RtlpBadDosRootPathToEmptyString(
    IN     ULONG            Flags,
    IN OUT PUNICODE_STRING  Path
    );

#define RTL_DETERMINE_DOS_PATH_NAME_TYPE_IN_FLAG_OLD (0x00000010)

//
// This bit means to do extra validation on \\? paths, to reject \\?\a\b,
// To only allow \\? followed by the documented forms \\?\unc\foo and \\?\c:
//
#define RTL_DETERMINE_DOS_PATH_NAME_TYPE_IN_FLAG_STRICT_WIN32NT (0x00000020)

#define RTLP_DETERMINE_DOS_PATH_NAME_TYPE_OUT_TYPE_MASK                    (0x0000000F)

//
// These bits add more information to RtlPathTypeUncAbsolute, which is what \\?
// is reported as.
//

//
// The path starts "\\?".
//
#define RTLP_DETERMINE_DOS_PATH_NAME_TYPE_OUT_FLAG_WIN32NT                 (0x00000010)

//
// The path starts "\\?\x:".
//
#define RTLP_DETERMINE_DOS_PATH_NAME_TYPE_OUT_FLAG_WIN32NT_DRIVE_ABSOLUTE  (0x00000020)

//
// The path starts "\\?\unc".
//
#define RTLP_DETERMINE_DOS_PATH_NAME_TYPE_OUT_FLAG_WIN32NT_UNC_ABSOLUTE    (0x00000040)

//
//future this would indicate \\machine instead of \\machine\share
//define RTLP_DETERMINE_DOS_PATH_NAME_TYPE_OUT_FLAG_WIN32NT_UNC_MACHINE_ONLY (0x00000080)
//future this would indicate \\ or \\?\unc
//define RTLP_DETERMINE_DOS_PATH_NAME_TYPE_OUT_FLAG_WIN32NT_UNC_EMPTY        (0x00000100)
//

//
// So far, this means something like \\?\a was seen, instead of \\?\unc or \\?\a:
// You have to request it with RTL_DETERMINE_DOS_PATH_NAME_TYPE_IN_FLAG_STRICT_WIN32NT.
//
#define RTLP_DETERMINE_DOS_PATH_NAME_TYPE_OUT_FLAG_INVALID       (0x00000200)

//
// stuff like \\ \\? \\?\unc \\?\unc\
//
#define RTLP_DETERMINE_DOS_PATH_NAME_TYPE_OUT_FLAG_INCOMPLETE_ROOT (0x00000400)

NTSTATUS
NTAPI
RtlpDetermineDosPathNameType4(
    IN ULONG            InFlags,
    IN PCUNICODE_STRING DosPath,
    OUT RTL_PATH_TYPE*  OutType,
    OUT ULONG*          OutFlags
    );

#define RTLP_IMPLIES(x,y) ((x) ? (y) : TRUE)

#endif // _NTDLLP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\propapi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1998.
//
//  File:       propapi.h
//
//  Contents:   Stuff needed to make properties build for Nashville and
//              NT... definitions of Nt property api.
//
//
//  History:    07-Aug-95   BillMo      Created.
//              22-Feb-96   MikeHill    Fixed the non-WINNT version of
//                                      PROPASSERTMSG.
//              09-May-96   MikeHill    Update define to allow PropSet names
//                                      to be 255 characters (from 127).
//              31-May-96   MikeHill    Add OSVersion to RtlCreatePropSet.
//              18-Jun-96   MikeHill    Add OleAut32 wrappers to Unicode callouts.
//              15-Jul-96   MikeHill    - Remvd Win32 SEH exception-related code.
//                                      - WCHAR=>OLECHAR where applicable.
//                                      - Added RtlOnMappedStreamEvent
//                                      - Added Mac versions of PROPASSERT
//
//--------------------------------------------------------------------------


#ifndef _PROPAPI_H_
#define _PROPAPI_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// typedef the function prototypes necessary
// for the UNICODECALLOUTS structure.
//

typedef UINT (WINAPI FNGETACP)(VOID);

typedef int (WINAPI FNMULTIBYTETOWIDECHAR)(
    IN UINT CodePage,
    IN DWORD dwFlags,
    IN LPCSTR lpMultiByteStr,
    IN int cchMultiByte,
    OUT LPWSTR lpWideCharStr,
    IN int cchWideChar);

typedef int (WINAPI FNWIDECHARTOMULTIBYTE)(
    IN UINT CodePage,
    IN DWORD dwFlags,
    IN LPCWSTR lpWideCharStr,
    IN int cchWideChar,
    OUT LPSTR lpMultiByteStr,
    IN int cchMultiByte,
    IN LPCSTR lpDefaultChar,
    IN LPBOOL lpUsedDefaultChar);

typedef BSTR FNSYSALLOCSTRING(
    OLECHAR FAR* pwsz);

typedef VOID FNSYSFREESTRING(
    BSTR pwsz);

//
// The UNICODECALLOUTS structure holds function
// pointers for routines needed by the property
// set routines in NTDLL.
//

typedef struct _UNICODECALLOUTS
{
    FNGETACP              *pfnGetACP;
    FNMULTIBYTETOWIDECHAR *pfnMultiByteToWideChar;
    FNWIDECHARTOMULTIBYTE *pfnWideCharToMultiByte;
    FNSYSALLOCSTRING      *pfnSysAllocString;
    FNSYSFREESTRING       *pfnSysFreeString;
} UNICODECALLOUTS;


//
// Define the default UNICODECALLOUTS
// values.
//

STDAPI_(BSTR)
PropSysAllocString(OLECHAR FAR* pwsz);

STDAPI_(VOID)
PropSysFreeString(BSTR bstr);

#define WIN32_UNICODECALLOUTS \
    GetACP,                   \
    MultiByteToWideChar,      \
    WideCharToMultiByte,      \
    PropSysAllocString,       \
    PropSysFreeString


// Is this pure NT (the IProp DLL needs to run on Win95)?
#if defined(WINNT) && !defined(IPROPERTY_DLL)

    // Set the function modifiers
#   define PROPSYSAPI NTSYSAPI
#   define PROPAPI NTAPI

    // How do we free mem allocated in the low-level propset routines?
#   define PropFreeHeap(h, z, p) RtlFreeHeap(h, z, p)

    // Assert implementations
#   define PROPASSERT ASSERT
#   define PROPASSERTMSG ASSERTMSG

    // Generate the default non-simple property stream/storage name
#   define PROPGENPROPERTYNAME(s,n) swprintf ((s), L"prop%lu", (n))

    // Ansi sprintf implementations
#   define PropSprintfA sprintf
#   define PropVsprintfA vsprintf

// Otherwise this is either the IProp DLL (NT, Win95, Mac),
// or it's the Win95 OLE32build.

#else // #if defined(WINNT) && !defined(IPROPERTY_DLL)

    // Set the function modifiers
#   define PROPSYSAPI
#   define PROPAPI

    // How do we free mem allocated in low-level propset routines?
#   define PropFreeHeap(h, z, p) CoTaskMemFree(p)

    // Assert implementations
#   if DBG==1
#       ifdef _MAC_NODOC
#           define PROPASSERT(f)                { if (!(f)) FnAssert(#f, NULL, __FILE__, __LINE__); }
#           define PROPASSERTMSG(szReason, f)   { if (!(f)) FnAssert(#f, szReason, __FILE__, __LINE__); }
#       else
#           define PROPASSERT(f) Win4Assert((f))
#           define PROPASSERTMSG(szReason, f) Win4Assert( (szReason && FALSE) || (f))
#       endif
#   else
#       define PROPASSERT(f)
#       define PROPASSERTMSG(szReason, f)
#   endif // #if DBG==1

    // Generate the default non-simple property stream/storage name
#   define PROPGENPROPERTYNAME(s,n) \
    { \
        memcpy ((s), OLESTR("prop"), sizeof (OLESTR("prop"))); \
        ULTOO  ((n), &(s)[sizeof("prop") - 1], 10); \
    }

    // Ansi sprintf implementations
#   ifdef IPROPERTY_DLL
#       define PropSprintfA sprintf
#       define PropVsprintfA vsprintf
#   else
#       define PropSprintfA wsprintfA
#       define PropVsprintfA wvsprintfA
#   endif	// #ifdef _MAC_NODOC

#endif // #if defined(WINNT) && !defined(IPROPERTY_DLL) ... #else


#ifdef IPROPERTY_DLL
#define MAX_ULONG ((ULONG) -1)
#endif


#define WC_PROPSET0     ((WCHAR) 0x0005)
#define OC_PROPSET0     ((OLECHAR) 0x0005)

#define CBIT_BYTE       8
#define CBIT_GUID       (CBIT_BYTE * sizeof(GUID))
#define CBIT_CHARMASK   5

// Allow for OC_PROPSET0 and a GUID mapped to a 32 character alphabet
#define CCH_PROPSET        (1 + (CBIT_GUID + CBIT_CHARMASK-1)/CBIT_CHARMASK)
#define CCH_PROPSETSZ      (CCH_PROPSET + 1)            // allow null
#define CCH_PROPSETCOLONSZ (1 + CCH_PROPSET + 1)        // allow colon and null

// Define the max property name in units of characters
// (and synonomously in wchars).

#define CCH_MAXPROPNAME    255                          // Matches Shell & Office
#define CCH_MAXPROPNAMESZ  (CCH_MAXPROPNAME + 1)        // allow null
#define CWC_MAXPROPNAME    CCH_MAXPROPNAME
#define CWC_MAXPROPNAMESZ  CCH_MAXPROPNAMESZ

#define MAX_DOCFILE_ENTRY_NAME  31

//+--------------------------------------------------------------------------
// Property Access APIs:
//---------------------------------------------------------------------------

typedef VOID *NTPROP;
typedef VOID *NTMAPPEDSTREAM;
typedef VOID *NTMEMORYALLOCATOR;


VOID PROPSYSAPI PROPAPI
RtlSetUnicodeCallouts(
    IN UNICODECALLOUTS *pUnicodeCallouts);

ULONG PROPSYSAPI PROPAPI
RtlGuidToPropertySetName(
    IN GUID const *pguid,
    OUT OLECHAR aocname[]);

NTSTATUS PROPSYSAPI PROPAPI
RtlPropertySetNameToGuid(
    IN ULONG cwcname,
    IN OLECHAR const aocname[],
    OUT GUID *pguid);

VOID 
PrSetUnicodeCallouts(
    IN UNICODECALLOUTS *pUnicodeCallouts);

ULONG 
PrGuidToPropertySetName(
    IN GUID const *pguid,
    OUT OLECHAR aocname[]);

NTSTATUS 
PrPropertySetNameToGuid(
    IN ULONG cwcname,
    IN OLECHAR const aocname[],
    OUT GUID *pguid);


// RtlCreatePropertySet Flags:

#define CREATEPROP_READ         0x0000 // request read access (must exist)
#define CREATEPROP_WRITE        0x0001 // request write access (must exist)
#define CREATEPROP_CREATE       0x0002 // create (overwrite if exists)
#define CREATEPROP_CREATEIF     0x0003 // create (open existing if exists)
#define CREATEPROP_DELETE       0x0004 // delete
#define CREATEPROP_MODEMASK     0x000f // open mode mask

#define CREATEPROP_NONSIMPLE    0x0010 // Is non-simple propset (in a storage)


// RtlCreateMappedStream Flags:

#define CMS_READONLY      0x00000000    // Opened for read-only
#define CMS_WRITE         0x00000001    // Opened for write access
#define CMS_TRANSACTED    0x00000002    // Is transacted


NTSTATUS PROPSYSAPI PROPAPI
RtlCreatePropertySet(
    IN NTMAPPEDSTREAM ms,       // Nt mapped stream
    IN USHORT Flags,	// NONSIMPLE|*1* of READ/WRITE/CREATE/CREATEIF/DELETE
    OPTIONAL IN GUID const *pguid, // property set guid (create only)
    OPTIONAL IN GUID const *pclsid,// CLASSID of propset code (create only)
    IN NTMEMORYALLOCATOR ma,	// caller's memory allocator
    IN ULONG LocaleId,		// Locale Id (create only)
    OPTIONAL OUT ULONG *pOSVersion,// OS Version field in header.
    IN OUT USHORT *pCodePage,   // IN: CodePage of property set (create only)
                                // OUT: CodePage of property set (always)
    OUT NTPROP *pnp);           // Nt property set context

NTSTATUS PROPSYSAPI PROPAPI
RtlClosePropertySet(
    IN NTPROP np);              // property set context

NTSTATUS 
PrCreatePropertySet(
    IN NTMAPPEDSTREAM ms,       // Nt mapped stream
    IN USHORT Flags,	// NONSIMPLE|*1* of READ/WRITE/CREATE/CREATEIF/DELETE
    OPTIONAL IN GUID const *pguid, // property set guid (create only)
    OPTIONAL IN GUID const *pclsid,// CLASSID of propset code (create only)
    IN NTMEMORYALLOCATOR ma,	// caller's memory allocator
    IN ULONG LocaleId,		// Locale Id (create only)
    OPTIONAL OUT ULONG *pOSVersion,// OS Version field in header.
    IN OUT USHORT *pCodePage,   // IN: CodePage of property set (create only)
                                // OUT: CodePage of property set (always)
    OUT NTPROP *pnp);           // Nt property set context

NTSTATUS 
PrClosePropertySet(
    IN NTPROP np);              // property set context

// *NOTE* RtlOnMappedStreamEvent assumes that the caller has
// already taken the CPropertySetStream::Lock.
#define CBSTM_UNKNOWN   ((ULONG) -1)
NTSTATUS PROPSYSAPI PROPAPI
RtlOnMappedStreamEvent(
    IN VOID *pv,               // property set context (NTPROP)
    IN VOID *pbuf,             // property set buffer
    IN ULONG cbstm );          // size of underlying stream, or CBSTM_UNKNOWN
NTSTATUS 
PrOnMappedStreamEvent(
    IN VOID *pv,               // property set context (NTPROP)
    IN VOID *pbuf,             // property set buffer
    IN ULONG cbstm );          // size of underlying stream, or CBSTM_UNKNOWN

NTSTATUS PROPSYSAPI PROPAPI
RtlFlushPropertySet(
    IN NTPROP np);              // property set context
NTSTATUS 
PrFlushPropertySet(
    IN NTPROP np);              // property set context

typedef struct _INDIRECTPROPERTY        // ip
{
    ULONG       Index;          // Index into Variant and PropId arrays
    LPOLESTR    poszName;       // Old indirect name, RtlSetProperties() only
} INDIRECTPROPERTY;

NTSTATUS PROPSYSAPI PROPAPI
RtlSetProperties(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID pidNameFirst,     // first PROPID for new named properties
    IN PROPSPEC const aprs[],   // array of property specifiers
    OPTIONAL OUT PROPID apid[], // buffer for array of propids
    OPTIONAL OUT INDIRECTPROPERTY **ppip, // pointer to returned pointer to
                                // MAXULONG terminated array of Indirect
                                // properties w/indexes into aprs & avar
    OPTIONAL IN PROPVARIANT const avar[]);// array of properties with values
NTSTATUS 
PrSetProperties(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID pidNameFirst,     // first PROPID for new named properties
    IN PROPSPEC const aprs[],   // array of property specifiers
    OPTIONAL OUT PROPID apid[], // buffer for array of propids
    OPTIONAL OUT INDIRECTPROPERTY **ppip, // pointer to returned pointer to
                                // MAXULONG terminated array of Indirect
                                // properties w/indexes into aprs & avar
    OPTIONAL IN PROPVARIANT const avar[]);// array of properties with values

NTSTATUS PROPSYSAPI PROPAPI
RtlQueryProperties(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPSPEC const aprs[],   // array of property specifiers
    OPTIONAL OUT PROPID apid[], // buffer for array of propids
    OPTIONAL OUT INDIRECTPROPERTY **ppip, // pointer to returned pointer to
                                // MAXULONG terminated array of Indirect
                                // properties w/indexes into aprs & avar
    IN OUT PROPVARIANT *avar,   // IN: array of uninitialized PROPVARIANTs,
                                // OUT: may contain pointers to alloc'd memory
    OUT ULONG *pcpropFound);    // count of property values retrieved
NTSTATUS 
PrQueryProperties(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPSPEC const aprs[],   // array of property specifiers
    OPTIONAL OUT PROPID apid[], // buffer for array of propids
    OPTIONAL OUT INDIRECTPROPERTY **ppip, // pointer to returned pointer to
                                // MAXULONG terminated array of Indirect
                                // properties w/indexes into aprs & avar
    IN OUT PROPVARIANT *avar,   // IN: array of uninitialized PROPVARIANTs,
                                // OUT: may contain pointers to alloc'd memory
    OUT ULONG *pcpropFound);    // count of property values retrieved



#define ENUMPROP_NONAMES        0x00000001      // return property IDs only

NTSTATUS PROPSYSAPI PROPAPI
RtlEnumerateProperties(
    IN NTPROP np,               // property set context
    IN ULONG Flags,             // flags: No Names (propids only), etc.
    IN OUT ULONG *pkey,         // bookmark; caller set to 0 before 1st call
    IN OUT ULONG *pcprop,       // pointer to property count
    OPTIONAL OUT PROPSPEC aprs[],// IN: array of uninitialized PROPSPECs
                                // OUT: may contain pointers to alloc'd strings
    OPTIONAL OUT STATPROPSTG asps[]);
                                // IN: array of uninitialized STATPROPSTGs
                                // OUT: may contain pointers to alloc'd strings

NTSTATUS PROPSYSAPI PROPAPI
RtlQueryPropertyNames(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID const *apid,      // PROPID array
    OUT OLECHAR *aposz[]        // OUT pointers to allocated strings
    );

NTSTATUS PROPSYSAPI PROPAPI
RtlSetPropertyNames(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID const *apid,      // PROPID array
    IN OLECHAR const * const aposz[] // pointers to property names
    );

NTSTATUS PROPSYSAPI PROPAPI
RtlSetPropertySetClassId(
    IN NTPROP np,               // property set context
    IN GUID const *pclsid       // new CLASSID of propset code
    );

NTSTATUS PROPSYSAPI PROPAPI
RtlQueryPropertySet(
    IN NTPROP np,               // property set context
    OUT STATPROPSETSTG *pspss   // buffer for property set stat information
    );

NTSTATUS PROPSYSAPI PROPAPI
RtlEnumeratePropertySets(
    IN HANDLE hstg,             // structured storage handle
    IN BOOLEAN fRestart,        // restart scan
    IN OUT ULONG *pcspss,       // pointer to count of STATPROPSETSTGs
    IN OUT GUID *pkey,          // bookmark
    OUT STATPROPSETSTG *pspss   // array of STATPROPSETSTGs
    );





NTSTATUS 
PrEnumerateProperties(
    IN NTPROP np,               // property set context
    IN ULONG Flags,             // flags: No Names (propids only), etc.
    IN OUT ULONG *pkey,         // bookmark; caller set to 0 before 1st call
    IN OUT ULONG *pcprop,       // pointer to property count
    OPTIONAL OUT PROPSPEC aprs[],// IN: array of uninitialized PROPSPECs
                                // OUT: may contain pointers to alloc'd strings
    OPTIONAL OUT STATPROPSTG asps[]);
                                // IN: array of uninitialized STATPROPSTGs
                                // OUT: may contain pointers to alloc'd strings

NTSTATUS 
PrQueryPropertyNames(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID const *apid,      // PROPID array
    OUT OLECHAR *aposz[]        // OUT pointers to allocated strings
    );

NTSTATUS 
PrSetPropertyNames(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID const *apid,      // PROPID array
    IN OLECHAR const * const aposz[] // pointers to property names
    );

NTSTATUS 
PrSetPropertySetClassId(
    IN NTPROP np,               // property set context
    IN GUID const *pclsid       // new CLASSID of propset code
    );

NTSTATUS 
PrQueryPropertySet(
    IN NTPROP np,               // property set context
    OUT STATPROPSETSTG *pspss   // buffer for property set stat information
    );

NTSTATUS 
PrEnumeratePropertySets(
    IN HANDLE hstg,             // structured storage handle
    IN BOOLEAN fRestart,        // restart scan
    IN OUT ULONG *pcspss,       // pointer to count of STATPROPSETSTGs
    IN OUT GUID *pkey,          // bookmark
    OUT STATPROPSETSTG *pspss   // array of STATPROPSETSTGs
    );



#ifdef __cplusplus
}
#endif

#endif // ifndef _PROPAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\propvar.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1993-1998
//
// File:        propvar.h
//
// Contents:    PROPVARIANT manipulation code
//
// History:     15-Aug-95   vich        created
//              01-Jul-96   MikeHill    Updated to allow Win32 SEH removal
//
//---------------------------------------------------------------------------

#ifndef _PROPVAR_H_
#define _PROPVAR_H_

#include <debnot.h>
#include <propset.h>

SERIALIZEDPROPERTYVALUE *
RtlConvertVariantToProperty(
    IN PROPVARIANT const *pvar,
    IN USHORT CodePage,
    OUT SERIALIZEDPROPERTYVALUE *pprop,
    IN OUT ULONG *pcb,
    IN PROPID pid,
    IN BOOLEAN fVariantVector,
    OPTIONAL OUT ULONG *pcIndirect);

SERIALIZEDPROPERTYVALUE *
RtlConvertVariantToPropertyNoEH(     // No NT Exception Handling version
    IN PROPVARIANT const *pvar,
    IN USHORT CodePage,
    OUT SERIALIZEDPROPERTYVALUE *pprop,
    IN OUT ULONG *pcb,
    IN PROPID pid,
    IN BOOLEAN fVariantVector,
    OPTIONAL OUT ULONG *pcIndirect,
    OUT NTSTATUS *pstatus);

BOOLEAN
RtlConvertPropertyToVariant(
    IN SERIALIZEDPROPERTYVALUE const *pprop,
    IN USHORT CodePage,
    OUT PROPVARIANT *pvar,
    IN PMemoryAllocator *pma);

BOOLEAN
RtlConvertPropertyToVariantNoEH(     // No NT Exception Handling version
    IN SERIALIZEDPROPERTYVALUE const *pprop,
    IN USHORT CodePage,
    OUT PROPVARIANT *pvar,
    IN PMemoryAllocator *pma,
    OUT NTSTATUS *pstatus);




SERIALIZEDPROPERTYVALUE *
PrConvertVariantToProperty(
    IN PROPVARIANT const *pvar,
    IN USHORT CodePage,
    OUT SERIALIZEDPROPERTYVALUE *pprop,
    IN OUT ULONG *pcb,
    IN PROPID pid,
    IN BOOLEAN fVariantVector,
    OPTIONAL OUT ULONG *pcIndirect);

SERIALIZEDPROPERTYVALUE *
PrConvertVariantToPropertyNoEH(     // No NT Exception Handling version
    IN PROPVARIANT const *pvar,
    IN USHORT CodePage,
    OUT SERIALIZEDPROPERTYVALUE *pprop,
    IN OUT ULONG *pcb,
    IN PROPID pid,
    IN BOOLEAN fVariantVector,
    OPTIONAL OUT ULONG *pcIndirect,
    OUT NTSTATUS *pstatus);

BOOLEAN
PrConvertPropertyToVariant(
    IN SERIALIZEDPROPERTYVALUE const *pprop,
    IN USHORT CodePage,
    OUT PROPVARIANT *pvar,
    IN PMemoryAllocator *pma);

BOOLEAN
PrConvertPropertyToVariantNoEH(     // No NT Exception Handling version
    IN SERIALIZEDPROPERTYVALUE const *pprop,
    IN USHORT CodePage,
    OUT PROPVARIANT *pvar,
    IN PMemoryAllocator *pma,
    OUT NTSTATUS *pstatus);





#ifndef KERNEL
VOID
CleanupVariants(
    IN PROPVARIANT *pvar,
    IN ULONG cprop,
    IN PMemoryAllocator *pma);
#endif

#if DBGPROP
BOOLEAN IsUnicodeString(WCHAR const *pwszname, ULONG cb);
BOOLEAN IsAnsiString(CHAR const *pszname, ULONG cb);
#endif


//+--------------------------------------------------------------------------
// Function:    SignalOverflow, SignalInvalidParameter, SignalStatus
//
// Synopsis:    ASSERT and raise data corrupt/overflow/specified error
//
// Arguments:   [szReason]              -- string explanation
//              [Status]                -- Status to raise (SignalStatus only)
//
// Returns:     None
//+--------------------------------------------------------------------------


#define StatusOverflow(pstatus, szReason)           \
          *(pstatus) = STATUS_BUFFER_OVERFLOW;      \
          TraceStatus(szReason)

#define StatusAccessDenied(pstatus, szReason)   \
          *(pstatus) = STATUS_ACCESS_DENIED;        \
          TraceStatus(szReason);

#define StatusInvalidParameter(pstatus, szReason)   \
          *(pstatus) = STATUS_INVALID_PARAMETER;    \
          TraceStatus(szReason);

#define StatusNoMemory(pstatus, szReason)           \
          *(pstatus) = STATUS_INSUFFICIENT_RESOURCES;\
          TraceStatus(szReason);

#define StatusDiskFull(pstatus, szReason)           \
          *(pstatus) = STATUS_DISK_FULL;            \
          TraceStatus(szReason);

#define StatusError(pstatus, szReason, Status)      \
          *(pstatus) = Status;                      \
          TraceStatus(szReason);

#ifdef KERNEL
#define StatusKBufferOverflow(pstatus, szReason) StatusOverflow(pstatus, szReason)
#else
#define StatusKBufferOverflow(pstatus, szReason) StatusNoMemory(pstatus, szReason)
#endif


#ifdef KERNEL
#define KERNELSELECT(k, u)      k
#else
#define KERNELSELECT(k, u)      u
#endif

#define DBGPROPASSERT   KERNELSELECT(DBGPROP, DBG)

#if DBGPROPASSERT
#define TraceStatus(szReason)                                   \
	{							\
	    DebugTrace(0, DEBTRACE_ERROR, (szReason "\n"));     \
	    PROPASSERTMSG(szReason, !(DebugLevel & DEBTRACE_WARN)); \
	}


#else
#define TraceStatus(szReason)
#endif



#define AssertVarField(field, cb) \
  PROPASSERT(FIELD_OFFSET(PROPVARIANT, iVal) == FIELD_OFFSET(PROPVARIANT, field) && \
	 sizeof(((PROPVARIANT *) 0)->field) == (cb))

#define AssertVarVector(field, cbElem) \
  PROPASSERT(FIELD_OFFSET(PROPVARIANT, cai.cElems) == \
	     FIELD_OFFSET(PROPVARIANT, field.cElems) && \
         FIELD_OFFSET(PROPVARIANT, cai.pElems) == \
	     FIELD_OFFSET(PROPVARIANT, field.pElems) && \
	 sizeof(((PROPVARIANT *) 0)->field.pElems[0]) == (cbElem))

#define AssertByteField(field)	    AssertVarField(field, sizeof(BYTE))
#define AssertShortField(field)	    AssertVarField(field, sizeof(SHORT))
#define AssertLongField(field)	    AssertVarField(field, sizeof(LONG))
#define AssertLongLongField(field)  AssertVarField(field, sizeof(LONGLONG))
#define AssertStringField(field)    AssertVarField(field, sizeof(VOID *))

#define AssertByteVector(field)	    AssertVarVector(field, sizeof(BYTE))
#define AssertShortVector(field)    AssertVarVector(field, sizeof(SHORT))
#define AssertLongVector(field)	    AssertVarVector(field, sizeof(LONG))
#define AssertLongLongVector(field) AssertVarVector(field, sizeof(LONGLONG))
#define AssertStringVector(field)   AssertVarVector(field, sizeof(VOID *))
#define AssertVariantVector(field)  AssertVarVector(field, sizeof(PROPVARIANT))


#define BSTRLEN(bstrVal)	*((ULONG *) bstrVal - 1)


//+-------------------------------------------------------------------
// Class:       CBufferAllocator, private
//
// Synopsis:    allocation from a buffer
//
// Notes:       The Summary catalog APIs use a single buffer to serialize row
//              values on input and deserialize them on output.  This class
//              encapsulates the memory allocation routines for these APIs.
//--------------------------------------------------------------------

class CBufferAllocator : public PMemoryAllocator
{
public:
    inline CBufferAllocator(ULONG cbBuffer, VOID *pvBuffer)
    {
	_cbFree = cbBuffer;
	_pvCur = _pvBuffer = pvBuffer;
#if defined(_X86_)
	PROPASSERT(((ULONG) _pvCur & (sizeof(LONG) - 1)) == 0);
#else
	PROPASSERT(((ULONG_PTR) _pvCur & (sizeof(LONGLONG) - 1)) == 0);
#endif // defined(_X86_)
    }

    VOID *Allocate(ULONG cbSize);
    VOID Free(VOID *pv) { }

    inline ULONG GetFreeSize(VOID) { return(_cbFree); }

private:
    ULONG  _cbFree;
    VOID  *_pvCur;
    VOID  *_pvBuffer;
};

//+-------------------------------------------------------------------
// Member:      CBufferAllocator::Allocate, private
//
// Synopsis:    allocation from a buffer
//
// Arguments:   [cb]	-- Count of bytes to be allocated.
//
// Returns:     pointer to 'allocated' memory -- NULL if no space left
//--------------------------------------------------------------------

#define DEFINE_CBufferAllocator__Allocate			\
VOID *								\
CBufferAllocator::Allocate(ULONG cb)				\
{								\
    VOID *pv;							\
								\
    cb = (cb + sizeof(LONGLONG) - 1) & ~(sizeof(LONGLONG) - 1);	\
    if (cb > _cbFree)						\
    {								\
        return(NULL);						\
    }								\
    pv = _pvCur;						\
    _pvCur = (BYTE *) _pvCur + cb;				\
    _cbFree -= cb;						\
    return(pv);							\
}

#endif // !_PROPVAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\seurtl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    seurtl.c

Abstract:

    This Module implements many security rtl routines defined in nturtl.h

Author:

    Robert Reichel  (RobertRe)  1-Mar-1991

Environment:

    Pure Runtime Library Routine
    User mode callable only

Revision History:

--*/


#include <ntos.h>
#include <nturtl.h>
#include <ntlsa.h>      // needed for RtlGetPrimaryDomain
#include "seopaque.h"
#include "sertlp.h"
#include "ldrp.h"





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//    Exported Procedures                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


#if WHEN_LSAUDLL_MOVED_TO_NTDLL
NTSTATUS
RtlGetPrimaryDomain(
    IN  ULONG            SidLength,
    OUT PBOOLEAN         PrimaryDomainPresent,
    OUT PUNICODE_STRING  PrimaryDomainName,
    OUT PUSHORT          RequiredNameLength,
    OUT PSID             PrimaryDomainSid OPTIONAL,
    OUT PULONG           RequiredSidLength
    )

/*++

Routine Description:

    This procedure opens the LSA policy object and retrieves
    the primary domain information for this machine.

Arguments:

    SidLength - Specifies the length of the PrimaryDomainSid
        parameter.

    PrimaryDomainPresent - Receives a boolean value indicating
        whether this machine has a primary domain or not. TRUE
        indicates the machine does have a primary domain. FALSE
        indicates the machine does not.

    PrimaryDomainName - Points to the unicode string to receive
        the primary domain name.  This parameter will only be
        used if there is a primary domain.

    RequiredNameLength - Recevies the length of the primary
        domain name (in bytes).  This parameter will only be
        used if there is a primary domain.

    PrimaryDomainSid - This optional parameter, if present,
        points to a buffer to receive the primary domain's
        SID.  This parameter will only be used if there is a
        primary domain.

    RequiredSidLength - Recevies the length of the primary
        domain SID (in bytes).  This parameter will only be
        used if there is a primary domain.


Return Value:

    STATUS_SUCCESS - The requested information has been retrieved.

    STATUS_BUFFER_TOO_SMALL - One of the return buffers was not
        large enough to receive the corresponding information.
        The RequiredNameLength and RequiredSidLength parameter
        values have been set to indicate the needed length.

    Other status values as may be returned by:

        LsaOpenPolicy()
        LsaQueryInformationPolicy()
        RtlCopySid()


--*/




{
    NTSTATUS Status, IgnoreStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE LsaHandle;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo;


    //
    // Set up the Security Quality Of Service
    //

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes to open the Lsa policy object
    //

    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,
                               0L,
                               (HANDLE)NULL,
                               NULL);
    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    //
    // Open the local LSA policy object
    //

    Status = LsaOpenPolicy( NULL,
                            &ObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &LsaHandle
                          );
    if (NT_SUCCESS(Status)) {

        //
        // Get the primary domain info
        //
        Status = LsaQueryInformationPolicy(LsaHandle,
                                           PolicyPrimaryDomainInformation,
                                           (PVOID *)&PrimaryDomainInfo);
        IgnoreStatus = LsaClose(LsaHandle);
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    if (NT_SUCCESS(Status)) {

        //
        // Is there a primary domain?
        //

        if (PrimaryDomainInfo->Sid != NULL) {

            //
            // Yes
            //

            (*PrimaryDomainPresent) = TRUE;
            (*RequiredNameLength) = PrimaryDomainInfo->Name.Length;
            (*RequiredSidLength)  = RtlLengthSid(PrimaryDomainInfo->Sid);



            //
            // Copy the name
            //

            if (PrimaryDomainName->MaximumLength >=
                PrimaryDomainInfo->Name.Length) {
                RtlCopyUnicodeString(
                    PrimaryDomainName,
                    &PrimaryDomainInfo->Name
                    );
            } else {
                Status = STATUS_BUFFER_TOO_SMALL;
            }


            //
            // Copy the SID (if appropriate)
            //

            if (PrimaryDomainSid != NULL && NT_SUCCESS(Status)) {

                Status = RtlCopySid(SidLength,
                                    PrimaryDomainSid,
                                    PrimaryDomainInfo->Sid
                                    );
            }
        } else {

            (*PrimaryDomainPresent) = FALSE;
        }

        //
        // We're finished with the buffer returned by LSA
        //

        IgnoreStatus = LsaFreeMemory(PrimaryDomainInfo);
        ASSERT(NT_SUCCESS(IgnoreStatus));

    }


    return(Status);
}
#endif //WHEN_LSAUDLL_MOVED_TO_NTDLL


NTSTATUS
RtlNewSecurityObjectWithMultipleInheritance (
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PSECURITY_DESCRIPTOR CreatorDescriptor OPTIONAL,
    OUT PSECURITY_DESCRIPTOR * NewDescriptor,
    IN GUID **pObjectType OPTIONAL,
    IN ULONG GuidCount,
    IN BOOLEAN IsDirectoryObject,
    IN ULONG AutoInheritFlags,
    IN HANDLE Token OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    See RtlpNewSecurityObject.

                              - - WARNING - -

    This service is for use by protected subsystems that project their own
    type of object.  This service is explicitly not for use by the
    executive for executive objects and must not be called from kernel
    mode.

Arguments:

    See RtlpNewSecurityObject.

Return Value:

    See RtlpNewSecurityObject.

--*/
{

    //
    // Simple call the newer RtlpNewSecurityObject
    //

    return RtlpNewSecurityObject (
                ParentDescriptor,
                CreatorDescriptor,
                NewDescriptor,
                pObjectType,
                GuidCount,
                IsDirectoryObject,
                AutoInheritFlags,
                Token,
                GenericMapping );

}



NTSTATUS
RtlNewSecurityObjectEx (
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PSECURITY_DESCRIPTOR CreatorDescriptor OPTIONAL,
    OUT PSECURITY_DESCRIPTOR * NewDescriptor,
    IN GUID *ObjectType OPTIONAL,
    IN BOOLEAN IsDirectoryObject,
    IN ULONG AutoInheritFlags,
    IN HANDLE Token OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    See RtlpNewSecurityObject.

                              - - WARNING - -

    This service is for use by protected subsystems that project their own
    type of object.  This service is explicitly not for use by the
    executive for executive objects and must not be called from kernel
    mode.

Arguments:

    See RtlpNewSecurityObject.

Return Value:

    See RtlpNewSecurityObject.

--*/
{

    //
    // Simple call the newer RtlpNewSecurityObject
    //

    return RtlpNewSecurityObject (
                ParentDescriptor,
                CreatorDescriptor,
                NewDescriptor,
                ObjectType ? &ObjectType : NULL,
                ObjectType ? 1 : 0,
                IsDirectoryObject,
                AutoInheritFlags,
                Token,
                GenericMapping );

}


NTSTATUS
RtlNewSecurityObject (
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PSECURITY_DESCRIPTOR CreatorDescriptor OPTIONAL,
    OUT PSECURITY_DESCRIPTOR * NewDescriptor,
    IN BOOLEAN IsDirectoryObject,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    See RtlpNewSecurityObject.

                              - - WARNING - -

    This service is for use by protected subsystems that project their own
    type of object.  This service is explicitly not for use by the
    executive for executive objects and must not be called from kernel
    mode.

Arguments:

    See RtlpNewSecurityObject.

Return Value:

    See RtlpNewSecurityObject.

--*/
{

    //
    // Simple call the newer RtlpNewSecurityObject
    //

    return RtlpNewSecurityObject (
                ParentDescriptor,
                CreatorDescriptor,
                NewDescriptor,
                NULL,   // No ObjectType
                0,  
                IsDirectoryObject,
                0,      // No Automatic inheritance
                Token,
                GenericMapping );

}



NTSTATUS
RtlSetSecurityObject (
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR ModificationDescriptor,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN PGENERIC_MAPPING GenericMapping,
    IN HANDLE Token OPTIONAL
    )
/*++

Routine Description:

    See RtlpSetSecurityObject.

Arguments:

    See RtlpSetSecurityObject.

Return Value:

    See RtlpSetSecurityObject.

--*/

{

    //
    // Simply call RtlpSetSecurityObject specifying no auto inheritance.
    //

    return RtlpSetSecurityObject( NULL,
                                  SecurityInformation,
                                  ModificationDescriptor,
                                  ObjectsSecurityDescriptor,
                                  0,   // No AutoInheritance
                                  PagedPool,
                                  GenericMapping,
                                  Token );
}



NTSTATUS
RtlSetSecurityObjectEx (
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR ModificationDescriptor,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN ULONG AutoInheritFlags,
    IN PGENERIC_MAPPING GenericMapping,
    IN HANDLE Token OPTIONAL
    )
/*++

Routine Description:

    See RtlpSetSecurityObject.

Arguments:

    See RtlpSetSecurityObject.

Return Value:

    See RtlpSetSecurityObject.

--*/

{

    //
    // Simply call RtlpSetSecurityObject specifying no auto inheritance.
    //

    return RtlpSetSecurityObject( NULL,
                                  SecurityInformation,
                                  ModificationDescriptor,
                                  ObjectsSecurityDescriptor,
                                  AutoInheritFlags,
                                  PagedPool,
                                  GenericMapping,
                                  Token );
}





NTSTATUS
RtlQuerySecurityObject (
    IN PSECURITY_DESCRIPTOR ObjectDescriptor,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR ResultantDescriptor,
    IN ULONG DescriptorLength,
    OUT PULONG ReturnLength
    )

/*++

Routine Description:

    Query information from a protected server object's existing security
    descriptor.

    This procedure, called only from user mode, is used to retrieve
    information from a security descriptor on an existing protected
    server's object.  All access checking is expected to be done before
    calling this routine.  This includes checking for READ_CONTROL, and
    privilege to read a system ACL as appropriate.

                          - - WARNING - -

    This service is for use by protected subsystems that project their own
    type of object.  This service is explicitly not for use by the
    executive for executive objects and must not be called from kernel
    mode.


Arguments:

    ObjectDescriptor - Points to a pointer to a security descriptor to be
        queried.

    SecurityInformation - Identifies the security information being
        requested.

    ResultantDescriptor - Points to buffer to receive the resultant
        security descriptor.  The resultant security descriptor will
        contain all information requested by the SecurityInformation
        parameter.

    DescriptorLength - Is an unsigned integer which indicates the length,
        in bytes, of the buffer provided to receive the resultant
        descriptor.

    ReturnLength - Receives an unsigned integer indicating the actual
        number of bytes needed in the ResultantDescriptor to store the
        requested information.  If the value returned is greater than the
        value passed via the DescriptorLength parameter, then
        STATUS_BUFFER_TOO_SMALL is returned and no information is returned.


Return Value:

    STATUS_SUCCESS - The operation was successful.

    STATUS_BUFFER_TOO_SMALL - The buffer provided to receive the requested
        information was not large enough to hold the information.  No
        information has been returned.

    STATUS_BAD_DESCRIPTOR_FORMAT - Indicates the provided object's security
        descriptor was not in self-relative format.

--*/

{

    PSID Group;
    PSID Owner;
    PACL Dacl;
    PACL Sacl;

    ULONG GroupSize = 0;
    ULONG DaclSize = 0;
    ULONG SaclSize = 0;
    ULONG OwnerSize = 0;

    PCHAR Field;
    PCHAR Base;


    PISECURITY_DESCRIPTOR IObjectDescriptor;
    PISECURITY_DESCRIPTOR_RELATIVE IResultantDescriptor;


    IResultantDescriptor = (PISECURITY_DESCRIPTOR_RELATIVE)ResultantDescriptor;
    IObjectDescriptor = (PISECURITY_DESCRIPTOR)ObjectDescriptor;

    //
    // For each item specified in the SecurityInformation, extract it
    // and get it to the point where it can be copied into a new
    // descriptor.
    //

    if (SecurityInformation & GROUP_SECURITY_INFORMATION) {

        Group = RtlpGroupAddrSecurityDescriptor(IObjectDescriptor);

        if (Group != NULL) {
            GroupSize = LongAlignSize(SeLengthSid(Group));
        }
    }

    if (SecurityInformation & DACL_SECURITY_INFORMATION) {

        Dacl = RtlpDaclAddrSecurityDescriptor( IObjectDescriptor );

        if (Dacl != NULL) {
            DaclSize = LongAlignSize(Dacl->AclSize);
        }
    }

    if (SecurityInformation & SACL_SECURITY_INFORMATION) {

        Sacl = RtlpSaclAddrSecurityDescriptor( IObjectDescriptor );

        if (Sacl != NULL) {
            SaclSize = LongAlignSize(Sacl->AclSize);
        }

    }

    if (SecurityInformation & OWNER_SECURITY_INFORMATION) {

        Owner = RtlpOwnerAddrSecurityDescriptor ( IObjectDescriptor );

        if (Owner != NULL) {
            OwnerSize = LongAlignSize(SeLengthSid(Owner));
        }
    }

    *ReturnLength = sizeof( SECURITY_DESCRIPTOR_RELATIVE ) +
                    GroupSize +
                    DaclSize  +
                    SaclSize  +
                    OwnerSize;

    if (*ReturnLength > DescriptorLength) {
        return( STATUS_BUFFER_TOO_SMALL );
    }

    RtlCreateSecurityDescriptorRelative(
        IResultantDescriptor,
        SECURITY_DESCRIPTOR_REVISION
        );

    RtlpSetControlBits( IResultantDescriptor, SE_SELF_RELATIVE );

    Base = (PCHAR)(IResultantDescriptor);
    Field =  Base + (ULONG)sizeof(SECURITY_DESCRIPTOR_RELATIVE);

    if (SecurityInformation & SACL_SECURITY_INFORMATION) {

        if (SaclSize > 0) {
            RtlMoveMemory( Field, Sacl, SaclSize );
            IResultantDescriptor->Sacl = RtlPointerToOffset(Base,Field);
            Field += SaclSize;
        }

        RtlpPropagateControlBits(
            IResultantDescriptor,
            IObjectDescriptor,
            SE_SACL_PRESENT | SE_SACL_DEFAULTED
            );
    }

    if (SecurityInformation & DACL_SECURITY_INFORMATION) {

        if (DaclSize > 0) {
            RtlMoveMemory( Field, Dacl, DaclSize );
            IResultantDescriptor->Dacl = RtlPointerToOffset(Base,Field);
            Field += DaclSize;
        }

        RtlpPropagateControlBits(
            IResultantDescriptor,
            IObjectDescriptor,
            SE_DACL_PRESENT | SE_DACL_DEFAULTED
            );
    }

    if (SecurityInformation & OWNER_SECURITY_INFORMATION) {

        if (OwnerSize > 0) {
            RtlMoveMemory( Field, Owner, OwnerSize );
            IResultantDescriptor->Owner = RtlPointerToOffset(Base,Field);
            Field += OwnerSize;
        }

        RtlpPropagateControlBits(
            IResultantDescriptor,
            IObjectDescriptor,
            SE_OWNER_DEFAULTED
            );

    }

    if (SecurityInformation & GROUP_SECURITY_INFORMATION) {

        if (GroupSize > 0) {
            RtlMoveMemory( Field, Group, GroupSize );
            IResultantDescriptor->Group = RtlPointerToOffset(Base,Field);
        }

        RtlpPropagateControlBits(
            IResultantDescriptor,
            IObjectDescriptor,
            SE_GROUP_DEFAULTED
            );
    }

    return( STATUS_SUCCESS );

}





NTSTATUS
RtlDeleteSecurityObject (
    IN OUT PSECURITY_DESCRIPTOR * ObjectDescriptor
    )


/*++

Routine Description:

    Delete a protected server object's security descriptor.

    This procedure, called only from user mode, is used to delete a
    security descriptor associated with a protected server's object.  This
    routine will normally be called by a protected server during object
    deletion.

                                  - - WARNING - -

    This service is for use by protected subsystems that project their own
    type of object.  This service is explicitly not for use by the
    executive for executive objects and must not be called from kernel
    mode.


Arguments:

    ObjectDescriptor - Points to a pointer to a security descriptor to be
        deleted.


Return Value:

    STATUS_SUCCESS - The operation was successful.

--*/

{
    RtlFreeHeap( RtlProcessHeap(), 0, (PVOID)*ObjectDescriptor );

    return( STATUS_SUCCESS );

}




NTSTATUS
RtlNewInstanceSecurityObject(
    IN BOOLEAN ParentDescriptorChanged,
    IN BOOLEAN CreatorDescriptorChanged,
    IN PLUID OldClientTokenModifiedId,
    OUT PLUID NewClientTokenModifiedId,
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PSECURITY_DESCRIPTOR CreatorDescriptor OPTIONAL,
    OUT PSECURITY_DESCRIPTOR * NewDescriptor,
    IN BOOLEAN IsDirectoryObject,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping
    )

/*++

Routine Description:

    If the return status is STATUS_SUCCESS and the NewSecurity return
    value is NULL, then the security desscriptor of the original
    instance of the object is valid for this instance as well.

Arguments:

    ParentDescriptorChanged - Supplies a flag indicating whether the
        parent security descriptor has changed since the last time
        this set of parameters was used.

    CreatorDescriptorChanged - Supplies a flag indicating whether the
        creator security descriptor has changed since the last time
        this set of parameters was used.

    OldClientTokenModifiedId - Supplies the ModifiedId from the passed
        token that was in effect when this call was last made with
        these parameters.  If the current ModifiedId is different from
        the one passed in here, the security descriptor must be
        rebuilt.

    NewClientTokenModifiedId - Returns the current ModifiedId from the
        passed token.

    ParentDescriptor - Supplies the Security Descriptor for the parent
        directory under which a new object is being created.  If there is
        no parent directory, then this argument is specified as NULL.

    CreatorDescriptor - (Optionally) Points to a security descriptor
        presented by the creator of the object.  If the creator of the
        object did not explicitly pass security information for the new
        object, then a null pointer should be passed.

    NewDescriptor - Points to a pointer that is to be made to point to the
        newly allocated self-relative security descriptor.

    IsDirectoryObject - Specifies if the new object is going to be a
        directory object.  A value of TRUE indicates the object is a
        container of other objects.

    Token - Supplies the token for the client on whose behalf the
        object is being created.  If it is an impersonation token,
        then it must be at SecurityIdentification level or higher.  If
        it is not an impersonation token, the operation proceeds
        normally.

        A client token is used to retrieve default security
        information for the new object, such as default owner, primary
        group, and discretionary access control.  The token must be
        open for TOKEN_QUERY access.

    GenericMapping - Supplies a pointer to a generic mapping array denoting
        the mapping between each generic right to specific rights.

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{

    TOKEN_STATISTICS ClientTokenStatistics;
    ULONG ReturnLength;
    NTSTATUS Status;



    //
    // Get the current token modified LUID
    //


    Status = NtQueryInformationToken(
                 Token,                        // Handle
                 TokenStatistics,              // TokenInformationClass
                 &ClientTokenStatistics,       // TokenInformation
                 sizeof(TOKEN_STATISTICS),     // TokenInformationLength
                 &ReturnLength                 // ReturnLength
                 );

    if ( !NT_SUCCESS( Status )) {
        return( Status );
    }

    *NewClientTokenModifiedId = ClientTokenStatistics.ModifiedId;

    if ( RtlEqualLuid(NewClientTokenModifiedId, OldClientTokenModifiedId) ) {

        if ( !(ParentDescriptorChanged || CreatorDescriptorChanged) ) {

            //
            // The old security descriptor is valid for this new instance
            // of the object type as well.  Pass back success and NULL for
            // the NewDescriptor.
            //

            *NewDescriptor = NULL;
            return( STATUS_SUCCESS );

        }
    }

    //
    // Something has changed, take the long route and build a new
    // descriptor
    //

    return( RtlNewSecurityObject( ParentDescriptor,
                                  CreatorDescriptor,
                                  NewDescriptor,
                                  IsDirectoryObject,
                                  Token,
                                  GenericMapping
                                  ));
}




NTSTATUS
RtlNewSecurityGrantedAccess(
    IN ACCESS_MASK DesiredAccess,
    OUT PPRIVILEGE_SET Privileges,
    IN OUT PULONG Length,
    IN HANDLE Token OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PACCESS_MASK RemainingDesiredAccess
    )

/*++

Routine Description:

    This routine implements privilege policy by examining the bits in
    a DesiredAccess mask and adjusting them based on privilege checks.

    Currently, a request for ACCESS_SYSTEM_SECURITY may only be satisfied
    by the caller having SeSecurityPrivilege.

    Note that this routine is only to be called when an object is being
    created.  When an object is being opened, it is expected that
    NtAccessCheck will be called, and that routine will implement
    another policy for substituting privileges for DACL access.

Arguments:

    DesiredAccess - Supplies the user's desired access mask

    Privileges - Supplies a pointer to an empty buffer in which will
        be returned a privilege set describing any privileges that were
        used to gain access.

        Note that this is not an optional parameter, that is, enough
        room for a single privilege must always be passed.

    Length - Supplies the length of the Privileges parameter in bytes.
        If the supplies length is not adequate to store the entire
        privilege set, this field will return the minimum length required.

    Token - (optionally) Supplies the token for the client on whose
        behalf the object is being accessed.  If this value is
        specified as null, then the token on the thread is opened and
        examined to see if it is an impersonation token.  If it is,
        then it must be at SecurityIdentification level or higher.  If
        it is not an impersonation token, the operation proceeds
        normally.

    GenericMapping - Supplies the generic mapping associated with this
        object type.

    RemainingDesiredAccess - Returns the DesiredAccess mask after any bits
        have been masked off.  If no access types could be granted, this
        mask will be identical to the one passed in.

Return Value:

    STATUS_SUCCESS - The operation completed successfully.

    STATUS_BUFFER_TOO_SMALL - The passed buffer was not large enough
        to contain the information being returned.

    STATUS_BAD_IMPERSONATION_LEVEL - The caller or passed token was
        impersonating, but not at a high enough level.


--*/

{
    PRIVILEGE_SET RequiredPrivilege;
    BOOLEAN Result = FALSE;
    NTSTATUS Status;
    ULONG PrivilegeCount = 0;
    HANDLE ThreadToken;
    BOOLEAN TokenPassed;
    TOKEN_STATISTICS ThreadTokenStatistics;
    ULONG ReturnLength;
    ULONG SizeRequired;
    ULONG PrivilegeNumber = 0;


    //
    //  If the caller hasn't passed a token, call the kernel and get
    //  his impersonation token.  This call will fail if the caller is
    //  not impersonating a client, so if the caller is not
    //  impersonating someone, he'd better have passed in an explicit
    //  token.
    //

    if (!ARGUMENT_PRESENT( Token )) {

        Status = NtOpenThreadToken(
                     NtCurrentThread(),
                     TOKEN_QUERY,
                     TRUE,
                     &ThreadToken
                     );

        TokenPassed = FALSE;

        if (!NT_SUCCESS( Status )) {
            return( Status );
        }

    } else {

        ThreadToken = Token;
        TokenPassed = TRUE;
    }

    Status = NtQueryInformationToken(
                 ThreadToken,                  // Handle
                 TokenStatistics,              // TokenInformationClass
                 &ThreadTokenStatistics,       // TokenInformation
                 sizeof(TOKEN_STATISTICS),     // TokenInformationLength
                 &ReturnLength                 // ReturnLength
                 );

    ASSERT( NT_SUCCESS(Status) );

    RtlMapGenericMask(
        &DesiredAccess,
        GenericMapping
        );

    *RemainingDesiredAccess = DesiredAccess;

    if ( DesiredAccess & ACCESS_SYSTEM_SECURITY ) {

        RequiredPrivilege.PrivilegeCount = 1;
        RequiredPrivilege.Control = PRIVILEGE_SET_ALL_NECESSARY;
        RequiredPrivilege.Privilege[0].Luid = RtlConvertLongToLuid(SE_SECURITY_PRIVILEGE);
        RequiredPrivilege.Privilege[0].Attributes = 0;

        //
        // NtPrivilegeCheck will make sure we are impersonating
        // properly.
        //

        Status = NtPrivilegeCheck(
                     ThreadToken,
                     &RequiredPrivilege,
                     &Result
                     );

        if ( (!NT_SUCCESS ( Status )) || (!Result) ) {

            if (!TokenPassed) {
                NtClose( ThreadToken );
            }

            if ( !NT_SUCCESS( Status )) {
                return( Status );
            }

            if ( !Result ) {
                return( STATUS_PRIVILEGE_NOT_HELD );
            }

        }

        //
        // We have the required privilege, turn off the bit in
        // copy of the input mask and remember that we need to return
        // this privilege.
        //

        *RemainingDesiredAccess &= ~ACCESS_SYSTEM_SECURITY;
    }

    if (!TokenPassed) {
        NtClose( ThreadToken );
    }

    SizeRequired = sizeof(PRIVILEGE_SET);

    if ( SizeRequired > *Length ) {
        *Length = SizeRequired;
        return( STATUS_BUFFER_TOO_SMALL );
    }

    if (Result) {

        Privileges->PrivilegeCount = 1;
        Privileges->Control = 0;
        Privileges->Privilege[PrivilegeNumber].Luid = RtlConvertLongToLuid(SE_SECURITY_PRIVILEGE);
        Privileges->Privilege[PrivilegeNumber].Attributes = SE_PRIVILEGE_USED_FOR_ACCESS;

    } else {

        Privileges->PrivilegeCount = 0;
        Privileges->Control = 0;
        Privileges->Privilege[PrivilegeNumber].Luid = RtlConvertLongToLuid(0);
        Privileges->Privilege[PrivilegeNumber].Attributes = 0;

    }

    return( STATUS_SUCCESS );

}



NTSTATUS
RtlCopySecurityDescriptor(
    IN PSECURITY_DESCRIPTOR InputSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR *OutputSecurityDescriptor
    )

/*++

Routine Description:

    This routine will copy a self-relative security descriptor from
    any memory into the correct type of memory required by security
    descriptor Rtl routines.

    This allows security descriptors to be kept in whatever kind of
    storage is most convenient for the current application.  A security
    descriptor should be copied via this routine and the copy passed
    into any Rtl routine that in any way modify the security descriptor
    (eg RtlSetSecurityObject).

    The storage allocated by this routine must be freed by
    RtlDeleteSecurityObject.

Arguments:

    InputSecurityDescriptor - contains the source security descriptor

    OutputSecurityDescriptor - returns a copy of the security descriptor
        in the correct kind of memory.


Return Value:

    STATUS_NO_MEMORY - There was not enough memory available to the current
        process to complete this operation.

--*/

{

    PACL Dacl;
    PACL Sacl;

    PSID Owner;
    PSID PrimaryGroup;

    ULONG DaclSize;
    ULONG OwnerSize;
    ULONG PrimaryGroupSize;
    ULONG SaclSize;
    ULONG TotalSize;

    PISECURITY_DESCRIPTOR ISecurityDescriptor =
                            (PISECURITY_DESCRIPTOR)InputSecurityDescriptor;


    RtlpQuerySecurityDescriptor(
        ISecurityDescriptor,
        &Owner,
        &OwnerSize,
        &PrimaryGroup,
        &PrimaryGroupSize,
        &Dacl,
        &DaclSize,
        &Sacl,
        &SaclSize
        );

    TotalSize = sizeof(SECURITY_DESCRIPTOR_RELATIVE) +
                OwnerSize +
                PrimaryGroupSize +
                DaclSize +
                SaclSize;

    *OutputSecurityDescriptor = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( SE_TAG ), TotalSize );

    if ( *OutputSecurityDescriptor == NULL ) {
        return( STATUS_NO_MEMORY );
    }

    RtlMoveMemory( *OutputSecurityDescriptor,
                   ISecurityDescriptor,
                   TotalSize
                   );

    return( STATUS_SUCCESS );

}


NTSTATUS
RtlpInitializeAllowedAce(
    IN  PACCESS_ALLOWED_ACE AllowedAce,
    IN  USHORT AceSize,
    IN  UCHAR InheritFlags,
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID AllowedSid
    )
/*++

Routine Description:

    This function assigns the specified ACE values into an allowed type ACE.

Arguments:

    AllowedAce - Supplies a pointer to the ACE that is initialized.

    AceSize - Supplies the size of the ACE in bytes.

    InheritFlags - Supplies ACE inherit flags.

    AceFlags - Supplies ACE type specific control flags.

    Mask - Supplies the allowed access masks.

    AllowedSid - Supplies the pointer to the SID of user/group which is allowed
        the specified access.

Return Value:

    Returns status from RtlCopySid.

--*/
{
    AllowedAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    AllowedAce->Header.AceSize = AceSize;
    AllowedAce->Header.AceFlags = AceFlags | InheritFlags;

    AllowedAce->Mask = Mask;

    return RtlCopySid(
               RtlLengthSid(AllowedSid),
               &(AllowedAce->SidStart),
               AllowedSid
               );
}


NTSTATUS
RtlpInitializeDeniedAce(
    IN  PACCESS_DENIED_ACE DeniedAce,
    IN  USHORT AceSize,
    IN  UCHAR InheritFlags,
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID DeniedSid
    )
/*++

Routine Description:

    This function assigns the specified ACE values into a denied type ACE.

Arguments:

    DeniedAce - Supplies a pointer to the ACE that is initialized.

    AceSize - Supplies the size of the ACE in bytes.

    InheritFlags - Supplies ACE inherit flags.

    AceFlags - Supplies ACE type specific control flags.

    Mask - Supplies the denied access masks.

    AllowedSid - Supplies the pointer to the SID of user/group which is denied
        the specified access.

Return Value:

    Returns status from RtlCopySid.

--*/
{
    DeniedAce->Header.AceType = ACCESS_DENIED_ACE_TYPE;
    DeniedAce->Header.AceSize = AceSize;
    DeniedAce->Header.AceFlags = AceFlags | InheritFlags;

    DeniedAce->Mask = Mask;

    return RtlCopySid(
               RtlLengthSid(DeniedSid),
               &(DeniedAce->SidStart),
               DeniedSid
               );
}


NTSTATUS
RtlpInitializeAuditAce(
    IN  PACCESS_ALLOWED_ACE AuditAce,
    IN  USHORT AceSize,
    IN  UCHAR InheritFlags,
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID AuditSid
    )
/*++

Routine Description:

    This function assigns the specified ACE values into an audit type ACE.

Arguments:

    AuditAce - Supplies a pointer to the ACE that is initialized.

    AceSize - Supplies the size of the ACE in bytes.

    InheritFlags - Supplies ACE inherit flags.

    AceFlags - Supplies ACE type specific control flags.

    Mask - Supplies the allowed access masks.

    AuditSid - Supplies the pointer to the SID of user/group which is to be
        audited.

Return Value:

    Returns status from RtlCopySid.

--*/
{
    AuditAce->Header.AceType = SYSTEM_AUDIT_ACE_TYPE;
    AuditAce->Header.AceSize = AceSize;
    AuditAce->Header.AceFlags = AceFlags | InheritFlags;

    AuditAce->Mask = Mask;

    return RtlCopySid(
               RtlLengthSid(AuditSid),
               &(AuditAce->SidStart),
               AuditSid
               );
}

NTSTATUS
RtlCreateAndSetSD(
    IN  PRTL_ACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid OPTIONAL,
    IN  PSID GroupSid OPTIONAL,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    )
/*++

Routine Description:

    This function creates an absolute security descriptor containing
    the supplied ACE information.

    A sample usage of this function:

        //
        // Order matters!  These ACEs are inserted into the DACL in the
        // following order.  Security access is granted or denied based on
        // the order of the ACEs in the DACL.
        //

        RTL_ACE_DATA AceData[4] = {
            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   GENERIC_ALL,                  &LocalAdminSid},

            {ACCESS_DENIED_ACE_TYPE,  0, 0,
                   GENERIC_ALL,                  &NetworkSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET |
                   WKSTA_CONFIG_USER_INFO_GET,   &DomainUsersSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET,  &DomainGuestsSid}
            };

        PSECURITY_DESCRIPTOR WkstaSecurityDescriptor;


        return RtlCreateAndSetSD(
                   AceData,
                   4,
                   LocalSystemSid,
                   LocalSystemSid,
                   &WkstaSecurityDescriptor
                   );

Arguments:

    AceData - Supplies the structure of information that describes the DACL.

    AceCount - Supplies the number of entries in AceData structure.

    OwnerSid - Supplies the pointer to the SID of the security descriptor
        owner.  If not specified, a security descriptor with no owner
        will be created.

    GroupSid - Supplies the pointer to the SID of the security descriptor
        primary group.  If not specified, a security descriptor with no primary
        group will be created.

    NewDescriptor - Returns a pointer to the absolute security descriptor
        allocated using RtlAllocateHeap.

Return Value:

    STATUS_SUCCESS - if successful
    STATUS_NO_MEMORY - if cannot allocate memory for DACL, ACEs, and
        security descriptor.

    Any other status codes returned from the security Rtl routines.

    NOTE : the user security object created by calling this function may be
                freed up by calling RtlDeleteSecurityObject().

--*/
{

    NTSTATUS ntstatus = STATUS_SUCCESS;
    ULONG i;

    //
    // Pointer to memory dynamically allocated by this routine to hold
    // the absolute security descriptor, the DACL, the SACL, and all the ACEs.
    //
    // +---------------------------------------------------------------+
    // |                     Security Descriptor                       |
    // +-------------------------------+-------+---------------+-------+
    // |          DACL                 | ACE 1 |   .  .  .     | ACE n |
    // +-------------------------------+-------+---------------+-------+
    // |          SACL                 | ACE 1 |   .  .  .     | ACE n |
    // +-------------------------------+-------+---------------+-------+
    //

    PSECURITY_DESCRIPTOR AbsoluteSd = NULL;
    PACL Dacl = NULL;   // Pointer to the DACL portion of above buffer
    PACL Sacl = NULL;   // Pointer to the SACL portion of above buffer

    ULONG DaclSize = sizeof(ACL);
    ULONG SaclSize = sizeof(ACL);
    ULONG MaxAceSize = 0;
    PVOID MaxAce = NULL;

    PCHAR CurrentAvailable;
    ULONG Size;

    PVOID HeapHandle = RtlProcessHeap();


    ASSERT( AceCount > 0 );

    //
    // Compute the total size of the DACL and SACL ACEs and the maximum
    // size of any ACE.
    //

    for (i = 0; i < AceCount; i++) {
        ULONG AceSize;

        AceSize = RtlLengthSid(*(AceData[i].Sid));

        switch (AceData[i].AceType) {
        case ACCESS_ALLOWED_ACE_TYPE:
            AceSize += sizeof(ACCESS_ALLOWED_ACE);
            DaclSize += AceSize;
            break;

        case ACCESS_DENIED_ACE_TYPE:
            AceSize += sizeof(ACCESS_DENIED_ACE);
            DaclSize += AceSize;
            break;

        case SYSTEM_AUDIT_ACE_TYPE:
            AceSize += sizeof(SYSTEM_AUDIT_ACE);
            SaclSize += AceSize;
            break;

        default:
            return STATUS_INVALID_PARAMETER;
        }

        MaxAceSize = MaxAceSize > AceSize ? MaxAceSize : AceSize;
    }

    //
    // Allocate a chunk of memory large enough for the security descriptor,
    // the DACL, the SACL and all ACEs.
    //
    // A security descriptor is of opaque data type but
    // SECURITY_DESCRIPTOR_MIN_LENGTH is the right size.
    //

    Size = SECURITY_DESCRIPTOR_MIN_LENGTH;
    if ( DaclSize != sizeof(ACL) ) {
        Size += DaclSize;
    }
    if ( SaclSize != sizeof(ACL) ) {
        Size += SaclSize;
    }

    if ((AbsoluteSd = RtlAllocateHeap(
                          HeapHandle, MAKE_TAG( SE_TAG ),
                          Size
                          )) == NULL) {
        ntstatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Initialize the Dacl and Sacl
    //

    CurrentAvailable = (PCHAR)AbsoluteSd + SECURITY_DESCRIPTOR_MIN_LENGTH;

    if ( DaclSize != sizeof(ACL) ) {
        Dacl = (PACL)CurrentAvailable;
        CurrentAvailable += DaclSize;

        ntstatus = RtlCreateAcl( Dacl, DaclSize, ACL_REVISION );

        if ( !NT_SUCCESS(ntstatus) ) {
            goto Cleanup;
        }
    }

    if ( SaclSize != sizeof(ACL) ) {
        Sacl = (PACL)CurrentAvailable;
        CurrentAvailable += SaclSize;

        ntstatus = RtlCreateAcl( Sacl, SaclSize, ACL_REVISION );

        if ( !NT_SUCCESS(ntstatus) ) {
            goto Cleanup;
        }
    }

    //
    // Allocate a temporary buffer big enough for the biggest ACE.
    //

    if ((MaxAce = RtlAllocateHeap(
                      HeapHandle, MAKE_TAG( SE_TAG ),
                      MaxAceSize
                      )) == NULL ) {
        ntstatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Initialize each ACE, and append it into the end of the DACL or SACL.
    //

    for (i = 0; i < AceCount; i++) {
        ULONG AceSize;
        PACL CurrentAcl;

        AceSize = RtlLengthSid(*(AceData[i].Sid));

        switch (AceData[i].AceType) {
        case ACCESS_ALLOWED_ACE_TYPE:

            AceSize += sizeof(ACCESS_ALLOWED_ACE);
            CurrentAcl = Dacl;
            ntstatus = RtlpInitializeAllowedAce(
                           MaxAce,
                           (USHORT) AceSize,
                           AceData[i].InheritFlags,
                           AceData[i].AceFlags,
                           AceData[i].Mask,
                           *(AceData[i].Sid)
                           );
            break;

        case ACCESS_DENIED_ACE_TYPE:
            AceSize += sizeof(ACCESS_DENIED_ACE);
            CurrentAcl = Dacl;
            ntstatus = RtlpInitializeDeniedAce(
                           MaxAce,
                           (USHORT) AceSize,
                           AceData[i].InheritFlags,
                           AceData[i].AceFlags,
                           AceData[i].Mask,
                           *(AceData[i].Sid)
                           );
            break;

        case SYSTEM_AUDIT_ACE_TYPE:
            AceSize += sizeof(SYSTEM_AUDIT_ACE);
            CurrentAcl = Sacl;
            ntstatus = RtlpInitializeAuditAce(
                           MaxAce,
                           (USHORT) AceSize,
                           AceData[i].InheritFlags,
                           AceData[i].AceFlags,
                           AceData[i].Mask,
                           *(AceData[i].Sid)
                           );
            break;
        }

        if ( !NT_SUCCESS( ntstatus ) ) {
            goto Cleanup;
        }

        //
        // Append the initialized ACE to the end of DACL or SACL
        //

        if (! NT_SUCCESS (ntstatus = RtlAddAce(
                                         CurrentAcl,
                                         ACL_REVISION,
                                         MAXULONG,
                                         MaxAce,
                                         AceSize
                                         ))) {
            goto Cleanup;
        }
    }

    //
    // Create the security descriptor with absolute pointers to SIDs
    // and ACLs.
    //
    // Owner = OwnerSid
    // Group = GroupSid
    // Dacl  = Dacl
    // Sacl  = Sacl
    //

    if (! NT_SUCCESS(ntstatus = RtlCreateSecurityDescriptor(
                                    AbsoluteSd,
                                    SECURITY_DESCRIPTOR_REVISION
                                    ))) {
        goto Cleanup;
    }

    if (! NT_SUCCESS(ntstatus = RtlSetOwnerSecurityDescriptor(
                                    AbsoluteSd,
                                    OwnerSid,
                                    FALSE
                                    ))) {
        goto Cleanup;
    }

    if (! NT_SUCCESS(ntstatus = RtlSetGroupSecurityDescriptor(
                                    AbsoluteSd,
                                    GroupSid,
                                    FALSE
                                    ))) {
        goto Cleanup;
    }

    if (! NT_SUCCESS(ntstatus = RtlSetDaclSecurityDescriptor(
                                    AbsoluteSd,
                                    TRUE,
                                    Dacl,
                                    FALSE
                                    ))) {
        goto Cleanup;
    }

    if (! NT_SUCCESS(ntstatus = RtlSetSaclSecurityDescriptor(
                                    AbsoluteSd,
                                    FALSE,
                                    Sacl,
                                    FALSE
                                    ))) {
        goto Cleanup;
    }

    //
    // Done
    //

    ntstatus = STATUS_SUCCESS;

    //
    // Clean up
    //

Cleanup:
    //
    // Either return the security descriptor to the caller or delete it
    //

    if ( NT_SUCCESS( ntstatus ) ) {
        *NewDescriptor = AbsoluteSd;
    } else if ( AbsoluteSd != NULL ) {
        (void) RtlFreeHeap(HeapHandle, 0, AbsoluteSd);
    }

    //
    // Delete the temporary ACE
    //

    if ( MaxAce != NULL ) {
        (void) RtlFreeHeap(HeapHandle, 0, MaxAce);
    }
    return ntstatus;
}


NTSTATUS
RtlCreateUserSecurityObject(
    IN  PRTL_ACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid,
    IN  PSID GroupSid,
    IN  BOOLEAN IsDirectoryObject,
    IN  PGENERIC_MAPPING GenericMapping,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    )
/*++

Routine Description:

    This function creates the DACL for the security descriptor based on
    on the ACE information specified, and creates the security descriptor
    which becomes the user-mode security object.

    A sample usage of this function:

        //
        // Structure that describes the mapping of Generic access rights to
        // object specific access rights for the ConfigurationInfo object.
        //

        GENERIC_MAPPING WsConfigInfoMapping = {
            STANDARD_RIGHTS_READ            |      // Generic read
                WKSTA_CONFIG_GUEST_INFO_GET |
                WKSTA_CONFIG_USER_INFO_GET  |
                WKSTA_CONFIG_ADMIN_INFO_GET,
            STANDARD_RIGHTS_WRITE |                // Generic write
                WKSTA_CONFIG_INFO_SET,
            STANDARD_RIGHTS_EXECUTE,               // Generic execute
            WKSTA_CONFIG_ALL_ACCESS                // Generic all
            };

        //
        // Order matters!  These ACEs are inserted into the DACL in the
        // following order.  Security access is granted or denied based on
        // the order of the ACEs in the DACL.
        //

        RTL_ACE_DATA AceData[4] = {
            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   GENERIC_ALL,                  &LocalAdminSid},

            {ACCESS_DENIED_ACE_TYPE,  0, 0,
                   GENERIC_ALL,                  &NetworkSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET |
                   WKSTA_CONFIG_USER_INFO_GET,   &DomainUsersSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET,  &DomainGuestsSid}
            };

        PSECURITY_DESCRIPTOR WkstaSecurityObject;


        return RtlCreateUserSecurityObject(
                   AceData,
                   4,
                   LocalSystemSid,
                   LocalSystemSid,
                   FALSE,
                   &WsConfigInfoMapping,
                   &WkstaSecurityObject
                   );

Arguments:

    AceData - Supplies the structure of information that describes the DACL.

    AceCount - Supplies the number of entries in AceData structure.

    OwnerSid - Supplies the pointer to the SID of the security descriptor
        owner.

    GroupSid - Supplies the pointer to the SID of the security descriptor
        primary group.

    IsDirectoryObject - Supplies the flag which indicates whether the
        user-mode object is a directory object.

    GenericMapping - Supplies the pointer to a generic mapping array denoting
        the mapping between each generic right to specific rights.

    NewDescriptor - Returns a pointer to the self-relative security descriptor
        which represents the user-mode object.

Return Value:

    STATUS_SUCCESS - if successful
    STATUS_NO_MEMORY - if cannot allocate memory for DACL, ACEs, and
        security descriptor.

    Any other status codes returned from the security Rtl routines.

    NOTE : the user security object created by calling this function may be
                freed up by calling RtlDeleteSecurityObject().

--*/
{

    NTSTATUS ntstatus;
    PSECURITY_DESCRIPTOR AbsoluteSd;
    HANDLE TokenHandle;
    PVOID HeapHandle = RtlProcessHeap();

    ntstatus = RtlCreateAndSetSD(
                   AceData,
                   AceCount,
                   OwnerSid,
                   GroupSid,
                   &AbsoluteSd
                   );

    if (! NT_SUCCESS(ntstatus)) {
        return ntstatus;
    }

    ntstatus = NtOpenProcessToken(
                   NtCurrentProcess(),
                   TOKEN_QUERY,
                   &TokenHandle
                   );

    if (! NT_SUCCESS(ntstatus)) {
        (void) RtlFreeHeap(HeapHandle, 0, AbsoluteSd);
        return ntstatus;
    }

    //
    // Create the security object (a user-mode object is really a pseudo-
    // object represented by a security descriptor that have relative
    // pointers to SIDs and ACLs).  This routine allocates the memory to
    // hold the relative security descriptor so the memory allocated for the
    // DACL, ACEs, and the absolute descriptor can be freed.
    //
    ntstatus = RtlNewSecurityObject(
                   NULL,                   // Parent descriptor
                   AbsoluteSd,             // Creator descriptor
                   NewDescriptor,          // Pointer to new descriptor
                   IsDirectoryObject,      // Is directory object
                   TokenHandle,            // Token
                   GenericMapping          // Generic mapping
                   );

    (void) NtClose(TokenHandle);

    //
    // Free dynamic memory before returning
    //
    (void) RtlFreeHeap(HeapHandle, 0, AbsoluteSd);
    return ntstatus;
}





NTSTATUS
RtlConvertToAutoInheritSecurityObject(
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PSECURITY_DESCRIPTOR CurrentSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR *NewSecurityDescriptor,
    IN GUID *ObjectType OPTIONAL,
    IN BOOLEAN IsDirectoryObject,
    IN PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    This is a converts a security descriptor whose ACLs are not marked
    as AutoInherit to a security descriptor whose ACLs are marked as
    AutoInherit.

    See further detailed description on ConvertToAutoInheritPrivateObjectSecurity.

Arguments:

    ParentDescriptor - Supplies the Security Descriptor for the parent
        directory under which a object exists.  If there is
        no parent directory, then this argument is specified as NULL.

    CurrentSecurityDescriptor - Supplies a pointer to the objects security descriptor
        that is going to be altered by this procedure.

    NewSecurityDescriptor Points to a pointer that is to be made to point to the
        newly allocated self-relative security descriptor. When no
        longer needed, this descriptor must be freed using
        DestroyPrivateObjectSecurity().

    ObjectType - GUID of the object type being created.  If the object being
        created has no GUID associated with it, then this argument is
        specified as NULL.

    IsDirectoryObject - Specifies if the object is a
        directory object.  A value of TRUE indicates the object is a
        container of other objects.

    GenericMapping - Supplies a pointer to a generic mapping array denoting
        the mapping between each generic right to specific rights.

Return Value:

    STATUS_SUCCESS - The operation was successful.

    STATUS_UNKNOWN_REVISION - Indicates the source ACL is a revision that
        is unknown to this routine.  (Only revision 2 ACLs are support by this routine.)

    STATUS_INVALID_ACL - The structure of one of the ACLs in invalid.



--*/
{

    //
    // Simply call the corresponding Rtlp routine telling it which allocator
    //  to use.
    //

    return RtlpConvertToAutoInheritSecurityObject(
                            ParentDescriptor,
                            CurrentSecurityDescriptor,
                            NewSecurityDescriptor,
                            ObjectType,
                            IsDirectoryObject,
                            GenericMapping );

}


NTSTATUS
RtlDefaultNpAcl(
    OUT PACL * pAcl
    )
/*++

Routine Description:

    This routine constructs a default ACL to be applied to
    named pipe objects when the caller has not specified one.
    See NT bug 131090.

    The ACL constructed is as follows:

    Need to build an ACL that looks like the following:

     Local System : F
     Administrators: F
     Owner: F
     Everyone: R
     Anonymous: R

     The owner is determined by querying the currently effective
     token and extracting the default owner.

Arguments:

    pAcl - Receives a pointer to an ACL to apply to the named pipe
        being created.  Guaranteed to be NULL on return if an error
        occurs.

        This must be freed by calling RtlFreeHeap.

Return Value:

    NT Status.

--*/
{
    SID_IDENTIFIER_AUTHORITY    NtAuthority         = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    CreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    WorldSidAuthority   = SECURITY_WORLD_SID_AUTHORITY;

    ULONG AclSize         = 0;
    NTSTATUS Status       = STATUS_SUCCESS;
    ULONG ReturnLength    = 0;
    PTOKEN_OWNER OwnerSid = NULL;

    HANDLE hToken;

    //
    // Initialize OUT parameters
    //

    *pAcl = NULL;

    //
    // Open thread token
    //

    Status = NtOpenThreadToken(
                 NtCurrentThread(),
                 TOKEN_QUERY,
                 TRUE,
                 &hToken
                 );

    if (STATUS_NO_TOKEN == Status) {

        //
        // Not impersonating, get process token
        //

        Status = NtOpenProcessToken(
                     NtCurrentProcess(),
                     TOKEN_QUERY,
                     &hToken
                     );
    }

    if (NT_SUCCESS( Status )) {

        //
        // Get the default owner
        //

        Status = NtQueryInformationToken (
                     hToken,
                     TokenOwner,
                     NULL,
                     0,
                     &ReturnLength
                     );

        if (STATUS_BUFFER_TOO_SMALL == Status) {

            OwnerSid = (PTOKEN_OWNER)RtlAllocateHeap( RtlProcessHeap(), 0, ReturnLength );

            if (OwnerSid) {

                Status = NtQueryInformationToken (
                             hToken,
                             TokenOwner,
                             OwnerSid,
                             ReturnLength,
                             &ReturnLength
                             );

                if (NT_SUCCESS( Status )) {

                    //
                    // Compute the size needed
                    //

                    UCHAR SidBuffer[16];
                    ASSERT( 16 == RtlLengthRequiredSid( 2 ));

                    AclSize += RtlLengthRequiredSid( 1 );   // LocalSystem Sid
                    AclSize += RtlLengthRequiredSid( 2 );   // Administrators
                    AclSize += RtlLengthRequiredSid( 1 );   // Everyone (World)
                    AclSize += RtlLengthRequiredSid( 1 );   // Anonymous Logon Sid

                    AclSize += RtlLengthSid( OwnerSid->Owner );   // Owner

                    AclSize += sizeof( ACL );               // Header
                    AclSize += 5 * (sizeof( ACCESS_ALLOWED_ACE ) - sizeof( ULONG ));

                    //
                    // Allocate the Acl out of the local process heap
                    //

                    *pAcl = (PACL)RtlAllocateHeap( RtlProcessHeap(), 0, AclSize );

                    if (*pAcl != NULL) {

                        RtlCreateAcl( *pAcl, AclSize, ACL_REVISION );

                        //
                        // Create each SID in turn and copy the resultant ACE into
                        // the new ACL
                        //

                        //
                        // Local System - Generic All
                        //

                        RtlInitializeSid( SidBuffer, &NtAuthority, 1);
                        *(RtlSubAuthoritySid( SidBuffer, 0 )) = SECURITY_LOCAL_SYSTEM_RID;
                        RtlAddAccessAllowedAce( *pAcl, ACL_REVISION, GENERIC_ALL, (PSID)SidBuffer );

                        //
                        // Admins - Generic All
                        //

                        RtlInitializeSid( SidBuffer, &NtAuthority, 2);
                        *(RtlSubAuthoritySid( SidBuffer, 0 )) = SECURITY_BUILTIN_DOMAIN_RID;
                        *(RtlSubAuthoritySid( SidBuffer, 1 )) = DOMAIN_ALIAS_RID_ADMINS;
                        RtlAddAccessAllowedAce( *pAcl, ACL_REVISION, GENERIC_ALL, (PSID)SidBuffer );

                        //
                        // Owner - Generic All
                        //

                        RtlAddAccessAllowedAce( *pAcl, ACL_REVISION, GENERIC_ALL, OwnerSid->Owner );

                        //
                        // World - Generic Read
                        //

                        RtlInitializeSid( SidBuffer, &WorldSidAuthority, 1 );
                        *(RtlSubAuthoritySid( SidBuffer, 0 )) = SECURITY_WORLD_RID;
                        RtlAddAccessAllowedAce( *pAcl, ACL_REVISION, GENERIC_READ, (PSID)SidBuffer );

                        //
                        // Anonymous Logon - Generic Read
                        //

                        RtlInitializeSid( SidBuffer, &NtAuthority, 1);
                        *(RtlSubAuthoritySid( SidBuffer, 0 )) = SECURITY_ANONYMOUS_LOGON_RID;
                        RtlAddAccessAllowedAce( *pAcl, ACL_REVISION, GENERIC_READ, (PSID)SidBuffer );

                    } else {

                        Status = STATUS_NO_MEMORY;
                    }
                }

                RtlFreeHeap( RtlProcessHeap(), 0, OwnerSid );

            } else {

                Status = STATUS_NO_MEMORY;
            }
        }

        NtClose( hToken );
    }

    if (!NT_SUCCESS( Status )) {

        //
        // Something failed, clean up OUT
        // parameters.
        //

        if (*pAcl != NULL) {
            RtlFreeHeap( RtlProcessHeap(), 0, *pAcl );
            *pAcl = NULL;
        }
    }

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\propset.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1993-1998
//
// File:	propset.h
//
// Contents:	OLE Appendix B property set structure definitions
//
// History:	15-Jul-94       brianb    created
//		15-Aug-94       SethuR    revised
//              22-Feb-96       MikeHill  Changed cb in tagENTRY to cch.
//              28-May-96       MikeHill  Changed OSVER_* to OSKIND_*.
//
//---------------------------------------------------------------------------

#ifndef _PROPSET_H_
#define _PROPSET_H_

// CBMAXPROPSETSTREAM must be a power of 2.
#define CBMAXPROPSETSTREAM	(256 * 1024)

#define IsIndirectVarType(vt)			\
	    ((vt) == VT_STREAM ||		\
	     (vt) == VT_STREAMED_OBJECT ||	\
	     (vt) == VT_STORAGE ||		\
	     (vt) == VT_STORED_OBJECT)


// Defines for the high order WORD of dwOSVer:

#define OSKIND_WINDOWS      0x0000
#define OSKIND_MACINTOSH    0x0001
#define OSKIND_WIN32        0x0002


typedef struct tagFORMATIDOFFSET	// fo
{
    FMTID	fmtid;
    DWORD	dwOffset;
} FORMATIDOFFSET;

#define CB_FORMATIDOFFSET	sizeof(FORMATIDOFFSET)


typedef struct tagPROPERTYSETHEADER	// ph
{
    WORD        wByteOrder;	// Always 0xfffe
    WORD        wFormat;	// Always 0
    DWORD       dwOSVer;	// System version
    CLSID       clsid;		// Application CLSID
    DWORD       reserved;	// reserved (must be at least 1)
} PROPERTYSETHEADER;

#define CB_PROPERTYSETHEADER	sizeof(PROPERTYSETHEADER)
#define PROPSET_BYTEORDER       0xFFFE


typedef struct tagPROPERTYIDOFFSET	// po
{
    DWORD       propid;
    DWORD       dwOffset;
} PROPERTYIDOFFSET;

#define CB_PROPERTYIDOFFSET	sizeof(PROPERTYIDOFFSET)


typedef struct tagPROPERTYSECTIONHEADER	// sh
{
    DWORD       cbSection;
    DWORD       cProperties;
    PROPERTYIDOFFSET rgprop[1];
} PROPERTYSECTIONHEADER;

#define CB_PROPERTYSECTIONHEADER FIELD_OFFSET(PROPERTYSECTIONHEADER, rgprop)


typedef struct tagSERIALIZEDPROPERTYVALUE		// prop
{
    DWORD	dwType;
    BYTE	rgb[1];
} SERIALIZEDPROPERTYVALUE;

#define CB_SERIALIZEDPROPERTYVALUE  FIELD_OFFSET(SERIALIZEDPROPERTYVALUE, rgb)


typedef struct tagENTRY			// ent
{
    DWORD propid;
    DWORD cch;			// Includes trailing '\0' or L'\0'
    char  sz[1];		// WCHAR if UNICODE CodePage
} ENTRY;

#define CB_ENTRY		FIELD_OFFSET(ENTRY, sz)


typedef struct tagDICTIONARY		// dy
{
    DWORD	cEntries;
    ENTRY	rgEntry[1];
} DICTIONARY;

#define CB_DICTIONARY		FIELD_OFFSET(DICTIONARY, rgEntry)

#endif // _PROPSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\propfwd.cxx ===
//+============================================================================
//
//  PropFwd.c
//
//  This file provides (slow) forwarders of the NT4 property APIs
//  from NTDLL to OLE32.  At one time, these APIs were used in both
//  kernel mode and user mode.  They're now only used in user mode,
//  so all the property code has been cosolidated into ole32.  Older
//  copies of Index Server (CI), however, still link to NTDLL, thus
//  the need for these forwarders.
//
//+============================================================================

#include <pch.cxx>
//#include "propvar.h"
//#include "propstm.hxx"

//+----------------------------------------------------------------------------
//
//  Function:   LoadOle32Export
//
//  Synopsis:   Load ole32.dll and get one of its exports.
//              Raises on error.
//
//+----------------------------------------------------------------------------

PVOID
LoadOle32Export( PVOID* Ole32, const PCHAR ProcedureName )
{
    NTSTATUS Status;
    UNICODE_STRING Ole32DllName_U;
    STRING ProcedureNameString;
    PVOID ProcedureAddress = NULL;

    RtlInitUnicodeString( &Ole32DllName_U, L"ole32.dll" );
    Status = LdrLoadDll( NULL, NULL, &Ole32DllName_U, Ole32 );
    if( !NT_SUCCESS(Status) )
        RtlRaiseStatus( Status );

    RtlInitString( &ProcedureNameString, ProcedureName );
    Status = LdrGetProcedureAddress(
                    *Ole32,
                    &ProcedureNameString,
                    0,
                    (PVOID*) &ProcedureAddress
                    );
    if( !NT_SUCCESS(Status) )
        RtlRaiseStatus(Status);

    return( ProcedureAddress );
}



//+----------------------------------------------------------------------------
//
//  Function:   RtlConvertVariantToProperty
//
//  Synopsis:   Serialize a variant.
//
//+----------------------------------------------------------------------------

typedef SERIALIZEDPROPERTYVALUE* (*PFNStgConvertVariantToProperty) (
                                        IN PROPVARIANT const *pvar,
                                        IN USHORT CodePage,
                                        OUT SERIALIZEDPROPERTYVALUE *pprop,
                                        IN OUT ULONG *pcb,
                                        IN PROPID pid,
                                        IN BOOLEAN fVariantVector,
                                        OPTIONAL OUT ULONG *pcIndirect);


SERIALIZEDPROPERTYVALUE * PROPSYSAPI PROPAPI
RtlConvertVariantToProperty(
    IN PROPVARIANT const *pvar,
    IN USHORT CodePage,
    OPTIONAL OUT SERIALIZEDPROPERTYVALUE *pprop,
    IN OUT ULONG *pcb,
    IN PROPID pid,
    IN BOOLEAN fVariantVector,
    OPTIONAL OUT ULONG *pcIndirect)
{
    NTSTATUS Status;
    PVOID Ole32 = NULL;
    PFNStgConvertVariantToProperty ProcedureAddress;
    SERIALIZEDPROPERTYVALUE *ppropRet;

    __try
    {
        ProcedureAddress = (PFNStgConvertVariantToProperty)
                           LoadOle32Export( &Ole32, "StgConvertVariantToProperty" );

        ppropRet = ProcedureAddress( pvar,
                                     CodePage,
                                     pprop,
                                     pcb,
                                     pid,
                                     fVariantVector,
                                     pcIndirect );  // Raises on error
    }
    __finally
    {
        if( NULL != Ole32 )
            LdrUnloadDll( Ole32 );
    }

    return (ppropRet );

}




//+----------------------------------------------------------------------------
//
//  Function:   RtlConvertPropertyToVariant
//
//  Synopsis:   De-serialize a variant.
//
//+----------------------------------------------------------------------------

typedef BOOLEAN (* PFNStgConvertPropertyToVariant) (
    IN SERIALIZEDPROPERTYVALUE const *pprop,
    IN USHORT CodePage,
    OUT PROPVARIANT *pvar,
    IN PMemoryAllocator *pma);

BOOLEAN PROPSYSAPI PROPAPI
RtlConvertPropertyToVariant(
    IN SERIALIZEDPROPERTYVALUE const *pprop,
    IN USHORT CodePage,
    OUT PROPVARIANT *pvar,
    IN PMemoryAllocator *pma)
{
    BOOLEAN Ret;
    NTSTATUS Status;
    PVOID Ole32 = NULL;
    STRING ProcedureName;
    PFNStgConvertPropertyToVariant ProcedureAddress;

    __try
    {
        ProcedureAddress = (PFNStgConvertPropertyToVariant)
                           LoadOle32Export( &Ole32, "StgConvertPropertyToVariant" );
    
        Ret = ProcedureAddress( pprop, CodePage, pvar, pma );  // Raises on error
    }
    __finally
    {
        if( NULL != Ole32 )
            LdrUnloadDll( Ole32 );
    }

    return (Ret);

}




//+----------------------------------------------------------------------------
//
//  Function:   PropertyLengthAsVariant
//
//  Synopsis:   Returns the amount of external memory will need to be
//              allocated for this variant when RtlPropertyToVariant is called.
//
//+----------------------------------------------------------------------------

typedef ULONG (*PFNStgPropertyLengthAsVariant)(
        IN SERIALIZEDPROPERTYVALUE const *pprop,
        IN ULONG cbprop,
        IN USHORT CodePage,
        IN BYTE flags);

ULONG PROPSYSAPI PROPAPI
PropertyLengthAsVariant(
    IN SERIALIZEDPROPERTYVALUE const *pprop,
    IN ULONG cbprop,
    IN USHORT CodePage,
    IN BYTE flags)
{
    NTSTATUS Status;
    ULONG Length;
    PVOID Ole32 = NULL;
    STRING ProcedureName;
    PFNStgPropertyLengthAsVariant ProcedureAddress;

    __try
    {
        ProcedureAddress = (PFNStgPropertyLengthAsVariant)
                           LoadOle32Export( &Ole32, "StgPropertyLengthAsVariant" );

        Length = ProcedureAddress( pprop, cbprop, CodePage, flags );  // Raises on error
    }
    __finally
    {
        if( NULL != Ole32 )
            LdrUnloadDll( Ole32 );
    }

    return( Length);
}

//+---------------------------------------------------------------------------
//
//  Function:   RtlSetUnicodeCallouts, public
//
//  Synopsis:   Set the Unicode conversion function pointers, used by
//              RtlConvertVarianttoProperty, RtlConvertPropertyToVariant,
//              and PropertyLengthAsVariant.
//
//              These functions are no longer settable (they're defaulted by
//              ole32).
//
//---------------------------------------------------------------------------

VOID PROPSYSAPI PROPAPI
RtlSetUnicodeCallouts(
    IN UNICODECALLOUTS *pUnicodeCallouts)
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\query.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    query.c

Abstract:

    This module contains the RtlQueryProcessInformation function

Author:

    Steve Wood (stevewo) 01-Apr-1994

Revision History:

--*/

#include <ntos.h>
#include "ldrp.h"
#include <stktrace.h>
#include <heap.h>
#include <stdio.h>

#define AdjustPointer( t, p, d ) (p); if ((p) != NULL) (p) = (t)((ULONG_PTR)(p) + (d))

NTSYSAPI
NTSTATUS
NTAPI
RtlpQueryProcessDebugInformationRemote(
    IN OUT PRTL_DEBUG_INFORMATION Buffer
    )
{
    NTSTATUS Status;
    ULONG i;
    ULONG_PTR Delta;
    PRTL_PROCESS_HEAPS Heaps;
    PRTL_HEAP_INFORMATION HeapInfo;

    if (Buffer->EventPairTarget != NULL) {
        Status = NtWaitLowEventPair( Buffer->EventPairTarget );
        }
    else {
        Status = STATUS_SUCCESS;
        }

    while (NT_SUCCESS( Status )) {
        Status = RtlQueryProcessDebugInformation( NtCurrentTeb()->ClientId.UniqueProcess,
                                                  Buffer->Flags,
                                                  Buffer
                                                );
        if (NT_SUCCESS( Status )) {
            if (Delta = Buffer->ViewBaseDelta) {
                //
                // Need to relocate buffer pointers back to client addresses
                //
                AdjustPointer( PRTL_PROCESS_MODULES, Buffer->Modules, Delta );
                AdjustPointer( PRTL_PROCESS_BACKTRACES, Buffer->BackTraces, Delta );
                Heaps = AdjustPointer( PRTL_PROCESS_HEAPS, Buffer->Heaps, Delta );
                if (Heaps != NULL) {
                    for (i=0; i<Heaps->NumberOfHeaps; i++) {
                        HeapInfo = &Heaps->Heaps[ i ];
                        AdjustPointer( PRTL_HEAP_TAG, HeapInfo->Tags, Delta );
                        AdjustPointer( PRTL_HEAP_ENTRY, HeapInfo->Entries, Delta );
                        }
                    }

                AdjustPointer( PRTL_PROCESS_LOCKS, Buffer->Locks, Delta );
                }
            }

        if (Buffer->EventPairTarget == NULL) {
            //
            // If no event pair handle, then exit loop and terminate
            //
            break;
            }

        Status = NtSetHighWaitLowEventPair( Buffer->EventPairTarget );
        if (Buffer->EventPairTarget == NULL) {
            break;
            }
        }

    //
    // All done with buffer, remove from our address space
    // then terminate ourselves so client wakes up.
    //

    NtUnmapViewOfSection( NtCurrentProcess(), Buffer );
    RtlExitUserThread (Status);
    return Status;
}


NTSTATUS
RtlpChangeQueryDebugBufferTarget(
    IN PRTL_DEBUG_INFORMATION Buffer,
    IN HANDLE TargetProcessId,
    OUT PHANDLE ReturnedTargetProcessHandle
    )
{
    NTSTATUS Status;
    CLIENT_ID OldTargetClientId, NewTargetClientId;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE OldTargetProcess, NewTargetProcess, NewHandle;
    PHANDLE pOldHandle;
    ULONG DuplicateHandleFlags;

    if (Buffer->EventPairClient != NULL &&
        Buffer->TargetProcessId == TargetProcessId
       ) {
        return STATUS_SUCCESS;
        }

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0,
                                NULL,
                                NULL
                              );

    DuplicateHandleFlags = DUPLICATE_CLOSE_SOURCE |
                           DUPLICATE_SAME_ACCESS |
                           DUPLICATE_SAME_ATTRIBUTES;

    if (Buffer->EventPairClient != NULL) {
        pOldHandle = &Buffer->EventPairTarget;
        }
    else {
        pOldHandle = NULL;
        }

    if (Buffer->TargetProcessId != NULL) {
        OldTargetClientId.UniqueProcess = Buffer->TargetProcessId;
        OldTargetClientId.UniqueThread = 0;
        Status = NtOpenProcess( &OldTargetProcess,
                                PROCESS_ALL_ACCESS,
                                &ObjectAttributes,
                                &OldTargetClientId
                              );
        if (!NT_SUCCESS( Status )) {
            return Status;
            }
        }
    else {
        OldTargetProcess = NtCurrentProcess();
        DuplicateHandleFlags &= ~DUPLICATE_CLOSE_SOURCE;
        if (pOldHandle != NULL) {
            pOldHandle = &Buffer->EventPairClient;
            }
        }

    if (ARGUMENT_PRESENT( TargetProcessId )) {
        NewTargetClientId.UniqueProcess = TargetProcessId;
        NewTargetClientId.UniqueThread = 0;
        Status = NtOpenProcess( &NewTargetProcess,
                                PROCESS_ALL_ACCESS,
                                &ObjectAttributes,
                                &NewTargetClientId
                              );
        if (!NT_SUCCESS( Status )) {
            if (OldTargetProcess != NtCurrentProcess()) {
                NtClose( OldTargetProcess );
                }
            return Status;
            }
        }
    else {
        NewTargetProcess = NULL;
        }

    NewHandle = NULL;
    if (pOldHandle != NULL) {
        Status = NtDuplicateObject( OldTargetProcess,
                                    *pOldHandle,
                                    NewTargetProcess,
                                    &NewHandle,
                                    0,
                                    0,
                                    DuplicateHandleFlags
                                  );
        if (!NT_SUCCESS( Status )) {
            if (OldTargetProcess != NtCurrentProcess()) {
                NtClose( OldTargetProcess );
                }
            if (NewTargetProcess != NULL) {
                NtClose( NewTargetProcess );
                }
            return Status;
            }
        }

    if (OldTargetProcess != NtCurrentProcess()) {
        NtUnmapViewOfSection( OldTargetProcess, Buffer->ViewBaseTarget );
        }
    else {
        Buffer->ViewBaseTarget = Buffer->ViewBaseClient;
        }

    if (NewTargetProcess != NULL) {
        Status = NtMapViewOfSection( Buffer->SectionHandleClient,
                                     NewTargetProcess,
                                     &Buffer->ViewBaseTarget,
                                     0,
                                     0,
                                     NULL,
                                     &Buffer->ViewSize,
                                     ViewUnmap,
                                     0,
                                     PAGE_READWRITE
                                   );
        if (Status == STATUS_CONFLICTING_ADDRESSES) {
            Buffer->ViewBaseTarget = NULL;
            Status = NtMapViewOfSection( Buffer->SectionHandleClient,
                                         NewTargetProcess,
                                         &Buffer->ViewBaseTarget,
                                         0,
                                         0,
                                         NULL,
                                         &Buffer->ViewSize,
                                         ViewUnmap,
                                         0,
                                         PAGE_READWRITE
                                       );
            }

        if (!NT_SUCCESS( Status )) {
            if (NewHandle != NULL) {
                NtDuplicateObject( NewTargetProcess,
                                   &NewHandle,
                                   NULL,
                                   NULL,
                                   0,
                                   0,
                                   DUPLICATE_CLOSE_SOURCE
                                 );
                }

            return Status;
            }

        if (ARGUMENT_PRESENT( ReturnedTargetProcessHandle )) {
            *ReturnedTargetProcessHandle = NewTargetProcess;
            }
        else {
            NtClose( NewTargetProcess );
            }
        }

    Buffer->EventPairTarget = NewHandle;
    Buffer->ViewBaseDelta = (ULONG_PTR)Buffer->ViewBaseClient - (ULONG_PTR)Buffer->ViewBaseTarget;
    return STATUS_SUCCESS;
}


PVOID
RtlpCommitQueryDebugInfo(
    IN PRTL_DEBUG_INFORMATION Buffer,
    IN ULONG Size
    )
{
    NTSTATUS Status;
    PVOID Result;
    PVOID CommitBase;
    SIZE_T CommitSize;
    SIZE_T NeededSize;

    Size = (Size + 3) & ~3;
    NeededSize = Buffer->OffsetFree + Size;
    if (NeededSize > Buffer->CommitSize) {
        if (NeededSize >= Buffer->ViewSize) {
            return NULL;
            }

        CommitBase = (PCHAR)Buffer + Buffer->CommitSize;
        CommitSize =  NeededSize - Buffer->CommitSize;
        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &CommitBase,
                                          0,
                                          &CommitSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                        );
        if (!NT_SUCCESS( Status )) {
            return NULL;
            }


        Buffer->CommitSize += CommitSize;
        }

    Result = (PCHAR)Buffer + Buffer->OffsetFree;
    Buffer->OffsetFree = NeededSize;
    return Result;
}

VOID
RtlpDeCommitQueryDebugInfo(
    IN PRTL_DEBUG_INFORMATION Buffer,
    IN PVOID p,
    IN ULONG Size
    )
{
    Size = (Size + 3) & ~3;
    if (p == (PVOID)(Buffer->OffsetFree - Size)) {
        Buffer->OffsetFree -= Size;
        }
}

NTSYSAPI
PRTL_DEBUG_INFORMATION
NTAPI
RtlCreateQueryDebugBuffer(
    IN ULONG MaximumCommit OPTIONAL,
    IN BOOLEAN UseEventPair
    )
{
    NTSTATUS Status;
    HANDLE Section;
    PRTL_DEBUG_INFORMATION Buffer;
    LARGE_INTEGER MaximumSize;
    ULONG_PTR ViewSize, CommitSize;

    if (!ARGUMENT_PRESENT( (PVOID)(ULONG_PTR)MaximumCommit )) { // Sundown Note: ULONG zero-extended.
        MaximumCommit = 4 * 1024 * 1024;
        }
    MaximumSize.QuadPart = MaximumCommit;
    Status = NtCreateSection( &Section,
                              SECTION_ALL_ACCESS,
                              NULL,
                              &MaximumSize,
                              PAGE_READWRITE,
                              SEC_RESERVE,
                              NULL
                            );
    if (!NT_SUCCESS( Status )) {
        return NULL;
        }

    Buffer = NULL;
    ViewSize = MaximumCommit;
    Status = NtMapViewOfSection( Section,
                                 NtCurrentProcess(),
                                 &Buffer,
                                 0,
                                 0,
                                 NULL,
                                 &ViewSize,
                                 ViewUnmap,
                                 0,
                                 PAGE_READWRITE
                               );
    if (!NT_SUCCESS( Status )) {
        NtClose( Section );
        return NULL;
        }

    CommitSize = 1;
    Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                      &Buffer,
                                      0,
                                      &CommitSize,
                                      MEM_COMMIT,
                                      PAGE_READWRITE
                                    );
    if (!NT_SUCCESS( Status )) {
        NtUnmapViewOfSection( NtCurrentProcess(), Buffer );
        NtClose( Section );
        return NULL;
        }

    if (UseEventPair) {
        Status = NtCreateEventPair( &Buffer->EventPairClient,
                                    EVENT_PAIR_ALL_ACCESS,
                                    NULL
                                  );
        if (!NT_SUCCESS( Status )) {
            NtUnmapViewOfSection( NtCurrentProcess(), Buffer );
            NtClose( Section );
            return NULL;
            }
        }

    Buffer->SectionHandleClient = Section;
    Buffer->ViewBaseClient = Buffer;
    Buffer->OffsetFree = 0;
    Buffer->CommitSize = CommitSize;
    Buffer->ViewSize = ViewSize;
    return Buffer;
}


NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyQueryDebugBuffer(
    IN PRTL_DEBUG_INFORMATION Buffer
    )
{
    NTSTATUS Status;
    HANDLE ProcessHandle, ThreadHandle;
    THREAD_BASIC_INFORMATION BasicInformation;
    SIZE_T BigSize;

    RtlpChangeQueryDebugBufferTarget( Buffer, NULL, NULL );

    Status = STATUS_SUCCESS;
    if (Buffer->TargetThreadHandle != NULL) {

        Buffer->EventPairTarget = NULL;
        NtSetLowEventPair( Buffer->EventPairClient );
        NtClose( Buffer->EventPairClient );
        Status = NtWaitForSingleObject( Buffer->TargetThreadHandle,
                                        TRUE,
                                        NULL
                                      );
        if (NT_SUCCESS( Status )) {
            Status = NtQueryInformationThread( Buffer->TargetThreadHandle,
                                               ThreadBasicInformation,
                                               &BasicInformation,
                                               sizeof( BasicInformation ),
                                               NULL
                                             );
            if (NT_SUCCESS( Status )) {
                Status = BasicInformation.ExitStatus;
                }
            }

        }

    NtClose( Buffer->SectionHandleClient );
    NtUnmapViewOfSection( NtCurrentProcess(), Buffer );
    return Status;
}


NTSYSAPI
NTSTATUS
NTAPI
RtlQueryProcessDebugInformation(
    IN HANDLE UniqueProcessId,
    IN ULONG Flags,
    IN OUT PRTL_DEBUG_INFORMATION Buffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE ProcessHandle, ThreadHandle;
    THREAD_BASIC_INFORMATION BasicInformation;

    HANDLE hNiProcess = NULL;

    Buffer->Flags = Flags;
    if (Buffer->OffsetFree != 0) {
        RtlZeroMemory( (Buffer+1), Buffer->OffsetFree - (SIZE_T)sizeof(*Buffer) );
    }
    Buffer->OffsetFree = sizeof( *Buffer );

    //
    // Get process handle for noninvasive query if required
    //
    if ( (NtCurrentTeb()->ClientId.UniqueProcess != UniqueProcessId) &&
         (Flags & RTL_QUERY_PROCESS_NONINVASIVE) &&
         (Flags & ( RTL_QUERY_PROCESS_MODULES | 
                    RTL_QUERY_PROCESS_MODULES32
                  )
         ) &&
         !(Flags & ~( RTL_QUERY_PROCESS_MODULES | 
                      RTL_QUERY_PROCESS_MODULES32 | 
                      RTL_QUERY_PROCESS_NONINVASIVE
                    )
          )
       ) {
            OBJECT_ATTRIBUTES ObjectAttributes;
            CLIENT_ID NiProcessId;

            InitializeObjectAttributes( &ObjectAttributes,
                                        NULL,
                                        0,
                                        NULL,
                                        NULL
                                      );
            NiProcessId.UniqueProcess = UniqueProcessId;
            NiProcessId.UniqueThread = 0;

            if (!NT_SUCCESS( NtOpenProcess( &hNiProcess,
                                            PROCESS_ALL_ACCESS,
                                            &ObjectAttributes,
                                            &NiProcessId
                                          )
                            )
               ) {
                hNiProcess = NULL;
            }
    }


    if ( (NtCurrentTeb()->ClientId.UniqueProcess != UniqueProcessId) &&
         !hNiProcess
       ) {
        //
        //  Perform remote query
        //
        ProcessHandle = NULL;
        Status = RtlpChangeQueryDebugBufferTarget( Buffer, UniqueProcessId, &ProcessHandle );
        if (!NT_SUCCESS( Status )) {
            return Status;
        }

        if (ProcessHandle == NULL) {
waitForDump:
            Status = NtSetLowWaitHighEventPair( Buffer->EventPairClient );
        } else {
            //
            // don't let the debugger see this remote thread !
            // This is a very ugly but effective way to prevent
            // the debugger deadlocking with the target process when calling
            // this function.
            //

            Status = RtlCreateUserThread( ProcessHandle,
                                          NULL,
                                          TRUE,
                                          0,
                                          0,
                                          0,
                                          RtlpQueryProcessDebugInformationRemote,
                                          Buffer->ViewBaseTarget,
                                          &ThreadHandle,
                                          NULL
                                        );
            if (NT_SUCCESS( Status )) {

                Status = NtSetInformationThread( ThreadHandle,
                                                 ThreadHideFromDebugger,
                                                 NULL,
                                                 0
                                               );

                if ( !NT_SUCCESS(Status) ) {
                    NtTerminateThread(ThreadHandle,Status);
                    NtClose(ThreadHandle);
                    NtClose(ProcessHandle);
                    return Status;
                }

                NtResumeThread(ThreadHandle,NULL);

                if (Buffer->EventPairClient != NULL) {
                    Buffer->TargetThreadHandle = ThreadHandle;
                    Buffer->TargetProcessHandle = ProcessHandle;
                    goto waitForDump;
                }


                Status = NtWaitForSingleObject( ThreadHandle,
                                                TRUE,
                                                NULL
                                              );

                if (NT_SUCCESS( Status )) {
                    Status = NtQueryInformationThread( ThreadHandle,
                                                       ThreadBasicInformation,
                                                       &BasicInformation,
                                                       sizeof( BasicInformation ),
                                                       NULL
                                                     );
                    if (NT_SUCCESS( Status )) {
                        Status = BasicInformation.ExitStatus;
                    }
                    if (NT_SUCCESS (Status) &&
                        (Flags&(RTL_QUERY_PROCESS_MODULES|RTL_QUERY_PROCESS_MODULES32)) != 0 &&
                        Buffer->Modules == NULL) {
                        Status = STATUS_PROCESS_IS_TERMINATING;
                    }
                }

                NtClose( ThreadHandle );

            }


            NtClose( ProcessHandle );
        }
    } else {
        if (Flags & (RTL_QUERY_PROCESS_MODULES | RTL_QUERY_PROCESS_MODULES32)) {
            Status = RtlQueryProcessModuleInformation( hNiProcess, Flags, Buffer );
            if (Status != STATUS_SUCCESS) {
                goto closeNiProcessAndBreak;
            }
        }

        if (Flags & RTL_QUERY_PROCESS_BACKTRACES) {
            Status = RtlQueryProcessBackTraceInformation( Buffer );
            if (Status != STATUS_SUCCESS) {
                goto closeNiProcessAndBreak;
            }
        }

        if (Flags & RTL_QUERY_PROCESS_LOCKS) {
            Status = RtlQueryProcessLockInformation( Buffer );
            if (Status != STATUS_SUCCESS) {
                goto closeNiProcessAndBreak;
            }
        }

        if (Flags & (RTL_QUERY_PROCESS_HEAP_SUMMARY |
                     RTL_QUERY_PROCESS_HEAP_TAGS |
                     RTL_QUERY_PROCESS_HEAP_ENTRIES
                    )
           ) {
            Status = RtlQueryProcessHeapInformation( Buffer );
            if (Status != STATUS_SUCCESS) {
                goto closeNiProcessAndBreak;
            }
        }

        closeNiProcessAndBreak:
            if ( hNiProcess ) {
                NtClose( hNiProcess );
            }
    }

    return Status;
}

NTSTATUS
LdrQueryProcessModuleInformationEx(
    IN HANDLE hProcess OPTIONAL,
    IN ULONG_PTR Flags OPTIONAL,
    OUT PRTL_PROCESS_MODULES ModuleInformation,
    IN ULONG ModuleInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );


NTSTATUS
NTAPI
RtlQueryProcessModuleInformation
(
    IN HANDLE hProcess OPTIONAL, 
    IN ULONG Flags,
    IN OUT PRTL_DEBUG_INFORMATION Buffer
    )
{
    NTSTATUS Status;
    ULONG RequiredLength;
    PRTL_PROCESS_MODULES Modules;
    ULONG LdrFlags = (Flags & RTL_QUERY_PROCESS_MODULES32) != 0;

    Status = LdrQueryProcessModuleInformationEx( hProcess,
                                                 LdrFlags,  
                                                 NULL,
                                                 0,
                                                 &RequiredLength
                                               );
    if (Status == STATUS_INFO_LENGTH_MISMATCH) {
        Modules = RtlpCommitQueryDebugInfo( Buffer, RequiredLength );
        if (Modules != NULL) {
            Status = LdrQueryProcessModuleInformationEx( hProcess, 
                                                         LdrFlags,
                                                         Modules,
                                                         RequiredLength,
                                                         &RequiredLength
                                                       );
            if (NT_SUCCESS( Status )) {
                Buffer->Modules = Modules;
                return STATUS_SUCCESS;
                }
            }
        }

    return STATUS_NO_MEMORY;
}

NTSTATUS
RtlQueryProcessBackTraceInformation(
    IN OUT PRTL_DEBUG_INFORMATION Buffer
    )
{
#if i386
    NTSTATUS Status;
    OUT PRTL_PROCESS_BACKTRACES BackTraces;
    PRTL_PROCESS_BACKTRACE_INFORMATION BackTraceInfo;
    PSTACK_TRACE_DATABASE DataBase;
    PRTL_STACK_TRACE_ENTRY p, *pp;
    ULONG n;

    DataBase = RtlpAcquireStackTraceDataBase();
    if (DataBase == NULL) {
        return STATUS_SUCCESS;
        }

    BackTraces = RtlpCommitQueryDebugInfo( Buffer, FIELD_OFFSET( RTL_PROCESS_BACKTRACES, BackTraces ) );
    if (BackTraces == NULL) {
        return STATUS_NO_MEMORY;
        }

    DataBase->DumpInProgress = TRUE;
    RtlpReleaseStackTraceDataBase();
    try {
        BackTraces->CommittedMemory = (ULONG)DataBase->CurrentUpperCommitLimit -
                                      (ULONG)DataBase->CommitBase;
        BackTraces->ReservedMemory =  (ULONG)DataBase->EntryIndexArray -
                                      (ULONG)DataBase->CommitBase;
        BackTraces->NumberOfBackTraceLookups = DataBase->NumberOfEntriesLookedUp;
        BackTraces->NumberOfBackTraces = DataBase->NumberOfEntriesAdded;
        BackTraceInfo = RtlpCommitQueryDebugInfo( Buffer, (sizeof( *BackTraceInfo ) * BackTraces->NumberOfBackTraces) );
        if (BackTraceInfo == NULL) {
            Status = STATUS_NO_MEMORY;
            }
        else {
            Status = STATUS_SUCCESS;
            n = DataBase->NumberOfEntriesAdded;
            pp = DataBase->EntryIndexArray;
            while (n--) {
                p = *--pp;
                BackTraceInfo->SymbolicBackTrace = NULL;
                BackTraceInfo->TraceCount = p->TraceCount;
                BackTraceInfo->Index = p->Index;
                BackTraceInfo->Depth = p->Depth;
                RtlMoveMemory( BackTraceInfo->BackTrace,
                               p->BackTrace,
                               p->Depth * sizeof( PVOID )
                             );
                BackTraceInfo++;
                }
            }
        }
    finally {
        DataBase->DumpInProgress = FALSE;
        }

    if (NT_SUCCESS( Status )) {
        Buffer->BackTraces = BackTraces;
        }

    return Status;
#else
    return STATUS_SUCCESS;
#endif // i386
}


NTSTATUS
RtlpQueryProcessEnumHeapsRoutine(
    PVOID HeapHandle,
    PVOID Parameter
    )
{
    PRTL_DEBUG_INFORMATION Buffer = (PRTL_DEBUG_INFORMATION)Parameter;
    PRTL_PROCESS_HEAPS Heaps = Buffer->Heaps;
    PHEAP Heap = (PHEAP)HeapHandle;
    PRTL_HEAP_INFORMATION HeapInfo;
    PHEAP_SEGMENT Segment;
    UCHAR SegmentIndex;

    HeapInfo = RtlpCommitQueryDebugInfo( Buffer, sizeof( *HeapInfo ) );
    if (HeapInfo == NULL) {
        return STATUS_NO_MEMORY;
        }

    HeapInfo->BaseAddress = Heap;
    HeapInfo->Flags = Heap->Flags;
    HeapInfo->EntryOverhead = sizeof( HEAP_ENTRY );
    HeapInfo->CreatorBackTraceIndex = Heap->AllocatorBackTraceIndex;
    SegmentIndex = HEAP_MAXIMUM_SEGMENTS;
    while (SegmentIndex--) {
        Segment = Heap->Segments[ SegmentIndex ];
        if (Segment) {
            HeapInfo->BytesCommitted += (Segment->NumberOfPages -
                                         Segment->NumberOfUnCommittedPages
                                        ) * PAGE_SIZE;

            }
        }
    HeapInfo->BytesAllocated = HeapInfo->BytesCommitted -
                               (Heap->TotalFreeSize << HEAP_GRANULARITY_SHIFT);
    Heaps->NumberOfHeaps += 1;
    return STATUS_SUCCESS;
}

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryProcessHeapInformation(
    IN OUT PRTL_DEBUG_INFORMATION Buffer
    )
{
    NTSTATUS Status;
    PHEAP Heap;
    BOOLEAN LockAcquired;
    PRTL_PROCESS_HEAPS Heaps;
    PRTL_HEAP_INFORMATION HeapInfo;
    ULONG NumberOfHeaps;
    PVOID *ProcessHeaps;
    UCHAR SegmentIndex;
    ULONG i, n, TagIndex;
    PHEAP_SEGMENT Segment;
    PRTL_HEAP_TAG Tags;
    PHEAP_PSEUDO_TAG_ENTRY PseudoTags;
    PRTL_HEAP_ENTRY Entries;
    PHEAP_ENTRY CurrentBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    PRTL_HEAP_ENTRY p;
    PLIST_ENTRY Head, Next;
    PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;
    ULONG Size;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange;

    Heaps = RtlpCommitQueryDebugInfo( Buffer, FIELD_OFFSET( RTL_PROCESS_HEAPS, Heaps ) );
    if (Heaps == NULL) {
        return STATUS_NO_MEMORY;
        }

    Buffer->Heaps = Heaps;
    Status = RtlEnumProcessHeaps( RtlpQueryProcessEnumHeapsRoutine, Buffer );
    if (NT_SUCCESS( Status )) {
        if (Buffer->Flags & RTL_QUERY_PROCESS_HEAP_TAGS) {
            Heap = RtlpGlobalTagHeap;
            if (Heap->TagEntries != NULL) {
                HeapInfo = RtlpCommitQueryDebugInfo( Buffer, sizeof( *HeapInfo ) );
                if (HeapInfo == NULL) {
                    return STATUS_NO_MEMORY;
                    }

                HeapInfo->BaseAddress = Heap;
                HeapInfo->Flags = Heap->Flags;
                HeapInfo->EntryOverhead = sizeof( HEAP_ENTRY );
                Heaps->NumberOfHeaps += 1;
                }

            for (i=0; i<Heaps->NumberOfHeaps; i++) {
                HeapInfo = &Heaps->Heaps[ i ];
                if (Buffer->SpecificHeap == NULL ||
                    Buffer->SpecificHeap == HeapInfo->BaseAddress
                   ) {
                    Heap = HeapInfo->BaseAddress;
                    HeapInfo->NumberOfTags = Heap->NextAvailableTagIndex;
                    n = HeapInfo->NumberOfTags * sizeof( RTL_HEAP_TAG );
                    if (Heap->PseudoTagEntries != NULL) {
                        HeapInfo->NumberOfTags += HEAP_MAXIMUM_FREELISTS + 1;
                        n += (HEAP_MAXIMUM_FREELISTS + 1) * sizeof( RTL_HEAP_TAG );
                        }
                    Tags = RtlpCommitQueryDebugInfo( Buffer, n );
                    if (Tags == NULL) {
                        Status = STATUS_NO_MEMORY;
                        break;
                        }
                    HeapInfo->Tags = Tags;
                    if ((PseudoTags = Heap->PseudoTagEntries) != NULL) {
                        HeapInfo->NumberOfPseudoTags = HEAP_NUMBER_OF_PSEUDO_TAG;
                        HeapInfo->PseudoTagGranularity = HEAP_GRANULARITY;
                        for (TagIndex=0; TagIndex<=HEAP_MAXIMUM_FREELISTS; TagIndex++) {
                            Tags->NumberOfAllocations = PseudoTags->Allocs;
                            Tags->NumberOfFrees = PseudoTags->Frees;
                            Tags->BytesAllocated = PseudoTags->Size << HEAP_GRANULARITY_SHIFT;
                            Tags->TagIndex = (USHORT)(TagIndex | HEAP_PSEUDO_TAG_FLAG);
                            if (TagIndex == 0) {
                                swprintf( Tags->TagName, L"Objects>%4u",
                                          HEAP_MAXIMUM_FREELISTS << HEAP_GRANULARITY_SHIFT
                                        );
                                }
                            else
                            if (TagIndex < HEAP_MAXIMUM_FREELISTS) {
                                swprintf( Tags->TagName, L"Objects=%4u",
                                          TagIndex << HEAP_GRANULARITY_SHIFT
                                        );
                                }
                            else {
                                swprintf( Tags->TagName, L"VirtualAlloc",
                                          TagIndex << HEAP_GRANULARITY_SHIFT
                                        );
                                }

                            Tags += 1;
                            PseudoTags += 1;
                            }
                        }

                    RtlMoveMemory( Tags,
                                   Heap->TagEntries,
                                   Heap->NextAvailableTagIndex * sizeof( RTL_HEAP_TAG )
                                 );
                    for (TagIndex=0; TagIndex<Heap->NextAvailableTagIndex; TagIndex++) {
                        Tags->BytesAllocated <<= HEAP_GRANULARITY_SHIFT;
                        Tags += 1;
                        }
                    }
                }
            }
        }
    else {
        Buffer->Heaps = NULL;
        }
    if (NT_SUCCESS( Status )) {
        if (Buffer->Flags & RTL_QUERY_PROCESS_HEAP_ENTRIES) {
            for (i=0; i<Heaps->NumberOfHeaps; i++) {
                HeapInfo = &Heaps->Heaps[ i ];
                Heap = HeapInfo->BaseAddress;
                if (Buffer->SpecificHeap == NULL ||
                    Buffer->SpecificHeap == Heap
                   ) {
                    if (!(Heap->Flags & HEAP_NO_SERIALIZE)) {
                        RtlEnterCriticalSection( (PRTL_CRITICAL_SECTION)Heap->LockVariable );
                        LockAcquired = TRUE;
                        }
                    else {
                        LockAcquired = FALSE;
                        }

                    try {
                        for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {
                            Segment = Heap->Segments[ SegmentIndex ];
                            if (!Segment) {
                                continue;
                                }

                            Entries = RtlpCommitQueryDebugInfo( Buffer, sizeof( *Entries ) );
                            if (Entries == NULL) {
                                Status = STATUS_NO_MEMORY;
                                break;
                                }
                            else
                            if (HeapInfo->Entries == NULL) {
                                HeapInfo->Entries = Entries;
                                }

                            Entries->Flags = RTL_HEAP_SEGMENT;
                            Entries->AllocatorBackTraceIndex = Segment->AllocatorBackTraceIndex;
                            Entries->Size = Segment->NumberOfPages * PAGE_SIZE;
                            Entries->u.s2.CommittedSize = (Segment->NumberOfPages -
                                                           Segment->NumberOfUnCommittedPages
                                                          ) * PAGE_SIZE;
                            Entries->u.s2.FirstBlock = Segment->FirstEntry;
                            HeapInfo->NumberOfEntries++;

                            UnCommittedRange = Segment->UnCommittedRanges;
                            CurrentBlock = Segment->FirstEntry;
                            while (CurrentBlock < Segment->LastValidEntry) {
                                Entries = RtlpCommitQueryDebugInfo( Buffer, sizeof( *Entries ) );
                                if (Entries == NULL) {
                                    Status = STATUS_NO_MEMORY;
                                    break;
                                    }

                                Size = CurrentBlock->Size << HEAP_GRANULARITY_SHIFT;
                                Entries->Size = Size;
                                HeapInfo->NumberOfEntries++;
                                if (CurrentBlock->Flags & HEAP_ENTRY_BUSY) {
                                    if (CurrentBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {
                                        ExtraStuff = (PHEAP_ENTRY_EXTRA)(CurrentBlock + CurrentBlock->Size - 1);
#if i386
                                        Entries->AllocatorBackTraceIndex = ExtraStuff->AllocatorBackTraceIndex;
#endif // i386
                                        Entries->Flags |= RTL_HEAP_SETTABLE_VALUE;
                                        Entries->u.s1.Settable = ExtraStuff->Settable;
                                        Entries->u.s1.Tag = ExtraStuff->TagIndex;
                                        }
                                    else {
                                        Entries->u.s1.Tag = CurrentBlock->SmallTagIndex;
                                        }

                                    Entries->Flags |= RTL_HEAP_BUSY | (CurrentBlock->Flags & HEAP_ENTRY_SETTABLE_FLAGS);
                                    }
                                else
                                if (CurrentBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {
                                    PHEAP_FREE_ENTRY_EXTRA FreeExtra;

                                    FreeExtra = (PHEAP_FREE_ENTRY_EXTRA)(CurrentBlock + CurrentBlock->Size) - 1;
                                    Entries->u.s1.Tag = FreeExtra->TagIndex;
                                    Entries->AllocatorBackTraceIndex = FreeExtra->FreeBackTraceIndex;
                                    }

                                if (CurrentBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {
                                    CurrentBlock += CurrentBlock->Size;
                                    if (UnCommittedRange == NULL) {
                                        CurrentBlock = Segment->LastValidEntry;
                                        }
                                    else {
                                        Entries = RtlpCommitQueryDebugInfo( Buffer, sizeof( *Entries ) );
                                        if (Entries == NULL) {
                                            Status = STATUS_NO_MEMORY;
                                            break;
                                            }

                                        Entries->Flags = RTL_HEAP_UNCOMMITTED_RANGE;
                                        Entries->Size = UnCommittedRange->Size;
                                        HeapInfo->NumberOfEntries++;

                                        CurrentBlock = (PHEAP_ENTRY)
                                            ((PCHAR)UnCommittedRange->Address + UnCommittedRange->Size);
                                        UnCommittedRange = UnCommittedRange->Next;
                                        }
                                    }
                                else {
                                    CurrentBlock += CurrentBlock->Size;
                                    }
                                }
                            }

                        Head = &Heap->VirtualAllocdBlocks;
                        Next = Head->Flink;
                        while (Head != Next) {
                            VirtualAllocBlock = CONTAINING_RECORD( Next, HEAP_VIRTUAL_ALLOC_ENTRY, Entry );
                            CurrentBlock = &VirtualAllocBlock->BusyBlock;
                            Entries = RtlpCommitQueryDebugInfo( Buffer, sizeof( *Entries ) );
                            if (Entries == NULL) {
                                Status = STATUS_NO_MEMORY;
                                break;
                                }
                            else
                            if (HeapInfo->Entries == NULL) {
                                HeapInfo->Entries = Entries;
                                }

                            Entries->Flags = RTL_HEAP_SEGMENT;
                            Entries->Size = VirtualAllocBlock->ReserveSize;
                            Entries->u.s2.CommittedSize = VirtualAllocBlock->CommitSize;
                            Entries->u.s2.FirstBlock = CurrentBlock;
                            HeapInfo->NumberOfEntries++;
                            Entries = RtlpCommitQueryDebugInfo( Buffer, sizeof( *Entries ) );
                            if (Entries == NULL) {
                                Status = STATUS_NO_MEMORY;
                                break;
                                }

                            Entries->Size = VirtualAllocBlock->CommitSize;
                            Entries->Flags = RTL_HEAP_BUSY | (CurrentBlock->Flags & HEAP_ENTRY_SETTABLE_FLAGS);
#if i386
                            Entries->AllocatorBackTraceIndex = VirtualAllocBlock->ExtraStuff.AllocatorBackTraceIndex;
#endif // i386
                            Entries->Flags |= RTL_HEAP_SETTABLE_VALUE;
                            Entries->u.s1.Settable = VirtualAllocBlock->ExtraStuff.Settable;
                            Entries->u.s1.Tag = VirtualAllocBlock->ExtraStuff.TagIndex;
                            HeapInfo->NumberOfEntries++;

                            Next = Next->Flink;
                            }
                        }
                    finally {
                        //
                        // Unlock the heap
                        //

                        if (LockAcquired) {
                            RtlLeaveCriticalSection( (PRTL_CRITICAL_SECTION)Heap->LockVariable );
                            }
                        }
                    }

                if (!NT_SUCCESS( Status )) {
                    break;
                    }
                }
            }
        }

    return Status;
}


NTSYSAPI
NTSTATUS
NTAPI
RtlQueryProcessLockInformation(
    IN OUT PRTL_DEBUG_INFORMATION Buffer
    )
{
    NTSTATUS Status;
    PLIST_ENTRY Head, Next;
    PRTL_PROCESS_LOCKS Locks;
    PRTL_PROCESS_LOCK_INFORMATION LockInfo;
    PRTL_CRITICAL_SECTION CriticalSection;
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;
    PRTL_RESOURCE Resource;
    PRTL_RESOURCE_DEBUG ResourceDebugInfo;

    Locks = RtlpCommitQueryDebugInfo( Buffer, FIELD_OFFSET( RTL_PROCESS_LOCKS, Locks ) );
    if (Locks == NULL) {
        return STATUS_NO_MEMORY;
        }

    RtlEnterCriticalSection( &RtlCriticalSectionLock );
    Head = &RtlCriticalSectionList;
    Next = Head->Flink;
    Status = STATUS_SUCCESS;
    while (Next != Head) {
        DebugInfo = CONTAINING_RECORD( Next,
                                       RTL_CRITICAL_SECTION_DEBUG,
                                       ProcessLocksList
                                     );
        LockInfo = RtlpCommitQueryDebugInfo( Buffer, sizeof( RTL_PROCESS_LOCK_INFORMATION ) );
        if (LockInfo == NULL) {
            Status = STATUS_NO_MEMORY;
            break;
            }

        CriticalSection = DebugInfo->CriticalSection;
        try {
            LockInfo->Address = CriticalSection;
            LockInfo->Type = DebugInfo->Type;
            LockInfo->CreatorBackTraceIndex = DebugInfo->CreatorBackTraceIndex;
            if (LockInfo->Type == RTL_CRITSECT_TYPE) {
                LockInfo->OwningThread = CriticalSection->OwningThread;
                LockInfo->LockCount = CriticalSection->LockCount;
                LockInfo->RecursionCount = CriticalSection->RecursionCount;
                LockInfo->ContentionCount = DebugInfo->ContentionCount;
                LockInfo->EntryCount = DebugInfo->EntryCount;
                }
            else {
                Resource = (PRTL_RESOURCE)CriticalSection;
                ResourceDebugInfo = Resource->DebugInfo;
                LockInfo->ContentionCount = ResourceDebugInfo->ContentionCount;
                LockInfo->OwningThread = Resource->ExclusiveOwnerThread;
                LockInfo->LockCount = Resource->NumberOfActive;
                LockInfo->NumberOfWaitingShared    = Resource->NumberOfWaitingShared;
                LockInfo->NumberOfWaitingExclusive = Resource->NumberOfWaitingExclusive;
                }

            Locks->NumberOfLocks++;
            }
        except (EXCEPTION_EXECUTE_HANDLER) {
            DbgPrint("NTDLL: Lost critical section %08lX\n", CriticalSection);
            RtlpDeCommitQueryDebugInfo( Buffer, LockInfo, sizeof( RTL_PROCESS_LOCK_INFORMATION ) );
            }

        if (Next == Next->Flink) {
            //
            // Bail if list is circular
            //
            break;
            }
        else {
            Next = Next->Flink;
            }
        }

    RtlLeaveCriticalSection( &RtlCriticalSectionLock );

    if (NT_SUCCESS( Status )) {
        Buffer->Locks = Locks;
        }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\sxsactctx.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sxsappctx.c

Abstract:

    Side-by-side activation support for Windows/NT
    Implementation of the application context object.

Author:

    Michael Grier (MGrier) 2/1/2000

Revision History:

--*/

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <sxstypes.h>
#include "sxsp.h"

typedef const void *PCVOID;

NTSTATUS
RtlpValidateActivationContextData(
    IN ULONG Flags,
    IN PCACTIVATION_CONTEXT_DATA Data,
    IN SIZE_T BufferSize OPTIONAL
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PCACTIVATION_CONTEXT_DATA_TOC_HEADER TocHeader;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER AssemblyRosterHeader;

    (Flags);

    if ((Data->Magic != ACTIVATION_CONTEXT_DATA_MAGIC) ||
        (Data->FormatVersion != ACTIVATION_CONTEXT_DATA_FORMAT_WHISTLER) ||
        ((BufferSize != 0) &&
         (BufferSize < Data->TotalSize)))
    {
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    // Check required elements...
    if (Data->DefaultTocOffset == 0) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: Warning: Activation context data at %p missing default TOC\n", Data);
    }

    // How can we not have an assembly roster?
    if (Data->AssemblyRosterOffset == 0) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: Warning: Activation context data at %p lacks assembly roster\n", Data);
    }

    if (Data->DefaultTocOffset != 0) {
        if ((Data->DefaultTocOffset >= Data->TotalSize) ||
            ((Data->DefaultTocOffset + sizeof(ACTIVATION_CONTEXT_DATA_TOC_HEADER)) > Data->TotalSize)) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: Activation context data at %p has invalid TOC header offset\n", Data);
            Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
            goto Exit;
        }

        TocHeader = (PCACTIVATION_CONTEXT_DATA_TOC_HEADER) (((ULONG_PTR) Data) + Data->DefaultTocOffset);

        if (TocHeader->HeaderSize < sizeof(ACTIVATION_CONTEXT_DATA_TOC_HEADER)) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: Activation context data at %p has TOC header too small (%lu)\n", Data, TocHeader->HeaderSize);
            Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
            goto Exit;
        }

        if ((TocHeader->FirstEntryOffset >= Data->TotalSize) ||
            ((TocHeader->FirstEntryOffset + (TocHeader->EntryCount * sizeof(ACTIVATION_CONTEXT_DATA_TOC_ENTRY))) > Data->TotalSize)) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: Activation context data at %p has invalid TOC entry array offset\n", Data);
            Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
            goto Exit;
        }
    }

    // we should finish validating the rest of the structure...

    if ((Data->AssemblyRosterOffset >= Data->TotalSize) ||
        ((Data->AssemblyRosterOffset + sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER)) > Data->TotalSize)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: Activation context data at %p has invalid assembly roster offset\n", Data);
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    AssemblyRosterHeader = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER) (((ULONG_PTR) Data) + Data->AssemblyRosterOffset);

    if (Data->AssemblyRosterOffset != 0) {
        if (AssemblyRosterHeader->HeaderSize < sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER)) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: Activation context data at %p has assembly roster header too small (%lu)\n", Data, AssemblyRosterHeader->HeaderSize);
            Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
            goto Exit;
        }
    }

    Status = STATUS_SUCCESS;

Exit:
    return Status;
}

const ACTIVATION_CONTEXT_DATA RtlpTheEmptyActivationContextData =
{
    ACTIVATION_CONTEXT_DATA_MAGIC,
    sizeof(ACTIVATION_CONTEXT_DATA), // header size
    ACTIVATION_CONTEXT_DATA_FORMAT_WHISTLER,
    sizeof(ACTIVATION_CONTEXT_DATA), // total size
    0, // default toc offset
    0, // extended toc offset
    0  // assembly roster index
};

// this struct is not const, its ref count can change (oops, no, that's
// no longer true, but leave it mutable for now to be safe)
ACTIVATION_CONTEXT RtlpTheEmptyActivationContext =
{
    MAXULONG, // ref count, pinned
    ACTIVATION_CONTEXT_NOT_HEAP_ALLOCATED, // flags
    (PVOID)&RtlpTheEmptyActivationContextData
    // the rest zeros and NULLs
};

NTSTATUS
NTAPI
RtlCreateActivationContext(
    IN ULONG Flags,
    IN PCACTIVATION_CONTEXT_DATA ActivationContextData,    
    IN ULONG ExtraBytes,
    IN PACTIVATION_CONTEXT_NOTIFY_ROUTINE NotificationRoutine,
    IN PVOID NotificationContext,
    OUT PACTIVATION_CONTEXT *ActCtx
    )
{
    PACTIVATION_CONTEXT NewActCtx = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG i;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER AssemblyRosterHeader;
    BOOLEAN UninitializeStorageMapOnExit = FALSE;

    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "SXS: RtlCreateActivationContext() called with parameters:\n"
        "   Flags = 0x%08lx\n"
        "   ActivationContextData = %p\n"
        "   ExtraBytes = %lu\n"
        "   NotificationRoutine = %p\n"
        "   NotificationContext = %p\n"
        "   ActCtx = %p\n",
        Flags,
        ActivationContextData,
        ExtraBytes,
        NotificationRoutine,
        NotificationContext,
        ActCtx);

    RTLP_DISALLOW_THE_EMPTY_ACTIVATION_CONTEXT_DATA(ActivationContextData);

    if (ActCtx != NULL)
        *ActCtx = NULL;

    if ((Flags != 0) ||
        (ActivationContextData == NULL) ||
        (ExtraBytes > 65536) ||
        (ActCtx == NULL))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    // Make sure that the activation context data passes muster
    Status = RtlpValidateActivationContextData(0, ActivationContextData, 0);
    if (NT_ERROR(Status))
        goto Exit;

    NewActCtx = (PACTIVATION_CONTEXT) RtlAllocateHeap(
                                RtlProcessHeap(),
                                0,
                                sizeof(ACTIVATION_CONTEXT) + ExtraBytes);
    if (NewActCtx == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    AssemblyRosterHeader = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER) (((ULONG_PTR) ActivationContextData) + ActivationContextData->AssemblyRosterOffset);

    Status = RtlpInitializeAssemblyStorageMap(
                    &NewActCtx->StorageMap,
                    AssemblyRosterHeader->EntryCount,
                    (AssemblyRosterHeader->EntryCount > NUMBER_OF(NewActCtx->InlineStorageMapEntries)) ? NULL : NewActCtx->InlineStorageMapEntries);
    if (NT_ERROR(Status))
        goto Exit;

    UninitializeStorageMapOnExit = TRUE;

    NewActCtx->RefCount = 1;
    NewActCtx->Flags = 0;
    NewActCtx->ActivationContextData = (PVOID) ActivationContextData;
    NewActCtx->NotificationRoutine = NotificationRoutine;
    NewActCtx->NotificationContext = NotificationContext;

    for (i=0; i<NUMBER_OF(NewActCtx->SentNotifications); i++)
        NewActCtx->SentNotifications[i] = 0;

    for (i=0; i<NUMBER_OF(NewActCtx->DisabledNotifications); i++)
        NewActCtx->DisabledNotifications[i] = 0;

    *ActCtx = NewActCtx;
    NewActCtx = NULL;

    UninitializeStorageMapOnExit = FALSE;

    Status = STATUS_SUCCESS;

Exit:
    if (NewActCtx != NULL) {
        if (UninitializeStorageMapOnExit) {
            RtlpUninitializeAssemblyStorageMap(&NewActCtx->StorageMap);
        }

        RtlFreeHeap(RtlProcessHeap(), 0, NewActCtx);
    }

    return Status;
}

VOID
NTAPI
RtlAddRefActivationContext(
    PACTIVATION_CONTEXT ActCtx
    )
{
    if ((ActCtx != NULL) &&
        (!IS_SPECIAL_ACTCTX(ActCtx)) &&
        (ActCtx->RefCount != MAXULONG))
    {
        LONG NewRefCount = 0;

        ASSERT(ActCtx->RefCount != 0);

        NewRefCount = InterlockedIncrement(&ActCtx->RefCount);

        // Probably indicative of a reference leak that's wrapped the refcount;
        // other probable cause is several concurrent releases.
        ASSERT(NewRefCount != 0);
    }
}

VOID
NTAPI
RtlReleaseActivationContext(
    PACTIVATION_CONTEXT ActCtx
    )
{
    if ((ActCtx != NULL) &&
        (!IS_SPECIAL_ACTCTX(ActCtx)) &&
        (ActCtx->RefCount != MAXULONG))
    {
        LONG NewRefCount = 0;

        ASSERT(ActCtx->RefCount != 0);
        NewRefCount = InterlockedDecrement(&ActCtx->RefCount);

        if (NewRefCount == 0)
        {
            if (ActCtx->NotificationRoutine != NULL)
            {
                // There's no need to check for the notification being disabled; destroy
                // notifications are sent only once, so if the notification routine is not
                // null, we can just call it.
                BOOLEAN DisableNotification = FALSE;

                (*(ActCtx->NotificationRoutine))(
                            ACTIVATION_CONTEXT_NOTIFICATION_DESTROY,
                            ActCtx,
                            ActCtx->ActivationContextData,
                            ActCtx->NotificationContext,
                            NULL,
                            &DisableNotification);
            }

            RtlpUninitializeAssemblyStorageMap(&ActCtx->StorageMap);

            //
            // This predates the MAXULONG refcount, maybe we can get rid of the the flag now?
            //
            if ((ActCtx->Flags & ACTIVATION_CONTEXT_NOT_HEAP_ALLOCATED) == 0) {
                RtlFreeHeap(RtlProcessHeap(), 0, ActCtx);
            }
        }
    }
}

NTSTATUS
NTAPI
RtlZombifyActivationContext(
    PACTIVATION_CONTEXT ActCtx
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    if ((ActCtx == NULL) || IS_SPECIAL_ACTCTX(ActCtx))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if ((ActCtx->Flags & ACTIVATION_CONTEXT_ZOMBIFIED) == 0)
    {
        if (ActCtx->NotificationRoutine != NULL)
        {
            // Since disable is sent only once, there's no need to check for
            // disabled notifications.

            BOOLEAN DisableNotification = FALSE;

            (*(ActCtx->NotificationRoutine))(
                        ACTIVATION_CONTEXT_NOTIFICATION_ZOMBIFY,
                        ActCtx,
                        ActCtx->ActivationContextData,
                        ActCtx->NotificationContext,
                        NULL,
                        &DisableNotification);
        }
        ActCtx->Flags |= ACTIVATION_CONTEXT_ZOMBIFIED;
    }

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\resource.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Resource.c

Abstract:

    This module implements the executive functions to acquire and release
    a shared resource.

Author:

    Mark Lucovsky       (markl)     04-Aug-1989

Environment:

    These routines are statically linked in the caller's executable and
    are callable in only from user mode.  They make use of Nt system
    services.

Revision History:

--*/

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <heap.h>
#include "ldrp.h"
#include "wmiumkm.h"
#include "NtdllTrc.h"


//
// Define the desired access for semaphores.
//

#define DESIRED_EVENT_ACCESS \
                (EVENT_QUERY_STATE | EVENT_MODIFY_STATE | SYNCHRONIZE)

#define DESIRED_SEMAPHORE_ACCESS \
                (SEMAPHORE_QUERY_STATE | SEMAPHORE_MODIFY_STATE | SYNCHRONIZE)

VOID RtlDumpResource( IN PRTL_RESOURCE Resource );

extern BOOLEAN LdrpShutdownInProgress;
extern HANDLE LdrpShutdownThreadId;

NTSTATUS
RtlpInitDeferedCriticalSection( VOID );
RTL_CRITICAL_SECTION DeferedCriticalSection;

HANDLE GlobalKeyedEventHandle=NULL;

//#define RTLP_USE_GLOBAL_KEYED_EVENT 1

#define RtlpIsKeyedEvent(xxHandle) ((((ULONG_PTR)xxHandle)&1) != 0)
#define RtlpSetKeyedEventHandle(xxHandle) ((HANDLE)(((ULONG_PTR)xxHandle)|1))

#if DBG
BOOLEAN
ProtectHandle(
    HANDLE hObject
    )
{
    NTSTATUS Status;
    OBJECT_HANDLE_FLAG_INFORMATION HandleInfo;

    Status = NtQueryObject( hObject,
                            ObjectHandleFlagInformation,
                            &HandleInfo,
                            sizeof( HandleInfo ),
                            NULL
                          );
    if (NT_SUCCESS( Status )) {
        HandleInfo.ProtectFromClose = TRUE;

        Status = NtSetInformationObject( hObject,
                                         ObjectHandleFlagInformation,
                                         &HandleInfo,
                                         sizeof( HandleInfo )
                                       );
        if (NT_SUCCESS( Status )) {
            return TRUE;
            }
        }

    return FALSE;
}


BOOLEAN
UnProtectHandle(
    HANDLE hObject
    )
{
    NTSTATUS Status;
    OBJECT_HANDLE_FLAG_INFORMATION HandleInfo;

    Status = NtQueryObject( hObject,
                            ObjectHandleFlagInformation,
                            &HandleInfo,
                            sizeof( HandleInfo ),
                            NULL
                          );
    if (NT_SUCCESS( Status )) {
        HandleInfo.ProtectFromClose = FALSE;

        Status = NtSetInformationObject( hObject,
                                         ObjectHandleFlagInformation,
                                         &HandleInfo,
                                         sizeof( HandleInfo )
                                       );
        if (NT_SUCCESS( Status )) {
            return TRUE;
            }
        }

    return FALSE;
}
#endif // DBG

RTL_CRITICAL_SECTION_DEBUG RtlpStaticDebugInfo[ 64 ];
PRTL_CRITICAL_SECTION_DEBUG RtlpDebugInfoFreeList;
BOOLEAN RtlpCritSectInitialized;

PRTL_CRITICAL_SECTION_DEBUG
RtlpChainDebugInfo(
    IN PVOID BaseAddress,
    IN ULONG Size
    )
{
    PRTL_CRITICAL_SECTION_DEBUG p, p1;

    Size = Size / sizeof( RTL_CRITICAL_SECTION_DEBUG );

    p = NULL;

    if (Size) {
        p = (PRTL_CRITICAL_SECTION_DEBUG)BaseAddress + Size - 1;
        *(PRTL_CRITICAL_SECTION_DEBUG *)p = NULL;
        while (--Size) {
            p1 = p - 1;
            *(PRTL_CRITICAL_SECTION_DEBUG *)p1 = p;
            p = p1;
            }
        }

    return p;
}


PVOID
RtlpAllocateDebugInfo( VOID );

VOID
RtlpFreeDebugInfo(
    IN PRTL_CRITICAL_SECTION_DEBUG DebugInfo
    );

PVOID
RtlpAllocateDebugInfo( VOID )
{
    PRTL_CRITICAL_SECTION_DEBUG p;
    PPEB Peb;


    if (RtlpCritSectInitialized) {
        RtlEnterCriticalSection(&DeferedCriticalSection);
        }
    try {
        p = RtlpDebugInfoFreeList;
        if (p == NULL) {
            Peb = NtCurrentPeb();
            p = RtlAllocateHeap(Peb->ProcessHeap,
                                0,
                                sizeof(RTL_CRITICAL_SECTION_DEBUG));
            if ( !p ) {
                KdPrint(( "NTDLL: Unable to allocate debug information from heap\n"));
                }
            }
        else {
            RtlpDebugInfoFreeList = *(PRTL_CRITICAL_SECTION_DEBUG *)p;
            }
        }
    finally {
        if (RtlpCritSectInitialized) {
            RtlLeaveCriticalSection(&DeferedCriticalSection);
            }
        }

    return p;
}


VOID
RtlpFreeDebugInfo(
    IN PRTL_CRITICAL_SECTION_DEBUG DebugInfo
    )
{
    RtlEnterCriticalSection(&DeferedCriticalSection);
    try {
        RtlZeroMemory( DebugInfo, sizeof( RTL_CRITICAL_SECTION_DEBUG ) );
	if ( (RtlpStaticDebugInfo <= DebugInfo)
	     && ((char *)DebugInfo < (((char *)RtlpStaticDebugInfo)
				      + sizeof(RtlpStaticDebugInfo)))) {
	    //
	    // It came from our static debug info; save it away...
	    //
	    *(PRTL_CRITICAL_SECTION_DEBUG *)DebugInfo = RtlpDebugInfoFreeList;
	    RtlpDebugInfoFreeList = DebugInfo;
	    }
	else {
	    //
	    // We allocated this debug info from the heap; give it back.
	    //
	    RtlFreeHeap(NtCurrentPeb()->ProcessHeap, 0, DebugInfo);
	    }
        }
    finally {
        RtlLeaveCriticalSection(&DeferedCriticalSection);
        }

    return;
}


NTSTATUS
RtlpInitDeferedCriticalSection( VOID )
{
    NTSTATUS Status;

    InitializeListHead( &RtlCriticalSectionList );

    if (sizeof( RTL_CRITICAL_SECTION_DEBUG ) != sizeof( RTL_RESOURCE_DEBUG )) {
        DbgPrint( "NTDLL: Critical Section & Resource Debug Info length mismatch.\n" );
        return STATUS_INVALID_PARAMETER;
    }

    RtlpDebugInfoFreeList = RtlpChainDebugInfo( RtlpStaticDebugInfo,
                                                sizeof( RtlpStaticDebugInfo )
                                              );

    Status = RtlInitializeCriticalSectionAndSpinCount( &RtlCriticalSectionLock, 1000 );
    if (NT_SUCCESS (Status)) {
        Status = RtlInitializeCriticalSectionAndSpinCount( &DeferedCriticalSection, 1000 );
    }

    if (NT_SUCCESS (Status)) {
        RtlpCritSectInitialized = TRUE;
    }
    return Status;
}


BOOLEAN
NtdllOkayToLockRoutine(
    IN PVOID Lock
    )
{
    return TRUE;
}




VOID
RtlInitializeResource(
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine initializes the input resource variable

Arguments:

    Resource - Supplies the resource variable being initialized

Return Value:

    None

--*/

{
    NTSTATUS Status;
    PRTL_RESOURCE_DEBUG ResourceDebugInfo;
    ULONG SpinCount;

    //
    //  Initialize the lock fields, the count indicates how many are waiting
    //  to enter or are in the critical section, LockSemaphore is the object
    //  to wait on when entering the critical section.  SpinLock is used
    //  for the add interlock instruction.
    //

    SpinCount = 1024 * (NtCurrentPeb()->NumberOfProcessors - 1);
    if (SpinCount > 12000) {
        SpinCount = 12000;
    }

    Status = RtlInitializeCriticalSectionAndSpinCount (&Resource->CriticalSection, SpinCount);
    if (!NT_SUCCESS (Status)){
        RtlRaiseStatus(Status);
    }

    Resource->CriticalSection.DebugInfo->Type = RTL_RESOURCE_TYPE;
    ResourceDebugInfo = (PRTL_RESOURCE_DEBUG) RtlpAllocateDebugInfo();

    if (ResourceDebugInfo == NULL) {
        RtlDeleteCriticalSection (&Resource->CriticalSection);
        RtlRaiseStatus(STATUS_NO_MEMORY);
    }

    ResourceDebugInfo->ContentionCount = 0;
    Resource->DebugInfo = ResourceDebugInfo;

    //
    //  Initialize flags so there is a default value.
    //  (Some apps may set RTL_RESOURCE_FLAGS_LONG_TERM to affect timeouts.)
    //

    Resource->Flags = 0;


    //
    //  Initialize the shared and exclusive waiting counters and semaphore.
    //  The counters indicate how many are waiting for access to the resource
    //  and the semaphores are used to wait on the resource.  Note that
    //  the semaphores can also indicate the number waiting for a resource
    //  however there is a race condition in the alogrithm on the acquire
    //  side if count if not updated before the critical section is exited.
    //

    Status = NtCreateSemaphore(
                 &Resource->SharedSemaphore,
                 DESIRED_SEMAPHORE_ACCESS,
                 NULL,
                 0,
                 MAXLONG
                 );
    if ( !NT_SUCCESS(Status) ){
        RtlDeleteCriticalSection (&Resource->CriticalSection);
        RtlpFreeDebugInfo( Resource->DebugInfo );
        RtlRaiseStatus(Status);
    }

    Resource->NumberOfWaitingShared = 0;

    Status = NtCreateSemaphore(
                 &Resource->ExclusiveSemaphore,
                 DESIRED_SEMAPHORE_ACCESS,
                 NULL,
                 0,
                 MAXLONG
                 );
    if ( !NT_SUCCESS(Status) ){
        RtlDeleteCriticalSection (&Resource->CriticalSection);
        NtClose(Resource->SharedSemaphore);
        RtlpFreeDebugInfo( Resource->DebugInfo );
        RtlRaiseStatus(Status);
        }

    Resource->NumberOfWaitingExclusive = 0;

    //
    //  Initialize the current state of the resource
    //

    Resource->NumberOfActive = 0;

    Resource->ExclusiveOwnerThread = NULL;

    return;
}


BOOLEAN
RtlAcquireResourceShared(
    IN PRTL_RESOURCE Resource,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    The routine acquires the resource for shared access.  Upon return from
    the procedure the resource is acquired for shared access.

Arguments:

    Resource - Supplies the resource to acquire

    Wait - Indicates if the call is allowed to wait for the resource
        to become available for must return immediately

Return Value:

    BOOLEAN - TRUE if the resource is acquired and FALSE otherwise

--*/

{
    NTSTATUS Status;
    ULONG TimeoutCount = 0;
    PLARGE_INTEGER TimeoutTime = &RtlpTimeout;
    //
    //  Enter the critical section
    //

    RtlEnterCriticalSection(&Resource->CriticalSection);

    //
    //  If it is not currently acquired for exclusive use then we can acquire
    //  the resource for shared access.  Note that this can potentially
    //  starve an exclusive waiter however, this is necessary given the
    //  ability to recursively acquire the resource shared.  Otherwise we
    //  might/will reach a deadlock situation where a thread tries to acquire
    //  the resource recusively shared but is blocked by an exclusive waiter.
    //
    //  The test to reanable not starving an exclusive waiter is:
    //
    //      if ((Resource->NumberOfWaitingExclusive == 0) &&
    //          (Resource->NumberOfActive >= 0)) {
    //

    if (Resource->NumberOfActive >= 0) {

        //
        //  The resource is ours, so indicate that we have it and
        //  exit the critical section
        //

        Resource->NumberOfActive += 1;

        RtlLeaveCriticalSection(&Resource->CriticalSection);

    //
    //  Otherwise check to see if this thread is the one currently holding
    //  exclusive access to the resource.  And if it is then we change
    //  this shared request to an exclusive recusive request and grant
    //  access to the resource.
    //

    } else if (Resource->ExclusiveOwnerThread == NtCurrentTeb()->ClientId.UniqueThread) {

        //
        //  The resource is ours (recusively) so indicate that we have it
        //  and exit the critial section
        //

        Resource->NumberOfActive -= 1;

        RtlLeaveCriticalSection(&Resource->CriticalSection);

    //
    //  Otherwise we'll have to wait for access.
    //

    } else {

        //
        //  Check if we are allowed to wait or must return immedately, and
        //  indicate that we didn't acquire the resource
        //

        if (!Wait) {

            RtlLeaveCriticalSection(&Resource->CriticalSection);

            return FALSE;

        }

        //
        //  Otherwise we need to wait to acquire the resource.
        //  To wait we will increment the number of waiting shared,
        //  release the lock, and wait on the shared semaphore
        //

        Resource->NumberOfWaitingShared += 1;
        Resource->DebugInfo->ContentionCount++;

        RtlLeaveCriticalSection(&Resource->CriticalSection);

rewait:
        if ( Resource->Flags & RTL_RESOURCE_FLAG_LONG_TERM ) {
            TimeoutTime = NULL;
        }
        Status = NtWaitForSingleObject(
                    Resource->SharedSemaphore,
                    FALSE,
                    TimeoutTime
                    );
        if ( Status == STATUS_TIMEOUT ) {
            DbgPrint("RTL: Acquire Shared Sem Timeout %d(%I64u secs)\n",
                     TimeoutCount, TimeoutTime->QuadPart / (-10000000));
            DbgPrint("RTL: Resource at %p\n",Resource);
            TimeoutCount++;
            if ( TimeoutCount > 2 ) {
                PIMAGE_NT_HEADERS NtHeaders;

                //
                // If the image is a Win32 image, then raise an exception and try to get to the
                // uae popup
                //

                NtHeaders = RtlImageNtHeader(NtCurrentPeb()->ImageBaseAddress);

                if (NtHeaders->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_CUI ||
                    NtHeaders->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_GUI) {
                    EXCEPTION_RECORD ExceptionRecord;

                    ExceptionRecord.ExceptionCode = STATUS_POSSIBLE_DEADLOCK;
                    ExceptionRecord.ExceptionFlags = 0;
                    ExceptionRecord.ExceptionRecord = NULL;
                    ExceptionRecord.ExceptionAddress = (PVOID)RtlRaiseException;
                    ExceptionRecord.NumberParameters = 1;
                    ExceptionRecord.ExceptionInformation[0] = (ULONG_PTR)Resource;
                    RtlRaiseException(&ExceptionRecord);
                    }
                else {
                    DbgBreakPoint();
                    }
                }
            DbgPrint("RTL: Re-Waiting\n");
            goto rewait;
        }
        if ( !NT_SUCCESS(Status) ) {
            RtlRaiseStatus(Status);
            }
    }

    //
    //  Now the resource is ours, for shared access
    //

    return TRUE;

}


BOOLEAN
RtlAcquireResourceExclusive(
    IN PRTL_RESOURCE Resource,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    The routine acquires the resource for exclusive access.  Upon return from
    the procedure the resource is acquired for exclusive access.

Arguments:

    Resource - Supplies the resource to acquire

    Wait - Indicates if the call is allowed to wait for the resource
        to become available for must return immediately

Return Value:

    BOOLEAN - TRUE if the resource is acquired and FALSE otherwise

--*/

{
    NTSTATUS Status;
    ULONG TimeoutCount = 0;
    PLARGE_INTEGER TimeoutTime = &RtlpTimeout;

    //
    //  Loop until the resource is ours or exit if we cannot wait.
    //

    while (TRUE) {

        //
        //  Enter the critical section
        //

        RtlEnterCriticalSection(&Resource->CriticalSection);

        //
        //  If there are no shared users and it is not currently acquired for
        //  exclusive use then we can acquire the resource for exclusive
        //  access.  We also can acquire it if the resource indicates exclusive
        //  access but there isn't currently an owner.
        //

        if ((Resource->NumberOfActive == 0)

                ||

            ((Resource->NumberOfActive == -1) &&
             (Resource->ExclusiveOwnerThread == NULL))) {

            //
            //  The resource is ours, so indicate that we have it and
            //  exit the critical section
            //

            Resource->NumberOfActive = -1;

            Resource->ExclusiveOwnerThread = NtCurrentTeb()->ClientId.UniqueThread;

            RtlLeaveCriticalSection(&Resource->CriticalSection);

            return TRUE;

        }

        //
        //  Otherwise check to see if we already have exclusive access to the
        //  resource and can simply recusively acquire it again.
        //

        if (Resource->ExclusiveOwnerThread == NtCurrentTeb()->ClientId.UniqueThread) {

            //
            //  The resource is ours (recusively) so indicate that we have it
            //  and exit the critial section
            //

            Resource->NumberOfActive -= 1;

            RtlLeaveCriticalSection(&Resource->CriticalSection);

            return TRUE;

        }

        //
        //  Check if we are allowed to wait or must return immedately, and
        //  indicate that we didn't acquire the resource
        //

        if (!Wait) {

            RtlLeaveCriticalSection(&Resource->CriticalSection);

            return FALSE;

        }

        //
        //  Otherwise we need to wait to acquire the resource.
        //  To wait we will increment the number of waiting exclusive,
        //  release the lock, and wait on the exclusive semaphore
        //

        Resource->NumberOfWaitingExclusive += 1;
        Resource->DebugInfo->ContentionCount++;

        RtlLeaveCriticalSection(&Resource->CriticalSection);

rewait:
        if ( Resource->Flags & RTL_RESOURCE_FLAG_LONG_TERM ) {
            TimeoutTime = NULL;
        }
        Status = NtWaitForSingleObject(
                    Resource->ExclusiveSemaphore,
                    FALSE,
                    TimeoutTime
                    );
        if ( Status == STATUS_TIMEOUT ) {
            DbgPrint("RTL: Acquire Exclusive Sem Timeout %d (%I64u secs)\n",
                     TimeoutCount, TimeoutTime->QuadPart / (-10000000));
            DbgPrint("RTL: Resource at %p\n",Resource);
            TimeoutCount++;
            if ( TimeoutCount > 2 ) {
                PIMAGE_NT_HEADERS NtHeaders;

                //
                // If the image is a Win32 image, then raise an exception and try to get to the
                // uae popup
                //

                NtHeaders = RtlImageNtHeader(NtCurrentPeb()->ImageBaseAddress);

                if (NtHeaders->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_CUI ||
                    NtHeaders->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_GUI) {
                    EXCEPTION_RECORD ExceptionRecord;

                    ExceptionRecord.ExceptionCode = STATUS_POSSIBLE_DEADLOCK;
                    ExceptionRecord.ExceptionFlags = 0;
                    ExceptionRecord.ExceptionRecord = NULL;
                    ExceptionRecord.ExceptionAddress = (PVOID)RtlRaiseException;
                    ExceptionRecord.NumberParameters = 1;
                    ExceptionRecord.ExceptionInformation[0] = (ULONG_PTR)Resource;
                    RtlRaiseException(&ExceptionRecord);
                    }
                else {
                    DbgBreakPoint();
                    }
                }
            DbgPrint("RTL: Re-Waiting\n");
            goto rewait;
        }
        if ( !NT_SUCCESS(Status) ) {
            RtlRaiseStatus(Status);
            }
    }
}


VOID
RtlReleaseResource(
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine release the input resource.  The resource can have been
    acquired for either shared or exclusive access.

Arguments:

    Resource - Supplies the resource to release

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    LONG PreviousCount;

    //
    //  Enter the critical section
    //

    RtlEnterCriticalSection(&Resource->CriticalSection);

    //
    //  Test if the resource is acquired for shared or exclusive access
    //

    if (Resource->NumberOfActive > 0) {

        //
        //  Releasing shared access to the resource, so decrement
        //  the number of shared users
        //

        Resource->NumberOfActive -= 1;

        //
        //  If the resource is now available and there is a waiting
        //  exclusive user then give the resource to the waiting thread
        //

        if ((Resource->NumberOfActive == 0) &&
            (Resource->NumberOfWaitingExclusive > 0)) {

            //
            //  Set the resource state to exclusive (but not owned),
            //  decrement the number of waiting exclusive, and release
            //  one exclusive waiter
            //

            Resource->NumberOfActive = -1;
            Resource->ExclusiveOwnerThread = NULL;

            Resource->NumberOfWaitingExclusive -= 1;

            Status = NtReleaseSemaphore(
                         Resource->ExclusiveSemaphore,
                         1,
                         &PreviousCount
                         );
            if ( !NT_SUCCESS(Status) ) {
                RtlRaiseStatus(Status);
                }
        }

    } else if (Resource->NumberOfActive < 0) {

        //
        //  Releasing exclusive access to the resource, so increment the
        //  number of active by one.  And continue testing only
        //  if the resource is now available.
        //

        Resource->NumberOfActive += 1;

        if (Resource->NumberOfActive == 0) {

            //
            //  The resource is now available.  Remove ourselves as the
            //  owner thread
            //

            Resource->ExclusiveOwnerThread = NULL;

            //
            //  If there is another waiting exclusive then give the resource
            //  to it.
            //

            if (Resource->NumberOfWaitingExclusive > 0) {

                //
                //  Set the resource to exclusive, and its owner undefined.
                //  Decrement the number of waiting exclusive and release one
                //  exclusive waiter
                //

                Resource->NumberOfActive = -1;
                Resource->NumberOfWaitingExclusive -= 1;

                Status = NtReleaseSemaphore(
                             Resource->ExclusiveSemaphore,
                             1,
                             &PreviousCount
                             );
                if ( !NT_SUCCESS(Status) ) {
                    RtlRaiseStatus(Status);
                    }

            //
            //  Check to see if there are waiting shared, who should now get
            //  the resource
            //

            } else if (Resource->NumberOfWaitingShared > 0) {

                //
                //  Set the new state to indicate that all of the shared
                //  requesters have access and there are no more waiting
                //  shared requesters, and then release all of the shared
                //  requsters
                //

                Resource->NumberOfActive = Resource->NumberOfWaitingShared;

                Resource->NumberOfWaitingShared = 0;

                Status = NtReleaseSemaphore(
                             Resource->SharedSemaphore,
                             Resource->NumberOfActive,
                             &PreviousCount
                             );
                if ( !NT_SUCCESS(Status) ) {
                    RtlRaiseStatus(Status);
                    }
            }
        }

#if DBG
    } else {

        //
        //  The resource isn't current acquired, there is nothing to release
        //  so tell the user the mistake
        //


        DbgPrint("NTDLL - Resource released too many times %lx\n", Resource);
        DbgBreakPoint();
#endif
    }

    //
    //  Exit the critical section, and return to the caller
    //

    RtlLeaveCriticalSection(&Resource->CriticalSection);

    return;
}


VOID
RtlConvertSharedToExclusive(
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine converts a resource acquired for shared access into
    one acquired for exclusive access.  Upon return from the procedure
    the resource is acquired for exclusive access

Arguments:

    Resource - Supplies the resource to acquire for shared access, it
        must already be acquired for shared access

Return Value:

    None

--*/

{
    NTSTATUS Status;
    ULONG TimeoutCount = 0;

    //
    //  Enter the critical section
    //

    RtlEnterCriticalSection(&Resource->CriticalSection);

    //
    //  If there is only one shared user (it's us) and we can acquire the
    //  resource for exclusive access.
    //

    if (Resource->NumberOfActive == 1) {

        //
        //  The resource is ours, so indicate that we have it and
        //  exit the critical section, and return
        //

        Resource->NumberOfActive = -1;

        Resource->ExclusiveOwnerThread = NtCurrentTeb()->ClientId.UniqueThread;

        RtlLeaveCriticalSection(&Resource->CriticalSection);

        return;
    }

    //
    //  If the resource is currently acquired exclusive and it's us then
    //  we already have exclusive access
    //

    if ((Resource->NumberOfActive < 0) &&
        (Resource->ExclusiveOwnerThread == NtCurrentTeb()->ClientId.UniqueThread)) {

        //
        //  We already have exclusive access to the resource so we'll just
        //  exit the critical section and return
        //

        RtlLeaveCriticalSection(&Resource->CriticalSection);

        return;
    }

    //
    //  If the resource is acquired by more than one shared then we need
    //  to wait to get exclusive access to the resource
    //

    if (Resource->NumberOfActive > 1) {

        //
        //  To wait we will decrement the fact that we have the resource for
        //  shared, and then loop waiting on the exclusive lock, and then
        //  testing to see if we can get exclusive access to the resource
        //

        Resource->NumberOfActive -= 1;

        while (TRUE) {

            //
            //  Increment the number of waiting exclusive, exit and critical
            //  section and wait on the exclusive semaphore
            //

            Resource->NumberOfWaitingExclusive += 1;
            Resource->DebugInfo->ContentionCount++;

            RtlLeaveCriticalSection(&Resource->CriticalSection);
rewait:
        Status = NtWaitForSingleObject(
                    Resource->ExclusiveSemaphore,
                    FALSE,
                    &RtlpTimeout
                    );
        if ( Status == STATUS_TIMEOUT ) {
            DbgPrint("RTL: Convert Exclusive Sem Timeout %d (%I64u secs)\n",
                     TimeoutCount, RtlpTimeout.QuadPart / (-10000000));
            DbgPrint("RTL: Resource at %p\n",Resource);
            TimeoutCount++;
            if ( TimeoutCount > 2 ) {
                PIMAGE_NT_HEADERS NtHeaders;

                //
                // If the image is a Win32 image, then raise an exception and try to get to the
                // uae popup
                //

                NtHeaders = RtlImageNtHeader(NtCurrentPeb()->ImageBaseAddress);

                if (NtHeaders->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_CUI ||
                    NtHeaders->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_GUI) {
                    EXCEPTION_RECORD ExceptionRecord;

                    ExceptionRecord.ExceptionCode = STATUS_POSSIBLE_DEADLOCK;
                    ExceptionRecord.ExceptionFlags = 0;
                    ExceptionRecord.ExceptionRecord = NULL;
                    ExceptionRecord.ExceptionAddress = (PVOID)RtlRaiseException;
                    ExceptionRecord.NumberParameters = 1;
                    ExceptionRecord.ExceptionInformation[0] = (ULONG_PTR)Resource;
                    RtlRaiseException(&ExceptionRecord);
                    }
                else {
                    DbgBreakPoint();
                    }
                }
            DbgPrint("RTL: Re-Waiting\n");
            goto rewait;
        }
            if ( !NT_SUCCESS(Status) ) {
                RtlRaiseStatus(Status);
                }

            //
            //  Enter the critical section
            //

            RtlEnterCriticalSection(&Resource->CriticalSection);

            //
            //  If there are no shared users and it is not currently acquired
            //  for exclusive use then we can acquire the resource for
            //  exclusive access.  We can also acquire it if the resource
            //  indicates exclusive access but there isn't currently an owner
            //

            if ((Resource->NumberOfActive == 0)

                    ||

                ((Resource->NumberOfActive == -1) &&
                 (Resource->ExclusiveOwnerThread == NULL))) {

                //
                //  The resource is ours, so indicate that we have it and
                //  exit the critical section and return.
                //

                Resource->NumberOfActive = -1;

                Resource->ExclusiveOwnerThread = NtCurrentTeb()->ClientId.UniqueThread;

                RtlLeaveCriticalSection(&Resource->CriticalSection);

                return;
            }

            //
            //  Otherwise check to see if we already have exclusive access to
            //  the resource and can simply recusively acquire it again.
            //

            if (Resource->ExclusiveOwnerThread == NtCurrentTeb()->ClientId.UniqueThread) {

                //
                //  The resource is ours (recusively) so indicate that we have
                //  it and exit the critical section and return.
                //

                Resource->NumberOfActive -= 1;

                RtlLeaveCriticalSection(&Resource->CriticalSection);

                return;
            }
        }

    }

    //
    //  The resource is not currently acquired for shared so this is a
    //  spurious call
    //

#if DBG
    DbgPrint("NTDLL:  Failed error - SHARED_RESOURCE_CONV_ERROR\n");
    DbgBreakPoint();
#endif
}


VOID
RtlConvertExclusiveToShared(
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine converts a resource acquired for exclusive access into
    one acquired for shared access.  Upon return from the procedure
    the resource is acquired for shared access

Arguments:

    Resource - Supplies the resource to acquire for shared access, it
        must already be acquired for exclusive access

Return Value:

    None

--*/

{
    LONG PreviousCount;
    NTSTATUS Status;

    //
    //  Enter the critical section
    //

    RtlEnterCriticalSection(&Resource->CriticalSection);

    //
    //  If there is only one shared user (it's us) and we can acquire the
    //  resource for exclusive access.
    //

    if (Resource->NumberOfActive == -1) {

        Resource->ExclusiveOwnerThread = NULL;

        //
        //  Check to see if there are waiting shared, who should now get the
        //  resource along with us
        //

        if (Resource->NumberOfWaitingShared > 0) {

            //
            //  Set the new state to indicate that all of the shared requesters
            //  have access including us, and there are no more waiting shared
            //  requesters, and then release all of the shared requsters
            //

            Resource->NumberOfActive = Resource->NumberOfWaitingShared + 1;

            Resource->NumberOfWaitingShared = 0;

            Status = NtReleaseSemaphore(
                         Resource->SharedSemaphore,
                         Resource->NumberOfActive - 1,
                         &PreviousCount
                         );
            if ( !NT_SUCCESS(Status) ) {
                RtlRaiseStatus(Status);
                }

        } else {

            //
            //  There is no one waiting for shared access so it's only ours
            //

            Resource->NumberOfActive = 1;

        }

        RtlLeaveCriticalSection(&Resource->CriticalSection);

        return;

    }

    //
    //  The resource is not currently acquired for exclusive, or we've
    //  recursively acquired it, so this must be a spurious call
    //

#if DBG
    DbgPrint("NTDLL:  Failed error - SHARED_RESOURCE_CONV_ERROR\n");
    DbgBreakPoint();
#endif
}


VOID
RtlDeleteResource (
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine deletes (i.e., uninitializes) the input resource variable


Arguments:

    Resource - Supplies the resource variable being deleted

Return Value:

    None

--*/

{
    RtlDeleteCriticalSection( &Resource->CriticalSection );
    NtClose(Resource->SharedSemaphore);
    NtClose(Resource->ExclusiveSemaphore);

    RtlpFreeDebugInfo( Resource->DebugInfo );
    RtlZeroMemory( Resource, sizeof( *Resource ) );

    return;
}



VOID
RtlDumpResource(
    IN PRTL_RESOURCE Resource
    )

{
    DbgPrint("Resource @ %lx\n", Resource);

    DbgPrint(" NumberOfWaitingShared = %lx\n", Resource->NumberOfWaitingShared);
    DbgPrint(" NumberOfWaitingExclusive = %lx\n", Resource->NumberOfWaitingExclusive);

    DbgPrint(" NumberOfActive = %lx\n", Resource->NumberOfActive);

    return;
}


NTSTATUS
RtlInitializeCriticalSection(
    IN PRTL_CRITICAL_SECTION CriticalSection
    )

/*++

Routine Description:

    This routine initializes the input critial section variable

Arguments:

    CriticalSection - Supplies the resource variable being initialized

Return Value:

    TBD - Status of semaphore creation.

--*/

{
    return RtlInitializeCriticalSectionAndSpinCount(CriticalSection,0);
}



#define MAX_SPIN_COUNT          0x00ffffff
#define PREALLOCATE_EVENT_MASK  0x80000000

VOID
RtlEnableEarlyCriticalSectionEventCreation(
    VOID
    )
/*++

Routine Description:

    This routine marks the PEB of the calling process so critical section events
    are created at critical section creation time rather than at contetion time.
    This allows critical processes not to have to worry about error paths later
    on at the expense of extra pool consumed.

Arguments:

    None

Return Value:

    None

--*/
{
    NtCurrentPeb ()->NtGlobalFlag |= FLG_CRITSEC_EVENT_CREATION;
}



NTSTATUS
RtlInitializeCriticalSectionAndSpinCount(
    IN PRTL_CRITICAL_SECTION CriticalSection,
    ULONG SpinCount
    )

/*++

Routine Description:

    This routine initializes the input critial section variable

Arguments:

    CriticalSection - Supplies the resource variable being initialized

Return Value:

    TBD - Status of semaphore creation.

--*/

{
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;
    NTSTATUS Status;
    //
    //  Initialize the lock fields, the count indicates how many are waiting
    //  to enter or are in the critical section, LockSemaphore is the object
    //  to wait on when entering the critical section.  SpinLock is used
    //  for the add interlock instruction. Recursion count is the number of
    //  times the critical section has been recursively entered.
    //

    CriticalSection->LockCount = -1;
    CriticalSection->RecursionCount = 0;
    CriticalSection->OwningThread = 0;
    CriticalSection->LockSemaphore = 0;
    if ( NtCurrentPeb()->NumberOfProcessors > 1 ) {
        CriticalSection->SpinCount = SpinCount & MAX_SPIN_COUNT;
    } else {
        CriticalSection->SpinCount = 0;
    }



    //
    // Open the global out of memory keyed event if its not already set up.
    //
    if (GlobalKeyedEventHandle == NULL) {
        OBJECT_ATTRIBUTES oa;
        UNICODE_STRING Name;
        HANDLE Handle;

        RtlInitUnicodeString (&Name, L"\\KernelObjects\\CritSecOutOfMemoryEvent");
        InitializeObjectAttributes (&oa, &Name, 0, NULL, NULL);

        Status = NtOpenKeyedEvent (&Handle,
                                   MAXIMUM_ALLOWED,
                                   &oa);
        if (!NT_SUCCESS (Status)) {
            return Status;
        }
        if (InterlockedCompareExchangePointer (&GlobalKeyedEventHandle,
                                               RtlpSetKeyedEventHandle (Handle),
                                               NULL) != NULL) {
            Status = NtClose (Handle);
            ASSERT (NT_SUCCESS (Status));
        } else {
#if DBG
            ProtectHandle (Handle);
#endif // DBG
        }
    }
    //
    // Initialize debugging information.
    //

    DebugInfo = (PRTL_CRITICAL_SECTION_DEBUG)RtlpAllocateDebugInfo();
    if (DebugInfo == NULL) {
        return STATUS_NO_MEMORY;
    }

    DebugInfo->Type = RTL_CRITSECT_TYPE;
    DebugInfo->ContentionCount = 0;
    DebugInfo->EntryCount = 0;

    //
    // It is important to set critical section pointers and potential
    // stack trace before we insert the resource in the process' 
    // resource list because the list can be randomly traversed from
    // other threads that check for orphaned resources.
    //

    DebugInfo->CriticalSection = CriticalSection;
    CriticalSection->DebugInfo = DebugInfo;

    //
    // Try to get a stack trace. If no trace database was created
    // then the log() function is a no op.
    //

    DebugInfo->CreatorBackTraceIndex = (USHORT)RtlLogStackBackTrace();

    //
    // If the critical section lock itself is not being initialized, then
    // synchronize the insert of the critical section in the process locks
    // list. Otherwise, insert the critical section with no synchronization.
    //

    if ((CriticalSection != &RtlCriticalSectionLock) &&
         (RtlpCritSectInitialized != FALSE)) {
        RtlEnterCriticalSection(&RtlCriticalSectionLock);
        InsertTailList(&RtlCriticalSectionList, &DebugInfo->ProcessLocksList);
        RtlLeaveCriticalSection(&RtlCriticalSectionLock );

    } else {
        InsertTailList(&RtlCriticalSectionList, &DebugInfo->ProcessLocksList);
    }

    return STATUS_SUCCESS;
}


ULONG
RtlSetCriticalSectionSpinCount(
    IN PRTL_CRITICAL_SECTION CriticalSection,
    ULONG SpinCount
    )

/*++

Routine Description:

    This routine initializes the input critial section variable

Arguments:

    CriticalSection - Supplies the resource variable being initialized

Return Value:

    Returns the previous critical section spin count

--*/

{
    ULONG OldSpinCount;

    OldSpinCount = (ULONG)CriticalSection->SpinCount;

    if ( NtCurrentPeb()->NumberOfProcessors > 1 ) {
        CriticalSection->SpinCount = SpinCount;
    } else {
        CriticalSection->SpinCount = 0;
    }

    return OldSpinCount;
}


BOOLEAN
RtlpCreateCriticalSectionSem(
    IN PRTL_CRITICAL_SECTION CriticalSection
    )
{
    NTSTATUS Status, Status1;
    HANDLE SemHandle;

#if defined (RTLP_USE_GLOBAL_KEYED_EVENT)
    Status = STATUS_INSUFFICIENT_RESOURCES;
    SemHandle = NULL;
#else
    Status = NtCreateEvent (&SemHandle,
                            DESIRED_EVENT_ACCESS,
                            NULL,
                            SynchronizationEvent,
                            FALSE);

#endif
    if (NT_SUCCESS (Status)) {
        if (InterlockedCompareExchangePointer (&CriticalSection->LockSemaphore,  SemHandle, NULL) != NULL) {
            Status1 = NtClose (SemHandle);
            ASSERT (NT_SUCCESS (Status1));
        } else {
#if DBG
            ProtectHandle(SemHandle);
#endif // DBG
        }
    } else {
        ASSERT (GlobalKeyedEventHandle != NULL);
        InterlockedCompareExchangePointer (&CriticalSection->LockSemaphore,
                                           GlobalKeyedEventHandle,
                                           NULL);
    }
    return TRUE;
}

VOID
RtlpCheckDeferedCriticalSection(
    IN PRTL_CRITICAL_SECTION CriticalSection
    )
{
    if (CriticalSection->LockSemaphore == NULL) {
        RtlpCreateCriticalSectionSem(CriticalSection);
    }
    return;
}


NTSTATUS
RtlDeleteCriticalSection(
    IN PRTL_CRITICAL_SECTION CriticalSection
    )

/*++

Routine Description:

    This routine deletes (i.e., uninitializes) the input critical
    section variable


Arguments:

    CriticalSection - Supplies the resource variable being deleted

Return Value:

    TBD - Status of semaphore close.

--*/

{
    NTSTATUS Status;
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;
    HANDLE LockSemaphore;

    LockSemaphore = CriticalSection->LockSemaphore;
    if (LockSemaphore != NULL && !RtlpIsKeyedEvent (LockSemaphore)) {
#if DBG
        UnProtectHandle (LockSemaphore);
#endif // DBG
        Status = NtClose (LockSemaphore);
    } else {
        Status = STATUS_SUCCESS;
    }

    //
    // Remove critical section from the list
    //

    RtlEnterCriticalSection( &RtlCriticalSectionLock );
    try {
        DebugInfo = CriticalSection->DebugInfo;
        if (DebugInfo != NULL) {
            RemoveEntryList( &DebugInfo->ProcessLocksList );
            RtlZeroMemory( DebugInfo, sizeof( *DebugInfo ) );
        }
    } finally {
        RtlLeaveCriticalSection( &RtlCriticalSectionLock );
    }
    if (DebugInfo != NULL) {
        RtlpFreeDebugInfo( DebugInfo );
    }
    RtlZeroMemory( CriticalSection,
                   FIELD_OFFSET(RTL_CRITICAL_SECTION, SpinCount) + sizeof(ULONG) );

    return Status;
}



//
// The following support routines are called from the machine language
// implementations of RtlEnterCriticalSection and RtlLeaveCriticalSection
// to execute the slow path logic of either waiting for a critical section
// or releasing a critical section to a waiting thread.
//

void
RtlpWaitForCriticalSection(
    IN PRTL_CRITICAL_SECTION CriticalSection
    )
{
    NTSTATUS st;
    ULONG TimeoutCount = 0;
    PLARGE_INTEGER TimeoutTime;
    BOOLEAN CsIsLoaderLock;
    HANDLE LockSemaphore;

    //
    // critical sections are disabled during exit process so that
    // apps that are not carefull during shutdown don't hang
    //

    CsIsLoaderLock = (CriticalSection == &LdrpLoaderLock);
    NtCurrentTeb()->WaitingOnLoaderLock = (ULONG)CsIsLoaderLock;

    if ( LdrpShutdownInProgress &&
        ((!CsIsLoaderLock) ||
         (CsIsLoaderLock && LdrpShutdownThreadId == NtCurrentTeb()->ClientId.UniqueThread) ) ) {

        //
        // slimey reinitialization of the critical section with the count biased by one
        // this is how the critical section would normally look to the thread coming out
        // of this function. Note that the semaphore handle is leaked, but since the
        // app is exiting, it's ok
        //

        CriticalSection->LockCount = 0;
        CriticalSection->RecursionCount = 0;
        CriticalSection->OwningThread = 0;
        CriticalSection->LockSemaphore = 0;

        NtCurrentTeb()->WaitingOnLoaderLock = 0;

        return;

    }

    if (RtlpTimoutDisable) {
        TimeoutTime = NULL;
    } else {
        TimeoutTime = &RtlpTimeout;
    }

    LockSemaphore = CriticalSection->LockSemaphore;
    if (LockSemaphore == NULL) {
        RtlpCheckDeferedCriticalSection (CriticalSection);
        LockSemaphore = CriticalSection->LockSemaphore;
    }

    CriticalSection->DebugInfo->EntryCount++;
    while( TRUE ) {

        CriticalSection->DebugInfo->ContentionCount++;

#if 0
        DbgPrint( "NTDLL: Waiting for CritSect: %p  owned by ThreadId: %X  Count: %u  Level: %u\n",
                  CriticalSection,
                  CriticalSection->OwningThread,
                  CriticalSection->LockCount,
                  CriticalSection->RecursionCount
                );
#endif

        if( IsCritSecLogging(CriticalSection)){

	        PTHREAD_LOCAL_DATA pThreadLocalData = NULL;
	        PPERFINFO_TRACE_HEADER pEventHeader = NULL;
	        USHORT ReqSize = sizeof(CRIT_SEC_COLLISION_EVENT_DATA) + FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);

	        AcquireBufferLocation(&pEventHeader, &pThreadLocalData, &ReqSize );

	        if(pEventHeader && pThreadLocalData) {

		        PCRIT_SEC_COLLISION_EVENT_DATA pCritSecCollEvent = (PCRIT_SEC_COLLISION_EVENT_DATA)( (SIZE_T)pEventHeader
														           +(SIZE_T)FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data ));

		        pEventHeader->Packet.Size = ReqSize;
		        pEventHeader->Packet.HookId= (USHORT) PERFINFO_LOG_TYPE_CRITSEC_COLLISION;

		        pCritSecCollEvent->Address		    = (PVOID)CriticalSection;
		        pCritSecCollEvent->SpinCount	    = (PVOID)CriticalSection->SpinCount;
		        pCritSecCollEvent->LockCount	    = CriticalSection->LockCount;
		        pCritSecCollEvent->OwningThread	    = (PVOID)CriticalSection->OwningThread;

		        ReleaseBufferLocation(pThreadLocalData);
	        }

        }

        if (!RtlpIsKeyedEvent (LockSemaphore)) {
            st = NtWaitForSingleObject (LockSemaphore,
                                        FALSE,
                                        TimeoutTime);
        } else {
            st = NtWaitForKeyedEvent (LockSemaphore,
                                      CriticalSection,
                                      FALSE,
                                      TimeoutTime);
        }
        if ( st == STATUS_TIMEOUT ) {

            //
            // This code path will be taken only if the TimeoutTime parameter for
            // Wait() was not null.
            //

            DbgPrint( "RTL: Enter Critical Section Timeout (%I64u secs) %d\n",
                      TimeoutTime->QuadPart / (-10000000), TimeoutCount
                    );
            DbgPrint( "RTL: Pid.Tid %x.%x, owner tid %x Critical Section %p - ContentionCount == %lu\n",
                    NtCurrentTeb()->ClientId.UniqueProcess,
                    NtCurrentTeb()->ClientId.UniqueThread,
                    CriticalSection->OwningThread,
                    CriticalSection, CriticalSection->DebugInfo->ContentionCount
                    );

            TimeoutCount++;

            if ((TimeoutCount > 2) && (CriticalSection != &LdrpLoaderLock)) {
                PIMAGE_NT_HEADERS NtHeaders;

                //
                // If the image is a Win32 image, then raise an exception and try to get to the
                // uae popup
                //

                NtHeaders = RtlImageNtHeader(NtCurrentPeb()->ImageBaseAddress);

                if (NtHeaders->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_CUI ||
                    NtHeaders->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_GUI) {
                    EXCEPTION_RECORD ExceptionRecord;

                    ExceptionRecord.ExceptionCode = STATUS_POSSIBLE_DEADLOCK;
                    ExceptionRecord.ExceptionFlags = 0;
                    ExceptionRecord.ExceptionRecord = NULL;
                    ExceptionRecord.ExceptionAddress = (PVOID)RtlRaiseException;
                    ExceptionRecord.NumberParameters = 1;
                    ExceptionRecord.ExceptionInformation[0] = (ULONG_PTR)CriticalSection;
                    RtlRaiseException(&ExceptionRecord);
                } else {
                    DbgBreakPoint();
                }
            }
            DbgPrint("RTL: Re-Waiting\n");
        } else {
            if ( NT_SUCCESS(st) ) {
                //
                // If some errant thread calls SetEvent on a bogus handle
                // which happens to match the handle we are using in the critical
                // section, everything gets really messed up since two threads
                // now own the lock at the same time. ASSERT that no other thread
                // owns the lock if we have been granted ownership.
                //
                ASSERT(CriticalSection->OwningThread == 0);
                if ( CsIsLoaderLock ) {
                    CriticalSection->OwningThread = NtCurrentTeb()->ClientId.UniqueThread;
                    NtCurrentTeb()->WaitingOnLoaderLock = 0;
                }
                return;
            } else {
                RtlRaiseStatus(st);
            }
        }
    }
}

void
RtlpUnWaitCriticalSection(
    IN PRTL_CRITICAL_SECTION CriticalSection
    )
{
    NTSTATUS st;
    HANDLE LockSemaphore;

#if 0
    DbgPrint( "NTDLL: Releasing CritSect: %p  ThreadId: %X\n",
              CriticalSection, CriticalSection->OwningThread
            );
#endif

    LockSemaphore = CriticalSection->LockSemaphore;
    if (LockSemaphore == NULL) {
        RtlpCheckDeferedCriticalSection(CriticalSection);
        LockSemaphore = CriticalSection->LockSemaphore;
    }

    if (!RtlpIsKeyedEvent (LockSemaphore)) {
        st = NtSetEventBoostPriority (LockSemaphore);
    } else {
        st = NtReleaseKeyedEvent (LockSemaphore,
                                  CriticalSection,
                                  FALSE,
                                  0);
    }

    if (NT_SUCCESS (st)) {
        return;
    } else {
        RtlRaiseStatus(st);
    }
}


void
RtlpNotOwnerCriticalSection(
    IN PRTL_CRITICAL_SECTION CriticalSection
    )
{
    BOOLEAN CsIsLoaderLock;

    //
    // critical sections are disabled during exit process so that
    // apps that are not carefull during shutdown don't hang
    //

    CsIsLoaderLock = (CriticalSection == &LdrpLoaderLock);

    if ( LdrpShutdownInProgress &&
        ((!CsIsLoaderLock) ||
         (CsIsLoaderLock && LdrpShutdownThreadId == NtCurrentTeb()->ClientId.UniqueThread) ) ) {
        return;
    }

    if (NtCurrentPeb()->BeingDebugged) {
        DbgPrint( "NTDLL: Calling thread (%X) not owner of CritSect: %p  Owner ThreadId: %X\n",
                  NtCurrentTeb()->ClientId.UniqueThread,
                  CriticalSection,
                  CriticalSection->OwningThread
                );
        DbgBreakPoint();
    }
    RtlRaiseStatus( STATUS_RESOURCE_NOT_OWNED );
}


#if DBG
void
RtlpCriticalSectionIsOwned(
    IN PRTL_CRITICAL_SECTION CriticalSection
    )
{
    //
    // The loader lock gets handled differently, so don't assert on it
    //

    if ((CriticalSection == &LdrpLoaderLock) &&
        (CriticalSection->OwningThread == NtCurrentTeb()->ClientId.UniqueThread))
        return;

    //
    // If we're being debugged, throw up a warning
    //

    if (NtCurrentPeb()->BeingDebugged) {
        DbgPrint( "NTDLL: Calling thread (%X) shouldn't enter CritSect: %p  Owner ThreadId: %X\n",
                  NtCurrentTeb()->ClientId.UniqueThread,
                  CriticalSection,
                  CriticalSection->OwningThread
                );
        DbgBreakPoint();
    }
}
#endif

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////// Critical section verifier
/////////////////////////////////////////////////////////////////////

//
// This variable enables the critical section verifier (abandoned locks,
// terminatethread() while holding locks, etc.). 
//

BOOLEAN RtlpCriticalSectionVerifier;

//
// Settable from debugger to avoid a flurry of similar failures.
//

BOOLEAN RtlpCsVerifyDoNotBreak;

VOID
RtlCheckForOrphanedCriticalSections(
    IN HANDLE hThread
    )
/*++

Routine Description:

    This routine is called from kernel32's ExitThread, TerminateThread
    and SuspendThread in an effort to track calls that kill threads while 
    they own critical sections.

Arguments:

    hThread     -- thread to be killed

Return Value:

    None.

--*/
    
{
    NTSTATUS Status;
    THREAD_BASIC_INFORMATION ThreadInfo;
    PLIST_ENTRY Entry;
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;
    RTL_CRITICAL_SECTION_DEBUG ExtraDebugInfoCopy;
    PRTL_CRITICAL_SECTION CriticalSection;
    RTL_CRITICAL_SECTION CritSectCopy;

    //
    // We do not check anything if critical section verifier is not on.
    //

    if (RtlpCriticalSectionVerifier == FALSE || RtlpCsVerifyDoNotBreak == TRUE ) {
        return;
    }

    //
    // We do not do anything if we are shutting down the process.
    //

    if (LdrpShutdownInProgress) {
        return;
    }

    Status = NtQueryInformationThread (hThread,
                                       ThreadBasicInformation,
                                       &ThreadInfo,
                                       sizeof(ThreadInfo),
                                       NULL);
    if (! NT_SUCCESS(Status)) {
        return;
    }

    //
    // Iterate the global list of critical sections
    //

    RtlEnterCriticalSection( &RtlCriticalSectionLock );

    try {

        for (Entry = RtlCriticalSectionList.Flink;
            Entry != &RtlCriticalSectionList;
            Entry = Entry->Flink) {

            DebugInfo = CONTAINING_RECORD (Entry,
                                           RTL_CRITICAL_SECTION_DEBUG,
                                           ProcessLocksList);

            CriticalSection = DebugInfo->CriticalSection;

            if (CriticalSection == &RtlCriticalSectionLock ||
                CriticalSection == &LdrpLoaderLock) {

                //
                // Skip these critsects.
                //

                continue;
            }

            //
            // Call NtReadVirtualMemory() and make a copy of the critsect.
            // This won't AV and break to the debugger if the critsect's
            // memory has been freed without an RtlDeleteCriticalSection call.
            //

            Status = NtReadVirtualMemory(NtCurrentProcess(),
                                         CriticalSection,
                                         &CritSectCopy,
                                         sizeof(CritSectCopy),
                                         NULL);
            if (!NT_SUCCESS(Status)) {

                //
                // Error reading the contents of the critsect.  The critsect
                // has probably been decommitted without a call to
                // RtlDeleteCriticalSection.
                //
                // You might think the entry could be deleted from the list,
                // but it can't... there may be another RTL_CRITICAL_SECTION
                // out there that is truly allocated, and who DebugInfo pointer
                // points at this DebugInfo.  In that case, when that critsect
                // is deleted, the RtlCriticalSectionList is corrupted.
                //
                // We will skip over null critical sections since there is 
                // a small window in RtlInitializeCriticalSection where this can happen.
                //

                if (CriticalSection) {

                    VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_IN_FREED_MEMORY,
                                   "undeleted critical section in freed memory",
                                   CriticalSection, "Critical section address",
                                   DebugInfo, "Critical section debug info address",
                                   RtlpGetStackTraceAddress (DebugInfo->CreatorBackTraceIndex), 
                                   "Initialization stack trace. Use dds to dump it if non-NULL.",
                                   NULL, "" );
                }
            }
            else if(CritSectCopy.DebugInfo != DebugInfo) {

                //
                // Successfully read the critical section structure but
                // the current debug info field of this critical section doesn't point
                // to the current DebugInfo - it was probably initialized more than
                // one time or simply corrupted.
                // 
                // Try to make a copy of the DebugInfo currently pointed 
                // by our critical section. This might fail if the critical section is
                // corrupted.
                //

                Status = NtReadVirtualMemory(NtCurrentProcess(),
                                             CritSectCopy.DebugInfo,
                                             &ExtraDebugInfoCopy,
                                             sizeof(ExtraDebugInfoCopy),
                                             NULL);

                if (!NT_SUCCESS(Status)) {

                    //
                    // Error reading the contents of the debug info.
                    // The current critical section structure is corrupted.
                    //

                    VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_CORRUPTED,
                                   "corrupted critical section",
                                   CriticalSection, 
                                   "Critical section address",
                                   CritSectCopy.DebugInfo, 
                                   "Invalid debug info address of this critical section",
                                   DebugInfo, 
                                   "Address of the debug info found in the active list.",
                                   RtlpGetStackTraceAddress (DebugInfo->CreatorBackTraceIndex), 
                                   "Initialization stack trace. Use dds to dump it if non-NULL." );
                }
                else {

                    // 
                    // Successfully read this second debug info 
                    // of the same critical section. 
                    //

                    VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_DOUBLE_INITIALIZE,
                                   "double initialized or corrupted critical section",
                                   CriticalSection, 
                                   "Critical section address.",
                                   DebugInfo, 
                                   "Address of the debug info found in the active list.",
                                   RtlpGetStackTraceAddress (DebugInfo->CreatorBackTraceIndex), 
                                   "First initialization stack trace. Use dds to dump it if non-NULL.",
                                   RtlpGetStackTraceAddress (ExtraDebugInfoCopy.CreatorBackTraceIndex), 
                                   "Second initialization stack trace. Use dds to dump it if non-NULL.");
                }
            }
            else if (CritSectCopy.OwningThread == ThreadInfo.ClientId.UniqueThread
                     && CritSectCopy.LockCount != -1) {

                    //
                    // The thread is about to die with a critical section locked.
                    //

                    VERIFIER_STOP (APPLICATION_VERIFIER_EXIT_THREAD_OWNS_LOCK,
                                   "Thread is terminated while owning a critical section",
                                   ThreadInfo.ClientId.UniqueThread, "Thread identifier",
                                   CriticalSection, "Critical section address",
                                   DebugInfo, "Critical section debug info address",
                                   RtlpGetStackTraceAddress (DebugInfo->CreatorBackTraceIndex), "Initialization stack trace. Use dds to dump it if non-NULL." );
                }
        }
    }
    finally {

        //
        // Release the CS list lock.
        //

        RtlLeaveCriticalSection( &RtlCriticalSectionLock );
    }
}


VOID
RtlpCheckForCriticalSectionsInMemoryRange(
    IN PVOID StartAddress,
    IN SIZE_T RegionSize,
    IN PVOID Information
    )
/*++

Routine Description:

    This routine is called from the loader unload code paths and heap manager
    deallocation code paths to make sure that no critical section is discarded
    before the RtlDeleteCriticalSection() routine has been called.

Arguments:

    StartAddress - start of the memory region that will become invalid.
    
    RegionSize - size of the memory region that will become invalid.

Return Value:

    None. If the function finds something it will break into debugger.

--*/

{
    NTSTATUS Status;
    PLIST_ENTRY Entry;
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;
    PRTL_CRITICAL_SECTION CriticalSection;
    PVOID TraceAddress = NULL;

    //
    // If lock verifier is not active we do nothing.
    //

    if (RtlpCriticalSectionVerifier == FALSE || RtlpCsVerifyDoNotBreak == TRUE) {
        return;
    }

    //
    // Skip if we are shutting down the process.
    //
     
    if (LdrpShutdownInProgress) {
        
        return;
    }

    //
    // Grab the CS list lock.
    //

    RtlEnterCriticalSection( &RtlCriticalSectionLock );

    //
    // Iterate the CS list.
    //

    try {


        for (Entry = RtlCriticalSectionList.Flink;
            Entry != &RtlCriticalSectionList;
            Entry = Entry->Flink) {

            DebugInfo = CONTAINING_RECORD(Entry,
                                          RTL_CRITICAL_SECTION_DEBUG,
                                          ProcessLocksList);

            CriticalSection = DebugInfo->CriticalSection;

            if (CriticalSection == &RtlCriticalSectionLock ||
                CriticalSection == &LdrpLoaderLock) {

                //
                // Skip the CS list lock and the loader lock.
                //

                continue;
            }

            if ((SIZE_T)CriticalSection >= (SIZE_T)StartAddress &&
                (SIZE_T)CriticalSection < (SIZE_T)StartAddress + RegionSize) {

                //
                // Ooops, we have found a CS live in a memory region that will
                // be discarded.
                //

                TraceAddress = RtlpGetStackTraceAddress (DebugInfo->CreatorBackTraceIndex);

                if (Information == NULL) {

                    //
                    // We are releasing a heap block that contains this critical section
                    //

                    VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_IN_FREED_HEAP,
                                   "releasing heap allocation containing active critical section",
                                   CriticalSection, "Critical section address",
                                   TraceAddress, "Initialization stack trace. Use dds to dump it if non-NULL.",
                                   StartAddress, "Heap block address",
                                   RegionSize, "Heap block size" );

                }
                else {

                    //
                    // We are unloading a DLL that contained this critical section
                    //

                    VERIFIER_STOP (APPLICATION_VERIFIER_LOCK_IN_UNLOADED_DLL,
                                   "unloading dll containing active critical section",
                                   CriticalSection, "Critical section address",
                                   TraceAddress, "Initialization stack trace. Use dds to dump it if non-NULL.",
                                   ((PLDR_DATA_TABLE_ENTRY)Information)->BaseDllName.Buffer, "DLL name address (use `du ADDRESS' to dump if not null)",
                                   StartAddress, "DLL base address",
                                   );

                }
            }
        }
    }
    finally {

        //
        // Release the CS list lock.
        //

        RtlLeaveCriticalSection( &RtlCriticalSectionLock );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\sxsctxact.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sxsctxact.c

Abstract:

    Side-by-side activation support for Windows/NT
    Implementation of context activation/deactivation

Author:

    Michael Grier (MGrier) 2/2/2000

Revision History:

--*/

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <sxstypes.h>
#include "sxsp.h"

#if NT_SXS_PERF_COUNTERS_ENABLED
#if defined(_X86_)
__inline
ULONGLONG
RtlpGetCycleCount(void)
{
	__asm {
		RDTSC
	}
}
#else
__inline
ULONGLONG
RtlpGetCycleCount(void)
{
    return 0;
}
#endif // defined(_X86_)
#endif // NT_SXS_PERF_COUNTERS_ENABLED

// DWORD just so that in the debugger we don't have to guess the size...
ULONG RtlpCaptureActivationContextActivationStacks = 
#if DBG
    TRUE
#else
    FALSE
#endif
;


//
// APPCOMPAT: Setting this flag to TRUE indicates that we no longer allow
// skipping over "unactivated" (ie: multiple activation) context frames.
// The default action should be FALSE, which will let mutliply-activated
// contexts slide by.
//
// WARNING: This allows app authors to be a little sleazy about their activate
// and deactivate pairs.
//
BOOLEAN RtlpNotAllowingMultipleActivation = FALSE;

NTSTATUS
RtlpAllocateActivationContextStackFrame(
    IN ULONG Flags,
    PTEB Teb,
    OUT PRTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME *FrameOut
    )
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;
    LIST_ENTRY *ple;
    PRTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame = NULL;
    ULONG i;

    if (FrameOut != NULL)
        *FrameOut = NULL;

    ASSERT((Flags == 0) && (FrameOut != NULL) && (Teb != NULL));
    if ((Flags != 0) || (FrameOut == NULL) || (Teb == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    for (ple = Teb->ActivationContextStack.FrameListCache.Flink; ple != &Teb->ActivationContextStack.FrameListCache; ple = ple->Flink) {
        PACTIVATION_CONTEXT_STACK_FRAMELIST FrameList = CONTAINING_RECORD(ple, ACTIVATION_CONTEXT_STACK_FRAMELIST, Links);

        for (i=0; i<RTL_NUMBER_OF(FrameList->Frames); i++) {
            if (FrameList->Frames[i].Frame.Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ON_FREE_LIST) {
                ASSERT(FrameList->FramesInUse != NUMBER_OF(FrameList->Frames));
                FrameList->FramesInUse++;
                Frame = &FrameList->Frames[i];
                break;
            }
        }

        if (Frame != NULL)
            break;
    }

    if (Frame == NULL) {
        // No space left; allocate a new framelist...
        PACTIVATION_CONTEXT_STACK_FRAMELIST FrameList = RtlAllocateHeap(RtlProcessHeap(), 0, sizeof(ACTIVATION_CONTEXT_STACK_FRAMELIST));

        if (FrameList == NULL) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }

        for (i=0; i<RTL_NUMBER_OF(FrameList->Frames); i++) {
            FrameList->Frames[i].Frame.Previous = NULL;
            FrameList->Frames[i].Frame.ActivationContext = NULL;
            FrameList->Frames[i].Frame.Flags = RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ON_FREE_LIST | RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED;
            FrameList->Frames[i].Cookie = 0;
        }

        Frame = &FrameList->Frames[0];

        FrameList->FramesInUse = 1;

        InsertHeadList(&Teb->ActivationContextStack.FrameListCache, &FrameList->Links);
    }

    ASSERT((Frame != NULL) && (Frame->Frame.Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ON_FREE_LIST));

    Frame->Frame.Flags = RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED;
    *FrameOut = Frame;
    Status = STATUS_SUCCESS;

Exit:
    return Status;
}

VOID
RtlpFreeActivationContextStackFrame(
    PRTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame
    )
{
    LIST_ENTRY *ple = NULL;
    PTEB Teb = NtCurrentTeb();

    ASSERT(Frame != NULL);
    if (Frame != NULL) {
        // If this assert fires, someone's trying to free an already freed frame.  Or someone's set the
        // "I'm on the free list" flag in the frame data.
        ASSERT(!(Frame->Frame.Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ON_FREE_LIST));
        if (!(Frame->Frame.Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ON_FREE_LIST)) {
            for (ple = Teb->ActivationContextStack.FrameListCache.Flink; ple != &Teb->ActivationContextStack.FrameListCache; ple = ple->Flink) {
                PACTIVATION_CONTEXT_STACK_FRAMELIST FrameList = CONTAINING_RECORD(ple, ACTIVATION_CONTEXT_STACK_FRAMELIST, Links);

                // A frame list with zero frames shouldn't be on the list!
                ASSERT(FrameList->FramesInUse > 0);

                if ((Frame >= &FrameList->Frames[0]) &&
                    (Frame < &FrameList->Frames[RTL_NUMBER_OF(FrameList->Frames)])) {
                    // It's in this frame list; look for it!
                    ULONG i = (ULONG)(Frame - FrameList->Frames);

                    // If this assert fires, it means that the frame pointer passed in should have been a frame
                    // in this framelist, but it actually didn't point to any of the array entries exactly.
                    // Probably someone munged the pointer.
                    ASSERT(Frame == &FrameList->Frames[i]);

                    if ((Frame == &FrameList->Frames[i]) && (FrameList->FramesInUse > 0)) {
                        FrameList->FramesInUse--;

                        Frame->Frame.Flags = RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ON_FREE_LIST;

                        if (FrameList->FramesInUse == 0) {
                            RemoveEntryList(ple);
                            RtlFreeHeap(RtlProcessHeap(), 0, FrameList);
                        }
                    }

                    // No sense continuing the search on the list; we've found the one.
                    break;
                }
            }

            // If we ran off the end of the list, it must have been a bogus frame pointer.
            ASSERT(ple != &Teb->ActivationContextStack.FrameListCache);
        }
    }
}



#if !defined(INVALID_HANDLE_VALUE)
#define INVALID_HANDLE_VALUE ((HANDLE)(LONG_PTR)-1)
#endif // !defined(INVALID_HANDLE_VALUE)

//
//  Define magic cookie values returned by RtlActivateActivationContext*() that
//  represent a failure to activate the requested context.  The notable thing
//  is that on deactivation via the cookie, we need to know whether to leave
//  querying disabled or whether to enable it, thus the two magic values.
//

// The top nibble of the cookie denotes its type: normal, default-pushed or failed
#define ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE_NORMAL                        (1)
#define ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE_DUPLICATE_ACTIVATION          (2)

#define ULONG_PTR_IZE(_x) ((ULONG_PTR) (_x))
#define ULONG_PTR_IZE_SHIFT_AND_MASK(_x, _shift, _mask) ((ULONG_PTR) ((ULONG_PTR_IZE((_x)) & (_mask)) << (_shift)))

//
//  We only use the lower 12 bits of the thread id, but that should be unique enough;
//  this is really for debugging aids; if your tests pass such that you're
//  erroneously passing activation context cookies between threads that happen to
//  match up in their lower 12 bits of their thread id, you're pretty darned
//  lucky.
//

#define CHAR_BITS 8

#define BIT_LENGTH(x) (sizeof(x) * CHAR_BITS)

#define ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE_BIT_LENGTH (4)
#define ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE_BIT_OFFSET (BIT_LENGTH(PVOID) - ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE_BIT_LENGTH)
#define ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE_BIT_MASK ((1 << ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE_BIT_LENGTH) - 1)

#define ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TID_BIT_LENGTH ((BIT_LENGTH(PVOID) / 2) - ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE_BIT_LENGTH)
#define ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TID_BIT_OFFSET (ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE_BIT_OFFSET - ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TID_BIT_LENGTH)
#define ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TID_BIT_MASK ((1 << ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TID_BIT_LENGTH) - 1)

#define ACTIVATION_CONTEXT_ACTIVATION_COOKIE_CODE_BIT_LENGTH (BIT_LENGTH(PVOID) - (ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE_BIT_LENGTH + ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TID_BIT_LENGTH))
#define ACTIVATION_CONTEXT_ACTIVATION_COOKIE_CODE_BIT_OFFSET (0)
#define ACTIVATION_CONTEXT_ACTIVATION_COOKIE_CODE_BIT_MASK ((1 << ACTIVATION_CONTEXT_ACTIVATION_COOKIE_CODE_BIT_LENGTH) - 1)

// Never try to use more than 32 bits for the TID field.
C_ASSERT(ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TID_BIT_LENGTH <= BIT_LENGTH(ULONG));

#define MAKE_ACTIVATION_CONTEXT_ACTIVATION_COOKIE(_type, _teb, _code) \
    ((ULONG_PTR) ( \
        ULONG_PTR_IZE_SHIFT_AND_MASK((_type), ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE_BIT_OFFSET, ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE_BIT_MASK) | \
        ULONG_PTR_IZE_SHIFT_AND_MASK((HandleToUlong((_teb)->ClientId.UniqueThread)), ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TID_BIT_OFFSET, ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TID_BIT_MASK) | \
        ULONG_PTR_IZE_SHIFT_AND_MASK((_code), ACTIVATION_CONTEXT_ACTIVATION_COOKIE_CODE_BIT_OFFSET, ACTIVATION_CONTEXT_ACTIVATION_COOKIE_CODE_BIT_MASK)))

#define EXTRACT_ACTIVATION_CONTEXT_ACTIVATION_COOKIE_FIELD(_x, _fieldname) (ULONG_PTR_IZE((ULONG_PTR_IZE((_x)) >> ACTIVATION_CONTEXT_ACTIVATION_COOKIE_ ## _fieldname ## _BIT_OFFSET)) & ACTIVATION_CONTEXT_ACTIVATION_COOKIE_ ## _fieldname ## _BIT_MASK)

#define EXTRACT_ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE(_x) EXTRACT_ACTIVATION_CONTEXT_ACTIVATION_COOKIE_FIELD((_x), TYPE)
#define EXTRACT_ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TID(_x) EXTRACT_ACTIVATION_CONTEXT_ACTIVATION_COOKIE_FIELD((_x), TID)
#define EXTRACT_ACTIVATION_CONTEXT_ACTIVATION_COOKIE_CODE(_x) EXTRACT_ACTIVATION_CONTEXT_ACTIVATION_COOKIE_FIELD((_x), CODE)

#define ACTIVATION_CONTEXT_TRUNCATED_TID_(_teb) (HandleToUlong((_teb)->ClientId.UniqueThread) & ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TID_BIT_MASK)
#define ACTIVATION_CONTEXT_TRUNCATED_TID() ACTIVATION_CONTEXT_TRUNCATED_TID_(NtCurrentTeb())

PACTIVATION_CONTEXT
RtlpMapSpecialValuesToBuiltInActivationContexts(
    PACTIVATION_CONTEXT ActivationContext
    )
{
    if (ActivationContext == ACTCTX_EMPTY) {
        ActivationContext = &RtlpTheEmptyActivationContext;
    }
    return ActivationContext;
}

// Disable FPO optimization so that captured call stacks are more complete
#if defined(_X86_)
#pragma optimize( "y", off )    // disable FPO for consistent stack traces
#endif

NTSTATUS
NTAPI
RtlActivateActivationContext(
    ULONG Flags,
    PACTIVATION_CONTEXT ActivationContext,
    ULONG_PTR *CookieOut
    )
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;

    ASSERT(Flags == 0);
    ASSERT(CookieOut != NULL);

    if (CookieOut != NULL)
        *CookieOut = INVALID_ACTIVATION_CONTEXT_ACTIVATION_COOKIE;

    if ((Flags != 0) || (CookieOut == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (!NT_SUCCESS(Status = RtlActivateActivationContextEx(
                0,
                NtCurrentTeb(),
                ActivationContext,
                CookieOut)))
        goto Exit;

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

NTSTATUS
NTAPI
RtlActivateActivationContextEx(
    ULONG Flags,
    PTEB Teb,
    PACTIVATION_CONTEXT ActivationContext,
    ULONG_PTR *Cookie
    )
{
#if NT_SXS_PERF_COUNTERS_ENABLED
	ULONGLONG InitialCycleCount = RtlpGetCycleCount();
#endif
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG_PTR NewCookie = INVALID_ACTIVATION_CONTEXT_ACTIVATION_COOKIE;
    PRTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame;
    ULONG CapturedFrameCount, CapturedFrameHash;

    ASSERT(Cookie != NULL);

    if (Cookie != NULL)
        *Cookie = INVALID_ACTIVATION_CONTEXT_ACTIVATION_COOKIE;

    ASSERT((Flags & ~(RTL_ACTIVATE_ACTIVATION_CONTEXT_EX_FLAG_RELEASE_ON_STACK_DEALLOCATION)) == 0);
    ASSERT(Teb != NULL);
    ASSERT(ActivationContext != INVALID_HANDLE_VALUE);

    ActivationContext = RtlpMapSpecialValuesToBuiltInActivationContexts(ActivationContext);

    if (((Flags & ~(RTL_ACTIVATE_ACTIVATION_CONTEXT_EX_FLAG_RELEASE_ON_STACK_DEALLOCATION)) != 0) ||
        (Teb == NULL) ||
        (ActivationContext == INVALID_HANDLE_VALUE) ||
        (Cookie == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Status = RtlpAllocateActivationContextStackFrame(0, Teb, &Frame);
    if (!NT_SUCCESS(Status))
        goto Exit;

    Frame->Frame.Flags = RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED;

    if (Flags & RTL_ACTIVATE_ACTIVATION_CONTEXT_EX_FLAG_RELEASE_ON_STACK_DEALLOCATION) {
        Frame->Frame.Flags |= RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_NO_DEACTIVATE |
                              RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_RELEASE_ON_DEACTIVATION;
        RtlAddRefActivationContext(ActivationContext);
    }

    if (RtlpCaptureActivationContextActivationStacks)
        CapturedFrameCount = RtlCaptureStackBackTrace(2, NUMBER_OF(Frame->ActivationStackBackTrace), Frame->ActivationStackBackTrace, &CapturedFrameHash);
    else
        CapturedFrameCount = 0;

    while (CapturedFrameCount < NUMBER_OF(Frame->ActivationStackBackTrace))
        Frame->ActivationStackBackTrace[CapturedFrameCount++] = NULL;

    Frame->Frame.Previous = Teb->ActivationContextStack.ActiveFrame;
    Frame->Frame.ActivationContext = ActivationContext;

    NewCookie = MAKE_ACTIVATION_CONTEXT_ACTIVATION_COOKIE(ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE_NORMAL, Teb, Teb->ActivationContextStack.NextCookieSequenceNumber);
    Teb->ActivationContextStack.NextCookieSequenceNumber++;
    Frame->Cookie = NewCookie;
    *Cookie = NewCookie;
    Teb->ActivationContextStack.ActiveFrame = &Frame->Frame;

    Status = STATUS_SUCCESS;

Exit:
#if NT_SXS_PERF_COUNTERS_ENABLED
    Teb->ActivationContextCounters.ActivationCycles += RtlpGetCycleCount() - InitialCycleCount;
	Teb->ActivationContextCounters.Activations++;
#endif // NT_SXS_PERF_COUNTERS_ENABLED

	return Status;
}

#if defined(_X86_)
#pragma optimize("", on)
#endif

VOID
NTAPI
RtlDeactivateActivationContext(
    ULONG Flags,
    ULONG_PTR Cookie
    )
{
#if NT_SXS_PERF_COUNTERS_ENABLED
	ULONGLONG InitialCycleCount = RtlpGetCycleCount();
#endif // NT_SXS_PERF_COUNTERS_ENABLED
    PTEB Teb = NtCurrentTeb();
    PRTL_ACTIVATION_CONTEXT_STACK_FRAME Frame;
    PRTL_ACTIVATION_CONTEXT_STACK_FRAME UnwindEndFrame;
    PRTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME HeapFrame = NULL;

    if ((Flags & ~(RTL_DEACTIVATE_ACTIVATION_CONTEXT_FLAG_FORCE_EARLY_DEACTIVATION)) != 0) {
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "SXS: %s() called with invalid flags 0x%08lx\n", __FUNCTION__, Flags);
        RtlRaiseStatus(STATUS_INVALID_PARAMETER);
    }

    // Fast exit
    if (Cookie == INVALID_ACTIVATION_CONTEXT_ACTIVATION_COOKIE)
        return;

    if (EXTRACT_ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE(Cookie) != ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TYPE_NORMAL) {
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "SXS: %s() called with invalid cookie type 0x%08I64x\n", __FUNCTION__, Cookie);
        RtlRaiseStatus(STATUS_INVALID_PARAMETER);
    }

    if (EXTRACT_ACTIVATION_CONTEXT_ACTIVATION_COOKIE_TID(Cookie) != ACTIVATION_CONTEXT_TRUNCATED_TID()) {
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "SXS: %s() called with invalid cookie tid 0x%08I64x - should be %08lx\n", __FUNCTION__, Cookie, ACTIVATION_CONTEXT_TRUNCATED_TID());
        RtlRaiseStatus(STATUS_INVALID_PARAMETER);
    }

    Frame = (PRTL_ACTIVATION_CONTEXT_STACK_FRAME) Teb->ActivationContextStack.ActiveFrame;
    // Do the "downcast", but don't use HeapFrame unless the RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED
    // flag is set...
    if (Frame != NULL) {
        HeapFrame = (Frame->Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED) ? CONTAINING_RECORD(Frame, RTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME, Frame) : NULL;
    }

    RTL_SOFT_ASSERT((Frame != NULL) && (Frame->Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED) && (HeapFrame->Cookie == Cookie));

    if (Frame != NULL)
    {
        if (((Frame->Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED) == 0) ||
            (HeapFrame->Cookie != Cookie))
        {
            ULONG InterveningFrameCount = 0;

            // The cookie wasn't current.  Let's see if we can figure out what frame it was for...

            PRTL_ACTIVATION_CONTEXT_STACK_FRAME CandidateFrame = Frame->Previous;
            PRTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME CandidateHeapFrame =
                (CandidateFrame != NULL) ?
                    (CandidateFrame->Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED) ?
                        CONTAINING_RECORD(CandidateFrame, RTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME, Frame) :
                        NULL :
                    NULL;

            while ((CandidateFrame != NULL) &&
                   ((CandidateHeapFrame == NULL) ||
                    (CandidateHeapFrame->Cookie != Cookie))) {
                InterveningFrameCount++;
                CandidateFrame = CandidateFrame->Previous;
                CandidateHeapFrame =
                    (CandidateFrame != NULL) ?
                        (CandidateFrame->Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED) ?
                            CONTAINING_RECORD(CandidateFrame, RTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME, Frame) :
                            NULL :
                        NULL;
            }

            RTL_SOFT_ASSERT(CandidateFrame != NULL);
            if (CandidateFrame == NULL) {
                RtlRaiseStatus(STATUS_SXS_INVALID_DEACTIVATION);
            } else {
                // Otherwise someone left some dirt around.

                EXCEPTION_RECORD ExceptionRecord;

                ExceptionRecord.ExceptionRecord = NULL;
                ExceptionRecord.NumberParameters = 3;
                ExceptionRecord.ExceptionInformation[0] = InterveningFrameCount;
                ExceptionRecord.ExceptionInformation[1] = (ULONG_PTR) CandidateFrame;
                ExceptionRecord.ExceptionInformation[2] = (ULONG_PTR) Teb->ActivationContextStack.ActiveFrame;
                ExceptionRecord.ExceptionCode = STATUS_SXS_EARLY_DEACTIVATION;
                ExceptionRecord.ExceptionFlags = 0; // this exception *is* continuable since we can actually put the activation stack into a reasonable state
                RtlRaiseException(&ExceptionRecord);

                // If they continue the exception, just do the unwinds.

                UnwindEndFrame = CandidateFrame->Previous;
            }
        } else
            UnwindEndFrame = Frame->Previous;

        do {
            PRTL_ACTIVATION_CONTEXT_STACK_FRAME Previous = Frame->Previous;

            // This is a weird one.  A no-deactivate frame is typically only used to propogate
            // active activation context state to a newly created thread.  As such, it'll always
            // be the topmost frame... thus how did we come to decide to deactivate it?

            ASSERTMSG(
                "Unwinding through a no-deactivate frame",
                !(Frame->Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_NO_DEACTIVATE));

            if (Frame->Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_RELEASE_ON_DEACTIVATION) {
                RtlReleaseActivationContext(Frame->ActivationContext);
            }

            if (Frame->Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED) {
                RtlpFreeActivationContextStackFrame(CONTAINING_RECORD(Frame, RTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME, Frame));
            }

            Frame = Previous;
        } while (Frame != UnwindEndFrame);

        Teb->ActivationContextStack.ActiveFrame = UnwindEndFrame;
    }

#if NT_SXS_PERF_COUNTERS_ENABLED
	Teb->ActivationContextCounters.DeactivationCycles += RtlpGetCycleCount() - InitialCycleCount;
	Teb->ActivationContextCounters.Deactivations++;
#endif
}

VOID
RtlActivateActivationContextUnsafeFast(
    PRTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame,
    PACTIVATION_CONTEXT ActivationContext
    )
{
    const PTEB Teb = NtCurrentTeb();
    const PRTL_ACTIVATION_CONTEXT_STACK_FRAME pStackFrame = 
        (PRTL_ACTIVATION_CONTEXT_STACK_FRAME)Teb->ActivationContextStack.ActiveFrame;
    ASSERT(Frame->Format == RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER);
    ASSERT(Frame->Size >= sizeof(RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME));

    if ( ( ( ( pStackFrame == NULL ) && ( ActivationContext == NULL ) ) ||
        ( pStackFrame && ( pStackFrame->ActivationContext == ActivationContext ) ) )
        && !RtlpNotAllowingMultipleActivation )
    {
        // this uses too much stack in stress
        //DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() Not really activating\n", __FUNCTION__ );
        Frame->Frame.Flags |= RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_NOT_REALLY_ACTIVATED;
    }
    else
    {
        // this uses too much stack in stress
        //DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() Really activating\n", __FUNCTION__ );
        Frame->Frame.Previous = Teb->ActivationContextStack.ActiveFrame;
        Frame->Frame.ActivationContext = ActivationContext;
        Frame->Frame.Flags = 0;
        Teb->ActivationContextStack.ActiveFrame = &Frame->Frame;
    }
}

VOID
RtlDeactivateActivationContextUnsafeFast(
    PRTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame
    )
{
    const PTEB Teb = NtCurrentTeb();

    //
    // Was this "not really activated" above (AppCompat problem) from above?
    //
    if ( !RtlpNotAllowingMultipleActivation &&
        ( ( Frame->Frame.Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_NOT_REALLY_ACTIVATED ) != 0 ) )
    {
        return;
    }
    // Make sure that the deactivation matches.  If it does not (the exceptional
    // condition) we'll throw an exception to make people deal with their
    // coding errors.
    else if (Teb->ActivationContextStack.ActiveFrame != &Frame->Frame) 
    {
        EXCEPTION_RECORD ExceptionRecord;
        ULONG InterveningFrameCount = 0;

        // What's the deal?  Look to see if we're further up the stack.
        // Actually, what we'll do is see if we can find our parent up the stack.
        // This will also handle the double-deactivation case and let us continue
        // nicely.

        PRTL_ACTIVATION_CONTEXT_STACK_FRAME SearchFrame = Teb->ActivationContextStack.ActiveFrame;
        const PRTL_ACTIVATION_CONTEXT_STACK_FRAME Previous = Frame->Frame.Previous;

        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() Active frame is not the frame being deactivated %p != %p\n",
            __FUNCTION__,
            Teb->ActivationContextStack.ActiveFrame,
            &Frame->Frame);
        
        while ((SearchFrame != NULL) && (SearchFrame != Previous)) {
            InterveningFrameCount++;
            SearchFrame = SearchFrame->Previous;
        }

        ExceptionRecord.ExceptionRecord = NULL;
        ExceptionRecord.NumberParameters = 3;
        ExceptionRecord.ExceptionInformation[0] = InterveningFrameCount;
        ExceptionRecord.ExceptionInformation[1] = (ULONG_PTR) &Frame->Frame;
        ExceptionRecord.ExceptionInformation[2] = (ULONG_PTR) Teb->ActivationContextStack.ActiveFrame;

        if (SearchFrame != NULL) {
            // We're there.  That's actually good; it just probably means that a function that our caller called
            // activated an activation context and forgot to deactivate.  Throw the exception and if it's continued,
            // we're good to go.

            if (InterveningFrameCount == 0) {
                // Wow, the frame-to-deactivate's previous is the active one.  It must be that the caller
                // already deactivated and is now deactivating again.
                ExceptionRecord.ExceptionCode = STATUS_SXS_MULTIPLE_DEACTIVATION;
            } else {
                // Otherwise someone left some dirt around.
                ExceptionRecord.ExceptionCode = STATUS_SXS_EARLY_DEACTIVATION;
            }

            ExceptionRecord.ExceptionFlags = 0; // this exception *is* continuable since we can actually put the activation stack into a reasonable state
        } else {
            // It wasn't there.  It's almost certainly the wrong thing to try to set this
            ExceptionRecord.ExceptionCode = STATUS_SXS_INVALID_DEACTIVATION;
            ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE; // this exception is NOT continuable
        }

        RtlRaiseException(&ExceptionRecord);
    }

    Teb->ActivationContextStack.ActiveFrame = Frame->Frame.Previous;

}

NTSTATUS
NTAPI
RtlGetActiveActivationContext(
    PACTIVATION_CONTEXT *ActivationContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PTEB Teb = NULL;
    PACTIVATION_CONTEXT_STACK Stack = NULL;
    PRTL_ACTIVATION_CONTEXT_STACK_FRAME Frame = NULL;

    if (ActivationContext != NULL)
        *ActivationContext = NULL;

    if (ActivationContext == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Teb = NtCurrentTeb();
    Frame = (PRTL_ACTIVATION_CONTEXT_STACK_FRAME) Teb->ActivationContextStack.ActiveFrame;

    if (Frame != NULL) {
        RtlAddRefActivationContext(Frame->ActivationContext);
        *ActivationContext = Frame->ActivationContext;
    }

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

VOID
NTAPI
RtlFreeThreadActivationContextStack(
    VOID
    )
{
    PTEB Teb = NtCurrentTeb();
    PRTL_ACTIVATION_CONTEXT_STACK_FRAME Frame = (PRTL_ACTIVATION_CONTEXT_STACK_FRAME) Teb->ActivationContextStack.ActiveFrame;

    while (Frame != NULL) {
        PRTL_ACTIVATION_CONTEXT_STACK_FRAME Previous = Frame->Previous;

        // Release any lingering frames.  The notable case when this happens is when a thread that
        // has a non-default activation context active creates another thread which inherits the
        // first thread's activation context, adding a reference to the activation context.  When
        // the new thread eventually dies, that initial frame is still active.

        if (Frame->Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_RELEASE_ON_DEACTIVATION) {
            RtlReleaseActivationContext(Frame->ActivationContext);
        }

        if (Frame->Flags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED) {
            RtlpFreeActivationContextStackFrame(CONTAINING_RECORD(Frame, RTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME, Frame));
        }

        Frame = Previous;
    }

    Teb->ActivationContextStack.ActiveFrame = NULL;
}

BOOLEAN
NTAPI
RtlIsActivationContextActive(
    PACTIVATION_CONTEXT ActivationContext
    )
{
    PTEB Teb = NtCurrentTeb();
    PRTL_ACTIVATION_CONTEXT_STACK_FRAME Frame = (PRTL_ACTIVATION_CONTEXT_STACK_FRAME) Teb->ActivationContextStack.ActiveFrame;

    while (Frame != NULL) {
        if (Frame->ActivationContext == ActivationContext) {
            return TRUE;
        }

        Frame = Frame->Previous;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\sxsp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sxsp.h

Abstract:

    Include file for ntdll-private definitions of Side-By-Side data structures.

Author:

    Michael J. Grier (mgrier) October 26, 2000

Environment:


Revision History:

--*/

#if !defined(_NTDLL_SXSP_H_INCLUDED_)
#define _NTDLL_SXSP_H_INCLUDED_

#include <nturtl.h>
#include <sxstypes.h>

//
//  Private definitions for activation context management stuff
//

#define NUMBER_OF(x) (sizeof(x) / sizeof((x)[0]))

//
//  Codes for the STATUS_SXS_CORRUPTION exception
//

#define SXS_CORRUPTION_CODE_FRAMELIST (1)
#define SXS_CORRUPTION_CODE_FRAMELIST_SUBCODE_BAD_MAGIC (1)
#define SXS_CORRUPTION_CODE_FRAMELIST_SUBCODE_BAD_INUSECOUNT (2)

//  SXS_CORRUPTION_CODE_FRAMELIST:
//
//      ExceptionInformation[0] == SXS_CORRUPTION_CODE_FRAMELIST
//      ExceptionInformation[1] == one of: SXS_CORRUPTION_CODE_FRAMELIST_SUBCODE_BAD_MAGIC, SXS_CORRUPTION_CODE_FRAMELIST_SUBCODE_BAD_INUSECOUNT
//      ExceptionInformation[2] == Framelist list head in TEB
//      ExceptionInformation[3] == Framelist found to be corrupt


typedef struct _RTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME {
    RTL_ACTIVATION_CONTEXT_STACK_FRAME Frame;
    ULONG_PTR Cookie;
    PVOID ActivationStackBackTrace[8];
} RTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME, *PRTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME;

NTSYSAPI
VOID
NTAPI
RtlpAssemblyStorageMapResolutionDefaultCallback(
    IN ULONG CallbackReason,
    IN OUT ASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_DATA *CallbackData,
    IN PVOID CallbackContext
    );

typedef struct _ASSEMBLY_STORAGE_MAP_ENTRY {
    ULONG Flags;
    UNICODE_STRING DosPath;         // stored with a trailing unicode null
    HANDLE Handle;                  // open file handle on the directory to lock it down
} ASSEMBLY_STORAGE_MAP_ENTRY, *PASSEMBLY_STORAGE_MAP_ENTRY;

#define ASSEMBLY_STORAGE_MAP_ASSEMBLY_ARRAY_IS_HEAP_ALLOCATED (0x00000001)

typedef struct _ASSEMBLY_STORAGE_MAP {
    ULONG Flags;
    ULONG AssemblyCount;
    PASSEMBLY_STORAGE_MAP_ENTRY *AssemblyArray;
} ASSEMBLY_STORAGE_MAP, *PASSEMBLY_STORAGE_MAP;

typedef struct _ACTIVATION_CONTEXT {
    LONG RefCount;
    ULONG Flags;
    PVOID ActivationContextData;
    PACTIVATION_CONTEXT_NOTIFY_ROUTINE NotificationRoutine;
    PVOID NotificationContext;
    ULONG SentNotifications[8];
    ULONG DisabledNotifications[8];
    ASSEMBLY_STORAGE_MAP StorageMap;
    PASSEMBLY_STORAGE_MAP_ENTRY InlineStorageMapEntries[32];
} ACTIVATION_CONTEXT;

#define ACTIVATION_CONTEXT_NOTIFICATION_DESTROY_INDEX (ACTIVATION_CONTEXT_NOTIFICATION_DESTROY >> 5)
#define ACTIVATION_CONTEXT_NOTIFICATION_DESTROY_MASK ((ULONG) (1 << (ACTIVATION_CONTEXT_NOTIFICATION_DESTROY & 0x1f)))

#define ACTIVATION_CONTEXT_NOTIFICATION_ZOMBIFY_INDEX (ACTIVATION_CONTEXT_NOTIFICATION_ZOMBIFY >> 5)
#define ACTIVATION_CONTEXT_NOTIFICATION_ZOMBIFY_MASK ((ULONG) (1 << (ACTIVATION_CONTEXT_NOTIFICATION_ZOMBIFY & 0x1f)))

#define ACTIVATION_CONTEXT_NOTIFICATION_USED_INDEX (ACTIVATION_CONTEXT_NOTIFICATION_USED >> 5)
#define ACTIVATION_CONTEXT_NOTIFICATION_USED_MASK ((ULONG) (1 << (ACTIVATION_CONTEXT_NOTIFICATION_USED & 0x1f)))

#define HAS_ACTIVATION_CONTEXT_NOTIFICATION_BEEN_SENT(_pac, _nt) (((_pac)->SentNotifications[ACTIVATION_CONTEXT_NOTIFICATION_ ## _nt ## _INDEX] & ACTIVATION_CONTEXT_NOTIFICATION_ ## _nt ## _MASK) != 0)
#define HAS_ACTIVATION_CONTEXT_NOTIFICATION_BEEN_DISABLED(_pac, _nt) (((_pac)->DisabledNotifications[ACTIVATION_CONTEXT_NOTIFICATION_ ## _nt ## _INDEX] & ACTIVATION_CONTEXT_NOTIFICATION_ ## _nt ## _MASK) != 0)

#define ACTIVATION_CONTEXT_SHOULD_SEND_NOTIFICATION(_pac, _nt) \
 ((!IS_SPECIAL_ACTCTX(_pac)) && ((_pac)->NotificationRoutine != NULL) && ((!HAS_ACTIVATION_CONTEXT_NOTIFICATION_BEEN_SENT((_pac), _nt)) || (!HAS_ACTIVATION_CONTEXT_NOTIFICATION_BEEN_DISABLED((_pac), _nt))))

#define RECORD_ACTIVATION_CONTEXT_NOTIFICATION_SENT(_pac, _nt) { (_pac)->SentNotifications[ACTIVATION_CONTEXT_NOTIFICATION_ ## _nt ## _INDEX] |= ACTIVATION_CONTEXT_NOTIFICATION_ ## _nt ## _MASK; }
#define RECORD_ACTIVATION_CONTEXT_NOTIFICATION_DISABLED(_pac, _nt) { (_pac)->DisabledNotifications[ACTIVATION_CONTEXT_NOTIFICATION_ ## _nt ## _INDEX] |= ACTIVATION_CONTEXT_NOTIFICATION_ ## _nt ## _MASK; }

#define SEND_ACTIVATION_CONTEXT_NOTIFICATION(_pac, _nt, _data) \
{ \
    if (ACTIVATION_CONTEXT_SHOULD_SEND_NOTIFICATION((_pac), _nt)) { \
        BOOLEAN __DisableNotification = FALSE; \
        (*((_pac)->NotificationRoutine))( \
            ACTIVATION_CONTEXT_NOTIFICATION_ ## _nt, \
            (_pac), \
            (_pac)->ActivationContextData, \
            (_pac)->NotificationContext, \
            (_data), \
            &__DisableNotification); \
        RECORD_ACTIVATION_CONTEXT_NOTIFICATION_SENT((_pac), _nt); \
        if (__DisableNotification) \
            RECORD_ACTIVATION_CONTEXT_NOTIFICATION_DISABLED((_pac), _nt); \
    } \
}

//
//  Flags for ACTIVATION_CONTEXT
//

#define ACTIVATION_CONTEXT_ZOMBIFIED          (0x00000001)
#define ACTIVATION_CONTEXT_NOT_HEAP_ALLOCATED (0x00000002)

//
//  Because activating an activation context may require a heap allocation
//  which may fail, sometimes (e.g. dispatching an APC) we must still
//  go forward with the operation.  If there is an opportunity to
//  report the failure to activate back to the user, that should be done.
//  However, as in activating the necessary context prior to dispatching
//  an APC back to the user mode code, if the allocation fails, there is
//  no caller to whom to report the error.
//
//  To alleviate this problem, failure paths should disable lookups on
//  the current stack frame via the RtlSetActivationContextSearchState()
//  API.  Calling RtlSetActivationContextSearchState(FALSE) marks
//  the active frame as having lookups disabled.  Attempts to query
//  the activation context stack will fail with the
//  STATUS_SXS_THREAD_QUERIES_DISABLED.
//
//  This means that attempts to load libraries from within APCs where this
//  is true will fail, but it's surely better than either silently not
//  calling the APC or calling the APC with the wrong activation context
//  active.
//

#define ACTIVATION_CONTEXT_STACK_FRAMELIST_MAGIC 'tslF'

typedef struct _ACTIVATION_CONTEXT_STACK_FRAMELIST {
    ULONG Magic;    // Bit pattern to recognize a framelist
    ULONG FramesInUse;
    LIST_ENTRY Links;
    ULONG Flags;
    ULONG NotFramesInUse; // Inverted bits of FramesInUse.  Useful for debugging.
    RTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frames[32];
} ACTIVATION_CONTEXT_STACK_FRAMELIST, *PACTIVATION_CONTEXT_STACK_FRAMELIST;

#define RTLP_VALIDATE_ACTIVATION_CONTEXT_DATA_FLAG_VALIDATE_SIZE        (0x00000001)
#define RTLP_VALIDATE_ACTIVATION_CONTEXT_DATA_FLAG_VALIDATE_OFFSETS     (0x00000002)
#define RTLP_VALIDATE_ACTIVATION_CONTEXT_DATA_FLAG_VALIDATE_READONLY    (0x00000004)

NTSTATUS
RtlpValidateActivationContextData(
    IN ULONG Flags OPTIONAL,
    IN PCACTIVATION_CONTEXT_DATA Data,
    IN SIZE_T BufferSize OPTIONAL
    );

NTSTATUS
RtlpFindUnicodeStringInSection(
    IN const ACTIVATION_CONTEXT_STRING_SECTION_HEADER UNALIGNED * Header,
    IN SIZE_T SectionSize,
    IN PCUNICODE_STRING StringToFind,
    OUT PACTIVATION_CONTEXT_SECTION_KEYED_DATA DataOut OPTIONAL,
    IN OUT PULONG HashAlgorithm,
    IN OUT PULONG PseudoKey,
    OUT PULONG UserDataSize OPTIONAL,
    OUT VOID CONST ** UserData OPTIONAL
    );

NTSTATUS
RtlpFindGuidInSection(
    IN const ACTIVATION_CONTEXT_GUID_SECTION_HEADER UNALIGNED * Header,
    IN const GUID *GuidToFind,
    OUT PACTIVATION_CONTEXT_SECTION_KEYED_DATA DataOut OPTIONAL
    );

NTSTATUS
RtlpLocateActivationContextSection(
    IN PCACTIVATION_CONTEXT_DATA ActivationContextData,
    IN const GUID *ExtensionGuid,
    IN ULONG Id,
    OUT VOID CONST **SectionData,
    OUT ULONG *SectionLength
    );

NTSTATUS
RtlpCrackActivationContextStringSectionHeader(
    IN CONST VOID *SectionBase,
    IN SIZE_T SectionLength,
    OUT ULONG *FormatVersion OPTIONAL,
    OUT ULONG *DataFormatVersion OPTIONAL,
    OUT ULONG *SectionFlags OPTIONAL,
    OUT ULONG *ElementCount OPTIONAL,
    OUT PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY *Elements OPTIONAL,
    OUT ULONG *HashAlgorithm OPTIONAL,
    OUT VOID CONST **SearchStructure OPTIONAL,
    OUT ULONG *UserDataSize OPTIONAL,
    OUT VOID CONST **UserData OPTIONAL
    );

NTSTATUS
RtlpGetActiveActivationContextApplicationDirectory(
    IN SIZE_T InLength,
    OUT PVOID OutBuffer,
    OUT SIZE_T *OutLength
    );

NTSTATUS
RtlpFindNextActivationContextSection(
    PFINDFIRSTACTIVATIONCONTEXTSECTION Context,
    VOID CONST **SectionData,
    ULONG *SectionLength,
    PACTIVATION_CONTEXT *ActivationContextOut
    );

NTSTATUS
RtlpAllocateActivationContextStackFrame(
    ULONG Flags,
    PTEB Teb,
    PRTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME *Frame
    );

VOID
RtlpFreeActivationContextStackFrame(
    PRTL_HEAP_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame
    );

PSTR
RtlpFormatGuidANSI(
    const GUID *Guid,
    PSTR Buffer,
    SIZE_T BufferLength
    );

extern const ACTIVATION_CONTEXT_DATA RtlpTheEmptyActivationContextData;
extern ACTIVATION_CONTEXT      RtlpTheEmptyActivationContext;

#define RTLP_DISALLOW_THE_EMPTY_ACTIVATION_CONTEXT(ActCtx) \
    {  \
        ASSERT((ActCtx) != &RtlpTheEmptyActivationContext); \
        if ((ActCtx) == &RtlpTheEmptyActivationContext) {   \
            DbgPrintEx( \
                DPFLTR_SXS_ID, \
                DPFLTR_ERROR_LEVEL, \
                "SXS: %s() passed the empty activation context\n", __FUNCTION__); \
            Status = STATUS_INVALID_PARAMETER; \
            goto Exit; \
        } \
    }

#define RTLP_DISALLOW_THE_EMPTY_ACTIVATION_CONTEXT_DATA(ActCtxData) \
    {  \
        ASSERT((ActCtxData) != &RtlpTheEmptyActivationContextData); \
        if ((ActCtxData) == &RtlpTheEmptyActivationContextData) {   \
            DbgPrintEx( \
                DPFLTR_SXS_ID, \
                DPFLTR_ERROR_LEVEL, \
                "SXS: %s() passed the empty activation context data\n", __FUNCTION__); \
            Status = STATUS_INVALID_PARAMETER; \
            goto Exit; \
        } \
    }

PACTIVATION_CONTEXT
RtlpMapSpecialValuesToBuiltInActivationContexts(
    PACTIVATION_CONTEXT ActivationContext
    );

NTSTATUS
RtlpThreadPoolGetActiveActivationContext(
    PACTIVATION_CONTEXT* ActivationContext
    );

NTSTATUS
RtlpInitializeAssemblyStorageMap(
    PASSEMBLY_STORAGE_MAP Map,
    ULONG EntryCount,
    PASSEMBLY_STORAGE_MAP_ENTRY *EntryArray
    );

VOID
RtlpUninitializeAssemblyStorageMap(
    PASSEMBLY_STORAGE_MAP Map
    );

NTSTATUS
RtlpResolveAssemblyStorageMapEntry(
    IN OUT PASSEMBLY_STORAGE_MAP Map,
    IN PCACTIVATION_CONTEXT_DATA Data,
    IN ULONG AssemblyRosterIndex,
    IN PASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_ROUTINE Callback,
    IN PVOID CallbackContext
    );

NTSTATUS
RtlpInsertAssemblyStorageMapEntry(
    IN PASSEMBLY_STORAGE_MAP Map,
    IN ULONG AssemblyRosterIndex,
    IN PCUNICODE_STRING StorageLocation,
    IN HANDLE OpenDirectoryHandle
    );

NTSTATUS
RtlpProbeAssemblyStorageRootForAssembly(
    IN ULONG Flags,
    IN PCUNICODE_STRING Root,
    IN PCUNICODE_STRING AssemblyDirectory,
    OUT PUNICODE_STRING PreAllocatedString,
    OUT PUNICODE_STRING DynamicString,
    OUT PUNICODE_STRING *StringUsed,
    OUT HANDLE OpenDirectoryHandle
    );

NTSTATUS
RtlpGetAssemblyStorageMapRootLocation(
    IN HANDLE KeyHandle,
    IN PCUNICODE_STRING SubKeyName,
    OUT PUNICODE_STRING Root
    );

#define RTLP_GET_ACTIVATION_CONTEXT_DATA_STORAGE_MAP_AND_ROSTER_HEADER_USE_PROCESS_DEFAULT (0x00000001)
#define RTLP_GET_ACTIVATION_CONTEXT_DATA_STORAGE_MAP_AND_ROSTER_HEADER_USE_SYSTEM_DEFAULT  (0x00000002)

NTSTATUS
RtlpGetActivationContextDataRosterHeader(
    IN ULONG Flags,
    IN PCACTIVATION_CONTEXT_DATA ActivationContextData,
    OUT PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER *AssemblyRosterHeader
    );

NTSTATUS
RtlpGetActivationContextDataStorageMapAndRosterHeader(
    IN ULONG Flags,
    IN PPEB Peb,
    IN PACTIVATION_CONTEXT ActivationContext,
    OUT PCACTIVATION_CONTEXT_DATA *ActivationContextData,
    OUT PASSEMBLY_STORAGE_MAP *AssemblyStorageMap,
    OUT PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER *AssemblyRosterHeader
    );

#define RTLP_GET_ACTIVATION_CONTEXT_DATA_MAP_NULL_TO_EMPTY (0x00000001)
NTSTATUS
RtlpGetActivationContextData(
    IN ULONG                                Flags,
    IN PCACTIVATION_CONTEXT                 ActivationContext,
    IN PCFINDFIRSTACTIVATIONCONTEXTSECTION  FindContext, OPTIONAL /* This is used for its flags. */
    OUT PCACTIVATION_CONTEXT_DATA *         ActivationContextData
    );

NTSTATUS
RtlpFindActivationContextSection_FillOutReturnedData(
    IN ULONG                                    Flags,
    OUT PACTIVATION_CONTEXT_SECTION_KEYED_DATA  ReturnedData,
    IN OUT PACTIVATION_CONTEXT                  ActivationContext,
    IN PCFINDFIRSTACTIVATIONCONTEXTSECTION      FindContext,
    IN const VOID * UNALIGNED                   Header,
    IN ULONG                                    Header_UserDataOffset,
    IN ULONG                                    Header_UserDataSize,
    IN ULONG                                    SectionLength
    );

#endif // !defined(_NTDLL_SXSP_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\sxsctxsrch.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sxsctxsrch.c

Abstract:

    Side-by-side activation support for Windows/NT
    Implementation of context stack searching

Author:

    Michael Grier (MGrier) 2/2/2000

Revision History:

--*/

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // condition expression is constant

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <sxsp.h>
#include <stdlib.h>

typedef const void *PCVOID;

//#undef DBG_SXS
#define DBG_SXS 0
//#if DBG_SXS
//#undef DPFLTR_TRACE_LEVEL
//#undef DPFLTR_INFO_LEVEL
//#define DPFLTR_TRACE_LEVEL DPFLTR_ERROR_LEVEL
//#define DPFLTR_INFO_LEVEL DPFLTR_ERROR_LEVEL
//#endif

#define ARRAY_FITS(_base, _count, _elemtype, _limit) ((((ULONG) (_base)) < (_limit)) && ((((ULONG) ((_base) + ((_count) * (sizeof(_elemtype)))))) <= (_limit)))
#define SINGLETON_FITS(_base, _elemtype, _limit) ARRAY_FITS((_base), 1, _elemtype, (_limit))

//
// Comparison of unsigned numbers by subtraction does Not work!
//
#define RTLP_COMPARE_NUMBER(x, y) \
    (((x) < (y)) ? -1 : ((x) > (y)) ? +1 : 0)

int
__cdecl
RtlpCompareActivationContextDataTOCEntryById(
    CONST VOID* VoidElement1,
    CONST VOID* VoidElement2
    )
/*++
This code must kinda sorta mimic code in sxs.dll.
base\win32\fusion\dll\whistler\actctxgenctxctb.cpp
    CActivationContextGenerationContextContributor::Compare
But we handle extended sections differently.
--*/
{
    const ACTIVATION_CONTEXT_DATA_TOC_ENTRY UNALIGNED * Element1 = (const ACTIVATION_CONTEXT_DATA_TOC_ENTRY UNALIGNED *)VoidElement1;
    const ACTIVATION_CONTEXT_DATA_TOC_ENTRY UNALIGNED * Element2 = (const ACTIVATION_CONTEXT_DATA_TOC_ENTRY UNALIGNED *)VoidElement2;

    return RTLP_COMPARE_NUMBER(Element1->Id, Element2->Id);
}

NTSTATUS
RtlpLocateActivationContextSection(
    PCACTIVATION_CONTEXT_DATA ActivationContextData,
    const GUID *ExtensionGuid,
    ULONG Id,
    PVOID *SectionData,
    ULONG *SectionLength
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    const ACTIVATION_CONTEXT_DATA_TOC_HEADER UNALIGNED * TocHeader = NULL;
    const ACTIVATION_CONTEXT_DATA_TOC_ENTRY UNALIGNED * TocEntries = NULL;
    const ACTIVATION_CONTEXT_DATA_TOC_ENTRY UNALIGNED * TocEntry = NULL;
    ULONG i;

#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Entered RtlpLocateActivationContextSection() Id = %u\n", Id);
#endif

    if ((ActivationContextData->TotalSize < sizeof(ACTIVATION_CONTEXT_DATA)) ||
        (ActivationContextData->HeaderSize < sizeof(ACTIVATION_CONTEXT_DATA)))
    {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS/RTL: Activation context data at %p too small; TotalSize = %lu; HeaderSize = %lu\n",
            ActivationContextData,
            ActivationContextData->TotalSize,
            ActivationContextData->HeaderSize);
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }
    
    if (ExtensionGuid != NULL)
    {
        if (ActivationContextData->ExtendedTocOffset != 0)
        {
            const ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER UNALIGNED * ExtHeader = NULL;
            const ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY UNALIGNED * ExtEntry = NULL;

            if (!SINGLETON_FITS(ActivationContextData->ExtendedTocOffset, ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER, ActivationContextData->TotalSize))
            {
                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SXS/RTL: Extended TOC offset (%ld) is outside bounds of activation context data (%lu bytes)\n",
                    ActivationContextData->ExtendedTocOffset, ActivationContextData->TotalSize);
                Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
                goto Exit;
            }

            ExtHeader = (PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER) (((LONG_PTR) ActivationContextData) + ActivationContextData->ExtendedTocOffset);

            if (!ARRAY_FITS(ExtHeader->FirstEntryOffset, ExtHeader->EntryCount, ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY, ActivationContextData->TotalSize))
            {
                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SXS/RTL: Extended TOC entry array (starting at offset %ld; count = %lu; entry size = %u) is outside bounds of activation context data (%lu bytes)\n",
                    ExtHeader->FirstEntryOffset,
                    ExtHeader->EntryCount,
                    sizeof(ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY),
                    ActivationContextData->TotalSize);
                Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
                goto Exit;
            }

            ExtEntry = (PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY) (((LONG_PTR) ActivationContextData) + ExtHeader->FirstEntryOffset);

            // No fancy searching for the extension; just a dumb linear search.
            for (i=0; i<ExtHeader->EntryCount; i++)
            {
                if (IsEqualGUID(ExtensionGuid, &ExtEntry[i].ExtensionGuid))
                {
                    if (!SINGLETON_FITS(ExtEntry[i].TocOffset, ACTIVATION_CONTEXT_DATA_TOC_HEADER, ActivationContextData->TotalSize))
                    {
                        DbgPrintEx(
                            DPFLTR_SXS_ID,
                            DPFLTR_ERROR_LEVEL,
                            "SXS/RTL: Extended TOC section TOC %d (offset: %ld, size: %u) is outside activation context data bounds (%lu bytes)\n",
                            i,
                            ExtEntry[i].TocOffset,
                            sizeof(ACTIVATION_CONTEXT_DATA_TOC_HEADER),
                            ActivationContextData->TotalSize);
                        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
                        goto Exit;
                    }

                    TocHeader = (PCACTIVATION_CONTEXT_DATA_TOC_HEADER) (((LONG_PTR) ActivationContextData) + ExtEntry[i].TocOffset);
                    break;
                }
            }
        }
    }
    else if (ActivationContextData->DefaultTocOffset != 0)
    {
        TocHeader = (PCACTIVATION_CONTEXT_DATA_TOC_HEADER) (((LONG_PTR) ActivationContextData) + ActivationContextData->DefaultTocOffset);
    }

    if ((TocHeader == NULL) || (TocHeader->EntryCount == 0))
    {
        Status = STATUS_SXS_SECTION_NOT_FOUND;
        goto Exit;
    }

    if (!ARRAY_FITS(TocHeader->FirstEntryOffset, TocHeader->EntryCount, ACTIVATION_CONTEXT_DATA_TOC_ENTRY, ActivationContextData->TotalSize))
    {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS/RTL: TOC entry array (offset: %ld; count = %lu; entry size = %u) is outside bounds of activation context data (%lu bytes)\n",
            TocHeader->FirstEntryOffset,
            TocHeader->EntryCount,
            sizeof(ACTIVATION_CONTEXT_DATA_TOC_ENTRY),
            ActivationContextData->TotalSize);
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    TocEntries = (PCACTIVATION_CONTEXT_DATA_TOC_ENTRY) (((LONG_PTR) ActivationContextData) + TocHeader->FirstEntryOffset);

    if (TocHeader->Flags & ACTIVATION_CONTEXT_DATA_TOC_HEADER_INORDER)
    {
#if DBG
        // Paranoia while we're writing the code to encode the data structure...
        ULONG j;

        for (j=1; j<TocHeader->EntryCount; j++)
            ASSERT(TocEntries[j-1].Id < TocEntries[j].Id);
#endif // DBG

        if (Id < TocEntries[0].Id)
        {
            Status = STATUS_SXS_SECTION_NOT_FOUND;
            goto Exit;
        }

        if (TocHeader->Flags & ACTIVATION_CONTEXT_DATA_TOC_HEADER_DENSE)
        {
            const ULONG Index = Id - TocEntries[0].Id;

#if DBG
            ULONG jx;
            for (jx=1; jx<TocHeader->EntryCount; jx++)
                ASSERT((TocEntries[jx-1].Id + 1) == TocEntries[jx].Id);
#endif // DBG

            if (Index >= TocHeader->EntryCount)
            {
                Status = STATUS_SXS_SECTION_NOT_FOUND;
                goto Exit;
            }

            // The entries are dense and in order; we can just do an array index.
            TocEntry = &TocEntries[Index];
        }
        else
        {
            ACTIVATION_CONTEXT_DATA_TOC_ENTRY Key;

            Key.Id = Id;

            TocEntry = (const ACTIVATION_CONTEXT_DATA_TOC_ENTRY UNALIGNED *)
                bsearch(
                    &Key,
                    TocEntries,
                    TocHeader->EntryCount,
                    sizeof(*TocEntries),
                    RtlpCompareActivationContextDataTOCEntryById
                    );
        }
    }
    else
    {
        // They're not in order; just do a linear search.
        for (i=0; i<TocHeader->EntryCount; i++)
        {
            if (TocEntries[i].Id == Id)
            {
                TocEntry = &TocEntries[i];
                break;
            }
        }
    }

    if ((TocEntry == NULL) || (TocEntry->Offset == 0))
    {
        Status = STATUS_SXS_SECTION_NOT_FOUND;
        goto Exit;
    }

    if (!SINGLETON_FITS(TocEntry->Offset, TocEntry->Length, ActivationContextData->TotalSize))
    {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS/RTL: Section found (offset %ld; length %lu) extends past end of activation context data (%lu bytes)\n",
            TocEntry->Offset,
            TocEntry->Length,
            ActivationContextData->TotalSize);
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    *SectionData = (PVOID) (((LONG_PTR) ActivationContextData) + TocEntry->Offset);
    *SectionLength = TocEntry->Length;

    Status = STATUS_SUCCESS;
Exit:
#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Leaving RtlpLocateActivationContextSection() with NTSTATUS 0x%08lx\n", Status);
#endif // DBG_SXS

    return Status;
}

NTSTATUS
RtlpFindNextActivationContextSection(
    PFINDFIRSTACTIVATIONCONTEXTSECTION Context,
    PVOID *SectionData,
    ULONG *SectionLength,
    PACTIVATION_CONTEXT *ActivationContextOut
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PCACTIVATION_CONTEXT_DATA ActivationContextData = NULL;
    PACTIVATION_CONTEXT ActivationContextWeAreTrying = NULL;
    const PTEB Teb = NtCurrentTeb();
    const PPEB Peb = Teb->ProcessEnvironmentBlock;

#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Entered RtlpFindNextActivationContextSection()\n");
#endif // DBG_SXS

    if (ActivationContextOut != NULL)
        *ActivationContextOut = NULL;

    for (;;)
    {
        switch (Context->Depth)
        {
        case 0:
            // first time through; select the activation context at the head of the stack.
            if (Teb->ActivationContextStack.ActiveFrame != NULL) {
                PRTL_ACTIVATION_CONTEXT_STACK_FRAME Frame = (PRTL_ACTIVATION_CONTEXT_STACK_FRAME) Teb->ActivationContextStack.ActiveFrame;

                ActivationContextWeAreTrying = Frame->ActivationContext;

                if ((ActivationContextWeAreTrying != NULL) &&
                    (ActivationContextWeAreTrying != ACTCTX_PROCESS_DEFAULT)) {
                    if (ActivationContextWeAreTrying == ACTCTX_SYSTEM_DEFAULT) {
                        ActivationContextData = Peb->SystemDefaultActivationContextData;
                    } else {
                        ActivationContextData = ActivationContextWeAreTrying->ActivationContextData;
                    }

                }

                if (ActivationContextData != NULL) {
                    // We got what we were looking for...
                    Context->Depth = 1;
                    break;
                }

                // We explicitly fall through in the other case...
            }

        case 1: // try the process default
            ActivationContextWeAreTrying = ACTCTX_PROCESS_DEFAULT;
            ActivationContextData = Peb->ActivationContextData;

            if (ActivationContextData != NULL) {
                Context->Depth = 2;
                break;
            }

            // explicit fall through...

        case 2: // try system default
            ActivationContextWeAreTrying = ACTCTX_SYSTEM_DEFAULT;
            ActivationContextData = Peb->SystemDefaultActivationContextData;

            if (ActivationContextData != NULL) {
                Context->Depth = 3;
                break;
            }

        default:
            ASSERT(Context->Depth <= 3);
            if (Context->Depth > 3) {
                Status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }
            break;
        }

        // Hmm... no data.
        if (ActivationContextData == NULL) {
            Status = STATUS_SXS_SECTION_NOT_FOUND;
            goto Exit;
        }

        Status = RtlpLocateActivationContextSection(
                        ActivationContextData,
                        Context->ExtensionGuid,
                        Context->Id,
                        SectionData,
                        SectionLength);

        if (NT_SUCCESS(Status))
            break;

        // If we're not at the end of the search list and we get an error other
        // than STATUS_SXS_SECTION_NOT_FOUND, report it.  If it is
        // STATUS_SXS_SECTION_NOT_FOUND and we're not at the end of the list,
        // iterate again.
        if ((Status != STATUS_SXS_SECTION_NOT_FOUND) ||
            (Context->Depth == 3))
             goto Exit;
    }

    Context->OutFlags = 
        ((ActivationContextWeAreTrying == ACTCTX_SYSTEM_DEFAULT)
        ? FIND_ACTIVATION_CONTEXT_SECTION_OUTFLAG_FOUND_IN_SYSTEM_DEFAULT
        : 0)
        |
        ((ActivationContextWeAreTrying == ACTCTX_PROCESS_DEFAULT)
        ? FIND_ACTIVATION_CONTEXT_SECTION_OUTFLAG_FOUND_IN_PROCESS_DEFAULT
        : 0)
        ;

    if (ActivationContextOut != NULL)
    {
        if (ActivationContextWeAreTrying == ACTCTX_SYSTEM_DEFAULT)
        {
            // Hide this new value from old code that doesn't understand it.
            ActivationContextWeAreTrying = ACTCTX_PROCESS_DEFAULT;
        }
        *ActivationContextOut = ActivationContextWeAreTrying;
    }

    Status = STATUS_SUCCESS;
Exit:
#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Leaving RtlpFindNextActivationContextSection() with NTSTATUS 0x%08lx\n", Status);
#endif // DBG_SXS

    return Status;
}

NTSTATUS
NTAPI
RtlFindFirstActivationContextSection(
    IN PFINDFIRSTACTIVATIONCONTEXTSECTION Context,
    OUT PVOID *SectionData,
    OUT ULONG *SectionLength,
    OUT PACTIVATION_CONTEXT *ActivationContextFound OPTIONAL
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PACTIVATION_CONTEXT ActivationContextTemp = NULL;

#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Entered RtlFindFirstActivationContextSection()\n");
#endif // DBG_SXS

    if (ActivationContextFound != NULL)
        *ActivationContextFound = NULL;

    if ((Context == NULL) ||
        (Context->Size < sizeof(FINDFIRSTACTIVATIONCONTEXTSECTION)) ||
        (Context->Flags & ~(
                    FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ACTIVATION_CONTEXT
                    | FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_FLAGS)) ||
        (SectionData == NULL) ||
        (SectionLength == NULL))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Context->Depth = 0;

    Status = RtlpFindNextActivationContextSection(Context, SectionData, SectionLength, &ActivationContextTemp);
    if (!NT_SUCCESS(Status))
        goto Exit;

    if (ActivationContextFound != NULL)
    {
        RtlAddRefActivationContext(ActivationContextTemp);
        *ActivationContextFound = ActivationContextTemp;
    }

    Status = STATUS_SUCCESS;
Exit:
#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Leaving RtlFindFirstActivationContextSection() with NTSTATUS 0x%08lx\n", Status);
#endif // DBG_SXS

    return Status;
}

NTSTATUS
RtlpFindFirstActivationContextSection(
    IN PFINDFIRSTACTIVATIONCONTEXTSECTION Context,
    OUT PVOID *SectionData,
    OUT ULONG *SectionLength,
    OUT PACTIVATION_CONTEXT *ActivationContextFound OPTIONAL
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Entered %s()\n", __FUNCTION__);
#endif // DBG_SXS

    if (ActivationContextFound != NULL)
        *ActivationContextFound = NULL;

    if ((Context == NULL) ||
        (Context->Size < sizeof(FINDFIRSTACTIVATIONCONTEXTSECTION)) ||
        (Context->Flags & ~(
                    FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ACTIVATION_CONTEXT
                    | FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_FLAGS)) ||
        (SectionData == NULL) ||
        (SectionLength == NULL))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Context->Depth = 0;

    Status = RtlpFindNextActivationContextSection(Context, SectionData, SectionLength, ActivationContextFound);
    if (!NT_SUCCESS(Status))
        goto Exit;

    Status = STATUS_SUCCESS;
Exit:
#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Leaving %s() with NTSTATUS 0x%08lx\n", __FUNCTION__, Status);
#endif // DBG_SXS

    return Status;
}

NTSTATUS
NTAPI
RtlFindNextActivationContextSection(
    IN PFINDFIRSTACTIVATIONCONTEXTSECTION Context,
    OUT PVOID *SectionData,
    OUT ULONG *SectionLength,
    OUT PACTIVATION_CONTEXT *ActivationContextFound OPTIONAL
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PACTIVATION_CONTEXT ActivationContextTemp = NULL;

#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Entered RtlFindNextActivationContextSection()\n");
#endif // DBG_SXS

    if (ActivationContextFound != NULL)
        *ActivationContextFound = NULL;

    if ((Context == NULL) ||
        (Context->Size < sizeof(FINDFIRSTACTIVATIONCONTEXTSECTION)) ||
        (Context->Flags & ~(
                    FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ACTIVATION_CONTEXT
                    | FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_FLAGS)) ||
        (SectionData == NULL) ||
        (SectionLength == NULL))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Status = RtlpFindNextActivationContextSection(
                    Context,
                    SectionData,
                    SectionLength,
                    &ActivationContextTemp);
    if (!NT_SUCCESS(Status))
        goto Exit;

    if (ActivationContextFound != NULL) {
        RtlAddRefActivationContext(ActivationContextTemp);
        *ActivationContextFound = ActivationContextTemp;
    }

    Status = STATUS_SUCCESS;

Exit:
#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Leaving RtlFindNextActivationContextSection() with NTSTATUS 0x%08lx\n", Status);
#endif // DBG_SXS

    return Status;
}

VOID
NTAPI
RtlEndFindActivationContextSection(
    IN PFINDFIRSTACTIVATIONCONTEXTSECTION Context
    )
{
    // We don't maintain any state, so nothing to do today.  Who knows what we might
    // do in the future however...
    UNREFERENCED_PARAMETER (Context);
}

NTSTATUS
RtlpFindActivationContextSection_FillOutReturnedData(
    IN ULONG                                    Flags,
    OUT PACTIVATION_CONTEXT_SECTION_KEYED_DATA  ReturnedData,
    IN OUT PACTIVATION_CONTEXT                  ActivationContext,
    IN PCFINDFIRSTACTIVATIONCONTEXTSECTION      Context,
    IN const VOID * UNALIGNED                   Header,
    IN ULONG                                    Header_UserDataOffset,
    IN ULONG                                    Header_UserDataSize,
    IN ULONG                                    SectionLength
    )
{
    NTSTATUS Status;
    PCACTIVATION_CONTEXT_DATA                           ActivationContextData;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER    AssemblyRosterHeader;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY     AssemblyRosterEntryList;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION      AssemblyDataInfo;

#if DBG
    Status = STATUS_INTERNAL_ERROR;
#if !defined(INVALID_HANDLE_VALUE)
#define INVALID_HANDLE_VALUE ((HANDLE)(LONG_PTR)-1)
#endif
    ActivationContextData =     (PCACTIVATION_CONTEXT_DATA)INVALID_HANDLE_VALUE;
    AssemblyRosterHeader =      (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER)INVALID_HANDLE_VALUE;
    AssemblyRosterEntryList =   (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY)INVALID_HANDLE_VALUE;
    AssemblyDataInfo =          (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION)INVALID_HANDLE_VALUE;
#endif

    if (Context == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (Header == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (ReturnedData == NULL) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }

    if (Header_UserDataOffset != 0) {
        ReturnedData->SectionGlobalData = (PVOID) (((ULONG_PTR) Header) + Header_UserDataOffset);
        ReturnedData->SectionGlobalDataLength = Header_UserDataSize;
    }

    ReturnedData->SectionBase = (PVOID)Header;
    ReturnedData->SectionTotalLength = SectionLength;

    if (Flags & FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ACTIVATION_CONTEXT) {

        ASSERT(RTL_CONTAINS_FIELD(ReturnedData, ReturnedData->Size, ActivationContext));

        RtlAddRefActivationContext(ActivationContext);
        ReturnedData->ActivationContext = ActivationContext;
    }

    if (Flags & FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_FLAGS) {

        ASSERT(RTL_CONTAINS_FIELD(ReturnedData, ReturnedData->Size, Flags));

        ReturnedData->Flags =
            ((Context->OutFlags & FIND_ACTIVATION_CONTEXT_SECTION_OUTFLAG_FOUND_IN_PROCESS_DEFAULT)
            ? ACTIVATION_CONTEXT_SECTION_KEYED_DATA_FLAG_FOUND_IN_PROCESS_DEFAULT
            : 0)
            |
            ((Context->OutFlags & FIND_ACTIVATION_CONTEXT_SECTION_OUTFLAG_FOUND_IN_SYSTEM_DEFAULT)
            ? ACTIVATION_CONTEXT_SECTION_KEYED_DATA_FLAG_FOUND_IN_SYSTEM_DEFAULT
            : 0)
            ;
    }

    if (Flags & FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ASSEMBLY_METADATA) {

        typedef ACTIVATION_CONTEXT_SECTION_KEYED_DATA RETURNED_DATA;

        PCACTIVATION_CONTEXT_STRING_SECTION_HEADER AssemblyMetadataStringSectionHeader;
        PVOID AssemblyMetadataSectionBase;
        ULONG AssemblyMetadataSectionLength;
        ULONG AssemblyRosterIndex;

#if DBG
        AssemblyRosterIndex =       ~0UL;
        AssemblyMetadataStringSectionHeader = (PCACTIVATION_CONTEXT_STRING_SECTION_HEADER)INVALID_HANDLE_VALUE;
        AssemblyMetadataSectionBase = (PVOID)INVALID_HANDLE_VALUE;
        AssemblyMetadataSectionLength = ~0UL;
#endif


        ASSERT(RTL_CONTAINS_FIELD(ReturnedData, ReturnedData->Size, AssemblyMetadata));

        Status = RtlpGetActivationContextData(
                0,
                ActivationContext,
                Context, /* for its flags */
                &ActivationContextData
                );
        if (!NT_SUCCESS(Status))
            goto Exit;

        if (!RTL_VERIFY(ActivationContextData != NULL)) {
            Status = STATUS_INTERNAL_ERROR;
            goto Exit;
        }

        AssemblyRosterIndex = ReturnedData->AssemblyRosterIndex;
        ASSERT(AssemblyRosterIndex >= 1);

        AssemblyRosterHeader = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER) (((ULONG_PTR) ActivationContextData) + ActivationContextData->AssemblyRosterOffset);
        ASSERT(AssemblyRosterIndex < AssemblyRosterHeader->EntryCount);

        AssemblyRosterEntryList = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY) (((ULONG_PTR) ActivationContextData) + AssemblyRosterHeader->FirstEntryOffset);
        AssemblyDataInfo = (PACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION)((ULONG_PTR)ActivationContextData + AssemblyRosterEntryList[AssemblyRosterIndex].AssemblyInformationOffset);

        ReturnedData->AssemblyMetadata.Information = RTL_CONST_CAST(PACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION)(AssemblyDataInfo);

        Status =
            RtlpLocateActivationContextSection(
                ActivationContextData,
                NULL, // ExtensionGuid
                ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION,
                &AssemblyMetadataSectionBase,
                &AssemblyMetadataSectionLength
                );
        if (!NT_SUCCESS(Status))
            goto Exit;

        ReturnedData->AssemblyMetadata.SectionBase = AssemblyMetadataSectionBase;
        ReturnedData->AssemblyMetadata.SectionLength = AssemblyMetadataSectionLength;

        if (AssemblyMetadataSectionBase != NULL
            && AssemblyMetadataSectionLength != 0) {

            ULONG HeaderSize;
            ULONG Magic;

            AssemblyMetadataStringSectionHeader = (PCACTIVATION_CONTEXT_STRING_SECTION_HEADER)(((ULONG_PTR)AssemblyMetadataSectionBase) + AssemblyMetadataSectionLength);

            if (!RTL_CONTAINS_FIELD(AssemblyMetadataStringSectionHeader, AssemblyMetadataSectionLength, Magic)) {
                Status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }
            if (!RTL_CONTAINS_FIELD(AssemblyMetadataStringSectionHeader, AssemblyMetadataSectionLength, HeaderSize)) {
                Status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }
            Magic = AssemblyMetadataStringSectionHeader->Magic;
            if (AssemblyMetadataStringSectionHeader->Magic != ACTIVATION_CONTEXT_STRING_SECTION_MAGIC) {
                Status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }
            HeaderSize = AssemblyMetadataStringSectionHeader->HeaderSize;
            if (HeaderSize > AssemblyMetadataSectionLength) {
                Status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }
            if (AssemblyMetadataSectionLength < sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HEADER)) {
                Status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }
            if (HeaderSize < sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HEADER)) {
                Status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }
            if (!RTL_CONTAINS_FIELD(AssemblyMetadataStringSectionHeader, HeaderSize, Magic)) {
                Status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }
            if (!RTL_CONTAINS_FIELD(AssemblyMetadataStringSectionHeader, HeaderSize, HeaderSize)) {
                Status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }
            if (!RTL_CONTAINS_FIELD(AssemblyMetadataStringSectionHeader, HeaderSize, UserDataOffset)) {
                Status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }
            if (!RTL_CONTAINS_FIELD(AssemblyMetadataStringSectionHeader, HeaderSize, UserDataSize)) {
                Status = STATUS_INTERNAL_ERROR;
                goto Exit;
            }
            ReturnedData->AssemblyMetadata.SectionGlobalDataBase = (PVOID)(((ULONG_PTR)AssemblyMetadataStringSectionHeader) + AssemblyMetadataStringSectionHeader->UserDataOffset);
            ReturnedData->AssemblyMetadata.SectionGlobalDataLength = AssemblyMetadataStringSectionHeader->UserDataSize;
        }
    }

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

NTSTATUS
RtlpFindActivationContextSection_CheckParameters(
    IN ULONG Flags,
    IN const GUID *ExtensionGuid OPTIONAL,
    IN ULONG SectionId,
    IN PCVOID ThingToFind,
    OUT PACTIVATION_CONTEXT_SECTION_KEYED_DATA ReturnedData OPTIONAL
    )
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;

    UNREFERENCED_PARAMETER(ExtensionGuid);
    UNREFERENCED_PARAMETER(SectionId);

    if ((ThingToFind == NULL) ||
            ((Flags & ~(
                FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ACTIVATION_CONTEXT
                | FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_FLAGS
                | FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ASSEMBLY_METADATA
                )) != 0) ||
            (((Flags & (
                FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ACTIVATION_CONTEXT
                | FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_FLAGS
                | FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ASSEMBLY_METADATA
                )) != 0) &&
            (ReturnedData == NULL)) ||
            ((ReturnedData != NULL) &&
             (ReturnedData->Size < (FIELD_OFFSET(ACTIVATION_CONTEXT_SECTION_KEYED_DATA, ActivationContext) + sizeof(ReturnedData->ActivationContext)))
             )) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if ((Flags & FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_FLAGS) != 0
        && !RTL_CONTAINS_FIELD(ReturnedData, ReturnedData->Size, Flags)
        ) {
        Status = STATUS_INVALID_PARAMETER;
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "SXS: %s() flags contains return_flags but they don't fit in size, return invalid_parameter 0x%08lx.\n", __FUNCTION__, STATUS_INVALID_PARAMETER);
        goto Exit;
    }

    if ((Flags & FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ASSEMBLY_METADATA) != 0
        && !RTL_CONTAINS_FIELD(ReturnedData, ReturnedData->Size, AssemblyMetadata)
        ) {
        Status = STATUS_INVALID_PARAMETER;
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "SXS: %s() flags contains return_assembly_metadata but they don't fit in size, return invalid_parameter 0x%08lx.\n", __FUNCTION__, STATUS_INVALID_PARAMETER);
        goto Exit;
    }

    Status = STATUS_SUCCESS;
Exit:

#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Leaving RtlFindActivationContextSectionString() with NTSTATUS 0x%08lx\n", Status);
#endif // DBG_SXS

    return Status;
}

NTSTATUS
NTAPI
RtlFindActivationContextSectionString(
    IN ULONG Flags,
    IN const GUID *ExtensionGuid OPTIONAL,
    IN ULONG SectionId,
    IN PCUNICODE_STRING StringToFind,
    OUT PACTIVATION_CONTEXT_SECTION_KEYED_DATA ReturnedData OPTIONAL
    )
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;

    FINDFIRSTACTIVATIONCONTEXTSECTION Context;
    const ACTIVATION_CONTEXT_STRING_SECTION_HEADER UNALIGNED * Header;
    ULONG StringSectionLength;
    BOOLEAN EndSearch;
    ULONG HashAlgorithm;
    ULONG PseudoKey;
    PACTIVATION_CONTEXT ActivationContext;
#if DBG_SXS
    CHAR ExtensionGuidBuffer[39];
#endif
    const PTEB Teb = NtCurrentTeb();
    const PPEB Peb = Teb->ProcessEnvironmentBlock;

    // Super short circuit...
    if ((Peb->ActivationContextData == NULL) &&
        (Peb->SystemDefaultActivationContextData == NULL) &&
        (Teb->ActivationContextStack.ActiveFrame == NULL))
        return STATUS_SXS_SECTION_NOT_FOUND;

    // Move variable initialization after the short-circuiting so that we truly
    // do the least amount of work possible prior to the early exit.
    StringSectionLength = 0;
    EndSearch = FALSE;
    HashAlgorithm = HASH_STRING_ALGORITHM_INVALID;
    PseudoKey = 0;
    ActivationContext = NULL;

#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Entered RtlFindActivationContextSectionString()\n"
        "   Flags = 0x%08lx\n"
        "   ExtensionGuid = %s\n"
        "   SectionId = %lu\n"
        "   StringToFind = %wZ\n"
        "   ReturnedData = %p\n",
        Flags,
        RtlpFormatGuidANSI(ExtensionGuid, ExtensionGuidBuffer, sizeof(ExtensionGuidBuffer)),
        SectionId,
        StringToFind,
        ReturnedData);
#endif // DBG_SXS

    Status = RtlpFindActivationContextSection_CheckParameters(Flags, ExtensionGuid, SectionId, StringToFind, ReturnedData);
    if (!NT_SUCCESS(Status))
        goto Exit;

    Context.Size = sizeof(Context);
    Context.Flags = Flags;
    Context.OutFlags = 0;
    Context.ExtensionGuid = ExtensionGuid;
    Context.Id = SectionId;

    Status = RtlpFindFirstActivationContextSection(&Context, (PVOID *) &Header, &StringSectionLength, &ActivationContext);
    if (!NT_SUCCESS(Status))
        goto Exit;

    for (;;) {
        // Validate that this actually looks like a string section...
        if ((StringSectionLength < sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HEADER)) ||
            (Header->Magic != ACTIVATION_CONTEXT_STRING_SECTION_MAGIC)) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "RtlFindActivationContextSectionString() found section at %p (length %lu) which is not a string section\n",
                Header,
                StringSectionLength);
            Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
            goto Exit;
        }

        Status = RtlpFindUnicodeStringInSection(
                        Header,
                        StringSectionLength,
                        StringToFind,
                        ReturnedData,
                        &HashAlgorithm,
                        &PseudoKey,
                        NULL,
                        NULL);
        if (NT_SUCCESS(Status))
            break;

        if (Status != STATUS_SXS_KEY_NOT_FOUND)
            goto Exit;

        Status = RtlFindNextActivationContextSection(&Context, (PVOID *) &Header, &StringSectionLength, &ActivationContext);
        if (!NT_SUCCESS(Status)) {
            // Convert from section not found to string not found so that the
            // caller can get an indication that at least some indirection
            // information was available but just not the particular key that
            // they're looking for.
            if (Status == STATUS_SXS_SECTION_NOT_FOUND)
                Status = STATUS_SXS_KEY_NOT_FOUND;

            goto Exit;
        }
    }

    SEND_ACTIVATION_CONTEXT_NOTIFICATION(ActivationContext, USED, NULL);

    if (ReturnedData != NULL) {
        Status =
            RtlpFindActivationContextSection_FillOutReturnedData(
                Flags,
                ReturnedData,
                ActivationContext,
                &Context,
                Header,
                Header->UserDataOffset,
                Header->UserDataSize,
                StringSectionLength
                );
        if (!NT_SUCCESS(Status))
            goto Exit;
    }

    Status = STATUS_SUCCESS;
Exit:

#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Leaving RtlFindActivationContextSectionString() with NTSTATUS 0x%08lx\n", Status);
#endif // DBG_SXS

    return Status;
}

int
__cdecl
RtlpCompareActivationContextStringSectionEntryByPseudoKey(
    const void *elem1, 
    const void *elem2
    )
/*++
This code must mimic code in sxs.dll
(base\win32\fusion\dll\whistler\ssgenctx.cpp CSSGenCtx::CompareStringSectionEntries)
--*/
{
    const ACTIVATION_CONTEXT_STRING_SECTION_ENTRY UNALIGNED * pEntry1 =
        (const ACTIVATION_CONTEXT_STRING_SECTION_ENTRY UNALIGNED *)elem1;
    const ACTIVATION_CONTEXT_STRING_SECTION_ENTRY UNALIGNED * pEntry2 =
        (const ACTIVATION_CONTEXT_STRING_SECTION_ENTRY UNALIGNED *)elem2;

    return RTLP_COMPARE_NUMBER(pEntry1->PseudoKey, pEntry2->PseudoKey);
}

NTSTATUS
RtlpFindUnicodeStringInSection(
    const ACTIVATION_CONTEXT_STRING_SECTION_HEADER UNALIGNED * Header,
    SIZE_T SectionSize,
    PCUNICODE_STRING String,
    PACTIVATION_CONTEXT_SECTION_KEYED_DATA DataOut,
    PULONG HashAlgorithm,
    PULONG PseudoKey,
    PULONG UserDataSize,
    PCVOID *UserData
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN CaseInsensitiveFlag;
    BOOLEAN UseHashTable = TRUE;
    BOOLEAN UsePseudoKey = TRUE;
    const ACTIVATION_CONTEXT_STRING_SECTION_ENTRY UNALIGNED * Entry = NULL;

    if (Header->Flags & ACTIVATION_CONTEXT_STRING_SECTION_CASE_INSENSITIVE) {
        CaseInsensitiveFlag = TRUE;
    }
    else {
        CaseInsensitiveFlag = FALSE;
    }

#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Entered RtlpFindUnicodeStringInSection() for string %p (->Length = %u; ->Buffer = %p) \"%wZ\"\n",
            String,
            (String != NULL) ? String->Length : 0,
            (String != NULL) ? String->Buffer : 0,
            String);
#endif // DBG_SXS

    if (UserDataSize != NULL)
        *UserDataSize = 0;

    if (UserData != NULL)
        *UserData = NULL;

    ASSERT(HashAlgorithm != NULL);
    ASSERT(PseudoKey != NULL);

    if (Header->Magic != ACTIVATION_CONTEXT_STRING_SECTION_MAGIC)
    {
#if DBG_SXS
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_TRACE_LEVEL,
            "RtlpFindUnicodeStringInSection: String section header has invalid .Magic value.\n");
#endif
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    // Eliminate the zero element case to make later code simpler.
    if (Header->ElementCount == 0)
    {
        Status = STATUS_SXS_KEY_NOT_FOUND;
        goto Exit;
    }

    if (Header->HashAlgorithm == HASH_STRING_ALGORITHM_INVALID)
    {
        UseHashTable = FALSE;
        UsePseudoKey = FALSE;
    }
    else if (*HashAlgorithm != Header->HashAlgorithm)
    {
        Status = RtlHashUnicodeString(String, CaseInsensitiveFlag, Header->HashAlgorithm, PseudoKey);
        if (!NT_SUCCESS(Status))
        {
            if (Status == STATUS_INVALID_PARAMETER)
            {
                ULONG TempPseudoKey = 0;

                // The only likely reason for invalid parameter is that the hash algorithm
                // wasn't understood.  We'll be pedantic and see if everything else is OK...
                Status = RtlHashUnicodeString(String, CaseInsensitiveFlag, HASH_STRING_ALGORITHM_DEFAULT, &TempPseudoKey);
                if (!NT_SUCCESS(Status))
                {
                    // Something's wrong, probably with the "String" parameter.  Punt.
                    goto Exit;
                }

                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_ERROR_LEVEL,
                    "RtlpFindUnicodeStringInSection: Unsupported hash algorithm %lu found in string section.\n",
                    Header->HashAlgorithm);

                // Ok, it's an algorithm ID that we don't understand.  We can't use the hash
                // table or the pseudokey.
                UseHashTable = FALSE;
                UsePseudoKey = FALSE;
            }
            else
                goto Exit;
        }
        else
        {
            // Record the hash algorithm we used so that we can avoid re-hashing if we have
            // to search another section.
            *HashAlgorithm = Header->HashAlgorithm;
        }
    }

    // If we don't understand the format version, we have to do the manual search.
    if (Header->FormatVersion != ACTIVATION_CONTEXT_STRING_SECTION_FORMAT_WHISTLER)
        UseHashTable = FALSE;

    // If there's no hash table, we can't use it!
    if (Header->SearchStructureOffset == 0)
        UseHashTable = FALSE;

    if (UseHashTable)
    {
        ULONG i;

        const ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE UNALIGNED * Table = (const ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE UNALIGNED *)
            (((LONG_PTR) Header) + Header->SearchStructureOffset);
        ULONG Index = ((*PseudoKey) % Table->BucketTableEntryCount);
        const ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET UNALIGNED * Bucket = ((const ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET UNALIGNED *)
            (((LONG_PTR) Header) + Table->BucketTableOffset)) + Index;
        const LONG UNALIGNED *Chain = (const LONG UNALIGNED *) (((LONG_PTR) Header) + Bucket->ChainOffset);

        for (i=0; i<Bucket->ChainCount; i++)
        {
            const ACTIVATION_CONTEXT_STRING_SECTION_ENTRY UNALIGNED *TmpEntry = NULL;
            UNICODE_STRING TmpEntryString;

            if (((SIZE_T) Chain[i]) > SectionSize)
            {
                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SXS: String hash collision chain offset at %p (= %ld) out of bounds\n", &Chain[i], Chain[i]);

                Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
                goto Exit;
            }

            TmpEntry = (const ACTIVATION_CONTEXT_STRING_SECTION_ENTRY UNALIGNED *) (((LONG_PTR) Header) + Chain[i]);

#if DBG_SXS
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_INFO_LEVEL,
                "SXS: Searching bucket collision %d; Chain[%d] = %ld\n"
                "   TmpEntry = %p; ->KeyLength = %lu; ->KeyOffset = %lu\n",
                i, i, Chain[i], TmpEntry, TmpEntry->KeyLength, TmpEntry->KeyOffset);
#endif DBG_SXS

            if (!UsePseudoKey || (TmpEntry->PseudoKey == *PseudoKey))
            {
                if (((SIZE_T) TmpEntry->KeyOffset) > SectionSize)
                {
                    DbgPrintEx(
                        DPFLTR_SXS_ID,
                        DPFLTR_ERROR_LEVEL,
                        "SXS: String hash table entry at %p has invalid key offset (= %ld)\n"
                        "   Header = %p; Index = %lu; Bucket = %p; Chain = %p\n",
                        TmpEntry, TmpEntry->KeyOffset, Header, Index, Bucket, Chain);

                    Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
                    goto Exit;
                }

                TmpEntryString.Length = (USHORT) TmpEntry->KeyLength;
                TmpEntryString.MaximumLength = TmpEntryString.Length;
                TmpEntryString.Buffer = (PWSTR) (((LONG_PTR) Header) + TmpEntry->KeyOffset);

                if (RtlCompareUnicodeString((PUNICODE_STRING) String, &TmpEntryString, CaseInsensitiveFlag) == 0)
                {
                    Entry = TmpEntry;
                    break;
                }
            }
        }
    }
    else if (UsePseudoKey && ((Header->Flags & ACTIVATION_CONTEXT_STRING_SECTION_ENTRIES_IN_PSEUDOKEY_ORDER) != 0))
    {
	    const ACTIVATION_CONTEXT_STRING_SECTION_ENTRY UNALIGNED * const first = (PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY)
            (((LONG_PTR) Header) + Header->ElementListOffset);

        const ACTIVATION_CONTEXT_STRING_SECTION_ENTRY UNALIGNED * const last = first + (Header->ElementCount - 1);

        ACTIVATION_CONTEXT_STRING_SECTION_ENTRY Key;

        Key.PseudoKey = *PseudoKey;

        Entry = (const ACTIVATION_CONTEXT_STRING_SECTION_ENTRY UNALIGNED *)
            bsearch(
                &Key,
                first,
                Header->ElementCount,
                sizeof(*first),
                RtlpCompareActivationContextStringSectionEntryByPseudoKey
                );
     
        if (Entry != NULL)
        {
            // Wow, we found the same pseudokey.  We need to search all the equal
            // pseudokeys, so back off to the first entry with this PK

            while ((Entry != first) && (Entry->PseudoKey == *PseudoKey))
                Entry--;

            // We may have stopped because we found a different pseudokey, or we may
            // have stopped because we hit the beginning of the list.  If we found a
            // different PK, move ahead one entry.
            if (Entry->PseudoKey != *PseudoKey)
                Entry++;

            do
            {
                UNICODE_STRING TmpEntryString;
                TmpEntryString.Length = (USHORT) Entry->KeyLength;
                TmpEntryString.MaximumLength = TmpEntryString.Length;
                TmpEntryString.Buffer = (PWSTR) (((LONG_PTR) Header) + Entry->KeyOffset);

                if (RtlCompareUnicodeString((PUNICODE_STRING) String, &TmpEntryString, CaseInsensitiveFlag) == 0)
                    break;
                Entry++;
            } while ((Entry <= last) && (Entry->PseudoKey == *PseudoKey));

            if ((Entry > last) || (Entry->PseudoKey != *PseudoKey))
                Entry = NULL;
        }
    }
    else
    {
        // Argh; we just have to do it the hard way.
        const ACTIVATION_CONTEXT_STRING_SECTION_ENTRY UNALIGNED * TmpEntry = (PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY)
            (((LONG_PTR) Header) + Header->ElementListOffset);
        ULONG Count;

#if DBG_SXS
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_INFO_LEVEL,
            "RtlpFindUnicodeStringInSection: About to do linear search of %d entries.\n", Header->ElementCount);
#endif // DBG_SXS

        for (Count = Header->ElementCount; Count != 0; Count--, TmpEntry++)
        {
            UNICODE_STRING TmpEntryString;

            TmpEntryString.Length = (USHORT) TmpEntry->KeyLength;
            TmpEntryString.MaximumLength = TmpEntryString.Length;
            TmpEntryString.Buffer = (PWSTR) (((LONG_PTR) Header) + TmpEntry->KeyOffset);

            if (!UsePseudoKey || (TmpEntry->PseudoKey == *PseudoKey))
            {
                if (RtlCompareUnicodeString((PUNICODE_STRING) String, &TmpEntryString, CaseInsensitiveFlag) == 0)
                {
                    Entry = TmpEntry;
                    break;
                }
            }
        }
    }

    if ((Entry == NULL) || (Entry->Offset == 0))
    {
        Status = STATUS_SXS_KEY_NOT_FOUND;
        goto Exit;
    }

    if (DataOut != NULL) {
        DataOut->DataFormatVersion = Header->DataFormatVersion;
        DataOut->Data = (PVOID) (((ULONG_PTR) Header) + Entry->Offset);
        DataOut->Length = Entry->Length;

        if (RTL_CONTAINS_FIELD(DataOut, DataOut->Size, AssemblyRosterIndex))
            DataOut->AssemblyRosterIndex = Entry->AssemblyRosterIndex;
    }

    if (UserDataSize != NULL)
        *UserDataSize = Header->UserDataSize;

    if ((UserData != NULL) && (Header->UserDataOffset != 0))
        *UserData = (PCVOID) (((ULONG_PTR) Header) + Header->UserDataOffset);

    Status = STATUS_SUCCESS;

Exit:
#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Leaving RtlpFindUnicodeStringInSection() with NTSTATUS 0x%08lx\n", Status);
#endif // DBG_SXS

    return Status;
}

NTSTATUS
NTAPI
RtlFindActivationContextSectionGuid(
    IN ULONG Flags,
    IN const GUID *ExtensionGuid OPTIONAL,
    IN ULONG SectionId,
    IN const GUID *GuidToFind,
    OUT PACTIVATION_CONTEXT_SECTION_KEYED_DATA ReturnedData
    )
{
    NTSTATUS Status;
    FINDFIRSTACTIVATIONCONTEXTSECTION Context;
    const ACTIVATION_CONTEXT_GUID_SECTION_HEADER UNALIGNED *Header;
    ULONG GuidSectionLength;
    BOOLEAN EndSearch;
    PACTIVATION_CONTEXT ActivationContext;
#if DBG
    CHAR GuidBuffer[39];
    CHAR ExtensionGuidBuffer[39];
    BOOLEAN DbgPrintSxsTraceLevel;
#endif
    PTEB Teb = NtCurrentTeb();
    PPEB Peb = Teb->ProcessEnvironmentBlock;

    // Super short circuit...
    if ((Peb->ActivationContextData == NULL) &&
        (Peb->SystemDefaultActivationContextData == NULL) &&
        (Teb->ActivationContextStack.ActiveFrame == NULL)) {

#if DBG_SXS
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_TRACE_LEVEL,
            __FUNCTION__"({%s}) super short circuited\n",
            RtlpFormatGuidANSI(GuidToFind, GuidBuffer, sizeof(GuidBuffer));
            );
#endif
        return STATUS_SXS_SECTION_NOT_FOUND;
    }

    // Perform initialization after the above test so that we really do the minimal amount of
    // work before bailing out when there's no side-by-side stuff going on in either the
    // process or thread.
    Status = STATUS_INTERNAL_ERROR;
    GuidSectionLength = 0;
    EndSearch = FALSE;
    ActivationContext = NULL;

#if DBG
    //
    // Comparison to TRUE is odd, but such is NtQueryDebugFilterState.
    //
    if (NtQueryDebugFilterState(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL) == TRUE) {
        DbgPrintSxsTraceLevel = TRUE;
    }
    else {
        DbgPrintSxsTraceLevel = FALSE;
    }

    if (DbgPrintSxsTraceLevel) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_TRACE_LEVEL,
            "Entered RtlFindActivationContextSectionGuid()\n"
            "   Flags = 0x%08lx\n"
            "   ExtensionGuid = %s\n"
            "   SectionId = %lu\n"
            "   GuidToFind = %s\n"
            "   ReturnedData = %p\n",
            Flags,
            RtlpFormatGuidANSI(ExtensionGuid, ExtensionGuidBuffer, sizeof(ExtensionGuidBuffer)),
            SectionId,
            RtlpFormatGuidANSI(GuidToFind, GuidBuffer, sizeof(GuidBuffer)),
            ReturnedData);
    }
#endif

    Status = RtlpFindActivationContextSection_CheckParameters(Flags, ExtensionGuid, SectionId, GuidToFind, ReturnedData);
    if (!NT_SUCCESS(Status))
        goto Exit;

    Context.Size = sizeof(Context);
    Context.Flags = 0;
    Context.ExtensionGuid = ExtensionGuid;
    Context.Id = SectionId;
    Context.OutFlags = 0;

    Status = RtlpFindFirstActivationContextSection(&Context, (PVOID *) &Header, &GuidSectionLength, &ActivationContext);
    if (!NT_SUCCESS(Status))
        goto Exit;

    for (;;) {
        // Validate that this actually looks like a guid section...
        if ((GuidSectionLength < sizeof(ACTIVATION_CONTEXT_GUID_SECTION_HEADER)) ||
            (Header->Magic != ACTIVATION_CONTEXT_GUID_SECTION_MAGIC)) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "RtlFindActivationContextSectionGuid() found section at %p (length %lu) which is not a GUID section\n",
                Header,
                GuidSectionLength);
            Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
            goto Exit;
        }

        Status = RtlpFindGuidInSection(
                        Header,
                        GuidToFind,
                        ReturnedData);
        if (NT_SUCCESS(Status))
            break;

        // If we failed for any reason other than not finding the key in the section, bail out.
        if (Status != STATUS_SXS_KEY_NOT_FOUND)
            goto Exit;

        Status = RtlpFindNextActivationContextSection(&Context, (PVOID *) &Header, &GuidSectionLength, &ActivationContext);
        if (!NT_SUCCESS(Status)) {
            // Convert from section not found to key not found so that the
            // caller can get an indication that at least some indirection
            // information was available but just not the particular key that
            // they're looking for.
            if (Status == STATUS_SXS_SECTION_NOT_FOUND)
                Status = STATUS_SXS_KEY_NOT_FOUND;

            goto Exit;
        }
    }

    SEND_ACTIVATION_CONTEXT_NOTIFICATION(ActivationContext, USED, NULL);

    if (ReturnedData != NULL) {
        Status =
            RtlpFindActivationContextSection_FillOutReturnedData(
                Flags,
                ReturnedData,
                ActivationContext,
                &Context,
                Header,
                Header->UserDataOffset,
                Header->UserDataSize,
                GuidSectionLength
                );
        if (!NT_SUCCESS(Status))
            goto Exit;
    }

    Status = STATUS_SUCCESS;
Exit:
#if DBG_SXS
    if (DbgPrintSxsTraceLevel) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_TRACE_LEVEL,
            "Leaving "__FUNCTION__"(%s) with NTSTATUS 0x%08lx\n",
            RtlpFormatGuidANSI(GuidToFind, GuidBuffer, sizeof(GuidBuffer)),
            Status);
    }
#endif

    return Status;
}

int
__cdecl
RtlpCompareActivationContextGuidSectionEntryByGuid(
    const void *elem1, 
    const void *elem2
    )
/*++
This code must mimic code in sxs.dll
(base\win32\fusion\dll\whistler\gsgenctx.cpp CGSGenCtx::SortGuidSectionEntries)
--*/
{
    const ACTIVATION_CONTEXT_GUID_SECTION_ENTRY UNALIGNED * pLeft =
            (const ACTIVATION_CONTEXT_GUID_SECTION_ENTRY*)elem1;

    const ACTIVATION_CONTEXT_GUID_SECTION_ENTRY UNALIGNED * pRight =
        (const ACTIVATION_CONTEXT_GUID_SECTION_ENTRY*)elem2;

    return memcmp( &pLeft->Guid, &pRight->Guid, sizeof(GUID) );
}

NTSTATUS
RtlpFindGuidInSection(
    const ACTIVATION_CONTEXT_GUID_SECTION_HEADER UNALIGNED *Header,
    const GUID *Guid,
    PACTIVATION_CONTEXT_SECTION_KEYED_DATA DataOut
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN UseHashTable = TRUE;
    const ACTIVATION_CONTEXT_GUID_SECTION_ENTRY UNALIGNED *Entry = NULL;

#if DBG_SXS
    CHAR GuidBuffer[39];

    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Entered "__FUNCTION__"({%s})\n",
        RtlpFormatGuidANSI(Guid, GuidBuffer, sizeof(GuidBuffer))
        );
#endif

    if (Header->Magic != ACTIVATION_CONTEXT_GUID_SECTION_MAGIC)
    {
#if DBG_SXS
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_TRACE_LEVEL,
            "RtlpFindGuidInSection: Guid section header has invalid .Magic value.\n");
#endif
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    // Eliminate the zero element case to make later code simpler.
    if (Header->ElementCount == 0)
    {
        Status = STATUS_SXS_KEY_NOT_FOUND;
        goto Exit;
    }

    // If we don't understand the format version, we have to do the manual search.
    if (Header->FormatVersion != ACTIVATION_CONTEXT_GUID_SECTION_FORMAT_WHISTLER)
        UseHashTable = FALSE;

    // If there's no hash table, we can't use it!
    if (Header->SearchStructureOffset == 0)
        UseHashTable = FALSE;

    if (UseHashTable)
    {
        ULONG i;

        const ACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE UNALIGNED *Table = (PCACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE)
            (((LONG_PTR) Header) + Header->SearchStructureOffset);
        ULONG Index = ((Guid->Data1) % Table->BucketTableEntryCount);
        const ACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET UNALIGNED *Bucket = ((PCACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET)
            (((LONG_PTR) Header) + Table->BucketTableOffset)) + Index;
        const ULONG UNALIGNED *Chain = (PULONG) (((LONG_PTR) Header) + Bucket->ChainOffset);

        for (i=0; i<Bucket->ChainCount; i++)
        {
            const ACTIVATION_CONTEXT_GUID_SECTION_ENTRY UNALIGNED * TmpEntry = (PCACTIVATION_CONTEXT_GUID_SECTION_ENTRY)
                (((LONG_PTR) Header) + *Chain++);

            if (RtlCompareMemory(&TmpEntry->Guid, Guid, sizeof(GUID)) == sizeof(GUID))
            {
                Entry = TmpEntry;
                break;
            }
        }
    }
    else if ((Header->Flags & ACTIVATION_CONTEXT_GUID_SECTION_ENTRIES_IN_ORDER) != 0)
    {
	    const ACTIVATION_CONTEXT_GUID_SECTION_ENTRY UNALIGNED * const first = (PCACTIVATION_CONTEXT_GUID_SECTION_ENTRY)
            (((LONG_PTR) Header) + Header->ElementListOffset);

        ACTIVATION_CONTEXT_GUID_SECTION_ENTRY Key;

        Key.Guid = *Guid;

        Entry = (const ACTIVATION_CONTEXT_GUID_SECTION_ENTRY UNALIGNED *)
            bsearch(
                &Key,
                first,
                Header->ElementCount,
                sizeof(*first),
                RtlpCompareActivationContextGuidSectionEntryByGuid
                );
    }
    else
    {
        // Argh; we just have to do it the hard way.
        const ACTIVATION_CONTEXT_GUID_SECTION_ENTRY UNALIGNED * TmpEntry = (const ACTIVATION_CONTEXT_GUID_SECTION_ENTRY UNALIGNED *)
            (((LONG_PTR) Header) + Header->ElementListOffset);
        ULONG Count;

#if DBG_SXS
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_INFO_LEVEL,
            __FUNCTION__"({%s}): About to do linear search of %d entries.\n",
            RtlpFormatGuidANSI(Guid, GuidBuffer, sizeof(GuidBuffer)),
            Header->ElementCount);
#endif // DBG_SXS

        for (Count = Header->ElementCount; Count != 0; Count--, TmpEntry++) {
            if (RtlCompareMemory(&TmpEntry->Guid, Guid, sizeof(GUID)) == sizeof(GUID)) {
                Entry = TmpEntry;
                break;
            }
        }
    }

    if ((Entry == NULL) || (Entry->Offset == 0)) {
        Status = STATUS_SXS_KEY_NOT_FOUND;
        goto Exit;
    }

    if (DataOut != NULL) {
        DataOut->DataFormatVersion = Header->DataFormatVersion;
        DataOut->Data = (PVOID) (((ULONG_PTR) Header) + Entry->Offset);
        DataOut->Length = Entry->Length;

        if (RTL_CONTAINS_FIELD(DataOut, DataOut->Size, AssemblyRosterIndex))
            DataOut->AssemblyRosterIndex = Entry->AssemblyRosterIndex;
    }

    Status = STATUS_SUCCESS;

Exit:
#if DBG_SXS
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "Leaving "__FUNCTION__"({%s}) with NTSTATUS 0x%08lx\n",
        RtlpFormatGuidANSI(Guid, GuidBuffer, sizeof(GuidBuffer)),
        Status);
#endif // DBG_SXS

    return Status;
}

#define tohexdigit(_x) ((CHAR) (((_x) < 10) ? ((_x) + '0') : ((_x) + 'A' - 10)))

PSTR
RtlpFormatGuidANSI(
    const GUID *Guid,
    PSTR Buffer,
    SIZE_T BufferLength
    )
{
    CHAR *pch = Buffer;

    ASSERT(BufferLength > 38);
    if (BufferLength <= 38)
    {
        return "<GUID buffer too small>";
    }

    if (Guid == NULL)
        return "<null>";

    pch = Buffer;

    *pch++ = '{';
    *pch++ = tohexdigit((Guid->Data1 >> 28) & 0xf);
    *pch++ = tohexdigit((Guid->Data1 >> 24) & 0xf);
    *pch++ = tohexdigit((Guid->Data1 >> 20) & 0xf);
    *pch++ = tohexdigit((Guid->Data1 >> 16) & 0xf);
    *pch++ = tohexdigit((Guid->Data1 >> 12) & 0xf);
    *pch++ = tohexdigit((Guid->Data1 >> 8) & 0xf);
    *pch++ = tohexdigit((Guid->Data1 >> 4) & 0xf);
    *pch++ = tohexdigit((Guid->Data1 >> 0) & 0xf);
    *pch++ = '-';
    *pch++ = tohexdigit((Guid->Data2 >> 12) & 0xf);
    *pch++ = tohexdigit((Guid->Data2 >> 8) & 0xf);
    *pch++ = tohexdigit((Guid->Data2 >> 4) & 0xf);
    *pch++ = tohexdigit((Guid->Data2 >> 0) & 0xf);
    *pch++ = '-';
    *pch++ = tohexdigit((Guid->Data3 >> 12) & 0xf);
    *pch++ = tohexdigit((Guid->Data3 >> 8) & 0xf);
    *pch++ = tohexdigit((Guid->Data3 >> 4) & 0xf);
    *pch++ = tohexdigit((Guid->Data3 >> 0) & 0xf);
    *pch++ = '-';
    *pch++ = tohexdigit((Guid->Data4[0] >> 4) & 0xf);
    *pch++ = tohexdigit((Guid->Data4[0] >> 0) & 0xf);
    *pch++ = tohexdigit((Guid->Data4[1] >> 4) & 0xf);
    *pch++ = tohexdigit((Guid->Data4[1] >> 0) & 0xf);
    *pch++ = '-';
    *pch++ = tohexdigit((Guid->Data4[2] >> 4) & 0xf);
    *pch++ = tohexdigit((Guid->Data4[2] >> 0) & 0xf);
    *pch++ = tohexdigit((Guid->Data4[3] >> 4) & 0xf);
    *pch++ = tohexdigit((Guid->Data4[3] >> 0) & 0xf);
    *pch++ = tohexdigit((Guid->Data4[4] >> 4) & 0xf);
    *pch++ = tohexdigit((Guid->Data4[4] >> 0) & 0xf);
    *pch++ = tohexdigit((Guid->Data4[5] >> 4) & 0xf);
    *pch++ = tohexdigit((Guid->Data4[5] >> 0) & 0xf);
    *pch++ = tohexdigit((Guid->Data4[6] >> 4) & 0xf);
    *pch++ = tohexdigit((Guid->Data4[6] >> 0) & 0xf);
    *pch++ = tohexdigit((Guid->Data4[7] >> 4) & 0xf);
    *pch++ = tohexdigit((Guid->Data4[7] >> 0) & 0xf);
    *pch++ = '}';
    *pch++ = '\0';

    return Buffer;
}


NTSTATUS
RtlpGetActivationContextData(
    IN ULONG                           Flags,
    IN PCACTIVATION_CONTEXT            ActivationContext,
    IN PCFINDFIRSTACTIVATIONCONTEXTSECTION  FindContext, OPTIONAL /* This is used for its flags. */
    OUT PCACTIVATION_CONTEXT_DATA*  ActivationContextData
    )
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR; // in case someone forgets to set it...
    SIZE_T PebOffset;

    if (ActivationContextData == NULL) {
        Status = STATUS_INVALID_PARAMETER_4;
        goto Exit;
    }
    if (Flags & ~(RTLP_GET_ACTIVATION_CONTEXT_DATA_MAP_NULL_TO_EMPTY)) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Exit;
    }
    *ActivationContextData = NULL;
    PebOffset = 0;

    //
    // We should use RtlpMapSpecialValuesToBuiltInActivationContexts here, but
    // it doesn't handle all the values and it isn't worth fixing it right now.
    //
    switch ((ULONG_PTR)ActivationContext)
    {
        case ((ULONG_PTR)NULL):
            if (FindContext == NULL) {
                PebOffset = FIELD_OFFSET(PEB, ActivationContextData);
            } else {
                switch (
                    FindContext->OutFlags
                        & (   FIND_ACTIVATION_CONTEXT_SECTION_OUTFLAG_FOUND_IN_PROCESS_DEFAULT
                            | FIND_ACTIVATION_CONTEXT_SECTION_OUTFLAG_FOUND_IN_SYSTEM_DEFAULT
                    )) {
                    case 0: // FALLTHROUGH
                    case FIND_ACTIVATION_CONTEXT_SECTION_OUTFLAG_FOUND_IN_PROCESS_DEFAULT:
                        PebOffset = FIELD_OFFSET(PEB, ActivationContextData);
                        break;
                    case FIND_ACTIVATION_CONTEXT_SECTION_OUTFLAG_FOUND_IN_SYSTEM_DEFAULT:
                        PebOffset = FIELD_OFFSET(PEB, SystemDefaultActivationContextData);
                        break;
                    case (FIND_ACTIVATION_CONTEXT_SECTION_OUTFLAG_FOUND_IN_PROCESS_DEFAULT 
                        | FIND_ACTIVATION_CONTEXT_SECTION_OUTFLAG_FOUND_IN_SYSTEM_DEFAULT):
                        Status = STATUS_INVALID_PARAMETER_2;
                        goto Exit;
                        break;
                }
            }
            break;

        case ((ULONG_PTR)ACTCTX_EMPTY):
            *ActivationContextData = &RtlpTheEmptyActivationContextData;
            break;

        case ((ULONG_PTR)ACTCTX_SYSTEM_DEFAULT):
            PebOffset = FIELD_OFFSET(PEB, SystemDefaultActivationContextData);
            break;

        default:
            *ActivationContextData = ActivationContext->ActivationContextData;
            break;
    }
    if (PebOffset != 0)
        *ActivationContextData = *(PCACTIVATION_CONTEXT_DATA*)(((ULONG_PTR)NtCurrentPeb()) + PebOffset);

    //
    // special transmutation of lack of actctx into the empty actctx
    //
    if (*ActivationContextData == NULL)
        if ((Flags & RTLP_GET_ACTIVATION_CONTEXT_DATA_MAP_NULL_TO_EMPTY) != 0)
            *ActivationContextData = &RtlpTheEmptyActivationContextData;

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\sxsstorage.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sxsstorage.c

Abstract:

    User-mode side by side storage map default resolution support.

    Private functions that support the default probing/finding
    where assemblies are stored.

Author:

    Michael J. Grier (mgrier) 6/30/2000

Revision History:

--*/

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "string.h"
#include "ctype.h"
#include "sxstypes.h"
#include "ntdllp.h"

VOID
NTAPI
RtlpAssemblyStorageMapResolutionDefaultCallback(
    ULONG Reason,
    PASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_DATA Data,
    PVOID Context
    )
{
    NTSTATUS Status;
    NTSTATUS *StatusOut = (NTSTATUS *) Context;

    switch (Reason) {
        case ASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_REASON_RESOLUTION_BEGINNING: {
            static const WCHAR NameStringBuffer[] = L"\\Registry\\Machine\\Software\\Microsoft\\Windows\\CurrentVersion\\SideBySide\\AssemblyStorageRoots";
            static const UNICODE_STRING NameString = { sizeof(NameStringBuffer) - sizeof(WCHAR), sizeof(NameStringBuffer), (PWSTR) NameStringBuffer };

            OBJECT_ATTRIBUTES Obja;
            HANDLE KeyHandle = NULL;

            InitializeObjectAttributes(
                &Obja,
                (PUNICODE_STRING) &NameString,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL);

            Status = NtOpenKey(&KeyHandle, KEY_ENUMERATE_SUB_KEYS, &Obja);
            if (!NT_SUCCESS(Status)) {
                // If the key is not found, we handle the system assembly installation area and privatized
                // assemblies differently anyways, so let things continue.  We'll just stop when we
                // try to use the registry stuff.

                if ((Status != STATUS_OBJECT_NAME_NOT_FOUND) &&
                    (Status != STATUS_TOO_LATE)) {
                    DbgPrintEx(
                        DPFLTR_SXS_ID,
                        DPFLTR_ERROR_LEVEL,
                        "SXS: Unable to open registry key %wZ Status = 0x%08lx\n", &NameString, Status);

                    Data->ResolutionBeginning.CancelResolution = TRUE;
                    if (StatusOut != NULL)
                        *StatusOut = Status;

                    break;
                }

                RTL_SOFT_ASSERT(KeyHandle == NULL);
            }

            Data->ResolutionBeginning.ResolutionContext = (PVOID) KeyHandle;
            Data->ResolutionBeginning.RootCount = ((SIZE_T) -1);

            break;
        }

        case ASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_REASON_GET_ROOT: {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_TRACE_LEVEL,
                "SXS: Getting assembly storage root #%Iu\n", Data->GetRoot.RootIndex);

            if (Data->GetRoot.RootIndex == 0) {
                // privatized assembly
                static const WCHAR DllRedirectionLocal[] = L".Local\\"; 
                USHORT cbFullImageNameLength; 
                LPWSTR pFullImageName = NULL;
                SIZE_T TotalLength; 
                PVOID  Cursor = NULL; 

                // get ImageName and Lenght from PEB
                cbFullImageNameLength = NtCurrentPeb()->ProcessParameters->ImagePathName.Length; // w/o trailing NULL
                TotalLength = cbFullImageNameLength + sizeof(DllRedirectionLocal); // containing a trailing NULL
                if (TotalLength > UNICODE_STRING_MAX_BYTES) {
                    Data->GetRoot.CancelResolution = TRUE;
                    if (StatusOut != NULL)
                        *StatusOut = STATUS_NAME_TOO_LONG;
                    break;
                }

                if ( TotalLength > Data->GetRoot.Root.MaximumLength) { 
                    Data->GetRoot.CancelResolution = TRUE;
                    if (StatusOut != NULL)
                        *StatusOut = STATUS_BUFFER_TOO_SMALL;
                    break; 
                }
                // point to ImageName
                pFullImageName = (PWSTR)NtCurrentPeb()->ProcessParameters->ImagePathName.Buffer;
                if (!(NtCurrentPeb()->ProcessParameters->Flags & RTL_USER_PROC_PARAMS_NORMALIZED)) 
                    pFullImageName = (PWSTR)((PCHAR)pFullImageName + (ULONG_PTR)(NtCurrentPeb()->ProcessParameters));

                Cursor = Data->GetRoot.Root.Buffer; 
                RtlCopyMemory(Cursor, pFullImageName, cbFullImageNameLength);
                Cursor = (PVOID) (((ULONG_PTR) Cursor) + cbFullImageNameLength);
                RtlCopyMemory(Cursor, DllRedirectionLocal, sizeof(DllRedirectionLocal));//with a trailing "/" and NULL
                Data->GetRoot.Root.Length = (USHORT)TotalLength - sizeof(WCHAR); 

                if ( ! RtlDoesFileExists_U(Data->GetRoot.Root.Buffer))  // no bother to return a wrong path
                    Data->GetRoot.Root.Length = 0 ; 

            } else if (Data->GetRoot.RootIndex == 1) {
                // Use %windir%\winsxs as the normal place to probe first
                static const WCHAR WinSxSBuffer[] = L"%SystemRoot%\\WinSxS\\";
                static const UNICODE_STRING WinSxS = { sizeof(WinSxSBuffer) - sizeof(WCHAR), sizeof(WinSxSBuffer), (PWSTR) WinSxSBuffer };
 
                Status = RtlExpandEnvironmentStrings_U(NULL, (PUNICODE_STRING) &WinSxS, &Data->GetRoot.Root, NULL);
                if (!NT_SUCCESS(Status)) {
                    DbgPrintEx(
                        DPFLTR_SXS_ID,
                        DPFLTR_ERROR_LEVEL,
                        "SXS: Unable to expand %%SystemRoot%%\\WinSxS\\ Status = 0x08lx\n", Status);

                    Data->GetRoot.CancelResolution = TRUE;
                    if (StatusOut != NULL)
                        *StatusOut = Status;

                    break;
                }
            } else if (Data->GetRoot.RootIndex <= MAXULONG) {
                // Return the appropriate root
                struct {
                    KEY_BASIC_INFORMATION kbi;
                    WCHAR KeyNameBuffer[DOS_MAX_PATH_LENGTH]; // arbitrary biggish size
                } KeyData;
                HANDLE KeyHandle = (HANDLE) Data->GetRoot.ResolutionContext;
                ULONG ResultLength = 0;
                ULONG SubKeyIndex = (ULONG) (Data->GetRoot.RootIndex - 2); // minus two because we use index 0 for privatized assembly probing and 1 for %SystemRoot%\winsxs
                UNICODE_STRING SubKeyName;

                // If the registry key could not be opened in the first place, we're done.
                if (KeyHandle == NULL) {
                    Data->GetRoot.NoMoreEntries = TRUE;
                    break;
                }

                Status = NtEnumerateKey(
                                KeyHandle,
                                SubKeyIndex,
                                KeyBasicInformation,
                                &KeyData,
                                sizeof(KeyData),
                                &ResultLength);
                if (!NT_SUCCESS(Status)) {
                    // If this is the end of the subkeys, tell our caller to stop the iterations.
                    if (Status == STATUS_NO_MORE_ENTRIES) {
                        Data->GetRoot.NoMoreEntries = TRUE;
                        break;
                    }

                    DbgPrintEx(
                        DPFLTR_SXS_ID,
                        DPFLTR_ERROR_LEVEL,
                        "SXS: Unable to enumerate assembly storage subkey #%lu Status = 0x%08lx\n", SubKeyIndex, Status);

                    // Otherwise, cancel the searching and propogate the error status.
                    Data->GetRoot.CancelResolution = TRUE;
                    if (StatusOut != NULL)
                        *StatusOut = Status;

                    break;
                }

                if (KeyData.kbi.NameLength > UNICODE_STRING_MAX_BYTES) {
                    Data->GetRoot.CancelResolution = TRUE;
                    if (StatusOut != NULL)
                        *StatusOut = STATUS_NAME_TOO_LONG;
                    break;
                }

                SubKeyName.Length = (USHORT) KeyData.kbi.NameLength;
                SubKeyName.MaximumLength = SubKeyName.Length;
                SubKeyName.Buffer = KeyData.kbi.Name;

                Status = RtlpGetAssemblyStorageMapRootLocation(
                            KeyHandle,
                            &SubKeyName,
                            &Data->GetRoot.Root);
                if (!NT_SUCCESS(Status)) {
                    DbgPrintEx(
                        DPFLTR_SXS_ID,
                        DPFLTR_ERROR_LEVEL,
                        "SXS: Attempt to get storage location from subkey %wZ failed; Status = 0x%08lx\n", &SubKeyName, Status);

                    Data->GetRoot.CancelResolution = TRUE;
                    if (StatusOut != NULL)
                        *StatusOut = Status;
                    
                    break;
                }
            } else {
                Data->GetRoot.NoMoreEntries = TRUE;
                break;
            }

            break;
        }

        case ASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_REASON_RESOLUTION_SUCCESSFUL:
            // nothing to do...
            break;

        case ASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_REASON_RESOLUTION_ENDING: {
            // close the registry key, if it was opened.
            if (Data->ResolutionEnding.ResolutionContext != NULL) {
                RTL_SOFT_VERIFY(NT_SUCCESS(NtClose((HANDLE) Data->ResolutionEnding.ResolutionContext)));
            }
            break;
        }

    }
}

NTSTATUS
RtlpGetAssemblyStorageMapRootLocation(
    HANDLE KeyHandle,
    PCUNICODE_STRING SubKeyName,
    PUNICODE_STRING Root
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES Obja;
    HANDLE SubKeyHandle = NULL;
    ULONG ResultLength = 0;

    struct {
        KEY_VALUE_PARTIAL_INFORMATION kvpi;
        WCHAR Buffer[DOS_MAX_PATH_LENGTH];
    } ValueData;

    static const WCHAR ValueNameBuffer[] = L"Location";
    static const UNICODE_STRING ValueName = { sizeof(ValueNameBuffer) - sizeof(WCHAR), sizeof(ValueNameBuffer), (PWSTR) ValueNameBuffer };

    ASSERT(KeyHandle != NULL);
    ASSERT(SubKeyName != NULL);
    ASSERT(Root != NULL);

    if ((KeyHandle == NULL) ||
        (SubKeyName == NULL) ||
        (Root == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    InitializeObjectAttributes(
        &Obja,
        (PUNICODE_STRING) &SubKeyName,
        OBJ_CASE_INSENSITIVE,
        KeyHandle,
        NULL);

    Status = NtOpenKey(&SubKeyHandle, KEY_QUERY_VALUE, &Obja);
    if (!NT_SUCCESS(Status)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: Unable to open storage root subkey %wZ; Status = 0x%08lx\n", &SubKeyName, Status);

        goto Exit;
    }

    Status = NtQueryValueKey(
        SubKeyHandle,
        (PUNICODE_STRING) &ValueName,
        KeyValuePartialInformation,
        &ValueData,
        sizeof(ValueData),
        &ResultLength);
    if (!NT_SUCCESS(Status)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: Unabel to query location from storage root subkey %wZ; Status = 0x%08lx\n", &SubKeyName, Status);

        goto Exit;
    }

    if (ValueData.kvpi.Type != REG_SZ) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: Assembly storage root location value type is not REG_SZ\n");
        Status = STATUS_OBJECT_PATH_NOT_FOUND;
        goto Exit;
    }

    if ((ValueData.kvpi.DataLength % 2) != 0) {
        // Hmmm... a unicode string with an odd size??
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: Assembly storage root location value has non-even size\n");
        Status = STATUS_OBJECT_PATH_NOT_FOUND;
        goto Exit;
    }

    if (ValueData.kvpi.DataLength > Root->MaximumLength) {
        // The buffer isn't big enough.  Let's allocate one that is.
        if (ValueData.kvpi.DataLength > UNICODE_STRING_MAX_BYTES) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: Assembly storage root location for %wZ does not fit in a UNICODE STRING\n", &SubKeyName);

            Status = STATUS_NAME_TOO_LONG;
            goto Exit;
        }

        Root->MaximumLength = (USHORT) ValueData.kvpi.DataLength;
        Root->Buffer = (RtlAllocateStringRoutine)(Root->MaximumLength);
        if (Root->Buffer == NULL) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }
    }

    RtlCopyMemory(
        Root->Buffer,
        ValueData.kvpi.Data,
        ValueData.kvpi.DataLength);

    // We checked the length earlier; either it was less than or equal to a value that's
    // already stored in a USHORT or we explicitly compared against UNICODE_STRING_MAX_BYTES.
    Root->Length = (USHORT) ValueData.kvpi.DataLength;

    Status = STATUS_SUCCESS;

Exit:
    if (SubKeyHandle != NULL) {
        RTL_SOFT_VERIFY(NT_SUCCESS(NtClose(SubKeyHandle)));
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\tenv.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    tenv.c

Abstract:

    Test program for the NT OS Runtime Library (RTL) Environment API Calls

Author:

    Steve Wood (stevewo) 30-Jan-1991

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>

VOID
DumpEnvironment( PVOID env )
{
    PWCHAR s = env;

    while (*s) {
        printf( "%79.79ws\n", s );
        while (*s++) {
            }
        }
}

VOID
SetEnvironment(
    PVOID *env,
    PCHAR Name,
    PCHAR Value
    );

VOID
SetEnvironment(
    PVOID *env,
    PCHAR Name,
    PCHAR Value
    )
{
    NTSTATUS Status;
    STRING NameString, ValueString;
    UNICODE_STRING uNameString, uValueString;

    RtlInitString( &NameString, Name );
    Status = RtlAnsiStringToUnicodeString(&uNameString, &NameString, TRUE);
    if (!NT_SUCCESS( Status )) {
        printf( " - failed converting to Unicode, Status == %X\n", Status );
	DumpEnvironment(*env);
	printf( "\n" );
	return;
    }
    if (Value != NULL) {
        RtlInitString( &ValueString, Value );
	Status = RtlAnsiStringToUnicodeString(&uValueString, &ValueString, TRUE);
        printf( "TENV: set variable (%X) %Z=%Z\n", *env, &NameString, &ValueString );
        Status = RtlSetEnvironmentVariable( env, &uNameString, &uValueString );
        printf( "TENV: (%X)", *env);
	RtlFreeUnicodeString(&uNameString);
	RtlFreeUnicodeString(&uValueString);
        }
    else {
        printf( "TENV: delete variable (%X) %Z\n", *env, &NameString );
        Status = RtlSetEnvironmentVariable( env, &uNameString, NULL );
        printf( "TENV: (%X)", *env, &NameString, &ValueString );
	RtlFreeUnicodeString(&uNameString);
        }

    if (NT_SUCCESS( Status )) {
        printf( "\n" );
        }
    else {
        printf( " - failed, Status == %X\n", Status );
        }
    DumpEnvironment(*env);
    printf( "\n" );
}


int
_cdecl
main(
    int argc,
    char **argv,
    char **envp
    )
{
    int i;
    PVOID env;
    PVOID nenv;
    NTSTATUS Status;
    char bigbuf[4100];

    for (i=0; i<argc; i++) {
        printf( "argv[ %d ] = %s\n", i, argv[ i ] );
        }

    i = 0;
    while (envp[ i ]) {
        printf( "envp[ %d ] = %s\n", i, envp[ i ] );
        i++;
        }
    
    for (i=0 ; i<4099 ; i++)
	bigbuf[i] = (i%26) + (((i&1) == 0) ? 'a' : 'A');
    bigbuf[4099] = '\0';

    env = NtCurrentPeb()->ProcessParameters->Environment;
    Status = RtlCreateEnvironment(TRUE, &nenv);	// clone current
    if (!NT_SUCCESS( Status )) {
        printf( "Unable to create clone environment - %X\n", Status );
	return 1;
    }

    // First, check with process environment
    DumpEnvironment( &env);
    SetEnvironment( &env, "aaaa", "12345" );
    SetEnvironment( &env, "aaaa", "1234567890" );
    SetEnvironment( &env, "aaaa", "1" );
    SetEnvironment( &env, "aaaa", "" );
    SetEnvironment( &env, "aaaa", NULL );
    SetEnvironment( &env, "AAAA", "12345" );
    SetEnvironment( &env, "AAAA", "1234567890" );
    SetEnvironment( &env, "AAAA", "1" );
    SetEnvironment( &env, "AAAA", "" );
    SetEnvironment( &env, "AAAA", NULL );
    SetEnvironment( &env, "MMMM", "12345" );
    SetEnvironment( &env, "MMMM", "1234567890" );
    SetEnvironment( &env, "MMMM", "1" );
    SetEnvironment( &env, "MMMM", "" );
    SetEnvironment( &env, "MMMM", NULL );
    SetEnvironment( &env, "ZZZZ", "12345" );
    SetEnvironment( &env, "ZZZZ", "1234567890" );
    SetEnvironment( &env, "ZZZZ", "1" );
    SetEnvironment( &env, "ZZZZ", "" );
    SetEnvironment( &env, "ZZZZ", NULL );
    SetEnvironment( &env, "BIGBUF", bigbuf );
    SetEnvironment( &env, "BIGBUF", NULL );

    // Second, check with non-process environment
    DumpEnvironment(nenv);
    SetEnvironment( &nenv, "aaaa", "12345" );
    SetEnvironment( &nenv, "aaaa", "1234567890" );
    SetEnvironment( &nenv, "aaaa", "1" );
    SetEnvironment( &nenv, "aaaa", "" );
    SetEnvironment( &nenv, "aaaa", NULL );
    SetEnvironment( &nenv, "AAAA", "12345" );
    SetEnvironment( &nenv, "AAAA", "1234567890" );
    SetEnvironment( &nenv, "AAAA", "1" );
    SetEnvironment( &nenv, "AAAA", "" );
    SetEnvironment( &nenv, "AAAA", NULL );
    SetEnvironment( &nenv, "MMMM", "12345" );
    SetEnvironment( &nenv, "MMMM", "1234567890" );
    SetEnvironment( &nenv, "MMMM", "1" );
    SetEnvironment( &nenv, "MMMM", "" );
    SetEnvironment( &nenv, "MMMM", NULL );
    SetEnvironment( &nenv, "ZZZZ", "12345" );
    SetEnvironment( &nenv, "ZZZZ", "1234567890" );
    SetEnvironment( &nenv, "ZZZZ", "1" );
    SetEnvironment( &nenv, "ZZZZ", "" );
    SetEnvironment( &nenv, "ZZZZ", NULL );
    SetEnvironment( &nenv, "BIGBUF", bigbuf );
    SetEnvironment( &nenv, "BIGBUF", NULL );
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\terminate.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    terminate.cpp

Abstract:

    temporary support for C++ exception handling

Author:

    Jay Krell (a-JayK) October 2000

Environment:

    User Mode

Revision History:

--*/
#include "ntos.h"
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "ntxcapi.h"

void __cdecl terminate(void)
{
#if DBG
    DbgPrint("NTDLL:"__FUNCTION__":NtTerminateThread(NtCurrentThread(), STATUS_UNHANDLED_EXCEPTION)\n");
    DbgBreakPoint();
#endif
    NtTerminateThread(NtCurrentThread(), STATUS_UNHANDLED_EXCEPTION);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\sxsquery.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sxsquery.c

Abstract:

    Side-by-side activation support for Windows/NT
    Implementation of query functions over activation contexts

Author:

    Michael Grier (MGrier) 1/18/2001

Revision History:

    1/18/2001 - MGrier  - initial; split off from sxsactctx.c.
    3/15/2001 - xiaoyuw - add support query for Assembly of Actctx and files of Assembly info
    5/2001 - JayKrell - more query support (from hmodule, from address, noaddref)

--*/

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // condition expression is constant

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <sxstypes.h>
#include "sxsp.h"
#include "ldrp.h"
typedef const void *PCVOID;

VOID
RtlpLocateActivationContextSectionForQuery(
    OUT PULONG                   Disposition,
    OUT NTSTATUS*                Status,
    PVOID                        Buffer,
    SIZE_T                       InLength,
    PSIZE_T                      OutLength OPTIONAL,
    SIZE_T                       MinimumLength,
    IN PCACTIVATION_CONTEXT_DATA ActivationContextData,
    IN const GUID *              ExtensionGuid OPTIONAL,
    IN ULONG                     Id,
    OUT VOID CONST **            SectionData,
    OUT ULONG *                  SectionLength
    )
{
#define RTLP_LOCATE_ACTIVATION_CONTEXT_SECTION_FOR_QUERY_CONTINUE (1)
#define RTLP_LOCATE_ACTIVATION_CONTEXT_SECTION_FOR_QUERY_RETURN   (2)
    ASSERT(Status != NULL);
    ASSERT(Disposition != NULL);

    if (ActivationContextData != NULL) {
        *Status = RtlpLocateActivationContextSection(ActivationContextData, ExtensionGuid, Id, SectionData, SectionLength);
        if (*Status != STATUS_SXS_SECTION_NOT_FOUND) {
            if (NT_SUCCESS(*Status))
                *Disposition = RTLP_LOCATE_ACTIVATION_CONTEXT_SECTION_FOR_QUERY_CONTINUE;
            else
                *Disposition = RTLP_LOCATE_ACTIVATION_CONTEXT_SECTION_FOR_QUERY_RETURN;
            return;
        }
    }
    *Disposition = RTLP_LOCATE_ACTIVATION_CONTEXT_SECTION_FOR_QUERY_RETURN;

    if (MinimumLength > InLength) {
        *Status = STATUS_BUFFER_TOO_SMALL;
        return;
    }
    RtlZeroMemory(Buffer, MinimumLength);
    if (OutLength != NULL)
        *OutLength = MinimumLength;
    *Status = STATUS_SUCCESS;
}

NTSTATUS
RtlpCrackActivationContextStringSectionHeader(
    IN PCVOID SectionBase,
    IN SIZE_T SectionLength,
    OUT ULONG *FormatVersion OPTIONAL,
    OUT ULONG *DataFormatVersion OPTIONAL,
    OUT ULONG *SectionFlags OPTIONAL,
    OUT ULONG *ElementCount OPTIONAL,
    OUT PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY *Elements OPTIONAL,
    OUT ULONG *HashAlgorithm OPTIONAL,
    OUT PCVOID *SearchStructure OPTIONAL,
    OUT ULONG *UserDataLength OPTIONAL,
    OUT PCVOID *UserData OPTIONAL
    )
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR; // in case someone forgets to set it...
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header = (PCACTIVATION_CONTEXT_STRING_SECTION_HEADER) SectionBase;

    if (FormatVersion != NULL)
        *FormatVersion = 0;

    if (DataFormatVersion != NULL)
        *DataFormatVersion = 0;

    if (SectionFlags != NULL)
        *SectionFlags = 0;

    if (ElementCount != NULL)
        *ElementCount = 0;

    if (Elements != NULL)
        *Elements = NULL;

    if (HashAlgorithm != NULL)
        *HashAlgorithm = 0;

    if (SearchStructure != NULL)
        *SearchStructure = NULL;

    if (UserDataLength != NULL)
        *UserDataLength = 0;

    if (UserData != NULL)
        *UserData = NULL;

    if (SectionLength < (RTL_SIZEOF_THROUGH_FIELD(ACTIVATION_CONTEXT_STRING_SECTION_HEADER, HeaderSize))) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() passed string section at %p only %lu bytes long; that's not even enough for the 4-byte magic and 4-byte header length!\n",
            __FUNCTION__,
            SectionBase,
            SectionLength);
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    if (Header->Magic != ACTIVATION_CONTEXT_STRING_SECTION_MAGIC) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() found assembly information section with wrong magic value\n"
            "   Expected %lu; got %lu\n",
            __FUNCTION__,
            ACTIVATION_CONTEXT_STRING_SECTION_MAGIC,
            Header->Magic);

        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    // Pedantic: check to see if the header size claimed includes the header size field so that we can safely use it.
    if (!RTL_CONTAINS_FIELD(Header, Header->HeaderSize, HeaderSize)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() passed string section at %p claims %lu byte header size; that doesn't even include the HeaderSize member!\n",
            __FUNCTION__,
            Header,
            Header->HeaderSize);
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    // Now we're just going to jump forward to the last known member that we expect to see; UserDataSize...
    if (!RTL_CONTAINS_FIELD(Header, Header->HeaderSize, UserDataSize)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() passed string section at %p with too small of a header\n"
            "   HeaderSize: %lu\n"
            "   Required: %lu\n",
            __FUNCTION__,
            Header,
            Header->HeaderSize,
            RTL_SIZEOF_THROUGH_FIELD(ACTIVATION_CONTEXT_STRING_SECTION_HEADER, UserDataSize));

        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    if ((Header->ElementListOffset != 0) &&
        (Header->ElementListOffset < Header->HeaderSize)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() found assembly information section with element list overlapping section header\n"
            "   Section header: %p\n"
            "   Header Size: %lu\n"
            "   ElementListOffset: %lu\n",
            __FUNCTION__,
            Header,
            Header->HeaderSize,
            Header->ElementListOffset);
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    if ((Header->SearchStructureOffset != 0) &&
        (Header->SearchStructureOffset < Header->HeaderSize)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() found assembly information section with search structure overlapping section header\n"
            "   Section header: %p\n"
            "   Header Size: %lu\n"
            "   SearchStructureOffset: %lu\n",
            __FUNCTION__,
            Header,
            Header->HeaderSize,
            Header->SearchStructureOffset);
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    if ((Header->UserDataOffset != 0) &&
        (Header->UserDataOffset < Header->HeaderSize)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() found assembly information section with user data overlapping section header\n"
            "   Section header: %p\n"
            "   Header Size: %lu\n"
            "   User Data Offset: %lu\n",
            __FUNCTION__,
            Header,
            Header->HeaderSize,
            Header->UserDataOffset);
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    if (Header->UserDataSize < sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() found assembly information section with user data too small\n"
            "   Section header: %p\n"
            "   UserDataSize: %lu; needed: %lu\n",
            __FUNCTION__,
            Header,
            Header->UserDataSize, sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION));
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    if ((Header->UserDataOffset + Header->UserDataSize) > SectionLength) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() found assembly information section with user data extending beyond section data\n"
            "   Section header: %p\n"
            "   UserDataSize: %lu\n"
            "   UserDataOffset: %lu\n"
            "   Section size: %lu\n",
            __FUNCTION__,
            Header,
            Header->UserDataSize,
            Header->UserDataOffset,
            SectionLength);

        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    if (FormatVersion != NULL)
        *FormatVersion = Header->FormatVersion;

    if (DataFormatVersion != NULL)
        *DataFormatVersion = Header->DataFormatVersion;

    if (SectionFlags != NULL)
        *SectionFlags = Header->Flags;

    if (ElementCount != NULL)
        *ElementCount = Header->ElementCount;

    if (Elements != NULL) {
        if (Header->ElementListOffset == 0)
            *Elements = NULL;
        else
            *Elements = (PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY) (((ULONG_PTR) Header) + Header->ElementListOffset);
    }

    if (HashAlgorithm != NULL)
        *HashAlgorithm = Header->HashAlgorithm;

    if (SearchStructure != NULL) {
        if (Header->SearchStructureOffset == 0)
            *SearchStructure = NULL;
        else
            *SearchStructure = (PCVOID) (((ULONG_PTR) Header) + Header->SearchStructureOffset);
    }

    if (UserDataLength != NULL)
        *UserDataLength = Header->UserDataSize;

    if (UserData != NULL) {
        if (Header->UserDataOffset == 0)
            *UserData = NULL;
        else
            *UserData = (PCVOID) (((ULONG_PTR) Header) + Header->UserDataOffset);
    }

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}


NTSTATUS
RtlpGetActiveActivationContextApplicationDirectory(
    IN SIZE_T InLength,
    OUT PVOID OutBuffer,
    OUT SIZE_T *OutLength
    )
// This is never used.
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;
    PCRTL_ACTIVATION_CONTEXT_STACK_FRAME Frame = NULL;
    PCACTIVATION_CONTEXT_DATA ActivationContextData = NULL;
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header = NULL;
    const PPEB Peb = NtCurrentPeb();
    const PTEB Teb = NtCurrentTeb();
    PVOID pvTemp = NULL;
    ULONG ulTemp = 0;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION GlobalInfo = NULL;

    if (OutLength != NULL)
        *OutLength = 0;

    if (((InLength != 0) && (OutBuffer == NULL)) ||
        ((OutBuffer == NULL) && (OutLength == NULL))) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s(): called with invalid parameters\n"
            "   InLength = %Iu\n"
            "   OutBuffer = %p\n"
            "   OutLength = %p\n",
            __FUNCTION__,
            InLength,
            OutBuffer,
            OutLength);
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Frame = (PCRTL_ACTIVATION_CONTEXT_STACK_FRAME) Teb->ActivationContextStack.ActiveFrame;

    if (Frame == NULL) {
        ActivationContextData = (PCACTIVATION_CONTEXT_DATA) Peb->ActivationContextData;
    } else {
        ActivationContextData = Frame->ActivationContext->ActivationContextData;
    }

    // We need to find the assembly metadata section...
    Status = RtlpLocateActivationContextSection(ActivationContextData, NULL, ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION, &pvTemp, &ulTemp);
    if (!NT_SUCCESS(Status))
        goto Exit;

    if (ulTemp < sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HEADER)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() found assembly information string section with header too small\n"
            "   Expected at least %lu; got %lu bytes\n",
            __FUNCTION__,
            sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HEADER),
            ulTemp);
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    Header = (PCACTIVATION_CONTEXT_STRING_SECTION_HEADER) pvTemp;

    if (Header->Magic != ACTIVATION_CONTEXT_STRING_SECTION_MAGIC) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() found assembly information section with wrong magic value\n"
            "   Expected %lu; got %lu\n",
            __FUNCTION__,
            ACTIVATION_CONTEXT_STRING_SECTION_MAGIC,
            Header->Magic);

        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    if (Header->UserDataOffset < sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HEADER)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() found assembly information section with user data overlapping section header\n"
            "   Section header: %p\n"
            "   User Data Offset: %lu\n",
            __FUNCTION__,
            Header,
            Header->UserDataOffset);
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    if (Header->UserDataSize < sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() found assembly information section with user data too small\n"
            "   Section header: %p\n"
            "   UserDataSize: %lu; needed: %lu\n",
            __FUNCTION__,
            Header,
            Header->UserDataSize, sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION));
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    if ((Header->UserDataOffset + Header->UserDataSize) > ulTemp) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() found assembly information section with user data extending beyond section data\n"
            "   Section header: %p\n"
            "   UserDataSize: %lu\n"
            "   UserDataOffset: %lu\n"
            "   Section size: %lu\n",
            __FUNCTION__,
            Header,
            Header->UserDataSize,
            Header->UserDataOffset,
            ulTemp);

        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    GlobalInfo = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION) (((ULONG_PTR) Header) + Header->UserDataOffset);

    if (GlobalInfo->Size < sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() found assembly information section global data with size less than structure size\n"
            "   Section header: %p\n"
            "   Global Info: %p\n"
            "   Global Info Size: %lu\n"
            "   Structure size: %lu\n",
            __FUNCTION__,
            Header,
            GlobalInfo,
            GlobalInfo->Size,
            sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION));
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    if (GlobalInfo->ApplicationDirectoryOffset != 0) {
        if (GlobalInfo->ApplicationDirectoryOffset < sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION)) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() found assembly information section global data with app dir offset within base structure\n"
                "   Section header: %p\n"
                "   GlobalInfo: %p\n"
                "   ApplicationDirectoryOffset: %lu\n",
                __FUNCTION__,
                Header,
                GlobalInfo,
                GlobalInfo->ApplicationDirectoryOffset);
            Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
            goto Exit;
        }

        if ((GlobalInfo->ApplicationDirectoryOffset + GlobalInfo->ApplicationDirectoryLength) > GlobalInfo->Size) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() found assembly information section global data with app dir extending beyond end of global data\n"
                "   Section header: %p\n"
                "   GlobalInfo: %p\n"
                "   ApplicationDirectoryOffset: %lu\n"
                "   ApplicationDirectoryLength: %lu\n"
                "   GlobalInfo size: %lu\n",
                __FUNCTION__,
                Header,
                GlobalInfo,
                GlobalInfo->ApplicationDirectoryOffset,
                GlobalInfo->ApplicationDirectoryLength,
                GlobalInfo->Size);
            Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
            goto Exit;
        }

        if (InLength < GlobalInfo->ApplicationDirectoryLength) {
            if (OutLength != NULL)
                *OutLength = GlobalInfo->ApplicationDirectoryLength;

            Status = STATUS_BUFFER_TOO_SMALL;
            goto Exit;
        }

        RtlCopyMemory(
            OutBuffer,
            (PVOID) (((ULONG_PTR) GlobalInfo) + GlobalInfo->ApplicationDirectoryOffset),
            GlobalInfo->ApplicationDirectoryLength);

        if (OutLength != NULL)
            *OutLength = GlobalInfo->ApplicationDirectoryLength;
    } else {
        // Hmm... there's just no application directory
        if (OutLength != NULL)
            *OutLength = 0; // I think we already did this but what the heck
    }

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

#define \
RTLP_QUERY_INFORMATION_ACTIVATION_CONTEXT_BASIC_INFORMATION_FLAG_NO_ADDREF (0x00000001)

NTSTATUS
RtlpQueryInformationActivationContextBasicInformation(
    IN ULONG                Flags,
    IN PCACTIVATION_CONTEXT ConstActivationContext,
    IN PCACTIVATION_CONTEXT_DATA ActivationContextData,
    IN ULONG SubInstanceIndex,
    OUT PVOID Buffer,
    IN SIZE_T InLength,
    OUT PSIZE_T OutLength OPTIONAL
    )
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;
    PACTIVATION_CONTEXT ActivationContext = RTL_CONST_CAST(PACTIVATION_CONTEXT)(ConstActivationContext);
    PACTIVATION_CONTEXT_BASIC_INFORMATION Info = (PACTIVATION_CONTEXT_BASIC_INFORMATION) Buffer;

    if (OutLength != NULL)
        *OutLength = 0;

    if (SubInstanceIndex != 0) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() received invalid non-zero sub-instance index %lu\n",
            __FUNCTION__,
            SubInstanceIndex);
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (InLength < sizeof(ACTIVATION_CONTEXT_BASIC_INFORMATION)) {
        if (OutLength != NULL) {
            *OutLength = sizeof(ACTIVATION_CONTEXT_BASIC_INFORMATION);
        }
        Status = STATUS_BUFFER_TOO_SMALL;
        goto Exit;
    }

    if (ActivationContextData != NULL)
        Info->Flags = ActivationContextData->Flags;
    else
        Info->Flags = 0;

    if ((Flags & RTLP_QUERY_INFORMATION_ACTIVATION_CONTEXT_BASIC_INFORMATION_FLAG_NO_ADDREF) == 0) {
        RtlAddRefActivationContext(ActivationContext);
    }
    Info->ActivationContext = ActivationContext;

    if (OutLength != NULL)
        *OutLength = sizeof(ACTIVATION_CONTEXT_BASIC_INFORMATION);

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

NTSTATUS
RtlpQueryInformationActivationContextDetailedInformation(
    PCACTIVATION_CONTEXT_DATA ActivationContextData,
    ULONG SubInstanceIndex,
    OUT PVOID Buffer,
    IN SIZE_T InLength,
    OUT PSIZE_T OutLength OPTIONAL
    )
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;
    PACTIVATION_CONTEXT_DETAILED_INFORMATION Info = (PACTIVATION_CONTEXT_DETAILED_INFORMATION) Buffer;
    SIZE_T BytesNeeded = 0;
    PCVOID StringSectionHeader;
    ULONG StringSectionSize;
    ULONG DataFormatVersion;
    PCVOID UserData;
    ULONG UserDataSize;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER AssemblyRosterHeader = NULL;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY AssemblyRosterEntryList = NULL;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION RootAssemblyInformation = NULL;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION AssemblyGlobalInformation = NULL;
    ULONG i;
    ULONG EntryCount;
    PWSTR Cursor = NULL;
    ULONG RtlpLocateActivationContextSectionForQueryDisposition = 0;

    if (OutLength != NULL)
        *OutLength = 0;
    
    if (SubInstanceIndex != 0) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() received invalid non-zero sub-instance index %lu\n",
            __FUNCTION__,
            SubInstanceIndex);
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    // We can't actually do the easy check of InLength against the structure size; we have to figure out the
    // total bytes we need to include all the paths, etc.

    // We need to find the assembly metadata section...
    RtlpLocateActivationContextSectionForQuery(
        &RtlpLocateActivationContextSectionForQueryDisposition,
        &Status,
        Buffer,
        InLength,
        OutLength,
        sizeof(*Info),
        ActivationContextData,
        NULL,
        ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION,
        &StringSectionHeader,
        &StringSectionSize
        );
    switch (RtlpLocateActivationContextSectionForQueryDisposition) {
        case RTLP_LOCATE_ACTIVATION_CONTEXT_SECTION_FOR_QUERY_RETURN:
            goto Exit;
        case RTLP_LOCATE_ACTIVATION_CONTEXT_SECTION_FOR_QUERY_CONTINUE:
            break;
    }
    Status = RtlpCrackActivationContextStringSectionHeader(
        StringSectionHeader,
        StringSectionSize,
        NULL,
        &DataFormatVersion,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        &UserDataSize,
        &UserData);
    if (!NT_SUCCESS(Status))
        goto Exit;

    AssemblyRosterHeader = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER) (((ULONG_PTR) ActivationContextData) + ActivationContextData->AssemblyRosterOffset);
    AssemblyRosterEntryList = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY) (((ULONG_PTR) ActivationContextData) + AssemblyRosterHeader->FirstEntryOffset);

    EntryCount = AssemblyRosterHeader->EntryCount;

    // 1-based counting for Asseblies in the actctx
    for (i=1; i<EntryCount; i++) {
        if (AssemblyRosterEntryList[i].Flags & ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_ROOT)
            break;
    }

    if (i == EntryCount) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() found activation context data at %p with assembly roster that has no root\n",
            __FUNCTION__,
            ActivationContextData);
        Status = STATUS_SXS_INVALID_ACTCTXDATA_FORMAT;
        goto Exit;
    }

    RootAssemblyInformation = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION) (((ULONG_PTR) ActivationContextData) + AssemblyRosterEntryList[i].AssemblyInformationOffset);
    AssemblyGlobalInformation = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION) UserData;

    // Ok, we have everything we could need.  Figure out the size of the buffer required.

    BytesNeeded = sizeof(ACTIVATION_CONTEXT_DETAILED_INFORMATION);

    if (RootAssemblyInformation->ManifestPathLength != 0)
        BytesNeeded += (RootAssemblyInformation->ManifestPathLength + sizeof(WCHAR));

    if (RootAssemblyInformation->PolicyPathLength != 0)
        BytesNeeded += (RootAssemblyInformation->PolicyPathLength + sizeof(WCHAR));

    if (AssemblyGlobalInformation->ApplicationDirectoryLength != 0)
        BytesNeeded += (AssemblyGlobalInformation->ApplicationDirectoryLength + sizeof(WCHAR));

    if (BytesNeeded > InLength) {
        if (OutLength != NULL)
            *OutLength = BytesNeeded;

        Status = STATUS_BUFFER_TOO_SMALL;
        goto Exit;
    }

    // Wow, it's all there and ready to go.  Let's fill in!

    Cursor = (PWSTR) (Info + 1);

    Info->dwFlags = ActivationContextData->Flags;
    Info->ulFormatVersion = ActivationContextData->FormatVersion;
    Info->ulAssemblyCount = AssemblyRosterHeader->EntryCount - 1;
    Info->ulRootManifestPathType = RootAssemblyInformation->ManifestPathType;
    Info->ulRootManifestPathChars = (RootAssemblyInformation->ManifestPathLength / sizeof(WCHAR));
    Info->lpRootManifestPath = NULL;
    Info->ulRootConfigurationPathType = RootAssemblyInformation->PolicyPathType;
    Info->ulRootConfigurationPathChars = (RootAssemblyInformation->PolicyPathLength / sizeof(WCHAR));
    Info->lpRootConfigurationPath = NULL;
    Info->ulAppDirPathType = AssemblyGlobalInformation->ApplicationDirectoryPathType;
    Info->ulAppDirPathChars = (AssemblyGlobalInformation->ApplicationDirectoryLength / sizeof(WCHAR));
    Info->lpAppDirPath = NULL;

    // And copy the strings...    
    if (RootAssemblyInformation->ManifestPathLength != 0) {
        RtlCopyMemory(
            Cursor,
            (PVOID) (((ULONG_PTR) StringSectionHeader) + RootAssemblyInformation->ManifestPathOffset),
            RootAssemblyInformation->ManifestPathLength);
        Info->lpRootManifestPath = Cursor;
        Cursor = (PWSTR) (((ULONG_PTR) Cursor) + RootAssemblyInformation->ManifestPathLength);
        *Cursor++ = L'\0';
    }
    
    if (RootAssemblyInformation->PolicyPathLength != 0) {
        RtlCopyMemory(
            Cursor,
            (PVOID) (((ULONG_PTR) StringSectionHeader) + RootAssemblyInformation->PolicyPathOffset),
            RootAssemblyInformation->PolicyPathLength);
        Info->lpRootConfigurationPath = Cursor;
        Cursor = (PWSTR) (((ULONG_PTR) Cursor) + RootAssemblyInformation->PolicyPathLength);
        *Cursor++ = L'\0';
    }
    
    if (AssemblyGlobalInformation->ApplicationDirectoryLength != 0) {
        RtlCopyMemory(
            Cursor,
            (PVOID) (((ULONG_PTR) AssemblyGlobalInformation) + AssemblyGlobalInformation->ApplicationDirectoryOffset),
            AssemblyGlobalInformation->ApplicationDirectoryLength);
        Info->lpAppDirPath = Cursor;
        Cursor = (PWSTR) (((ULONG_PTR) Cursor) + AssemblyGlobalInformation->ApplicationDirectoryLength);
        *Cursor++ = L'\0';
    }

    ASSERT((((ULONG_PTR) Cursor) - ((ULONG_PTR) Info)) == BytesNeeded);

    if (OutLength != NULL)
        *OutLength = BytesNeeded;

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

NTSTATUS 
RtlpQueryAssemblyInformationActivationContextDetailedInformation(
    PCACTIVATION_CONTEXT_DATA ActivationContextData,
    ULONG SubInstanceIndex,     // 0-based index of assembly
    OUT PVOID Buffer,
    IN SIZE_T InLength,
    OUT PSIZE_T OutLength OPTIONAL
    )
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;
    SIZE_T BytesNeeded = 0;
    PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION Info= (PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION)Buffer;
    PCVOID StringSectionHeader;
    ULONG StringSectionSize;
    PWSTR Cursor = NULL;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER AssemblyRosterHeader = NULL;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY AssemblyRosterEntryList = NULL;
    PACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION AssemlbyDataInfo = NULL;
    ULONG RtlpLocateActivationContextSectionForQueryDisposition = 0;

    if (OutLength != NULL)
        *OutLength = 0;
    
    // We can't actually do the easy check of InLength against the structure size; we have to figure out the
    // total bytes we need to include all the paths, etc.

    AssemblyRosterHeader = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER) (((ULONG_PTR) ActivationContextData) + ActivationContextData->AssemblyRosterOffset);
    AssemblyRosterEntryList = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY) (((ULONG_PTR) ActivationContextData) + AssemblyRosterHeader->FirstEntryOffset);
    
    if (SubInstanceIndex > AssemblyRosterHeader->EntryCount) // AssemblyRosterHeader->EntryCount is 1-based, 
    {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() received invalid sub-instance index %lu out of %lu Assemblies in the Acitvation Context\n",
            __FUNCTION__,
            SubInstanceIndex, 
            AssemblyRosterHeader->EntryCount
            );
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    AssemlbyDataInfo = (PACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION)((ULONG_PTR)ActivationContextData + AssemblyRosterEntryList[SubInstanceIndex].AssemblyInformationOffset);

    // We need to find the assembly metadata section...
    RtlpLocateActivationContextSectionForQuery(
        &RtlpLocateActivationContextSectionForQueryDisposition,
        &Status,
        Buffer,
        InLength,
        OutLength,
        sizeof(ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
        ActivationContextData,
        NULL,
        ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION,
        &StringSectionHeader,
        &StringSectionSize
        );
    switch (RtlpLocateActivationContextSectionForQueryDisposition) {
        case RTLP_LOCATE_ACTIVATION_CONTEXT_SECTION_FOR_QUERY_RETURN:
            goto Exit;
        case RTLP_LOCATE_ACTIVATION_CONTEXT_SECTION_FOR_QUERY_CONTINUE:
            break;
    }

    // Figure out the size of the buffer required.
    BytesNeeded = sizeof(ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION);

    if (AssemlbyDataInfo->EncodedAssemblyIdentityLength != 0 )
        BytesNeeded += (AssemlbyDataInfo->EncodedAssemblyIdentityLength + sizeof(WCHAR));

    if (AssemlbyDataInfo->ManifestPathLength != 0 )
        BytesNeeded += (AssemlbyDataInfo->ManifestPathLength + sizeof(WCHAR));
    
    if (AssemlbyDataInfo->PolicyPathLength != 0 )
        BytesNeeded += (AssemlbyDataInfo->PolicyPathLength + sizeof(WCHAR));

    if (AssemlbyDataInfo->AssemblyDirectoryNameLength != 0 )
        BytesNeeded += (AssemlbyDataInfo->AssemblyDirectoryNameLength + sizeof(WCHAR));

    if (BytesNeeded > InLength) {
        if (OutLength != NULL)
            *OutLength = BytesNeeded;

        Status = STATUS_BUFFER_TOO_SMALL;
        goto Exit;
    }

    // fill in the struct

    Cursor = (PWSTR) (Info + 1);
    Info->ulFlags = AssemlbyDataInfo->Flags;
    Info->ulEncodedAssemblyIdentityLength   = AssemlbyDataInfo->EncodedAssemblyIdentityLength;
    Info->ulManifestPathType                = AssemlbyDataInfo->ManifestPathType;
    Info->ulManifestPathLength              = AssemlbyDataInfo->ManifestPathLength ;
    Info->liManifestLastWriteTime           = AssemlbyDataInfo->ManifestLastWriteTime;
    Info->ulPolicyPathType                  = AssemlbyDataInfo->PolicyPathType;
    Info->ulPolicyPathLength                = AssemlbyDataInfo->PolicyPathLength;
    Info->liPolicyLastWriteTime             = AssemlbyDataInfo->PolicyLastWriteTime;
    Info->ulMetadataSatelliteRosterIndex    = AssemlbyDataInfo->MetadataSatelliteRosterIndex;
    
    Info->ulManifestVersionMajor            = AssemlbyDataInfo->ManifestVersionMajor;
    Info->ulManifestVersionMinor            = AssemlbyDataInfo->ManifestVersionMinor;
    Info->ulPolicyVersionMajor              = AssemlbyDataInfo->PolicyVersionMajor;
    Info->ulPolicyVersionMinor              = AssemlbyDataInfo->PolicyVersionMinor;
    Info->ulAssemblyDirectoryNameLength     = AssemlbyDataInfo->AssemblyDirectoryNameLength;          // in bytes    

    Info->lpAssemblyEncodedAssemblyIdentity = NULL;
    Info->lpAssemblyManifestPath            = NULL;
    Info->lpAssemblyPolicyPath              = NULL;
    Info->lpAssemblyDirectoryName           = NULL;
    Info->ulFileCount                       = AssemlbyDataInfo->NumOfFilesInAssembly;

    if (AssemlbyDataInfo->EncodedAssemblyIdentityLength != 0) {
        RtlCopyMemory(
            Cursor,
            (PVOID) (((ULONG_PTR) StringSectionHeader) + AssemlbyDataInfo->EncodedAssemblyIdentityOffset),
            AssemlbyDataInfo->EncodedAssemblyIdentityLength);
        Info->lpAssemblyEncodedAssemblyIdentity = Cursor;
        Cursor = (PWSTR) (((ULONG_PTR) Cursor) + AssemlbyDataInfo->EncodedAssemblyIdentityLength);
        *Cursor++ = L'\0';
    }

    if (AssemlbyDataInfo->ManifestPathLength != 0) {
        RtlCopyMemory(
            Cursor,
            (PVOID) (((ULONG_PTR) StringSectionHeader) + AssemlbyDataInfo->ManifestPathOffset),
            AssemlbyDataInfo->ManifestPathLength);
        Info->lpAssemblyManifestPath = Cursor;
        Cursor = (PWSTR) (((ULONG_PTR) Cursor) + AssemlbyDataInfo->ManifestPathLength);
        *Cursor++ = L'\0';
    }

    if (AssemlbyDataInfo->PolicyPathLength != 0) {
        RtlCopyMemory(
            Cursor,
            (PVOID) (((ULONG_PTR) StringSectionHeader) + AssemlbyDataInfo->PolicyPathOffset),
            AssemlbyDataInfo->PolicyPathLength);
        Info->lpAssemblyPolicyPath = Cursor;
        Cursor = (PWSTR) (((ULONG_PTR) Cursor) + AssemlbyDataInfo->PolicyPathLength);
        *Cursor++ = L'\0';
    }

    if (AssemlbyDataInfo->AssemblyDirectoryNameLength != 0) {
        RtlCopyMemory(
            Cursor,
            (PVOID) (((ULONG_PTR) StringSectionHeader) + AssemlbyDataInfo->AssemblyDirectoryNameOffset),
            AssemlbyDataInfo->AssemblyDirectoryNameLength);
        Info->lpAssemblyDirectoryName = Cursor;
        Cursor = (PWSTR) (((ULONG_PTR) Cursor) + AssemlbyDataInfo->AssemblyDirectoryNameLength);
        *Cursor++ = L'\0';
    }

    ASSERT((((ULONG_PTR) Cursor) - ((ULONG_PTR) Info)) == BytesNeeded);

    if (OutLength != NULL)
        *OutLength = BytesNeeded;

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

NTSTATUS
RtlpQueryFilesInAssemblyInformationActivationContextDetailedInformation(
    PCACTIVATION_CONTEXT_DATA ActivationContextData,
    PCACTIVATION_CONTEXT_QUERY_INDEX SubInstanceIndex,
    OUT PVOID Buffer,
    IN SIZE_T InLength,
    OUT PSIZE_T OutLength OPTIONAL
    )
{    
    NTSTATUS Status = STATUS_INTERNAL_ERROR;
    SIZE_T BytesNeeded = 0;
    PASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION Info= (PASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION)Buffer;
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER StringSectionHeader=NULL;
    ULONG StringSectionSize;
    PWSTR Cursor = NULL;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER AssemblyRosterHeader = NULL;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY AssemblyRosterEntryList = NULL;
    PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY ElementList = NULL;
    PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION EntryData = NULL;
    ULONG i, CounterForFilesFoundInSpecifiedAssembly;
    PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT PathSegments = NULL;
    ULONG RtlpLocateActivationContextSectionForQueryDisposition = 0;


    if (OutLength != NULL)
        *OutLength = 0;
    
    // We can't actually do the easy check of InLength against the structure size; we have to figure out the
    // total bytes we need to include all the paths, etc.

    AssemblyRosterHeader = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER) (((ULONG_PTR) ActivationContextData) + ActivationContextData->AssemblyRosterOffset);
    AssemblyRosterEntryList = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY) (((ULONG_PTR) ActivationContextData) + AssemblyRosterHeader->FirstEntryOffset);

    if (SubInstanceIndex->ulAssemblyIndex >= AssemblyRosterHeader->EntryCount - 1)// AssemblyRosterHeader->EntryCount is 1-based,                                                                               
    {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() received invalid sub-instance index %lu out of %lu Assemblies in the Acitvation Context\n",
            __FUNCTION__,
            SubInstanceIndex->ulAssemblyIndex, 
            AssemblyRosterHeader->EntryCount
            );
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }    

    // We need to find the assembly metadata section...
    RtlpLocateActivationContextSectionForQuery(
        &RtlpLocateActivationContextSectionForQueryDisposition,
        &Status,
        Buffer,
        InLength,
        OutLength,
        sizeof(ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
        ActivationContextData,
        NULL,
        ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION,
        &StringSectionHeader,
        &StringSectionSize
        );
    switch (RtlpLocateActivationContextSectionForQueryDisposition) {
        case RTLP_LOCATE_ACTIVATION_CONTEXT_SECTION_FOR_QUERY_RETURN:
            goto Exit;
        case RTLP_LOCATE_ACTIVATION_CONTEXT_SECTION_FOR_QUERY_CONTINUE:
            break;
    }

    if (SubInstanceIndex->ulFileIndexInAssembly >= StringSectionHeader->ElementCount) 
    {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() received invalid file index (%d) in Assembly (%d)\n",
            __FUNCTION__,
            SubInstanceIndex->ulFileIndexInAssembly, 
            SubInstanceIndex->ulAssemblyIndex, 
            StringSectionHeader->ElementCount
            );
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (StringSectionHeader->ElementListOffset != 0)
        ElementList = (PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY)(((ULONG_PTR)StringSectionHeader) + StringSectionHeader->ElementListOffset);
    else
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Exit;
    } 
    
    CounterForFilesFoundInSpecifiedAssembly = 0 ;
    EntryData = NULL;
    for ( i = 0 ; i < StringSectionHeader->ElementCount; i++ ) 
    {
        // for a specified assembly
        if (ElementList[i].AssemblyRosterIndex == SubInstanceIndex->ulAssemblyIndex + 1)
        {       
            // for specified file in this assembly   
            if (CounterForFilesFoundInSpecifiedAssembly == SubInstanceIndex->ulFileIndexInAssembly) 
            {
                if (ElementList[i].Offset != 0) 
                {
                    // we found the right one                    
                    EntryData = (PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION)(((ULONG_PTR)StringSectionHeader) + ElementList[i].Offset);
                    break;
                }
            }
            CounterForFilesFoundInSpecifiedAssembly ++;            
        }
    }
    if (EntryData == NULL )
    {        
        Status = STATUS_INTERNAL_ERROR;
        goto Exit;
    }

    // figure out buffer size needed

    BytesNeeded = sizeof(ASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION);

    if (ElementList[i].KeyLength != 0)
        BytesNeeded += (ElementList[i].KeyLength + sizeof(WCHAR)); // for filename       

    if (EntryData->TotalPathLength != 0)
        BytesNeeded += (EntryData->TotalPathLength + sizeof(WCHAR));

    if (BytesNeeded > InLength) 
    {
        if (OutLength != NULL)
            *OutLength = BytesNeeded;

        Status = STATUS_BUFFER_TOO_SMALL;
        goto Exit;
    }

    // let us fill in
    
    Cursor = (PWSTR) (Info + 1);
    Info->ulFlags = EntryData->Flags;
    Info->ulFilenameLength = ElementList[i].KeyLength;
    Info->ulPathLength = EntryData->TotalPathLength;

    Info->lpFileName = NULL;
    Info->lpFilePath = NULL;   

    // copy the strings...

    // copy the filename
    if (ElementList[i].KeyLength != 0) {
        RtlCopyMemory(
            Cursor,
            (PVOID) (((ULONG_PTR) StringSectionHeader) + ElementList[i].KeyOffset),
            ElementList[i].KeyLength);
        Info->lpFileName = Cursor;
        Cursor = (PWSTR) (((ULONG_PTR) Cursor) + ElementList[i].KeyLength);
        *Cursor++ = L'\0';
    }

    // concatenate the path
    if (EntryData->TotalPathLength != 0) {
        if (EntryData->PathSegmentOffset != 0)
            PathSegments = (PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT)(StringSectionHeader + EntryData->PathSegmentOffset);

        if (PathSegments != NULL)
        {  
            Info->lpFilePath = Cursor;
            for (i=0; i < EntryData->PathSegmentCount; i++)
            {
                if (PathSegments[i].Offset != 0)
                {                                
                    RtlCopyMemory(
                        Cursor,
                        (PVOID) (((ULONG_PTR) StringSectionHeader) + PathSegments[i].Offset),
                        PathSegments[i].Length);
                    Cursor = (PWSTR) (((ULONG_PTR) Cursor) + PathSegments[i].Length);
                }
            }
            *Cursor++ = L'\0';
        }
    }

    ASSERT((((ULONG_PTR) Cursor) - ((ULONG_PTR) Info)) == BytesNeeded);

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

NTSTATUS
NTAPI
RtlQueryInformationActivationContext(
    IN ULONG Flags,
    IN PCACTIVATION_CONTEXT ActivationContext,
    IN PVOID SubInstanceIndex,
    IN ACTIVATION_CONTEXT_INFO_CLASS InfoClass,
    OUT PVOID Buffer,
    IN SIZE_T InLength,
    OUT PSIZE_T OutLength OPTIONAL
    )
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;
    BOOLEAN  LoaderLockLocked = FALSE;
    PVOID    LoaderLockCookie = NULL;
    PCACTIVATION_CONTEXT_DATA ActivationContextData = NULL;

    __try {

        if (OutLength != NULL) {
            *OutLength = 0;
        }

        if ((Flags &
                ~(  RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_USE_ACTIVE_ACTIVATION_CONTEXT
                  | RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_ACTIVATION_CONTEXT_IS_MODULE
                  | RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_ACTIVATION_CONTEXT_IS_ADDRESS
                  | RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_NO_ADDREF
                 )) != 0) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() - Caller passed invalid flags (0x%08lx)\n",
                __FUNCTION__,
                Flags);
            Status = STATUS_INVALID_PARAMETER_1;
            goto Exit;
        }

        //
        // REVIEW do we really care?
        // And check that no other infoclass really does include an optionally addrefed actctx.
        //
        if ((Flags & RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_NO_ADDREF) != 0
            && InfoClass != ActivationContextBasicInformation) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() - Caller passed meaningless flags/class combination (0x%08lx/0x%08lx)\n",
                __FUNCTION__,
                Flags,
                InfoClass);
            Status = STATUS_INVALID_PARAMETER_1;
            goto Exit;
        }

        if ((InfoClass != ActivationContextBasicInformation) &&
            (InfoClass != ActivationContextDetailedInformation) && 
            (InfoClass != AssemblyDetailedInformationInActivationContxt ) &&
            (InfoClass != FileInformationInAssemblyOfAssemblyInActivationContxt))
        {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() - caller asked for unknown information class %lu\n",
                __FUNCTION__,
                InfoClass);
            Status = STATUS_INVALID_PARAMETER_3;
            goto Exit;
        }

        if ((InLength != 0) && (Buffer == NULL)) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() - caller passed nonzero buffer length but NULL buffer pointer\n",
                __FUNCTION__);
            Status = STATUS_INVALID_PARAMETER_4;
            goto Exit;
        }

        if ((InLength == 0) && (OutLength == NULL)) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() - caller supplied no buffer to populate and no place to return required byte count\n",
                __FUNCTION__);
            Status = STATUS_INVALID_PARAMETER_6;
            goto Exit;
        }

        switch (
            Flags & (
                  RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_USE_ACTIVE_ACTIVATION_CONTEXT
                | RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_ACTIVATION_CONTEXT_IS_MODULE
                | RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_ACTIVATION_CONTEXT_IS_ADDRESS
                )) {

        default:
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() - Caller passed invalid flags (0x%08lx)\n",
                __FUNCTION__,
                Flags);
            Status = STATUS_INVALID_PARAMETER_1;
            goto Exit;

        case 0:
            break;

        case RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_USE_ACTIVE_ACTIVATION_CONTEXT:
            {
                PCRTL_ACTIVATION_CONTEXT_STACK_FRAME Frame;

                if (ActivationContext != NULL) {
                    DbgPrintEx(
                        DPFLTR_SXS_ID,
                        DPFLTR_ERROR_LEVEL,
                        "SXS: %s() - caller asked to use active activation context but passed %p\n",
                        __FUNCTION__,
                        ActivationContext);
                    Status = STATUS_INVALID_PARAMETER_2;
                    goto Exit;
                }

                Frame = (PCRTL_ACTIVATION_CONTEXT_STACK_FRAME) NtCurrentTeb()->ActivationContextStack.ActiveFrame;

                if (Frame != NULL) {
                    ActivationContext = Frame->ActivationContext;
                }
            }
            break;

        case RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_ACTIVATION_CONTEXT_IS_ADDRESS:
            {
                PVOID DllHandle;

                if (ActivationContext == NULL) {
                    DbgPrintEx(
                        DPFLTR_SXS_ID,
                        DPFLTR_ERROR_LEVEL,
                        "SXS: %s() - Caller asked to use activation context from address in .dll but passed NULL\n",
                        __FUNCTION__
                        );
                    Status = STATUS_INVALID_PARAMETER_2;
                    goto Exit;
                }

                Status = LdrLockLoaderLock(0, NULL, &LoaderLockCookie);
                if (!NT_SUCCESS(Status)) {
                    goto Exit;
                }
                LoaderLockLocked = TRUE;
                DllHandle = RtlPcToFileHeader(RTL_CONST_CAST(PVOID)(ActivationContext), &DllHandle);
                if (DllHandle == NULL) {
                    DbgPrintEx(
                        DPFLTR_SXS_ID,
                        DPFLTR_ERROR_LEVEL,
                        "SXS: %s() - Caller passed invalid address, not in any .dll (%p)\n",
                        __FUNCTION__,
                        ActivationContext);
                    Status = STATUS_DLL_NOT_FOUND; // REVIEW
                    goto Exit;
                }
                ActivationContext = DllHandle;
            }
            // FALLTHROUGH
        case RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_ACTIVATION_CONTEXT_IS_MODULE:
            {
                PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;

                if (ActivationContext == NULL) {
                    DbgPrintEx(
                        DPFLTR_SXS_ID,
                        DPFLTR_ERROR_LEVEL,
                        "SXS: %s() - Caller asked to use activation context from hmodule but passed NULL\n",
                        __FUNCTION__
                        );
                    Status = STATUS_INVALID_PARAMETER_2;
                    goto Exit;
                }

                if (!LoaderLockLocked) {
                    Status = LdrLockLoaderLock(0, NULL, &LoaderLockCookie);
                    if (!NT_SUCCESS(Status))
                        goto Exit;
                    LoaderLockLocked = TRUE;
                }
                if (!LdrpCheckForLoadedDllHandle(RTL_CONST_CAST(PVOID)(ActivationContext), &LdrDataTableEntry)) {
                    DbgPrintEx(
                        DPFLTR_SXS_ID,
                        DPFLTR_ERROR_LEVEL,
                        "SXS: %s() - Caller passed invalid hmodule (%p)\n",
                        __FUNCTION__,
                        ActivationContext);
                    Status = STATUS_DLL_NOT_FOUND; // REVIEW
                    goto Exit;
                }
                ActivationContext = LdrDataTableEntry->EntryPointActivationContext;
            }
            break;
        }

        Status = RtlpGetActivationContextData(
            RTLP_GET_ACTIVATION_CONTEXT_DATA_MAP_NULL_TO_EMPTY,
            ActivationContext,
            NULL,
            &ActivationContextData);
        if (!NT_SUCCESS(Status))
            goto Exit;

        if (ActivationContextData == NULL) {
            switch (InfoClass) {
                case ActivationContextBasicInformation:
                default:
                    break;

                case ActivationContextDetailedInformation:
                case AssemblyDetailedInformationInActivationContxt:
                case FileInformationInAssemblyOfAssemblyInActivationContxt:
                    Status = STATUS_INVALID_PARAMETER_1;
                    goto Exit;
            }
        }

        switch (InfoClass) {
        case ActivationContextBasicInformation:
            {
                ULONG BasicInfoFlags = 0;
                if ((Flags & RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_NO_ADDREF) != 0) {
                    BasicInfoFlags |= RTLP_QUERY_INFORMATION_ACTIVATION_CONTEXT_BASIC_INFORMATION_FLAG_NO_ADDREF;
                }
                Status = RtlpQueryInformationActivationContextBasicInformation(
                    BasicInfoFlags,
                    ActivationContext,
                    ActivationContextData,
                    0, 
                    Buffer, 
                    InLength, 
                    OutLength
                    );
                if (!NT_SUCCESS(Status))
                    goto Exit;
            }
            break;

        case ActivationContextDetailedInformation:
            Status = RtlpQueryInformationActivationContextDetailedInformation(
                ActivationContextData,
                0,
                Buffer,
                InLength,
                OutLength
                );
            if (!NT_SUCCESS(Status))
                goto Exit;
            break;
        case AssemblyDetailedInformationInActivationContxt:
            if (SubInstanceIndex == NULL) {
                Status = STATUS_INVALID_PARAMETER;
                goto Exit;
            }
            Status = RtlpQueryAssemblyInformationActivationContextDetailedInformation(
                ActivationContextData,
                *((ULONG *)SubInstanceIndex),
                Buffer,
                InLength,
                OutLength
                );
            if (!NT_SUCCESS(Status))
                goto Exit;
            break;
        case FileInformationInAssemblyOfAssemblyInActivationContxt:
            Status = RtlpQueryFilesInAssemblyInformationActivationContextDetailedInformation(
                ActivationContextData,
                ((ACTIVATION_CONTEXT_QUERY_INDEX *)SubInstanceIndex),
                Buffer,
                InLength,
                OutLength
                );
            if (!NT_SUCCESS(Status))
                goto Exit;
            break;
        default:
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() - internal coding error; missing switch statement branch for InfoClass == %lu\n",
                __FUNCTION__,
                InfoClass);
            Status = STATUS_INTERNAL_ERROR;
            goto Exit;
        }

        Status = STATUS_SUCCESS;
Exit:
        ;
    } __finally {
        if (LoaderLockLocked)
            LdrUnlockLoaderLock(0, LoaderLockCookie);
    }
    return Status;
}


NTSTATUS
NTAPI
RtlQueryInformationActiveActivationContext(
    IN ACTIVATION_CONTEXT_INFO_CLASS InfoClass,
    OUT PVOID OutBuffer,
    IN SIZE_T InLength,
    OUT PSIZE_T OutLength OPTIONAL
    )
{
    return RtlQueryInformationActivationContext(
        RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_USE_ACTIVE_ACTIVATION_CONTEXT,
        NULL,
        0,
        InfoClass,
        OutBuffer,
        InLength,
        OutLength);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\sxsstoragemap.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sxsstorage.c

Abstract:

    Side-by-side activation support for Windows/NT

    Implementation of the assembly storage map.


Author:

    Michael Grier (MGrier) 6/13/2000

Revision History:
    Xiaoyu Wu(xiaoyuw) 7/01/2000     .local directory
    Xiaoyu Wu(xiaoyuw) 8/04/2000     private assembly
    Jay Krell (a-JayK) October 2000  the little bit of system default context that wasn't already done
--*/

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // condition expression is constant

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <sxstypes.h>
#include "sxsp.h"

#define IS_PATH_SEPARATOR(_wch) (((_wch) == L'\\') || ((_wch) == L'/'))
#define LOCAL_ASSEMBLY_STORAGE_DIR_SUFFIX L".Local"

#if DBG
PCUNICODE_STRING RtlpGetImagePathName(VOID);
#define RtlpGetCurrentProcessId() (HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess))
#define RtlpGetCurrentThreadId() (HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread))
#endif

#if DBG

PCUNICODE_STRING RtlpGetImagePathName(VOID)
{
    PPEB Peb = NtCurrentPeb();
    return (Peb->ProcessParameters != NULL) ? &Peb->ProcessParameters->ImagePathName : NULL;
}

static VOID
DbgPrintFunctionEntry(
    CONST CHAR* Function
    )
{
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "SXS: [pid:0x%x, tid:0x%x, %wZ] enter %s%d()\n",
        RtlpGetCurrentProcessId(),
        RtlpGetCurrentThreadId(),
        RtlpGetImagePathName(),
        Function,
        (int)sizeof(PVOID) * 8
        );
}

static VOID
DbgPrintFunctionExit(
    CONST CHAR* Function,
    NTSTATUS    Status
    )
{
    DbgPrintEx(
        DPFLTR_SXS_ID,
        NT_SUCCESS(Status) ? DPFLTR_TRACE_LEVEL : DPFLTR_ERROR_LEVEL,
        "SXS: [0x%x.%x] %s%d() exiting with status 0x%lx\n",
        RtlpGetCurrentProcessId(),
        RtlpGetCurrentThreadId(),
        Function,
        (int)sizeof(PVOID) * 8,
        Status
        );
}
#else

#define DbgPrintFunctionEntry(function) /* nothing */
#define DbgPrintFunctionExit(function, status) /* nothing */

#endif // DBG

// Because we write to the peb, we must not be in 64bit code for a 32bit process,
// unless we know we are early enough in CreateProcess, which is not the case
// in this file. Also don't call the 32bit version of this in a 64bit process.
#if DBG
#define ASSERT_OK_TO_WRITE_PEB() \
{ \
    PVOID Peb32 = NULL; \
    NTSTATUS Status; \
 \
    Status = \
        NtQueryInformationProcess( \
            NtCurrentProcess(), \
            ProcessWow64Information, \
            &Peb32, \
            sizeof(Peb32), \
            NULL); \
    /* The other Peb must be The Peb or the other Peb must not exist. */ \
    ASSERT(Peb32 == NtCurrentPeb() || Peb32 == NULL); \
}
#else
#define ASSERT_OK_TO_WRITE_PEB() /* nothing */
#endif

NTSTATUS
RtlpInitializeAssemblyStorageMap(
    PASSEMBLY_STORAGE_MAP Map,
    ULONG EntryCount,
    PASSEMBLY_STORAGE_MAP_ENTRY *EntryArray
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG i;
    ULONG Flags = 0;

#if DBG
    DbgPrintFunctionEntry(__FUNCTION__);
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "%s(Map:%p, EntryCount:0x%lx)\n",
        __FUNCTION__,
        Map,
        EntryCount
        );

    ASSERT_OK_TO_WRITE_PEB();
#endif // DBG

    if ((Map == NULL) ||
        (EntryCount == 0)) {

        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() bad parameters:\n"
            "SXS:    Map        : 0x%lx\n"
            "SXS:    EntryCount : 0x%lx\n"
            __FUNCTION__,
            Map,
            EntryCount
            );
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (EntryArray == NULL) {
        EntryArray = (PASSEMBLY_STORAGE_MAP_ENTRY *) RtlAllocateHeap(RtlProcessHeap(), 0, EntryCount * sizeof(PASSEMBLY_STORAGE_MAP_ENTRY));
        if (EntryArray == NULL) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }

        Flags |= ASSEMBLY_STORAGE_MAP_ASSEMBLY_ARRAY_IS_HEAP_ALLOCATED;
    }

    for (i=0; i<EntryCount; i++)
        EntryArray[i] = NULL;

    Map->Flags = Flags;
    Map->AssemblyCount = EntryCount;
    Map->AssemblyArray = EntryArray;

    Status = STATUS_SUCCESS;
Exit:
#if DBG
    DbgPrintFunctionExit(__FUNCTION__, Status);
    DbgPrintEx(
        DPFLTR_SXS_ID,
        NT_SUCCESS(Status) ? DPFLTR_TRACE_LEVEL : DPFLTR_ERROR_LEVEL,
        "%s(Map:%p, EntryCount:0x%lx) : (Map:%p, Status:0x%lx)\n",
        __FUNCTION__,
        Map,        
        EntryCount,
        Map,
        Status
        );
#endif

    return Status;
}

VOID
RtlpUninitializeAssemblyStorageMap(
    PASSEMBLY_STORAGE_MAP Map
    )
{
    DbgPrintFunctionEntry(__FUNCTION__);
#if DBG
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "%s(Map:%p)\n",
        __FUNCTION__,
        Map
        );
#endif

    if (Map != NULL) {
        ULONG i;

        for (i=0; i<Map->AssemblyCount; i++) {
            PASSEMBLY_STORAGE_MAP_ENTRY Entry = Map->AssemblyArray[i];

            if (Entry != NULL) {
                Entry->DosPath.Length = 0;
                Entry->DosPath.MaximumLength = 0;
                Entry->DosPath.Buffer = NULL;

                if (Entry->Handle != NULL) {
                    RTL_SOFT_VERIFY(NT_SUCCESS(NtClose(Entry->Handle)));
                    Entry->Handle = NULL;
                }

                Map->AssemblyArray[i] = NULL;

                RtlFreeHeap(RtlProcessHeap(), 0, Entry);
            }
        }

        if (Map->Flags & ASSEMBLY_STORAGE_MAP_ASSEMBLY_ARRAY_IS_HEAP_ALLOCATED) {
            RtlFreeHeap(RtlProcessHeap(), 0, Map->AssemblyArray);
        }

        Map->AssemblyArray = NULL;
        Map->AssemblyCount = 0;
        Map->Flags = 0;
    }
}

NTSTATUS
RtlpInsertAssemblyStorageMapEntry(
    PASSEMBLY_STORAGE_MAP Map,
    ULONG AssemblyRosterIndex,
    PCUNICODE_STRING StorageLocation,
    HANDLE* OpenDirectoryHandle
    )
{
    PASSEMBLY_STORAGE_MAP_ENTRY Entry = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(Map != NULL);
    ASSERT(AssemblyRosterIndex >= 1);
    ASSERT((Map != NULL) && (AssemblyRosterIndex < Map->AssemblyCount));
    ASSERT(StorageLocation != NULL);
    ASSERT((StorageLocation != NULL) && (StorageLocation->Length >= sizeof(WCHAR)));
    ASSERT((StorageLocation != NULL) && (StorageLocation->Buffer != NULL));

    DbgPrintFunctionEntry(__FUNCTION__);

    if ((Map == NULL) ||
        (AssemblyRosterIndex < 1) ||
        (AssemblyRosterIndex > Map->AssemblyCount) ||
        (StorageLocation == NULL) ||
        (StorageLocation->Length < sizeof(WCHAR)) ||
        (StorageLocation->Buffer == NULL) ||
        (OpenDirectoryHandle == NULL)) {

        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() bad parameters\n"
            "SXS:  Map                    : %p\n"
            "SXS:  AssemblyRosterIndex    : 0x%lx\n"
            "SXS:  Map->AssemblyCount     : 0x%lx\n"
            "SXS:  StorageLocation        : %p\n"
            "SXS:  StorageLocation->Length: 0x%x\n"
            "SXS:  StorageLocation->Buffer: %p\n"
            "SXS:  OpenDirectoryHandle    : %p\n",
            __FUNCTION__,
            Map,
            AssemblyRosterIndex,
            Map ? Map->AssemblyCount : 0,
            StorageLocation,
            (StorageLocation != NULL) ? StorageLocation->Length : 0,
            (StorageLocation != NULL) ? StorageLocation->Buffer : NULL,
            OpenDirectoryHandle
            );

        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if ((StorageLocation->Length + sizeof(WCHAR)) > UNICODE_STRING_MAX_BYTES) {
        Status = STATUS_NAME_TOO_LONG;
        goto Exit;
    }

    Entry = (PASSEMBLY_STORAGE_MAP_ENTRY) RtlAllocateHeap(RtlProcessHeap(), 0, sizeof(ASSEMBLY_STORAGE_MAP_ENTRY) + StorageLocation->Length + sizeof(WCHAR));
    if (Entry == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    Entry->Flags = 0;
    Entry->DosPath.Length = StorageLocation->Length;
    Entry->DosPath.Buffer = (PWSTR) (Entry + 1);
    Entry->DosPath.MaximumLength = (USHORT) (StorageLocation->Length + sizeof(WCHAR));
    RtlCopyMemory(
        Entry->DosPath.Buffer,
        StorageLocation->Buffer,
        StorageLocation->Length);
    Entry->DosPath.Buffer[Entry->DosPath.Length / sizeof(WCHAR)] = L'\0';

    Entry->Handle = *OpenDirectoryHandle;

    // Ok, we're all set.  Let's try the big interlocked switcheroo
    if (InterlockedCompareExchangePointer(
            (PVOID *) &Map->AssemblyArray[AssemblyRosterIndex],
            (PVOID) Entry,
            (PVOID) NULL) == NULL) {
        // If we're the first ones in, avoid cleaning up in the exit path.
        Entry = NULL;
        *OpenDirectoryHandle = NULL;
    }

    Status = STATUS_SUCCESS;
Exit:
    DbgPrintFunctionExit(__FUNCTION__, Status);
    if (Entry != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, Entry);
    }

    return Status;
}

NTSTATUS
RtlpResolveAssemblyStorageMapEntry(
    PASSEMBLY_STORAGE_MAP Map,
    PCACTIVATION_CONTEXT_DATA Data,
    ULONG AssemblyRosterIndex,
    PASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_ROUTINE Callback,
    PVOID CallbackContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    ASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_DATA CallbackData;
    PVOID ResolutionContext;
    BOOLEAN ResolutionContextValid = FALSE;
    UNICODE_STRING AssemblyDirectory;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER AssemblyRoster;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY AssemblyRosterEntry;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION AssemblyInformation;
    PVOID AssemblyInformationSectionBase;
    UNICODE_STRING ResolvedPath;
    WCHAR ResolvedPathBuffer[DOS_MAX_PATH_LENGTH];
    UNICODE_STRING ResolvedDynamicPath;
    PUNICODE_STRING ResolvedPathUsed;
    HANDLE OpenDirectoryHandle = NULL;
    WCHAR QueryPathBuffer[DOS_MAX_PATH_LENGTH];
    UNICODE_STRING FileName;
    RTL_RELATIVE_NAME RelativeName;
    OBJECT_ATTRIBUTES Obja; 
    IO_STATUS_BLOCK IoStatusBlock;
    SIZE_T RootCount, CurrentRootIndex;
    PWSTR FreeBuffer = NULL;

    DbgPrintFunctionEntry(__FUNCTION__);

    ResolvedPath.Length = 0;
    ResolvedPath.MaximumLength = sizeof(ResolvedPathBuffer);
    ResolvedPath.Buffer = ResolvedPathBuffer;

    ResolvedDynamicPath.Length = 0;
    ResolvedDynamicPath.MaximumLength = 0;
    ResolvedDynamicPath.Buffer = NULL;

    FileName.Length = 0;
    FileName.MaximumLength = 0;
    FileName.Buffer = NULL;

    ResolutionContext = NULL;

    // First, let's validate parameters...
    if ((Map == NULL) ||
        (Data == NULL) ||
        (AssemblyRosterIndex < 1) ||
        (AssemblyRosterIndex > Map->AssemblyCount)) {

        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() bad parameters\n"
            "SXS:   Map                : %p\n"
            "SXS:   Data               : %p\n"
            "SXS:   AssemblyRosterIndex: 0x%lx\n"
            "SXS:   Map->AssemblyCount : 0x%lx\n",
            __FUNCTION__,
            Map,
            Data,
            AssemblyRosterIndex,
            (Map != NULL) ? Map->AssemblyCount : 0
            );

        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    // Is it already resolved?
    if (Map->AssemblyArray[AssemblyRosterIndex] != NULL)
        goto Exit;

    AssemblyRoster = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER) (((ULONG_PTR) Data) + Data->AssemblyRosterOffset);
    AssemblyRosterEntry = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY) (((ULONG_PTR) Data) + AssemblyRoster->FirstEntryOffset + (AssemblyRosterIndex * sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY)));
    AssemblyInformation = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION) (((ULONG_PTR) Data) + AssemblyRosterEntry->AssemblyInformationOffset);
    AssemblyInformationSectionBase = (PVOID) (((ULONG_PTR) Data) + AssemblyRoster->AssemblyInformationSectionOffset);

    if (AssemblyInformation->AssemblyDirectoryNameLength > UNICODE_STRING_MAX_BYTES) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: Assembly directory name stored in assembly information too long (%lu bytes) - ACTIVATION_CONTEXT_DATA at %p\n", AssemblyInformation->AssemblyDirectoryNameLength, Data);

        Status = STATUS_NAME_TOO_LONG;
        goto Exit;
    }

    // The root assembly may just be in the raw filesystem, in which case we want to resolve the path to be the
    // directory containing the application.
    if (AssemblyInformation->Flags & ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_PRIVATE_ASSEMBLY)
    {
        WCHAR * p = NULL;
        WCHAR * pManifestPath = NULL; 
        USHORT ManifestPathLength;
        
        //now, we have AssemblyInformation in hand, get the manifest path 
        ResolvedPathUsed = &ResolvedPath;

        pManifestPath = (PWSTR)((ULONG_PTR)AssemblyInformationSectionBase + AssemblyInformation->ManifestPathOffset);
        if ( !pManifestPath) { 
            Status = STATUS_INTERNAL_ERROR;
            goto Exit; 
    
        }

        p = wcsrchr(pManifestPath, L'\\'); 
        if (!p) {
            Status = STATUS_INTERNAL_ERROR;
            goto Exit; 
        }
        ManifestPathLength = (USHORT)((p - pManifestPath + 1) * sizeof(WCHAR)); // additional 1 WCHAR for "\"
        ManifestPathLength += sizeof(WCHAR); // for trailing NULL

        if (ManifestPathLength > sizeof(ResolvedPathBuffer)) {
            if (ManifestPathLength > UNICODE_STRING_MAX_BYTES) {
                Status = STATUS_NAME_TOO_LONG;
                goto Exit;
            }

            ResolvedDynamicPath.MaximumLength = (USHORT) (ManifestPathLength);

            ResolvedDynamicPath.Buffer = (RtlAllocateStringRoutine)(ResolvedDynamicPath.MaximumLength);
            if (ResolvedDynamicPath.Buffer == NULL) {
                Status = STATUS_NO_MEMORY;
                goto Exit;
            }

            ResolvedPathUsed = &ResolvedDynamicPath;
        }

        RtlCopyMemory(
            ResolvedPathUsed->Buffer,
            (PVOID)(pManifestPath),
            ManifestPathLength-sizeof(WCHAR));

        ResolvedPathUsed->Buffer[ManifestPathLength / sizeof(WCHAR) - 1] = L'\0';
        ResolvedPathUsed->Length = (USHORT)ManifestPathLength-sizeof(WCHAR);
    } else if ((AssemblyInformation->Flags & ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ROOT_ASSEMBLY) &&
        (AssemblyInformation->AssemblyDirectoryNameLength == 0)) {
        // Get the image directory for the process
        PRTL_USER_PROCESS_PARAMETERS ProcessParameters = NtCurrentPeb()->ProcessParameters;
        // We don't need to image name, just the length up to the last slash.
        PWSTR pszCursor;
        USHORT cbOriginalLength;
        USHORT cbLeft;
        USHORT cbIncludingSlash;

        ASSERT(ProcessParameters != NULL);
        if (ProcessParameters == NULL) {
            Status = STATUS_INTERNAL_ERROR;
            goto Exit;
        }

        // We don't need to image name, just the length up to the last slash.
        pszCursor = ProcessParameters->ImagePathName.Buffer;
        cbOriginalLength = ProcessParameters->ImagePathName.Length;
        cbLeft = cbOriginalLength;
        cbIncludingSlash = 0;

        while (cbLeft != 0) {
            const WCHAR wch = *pszCursor++;
            cbLeft -= sizeof(WCHAR);

            if (IS_PATH_SEPARATOR(wch)) {
                cbIncludingSlash = cbOriginalLength - cbLeft;
            }
        }

        ResolvedPathUsed = &ResolvedPath;

        if ((cbIncludingSlash + sizeof(WCHAR)) > sizeof(ResolvedPathBuffer)) {
            if ((cbIncludingSlash + sizeof(WCHAR)) > UNICODE_STRING_MAX_BYTES) {
                Status = STATUS_NAME_TOO_LONG;
                goto Exit;
            }

            ResolvedDynamicPath.MaximumLength = (USHORT) (cbIncludingSlash + sizeof(WCHAR));

            ResolvedDynamicPath.Buffer = (RtlAllocateStringRoutine)(ResolvedDynamicPath.MaximumLength);
            if (ResolvedDynamicPath.Buffer == NULL) {
                Status = STATUS_NO_MEMORY;
                goto Exit;
            }

            ResolvedPathUsed = &ResolvedDynamicPath;
        }

        RtlCopyMemory(
            ResolvedPathUsed->Buffer,
            ProcessParameters->ImagePathName.Buffer,
            cbIncludingSlash);

        ResolvedPathUsed->Buffer[cbIncludingSlash / sizeof(WCHAR)] = L'\0';
        ResolvedPathUsed->Length = cbIncludingSlash;
    } else {
        // If the resolution is not to the root assembly path, we need to make our callbacks.

        ResolvedPathUsed = NULL;
        AssemblyDirectory.Length = (USHORT) AssemblyInformation->AssemblyDirectoryNameLength;
        AssemblyDirectory.MaximumLength = AssemblyDirectory.Length;
        AssemblyDirectory.Buffer = (PWSTR) (((ULONG_PTR) AssemblyInformationSectionBase) + AssemblyInformation->AssemblyDirectoryNameOffset);

        // Get ready to fire the resolution beginning event...
        CallbackData.ResolutionBeginning.Data = Data;
        CallbackData.ResolutionBeginning.AssemblyRosterIndex = AssemblyRosterIndex;
        CallbackData.ResolutionBeginning.ResolutionContext = NULL;
        CallbackData.ResolutionBeginning.Root.Length = 0;
        CallbackData.ResolutionBeginning.Root.MaximumLength = sizeof(QueryPathBuffer);
        CallbackData.ResolutionBeginning.Root.Buffer = QueryPathBuffer;
        CallbackData.ResolutionBeginning.KnownRoot = FALSE;
        CallbackData.ResolutionBeginning.CancelResolution = FALSE;
        CallbackData.ResolutionBeginning.RootCount = 0;

        (*Callback)(
            ASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_REASON_RESOLUTION_BEGINNING,
            &CallbackData,
            CallbackContext);
        if (CallbackData.ResolutionBeginning.CancelResolution) {
            Status = STATUS_CANCELLED;
            goto Exit;
        }

        // If that was enough, then register it and we're outta here...
        if (CallbackData.ResolutionBeginning.KnownRoot) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_TRACE_LEVEL,
                "SXS: Storage resolution callback said that this is a well known storage root\n");

            // See if it's there...
            Status = RtlpProbeAssemblyStorageRootForAssembly(
                0,
                &CallbackData.ResolutionBeginning.Root,
                &AssemblyDirectory,
                &ResolvedPath,
                &ResolvedDynamicPath,
                &ResolvedPathUsed,
                &OpenDirectoryHandle);
            if (!NT_SUCCESS(Status)) {
                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SXS: Attempt to probe known root of assembly storage (\"%wZ\") failed; Status = 0x%08lx\n", &CallbackData.ResolutionBeginning.Root, Status);
                goto Exit;
            }

            Status = RtlpInsertAssemblyStorageMapEntry(
                Map,
                AssemblyRosterIndex,
                &CallbackData.ResolutionBeginning.Root,
                &OpenDirectoryHandle);
            if (!NT_SUCCESS(Status)) {
                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SXS: Attempt to insert well known storage root into assembly storage map assembly roster index %lu failed; Status = 0x%08lx\n", AssemblyRosterIndex, Status);

                goto Exit;
            }

            Status = STATUS_SUCCESS;
            goto Exit;
        }

        // Otherwise, begin the grind...
        ResolutionContext = CallbackData.ResolutionBeginning.ResolutionContext;
        RootCount = CallbackData.ResolutionBeginning.RootCount;

        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_TRACE_LEVEL,
            "SXS: Assembly storage resolution trying %Id roots (-1 is ok)\n", (SSIZE_T/*from SIZE_T*/)RootCount);

        ResolutionContextValid = TRUE;

        for (CurrentRootIndex = 0; CurrentRootIndex < RootCount; CurrentRootIndex++) {
            CallbackData.GetRoot.ResolutionContext = ResolutionContext;
            CallbackData.GetRoot.RootIndex = CurrentRootIndex;
            CallbackData.GetRoot.Root.Length = 0;
            CallbackData.GetRoot.Root.MaximumLength = sizeof(QueryPathBuffer);
            CallbackData.GetRoot.Root.Buffer = QueryPathBuffer;
            CallbackData.GetRoot.CancelResolution = FALSE;
            CallbackData.GetRoot.NoMoreEntries = FALSE;

            (*Callback)(
                ASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_REASON_GET_ROOT,
                &CallbackData,
                CallbackContext);

            if (CallbackData.GetRoot.CancelResolution) {
                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_TRACE_LEVEL,
                    "SXS: Callback routine cancelled storage root resolution on root number %Iu\n", CurrentRootIndex);

                Status = STATUS_CANCELLED;
                goto Exit;
            }

            if (CallbackData.GetRoot.NoMoreEntries) {
                if (CallbackData.GetRoot.Root.Length == 0) {
                    DbgPrintEx(
                        DPFLTR_SXS_ID,
                        DPFLTR_TRACE_LEVEL,
                        "SXS: Storage resolution finished because callback indicated no more entries on root number %Iu\n", CurrentRootIndex);

                    // we're done... 
                    RootCount = CurrentRootIndex;
                    break;
                }

                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_TRACE_LEVEL,
                    "SXS: Storage resolution callback has indicated that this is the last root to process: number %Iu\n", CurrentRootIndex);

                RootCount = CurrentRootIndex + 1;
            }

            // Allow the caller to skip this index.
            if (CallbackData.GetRoot.Root.Length == 0) {
                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_TRACE_LEVEL,
                    "SXS: Storage resolution for root number %lu returned blank root; skipping probing logic and moving to next.\n", CurrentRootIndex);

                continue;
            }

            if (OpenDirectoryHandle != NULL) {
                RTL_SOFT_VERIFY(NT_SUCCESS(NtClose(OpenDirectoryHandle)));
                OpenDirectoryHandle = NULL;
            }

            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_TRACE_LEVEL,
                "SXS: Assembly storage map probing root %wZ for assembly directory %wZ\n", &CallbackData.GetRoot.Root, &AssemblyDirectory);

            // See if it's there...
            Status = RtlpProbeAssemblyStorageRootForAssembly(
                0,
                &CallbackData.GetRoot.Root,
                &AssemblyDirectory,
                &ResolvedPath,
                &ResolvedDynamicPath,
                &ResolvedPathUsed,
                &OpenDirectoryHandle);

            // If we got it, leave the loop.
            if (NT_SUCCESS(Status)) {
                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_TRACE_LEVEL,
                    "SXS: Found good storage root for %wZ at index %Iu\n", &AssemblyDirectory, CurrentRootIndex);
                break;
            }

            if (Status != STATUS_SXS_ASSEMBLY_NOT_FOUND) {
                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SXS: Attempt to probe assembly storage root %wZ for assembly directory %wZ failed with status = 0x%08lx\n", &CallbackData.GetRoot.Root, &AssemblyDirectory, Status);

                goto Exit;
            }
        }

        if (CurrentRootIndex == RootCount) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: Unable to resolve storage root for assembly directory %wZ in %Iu tries\n", &AssemblyDirectory, CurrentRootIndex);

            Status = STATUS_SXS_ASSEMBLY_NOT_FOUND;
            goto Exit;
        }
    }

    //
    // sometimes at this point probing has simultaneously opened the directory,
    // sometimes it has not.
    //
    if (OpenDirectoryHandle == NULL) {

        //create Handle for this directory
        if (!RtlDosPathNameToNtPathName_U(
                    ResolvedPathUsed->Buffer,
                    &FileName,
                    NULL,
                    &RelativeName
                    )) 
        {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: Attempt to translate DOS path name \"%S\" to NT format failed\n", ResolvedPathUsed->Buffer);

            Status = STATUS_OBJECT_PATH_NOT_FOUND;
            goto Exit;
        }

        FreeBuffer = FileName.Buffer;

        if (RelativeName.RelativeName.Length != 0) 
        {
            FileName = *((PUNICODE_STRING) &RelativeName.RelativeName);
        } else 
        {
            RelativeName.ContainingDirectory = NULL;
        }

        InitializeObjectAttributes(
            &Obja,
            &FileName,
            OBJ_CASE_INSENSITIVE,
            RelativeName.ContainingDirectory,
            NULL
            );

        // Open the directory to prevent deletion, just like set current working directory does...
        Status = NtOpenFile(
                    &OpenDirectoryHandle,
                    FILE_TRAVERSE | SYNCHRONIZE,
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT
                    );
        if (!NT_SUCCESS(Status)) 
        {
            //
            // Don't map this to like SXS_blah_NOT_FOUND, because
            // probing says this is definitely where we expect to get stuff.
            //
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: Unable to open assembly directory under storage root \"%S\"; Status = 0x%08lx\n", ResolvedPathUsed->Buffer, Status);
            goto Exit; 
        } else 
        { 
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_TRACE_LEVEL,
                "SXS: It is resolved!!!, GOOD");
        }
    }

    // Hey, we made it.  Add us to the list!
    Status = RtlpInsertAssemblyStorageMapEntry(
        Map,
        AssemblyRosterIndex,
        ResolvedPathUsed,
        &OpenDirectoryHandle);
    if (!NT_SUCCESS(Status)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: Storage resolution failed to insert entry to storage map; Status = 0x%08lx\n", Status);

        goto Exit;
    }

    Status = STATUS_SUCCESS;
Exit:
    DbgPrintFunctionExit(__FUNCTION__, Status);

    // Let the caller run down their context...
    if (ResolutionContextValid) {
        CallbackData.ResolutionEnding.ResolutionContext = ResolutionContext;

        (*Callback)(
            ASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_REASON_RESOLUTION_ENDING,
            &CallbackData,
            CallbackContext);
    }

    if (ResolvedDynamicPath.Buffer != NULL) {
        (RtlFreeStringRoutine)(ResolvedDynamicPath.Buffer);
    }

    //
    // RtlpInsertAssemblyStorageMapEntry gives ownership to the storage map, and
    // NULLs out our local, when successful.
    //
    if (OpenDirectoryHandle != NULL) {
        RTL_SOFT_VERIFY(NT_SUCCESS(NtClose(OpenDirectoryHandle)));
    }

    if (FreeBuffer != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
    }

    return Status;
}

NTSTATUS
RtlpProbeAssemblyStorageRootForAssembly(
    ULONG Flags,
    PCUNICODE_STRING Root,
    PCUNICODE_STRING AssemblyDirectory,
    PUNICODE_STRING PreAllocatedString,
    PUNICODE_STRING DynamicString,
    PUNICODE_STRING *StringUsed,
    HANDLE *OpenDirectoryHandle
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    WCHAR Buffer[DOS_MAX_PATH_LENGTH];
    UNICODE_STRING String = {0};
    SIZE_T TotalLength;
    BOOLEAN SeparatorNeededAfterRoot = FALSE;
    PWSTR Cursor;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING FileName = {0};
    RTL_RELATIVE_NAME RelativeName;
    PWSTR FreeBuffer = NULL;
    HANDLE TempDirectoryHandle = NULL;
    BOOLEAN fExistDir; 
    FILE_BASIC_INFORMATION BasicInfo;

    DbgPrintFunctionEntry(__FUNCTION__);

    if (StringUsed != NULL)
        *StringUsed = NULL;

    if (OpenDirectoryHandle != NULL)
        *OpenDirectoryHandle = NULL;

    if ((Flags != 0) ||
        (Root == NULL) ||
        (AssemblyDirectory == NULL) ||
        (PreAllocatedString == NULL) ||
        (DynamicString == NULL) ||
        (StringUsed == NULL) ||
        (OpenDirectoryHandle == NULL)) {

        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() bad parameters\n"
            "SXS:  Flags:               0x%lx\n"
            // %p is good enough because the checks are only against NULL
            "SXS:  Root:                %p\n"
            "SXS:  AssemblyDirectory:   %p\n"
            "SXS:  PreAllocatedString:  %p\n"
            "SXS:  DynamicString:       %p\n"
            "SXS:  StringUsed:          %p\n"
            "SXS:  OpenDirectoryHandle: %p\n",
            __FUNCTION__,
            Flags,
            Root,
            AssemblyDirectory,
            PreAllocatedString,
            DynamicString,
            StringUsed,
            OpenDirectoryHandle
            );

        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    TotalLength = Root->Length;

    if (Root->Length != 0) {
        if (!IS_PATH_SEPARATOR(Root->Buffer[(Root->Length / sizeof(WCHAR)) - 1])) {
            SeparatorNeededAfterRoot = TRUE;
            TotalLength += sizeof(WCHAR);
        }
    }

    TotalLength += AssemblyDirectory->Length;

    // And space for the trailing slash
    TotalLength += sizeof(WCHAR);

    // And space for a trailing null character because the path functions want one
    TotalLength += sizeof(WCHAR);

    //
    //  We do not add in space for the trailing slash so as to not cause a dynamic
    //  allocation until necessary in the boundary condition.  If the name of the
    //  directory we're probing fits fine in the stack-allocated buffer, we'll do
    //  the heap allocation if the probe succeeds.  Otherwise we'll not bother.
    //
    //  Maybe the relative complexity of the extra "+ sizeof(WCHAR)"s that are
    //  around aren't worth it, but extra unnecessary heap allocations are my
    //  hot button.
    //

    // Check to see if the string, plus a trailing slash that we don't write until
    // the end of this function plus the trailing null accounted for above
    // fits into a UNICODE_STRING.  If not, bail out.
    if (TotalLength > UNICODE_STRING_MAX_BYTES) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: Assembly storage resolution failing probe because combined path length does not fit in an UNICODE_STRING.\n");

        Status = STATUS_NAME_TOO_LONG;
        goto Exit;
    }

    if (TotalLength > sizeof(Buffer)) {
        String.MaximumLength = (USHORT) TotalLength;

        String.Buffer = (RtlAllocateStringRoutine)(String.MaximumLength);
        if (String.Buffer == NULL) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: Assembly storage resolution failing probe because attempt to allocate %u bytes failed.\n", String.MaximumLength);

            Status = STATUS_NO_MEMORY;
            goto Exit;
        }
    } else {
        String.Buffer = Buffer;
        String.MaximumLength = sizeof(Buffer);
    }

    RtlCopyMemory(
        String.Buffer,
        Root->Buffer,
        Root->Length);

    Cursor = (PWSTR) (((ULONG_PTR) String.Buffer) + Root->Length);

    if (SeparatorNeededAfterRoot) {
        *Cursor++ = L'\\';
    }

    RtlCopyMemory(
        Cursor,
        AssemblyDirectory->Buffer,
        AssemblyDirectory->Length);

    Cursor = (PWSTR) (((ULONG_PTR) Cursor) + AssemblyDirectory->Length);

    *Cursor = L'\0';

    String.Length =
        Root->Length +
        (SeparatorNeededAfterRoot ? sizeof(WCHAR) : 0) +
        AssemblyDirectory->Length;

    if (!RtlDosPathNameToNtPathName_U(
                            String.Buffer,
                            &FileName,
                            NULL,
                            &RelativeName
                            )) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: Attempt to translate DOS path name \"%S\" to NT format failed\n", String.Buffer);

        Status = STATUS_OBJECT_PATH_NOT_FOUND;
        goto Exit;
    }

    FreeBuffer = FileName.Buffer;

    if (RelativeName.RelativeName.Length != 0) {
        FileName = *((PUNICODE_STRING) &RelativeName.RelativeName);
    } else {
        RelativeName.ContainingDirectory = NULL;
    }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );
    // check the existence of directories
    Status = NtQueryAttributesFile(
                &Obja,
                &BasicInfo
                );

    fExistDir = FALSE; 
    if ( !NT_SUCCESS(Status) ) {
        if ( (Status == STATUS_SHARING_VIOLATION) || (Status == STATUS_ACCESS_DENIED) ) 
            fExistDir = TRUE; 
        else 
            fExistDir = FALSE;
    }
    else 
        fExistDir = TRUE;
    
    if (! fExistDir) {
        if (( Status == STATUS_NO_SUCH_FILE) || Status == STATUS_OBJECT_NAME_NOT_FOUND || Status == STATUS_OBJECT_PATH_NOT_FOUND)
             Status = STATUS_SXS_ASSEMBLY_NOT_FOUND;
        else 
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: Unable to open assembly directory under storage root \"%S\"; Status = 0x%08lx\n", String.Buffer, Status);

        goto Exit; 
    }

    // Open the directory to prevent deletion, just like set current working directory does...
    Status = NtOpenFile(
                &TempDirectoryHandle,
                FILE_TRAVERSE | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT
                );
    if (!NT_SUCCESS(Status)) {
        // If we failed, remap no such file to STATUS_SXS_ASSEMBLY_NOT_FOUND.
        if (Status == STATUS_NO_SUCH_FILE) {
            Status = STATUS_SXS_ASSEMBLY_NOT_FOUND;
        } else {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: Unable to open assembly directory under storage root \"%S\"; Status = 0x%08lx\n", String.Buffer, Status);
        }

        goto Exit;
    }

    // Hey, we found it!
    // add a slash to the path on the way out and we're done!

    if (TotalLength <= PreAllocatedString->MaximumLength) {
        // The caller's static string is big enough; just use it.
        RtlCopyMemory(
            PreAllocatedString->Buffer,
            String.Buffer,
            String.Length);

        *StringUsed = PreAllocatedString;
    } else {
        // If we already have a dynamic string, just give them our pointer.
        if (String.Buffer != Buffer) {
            DynamicString->Buffer = String.Buffer;
            String.Buffer = NULL;
        } else {
            // Otherwise we do our first allocation on the way out...
            DynamicString->Buffer = (RtlAllocateStringRoutine)(TotalLength);
            if (DynamicString->Buffer == NULL) {
                Status = STATUS_NO_MEMORY;
                goto Exit;
            }

            RtlCopyMemory(
                DynamicString->Buffer,
                String.Buffer,
                String.Length);
        }

        DynamicString->MaximumLength = (USHORT) TotalLength;
        *StringUsed = DynamicString;
    }

    Cursor = (PWSTR) (((ULONG_PTR) (*StringUsed)->Buffer) + String.Length);
    *Cursor++ = L'\\';
    *Cursor++ = L'\0';
    (*StringUsed)->Length = (USHORT) (String.Length + sizeof(WCHAR)); // aka "TotalLength - sizeof(WCHAR)" but this seemed cleaner

    *OpenDirectoryHandle = TempDirectoryHandle;
    TempDirectoryHandle = NULL;

    Status = STATUS_SUCCESS;
Exit:
    DbgPrintFunctionExit(__FUNCTION__, Status);

    if (FreeBuffer != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
    }

    if ((String.Buffer != NULL) && (String.Buffer != Buffer)) {
        (RtlFreeStringRoutine)(String.Buffer);
    }

    if (TempDirectoryHandle != NULL) {
        RTL_SOFT_VERIFY(NT_SUCCESS(NtClose(TempDirectoryHandle)));
    }

    return Status;
}

#if 0 /* dead code */

NTSTATUS
NTAPI
RtlResolveAssemblyStorageMapEntry(
    IN ULONG Flags,
    IN PACTIVATION_CONTEXT ActivationContext,
    IN ULONG AssemblyRosterIndex,
    IN PASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_ROUTINE Callback,
    IN PVOID CallbackContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PCACTIVATION_CONTEXT_DATA ActivationContextData = NULL;
    PASSEMBLY_STORAGE_MAP Map = NULL;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER AssemblyRosterHeader = NULL;
    PPEB Peb = NtCurrentPeb();

    DbgPrintFunctionEntry(__FUNCTION__);
    ASSERT_OK_TO_WRITE_PEB();
    RTLP_DISALLOW_THE_EMPTY_ACTIVATION_CONTEXT(ActivationContext);

    Status = RtlpGetActivationContextDataStorageMapAndRosterHeader(
                    0,
                    Peb,
                    ActivationContext,
                    &ActivationContextData,
                    &Map,
                    &AssemblyRosterHeader);
    if (!NT_SUCCESS(Status))
        goto Exit;

    if (ActivationContextData == NULL) {
        ASSERT(ActivationContext == NULL);

        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: RtlResolveAssemblyStorageMapEntry() asked to resolve an assembly storage entry when no activation context data is available.\n");

        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (AssemblyRosterIndex >= AssemblyRosterHeader->EntryCount) {

        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() bad parameters: AssemblyRosterIndex 0x%lx >= AssemblyRosterHeader->EntryCount 0x%lx\n",
            __FUNCTION__,
            AssemblyRosterIndex,
            AssemblyRosterHeader->EntryCount
            );
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Status = RtlpResolveAssemblyStorageMapEntry(Map, ActivationContextData, AssemblyRosterIndex, Callback, CallbackContext);
    if (!NT_SUCCESS(Status))
        goto Exit;

    Status = STATUS_SUCCESS;
Exit:
    DbgPrintFunctionExit(__FUNCTION__, Status);

    return Status;
}

#endif /* dead code */

NTSTATUS
NTAPI
RtlGetAssemblyStorageRoot(
    IN ULONG Flags,
    IN PACTIVATION_CONTEXT ActivationContext,
    IN ULONG AssemblyRosterIndex,
    OUT PCUNICODE_STRING *AssemblyStorageRoot,
    IN PASSEMBLY_STORAGE_MAP_RESOLUTION_CALLBACK_ROUTINE Callback,
    IN PVOID CallbackContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    PCACTIVATION_CONTEXT_DATA ActivationContextData = NULL;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER AssemblyRosterHeader = NULL;
    PASSEMBLY_STORAGE_MAP AssemblyStorageMap = NULL;

    const PPEB Peb = NtCurrentPeb();

    DbgPrintFunctionEntry(__FUNCTION__);
    ASSERT_OK_TO_WRITE_PEB();
    RTLP_DISALLOW_THE_EMPTY_ACTIVATION_CONTEXT(ActivationContext);

    if (AssemblyStorageRoot != NULL) {
        *AssemblyStorageRoot = NULL;
    }

    if ((Flags & ~(RTL_GET_ASSEMBLY_STORAGE_ROOT_FLAG_ACTIVATION_CONTEXT_USE_PROCESS_DEFAULT
            | RTL_GET_ASSEMBLY_STORAGE_ROOT_FLAG_ACTIVATION_CONTEXT_USE_SYSTEM_DEFAULT))
        ||
        (AssemblyRosterIndex < 1) ||
        (AssemblyStorageRoot == NULL) ||
        (Callback == NULL)) {

        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() bad parameters:\n"
            "SXS:    Flags              : 0x%lx\n"
            "SXS:    AssemblyRosterIndex: 0x%lx\n"
            "SXS:    AssemblyStorageRoot: %p\n"
            "SXS:    Callback           : %p\n",
            __FUNCTION__,
            Flags,
            AssemblyRosterIndex,
            AssemblyStorageRoot,
            Callback
            );
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    // Simple implementation: just resolve it and if it resolves OK, return the string in the
    // storage map.
    Status =
        RtlpGetActivationContextDataStorageMapAndRosterHeader(
            ((Flags & RTL_GET_ASSEMBLY_STORAGE_ROOT_FLAG_ACTIVATION_CONTEXT_USE_PROCESS_DEFAULT)
                ? RTLP_GET_ACTIVATION_CONTEXT_DATA_STORAGE_MAP_AND_ROSTER_HEADER_USE_PROCESS_DEFAULT
                : 0)
            | ((Flags & RTL_GET_ASSEMBLY_STORAGE_ROOT_FLAG_ACTIVATION_CONTEXT_USE_SYSTEM_DEFAULT)
                ? RTLP_GET_ACTIVATION_CONTEXT_DATA_STORAGE_MAP_AND_ROSTER_HEADER_USE_SYSTEM_DEFAULT
                : 0),
            Peb,
            ActivationContext,
            &ActivationContextData,
            &AssemblyStorageMap,
            &AssemblyRosterHeader
            );
    if (!NT_SUCCESS(Status)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: RtlGetAssemblyStorageRoot() unable to get activation context data, storage map and assembly roster header.  Status = 0x%08lx\n", Status);

        goto Exit;
    }

    // It's possible that there wasn't anything...
    if (ActivationContextData != NULL) {
        ASSERT(AssemblyRosterHeader != NULL);
        ASSERT(AssemblyStorageMap != NULL);

        if ((AssemblyRosterHeader == NULL) || (AssemblyStorageMap == NULL)) {
            Status = STATUS_INTERNAL_ERROR;
            goto Exit;
        }

        if (AssemblyRosterIndex >= AssemblyRosterHeader->EntryCount) {

            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() bad parameters AssemblyRosterIndex 0x%lx "
                           ">= AssemblyRosterHeader->EntryCount: 0x%lx\n",
                __FUNCTION__,
                AssemblyRosterIndex,
                AssemblyRosterHeader->EntryCount
                );
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        Status = RtlpResolveAssemblyStorageMapEntry(AssemblyStorageMap, ActivationContextData, AssemblyRosterIndex, Callback, CallbackContext);
        if (!NT_SUCCESS(Status)) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: RtlGetAssemblyStorageRoot() unable to resolve storage map entry.  Status = 0x%08lx\n", Status);

            goto Exit;
        }

        // I guess we're done!
        ASSERT(AssemblyStorageMap->AssemblyArray[AssemblyRosterIndex] != NULL);
        if (AssemblyStorageMap->AssemblyArray[AssemblyRosterIndex] == NULL) {
            Status = STATUS_INTERNAL_ERROR;
            goto Exit;
        }

        *AssemblyStorageRoot = &AssemblyStorageMap->AssemblyArray[AssemblyRosterIndex]->DosPath;
    }

    Status = STATUS_SUCCESS;
Exit:
    DbgPrintFunctionExit(__FUNCTION__, Status);
    return Status;
}

NTSTATUS
RtlpGetActivationContextDataStorageMapAndRosterHeader(
    ULONG Flags,
    PPEB Peb,
    PACTIVATION_CONTEXT ActivationContext,
    PCACTIVATION_CONTEXT_DATA *ActivationContextData,
    PASSEMBLY_STORAGE_MAP *AssemblyStorageMap,
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER  *AssemblyRosterHeader
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER TempAssemblyRosterHeader = NULL;
    PCACTIVATION_CONTEXT_DATA* TempActivationContextData = NULL;
    PASSEMBLY_STORAGE_MAP* TempAssemblyStorageMap = NULL;
    WCHAR LocalAssemblyDirectoryBuffer[DOS_MAX_PATH_LENGTH];
    UNICODE_STRING LocalAssemblyDirectory = {0};

    DbgPrintFunctionEntry(__FUNCTION__);
    LocalAssemblyDirectoryBuffer[0] = 0;
    LocalAssemblyDirectory.Length = 0;
    LocalAssemblyDirectory.MaximumLength = sizeof(WCHAR);
    LocalAssemblyDirectory.Buffer = LocalAssemblyDirectoryBuffer;

    ASSERT(Peb != NULL);
    RTLP_DISALLOW_THE_EMPTY_ACTIVATION_CONTEXT(ActivationContext);

    if (ActivationContextData != NULL) {
        *ActivationContextData = NULL;
    }

    if (AssemblyStorageMap != NULL) {
        *AssemblyStorageMap = NULL;
    }

    if (AssemblyRosterHeader != NULL) {
        *AssemblyRosterHeader = NULL;
    }

    if (
        (Flags & ~(RTLP_GET_ACTIVATION_CONTEXT_DATA_STORAGE_MAP_AND_ROSTER_HEADER_USE_PROCESS_DEFAULT
            | RTLP_GET_ACTIVATION_CONTEXT_DATA_STORAGE_MAP_AND_ROSTER_HEADER_USE_SYSTEM_DEFAULT))
        ||
        (Peb == NULL) ||
        (ActivationContextData == NULL) ||
        (AssemblyStorageMap == NULL)) {

        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() bad parameters:\n"
            "SXS:    Flags                : 0x%lx\n"
            "SXS:    Peb                  : %p\n"
            "SXS:    ActivationContextData: %p\n"
            "SXS:    AssemblyStorageMap   : %p\n"
            __FUNCTION__,
            Flags,
            Peb,
            ActivationContextData,
            AssemblyStorageMap
            );
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (ActivationContext == ACTCTX_PROCESS_DEFAULT
        || ActivationContext == ACTCTX_SYSTEM_DEFAULT
        || (Flags & (
        RTLP_GET_ACTIVATION_CONTEXT_DATA_STORAGE_MAP_AND_ROSTER_HEADER_USE_PROCESS_DEFAULT
        | RTLP_GET_ACTIVATION_CONTEXT_DATA_STORAGE_MAP_AND_ROSTER_HEADER_USE_SYSTEM_DEFAULT))) {

        //
        // NOTE the ambiguity here. Maybe we'll clean this up.
        //
        // The flags override.
        // ActivationContext == ACTCTX_PROCESS_DEFAULT could still be system default.
        //

        if (ActivationContext == ACTCTX_SYSTEM_DEFAULT
            || (Flags & RTLP_GET_ACTIVATION_CONTEXT_DATA_STORAGE_MAP_AND_ROSTER_HEADER_USE_SYSTEM_DEFAULT)
            ) {
            TempActivationContextData = (PACTIVATION_CONTEXT_DATA*)(&Peb->SystemDefaultActivationContextData);
            TempAssemblyStorageMap = (PASSEMBLY_STORAGE_MAP*)(&Peb->SystemAssemblyStorageMap);

            if (*TempActivationContextData != NULL) {
                TempAssemblyRosterHeader = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER) (((ULONG_PTR) *TempActivationContextData) + (*TempActivationContextData)->AssemblyRosterOffset);
            }
        }
        else if (ActivationContext == ACTCTX_PROCESS_DEFAULT || (Flags & RTLP_GET_ACTIVATION_CONTEXT_DATA_STORAGE_MAP_AND_ROSTER_HEADER_USE_PROCESS_DEFAULT)) {
            TempActivationContextData = (PACTIVATION_CONTEXT_DATA*)(&Peb->ActivationContextData);
            TempAssemblyStorageMap = (PASSEMBLY_STORAGE_MAP*)(&Peb->ProcessAssemblyStorageMap);

            if (*TempActivationContextData != NULL) {
                TempAssemblyRosterHeader = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER) (((ULONG_PTR) *TempActivationContextData) + (*TempActivationContextData)->AssemblyRosterOffset);
                if (*TempAssemblyStorageMap == NULL) {
                    UNICODE_STRING ImagePathName;

                    // Capture the image path name so that we don't overrun allocated buffers because someone's
                    // randomly tweaking the RTL_USER_PROCESS_PARAMETERS.
                    ImagePathName = Peb->ProcessParameters->ImagePathName;

                    // The process default local assembly directory is the image name plus ".local".
                    // The process default private assembly directory is the image path.
                    if ((ImagePathName.Length + sizeof(LOCAL_ASSEMBLY_STORAGE_DIR_SUFFIX)) > sizeof(LocalAssemblyDirectoryBuffer)) {
                        if ((ImagePathName.Length + sizeof(LOCAL_ASSEMBLY_STORAGE_DIR_SUFFIX)) > UNICODE_STRING_MAX_BYTES) {
                            Status = STATUS_NAME_TOO_LONG;
                            goto Exit;
                        }

                        LocalAssemblyDirectory.MaximumLength = (USHORT) (ImagePathName.Length + sizeof(LOCAL_ASSEMBLY_STORAGE_DIR_SUFFIX));

                        LocalAssemblyDirectory.Buffer = (RtlAllocateStringRoutine)(LocalAssemblyDirectory.MaximumLength);
                        if (LocalAssemblyDirectory.Buffer == NULL) {
                            Status = STATUS_NO_MEMORY;
                            goto Exit;
                        }
                    } else {
                        LocalAssemblyDirectory.MaximumLength = sizeof(LocalAssemblyDirectoryBuffer);
                        LocalAssemblyDirectory.Buffer = LocalAssemblyDirectoryBuffer;
                    }

                    RtlCopyMemory(
                        LocalAssemblyDirectory.Buffer,
                        ImagePathName.Buffer,
                        ImagePathName.Length);

                    RtlCopyMemory(
                        &LocalAssemblyDirectory.Buffer[ImagePathName.Length / sizeof(WCHAR)],
                        LOCAL_ASSEMBLY_STORAGE_DIR_SUFFIX,
                        sizeof(LOCAL_ASSEMBLY_STORAGE_DIR_SUFFIX));

                    LocalAssemblyDirectory.Length = ImagePathName.Length + sizeof(LOCAL_ASSEMBLY_STORAGE_DIR_SUFFIX) - sizeof(WCHAR);

                    if (!NT_SUCCESS(Status))
                        goto Exit;
                }
            }
        }
        if (*TempActivationContextData != NULL) {
            if (*TempAssemblyStorageMap == NULL) {
                PASSEMBLY_STORAGE_MAP Map = (PASSEMBLY_STORAGE_MAP) RtlAllocateHeap(RtlProcessHeap(), 0, sizeof(ASSEMBLY_STORAGE_MAP) + (TempAssemblyRosterHeader->EntryCount * sizeof(PASSEMBLY_STORAGE_MAP_ENTRY)));
                if (Map == NULL) {
                    Status = STATUS_NO_MEMORY;
                    goto Exit;
                }
                Status = RtlpInitializeAssemblyStorageMap(Map, TempAssemblyRosterHeader->EntryCount, (PASSEMBLY_STORAGE_MAP_ENTRY *) (Map + 1));
                if (!NT_SUCCESS(Status)) {
                    RtlFreeHeap(RtlProcessHeap(), 0, Map);
                    goto Exit;
                }

                if (InterlockedCompareExchangePointer(TempAssemblyStorageMap, Map, NULL) != NULL) {
                    // We were not the first ones in.  Free ours and use the one allocated.
                    RtlpUninitializeAssemblyStorageMap(Map);
                    RtlFreeHeap(RtlProcessHeap(), 0, Map);
                }
            }
        } else {
            ASSERT(*TempAssemblyStorageMap == NULL);
        }
        *AssemblyStorageMap = (PASSEMBLY_STORAGE_MAP) *TempAssemblyStorageMap;
    } else {
        TempActivationContextData = (PACTIVATION_CONTEXT_DATA*)(&ActivationContext->ActivationContextData);

        ASSERT(*TempActivationContextData != NULL);
        if (*TempActivationContextData == NULL) {
            Status = STATUS_INTERNAL_ERROR;
            goto Exit;
        }

        TempAssemblyRosterHeader = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER) (((ULONG_PTR) *TempActivationContextData) + (*TempActivationContextData)->AssemblyRosterOffset);
        *AssemblyStorageMap = &ActivationContext->StorageMap;
    }

    if (ActivationContextData != NULL)
        *ActivationContextData = *TempActivationContextData;

    if (AssemblyRosterHeader != NULL)
        *AssemblyRosterHeader = TempAssemblyRosterHeader;

    Status = STATUS_SUCCESS;
Exit:
    DbgPrintFunctionExit(__FUNCTION__, Status);
    if ((LocalAssemblyDirectory.Buffer != NULL) &&
        (LocalAssemblyDirectory.Buffer != LocalAssemblyDirectoryBuffer)) {
        RtlFreeUnicodeString(&LocalAssemblyDirectory);
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\tpath.c ===
/*++

Copyright (b\\c) 2000 Microsoft Corporation

Module Name:

    tpath.b\\c

Abstract:

    Test program for path stuff in rtl.

Author:

    Jay Krell (a-JayK) November 2000

Revision History:

--*/

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include <stdio.h>

//__declspec(selectany) int _ldused = 0;
//__declspec(selectany) int _fltused = 0;

#if 1
void __stdcall RtlpInitDeferedCriticalSection(void);
void __stdcall RtlpDphInitializeDelayedFreeQueue(void);
extern RTL_CRITICAL_SECTION RtlpDphHeapListCriticalSection;

VOID __stdcall LdrpInitialize (IN PCONTEXT Context, IN PVOID SystemArgument1, IN PVOID SystemArgument2);

void NtdllMain()
{
    PPEB PPeb = NtCurrentPeb();
    PTEB PTeb = NtCurrentTeb();
    PEB  Peb;
    TEB  Teb;
    HANDLE NtdllModuleHandle = GetModuleHandleW(L"ntdll.dll");
    HANDLE MyModuleHandle = GetModuleHandleW(NULL);
    PIMAGE_NT_HEADERS MyHeaders = RtlImageNtHeader(MyModuleHandle);
    /*const*/ static IMAGE_NT_HEADERS ZeroHeaders = { 0 };
    SIZE_T RegionSize = 0x10000;
    PVOID  Base = MyModuleHandle;
    ULONG  OldProtect = 0;
    NTSTATUS Status;

    Status = NtProtectVirtualMemory(
                NtCurrentProcess(),
                &Base,
                &RegionSize,
                PAGE_EXECUTE_READWRITE,
                &OldProtect
                );
/*
    WriteProcessMemory(
        NtCurrentProcess(),
        &MyHeaders->OptionalHeader.DataDirectory,
        &ZeroHeaders,
        sizeof(MyHeaders->OptionalHeader.DataDirectory),
        NULL
        );
*/
    RtlZeroMemory(&MyHeaders->OptionalHeader.DataDirectory, sizeof(MyHeaders->OptionalHeader.DataDirectory));
#if 0
    NLSTABLEINFO InitTableInfo = {0};

    RtlInitNlsTables(
        Peb->AnsiCodePageData,
        Peb->OemCodePageData,
        Peb->UnicodeCaseTableData,
        &InitTableInfo
        );

    RtlResetRtlTranslations(&InitTableInfo);

    RtlpInitDeferedCriticalSection();
    RtlInitializeCriticalSection( &RtlpDphHeapListCriticalSection );
    RtlpDphInitializeDelayedFreeQueue();
#elif 1
    Peb = *PPeb;
    Teb = *PTeb;
    RtlZeroMemory(NtCurrentPeb(), sizeof(*NtCurrentPeb()));
    PPeb->ProcessParameters = Peb.ProcessParameters;
    PPeb->BeingDebugged = Peb.BeingDebugged;
    PPeb->FastPebLock = Peb.FastPebLock;
    PPeb->FastPebLockRoutine = Peb.FastPebLockRoutine;
    PPeb->FastPebUnlockRoutine = Peb.FastPebUnlockRoutine;
    PPeb->ProcessHeap = Peb.ProcessHeap;
    PPeb->ImageBaseAddress = Peb.ImageBaseAddress;
    PPeb->AnsiCodePageData = Peb.AnsiCodePageData;
    PPeb->OemCodePageData = Peb.OemCodePageData;
    PPeb->UnicodeCaseTableData = Peb.UnicodeCaseTableData;
    PPeb->NtGlobalFlag = Peb.NtGlobalFlag
                    /*
                   | FLG_HEAP_ENABLE_TAIL_CHECK |
                     FLG_HEAP_ENABLE_FREE_CHECK |
                     FLG_HEAP_VALIDATE_PARAMETERS |
                     FLG_HEAP_VALIDATE_ALL |
                     FLG_HEAP_ENABLE_TAGGING
                     */
                     ;
    __try
    {
        //LdrpInitialize(0, NtdllModuleHandle, 0);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
    PPeb->ProcessParameters = Peb.ProcessParameters;
    PPeb->BeingDebugged = Peb.BeingDebugged;
    PPeb->NtGlobalFlag = Peb.NtGlobalFlag
                    /*
                   | FLG_HEAP_ENABLE_TAIL_CHECK |
                     FLG_HEAP_ENABLE_FREE_CHECK |
                     FLG_HEAP_VALIDATE_PARAMETERS |
                     FLG_HEAP_VALIDATE_ALL |
                     FLG_HEAP_ENABLE_TAGGING
                     */
                     ;
    PPeb->FastPebLock = Peb.FastPebLock;
    PPeb->FastPebLockRoutine = Peb.FastPebLockRoutine;
    PPeb->ProcessHeap = Peb.ProcessHeap;
    PPeb->FastPebUnlockRoutine = Peb.FastPebUnlockRoutine;
    PPeb->ImageBaseAddress = Peb.ImageBaseAddress;
    PPeb->AnsiCodePageData = Peb.AnsiCodePageData;
    PPeb->OemCodePageData = Peb.OemCodePageData;
    PPeb->UnicodeCaseTableData = Peb.UnicodeCaseTableData;
    PPeb->Ldr = Peb.Ldr;
#else
#endif
}
#else
void NtdllMain() { }
#include "curdir.c"
#endif

// WriteProcessMemory(1 + (ULONG_PTR)RtlEnterCriticalSection, GetModuleHandleW(L"ntdll.dll"), "RtlEnterCriticalSection"

static BOOLEAN InMain;

int __cdecl main(int argc, char** argv)
{
    UCHAR Buffer[100];
    RTL_UNICODE_STRING_BUFFER StringBuffer = {0};
    UNICODE_STRING String = {0};
    ULONG i = 0;
    PCWSTR x = 0;
    PCWSTR y = 0;
    NTSTATUS Status = 0;

    const static WCHAR AppendPathElementTestData[] =
    {
// noslash
        L"a\0bar\0" // =  a\b
// one slash
        L"/a\0bar\0" // = /a/b
        L"a/\0bar\0" // = /a/b/
        L"a\0/b\0" // =  a/b
        L"a\0bar/\0" // =  a/b/
// two slashes
        L"/a/\0bar\0" // = /a/b/
        L"/a\0/b\0" // = /a/b
        L"/a\0bar/\0" // = /a/b/
        L"a/\0/b\0" // =  a/b/
        L"a/\0bar/\0" // =  a/b/
        L"a\0/b/\0" // =  a/b/
// three slashes
        L"/a/\0/b\0" // = /a/b/
        L"/a/\0bar/\0" // = /a/b/
        L"/a\0/b/\0" // = /a/b/
        L"a/\0/b/\0" // =  a/b
// four slashes
        L"/a/\0/b/\0" // = /a/b/
//
// 1 + 4 + 6 + 4 + 1 = 4^2 = 16 posibilities
        L"\0"
    };

    const static WCHAR RemoveLastPathElementTestData[] =
    {

    //
    // move/copy cases to the top to debug them
    //
        //L"c:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
        //L"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"
        //L"\0"

        L"\\\\a\\\\b\\\\c\\\\\0"

        L"x:\\\0"

        L"c:a\\\\b\\c\\\\\0"

        L"\\\\?\\a:\\\0"

        L"\\\\?\\unc\\a\\b\0"

        L"\\\0"
        L"\\\\\0"
        L"\\\\?\0"

        L"\\\\?\\unc\0"
        L"\\\\?\\unc\\a\0"
        L"\\\\?\\unc\\a\\b\0"
        L"\\\\?\\unc\\a\\b\\c\0"

        L"\\\\?\\a\0"
        L"\\\\?\\a\\b\0"
        L"\\\\?\\a\\b\\c\0"

        L"\\\\?\\a:\0"
        L"\\\\?\\a:\\\0"
        L"\\\\?\\a:\\b\0"
        L"\\\\?\\a:\\b\\c\0"

        L"\\\\a\\\\b\\c\\\\\0"
        L"\\\\a\\\\b\\c\\\0"
        L"\\\\a\\\\b\\c/\0"
        L"\\\\a\\\\b\\c//\0"
        L"\\\\a\\\\b\\c/\\\0"
        L"\\\\a\\\\b\\c\\/\0"
        L"\\\\a\\\\b\\c\0"

        L"\\\\a\\b\\c\\\\\0"
        L"\\\\a\\b\\c\\\0"
        L"\\\\a\\b\\c/\0"
        L"\\\\a\\b\\c//\0"
        L"\\\\a\\b\\c/\\\0"
        L"\\\\a\\b\\c\\/\0"
        L"\\\\a\\b\\c\0"

        L"\\\\a/b\\c\\\\\0"
        L"\\\\a/b\\c\\\0"
        L"\\\\a/b\\c/\0"
        L"\\\\a/b\\c//\0"
        L"\\\\a/b\\c/\\\0"
        L"\\\\a/b\\c\\/\0"
        L"\\\\a/b\\c\0"

        L"\\\\a//b\\c\\\\\0"
        L"\\\\a//b\\c\\\0"
        L"\\\\a//b\\c/\0"
        L"\\\\a//b\\c//\0"
        L"\\\\a//b\\c/\\\0"
        L"\\\\a//b\\c\\/\0"
        L"\\\\a//b\\c\0"

        L"\\\\a/\\b\\c\\\\\0"
        L"\\\\a/\\b\\c\\\0"
        L"\\\\a/\\b\\c/\0"
        L"\\\\a/\\b\\c//\0"
        L"\\\\a/\\b\\c/\\\0"
        L"\\\\a/\\b\\c\\/\0"
        L"\\\\a/\\b\\c\0"

        L"\\\\a\\/b\\c\\\\\0"
        L"\\\\a\\/b\\c\\\0"
        L"\\\\a\\/b\\c/\0"
        L"\\\\a\\/b\\c//\0"
        L"\\\\a\\/b\\c/\\\0"
        L"\\\\a\\/b\\c\\/\0"
        L"\\\\a\\/b\\c\0"

        L"\\\\\0"
        L"//\0"
        L"/\\\0"
        L"\\/\0"

        L"x:\\\\a\\\\b\\c\\\\\0"
        L"x:\\\\a\\\\b\\c\\\0"
        L"x:\\\\a\\\\b\\c/\0"
        L"x:\\\\a\\\\b\\c//\0"
        L"x:\\\\a\\\\b\\c/\\\0"
        L"x:\\\\a\\\\b\\c\\/\0"
        L"x:\\\\a\\\\b\\c\0"

        L"x:\\\\a\\b\\c\\\\\0"
        L"x:\\\\a\\b\\c\\\0"
        L"x:\\\\a\\b\\c/\0"
        L"x:\\\\a\\b\\c//\0"
        L"x:\\\\a\\b\\c/\\\0"
        L"x:\\\\a\\b\\c\\/\0"
        L"x:\\\\a\\b\\c\0"

        L"x:\\\\a/b\\c\\\\\0"
        L"x:\\\\a/b\\c\\\0"
        L"x:\\\\a/b\\c/\0"
        L"x:\\\\a/b\\c//\0"
        L"x:\\\\a/b\\c/\\\0"
        L"x:\\\\a/b\\c\\/\0"
        L"x:\\\\a/b\\c\0"

        L"x:\\\\a//b\\c\\\\\0"
        L"x:\\\\a//b\\c\\\0"
        L"x:\\\\a//b\\c/\0"
        L"x:\\\\a//b\\c//\0"
        L"x:\\\\a//b\\c/\\\0"
        L"x:\\\\a//b\\c\\/\0"
        L"x:\\\\a//b\\c\0"

        L"x:\\\\a/\\b\\c\\\\\0"
        L"x:\\\\a/\\b\\c\\\0"
        L"x:\\\\a/\\b\\c/\0"
        L"x:\\\\a/\\b\\c//\0"
        L"x:\\\\a/\\b\\c/\\\0"
        L"x:\\\\a/\\b\\c\\/\0"
        L"x:\\\\a/\\b\\c\0"

        L"x:\\\\a\\/b\\c\\\\\0"
        L"x:\\\\a\\/b\\c\\\0"
        L"x:\\\\a\\/b\\c/\0"
        L"x:\\\\a\\/b\\c//\0"
        L"x:\\\\a\\/b\\c/\\\0"
        L"x:\\\\a\\/b\\c\\/\0"
        L"x:\\\\a\\/b\\c\0"

        L"x:\\\\a\\\\\0"
        L"x:\\\\a\\\0"
        L"x:\\\\a/\0"
        L"x:\\\\a//\0"
        L"x:\\\\a/\\\0"
        L"x:\\\\a\\/\0"
        L"x:\\\\a\0"

        L"x:\\a\\\\\0"
        L"x:\\a\\\0"
        L"x:\\a/\0"
        L"x:\\a//\0"
        L"x:\\a/\\\0"
        L"x:\\a\\/\0"
        L"x:\\a\0"

        L"x:/a\\\\\0"
        L"x:/a\\\0"
        L"x:/a/\0"
        L"x:/a//\0"
        L"x:/a/\\\0"
        L"x:/a\\/\0"
        L"x:/a\0"

        L"x:\\\0"
        L"x:/\0"
        L"x:\0"
        L"c\0"

        //////////////////////////////////////////////////////////////////////////

        L"a\\\\b\\c\\\\\0"
        L"a\\\\b\\c\\\0"
        L"a\\\\b\\c/\0"
        L"a\\\\b\\c//\0"
        L"a\\\\b\\c/\\\0"
        L"a\\\\b\\c\\/\0"
        L"a\\\\b\\c\0"

        L"a\\b\\c\\\\\0"
        L"a\\b\\c\\\0"
        L"a\\b\\c/\0"
        L"a\\b\\c//\0"
        L"a\\b\\c/\\\0"
        L"a\\b\\c\\/\0"
        L"a\\b\\c\0"

        L"a/b\\c\\\\\0"
        L"a/b\\c\\\0"
        L"a/b\\c/\0"
        L"a/b\\c//\0"
        L"a/b\\c/\\\0"
        L"a/b\\c\\/\0"
        L"a/b\\c\0"

        L"a//b\\c\\\\\0"
        L"a//b\\c\\\0"
        L"a//b\\c/\0"
        L"a//b\\c//\0"
        L"a//b\\c/\\\0"
        L"a//b\\c\\/\0"
        L"a//b\\c\0"

        L"a/\\b\\c\\\\\0"
        L"a/\\b\\c\\\0"
        L"a/\\b\\c/\0"
        L"a/\\b\\c//\0"
        L"a/\\b\\c/\\\0"
        L"a/\\b\\c\\/\0"
        L"a/\\b\\c\0"

        L"a\\/b\\c\\\\\0"
        L"a\\/b\\c\\\0"
        L"a\\/b\\c/\0"
        L"a\\/b\\c//\0"
        L"a\\/b\\c/\\\0"
        L"a\\/b\\c\\/\0"
        L"a\\/b\\c\0"

        L"x:a\\\\b\\c\\\\\0"
        L"x:a\\\\b\\c\\\0"
        L"x:a\\\\b\\c/\0"
        L"x:a\\\\b\\c//\0"
        L"x:a\\\\b\\c/\\\0"
        L"x:a\\\\b\\c\\/\0"
        L"x:a\\\\b\\c\0"

        L"x:a\\b\\c\\\\\0"
        L"x:a\\b\\c\\\0"
        L"x:a\\b\\c/\0"
        L"x:a\\b\\c//\0"
        L"x:a\\b\\c/\\\0"
        L"x:a\\b\\c\\/\0"
        L"x:a\\b\\c\0"

        L"x:a/b\\c\\\\\0"
        L"x:a/b\\c\\\0"
        L"x:a/b\\c/\0"
        L"x:a/b\\c//\0"
        L"x:a/b\\c/\\\0"
        L"x:a/b\\c\\/\0"
        L"x:a/b\\c\0"

        L"x:a//b\\c\\\\\0"
        L"x:a//b\\c\\\0"
        L"x:a//b\\c/\0"
        L"x:a//b\\c//\0"
        L"x:a//b\\c/\\\0"
        L"x:a//b\\c\\/\0"
        L"x:a//b\\c\0"

        L"x:a/\\b\\c\\\\\0"
        L"x:a/\\b\\c\\\0"
        L"x:a/\\b\\c/\0"
        L"x:a/\\b\\c//\0"
        L"x:a/\\b\\c/\\\0"
        L"x:a/\\b\\c\\/\0"
        L"x:a/\\b\\c\0"

        L"x:a\\/b\\c\\\\\0"
        L"x:a\\/b\\c\\\0"
        L"x:a\\/b\\c/\0"
        L"x:a\\/b\\c//\0"
        L"x:a\\/b\\c/\\\0"
        L"x:a\\/b\\c\\/\0"
        L"x:a\\/b\\c\0"

        L"x:a\\\\\0"
        L"x:a\\\0"
        L"x:a/\0"
        L"x:a//\0"
        L"x:a/\\\0"
        L"x:a\\/\0"
        L"x:a\0"

        L"x:a\\\\\0"
        L"x:a\\\0"
        L"x:a/\0"
        L"x:a//\0"
        L"x:a/\\\0"
        L"x:a\\/\0"
        L"x:a\0"

        L"x:a\\\\\0"
        L"x:a\\\0"
        L"x:a/\0"
        L"x:a//\0"
        L"x:a/\\\0"
        L"x:a\\/\0"
        L"x:a\0"

        L"\\a\\b\\c\\\\\0"
        L"\\a\\b\\c\\\0"
        L"\\a\\b\\c/\0"
        L"\\a\\b\\c//\0"
        L"\\a\\b\\c/\\\0"
        L"\\a\\b\\c\\/\0"
        L"\\a\\b\\c\0"

        L"\\a\0"
        L"\\a\\\0"
        L"\\a\\\0"
        L"\\a\\\0"
        L"\\a\\\0"
        L"\\a\\\0"
        L"\\a\\b\\c\0"

        L"\0\0"
    };

    if (InMain)
        return;
    InMain = TRUE;

    NtdllMain();

    Status = RtlInitUnicodeStringBuffer(&StringBuffer, Buffer, sizeof(Buffer));
    RTL_SOFT_ASSERT(NT_SUCCESS(Status));

#if 1
    for (   (x = AppendPathElementTestData, y = x + wcslen(x) + 1) ;
            *x && *y ;
            (x = y + wcslen(y) + 1, y = x + wcslen(x) + 1)
        )
    {
        RtlInitUnicodeString(&String, x);
        RTL_SOFT_VERIFY(NT_SUCCESS(Status = RtlAssignUnicodeStringBuffer(&StringBuffer, &String)));
        RtlInitUnicodeString(&String, y);

        RTL_SOFT_VERIFY(NT_SUCCESS(Status = RtlAppendPathElement(0, &StringBuffer, &String)));

        printf("%ls + %ls = %ls\n", x, y, StringBuffer.String.Buffer);
    }
#endif


#if 1
    printf("\n\nDosPath<->NtPath conversion\n\n");

    for (x = RemoveLastPathElementTestData ; *x || *(x + 1) ; x += + wcslen(x) + 1)
    {
        UNICODE_STRING DosToNt = {0};
        RTL_UNICODE_STRING_BUFFER NtToDos = {0};
        BOOLEAN  Success;

        RtlInitUnicodeStringBuffer(&NtToDos, 0, 0);
        //RtlInitUnicodeStringBuffer(&NtToDos, Buffer, sizeof(Buffer));

        RTL_SOFT_VERIFY(Success = RtlDosPathNameToNtPathName_U(x, &DosToNt, NULL, NULL));

        if (!Success)
            printf("%ls failed\n", x);
        else if (DosToNt.Length && DosToNt.Buffer)
        {
            printf("%ls -> %ls\n", x, DosToNt.Buffer);

            RTL_SOFT_VERIFY(NT_SUCCESS(Status = RtlAssignUnicodeStringBuffer(&NtToDos, &DosToNt)));
            RTL_SOFT_VERIFY(NT_SUCCESS(Status = RtlNtPathNameToDosPathName(0, &NtToDos, NULL, NULL)));

            if (Status != STATUS_SUCCESS)
                printf("%ls Status = 0x%08lx\n", x, Status);
            else if (NtToDos.String.Length && NtToDos.String.Buffer)
                printf("%ls -> %ls\n\n", DosToNt.Buffer, NtToDos.String.Buffer);
        }

        RtlFreeStringRoutine(DosToNt.Buffer);
        RtlFreeUnicodeStringBuffer(&NtToDos);
    }
#endif

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\uilist.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    uilist.c

Abstract:

    Contains routine to convert a list of workstation names from UI/Service
    list format to API list format

    Contents:
        RtlConvertUiListToApiList
        (NextElement)
        (ValidateName)

Author:

    Richard L Firth (rfirth) 01-May-1992

Environment:

    User mode (makes Windows calls)

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wchar.h>

//
// macros
//

#define IS_DELIMITER(c,_BlankOk) \
    (((c) == L' ' && (_BlankOk)) || \
    ((c) == L'\t') || ((c) == L',') || ((c) == L';'))


//
// prototypes
//

static
ULONG
NextElement(
    IN OUT PWSTR* InputBuffer,
    IN OUT PULONG InputBufferLength,
    OUT PWSTR OutputBuffer,
    IN ULONG OutputBufferLength,
    IN BOOLEAN BlankIsDelimiter
    );

static
BOOLEAN
ValidateName(
    IN  PWSTR Name,
    IN  ULONG Length
    );

//
// functions
//

NTSTATUS
RtlConvertUiListToApiList(
    IN  PUNICODE_STRING UiList OPTIONAL,
    OUT PUNICODE_STRING ApiList,
    IN BOOLEAN BlankIsDelimiter
    )

/*++

Routine Description:

    Converts a list of workstation names in UI/Service format into a list of
    canonicalized names in API list format. UI/Service list format allows
    multiple delimiters, leading and trailing delimiters. Delimiters are the
    set "\t,;". API list format has no leading or trailing delimiters and
    elements are delimited by a single comma character.

    For each name parsed from UiList, the name is canonicalized (which checks
    the character set and name length) as a workstation name. If this fails,
    an error is returned. No information is returned as to which element
    failed canonicalization: the list should be discarded and a new one re-input

Arguments:

    UiList  - The list to canonicalize in UI/Service list format
    ApiList - The place to store the canonicalized version of the list in
              API list format.  The list will have a trailing zero character.
    BlankIsDelimiter - TRUE indicates blank should be considered a delimiter
              character.

Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS
                    List converted ok

        Failure = STATUS_INVALID_PARAMETER
                    UiList parameter is in error

                  STATUS_INVALID_COMPUTER_NAME
                    A name parsed from UiList has an incorrect format for a
                    computer (aka workstation) name
--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG inLen;
    PWSTR input;
    PWSTR buffer;
    PWSTR output;
    ULONG cLen;
    ULONG len;
    ULONG outLen = 0;
    WCHAR element[MAX_COMPUTERNAME_LENGTH+1];
    BOOLEAN firstElement = TRUE;
    BOOLEAN ok;

    try {
        if (ARGUMENT_PRESENT(UiList)) {
            inLen = UiList->MaximumLength;  // read memory test
            inLen = UiList->Length;
            input = UiList->Buffer;
            if (inLen & sizeof(WCHAR)-1) {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        RtlInitUnicodeString(ApiList, NULL);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        status = STATUS_ACCESS_VIOLATION;
    }
    if (NT_SUCCESS(status) && ARGUMENT_PRESENT(UiList) && inLen) {
        buffer = RtlAllocateHeap(RtlProcessHeap(), 0, inLen + sizeof(WCHAR));
        if (buffer == NULL) {
            status = STATUS_NO_MEMORY;
        } else {
            ApiList->Buffer = buffer;
            ApiList->MaximumLength = (USHORT)inLen + sizeof(WCHAR);
            output = buffer;
            ok = TRUE;
            while (len = NextElement(&input,
                                     &inLen,
                                     element,
                                     sizeof(element) - sizeof(element[0]),
                                     BlankIsDelimiter )) {
                if (len == (ULONG)-1L) {
                    ok = FALSE;
                } else {
                    cLen = len/sizeof(WCHAR);
                    element[cLen] = 0;
                    ok = ValidateName(element, cLen);
                }
                if (ok) {
                    if (!firstElement) {
                        *output++ = L',';

                        outLen += sizeof(WCHAR);
                    } else {
                        firstElement = FALSE;
                    }
                    wcscpy(output, element);
                    outLen += len;
                    output += cLen;
                } else {
                    RtlFreeHeap(RtlProcessHeap(), 0, buffer);
                    ApiList->Buffer = NULL;
                    status = STATUS_INVALID_COMPUTER_NAME;
                    break;
                }
            }
        }
        if (NT_SUCCESS(status)) {
            ApiList->Length = (USHORT)outLen;
            if (!outLen) {
                ApiList->MaximumLength = 0;
                ApiList->Buffer = NULL;
                RtlFreeHeap(RtlProcessHeap(), 0, buffer);
            }
        }
    }
    return status;
}

static
ULONG
NextElement(
    IN OUT PWSTR* InputBuffer,
    IN OUT PULONG InputBufferLength,
    OUT PWSTR OutputBuffer,
    IN ULONG OutputBufferLength,
    IN BOOLEAN BlankIsDelimiter
    )

/*++

Routine Description:

    Locates the next (non-delimter) element in a string and extracts it to a
    buffer. Delimiters are the set [\t,;]

Arguments:

    InputBuffer         - pointer to pointer to input buffer including delimiters
                          Updated on successful return
    InputBufferLength   - pointer to length of characters in InputBuffer.
                          Updated on successful return
    OutputBuffer        - pointer to buffer where next element is copied
    OutputBufferLength  - size of OutputBuffer (in bytes)
    BlankIsDelimiter    - TRUE indicates blank should be considered a delimiter
              character.

Return Value:

    ULONG
                           -1 = error - extracted element breaks OutputBuffer
                            0 = no element extracted (buffer is empty or all
                                delimiters)
        1..OutputBufferLength = OutputBuffer contains extracted element

--*/

{
    ULONG elementLength = 0;
    ULONG inputLength = *InputBufferLength;
    PWSTR input = *InputBuffer;

    while (IS_DELIMITER(*input, BlankIsDelimiter) && inputLength) {
        ++input;
        inputLength -= sizeof(*input);
    }
    while (!IS_DELIMITER(*input, BlankIsDelimiter) && inputLength) {
        if (!OutputBufferLength) {
            return (ULONG)-1L;
        }
        *OutputBuffer++ = *input++;
        OutputBufferLength -= sizeof(*input);
        elementLength += sizeof(*input);
        inputLength -= sizeof(*input);
    }
    *InputBuffer = input;
    *InputBufferLength = inputLength;
    return elementLength;
}

//
// Illegal names characters same as those in net\api. Move to common
// include directory
//

#define ILLEGAL_NAME_CHARS      L"\001\002\003\004\005\006\007" \
                            L"\010\011\012\013\014\015\016\017" \
                            L"\020\021\022\023\024\025\026\027" \
                            L"\030\031\032\033\034\035\036\037" \
                            L"\"/\\[]:|<>+=;,?*"

static
BOOLEAN
ValidateName(
    IN  PWSTR Name,
    IN  ULONG Length
    )

/*++

Routine Description:

    Determines whether a computer name is valid or not

Arguments:

    Name    - pointer to zero terminated wide-character computer name
    Length  - of Name in characters, excluding zero-terminator

Return Value:

    BOOLEAN
        TRUE    Name is valid computer name
        FALSE   Name is not valid computer name

--*/

{
    if (Length > MAX_COMPUTERNAME_LENGTH || Length < 1) {
        return FALSE;
    }

    //
    // Don't allow leading or trailing blanks in the computername.
    //

    if ( Name[0] == ' ' || Name[Length-1] == ' ' ) {
        return(FALSE);
    }

    return (BOOLEAN)((ULONG)wcscspn(Name, ILLEGAL_NAME_CHARS) == Length);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\vectxcpt.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vectxcpt.c

Abstract:

    This module implements call out functionality needed to
    implement vectored exception handlers

Author:

    Mark Lucovsky (markl) 14-Feb-2000

Revision History:

--*/

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ldrp.h>

typedef struct _VECTXCPT_CALLOUT_ENTRY {
    LIST_ENTRY Links;
    PVECTORED_EXCEPTION_HANDLER VectoredHandler;
} VECTXCPT_CALLOUT_ENTRY, *PVECTXCPT_CALLOUT_ENTRY;

BOOLEAN
RtlCallVectoredExceptionHandlers(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord
    )
/*++

Routine Description:

    This function is called by the user-mode exception dispatcher trampoline
    logic prior to performing a frame based exception handler search.
    
    It's purpose is call any registered vectored exception handlers. If any one
    of the registered handlers tells this function to continue execution, exception
    handler searching is terminated and the passed in context is restored.
    
    If none of the vectored handlers returns this indication, frame based handling 
    resumes.

Arguments:

    ExceptionInfo - Supplies the address of an EXCEPTION_POINTERS structures
        that defines the current exception.
        
Return Value:

    EXCEPTION_CONTINUE_EXECUTION - A vectored handler would like execution to continue
        without searching for frame based exception handlers
        
    EXCEPTION_CONTINUE_SEARCH - None of the vectored handlers have "handled" the 
        exception, so frame based handlers should be searched

--*/
{
    
    PLIST_ENTRY Next;
    PVECTXCPT_CALLOUT_ENTRY CalloutEntry;
    LONG ReturnValue;
    EXCEPTION_POINTERS ExceptionInfo;

    if (IsListEmpty (&RtlpCalloutEntryList)) {
        return FALSE;
    }

    ExceptionInfo.ExceptionRecord = ExceptionRecord;
    ExceptionInfo.ContextRecord = ContextRecord;
    
    RtlEnterCriticalSection(&RtlpCalloutEntryLock);
    
    Next = RtlpCalloutEntryList.Flink;

    while ( Next != &RtlpCalloutEntryList) {

        //
        // Call all of the vectored handlers
        // The first one that returns EXCEPTION_CONTINUE_EXECUTION is assumed to
        // have "handled" the exception.
        //

        CalloutEntry = (PVECTXCPT_CALLOUT_ENTRY)(CONTAINING_RECORD(Next,VECTXCPT_CALLOUT_ENTRY,Links));
        ReturnValue = (CalloutEntry->VectoredHandler)(&ExceptionInfo);
        if (ReturnValue == EXCEPTION_CONTINUE_EXECUTION) {
            RtlLeaveCriticalSection(&RtlpCalloutEntryLock);
            return TRUE;
            }
        Next = Next->Flink;
        }
    RtlLeaveCriticalSection(&RtlpCalloutEntryLock);
    return FALSE;
}

PVOID
RtlAddVectoredExceptionHandler(
    IN ULONG FirstHandler,
    IN PVECTORED_EXCEPTION_HANDLER VectoredHandler
    )
/*++

Routine Description:

    This function is used to register a vectored exception handler. The caller
    can request that this be the first handler, or the last handler called by
    using the FirstHandler argument.
    
    If this API is used and that VectoredHandler points to a DLL, and that DLL unloads,
    the unload does not invalidate the registration of the handler. This is considered a
    programming error.
    
Arguments:

    FirstHandler - If non-zero, specifies that the VectoredHandler should be the
        first handler called. This of course changes when a subsequent call is
        made by other code in the process that also requests to be the FirstHandler. If zero,
        the vectored handler is added as the last handler to be called.

    VectoredHandler - Supplies the address of the handler to call.

Return Value:

    NULL - The operation failed. No further error status is available.
        
    Non-Null - The operation was successful. This value may be used in a subsequent call
        to RtlRemoveVectoredExceptionHandler.

--*/
{
    
    PVECTXCPT_CALLOUT_ENTRY CalloutEntry;
    LONG ReturnValue;

    CalloutEntry = RtlAllocateHeap(RtlProcessHeap(),0,sizeof(*CalloutEntry));

    if (CalloutEntry) {
        CalloutEntry->VectoredHandler = VectoredHandler;

        RtlEnterCriticalSection(&RtlpCalloutEntryLock);
        if (FirstHandler) {
            InsertHeadList(&RtlpCalloutEntryList,&CalloutEntry->Links);
        } else {
            InsertTailList(&RtlpCalloutEntryList,&CalloutEntry->Links);
        }
        RtlLeaveCriticalSection(&RtlpCalloutEntryLock);
    }
    return CalloutEntry;
}


ULONG
RtlRemoveVectoredExceptionHandler(
    IN PVOID VectoredHandlerHandle
    )
/*++

Routine Description:

    This function is used to un-register a vectored exception handler.
    
Arguments:

    VectoredHandlerHandle - Specifies a vectored handler previsouly registerd using
        RtlAddVectoredExceptionHandler.

Return Value:

    Non-Zero - The operation was successful. The vectored handler associated with the
        specified VectoredHandlerHandle will not be called.
        
    Zero - The operation failed. The specified VecoteredHandlerHandle does not match
        a handler previously added with RtlAddVectoredExceptionHandler.

--*/
{
    
    PLIST_ENTRY Next;
    PVECTXCPT_CALLOUT_ENTRY CalloutEntry;
    LONG ReturnValue;
    BOOLEAN FoundOne = FALSE;

    RtlEnterCriticalSection(&RtlpCalloutEntryLock);
    Next = RtlpCalloutEntryList.Flink;

    while ( Next != &RtlpCalloutEntryList) {

        CalloutEntry = (PVECTXCPT_CALLOUT_ENTRY)(CONTAINING_RECORD(Next,VECTXCPT_CALLOUT_ENTRY,Links));
        
        if (CalloutEntry == VectoredHandlerHandle) {
            RemoveEntryList(&CalloutEntry->Links);
            FoundOne = TRUE;
            break;
            }
        Next = Next->Flink;
        }
    RtlLeaveCriticalSection(&RtlpCalloutEntryLock);
        
    if (FoundOne) {
        RtlFreeHeap(RtlProcessHeap(),0,CalloutEntry);
        }
    return FoundOne ? 1 : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\wow64apc.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    wow64apc.c

Abstract:

    This module implements APC queuing to 32-bit target threads from
    native 64-bit threads.

Author:

    Samer Arafeh (samera) 9-Oct-2000

Revision History:

--*/

#include <ntos.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <heap.h>
#include <apcompat.h>
#include "ldrp.h"

#if defined(_WIN64)
extern PVOID Wow64ApcRoutine;
#endif




#if defined(_WIN64)
VOID
RtlpWow64Apc(
    IN PVOID Argument1,
    IN PVOID Argument2,
    IN PVOID Argument3
    )

/*++

Routine Description:

    This function is called as a result of firing a usermode APC that's targeted to 
    a thread running inside Wow64.

Arguments:

    ApcArgument1 - The 1st argument of the APC. This includes both the 32-bit APC and
        the original 1st argument.

    ApcArgument2 - The second argument of the APC

    ApcArgument3 - The third argument of the APC

Return Value:

    None
    
--*/

{
    if (Wow64ApcRoutine)
    {
        (*(PPS_APC_ROUTINE) Wow64ApcRoutine) (
            Argument1,
            Argument2,
            Argument3);
    }
}

#endif

NTSTATUS
RtlQueueApcWow64Thread(
    IN HANDLE ThreadHandle,
    IN PPS_APC_ROUTINE ApcRoutine,
    IN PVOID ApcArgument1,
    IN PVOID ApcArgument2,
    IN PVOID ApcArgument3
    )

/*++

Routine Description:

    This function is used to queue a 32-bit user-mode APC to the specified thread. The APC
    will fire when the specified thread does an alertable wait.
    
    Note: This function is only used by 64-bit components that want to queue an APC to 
          a thread running inside Wow64.

Arguments:

    ThreadHandle - Supplies a handle to a thread object.  The caller
        must have THREAD_SET_CONTEXT access to the thread.

    ApcRoutine - Supplies the address of the APC routine to execute when the
        APC fires.

    ApcArgument1 - Supplies the first PVOID passed to the APC

    ApcArgument2 - Supplies the second PVOID passed to the APC

    ApcArgument3 - Supplies the third PVOID passed to the APC

Return Value:

    Returns an NT Status code indicating success or failure of the API
    
--*/

{
#if defined(_WIN64)

    //
    // Setup the jacket routine inside ntdll
    //

    ApcArgument1 = (PVOID)((ULONG_PTR) ApcArgument1 | 
                           ((ULONG_PTR) ApcRoutine << 32 ));

    ApcRoutine = RtlpWow64Apc;
#endif

    return NtQueueApcThread (
        ThreadHandle,
        ApcRoutine,
        ApcArgument1,
        ApcArgument2,
        ApcArgument3);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\alpha\critsect.s ===
//      TITLE("Enter and Leave Critical Section")
//++
//
// Copyright (c) 1991  Microsoft Corporation
// Copyright (c) 1992  Digital Equipment Corporation
//
// Module Name:
//
//    critsect.s
//
// Abstract:
//
//    This module implements functions to support user mode critical sections.
//
// Author:
//
//    David N. Cutler 1-May-1992
//
// Environment:
//
//    Any mode.
//
// Revision History:
//
//    Thomas Van Baak (tvb) 21-May-1992
//
//        Adapted for Alpha AXP.
//
//--

#include "ksalpha.h"

        SBTTL("Enter Critical Section")
//++
//
// NTSTATUS
// RtlEnterCriticalSection (
//    IN PRTL_CRITICAL_SECTION CriticalSection
//    )
//
// Routine Description:
//
//    This function enters a critical section.
//
//    N.B. This function is duplicated in the runtime library.
//
// Arguments:
//
//    CriticalSection (a0) - Supplies a pointer to a critical section.
//
// Return Value:
//
//    STATUS_SUCCESS is returned as the function value.
//
//--

        .struct 0
EcRa:   .space  8                       // saved return address
EcA0:   .space  8                       // saved critical section address
EcA1:   .space  8                       // saved unique thread id
        .space  1 * 8                   // required for 16-byte stack alignment
EcFrameLength:                          // length of stack frame

        NESTED_ENTRY(RtlEnterCriticalSection, EcFrameLength, zero)

        lda     sp, -EcFrameLength(sp)  // allocate stack frame
        stq     ra, EcRa(sp)            // save return address

        PROLOGUE_END

        GET_THREAD_ENVIRONMENT_BLOCK    // (PALcode) get TEB address in v0

        ldl     t3, CsSpinCount(a0)     // check if spin count is zero
        LDP     a1, TeClientId + CidUniqueThread(v0) // get current thread id
        bne     t3, 50f                 // if ne, spin count specified

//
// Attempt to enter the critical section.
//

10:     ldl_l   t0, CsLockCount(a0)     // get addend value - locked
        addl    t0, 1, t0               // increment addend value
        mov     t0, t1                  //
        stl_c   t1, CsLockCount(a0)     // store conditionally
        beq     t1, 40f                 // if eq, conditional store failed
        mb                              // synchronize memory access

//
// If the critical section is not already owned, then initialize the owner
// thread id, initialize the recursion count, and return a success status.
// The updated lock value is now in t0.
//

        bne     t0, 20f                 // if ne, lock already owned
        STP     a1, CsOwningThread(a0)  // set critical section owner
        ldil    v0, STATUS_SUCCESS      // set return status
        lda     sp, EcFrameLength(sp)   // deallocate stack frame
        ret     zero, (ra)              // return

//
// The critical section is owned. If the current thread is the owner, then
// increment the recursion count, and return a success status. Otherwise,
// wait for critical section ownership.
// The current thread unique id is in a1.
//

20:     LDP     t0, CsOwningThread(a0)  // get unique id of owner thread
        cmpeq   a1, t0, t1              // check if current thread is owner
        beq     t1, 30f                 // if eq, current thread not owner
        ldl     t0, CsRecursionCount(a0) // increment the recursion count
        addl    t0, 1, t2               //
        stl     t2, CsRecursionCount(a0) //
        ldil    v0, STATUS_SUCCESS      // set return status
        lda     sp, EcFrameLength(sp)   // deallocate stack frame
        ret     zero, (ra)              // return

//
// The critical section is owned by a thread other than the current thread.
// Wait for ownership of the critical section.
// N.B. a1 is just a temp register below, not an argument to the function.
//

30:     stq     a0, EcA0(sp)            // save address of critical section
        stq     a1, EcA1(sp)            // save unique thread id
        bsr     ra, RtlpWaitForCriticalSection // wait for critical section
        ldq     a0, EcA0(sp)            // restore address of critical section
        ldq     a1, EcA1(sp)            // restore unique thread id
        STP     a1, CsOwningThread(a0)  // set critical section owner
        ldil    v0, STATUS_SUCCESS      // set return status
        ldq     ra, EcRa(sp)            // restore return address
        lda     sp, EcFrameLength(sp)   // deallocate stack frame
        ret     zero, (ra)              // return

//
// We expect the store conditional will usually succeed the first time so it
// is faster to branch forward (predicted not taken) to here and then branch
// backward (predicted taken) to where we wanted to go.
//

40:     br      zero, 10b               // go try lock again

//
// A nonzero spin count is specified
//

50:     LDP     t4, CsOwningThread(a0)  // get owner thread id
        cmpeq   t4, a1, t5              // check if current thread is owner
        beq     t5, 60f                 // if eq, current thread not owner

//
// The critical section is owned by the current thread. Increment the lock
// count and the recursion count.
//

55:     ldl_l   t0, CsLockCount(a0)     // get addend value - locked
        addl    t0, 1, t1               // increment addend value
        stl_c   t1, CsLockCount(a0)     // store conditionally
        beq     t1, 59f                 // if lock-flag eq zero, store failed
        mb                              // synchronize memory access
        ldl     t3, CsRecursionCount(a0) // increment recursion count
        addl    t3, 1, t4               //
        stl     t4, CsRecursionCount(a0) //
        ldil    v0, STATUS_SUCCESS      // set return status
        lda     sp, EcFrameLength(sp)   // deallocate stack frame
        ret     zero, (ra)              // return

//
// Store conditional attempt failed.
//

59:     br      zero, 55b               // go try lock again

//
// A nonzero spin count is specified and the current thread is not the owner.
//

60:     ldl_l   t0, CsLockCount(a0)     // get addend value - locked
        addl    t0, 1, t1               // increment addend value
        bne     t1, 70f                 // if ne, critical section is owned
        stl_c   t1, CsLockCount(a0)     // set new lock count
        beq     t1, 69f                 // if eq, conditional store failed
        mb                              // synchronize memory access

//
// The critical section has been acquired. Set the owning thread and the initial
// recursion count.
//

        STP     a1, CsOwningThread(a0)  // set critical section owner
        ldil    v0, STATUS_SUCCESS      // set return status
        lda     sp, EcFrameLength(sp)   // deallocate stack frame
        ret     zero, (ra)              // return

//
// Store conditional attempt failed.
//

69:     br      zero, 60b               //

//
// The critical section is currently owned. Spin until it is either unowned
// or the spin count has reached zero. Spin count is in t3
//
// If waiters are present, don't spin on the lock since we will never see it
// go free.
//

70:     ldl     t0, CsLockCount(a0)     // check if lock is owned
        addl    t0, 1, t1               //
        bgt     t0, 10b                 // if >=, then do not spin
        beq     t1, 60b                 // if eq, lock is not owned
        subl    t3, 1, t3               // decrement spin count
        bne     t3, 70b                 // if nz, continue spinning
        br      10b                     // spin expired, go wait for lock

        .end    RtlEnterCriticalSection

        SBTTL("Leave Critical Section")
//++
//
// NTSTATUS
// RtlLeaveCriticalSection (
//    IN PRTL_CRITICAL_SECTION CriticalSection
//    )
//
// Routine Description:
//
//    This function leaves a critical section.
//
//    N.B. This function is duplicated in the runtime library.
//
// Arguments:
//
//    CriticalSection (a0) - Supplies a pointer to a critical section.
//
// Return Value:
//
//    STATUS_SUCCESS is returned as the function value.
//
//--

        .struct 0
LcRa:   .space  8                       // saved return address
        .space  1 * 8                   // required for 16-byte stack alignment
LcFrameLength:                          // length of stack frame

        NESTED_ENTRY(RtlLeaveCriticalSection, LcFrameLength, zero)

        lda     sp, -LcFrameLength(sp)  // allocate stack frame
        stq     ra, LcRa(sp)            // save return address

        PROLOGUE_END

//
// If the current thread is not the owner of the critical section, then
// raise an exception.
//

#if DBG

        GET_THREAD_ENVIRONMENT_BLOCK    // (PALcode) get TEB address in v0

        LDP     a1, TeClientId + CidUniqueThread(v0) // get current thread id
        LDP     t0, CsOwningThread(a0)  // get owner thread id
        cmpeq   a1, t0, t1              // check if current thread owner
        bne     t1, 10f                 // if ne, current thread is owner
        bsr     ra, RtlpNotOwnerCriticalSection // raise exception
        ldil    v0, STATUS_INVALID_OWNER // set completion status
        ldq     ra, LcRa(sp)            // restore return address
        lda     sp, LcFrameLength(sp)   // deallocate stack frame
        ret     zero, (ra)              // return

#endif

//
// Decrement the recursion count. If the result is zero, then the lock
// is no longer owned.
//

10:     ldl     t0, CsRecursionCount(a0) // decrement recursion count
        subl    t0, 1, t0                //
        bge     t0, 30f                  // if ge, lock still owned
        STP     zero, CsOwningThread(a0) // clear owner thread id

//
// Decrement the lock count and check if a waiter should be continued.
//
//

20:     mb                              // synchronize memory access
        ldl_l   t0, CsLockCount(a0)     // get addend value - locked
        subl    t0, 1, t0               // decrement addend value
        mov     t0, t1                  // copy updated value to t1 for store
        stl_c   t1, CsLockCount(a0)     // store conditionally
        beq     t1, 60f                 // if eq, conditional store failed
        blt     t0, 50f                 // if lt, no waiter present
        bsr     ra, RtlpUnWaitCriticalSection // unwait thread
        ldil    v0, STATUS_SUCCESS      // set completion status
        ldq     ra, LcRa(sp)            // restore return address
        lda     sp, LcFrameLength(sp)   // deallocate stack frame
        ret     zero, (ra)              // return

//
// Decrement the lock count and return a success status since the lock
// is still owned.
//

30:     stl     t0, CsRecursionCount(a0) // store updated recursion count
40:     ldl_l   t0, CsLockCount(a0)     // get addend value - locked
        subl    t0, 1, t0               // decrement addend value
        stl_c   t0, CsLockCount(a0)     // store conditionally
        beq     t0, 70f                 // if lock-flag eq zero, store failed
50:     ldil    v0, STATUS_SUCCESS      // set completion status
        lda     sp, LcFrameLength(sp)   // deallocate stack frame
        ret     zero, (ra)              // return

//
// We expect the store conditional will usually succeed the first time so it
// is faster to branch forward (predicted not taken) to here and then branch
// backward (predicted taken) to where we wanted to go.
//

60:     br      zero, 20b               // go try lock again

70:     br      zero, 40b               // go try lock again

        .end    RtlLeaveCriticalSection


        SBTTL("Try to Enter Critical Section")
//++
//
// BOOLEAN
// RtlTryEnterCriticalSection(
//    IN PRTL_CRITICAL_SECTION CriticalSection
//    )
//
// Routine Description:
//
//    This function attempts to enter a critical section without blocking.
//
// Arguments:
//
//    CriticalSection (a0) - Supplies a pointer to a critical section.
//
// Return Value:
//
//    If the critical section was successfully entered, then a value of TRUE
//    is returned as the function value. Otherwise, a value of FALSE is returned.
//
//--

        .struct 0
EcRa:   .space  8                       // saved return address
EcA0:   .space  8                       // saved critical section address
EcA1:   .space  8                       // saved unique thread id
        .space  1 * 8                   // required for 16-byte stack alignment
EcFrameLength:                          // length of stack frame

        LEAF_ENTRY(RtlTryEnterCriticalSection)

        GET_THREAD_ENVIRONMENT_BLOCK    // (PALcode) get TEB address in v0

        LDP     a1, TeClientId + CidUniqueThread(v0) // get current thread unique id

//
// Attempt to enter the critical section.
//

10:     ldl_l   t0, CsLockCount(a0)     // get addend value - locked
        addl    t0, 1, t1               // increment addend value
        bne     t1, 20f                 // critical section owned
        stl_c   t1, CsLockCount(a0)     // store conditionally
        beq     t1, 40f                 // if eq, conditional store failed
        mb                              // synchronize memory access

//
// The critical section is now owned by this thread. Initialize the owner
// thread id and return a successful status.
//

        STP     a1, CsOwningThread(a0)  // set critical section owner
        ldil    v0, TRUE                // set success status
        ret     zero, (ra)

//
// The critical section is already owned. If it is owned by another thread,
// return FALSE immediately. If it is owned by this thread, we must increment
// the lock count here.
//

20:     LDP     t2, CsOwningThread(a0)  // get current owner
        cmpeq   t2, a1, t3              // check if current thread owner
        bne     t3, 30f                 // if ne, current thread owner
        bis     zero,zero,v0            // set failure status
        ret     zero, (ra)              // return

//
// This thread is already the owner of the critical section. Perform an atomic
// increment of the LockCount and a normal increment of the RecursionCount and
// return success.
//

30:     ldl_l   t0, CsLockCount(a0)     // get addend value - locked
        addl    t0, 1, t1               // increment addend value
        stl_c   t1, CsLockCount(a0)     // store conditionally
        beq     t1, 50f                 // if eq, conditional store failed
        ldl     t0, CsRecursionCount(a0) // increment recursion count
        addl    t0, 1, t1               //
        stl     t1, CsRecursionCount(a0) //
        ldil    v0, TRUE                // set success status
        ret     zero, (ra)              // return

//
// We expect the store conditional will usually succeed the first time so it
// is faster to branch forward (predicted not taken) to here and then branch
// backward (predicted taken) to where we wanted to go.
//

40:     br      zero, 10b               // go try lock again

50:     br      zero, 30b               // retry lock

        .end    RtlTryEnterCriticalSection
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\verifier.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    verifier.c

Abstract:

    This module implements the core support for application verifier.

Author:

    Silviu Calinoiu (SilviuC) 2-Feb-2001

Revision History:

--*/


#include "ntos.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <heap.h>
#include "ldrp.h"

#define AVRF_FLG_EXPORT_DLL_LOADED 0x0001

ULONG AVrfpDebug = 0x0000;

#define AVRF_DBG_SHOW_SNAPS             0x0001
#define AVRF_DBG_SHOW_VERIFIED_EXPORTS  0x0002
#define AVRF_DBG_SHOW_DLLS_WITH_EXPORTS 0x0004
#define AVRF_DBG_SHOW_PROVIDER_LOADS    0x0008
#define AVRF_DBG_SHOW_CHAIN_ACTIVITY    0x0010
#define AVRF_DBG_SHOW_CHAIN_DETAILS     0x0020

BOOLEAN AVrfpEnabled;

//
// Default system-wide settings
//

#define RTL_VRF_FLG_SYSTEM_WIDE_SETTINGS              \
    ( RTL_VRF_FLG_LOCK_CHECKS                         \
    | RTL_VRF_FLG_HANDLE_CHECKS                       \
    )

//
// Local vars
//

ULONG AVrfpVerifierFlags;
WCHAR AVrfpVerifierDllsString [512];
LIST_ENTRY AVrfpVerifierProvidersList;

RTL_CRITICAL_SECTION AVrfpVerifierLock;

#define VERIFIER_LOCK()  RtlEnterCriticalSection(&AVrfpVerifierLock)
#define VERIFIER_UNLOCK()  RtlLeaveCriticalSection(&AVrfpVerifierLock)

//
// Local types
//

typedef struct _AVRF_VERIFIER_DESCRIPTOR {

    LIST_ENTRY List;
    UNICODE_STRING VerifierName;
    PVOID VerifierHandle;
    PVOID VerifierEntryPoint;
    PRTL_VERIFIER_DLL_DESCRIPTOR VerifierDlls;
    RTL_VERIFIER_DLL_LOAD_CALLBACK VerifierLoadHandler;
    RTL_VERIFIER_DLL_UNLOAD_CALLBACK VerifierUnloadHandler;

} AVRF_VERIFIER_DESCRIPTOR, *PAVRF_VERIFIER_DESCRIPTOR;

//
// Local functions
//

BOOLEAN
AVrfpSnapDllImports (
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    );

BOOLEAN
AVrfpDetectVerifiedExports (
    PRTL_VERIFIER_DLL_DESCRIPTOR Dll,
    PRTL_VERIFIER_THUNK_DESCRIPTOR Thunks
    );

BOOLEAN
AVrfpParseVerifierDllsString (
    PWSTR Dlls
    );

VOID
AVrfpSnapAlreadyLoadedDlls (
    );

VOID
AVrfpMoveProviderToEndOfInitializationList (
    PWSTR ProviderName
    );

BOOLEAN
AVrfpLoadAndInitializeProvider (
    PAVRF_VERIFIER_DESCRIPTOR Provider
    );

BOOLEAN
AVrfpIsVerifierProviderDll (
    PVOID Handle
    );

VOID
AVrfpDumpProviderList (
    );

PVOID
AVrfpFindClosestThunkDuplicate (
    PAVRF_VERIFIER_DESCRIPTOR Verifier,
    PWCHAR DllName,
    PCHAR ThunkName
    );

VOID
AVrfpChainDuplicateVerificationLayers (
    );

VOID
AVrfpDllLoadNotificationInternal (
    PLDR_DATA_TABLE_ENTRY LoadedDllData
    );

PWSTR
AVrfpGetProcessName (
    );

BOOLEAN
AVrfpEnableVerifierOptions (
    );

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

VOID
AVrfInitializeVerifier (
    BOOLEAN EnabledSystemWide,
    PUNICODE_STRING ImageName,
    ULONG Phase
    )
/*++

Routine description:

    This routine initializes the verifier package. Reads options 
    from registry, loads verifier dlls, etc.

Parameters:

    EnabledSystemWide - true if all processes are supposed to run with
        application verifier enabled. If this is the case we will scale
        down our memory-demanding checks so that we can boot.

    ImageName - unicode name of the current process
    
    Phase - initialization happens in several stages. 
        0 - we read registry settings under image file execution options.
            in this phase the other two parameters have a meaning.
        1 - we parse the verifier dlls and load them.    
    
Return value:

    None.
            
--*/
{
    BOOLEAN Result;
    PLIST_ENTRY Entry;
    PAVRF_VERIFIER_DESCRIPTOR Provider;
    NTSTATUS Status;
    BOOLEAN LoadSuccess;

    switch (Phase) {
        
        case 0: // Phase 0

            AVrfpVerifierFlags = RTL_VRF_FLG_SYSTEM_WIDE_SETTINGS;
            AVrfpVerifierDllsString[0] = L'\0';

            //
            // Attempt to read verifier registry settings even if verifier
            // is enabled system wide. In the worst case no values are there 
            // and nothing will be read. If we have some options per process
            // this will override system wide settings.
            //

            LdrQueryImageFileExecutionOptions (ImageName,
                                               L"VerifierFlags",
                                               REG_DWORD,
                                               &AVrfpVerifierFlags,
                                               sizeof(AVrfpVerifierFlags),
                                               NULL);

            LdrQueryImageFileExecutionOptions (ImageName,
                                               L"VerifierDebug",
                                               REG_DWORD,
                                               &AVrfpDebug,
                                               sizeof(AVrfpDebug),
                                               NULL);

            LdrQueryImageFileExecutionOptions (ImageName,
                                               L"VerifierDlls",
                                               REG_SZ,
                                               AVrfpVerifierDllsString,
                                               512,
                                               NULL);

            AVrfpEnableVerifierOptions ();

            break;

        case 1: // Phase 1

            InitializeListHead (&AVrfpVerifierProvidersList);
            RtlInitializeCriticalSection (&AVrfpVerifierLock);

            DbgPrint ("AVRF: %ws: pid 0x%X: flags 0x%X: application verifier enabled\n",
                      AVrfpGetProcessName(),
                      HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess),
                      AVrfpVerifierFlags);

            Result = AVrfpParseVerifierDllsString (AVrfpVerifierDllsString);

            if (Result == FALSE) {
                
                DbgPrint ("AVRF: %ws: pid 0x%X: application verifier will be disabled due to an initialization error.\n",
                      AVrfpGetProcessName(),
                      HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess));

                NtCurrentPeb()->NtGlobalFlag &= ~FLG_APPLICATION_VERIFIER;
            }

            Entry = AVrfpVerifierProvidersList.Flink;

            while  (Entry != &AVrfpVerifierProvidersList) {

                Provider = CONTAINING_RECORD (Entry,
                                              AVRF_VERIFIER_DESCRIPTOR,
                                              List);

                //
                // Load provider, probe it to make sure it is really a
                // provider, call initialize routine with PROCESS_VERIFIER, etc.
                //

                LoadSuccess = AVrfpLoadAndInitializeProvider (Provider);

                //
                // Move to next provider
                //

                Entry = Provider->List.Flink;

                //
                // Get this provider out of the providers list if we
                // encountered an error while loading
                //

                if (! LoadSuccess) {

                    RemoveEntryList (&(Provider->List));

                    RtlFreeHeap (RtlProcessHeap(), 0, Provider);
                }
            }

            //
            // Chain duplicate verification functions.
            //

            AVrfpChainDuplicateVerificationLayers ();

            //
            // Enable verifier. Resnap already loaded dlls.
            // Now we will start processing dll load
            // notifications coming from loader.
            //

            AVrfpEnabled = TRUE; 

            AVrfpSnapAlreadyLoadedDlls ();

            if ((AVrfpDebug & AVRF_DBG_SHOW_PROVIDER_LOADS)) {

                DbgPrint ("AVRF: -*- final list of providers -*- \n");
                AVrfpDumpProviderList ();
            }

            break;

        default:

            break;
    }
}


BOOLEAN
AVrfpParseVerifierDllsString (
    PWSTR Dlls
    )
{
    PWSTR Current;
    PWSTR Start;
    WCHAR Save;
    PAVRF_VERIFIER_DESCRIPTOR Entry;

    //
    // Create by default an entry for the standard provider "verifier.dll"
    //

    Entry = RtlAllocateHeap (RtlProcessHeap (), 0, sizeof *Entry);

    if (Entry == NULL) {
        return FALSE;
    }

    RtlZeroMemory (Entry, sizeof *Entry);

    RtlInitUnicodeString (&(Entry->VerifierName), L"verifier.dll");

    InsertTailList (&AVrfpVerifierProvidersList, &(Entry->List));

    //
    // Parse the string
    //

    Current = Dlls;

    while (*Current != L'\0') {
        
        while (*Current == L' ' || *Current == L'\t') {
            Current += 1;
        }

        Start = Current;

        while (*Current && *Current != L' ' && *Current != L'\t') {
            Current += 1;
        }

        if (Start == Current) {
            break;
        }

        Save = *Current;
        *Current = L'\0';

        //
        // Check if standard provider was specified explicitely.
        // In this case we ignore it because we already have it 
        // in the list.
        //

        if (_wcsicmp (Start, L"verifier.dll") != 0) {
            
            Entry = RtlAllocateHeap (RtlProcessHeap (), 0, sizeof *Entry);

            if (Entry == NULL) {
                return FALSE;
            }

            RtlZeroMemory (Entry, sizeof *Entry);

            RtlInitUnicodeString (&(Entry->VerifierName), Start);

            InsertTailList (&AVrfpVerifierProvidersList, &(Entry->List));
        }

        // *Current = Save;
        Current += 1;
    }   

    return TRUE;
}


VOID
AVrfpSnapAlreadyLoadedDlls (
    )
{
    PPEB_LDR_DATA Ldr;
    PLIST_ENTRY Head;
    PLIST_ENTRY Next;
    PLDR_DATA_TABLE_ENTRY Entry;

    Ldr = NtCurrentPeb()->Ldr;
    Head = &(Ldr->InLoadOrderModuleList);
    Next = Head->Flink;

    while (Next != Head) {

        Entry = CONTAINING_RECORD (Next, 
                                   LDR_DATA_TABLE_ENTRY, 
                                   InLoadOrderLinks);
        Next = Next->Flink;

        if (! AVrfpIsVerifierProviderDll (Entry->DllBase)) {

            if ((AVrfpDebug & AVRF_DBG_SHOW_SNAPS)) {
                DbgPrint ("AVRF: resnapping %ws ... \n", Entry->BaseDllName.Buffer);
            }

            AVrfpDllLoadNotificationInternal (Entry);
        }
        else {

            if ((AVrfpDebug & AVRF_DBG_SHOW_SNAPS)) {
                DbgPrint ("AVRF: skipped resnapping provider %ws ... \n", Entry->BaseDllName.Buffer);
            }
        }
    }
}


VOID
AVrfpMoveProviderToEndOfInitializationList (
    PWSTR ProviderName
    )
{
    PPEB_LDR_DATA Ldr;
    PLIST_ENTRY Head;
    PLIST_ENTRY Next;
    PLDR_DATA_TABLE_ENTRY Entry;
    BOOLEAN Done = FALSE;

    Ldr = NtCurrentPeb()->Ldr;
    Head = &(Ldr->InInitializationOrderModuleList);
    Next = Head->Flink;

    while (Next != Head) {

        Entry = CONTAINING_RECORD (Next, 
                                   LDR_DATA_TABLE_ENTRY, 
                                   InInitializationOrderLinks);
        
        if (_wcsicmp (Entry->BaseDllName.Buffer, ProviderName) == 0) {

            RemoveEntryList (Next);
            InsertTailList (Head, Next);
            Done = TRUE;
            break;
        }

        Next = Next->Flink;
    }

    if (! Done) {
        DbgPrint ("AVRF: provider %ws was not found in the initialization list \n",
                  ProviderName);

        DbgBreakPoint ();
    }
}


BOOLEAN
AVrfpLoadAndInitializeProvider (
    PAVRF_VERIFIER_DESCRIPTOR Provider
    )
{
    PIMAGE_NT_HEADERS NtHeaders;
    BOOLEAN LoadError = FALSE;
    NTSTATUS Status;
    ULONG_PTR Descriptor;
    PRTL_VERIFIER_PROVIDER_DESCRIPTOR Dscr;
    BOOLEAN InitStatus;
    static WCHAR SystemDllPathBuffer[DOS_MAX_PATH_LENGTH];
    UNICODE_STRING SystemDllPath;

    if ((AVrfpDebug & AVRF_DBG_SHOW_SNAPS)) {
        DbgPrint ("AVRF: verifier dll `%ws' \n", 
                  Provider->VerifierName.Buffer);
    }

    //
    // Prepare the system search path (%windir%\system32).
    // Verifier providers can be loaded only from this directory.
    //

    SystemDllPath.Buffer = SystemDllPathBuffer;
    SystemDllPath.Length = 0;
    SystemDllPath.MaximumLength = sizeof(SystemDllPathBuffer);

    RtlAppendUnicodeToString (&SystemDllPath, USER_SHARED_DATA->NtSystemRoot);
    RtlAppendUnicodeToString (&SystemDllPath, L"\\System32\\");

    //
    // Load provider dll
    //

    Status = LdrLoadDll (SystemDllPath.Buffer,
                         NULL,
                         &(Provider->VerifierName),
                         &(Provider->VerifierHandle));

    if (! NT_SUCCESS(Status)) {

        DbgPrint ("AVRF: %ws: failed to load provider `%ws' (status %08X) from %ws\n", 
                  AVrfpGetProcessName(),
                  Provider->VerifierName.Buffer,
                  Status,
                  SystemDllPath.Buffer);

        LoadError = TRUE;
        goto Error;
    }
    
    //
    // Make sure we have a dll.
    //

    try {
        
        NtHeaders = RtlImageNtHeader (Provider->VerifierHandle);

        if (! NtHeaders) {

            LoadError = TRUE;
            goto Error;
        }

        if ((NtHeaders->FileHeader.Characteristics & IMAGE_FILE_DLL) == 0) {

            DbgPrint ("AVRF: provider %ws is not a DLL image \n",
                      Provider->VerifierName.Buffer);

            LoadError = TRUE;
            goto Error;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {

        DbgPrint ("AVRF: exception raised while probing provider %ws \n",
                  Provider->VerifierName.Buffer);

        LoadError = TRUE;
        goto Error;
    }

    //
    // We loaded the provider successfully. We will move it to the end
    // of the initialization list so that code from other system dlls
    // on which the provider relies gets initialized first. For normal
    // DLLs this is not an issue but a verifier provider gets loaded
    // before any normal DLL no matter what dependencies has.
    //

    AVrfpMoveProviderToEndOfInitializationList (Provider->VerifierName.Buffer);

    //
    // Now call the initialization routine with the special
    // PROCESS_VERIFIER reason.
    //

    Provider->VerifierEntryPoint = LdrpFetchAddressOfEntryPoint(Provider->VerifierHandle);

    if (Provider->VerifierEntryPoint == NULL) {

        DbgPrint ("AVRF: cannot find an entry point for provider %ws \n",
                  Provider->VerifierName.Buffer);
        
        LoadError = TRUE;
        goto Error;
    }
    
    try {

        Descriptor = 0;

        InitStatus = LdrpCallInitRoutine ((PDLL_INIT_ROUTINE)(Provider->VerifierEntryPoint),
                                          Provider->VerifierHandle,
                                          DLL_PROCESS_VERIFIER,
                                          (PCONTEXT)(&Descriptor));

        if (InitStatus && Descriptor) {

            Dscr = (PRTL_VERIFIER_PROVIDER_DESCRIPTOR)Descriptor;

            //
            // Check if this is really a provider descriptor.
            //

            if (Dscr->Length != sizeof (*Dscr)) {

                LoadError = TRUE;

                DbgPrint ("AVRF: provider %ws passed an invalid descriptor @ %p \n",
                          Provider->VerifierName.Buffer,
                          Descriptor);
            }
            else {

                if ((AVrfpDebug & AVRF_DBG_SHOW_PROVIDER_LOADS)) {

                    DbgPrint ("AVRF: initialized provider %ws (descriptor @ %p) \n",
                          Provider->VerifierName.Buffer,
                          Descriptor);
                }

                Provider->VerifierDlls = Dscr->ProviderDlls;
                Provider->VerifierLoadHandler = Dscr->ProviderDllLoadCallback;
                Provider->VerifierUnloadHandler = Dscr->ProviderDllUnloadCallback;

                //
                // Fill out the provider descriptor structure with goodies.
                //

                Dscr->VerifierImage = AVrfpGetProcessName();
                Dscr->VerifierFlags = AVrfpVerifierFlags;
                Dscr->VerifierDebug = AVrfpDebug;
            }
        }
        else {

            LoadError = TRUE;

            DbgPrint ("AVRF: provider %ws did not initialize correctly \n",
                      Provider->VerifierName.Buffer);
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {

        DbgPrint ("AVRF: exception raised in provider %ws initialization routine \n",
                  Provider->VerifierName.Buffer);
        
        LoadError = TRUE;
        goto Error;
    }

    Error:

    return !LoadError;
}


BOOLEAN
AVrfpIsVerifierProviderDll (
    PVOID Handle
    )
{
    PLIST_ENTRY Current;
    PAVRF_VERIFIER_DESCRIPTOR Entry;;

    Current = AVrfpVerifierProvidersList.Flink;

    while (Current != &AVrfpVerifierProvidersList) {

        Entry = CONTAINING_RECORD (Current,
                                   AVRF_VERIFIER_DESCRIPTOR,
                                   List);

        Current = Current->Flink;

        if (Entry->VerifierHandle == Handle) {
            return TRUE;
        }
    }

    return FALSE;
}


VOID
AVrfpDumpProviderList (
    )
{
    PLIST_ENTRY Current;
    PAVRF_VERIFIER_DESCRIPTOR Entry;

    Current = AVrfpVerifierProvidersList.Flink;

    while (Current != &AVrfpVerifierProvidersList) {

        Entry = CONTAINING_RECORD (Current,
                                   AVRF_VERIFIER_DESCRIPTOR,
                                   List);

        Current = Current->Flink;

        DbgPrint ("AVRF: provider %ws \n",
                  Entry->VerifierName.Buffer);
    }
}


PVOID
AVrfpFindClosestThunkDuplicate (
    PAVRF_VERIFIER_DESCRIPTOR Verifier,
    PWCHAR DllName,
    PCHAR ThunkName
    )
/*++

Routine description:

    This function searches the list of providers backwards (reverse load order)
    for a function that verifies original export ThunkName from DllName. This
    is necessary to implement chaining of verification layers.              

Parameters:

    Verifier -  verifier provider descriptor for which we want to find 
        duplicates.                                      
        
    DllName - name of a dll containing a verified export
    
    ThunkName - name of the verified export
    
Return value:

    Address of a verification function for the same thunk. Null if none
    was found.
            
--*/
{
    PLIST_ENTRY Current;
    PAVRF_VERIFIER_DESCRIPTOR Entry;
    PRTL_VERIFIER_DLL_DESCRIPTOR Dlls;
    PRTL_VERIFIER_THUNK_DESCRIPTOR Thunks;
    ULONG Di;
    ULONG Ti;

    Current = Verifier->List.Blink;

    while (Current != &AVrfpVerifierProvidersList) {

        Entry = CONTAINING_RECORD (Current,
                                   AVRF_VERIFIER_DESCRIPTOR,
                                   List);

        Current = Current->Blink;

        //
        // Search in this provider for the thunk.
        //

        if ((AVrfpDebug & AVRF_DBG_SHOW_CHAIN_DETAILS)) {
            DbgPrint ("AVRF: chain: searching in %ws\n", Entry->VerifierName.Buffer);
        }
        
        Dlls = Entry->VerifierDlls;

        for (Di = 0; Dlls[Di].DllName; Di += 1) {

            if ((AVrfpDebug & AVRF_DBG_SHOW_CHAIN_DETAILS)) {
                DbgPrint ("AVRF: chain: dll: %ws\n", Dlls[Di].DllName);
            }
            
            if (_wcsicmp(Dlls[Di].DllName, DllName) == 0) {

                Thunks = Dlls[Di].DllThunks;

                for (Ti = 0; Thunks[Ti].ThunkName; Ti += 1) {

                    if ((AVrfpDebug & AVRF_DBG_SHOW_CHAIN_DETAILS)) {
                        DbgPrint ("AVRF: chain: thunk: %s == %s ?\n", 
                                  Thunks[Ti].ThunkName,
                                  ThunkName);
                    }

                    if (_stricmp(Thunks[Ti].ThunkName, ThunkName) == 0) {
                        
                        if ((AVrfpDebug & AVRF_DBG_SHOW_CHAIN_DETAILS)) {

                            DbgPrint ("AVRF: Found duplicate for (%ws: %s) in %ws\n",
                                      DllName,
                                      ThunkName,
                                      Dlls[Di].DllName);
                        }

                        return Thunks[Ti].ThunkNewAddress;
                    }
                }
            }
        }
    }

    return NULL;
}


VOID
AVrfpChainDuplicateVerificationLayers (
    )
/*++

Routine description:

    This routines is called in the final stage of verifier initialization,
    after all provider dlls have been loaded, and makes a final sweep to
    detect providers that attempt to verify the same interface. This will be
    chained together so that they will be called in reverse load order 
    (last declared will be first called).
    
Parameters:

    None.            
    
Return value:

    None.            
    
--*/
{
    PLIST_ENTRY Current;
    PAVRF_VERIFIER_DESCRIPTOR Entry;
    PRTL_VERIFIER_DLL_DESCRIPTOR Dlls;
    PRTL_VERIFIER_THUNK_DESCRIPTOR Thunks;
    ULONG Di;
    ULONG Ti;
    PVOID Duplicate;

    Current = AVrfpVerifierProvidersList.Flink;

    while (Current != &AVrfpVerifierProvidersList) {

        Entry = CONTAINING_RECORD (Current,
                                   AVRF_VERIFIER_DESCRIPTOR,
                                   List);

        Current = Current->Flink;

        //
        // Search in this provider for duplicate thunks.
        //

        Dlls = Entry->VerifierDlls;

        for (Di = 0; Dlls[Di].DllName; Di += 1) {

            Thunks = Dlls[Di].DllThunks;

            for (Ti = 0; Thunks[Ti].ThunkName; Ti += 1) {

                if ((AVrfpDebug & AVRF_DBG_SHOW_CHAIN_DETAILS)) {

                    DbgPrint ("AVRF: Checking %ws for duplicate (%ws: %s) \n",
                              Entry->VerifierName.Buffer,
                              Dlls[Di].DllName,
                              Thunks[Ti].ThunkName);
                }

                Duplicate = AVrfpFindClosestThunkDuplicate (Entry,
                                                            Dlls[Di].DllName,
                                                            Thunks[Ti].ThunkName);

                if (Duplicate) {

                    if ((AVrfpDebug & AVRF_DBG_SHOW_CHAIN_ACTIVITY)) {

                        DbgPrint ("AVRF: Chaining (%ws: %s) to %ws\n",
                                  Dlls[Di].DllName,
                                  Thunks[Ti].ThunkName,
                                  Entry->VerifierName.Buffer);
                    }
                    
                    Thunks[Ti].ThunkOldAddress = Duplicate;
                }
            }
        }
    }
}


VOID
AVrfDllLoadNotification (
    PLDR_DATA_TABLE_ENTRY LoadedDllData
    )
/*++

Routine description:

    This routine is the DLL load hook of application verifier. It gets called
    whenever a dll got loaded in the process space and after its import
    descriptors have been walked.

Parameters:

    LoadedDllData - LDR loader structure for the dll.
    
Return value:

    None.
            
--*/
{
    ULONG Index;
    PLIST_ENTRY Current;
    PAVRF_VERIFIER_DESCRIPTOR Entry;

    //
    // Do nothing if application verifier is not enabled. The function
    // should not even get called if the flag is not set but we
    // double check just in case.
    //

    if ((NtCurrentPeb()->NtGlobalFlag & FLG_APPLICATION_VERIFIER) == 0) {
        return;
    }
    
    //
    // Get verifier global lock.
    //

    VERIFIER_LOCK ();

    //
    // We skip verifier providers. Otherwise we get into infinite loops.
    //

    if (AVrfpIsVerifierProviderDll (LoadedDllData->DllBase)) {

        VERIFIER_UNLOCK ();
        return;
    }

    //
    // Call internal function.
    //

    AVrfpDllLoadNotificationInternal (LoadedDllData);

    //
    // Iterate the verifier provider list and notify each one of the
    // load event.

    Current = AVrfpVerifierProvidersList.Flink;

    while (Current != &AVrfpVerifierProvidersList) {

        Entry = CONTAINING_RECORD (Current,
                                   AVRF_VERIFIER_DESCRIPTOR,
                                   List);

        Current = Current->Flink;

        if (Entry->VerifierLoadHandler) {

            Entry->VerifierLoadHandler (LoadedDllData->BaseDllName.Buffer,
                                        LoadedDllData->DllBase,
                                        LoadedDllData->SizeOfImage,
                                        LoadedDllData);
        }
    }
    
    VERIFIER_UNLOCK ();
}


VOID
AVrfpDllLoadNotificationInternal (
    PLDR_DATA_TABLE_ENTRY LoadedDllData
    )
/*++

Routine description:

    This routine is the DLL load hook of application verifier. It gets called
    whenever a dll got loaded in the process space and after its import
    descriptors have been walked. It is also called internally in early stages 
    of process initialization when we just loaded verifier providers and
    we need to resnap dlls already loaded (.exe, ntdll.dll (although on
    ntdll this will have zero effect because it does not import anything)). 

Parameters:

    LoadedDllData - LDR loader structure for the dll.
    
Return value:

    None.
            
--*/
{
    ULONG Index;
    PLIST_ENTRY Current;
    PAVRF_VERIFIER_DESCRIPTOR Entry;;

    //
    // If verifier is disabled skip.
    //

    if (AVrfpEnabled == FALSE) {
        return;
    }
    
    //
    // Iterate the verifier provider list and for each one determine
    // if one of the dlls that has exports to be verified is loaded.
    // If this is the case we need to look at its export table in order
    // to find out real addresses for functions being redirected.
    //

    Current = AVrfpVerifierProvidersList.Flink;

    while (Current != &AVrfpVerifierProvidersList) {

        PRTL_VERIFIER_DLL_DESCRIPTOR Dlls;
        PRTL_VERIFIER_THUNK_DESCRIPTOR Thunks;

        Entry = CONTAINING_RECORD (Current,
                                   AVRF_VERIFIER_DESCRIPTOR,
                                   List);

        Current = Current->Flink;

        Dlls = Entry->VerifierDlls;

        for (Index = 0; Dlls[Index].DllName; Index += 1) {

            if ((Dlls[Index].DllFlags & AVRF_FLG_EXPORT_DLL_LOADED) == 0) {

                int CompareResult;

                CompareResult = _wcsicmp (LoadedDllData->BaseDllName.Buffer,
                                          Dlls[Index].DllName);

                if (CompareResult == 0) {

                    if ((AVrfpDebug & AVRF_DBG_SHOW_DLLS_WITH_EXPORTS)) {
                        DbgPrint ("AVRF: pid 0x%X: found dll descriptor for `%ws' with verified exports \n", 
                                  HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess),
                                  LoadedDllData->BaseDllName.Buffer);
                    }

                    AVrfpDetectVerifiedExports (&(Dlls[Index]),
                                                Dlls[Index].DllThunks);
                }
            }
        }
    }

    //
    // Note. We do not have to snap other DLLs already loaded because they cannot
    // possibly have a dependence on a verifier export just discovered in
    // current DLL. If this had been the case, the DLL would have been loaded
    // earlier (before the current one).
    //

    AVrfpSnapDllImports (LoadedDllData);
}


VOID
AVrfDllUnloadNotification (
    PLDR_DATA_TABLE_ENTRY DllData
    )
/*++

Routine description:

    This routine is the DLL unload hook of application verifier. 
    It gets called whenever a dll gets unloaded from the process space.
    The hook is called after the DllMain routine of the DLL got called
    with PROCESS_DETACH therefore this is the right moment to check for 
    leaks.
    
    The function will call DllUnload notification routines for all providers
    loaded into the process space.

Parameters:

    LoadedDllData - LDR loader structure for the dll.
    
Return value:

    None.
            
--*/
{
    ULONG Index;
    PLIST_ENTRY Current;
    PAVRF_VERIFIER_DESCRIPTOR Entry;;

    //
    // Do nothing if application verifier is not enabled. The function
    // should not even get called if the flag is not set but we
    // double check just in case.
    //

    if ((NtCurrentPeb()->NtGlobalFlag & FLG_APPLICATION_VERIFIER) == 0) {
        return;
    }

    //
    // If verifier is disabled skip.
    //

    if (AVrfpEnabled == FALSE) {
        return;
    }
    
    //
    // Get verifier global lock.
    //

    VERIFIER_LOCK ();

    //
    // We should never get this call for a verifier provider DLL because
    // these are never unloaded.
    //

    if (AVrfpIsVerifierProviderDll (DllData->DllBase)) {

        DbgPrint ("AVrfDllUnloadNotification called for a provider (%p) \n", DllData);
        DbgBreakPoint ();
        VERIFIER_UNLOCK ();
        return;
    }

    //
    // Iterate the verifier provider list and notify each one of the
    // unload event.

    Current = AVrfpVerifierProvidersList.Flink;

    while (Current != &AVrfpVerifierProvidersList) {

        Entry = CONTAINING_RECORD (Current,
                                   AVRF_VERIFIER_DESCRIPTOR,
                                   List);

        Current = Current->Flink;

        if (Entry->VerifierUnloadHandler) {

            Entry->VerifierUnloadHandler (DllData->BaseDllName.Buffer,
                                          DllData->DllBase,
                                          DllData->SizeOfImage,
                                          DllData);
        }
    }
    
    VERIFIER_UNLOCK ();
}


BOOLEAN
AVrfpSnapDllImports (
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry
    )
/*++

Routine description:

    This routine walks the already resolved import tables of a loaded
    dll and modifies the addresses of all functions that need to be
    verifier. The dll has just been loaded, imports resolved but dll
    main function has not been called.
    
Parameters:

    LdrDataTableEntry - loader descriptor for a loaded dll
    
Return value:

    True if we checked all imports of the dll and modified the ones
    that need to be verified. False if an error was encountered along
    the way.
            
--*/
{
    PVOID IATBase;
    SIZE_T BigIATSize;
    ULONG  LittleIATSize;
    PVOID *ProcAddresses;
    ULONG NumberOfProcAddresses;
    ULONG OldProtect;
    USHORT TagIndex;
    NTSTATUS st;
    ULONG Pi; // procedure index
    ULONG Di; // dll index
    ULONG Ti; // thunk index
    PLIST_ENTRY Current;
    PAVRF_VERIFIER_DESCRIPTOR Entry;
    PRTL_VERIFIER_DLL_DESCRIPTOR Dlls;
    PRTL_VERIFIER_THUNK_DESCRIPTOR Thunks;

    //
    // Determine the location and size of the IAT.  If found, scan the
    // IAT address to see if any are pointing to functions that should be
    // verified and replace those thunks.
    //

    IATBase = RtlImageDirectoryEntryToData (LdrDataTableEntry->DllBase,
                                            TRUE,
                                            IMAGE_DIRECTORY_ENTRY_IAT,
                                            &LittleIATSize);

    if (IATBase == NULL) {
        return FALSE;
    }
    
    BigIATSize = LittleIATSize;

    //
    // Make table read/write.
    //

    st = NtProtectVirtualMemory (NtCurrentProcess(),
                                 &IATBase,
                                 &BigIATSize,
                                 PAGE_READWRITE,
                                 &OldProtect);

    if (!NT_SUCCESS (st)) {

        DbgPrint( "AVRF: Unable to unprotect IAT to modify thunks (status %08X).\n", st);
        return FALSE;
    }

    ProcAddresses = (PVOID *)IATBase;
    NumberOfProcAddresses = (ULONG)(BigIATSize / sizeof(PVOID));

    for (Pi = 0; Pi < NumberOfProcAddresses; Pi += 1) {
        
        //
        // If we find a null in the import table we skip over it.
        //

        if (*ProcAddresses == NULL) {
            ProcAddresses += 1;
            continue;
        }

        Current = AVrfpVerifierProvidersList.Flink;

        while (Current != &AVrfpVerifierProvidersList) {

            Entry = CONTAINING_RECORD (Current,
                                       AVRF_VERIFIER_DESCRIPTOR,
                                       List);

            Current = Current->Flink;

            Dlls = Entry->VerifierDlls;
            
            for (Di = 0; Dlls[Di].DllName; Di += 1) {

                Thunks = Dlls[Di].DllThunks;

                for (Ti = 0; Thunks[Ti].ThunkName; Ti += 1) {

                    if (*ProcAddresses == Thunks[Ti].ThunkOldAddress) {

                        if (Thunks[Ti].ThunkNewAddress) {

                            *ProcAddresses = Thunks[Ti].ThunkNewAddress;
                        }
                        else {

                            DbgPrint ("AVRF:SilviuC: New thunk for %s is null. \n",
                                      Thunks[Ti].ThunkName);
                            DbgBreakPoint ();
                        }

                        if ((AVrfpDebug & AVRF_DBG_SHOW_SNAPS)) {

                            DbgPrint ("AVRF: Snapped (%ws: %s) with (%ws: %p). \n",
                                      LdrDataTableEntry->BaseDllName.Buffer,
                                      Thunks[Ti].ThunkName,
                                      Entry->VerifierName.Buffer,
                                      Thunks[Ti].ThunkNewAddress);
                        }
                    }
                }
            }
        }

        ProcAddresses += 1;
    }

    //
    // Restore old protection for the table.
    //

    NtProtectVirtualMemory (NtCurrentProcess(),
                            &IATBase,
                            &BigIATSize,
                            OldProtect,
                            &OldProtect);

    return TRUE;
}


BOOLEAN
AVrfpDetectVerifiedExports (
    PRTL_VERIFIER_DLL_DESCRIPTOR Dll,
    PRTL_VERIFIER_THUNK_DESCRIPTOR Thunks
    )
/*++

Routine description:

    This routine checks if `DllString' is the name of a dll that has
    exports that need to be verifier. If it does then we detect the
    addresses of all those exports. We need the addresses to detect
    what imports need to be modified by application verifier.
    
Parameters:

    DlString - name of a dll exporting verified interfaces.
    
    Thunks - array of thunk descriptors for our dll    
    
Return value:

    True if verified exports have been detected. False if an error has been
    encountered.
        
--*/
{
    UNICODE_STRING DllName;
    PLDR_DATA_TABLE_ENTRY DllData;
    PIMAGE_EXPORT_DIRECTORY Directory;
    ULONG Size;
    PCHAR NameAddress;
    PCHAR FunctionAddress;
    PCHAR Base;
    PCHAR IndexAddress;
    ULONG Index;
    ULONG RealIndex;
    BOOLEAN Result = FALSE;
    NTSTATUS Status;
    WCHAR StaticRedirectionBuffer[DOS_MAX_PATH_LENGTH];
    UNICODE_STRING StaticRedirectionString;
    UNICODE_STRING DynamicRedirectionString;
    PUNICODE_STRING DllNameToUse;
    BOOLEAN Redirected = FALSE;
    ULONG Fi, Ti;

    //
    // "Fusion-ize" the dll name. 
    //

    RtlInitUnicodeString (&DllName,
                          Dll->DllName);

    DynamicRedirectionString.Buffer = NULL;

    StaticRedirectionString.Length = 0;
    StaticRedirectionString.MaximumLength = sizeof(StaticRedirectionBuffer);
    StaticRedirectionString.Buffer = StaticRedirectionBuffer;

    DllNameToUse = &DllName;

    Status = RtlDosApplyFileIsolationRedirection_Ustr(
            RTL_DOS_APPLY_FILE_REDIRECTION_USTR_FLAG_RESPECT_DOT_LOCAL,
            &DllName,
            &DefaultExtension,
            &StaticRedirectionString,
            &DynamicRedirectionString,
            &DllNameToUse,
            NULL,
            NULL,
            NULL);

    if (NT_SUCCESS(Status)) {
        Redirected = TRUE;
    } else if (Status == STATUS_SXS_KEY_NOT_FOUND) {
        Status = STATUS_SUCCESS;
    }

    //
    // Get the loader descriptor for this dll.
    //

    if (NT_SUCCESS(Status)) {

        Result = LdrpCheckForLoadedDll (NULL,
                                        DllNameToUse,
                                        TRUE,
                                        Redirected,
                                        &DllData);

        if (DynamicRedirectionString.Buffer != NULL)
            RtlFreeUnicodeString(&DynamicRedirectionString);
    }

    if (Result == FALSE) {

        //
        // We exit of we failed to fusionize name or did not find
        // the dll among the loaded ones.
        //

        return FALSE;
    }

    //
    // Get the export directory for the dll.
    //

    Base = DllData->DllBase;

    Directory = RtlImageDirectoryEntryToData (DllData->DllBase,
                                              TRUE,
                                              IMAGE_DIRECTORY_ENTRY_EXPORT,
                                              &Size);

    if (Directory == NULL) {
        return FALSE;
    }

    //
    // Iterate the exports for the dll and replace all those that
    // need to be verified.
    //

    for (Ti = 0; Thunks[Ti].ThunkName; Ti += 1) {
        
        //
        // If old thunk already filled (can happen due to chaining)
        // then skip search for the original address.
        //

        if (Thunks[Ti].ThunkOldAddress) {
            continue;
        }

        for (Fi = 0; Fi < Directory->NumberOfFunctions; Fi += 1) {
            
            NameAddress = Base + Directory->AddressOfNames;
            NameAddress = Base + ((ULONG *)NameAddress)[Fi];

            IndexAddress = Base + Directory->AddressOfNameOrdinals;
            RealIndex = (ULONG)(((USHORT *)IndexAddress)[Fi]);

            if (_stricmp (NameAddress, Thunks[Ti].ThunkName) == 0) {

                FunctionAddress = Base + Directory->AddressOfFunctions;
                FunctionAddress = Base + ((ULONG *)FunctionAddress)[RealIndex];

                Thunks[Ti].ThunkOldAddress = FunctionAddress;

                if ((AVrfpDebug & AVRF_DBG_SHOW_VERIFIED_EXPORTS)) {
                    DbgPrint ("AVRF: found verified export %s @ %p \n", 
                              NameAddress, FunctionAddress);
                }
            }
        }
    }

    Dll->DllFlags |= AVRF_FLG_EXPORT_DLL_LOADED;

    return TRUE;
}


PWSTR
AVrfpGetProcessName (
    )
{
    PPEB_LDR_DATA Ldr;
    PLIST_ENTRY Head;
    PLIST_ENTRY Next;
    PLDR_DATA_TABLE_ENTRY Entry;

    Ldr = NtCurrentPeb()->Ldr;
    Head = &(Ldr->InLoadOrderModuleList);
    Next = Head->Flink;

    Entry = CONTAINING_RECORD (Next, 
                               LDR_DATA_TABLE_ENTRY, 
                               InLoadOrderLinks);

    return Entry->BaseDllName.Buffer;
}


/////////////////////////////////////////////////////////////////////
///////////////////////////////////// Verifier options initialization
/////////////////////////////////////////////////////////////////////

BOOLEAN
AVrfpEnableHandleVerifier (
    )
{
    PROCESS_HANDLE_TRACING_ENABLE HandleCheckEnable;
    NTSTATUS Status;

    RtlZeroMemory (&HandleCheckEnable, sizeof HandleCheckEnable);

    Status = NtSetInformationProcess (NtCurrentProcess(),
                                      ProcessHandleTracing,
                                      &HandleCheckEnable,
                                      sizeof HandleCheckEnable);

    if (!NT_SUCCESS (Status)) {

        DbgPrint ("AVRF: failed to enable handle checking (status %X) \n", 
                  Status);

        return FALSE;
    }

    return TRUE;
}

BOOLEAN
AVrfpEnableStackVerifier (
    )
{
    NtCurrentPeb()->NtGlobalFlag |= FLG_DISABLE_STACK_EXTENSION;
    return TRUE;
}

BOOLEAN
AVrfpEnableLockVerifier (
    )
{
    RtlpCriticalSectionVerifier = TRUE;
    return TRUE;
}

BOOLEAN
AVrfpEnableHeapVerifier (
    )
{
    extern ULONG RtlpDphGlobalFlags;

    NtCurrentPeb()->NtGlobalFlag |= FLG_HEAP_PAGE_ALLOCS;

    if (AVrfpVerifierFlags & RTL_VRF_FLG_FULL_PAGE_HEAP) {
    
        RtlpDphGlobalFlags |= PAGE_HEAP_ENABLE_PAGE_HEAP;
    }
    else {

        //
        // Nothing. Light heap is the default.
        //
    }

    return TRUE;
}

BOOLEAN
AVrfpEnableVerifierOptions (
    )
{
    BOOLEAN Result;
    BOOLEAN Failures = FALSE;

    //
    // Heap verifier in some form is enabled always.
    //

    Result = AVrfpEnableHeapVerifier ();

    if (Result == FALSE) {
        Failures = TRUE;
    }

    //
    // Handle checks
    //

    if (AVrfpVerifierFlags & RTL_VRF_FLG_HANDLE_CHECKS) {

        Result = AVrfpEnableHandleVerifier ();

        if (Result == FALSE) {
            Failures = TRUE;
        }
    }

    //
    // Stack overflow checks
    //

    if (AVrfpVerifierFlags & RTL_VRF_FLG_STACK_CHECKS) {

        Result = AVrfpEnableStackVerifier ();

        if (Result == FALSE) {
            Failures = TRUE;
        }
    }

    //
    // Lock checks
    //

    if (AVrfpVerifierFlags & RTL_VRF_FLG_LOCK_CHECKS) {

        Result = AVrfpEnableLockVerifier ();

        if (Result == FALSE) {
            Failures = TRUE;
        }
    }

    return !Failures;
}

/////////////////////////////////////////////////////////////////////
////////////////////////////////////////// Application verifier stops
/////////////////////////////////////////////////////////////////////

ULONG_PTR AVrfpPreviousStopData[5];
ULONG_PTR AVrfpStopData[5];

VOID
RtlApplicationVerifierStop (
    ULONG_PTR Code,
    PCHAR Message,
    ULONG_PTR Param1, PCHAR Description1,
    ULONG_PTR Param2, PCHAR Description2,
    ULONG_PTR Param3, PCHAR Description3,
    ULONG_PTR Param4, PCHAR Description4
    )
{
    BOOLEAN DoNotBreak = FALSE;

    if ((Code & APPLICATION_VERIFIER_NO_BREAK)) {

        DoNotBreak = TRUE;
        Code &= ~APPLICATION_VERIFIER_NO_BREAK;
    }
    
    //
    // Make it easy for a debugger to pick up the failure info.
    //

    RtlMoveMemory (AVrfpPreviousStopData, 
                   AVrfpStopData, 
                   sizeof AVrfpStopData);

    AVrfpStopData[0] = Code;
    AVrfpStopData[1] = Param1;
    AVrfpStopData[2] = Param2;
    AVrfpStopData[3] = Param3;
    AVrfpStopData[4] = Param4;

    //
    // Internal warnings/errors will not cause a break if app verifier is on.
    // SilviuC: should make sure we really need this.
    //

    if ((Code & APPLICATION_VERIFIER_INTERNAL_ERROR)) {
        
        if (! (NtCurrentPeb()->NtGlobalFlag & FLG_APPLICATION_VERIFIER)) {

            DbgPrint ("\n\n===========================================================\n");
            DbgPrint ("VERIFIER INTERNAL ERROR %p: pid 0x%X: %s \n"
                      "\n\t%p : %s\n\t%p : %s\n\t%p : %s\n\t%p : %s\n",
                      Code, HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess), Message,
                      Param1, Description1, 
                      Param2, Description2, 
                      Param3, Description3, 
                      Param4, Description4);
            DbgPrint ("===========================================================\n\n");
            DbgBreakPoint ();
        }
    }
    else if ((Code & APPLICATION_VERIFIER_INTERNAL_WARNING)) {
        
        if (! (NtCurrentPeb()->NtGlobalFlag & FLG_APPLICATION_VERIFIER)) {
            
            DbgPrint ("\n\n===========================================================\n");
            DbgPrint ("VERIFIER INTERNAL WARNING %p: pid 0x%X: %s \n"
                      "\n\t%p : %s\n\t%p : %s\n\t%p : %s\n\t%p : %s\n",
                      Code, HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess), Message,
                      Param1, Description1, 
                      Param2, Description2, 
                      Param3, Description3, 
                      Param4, Description4);
            DbgPrint ("===========================================================\n\n");
            DbgBreakPoint ();
        }
    }
    else {
        
        DbgPrint ("\n\n===========================================================\n");
        DbgPrint ("VERIFIER STOP %p: pid 0x%X: %s \n"
                  "\n\t%p : %s\n\t%p : %s\n\t%p : %s\n\t%p : %s\n",
                  Code, HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess), Message,
                  Param1, Description1, 
                  Param2, Description2, 
                  Param3, Description3, 
                  Param4, Description4);
        DbgPrint ("===========================================================\n\n");

        if (! DoNotBreak) {
            DbgBreakPoint ();
        }
    }
}


/////////////////////////////////////////////////////////////////////
////////////////////////////////////////// Page heap target dll logic
/////////////////////////////////////////////////////////////////////

//
// ISSUE: SilviuC: pageheap per dll code should move into verifier.dll
//

BOOLEAN AVrfpDphKernel32Snapped;
BOOLEAN AVrfpDphMsvcrtSnapped;

#define SNAP_ROUTINE_GLOBALALLOC     0
#define SNAP_ROUTINE_GLOBALREALLOC   1
#define SNAP_ROUTINE_GLOBALFREE      2
#define SNAP_ROUTINE_LOCALALLOC      3
#define SNAP_ROUTINE_LOCALREALLOC    4
#define SNAP_ROUTINE_LOCALFREE       5
#define SNAP_ROUTINE_HEAPALLOC       6
#define SNAP_ROUTINE_HEAPREALLOC     7
#define SNAP_ROUTINE_HEAPFREE        8
#define SNAP_ROUTINE_HEAPCREATE      9
#define SNAP_ROUTINE_MALLOC          10
#define SNAP_ROUTINE_CALLOC          11
#define SNAP_ROUTINE_REALLOC         12
#define SNAP_ROUTINE_FREE            13
#define SNAP_ROUTINE_NEW             14
#define SNAP_ROUTINE_DELETE          15
#define SNAP_ROUTINE_NEW_ARRAY       16
#define SNAP_ROUTINE_DELETE_ARRAY    17
#define SNAP_ROUTINE_MAX_INDEX       18

PVOID AVrfpDphSnapRoutines [SNAP_ROUTINE_MAX_INDEX];

typedef struct _DPH_SNAP_NAME {

    PSTR Name;
    ULONG Index;

} DPH_SNAP_NAME, * PDPH_SNAP_NAME;

DPH_SNAP_NAME
AVrfpDphSnapNamesForKernel32 [] = {

    { "GlobalAlloc",   0 },
    { "GlobalReAlloc", 1 },
    { "GlobalFree",    2 },
    { "LocalAlloc",    3 },
    { "LocalReAlloc",  4 },
    { "LocalFree",     5 },
    { "HeapAlloc",     6 },
    { "HeapReAlloc",   7 },
    { "HeapFree",      8 },
    { "HeapCreate",    9 },
    { NULL, 0 }
};

DPH_SNAP_NAME
AVrfpDphSnapNamesForMsvcrt [] = {

    { "malloc",        10},
    { "calloc",        11},
    { "realloc",       12},
    { "free",          13},
    { "??2@YAPAXI@Z",  14}, // operator new
    { "??3@YAXPAX@Z",  15}, // operator delete
    { "??_U@YAPAXI@Z", 16}, // operator new[]
    { "??_V@YAXPAX@Z", 17}, // operator delete[]
    { NULL, 0 }
};

//
// Declarations for replacement functions
//

PVOID
AVrfpDphDllHeapAlloc (
    IN PVOID  HeapHandle,
    IN ULONG  Flags,
    IN SIZE_T Size
    );

PVOID
AVrfpDphDllHeapReAlloc (
    IN PVOID  HeapHandle,
    IN ULONG  Flags,
    IN PVOID Address,
    IN SIZE_T Size
    );

BOOLEAN
AVrfpDphDllHeapFree(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

PVOID
AVrfpDphDllLocalAlloc (
    IN ULONG  Flags,
    IN SIZE_T Size
    );

PVOID
AVrfpDphDllLocalReAlloc (
    IN PVOID Address,
    IN SIZE_T Size,
    IN ULONG  Flags
    );

PVOID
AVrfpDphDllLocalFree(
    IN PVOID Address
    );

PVOID
AVrfpDphDllGlobalAlloc (
    IN ULONG  Flags,
    IN SIZE_T Size
    );

PVOID
AVrfpDphDllGlobalReAlloc (
    IN PVOID Address,
    IN SIZE_T Size,
    IN ULONG  Flags
    );

PVOID
AVrfpDphDllGlobalFree(
    IN PVOID Address
    );

PVOID __cdecl
AVrfpDphDllmalloc (
    IN SIZE_T Size
    );

PVOID __cdecl
AVrfpDphDllcalloc (
    IN SIZE_T Number,
    IN SIZE_T Size
    );

PVOID __cdecl
AVrfpDphDllrealloc (
    IN PVOID Address,
    IN SIZE_T Size
    );

VOID __cdecl
AVrfpDphDllfree (
    IN PVOID Address
    );

PVOID __cdecl
AVrfpDphDllNew (
    IN SIZE_T Size
    );

VOID __cdecl
AVrfpDphDllDelete (
    IN PVOID Address
    );

PVOID __cdecl
AVrfpDphDllNewArray (
    IN SIZE_T Size
    );

VOID __cdecl
AVrfpDphDllDeleteArray (
    IN PVOID Address
    );

//
// Replacement function for msvcrt HeapCreate used to intercept
// the CRT heap creation.
//

PVOID
AVrfpDphDllHeapCreate (
    ULONG Options,
    SIZE_T InitialSize,
    SIZE_T MaximumSize
    );

//
// Address of heap created by msvcrt. This is needed
// by the replacements of malloc/free etc.
//

PVOID AVrfpDphMsvcrtHeap;

//
// Snap implementation
//

BOOLEAN
AVrfpDphDetectSnapRoutines (
    PWSTR DllString,
    PDPH_SNAP_NAME SnapNames
    )
{
    PLDR_DATA_TABLE_ENTRY DllData;
    PIMAGE_EXPORT_DIRECTORY Directory;
    ULONG Size;
    PCHAR NameAddress;
    PCHAR FunctionAddress;
    PCHAR Base;
    PCHAR IndexAddress;
    ULONG Index;
    ULONG RealIndex;
    BOOLEAN Result = FALSE;
    UNICODE_STRING DllName;
    PDPH_SNAP_NAME CurrentSnapName;
    NTSTATUS Status;
    WCHAR StaticRedirectionBuffer[DOS_MAX_PATH_LENGTH];
    UNICODE_STRING StaticRedirectionString;
    UNICODE_STRING DynamicRedirectionString;
    PUNICODE_STRING DllNameToUse;
    BOOLEAN Redirected = FALSE;

    RtlInitUnicodeString (
        &DllName,
        DllString);

    DynamicRedirectionString.Buffer = NULL;

    StaticRedirectionString.Length = 0;
    StaticRedirectionString.MaximumLength = sizeof(StaticRedirectionBuffer);
    StaticRedirectionString.Buffer = StaticRedirectionBuffer;

    DllNameToUse = &DllName;

    Status = RtlDosApplyFileIsolationRedirection_Ustr(
            RTL_DOS_APPLY_FILE_REDIRECTION_USTR_FLAG_RESPECT_DOT_LOCAL,
            &DllName,
            &DefaultExtension,
            &StaticRedirectionString,
            &DynamicRedirectionString,
            &DllNameToUse,
            NULL,
            NULL,
            NULL);
    if (NT_SUCCESS(Status)) {
        Redirected = TRUE;
    } else if (Status == STATUS_SXS_KEY_NOT_FOUND) {
        Status = STATUS_SUCCESS;
    }

    if (NT_SUCCESS(Status)) {
        Result = LdrpCheckForLoadedDll (
            NULL,
            DllNameToUse,
            TRUE,
            Redirected,
            &DllData);

        if (DynamicRedirectionString.Buffer != NULL)
            RtlFreeUnicodeString(&DynamicRedirectionString);
    }

    if (Result == FALSE) {
        return FALSE;
    }

    Base = DllData->DllBase;

    Directory = RtlImageDirectoryEntryToData (
        DllData->DllBase,
        TRUE,
        IMAGE_DIRECTORY_ENTRY_EXPORT,
        &Size
        );

    if (Directory == NULL) {
        return FALSE;
    }

    for (CurrentSnapName = SnapNames; CurrentSnapName->Name; CurrentSnapName += 1) {

        for (Index = 0; Index < Directory->NumberOfFunctions; Index += 1) {

            NameAddress = Base + Directory->AddressOfNames;
            NameAddress = Base + ((ULONG *)NameAddress)[Index];

            IndexAddress = Base + Directory->AddressOfNameOrdinals;
            RealIndex = (ULONG)(((USHORT *)IndexAddress)[Index]);

            if (_stricmp (NameAddress, CurrentSnapName->Name) == 0) {

                FunctionAddress = Base + Directory->AddressOfFunctions;
                FunctionAddress = Base + ((ULONG *)FunctionAddress)[RealIndex];

                AVrfpDphSnapRoutines[CurrentSnapName->Index] = FunctionAddress;
                DbgPrint ("Page heap: found %s @ address %p \n", NameAddress, FunctionAddress);
            }
        }
    }

    return TRUE;
}

BOOLEAN
AVrfpDphSnapImports (
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry,
    BOOLEAN CallToDetectCrtHeap
    )
{
    PVOID IATBase;
    SIZE_T BigIATSize;
    ULONG  LittleIATSize;
    PVOID *ProcAddresses;
    ULONG NumberOfProcAddresses;
    ULONG OldProtect;
    USHORT TagIndex;
    NTSTATUS st;

    //
    // Determine the location and size of the IAT.  If found, scan the
    // IAT address to see if any are pointing to alloc/free functions
    // and replace those thunks.
    //

    IATBase = RtlImageDirectoryEntryToData(
        LdrDataTableEntry->DllBase,
        TRUE,
        IMAGE_DIRECTORY_ENTRY_IAT,
        &LittleIATSize);

    if (IATBase != NULL) {

        BigIATSize = LittleIATSize;

        st = NtProtectVirtualMemory(
            NtCurrentProcess(),
            &IATBase,
            &BigIATSize,
            PAGE_READWRITE,
            &OldProtect);

        if (!NT_SUCCESS(st)) {
            DbgPrint( "LDR: Unable to unprotect IAT to enable per DLL page heap.\n" );
            return FALSE;
        }
        else {
            ProcAddresses = (PVOID *)IATBase;
            NumberOfProcAddresses = (ULONG)(BigIATSize / sizeof(PVOID));
            while (NumberOfProcAddresses--) {

                //
                // If we find a null in the import table we skip over it.
                // Otherwise we will erroneously think it is a malloc() routine
                // to be replaced. This can happen if msvcrt was not loaded yet
                // and therefore the address of malloc() is also null.
                //

                if (*ProcAddresses == NULL) {
                    ProcAddresses += 1;
                    continue;
                }

                if (CallToDetectCrtHeap) {
                    if (*ProcAddresses == AVrfpDphSnapRoutines[SNAP_ROUTINE_HEAPCREATE]) {
                        *ProcAddresses = AVrfpDphDllHeapCreate;
                        DbgPrint ("Snapped (%ws) HeapCreate ... \n",
                            LdrDataTableEntry->BaseDllName.Buffer);
                    }
                }
                else {

                    //
                    // ntdll imports
                    //

                    if (*ProcAddresses == RtlAllocateHeap) {
                        *ProcAddresses = AVrfpDphDllHeapAlloc;
                        DbgPrint ("Snapped (%ws) RtlAllocateHeap ... \n",
                                  LdrDataTableEntry->BaseDllName.Buffer);
                    }
                    else if (*ProcAddresses == RtlReAllocateHeap) {
                        *ProcAddresses = AVrfpDphDllHeapReAlloc;
                        DbgPrint ("Snapped (%ws) RtlReAllocateHeap ... \n",
                                  LdrDataTableEntry->BaseDllName.Buffer);
                    }
                    else if (*ProcAddresses == RtlFreeHeap) {
                        *ProcAddresses = AVrfpDphDllHeapFree;
                        DbgPrint ("Snapped (%ws) RtlFreeHeap ... \n",
                                  LdrDataTableEntry->BaseDllName.Buffer);
                    }

                    //
                    // kernel32 imports
                    //

                    else if (*ProcAddresses == AVrfpDphSnapRoutines[SNAP_ROUTINE_HEAPALLOC]) {
                        *ProcAddresses = AVrfpDphDllHeapAlloc;
                        DbgPrint ("Snapped (%ws) HeapAlloc ... \n",
                                  LdrDataTableEntry->BaseDllName.Buffer);
                    }
                    else if (*ProcAddresses == AVrfpDphSnapRoutines[SNAP_ROUTINE_HEAPREALLOC]) {
                        *ProcAddresses = AVrfpDphDllHeapReAlloc;
                        DbgPrint ("Snapped (%ws) HeapReAlloc ... \n",
                                  LdrDataTableEntry->BaseDllName.Buffer);
                    }
                    else if (*ProcAddresses == AVrfpDphSnapRoutines[SNAP_ROUTINE_HEAPFREE]) {
                        *ProcAddresses = AVrfpDphDllHeapFree;
                        DbgPrint ("Snapped (%ws) HeapFree ... \n",
                                  LdrDataTableEntry->BaseDllName.Buffer);
                    }

                    else if (*ProcAddresses == AVrfpDphSnapRoutines[SNAP_ROUTINE_LOCALALLOC]) {
                        *ProcAddresses = AVrfpDphDllLocalAlloc;
                        DbgPrint ("Snapped (%ws) LocalAlloc ... \n",
                                  LdrDataTableEntry->BaseDllName.Buffer);
                    }
                    else if (*ProcAddresses == AVrfpDphSnapRoutines[SNAP_ROUTINE_LOCALREALLOC]) {
                        *ProcAddresses = AVrfpDphDllLocalReAlloc;
                        DbgPrint ("Snapped (%ws) LocalReAlloc ... \n",
                                  LdrDataTableEntry->BaseDllName.Buffer);
                    }
                    else if (*ProcAddresses == AVrfpDphSnapRoutines[SNAP_ROUTINE_LOCALFREE]) {
                        *ProcAddresses = AVrfpDphDllLocalFree;
                        DbgPrint ("Snapped (%ws) LocalFree ... \n",
                                  LdrDataTableEntry->BaseDllName.Buffer);
                    }

                    else if (*ProcAddresses == AVrfpDphSnapRoutines[SNAP_ROUTINE_GLOBALALLOC]) {
                        *ProcAddresses = AVrfpDphDllGlobalAlloc;
                        DbgPrint ("Snapped (%ws) GlobalAlloc ... \n",
                                  LdrDataTableEntry->BaseDllName.Buffer);
                    }
                    else if (*ProcAddresses == AVrfpDphSnapRoutines[SNAP_ROUTINE_GLOBALREALLOC]) {
                        *ProcAddresses = AVrfpDphDllGlobalReAlloc;
                        DbgPrint ("Snapped (%ws) GlobalReAlloc ... \n",
                                  LdrDataTableEntry->BaseDllName.Buffer);
                    }
                    else if (*ProcAddresses == AVrfpDphSnapRoutines[SNAP_ROUTINE_GLOBALFREE]) {
                        *ProcAddresses = AVrfpDphDllGlobalFree;
                        DbgPrint ("Snapped (%ws) GlobalFree ... \n",
                                  LdrDataTableEntry->BaseDllName.Buffer);
                    }

                    //
                    // msvcrt imports
                    //

                    else if (*ProcAddresses == AVrfpDphSnapRoutines[SNAP_ROUTINE_MALLOC]) {
                        *ProcAddresses = AVrfpDphDllmalloc;
                        DbgPrint ("Snapped (%ws) malloc ... \n",
                                  LdrDataTableEntry->BaseDllName.Buffer);
                    }
                    else if (*ProcAddresses == AVrfpDphSnapRoutines[SNAP_ROUTINE_REALLOC]) {
                        *ProcAddresses = AVrfpDphDllrealloc;
                        DbgPrint ("Snapped (%ws) realloc ... \n",
                                  LdrDataTableEntry->BaseDllName.Buffer);
                    }
                    else if (*ProcAddresses == AVrfpDphSnapRoutines[SNAP_ROUTINE_CALLOC]) {
                        *ProcAddresses = AVrfpDphDllcalloc;
                        DbgPrint ("Snapped (%ws) calloc ... \n",
                                  LdrDataTableEntry->BaseDllName.Buffer);
                    }
                    else if (*ProcAddresses == AVrfpDphSnapRoutines[SNAP_ROUTINE_FREE]) {
                        *ProcAddresses = AVrfpDphDllfree;
                        DbgPrint ("Snapped (%ws) free ... \n",
                                  LdrDataTableEntry->BaseDllName.Buffer);
                    }

                    else if (*ProcAddresses == AVrfpDphSnapRoutines[SNAP_ROUTINE_NEW]) {
                        *ProcAddresses = AVrfpDphDllNew;
                        DbgPrint ("Snapped (%ws) operator new ... \n",
                                  LdrDataTableEntry->BaseDllName.Buffer);
                    }
                    else if (*ProcAddresses == AVrfpDphSnapRoutines[SNAP_ROUTINE_DELETE]) {
                        *ProcAddresses = AVrfpDphDllDelete;
                        DbgPrint ("Snapped (%ws) operator delete ... \n",
                                  LdrDataTableEntry->BaseDllName.Buffer);
                    }
                    else if (*ProcAddresses == AVrfpDphSnapRoutines[SNAP_ROUTINE_NEW_ARRAY]) {
                        *ProcAddresses = AVrfpDphDllNewArray;
                        DbgPrint ("Snapped (%ws) operator new[] ... \n",
                                  LdrDataTableEntry->BaseDllName.Buffer);
                    }
                    else if (*ProcAddresses == AVrfpDphSnapRoutines[SNAP_ROUTINE_DELETE_ARRAY]) {
                        *ProcAddresses = AVrfpDphDllDeleteArray;
                        DbgPrint ("Snapped (%ws) operator delete[] ... \n",
                                  LdrDataTableEntry->BaseDllName.Buffer);
                    }
                }

                ProcAddresses += 1;
            }

            NtProtectVirtualMemory(
                NtCurrentProcess(),
                &IATBase,
                &BigIATSize,
                OldProtect,
                &OldProtect);
        }
    }

    return TRUE;
}

VOID
AVrfPageHeapDllNotification (
    PLDR_DATA_TABLE_ENTRY LoadedDllData
    )
/*++

Routine description:

    This routine is the DLL load hook for page heap per dll. It gets called
    whenever a dll got loaded in the process space and after its import
    descriptors have been walked.

Parameters:

    LoadedDllData - LDR loader structure for the dll.
    
Return value:

    None.
            
--*/
{
    BOOLEAN Kernel32JustSnapped = FALSE;
    BOOLEAN MsvcrtJustSnapped = FALSE;

    //
    // If we do not have per dll page heap feature enabled
    // we return immediately.
    //

    if (! (RtlpDphGlobalFlags & PAGE_HEAP_USE_DLL_NAMES)) {
        return;
    }

    if (! AVrfpDphKernel32Snapped) {

        Kernel32JustSnapped = AVrfpDphDetectSnapRoutines (
            Kernel32String.Buffer,
            AVrfpDphSnapNamesForKernel32);

        AVrfpDphKernel32Snapped = Kernel32JustSnapped;
    }

    if (! AVrfpDphMsvcrtSnapped) {

        MsvcrtJustSnapped = AVrfpDphDetectSnapRoutines (
            L"msvcrt.dll",
            AVrfpDphSnapNamesForMsvcrt);

        AVrfpDphMsvcrtSnapped = MsvcrtJustSnapped;
    }

    //
    // Snap everything already loaded if we just managed
    // to detect snap routines.
    //

    if (Kernel32JustSnapped || MsvcrtJustSnapped) {

        PWSTR Current;
        PWSTR End;
        WCHAR SavedChar;
        PLDR_DATA_TABLE_ENTRY DllData;
        BOOLEAN Result;
        UNICODE_STRING DllName;
        WCHAR StaticRedirectionBuffer[DOS_MAX_PATH_LENGTH];
        UNICODE_STRING StaticRedirectionString;
        UNICODE_STRING DynamicRedirectionString;
        PUNICODE_STRING DllNameToUse;
        BOOLEAN Redirected = FALSE;
        NTSTATUS Status;        

        DynamicRedirectionString.Buffer = NULL;

        StaticRedirectionString.Length = 0;
        StaticRedirectionString.MaximumLength = sizeof(StaticRedirectionBuffer);
        StaticRedirectionString.Buffer = StaticRedirectionBuffer;

        Current = RtlpDphTargetDlls;

        while (*Current) {

            while (*Current == L' ') {
                Current += 1;
            }

            End = Current;

            while (*End && *End != L' ') {
                End += 1;
            }

            if (*Current == L'\0') {
                break;
            }

            SavedChar = *End;
            *End = L'\0';

            RtlInitUnicodeString (
                &DllName,
                Current);

            DllNameToUse = &DllName;

            Status = RtlDosApplyFileIsolationRedirection_Ustr(
                    RTL_DOS_APPLY_FILE_REDIRECTION_USTR_FLAG_RESPECT_DOT_LOCAL,
                    &DllName,
                    &DefaultExtension,
                    &StaticRedirectionString,
                    &DynamicRedirectionString,
                    &DllNameToUse,
                    NULL,
                    NULL,
                    NULL);
            if (NT_SUCCESS(Status)) {
                Redirected = TRUE;
            } else if (Status == STATUS_SXS_KEY_NOT_FOUND) {
                Status = STATUS_SUCCESS;
            }

            if (NT_SUCCESS(Status)) {
                Result = LdrpCheckForLoadedDll (
                    NULL,
                    DllNameToUse,
                    TRUE,
                    Redirected,
                    &DllData);

                if (DynamicRedirectionString.Buffer != NULL)
                    RtlFreeUnicodeString(&DynamicRedirectionString);
            }

            if (Result) {

                if (DllData->DllBase == LoadedDllData->DllBase) {
#if DBG
                    DbgPrint ("Page heap: oversnapping %ws \n", DllData->BaseDllName);
#endif
                }

                AVrfpDphSnapImports (DllData, FALSE);
            }

            *End = SavedChar;
            Current = End;
        }
    }

    //
    // If we just loaded msvcrt.dll we need to redirect HeapCreate call
    // in order to detect when the CRT heap gets created.
    //

    if (_wcsicmp (LoadedDllData->BaseDllName.Buffer, L"msvcrt.dll") == 0) {

        AVrfpDphSnapImports (LoadedDllData, TRUE);
    }

    //
    // Call back into page heap manager to figure out if the
    // currently loaded dll is a target for page heap.
    //

    if (RtlpDphIsDllTargeted (LoadedDllData->BaseDllName.Buffer)) {

        AVrfpDphSnapImports (LoadedDllData, FALSE);
    }
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////// Snap routines
/////////////////////////////////////////////////////////////////////

//
// A biased heap pointer signals to the page heap manager that
// this allocation needs to get into page heap (not normal heap).
// This needs to happen only for allocation function (not free, delete).
//

#define BIAS_POINTER(p) ((PVOID)((ULONG_PTR)(p) | 0x01))

PVOID
AVrfpDphDllHeapAlloc (
    IN PVOID  HeapHandle,
    IN ULONG  Flags,
    IN SIZE_T Size
    )
{
    return RtlpDebugPageHeapAllocate (
        BIAS_POINTER(HeapHandle),
        Flags,
        Size);
}

PVOID
AVrfpDphDllHeapReAlloc (
    IN PVOID  HeapHandle,
    IN ULONG  Flags,
    IN PVOID Address,
    IN SIZE_T Size
    )
{
    return RtlpDebugPageHeapReAllocate (
        BIAS_POINTER(HeapHandle),
        Flags,
        Address,
        Size);
}

BOOLEAN
AVrfpDphDllHeapFree(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    )
{
    return RtlpDebugPageHeapFree (
        HeapHandle,
        Flags,
        Address);
}

//
// LocalAlloc, LocalReAlloc, LocalFree
// GlobalAlloc, GlobalReAlloc, GlobalFree
//
// The following macros are copied from sdk\inc\winbase.h
// There is very low probability that anybody will ever change
// these values for application compatibility reasons.
//

#define LMEM_MOVEABLE       0x0002
#define LMEM_ZEROINIT       0x0040

#if defined(_AMD64_) || defined(_IA64_)
#define BASE_HANDLE_MARK_BIT 0x08
#else
#define BASE_HANDLE_MARK_BIT 0x04
#endif

typedef PVOID
(* FUN_LOCAL_ALLOC) (
    IN ULONG  Flags,
    IN SIZE_T Size
    );

typedef PVOID
(* FUN_LOCAL_REALLOC) (
    IN PVOID Address,
    IN SIZE_T Size,
    IN ULONG  Flags
    );

typedef PVOID
(* FUN_LOCAL_FREE)(
    IN PVOID Address
    );

typedef PVOID
(* FUN_GLOBAL_ALLOC) (
    IN ULONG  Flags,
    IN SIZE_T Size
    );

typedef PVOID
(* FUN_GLOBAL_REALLOC) (
    IN PVOID Address,
    IN SIZE_T Size,
    IN ULONG  Flags
    );

typedef PVOID
(* FUN_GLOBAL_FREE)(
    IN PVOID Address
    );

PVOID
AVrfpDphDllLocalAlloc (
    IN ULONG  Flags,
    IN SIZE_T Size
    )
{
    PVOID Block;
    FUN_LOCAL_ALLOC Original;

    if (!(Flags & LMEM_MOVEABLE)) {

        Block = RtlpDebugPageHeapAllocate (
            BIAS_POINTER(RtlProcessHeap()),
            0,
            Size);

        if (Block && (Flags & LMEM_ZEROINIT)) {
            RtlZeroMemory (Block, Size);
        }

        return Block;
    }
    else {

        Original = (FUN_LOCAL_ALLOC)(AVrfpDphSnapRoutines[SNAP_ROUTINE_LOCALALLOC]);
        return (* Original) (Flags, Size);
    }
}

PVOID
AVrfpDphDllLocalReAlloc (
    IN PVOID Address,
    IN SIZE_T Size,
    IN ULONG  Flags
    )
{
    PVOID Block;
    FUN_LOCAL_REALLOC Original;

    if (!(Flags & LMEM_MOVEABLE)) {

        Block = RtlpDebugPageHeapReAllocate (
            BIAS_POINTER(RtlProcessHeap()),
            0,
            Address,
            Size);

        return Block;
    }
    else {

        Original = (FUN_LOCAL_REALLOC)(AVrfpDphSnapRoutines[SNAP_ROUTINE_LOCALREALLOC]);
        return (* Original) (Address, Size, Flags);
    }
}

PVOID
AVrfpDphDllLocalFree(
    IN PVOID Address
    )
{
    BOOLEAN Result;
    FUN_LOCAL_FREE Original;

    if ((ULONG_PTR)Address & BASE_HANDLE_MARK_BIT) {

        Original = (FUN_LOCAL_FREE)(AVrfpDphSnapRoutines[SNAP_ROUTINE_LOCALFREE]);
        return (* Original) (Address);
    }
    else {

        Result = RtlpDebugPageHeapFree (
            RtlProcessHeap(),
            0,
            Address);

        if (Result) {
            return NULL;
        }
        else {
            return Address;
        }
    }
}

PVOID
AVrfpDphDllGlobalAlloc (
    IN ULONG  Flags,
    IN SIZE_T Size
    )
{
    PVOID Block;
    FUN_GLOBAL_ALLOC Original;

    if (!(Flags & LMEM_MOVEABLE)) {

        Block = RtlpDebugPageHeapAllocate (
            BIAS_POINTER(RtlProcessHeap()),
            0,
            Size);

        if (Block && (Flags & LMEM_ZEROINIT)) {
            RtlZeroMemory (Block, Size);
        }

        return Block;
    }
    else {

        Original = (FUN_GLOBAL_ALLOC)(AVrfpDphSnapRoutines[SNAP_ROUTINE_GLOBALALLOC]);
        return (* Original) (Flags, Size);
    }
}

PVOID
AVrfpDphDllGlobalReAlloc (
    IN PVOID Address,
    IN SIZE_T Size,
    IN ULONG  Flags
    )
{
    PVOID Block;
    FUN_GLOBAL_REALLOC Original;

    if (!(Flags & LMEM_MOVEABLE)) {

        Block = RtlpDebugPageHeapReAllocate (
            BIAS_POINTER(RtlProcessHeap()),
            0,
            Address,
            Size);

        return Block;
    }
    else {

        Original = (FUN_GLOBAL_REALLOC)(AVrfpDphSnapRoutines[SNAP_ROUTINE_GLOBALREALLOC]);
        return (* Original) (Address, Size, Flags);
    }
}

PVOID
AVrfpDphDllGlobalFree(
    IN PVOID Address
    )
{
    BOOLEAN Result;
    FUN_GLOBAL_FREE Original;

    if ((ULONG_PTR)Address & BASE_HANDLE_MARK_BIT) {

        Original = (FUN_GLOBAL_FREE)(AVrfpDphSnapRoutines[SNAP_ROUTINE_GLOBALFREE]);
        return (* Original) (Address);
    }
    else {

        Result = RtlpDebugPageHeapFree (
            RtlProcessHeap(),
            0,
            Address);

        if (Result) {
            return NULL;
        }
        else {
            return Address;
        }
    }
}

//
// malloc, calloc, realloc, free
//

PVOID __cdecl
AVrfpDphDllmalloc (
    IN SIZE_T Size
    )
{
    PVOID Block;

    ASSERT(AVrfpDphMsvcrtHeap != NULL);

    Block = RtlpDebugPageHeapAllocate (
        BIAS_POINTER(AVrfpDphMsvcrtHeap),
        0,
        Size);

    return Block;
}

PVOID __cdecl
AVrfpDphDllcalloc (
    IN SIZE_T Number,
    IN SIZE_T Size
    )
{
    PVOID Block;

    ASSERT(AVrfpDphMsvcrtHeap != NULL);

    Block =  RtlpDebugPageHeapAllocate (
        BIAS_POINTER(AVrfpDphMsvcrtHeap),
        0,
        Size * Number);

    if (Block) {
        RtlZeroMemory (Block, Size * Number);
    }

    return Block;
}

PVOID __cdecl
AVrfpDphDllrealloc (
    IN PVOID Address,
    IN SIZE_T Size
    )
{
    PVOID Block;

    ASSERT(AVrfpDphMsvcrtHeap != NULL);

    if (Address == NULL) {

        Block = RtlpDebugPageHeapAllocate (
            BIAS_POINTER(AVrfpDphMsvcrtHeap),
            0,
            Size);
    }
    else {

        Block = RtlpDebugPageHeapReAllocate (
            BIAS_POINTER(AVrfpDphMsvcrtHeap),
            0,
            Address,
            Size);
    }

    return Block;
}

VOID __cdecl
AVrfpDphDllfree (
    IN PVOID Address
    )
{
    ASSERT(AVrfpDphMsvcrtHeap != NULL);

    RtlpDebugPageHeapFree (
        AVrfpDphMsvcrtHeap,
        0,
        Address);
}

//
// operator new, delete
// operator new[], delete[]
//

PVOID __cdecl
AVrfpDphDllNew (
    IN SIZE_T Size
    )
{
    PVOID Block;

    ASSERT(AVrfpDphMsvcrtHeap != NULL);

    Block = RtlpDebugPageHeapAllocate (
        BIAS_POINTER(AVrfpDphMsvcrtHeap),
        0,
        Size);

    return Block;
}

VOID __cdecl
AVrfpDphDllDelete (
    IN PVOID Address
    )
{
    ASSERT(AVrfpDphMsvcrtHeap != NULL);

    RtlpDebugPageHeapFree (
        AVrfpDphMsvcrtHeap,
        0,
        Address);
}

PVOID __cdecl
AVrfpDphDllNewArray (
    IN SIZE_T Size
    )
{
    ASSERT(AVrfpDphMsvcrtHeap != NULL);

    return RtlpDebugPageHeapAllocate (
        BIAS_POINTER(AVrfpDphMsvcrtHeap),
        0,
        Size);
}

VOID __cdecl
AVrfpDphDllDeleteArray (
    IN PVOID Address
    )
{
    ASSERT(AVrfpDphMsvcrtHeap != NULL);

    RtlpDebugPageHeapFree (
        AVrfpDphMsvcrtHeap,
        0,
        Address);
}

//
// HeapCreate
//

typedef PVOID
(* FUN_HEAP_CREATE) (
    ULONG Options,
    SIZE_T InitialSize,
    SIZE_T MaximumSize
    );

PVOID
AVrfpDphDllHeapCreate (
    ULONG Options,
    SIZE_T InitialSize,
    SIZE_T MaximumSize
    )
{
    PVOID Heap;
    FUN_HEAP_CREATE Original;

    Original = (FUN_HEAP_CREATE)(AVrfpDphSnapRoutines[SNAP_ROUTINE_HEAPCREATE]);
    Heap = (* Original) (Options, InitialSize, MaximumSize);

    AVrfpDphMsvcrtHeap = Heap;
    DbgPrint ("Page heap: detected CRT heap @ %p \n", AVrfpDphMsvcrtHeap);

    return Heap;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\alpha\evpair.s ===
//       TITLE("Fast Event Pair Support")
//++
//
// Copyright (c) 1992  Microsoft Corporation
// Copyright (c) 1993  Digital Equipment Corporation
//
// Module Name:
//
//    evpair.s
//
// Abstract:
//
//    This module contains the system call interface for the fast event pair
//    system service that is used from the client side.
//
// Author:
//
//    David N. Cutler (davec) 29-Oct-1992
//    Joe Notarangelo         20-Feb-1993 (Alpha AXP version)
//
// Environment:
//
//    Kernel mode.
//
// Revision History:
//
//--

#include "ksalpha.h"

        SBTTL("Set Low Wait High Thread")
//++
//
// NTSTATUS
// XySetLowWaitHighThread (
//    )
//
// Routine Description:
//
//    This function calls the fast event pair system service.
//
//    N.B. The return from this routine is directly to the caller.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    STATUS_NO_EVENT_PAIR is returned if no event pair is associated with
//    the current thread. Otherwise, the status of the wait operation is
//    returned as the function value.
//
//
//--

        LEAF_ENTRY(XySetLowWaitHighThread)

        ldil    v0,SET_LOW_WAIT_HIGH    // set system service number
        SYSCALL                         // call system service

        .end    XySetLowWaitHighThread
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\alpha\ldrthunk.s ===
//      TITLE("LdrInitializeThunk")
//++
//
// Copyright (c) 1989  Microsoft Corporation
// Copyright (c) 1992  Digital Equipment Corporation
//
// Module Name:
//
//    ldrthunk.s
//
// Abstract:
//
//    This module implements the thunk for the LdrpInitialize APC routine.
//
// Author:
//
//    Steven R. Wood (stevewo) 27-Apr-1990
//
// Environment:
//
//    Any mode.
//
// Revision History:
//
//    Thomas Van Baak (tvb) 18-May-1992
//
//        Adapted for Alpha AXP.
//
//--

#include "ksalpha.h"

//++
//
// VOID
// LdrInitializeThunk (
//    IN PVOID NormalContext,
//    IN PVOID SystemArgument1,
//    IN PVOID SystemArgument2
//    )
//
// Routine Description:
//
//    This function computes a pointer to the context record on the stack
//    and jumps to the LdrpInitialize function with that pointer as its
//    parameter.
//
// Arguments:
//
//    NormalContext (a0) - User Mode APC context parameter (ignored).
//
//    SystemArgument1 (a1) - User Mode APC system argument 1 (ignored).
//
//    SystemArgument2 (a2) - User Mode APC system argument 2 (ignored).
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(LdrInitializeThunk)

        mov     sp, a0                  // get address of context record
        br      zero, LdrpInitialize    // jump to LdrpInitialize

        .end LdrInitializeThunk

//++
//
// VOID
// LdrpSetGp(
//    IN ULONG GpValue
//    )
//
// Routine Description:
//
//    This function sets the value of the Gp register.
//
// Arguments:
//
//    GpValue (a0) - Supplies the value for Gp.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(LdrpSetGp)

        mov     a0, gp                  // set global pointer register
        ret     zero, (ra)              // return

        .end LdrpSetGp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\alpha\ldrctx.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ldrctx.c

Abstract:

    This module contains support for relocating executables.

Author:

    Landy Wang (landyw) 8-Jul-1998

Environment:

    User Mode only

Revision History:

--*/

#include <ntos.h>
#include <ldrp.h>

VOID
LdrpRelocateStartContext (
    IN PCONTEXT Context,
    IN LONG_PTR Diff
    )
/*++

Routine Description:

   This routine relocates the start context to mesh with the
   executable that has just been relocated.

Arguments:

   Context - Supplies a context that needs editing.

   Diff - Supplies the difference from the based address to the relocated
          address.

Return Value:

   None.

--*/
{
    Context->IntA0 += (ULONGLONG)Diff;
    Context->IntGp += (ULONGLONG)Diff;
}

VOID
LdrpCorReplaceStartContext (
    IN PCONTEXT Context
    )
/*++

Routine Description:

   This routine replaces the initial address to run by one in mscoree.dll.

Arguments:

   Context - Supplies a context that needs editing.

Return Value:

   None.

--*/
{
    Context->IntA0 = (ULONGLONG)CorExeMain;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\emarith.asm ===
subttl  emarith.asm - Arithmetic Operations
	page
;*******************************************************************************
;emarith.asm - Arithmetic Operations
;
;        Microsoft Confidential
;
;        Copyright (c) Microsoft Corporation 1991
;        All Rights Reserved
;
;Purpose:
;       Arithmetic Operations
;
;Revision History:
;
; []	09/05/91  TP	Initial 32-bit version.
;
;*******************************************************************************

	NextStackWrap   esi,TwoOp       ;Tied to NextStackElem below

EM_ENTRY eFPREM
eFPREM:
    and		[esp].[OldLongStatus+4],NOT(ConditionCode SHL 16)	;clear C0,C1,C2,C3
	push	offset PremCont		;Return address if normal
PremPointTopTwo:
	push	offset PremSpclDone	;Return address if special
	mov	ebp,offset tFpremDisp
PointTopTwo:
	mov	esi,edi
	NextStackElem   esi,TwoOp
TwoOpSiDi:
	mov	ecx,EMSEG:[esi].ExpSgn
	mov	ebx,EMSEG:[esi].lManHi
	mov	esi,EMSEG:[esi].lManLo
TwoOpSetResult:
	mov	EMSEG:[Result],edi		;Save result pointer
TwoOpResultSet:
	mov     ah,EMSEG:[edi].bTag
TwoOpDispAh:
	mov	al,cl
TwoOpDispatch:
	and     eax,TAG_MASK + 100H*TAG_MASK	;Look at internal tags only
	shl     al,TAG_SHIFT
	or      al,ah
	xor	ah,ah			;Zero ah
;UNDONE:  masm bug!  ebp + scaled index requires a displacement.
;UNDONE:  No displacement is needed here, so masm should generate a
;UNDONE:  zero.  It doesn't!  dec eax so we can add 4*1 back.
	dec	eax			;UNDONE
	jmp     dword ptr cs:[ebp+4*eax+4];UNDONE Go to appropriate routine.

EM_ENTRY eFPREM1
eFPREM1:
    and		[esp].[OldLongStatus+4],NOT(ConditionCode SHL 16)	;clear C0,C1,C2,C3
	push	offset Prem1Cont	;Return address if normal
	jmp	PremPointTopTwo

EM_ENTRY eFSCALE
eFSCALE:
	mov	ebp,offset tFscaleDisp
	jmp	PointTopTwo

EM_ENTRY eFPATAN
eFPATAN:
	mov	ebp,offset tFpatanDisp
TopTwoPop:
	push	offset PopWhenDone
	mov	esi,edi
	add	edi,Reg87Len		;edi = ST(1)
        cmp     edi,ENDstk
	jb	TwoOpSiDi
        mov     edi,BEGstk
	jmp	TwoOpSiDi

EM_ENTRY eFYL2X
eFYL2X:
	mov	ebp,offset tFyl2xDisp
	jmp	TopTwoPop

EM_ENTRY eFYL2XP1
eFYL2XP1:
	mov	ebp,offset tFyl2xp1Disp
	jmp	TopTwoPop

;*******************************************************************************

page
;-----------------------------------------------------------;
;                                                           ;
;       Special Case Routines for Arithmetic Functions      ;
;                                                           ;
;-----------------------------------------------------------;

;There are four kinds of "specials", encoded in the tag:
;
;	Empty
; 	Infinity
;	NAN (which can be QNAN or SNAN)
;	Denormal
;
;Empty always results in an Invalid Operation exception with Stack Flag set
;and C1 (O/U#) bit clear, and returns Indefinite (a specific QNAN).
;
;Operations on NAN return the same NAN except it is always modified to a 
;QNAN.  If both  operands are NAN, the one with the larger mantissa is
;returned.  An SNAN causes an Invalid Operation exception except for
;internal FP stack operations, FCHS, and FABS.  A QNAN does not cause
;and exception.  
;
;Operations on Infinity return a result depending on the operation.
;
;UNDONE: Old code plays with sign of NAN when two NANs with equal
;mantissas are used.  Why?

;"***" means entry point from dispatch tables

;***
DivSpclSource:
	cmp	cl,bTAG_INF
	jnz	SpclSource
;Division by infinity always returns zero
	xor	ch,EMSEG:[edi].bSgn
	jmp	SignedZero		;in emfmul.asm

;***
MulSpclSource:
	cmp	cl,bTAG_INF
	jnz	SpclSource
MulByInf:
	cmp	EMSEG:[edi].bTag,bTAG_ZERO	;Infinity * zero?
	jz	ReturnIndefinite
XorSourceSign:
	xor	ch,EMSEG:[edi].bSgn
	jmp	SaveResultEdi

;***
AddSpclSource:
	cmp	cl,bTAG_INF
	jnz	SpclSource
	xor	ch,dl			;Flip sign of infinity if subtracting
	jmp	SaveResultEdi

DenormalSource:
	mov	cl,bTAG_VALID		;Change denormal to DOUBLE
	mov	EMSEG:[CURerr],Denormal
	test	EMSEG:[CWmask],Denormal	;Is denormal exception masked?
	jnz	TwoOpResultSet
AbortOp:
	mov	cl,bTAG_NOPOP		;Unmasked, don't pop stack
	ret

DenormalDisp:
;Repeat dispatch, but for normal ops
	jmp     dword ptr cs:[ebp+4*(TAG_VALID + TAG_VALID shl TAG_SHIFT)]

;***
DivrSpclSource:
	cmp	cl,bTAG_INF
	jz	XorSourceSign		;Return infinity
SpclSource:
	cmp	cl,bTAG_DEN
	jz	DenormalSource
	cmp	cl,bTAG_EMPTY
	jz	StackError
;Must be a NAN
SourceNAN:
	test	ebx,1 shl 30		;Check for SNAN
	jnz	SaveResultEdi		;If QNAN, just use it as result
SourceSNAN:
	or	EMSEG:[CURerr],Invalid	;Flag the error
	or	ebx,1 shl 30		;Make it into a QNAN
	test	EMSEG:[CWmask],Invalid	;Is it masked?
	jnz	SaveResultEdi		;If so, update with masked response
	mov	cl,bTAG_NOPOP		;Unmasked, don't pop stack
	ret


;***
DivrSpclDest:
	mov	eax,EMSEG:[edi].ExpSgn	;Pick up tag
	cmp	al,bTAG_INF
	jnz	SpclDest
;Division by infinity always returns zero
	xor	ch,ah
	jmp	SignedZero		;in emfmul.asm

;***
MulSpclDest:
	mov	al,EMSEG:[edi].bTag	;Pick up tag
	cmp	al,bTAG_INF
	jnz	SpclDest
	cmp	cl,bTAG_ZERO		;Infinity * zero?
	jz	ReturnIndefinite
XorDestSign:
	xor	EMSEG:[edi].bSgn,ch	;Xor signs
	ret

;***
AddSpclDest:
	mov	al,EMSEG:[edi].bTag	;Pick up tag
	cmp	al,bTAG_INF
	jnz	SpclDest
	xor	EMSEG:[edi].bSgn,dh	;Flip sign of infinity if subtracting
	ret

DenormalDest:
	mov	ah,bTAG_VALID		;Change denormal to DOUBLE
	mov	EMSEG:[CURerr],Denormal
	test	EMSEG:[CWmask],Denormal	;Is denormal exception masked?
	jnz	TwoOpDispAh
	mov	cl,bTAG_NOPOP		;Unmasked, don't pop stack
	ret

;***
DivSpclDest:
	mov	al,EMSEG:[edi].bTag	;Pick up tag
	cmp	al,bTAG_INF
	jz	XorDestSign		;Return infinity
SpclDest:
	cmp	al,bTAG_DEN
	jz	DenormalDest
SpclDestNotDen:
	cmp	al,bTAG_EMPTY
	jz	StackError
;Must be a NAN
DestNAN:
	test	EMSEG:[edi].bMan7,40H	;Check for SNAN
	jnz	ReturnDest		;If QNAN, just use it as result
DestSNAN:
	or	EMSEG:[CURerr],Invalid	;Flag the error
	test	EMSEG:[CWmask],Invalid	;Is it masked?
	jz	AbortOp			;No - preserve value
	or	EMSEG:[edi].bMan7,40H	;Make it into a QNAN
	ret

StackError:
	mov	EMSEG:[CURerr],Invalid+StackFlag
ReturnIndefinite:
	or 	EMSEG:[CURerr],Invalid
	test	EMSEG:[CWmask],Invalid	;Is it masked?
	jz	AbortOp			;No - preserve value
	mov	EMSEG:[edi].lManLo,0
	mov	EMSEG:[edi].lManHi,0C0000000H
	mov	EMSEG:[edi].ExpSgn,TexpMax shl 16 + bSign shl 8 + bTAG_NAN
ReturnDest:
	ret


AddTwoInf:
;Adding two infinites.
;If signs are the same, return that infinity.  Otherwise, Invalid Operation.
	xor	ch,dl			;Possibly subtracting source
	xor	ah,dh			;Possibly subtracting dest
	xor	ch,ah			;Compare signs
	js	ReturnIndefinite
	mov	EMSEG:[edi].bSgn,ah	;Correct the sign if subtracting
	ret

;***
TwoOpBothSpcl:
;ebp = dispatch table address
	mov	al,EMSEG:[edi].bTag
	mov	ah,cl
	cmp	ax,(bTAG_NAN shl 8) + bTag_NAN	;Are both NAN?
	jz	TwoNANs
	cmp	cl,bTAG_EMPTY
	jz	StackError
	cmp	al,bTAG_EMPTY
	jz	StackError
	cmp	cl,bTAG_NAN
	jz	SourceNAN
	cmp	al,bTAG_NAN
	jz	DestNAN
	cmp	ax,(bTAG_INF shl 8) + bTag_INF	;Are both infinity?
	jz	TwoInfs
;At least one of the operands is a denormal
	mov	EMSEG:[CURerr],Denormal
	test	EMSEG:[CWmask],Denormal	;Is denormal exception masked?
	jz	AbortOp			;If not, don't do operation
;Denormal exception is masked, treat denormals as VALID
;Dispatch through operation table in ebp again
	cmp	ax,(bTAG_DEN shl 8) + bTag_DEN	;Are both denormal?
	jz	DenormalDisp
;Have an infinity and a denormal
	cmp	al,bTAG_INF
	jz	DestInf
;Source is denormal, Dest is infinity
	jmp	dword ptr [ebp+4*(TAG_SPCL + TAG_VALID shl TAG_SHIFT)]

DestInf:
;Source is infinity, Dest is denormal
	jmp	dword ptr [ebp+4*(TAG_VALID + TAG_SPCL shl TAG_SHIFT)]

TwoNANs:
;Two NANs. Use largest mantissa
	cmp	ebx,EMSEG:[edi].lManHi
	ja	BiggerNAN
	jb	DestBigger
;Now we know they're both the same type, SNAN or QNAN
	cmp	esi,EMSEG:[edi].lManLo
	ja	SourceNAN
;UNDONE: Old code did funny business with signs when mantissas were equal
	jmp	DestNAN

BiggerNAN:
	test	EMSEG:[edi].bMan7,40H		;Is smaller one SNAN?
	jz	SourceSNAN
	jmp	SourceNAN

DestBigger:
	test	ebx,40H			;Is smaller one SNAN?
	jz	DestSNAN
	jmp	DestNAN

TwoInfs:
        mov     ah,EMSEG:[edi].bSgn
	jmp	dword ptr [ebp+4*16]	;Go do code for two infinites


;***
DivideByMinusZero:
	mov	ch,bSign
;***
DivideByZero:
	or	EMSEG:[CURerr],ZeroDivide
	test	EMSEG:[CWmask],ZeroDivide	;Is exception masked?
	jz	AbortOp			;No - preserve value
;Set up a signed infinity
	xor	ch,EMSEG:[edi].bSgn		;Get result sign
	and	ecx,1 shl 15		;Keep only sign bit
	or	ecx,(4000H+TexpBias) shl 16 + bTAG_INF	;ExpSgn of infinity
	mov	ebx,1 shl 31
	xor	esi,esi
	jmp	SaveResultEdi
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\critsect.asm ===
title   "Critical Section Support"
;++
;
;  Copyright (c) 1991  Microsoft Corporation
;
;  Module Name:
;
;     critsect.asm
;
;  Abstract:
;
;     This module implements functions to support user mode critical sections.
;
;  Author:
;
;     Bryan M. Willman (bryanwi) 2-Oct-91
;
;  Environment:
;
;     Any mode.
;
;  Revision History:
;
;--

.486p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
include mac386.inc
        .list

_DATA   SEGMENT DWORD PUBLIC 'DATA'
    public _LdrpLockPrefixTable
_LdrpLockPrefixTable    label dword
        dd offset FLAT:Lock1
        dd offset FLAT:Lock2
        dd offset FLAT:Lock3
        dd offset FLAT:Lock4
        dd offset FLAT:Lock5
        dd offset FLAT:Lock6
        dd offset FLAT:Lock7
        dd 0
_DATA   ENDS

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        EXTRNP  _RtlpWaitForCriticalSection,1
        EXTRNP  _RtlpUnWaitCriticalSection,1
if DEVL
        EXTRNP  _RtlpNotOwnerCriticalSection,1
endif
if DBG
        EXTRNP  _RtlpCriticalSectionIsOwned,1
endif

CriticalSection equ     [esp + 4]

        page , 132
        subttl  "RtlEnterCriticalSection"

;++
;
; NTSTATUS
; RtlEnterCriticalSection(
;    IN PRTL_CRITICAL_SECTION CriticalSection
;    )
;
; Routine Description:
;
;    This function enters a critical section.
;
; Arguments:
;
;    CriticalSection - supplies a pointer to a critical section.
;
; Return Value:
;
;   STATUS_SUCCESS or raises an exception if an error occured.
;
;--

        align   16
cPublicProc _RtlEnterCriticalSection,1
cPublicFpo 1,0

        mov     ecx,fs:PcTeb            ; get current TEB address
        mov     edx,CriticalSection     ; get address of critical section
        cmp     CsSpinCount[edx],0      ; check if spin count is zero
        jne     short Ent40             ; if ne, spin count specified

;
; Attempt to acquire critical section.
;

Lock1:                                  ;
   lock inc     dword ptr CsLockCount[edx] ; increment lock count
        jnz     short Ent20             ; if nz, already owned

;
; Set critical section owner and initialize recursion count.
;

Ent10:
if DBG
        cmp     CsOwningThread[edx],0
        je      @F
        stdCall _RtlpCriticalSectionIsOwned, <edx>
        mov     ecx,fs:PcTeb            ; get current TEB address
        mov     edx,CriticalSection     ; get address of critical section
@@:
endif ; DBG
        mov     eax,TbClientId + 4[ecx] ; get current client ID
        mov     CsOwningThread[edx],eax ; set critical section owner
        mov     dword ptr CsRecursionCount[edx],1 ; set recursion count

if DBG

        inc     dword ptr TbCountOfOwnedCriticalSections[ecx] ; increment owned count
        mov     eax,CsDebugInfo[edx]    ; get debug information address
        inc     dword ptr CsEntryCount[eax] ; increment entry count

endif ; DBG

        xor     eax,eax                 ; set success status

        stdRET  _RtlEnterCriticalSection

;
; The critical section is already owned, but may be owned by the current thread.
;

        align   16
Ent20:  mov     eax,TbClientId + 4[ecx] ; get current client ID
        cmp     CsOwningThread[edx],eax ; check if current thread is owner
        jne     short Ent30             ; if ne, current thread not owner
        inc     dword ptr CsRecursionCount[edx] ; increment recursion count

if DBG

        mov     eax,CsDebugInfo[edx]    ; get debug information address
        inc     dword ptr CsEntryCount[eax] ; increment entry count

endif ; DBG

        xor     eax,eax                 ; set success status

        stdRET  _RtlEnterCriticalSection

;
; The critcal section is owned by another thread and the current thread must
; wait for ownership.
;

Ent30:  stdCall _RtlpWaitForCriticalSection, <edx> ; wait for ownership
        mov     ecx,fs:PcTeb            ; get current TEB address
        mov     edx,CriticalSection     ; get address of critical section
        jmp     Ent10                   ; set owner and recursion count

;
; A nonzero spin count is specified.
;

        align   16
Ent40:  mov     eax,TbClientId + 4[ecx] ; get current client ID
        cmp     CsOwningThread[edx],eax ; check if current thread is owner
        jne     short Ent50             ; if ne, current thread not owner

;
; The critical section is owned by the current thread. Increment the lock
; count and the recursion count.
;

Lock6:                                  ;
   lock inc     dword ptr CsLockCount[edx] ; increment lock count
        inc     dword ptr CsRecursionCount[edx] ; increment recursion count

if DBG

        mov     eax,CsDebugInfo[edx]    ; get debug information address
        inc     dword ptr CsEntryCount[eax] ; increment entry count

endif ; DBG

        xor     eax,eax                 ; set success status

        stdRET  _RtlEnterCriticalSection

;
; A nonzero spin count is specified and the current thread is not the owner.
;

        align   16
Ent50:  push    CsSpinCount[edx]        ; get spin count value
Ent60:  mov     eax,-1                  ; set comparand value
        mov     ecx,0                   ; set exchange value

Lock7:
   lock cmpxchg dword ptr CsLockCount[edx],ecx ; attempt to acquire critical section
        jnz     short Ent70             ; if nz, critical section not acquired

;
; The critical section has been acquired. Set the owning thread and the initial
; recursion count.
;

        add     esp,4                   ; remove spin count from stack
        mov     ecx,fs:PcTeb            ; get current TEB address
        mov     eax,TbClientId + 4[ecx] ; get current client ID
        mov     CsOwningThread[edx],eax ; set critical section owner
        mov     dword ptr CsRecursionCount[edx],1 ; set recursion count

if DBG

        inc     dword ptr TbCountOfOwnedCriticalSections[ecx] ; increment owned count
        mov     eax,CsDebugInfo[edx]    ; get debug information address
        inc     dword ptr CsEntryCount[eax] ; increment entry count

endif ; DBG

        xor     eax,eax                 ; set success status

        stdRET  _RtlEnterCriticalSection

;
; The critical section is currently owned. Spin until it is either unowned
; or the spin count has reached zero.
;
; If waiters are present, don't spin on the lock since we will never see it go free
;

Ent70:  cmp     CsLockCount[edx],1      ; check if waiters are present,
        jge     short Ent76             ; if ge 1, then do not spin

Ent75:  YIELD
        cmp     CsLockCount[edx],-1     ; check if lock is owned
        je      short Ent60             ; if e, lock is not owned
        dec     dword ptr [esp]         ; decrement spin count
        jnz     short Ent75             ; if nz, continue spinning
Ent76:  add     esp,4                   ; remove spin count from stack
        mov     ecx,fs:PcTeb            ; get current TEB address
        jmp     Lock1                   ;

stdENDP _RtlEnterCriticalSection

        page , 132
        subttl  "RtlLeaveCriticalSection"
;++
;
; NTSTATUS
; RtlLeaveCriticalSection(
;    IN PRTL_CRITICAL_SECTION CriticalSection
;    )
;
; Routine Description:
;
;    This function leaves a critical section.
;
; Arguments:
;
;    CriticalSection - supplies a pointer to a critical section.
;
; Return Value:
;
;   STATUS_SUCCESS or raises an exception if an error occured.
;
;--

        align   16
cPublicProc _RtlLeaveCriticalSection,1
cPublicFpo 1,0

        mov     edx,CriticalSection
if DBG
        mov     ecx,fs:PcTeb                ; (ecx) == NtCurrentTeb()
        mov     eax,TbClientId+4[ecx]       ; (eax) == NtCurrentTeb()->ClientId.UniqueThread
        cmp     eax,CsOwningThread[edx]
        je      @F
        stdCall _RtlpNotOwnerCriticalSection, <edx>
        mov     eax,STATUS_INVALID_OWNER
        stdRET  _RtlLeaveCriticalSection
@@:
endif ; DBG
        xor     eax,eax                     ; Assume STATUS_SUCCESS
        dec     dword ptr CsRecursionCount[edx]
        jnz     leave_recurs                ; skip if only leaving recursion

        mov     CsOwningThread[edx],eax     ; clear owning thread id

if DBG
        mov     ecx,fs:PcTeb                ; (ecx) == NtCurrentTeb()
        dec     dword ptr TbCountOfOwnedCriticalSections[ecx]
endif ; DBG

Lock2:
   lock dec     dword ptr CsLockCount[edx]  ; interlocked dec of
                                            ; ... CriticalSection->LockCount
        jge     @F
        stdRET  _RtlLeaveCriticalSection

@@:
        stdCall _RtlpUnWaitCriticalSection, <edx>
        xor     eax,eax                     ; return STATUS_SUCCESS
        stdRET  _RtlLeaveCriticalSection

        align   16
leave_recurs:
Lock3:
   lock dec     dword ptr CsLockCount[edx]  ; interlocked dec of
                                            ; ... CriticalSection->LockCount
        stdRET  _RtlLeaveCriticalSection

_RtlLeaveCriticalSection    endp

        page    ,132
        subttl  "RtlTryEnterCriticalSection"
;++
;
; BOOL
; RtlTryEnterCriticalSection(
;    IN PRTL_CRITICAL_SECTION CriticalSection
;    )
;
; Routine Description:
;
;    This function attempts to enter a critical section without blocking.
;
; Arguments:
;
;    CriticalSection (a0) - Supplies a pointer to a critical section.
;
; Return Value:
;
;    If the critical section was successfully entered, then a value of TRUE
;    is returned as the function value. Otherwise, a value of FALSE is returned.
;
;--

CriticalSection equ     [esp + 4]

cPublicProc _RtlTryEnterCriticalSection,1
cPublicFpo 1,0

        mov     ecx,CriticalSection         ; interlocked inc of
        mov     eax, -1                     ; set value to compare against
        mov     edx, 0                      ; set value to set
Lock4:
   lock cmpxchg dword ptr CsLockCount[ecx],edx  ; Attempt to acquire critsect
        jnz     short tec10                 ; if nz, critsect already owned

        mov     eax,fs:TbClientId+4         ; (eax) == NtCurrentTeb()->ClientId.UniqueThread
        mov     CsOwningThread[ecx],eax
        mov     dword ptr CsRecursionCount[ecx],1

if DBG
        mov     eax,fs:PcTeb                ; (ecx) == NtCurrentTeb()
        inc     dword ptr TbCountOfOwnedCriticalSections[eax]
endif ; DBG

        mov     eax, 1                      ; set successful status

        stdRET  _RtlTryEnterCriticalSection

tec10:
;
; The critical section is already owned. If it is owned by another thread,
; return FALSE immediately. If it is owned by this thread, we must increment
; the lock count here.
;
        mov     eax, fs:TbClientId+4        ; (eax) == NtCurrentTeb()->ClientId.UniqueThread
        cmp     CsOwningThread[ecx], eax
        jz      tec20                       ; if eq, this thread is already the owner
        xor     eax, eax                    ; set failure status
        YIELD
        stdRET  _RtlTryEnterCriticalSection

tec20:
;
; This thread is already the owner of the critical section. Perform an atomic
; increment of the LockCount and a normal increment of the RecursionCount and
; return success.
;
Lock5:
   lock inc     dword ptr CsLockCount[ecx]
        inc     dword ptr CsRecursionCount[ecx]
        mov     eax, 1
        stdRET  _RtlTryEnterCriticalSection

stdENDP _RtlTryEnterCriticalSection


_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\daytona\makefile.inc ===
!if exist(..\$(TARGET_DIRECTORY).inc)
!include ..\$(TARGET_DIRECTORY).inc
!endif

SERVICES_DIR=$(O)
SERVICES_TAB=$(SERVICES_DIR)\services.tab
SERVICES_STB=..\..\ntos\ke\$(TARGET_DIRECTORY)\services.stb
NTDLL_XTR=$(O)\ntdll.xtr

$(SERVICES_TAB): ..\..\ntos\ke\services.tab
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@

$(O)\usrstubs.obj: \
    $(O)\usrstubs.$(ASM_SUFFIX) $(O)\ntdll.def

$(NTDLL_XTR): $(SERVICES_TAB)
    gensrv -f $(NTDLL_XTR) -s ..\..\ntos\ke $(SERVICES_DIR)

$(O)\usrstubs.$(ASM_SUFFIX): $(SERVICES_TAB) $(SERVICES_STB)
    gensrv -d $(O) -e $(ASM_SUFFIX) $(TARGET_BRACES) -s ..\..\ntos\ke\$(TARGET_DIRECTORY) $(SERVICES_DIR)

$(DLLDEF): ..\ntdlldef.src ..\$(TARGET_DIRECTORY)def.src $(NTDLL_XTR)
    copy ..\ntdlldef.src+..\$(TARGET_DIRECTORY)def.src+$(NTDLL_XTR) $(O)\$(TARGETNAME).pp
    $(TARGET_CPP) /EP $(CDEFINES) $(O)\$(TARGETNAME).pp > $@
    -del $(O)\$(TARGETNAME).pp

..\ntdll.rc: $(PROJECT_ROOT)\published\$(O)\ntstatus.rc $(PROJECT_ROOT)\published\$(O)\ntstatus_MSG00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\amd64\critsect.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    critsect.asm

Abstract:

    This module implements functions to support user mode critical sections.

Author:

    David N. Cutler (davec) 25-Jun-2000

Environment:

    Any mode.

Revision History:

--*/

#include "ntos.h"
#include "ldrp.h"

NTSTATUS
RtlEnterCriticalSection(
    IN PRTL_CRITICAL_SECTION CriticalSection
    )

/*++

Routine Description:

    This function enters a critical section.

Arguments:

    CriticalSection - Supplies a pointer to a critical section.

Return Value:

    STATUS_SUCCESS is returned or a exception can be raised if the wait
    for the resoruce fails.

--*/

{

    ULONG64 SpinCount;
    HANDLE Thread;

    //
    // If the current thread owns the critical section, then increment
    // the lock count and the recursion count and return success.
    //

    Thread = NtCurrentTeb()->ClientId.UniqueThread;
    if (Thread == CriticalSection->OwningThread) {

        ASSERT(CriticalSection->LockCount >= 0);

        InterlockedIncrement(&CriticalSection->LockCount);
        CriticalSection->RecursionCount += 1;
        return STATUS_SUCCESS;
    }

    //
    // If the critical section spin count is nonzero, then spin attempting
    // to enter critical section until the critical section is entered, the
    // spin count reaches zero, or there are waiters for the critical section.
    //

    SpinCount = CriticalSection->SpinCount;
    if (SpinCount != 0) {
        do {

            //
            // If the critical section is free, then attempt to enter the
            // critical section. Otherwise, spin if the spin count is not
            // zero and there are no waiters for the critical section.
            //

            if (CriticalSection->LockCount == - 1) {
                if (InterlockedCompareExchange(&CriticalSection->LockCount,
                                               0,
                                               - 1) == - 1) {
                    CriticalSection->OwningThread = Thread;
                    CriticalSection->RecursionCount = 1;
                    return STATUS_SUCCESS;
                }

            } else if (CriticalSection->LockCount > 0) {
                break;
            }

            SpinCount -= 1;
        } while (SpinCount != 0);
    }

    //
    // Attempt to enter the critical section. If the critical section is not
    // free, then wait for ownership to be granted.
    //

    if (InterlockedIncrement(&CriticalSection->LockCount) != 0) {
        RtlpWaitForCriticalSection(CriticalSection);
    }

    //
    // Set owning thread, initialization the recusrion count, and return
    // success.
    //

    CriticalSection->OwningThread = Thread;
    CriticalSection->RecursionCount = 1;
    return STATUS_SUCCESS;
}

NTSTATUS
RtlLeaveCriticalSection(
    IN PRTL_CRITICAL_SECTION CriticalSection
    )

/*++

Routine Description:

    This function leaves a critical section.

Arguments:

    CriticalSection - Supplies a pointer to a critical section.

Return Value:

   STATUS_SUCCESS is returned.

--*/

{

    //
    // Decrement the recursion count. If the resultant recursion count is
    // zero, then leave the critical section.
    //

    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == CriticalSection->OwningThread);

    if ((CriticalSection->RecursionCount -= 1) == 0) {
        CriticalSection->OwningThread = NULL;
        if (InterlockedDecrement(&CriticalSection->LockCount) >= 0) {
            RtlpUnWaitCriticalSection(CriticalSection);
        }
    }

    return STATUS_SUCCESS;
}

BOOLEAN
RtlTryEnterCriticalSection (
    IN PRTL_CRITICAL_SECTION CriticalSection
    )

/*++

Routine Description:

    This function attempts to enter a critical section without blocking.

Arguments:

    CriticalSection (a0) - Supplies a pointer to a critical section.

Return Value:

    If the critical section was successfully entered, then a value of TRUE
    is returned. Otherwise, a value of FALSE is returned.

--*/

{

    HANDLE Thread;

    //
    // If the current thread owns the critical section, then increment
    // the lock count and the recursion count and return TRUE.
    //

    Thread = NtCurrentTeb()->ClientId.UniqueThread;
    if (Thread == CriticalSection->OwningThread) {

        ASSERT(CriticalSection->LockCount >= 0);

        InterlockedIncrement(&CriticalSection->LockCount);
        CriticalSection->RecursionCount += 1;
        return TRUE;
    }

    //
    // Attempt to enter the critical section. If the attempt is successful,
    // then set the owning thread, initialize the recursion count, and return
    // TRUE. Otherwise, return FALSE.
    //

    if (InterlockedCompareExchange(&CriticalSection->LockCount,
                                   0,
                                   - 1) == - 1) {
        CriticalSection->OwningThread = Thread;
        CriticalSection->RecursionCount = 1;
        return TRUE;

    } else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\amd64\ldrthunk.asm ===
title   "LdrInitializeThunk"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;   ldrthunk.s
;
; Abstract:
;
;   This module implements the thunk for the loader staetup APC routine.
;
; Author:
;
;   David N. Cutler (davec) 25-Jun-2000
;
;  Environment:
;
;    Any mode.
;
;--

include ksamd64.inc

        extrn   LdrpInitialize:proc

        subttl  "Initialize Thunk"
;++
;
; VOID
; LdrInitializeThunk(
;     IN PVOID NormalContext,
;     IN PVOID SystemArgument1,
;     IN PVOID SystemArgument2
;     )
;
; Routine Description:
;
;   This function computes a pointer to the context record on the stack
;   and jumps to the LdrpInitialize function with that pointer as its
;   parameter.
;
; Arguments:
;
;   NormalContext (rcx) - User Mode APC context parameter (ignored).
;
;   SystemArgument1 (rdx) - User Mode APC system argument 1 (ignored).
;
;   SystemArgument2 (r8) - User Mode APC system argument 2 (ignored).
;
; Return Value:
;
;   None.
;
;--

        LEAF_ENTRY LdrInitializeThunk, _TEXT$00

        mov     rcx, rsp                ; set context record address
        jmp     LdrpInitialize          ; finish in common common

        LEAF_END LdrInitializeThunk, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\amd64\ldrctx.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ldrctx.c

Abstract:

    This module contains support for relocating executables.

Author:

    Landy Wang (landyw) 8-Jul-1998

Environment:

    User Mode only

Revision History:

--*/

#include <ntos.h>
#include <ldrp.h>

VOID
LdrpRelocateStartContext (
    IN PCONTEXT Context,
    IN LONG_PTR Diff
    )
/*++

Routine Description:

   This routine relocates the start context to mesh with the
   executable that has just been relocated.

Arguments:

   Context - Supplies a context that needs editing.

   Diff - Supplies the difference from the based address to the relocated
          address.

Return Value:

   None.

--*/
{
    Context->Rax += Diff;
}

VOID
LdrpCorReplaceStartContext (
    IN PCONTEXT Context
    )
/*++

Routine Description:

   This routine replaces the initial address to run by one in mscoree.dll.

Arguments:

   Context - Supplies a context that needs editing.

Return Value:

   None.

--*/
{
    Context->Rax = (ULONG64)CorExeMain;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\emdisp.asm ===
subttl	emdisp.asm - Emulator Dispatch Tables
	page
;
;	 IBM/Microsoft Confidential
;
;	 Copyright (c) IBM Corporation 1987, 1989
;	 Copyright (c) Microsoft Corporation 1987, 1989
;
;	 All Rights Reserved
;
;Revision History:  (also see emulator.hst)
;
;    1/21/92  JWM   Minor modifications for DOSX32 emulator
;    8/23/91  TP    Direct dispatch off of 6-bit opcode
;   10/30/89  WAJ   Added this header.
;
;*******************************************************************************

;*********************************************************************;
;								      ;
;		Dispatch Tables 				      ;
;								      ;
;*********************************************************************;


;   These tables are based upon the layout of the 8087 instructions
;
;      8087 instruction fields:   |escape|MF|Arith|MOD|Op|r/m|disp1|disp2|
;	  field length in bits:       5    2   1    2	3   3	8     8
;
;   Disp1 and Disp2  are optional address bytes present only if MOD <> 11.
;   When (MOD <> 11) r/m describes which regs (SI,DI,BX,BP) are added to
;	Disp1 and Disp2 to calculate the effective address. This form
;	(memory format) is used for Loads, Stores, Compares, and Arithmetic
;   When using memory format MF determines the Type of the Memory operand
;	i.e. Single Real, Double real, Single Integer, or Double Integer
;   Arith is 0 for Arithmetic opetations (and compares), set to 1 otherwise
;   Op mostly determines which type of operation to do though when not in
;	memory format some of that is coded into MF and r/m
;   All of the tables are set up to do a jump based upon one or more of the
;	above fields. The outline for decoding instructions is:
;
;	    IF (memory format) THEN
;	       Assemble Effective Address (using MOD and r/m and EffectiveAddressTab)
;	       Jump through table to operation, using MF, Arith and Op bits
;	    ELSE (Register format)
;	       Jump through table to operation, using MF, Arith and Op bits

	ALIGN	4

;*********************************************************************;
;
; Memory address calculation tables

EA386Tab	label	dword			; Uses |r/m|MOD+1| for indexing
	dd	NoEffectiveAddress
	dd	Exx00			; eax
	dd	Exx01
	dd	Exx10
	dd	NoEffectiveAddress
	dd	Exx00			; ecx
	dd	Exx01
	dd	Exx10
	dd	NoEffectiveAddress
	dd	Exx00			; edx
	dd	Exx01
	dd	Exx10
	dd	NoEffectiveAddress
	dd	Exx00			; ebx
	dd	Exx01
	dd	Exx10
	dd	NoEffectiveAddress
	dd	SIB00			; esp (S-I-B follows)
	dd	SIB01
	dd	SIB10
	dd	NoEffectiveAddress
	dd	Direct386		; ebp (00 = direct addressing)
	dd	Exx01
	dd	Exx10
	dd	NoEffectiveAddress
	dd	Exx00			; esi
	dd	Exx01
	dd	Exx10
	dd	NoEffectiveAddress
	dd	Exx00			; edi
	dd	Exx01
	dd	Exx10

;*********************************************************************;
;
;Opcode dispatching tables
;Indexed by  | op1 | op2 |0 0|  (op1 = MF|Arith)

	public	tOpRegDisp
tOpRegDisp	label	dword
	dd	eFADDtop
	dd	eFMULtop
	dd	eFCOM
	dd	eFCOMP
	dd	eFSUBtop
	dd	eFSUBRtop
	dd	eFDIVtop
	dd	eFDIVRtop

	dd	eFLDreg
	dd	eFXCH
	dd	eFNOP		;UNDONE: also reserved on 387
	dd	eFSTP		;Special form 1
	dd	GroupFCHS	;FCHS,FABS,FTST,FXAM
	dd	GroupFLD1	;FLD1,FLDL2T,FLDL2E,FLDPI,FLDLG2,FLDLN2,FLDZ
	dd	GroupF2XM1	;F2XM1,FYL2X,FPTAN,FPATAN,FXTRACT,FPREM1,FDECSTP,FINCSTP
	dd	GroupFPREM	;FPREM,FYL2XP1,FSQRT,FSINCOS,FRNDINT,FSCALE,FSIN,FCOS

	dd	UNUSED
	dd	UNUSED
	dd	UNUSED
	dd	UNUSED
	dd	UNUSED
	dd	eFUCOMPP	;UNDONE: also reserved on 387
	dd	UNUSED
	dd	UNUSED

	dd	UNUSED
	dd	UNUSED
	dd	UNUSED
	dd	UNUSED
	dd	GroupFENI	;FENI,FDISI,FCLEX,FINIT
	dd	UNUSED
	dd	UNUSED
	dd	UNUSED

	dd	eFADDreg
	dd	eFMULreg
	dd	eFCOM		;Special form  2
	dd	eFCOMP		;Special form  3
	dd	eFSUBRreg
	dd	eFSUBreg
	dd	eFDIVRreg
	dd	eFDIVreg

	dd	eFFREE
	dd	eFXCH		;Special form 4
	dd	eFST
	dd	eFSTP
	dd	eFUCOM
	dd	eFUCOMP
	dd	UNUSED
	dd	UNUSED

	dd	eFADDPreg
	dd	eFMULPreg
	dd	eFCOMP		;Special form 5
	dd	eFCOMPP		;UNDONE: also reserved on 387
	dd	eFSUBRPreg
	dd	eFSUBPreg
	dd	eFDIVRPreg
	dd	eFDIVPreg

	dd	eFFREE		;Special form 6 UNDONE: "and pop stack"?
	dd	eFXCH		;Special form 7
	dd	eFSTP		;Special form 8
	dd	eFSTP		;Special form 9
	dd	eFSTSWax	;UNDONE: also reserved on 387
	dd	UNUSED
	dd	UNUSED
	dd	UNUSED


tOpMemDisp	label	dword
;MF = 00 (32-bit Real), Arith = 0
	dd	eFADD32
	dd	eFMUL32
	dd	eFCOM32
	dd	eFCOMP32
	dd	eFSUB32
	dd	eFSUBR32
	dd	eFDIV32
	dd	eFDIVR32
;MF = 00 (32-bit Real), Arith = 1
	dd	eFLD32
	dd	UNUSED
	dd	eFST32
	dd	eFSTP32
	dd	eFLDENV
	dd	eFLDCW
	dd	eFSTENV
	dd	eFSTCW
;MF = 01 (32-bit Int), Arith = 0
	dd	eFIADD32
	dd	eFIMUL32
	dd	eFICOM32
	dd	eFICOMP32
	dd	eFISUB32
	dd	eFISUBR32
	dd	eFIDIV32
	dd	eFIDIVR32
;MF = 01 (32-bit Int), Arith = 1
	dd	eFILD32
	dd	UNUSED
	dd	eFIST32
	dd	eFISTP32
	dd	UNUSED
	dd	eFLD80
	dd	UNUSED
	dd	eFSTP80
;MF = 10 (64-bit Real), Arith = 0
	dd	eFADD64
	dd	eFMUL64
	dd	eFCOM64
	dd	eFCOMP64
	dd	eFSUB64
	dd	eFSUBR64
	dd	eFDIV64
	dd	eFDIVR64
;MF = 10 (64-bit Real), Arith = 1
	dd	eFLD64
	dd	UNUSED
	dd	eFST64
	dd	eFSTP64
	dd	eFRSTOR
	dd	UNUSED
	dd	eFSAVE
	dd	eFSTSW
;MF = 11 (16-bit Int), Arith = 0
	dd	eFIADD16
	dd	eFIMUL16
	dd	eFICOM16
	dd	eFICOMP16
	dd	eFISUB16
	dd	eFISUBR16
	dd	eFIDIV16
	dd	eFIDIVR16
;MF = 11 (16-bit Int), Arith = 1
	dd	eFILD16
	dd	UNUSED
	dd	eFIST16
	dd	eFISTP16
	dd	eFBLD
	dd	eFILD64
	dd	eFBSTP
	dd	eFISTP64


tGroupFLD1disp	label	dword
	dd	eFLD1
	dd	eFLDL2T
	dd	eFLDL2E
	dd	eFLDPI
	dd	eFLDLG2
	dd	eFLDLN2
	dd	eFLDZ
	dd	UNUSED


tGroupF2XM1disp	label	dword
	dd	eF2XM1
	dd	eFYL2X
	dd	eFPTAN
	dd	eFPATAN
	dd	eFXTRACT
	dd	eFPREM1
	dd	eFDECSTP
	dd	eFINCSTP


tGroupFCHSdisp	label	dword
	dd	eFCHS
	dd	eFABS
	dd	UNUSED
	dd	UNUSED
	dd	eFTST
	dd	eFXAM
	dd	UNUSED
	dd	UNUSED


tGroupFPREMdisp	label	dword
	dd	eFPREM
	dd	eFYL2XP1
	dd	eFSQRT
	dd	eFSINCOS
	dd	eFRNDINT
	dd	eFSCALE
	dd	eFSIN
	dd	eFCOS


tGroupFENIdisp	label	dword
	dd	eFENI
	dd	eFDISI
	dd	eFCLEX
	dd	eFINIT
	dd	eFSETPM
	dd	UNUSED
	dd	UNUSED
	dd	UNUSED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\emdecode.asm ===
subttl	emdecode.asm - Instruction decoding
	page
;***
;emdecode.asm - Instruction decoding
;
;	 Microsoft Confidential
;
;	 Copyright (c) Microsoft Corporation 1991
;
;	 All Rights Reserved
;
;Purpose:
;	Further decoding of instructions done here.
;
;Revision History:
;
;    8/23/91  TP    Rewritten for 32 bits
;
;*******************************************************************************

;On entry, eax = r/m bits * 4.  This is used to jump directly to the
;correct instruction within the group.

GroupFCHS:
	jmp	tGroupFCHSdisp[eax]

GroupFLD1:
	jmp	tGroupFLD1disp[eax]

GroupF2XM1:
	jmp	tGroupF2XM1disp[eax]

GroupFPREM:
	jmp	tGroupFPREMdisp[eax]

GroupFENI:
	jmp	tGroupFENIdisp[eax]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\emfcom.asm ===
subttl  emfcom.asm - Comparison Instructions
	page
;*******************************************************************************
;emfcom.asm - Comparison Instructions
;
;        Microsoft Confidential
;
;        Copyright (c) Microsoft Corporation 1991
;        All Rights Reserved
;
;Purpose:
;       FCOM,FCOMP,FCOMPP,FUCOM,FUCOMP,FUCOMPP,FTST,FXAM instructions
;
;Revision History:
;
; []	09/05/91  TP	Initial 32-bit version.
;
;*******************************************************************************


;*******************************************************************************
;Dispatch table for compare
;
;One operand has been loaded into ecx:ebx:esi ("source"), the other is
;pointed to by edi ("dest").  
;
;Tag of source is shifted.  Tag values are as follows:
.erre   TAG_SNGL        eq      0       ;SINGLE: low 32 bits are zero
.erre   TAG_VALID       eq      1
.erre   TAG_ZERO        eq      2
.erre   TAG_SPCL        eq      3       ;NAN, Infinity, Denormal, Empty
;Any special case routines not found in this file are in emarith.asm
tFcomDisp       label   dword           ;Source (reg)   Dest (*[di] = ST)
        dd      ComDouble               ;single         single
        dd      ComDouble               ;single         double
	dd	ComDestZero		;single		zero
        dd      ComSpclDest             ;single         special
        dd      ComDouble               ;double         single
        dd      ComDouble               ;double         double
        dd      ComDestZero             ;double         zero
        dd      ComSpclDest             ;double         special
        dd      ComSrcZero              ;zero           single
        dd      ComSrcZero              ;zero           double
        dd      ComEqual                ;zero           zero
	dd	ComSpclDest		;zero		special
	dd	ComSpclSource		;special	single
	dd	ComSpclSource		;special	double
	dd	ComSpclSource		;special	zero
	dd	ComBothSpcl		;special	special


EM_ENTRY eFICOMP16
eFICOMP16:
    and		[esp].[OldLongStatus+4],NOT(ConditionCode SHL 16)	;clear C0,C1,C2,C3
	push	offset PopWhenDone
	push	offset ComOpLoaded
	jmp	Load16Int		;Returns to ComOpLoaded

EM_ENTRY eFICOM16
eFICOM16:
    and		[esp].[OldLongStatus+4],NOT(ConditionCode SHL 16)	;clear C0,C1,C2,C3
	push	offset ComOpLoaded
	jmp	Load16Int		;Returns to ComOpLoaded

EM_ENTRY eFICOMP32
eFICOMP32:
    and		[esp].[OldLongStatus+4],NOT(ConditionCode SHL 16)	;clear C0,C1,C2,C3
	push	offset PopWhenDone
	push	offset ComOpLoaded
	jmp	Load32Int		;Returns to ComOpLoaded

EM_ENTRY eFICOM32
eFICOM32:
    and		[esp].[OldLongStatus+4],NOT(ConditionCode SHL 16)	;clear C0,C1,C2,C3
	push	offset ComOpLoaded
	jmp	Load32Int		;Returns to ComOpLoaded

EM_ENTRY eFCOMP32
eFCOMP32:
    and		[esp].[OldLongStatus+4],NOT(ConditionCode SHL 16)	;clear C0,C1,C2,C3
	push	offset PopWhenDone
	push	offset ComOpLoaded
	jmp	Load32Real		;Returns to ComOpLoaded

EM_ENTRY eFCOM32
eFCOM32:
    and		[esp].[OldLongStatus+4],NOT(ConditionCode SHL 16)	;clear C0,C1,C2,C3
	push	offset ComOpLoaded
	jmp	Load32Real		;Returns to ComOpLoaded

EM_ENTRY eFCOMP64
eFCOMP64:
    and		[esp].[OldLongStatus+4],NOT(ConditionCode SHL 16)	;clear C0,C1,C2,C3
	push	offset PopWhenDone
	push	offset ComOpLoaded
	jmp	Load64Real		;Returns to ComOpLoaded

EM_ENTRY eFCOM64
eFCOM64:
    and		[esp].[OldLongStatus+4],NOT(ConditionCode SHL 16)	;clear C0,C1,C2,C3
	push	offset ComOpLoaded
	jmp	Load64Real		;Returns to ComOpLoaded

EM_ENTRY eFUCOMPP
eFUCOMPP:
    and		[esp].[OldLongStatus+4],NOT(ConditionCode SHL 16)	;clear C0,C1,C2,C3
	push	offset ComPop2
	jmp	eFUCOM0

EM_ENTRY eFUCOMP
eFUCOMP:
    and		[esp].[OldLongStatus+4],NOT(ConditionCode SHL 16)	;clear C0,C1,C2,C3
	push	offset PopWhenDone
	jmp	eFUCOM0

EM_ENTRY eFUCOM
eFUCOM:
    and		[esp].[OldLongStatus+4],NOT(ConditionCode SHL 16)	;clear C0,C1,C2,C3
eFUCOM0:	
;esi = pointer to st(i) from instruction field
;edi = [CURstk]
	mov	ecx,EMSEG:[esi].ExpSgn
	mov	ebx,EMSEG:[esi].lManHi
	mov	esi,EMSEG:[esi].lManLo
	mov	dl,40H			;Flag FUCOM - Look for SNAN
	jmp	UComOpLoaded

EM_ENTRY eFCOMPP
eFCOMPP:
    and		[esp].[OldLongStatus+4],NOT(ConditionCode SHL 16)	;clear C0,C1,C2,C3
	push	offset ComPop2
	jmp	eFCOM0

EM_ENTRY eFCOMP
eFCOMP:
    and		[esp].[OldLongStatus+4],NOT(ConditionCode SHL 16)	;clear C0,C1,C2,C3
	push	offset PopWhenDone
	jmp	eFCOM0

EM_ENTRY eFCOM
eFCOM:
    and		[esp].[OldLongStatus+4],NOT(ConditionCode SHL 16)	;clear C0,C1,C2,C3
eFCOM0:
;esi = pointer to st(i) from instruction field
;edi = [CURstk]
	mov	ecx,EMSEG:[esi].ExpSgn
	mov	ebx,EMSEG:[esi].lManHi
	mov	esi,EMSEG:[esi].lManLo

ComOpLoaded:
;	mov	EMSEG:[UpdateCCodes],1
	mov	dl,0			;flag FCOM - Look for any NAN
UComOpLoaded:
	mov     ebp,offset tFcomDisp
	mov	al,cl
	mov     ah,EMSEG:[edi].bTag
	test	ax,ZEROorSPCL * 100H + ZEROorSPCL
	jnz	TwoOpDispatch

;.erre	ComDouble eq $			;Fall into ComDouble

;*********
ComDouble:
;*********
;
;ebx:esi = op1 mantissa
;ecx = op1 sign in bit 15, exponent in high half
;edi = pointer to op2
	mov	eax,EMSEG:[edi].ExpSgn
	and	ax,bSign shl 8		;Keep sign only
	and	cx,bSign shl 8
	cmp	ah,ch			;Are signs the same?
	jnz	StBigger
	cmp	eax,ecx			;Are exponents the same?
	jl	StSmaller
	jg	StBigger
	cmp	EMSEG:[edi].lManHi,ebx	;Compare mantissas
	jnz	MantDif
	cmp	EMSEG:[edi].lManLo,esi	;Set flags for ST - src
	jz	ComEqual
MantDif:
	adc	al,al			;Copy CY flag to bit 0
	rol	ah,1			;Rotate sign to bit 0
	xor	al,ah			;Flip saved CY bit if negative
	mov	EMSEG:[SWcc],al		;Set condition code
	ret

StSmaller:
	not	ah
StBigger:
;ah = sign of ST
;ch = sign of other operand
;ST is bigger if it is positive (smaller if it is negative).
;Use the sign bit directly as the "less than" bit C0.
.erre	C0 eq 1
	shr	ah,7			;Bring sign down to bit 0, clear CY
	mov	EMSEG:[SWcc],ah		;Bit set if ST smaller (negative)
	ret

ComEqual:
	mov	EMSEG:[SWcc],CCequal
	ret



PopWhenDone:
.erre	bTAG_NOPOP eq -1
	inc	cl			;OK to pop?
	jz	ComPopX			;No - had unmasked Invalid Operation

	POPSTret

ComPop2:
.erre	bTAG_NOPOP eq -1
	inc	cl			;OK to pop?
	jz	ComPopX			;No - had unmasked Invalid Operation
	mov	esi,EMSEG:[CURstk]
	mov	EMSEG:[esi].bTag,bTAG_EMPTY
	add	esi,Reg87Len*2
	cmp	esi,ENDstk			;JWM
	je	PopOneOver
	ja	PopTwoOver
	mov	EMSEG:[esi-Reg87Len].bTag,bTAG_EMPTY
	mov	EMSEG:[CURstk],esi
ComPopX:
	ret

PopOneOver:
	mov	EMSEG:[CURstk],BEGstk		;JWM
ifdef NT386
	mov	EMSEG:[INITstk].bTAG,bTAG_EMPTY
else
	mov	EMSEG:[XINITstk].bTAG,bTAG_EMPTY
endif
	ret

PopTwoOver:
	mov	EMSEG:[CURstk],BEGstk+Reg87Len	;JWM
ifdef NT386
	mov	EMSEG:[BEGstk].bTAG,bTAG_EMPTY
else
	mov	EMSEG:[XBEGstk].bTAG,bTAG_EMPTY
endif
	ret

;*******************************************************************************
;Special cases for FCOM/FUCOM.
;These don't share with those in emarith.asm because NANs are treated
;differently.
ComDestZero:
;ST is zero, so Src is bigger if it is positive (smaller if it is negative).
;Use the sign bit directly as the "less than" bit C0.
	not	ch			;C0 is 1 if ST < Src
.erre	C0 eq 1
	shr	ch,7			;Bring sign down to bit 0
	mov	EMSEG:[SWcc],ch		;Bit set if Src smaller (negative)
	ret

ComSrcZero:
;ST is bigger if it is positive (smaller if it is negative).
;Use the sign bit directly as the "less than" bit C0.
	mov	al,EMSEG:[edi].bSgn
.erre	C0 eq 1
	shr	al,7			;Bring sign down to bit 0
	mov	EMSEG:[SWcc],al		;Bit set if ST smaller (negative)
	ret

ComSpclSource:
	cmp	cl,bTAG_NAN
	jz	ComSrcNAN
	cmp	cl,bTAG_INF
	jz	ComDestZero
	cmp	cl,bTAG_DEN
	jz	ComDenormal
;Must be empty
ComEmpty:
	mov	EMSEG:[CURerr],Invalid+StackFlag
	jmp	ComChkMask

ComSrcNAN:
	shl	edx,24			;Move dl to high byte
	test	ebx,edx			;See if we report error with this NAN
ComChkNAN:
	jnz	Incomp
ComInvalid:
	mov	EMSEG:[CURerr],Invalid	;Flag the error
ComChkMask:
	test	EMSEG:[CWmask],Invalid	;Is exception masked?
	jnz	Incomp
	mov	cl,bTAG_NOPOP		;Unmasked, don't pop stack
Incomp:
	mov	EMSEG:[SWcc],CCincomprable
	ret

ComSpclDest:
	mov	al,EMSEG:[edi].bTag
	cmp	al,bTAG_INF
	jz	ComSrcZero
	cmp	al,bTAG_Empty
	jz	ComEmpty
	cmp	al,bTAG_DEN
	jz	ComDenormal
;Must be NAN
ComDestNAN:
	test	EMSEG:[edi].bMan7,dl		;See if we report error with this NAN
	jmp	ComChkNAN

ComBothSpcl:
	mov	al,EMSEG:[edi].bTag
	cmp	cl,bTAG_EMPTY
	jz	ComEmpty
	cmp	al,bTAG_EMPTY
	jz	ComEmpty
	cmp	cl,bTAG_NAN
	jz	ComSrcNAN
	cmp	al,bTAG_NAN
	jz	ComDestNAN
	mov	ah,cl
	cmp	ax,(bTAG_INF shl 8) + bTag_INF	;Are both Infinity?
	jz	ComDouble		;If so, compare their signs
;Must have at least one denormal
ComDenormal:
	or	EMSEG:[CURerr],Denormal
        jmp     ComDouble

;*******************************************************************************

XAM_Unsupported	equ	0
XAM_NAN		equ	C0
XAM_Norm	equ	C2
XAM_Inf		equ	C2+C0
XAM_Zero	equ	C3
XAM_Empty	equ	C3+C0
XAM_Den		equ	C3+C2

tXamTag	label	byte
.erre	TAG_SNGL	eq	$-tXamTag
	db	XAM_Norm		;TAG_SNGL
.erre	TAG_VALID	eq	$-tXamTag
	db	XAM_Norm		;TAG_VALID
.erre	TAG_ZERO	eq	$-tXamTag
	db	XAM_Zero		;TAG_ZERO
.erre	TAG_EMPTY	eq	$-tXamTag
	db	XAM_Empty		;TAG_EMPTY
	db	0
	db	0
	db	0
.erre	TAG_INF 	eq	$-tXamTag
	db	XAM_Inf 		;TAG_INF
	db	0
	db	0
	db	0
.erre	TAG_NAN 	eq	$-tXamTag
	db	XAM_NAN 		;TAG_NAN
	db	0
	db	0
	db	0
.erre	TAG_DEN 	eq	$-tXamTag
	db	XAM_Den 		;TAG_DEN

EM_ENTRY eFXAM
eFXAM:
;edi = [CURstk]
    and		[esp].[OldLongStatus+4],NOT(ConditionCode SHL 16)	;clear C0,C1,C2,C3
	mov	eax,EMSEG:[edi].ExpSgn	;Get sign and tag
	mov	bl,ah			;Save sign
	and	bl,bSign		;Keep only sign bit
	and	eax,0FH			;Save low 4 bits of tag
	mov	al,tXamTag[eax]		;Lookup cond. codes for this tag
.erre	C1 eq 2		;Bit 1
.erre	bSign eq 80H	;Bit 7
	shr	bl,7-1			;Move sign bit to CC C1
	or	al,bl
	mov	EMSEG:[SWcc],al
	ret

;*******************************************************************************

EM_ENTRY eFTST
eFTST:
;edi = [CURstk]
    and		[esp].[OldLongStatus+4],NOT(ConditionCode SHL 16)	;clear C0,C1,C2,C3
	mov	eax,EMSEG:[edi].ExpSgn
	cmp	al,bTAG_ZERO
	jz	ComEqual
	ja	TestSpcl
;Either single or double, non-zero.  Just check sign.
TestSign:
	shr	ah,7			;Bring sign down to bit 0
	mov	EMSEG:[SWcc],ah		;Bit set if negative
	ret

TestSpcl:
	cmp	al,bTAG_INF
	jz	TestSign		;Normal test for Infinity
	cmp	al,bTAG_EMPTY
	jz	ComEmpty
	cmp	al,bTAG_NAN
	jz	ComInvalid
;Must be denormal
	mov	EMSEG:[CURerr],Denormal
	jmp	TestSign
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\emfinit.asm ===
subttl	emfinit.asm - Emulator initialization and FINIT instruction
        page
;*******************************************************************************
;emfinit.asm - Emulator initialization and FINIT instruction
;
;        Microsoft Confidential
;
;	 Copyright (c) Microsoft Corporation 1991
;        All Rights Reserved
;
;Revision History:
;
; []	09/05/91  TP	Initial 32-bit version.
;
;*******************************************************************************


EM_ENTRY eEmulatorInit
EmulatorInit:
EM_ENTRY eFINIT
eFINIT:
	mov	esi,BEGstk
	mov	EMSEG:[CURstk],INITstk
	mov	ecx,Numlev
	xor	eax,eax

EmInitLoop:
	mov	EMSEG:[esi].ExpSgn,bTAG_EMPTY		;Exponent and sign are zero
	mov	EMSEG:[esi].lManHi,eax
	mov	EMSEG:[esi].lManLo,eax

	add	esi, Reg87Len
	loop	EmInitLoop

	mov	EMSEG:[StatusWord],ax			; clear status word
	mov	[esp+4].OldStatus,ax			; clear saved status word.
	mov	EMSEG:[PrevCodeOff],eax
	mov	EMSEG:[PrevDataOff],eax
	mov	EMSEG:[LongControlWord],InitControlWord
	mov	eax,offset Round64near
	mov	EMSEG:[RoundMode],eax			;Address of round routine
	mov	EMSEG:[TransRound],eax			;Address of round routine
	mov	EMSEG:[SavedRoundMode],eax
	mov	EMSEG:[ZeroVector],offset SaveResult
	mov	EMSEG:[Einstall], 1
	ret
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\emf386.asm ===
subttl  emf386.asm - 32 bit Emulator Interrupt Handler
        page
;***
;emf386.asm - 32 bit Emulator Interrupt Handler
;
;        IBM/Microsoft Confidential
;
;        Copyright (c) IBM Corporation 1987, 1989
;        Copyright (c) Microsoft Corporation 1987, 1989
;
;        All Rights Reserved
;
;Purpose:
;       32 bit Emulator Interrupt Handler
;
;Revision History:  (also see emulator.hst)
;
;    1/21/92  JWM   Minor modifications for DOSX32 emulator
;    8/23/91  TP    Reduce to only two decoding steps
;
;*******************************************************************************


;*********************************************************************;
;                                                                     ;
;         Main Entry Point and Address Calculation Procedure          ;
;                                                                     ;
;               80386 version                                         ;
;                                                                     ;
;*********************************************************************;
;
; This routine fetches the 8087 instruction, calculates memory address
; if necessary into ES:ESI and calls a routine to emulate the instruction.
; Most of the dispatching is done through tables. (see comments in CONST)
;
; The instruction dispatching is designed to favor the 386 addressing modes


ifdef _DOS32EXT                 ; JWM
public __astart
__astart:
        mov     eax, 1
        ret

public _Ms32KrnlHandler
_Ms32KrnlHandler:
endif

ifdef   NT386

;
; NPXEmulatorTable is a table read by the Windows/NT kernel in
; order to support the R3 emulator
;
public _NPXEMULATORTABLE
_NPXEMULATORTABLE   label   dword
        dd      offset NpxNpHandler     ; Address of Ring3 Trap7 handler
        dd      offset tRoundMode       ; Address of rounding vector table
endif

public NPXNPHandler
NPXNPHandler:

ifdef  DEBUG
        int     3
endif
        cld                             ; clear direction flag forever

ifdef NT386


;-- bryanwi - 16Oct91 - Hack FP fix, not pointing IDT:7 at this
;   routine for 16bit code is the right thing to do.
;
;   Check to see if we are running on flat SS.  If so, assume things
;   are OK and proceed.  (If a 16bit app loads the flat SS and then
;   does an FP instruction, they're hosed, no skin off our nose.)
;
;   If SS not what we expect, then either (a) a flat apps is *very*
;   confused, or (b) a 16 bit app has hit an FP instuction.  In either
;   case, this emulator is not going to work.  Therefore, raise an exception.
;

        push    ax                      ; use form that will word with any SS
        mov     ax,ss
        or      ax,RPL_MASK
        cmp     ax,(KGDT_R3_DATA OR RPL_MASK)
        pop     ax
        jz      OK_Segment              ; Segments are OK, proceed normally.

        jmp     Around

_DATA   SEGMENT  DWORD USE32 PUBLIC 'DATA'

    align 4

EmerStk         db      1024 dup (?)                    ; *** SaveContext is assumed to be
SaveContext     db  size ContextFrameLength  dup (?)    ; *** at the top of the EmerStk by
SaveException   db  size ExceptionRecordLength dup (?)  ; *** the function @ 13f:0

_DATA   ENDS

Around:
;
;   Trap occured in 16bit code, get to flat environment and raise exception
;

        push    eax                             ; save EAX on old stack
        mov     ax, ds
        push    eax                             ; Save DS on old stack

        mov     ax,(KGDT_R3_DATA OR RPL_MASK)
        mov     ds,ax
    ASSUME  DS:FLAT

        pop     dword ptr [SaveContext.CsSegDs] ; remove ds  from old stack
        pop     dword ptr [SaveContext.CsEax]   ; remove eax from old stack
        pop     dword ptr [SaveContext.CsEip]   ; copy eip   from old stack
        pop     dword ptr [SaveContext.CsSegCs] ; copy cs    from old stack
        pop     dword ptr [SaveContext.CsEflags] ; copy eflag from old stack

        push    dword ptr [SaveContext.CsEFlags] ; restore eflag to old stack
        push    dword ptr [SaveContext.CsSegCs] ; restore cs    to old stack
        push    dword ptr [SaveContext.CsEip]   ; restore eip   to old stack
        mov     dword ptr [SaveContext.CsEsp], esp

;
; Build rest of context frame
;

        mov     dword ptr [SaveContext.CsContextFlags],CONTEXT_CONTROL OR CONTEXT_SEGMENTS OR CONTEXT_INTEGER
        mov     dword ptr [SaveContext.CsEbx], ebx
        mov     dword ptr [SaveContext.CsEcx], ecx
        mov     dword ptr [SaveContext.CsEdx], edx
        mov     dword ptr [SaveContext.CsEsi], esi
        mov     dword ptr [SaveContext.CsEdi], edi
        mov     dword ptr [SaveContext.CsEbp], ebp
        mov     dword ptr [SaveContext.CsSegEs], es
        mov     dword ptr [SaveContext.CsSegFs], fs
        mov     dword ptr [SaveContext.CsSegGs], gs
        mov     dword ptr [SaveContext.CsSegSs], ss

        mov     ss,ax                   ; Switch to new stack
        mov     esp,(OFFSET FLAT:EmerStk) + 1024
    ASSUME  SS:FLAT

;
;   ss: flat, esp -> EmerStk
;

        mov     ax,KGDT_R3_TEB OR RPL_MASK
        mov     fs, ax
        mov     ecx, fs:[TbVdm]
        or      ecx, ecx
        jne     short DoVdmFault

        mov     ecx, offset SaveContext         ; (ecx) -> context record
        mov     edx, offset SaveException       ; (edx) -> exception record

        mov     dword ptr [edx.ErExceptionCode],STATUS_ILLEGAL_FLOAT_CONTEXT
        mov     dword ptr [edx.ErExceptionFlags],0
        mov     dword ptr [edx.ErExceptionRecord],0
        mov     ebx, [ecx.CsEip]
        mov     [edx.ErExceptionAddress],ebx
        mov     [edx.ErNumberParameters],0

;
;   ZwRaiseException(edx=ExceptionRecord, ecx=ContextRecord, TRUE=FirstChance)
;

        stdCall _ZwRaiseException, <edx, ecx, 1>

;
;   If we come back HERE, things are hosed.  We cannot bugcheck because
;   we are in user space, so int-3 and loop forever instead.
;

Forever:
        int     3
        jmp     short Forever

DoVdmFault:
;
; Does the VDM want the fault, or should the instruction be skipped
;
        test    ds:[ecx].VtVdmContext.CsFloatSave.FpCr0NpxState, CR0_EM
        jz      short SkipNpxInstruction

        add     dword ptr [SaveContext.CsEsp], 12   ; remove from old stack

; jump to the dos extender NPX exception handler

;       jmp     far ptr 013fh:0
        db      0eah
        dd      0
        dw      013fh

SkipNpxInstruction:
        mov     ax,(KGDT_R3_DATA OR RPL_MASK)
        mov     es,ax

        stdCall _NpxNpSkipInstruction, <offset SaveContext>

        mov     ebx, dword ptr [SaveContext.CsEbx]
        mov     ecx, dword ptr [SaveContext.CsEcx]
        mov     edx, dword ptr [SaveContext.CsEdx]
        mov     edi, dword ptr [SaveContext.CsEdi]
        mov     esi, dword ptr [SaveContext.CsEsi]
        mov     ebp, dword ptr [SaveContext.CsEbp]
        mov     gs,  dword ptr [SaveContext.CsSegGs]
        mov     fs,  dword ptr [SaveContext.CsSegFs]
        mov     es,  dword ptr [SaveContext.CsSegEs]

        mov     eax, dword ptr [SaveContext.CsEsp]
        mov     ss,  dword ptr [SaveContext.CsSegSs]  ; switch to original stack
        mov     esp, eax

        add     esp, 12                     ; remove eflag, cs, eip
        push    dword ptr [SaveContext.CsEflags]
        push    dword ptr [SaveContext.CsSegCs]
        push    dword ptr [SaveContext.CsEip]
        mov     eax, dword ptr [SaveContext.CsEax]
        mov     ds,  dword ptr [SaveContext.CsSegDs]

        iretd                               ; restore eflag, cs, eip

OK_Segment:
endif


        push    ds                      ; save segment registers

        GetEmData   ds

        push    EMSEG:[LongStatusWord]  ;In case we're saving status
        push    EMSEG:[PrevCodeOff]     ;In case we save environment
;Save registers in order of their index number
        push    edi
        push    esi
        push    ebp
        push    esp
        add     dword ptr [esp],regFlg-regESP   ; adjust to original esp
        push    ebx
        push    edx
        push    ecx
        push    eax

        cmp     EMSEG:[Einstall], 0     ; Make sure emulator is initialized.
        je      InstalEm

EmInstalled:
        mov     edi,[esp].regEIP            ;edi = 387 instruction address
        movzx   edx, word ptr cseg:[edi]    ;dx = esc and opcode

; Check for unmasked errors
        mov     al, EMSEG:[CURerr]      ; fetch errors
        and     al, EMSEG:[ErrMask]
        jnz     short PossibleException

; UNDONE: rip test for FWAIT in final version
        cmp     dl, 9bh                 ;FWAIT?
        je      sawFWAIT

NoException:
Execute387inst:
;Enter here if look-ahead found another 387 instruction
        mov     EMSEG:[PrevCodeOff],edi
        mov     EMSEG:[CurErrCond],0    ;clear error and cond. codes, show busy
        add     edi, 2                  ; point past opcode
        
;CONSIDER:  remove the two instruction below and muck with EA386Tab
;CONSIDER:  to optimize for mem ops instead of reg ops.
        add     dh,40h                  ; No effective address?
        jc      NoEffectiveAddress0     ;  yes, go do instruction
        rol     dh,2                    ; rotate MOD field next to r/m field
        mov     bl,dh
        and     ebx,1FH                 ; Mask to MOD and r/m fields
MemModeDispatch:                        ;Label for debugging
        jmp     EA386Tab[4*ebx]


InstalEm:
        call    EmulatorInit
        mov     edi,DefaultControlWord  ; Default mode to start in
        mov     eax, edi
        call    SetControlWord          ; Set it
        mov     EMSEG:[LongControlWord], edi    ; reset reserved bits
        jmp     EmInstalled

; ************************

;
; We are about to execute a new FP instruction and there is an
; unmasked expcetion.  Check to see if the new FP instruction is
; a "no wait" instruction.   If so, let it proceede; otherwise, raise
; the exception.
;

PossibleException:
        cmp     edx, 0E3DBh             ; if fninit, no exception
        je      short NoException

        cmp     edx, 0E2DBh             ; if fnclex, no exception
        je      short NoException

        cmp     edx, 0E0DFh             ; if "fnstsw ax", no exception
        je      short NoException

        cmp     dl, 0D9h                ; possible encoding for fnstenv or fnstcw?
        je      short pe20              ; yes, check mod r/m
        cmp     dl, 0DDh                ; possible encoding for fnsave or fnstsw?
        jne     short pe30

pe20:   mov     bl, dh                  ; bl = op2
        shr     bl, 3
        and     bl, 7                   ; bl = mod r/m
        cmp     bl, 6                   ; is it a 6 or 7?
        jnc     short NoException       ; yes, no exception

pe30:
        jmp     CommonExceptions        ; unmasked exception is pending, raise it

; ************************



;       386 address modes

;       SIB does not handle SS overrides for ebp

SIB     macro   modval
        local   SIBindex,SIBbase

        movzx   ebx,byte ptr cseg:[edi] ; ebx = SIB field
        inc     edi                     ; bump past SIB field
        mov     eax,ebx
        and     al,7                    ; mask down to base register

if      modval eq 0
        cmp     al,5                    ; base = ebp
        jne     short SIBbase           ;   yes - get base register value
        mov     eax,cseg:[edi]          ; eax = disp32
        add     edi,4                   ; bump past displacement
        jmp     SIBindex                ; Added to support bbt, 
                                        ;   replacing    SKIP    3,SIBindex
endif

SIBbase:
        mov     eax,[esp+4*eax]         ; eax = base register value

SIBindex:
        mov     [esp].regESP,0          ; no esp indexing allowed
        mov     cl,bl
        shr     cl,6                    ; cl = scale factor
        and     bl,7 shl 3              ; ebx = 8 * index register
        shr     bl,1
        mov     esi,[esp+1*ebx]         ; esi = index register value
        shl     esi,cl                  ; esi = scaled index register value
        add     esi,eax                 ; esi = SIB address value
        endm


        ALIGN   4

SIB00:
        SIB     00                      ; decode SIB field
        jmp     CommonMemory

        ALIGN   4

SIB01:
        SIB     01                      ; decode SIB field
        movsx   eax,byte ptr cseg:[edi]
        inc     edi
        add     esi,eax
        jmp     short CommonMemory

        ALIGN   4

SIB10:
        SIB     10                      ; decode SIB field
        mov     eax,cseg:[edi]
        add     edi,4
        add     esi,eax
        jmp     short CommonMemory


;       386 single register addressing

        ALIGN   4

Exx00:
        and     bl,7 shl 2              ; mask off mod bits
        mov     esi,[esp+1*ebx]
        jmp     short CommonMemory

        ALIGN   4

Exx01:
        and     bl,7 shl 2              ; mask off mod bits
        mov     esi,[esp+1*ebx]
        movsx   eax,byte ptr cseg:[edi]
        inc     edi
        add     esi,eax
        jmp     short CommonMemory

        ALIGN   4

Exx10:
        and     bl,7 shl 2              ; mask off mod bits
        mov     esi,[esp+1*ebx]
        add     esi,cseg:[edi]
        add     edi,4
        jmp     short CommonMemory


;       386 direct addressing

        ALIGN   4

Direct386:
        mov     esi,cseg:[edi]
        add     edi,4

CommonMemory:
        MOV     [esp].regEIP,edi        ; final return offset


; At this point ESI = memory address, dx = |Op|r/m|MOD|escape|MF|Arith|
; Current format of opcode and address mode bytes (after rol dh,2)
;
;  7 6 5 4 3 2 1 0
; |1 1 0 1 1| op1 |   dl
;
;  7 6 5 4 3 2 1 0
; | op2 | r/m |mod|   dh
;
;op1 and op2 fields together make the FP opcode

        rol     dx,5                    ; dl = | op1 | op2 |? ?|
        and     edx,0FCH                ;Keep only op1 & op2 bits
        push    offset EMLFINISH
        mov     edi,EMSEG:[CURstk]
MemOpDisp:                              ;Debugging label
;edi = [CURstk]
        jmp     tOpMemDisp[edx]


        ALIGN   4


NoEffectiveAddress0:
        rol     dh,2
NoEffectiveAddress:                     ; Either Register op or Miscellaneous
        mov     [esp].regEIP,edi        ; final return offset

;Current format of opcode and address mode bytes (after rol dh,2)
;
;  7 6 5 4 3 2 1 0
; |1 1 0 1 1| op1 |   dl
;
;  7 6 5 4 3 2 1 0
; | op2 | r/m |mod|   dh
;
;op1 and op2 fields together make the FP opcode

        mov     al,dh                   ;Save r/m bits (contains reg. no.)
        rol     dx,5                    ; dl = | op1 | op2 |? ?|
        and     edx,0FCH                ;Keep only op1 & op2 bits
        push    offset EMLFINISH
        and     eax,7 shl 2             ;Mask to register number * 4
        mov     edi,EMSEG:[CURstk]
        lea     esi,[2*eax+eax]         ;Register no. * 12
        add     esi,edi
        cmp     esi,ENDstk              ;Run past end?
        jae     RegWrap
RegOpDisp:                              ;Debugging label
;eax = r/m bits * 4
;esi = FP register address
;edi = [CURstk]
        jmp     tOpRegDisp[edx]

        ALIGN   4
RegWrap:
        sub     esi,ENDstk - BEGstk     ;Wrap around    JWM
RegOpDispWrap:                          ;Debugging label
        jmp     tOpRegDisp[edx]


SawFwait:
        inc     edi                     ; bump past FWAIT
        mov     [esp].regEIP,edi        ; final return offset
        mov     EMSEG:[CURErr],0        ; clear current error and cond. codes

; return from routine;  restore registers and return

        align   4
EMLFINISH:
; check for errors
        mov     al, EMSEG:[CURerr]      ; fetch errors
        or      al, EMSEG:[SWerr]
        mov     EMSEG:[SWerr],al        ; set errors in sticky error flag
        and     al,EMSEG:[ErrMask]
        jnz     CommonExceptions

ifdef TRACENPX
        jmp     CommonExceptions
endif

if DBG eq 0

;
; On a free build, look ahead to next instruction
;

;09BH is FWAIT - just skip it
;0D8H - 0DFH is 387 instruction, emulate it
        mov     edi,[esp].regEIP        ;edi = 387 instruction address
        mov     dx,cseg:[edi]
        cmp     dl,09BH                 ;FWAIT?
        jz      short SawFwait
        sub     dl,0D8H
        cmp     dl,8
        jb      ReExecute
endif
        mov     ebx,[esp].[OldLongStatus]
        and		ebx,LongSavedFlags		;preserve condition codes, error flags
        or		EMSEG:[LongStatusWord],ebx	;merge saved status word, condition codes
        
        pop     eax
        pop     ecx
        pop     edx
        pop     ebx
        add     esp,4                   ; toss esp value
        pop     ebp
        pop     esi
        pop     edi
        add     esp,8                   ;toss old PrevCodeOff and StatusWord
        mov     EMSEG:[CURerr],Summary  ;Indicate we are not busy
        pop     ds
        error_return                    ; common exit sequence

ReExecute:
        mov     eax,EMSEG:[LongStatusWord]
        mov     ebx,[esp].[OldLongStatus]
        and		ebx,LongSavedFlags		;preserve condition codes, error flags
        or		eax,ebx					;merge saved status word, condition codes
        mov     [esp].OldLongStatus,eax
        mov     eax,EMSEG:[PrevCodeOff]
        mov     [esp].OldCodeOff,eax
        lea		eax,[esp+regFlg+4]		;must restore "saved" esp
        mov		[esp].RegEsp,eax
        jmp     Execute387inst
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\emerror.asm ===
page    ,132
        subttl  emerror.asm - Emulator error handler
;***
;emerror.asm - Emulator error handler
;
;        Microsoft Confidential
;
;        Copyright (c) Microsoft Corporation 1987, 1991
;
;        All Rights Reserved
;
;Purpose:
;       Emulator error handler
;
;Revision History:  (also see emulator.hst)
;
;   10/30/89  WAJ   Added this header.
;   11/15/89  WAJ   Major changes for Dos32RaiseExcpetion().
;   12/01/89  WAJ   Now set cbExceptionInfo correctly.
;   02/08/90  WAJ   Fixed GP fault in 32 bit exception handler.
;   09/03/91  JWM   Modified entry/exit sequence for DOSX32.
;   02/15/92  JWM   Adapted for NT.
;
;*******************************************************************************

ifdef   _DOS32EXT
include except32.inc
endif

;***    error_return - return to user code (regardless of error)
;
;       This macro returns to user code.  It goes to some lengths
;       to restore the flags on the instruction immediately before
;       the return so that any pending trace trap will be
;       acknowledged immediately after the retfd (and before the
;       next user instruction) instead of after the instruction
;       following the return as would be the case if we returned
;       using iretd.
;
;       ENTRY   ((SS:ESP)) = user's EAX
;               ((SS:ESP)+4) = return EIP
;               ((SS:ESP)+8) = return CS
;               ((SS:ESP)+12) = user's EFLAGS
;       EXIT    return to user program, above arguments
;               popped off stack, user's EAX and EFLAGS
;               restored.

error_return    macro   noerror
ifdef   _DOS32EXT
        sti                                     ; JWM, 9/3/91
        push    dword ptr [esp+8]               ; JWM, 9/6/91
        popfd                                   ; JWM, 9/6/91
endif                                           ; DOS32EXT

ifdef NT386
if DBG
        push    dword ptr [esp+8]               ; On checked build, allow
        popfd                                   ; single step to work
endif
endif
        iretd
        endm


TESTif  macro   nam
        mov     bl,err&nam      ; default error number
   if (nam ge 100h)
        test    ah,nam/256
   else ;not (nam ge 100h)
        test    al,nam
   endif ;(nam ge 100h)
        JSNZ    signalerror
        endm

EM_ENTRY eCommonExceptions
CommonExceptions:
        mov     ebx,[esp].[OldLongStatus]
        and		ebx,LongSavedFlags		;preserve condition codes, error flags
        or		EMSEG:[LongStatusWord],ebx					;merge saved status word, condition codes
        pop     eax
        pop     ecx
        pop     edx
        pop     ebx
        add     esp,4                   ; toss esp value
        pop     ebp
        pop     esi
        pop     edi
        add     esp,8                   ;toss old PrevCodeOff and StatusWord
        pop     ds
        call    Emexcept
        error_return    noerror

ifdef _DOS32EXT

EmExcept PROC C, OldEIP:DWORD, OldCS:DWORD, OldFlags:DWORD

LOCAL   SSAR:DWORD
LOCAL   ec:_DX32_CONTEXT

    ;*
    ;*  Set up SS access rights.
    ;*

        push    ds
        mov     [ec.R_Eax], eax
        GetEmData   ds,ax

        mov     eax, ss
        lar     eax, eax
        mov     [SSAR], eax

    ;*
    ;*  Fill in ExceptionContext structure.
    ;*


        mov     [ec.NPXContextFlags], NPX_CONTEXT_FULL
        mov     [ec.R_Edi], edi
        mov     [ec.R_Esi], esi

        mov     eax, [ebp]
        mov     [ec.R_Ebp], eax

        lea     eax, [OldFlags+4]
        mov     [ec.R_Esp], eax

        mov     [ec.R_Ebx], ebx
        mov     [ec.R_Edx], edx
        mov     [ec.R_Ecx], ecx

        mov     eax, EMSEG:[PrevCodeOff]

        mov     [ec.R_Eip], eax
        mov     eax, [OldFlags]
        mov     [ec.EFlags], eax

        mov     eax, [OldCS]
        movzx   eax,ax
        mov     [ec.SegCs], eax
        mov     ax,ss
        movzx   eax,ax
        mov     [ec.SegSs], eax

        pop     eax
        movzx   eax,ax
        mov     [ec.SegDs], eax         ; ds was pushed on entry.

        mov     ax,es
        movzx   eax,ax
        mov     [ec.SegEs], eax

        mov     ax,fs
        movzx   eax,ax
        mov     [ec.SegFs], eax

        mov     ax,gs
        movzx   eax,ax
        mov     [ec.SegGs], eax

        lea     esi, [ec]
        add     esi, 4

        push    ebp
        call    SaveState
        pop     ebp

        lea     eax, [ec]
        push    ds
        push    es

        mov     bx, seg FLAT:CURstk
        mov     ds, ebx
        mov     es, ebx
        push    eax

        call    DOS32RAISEEXCEPTION

        add     esp, 4

        pop     es
        pop     ds

RaiseExceptRet:
        or      eax, eax
        JZ      ExceptNotHandled

    ;*
    ;* Copy new flags, cs, eip to new stack.
    ;*

        mov     ds, [ec.SegSs]
        mov     esi, [ec.R_Esp]     ; ds:esi == new ss:esp

        mov     eax, [ec.Eflags]            ; set up iretd frame
        mov     [esi-4], eax

        mov     eax, [ec.SegCs]
        mov     [esi-8], eax

        mov     eax, [ec.R_Eip]
        mov     [esi-12], eax

    ;*
    ;*  Put new stack pointer on stack.
    ;*

        push    ds
        sub     esi, 12
        push    esi

    ;*
    ;*  Reset other registers.
    ;*

        mov     edi, [ec.R_Edi]
        mov     esi, [ec.R_Esi]
        mov     ebx, [ec.R_Ebx]
        mov     edx, [ec.R_Edx]
        mov     ecx, [ec.R_Ecx]
        mov     eax, [ec.R_Eax]
        mov     ds, [ec.SegDs]
        mov     es, [ec.SegEs]
        mov     fs, [ec.SegFs]
        mov     gs, [ec.SegGs]

        mov     ebp, [ec.R_Ebp]    ; must do this last.

        lss     esp, fword ptr [esp] ; reset ss:esp

        sti                             ; JWM, 9/3/91
        push    [esp+8]                 ; JWM, 9/6/91
        popfd                           ; JWM, 9/6/91

        iretd                       ; reset flags, cs, eip

ExceptNotHandled:
EmExcept        ENDP

endif                   ; ifdef _DOS32EXT

ifdef NT386

ISIZE                   equ     4
ISizeEC                 equ     (ContextFrameLength + ISIZE - 1) and (not (ISIZE - 1))
ISizeExceptStruct       equ     (ExceptionRecordLength + ISIZE - 1) and (not (ISIZE - 1))

ec_off          EQU     4+ISizeEc
estruct_off     EQU     ec_off+ISizeExceptStruct

SSAR            EQU     <[ebp][-4]>
ec              EQU     <[ebp][-ec_off]>
eStruct         EQU     <[ebp][-estruct_off]>

OldEIP          EQU     <ebp+8>
OldCS           EQU     <ebp+12>
OldFlags        EQU     <ebp+16>


EmExcept PROC   NEAR

        push    ebp
        mov     ebp,esp
        sub     esp,estruct_off


    ;*
    ;*  Set up SS access rights.
    ;*

        push    ds
        mov     [ec.ctx_RegEax], eax
        GetEmData   ds,ax

        mov     eax, ss
        lar     eax, eax
        mov     [SSAR], eax

    ;*
    ;*  Fill in ExceptionContext structure.
    ;*


        mov     dword ptr [ec.ContextFlags], NPX_CONTEXT_FULL
        mov     dword ptr [ec.ctx_Cr0NpxState], CR0_EM
        mov     [ec.ctx_RegEdi], edi
        mov     [ec.ctx_RegEsi], esi

        mov     eax, [ebp]
        mov     [ec.ctx_RegEbp], eax

        lea     eax, [OldFlags+4]
        mov     [ec.ctx_RegEsp], eax

        mov     [ec.ctx_RegEbx], ebx
        mov     [ec.ctx_RegEdx], edx
        mov     [ec.ctx_RegEcx], ecx

        mov     eax, [OldEIP]

        mov     [ec.ctx_RegEip], eax
        mov     eax, [OldFlags]
        mov     [ec.ctx_EFlags], eax

        mov     eax, [OldCS]
        movzx   eax,ax
        mov     [ec.ctx_SegCs], eax
        mov     ax,ss
        movzx   eax,ax
        mov     [ec.ctx_SegSs], eax

        pop     eax
        movzx   eax,ax
        mov     [ec.ctx_SegDs], eax             ; ds was pushed on entry.

        mov     ax,es
        movzx   eax,ax
        mov     [ec.ctx_SegEs], eax

        mov     ax,fs
        movzx   eax,ax
        mov     [ec.ctx_SegFs], eax

        mov     ax,gs
        movzx   eax,ax
        mov     [ec.ctx_SegGs], eax

        lea     esi, [ec]
        add     esi, ctx_env

        or      EMSEG:[StatusWord], 8000H		; set 'busy' bit
        or      EMSEG:[SWerr], Summary                  ; set Summary bit
        or      EMSEG:[CURerr], Summary

        mov     cl, EMSEG:[ErrMask]
        push    ecx
        push    ebp
        call    SaveState
        pop     ebp
        pop     ecx

        call    GetEMSEGStatusWord                      ; EAX = status word
        test    al, cl                          ; test status word against mask
        jne     short Err00

ifdef TRACENPX
        mov     edx, 0C1020304h                 ; Raise bogus exception code, to trace with
        jmp     short Err50
endif
        mov     al, Invalid

;
; According to the floating error priority, we test what is the cause of
; the NPX error and raise an appropriate exception.
;

Err00:
        test    al, Invalid                     ; Invalid Op?
        jz      short Err10                     ; No, go check next

        mov     edx, XCPT_FLOAT_INVALID_OPERATION
        test    al, StackFlag                   ; Stack fault?
        jz      short Err50                     ; No, go raise invalid op
        mov     edx, XCPT_FLOAT_STACK_CHECK
        jmp     short Err50                     ; Go raise stack fault

Err10:  mov     edx, XCPT_FLOAT_DIVIDE_BY_ZERO
        test    al, ZeroDivide
        jnz     short Err50
        mov     edx, XCPT_FLOAT_DENORMAL_OPERAND
        test    al, Denormal
        jnz     short Err50
        mov     edx, XCPT_FLOAT_OVERFLOW
        test    al, Overflow
        jnz     short Err50
        mov     edx, XCPT_FLOAT_UNDERFLOW
        test    al, Underflow
        jnz     short Err50
        mov     edx, XCPT_FLOAT_INEXACT_RESULT

Err50:  mov     [eStruct.ExceptionNum], edx

        xor     eax,eax
        mov     [eStruct.fHandlerFlags], eax
        mov     [eStruct.NestedExceptionReportRecord], eax
        mov     dword ptr [eStruct.CParameters], 1      ; GeorgioP convention
        mov     [eStruct.ErExceptionInformation], eax   ; GeorgioP convention

        mov     eax, EMSEG:[PrevCodeOff]
        mov     [eStruct.ExceptionAddress], eax

        lea     edx, [eStruct]

        lea     eax, [ec]
        push    ds
        push    es


;TRUE, this is a first-chance exception

        stdCall _NtRaiseException,<edx, eax, 1>
        stdCall _RtlRaiseStatus, <eax>

        pop     es
        pop     ds

RaiseExceptRet:
        or      eax, eax
        JZ      ExceptNotHandled

    ;*
    ;* Copy new flags, cs, eip to new stack.
    ;*

        mov     ds, [ec.ctx_SegSs]
        mov     esi, [ec.ctx_RegEsp]        ; ds:esi == new ss:esp

        mov     eax, [ec.ctx_Eflags]        ; set up iretd frame
        mov     [esi-4], eax

        mov     eax, [ec.ctx_SegCs]
        mov     [esi-8], eax

        mov     eax, [ec.ctx_RegEip]
        mov     [esi-12], eax

    ;*
    ;*  Put new stack pointer on stack.
    ;*

        push    ds
        sub     esi, 12
        push    esi

    ;*
    ;*  Reset other registers.
    ;*

        mov     edi, [ec.ctx_RegEdi]
        mov     esi, [ec.ctx_RegEsi]
        mov     ebx, [ec.ctx_RegEbx]
        mov     edx, [ec.ctx_RegEdx]
        mov     ecx, [ec.ctx_RegEcx]
        mov     eax, [ec.ctx_RegEax]
        mov     ds, [ec.ctx_SegDs]
        mov     es, [ec.ctx_SegEs]
        mov     fs, [ec.ctx_SegFs]
        mov     gs, [ec.ctx_SegGs]

        mov     ebp, [ec.ctx_RegEbp]    ; must do this last.

        lss     esp, fword ptr [esp] ; reset ss:esp

        sti                             ; JWM, 9/3/91
        push    [esp+8]                 ; JWM, 9/6/91
        popfd                           ; JWM, 9/6/91

        iretd                       ; reset flags, cs, eip

ExceptNotHandled:
EmExcept        ENDP

endif                   ; ifdef NT386

        int 3	                ; Added For BBT, a return here is needed or BBT
        ret	                ; has a flow problem.
ifdef  DEBUG

lab PageFault
        mov     al, byte ptr cs:[iax]
        ret
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\emfmisc.asm ===
subttl  emfmisc.asm - FABS, FCHS, FFREE, FXCH
        page
;*******************************************************************************
;emfmisc.asm - FABS, FCHS, FFREE, FXCH
;
;        Microsoft Confidential
;
;	 Copyright (c) Microsoft Corporation 1991
;        All Rights Reserved
;
;Purpose:
;       FABS, FCHS, FFREE, FXCH instructions
;Inputs:
;	edi = [CURstk]
;	esi = pointer to st(i) from instruction field
;
;Revision History:
;
; []	09/05/91  TP	Initial 32-bit version.
;
;*******************************************************************************


;******
EM_ENTRY eFABS
eFABS:
;******
	cmp	EMSEG:[edi].bTag,bTAG_EMPTY
	jz	StackError		;in emarith.asm
	mov	EMSEG:[edi].bSgn,0		;Turn sign bit off
	ret

;******
EM_ENTRY eFCHS
eFCHS:
;******
	cmp	EMSEG:[edi].bTag,bTAG_EMPTY
	jz	StackError		;in emarith.asm
	not	EMSEG:[edi].bSgn		;Flip the sign
	ret

;******
EM_ENTRY eFFREE
eFFREE:
;******
	mov	EMSEG:[esi].bTag,bTAG_EMPTY
	ret

;******
EM_ENTRY eFXCH
eFXCH:
;******
	cmp	EMSEG:[esi].bTag,bTAG_EMPTY
	jz	XchDestEmpty
XchgChkSrc:
	cmp	EMSEG:[edi].bTag,bTAG_EMPTY
	jz	XchSrcEmpty
DoSwap:
;Swap [esi] with [edi]
	mov	eax,EMSEG:[edi]
	xchg	eax,EMSEG:[esi]
	mov	EMSEG:[edi],eax
	mov	eax,EMSEG:[edi+4]
	xchg	eax,EMSEG:[esi+4]
	mov	EMSEG:[edi+4],eax
	mov	eax,EMSEG:[edi+8]
	xchg	eax,EMSEG:[esi+8]
	mov	EMSEG:[edi+8],eax
	ret

XchDestEmpty:
	call	ReturnIndefinite	;in emarith.asm - ZF set if unmasked
	jnz	XchgChkSrc		;Continue if masked
	ret

XchSrcEmpty:
	xchg	edi,esi			;pass pointer in esi
	call	ReturnIndefinite	;in emarith.asm - ZF set if unmasked
	xchg	edi,esi
	jnz	DoSwap			;Continue if masked
	ret
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\emfadd.asm ===
subttl  emfadd.asm - Addition and Subtraction
	page
;*******************************************************************************
;	 Copyright (c) Microsoft Corporation 1991
;	 All Rights Reserved
;
;emfadd.asm - long double add and subtract
;	by Tim Paterson
;
;Purpose:
;	Long double add/subtract.
;Outputs:
;	Jumps to [RoundMode] to round and store result.
;
;Revision History:
;
; []	09/05/91  TP	Initial 32-bit version.
;
;*******************************************************************************

;*******************************************************************************
; Dispatch for Add/Sub/Subr
;
; Signs are passed in dx:
;       xor source sign with dl
;       xor dest sign with dh
;
;One operand has been loaded into ecx:ebx:esi ("source"), the other is
;pointed to by edi ("dest").  
;
;Tag of source is shifted.  Tag values are as follows:
.erre   TAG_SNGL        eq      0       ;SINGLE: low 32 bits are zero
.erre   TAG_VALID       eq      1
.erre   TAG_ZERO        eq      2
.erre   TAG_SPCL        eq      3       ;NAN, Infinity, Denormal, Empty
;Any special case routines not found in this file are in emarith.asm
tFaddDisp	label	dword		;Source (reg)	Dest (*[di])
	dd	AddDouble		;single		single
	dd	AddDouble		;single		double
	dd	AddSourceSign		;single		zero
	dd	AddSpclDest		;single		special
	dd	AddDouble		;double		single
	dd	AddDouble		;double		double
	dd	AddSourceSign		;double		zero
	dd	AddSpclDest		;double		special
	dd	AddDestSign		;zero		single
	dd	AddDestSign		;zero		double
	dd	AddZeroZero		;zero		zero
	dd	AddSpclDest		;zero		special
	dd	AddSpclSource		;special	single
	dd	AddSpclSource		;special	double
	dd	AddSpclSource		;special	zero
	dd	TwoOpBothSpcl		;special	special
	dd	AddTwoInf		;Two infinities

EM_ENTRY eFISUB16
eFISUB16:
        call    Load16Int
        mov     dx,bSign                ;Change sign of source
        jmp     AddSetResult

EM_ENTRY eFISUBR16
eFISUBR16:
        call    Load16Int
        mov     dx,bSign shl 8          ;Change sign of dest
        jmp     AddSetResult

EM_ENTRY eFIADD16
eFIADD16:
        call    Load16Int
        xor     edx,edx                 ;Both signs positive
        jmp     AddSetResult

EM_ENTRY eFISUB32
eFISUB32:
        call    Load32Int
        mov     dx,bSign                ;Change sign of source
        jmp     AddSetResult

EM_ENTRY eFISUBR32
eFISUBR32:
        call    Load32Int
        mov     dx,bSign shl 8          ;Change sign of dest
        jmp     AddSetResult

EM_ENTRY eFIADD32
eFIADD32:
        call    Load32Int
        xor     edx,edx                 ;Both signs positive
        jmp     AddSetResult

EM_ENTRY eFSUB32
eFSUB32:
        call    Load32Real
        mov     dx,bSign                ;Change sign of source
        jmp     AddSetResult

EM_ENTRY eFSUBR32
eFSUBR32:
        call    Load32Real
        mov     dx,bSign shl 8          ;Change sign of dest
        jmp     AddSetResult

EM_ENTRY eFADD32
eFADD32:
        call    Load32Real
        xor     edx,edx                 ;Both signs positive
        jmp     AddSetResult

EM_ENTRY eFSUB64
eFSUB64:
        call    Load64Real
        mov     dx,bSign                ;Change sign of source
        jmp     AddSetResult

EM_ENTRY eFSUBR64
eFSUBR64:
        call    Load64Real
        mov     dx,bSign shl 8          ;Change sign of dest
        jmp     AddSetResult

EM_ENTRY eFADD64
eFADD64:
        call    Load64Real
        xor     edx,edx                 ;Both signs positive
        jmp     AddSetResult


PolyAddDouble:
;This entry point is used by polynomial evaluator.
;It checks the operand in registers for zero, and doesn't require
;signs to be set up in dx.
;
;op1 mantissa in ebx:esi, exponent in high ecx, sign in ch bit 7, tag in cl
;edi = pointer to op2 in ds
	xor	edx,edx			;Addition
	cmp	cl,bTAG_ZERO		;Adding to zero?
        jnz     AddDouble
;Number in registers is zero, so just return value from memory.
        mov     ecx,EMSEG:[edi].ExpSgn
        mov     ebx,EMSEG:[edi].lManHi
        mov     esi,EMSEG:[edi].lManLo
        ret

EM_ENTRY eFSUBPreg
eFSUBPreg:
        push    offset PopWhenDone

EM_ENTRY eFSUBreg
eFSUBreg:
        xchg    esi,edi

EM_ENTRY eFSUBtop
eFSUBtop:
        mov     dx,bSign                ;Change sign of source
        jmp     AddHaveSgn

EM_ENTRY eFSUBRPreg
eFSUBRPreg:
        push    offset PopWhenDone

EM_ENTRY eFSUBRreg
eFSUBRreg:
        xchg    esi,edi

EM_ENTRY eFSUBRtop
eFSUBRtop:
        mov     dx,bSign shl 8          ;Change sign of dest
        jmp     AddHaveSgn


InsignifAdd:
	mov	eax,1			;Set sticky bit
	shl	ch,1			;Get sign, CY set IFF subtracting mant.
	jnc	ReturnOp1
	sub	esi,eax			;Subtract 1 from mantissa
	sbb	ebx,0
	neg	eax
ReturnOp1:
;ebx:esi:eax = normalized unrounded mantissa
;high half of ecx = exponent
;high bit of ch = sign
	jmp	EMSEG:[RoundMode]

EM_ENTRY eFADDPreg
eFADDPreg:
        push    offset PopWhenDone

EM_ENTRY eFADDreg
eFADDreg:
        xchg    esi,edi

EM_ENTRY eFADDtop
eFADDtop:
        xor     edx,edx                 ;Both signs positive
AddHaveSgn:
        mov     ecx,EMSEG:[esi].ExpSgn
        mov     ebx,EMSEG:[esi].lManHi
        mov     esi,EMSEG:[esi].lManLo
AddSetResult:
        mov     ebp,offset tFaddDisp
        mov     EMSEG:[Result],edi            ;Save result pointer
        mov     al,cl
        mov     ah,EMSEG:[edi].bTag
        test    ax,ZEROorSPCL * 100H + ZEROorSPCL
        jnz     TwoOpDispatch

;.erre   AddDouble eq $                  ;Fall into AddDouble

;*********
AddDouble:
;*********
;
;op1 mantissa in ebx:esi, exponent in high ecx, sign in ch bit 7
;dl = sign change for op1
;dh = sign change for op2
;edi = pointer to op2

	xor	ch,dl			;Flip sign if subtracting
	mov	eax,EMSEG:[edi].ExpSgn
	xor	ah,dh			;Flip sign if subtracting
	mov	edx,EMSEG:[edi].lManHi
	mov	edi,EMSEG:[edi].lManLo

AddDoubleReg:
;op1 mantissa in ebx:esi, exponent in high ecx, sign in ch bit 7
;op2 mantissa in edx:edi, exponent in high eax, sign in ah bit 7

	cmp	eax,ecx			;Compare exponents
.erre	TexpBias eq 0			;Not biased, use signed jump
	jle	short HavLg		;op1 is larger, we have the right order
	xchg	esi,edi
	xchg	ebx,edx
	xchg	eax,ecx
HavLg:
;Larger in ebx:esi.  Note that if the exponents were equal, things like
;the sign bit or tag may have determined which is "larger".  It doesn't
;matter which is which if the exponents are equal, however.
	and	ah,80H			;Keep sign bit
	sar	ch,1			;Extend sign into bit 6 of byte
	xor	ch,ah			;See if signs are the same
	xor	ax,ax			;Clear out sign and tag
	neg	eax			;ax still 0
	add	eax,ecx			;Get exponent difference
	shr	eax,16			;Bring exp. difference down to low end
	jz	short Aligned
	cmp	eax,64+1		;Is difference in range?
;CONSIDER: tell me again why 1/4 LSB could have effect.  It seems like
;CONSIDER: 1/2 LSB is the limit.
	ja	short InsignifAdd	;  (Even 1/4 LSB could have effect)
	mov	cl,al			;Shift count to cl
;High half ecx = exponent
;ch bit 7 = sign difference
;ch bit 6 = sign
;cl = shift count
	xor	eax,eax			;Prepare to take bits shifted out
	cmp	cl,32			;More than a whole word?
	jb	short ShortShift
	xchg	eax,edx			;Save bits shifted out in eax
	xchg	edi,eax
	sub	cl,32
	cmp	cl,8			;Safe to shift this much
	jb	short ShortSticky
;Collapse all (sticky) bits of eax into LSB of edi
	neg	eax			;Sets CY if eax was not zero
	sbb	eax,eax			;-1 if CY was set, zero otherwise
	neg	eax			;Sticky bit in LSB only
	or	di,ax			;Move sticky bit up
	cmp	cl,32			;Less than another Dword?
	jb	short ShortShift
	mov	eax,edi
	xor	edi,edi			;edx = edi = 0
ShortSticky:
;Shift will not be more than 8 bits
	or	ah,al			;Move up sticky bits
ShortShift:
	shrd	eax,edi,cl		;Save bits shifted out in eax
	shrd	edi,edx,cl
	shr	edx,cl
Aligned:
	shl	ch,1			;Were signs the same?
	jc	short SubMant		;No--go subtract mantissas
;Add mantissas
	add	esi,edi
	adc	ebx,edx
	jnc	short AddExit
;Addition of mantissas overflowed. Bump exponent and shift right
	shrd	eax,esi,1
	shrd	esi,ebx,1		;Faster than RCR
	sar	ebx,1
	or	ebx,1 shl 31		;Set MSB
	add	ecx,1 shl 16
AddExit:
;ebx:esi:eax = normalized unrounded mantissa
;high half of ecx = exponent
;high bit of ch = sign
	jmp	EMSEG:[RoundMode]

NegMant:
;To get here, exponents must have been equal and op2 was bigger than op1.
;Note that this means nothing ever got shifted into eax.
	not	ch			;Change sign of result
	not	ebx
	neg	esi
	sbb	ebx,-1
	js	short AddExit		;Already normalized?
	test	ebx,40000000H		;Only one bit out of normal?
	jz	short NormalizeAdd
	jmp	short NormOneBit

SubMant:
;Subtract mantissas
	neg	eax			;Pretend minuend is zero extended
	sbb	esi,edi
	sbb	ebx,edx
	jc	short NegMant
	js	short AddExit		;Already normalized?
NormChk:
	test	ebx,40000000H		;Only one bit out of normal?
	jz	short NormalizeAdd
;One bit normalization
NormOneBit:
	sub	ecx,1 shl 16		;Adjust exponent
ShiftOneBit:				;Entry point from emfmul.asm
	shld	ebx,esi,1
	shld	esi,eax,1
	shl	eax,1
	jmp	EMSEG:[RoundMode]

;***********
AddZeroZero:				;Entry point for adding two zeros
;***********
	mov	ah,EMSEG:[edi].bSgn	;Get sign of op
	xor	ch,dl			;Possibly subtracting source
	xor	ah,dh			;Possibly subtracting dest
	xor	ch,ah			;Do signs match?
	js	FindZeroSign		;No - use rounding mode to set sign
	mov	EMSEG:[edi].bSgn,ah	;Correct the sign if subtracting
	ret				;Result at [edi] is now correct

ZeroChk:
;Upper 64 bits were all zero, but there could be 1 bit in the MSB
;of eax.
	or	eax,eax
	jnz	short OneBitLeft
	mov	ebx,eax
	mov	esi,eax			;Zero mantissa
FindZeroSign:
;Round to -0 if "round down" mode, round to +0 otherwise
	xor	ecx,ecx			;Zero exponent, positive sign
	mov	dl,EMSEG:[CWcntl]	;Get control word
	and	dl,RoundControl
        cmp	dl,RCdown		;Rounding down?
	jnz	ZeroJmp
	mov	ch,80H			;Set sign bit
ZeroJmp:
	mov	cl,bTAG_ZERO
	jmp	EMSEG:[ZeroVector]

OneBitLeft:
	xchg	ebx,eax			;Bit now normalized
	sub	ecx,64 shl 16		;Adjust exponent
	jmp	EMSEG:[RoundMode]

NormalizeAdd:
;Inputs:
;	ebx:esi:eax = 65-bit number
;	ecx high half = exponent
;
;Since we are more than 1 bit out of normalization, exponents must have
;differed by 0 or 1.  Thus rounding will not be necessary for 64 bits.
	bsr	edx,ebx			;Scan for MSB
	jnz	short ShortNorm
	bsr	edx,esi
	jz	short ZeroChk
	sub	ecx,32 shl 16		;Adjust exponent
	mov	ebx,esi			;Push it up 32 bits
	mov	esi,eax
ShortNorm:
;Bit number in edx ranges from 0 to 31
	mov	cl,dl
	not	cl			;Convert bit number to shift count
	shld	ebx,esi,cl
	shld	esi,eax,cl
	shl	edx,16			;Move exp. adjustment to high end
	lea	ecx,[ecx+edx-(31 shl 16)] ;Adjust exponent
	xor	eax,eax			;No extra bits
	jmp	EMSEG:[RoundMode]

AddDestSign:
	xor	EMSEG:[edi].bSgn,dh
	ret

AddSourceSign:
	xor	ch,dl
	jmp	SaveResult
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\emfdiv.asm ===
subttl  emfdiv.asm - Division
	page
;*******************************************************************************
;	 Copyright (c) Microsoft Corporation 1991
;	 All Rights Reserved
;
;emfdiv.asm - long double divide
;	by Tim Paterson
;
;Purpose:
;	Long double division.
;Inputs:
;	ebx:esi = op1 mantissa
;	ecx = op1 sign in bit 15, exponent in high half
;	edi = pointer to op2 and result location
;	[Result] = edi
;
;	Exponents are unbiased.  Denormals have been normalized using
;	this expanded exponent range.  Neither operand is allowed to be zero.
;Outputs:
;	Jumps to [RoundMode] to round and store result.
;
;Revision History:
;
; []	09/05/91  TP	Initial 32-bit version.
;
;*******************************************************************************


;Dispatch tables for division
;
;One operand has been loaded into ecx:ebx:esi ("source"), the other is
;pointed to by edi ("dest").  edi points to dividend for fdiv,
;to divisor for fdivr.  
;
;Tag of source is shifted.  Tag values are as follows:
;
.erre	TAG_SNGL	eq	0	;SINGLE: low 32 bits are zero
.erre	TAG_VALID	eq	1
.erre	TAG_ZERO	eq	2
.erre	TAG_SPCL	eq	3	;NAN, Infinity, Denormal, Empty

;dest = dest / source
tFdivDisp	label	dword		;Source (reg)	Dest (*[di])
	dd	DivSingle		;single		single
	dd	DivSingle		;single		double
	dd	XorDestSign		;single		zero
	dd	DivSpclDest		;single		special
	dd	DivDouble		;double		single
	dd	DivDouble		;double		double
	dd	XorDestSign		;double		zero
	dd	DivSpclDest		;double		special
	dd	DivideByZero		;zero		single
	dd	DivideByZero		;zero		double
	dd	ReturnIndefinite	;zero		zero
	dd	DivSpclDest		;zero		special
	dd	DivSpclSource		;special	single
	dd	DivSpclSource		;special	double
	dd	DivSpclSource		;special	zero
	dd	TwoOpBothSpcl		;special	special
	dd	ReturnIndefinite	;Two infinities

;dest = source / dest
tFdivrDisp	label	dword		;Source (reg)	Dest (*[di])
	dd	DivrSingle		;single		single
	dd	DivrDouble		;single		double
	dd	DivideByZero		;single		zero
	dd	DivrSpclDest		;single		special
	dd	DivrSingle		;double		single
	dd	DivrDouble		;double		double
	dd	DivideByZero		;double		zero
	dd	DivrSpclDest		;double		special
	dd	XorSourceSign		;zero		single
	dd	XorSourceSign		;zero		double
	dd	ReturnIndefinite	;zero		zero
	dd	DivrSpclDest		;zero		special
	dd	DivrSpclSource		;special	single
	dd	DivrSpclSource		;special	double
	dd	DivrSpclSource		;special	zero
	dd	TwoOpBothSpcl		;special	special
	dd	ReturnIndefinite	;Two infinities


EM_ENTRY eFIDIV16
eFIDIV16:
	push	offset DivSetResult
	jmp	Load16Int		;Returns to DivSetResult

EM_ENTRY eFIDIVR16
eFIDIVR16:
	push	offset DivrSetResult
	jmp	Load16Int

EM_ENTRY eFIDIV32
eFIDIV32:
	push	offset DivSetResult
	jmp	Load32Int

EM_ENTRY eFIDIVR32
eFIDIVR32:
	push	offset DivrSetResult
	jmp	Load32Int

EM_ENTRY eFDIV32
eFDIV32:
	push	offset DivSetResult
	jmp	Load32Real			;Returns to DivSetResult

EM_ENTRY eFDIVR32
eFDIVR32:
	push	offset DivrSetResult		;Returns to DivrSetResult
	jmp	Load32Real

EM_ENTRY eFDIV64
eFDIV64:
	push	offset DivSetResult
	jmp	Load64Real			;Returns to DivSetResult

EM_ENTRY eFDIVR64
eFDIVR64:
	push	offset DivrSetResult
	jmp	Load64Real			;Returns to DivrSetResult


EM_ENTRY eFDIVRPreg
eFDIVRPreg:
	push	offset PopWhenDone

EM_ENTRY eFDIVRreg
eFDIVRreg:
	xchg	esi,edi

EM_ENTRY eFDIVRtop
eFDIVRtop:
	mov	ecx,EMSEG:[esi].ExpSgn
	mov	ebx,EMSEG:[esi].lManHi
	mov	esi,EMSEG:[esi].lManLo
DivrSetResult:
;cl has tag of dividend
	mov     ebp,offset tFdivrDisp
	mov	EMSEG:[Result],edi		;Save result pointer
	mov	ah,cl
	mov     al,EMSEG:[edi].bTag
	and	ah,not 1		;Ignore single vs. double on dividend
	cmp	ax,1
.erre	bTAG_VALID	eq	1
.erre	bTAG_SNGL	eq	0
	jz	DivrDouble		;Divisor was double
	ja	TwoOpResultSet
;.erre	DivrSingle eq $			;Fall into DivrSingle

;*********
DivrSingle:
;*********
;Computes op1/op2
;Op1 is double, op2 is single (low 32 bits are zero)
	mov	edx,ebx
	mov	eax,esi			;Mantissa in edx:eax
	mov	ebx,EMSEG:[edi].ExpSgn
	mov	edi,EMSEG:[edi].lManHi
	jmp	DivSingleReg


SDivBigUnderflow:
;Overflow flag set could only occur with denormals (true exp < -32768)
	or	EMSEG:[CURerr],Underflow
	test	EMSEG:[CWmask],Underflow	;Is exception masked?
	jnz	UnderflowZero		;Yes, return zero (in emfmul.asm)
	add	ecx,Underbias shl 16	;Fix up exponent
	jmp	ContSdiv		;Continue with multiply


EM_ENTRY eFDIVPreg
eFDIVPreg:
	push	offset PopWhenDone

EM_ENTRY eFDIVreg
eFDIVreg:
	xchg	esi,edi

EM_ENTRY eFDIVtop
eFDIVtop:
	mov	ecx,EMSEG:[esi].ExpSgn
	mov	ebx,EMSEG:[esi].lManHi
	mov	esi,EMSEG:[esi].lManLo
DivSetResult:
;cl has tag of divisor
	mov     ebp,offset tFdivDisp
	mov	EMSEG:[Result],edi		;Save result pointer
	mov	al,cl
	mov     ah,EMSEG:[edi].bTag
	and	ah,not 1		;Ignore single vs. double on dividend
	cmp	ax,1
.erre	bTAG_VALID	eq	1
.erre	bTAG_SNGL	eq	0
	jz	DivDouble		;Divisor was double
	ja	TwoOpResultSet
;.erre	DivSingle eq $			;Fall into DivSingle

;*********
DivSingle:
;*********
;Computes op2/op1
;Op2 is double, op1 is single (low 32 bits are zero)
	xchg	edi,ebx			;Mantissa in edi, op2 ptr to ebx
	xchg	ebx,ecx			;ExpSgn to ebx, op2 ptr to ecx
	mov	edx,EMSEG:[ecx].lManHi
	mov	eax,EMSEG:[ecx].lManLo
	mov	ecx,EMSEG:[ecx].ExpSgn	;Op2 loaded

DivSingleReg:
;dividend mantissa in edx:eax, exponent in high ecx, sign in ch bit 7
;divisor mantissa in edi, exponent in high ebx, sign in bh bit 7

	xor	ch,bh			;Compute result sign
	xor	bx,bx			;Clear out sign and tag
	sub	ecx,1 shl 16		;Exponent adjustment needed
	sub	ecx,ebx			;Compute result exponent
.erre	TexpBias eq 0			;Exponents not biased
	jo	SDivBigUnderflow	;Dividing denormal by large number
ContSdiv:

;If dividend >= divisor, the DIV instruction will overflow.  Check for
;this condition and shift the dividend right one bit if necessary.
;
;In previous versions of this algorithm for 24-bit and 53-bit mantissas,
;this shift was always performed without a test.  This meant that a 1-bit
;normalization might be required at the end.  This worked fine because
;32 or 64 bits were calculated, so extra precision was available for
;normalization.  However, this version needs all 64 bits that are calculated, 
;so we can't afford a normalization shift at the end.  This test tells us
;up front how to align so we'll be normalized.
	xor	ebx,ebx			;Extend dividend
	cmp	edi,edx			;Will DIV overflow?
	ja	DoSdiv			;No, we're safe
	shrd	ebx,eax,1
	shrd	eax,edx,1
	shr	edx,1
	add	ecx,1 shl 16		;Bump exponent to account for shift
DoSdiv:
	div	edi
	xchg	ebx,eax			;Save quotient in ebx, extend remainder
	div	edi
	mov	esi,eax
;We have a 64-bit quotient in ebx:esi.  Now compare remainder*2 with divisor
;to compute round and sticky bits.
	mov	eax,-1			;Set round and sticky bits
	shl	edx,1			;Double remainder
	jc	RoundJmp		;If too big, round & sticky set
	cmp	edx,edi			;Is remainder*2 > divisor?
	ja	RoundJmp

;Observe, oh wondering one, how you can assume the result of this last
;compare is not equality.  Use the following notation: n=numerator,
;d=denominator,q=quotient,r=remainder,b=base(2^64 here).  If
;initially we had n < d then there was no shift and we will find q and r
;so that q*d+r=n*b, if initially we had n >= d then there was a shift and
;we will find q and r so that q*d+r=n*b/2.  If we have equality here
;then r=d/2  ==>  n={possibly 2*}(2*q+1)*d/(2*b), since this can only
;be integral if d is a multiple of b, but by definition b/2 <= d < b, we
;have a contradiction.	Equality is thus impossible at this point.

	cmp	edx,1			;Check for zero remainder
	sbb	eax,-2			;eax==0 if CY, ==1 if NC (was -1)
RoundJmp:
	jmp	EMSEG:[RoundMode]

;*******************************************************************************

DDivBigUnderflow:
;Overflow flag set could only occur with denormals (true exp < -32768)
	or	EMSEG:[CURerr],Underflow
	test	EMSEG:[CWmask],Underflow	;Is exception masked?
	jnz	UnderflowZero		;Yes, return zero (in emfmul.asm)
	add	ecx,Underbias shl 16	;Fix up exponent
	jmp	ContDdiv		;Continue with multiply

DivrDoubleSetFlag:
;Special entry point used by FPATAN to set bit 6 of flag dword pushed
;on stack before call.
	or	byte ptr [esp+4],40H
;*********
DivrDouble:
;*********
;Computes op1/op2
	mov	edx,ebx
	mov	eax,esi			;Mantissa in edx:eax
	mov	ebx,EMSEG:[edi].ExpSgn
	mov	esi,EMSEG:[edi].lManHi
	mov	edi,EMSEG:[edi].lManLo
	jmp	short DivDoubleReg

HighHalfEqual:
;edx:eax:ebp = dividend
;esi:edi = divisor
;ecx = exponent and sign of result
;
;High half of dividend is equal to high half of divisor.  This will cause
;the DIV instruction to overflow.  If whole dividend >= whole divisor, then
;we just shift the dividend right 1 bit.
	cmp	eax,edi			;Is dividend >= divisor?
	jae	ShiftDividend		;Yes, divide it by two
;DIV instruction would overflow, so skip it and calculate the effective
;result.  Assume a quotient of 2^32-1 and calculate the remainder.  See
;detailed comments under MaxQuo below--this is a copy of that code.
	push	ecx			;Save exp. and sign
	mov	ebx,-1			;Max quotient digit
	sub	eax,edi			;Calculate correct remainder
;Currently edx == esi, but the next instruction ensures that is no longer
;true, since eax != 0.  This will allow us to skip the MaxQuo check at
;DivFirstDigit.
	add	edx,eax			;Should set CY if quotient fit
	mov	eax,edi			;ecx:eax has new remainder
	jc	ComputeSecond		;Remainder was positive
;Quotient doesn't fit.  Note that we can no longer ensure that edx != esi
;after making a correction.
	mov	ecx,edx			;Need remainder in ecx:eax
	jmp	DivCorrect1

;*********
DivDouble:
;*********
;Computes op2/op1
	mov	eax,edi			;Move op2 pointer
	mov	edi,esi
	mov	esi,ebx			;Mantissa in esi:edi
	mov	ebx,ecx			;ExpSgn to ebx
	mov	ecx,EMSEG:[eax].ExpSgn	;Op2 loaded
	mov	edx,EMSEG:[eax].lManHi
	mov	eax,EMSEG:[eax].lManLo

DivDoubleReg:
;dividend mantissa in edx:eax, exponent in high ecx, sign in ch bit 7
;divisor mantissa in esi:edi, exponent in high ebx, sign in bh bit 7

	xor	ch,bh			;Compute result sign
	xor	bx,bx			;Clear out sign and tag
	sub	ecx,1 shl 16		;Exponent adjustment needed
	sub	ecx,ebx			;Compute result exponent
.erre	TexpBias eq 0			;Exponents not biased
	jo	DDivBigUnderflow	;Dividing denormal by large number
ContDdiv:

;If dividend >= divisor, we must shift the dividend right one bit.
;This will ensure the result is normalized.
;
;In previous versions of this algorithm for 24-bit and 53-bit mantissas,
;this shift was always performed without a test.  This meant that a 1-bit
;normalization might be required at the end.  This worked fine because
;32 or 64 bits were calculated, so extra precision was available for
;normalization.  However, this version needs all 64 bits that are calculated, 
;so we can't afford a normalization shift at the end.  This test tells us
;up front how to align so we'll be normalized.
	xor	ebp,ebp			;Extend dividend
	cmp	esi,edx			;Dividend > divisor
	ja	DoDdiv
	jz	HighHalfEqual		;Go compare low halves
ShiftDividend:
	shrd	ebp,eax,1
	shrd	eax,edx,1
	shr	edx,1
	add	ecx,1 shl 16		;Bump exponent to account for shift
DoDdiv:
	push	ecx			;Save exp. and sign

;edx:eax:ebp = dividend
;esi:edi = divisor
;
;Division algorithm from Knuth vol. 2, p. 237, using 32-bit "digits":
;Guess a quotient digit by dividing two MSDs of dividend by the MSD of
;divisor.  If divisor is >= 1/2 the radix (radix = 2^32 in this case), then
;this guess will be no more than 2 larger than the correct value of that
;quotient digit (and never smaller).  Divisor meets magnitude condition 
;because it's normalized.

	div	esi			;Guess first quotient "digit"

;Check out our guess.  
;Currently, remainder in edx = dividend - (quotient * high half divisor).
;The definition of remainder is dividend - (quotient * all divisor).  So
;if we subtract (quotient * low half divisor) from edx, we'll get
;the true remainder.  If it's negative, our guess was too big.

	mov	ebx,eax			;Save quotient
	mov	ecx,edx			;Save remainder
	mul	edi			;Quotient * low half divisor
	sub	ebp,eax			;Subtract from dividend extension
	sbb	ecx,edx			;Subtract from remainder
	mov	eax,ebp			;Low remainder to eax
	jnc	DivFirstDigit		;Was quotient OK?
DivCorrect1:
	dec	ebx			;Quotient was too big
	add	eax,edi			;Add divisor back into remainder
	adc	ecx,esi
	jnc	DivCorrect1		;Repeat if quotient is still too big
DivFirstDigit:
	cmp	ecx,esi			;Would DIV instruction overflow?
	jae	short MaxQuo		;Yes, figure alternate quotient
	mov	edx,ecx			;Remainder back to edx:eax

;Compute 2nd quotient "digit"

ComputeSecond:
	div	esi			;Guess 2nd quotient "digit"
	mov	ebp,eax			;Save quotient
	mov	ecx,edx			;Save remainder
	mul	edi			;Quotient * low half divisor
	neg	eax			;Subtract from dividend extended with 0
	sbb	ecx,edx			;Subtract from remainder
	jnc	DivSecondDigit		;Was quotient OK?
DivCorrect2:
	dec	ebp			;Quotient was too big
	add	eax,edi			;Add divisor back into remainder
	adc	ecx,esi
	jnc	DivCorrect2		;Repeat if quotient is still too big
DivSecondDigit:
;ebx:ebp = quotient
;ecx:eax = remainder
;esi:edi = divisor
;Now compare remainder*2 with divisor to compute round and sticky bits.
	mov	edx,-1			;Set round and sticky bits
	shld	ecx,eax,1		;Double remainder
	jc	DDivEnd			;If too big, round & sticky set
	shl	eax,1
	sub	edi,eax
	sbb	esi,ecx			;Subtract remainder*2 from divisor
	jb	DDivEnd			;If <0, use round & sticky bits set

;Observe, oh wondering one, how you can assume the result of this last
;compare is not equality.  Use the following notation: n=numerator,
;d=denominator,q=quotient,r=remainder,b=base(2^64 here).  If
;initially we had n < d then there was no shift and we will find q and r
;so that q*d+r=n*b, if initially we had n >= d then there was a shift and
;we will find q and r so that q*d+r=n*b/2.  If we have equality here
;then r=d/2  ==>  n={possibly 2*}(2*q+1)*d/(2*b), since this can only
;be integral if d is a multiple of b, but by definition b/2 <= d < b, we
;have a contradiction.	Equality is thus impossible at this point.

;No round bit, but set sticky bit if remainder != 0.
	or	eax,ecx			;Is remainder zero?
	add	eax,-1			;Set CY if non-zero
	adc	edx,1			;edx==0 if NC, ==1 if CY (was -1)
DDivEnd:
	mov	esi,ebp			;Result in ebx:esi
	mov	eax,edx			;Round/sticky bits to eax
	pop	ecx			;Recover sign/exponent
	jmp	EMSEG:[RoundMode]


MaxQuo:
;ebx = first quotient "digit"
;ecx:eax = remainder
;esi:edi = divisor
;On exit, ebp = second quotient "digit"
;
;Come here if divide instruction would overflow. This must mean that ecx == esi,
;i.e., the high halves of the dividend and divisor are equal. Assume a result
;of 2^32-1, thus remainder = dividend - ( divisor * (2^32-1) )
; = dividend - divisor * 2^32 + divisor. Since the high halves of the dividend
;and divisor are equal, dividend - divisor * 2^32 can be computed by
;subtracting only the low halves. When adding divisor (in esi) to this, note
;that ecx == esi, and we want the result in ecx anyway.
;
;Note also that since the dividend is a previous remainder, the
;dividend - divisor * 2^32 calculation must always be negative. Thus the 
;addition of divisor back to it should generate a carry if it goes positive.

	mov	ebp,-1			;Max quotient digit
	sub	eax,edi			;Calculate correct remainder
	add	ecx,eax			;Should set CY if quotient fit
	mov	eax,edi			;ecx:eax has new remainder
	jc	DivSecondDigit		;Remainder was positive
	jmp	DivCorrect2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\emfconst.asm ===
subttl	emfconst.asm - Loading of 387 on chip constants
        page
;*******************************************************************************
;emfconst.asm - Loading of 387 on chip constants
;
;        Microsoft Confidential
;
;	 Copyright (c) Microsoft Corporation 1991
;        All Rights Reserved
;
;Purpose:
;       FLDZ, FLD1, FLDPI, FLDL2T, FLDL2E, FLDLG2, FLDLN2 instructions
;Inputs:
;	edi = [CURstk]
;
;Revision History:
;
; []	09/05/91  TP	Initial 32-bit version.
;
;*******************************************************************************


	PrevStackWrap	edi,Ld1		;Tied to PrevStackElem below

EM_ENTRY eFLD1
eFLD1:
;edi = [CURstk]
	PrevStackElem	edi,Ld1		;Point to receiving location
	cmp	EMSEG:[edi].bTag,bTAG_EMPTY	;Is it empty?
	jnz	FldErr			;in emload.asm
	mov	EMSEG:[CURstk],edi
	mov	EMSEG:[edi].lManLo,0
	mov	EMSEG:[edi].lManHi,1 shl 31
	mov	EMSEG:[edi].ExpSgn,bTAG_SNGL	;Exponent and sign are zero
	ret


	PrevStackWrap	edi,Ldz		;Tied to PrevStackElem below

EM_ENTRY eFLDZ
eFLDZ:
;edi = [CURstk]
	PrevStackElem	edi,Ldz		;Point to receiving location
	cmp	EMSEG:[edi].bTag,bTAG_EMPTY	;Is it empty?
	jnz	FldErr			;in emload.asm
	mov	EMSEG:[CURstk],edi
	mov	EMSEG:[edi].lManLo,0
	mov	EMSEG:[edi].lManHi,0
	mov	EMSEG:[edi].ExpSgn,bTAG_ZERO	;Exponent and sign are zero
	ret

;*******************************************************************************

;The 5 irrational constants need to be adjusted according to rounding mode.

DefConst	macro	cName,low,high,expon,round
c&cName&lo	equ	low
c&cName&hi	equ	high
c&cName&exp     equ     expon
c&cName&rnd     equ     round
	endm

DefConst	FLDL2T,0CD1B8AFEH,0D49A784BH,00001H,0

DefConst	FLDL2E,05C17F0BCH,0B8AA3B29H,00000H,1

DefConst	FLDLG2,0FBCFF799H,09A209A84H,0FFFEH,1

DefConst	FLDLN2,0D1CF79ACH,0B17217F7H,0FFFFH,1

DefConst	FLDPI,02168C235H,0C90FDAA2H,00001H,1


LoadConstant   macro   cName,nojmp
EM_ENTRY e&cName
e&cName:
	mov	ebx,c&cName&hi
	mov	edx,c&cName&lo
        mov     ecx,c&cName&exp shl 16 + c&cName&rnd
ifb	<nojmp>
	jmp	CommonConst
endif
	endm

LoadConstant	FLDL2T

LoadConstant	FLDL2E

LoadConstant	FLDLG2

LoadConstant	FLDLN2

LoadConstant	FLDPI,nojmp

CommonConst:
;ebx:edx = mantissa of constant, rounded to nearest
;high ecx = exponent 
;ch = sign
;cl = rounding flag: 1 indicates roundup occured for round nearest, else 0
;edi = [CURstk]
	test	EMSEG:[CWcntl],RoundControl	;Check rounding control bits
.erre	RCnear eq 0
	jnz	NotNearConst		;Adjust constant if not round nearest
StoreConst:
	mov	cl,bTAG_VALID
	mov	esi,edx
	jmp	FldCont			;In emload.asm

NotNearConst:
;It is known that the five constants positive irrational numbers.
;This means they are never exact, and chop and round down always
;produce the same answer.  It is also know that the values are such
;that rounding only alters bits in the last byte.
;
;A flag in cl indicates if the number has been rounded up for round
;nearest (1 = rounded up, 0 = rounded down).  In chop and round down 
;modes, this flag can be directly subtracted to reverse the rounding.  
;In round up mode, we want to add (1-flag) = -(flag-1).
.erre	RCchop eq 0CH			;Two bits set only for chop
	test	EMSEG:[CWcntl],RCdown	;DOWN bit set?
	jnz	DirectRoundConst	;If so, it's chop or down
;Round Up mode
	dec	cl			;-1 if round up needed, else 0
DirectRoundConst:
	sub	dl,cl			;Directed rounding
	jmp	StoreConst
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\emfmul.asm ===
subttl  emfmul.asm - Multiplication
	page
;*******************************************************************************
;	 Copyright (c) Microsoft Corporation 1991
;	 All Rights Reserved
;
;emfmul.asm - long double multiply
;	by Tim Paterson
;
;Purpose:
;	Long double multiplication.
;Inputs:
;	ebx:esi = op1 mantissa
;	ecx = op1 sign in bit 15, exponent in high half
;	edi = pointer to op2 and result location
;	[Result] = edi
;
;	Exponents are unbiased.  Denormals have been normalized using
;	this expanded exponent range.  Neither operand is allowed to be zero.
;Outputs:
;	Jumps to [RoundMode] to round and store result.
;
;Revision History:
;
; []	09/05/91  TP	Initial 32-bit version.
;
;*******************************************************************************

;Dispatch table for multiply
;
;One operand has been loaded into ecx:ebx:esi ("source"), the other is
;pointed to by edi ("dest").  
;
;Tag of source is shifted.  Tag values are as follows:

.erre	TAG_SNGL	eq	0	;SINGLE: low 32 bits are zero
.erre	TAG_VALID	eq	1
.erre	TAG_ZERO	eq	2
.erre	TAG_SPCL	eq	3	;NAN, Infinity, Denormal, Empty

;Any special case routines not found in this file are in emarith.asm

tFmulDisp	label	dword		;Source (reg)	Dest (*[di])
	dd	MulSingle		;single		single
	dd	MulDouble		;single		double
	dd	XorDestSign		;single		zero
	dd	MulSpclDest		;single		special
	dd	MulDouble		;double		single
	dd	MulDouble		;double		double
	dd	XorDestSign		;double		zero
	dd	MulSpclDest		;double		special
	dd	XorSourceSign		;zero		single
	dd	XorSourceSign		;zero		double
	dd	XorDestSign		;zero		zero
	dd	MulSpclDest		;zero		special
	dd	MulSpclSource		;special	single
	dd	MulSpclSource		;special	double
	dd	MulSpclSource		;special	zero
	dd	TwoOpBothSpcl		;special	special
	dd	XorDestSign		;Two infinities


EM_ENTRY eFIMUL16
eFIMUL16:
	push	offset MulSetResult
	jmp	Load16Int			;Returns to MulSetResult

EM_ENTRY eFIMUL32
eFIMUL32:
	push	offset MulSetResult
	jmp	Load32Int			;Returns to MulSetResult

EM_ENTRY eFMUL32
eFMUL32:
	push	offset MulSetResult
	jmp	Load32Real			;Returns to MulSetResult

EM_ENTRY eFMUL64
eFMUL64:
	push	offset MulSetResult
	jmp	Load64Real			;Returns to MulSetResult

EM_ENTRY eFMULPreg
eFMULPreg:
	push	offset PopWhenDone

EM_ENTRY eFMULreg
eFMULreg:
	xchg	esi,edi

EM_ENTRY eFMULtop
eFMULtop:
	mov	ecx,EMSEG:[esi].ExpSgn
	mov	ebx,EMSEG:[esi].lManHi
	mov	esi,EMSEG:[esi].lManLo
MulSetResult:
	mov     ebp,offset tFmulDisp
	mov	EMSEG:[Result],edi		;Save result pointer
	mov	al,cl
	or	al,EMSEG:[edi].bTag
	cmp	al,bTAG_VALID
.erre	bTAG_VALID	eq	1
.erre	bTAG_SNGL	eq	0
	jz	MulDouble
	ja	TwoOpResultSet
;.erre	MulSingle eq $			;Fall into MulSingle


;*********
MulSingle:
;*********

	mov	edx,EMSEG:[edi].ExpSgn
	mov	eax,EMSEG:[edi].lManHi

;op1 mantissa in ebx:esi, exponent in high ecx, sign in ch bit 7
;op2 high mantissa in eax, exponent in high edx, sign in dh bit 7

	xor	ch,dh			;Compute result sign
	xor	dx,dx			;Clear out sign and tag
	add	ecx,edx			;Result exponent
.erre	TexpBias eq 0			;Exponents not biased
	jo	SMulBigUnderflow	;Multiplying two denormals
ContSmul:

;Value in ecx is correct exponent if result is not normalized.
;If result comes out normalized, 1 will be added.

	mul	ebx			;Compute product
	mov	ebx,edx
	mov	esi,eax
	xor	eax,eax			;Extend with zero

;Result in ebx:esi:eax
;ecx = exponent minus one in high half, sign in ch
	or	ebx,ebx			;Check for normalization
	jns	ShiftOneBit		;In emfadd.asm
	add	ecx,1 shl 16		;Adjust exponent
	jmp	EMSEG:[RoundMode]

SMulBigUnderflow:
	or	EMSEG:[CURerr],Underflow
	add	ecx,Underbias shl 16	;Fix up exponent
	test	EMSEG:[CWmask],Underflow	;Is exception masked?
	jz	ContSmul		;No, continue with multiply
UnderflowZero:
	or	EMSEG:[CURerr],Precision
SignedZero:
	and	ecx,bSign shl 8		;Preserve sign bit
	xor	ebx,ebx
	mov	esi,ebx
	mov	cl,bTAG_ZERO
	jmp	EMSEG:[ZeroVector]

;*******************************************************************************

DMulBigUnderflow:
;Overflow flag set could only occur with denormals (true exp < -32768)
	or	EMSEG:[CURerr],Underflow
	test	EMSEG:[CWmask],Underflow	;Is exception masked?
	jnz	UnderflowZero		;Yes, return zero
	add	ecx,Underbias shl 16	;Fix up exponent
	jmp	ContDmul		;Continue with multiply

PolyMulToZero:
	ret				;Return the zero in registers

PolyMulDouble:
;This entry point is used by polynomial evaluator.
;It checks the operand in registers for zero.
	cmp	cl,bTAG_ZERO		;Adding to zero?
	jz	PolyMulToZero

;*********
MulDouble:
;*********

	mov	eax,EMSEG:[edi].ExpSgn
	mov	edx,EMSEG:[edi].lManHi
	mov	edi,EMSEG:[edi].lManLo

MulDoubleReg:				;Entry point used by transcendentals
;op1 mantissa in ebx:esi, exponent in high ecx, sign in ch bit 7
;op2 mantissa in edx:edi, exponent in high eax, sign in ah bit 7

	xor	ch,ah			;Compute result sign
	xor	ax,ax			;Clear out sign and tag
	add	ecx,eax			;Result exponent
.erre	TexpBias eq 0			;Exponents not biased
	jo	DMulBigUnderflow	;Multiplying two denormals
ContDmul:

;Value in ecx is correct exponent if result is not normalized.
;If result comes out normalized, 1 will be added.

	mov	ebp,edx			;edx is used by MUL instruction

;Generate and sum partial products, from least to most significant

	mov	eax,edi
	mul	esi			;Lowest partial product
	add	eax,-1			;CY set IFF eax<>0
	sbb	cl,cl			;Sticky bit: 0 if zero, -1 if nz
	xchg	edi,edx			;Save high result

;First product: cl reflects low dword non-zero (sticky bit), edi has high dword

	mov	eax,ebx
	mul	edx
	add	edi,eax
	adc	edx,0			;Sum first results
	xchg	edx,esi			;High result to esi

;Second product: accumulated in esi:edi:cl

	mov	eax,ebp			;Next mult. to eax
	mul	edx
	add	edi,eax			;Sum low results
	adc	esi,edx			;Sum high results
	mov	eax,ebx
	mov	ebx,0			;Preserve CY flag
	adc	ebx,ebx			;Keep carry out of high sum

;Third product: accumulated in ebx:esi:edi:cl

	mul	ebp
	add	esi,eax
	adc	ebx,edx
	mov	eax,edi
	or	al,cl			;Collapse sticky bits into eax

;Result in ebx:esi:eax
;ecx = exponent minus one in high half, sign in ch
MulDivNorm:
	or	ebx,ebx			;Check for normalization
	jns	ShiftOneBit		;In emfadd.asm
	add	ecx,1 shl 16		;Adjust exponent
	jmp	EMSEG:[RoundMode]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\emlsbcd.asm ===
subttl	emlsbcd.asm - FBSTP and FBLD instructions
        page
;*******************************************************************************
;emlsbcd.asm - FBSTP and FBLD instructions
;
;        Microsoft Confidential
;
;	 Copyright (c) Microsoft Corporation 1991
;        All Rights Reserved
;
;Purpose:
;	FBSTP and FBLD instructions.
;
;	These routines convert between 64-bit integer and 18-digit packed BCD
;	format.  They work by splitting the number being converted in half
;	and converting the two halves separately.  This works well because
;	9 decimal digits fit nicely within 30 binary bits, so converion of
;	each half is strictly a 32-bit operation.
;
;Inputs:
;	edi = [CURstk]
;	dseg:esi = pointer to memory operand
;
;Revision History:
;
; []	09/05/91  TP	Initial 32-bit version.
;
;*******************************************************************************


;******
eFBLD:
;******
	mov	eax,dseg:[esi+5]		;Get high 8 digits
	or	eax,eax			;Anything there?
	jz	HighDigitsZero
	mov	ecx,8
	call	ReadDigits		;Convert first 8 digits to binary
	mov	eax,dseg:[esi+1]		;Get next 8 digits
	xor	edi,edi
	shld	edi,eax,4		;Shift ninth digit into edi
	imul	ebx,10
	add	edi,ebx			;Accumulate ninth digit
SecondNineDigits:
	xor	ebx,ebx			;In case eax==0
	shl	eax,4			;Keep digits left justified
	jz	LastTwoDigits
	mov	ecx,7
	call	ReadDigits		;Convert next 7 digits to binary
LastTwoDigits:
	mov	al,dseg:[esi]		;Get last two digits
	shl	eax,24			;Left justify
	mov	ecx,2
	call	InDigitLoop		;Accumulate last two digits
;edi = binary value of high 9 digits
;ebx = binary value of low 9 digits
	mov	eax,1000000000		;One billion: shift nine digits left
	mul	edi			;Left shift 9 digits. 9 cl. if edi==0
	add	ebx,eax			;Add in low digits
	adc	edx,0
BcdReadyToNorm:
;edx:ebx = integer converted to binary
	mov	eax,dseg:[esi+6]		;Get sign to high bit of eax
	mov	esi,ebx
	mov	ebx,edx
	mov     edi,EMSEG:[CURstk]
;mantissa in ebx:esi, sign in high bit of eax
;edi = [CURstk]
	jmp	NormQuadInt		;in emload.asm

HighDigitsZero:
	mov	eax,dseg:[esi+1]		;Get next 8 digits
	or	eax,eax			;Anything there?
	jz	CheckLastTwo
	xor	edi,edi
	shld	edi,eax,4		;Shift ninth digit into edi
	jmp	SecondNineDigits
       
CheckLastTwo:
	mov	bl,dseg:[esi]		;Get last two digits
	or	bl,bl
	jz	ZeroBCD
	mov	al,bl
	shr	al,4			;Bring down upper digit
	imul	eax,10
	and	ebx,0FH			;Keep lowest digit only
	add	ebx,eax
	xor	edx,edx
	jmp	BcdReadyToNorm
	
ZeroBCD:
	mov	ecx,bTAG_ZERO		;Exponent is zero
	mov	ch,dseg:[esi+9]		;Get sign byte to ch
	xor	ebx,ebx
	mov	esi,ebx
;mantissa in ebx:esi, exp/sign in ecx
;edi = [CURstk]
	jmp	FldCont			;in emload.asm

			
;*** ReadDigits
;
;Inputs:
;	eax = packed BCD digits, left justified, non-zero
;	ecx = no. of digits, 7 or 8
;Outputs:
;	ebx = number

SkipZeroDigits:
        sub     ecx,3
        shl     eax,12
ReadDigits:
;We start by scanning off leading zeros.  This costs 16 cl./nybble in
;the ScanZero loop.  To reduce this cost for many leading zeros, we
;check for three leading zeros at a time.  Adding this test saves
;26 cl. for 3 leading zeros, 57 cl. for 6 leading zeros, at a cost
;of only 5 cl. if less than 3 zeros.  We choose 3 at a time so we
;can repeat it once (there are never more than 7 zeros).
	test    eax,0FFF00000H          ;Check first 3 nybbles for zero
	jz      SkipZeroDigits
	xor	ebx,ebx
ScanZero:
;Note that bsr is 3 cl/bit, or 12 cl/nybble.  Add in the overhead and
;this loop of 16 cl/nybble is cheaper for the 1 - 3 digits it does.
	dec	ecx
	shld	ebx,eax,4		;Shift digit into ebx
	rol	eax,4			;Left justify **Doesn't affect ZF!**
	jz	ScanZero		;Skip to next digit if zero
	jecxz	ReadDigitsX
InDigitLoop:
;eax = digits to convert, left justified
;ebx = result accumulation
;ecx = number of digits to convert
	xor	edx,edx
	shld	edx,eax,4		;Shift digit into edx
	shl	eax,4			;Keep digits left justified
	imul	ebx,10			;Only 10 clocks on 386!
	add	ebx,edx			;Accumulate number
	dec	ecx
	jnz	InDigitLoop
ReadDigitsX:
	ret
		
;*******************************************************************************

ChkInvalidBCD:
	ja	SetInvalidBCD
	cmp	edi,0A7640000H		;(1000000000*1000000000) and 0ffffffffh
	jb	ValidBCD
SetInvalidBCD:
	mov	EMSEG:[CURerr],Invalid
InvalidBCD:
	test	EMSEG:[CWmask],Invalid	;Is it masked?
	jz	ReadDigitsX		;No--leave memory unchanged
;Store Indefinite
	mov	dword ptr dseg:[esi],0
	mov	dword ptr dseg:[esi+4],0
	mov	word ptr dseg:[esi+8],-1	;0FF00000000H for packed BCD indefinite
	jmp	PopStack		;in emstore.asm

;******
eFBSTP:
;******
	call	RoundToInteger		;Get integer in ebx:edi, sign in ch
	jc	InvalidBCD
	cmp	ebx,0DE0B6B3H		;(1000000000*1000000000) shr 32
	jae	ChkInvalidBCD
ValidBCD:
	and	ch,bSign
	mov	dseg:[esi+9],ch		;Fill in sign byte
	mov	edx,ebx
	mov	eax,edi			;Get number to edx:eax for division
	mov	ebx,1000000000
	div	ebx			;Break into two 9-digit halves
	xor	ecx,ecx			;Initial digits
	mov	edi,eax			;Save quotient
	mov	eax,edx
	or	eax,eax
	jz	SaveLowBCD
	call	WriteDigits
	shrd	ecx,eax,4		;Pack 8th digit
	xor	al,al
	shl	eax,20			;Move digit in ah to high end
SaveLowBCD:
	mov	dseg:[esi],ecx		;Save low 8 digits
	mov	ecx,eax			;Get ready for next 8 digits
	mov	eax,edi
	or	eax,eax
	jz	ZeroHighBCD
	call	WriteDigits
	shl	ah,4			;Move digit to upper nybble
	or	al,ah			;Combine last two digits
SaveHighBCD:
	mov	dseg:[esi+4],ecx		;Save lower 8 digits
	mov	dseg:[esi+8],al
	jmp	PopStack

ZeroHighBCD:
	shr	ecx,28			;Position 9th digit
	jmp	SaveHighBCD


;*** WriteDigits
;
;Inputs:
;	eax = binary number < 1,000,000,000 and > 0
;	ecx = Zero or had one BCD digit left justified
;Purpose:
;	Convert binary integer to BCD.
;
;	The time required for the DIV instruction is dependent on operand
;	size, at 6 + (no. of bits) clocks for 386.  (In contrast, multiply
;	by 10 as used in FBLD/ReadDigits above takes the same amount of
;	time regardless of operand size--only 10 clocks.)
;
;	The easy way to do this conversion would be to repeatedly do a
;	32-bit division by 10 (at 38 clocks/divide).  Instead, the number
;	is broken down so that mostly 8-bit division is used (only 14 clocks).
;	AAM (17 clocks) is also used to save us from having to load the 
;	constant 10 and zero ah.  AAM is faster than DIV on the 486sx.
;
;Outputs:
;	ecx has seven more digits packed into it (from left)
;	ah:al = most significant two digits (unpacked)
;esi,edi preserved

WriteDigits:
;eax = binary number < 1,000,000,000
	cdq				;Zero edx
	mov	ebx,10000
	div	ebx			;Break into 4-digit and 5-digit pieces
	mov	bl,100
	or	edx,edx
	jz	ZeroLowDigits
	xchg	edx,eax			;Get 4-digit remainder to eax
;Compute low 4 digits
; 0 < eax < 10000
	div	bl			;Get two 2-digit pieces. 14cl on 386
	mov	bh,al			;Save high 2 digits
	mov	al,ah			;Get low digits
	aam
	shl	ah,4			;Move digit to upper nybble
	or	al,ah
	shrd	ecx,eax,8
	mov	al,bh			;Get high 2 digits
	aam
	shl	ah,4			;Move digit to upper nybble
	or	al,ah
	shrd	ecx,eax,8
;Compute high 5 digits
	mov	eax,edx			;5-digit quotient to eax
	or	eax,eax
	jz	ZeroHighDigits
ConvHigh5:
	cdq				;Zero edx
	shld	edx,eax,16		;Put quotient in dx:ax
	xor	bh,bh			;bx = 100
	div	bx			;Get 2- and 3-digit pieces. 22cl on 386
	xchg	edx,eax			;Save high 3 digits, get log 2 digits
	aam
	shl	ah,4			;Move digit to upper nybble
	or	al,ah
	shrd	ecx,eax,8
	mov	eax,edx			;Get high 3 digits
	mov	bl,10
	div	bl
	mov	bl,ah			;Remainder is next digit
	shrd	ecx,ebx,4
	aam				;Get last two digits
;Last two digits in ah:al
	ret

ZeroLowDigits:
	shr	ecx,16
	jmp	ConvHigh5

ZeroHighDigits:
	shr	ecx,12
	ret
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\emload.asm ===
subttl  emload.asm - FLD and FILD instructions
        page
;*******************************************************************************
;emload.asm - FLD and FILD instructions
;
;        Microsoft Confidential
;
;	 Copyright (c) Microsoft Corporation 1991
;        All Rights Reserved
;
;Purpose:
;       FLD and FILD instructions
;Inputs:
;	edi = [CURstk]
;	dseg:esi = pointer to memory operand
;
;Revision History:
;
; []	09/05/91  TP	Initial 32-bit version.
;
;*******************************************************************************


	PrevStackWrap	edi,LdStk	;Tied to PrevStackElem below

;*******
EM_ENTRY eFLDreg
eFLDreg:
;*******
;	edi = [CURstk]
;	esi = pointer to st(i) from instruction field

	PrevStackElem	edi,LdStk	;Point to receiving location
	cmp	EMSEG:[edi].bTag,bTAG_EMPTY	;Is it empty?
	jnz	FldErr
	mov	ecx,EMSEG:[esi].ExpSgn
	cmp	cl,bTAG_EMPTY
	jz	FldErr
	mov	ebx,EMSEG:[esi].lManHi
	mov	esi,EMSEG:[esi].lManLo
	mov	EMSEG:[CURstk],edi
	mov	EMSEG:[edi].lManLo,esi
	mov	EMSEG:[edi].lManHi,ebx
	mov	EMSEG:[edi].ExpSgn,ecx
	ret


;This is common code that stores a value into the stack after being loaded
;into registers by the appropriate routine.

	PrevStackWrap	edi,Load	;Tied to PrevStackElem below

FldCont:
;mantissa in ebx:esi, exp/sign in ecx
;edi = [CURstk]
	PrevStackElem	edi,Load	;Point to receiving location
	cmp	EMSEG:[edi].bTag,bTAG_EMPTY	;Is it empty?
	jnz	FldErr
	cmp	cl,bTAG_NAN		;Returning a NAN?
	jz	FldNAN
SaveStack:
	mov	EMSEG:[CURstk],edi
	mov	EMSEG:[edi].lManLo,esi
	mov	EMSEG:[edi].lManHi,ebx
	mov	EMSEG:[edi].ExpSgn,ecx
	ret

FldErr:
	or	EMSEG:[SWcc],C1		;Signal overflow
	mov	EMSEG:[CURerr],StackFlag;Kills possible denormal exception
Unsupported:
	call	ReturnIndefinite	;in emarith.asm
	jz	FldExit			;Unmasked, do nothing
	mov	EMSEG:[CURstk],edi	;Update top of stack
FldExit:
	ret

FldNAN:
;Is it a signaling NAN?
	test	ebx,1 shl 30		;Check for SNAN
	jnz	SaveStack		;If QNAN, just use it as result
	or	EMSEG:[CURerr],Invalid	;Flag the error
	or	ebx,1 shl 30		;Make it into a QNAN
	test	EMSEG:[CWmask],Invalid	;Is it masked?
	jnz	SaveStack		;If so, update with masked response
	ret


;****************
;Load Single Real
;****************

EM_ENTRY eFLD32
eFLD32:
	push	offset FldCont		;Return address
					;Fall into Load32Real
Load32Real:
;dseg:esi points to IEEE 32-bit real number
;On exit:
;	mantissa in ebx:esi, exponent in high ecx, sign in ch bit 7, tag in cl
;preserves edi.

        mov     EMSEG:[PrevDataOff],esi       ;Save operand pointer
	mov	ecx,dseg:[esi]		;Get number
	mov	ebx,ecx			;Save copy of mantissa
	shl	ebx,8			;Normalize
	shr	ecx,7			;Bring exponent down
	and	ecx,0FFH shl 16		;Look at just exponent
	mov	ch,dseg:[esi+3]		;Get sign again
	jz	short ZeroOrDenorm32	;Exponent is zero
	xor	esi,esi			;Zero out the low bits
	or	ebx,1 shl 31		;Set implied bit
	cmp	ecx,SexpMax shl 16
	jge	NANorInf		;Max exp., must be NAN or Infinity
	add	ecx,(TexpBias-SexpBias) shl 16	;Change to extended format bias
	mov	cl,bTAG_SNGL
	ret

ZeroOrDenorm32:
;Exponent is zero. Number is either zero or denormalized
	xor	esi,esi			;Zero out the low bits
	and	ebx,not (1 shl 31)	;Keep just mantissa
	jnz	Norm32
	mov	cl,bTAG_ZERO
	ret

Norm32:
	add	ecx,(TexpBias-SexpBias+1-31) shl 16	;Fix up bias
	jmp	FixDenorm


NANorInf:
;Shared by single and double real
	and	ecx,bSign shl 8		;Save only sign in ch
	or	ecx,TexpMax shl 16 + bTAG_NAN	;Max exp.
	cmp	ebx,1 shl 31		;Only 1 bit set means infinity
	jnz	@F
	or	esi,esi
	jnz	@F
	mov	cl,bTAG_INF
@@:
	ret

;****************
;Load Double Real
;****************

EM_ENTRY eFLD64
eFLD64:
	push	offset FldCont		;Return address
					;Fall into Load64Real
Load64Real:
;dseg:esi points to IEEE 64-bit real number
;On exit:
;	mantissa in ebx:esi, exponent in high ecx, sign in ch bit 7, tag in cl
;preserves edi.

        mov     EMSEG:[PrevDataOff],esi       ;Save operand pointer
	mov	ecx,dseg:[esi+4]		;Get sign, exp., and high mantissa
	mov	ebx,ecx			;Save copy of mantissa
	shr	ecx,4			;Bring exponent down
	and	ecx,7FFH shl 16		;Look at just exponent
	mov	ch,dseg:[esi+7]		;Get sign again
	mov	esi,dseg:[esi]		;Get low 32 bits of op
	jz	short ZeroOrDenorm64	;Exponent is zero
	shld	ebx,esi,31-20
	shl	esi,31-20		;Normalize
	or	ebx,1 shl 31		;Set implied bit
	cmp	ecx,DexpMax shl 16
	jge	NANorInf		;Max exp., must be NAN or Infinity
	add	ecx,(TexpBias-DexpBias) shl 16	;Change to extended format bias
SetNormTag:
	or	esi,esi			;Any bits in low half?
.erre	bTAG_VALID eq 1
.erre	bTAG_SNGL eq 0
	setnz   cl                      ;if low half==0 then cl=0 else cl=1
	ret

ZeroOrDenorm64:
;Exponent is zero. Number is either zero or denormalized
	and	ebx,0FFFFFH		;Keep just mantissa
	jnz	ShortNorm64		;Are top 20 bits zero?
	or	esi,esi			;Are low 32 bits zero too?
	jnz	LongNorm64
	mov	cl,bTAG_ZERO
	ret

LongNorm64:
	xchg	ebx,esi			;Shift up 32 bits
	sub	ecx,32 shl 16		;Correct exponent
ShortNorm64:
	add	ecx,(TexpBias-DexpBias+12-31) shl 16	;Fix up bias
FixDenorm:
	or	EMSEG:[CURerr],Denormal	;Set Denormal Exception
	bsr	edx,ebx			;Scan for MSB
;Bit number in edx ranges from 0 to 31
	mov	cl,dl
	not	cl			;Convert bit number to shift count
	shld	ebx,esi,cl
	shl	esi,cl
	shl	edx,16			;Move exp. adjustment to high end
	add	ecx,edx			;Adjust exponent
	jmp	SetNormTag


;******************
;Load Short Integer
;******************

EM_ENTRY eFILD16
eFILD16:
	push	offset FldCont		;Return address
					;Fall into Load16Int
Load16Int:
;dseg:esi points to 16-bit integer
;On exit:
;	mantissa in ebx:esi, exponent in high ecx, sign in ch bit 7, tag in cl
;preserves edi.

        mov     EMSEG:[PrevDataOff],esi       ;Save operand pointer
	mov	ax,dseg:[esi]
NormInt16:
	xor	esi,esi			;Extend with zero
	cwd				;extend sign through dx
	xor	ax,dx
	sub	ax,dx			;Take ABS() of integer
	bsr	cx,ax			;Find MSB
	jz	ZeroInt
;Bit number in cx ranges from 0 to 15
	not	ecx			;Convert to shift count
	shl	eax,cl			;Normalize
	not	ecx
.erre	TexpBias eq 0
	shl	ecx,16			;Move exponent to high half
	mov	ch,dh			;Set sign
	mov	ebx,eax			;Mantissa to ebx
	mov	cl,bTAG_SNGL
	ret

ZeroInt:
	xor	ebx,ebx
	mov	ecx,ebx
	mov	cl,bTAG_ZERO
	ret


;******************
;Load Long Integer
;******************

EM_ENTRY eFILD32
eFILD32:
	push	offset FldCont		;Return address
					;Fall into Load32Int
Load32Int:
;dseg:esi points to 32-bit integer
;On exit:
;	mantissa in ebx:esi, exponent in high ecx, sign in ch bit 7, tag in cl
;preserves edi.

        mov     EMSEG:[PrevDataOff],esi       ;Save operand pointer
	mov	eax,dseg:[esi]
	xor	esi,esi			;Extend with zero
	or	eax,eax			;It it zero?
	jz	ZeroInt
	cdq				;extend sign through edx
	xor	eax,edx
	sub	eax,edx			;Take ABS() of integer
	mov	ebx,eax			;Mantissa to ebx
;BSR uses 3 clocks/bit, so speed it up by checking the top half
;This saves 36 clocks on 386 (42 on 486sx)
;Cost is 13 clocks on 386 if high word isn't zero (5 on 486sx)
.erre	TexpBias eq 0
	xor	eax,eax			;Initialize exponent
	cmp	ebx,0FFFFH		;Upper bits zero?
	ja	@F
	shl	ebx,16
	sub	eax,16
@@:
	bsr	ecx,ebx			;Find MSB
	add	eax,ecx			;Compute expoment
	not	cl			;Convert bit number to shift count
	shl	ebx,cl			;Normalize
	shrd	ecx,eax,16		;Move exponent to high half of ecx
	mov	ch,dh			;Set sign
	mov	cl,bTAG_SNGL
	ret


;*****************
;Load Quad Integer
;*****************

EM_ENTRY eFILD64
eFILD64:
        mov     EMSEG:[PrevDataOff],esi       ;Save operand pointer
	mov	ebx,dseg:[esi+4]		;Get high 32 bits
	mov	eax,ebx			;Make copy of sign
	mov	esi,dseg:[esi]		;Get low 32 bits
	mov	ecx,ebx
	or	ecx,esi			;Is it zero?
	jz	ZeroQuad
NormQuadInt:
;Entry point from eFBLD
;eax bit 31 = sign
;ebx:esi = integer
;edi = [CURstk]
.erre	TexpBias eq 0
	mov     ax,32                   ;Initialize exponent
	or	ebx,ebx			;Check sign
	jz	LongNormInt
	jns	FindBit
	not	ebx
	neg	esi			;CY set if non-zero
	sbb	ebx,-1			;Add one if esi == 0
	jnz	FindBit			;Check for high bits zero
LongNormInt:
	xchg	ebx,esi			;Normalize 32 bits
	xor     ax,ax                   ;Reduce exponent by 32
FindBit:
;BSR uses 3 clocks/bit, so speed it up by checking the top half
;This saves 35 clocks on 386 (41 on 486sx)
;Cost is 11 clocks on 386 if high word isn't zero (4 on 486sx)
	cmp	ebx,0FFFFH		;Upper bits zero?
	ja	@F
	shld	ebx,esi,16
	shl	esi,16
	sub	eax,16
@@:
	bsr	ecx,ebx			;Find MSB
	add	eax,ecx			;Compute expoment
	not	cl			;Convert bit number to shift count
	shld	ebx,esi,cl		;Normalize
	shl	esi,cl
	mov     ecx,eax                 ;Move sign and exponent to ecx
	rol     ecx,16                  ;Swap sign and exponent halves
	or	esi,esi			;Any bits in low half?
.erre	bTAG_VALID eq 1
.erre	bTAG_SNGL eq 0
	setnz   cl                      ;if low half==0 then cl=0 else cl=1
	jmp	FldCont

ZeroQuad:
	mov	cl,bTAG_ZERO
	jmp	FldCont


;****************
;Load Temp Real
;****************

	PrevStackWrap	edi,Ld80	;Tied to PrevStackElem below

EM_ENTRY eFLD80
eFLD80:
;This is not considered an "arithmetic" operation (like all the others are),
;so SNANs do NOT cause an exception.  However, unsupported formats do.
        mov     EMSEG:[PrevDataOff],esi	;Save operand pointer
	PrevStackElem	edi,Ld80	;Point to receiving location
	cmp	EMSEG:[edi].bTag,bTAG_EMPTY	;Is it empty?
	jnz	FldErr
LoadTempReal:
	mov	ebx,dseg:[esi+4]	;Get high half of mantissa
	mov	cx,dseg:[esi+8]		;Get exponent and sign
	mov	esi,dseg:[esi]		;Get low half of mantissa
	mov	eax,ecx	
	and	ch,7FH			;Mask off sign bit
	shl	ecx,16			;Move exponent to high end
	mov	ch,ah			;Restore sign
	jz	ZeroOrDenorm80
;Check for unsupported format: unnormals (MSB not set)
	or	ebx,ebx
	jns	Unsupported
	sub	ecx,(IexpBias-TexpBias) shl 16	;Correct the bias
	cmp	ecx,TexpMax shl 16
	jge	NANorInf80
SetupTag:
	or	esi,esi			;Any bits in low half?
.erre	bTAG_VALID eq 1
.erre	bTAG_SNGL eq 0
	setnz   cl                      ;if low half==0 then cl=0 else cl=1
	jmp	SaveStack

NANorInf80:
	mov	cl,bTAG_NAN
	cmp	ebx,1 shl 31		;Only 1 bit set means infinity
	jnz	SaveStack
	or	esi,esi
	jnz	SaveStack
	mov	cl,bTAG_INF
	jmp	SaveStack

ZeroOrDenorm80:
;Exponent is zero. Number is either zero or denormalized
	or	ebx,ebx
	jnz	ShortNorm80		;Are top 32 bits zero?
	or	esi,esi			;Are low 32 bits zero too?
	jnz	LongNorm80
	mov	cl,bTAG_ZERO
	jmp	SaveStack

;This code accepts and works correctly with pseudo-denormals (MSB already set)
LongNorm80:
	xchg	ebx,esi			;Shift up 32 bits
	sub	ecx,32 shl 16		;Correct exponent
ShortNorm80:
	add	ecx,(TexpBias-IexpBias+1-31) shl 16	;Fix up bias
	bsr	edx,ebx			;Scan for MSB
;Bit number in edx ranges from 0 to 31
	mov	cl,dl
	not	cl			;Convert bit number to shift count
	shld	ebx,esi,cl
	shl	esi,cl
	shl	edx,16			;Move exp. adjustment to high end
	add	ecx,edx			;Adjust exponent
	jmp	SetUpTag
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\emlsenv.asm ===
subttl	emlsenv.asm - Emulator Save/Restore
	page
;***
;emlsenv.asm - Emulator Save/Restore
;
;
;	 Copyright (c) Microsoft Corporation 1991
;
;	 All Rights Reserved
;
;Purpose:
;	FLDCW, FSTCW, FSTSW, FSTENV, FLDENV, FSAVE, FRSTOR instructions
;
;Revision History:
;
; []	09/05/91  TP	Initial 32-bit version.
;
;
;*******************************************************************************


;When setting the control word, the [RoundMode] vector must be set
;according to the rounding and precision modes.

tRoundMode	label	dword
	irp	RC,<near,down,up,chop>
	irp	PC,<24,24,53,64>
	dd	Round&&PC&&RC
	endm
	endm


EM_ENTRY eFLDCW
eFLDCW:
;Uses only eax and ebx
	mov	ax, dseg:[esi]		; Fetch control word from user memory
SetControlWord:
	and	ax,0F3FH		; Limit to valid values
	mov	EMSEG:[ControlWord], ax	; Store in the emulated control word
	not	al			;Flip mask bits for fast compare
        and     al,3FH                  ;Limit to valid mask bits
	mov	EMSEG:[ErrMask],al
	and	eax,(RoundControl + PrecisionControl) shl 8
.erre	RoundControl eq 1100B
.erre	PrecisionControl eq 0011B
	shr	eax,6			;Put PC and RC in bits 2-5
	mov	ebx,tRoundMode[eax]	;Get correct RoundMode vector
	mov	EMSEG:[RoundMode],ebx
	mov	EMSEG:[SavedRoundMode],ebx
	and	eax,RoundControl shl (8-6)	;Mask off precision control
	mov	ebx,tRoundMode[eax+PC64 shl (8-6)];Get correct RoundMode vector
	mov	EMSEG:[TransRound],ebx	;Round mode w/o precision
	ret


EM_ENTRY eFSTCW
eFSTCW:
;Uses only eax 
	mov	ax, EMSEG:[ControlWord]	; Fetch user control word
	mov	dseg:[esi], ax		; Store into user memory
	ret


EM_ENTRY eFSTSW
eFSTSW:
;Uses only eax and ebx
	call	GetStatusWord		; Fetch emulated Status word
	mov	dseg:[esi], ax		; Store into user memory
	ret


eFSTSWax:
;Uses only eax and ebx
	call	GetStatusWord		; Fetch emulated Status word
	mov	[esp+4].regAX,ax
	ret


EM_ENTRY eFDECSTP
eFDECSTP:
;edi = [CURstk]
	cmp	edi,BEGstk
	jbe	DecWrap
	sub	EMSEG:[CURstk],Reg87Len
	ret

DecWrap:
	mov	EMSEG:[CURstk],INITstk
	ret


EM_ENTRY eFINCSTP
eFINCSTP:
;edi = [CURstk]
	cmp	edi,INITstk
	jae	IncWrap
	add	EMSEG:[CURstk],Reg87Len
	ret

IncWrap:
	mov	EMSEG:[CURstk],BEGstk
	ret


eFCLEX:
	mov	EMSEG:[SWerr],0
	and	[esp+4].OldLongStatus,0FFFF00FFH		; clear saved SWerr
	ret


;*** eFSTENV - emulate FSTENV	[address]
;
;   ARGUMENTS
;	    dseg:esi  = where to store environment
;
;
;   DESCRIPTION
;	    This routine emulates an 80387 FSTENV (store environment)
;

EM_ENTRY eFSTENV
eFSTENV:
	mov	ax,[esp+4].OldStatus
	mov	EMSEG:[StatusWord],ax
SaveEnv:
	xor	ax,ax
	mov	dseg:[esi.reserved1],ax
	mov	dseg:[esi.reserved2],ax
	mov	dseg:[esi.reserved3],ax
	mov	dseg:[esi.reserved4],ax
	mov	dseg:[esi.reserved5],ax
	mov	ax,EMSEG:[ControlWord]
	mov	dseg:[esi.E32_ControlWord],ax
	call	GetEMSEGStatusWord
	mov	dseg:[esi.E32_StatusWord],ax
	call	GetTagWord
	mov	dseg:[esi.E32_TagWord],ax
	mov	ax,cs
	mov	dseg:[esi.E32_CodeSeg],ax
	mov	ax,ss
	mov	dseg:[esi.E32_DataSeg],ax
	mov	eax,EMSEG:[PrevCodeOff]
	mov	dseg:[esi.E32_CodeOff],eax
	mov	eax,EMSEG:[PrevDataOff]
	mov	dseg:[esi.E32_DataOff],eax
        mov     EMSEG:[CWmask],03FH        ;Set all mask bits
	mov	EMSEG:[ErrMask],0
	ret


;*** eFSAVE - emulate FSAVE   [address]
;
;   ARGUMENTS
;	    dseg:esi  = where to store environment
;
;
;   DESCRIPTION
;	    This routine emulates an 80387 FSAVE (store environment)
;	    Once the data is stored an finit is executed.
;
;   REGISTERS
;	destroys ALL.

EM_ENTRY eFSAVE
eFSAVE:
	mov	ax,[esp+4].OldStatus
	mov	EMSEG:[StatusWord],ax
        mov     eax,[esp+4].OldCodeOff
        mov     EMSEG:[PrevCodeOff],eax
	push	offset eFINIT		; After fsave we must do a finit
SaveState:				; Enter here for debugger save state
	call	SaveEnv
	add	esi,size Env80x87_32	;Skip over environment
	mov	ebp,NumLev		;Save entire stack
	mov	edi,EMSEG:[CURstk]
FsaveStoreLoop:
	mov	eax,EMSEG:[edi].ExpSgn
	call	StoreTempReal		;in emstore.asm
        add     esi,10

        mov     edi,EMSEG:[CURstk]
        NextStackElem   edi,FSave
        mov     EMSEG:[CURstk],edi

        dec     ebp
	jnz	FsaveStoreLoop
	ret

WrapFSave:                              ; tied to NextStackElem above
        mov     edi, BEGstk
        mov     EMSEG:[CURstk],edi
        dec     ebp
        jnz     FsaveStoreLoop
        ret


;*** eFRSTOR - emulate FRSTOR  [address]
;
;   ARGUMENTS
;	    dseg:esi  = where to get the environment
;
;   DESCRIPTION
;	    This routine emulates an 80387 FRSTOR (restore state)

	NextStackWrap	edi,Frstor

EM_ENTRY eFRSTOR
eFRSTOR:
;First we set up the status word so that [CURstk] is initialized.
;The floating-point registers are stored in logical ST(0) - ST(7) order,
;not physical register order.  We don't do a full load of the environment
;because we're not ready to use the tag word yet.

    and		[esp+4].[OldLongStatus], NOT(LongSavedFlags)	;clear saved codes, errs
	mov	ax, dseg:[esi.E32_StatusWord]
	call	SetEmStatusWord		;Initialize [CURstk]
	add	esi,size Env80x87_32	;Skip over environment

;Load of temp real has one difference from real math chip: it is an invalid
;operation to load an unsupported format.  By ensuring the exception is
;masked, we will convert unsupported format to Indefinite.  Note that the
;mask and [CURerr] will be completely restored by the FLDENV at the end.

        mov     EMSEG:[CWmask],3FH              ;Mask off invalid operation exception
	mov	edi,EMSEG:[CURstk]
	mov	ebp,NumLev
FrstorLoadLoop:
	push	esi
	call	LoadTempReal		;In emload.asm
	pop	esi
	add	esi,10		;Point to next temp real
	NextStackElem	edi,Frstor
	dec	ebp
	jnz	FrstorLoadLoop
	sub	esi,NumLev*10+size Env80x87_32	;Point to start of env.
        jmp     eFLDENV                 ;Fall into eFLDENV


;***	eFLDENV - emulate FLDENV   [address]
;
;	ARGUMENTS
;	       dseg:si	= where to store environment
;
;	       This routine emulates an 80387 FLDENV (load environment)

EM_ENTRY eFLDENV
eFLDENV:
    and		[esp+4].[OldLongStatus], NOT(LongSavedFlags)	;clear saved codes, errs
	mov		ax, dseg:[esi.E32_StatusWord]
	call	SetEmStatusWord			; set up status word
	mov		ax, dseg:[esi.E32_ControlWord]
	call	SetControlWord
	mov		ax, dseg:[esi.E32_TagWord]
	call	UseTagWord
	mov		eax, dseg:[esi.E32_CodeOff]
	mov     EMSEG:[PrevCodeOff], eax
	mov		eax, dseg:[esi.E32_DataOff]
	mov     EMSEG:[PrevDataOff], eax
	ret


;***	GetTagWord - figures out what the tag word is from the numeric stack
;		   and returns the value of the tag word in ax.
;

GetTagWord:
	push	esi
	xor	eax, eax
	mov	ecx, NumLev		; get tags for regs. 0, 7 - 1
	mov	esi,INITstk
GetTagLoop:
	mov	bh, EMSEG:[esi.bTag]	; The top 2 bits of Tag are the X87 tag bits.
	shld	ax, bx, 2
	sub	esi, Reg87Len
	loop	GetTagLoop
	rol	ax, 2			; This moves Tag(0) into the low 2 bits
	pop	esi
	ret


;***	UseTagWord - Set up tags using tag word from environment
;
;	ARGUMENTS
;	       ax - should contain the tag word
;
;	Destroys ax,bx,cx,dx,di

UseTagWord:
	ror	ax, 2			; mov Tag(0) into top bits of ax
	mov	edi,INITstk
	mov	ecx, NumLev
UseTagLoop:
	mov	dl,bTAG_EMPTY
	cmp	ah, 0c0h		;Is register to be tagged Empty?
	jae	SetTag			;Yes, go mark it
	mov	dl,EMSEG:[edi].bTag	;Get current tag
	cmp	dl,bTAG_EMPTY		;Is register currently Empty?
	je	SetTagNotEmpty		;If so, go figure out tag for it
SetTag:
	mov	EMSEG:[edi].bTag,dl
UseTagLoopCheck:
	sub	edi, Reg87Len
	shl	eax, 2
	loop	UseTagLoop
	ret

SetTagEmpty:
	mov	EMSEG:[edi.bTag], bTAG_EMPTY
	jmp	UseTagLoopCheck

SetTagNotEmpty:
;Register is currently tagged empty, but new tag word says it is not empty.
;Figure out a new tag for it.  The rules are:
;
;1. Everything is either normalized or zero--unnormalized formats cannot
;get in.  So if the high half mantissa is zero, the number is zero.
;
;2. Although the exponent bias is different, NANs and Infinities are in
;standard IEEE format - exponent is TexpMax, mantissa indicates NAN vs.
;infinity (mantissa for infinity is 800..000H).
;
;3. Denormals have an exponent less than TexpMin.
;
;4. If the low half of the mantissa is zero, it is tagged bTAG_SNGL
;
;5. Everything else is bTAG_VALID

	mov	ebx,EMSEG:[edi].lManHi
	mov	dl,bTAG_ZERO		;Try zero first
	or	ebx,ebx			;Is mantissa zero?
	jz	SetTag
	mov	edx,EMSEG:[edi].ExpSgn
	mov	dl,bTAG_DEN
	cmp	edx,TexpMin shl 16	;Is it denormal?
	jl	SetTag
	cmp	EMSEG:[edi].lManLo,0	;Is low half zero?
.erre	bTAG_VALID eq 1
.erre	bTAG_SNGL eq 0
	setnz	dl			;if low half==0 then dl=0 else dl=1
	cmp	edx,TexpMax shl 16	;Is it NAN or Infinity?
	jl	SetTag			;If not, it's valid
.erre	(bTAG_VALID - bTAG_SNGL) shl TAG_SHIFT eq (bTAG_NAN - bTAG_INF)
	shl	dl,TAG_SHIFT
	add	dl,bTAG_INF - bTAG_SNGL
;If the low bits were zero we have just changed bTAG_SNGL to bTAG_INF
;If the low bits weren't zero, we changed bTAG_VALID to bTAG_NAN
;See if infinity is really possible: is high half 80..00H?
	cmp	ebx,1 shl 31		;Is it infinity?
	jz	SetTag			;Store tag for infinity or NAN
	mov	dl,bTAG_NAN
	jmp	SetTag


;***	GetStatusWord -
;
; User status word returned in ax.
; Destroys ebx only.

GetStatusWord:
	mov	eax, EMSEG:[CURstk]
	sub	eax, BEGstk
	mov	bl,Reg87Len
	div	bl
        inc     eax                     ; adjust for emulator's stack layout
	and	eax, 7			; eax is now the stack number
	shl	ax, 11
	or	ax,[esp+8].OldStatus	; or in the rest of the status word.
	ret


;***	GetEMSEGStatusWord -
;
; User status word returned in ax.
; Destroys ebx only.
; Uses status word in per-thread data area, otherwise
;   identical to GetStatusWord

EM_ENTRY eGetStatusWord
GetEMSEGStatusWord:
	mov	eax, EMSEG:[CURstk]
	sub	eax, BEGstk
	mov	bl,Reg87Len
	div	bl
        inc     eax                     ; adjust for emulator's stack layout
	and	eax, 7			; eax is now the stack number
	shl	ax, 11
	or	ax, EMSEG:[StatusWord]	; or in the rest of the status word.
	ret


;***	SetEmStatusWord -
;
; Given user status word in ax, set into emulator.
; Destroys ebx only.


SetEmStatusWord:
	and	ax,7F7FH
	mov	bx,ax
        and     bx,3FH                  ; set up CURerr in case user
	mov	EMSEG:[CURerr],bl	; wants to force an exception
	mov	ebx, eax
	and	ebx, not (7 shl 11)	; remove stack field.
	mov	EMSEG:[StatusWord], bx

	sub	ah, 8  			; adjust for emulator's stack layout
	and	ah, 7 shl 3
	mov	al, ah
	shr	ah, 1
	add	al, ah			; stack field * 3 * 4
.erre	Reg87Len eq 12	
	and	eax, 255	   	; eax is now 12*stack number
        add     eax, BEGstk
	mov	EMSEG:[CURstk], eax
	ret


public _SaveEm87Context
_SaveEm87Context PROC

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	push	esi
	mov	esi, [ebp+8]
	call	SaveState
	test	EMSEG:[CURErr], Summary
	jne	RetSaveEmIdle
	mov	eax, Em87Busy
	jmp	RetSaveEm
RetSaveEmIdle:
	mov	eax, Em87Idle
RetSaveEm:
	pop	esi
	pop	edi
	pop	ebx
	pop	ebp
	ret
_SaveEm87Context ENDP


public _RestoreEm87Context
_RestoreEm87Context PROC
	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi
	push	esi
	mov	esi, [ebp+8]
	call	eFRSTOR
	pop	esi
	pop	edi
	pop	ebx
	pop	ebp
	ret
_RestoreEm87Context  ENDP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\emfprem.asm ===
subttl emfprem.asm - FPREM and FPREM1 instructions
	page
;*******************************************************************************
;emfprem.asm - FPREM and FPREM1 instructions
;	by Tim Paterson
;
;        Microsoft Confidential
;
;	 Copyright (c) Microsoft Corporation 1991
;	 All Rights Reserved
;
;Inputs:
;	edi = [CURstk]
;	ST(1) loaded into ebx:esi & ecx
;
;Revision History:
;
; []	09/05/91  TP	Initial 32-bit version.
;
;*******************************************************************************

;Dispatch table for remainder
;
;One operand has been loaded into ecx:ebx:esi ("source"), the other is
;pointed to by edi ("dest").  
;
;Tag of source is shifted.  Tag values are as follows:

.erre   TAG_SNGL        eq      0       ;SINGLE: low 32 bits are zero
.erre   TAG_VALID       eq      1
.erre   TAG_ZERO        eq      2
.erre   TAG_SPCL        eq      3       ;NAN, Infinity, Denormal, Empty

;Any special case routines not found in this file are in emarith.asm

					;Divisor	Dividend
tFpremDisp	label	dword		;Source(ST(1))	Dest (ST(0))
	dd	PremDouble		;single		single
	dd	PremDouble		;single		double
	dd	PremX			;single		zero
	dd	PremSpclDest		;single		special
	dd	PremDouble		;double		single
	dd	PremDouble		;double		double
	dd	PremX			;double		zero
	dd	PremSpclDest		;double		special
	dd	ReturnIndefinite	;zero		single
	dd	ReturnIndefinite	;zero		double
	dd	ReturnIndefinite	;zero		zero
	dd	PremSpclDest		;zero		special
	dd	PremSpclSource		;special	single
	dd	PremSpclSource		;special	double
	dd	PremSpclSource		;special	zero
	dd	TwoOpBothSpcl		;special	special
	dd	ReturnIndefinite	;Two infinites


PremSpclDone:
	add	sp,4			;Clean off return address for normal
	ret

;***
PremSpclDest:
	mov	al,EMSEG:[edi].bTag		;Pick up tag
	cmp	al,bTAG_INF		;Dividing infinity?
	jz	ReturnIndefinite	;Invalid operation if so
	jmp	SpclDest		;In emarith.asm

;***
PremSpclSource:
	cmp	cl,bTAG_INF		;Dividing by infinity?
	jnz	SpclSource		;in emarith.asm
PremX:
;Return Dest unchanged, quotient = 0
	mov     EMSEG:[SWcc],0
	ret
;*******************************************************************************

;Map quotient bits to condition codes

Q0	equ	C1
Q1	equ	C3
Q2	equ	C0

MapQuo	label	byte
	db	0
	db	Q0
	db	Q1
	db	Q1+Q0
	db	Q2
	db	Q2+Q0
	db	Q2+Q1
	db	Q2+Q1+Q0

Prem1Cont:

;edx:eax = remainder, normalized
;ebx:esi = divisor
;ebp = quotient
;edi = exponent difference, zero or less
;ecx = 0 (positive sign)
;
;At this point, 0 <= remainder < divisor.  However, for FPREM1 we need
; -divisor/2 <= remainder <= divisor/2.  If remainder = divisor/2, whether
;we choose + or - is dependent on whichever gives us an even quotient
;(the usual IEEE rounding rule).  Quotient must be incremented if we
;use negative remainder.

	cmp	edi,-1
	jl	PremCont		;Remainder < divisor/2
	jg	NegRemainExp0		;Remainder > divisor/2
;Exponent is -1
	cmp	edx,ebx
	jl	PremCont		;Remainder < divisor/2
	jg	NegRemain		;Remainder > divisor/2
	cmp	eax,esi
	jl	PremCont		;Remainder < divisor/2
	jg	NegRemain		;Remainder > divisor/2
;Remainder = divisor/2.  Ensure quotient is even
	test	ebp,1			;Even?
	jz	PremCont
NegRemain:
;Theoretically we subtract divisor from remainder once more, leaving us
;with a negative remainder.  But since we use sign/magnitude representation,
;we want the abs() of that with sign bit set--so subtract remainder from
;(larger) divisor.  Note that exponent difference is -1, so we must align
;binary points first.
	add	esi,esi
	adc	ebx,ebx			;Double divisor to align binary points
NegRemainExp0:
	sub	esi,eax
	sbb	ebx,edx			;Subtract remainder
	mov	eax,esi
	mov	edx,ebx			;Result in edx:eax
	mov	ch,bSign		;Flip sign of remainder
	inc	ebp			;Increase quotient
;Must normalize result of subtraction
	bsr	ecx,edx			;Look for 1 bit
	jnz	@F
	sub	edi,32
	xchg	edx,eax			;Shift left 32 bits
	bsr	ecx,edx
@@:
	lea     edi,[edi+ecx-31]        ;Fix up exponent for normalization
	not     cl
	shld	edx,eax,cl
	shl	eax,cl
	mov	ch,bSign		;Flip sign of remainder

PremCont:
;edx:eax = remainder, normalized
;ebp = quotient
;edi = exponent difference, zero or less
;ch = sign
	or	eax,eax			;Low bits zero?
.erre	bTAG_VALID eq 1
.erre	bTAG_SNGL eq 0
	setnz   cl                      ;if low half==0 then cl=0 else cl=1
	mov	esi,EMSEG:[CURstk]
	mov     ebx,esi
	NextStackElem   ebx,Prem
	add	di,EMSEG:[ebx].wExp		;Compute result exponent
	cmp	di,IexpMin-IexpBias
	jle	PremUnderflow
SavePremResult:
	mov	EMSEG:[esi].lManLo,eax
	xor	EMSEG:[esi].bSgn,ch
	mov	EMSEG:[esi].lManHi,edx
	and	ebp,7			;Keep last 3 bits of quotient only
					;  and give write buffers a break
	mov	EMSEG:[esi].wExp,di
	mov	EMSEG:[esi].bTag,cl
	mov	al,MapQuo[ebp]		;Get cond. codes for this quotient
	mov	EMSEG:[SWcc],al
	ret

	NextStackWrap   ebx,Prem        ;Tied to NextStackElem above

PremUnderflow:
	test	EMSEG:[CWmask],Underflow	;Is exception unmasked?
	jz	UnmaskedPremUnder
	mov	cl,bTAG_DEN
	jmp	SavePremResult

UnmaskedPremUnder:
	add	edi,UnderBias		;Additional exp. bias for unmasked resp.
	or	EMSEG:[CURerr],Underflow
	jmp	SavePremResult

;*******************************************************************************

PremDouble:
;edi = [CURstk]
;ebx:esi = ST(1) mantissa, ecx = ExpSgn

	add	sp,4			;Clean off return address for special
	mov	eax,EMSEG:[edi].lManLo
	mov	edx,EMSEG:[edi].lManHi
	movsx	edi,EMSEG:[edi].wExp
	xor	ebp,ebp			;Quotient, in case we skip stage 1
	sar	ecx,16			;Bring exponent down
	sub	edi,ecx			;Get exponent difference
	jl	ExitPremLoop		;If dividend is smaller, return it.

;FPREM is performed in two stages.  The first stage is used only if the
;exponent difference is greater than 31.  It reduces the exponent difference
;by 32, and repeats until the difference is less than 32.  Note that
;unlike the hardware FPREM instruction, we are not limited to reducing
;the exponent by only 63--we just keep looping until it's done.
;
;The second stage performs ordinary 1-bit-at-a-time long division.
;It stops when the exponent difference is zero, meaning we have an
;integer quotient and the final remainder.
;
;edx:eax = dividend
;ebx:esi = divisor
;edi = exponent difference
;ebp = 0 (initial quotient)

	cmp	edi,32			;Do we need to do stage 1?
	jl	FitDivisor		;No, start stage 2

;FPREM stage 1
;
;Exponent difference is at least 32.  Use 32-bit division to compute
;quotient and exact remainder, reducing exponent difference by 32.

;DIV instruction will overflow if dividend >= divisor.  In this case,
;subtract divisor from dividend to ensure no overflow.  This will change
;the quotient, but that doesn't matter because we only need the last
;3 bits of the quotient (and we're about to calculate 32 quotient bits).
;This subtraction will not affect the remainder.

	sub	eax,esi
	sbb	edx,ebx	
	jnc	FpremReduce32		;Was dividend big?
	add	eax,esi			;Restore dividend, it was smaller
	adc	edx,ebx

;Division algorithm from Knuth vol. 2, p. 237, using 32-bit "digits":
;Guess a quotient digit by dividing two MSDs of dividend by the MSD of
;divisor.  If divisor is >= 1/2 the radix (radix = 2^32 in this case), then
;this guess will be no more than 2 larger than the correct value of that
;quotient digit (and never smaller).  Divisor meets magnitude condition 
;because it's normalized.
;
;This loop typically takes 117 clocks.

;edx:eax = dividend
;ebx:esi = divisor
;edi = exponent difference
;ebp = quotient (zero)

FpremReduce32:
;We know that dividend < divisor, but it is still possible that 
;high dividend == high divisor, which will cause the DIV instruction
;to overflow.
	cmp	edx,ebx			;Will DIV instruction overflow?
	jae	PremOvfl
	div	ebx			;Guess a quotient "digit"

;Currently, remainder in edx = dividend - (quotient * high half divisor).
;The definition of remainder is dividend - (quotient * all divisor).  So
;if we subtract (quotient * low half divisor) from edx, we'll get
;the true remainder.  If it's negative, our guess was too big.

	mov	ebp,eax			;Save quotient
	mov	ecx,edx			;Save remainder
	mul	esi			;Quotient * low half divisor
	neg	eax			;Subtract from dividend extended with 0
	sbb	ecx,edx			;Subtract from remainder
	mov	edx,ecx			;Remainder back to edx:eax
	jnc	HavPremQuo		;Was quotient OK?
FpremCorrect:
	dec	ebp			;Quotient was too big
	add	eax,esi			;Add divisor back into remainder
	adc	edx,ebx
	jnc	FpremCorrect		;Repeat if quotient is still too big
HavPremQuo:
	sub	edi,32			;Exponent reduced
	cmp	edi,32			;Exponent difference within 31?
	jl	PremNormalize		;Do it a bit a time
	or	edx,edx			;Check for zero remainder
	jnz	FpremReduce32
	or	eax,eax			;Remainder 0?
	jz	ExactPrem
	xchg	edx,eax			;Shift left 32 bits
	sub	edi,32			;Another 32 bits reduced
	cmp	edi,32
	jge	FpremReduce32
	xor	ebp,ebp			;No quotient bits are valid
	jmp	PremNormalize

PremOvfl:
;edx:eax = dividend
;ebx:esi = divisor
;On exit, ebp = second quotient "digit"
;
;Come here if divide instruction would overflow. This must mean that edx == ebx,
;i.e., the high halves of the dividend and divisor are equal. Assume a result
;of 2^32-1, thus remainder = dividend - ( divisor * (2^32-1) )
; = dividend - divisor * 2^32 + divisor. Since the high halves of the dividend
;and divisor are equal, dividend - divisor * 2^32 can be computed by
;subtracting only the low halves. When adding divisor (in ebx) to this, note
;that edx == ebx, and we want the result in edx anyway.
;
;Note also that since dividend < divisor, the
;dividend - divisor * 2^32 calculation must always be negative. Thus the 
;addition of divisor back to it should generate a carry if it goes positive.

	mov	ebp,-1			;Max quotient digit
	sub	eax,esi			;Calculate correct remainder
	add	edx,eax			;Should set CY if quotient fit
	mov	eax,esi			;edx:eax has new remainder
	jc	HavPremQuo		;Remainder was positive
	jmp	FpremCorrect

ExactPrem:
;eax = 0
	mov	esi,EMSEG:[CURstk]
	mov	EMSEG:[esi].lManLo,eax
	mov	EMSEG:[esi].lManHi,eax
	add	sp,4			;Clean off first return address
	mov	EMSEG:[esi].wExp,ax
	mov	EMSEG:[esi].bTag,bTAG_ZERO
	ret


;FPREM stage 2
;
;Exponent difference is less than 32.  Use restoring long division to
;compute quotient bits until exponent difference is zero.  Note that we
;often get more than one bit/loop:  BSR is used to scan off leading
;zeros each time around.  Since the divisor is normalized, we can
;instantly compute a zero quotient bit for each leading zero bit.
;
;For reductions of 1 to 31 bits per loop, this loop requires 41 or 59 clocks
;plus 3 clocks/bit (BSR time).  If we had to use this for 32-bit reductions
;(without stage 1), we could expect (50+6)*16 = 896 clocks typ (2 bits/loop)
;instead of the 112 required by stage 1!

FpremLoop:
;edx:eax = dividend (remainder) minus divisor
;ebx:esi = divisor
;ebp = quotient
;edi = exponent difference, less than 32
;
;If R is current remainder and d is divisor, then we have edx:eax = R - d, 
;which is negative.  We want 2*R - d, which is positive.  
;2*R - d = 2*(R - d) + d.
	add	eax,eax			;2*(R - d)
	adc	edx,edx
	add	eax,esi			;2*(R-d) + d = 2*R - d
	adc	edx,ebx	
	add	ebp,ebp			;Double quotient too
	dec	edi			;Decrement exponent difference
DivisorFit:
	inc	ebp			;Count one in quotient
PremNormalize:
	bsr	ecx,edx			;Find first 1 bit
	jz	PremHighZero
	not     cl
	and     cl,1FH                  ;Convert bit no. to shift count
	shld	edx,eax,cl		;Normalize
	shl	eax,cl
	sub	edi,ecx			;Reduce exponent difference
	jl	PremTooFar
	shl	ebp,cl			;Shift quotient
FitDivisor:
;Dividend could be larger or smaller than divisor
	sub	eax,esi
	sbb	edx,ebx
	jnc	DivisorFit
;Couldn't subtract divisor from dividend.
	or	edi,edi			;Is exponent difference zero or less?
	jg	FpremLoop
	add	eax,esi			;Restore dividend
	adc	edx,ebx
	xor	ecx,ecx			;Sign is positive
	ret

PremTooFar:
;Exponent difference in edi went negative when reduced by shift count in ecx.
;We need a quotient corresponding to exponent difference of zero.
	add	ecx,edi			;Restore exponent difference
	shl	ebp,cl			;Fix up quotient
ExitPremLoop:
;edx:eax = remainder, normalized
;ebp = quotient
;edi = exponent difference, zero or less
	xor	ecx,ecx			;Sign is positive
	ret

PremHighZero:
;High half of remainder is all zero, so we've reduced exponent difference
;by 32 bits and overshot.  We need a quotient corresponding to exponent 
;difference of zero, so we just shift it by the original difference.  Then
;we need to normalize the low half remainder.
	mov	ecx,edi
	shl	ebp,cl			;Fix up quotient
	bsr	ecx,eax
	jz	ExactPrem
	lea     edi,[edi+ecx-63]        ;Fix up exponent for normalization
	xchg	eax,edx			;Shift by 32 bits
	not     cl
        shl     edx,cl                  ;Normalize remainder
        xor     ecx,ecx                 ;Sign is positive
        ret
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\emfsqrt.asm ===
subttl	emfsqrt.asm - FSQRT instruction
	page
;*******************************************************************************
;emfsqrt.asm - FSQRT instruction
;	by Tim Paterson
;
;	 Microsoft Confidential
;
;	 Copyright (c) Microsoft Corporation 1991
;	 All Rights Reserved
;
;Inputs:
;	edi = [CURstk]
;
;Revision History:
;
; []	09/05/91  TP	Initial 32-bit version.
;
;*******************************************************************************


;A linear approximation of the square root function is used to get the
;intial value for Newton-Raphson iteration.  This approximation gives
;nearly 5-bit accuracy over the required input interval, [1,4).  The
;equation for the linear approximation of y = sqrt(x) is y = mx + b,
;where m is the slope (named SQRT_COEF) and b is the y-intercept (named
;SQRT_INTERCEPT).
;
;(The values for m and b were computed with Excel Solver in two passes: 
;the first pass computed them full precision, minimizing absolute error;
;the second computed only b after m was rounded to an 8-bit value.)
;
;The resulting values have the following maximum error:
;
;inp. value -->		1		 2.18972	3.82505
;----------------------------------------------------------------
;abs. err., full prec.	0.04544		-0.03233	0.04423
;abs. err., truncated	0.04544		-0.04546	0.04423
;
;The three input values shown represent the left end point, the maximum 
;error (derivative of absolute error == 0), and the right end point.  
;The right end point is not 4 because the approximation reaches 2.000
;at the value given--we abandon the linear approximation at that point
;and use that same value for all greater input values.	This linear
;approximation is computed with 8-bit operations, so truncations can
;add a negative error.  This increases maximum error only when it is
;already negative, as shown in the table.
;
;Each iteration of Newton-Raphson approximation more than doubles the
;number of bits of accuracy.  Suppose the current guess is A, and it has
;an absolute error of e (i.e., A+e or A-e is the root).  Then the absolute
;error after the next iteration is e^2/2A.  This error is always positive.
;However, the divide instruction truncates, which introduces an error
;that is always negative.  Sometimes a constant or rounding bit is added
;to balance the positive and negative errors.  The maximum possible error 
;is given in comments below for each iteration.  (Note that when we compute 
;the error from e^2/2A, A could be in the range 1 to 2--we use 1 to get
;max error.)  Remember that the binary point is to the RIGHT of the MSB
;when looking at these error numbers.


;SQRT_INTERCEPT is used when the binary point is to the right of the MSB.
;Multiplying it by 64K would put the binary point to the left of the MSB,
;so it must be divided by two to be aligned.
SQRT_INTERCEPT	equ	23185		; 0.70755 * 65536 / 2

;SQRT_COEF would have the binary point to the left of the MSB if multiplied
;by 256.  However, this would leave it with a leading zero, so we multiply
;it by two more to normalize it.
SQRT_COEF	equ	173		; 0.33789 * 256 * 2

SqrtSpcl:
	cmp	al,bTAG_DEN
	jz	SqrtDen
	cmp	al,bTAG_INF
	jnz	SpclDestNotDen
;Have infinity
	or	ah,ah			;Is it negative?
	js	ReturnIndefinite
SqrtRet:
	ret


MaxStartRoot:
;The first iteration is calculated as  (ax / bh) * 100H + bx.  The first 
;trial root in bx should be 10000H (which is too big).  But it's very
;easy to calculate (ax / 100H) * 100H + 10000H = ax.
	mov	bx,ax
	cmp	ax,-1			;Would subsequent DIV overflow?
	jb	FirstTrialRoot
;The reduced argument is so close to 4.0 that the 16-bit DIV instruction
;used in the next iteration would overflow.  If the argument is 4-A 
;then a guess of 2.0 is in error by approximately A/4.  [This is not
;an upper bound.  The error is a little by more than this by an
;addition with the magnitude of A^2.  This is an insignificant amount
;when A is small.]  This means that the first guess of 2.0 is quite
;accurate, and we'll use it to bypass some of the iteration steps. 
;This will eliminate the DIV overflow by skipping the DIV.
;
;One iteration is performed by: (Arg/Guess + Guess)/2.  When Guess = 2,
;this becomes (Arg/2 + 2)/2 = Arg/4 + 1.  We get Arg/2 just by assuming
;the binary point is one bit further left; then a single right shift is
;needed to get Arg/4.  By shifting in a 1 bit on the left, we account for
;adding 1 at the same time.  [Note that if Arg = 4 - A, then Arg/4 + 1
; = (4 - A)/4 + 1 = 1 - A/4 + 1 = 2 - A/4.  In other words, we just
;subtract out exactly what we estimate our error to be, A/4.]
;
;Since the upper 16 bits are 0FFFFH, A <= 2^-14, so error <= 2^-16 =
; +0.00001526, -0.
	mov	ebx,esi			;Return root in ebx
	sar	ebx,1			;Trial root = arg/2
	cmp	esi,ebx			;Will 32-bit division overflow?
	jb	StartThirdIteration	;No, our 32-bit guess is good
;Argument is really, really close to 4.0: with an initial trial root of
;2.0, max absolute error is 2^-32 = +2.328E-10, -0.  One trivial
;iteration will get us 65-bit accuracy, max abs. error = +2.71E-20, -0.
	mov	ebx,esi
	mov	eax,ecx			;65-bit root*2 in ebx:eax (MSB implied)
	shl	ecx,2			;ecx = low half*4
	jmp	RoundRoot

SqrtDen:
	mov	EMSEG:[CURerr],Denormal
	test	EMSEG:[CWmask],Denormal ;Is denormal exception masked?
	jnz	SqrtRet			;If not, quit

;******
EM_ENTRY eFSQRT
eFSQRT:
;******
	mov	eax,EMSEG:[edi].ExpSgn
	cmp	al,bTAG_ZERO
	jz	SqrtRet
	ja	SqrtSpcl
	or	ah,ah
	js	ReturnIndefinite
	mov	esi,EMSEG:[edi].lManHi
	mov	ecx,EMSEG:[edi].lManLo
	sar	EMSEG:[edi].wExp,1	;Divide exponent by two
	mov	edi,0			;Extend mantissa
	jc	RootAligned		;If odd exponent, leave it normalized
	shrd	edi,ecx,1
	shrd	ecx,esi,1
	shr	esi,1			;Denormalize, extending into edi
RootAligned:
;esi:ecx:edi has mantissa, 2 MSBs are left of binary point. Range is [1,4).
	shld	eax,esi,16		;Get high word of mantissa
	movzx	ebx,ah			;High byte to bl
;UNDONE:  MASM 6 bug!!
;UNDONE:  SQRT_COEF (=0AEH) get sign extended!!
	mov	dx,SQRT_COEF		;UNDONE
	imul	bx,dx			;UNDONE
;UNDONE imul	bx,SQRT_COEF		;Product in bx
;Multiply by SQRT_COEF causes binary point to shift left 1 bit.
	add	bx,SQRT_INTERCEPT	;5-bit approx. square root in bh
	jc	MaxStartRoot
;Max absolute error is +/- 0.04546
	div	bh			;See how close we are
	add	bh,al			;quotient + divisor (always sets CY)
FirstTrialRoot:
;Avoid RCR because it takes 9 clocks on 386.  Use SHRD (3 clocks) instead.
	mov	dl,1			;Need bit set
	shrd	bx,dx,1			;(quotient + divisor)/2
;bx has 9-bit approx. square root, normalized
;Max absolute error is +0.001033, -0.003906
	movzx	eax,si
	shld	edx,esi,16		;dx:ax has high half mantissa
	div	bx			;Test our approximation
	add	ebx,eax			;quotient + divisor
	shl	ebx,15			;Normalize (quotient + divisor)/2
;ebx has 17-bit approx. square root, normalized
;Max absolute error is +0.000007629, -0.00001526
;Add adjustment factor to center the error range at +/-0.00001144
	or	bh,20H			;Add in 0.000003815
StartThirdIteration:
	mov	edx,esi
	mov	eax,ecx
	div	ebx			;Test approximation
	stc				;Set bit for rounding (= 2.328E-10)
	adc	ebx,eax			;quotient + divisor + round bit
;Avoid RCR because it takes 9 clocks on 386.  Use SHRD (3 clocks) instead.
	mov	dl,1			;Need bit set
	shrd	ebx,edx,1		;(quotient + divisor)/2, rounded
;ebx has 32-bit approx. square root, normalized
;Max absolute error is +2.983E-10, -2.328E-10
	mov	edx,esi			;Last time we need high half
	mov	eax,ecx
	shld	ecx,edi,2		;ecx = low half*4, w/extension back in
	div	ebx			;Test approximation
	xchg	edi,eax			;Save 1st quotient, get extension
	mov	esi,eax
	or	esi,edx			;Any remainder?
	jz	HaveRoot		;Result is ebx:esi
	div	ebx			;edi:eax is 64-bit quotient
	add	ebx,edi			;quotient + divisor (always sets CY)
RoundRoot:
	mov	esi,eax			;Save low half root*2

;We have 65-bit root*2 in ebx:esi (eax==esi) (MSB is implied one).
;Max absolute error is +4.450E-20, -5.421E-20.	This maximum error 
;corresponds to just less than +/- 1 in the last (65th) bit.  
;	
;We have to determine if this error is positive or negative so
;we can tell if we rounded up or down (and set the status bit
;accordingly).	This is done by squaring the root and comparing the
;that result with the input.
;
;Squaring the sample root requires summing partial products:
; lo*lo + lo*hi + hi*lo + hi*hi.  lo*hi == hi*lo, so only one multiply
;is needed there.  The low half of lo*lo isn't relevant, we know it
;is non-zero.  Only the low few bits of hi*hi are needed, so we can use
;an 8-bit multiply there.  Since the MSB is implied, we need to add in
;two 1*lo products (shifted up 64 bits).  We only need bits 64 - 71 of
;the 130-bit product (the action happens near bit 65).	What we're 
;squaring is root*2, so the result is square*4.  ecx already has arg*4.

	mul	eax			;Low partial product of square
	mov	edi,edx			;Only high half counts
	mov	eax,ebx
	mul	esi			;Middle partial product of square
	add	eax,eax			;There are two of these
	adc	edx,edx
	add	edi,eax
	adc	edx,0			;edx:edi = lo*lo + lo*hi + hi*lo
	add	edx,esi			;lo*implied msb
	add	edx,esi			;lo*implied msb again
	mov	al,bl
	mul	al			;hi*hi - only low 8 bits are valid
	add	al,dl			;Bits 64 - 71 of product
	or	al,1			;Account for sticky bits 0 - 63
	sub	cl,al			;Compare product with argument
;Sign flag set if product is larger.  In this case, subtract 1 from root.
	add	cl,cl			;Set CY if sign is set
SubOneFromRoot:
	sbb	esi,0			;Reduce root if product was too big
	sbb	ebx,0
ShiftRoot:
;ebx:esi = root*2
;Absolute error is in the range (0, -5.421E-20).  This is equivalent to
;less than +1, -0 in last bit.	Thus LSB is correct rounding bit as 
;long as we set a sticky bit below it.
;
;Now divide root*2 by 2, preserving LSB as rounding bit and filling
;eax with 1's as sticky bits.
;
;Avoid RCR because it takes 9 clocks on 386.  Use SHRD (3 clocks) instead.
	mov	eax,-1
	shrd	eax,esi,1		;Move round bit to MSB of eax
	shrd	esi,ebx,1
	shrd	ebx,eax,1		;Shift 1 into MSB of ebx
StoreRoot:
	mov	edi,EMSEG:[CURstk]
	mov	EMSEG:[Result],edi
	mov	ecx,EMSEG:[edi].ExpSgn
;mantissa in ebx:esi:eax, exponent in high ebx, sign in bh bit 7
	jmp	EMSEG:[RoundMode]

HaveRoot:
;esi = eax = edx = 0
	cmp	edi,ebx			;Does quotient == divisor?
	jz	StoreRoot		;If so, we're done
;Quotient != divisor, so answer is not exact.  Since remainder is zero,
;the division was exact.  The only error in the result is e^2/2A, which
;is always positive.  We need the error to be only negative so that
;the rounding routine can properly tell if it rounded up.
	add	ebx,edi			;quotient + divisor (always sets CY)
	jmp	SubOneFromRoot		;Reduce root to ensure negative error
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\emsincos.asm ===
;      SCCSID = @(#)emsincos.asm	       13.5 90/03/27
	page	,132
	subttl	emsincos - fsin, fcos and fsincos
;***
;emulator.asm -  80387 emulator
;
;	 IBM/Microsoft Confidential
;
;	 Copyright (c) IBM Corporation 1987, 1989
;	 Copyright (c) Microsoft Corporation 1987, 1989
;
;	 All Rights Reserved
;
;Purpose:
;	Code for fsin, fcos and fsincos
;
;Revision History:
;	See emulator.hst
;
;*******************************************************************************

lab eFsincosStackOver
	or	SEL[CURerr], StackFlag or Invalid
	test	SEL[CWmask], Invalid
	JSZ	eFsincosStackOverRet

	mov	SEL[rsi.lMan0], 0			; st(0) = Ind
	mov	SEL[rsi.lMan1], 0c0000000h
	mov	SEL[rsi.wExp], 7fffh - IexpBias
	mov	SEL[rsi.bTag], bTAG_NAN
	mov	SEL[rsi.bFlags], bSign

	mov	SEL[rdi.lMan0], 0			; st(-1) = Ind
	mov	SEL[rdi.lMan1], 0c0000000h
	mov	SEL[rdi.wExp], 7fffh - IexpBias
	mov	SEL[rdi.bTag], bTAG_NAN
	mov	SEL[rdi.bFlags], bSign

	mov	SEL[CURstk], rdi		; push stack
lab eFsincosStackOverRet
	ret


lab eFSINCOS
	mov	esi, SEL[CURStk]    ; esi = st(0)
	mov	edi, esi
	PrevStackElem	 edi	    ; edi = st(-1)

	cmp	SEL[edi.bTag], bTAG_EMPTY
	JSNE	eFsincosStackOver

	cmp	SEL[esi.bTag], bTAG_NAN
	JSNE	eFsincosNotSNaN

	test	SEL[esi.bMan7], 40h
	JSNZ	eFsincosNotSNaN

	test	SEL[CWmask], Invalid
	JSNZ	eFsincosNotSNaN

	or	SEL[CURerr], Invalid
	ret

lab eFsincosNotSNaN
ifdef NT386
        push    eax
        mov     eax, dword ptr SEL[rsi]
        mov     dword ptr SEL[rdi], eax
        mov     eax, dword ptr SEL[rsi+4]
        mov     dword ptr SEL[rdi+4], eax
        mov     eax, dword ptr SEL[rsi+8]
        mov     dword ptr SEL[rdi+8], eax
        add     rsi, Reg87Len
        add     rdi, Reg87Len
        pop     eax
else
        push	ds		    ; Copy current stack into st(-1)
	pop	es
	movsd
	movsd
	movsd
endif

	call	eFSIN
	PUSHST
	call	eFCOS

	ret


lab eFcosSpecial
	mov	esp, ebp
	pop	ebp

	mov	SEL[RESULT], esi

	mov	al, SEL[esi.bTag]
	cmp	al, bTAG_ZERO
	JSNE	eFcosInf

lab eFcosRetOne
	mov	SEL[esi.lMan0], 0
	mov	SEL[esi.lMan1], 080000000h
	mov	SEL[esi.wExp], 3fffh - IexpBias
	mov	SEL[esi.bFlags], 0
	mov	SEL[esi.bTag], bTAG_VALID
	ret

lab eFcosInf
	cmp	al, bTAG_INF
	JE	RetIndInv

lab eFcosNaN
	jmp	OneArgOpNaNRet


cProc  eFCOS,<PLM,PUBLIC>,<>

	localT	temp
	localB	SignFlag

cBegin
	mov	esi, SEL[CURstk]

	cmp	SEL[esi.bTag], bTAG_VALID
	jne	eFcosSpecial

	or	SEL[CURerr], Precision

	and	SEL[esi].bFlags, not bSign ; st(0) = fabs( st(0) );

	call	SinCosReduce		; Set ah to condition code.

	add	SEL[esi].wExp, IExpBias

	push	SEL[esi].wExp
	push	SEL[esi].lMan1
	push	SEL[esi].lMan0
	lea	ecx, [temp]
	push	ecx

	mov	bl, ah			; if octant 2, 3, 4, or 5 then final
	and	bl, bOCT2 or bOCT4	; result must be negative
	mov	[SignFlag], bl

	test	ah, bOCT1 or bOCT2	; if octant is 1, 2, 5, 6 then must
	jpo	CosCallSin		; do sin()

	call	__FASTLDCOS
	jmp	short CosCopyRes

CosCallSin:
	call	__FASTLDSIN

CosCopyRes:
	mov	eax, dword ptr [temp]
	mov	SEL[esi].lMan0, eax
	mov	eax, dword ptr [temp+4]
	mov	SEL[esi].lMan1, eax

	mov	ax,  word ptr [temp+8]
	sub	ax, IExpBias
	mov	SEL[esi].wExp, ax

	cmp	[SignFlag], 0
	jpe	CosDone

	or	SEL[esi].bFlags, bSign	; Make result negative.
CosDone:

cEnd





lab eFsinSpecial
	mov	esp, ebp
	pop	ebp

	mov	al, SEL[esi.bTag]
	cmp	al, bTAG_ZERO
	JSNE	eFsinInf

lab eFsinZero
	ret

lab eFsinInf
	cmp	al, bTAG_INF
	JE	RetIndInv

lab eFsinNaN
	jmp	OneArgOpNaNRet


cProc  eFSIN,<PLM,PUBLIC>,<>

	localT	temp
	localB	SignFlag

cBegin
	mov	esi, SEL[CURstk]

	cmp	SEL[esi.bTag], bTAG_VALID
	jne	eFsinSpecial

	or	SEL[CURerr], Precision

	mov	al, SEL[esi].bFlags
	and	SEL[esi].bFlags, not bSign

	shl	al, 1		    ; shift sign into carry.
	sbb	cl, cl		    ; set cl to -1 if argument is negative.

	push	ecx
	call	SinCosReduce	    ; Set ah to condition code.
	pop	ecx

	cmp	SEL[esi].bTag, bTAG_ZERO
	je	SinDone

	add	SEL[esi].wExp, IExpBias

	push	SEL[esi].wExp
	push	SEL[esi].lMan1
	push	SEL[esi].lMan0
	lea	ebx, [temp]
	push	ebx

	mov	bl, ah			; if octant 4, 5, 6 or 7 then final
	and	bl, bOCT4		; result must be negative

	neg	cl			; set cl to odd parity if arg was < 0.0
	xor	bl, cl			; set bl to odd parity if result must be negative

	mov	[SignFlag], bl

	test	ah, bOCT1 or bOCT2	; if octant is 1, 2, 5, 6 then must
	jpo	SinCallCos		; do cos()

	call	__FASTLDSIN
	jmp	short SinCopyResult

SinCallCos:
	call	__FASTLDCOS

SinCopyResult:
	mov	eax, dword ptr [temp]
	mov	SEL[esi].lMan0, eax
	mov	eax, dword ptr [temp+4]
	mov	SEL[esi].lMan1, eax

	mov	ax, word ptr [temp+8]
	sub	ax, IExpBias
	mov	SEL[esi].wExp, ax

	cmp	[SignFlag], 0
	jpe	SinDone

	or	SEL[esi].bFlags, bSign	; Make result negative.
SinDone:

cEnd



lab SinCosReduce
	mov	SEL[TEMP1.bFlags], 0		; TEMP1 = pi/4
	mov	SEL[TEMP1.bTag], bTAG_VALID
	mov	SEL[TEMP1.wExp], 3ffeh-IExpBias
	mov	SEL[TEMP1.wMan3], 0c90fh
	mov	SEL[TEMP1.wMan2], 0daa2h
	mov	SEL[TEMP1.wMan1],	2168h
	mov	SEL[TEMP1.wMan0], 0c235h

ifdef NT386
        mov     edi, TEMP1
else
	mov	edi, edataOFFSET TEMP1
endif

	push	esi
	call	InternFPREM		    ; rsi = st(0), rdi = st(0)
	pop	esi

	mov	ah, SEL[SWcc]

	test	ah, bOCT1		; check for even octant
	jz	EvenOct 		;   yes

	add	SEL[esi.wExp], IExpBias	; convert to true long double

	push	ds
	push	esi
	push	cs
	push	ecodeOFFSET PIBY4
	push	ds
	push	esi
	push	-1
	call	__FASTLDADD		; st(0) = pi/4 - st(0)
	mov	ah, SEL[SWcc]

	sub	SEL[esi.wExp], IExpBias	; convert to squirly emulator long double

EvenOct:
	retn



labelW	PIBY4
    dw	    0c235h, 02168h, 0daa2h, 0c90fh, 3ffeh

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; NOTE tedm:   NT masm can't handle floating-point constants  ;
;              because strtod and _strtold C-runtimes aren't  ;
;              there.  So the constants below must be pre-    ;
;              assembled and defined as a byte stream.        ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ifdef NOTDEF

staticT  FourByPI, +0.1273239544735162686151e+01

staticT  SinP0, +0.7853981633974483096141845e+00
staticT  SinP1, -0.8074551218828078152025820e-01
staticT  SinP2, +0.2490394570192716275251900e-02
staticT  SinP3, -0.3657620418214640005290000e-04
staticT  SinP4, +0.3133616889173253480000000e-06
staticT  SinP5, -0.1757247417617080600000000e-08
staticT  SinP6, +0.6948152035052200000000000e-11
staticT  SinP7, -0.2022531292930000000000000e-13

staticT  CosP0, +0.99999999999999999996415e+00
staticT  CosP1, -0.30842513753404245242414e+00
staticT  CosP2, +0.15854344243815410897540e-01
staticT  CosP3, -0.32599188692668755044000e-03
staticT  CosP4, +0.35908604458858195300000e-05
staticT  CosP5, -0.24611363826370050000000e-07
staticT  CosP6, +0.11500497024263000000000e-09
staticT  CosP7, -0.38577620372000000000000e-12

else

staticB  FourByPI, <02Ah,015h,044h,04Eh,06Eh,083h,0F9h,0A2h,0FFh,03Fh>

staticB  SinP0   , <035h,0C2h,068h,021h,0A2h,0DAh,00Fh,0C9h,0FEh,03Fh>
staticB  SinP1   , <0DAh,095h,0F2h,02Dh,031h,0E7h,05Dh,0A5h,0FBh,0BFh>
staticB  SinP2   , <0E9h,0C6h,056h,0ADh,03Bh,0E3h,035h,0A3h,0F6h,03Fh>
staticB  SinP3   , <0D5h,0E7h,05Dh,015h,073h,066h,069h,099h,0F0h,0BFh>
staticB  SinP4   , <0BCh,032h,069h,0E1h,042h,01Ah,03Ch,0A8h,0E9h,03Fh>
staticB  SinP5   , <021h,077h,004h,05Fh,0A1h,0A5h,083h,0F1h,0E1h,0BFh>
staticB  SinP6   , <0FCh,01Ah,0D1h,006h,0CCh,063h,077h,0F4h,0D9h,03Fh>
staticB  SinP7   , <04Ah,003h,086h,040h,07Ch,065h,02Ch,0B6h,0D1h,0BFh>

staticB  CosP0   , <0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FEh,03Fh>
staticB  CosP1   , <02Fh,0F2h,02Eh,0F2h,04Dh,0E6h,0E9h,09Dh,0FDh,0BFh>
staticB  CosP2   , <02Fh,04Eh,0D5h,0DAh,040h,0F8h,0E0h,081h,0F9h,03Fh>
staticB  CosP3   , <09Dh,0DEh,06Ah,0E4h,0F1h,0E3h,0E9h,0AAh,0F3h,0BFh>
staticB  CosP4   , <031h,01Eh,0F9h,081h,041h,083h,0FAh,0F0h,0ECh,03Fh>
staticB  CosP5   , <076h,0B1h,000h,0A4h,01Eh,0F6h,068h,0D3h,0E5h,0BFh>
staticB  CosP6   , <0D8h,005h,06Fh,08Ah,0EAh,00Ah,0E6h,0FCh,0DDh,03Fh>
staticB  CosP7   , <003h,0D5h,00Ah,0ACh,0CCh,035h,02Ch,0D9h,0D5h,0BFh>

endif

cProc __FASTLDSIN,<PLM,PUBLIC>,<isi,idi>

	parmT	x
	parmI	RetOff

	localT	x2
	localT	poly
	localI	count

cBegin

	lea	isi, [x]		    ; x = x * (4/PI)
	push	ss
	push	isi

	push	ss
	push	isi

	mov	iax, codeOFFSET FourByPI
	push	cs
	push	iax

	call	__FASTLDMULT


	lea	idi, [x2]		    ; x2 = x * x
	push	ss
	push	idi

	push	ss
	push	isi

	push	ss
	push	isi

	call	__FASTLDMULT

if 0
	push	ss
	pop	es
	lea	idi, [poly]
	mov	isi, codeOFFSET SinP7
	movsw
	movsw
	movsw
	movsw
	movsw
endif
	mov	eax, dword ptr [SinP7]	    ; poly = SinP7
	mov	dword ptr [poly], eax
	mov	eax, dword ptr [SinP7+4]
	mov	dword ptr [poly+4], eax
	mov	ax, word ptr [SinP7+8]
	mov	word ptr [poly+8], ax

	lea	isi, [poly]
	mov	idi, codeOFFSET SinP6

	mov	[count], 7

SinPolyLoop:
	push	ss
	push	isi		    ; poly = poly * x2

	push	ss
	push	isi

	lea	iax, [x2]
	push	ss
	push	iax

	call	__FASTLDMULT


	push	ss
	push	isi		    ; poly = poly + SinP[n]

	push	ss
	push	isi

	push	cs
	push	idi

	xor	iax, iax
	push	iax
	call	__FASTLDADD

	sub	idi, 10

	dec	[count]
	jnz	SinPolyLoop

	push	ss
	push	[RetOff]		; return x * poly

	lea	iax, [x]
	push	ss
	push	iax

	push	ss
	push	isi

	call	__FASTLDMULT

	mov	iax, [RetOff]
	mov	idx, ss
cEnd




cProc  __FASTLDCOS,<PLM,PUBLIC>,<isi,idi>

	parmT	x
	parmI	RetOff

	localT	x2
	localI	count

cBegin

	lea	isi, [x]		    ; x = x * (4/PI)
	push	ss
	push	isi

	push	ss
	push	isi

	mov	iax, codeOFFSET FourByPI
	push	cs
	push	iax

	call	__FASTLDMULT


	lea	idi, [x2]		    ; x2 = x * x
	push	ss
	push	idi

	push	ss
	push	isi

	push	ss
	push	isi

	call	__FASTLDMULT

if 0
	push	ss			    ; (return) = CosP7
	pop	es
	mov	idi, [RetOff]
	mov	isi, codeOFFSET CosP7
	movsw
	movsw
	movsw
	movsw
	movsw
endif
	mov	isi, [RetOff]
	mov	eax, dword ptr [CosP7]
	mov	dword ptr ss:[isi], eax
	mov	eax, dword ptr [CosP7+4]
	mov	dword ptr ss:[isi+4], eax
	mov	ax, word ptr [CosP7+8]
	mov	word ptr ss:[isi+8], ax

	mov	idi, codeOFFSET CosP6

	mov	[count], 7

CosPolyLoop:
	push	ss
	push	isi		    ; (return) = (return) * x2

	push	ss
	push	isi

	lea	iax, [x2]
	push	ss
	push	iax

	call	__FASTLDMULT


	push	ss
	push	isi		    ; (return) = (return) + SinP[n]

	push	ss
	push	isi

	push	cs
	push	idi

	xor	iax, iax
	push	iax

	call	__FASTLDADD


	sub	idi, 10

	dec	[count]
	jnz	CosPolyLoop

	mov	iax, isi
	mov	idx, ss
cEnd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\emround.asm ===
subttl  emround.asm - Rounding and Precision Control and FRNDINT
        page
;*******************************************************************************
;emround.asm - Rounding and Precision Control
;
;        Microsoft Confidential
;
;	 Copyright (c) Microsoft Corporation 1991
;        All Rights Reserved
;
;Purpose:
;       Rounding and precision control.  The correct routine is jumped
;	to through the [RoundMode] vector.
;
;Revision History:
;
; []	09/05/91  TP	Initial 32-bit version.
;	02/28/92  JWM   Minor bug fix in NotNearLow
;
;*******************************************************************************


RndIntSpcl:
	cmp	cl,bTAG_INF
	jz	RndIntX			;Leave infinity unchanged
	cmp	cl,bTAG_DEN
	jnz	SpclDestNotDen		;Handle NAN & empty - in emarith.asm
;Handle denormal
	mov	EMSEG:[CURerr],Denormal
	test	EMSEG:[CWmask],Denormal	;Is it masked?
	jnz	NormRndInt		;If so, ignore denormalization
RndIntX:
	ret

;********
EM_ENTRY eFRNDINT
eFRNDINT:
;********
;edi points to top of stack
	mov	ecx,EMSEG:[edi].ExpSgn
	cmp	cl,bTAG_ZERO
.erre	bTAG_VALID lt bTAG_ZERO
.erre	bTAG_SNGL lt bTAG_ZERO
	jz	RndIntX	
	ja	RndIntSpcl
	cmp	ecx,63 shl 16		;Is it already integer?
	jge	RndIntX
NormRndInt:
	mov	ebx,EMSEG:[edi].lManHi
	mov	esi,EMSEG:[edi].lManLo
	mov	EMSEG:[Result],edi	;Save result pointer
	xor	eax,eax			;Extend mantissa
	push	offset SaveResult
	jmp	RoundToBit

;*******************************************************************************

ResultOverflow:
;mantissa in ebx:esi, exponent in high ecx, sign in ch bit 7, tag in cl.
;We were all ready to save the rounded result, but the exponent turned out
;to be too large.
	or	EMSEG:[CURerr],Overflow
	sub	ecx,UnderBias shl 16	;Unmasked response
	test	EMSEG:[CWmask],Overflow	;Is exception unmasked?
	jz	SaveResult		;If so, we're ready
;Produce masked overflow response
	mov	ebx,1 shl 31		;Assume infinity
	xor	esi,esi
	mov	cl,bTAG_INF
	mov	al,EMSEG:[CWcntl]	;Get rounding control
	mov	ah,al
	and	ah,RCchop			;Rounding control only
;Return max value if RCup bit = 1 and -, or RCdown bit = 1 and +
;i.e., RCup & sign OR RCdown & not sign
.erre	RCchop eq RCup + RCdown		;Always return max value
.erre	RCnear eq 0			;Never return max value
	sar	ch,7			;Expand sign through whole byte
.erre	(RCdown and bSign) eq 0		;Don't want to change real sign
	xor	ch,RCdown		;Flip sign for RCdown bit
	and	ah,ch			;RCup & sign  OR  RCdown & not sign
	jnz	SaveMax
	and	ecx,0FFFFH
	or	ecx,TexpMax shl 16
	jmp	SaveResult		;Save Infinity
SaveMax:
;Get max value for current precision
	mov	ebx,0FFFFFF00H		;Max value for 24 bits
	and	ecx,bSign shl 8		;Preserve only sign
	or	ecx,(IexpMax-IexpBias-1) shl 16 + bTAG_VALID ;Set up max value
	and	al,PrecisionControl
.erre	PC24 eq 0
	jz	SaveResult		;Save 24-bit max value
	dec	esi			;esi == -1
	mov	ebx,esi
	cmp	al,PC53
	jnz	SaveResult		;Save 64-bit max value
	mov	esi,0FFFFF800H
	jmp	SaveResult		;Save 53-bit max value

;*******************************************************************************
;
;64-bit rounding routines
;

;***********
Round64down:
;***********
	cmp	ecx,(IexpMin-IexpBias+1) shl 16	;Test for Underflow
	jl	RndDenorm64
	or	eax,eax			;Exact result?
	jz	SaveValidResult
	or	EMSEG:[CURerr],Precision 	;Set flag on inexact result
;Chop if positive, increase mantissa if negative
	test	ch,bSign
	jz	SaveValidResult		;Positive, so chop
	jmp	RoundUp64		;Round up if negative

RndDenorm64:
	test	EMSEG:[CWmask],Underflow ;Is exception unmasked?
	jz	RndSetUnder
Denormalize:
;We don't really store in denormalized format, but we need the number 
;to be rounded as if we do.  If the exponent were -IexpBias, we would
;lose 1 bit of precision; as it gets more negative, we lose more bits.
;We'll do this by adjusting the exponent so that the bits we want to 
;keep look like integer bits, and performing round-to-integer.
	add	ecx,(IexpBias+62) shl 16 ;Adjust exponent so we're integer
	call	RoundToBit
;Set underflow exception if precision exception is set
	mov	al,EMSEG:[CURerr]
	and	al,Precision
	ror	al,Precision-Underflow	;Move Precision bit to Underflow pos.
	or	EMSEG:[CURerr],al	;Signal Underflow if inexact
	cmp	cl,bTAG_ZERO
	jz	SaveResult
	sub	ecx,(IexpBias+62) shl 16;Restore unbiased exponent
	cmp	ecx,TexpMin shl 16	;Did we round out of denorm?
	jae	SaveResult
	mov	cl,bTAG_DEN
	jmp	SaveResult

RndSetUnder:
;Underflow exception not masked.  Adjust exponent and try again.
	or	EMSEG:[CURerr],Underflow
	add	ecx,UnderBias shl 16
	jmp	EMSEG:[RoundMode]	;Try again with revised exponent

;***********
Round64near:
;***********
;mantissa in ebx:esi:eax, exponent in high ecx, sign in ch bit 7
	cmp	ecx,TexpMin shl 16	;Test for Underflow
	jl	RndDenorm64
	or	eax,eax			;Exact result?
	jz	short SaveValidResult
	or	EMSEG:[CURerr],Precision ;Set flag on inexact result

;To perform "round even" when the round bit is set and the sticky bits
;are zero, we treat the LSB as if it were a sticky bit.  Thus if the LSB
;is set, that will always force a round up (to even) if the round bit is
;set.  If the LSB is zero, then the sticky bits remain zero and we always
;round down.  This rounding rule is implemented by adding RoundBit-1
;(7F..FFH), setting CY if round up.  

	bt	esi,0			;Is mantissa even or odd? (set CY)
	adc	eax,(1 shl 31)-1	;Sum LSB & sticky bits--CY if round up
	jnc	SaveValidResult
RoundUp64:
	mov	EMSEG:[SWcc],RoundUp
	add	esi,1
	adc	ebx,0
	jc	BumpExponent		;Overflowed, increment exponent

SaveValidResult:			;A jump to here requires 9 clocks
	or	esi,esi			;Any bits in low half?
.erre	bTAG_VALID eq 1
.erre	bTAG_SNGL eq 0
	setnz   cl                      ;if low half==0 then cl=0 else cl=1
	cmp	ecx,TexpMax shl 16	;Test for overflow
	jge	ResultOverflow

SaveResult:				;A jump to here requires 10 clocks
;mantissa in ebx:esi, exponent in high ecx, sign in ch bit 7, tag in cl
	mov	edi,EMSEG:[Result]
SaveResultEdi:
	mov	EMSEG:[edi].lManLo,esi
	mov	EMSEG:[edi].lManHi,ebx
SaveExpSgn:
	mov	EMSEG:[edi].ExpSgn,ecx
	ret

;***********
Round64up:
;***********
	cmp	ecx,TexpMin shl 16	;Test for Underflow
	jl	RndDenorm64
	or	eax,eax			;Exact result?
	jz	short SaveValidResult
	or	EMSEG:[CURerr],Precision;Set flag on inexact result
;Chop if negative, increase mantissa if positive
	cmp	ch,bSign		;No CY iff sign bit is set
	jc	RoundUp64		;Round up if positive
	jmp	short SaveValidResult

;***********
Round64chop:
;***********
	cmp	ecx,TexpMin shl 16	;Test for Underflow
	jl	RndDenorm64
	or	eax,eax			;Exact result?
	jz	short SaveValidResult
	or	EMSEG:[CURerr],Precision;Set flag on inexact result
	jmp	short SaveValidResult

;*******************************************************************************
;
;53-bit rounding routines
;

;***********
Round53down:
;***********
	cmp	ecx,TexpMin shl 16	;Test for Underflow
	jl	RndDenorm53
	mov	edx,esi			;Get low bits
	and	edx,(1 shl 11) - 1	;Mask to last 11 bits
	or	edx,eax			;Throwing away any bits?
	jz	SaveValidResult
	or	EMSEG:[CURerr],Precision;Set flag on inexact result
;Chop if positive, increase mantissa if negative
	and	esi,not ((1 shl 11)-1)	;Mask off low 11 bits
	test	ch,bSign
	jz	SaveValidResult		;Positive, go chop
	jmp	RoundUp53

RndDenorm53:
	test	EMSEG:[CWmask],Underflow;Is exception unmasked?
	jz	RndSetUnder
;We don't really store in denormalized format, but we need the number 
;to be rounded as if we do.  If the exponent were -IexpBias, we would
;lose 1 bit of precision; as it gets more negative, we lose more bits.
;We'll do this by adjusting the exponent so that the bits we want to 
;keep look like integer bits, and performing round-to-integer.
	add	ecx,(IexpBias+51) shl 16 ;Adjust exponent so we're integer
	call	RoundToBit
;Set underflow exception if precision exception is set
	mov	al,EMSEG:[CURerr]
	and	al,Precision
	ror	al,Precision-Underflow	;Move Precision bit to Underflow pos.
	or	EMSEG:[CURerr],al	;Signal Underflow if inexact
	cmp	cl,bTAG_ZERO
	jz	SaveResult
	sub	ecx,(IexpBias+51) shl 16;Restore unbiased exponent
	cmp	ecx,(IexpMin-IexpBias+1) shl 16	;Did we round out of denorm?
	jae	SaveResult
	mov	cl,bTAG_DEN
	jmp	SaveResult

;***********
Round53near:
;***********
;mantissa in ebx:esi:eax, exponent in high ecx, sign in ch bit 7
	cmp	ecx,TexpMin shl 16	;Test for Underflow
	jl	RndDenorm53
	mov	edx,esi			;Get low bits
	and	edx,(1 shl 11) - 1	;Mask to last 11 bits
	or	edx,eax			;Throwing away any bits?
	jz	SaveValidResult
	or	EMSEG:[CURerr],Precision;Set flag on inexact result

;To perform "round even" when the round bit is set and the sticky bits
;are zero, we treat the LSB as if it were a sticky bit.  Thus if the LSB
;is set, that will always force a round up (to even) if the round bit is
;set.  If the LSB is zero, then the sticky bits remain zero and we always
;round down.

	mov	edx,esi
	and	esi,not ((1 shl 11)-1)	;Mask off low 11 bits
	test	edx,1 shl 10		;Is round bit set?
	jz	SaveValidResult
	and	edx,(3 shl 10)-1	;Keep only sticky bits and LSB
	or	eax,edx			;Combine with other sticky bits
	jz	SaveValidResult
RoundUp53:
	mov	EMSEG:[SWcc],RoundUp
	add	esi,1 shl 11		;Round
	adc	ebx,0
	jnc	SaveValidResult
BumpExponent:
	add	ecx,1 shl 16		;Mantissa overflowed, bump exponent
	or	ebx,1 shl 31		;Set MSB
	jmp	SaveValidResult

;***********
Round53up:
;***********
	cmp	ecx,TexpMin shl 16	;Test for Underflow
	jl	RndDenorm53
	mov	edx,esi			;Get low bits
	and	edx,(1 shl 11) - 1	;Mask to last 11 bits
	or	edx,eax			;Throwing away any bits?
	jz	SaveValidResult
	or	EMSEG:[CURerr],Precision;Set flag on inexact result
;Chop if negative, increase mantissa if positive
	and	esi,not ((1 shl 11)-1)	;Mask off low 11 bits
	test	ch,bSign
	jz	RoundUp53		;Round up if positive
	jmp	SaveValidResult

;***********
Round53chop:
;***********
	cmp	ecx,TexpMin shl 16	;Test for Underflow
	jl	RndDenorm53
	mov	edx,esi			;Get low bits
	and	edx,(1 shl 11) - 1	;Mask to last 11 bits
	or	edx,eax			;Throwing away any bits?
	jz	SaveValidResult
	or	EMSEG:[CURerr],Precision;Set flag on inexact result
	and	esi,not ((1 shl 11)-1)	;Mask off low 11 bits
	jmp	SaveValidResult

;*******************************************************************************
;
;24-bit rounding routines
;

;***********
Round24down:
;***********
	cmp	ecx,TexpMin shl 16	;Test for Underflow
	jl	RndDenorm24
	or	eax,esi			;Low dword is just sticky bits
	mov	edx,ebx			;Get low bits
	and	edx,(1 shl 8) - 1	;Mask to last 8 bits
	or	edx,eax			;Throwing away any bits?
	jz	SaveValidResult
	or	EMSEG:[CURerr],Precision;Set flag on inexact result
;Chop if positive, increase mantissa if negative
	xor	esi,esi
	and	ebx,not ((1 shl 8)-1)	;Mask off low 8 bits
	test	ch,bSign
	jz	SaveValidResult		;Chop if positive
	jmp	RoundUp24

RndDenorm24:
	test	EMSEG:[CWmask],Underflow;Is exception unmasked?
	jz	RndSetUnder
;We don't really store in denormalized format, but we need the number 
;to be rounded as if we do.  If the exponent were -IexpBias, we would
;lose 1 bit of precision; as it gets more negative, we lose more bits.
;We'll do this by adjusting the exponent so that the bits we want to 
;keep look like integer bits, and performing round-to-integer.
	add	ecx,(IexpBias+22) shl 16 ;Adjust exponent so we're integer
	call	RoundToBit
;Set underflow exception if precision exception is set
	mov	al,EMSEG:[CURerr]
	and	al,Precision
	ror	al,Precision-Underflow	;Move Precision bit to Underflow pos.
	or	EMSEG:[CURerr],al	;Signal Underflow if inexact
	cmp	cl,bTAG_ZERO
	jz	SaveResult
	sub	ecx,(IexpBias+22) shl 16;Restore unbiased exponent
	cmp	ecx,(IexpMin-IexpBias+1) shl 16	;Did we round out of denorm?
	jae	SaveResult
	mov	cl,bTAG_DEN
	jmp	SaveResult

;***********
Round24near:
;***********
;mantissa in ebx:esi:eax, exponent in high ecx, sign in ch bit 7
	cmp	ecx,TexpMin shl 16	;Test for Underflow
	jl	RndDenorm24
	or	eax,esi			;Low dword is just sticky bits
	mov	edx,ebx			;Get low bits
	and	edx,(1 shl 8) - 1	;Mask to last 8 bits
	or	edx,eax			;Throwing away any bits?
	jz	SaveValidResult
	or	EMSEG:[CURerr],Precision;Set flag on inexact result
	xor	esi,esi

;To perform "round even" when the round bit is set and the sticky bits
;are zero, we treat the LSB as if it were a sticky bit.  Thus if the LSB
;is set, that will always force a round up (to even) if the round bit is
;set.  If the LSB is zero, then the sticky bits remain zero and we always
;round down.  

	mov	edx,ebx
	and	ebx,not ((1 shl 8)-1)	;Mask off low 8 bits
	test	dl,1 shl 7		;Round bit set?
	jz	SaveValidResult
	and	edx,(3 shl 7)-1		;Mask to LSB and sticky bits
	or	eax,edx			;Combine all sticky bits
	jz	SaveValidResult
RoundUp24:
	mov	EMSEG:[SWcc],RoundUp
	add	ebx,1 shl 8
	jnc	SaveValidResult
	jmp	BumpExponent		;Overflowed, increment exponent

;***********
Round24up:
;***********
	cmp	ecx,TexpMin shl 16	;Test for Underflow
	jl	RndDenorm24
	or	eax,esi			;Low dword is just sticky bits
	mov	edx,ebx			;Get low bits
	and	edx,(1 shl 8) - 1	;Mask to last 8 bits
	or	edx,eax			;Throwing away any bits?
	jz	SaveValidResult
	or	EMSEG:[CURerr],Precision;Set flag on inexact result
;Chop if negative, increase mantissa if positive
	xor	esi,esi
	and	ebx,not ((1 shl 8)-1)	;Mask off low 8 bits
	test	ch,bSign
	jz	RoundUp24		;Round up if positive
	jmp	SaveValidResult

;***********
Round24chop:
;***********
	cmp	ecx,TexpMin shl 16	;Test for Underflow
	jl	RndDenorm24
	or	eax,esi			;Low dword is just sticky bits
	mov	edx,ebx			;Get low bits
	and	edx,(1 shl 8) - 1	;Mask to last 8 bits
	or	edx,eax			;Throwing away any bits?
	jz	SaveValidResult
	or	EMSEG:[CURerr],Precision;Set flag on inexact result
	xor	esi,esi
	and	ebx,not ((1 shl 8)-1)	;Mask off low 8 bits
	jmp	SaveValidResult

;*******************************************************************************

;*** RoundToInteger
;
;This routine is used by FISTP Int64 and BSTP.  Unlike RoundToBit, this
;unnormalizes the number into a 64-bit integer.
;
;Inputs:
;	edi = pointer to number to round in stack
;Outputs:
;	CY set if invalid operation
;	ebx:edi = rounded integer if CY clear
;	ch = sign if CY clear
;Note:
;	FIST/FISTP/BSTP exception rules are used:  If the number is too big,
;	Invalid Operation occurs.  Denormals are ignored.
;
;esi preserved

RoundSpcl64Int:
	cmp	cl,bTAG_DEN
	jz	NormRound64Int		;Ignore denormal
	cmp	cl,bTAG_EMPTY
	jnz	RoundInvalid		;All other specials are invalid
	mov	EMSEG:[CURerr],StackFlag+Invalid
	stc				;Flag exception to caller
	ret

RoundInvalid:
;Overflow on integer store is invalid according to IEEE
	mov	EMSEG:[CURerr],Invalid
	stc				;Flag exception to caller
	ret

RoundToInteger:
	mov	ebx,EMSEG:[edi].lManHi
	mov	ecx,EMSEG:[edi].ExpSgn
	mov	edi,EMSEG:[edi].lManLo
;mantissa in ebx:edi, exponent in high ecx, sign in ch bit 7, tag in cl
	mov	al,ch			;Save sign bit
	cmp	cl,bTAG_ZERO
.erre	bTAG_VALID lt bTAG_ZERO
.erre	bTAG_SNGL lt bTAG_ZERO
	jz	RoundIntX		;Just return zero
	ja	RoundSpcl64Int
NormRound64Int:
	xor	edx,edx
	sar	ecx,16			;Bring exponent down
	cmp	ecx,-1			;Is it less than 1?
	jle	Under64Int
	cmp	ecx,63
	jg	RoundInvalid
	sub	ecx,63
	neg	ecx			;cl = amount to shift right
	mov	ch,al			;Get sign out of al
	xor	eax,eax
	cmp	cl,32			;Too big for one shift?
	jl	ShortShft64
;32-bit shift right
	xchg	edx,edi
	xchg	ebx,edi			;ebx=0 now
	shrd	eax,edx,cl
;Max total shift is 63 bits, so we know that the LSB of eax is still zero.
;We can rotate this zero to the MSB so the sticky bits in eax can be combined
;with those in edx without affecting the rounding bit in the MSB of edx.
	ror	eax,1			;MSB is now zero
ShortShft64:
;Shift count in cl is modulo-32
	shrd	edx,edi,cl
	shrd	edi,ebx,cl
	shr	ebx,cl
	or	edx,eax			;Collapse sticky bits into one dword
	jz	RoundIntX		;No sticky or round bits, so don't round
;Result will not be exact--check rounding mode
Round64Int:
	mov	EMSEG:[CURerr],Precision;Set flag on inexact result
	test	EMSEG:[CWcntl],RoundControl	;Check rounding control bits
.erre	RCnear eq 0
	jnz	NotNearest64Int		;Not just round-to-nearest

;To perform "round even" when the round bit is set and the sticky bits
;are zero, we treat the LSB as if it were a sticky bit.  Thus if the LSB
;is set, that will always force a round up (to even) if the round bit is
;set.  If the LSB is zero, then the sticky bits remain zero and we always
;round down.

	bt	edi,0			;Look at LSB (for round even)
	adc	edx,(1 shl 31)-1	;CY set if round up
	jnc	RoundIntX
	mov	EMSEG:[SWcc],RoundUp
	add	edi,1			;Round
	adc	ebx,0
	jc	RoundInvalid
RoundIntX:
	ret				;CY clear, no Invalid exception

Shift64Round:
	or	edi,edi
	setnz	dl			;Set sticky bit in edx
	xor	edi,edi			;Mantissa is all zero
	jmp	Round64Int

Under64Int:
;ZF set if exponent is -1
	xchg	ebx,edx			;64-bit right shift
	mov	ch,al			;Restore sign to ch
	jz	Shift64Round		;Exp. is -1, could need to round up
	xor	edi,edi			;Mantissa is all zero
	mov	EMSEG:[CURerr],Precision;Set flag on inexact result
NotNearest64Int:
;We want to increase the magnitude if RCup and +, or RCdown and -
	mov	al,EMSEG:[CWcntl]	;Get rounding control
.erre	(not RCup and RoundControl) eq RCdown
	sar	ch,7			;Expand sign through whole byte
	xor	al,ch			;Flip round mode if -
	and	al,RoundControl
	cmp	al,RCup			;Rounding up?
	jnz	RoundIntOk		;No, chop it
	mov	EMSEG:[SWcc],RoundUp
	add	edi,1
	adc	ebx,0
	jc	RoundInvalid
RoundIntOk:
	clc
	ret

;*******************************************************************************

;*** RoundToBit
;
;This is a relatively low performance routine used by FRNDINT and to
;generate internal-format denormals.  It can round to any bit position.
;
;Inputs:
;	mantissa in ebx:esi:eax, exponent in high ecx, sign in ch bit 7
;Purpose:
;	Round number to integer.  Zero exponent means number is in the
;	range [1,2), so only the MSB will survive (MSB-1 is round bit).  
;	Larger exponents keep more bits; 63 would mean no rounding.
;Outputs:
;	mantissa in ebx:esi, exponent in high ecx, sign in ch bit 7, tag in cl
;
;Does NOT detect overflow.

NoSigBits:
;Exponent was negative: no integer part
	and	ecx,bSign shl 8		;Zero exponent, preserve sign
	mov	cl,bTAG_ZERO
	or	EMSEG:[CURerr],Precision;Set flag on inexact result
	test	EMSEG:[CWcntl],RoundControl	;Check rounding control bits
.erre	RCnear eq 0
	jnz	NotNearNoSig		;Not just round-to-nearest
	cmp	edx,-1			;Exponent of -1 ==> range [.5,1)
	je	HalfBitRound
RndIntToZero:
	xor	ebx,ebx
	mov	esi,ebx			;Just return zero
	ret

NotNearNoSig:
;We want to increase the magnitude if RCup and +, or RCdown and -
	mov	al,EMSEG:[CWcntl]	;Get rounding control
	sar	ch,7			;Expand sign through whole byte
	xor	al,ch			;Flip rounding bits if negative
	and	al,RoundControl
	cmp	al,RCup			;Rounding up?
	jnz	RndIntToZero		;No, chop it
RndIntToOne:
	mov	ebx,1 shl 31
	xor	esi,esi
	mov	cl,bTAG_SNGL
	mov	EMSEG:[SWcc],RoundUp
	ret

HalfBitRound:
	add	ebx,ebx			;Shift off MSB (round bit)
	or	ebx,esi
	or	ebx,eax
	jnz	RndIntToOne
	ret				;Return zero

;**********
RoundToBit:
;**********
	mov	edx,ecx			;Make copy of exponent
	sar	edx,16			;Bring rounding exponent down
	jl	NoSigBits
	mov	cl,dl
	cmp	cl,32			;Rounding in low word?
	jae	RoundLow
;When cl = 31, the RoundBit is in the low half while the LSB is in the 
;high half.  We must preserve the RoundBit when we move it to eax.
	xchg    eax,esi                 ;Low half becomes sticky bits
	or      ah,al                   ;Preserve lowest bits in ah
	add     esi,-1                  ;Set CY if any original sticky bits
	sbb     al,al                   ;Put original sticky bits in al
	mov	esi,ebx
	xor	ebx,ebx			;Shift mantissa right 32 bits
RoundLow:
	mov	edx,(1 shl 31) - 1
	shr	edx,cl			;Make mask
;Note in the case of cl = 31, edx is now zero.
	mov	edi,esi
	and	edi,edx
	or	edi,eax			;Any bits being lost?
	jz	RndSetTag		;All done
	inc	edx			;Mask for LSB
	or	EMSEG:[CURerr],Precision;Set flag on inexact result
	test	EMSEG:[CWcntl],RoundControl	;Check rounding control bits
.erre	RCnear eq 0
	jnz	NotNearLow		;Not just round-to-nearest
	mov	edi,edx			;Save LSB mask
	shr	edi,1			;Mask for round bit
	jc	SplitRound		;Round bit in eax?
	test	esi,edi			;Round bit set?
	jz	MaskOffLow
	dec	edi			;Mask for sticky bits
	or	edi,edx			;Sticky bits + LSB
	and	edi,esi
	or	edi,eax			;Any sticky bits set?
	jz	MaskOffLow
RoundUpThenMask:
	mov	EMSEG:[SWcc],RoundUp
	add	esi,edx			;Round up
	adc	ebx,0
	jc	RoundBumpExp
MaskOffLow:
	dec	edx			;Mask for round & sticky bits
	not	edx
	and	esi,edx			;Zero out low bits
RndSetTag:
	or	ebx,ebx			;Is it normalized?
        jns     RoundedHighHalf
        or      esi,esi                 ;Any bits in low half?
.erre   bTAG_VALID eq 1
.erre   bTAG_SNGL eq 0
        setnz   cl                      ;if low half==0 then cl=0 else cl=1
        ret

SplitRound:
;Rounding high half in esi on rounding bit in eax
	bt	esi,0			;Look at LSB
	adc	eax,(1 shl 31) - 1	;Set CY if round up
	jc	RoundUpThenMask
        or      ebx,ebx                 ;Will set ZF for jnz below
RoundedHighHalf:
;Rounding occured in high half, which had been moved low.
;Move it back up high.
;
;ZF set here on content of ebx.  If not zero, rounding high half in esi
;rippled forward into zero in ebx.
        mov     cl,bTAG_SNGL
        jnz     RndIntNorm              ;Present high half should be zero
        xchg    ebx,esi                 ;Shift left 32 bits
        ret

RndIntNorm:
;Rounded up high half of mantissa, which rolled over to 0.
	add	ecx,1 shl 16		;Increase exponent
	mov	ebx,1 shl 31		;Restore MSB
	ret				;Tag already set to SNGL

RoundBumpExp:
;Mantissa was FFFFF... and rolled over to 0 when we rounded
	add	ecx,1 shl 16		;Increase exponent
	mov	ebx,1 shl 31		;Restore MSB
	jmp	MaskOffLow

NotNearLow:
;We want to increase the magnitude if RCup and +, or RCdown and -
	mov	al,EMSEG:[CWcntl]	;Get rounding control
	sar	ch,7			;Expand sign through whole byte
.erre	(not RCup and RoundControl) eq RCdown
	xor	al,ch			;Flip rounding bits if negative
	and	al,RoundControl
	cmp	al,RCup			;Rounding up?
	jz	RoundUpThenMask		;yes
	jmp	MaskOffLow		;No, chop it
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\emstack.inc ===
subttl	emstack.asm - Emulator Stack Management Macros
	page
;***
;emstack.asm - Emulator Stack Management Area
;
;	 Microsoft Confidential
;	 Copyright (c) Microsoft Corporation 1991
;	 All Rights Reserved
;
;Purpose:
;	Handles emulator stack.
;
;Revision History:
;
; []	09/05/91  TP	Initial 32-bit version.
;
;*******************************************************************************


;POPSTret:  pops the stack and returns.  Uses esi.

POPSTret        macro	reg
        local   stackwrap
IFB	<reg>
        mov     esi,EMSEG:[CURstk]
_popreg	equ	esi
ELSE
_popreg	equ	reg
ENDIF
	mov     EMSEG:[_popreg].bTag,bTAG_EMPTY
        NextStackElem   _popreg,stackwrap
        mov     EMSEG:[CURstk],_popreg
        ret

Wrap&stackwrap:
	mov	EMSEG:[CURstk],BEGstk
	ret
	endm

;NextStackElem:  Given pST(0) = [CURstk] in reg, returns pST(1)
;Requires NextStackWrap macro with same arguments

NextStackElem	macro	reg,stackwrap
	cmp	reg,INITstk			;JWM
	jae	Wrap&stackwrap
	add	reg,Reg87Len
Cont&stackwrap:
	endm

NextStackWrap	macro	reg,stackwrap
Wrap&stackwrap:
	mov	reg,BEGstk			;JWM
	jmp	Cont&stackwrap
	endm


;PrevStackElem:  Given pST(0) = [CURstk] in reg, returns new pST(0) 
;after a push onto on the stack.
;Requires PrevStackWrap macro with same arguments

PrevStackElem	macro	reg,stackwrap
	cmp	reg,BEGstk			;JWM
	jbe	Wrap&stackwrap
	sub	reg,Reg87Len
Cont&stackwrap:
	endm

PrevStackWrap	macro	reg,stackwrap
Wrap&stackwrap:
	mov	reg,INITstk			;JWM
	jmp	Cont&stackwrap
	endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\emulator.asm ===
page    78,132
        title   emulator - 80387 emulator for flat 32-bit OS
;*******************************************************************************
;        Copyright (c) Microsoft Corporation 1991
;        All Rights Reserved
;
;emulator.asm -  80387 emulator
;       by Tim Paterson
;
;Revision History:
;
; []    09/05/91  TP    Initial 32-bit version.
; []    11/13/92  JWM   Bug fixes for esp-indexed addressing, handling of denormals.
; []    01/18/93  JWM   Bug fixes for preservation of condition & error codes.
;
;*******************************************************************************

        .386p
        .387
        .model  flat,Pascal
        option oldstructs                               ;JWM

;*******************************************************************************
;
;   Define segments.
;
;*******************************************************************************


;These equates give access to the program that's using floating point.
dseg    equ     ss                      ;Segment of program's data
cseg    equ     es                      ;Segment of program's code

edata           segment dword public 'FAR_DATA'
edata           ends

ecode           segment dword public 'CODE'
ecode           ends


assume  cs:ecode

ifdef NT386
assume ds:nothing
assume fs:edata
else
assume ds:edata
assume fs:nothing
endif

assume  es:nothing
assume  gs:nothing
assume  ss:nothing

ifdef NT386
        include  ks386.inc
        include  nt386npx.inc
        include  callconv.inc
        include  vdmtib.inc
endif                           ; NT386

;*******************************************************************************
;
;   List external functions.
;
;*******************************************************************************

ifdef  NT386
        EXTRNP   _NtRaiseException,3
        EXTRNP   _RtlRaiseStatus,1
        EXTRNP   _ZwRaiseException,3
        EXTRNP   _NpxNpSkipInstruction,1
endif           ; NT386

ifdef _DOS32EXT
        extern  _SelKrnGetEmulData:NEAR
        extern  DOS32RAISEEXCEPTION:NEAR
endif           ; _DOS32EXT

ifdef _CRUISER
        extern  DOS32IRAISEEXCEPTION:near
endif           ; CRUISER


;*******************************************************************************
;
;   Segment override macro (for NT)
;
;*******************************************************************************

ifdef NT386
        EMSEG EQU FS
else
        EMSEG EQU DS
endif

;;*******************************************************************************
;;
;;   Include some more macros and constants.
;;
;;*******************************************************************************
;
        include em387.inc
        include emstack.inc             ; stack management macros
;**************************************************************************
;**************************************************************************
;**************************************************************************
subttl  emulator.asm - Emulator Task DATA Segment
page
;*********************************************************************;
;                                                                     ;
;                 Emulator Task DATA Segment                          ;
;                                                                     ;
;*********************************************************************;

edata   segment

ifdef NT386
        db size EmulatorTebData dup (?) ; Make space for varibles
else					; ifdef NT386

Numlev          equ     8               ; Number of stack registers

InitControlWord	equ	37FH		; Default - Round near,
					; 64 bits, all exceptions masked

RoundMode       dd      ?               ;Address of rounding routine
SavedRoundMode  dd      ?               ;For restoring RoundMode
ZeroVector      dd      ?               ;Address of sum-to-zero routine
TransRound      dd      ?               ;Round mode w/o precision
Result          dd      ?               ;Result pointer

PrevCodeOff     dd      ?
PrevDataOff     dd      ?

(See note below on 'Emulator stack area')
CURstk          dd      ?

XBEGstk		db	(Numlev-1)*Reg87Len dup(?)	;Allocate register 1 - 7

BEGstk EQU offset edata:XBEGstk
INITstk EQU offset edata:XINITstk
ENDstk EQU offset edata:XENDstk

FloatTemp       db      Reg87Len dup(?)
ArgTemp         db      Reg87Len dup(?)

public Trap7Handler
Trap7Handler    dd      0

;We're DWORD aligned at this point

LongStatusWord  label   dword           ;Combined Einstall, CURerr, StatusWord
.erre   Einstall eq $
.erre   StatusWord eq $+1
.erre   CURerr eq $+3

Einstall        db      0               ; Emulator installed flag

StatusWord      label   word
    SWerr       db      ?               ; Initially no exceptions (sticky flags)
CurErrCond      label   word            ; Combined error and condition codes
    SWcc        db      ?               ; Condition codes from various operations

    CURerr      db      ?               ; initially 8087 exception flags clear
                                        ; this is the internal flag reset after
                                        ; each operation to detect per instruction
                                        ; errors

LongControlWord label   dword           ;Combined ControlWord and ErrMask
.erre   ControlWord eq $
.erre   ErrMask eq $+2

ControlWord     label   word
    CWmask      db      ?               ; exception masks
    CWcntl      db      ?               ; arithmetic control flags

    ErrMask     db      ?
    dummy       db      ?

endif                                   ; ifdef NT386 else

;*******************************************************************************
;
; Emulator stack area
;
;The top of stack pointer CURstk is initialized to the last register 
;in the list; on a real 8087, this corresponds to hardware register 0.
;The stack grows toward lower addresses, so the first push (which is
;hardware register 7) is stored into the second-to-last slot.  This gives
;the following relationship between hardware registers and memory
;locations:
;
; BEGstk --> |    reg 1    |  (lowest memory address)
; 	     |    reg 2    |
; 	     |    reg 3    |
; 	     |    reg 4    |
; 	     |    reg 5    |
; 	     |    reg 6    |
; 	     |    reg 7    |
; 	     |    reg 0    |  <-- Initial top of stack (empty)
; ENDstk -->
;
;This means that the wrap-around case on decrementing CURstk will not
;occur until the last (8th) item is pushed.
;
;Note that the physical register numbers are only used in regard to
;the tag word.  All other operations are relative the current top.


edata	ends

subttl  emulator.asm
page
;*********************************************************************;
;                                                                     ;
;               Start of Code Segment                                 ;
;                                                                     ;
;*********************************************************************;


ecode segment

;         public  __fpemulatorbegin       ; unused code label commented out for BBT
;__fpemulatorbegin equ       $            ; emulator really starts here   


        include emfinit.asm
        include emerror.asm             ; error handler
        include emdisp.asm              ; dispatch tables

        include emf386.asm              ; Flat 386 emulation entry
        include emdecode.asm            ; instruction decoder

        include emarith.asm             ; arithmetic dispatcher
        include emfadd.asm              ; add and subtract
        include emfmul.asm              ; multiply
        include emfdiv.asm              ; division
        include emround.asm             ; rounding
        include emload.asm              ; load memory operands
        include emstore.asm             ; store memory operands
        include emfmisc.asm             ; miscellaneous instructions
        include emfcom.asm              ; compare
        include emfconst.asm            ; constant loading
        include emlsbcd.asm             ; packed BCD conversion
        include emxtract.asm            ; xtract and scale
        include emfprem.asm             ; partial remainder
        include emtrig.asm              ; trig instructions
        include emftran.asm             ; transcendentals
        include emlsenv.asm
        include emfsqrt.asm             ; square root
ifndef NT386
        include emccall.asm
endif

UNUSED:
eFSETPM:
eFNOP:
eFENI:
eFDISI:
        ret                     ;Return to EMLFINISH


;        public  __fpemulatorend         ; unused code label commented out for BBT
;__fpemulatorend equ     $               ; emulator ends here  ; commented out for BBT

ecode   ends
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\emftran.asm ===
subttl  emftran.asm - Transcendental instructions
	page
;*******************************************************************************
;	 Copyright (c) Microsoft Corporation 1991
;	 All Rights Reserved
;
;emftran.asm - Transcendental instructions
;	by Tim Paterson
;
;Purpose:
;	F2XM1, FPATAN, FYL2X, FYL2XP1 instructions
;Inputs:
;	edi = [CURstk]
;
;Revision History:
;
; []	09/05/91  TP	Initial 32-bit version.
;
;*******************************************************************************


;********************* Polynomial Coefficients *********************

;These polynomial coefficients were all taken from "Computer Approximations"
;by J.F. Hart (reprinted 1978 w/corrections).  All calculations and 
;conversions to hexadecimal were done with a character-string calculator
;written in Visual Basic with precision set to 30 digits.  Once the constants
;were typed into this file, all transfers were done with cut-and-paste
;operations to and from the calculator to help eliminate any typographical
;errors.


tAtanPoly	label	word

;These constants are from Hart #5056: atan(x) = x * P(x^2) / Q(x^2),
;accurate to 20.78 digits over interval [0, tan(pi/12)].

	dd	4			;P() is degree four

;  Hart constant
;
;+.16241 70218 72227 96595 08	      E0
;Hex value:    0.A650A5D5050DE43A2C25A8C00 HFFFE
	dq	0A650A5D5050DE43AH
	dw	bTAG_VALID,0FFFEH-1

;+.65293 76545 29069 63960 675	      E1
;Hex value:    0.D0F0A714A9604993AC4AC49A0 H3
	dq	0D0F0A714A9604994H
	dw	bTAG_VALID,03H-1

;+.39072 57269 45281 71734 92684      E2
;Hex value:    0.9C4A507F16530AC3CDDEFA3DE H6
	dq	09C4A507F16530AC4H
	dw	bTAG_VALID,06H-1

;+.72468 55912 17450 17145 90416 9    E2
;Hex value:    0.90EFE6FB30465042CF089D1310 H7
	dq	090EFE6FB30465043H
	dw	bTAG_VALID,07H-1

;+.41066 29181 34876 24224 77349 62   E2
;Hex value:    0.A443E2004BB000B84A5154D44 H6
	dq	0A443E2004BB000B8H
	dw	bTAG_VALID,06H-1

	dd	4			;Q() is degree four

;  Hart constant
;
;+.15023 99905 56978 85827 4928	      E2
;Hex value:    0.F0624CD575B782643AFB912D0 H4
	dq	0F0624CD575B78264H
	dw	bTAG_VALID,04H-1

;+.59578 42201 83554 49303 22456      E2
;Hex value:    0.EE504DDC907DEAEB7D7473B82 H6
	dq	0EE504DDC907DEAEBH
	dw	bTAG_VALID,06H-1

;+.86157 32305 95742 25062 42472      E2
;Hex value:    0.AC508CA5E78E504AB2032E864 H7
	dq	0AC508CA5E78E504BH
	dw	bTAG_VALID,07H-1

;+.41066 29181 34876 24224 84140 84   E2
;Hex value:    0.A443E2004BB000B84F542813C H6
	dq	0A443E2004BB000B8H
	dw	bTAG_VALID,06H-1


;tan(pi/12) = tan(15 deg.) = 2 - sqrt(3) 
;= 0.26794 91924 31122 70647 25536 58494 12763	;From Hart appendix
;Hex value:    0.8930A2F4F66AB189B517A51F2 HFFFF
Tan15Hi		equ	08930A2F4H
Tan15Lo		equ	0F66AB18AH
Tan15exp	equ	0FFFFH-1

;1/tan(pi/6) = sqrt(3) = 1.73205 08075 68877 29352 74463 41505 87236	;From Hart appendix
;Hex value:    0.DDB3D742C265539D92BA16B8 H1
Sqrt3Hi		equ	0DDB3D742H
Sqrt3Lo		equ	0C265539EH
Sqrt3exp	equ	01H-1

;pi = +3.14159265358979323846264338328
;Hex value:    0.C90FDAA22168C234C4C6628B8 H2
PiHi		equ	0C90FDAA2H
PiLo		equ	02168C235H
PiExp		equ	02H-1

;3*pi = +9.42477796076937971538793014984
;Hex value:    0.96CBE3F9990E91A79394C9E890 H4
XThreePiHi	equ	096CBE3F9H
XThreePiMid	equ	0990E91A7H
XThreePiLo	equ	090000000H
ThreePiExp	equ	04H-1


;This is a table of multiples of pi/6.  It is used to adjust the
;final result angle after atan().  Derived from Hart appendix
;pi/180 = 0.01745 32925 19943 29576 92369 07684 88612
;
;When the reduced argument for atan() is very small, these correction
;constants simply become the result.  These constants have all been
;rounded to nearest, but the user may have selected a different rounding
;mode.  The tag byte is not needed for these constants, so its space
;is used to indicate if it was rounded.  To determine if a constant 
;was rounded, 7FH is subtracted from this flag; CY set means it was
;rounded up.

RoundedUp	equ	040H
RoundedDown	equ	0C0H

tAtanPiFrac	label	dword
;pi/2 = +1.57079632679489661923132169163
;Hex value:    0.C90FDAA22168C234C4C6628B0 H1
	dq	0C90FDAA22168C235H
	dw	RoundedUp,01H-1

;2*pi/3 = +2.09439510239319549230842892218
;Hex value:    0.860A91C16B9B2C232DD997078 H2
	dq	0860A91C16B9B2C23H
	dw	RoundedDown,02H-1

;none
	dd	0,0,0

;pi/6 = +0.523598775598298873077107230544E0
;Hex value:    0.860A91C16B9B2C232DD99707A H0
	dq	0860A91C16B9B2C23H
	dw	RoundedDown,00H-1

;pi/2 = +1.57079632679489661923132169163
;Hex value:    0.C90FDAA22168C234C4C6628B0 H1
	dq	0C90FDAA22168C235H
	dw	RoundedUp,01H-1

;pi/3 = +1.04719755119659774615421446109
;Hex value:    0.860A91C16B9B2C232DD997078 H1
	dq	0860A91C16B9B2C23H
	dw	RoundedDown,01H-1

;pi = +3.14159265358979323846264338328
;Hex value:    0.C90FDAA22168C234C4C6628B8 H2
	dq	0C90FDAA22168C235H
	dw	RoundedUp,02H-1

;5*pi/6 = +2.61799387799149436538553615272
;Hex value:    0.A78D3631C681F72BF94FFCC96 H2
	dq	0A78D3631C681F72CH
	dw	RoundedUp,02H-1

;*********************

tExpPoly	label	word

;These constants are from Hart #1324: 2^x - 1 = 
; 2 * x * P(x^2) / ( Q(x^2) - x * P(x^2) )
;accurate to 21.54 digits over interval [0, 0.5].

	dd	2			;P() is degree two

;  Hart constant
;
;+.60613 30790 74800 42574 84896 07	E2
;Hex value:    0.F27406FCF405189818F68BB78 H6
	dq	0F27406FCF4051898H
	dw	bTAG_VALID,06H-1

;+.30285 61978 21164 59206 24269 927	E5
;Hex value:    0.EC9B3D5414E1AD0852E432A18 HF
	dq	0EC9B3D5414E1AD08H
	dw	bTAG_VALID,0FH-1

;+.20802 83036 50596 27128 55955 242	E7
;Hex value:    0.FDF0D84AC3A35FAF89A690CC4 H15
	dq	0FDF0D84AC3A35FB0H
	dw	bTAG_VALID,015H-1

	dd	3			;Q() is degree three.  First 
					;coefficient is 1.0 and is not listed.
;  Hart constant
;
;+.17492 20769 51057 14558 99141 717	E4
;Hex value:    0.DAA7108B387B776F212ECFBEC HB
	dq	0DAA7108B387B776FH
	dw	bTAG_VALID,0BH-1

;+.32770 95471 93281 18053 40200 719	E6
;Hex value:    0.A003B1829B7BE85CC81BD5309 H13
	dq	0A003B1829B7BE85DH
	dw	bTAG_VALID,013H-1

;+.60024 28040 82517 36653 36946 908	E7
;Hex value:    0.B72DF814E709837E066855BDD H17
	dq	0B72DF814E709837EH
	dw	bTAG_VALID,017H-1


;sqrt(2) = 1.41421 35623 73095 04880 16887 24209 69808	;From Hart appendix
;Hex value:    0.B504F333F9DE6484597D89B30 H1
Sqrt2Hi		equ	0B504F333H
Sqrt2Lo		equ	0F9DE6484H
Sqrt2Exp	equ	01H-1

;sqrt(2) - 1 = +0.4142135623730950488016887242E0
;Hex value:    0.D413CCCFE779921165F626CC4 HFFFF
Sqrt2m1Hi	equ	0D413CCCFH
Sqrt2m1Lo	equ	0E7799211H
XSqrt2m1Lo	equ	060000000H
Sqrt2m1Exp	equ	0FFFFH-1

;2 - sqrt(2) = +0.5857864376269049511983112758E0
;Hex value:    0.95F619980C4336F74D04EC9A0 H0
TwoMinusSqrt2Hi	equ	095F61998H
TwoMinusSqrt2Lo	equ	00C4336F7H
TwoMinusSqrt2Exp equ	00H-1

;*********************

tLogPoly	label	dword

;These constants are derived from Hart #2355: log2(x) = z * P(z^2) / Q(z^2),
; z = (x+1) / (x-1) accurate to 19.74 digits over interval 
;[1/sqrt(2), sqrt(2)].  The original Hart coefficients were for log10(); 
;the P() coefficients have been scaled by log2(10) to compute log2().
;
;log2(10) = 3.32192 80948 87362 34787 03194 29489 39017	;From Hart appendix

	dd	3			;P() is degree three

;  Original Hart constant	 	Scaled value
;
;+.18287 59212 09199 9337	 E0	+0.607500660543248917834110566373E0
;Hex value:    0.9B8529CD54E72022A12BAEC53 H0
	dq	09B8529CD54E72023H
	dw	bTAG_VALID,00H-1

;-.41855 96001 31266 20633	 E1	-13.9042489506087332809657007634
;Hex value:    0.DE77CDBF64E8C53F0DCD458D0 H4
	dq	0DE77CDBF64E8C53FH
	dw	bSign shl 8 + bTAG_VALID,04H-1

;+.13444 58152 27503 62236	 E2	+44.6619330844279438866067340334
;Hex value:    0.B2A5D1C95708A0C9FE50F6F97 H6
	dq	0B2A5D1C95708A0CAH
	dw	bTAG_VALID,06H-1

;-.10429 11213 72526 69497 44122 E2	-34.6447606134704282123622236943
;Hex value:    0.8A943C20526AE439A98B30F6A H6
	dq	08A943C20526AE43AH
	dw	bSign shl 8 + bTAG_VALID,06H-1


	dd	3			;Q() is degree three.  First 
					;coefficient is 1.0 and is not listed.
;  Hart constant
;
;-.89111 09060 90270 85654	 E1
;Hex value:    0.8E93E7183AA998D74F45CDFF0 H4
	dq	08E93E7183AA998D7H
	dw	bSign shl 8 + bTAG_VALID,04H-1

;+.19480 96618 79809 36524 155	 E2
;Hex value:    0.9BD904CCFEE118D4BEF319716 H5
	dq	09BD904CCFEE118D5H
	dw	bTAG_VALID,05H-1

;-.12006 95907 02006 34243 4218	 E2
;Hex value:    0.C01C811D2EC1B5806304B1858 H4
	dq	0C01C811D2EC1B580H
	dw	bSign shl 8 + bTAG_VALID,04H-1

;Log2(e) = 1.44269 50408 88963 40735 99246 81001 89213	;From Hart appendix
;Hex value:    0.B8AA3B295C17F0BBBE87FED04 H1
Log2OfEHi	equ	0B8AA3B29H
Log2OfELo	equ	05C17F0BCH
Log2OfEexp	equ	01H-1


;********************* Generic polynomial evaluation *********************
;
;EvalPoly, EvalPolyAdd, EvalPolySetup, Eval2Poly
;
;Inputs:
;	ebx:esi,ecx = floating point number, internal format
;	edi = pointer to polynomial degree and coefficients
;Outputs:
;	result in ebx:esi,ecx
;	edi incremented to start of last coefficient in list
;
;EvalPoly is the basic polynomial evaluator, using Horner's rule.  The
;polynomial pointer in edi points to a list: the first dword in the list
;is the degree of the polynomial (n); it is followed by the n+1 
;coefficients in internal (12-byte) format.  The argment for EvalPoly
;must be stored in the static FloatTemp in addition to being in
;registers.
;
;EvalPolyAdd is an alternate entry point into the middle of EvalPoly.
;It is used when the first coefficient is 1.0, so it skips the first
;multiplication.  It requires that the degree of the polynomial be
;already loaded into ebp.
;
;EvalPolySetup store a copy of the argument in the static ArgTemp,
;and stores the square of the argument in the static FloatTemp.  
;Then it falls into EvalPoly to evaluate the polynomial on the square.
;
;Eval2Poly evaluate two polynomials on its argument.  The first 
;polynomial is  x * P(x^2), and its result is left at [[CURstk]].
;The second polynomial is Q(x^2), and its result is left in registers.
;The most significant coefficient of Q() is 1.
;
;Polynomial evaluation uses a slight variation on the standard add
;and multiply routines.  PolyAddDouble and PolyMulDouble both check
;to see if the argument in registers (the current accumulation) is 
;zero.  The argument pointed to by edi is a coefficient and is never
;zero.
;
;In addition, the [RoundMode] and [ZeroVector] vectors are "trapped",
;i.e., redirected to special handlers for polynomial evaluation.
;[RoundMode] ordinarily points to the routine that handles the
;the current rounding mode and precision control; however, during
;polynomial evaluation, we always want full precision and round
;nearest.  The normal rounding routines also store their result
;at [[Result]], but we want the result left in registers.
;[ZeroVector] exists solely so polynomial evaluation can trap
;when AddDouble results of zero.  The normal response is to store
;a zero at [[Result]], but we need the zero left in registers.
;PolyRound and PolyZero handle these traps.


EvalPolySetup:
;Save x in ArgTemp
	mov	EMSEG:[ArgTemp].ExpSgn,ecx
	mov	EMSEG:[ArgTemp].lManHi,ebx
	mov	EMSEG:[ArgTemp].lManLo,esi
	mov	EMSEG:[RoundMode],offset PolyRound
	mov	EMSEG:[ZeroVector],offset PolyZero
	push	edi			;Save pointer to  polynomials
;op1 mantissa in ebx:esi, exponent in high ecx, sign in ch bit 7
	mov	edx,ebx
	mov	edi,esi
	mov	eax,ecx
;op2 mantissa in edx:edi, exponent in high eax, sign in ah bit 7
	call	MulDoubleReg		;Compute x^2
;Save x^2 in FloatTemp
	mov	EMSEG:[FloatTemp].ExpSgn,ecx
	mov	EMSEG:[FloatTemp].lManHi,ebx
	mov	EMSEG:[FloatTemp].lManLo,esi
	pop	edi
EvalPoly:
;ebx:esi,ecx = arg to evaluate, also in FloatTemp
;edi = pointer to degree and list of coefficients.
	push	edi
	mov	eax,cs:[edi+4].ExpSgn
	mov	edx,cs:[edi+4].lManHi
	mov	edi,cs:[edi+4].lManLo
	call	MulDoubleReg		;Multiply arg by first coef.
	pop	edi
	mov	ebp,cs:[edi]		;Get polynomial degree
	add	edi,4+Reg87Len		;Point to second coefficient
	jmp	EvalPolyAdd

PolyLoop:
	push	ebp			;Save loop count
ifdef NT386
        mov	edi,YFloatTemp
else
	mov	edi,offset edata:FloatTemp
endif
        call	PolyMulDouble
	pop	ebp
	pop	edi
	add	di,Reg87Len
EvalPolyAdd:
	push	edi
	mov	eax,cs:[edi].ExpSgn
	mov	edx,cs:[edi].lManHi
	mov	edi,cs:[edi].lManLo
	cmp	cl,bTAG_ZERO		;Adding to zero?
	jz	AddToZero
	call	AddDoubleReg		;ebp preserved
ContPolyLoop:
	dec	ebp
	jnz	PolyLoop
	pop	edi
	ret

AddToZero:
;Number in registers is zero, so just return value from memory.
	mov	ecx,eax
	mov	ebx,edx
	mov	esi,edi
	jmp	ContPolyLoop


Eval2Poly:
	call	EvalPolySetup
	push	edi
ifdef NT386
        mov	edi,YArgTemp
else
	mov	edi,offset edata:ArgTemp
endif
	call	PolyMulDouble		;Multiply first result by argument
	pop	edi
;Save result of first polynomial at [[CURstk]]
	mov	edx,EMSEG:[CURstk]
	mov	EMSEG:[edx].ExpSgn,ecx
	mov	EMSEG:[edx].lManHi,ebx
	mov	EMSEG:[edx].lManLo,esi
;Load x^2 back into registers
	mov	ecx,EMSEG:[FloatTemp].ExpSgn
	mov	ebx,EMSEG:[FloatTemp].lManHi
	mov	esi,EMSEG:[FloatTemp].lManLo
;Start second polynomial evaluation
	add	edi,4+Reg87Len		;Point to coefficient
	mov	ebp,cs:[edi-4]		;Get polynomial degree
	jmp	EvalPolyAdd


PolyRound:
;This routine handles all rounding during polynomial evaluation.
;It performs 64-but round nearest, with result left in registers.
;
;Inputs:
;	mantissa in ebx:esi:eax, exponent in high ecx, sign in ch bit 7
;Outputs:
;	same, plus tag in cl.
;
;To perform "round even" when the round bit is set and the sticky bits
;are zero, we treat the LSB as if it were a sticky bit.  Thus if the LSB
;is set, that will always force a round up (to even) if the round bit is
;set.  If the LSB is zero, then the sticky bits remain zero and we always
;round down.  This rounding rule is implemented by adding RoundBit-1
;(7F..FFH), setting CY if round up.  
;
;This routine needs to be reversible in case we're at the last step
;in the polynomial and final rounding uses a different rounding mode.
;We do this by copying the LSB of esi into al.  While the rounding is 
;reversible, you can't tell if the answer was exact.

	mov	edx,esi
	and	dl,1			;Look at LSB
	or	al,dl			;Set LSB as sticky bit
	add	eax,(1 shl 31)-1	;Sum LSB & sticky bits--CY if round up
	adc	esi,0
	adc	ebx,0
	jc	PolyBumpExponent	;Overflowed, increment exponent
	or      esi,esi			;Any bits in low half?
.erre   bTAG_VALID eq 1
.erre   bTAG_SNGL eq 0
	setnz   cl			;if low half==0 then cl=0 else cl=1
	ret

PolyBumpExponent:
	add	ecx,1 shl 16		;Mantissa overflowed, bump exponent
	or	ebx,1 shl 31		;Set MSB
	mov     cl,bTAG_SNGL
PolyZero:
;Enter here when result is zero
	ret

;*******************************************************************************

;FPATAN instruction

;Actual instruction entry point is in emarith.asm

tFpatanDisp	label	dword		;Source (ST(0))	Dest (*[di] = ST(1))
	dd	AtanDouble		;single		single
	dd	AtanDouble		;single		double
	dd	AtanZeroDest		;single		zero
	dd	AtanSpclDest		;single		special
	dd	AtanDouble		;double		single
	dd	AtanDouble		;double		double
	dd	AtanZeroDest		;double		zero
	dd	AtanSpclDest		;double		special
	dd	AtanZeroSource		;zero		single
	dd	AtanZeroSource		;zero		double
	dd	AtanZeroDest		;zero		zero
	dd	AtanSpclDest		;zero		special
	dd	AtanSpclSource		;special	single
	dd	AtanSpclSource		;special	double
	dd	AtanSpclSource		;special	zero
	dd	TwoOpBothSpcl		;special	special
	dd	AtanTwoInf		;Two infinites

;Compute atan( st(1)/st(0) ).  Neither st(0) or st(1) are zero or
;infinity at this point.
;
;Argument reduction starts by dividing the smaller by the larger,
;ensuring that the result x is <= 1.  The absolute value of the quotient
;is used and the quadrant is fixed up later.  If x = st(0)/st(1), then 
;the final atan result is subtracted from pi/2 (and normalized for the
;correct range of -pi to +pi).  
;
;The range of x is further reduced using the formulas:
;	t = (x - k) / (1 + kx)
;	atan(x) = atan(k) + atan(t)
;
;Given that x <= 1, if we choose k = tan(pi/6) = 1/sqrt(3), then we
;are assured that t <= tan(pi/12) = 2 - sqrt(3), and
;for x >= tan(pi/12) = 2 - sqrt(3), t >= -tan(pi/12).
;Thus we can always reduce the argument to abs(t) <= tan(pi/12).
;
;Since k = 1/sqrt(3), it is convenient to multiply the numerator
;and denominator of t by 1/k, which gives
;t = (x/k - 1) / (1/k + x) = ( x*sqrt(3) - 1 ) / ( sqrt(3) + x ).
;This is the form found in Cody and Waite and in previous versions
;of the emulator.  It requires one each add, subtract, multiply, and
;divide.
;
;Hart has derived a simpler version of this formula:
;t = 1/k - (1/k^2 + 1) / (1/k + x) = sqrt(3) - 4 / ( sqrt(3) + x ).
;Note that this computation requires one each add, subtract, and
;divide, but no multiply.

;st(0) mantissa in ebx:esi, exponent in high ecx, sign in ch bit 7
;[edi] points to st(1), where result is returned

AtanDouble:
	mov	EMSEG:[Result],edi
	mov	EMSEG:[RoundMode],offset PolyRound
	mov	EMSEG:[ZeroVector],offset PolyZero
	mov	ah,EMSEG:[edi].bSgn	;Sign of result
	mov	al,ch			;Affects quadrant of result
	and	al,bSign		;Zero other bits, used as flags
	push	eax			;Save flag
;First figure out which is larger
	push	offset AtanQuo		;Return address for DivDouble
	shld	edx,ecx,16		;Get exponent to ax
	cmp	dx,EMSEG:[edi].wExp	;Compare exponents
	jl	DivrDoubleSetFlag	;ST(0) is smaller, make it dividend
	jg	DivDouble		;   ...is bigger, make it divisor
;Exponents are equal, compare mantissas
	cmp	ebx,EMSEG:[edi].lManHi
	jb	DivrDoubleSetFlag	;ST(0) is smaller, make it dividend
	ja	DivDouble		;   ...is bigger, make it divisor
	cmp	esi,EMSEG:[edi].lManLo
	jbe	DivrDoubleSetFlag	;ST(0) is smaller, make it dividend
	jmp	DivDouble

TinyAtan:
;Come here if the angle was reduced to zero, or the divide resulted in
;unmasked underflow so that the quotient exponent was biased.
;Note that an angle of zero means reduction was performed, and the
;result will be corrected to a non-zero value.
	mov	dl,[esp]		;Get flag byte
	or	dl,dl			;No correction needed?
	jz	AtanSetSign		;Just return result of divide
	and	EMSEG:[CURerr],not Underflow
;Angle in registers is too small to affect correction amount.  Just
;load up correction angle instead of adding it in.
	add	dl,40H			;Change flags for correction lookup
	shr	dl,5-2			;Now in bits 2,3,4
	and	edx,7 shl 2
	mov	ebx,[edx+2*edx+tAtanPiFrac].lManHi
	mov	esi,[edx+2*edx+tAtanPiFrac].lManLo
	mov	ecx,[edx+2*edx+tAtanPiFrac].ExpSgn
	shrd	eax,ecx,8		;Copy rounding flag to high eax
	jmp	AtanSetSign

AtanQuo:
;Return here after divide.  Underflow flag is set only for "big underflow",
;meaning the (15-bit) exponent couldn't even be kept in 16 bits.  This can
;only happen dividing a denormal by one of the largest numbers.
;
;Rounded mantissa in ebx:esi:eax, exp/sign in high ecx
	test	EMSEG:[CURerr],Underflow;Did we underflow?
	jnz	TinyAtan
;Now compare quotient in ebx:esi,ecx with tan(pi/12) = 2 - sqrt(3)
	xor	cx,cx			;Use absolute value
	cmp	ecx,Tan15exp shl 16
	jg	AtnNeedReduce
	jl	AtnReduced
	cmp	ebx,Tan15Hi
	ja	AtnNeedReduce
	jb	AtnReduced
	cmp	esi,Tan15Lo
	jbe	AtnReduced
AtnNeedReduce:
	or	byte ptr [esp],20H	;Note reduction in flags on stack
;Compute t = sqrt(3) - 4 / ( sqrt(3) + x ).
	mov	eax,Sqrt3exp shl 16
	mov	edx,Sqrt3Hi
	mov	edi,Sqrt3Lo
	call	AddDoubleReg		;x + sqrt(3)
	mov	edi,esi
	mov	esi,ebx			;Mantissa in esi:edi
	mov	ebx,ecx			;ExpSgn to ebx
	mov	ecx,(2+TexpBias) shl 16
	mov	edx,1 shl 31
	xor	eax,eax			;edx:edi,eax = 4.0
;dividend mantissa in edx:eax, exponent in high ecx, sign in ch bit 7
;divisor mantissa in esi:edi, exponent in high ebx, sign in bh bit 7
	call	DivDoubleReg		;4 / ( x + sqrt(3) )
	not	ch			;Flip sign
	mov	eax,Sqrt3exp shl 16
	mov	edx,Sqrt3Hi
	mov	edi,Sqrt3Lo
	call	AddDoubleReg		;sqrt(3) - 4 / ( x + sqrt(3) )
;Result in ebx:esi,ecx could be very small (or zero) if arg was near tan(pi/6).
	cmp	cl,bTAG_ZERO
	jz	TinyAtan
AtnReduced:
;If angle is small, skip the polynomial. atan(x) = x when x - x^3/3 = x
;[or 1 - x^2/3 = 1], which happens when x < 2^-32.  This prevents underflow
;in computing x^2.
TinyAtanArg	equ	-32
	cmp	ecx,TinyAtanArg shl 16
	jl	AtanCorrection
	mov	edi,offset tAtanPoly
	call	Eval2Poly
	mov	edi,EMSEG:[CURstk]	;Point to first result
	call	DivDouble		;x * P(x^2) / Q(x^2)
AtanCorrection:
;Rounded mantissa in ebx:esi:eax, exp/sign in high ecx
;
;Correct sign and add fraction of pi to account for various angle reductions:
;
;    flag bit	   indicates		correction
;----------------------------------------------------
;	5	arg > tan(pi/12)	add pi/6
;	6	st(1) > st(0)		sub from pi/2
;	7	st(0) < 0		sub from pi
;
;This results in the following correction for the result R:
;
;bit  7 6 5	correction
;---------------------------
;     0 0 0	none
;     0 0 1	pi/6 + R
;     0 1 0	pi/2 - R
;     0 1 1	pi/3 - R
;     1 0 0	pi - R
;     1 0 1	5*pi/6 - R
;     1 1 0	pi/2 + R
;     1 1 1	2*pi/3 + R

	mov	dl,[esp]		;Get flag byte
	or	dl,dl			;No correction needed?
	jz	AtanSetSign
	add	dl,40H			;Set bit 7 for all -R cases

;This changes the meaning of the flag bits to the following:
;
;bit  7 6 5	correction
;---------------------------
;     0 0 0	pi/2 + R
;     0 0 1	2*pi/3 + R
;     0 1 0	none
;     0 1 1	pi/6 + R
;     1 0 0	pi/2 - R
;     1 0 1	pi/3 - R
;     1 1 0	pi - R
;     1 1 1	5*pi/6 - R

	xor	ch,dl			;Flip sign bit in cases 4 - 7
	shr	dl,5-2			;Now in bits 2,3,4
	and	edx,7 shl 2
	mov	eax,[edx+2*edx+tAtanPiFrac].ExpSgn
	mov	edi,[edx+2*edx+tAtanPiFrac].lManLo
	mov	edx,[edx+2*edx+tAtanPiFrac].lManHi
	call	AddDoubleReg		;Add in correction angle
AtanSetSign:
	pop	edx			;Get flags again
	mov	ch,dh			;Set sign to original ST(1)
;Rounded mantissa in ebx:esi:eax, exp/sign in ecx
	jmp     TransUnround


;***
AtanSpclDest:
	mov	al,EMSEG:[edi].bTag	;Pick up tag
;	cmp     cl,bTAG_INF		;Is argument infinity?
	cmp     al,bTAG_INF		;Is argument infinity?
	jnz	SpclDest		;In emarith.asm
AtanZeroSource:
;Dividend is infinity or divisor is zero.  Return pi/2 with 
;same sign as dividend.
	mov	ecx,(PiExp-1) shl 16 + bTAG_VALID	;Exponent for pi/2
PiMant:
;For storing multiples of pi.  Exponent/tag is in ecx.
	mov	ch,EMSEG:[edi].bSgn	;Get dividend's sign
	mov	ebx,XPiHi
	mov	esi,XPiMid
	mov	eax,XPiLo
;A jump through [TransRound] is only valid if the number is known not to
;underflow.  Unmasked underflow requires [RoundMode] be set.
	jmp	EMSEG:[TransRound]

;***
AtanSpclSource:
	cmp	cl,bTAG_INF		;Scaling by infinity?
	jnz	SpclSource		;in emarith.asm
AtanZeroDest:
;Divisor is infinity or dividend is zero.  Return zero for +divisor, 
;pi for -divisor.  Result sign is same is dividend.
	or	ch,ch			;Check divisor's sign
	mov	ecx,PiExp shl 16 + bTAG_VALID	;Exponent for pi
	js	PiMant			;Store pi
;Result is zero
	mov	EMSEG:[edi].lManHi,0
	mov	EMSEG:[edi].lManLo,0
	mov	EMSEG:[edi].wExp,0
	mov	EMSEG:[edi].bTAG,bTAG_ZERO
	ret

;***
AtanTwoInf:
;Return pi/4 for +infinity divisor, 3*pi/4 for -infinity divisor.
;Result sign is same is dividend infinity.
	or	ch,ch			;Check divisor's sign
	mov	ecx,(PiExp-2) shl 16 + bTAG_VALID	;Exponent for pi/4
	jns	PiMant			;Store pi/4
	mov	ecx,(ThreePiExp-2) shl 16 + bTAG_VALID	;Exponent for 3*pi/4
	mov	ch,EMSEG:[edi].bSgn	;Get dividend's sign
	mov	ebx,XThreePiHi
	mov	esi,XThreePiMid
	mov	eax,XThreePiLo
;A jump through [TransRound] is only valid if the number is known not to
;underflow.  Unmasked underflow requires [RoundMode] be set.
	jmp	EMSEG:[TransRound]

;*******************************************************************************

ExpSpcl:
;Tagged special
	cmp	cl,bTAG_DEN
	jz	ExpDenorm
	cmp	cl,bTAG_INF
        mov     al, cl
	jnz	SpclDestNotDen		;Check for Empty or NAN
;Have infinity, check its sign.  
;Return -1 for -infinity, no change if +infinity
	or	ch,ch			;Check sign
	jns	ExpRet			;Just return the +inifinity
	mov	EMSEG:[edi].lManLo,0
	mov	EMSEG:[edi].lManHi,1 shl 31
	mov	EMSEG:[edi].ExpSgn,bSign shl 8 + bTAG_SNGL	;-1.0 (exponent is zero)
	ret

ExpDenorm:
	mov	EMSEG:[CURerr],Denormal
	test	EMSEG:[CWmask],Denormal	;Is denormal exception masked?
	jnz	ExpCont			;Yes, continue
ExpRet:
	ret

EM_ENTRY eF2XM1
eF2XM1:
;edi = [CURstk]
	mov	ecx,EMSEG:[edi].ExpSgn
	cmp	cl,bTAG_ZERO
	jz	ExpRet			;Return same zero
	ja	ExpSpcl
ExpCont:

;The input range specified for the function is (-1, +1).  The polynomial 
;used for this function is valid only over the range [0, +0.5], so range
;reduction is needed.  Range reduction is based on the identity:
;
;  2^(a+b) = 2^a * 2^b
;
;1.0 or 0.5 can be added/subtracted from the argument to bring it into
;range.  We calculate 2^x - 1 with a polynomial, and then adjust the
;result according to the amount added or subtracted, as shown in the table:
;
;Arg range	Adj	Polynomial result	Required result, 2^x - 1
;
; (-1, -0.5]	+1	P = 2^(x+1) - 1		(P - 1)/2
;
; (-0.5, 0)	+0.5	P = 2^(x+0.5) - 1	P * sqrt(2)/2 + (sqrt(2)/2 - 1)
;
; (0, 0.5)	0	P = 2^x - 1		P
;
; [0.5, 1)	-0.5	P = 2^(x-0.5) - 1	P * sqrt(2) + (sqrt(2)-1)
;
;Since the valid input range does not include +1.0 or -1.0, and zero is
;handled separately, the precision exception will always be set.

	mov	EMSEG:[Result],edi
	mov	EMSEG:[RoundMode],offset PolyRound
	mov	EMSEG:[ZeroVector],offset PolyZero
	push	offset TransUnround		;Always exit through here
	mov	ebx,EMSEG:[edi].lManHi
	mov	esi,EMSEG:[edi].lManLo
;Check for small argument, so that x^2 does not underflow.  Note that 
;e^x = 1+x for small x, where small x means  x + x^2/2 = x  [or 1 + x/2 = 1], 
;which happens when x < 2^-64, so 2^x - 1 = x * ln(2) for small x.
TinyExpArg	equ	-64
	cmp	ecx,TinyExpArg shl 16
	jl	TinyExp
	cmp	ecx,-1 shl 16 + bSign shl 8	;See if positive, < 0.5
	jl	ExpReduced
;Argument was not in range (0, 0.5), so we need some kind of reduction
	or	ecx,ecx			;Exp >= 0 means arg >= 1.0 --> too big
;CONSIDER: this returns through TransUnround which restores the rounding
;vectors, but it also randomly rounds the result becase eax is not set.
	jge	ExpRet			;Give up if arg out of range
;We're going to need to add/subtract 1.0 or 0.5, so load up the constant
	mov	edx,1 shl 31
	xor	edi,edi
	mov	eax,-1 shl 16 + bSign shl 8	;edx:edi,eax = -0.5
	mov	ebp,offset ExpReducedMinusHalf
	or	ch,ch			;If it's positive, must be [0.5, 1)
	jns	ExpReduction
	xor	ah,ah			;edx:edi,eax = +0.5
	mov	ebp,offset ExpReducedPlusHalf
	cmp	ecx,eax			;See if abs(arg) >= 0.5
	jl	ExpReduction		;No, adjust by .5
	xor	eax,eax			;edx:edi,eax = 1.0
	mov	ebp,offset ExpReducedPlusOne
ExpReduction:
	call	AddDoubleReg		;Argument now in range [0, 0.5]
	cmp	cl,bTAG_ZERO		;Did reduction result in zero?
	jz	ExpHalf			;If so, must have been exactly 0.5
	push	ebp			;Address of reduction cleanup
ExpReduced:
	mov	edi,offset tExpPoly
	call	Eval2Poly
;2^x - 1 is approximated with 2 * x*P(x^2) / ( Q(x^2) - x*P(x^2) )
;Q(x^2) is in registers, P(x^2) is at [[CURstk]]
	mov	edi,EMSEG:[CURstk]
	mov	dx,bSign shl 8		;Subtract memory operand
;Note that Q() and P() have no roots over the input range
;(they will never be zero).
	call	AddDouble		;Q(x^2) - x*P(x^2)
	sub	ecx,1 shl 16		;Divide by two
	mov	edi,EMSEG:[CURstk]
	jmp	DivDouble		;2 * x*P(x^2) / ( Q(x^2) - x*P(x^2) )
;Returns to correct argument reduction correction routine or TransUnround

TinyExp:
;Exponent is very small (and was not reduced)
	mov	edx,cFLDLN2hi
	mov	edi,cFLDLN2lo
	mov	eax,cFLDLN2exp shl 16
;This could underflow (but not big time)
	jmp	MulDoubleReg		;Returns to TransUnround

ExpHalf:
;Argument of exactly 0.5 was reduced to zero.  Just return result.
	mov	ebx,Sqrt2m1Hi
	mov	esi,Sqrt2m1Lo
	mov	eax,XSqrt2m1Lo + 1 shl 31 - 1
	mov	ecx,Sqrt2m1Exp shl 16
	ret				;Exit through TransUnround

ExpReducedPlusOne:
;Correct result is (P - 1)/2
	sub	ecx,1 shl 16		;Divide by two
	mov	edx,1 shl 31
	xor	edi,edi
	mov	eax,-1 shl 16 + bSign shl 8	;edx:edi,eax = -0.5
	jmp	AddDoubleReg

ExpReducedPlusHalf:
;Correct result is P * sqrt(2)/2 - (1 - sqrt(2)/2)
	mov	edx,Sqrt2Hi
	mov	edi,Sqrt2Lo
	mov	eax,Sqrt2exp-1 shl 16	;sqrt(2)/2
	call	MulDoubleReg
	mov	edx,TwoMinusSqrt2Hi
	mov	edi,TwoMinusSqrt2Lo
	mov	eax,(TwoMinusSqrt2Exp-1) shl 16 + bSign shl 8	;(2-sqrt(2))/2
	jmp	AddDoubleReg

ExpReducedMinusHalf:
;Correct result is P * sqrt(2) + (sqrt(2)-1)
	mov	edx,Sqrt2Hi
	mov	edi,Sqrt2Lo
	mov	eax,Sqrt2exp shl 16
	call	MulDoubleReg
	mov	edx,Sqrt2m1Hi
	mov	edi,Sqrt2m1Lo
	mov	eax,Sqrt2m1Exp shl 16
	jmp	AddDoubleReg

;*******************************************************************************

;Dispatch table for log(x+1)
;
;One operand has been loaded into ecx:ebx:esi ("source"), the other is
;pointed to by edi ("dest").  
;
;Tag of source is shifted.  Tag values are as follows:

.erre	TAG_SNGL	eq	0	;SINGLE: low 32 bits are zero
.erre	TAG_VALID	eq	1
.erre	TAG_ZERO	eq	2
.erre	TAG_SPCL	eq	3	;NAN, Infinity, Denormal, Empty

;Any special case routines not found in this file are in emarith.asm

tFyl2xp1Disp	label	dword		;Source (ST(0))	Dest (*[di] = ST(1))
	dd	LogP1Double		;single		single
	dd	LogP1Double		;single		double
	dd	LogP1ZeroDest		;single		zero
	dd	LogP1SpclDest		;single		special
	dd	LogP1Double		;double		single
	dd	LogP1Double		;double		double
	dd	LogP1ZeroDest		;double		zero
	dd	LogP1SpclDest		;double		special
	dd	XorSourceSign		;zero		single
	dd	XorSourceSign		;zero		double
	dd	XorDestSign		;zero		zero
	dd	LogP1SpclDest		;zero		special
	dd	LogSpclSource		;special	single
	dd	LogSpclSource		;special	double
	dd	LogSpclSource		;special	zero
	dd	TwoOpBothSpcl		;special	special
	dd	LogTwoInf		;Two infinites


LogP1Double:
;st(0) mantissa in ebx:esi, exponent in high ecx, sign in ch bit 7
;[edi] points to st(1), where result is returned
;
;This instruction is defined only for x+1 in the range [1/sqrt(2), sqrt(2)]
;The approximation used (valid over exactly this range) is
; log2(x) = z * P(z^2) / Q(z^2), z = (x-1) / (x+1), which is
; log2(x+1) = r * P(r^2) / Q(r^2), r = x / (x+2)
;
;We're not too picky about this range check because the function is simply
;"undefined" if out of range--EXCEPT, we're supposed to check for -1 and
;signal Invalid if less, -infinity if equal.
	or	ecx,ecx			;abs(x) >= 1.0?
	jge	LogP1OutOfRange		;Valid range is approx [-0.3, +0.4]
	mov	EMSEG:[Result],edi
	mov	EMSEG:[RoundMode],offset PolyRound
	mov	EMSEG:[ZeroVector],offset PolyZero
	mov	eax,1 shl 16		;Exponent of 1 for adding 2.0
	push	offset TotalLog		;Return address for BasicLog
;	jmp	BasicLog		;Fall into BasicLog
;.erre	BasicLog eq $

;BasicLog is used by eFYL2X and eFYL2XP1.
;eax has exponent and sign to add 1.0 or 2.0 to argument
;ebx:esi,ecx has argument, non-zero, tag not set
;ST has argument to take log2 of, minus 1.  (This is the actual argument
;of eFYL2XP1, or argument minus 1 of eFYL2X.)

BasicLog:
	mov	edx,1 shl 31
	xor	edi,edi			;edx:edi,eax = +1.0 or +2.0
	call	AddDoubleReg
	mov	edi,EMSEG:[CURstk]	;Point to x-1
	call	DivDouble		;Compute (x-1) / (x+1)
;Result in registers is z = (x-1)/(x+1).  For tiny z, ln(x) = 2*z, so
; log2(x) = 2 * log2(e) * z.  Tiny z is such that z + z^3/3 = z.
	cmp	ecx,-32 shl 16		;Smallest exponent to bother with
	jl	LogSkipPoly
	mov	edi,offset tLogPoly
	call	Eval2Poly
	mov	edi,EMSEG:[CURstk]	;Point to first result, r * P(r^2)
	jmp	DivDouble		;Compute r * P(r^2) / Q(r^2)

LogSkipPoly:
;Multiply r by 2 * log2(e)
	mov	edx,Log2OfEHi
	mov	edi,Log2OfELo
	mov	eax,(Log2OfEexp+1) shl 16
	jmp	MulDoubleReg

LogP1OutOfRange:
;Input range isn't valid, so we can return anything we want--EXCEPT, for
;numbers < -1 we must signal Invalid Operation, and Divide By Zero for
;-1.  Otherwise, we return an effective log of one by just leaving the
;second operand as the return value.
;
;Exponent in ecx >= 0  ( abs(x) >= 1 )
	or	ch,ch			;Is it positive?
	jns	LogP1Ret		;If so, skip it
	and	ecx,0FFFFH shl 16	;Look at exponent only: 0 for -1.0
	sub	ebx,1 shl 31		;Kill MSB
	or	ebx,esi
	or	ebx,ecx
	jnz	ReturnIndefinite	;Must be < -1.0
	jmp	DivideByMinusZero

LogP1Ret:
	ret
	
;***
LogP1ZeroDest:
	or	ch,ch			;Is it negative?
	jns	LogP1Ret		;If not, just leave it zero
	or	ecx,ecx			;abs(x) >= 1.0?
	jl	XorDestSign		;Flip sign of zero
;Argument is <= -1
	jmp	ReturnIndefinite	;Have 0 * log( <=0 )

;***
LogP1SpclDest:
	mov	al,EMSEG:[edi].bTag		;Pick up tag
	cmp	al,bTAG_INF		;Is argument infinity?
	jnz	SpclDest		;In emarith.asm
;Multiplying log(x+1) * infinity.
;If x > 0, return original infinity.
;If -1 <= x < 0, return infinity with sign flipped.
;If x < -1 or x == 0, invalid operation.
	cmp	cl,bTAG_ZERO
	jz	ReturnIndefinite
	or	ch,ch			;Is it positive?
	jns	LogP1Ret
	test	ecx,0FFFFH shl 16	;Is exponent zero?
	jl	XorDestSign
	jg	ReturnIndefinite
	sub	ebx,1 shl 31		;Kill MSB
	or	ebx,esi
	jnz	ReturnIndefinite	;Must be < -1.0
	jmp	XorDestSign

;***
LogSpclSource:
	cmp	cl,bTAG_INF		;Is argument infinity?
	jnz	SpclSource		;in emarith.asm
	or	ch,ch			;Is it negative infinity?
	js	ReturnIndefinite
	jmp	MulByInf

;***
LogTwoInf:
	or	ch,ch			;Is it negative infinity?
	js	ReturnIndefinite
	jmp	XorDestSign

;*******************************************************************************

;Dispatch table for log(x)
;
;One operand has been loaded into ecx:ebx:esi ("source"), the other is
;pointed to by edi ("dest").  
;
;Tag of source is shifted.  Tag values are as follows:

.erre	TAG_SNGL	eq	0	;SINGLE: low 32 bits are zero
.erre	TAG_VALID	eq	1
.erre	TAG_ZERO	eq	2
.erre	TAG_SPCL	eq	3	;NAN, Infinity, Denormal, Empty

;Any special case routines not found in this file are in emarith.asm

tFyl2xDisp	label	dword		;Source (ST(0))	Dest (*[di] = ST(1))
	dd	LogDouble		;single		single
	dd	LogDouble		;single		double
	dd	LogZeroDest		;single		zero
	dd	LogSpclDest		;single		special
	dd	LogDouble		;double		single
	dd	LogDouble		;double		double
	dd	LogZeroDest		;double		zero
	dd	LogSpclDest		;double		special
	dd	DivideByMinusZero	;zero		single
	dd	DivideByMinusZero	;zero		double
	dd	ReturnIndefinite	;zero		zero
	dd	LogSpclDest		;zero		special
	dd	LogSpclSource		;special	single
	dd	LogSpclSource		;special	double
	dd	LogSpclSource		;special	zero
	dd	TwoOpBothSpcl		;special	special
	dd	LogTwoInf		;Two infinites


LogDouble:
;st(0) mantissa in ebx:esi, exponent in high ecx, sign in ch bit 7
;[edi] points to st(1), where result is returned
;
;Must reduce the argument to the range [1/sqrt(2), sqrt(2)]
	or	ch,ch			;Is it positive?
	js	ReturnIndefinite	;Can't take log of negative number
	mov	EMSEG:[Result],edi
	mov	EMSEG:[RoundMode],offset PolyRound
	mov	EMSEG:[ZeroVector],offset PolyZero
	shld	eax,ecx,16		;Save exponent in ax as int part of log2
	xor	ecx,ecx			;Zero exponent: 1 <= x < 2
	cmp	ebx,Sqrt2Hi		;x > sqrt(2)?
	jb	LogReduced
	ja	LogReduceOne
	cmp	esi,Sqrt2Lo
	jb	LogReduced
LogReduceOne:
	sub	ecx,1 shl 16		;1/sqrt(2) < x < 1
	inc	eax
LogReduced:
	push	eax			;Save integer part of log2
	mov	ebp,ecx 		;Save reduced exponent (tag is wrong!)
	mov	edx,1 shl 31
	mov	eax,bSign shl 8		;Exponent of 0, negaitve
	xor	edi,edi			;edx:edi,eax = -1.0
	call	AddDoubleReg
	cmp	cl,bTAG_ZERO		;Was it exact power of two?
	jz	LogDone			;Skip log if power of two
;Save (x - 1), reload x with reduced exponent
	mov	edi,EMSEG:[CURstk]	;Point to original x again
	xchg	EMSEG:[edi].lManHi,ebx
	xchg	EMSEG:[edi].lManLo,esi
	mov	EMSEG:[edi].ExpSgn,ecx
	mov	ecx,ebp			;Get reduced exponent
	xor	eax,eax			;Exponent of 0, positive
	call	BasicLog
LogDone:
	pop	eax			;Get integer part back
	cwde
	or	eax,eax			;Is it zero?
	jz	TotalLog
;Next 3 instructions take abs() of integer
	cdq				;Extend sign through edx
	xor	eax,edx			;Complement...
	sub	eax,edx			;  and increment if negative
	bsr	dx,ax			;Look for MSB to normalize integer
;Bit number in dx ranges from 0 to 15
	mov	cl,dl
	not	cl			;Convert to shift count
	shl	eax,cl			;Normalize
.erre	TexpBias eq 0
	rol	edx,16			;Move exponent high, sign low
	or	ebx,ebx			;Was log zero?
	jz	ExactPower
	xchg	edx,eax			;Exp/sign to eax, mantissa to edx
	xor	edi,edi			;Extend with zero
	call	AddDoubleReg
TotalLog:
;Registers could be zero if input was exactly 1.0
	cmp	cl,bTAG_ZERO
	jz	ZeroLog
TotalLogNotZero:
	mov	edi,EMSEG:[Result]	;Point to second arg
	push	offset TransUnround
	jmp	MulDouble

ExactPower:
;Arg was a power of two, so log is exact (but not zero).
	mov     ebx,eax			;Mantissa to ebx
	mov     ecx,edx			;Exponent to ecx
	xor     esi,esi			;Extend with zero
;Exponent of arg [= log2(arg)] is now normalized in ebx:esi,ecx
;
;The result log is exact, so we don't want TransUnround, which is designed 
;to ensure the result is never exact.  Instead we set the [RoundMode]
;vector to [TransRound] before the final multiply.
	mov	eax,EMSEG:[TransRound]
	mov	EMSEG:[RoundMode],eax
	mov	edi,EMSEG:[Result]	;Point to second arg
	push	offset RestoreRound	;Return addr. for MulDouble in emtrig.asm
	jmp	MulDouble

ZeroLog:
	mov	eax,EMSEG:[SavedRoundMode]
	mov	EMSEG:[RoundMode],eax
	mov	EMSEG:[ZeroVector],offset SaveResult
	jmp	SaveResult

;***
LogZeroDest:
	or	ch,ch			;Is it negative?
	js	ReturnIndefinite	;Can't take log of negative numbers
;See if log is + or - so we can get correct sign of zero
	or	ecx,ecx			;Is exponent >= 0?
	jge	LogRet			;If so, keep present zero sign
FlipDestSign:
	not	EMSEG:[edi].bSgn
	ret

;***
LogSpclDest:
	mov	al,EMSEG:[edi].bTag		;Pick up tag
	cmp	al,bTAG_INF		;Is argument infinity?
	jnz	SpclDest		;In emarith.asm
;Multiplying log(x) * infinity.
;If x > 1, return original infinity.
;If 0 <= x < 1, return infinity with sign flipped.
;If x < 0 or x == 1, invalid operation.
	cmp	cl,bTAG_ZERO
	jz	FlipDestSign
	or	ch,ch			;Is it positive?
	js	ReturnIndefinite
	test	ecx,0FFFFH shl 16	;Is exponent zero?
	jg	LogRet			;x > 1, just return infinity
	jl	FlipDestSign
	sub	ebx,1 shl 31		;Kill MSB
	or	ebx,esi
	jz	ReturnIndefinite	;x == 1.0
LogRet:
	ret
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\ldrctx.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ldrctx.c

Abstract:

    This module contains support for relocating executables.

Author:

    Landy Wang (landyw) 8-Jul-1998

Environment:

    User Mode only

Revision History:

--*/

#include <ntos.h>
#include <ldrp.h>

VOID
LdrpRelocateStartContext (
    IN PCONTEXT Context,
    IN LONG_PTR Diff
    )
/*++

Routine Description:

   This routine relocates the start context to mesh with the
   executable that has just been relocated.

Arguments:

   Context - Supplies a context that needs editing.

   Diff - Supplies the difference from the based address to the relocated
          address.

Return Value:

   None.

--*/
{
    Context->Eax += (ULONG)Diff;
}

VOID
LdrpCorReplaceStartContext (
    IN PCONTEXT Context
    )
/*++

Routine Description:

   This routine replaces the initial address to run by one in mscoree.dll.

Arguments:

   Context - Supplies a context that needs editing.

Return Value:

   None.

--*/
{
    Context->Eax = (ULONG)CorExeMain;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\ldrthunk.asm ===
title   "LdrInitializeThunk"
;++
;
;  Copyright (c) 1989  Microsoft Corporation
;
;  Module Name:
;
;     ldrthunk.s
;
;  Abstract:
;
;     This module implements the thunk for the LdrpInitialize APC routine.
;
;  Author:
;
;     Steven R. Wood (stevewo) 27-Apr-1990
;
;  Environment:
;
;     Any mode.
;
;  Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
        .list

        EXTRNP  _LdrpInitialize,3

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page , 132

;++
;
; VOID
; LdrInitializeThunk(
;    IN PVOID NormalContext,
;    IN PVOID SystemArgument1,
;    IN PVOID SystemArgument2
;    )
;
; Routine Description:
;
;    This function computes a pointer to the context record on the stack
;    and jumps to the LdrpInitialize function with that pointer as its
;    parameter.
;
; Arguments:
;
;    NormalContext - User Mode APC context parameter (ignored).
;
;    SystemArgument1 - User Mode APC system argument 1 (ignored).
;
;    SystemArgument2 - User Mode APC system argument 2 (ignored).
;
; Return Value:
;
;    None.
;
;--

cPublicProc _LdrInitializeThunk , 4

NormalContext   equ [esp + 4]
SystemArgument1 equ [esp + 8]
SystemArgument2 equ [esp + 12]
Context         equ [esp + 16]

        lea     eax,Context             ; Calculate address of context record
        mov     NormalContext,eax       ; Pass as first parameter to
if DEVL
        xor     ebp,ebp                 ; Mark end of frame pointer list
endif
IFDEF STD_CALL
        jmp     _LdrpInitialize@12      ; LdrpInitialize
ELSE
        jmp     _LdrpInitialize         ; LdrpInitialize
ENDIF

stdENDP _LdrInitializeThunk

;++
;
; VOID
; LdrpCallInitRoutine(
;    IN PDLL_INIT_ROUTINE InitRoutine,
;    IN PVOID DllHandle,
;    IN ULONG Reason,
;    IN PCONTEXT Context OPTIONAL
;    )
;
; Routine Description:
;
;    This function calls an x86 DLL init routine.  It is robust
;    against DLLs that don't preserve EBX or fail to clean up
;    enough stack.
;
;    The only register that the DLL init routine cannot trash is ESI.
;
; Arguments:
;
;    InitRoutine - Address of init routine to call
;
;    DllHandle - Handle of DLL to call
;
;    Reason - one of the DLL_PROCESS_... or DLL_THREAD... values
;
;    Context - context pointer or NULL
;
; Return Value:
;
;    FALSE if the init routine fails, TRUE for success.
;
;--

cPublicProc _LdrpCallInitRoutine , 4

InitRoutine     equ [ebp + 8]
DllHandle       equ [ebp + 12]
Reason          equ [ebp + 16]
Context         equ [ebp + 20]

stdENDP _LdrpCallInitRoutine
        push    ebp
        mov     ebp, esp
        push    esi         ; save esi across the call
        push    edi         ; save edi across the call
        push    ebx         ; save ebx on the stack across the call
        mov     esi,esp     ; save the stack pointer in esi across the call
        push    Context
        push    Reason
        push    DllHandle
        call    InitRoutine
        mov     esp,esi     ; restore the stack pointer in case callee forgot to clean up
        pop     ebx         ; restore ebx
        pop     edi         ; restore edi
        pop     esi         ; restore esi
        pop     ebp
        stdRET  _LdrpCallInitRoutine

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\npxnp.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    npxnp.c

Abstract:

    This module contains support for non-Flat mode NPX faults when
    the application has it's CR0_EM bit clear.

Author:

    Ken Reneris (kenr) 8-Dec-1994

Environment:

    User Mode only

Revision History:

--*/


#include "csrdll.h"

static UCHAR MOD16[] = { 0, 1, 2, 0 };
static UCHAR MOD32[] = { 0, 1, 4, 0 };

UCHAR
NpxNpReadCSEip (
    IN PCONTEXT Context
    )
#pragma warning(disable:4035)
{
    _asm {
        push    es
        mov     ecx, Context
        mov     eax, [ecx] CONTEXT.SegCs
        mov     es, ax
        mov     eax, [ecx] CONTEXT.Eip
        inc     dword ptr [ecx] CONTEXT.Eip     ; Advance EIP
        mov     al, es:[eax]
        pop     es
    }
}
#pragma warning(default:4035)


VOID
NpxNpSkipInstruction (
    IN PCONTEXT Context
    )
/*++

Routine Description:

    This functions gains control when the system has no installed
    NPX support, but the thread has cleared it's EM bit in CR0.

    The purpose of this function is to move the instruction
    pointer forward over the current NPX instruction.

Enviroment:

    16:16 mode

Arguments:

Return Value:

--*/
{
    BOOLEAN     fPrefix;
    UCHAR       ibyte, Mod, rm;
    UCHAR       Address32Bits;
    ULONG       CallerCs;

    Address32Bits = 0;                          // assume called from 16:16

    //
    // Lookup and determine callers default mode
    //

    CallerCs = Context->SegCs;
    _asm {
        mov     eax, CallerCs
        lar     eax, eax
        test    eax, 400000h
        jz      short IsDefault16Bit

        mov     Address32Bits, 1

IsDefault16Bit:
    }

    //
    // No sense in using a try-except since we are not on the
    // correct stack.  A fault here could occur if the start
    // of an NPX instruction is near the end of a selector, and the
    // end of the instruction is past the selectors end.  This
    // would kill the app anyway.
    //

    //
    // Read any instruction prefixes
    //

    fPrefix = TRUE;
    while (fPrefix) {
        ibyte = NpxNpReadCSEip(Context);

        switch (ibyte) {
            case 0x2e:  // cs override, skip it
            case 0x36:  // ss override, skip it
            case 0x3e:  // ds override, skip it
            case 0x26:  // es override, skip it
            case 0x64:  // fs override, skip it
            case 0x65:  // gs override, skip it
            case 0x66:  // operand size override, skip it
                break;

            case 0x67:
                // address size override
                Address32Bits ^= 1;
                break;

            default:
                fPrefix = FALSE;
                break;
        }
    }

    //
    // Handle first byte of NPX instruction
    //

    if (ibyte == 0x9b) {

        //
        // FWait instruction - single byte opcode - all done
        //

        return;
    }

    if (ibyte < 0xD8 || ibyte > 0xDF) {

        //
        // Not an ESC instruction
        //

#if DBG
        DbgPrint ("P5_FPU_PATCH: 16: Not NPX ESC instruction\n");
#endif
        return;
    }

    //
    // Get ModR/M byte for NPX opcode
    //

    ibyte = NpxNpReadCSEip(Context);

    if (ibyte > 0xbf) {
        //
        // Outside of ModR/M range for addressing, all done
        //

        return;
    }

    Mod = ibyte >> 6;
    rm  = ibyte & 0x7;
    if (Address32Bits) {
        Context->Eip += MOD32 [Mod];
        if (Mod == 0  &&  rm == 5) {
            // disp 32
            Context->Eip += 4;
        }

        //
        // If SIB byte, read it
        //

        if (rm == 4) {
            ibyte = NpxNpReadCSEip(Context);

            if (Mod == 0  &&  (ibyte & 7) == 5) {
                // disp 32
                Context->Eip += 4;
            }
        }

    } else {
        Context->Eip += MOD16 [Mod];
        if (Mod == 0  &&  rm == 6) {
            // disp 16
            Context->Eip += 2;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\emtrig.asm ===
subttl	emtrig.asm - Trig functions sine, cosine, tangent
	page
;*******************************************************************************
;	 Copyright (c) Microsoft Corporation 1991
;	 All Rights Reserved
;
;emtrig.asm - Trig functions sine, cosine, tangent
;	by Tim Paterson
;
;Purpose:
;	FCOS, FPTAN, FSIN, FSINCOS instructions
;Inputs:
;	edi = [CURstk]
;
;Revision History:
;
; []	09/05/91  TP	Initial 32-bit version.
;
;*******************************************************************************


;XPi is the 66-bit value of Pi from the Intel manual
XPiHi		equ	0C90FDAA2H
XPiMid		equ	02168C234H
XPiLo		equ	0C0000000H	;Extension of pi
PiOver4exp	equ	-1		;Pi/4 ~= 3/4, so exponent is -1

TinyAngleExp	equ	-32		;Smallest angle we bother with
MaxAngleExp	equ	63		;Angle that's too big

Trig1Result:
;Trig function reduction routine used by functions returning 1 value
;(FSIN and FCOS)
;edi = [CURstk] = argument pointer
;Argument has already been checked for zero.
;ZF = (tag == bTAG_ZERO)
	jb	TrigPrem
;Tagged special
	mov	al,EMSEG:[edi].bTAG
	cmp	al,bTAG_DEN
	jz	TrigDenorm
	add	sp,4			;Don't return to caller
	cmp	al,bTAG_INF
	jnz	SpclDestNotDen		;Check for Empty or NAN
	mov	EMSEG:[SWcc],C2		;Can't reduce infinity
	jmp	ReturnIndefinite

TrigDenorm:
	mov	EMSEG:[CURerr],Denormal
	test	EMSEG:[CWmask],Denormal	;Is denormal exception masked?
	jnz	TrigPrem		;Yes, continue
	add	sp,4			;Don't return to caller
TrigRet:
	ret


Trig2Inf:
	mov	EMSEG:[SWcc],C2		;Can't reduce infinity
	jmp	Trig2Indefinite

Trig2StackOver:
	mov	EMSEG:[SWcc],C1		;Signal overflow
Trig2StackUnder:
	mov	EMSEG:[CURerr],Invalid+StackFlag
Trig2Indefinite:
	add	sp,4			;Don't return to caller
	call	ReturnIndefinite
	jz	TrigRet			;Unmasked, don't change registers
;Produce masked response
	mov	EMSEG:[CURstk],esi		;Push stack
	mov	edi,esi
	jmp	ReturnIndefinite

Trig2Special:
	cmp	al,bTAG_DEN
	jz	TrigDenorm
	cmp	al,bTAG_INF
	jz	Trig2Inf
;Must be a NAN
	add	sp,4			;Don't return to caller
	call	DestNAN
	jz	TrigRet			;Unmasked, don't change registers
;Produce masked response
	mov	EMSEG:[CURstk],esi		;Push stack
        mov     eax,EMSEG:[edi].ExpSgn
        mov     EMSEG:[esi].ExpSgn,eax
        mov     eax,EMSEG:[edi].lManHi
        mov     EMSEG:[esi].lManHi,eax
        mov     eax,EMSEG:[edi].lManLo
        mov     EMSEG:[esi].lManLo,eax
	ret

Trig2Zero:
	add	sp,4			;Don't return to caller
	mov	EMSEG:[CURstk],esi
	mov	edi,esi
;Amazing coincidence: both FSINCOS and FPTAN return the same result for
;a zero argument:
;	FSINCOS returns ST(0) = cos(0) = 1, ST(1) = sin(0) = 0.
;	FPTAN returns ST(0) = 1 always, ST(1) = tan(0) = 0.
;Return zero has same sign as argument zero, so we don't need to touch
;it -- just push +1.0.
	jmp	ReturnOne

TrigOutOfRange:
	mov	EMSEG:[SWcc],C2		;Signal argument not reduced
	add	sp,4
	ret

PrevStackWrap	esi,Trig2		;Tied to PrevStackElem below

Trig2Result:
;Trig function reduction routine used by functions returning 2 values
;(FSINCOS and FPTAN)
;edi = [CURstk] = argument pointer
	mov	esi,edi
	PrevStackElem	esi,Trig2	;esi points to second result location
	mov	al,EMSEG:[edi].bTAG	;Get tag
	cmp	al,bTAG_EMPTY		;Stack underflow if empty
	jz	Trig2StackUnder
	cmp	EMSEG:[esi].bTAG,bTAG_EMPTY	;Stack overflow if not empty
	jnz	Trig2StackOver
	cmp	al,bTAG_ZERO		;Is it Special?
	ja	Trig2Special
	jz	Trig2Zero
;Fall into TrigPrem

;****
;TrigPrem
;
;This routine reduces an angle in radians to the range [0, pi/4].
;Angles in odd-numbered octants have been subtracted from pi/4.
;It uses a 66-bit value for pi, as required by the 387.
;TrigPrem uses the same two-stage algorithm as FPREM (see 
;emfprem.asm).	However, it is limited to an argument < 2^63.
;
;Inputs:
;	edi = [CURstk]
;Outputs:
;	ebx:esi = remainder, normalized
;	high ecx = exponent, cl = tag
;	al = octant
;	edi = [CURstk]

TrigPrem:
	mov	EMSEG:[Result],edi
	mov	eax,EMSEG:[edi].lManLo
	mov	edx,EMSEG:[edi].lManHi
	movsx	ebx,EMSEG:[edi].wExp
	cmp	ebx,MaxAngleExp
	jge	TrigOutOfRange
	xor	edi,edi			;Extend dividend
	xor	esi,esi			;Quotient, in case we skip stage 1
.erre	PiOver4exp eq -1
	inc	ebx			;Subtract exponent of pi/4
	jl	ExitTrigPrem		;If dividend is smaller, return it.
;We now know that 0 <= ExpDif < 64, so it fits in bl.
	cmp	bl,31			;Do we need to do stage 1?
	jl	FitPi			;No, start stage 2

;FPREM stage 1
;
;Exponent difference is at least 31.  Use 32-bit division to compute
;quotient and exact remainder, reducing exponent difference by 31.
;
;edx:eax = dividend
;ebx = exponent difference

;Shift dividend right one bit to be sure DIV instruction won't overflow
;This means we'll be reducing the exponent difference by 31, not 32
	xor	ebp,ebp			;Dividend extension
	shrd	ebp,eax,1
	shrd	eax,edx,1
	shr	edx,1

	sub	bl,31			;Exponent reduced
	mov	ecx,XPiHi
	div	ecx			;Guess a quotient "digit"

;Check out our guess.  
;Currently, remainder in edx = (high dividend) - (quotient * high pi).
;(High dividend is the upper 64 bits--ebp has 1 bit.)  The definition 
;of remainder is (all dividend) - (quotient * all pi).  So if we
;subtract (quotient * low pi) from edx:ebp, we'll get the true 
;remainder.  If it's negative, our guess was too big.

	mov	esi,eax			;Save quotient
	mov	ecx,edx			;Save remainder

;The pi/4 we use has two bits set below the first 64 bits.  This means
;we must add another 3/4 of the quotient into the amount to subtract,
;which we'll compute by rounding the low 32 bits up 1, then subtracting 
;1/4 of quotient.  But since we're computing the amount to subtract from
;the remainder, we'll add the 1/4 of the quotient to the remainder instead
;of subtracting it from the amount to subtract.

.erre	XPiLo eq (3 shl 30)
	mov	eax,XPiMid+1
	mul	esi			;Quotient * low pi
;Note that ebp is either 0 or 800...00H
	shr	ebp,30			;Move down to low end
	shld	ebp,esi,30		;Move back up, adding 1/4 of quotient
	mov	edi,esi			;Another copy of quotient
	shl	edi,30			;Keep last two bits
;edx:eax has amount to subtract to get correct remainder from ecx:ebp:edi
	sub	ebp,eax
	sbb	ecx,edx			;Subtract from remainder
	mov	eax,ebp
	mov	edx,ecx			;Remainder back to edx:eax:edi
	jnc	TrigPremNorm		;Was quotient OK?
TrigCorrect:
	dec	esi			;Quotient was too big
	add	edi,XPiLo
	adc	eax,XPiMid		;Add divisor back into remainder
	adc	edx,XPiHi
	jnc	TrigCorrect		;Repeat if quotient is still too big
	jmp	TrigPremNorm

;FPREM stage 2
;
;Exponent difference is less than 32.  Use restoring long division to
;compute quotient bits until exponent difference is zero.  Note that we
;often get more than one bit/loop:  BSR is used to scan off leading
;zeros each time around.  Since the divisor is normalized, we can
;instantly compute a zero quotient bit for each leading zero bit.

TrigPremLoop:
;edx:eax:edi = dividend (remainder) minus pi/4
;esi = quotient
;ebx = exponent difference
;
;If D is current dividend and p is pi/4, then we have edx:eax:edi = D - p, 
;which is negative.  We want 2*D - p, which is positive.  
;2*D - p = 2*(D - p) + p.
	add	edi,edi			;2*(D - p)
	adc	eax,eax
	adc	edx,edx

	add	edi,XPiLo		;2*(D-p) + p = 2*D - p
	adc	eax,XPiMid
	adc	edx,XPiHi

	add	esi,esi			;Double quotient too
	dec	ebx			;Decrement exponent difference
PiFit:
	inc	esi
TrigPremNorm:
	bsr	ecx,edx			;Find first 1 bit
	jz	TrigPremZero
	not	cl
	and	cl,1FH			;Convert bit no. to shift count
	sub	ebx,ecx			;Reduce exponent difference
	jl	TrigTooFar
	shld	edx,eax,cl
	shld	eax,edi,cl
	shl	edi,cl			;Finish normalize shift
	shl	esi,cl			;Shift quotient
FitPi:
;Dividend could be larger or smaller than divisor
	sub	edi,XPiLo
	sbb	eax,XPiMid
	sbb	edx,XPiHi
	jnc	PiFit
;Couldn't subtract pi/2 from dividend.	
;edx:eax:edi = dividend - pi/4, which is negative
	or	ebx,ebx			;Is exponent difference zero?
	jg	TrigPremLoop
;If quotient (octant number) is odd, we have subtracted an odd number of
;pi/4's.  However, simple angle reductions work in multiples of pi/2.
;We will keep the extra pi/4 we just subtracted if the octant was odd.
;This will give a result range of [-pi/4, pi/4].  
	test	esi,1			;Is octant odd?
	jz	EvenOctant
NegPremResult:
;-pi/4 < dividend < 0.  Negate this since we use sign-magnitude representation.
	not	edx			;96-bit negation
	not	eax
	neg	edi
	sbb	eax,-1
	sbb	edx,-1
;May need to normalize
	bsr	ecx,edx
	jz	TrigNorm32
	lea	ebx,[ebx+ecx-31]	;Fix up exponent for normalization
	not	cl			;Convert bit no. to shift count
TrigShortNorm:
	shld	edx,eax,cl
	shld	eax,edi,cl
	shl	edi,cl			;Finish normalize shift
RoundPrem:
;Must round 66-bit result to 64 bits.
;To perform "round even" when the round bit is set and the sticky bits
;are zero, we treat the LSB as if it were a sticky bit.  Thus if the LSB
;is set, that will always force a round up (to even) if the round bit is
;set.  If the LSB is zero, then the sticky bits remain zero and we always
;round down.  This rounding rule is implemented by adding RoundBit-1
;(7F..FFH), setting CY if round up.  
	bt	eax,0			;Is mantissa even or odd? (set CY)
	adc	edi,(1 shl 31)-1	;Sum LSB & sticky bits--CY if round up
	adc	eax,0
	adc	edx,0
ExitTrigPrem:
;edx:eax = remainder, normalized
;esi = quotient
;ebx = exponent difference, zero or less
.erre	PiOver4exp eq -1
	dec	ebx			;True exponent
.erre	bTAG_SNGL eq 0
	shrd	ecx,ebx,16		;Exponent to high ecx
	mov	ebx,edx			;High mant. to ebx
	xchg	esi,eax			;Low mant. to esi, octant to eax
	or      esi,esi			;Any bits in low half?
.erre   bTAG_VALID eq 1
.erre   bTAG_SNGL eq 0
	setnz   cl			;if low half==0 then cl=0 else cl=1
	mov	edi,EMSEG:[CURstk]
	test	EMSEG:[edi].bSgn,bSign	;Was angle negative?
	jnz	FlipOct			;Yes, flip octant over
	ret

FlipOct:
;Angle was negative.  Subtract octant from 7.
	neg	al
	add	al,7
	ret

EvenOctant:
;Restore dividend
	add	edi,XPiLo
	adc	eax,XPiMid
	adc	edx,XPiHi
	jmp	RoundPrem

TrigTooFar:
;Exponent difference in ebx went negative when reduced by shift count in ecx.
;We need a quotient corresponding to exponent difference of zero.
	add	ecx,ebx			;Compute previous exponent difference
	shl	esi,cl			;Fix up quotient
	sub	ecx,ebx			;Restore shift count
	test	esi,1			;Is octant odd?
	jz	TrigShortNorm		;No, go normalize
	xor	ebx,ebx			;Restore old exponent difference (zero)
SubPiOver4:
;We are here if exponent difference was zero and octant is odd.
;As noted above, we need to reduce the angle by a multiple of pi/2,
;not pi/4.  We will subtract one more pi/4, which will make the
;result range [-pi/4, pi/4].
	sub	edi,XPiLo
	sbb	eax,XPiMid
	sbb	edx,XPiHi
	jmp	NegPremResult

TrigPremZero:
;High dword of remainder is all zero, so we've reduced exponent difference
;by 32 bits and overshot.  We need a quotient corresponding to exponent 
;difference of zero, so we just shift it by the original difference.  Then
;we need to normalize the rest of the remainder.
	mov	ecx,ebx			;Get exponent difference
	shl	esi,cl			;Fix up quotient
	test	esi,1			;Is octant odd?
	jnz	SubPiOver4		;Yes, go subtract another pi/4
TrigNorm32:
	bsr	ecx,eax
	jz	TinyTrig
	lea	ebx,[ebx+ecx-31-32]	;Fix up exponent for normalization
	mov	edx,eax
	mov	eax,edi			;Shift left by 32 bits
	not	cl			;Convert bit no. to shift count
	shld	edx,eax,cl		;Normalize remainder
	shl	eax,cl
	jmp	ExitTrigPrem

TinyTrig:
;Upper 64 bits of remainder are all zero.  We are assured that the extended
;remainder is never zero, though.
	mov	edx,edi			;Shift left 64 bits
	bsr	ecx,edi
	lea	ebx,[ebx+ecx-31-64]	;Fix up exponent for normalization
	not	cl			;Convert bit no. to shift count
	shl	edx,cl			;Normalize
	jmp	ExitTrigPrem

;*******************************************************************************

EM_ENTRY eFCOS
eFCOS:
    and		[esp].[OldLongStatus+4],NOT(C2 SHL 16)	;clear C2
	cmp	EMSEG:[edi].bTAG,bTAG_ZERO
	jz	ReturnOne
	call	Trig1Result
;ebx:esi,ecx = reduced argument
;eax = octant
	mov	ch,80H			;Assume negative
	test	al,110B			;Negative in octants 2 - 5
	jpo	@F			;Occurs when 1 of these bits are set
	xor	ch,ch			;Actually positve
@@:
	test	al,011B			;Look for octants 0,3,4,7
	jpo	TakeSine		;Use sine if not
TakeCosine:
	cmp	ecx,TinyAngleExp shl 16	;Is angle really small?
	jl	CosReturnOne		;cos(x) = 1 for tiny x
CosNotTiny:
	mov	edi,offset tCosPoly
;Note that argument needs to be saved in ArgTemp (by EvalPolySetup) in case 
;we were called from eFSINCOS and we'll need the arg for the sine.  Argument
;is not needed for cosine, however (just its square).
	call	EvalPolySetup		;In emftran.asm
	mov	ch,EMSEG:[ArgTemp].bSgn	;Get sign we already figured out
TransUnround:
;The last operation performed a simple round nearest, without setting the 
;C1 status bit if round up occured.  We reverse this last rounding now
;so we can do the user's selected rounding mode.  We also ensure that
;the answer is never exact.
	sub	eax,(1 shl 31)-1	;Sum LSB & sticky bits--CY if round up
	jz	UnroundExact		;Answer looks exact, but it's not
	sbb	esi,0
	sbb	ebx,0
	jns	PolyDropExponent	;We had rounded up exponent too
FinalTransRound:
;A jump through [TransRound] is only valid if the number is known not to
;underflow.  Unmasked underflow requires [RoundMode] be set.
	mov	edx,EMSEG:[TransRound]
	mov	EMSEG:[RoundMode],edx
	call	edx			;Perform user's rounding
RestoreRound:
;Restore rounding vectors
	mov	EMSEG:[ZeroVector],offset SaveResult
	mov	eax,EMSEG:[SavedRoundMode]
	mov	EMSEG:[RoundMode],eax
	ret

UnroundExact:
	inc	eax			;Let's say our answer is a bit small
	jmp	FinalTransRound

PolyDropExponent:
	sub	ecx,1 shl 16		;Decrement exponent
	or	ebx,1 shl 31		;Set MSB
	jmp	FinalTransRound


SinRet:
	ret

SaveTinySin:
;Argument in ebx:esi,ecx is small enough so that sin(x) = x, which happens
;when x - x^3/6 = x [or 1 - x^2/6 = 1].  Note that the infinitely precise
;result is slightly less than the argument.  To get the correct answer for
;any rounding mode, we decrement the argument and set up for rounding.
	mov	eax,-1			;Set up rounding bits
	sub	esi,1
	sbb	ebx,0			;Drop mantissa by one
	js	FinalTransRound		;Still normalized?
;mantissa must have been 800..000H, set it to 0FFF...FFFH and drop exponent
	mov	ebx,eax			;ebx = -1
	sub	ecx,1 shl 16		;Drop exponent by one
	jmp	FinalTransRound


EM_ENTRY eFSIN
eFSIN:
    and		[esp].[OldLongStatus+4],NOT(C2 SHL 16)	;clear C2
	cmp	EMSEG:[edi].bTAG,bTAG_ZERO
	jz	SinRet			;Return zero for zero argument
	call	Trig1Result
	mov	ch,al
	shl	ch,7-2			;Move bit 2 to bit 7 as sign bit
ReducedSine:
;ebx:esi,ecx = reduced argument
;ch = correct sign
;eax = octant
	test	al,011B			;Look for octants 0,3,4,7
	jpo	TakeCosine		;Use cosine if not
TakeSine:
	cmp	ecx,TinyAngleExp shl 16	;Is angle really small?
	jl	SaveTinySin		;sin(x) = x for tiny x

;The polynomial for sine is  sin(x) = x * P(x^2).  However, the degree zero
;coefficient of P() is 1, so  P() = R() + 1, where R() has no degree zero
;term.	Thus  sin(x) = x * [R(x^2) + 1] = x * R(x^2) + x.
;
;What's important here is that adding 1 to R(x^2) can blow away a lot of
;precision just before we do that last multiply by x.  Note that x < pi/4 < 1,
;so that x^2 is often << 1.  The precision is lost when R(x^2) is shifted
;right to align its binary point with 1.0.  This can cause a loss of at
;least 1 bit of precision after the final multiply by x in addition to 
;rounding errors.
;
;To avoid this precision loss, we use the alternate form given above,
;sin(x) = x * R(x^2) + x.  Instead of adding 1.0 and multiplying by x,
;we multiply by x and add x--exactly the same level of difficulty.  But
;the mulitply has all of R(x^2)'s precision available.
;
;Because the polynomial R() has no zero-degree term, we give EvalPoly
;one degree less (so we don't have to add zero as the last term).
;Then we have to multiply once more by x^2 since we left the loop early.

SineNotTiny:
	mov	edi,offset tSinPoly
	call	EvalPolySetup		;In emftran.asm
SineFinish:

ifdef NT386
        mov	edi,YFloatTemp
else
	mov	edi,offset edata:FloatTemp
endif
	call	PolyMulDouble		;Last coefficient in R(x^2)

ifdef NT386
	mov	edi,YArgTemp		;Point to original x
else
	mov	edi,offset edata:ArgTemp ;Point to original x
endif

	call	PolyMulDouble		;Compute x * R(x^2)

ifdef NT386
	mov	edi,YArgTemp		;Point to original x
else
	mov	edi,offset edata:ArgTemp ;Point to original x
endif

	push	offset TransUnround
	jmp	PolyAddDouble		;Compute x * R(x^2) + x


EM_ENTRY eFPTAN
eFPTAN:
    and		[esp].[OldLongStatus+4],NOT(C2 SHL 16)	;clear C2
	call	Trig2Result
	push	offset TanPushOne	; Push 1.0 when we're all done
;ebx:esi,ecx = reduced argument
;eax = octant
	mov	ch,al
	shl	ch,7-1			;Move bit 1 to bit 7 as sign bit
;Note that ch bit 6 now has even/odd octant, which we'll need when we're
;done to see if we should take reciprocal.
	cmp	ecx,TinyAngleExp shl 16	;Is angle really small?
	jl	TinyTan
	mov	edi,offset tTanPoly
	call	Eval2Poly		;In emftran.asm
	mov	edi,EMSEG:[CURstk]	;Point to first result
	push	offset TransUnround	;Return address of divide
	test	EMSEG:[ArgTemp].bSgn,0C0H	;Check low 2 bits of octant
;Given the reduced input range, the result can never overflow or underflow.
;It is must then be safe to assume neither operand is zero.
	jpe	DivDouble		;Tan() octants 0,3,4,7
	jmp	DivrDouble		;CoTan()

TinyTan:
	test	ch,0C0H			;Check low 2 bits of octant
	jpe	SaveTinySin		;Octants 0,3,4,7: tan(x) = x for tiny x
;Need reciprocal of reduced argument
	mov	edi,esi
	mov	esi,ebx			;Mantissa in esi:edi
	mov	ebx,ecx			;ExpSgn to ebx
	mov	edx,1 shl 31		;Load 1.0
	xor	eax,eax
.erre	TexpBias eq 0
	xor	ecx,ecx			;Sign and exponent are zero
;dividend mantissa in edx:eax, exponent in high ecx, sign in ch bit 7
;divisor mantissa in esi:edi, exponent in high ebx, sign in bh bit 7
	push	offset TransUnround	;Return address of divide
;Note that this can never overflow, because the reduced argument is never
;smaller than about 2^-65.
	jmp	DivDoubleReg


PrevStackWrap	edi,Tan			;Tied to PrevStackElem below

TanPushOne:
	PrevStackElem	edi,Tan		;edi points to second result location
	mov	EMSEG:[CURstk],edi
ReturnOne:
	mov	EMSEG:[edi].lManLo,0
	mov	EMSEG:[edi].lManHi,1 shl 31
	mov	EMSEG:[edi].ExpSgn,(0-TexpBias) shl 16 + bTAG_SNGL
	ret


PrevStackWrap	edi,SinCos		;Tied to PrevStackElem below

eFSINCOS:
    and		[esp].[OldLongStatus+4],NOT(C2 SHL 16)	;clear C2
	call	Trig2Result
;Figure out signs
	mov	ch,al			;Start with sign of sine
	shl	ch,7-2			;Move bit 2 to bit 7 as sign bit
	mov	ah,80H			;Assume sign of cosine is negative
	test	al,110B			;Negative in octants 2 - 5
	jpo	@F			;Occurs when 1 of these bits are set
	xor	ah,ah			;Actually positve
@@:
;ch = sign of sine
;ah = sign of cosine
	cmp	ecx,TinyAngleExp shl 16	;Is angle really small?
	jl	TinySinCos
	push	eax			;Save octant and sign of cosine
	call	ReducedSine		;On exit, edi = [CURstk]
	pop	eax
;The Sin() funcion restored the rounding vectors to normal.  Set them back.
	mov	EMSEG:[RoundMode],offset PolyRound
	mov	EMSEG:[ZeroVector],offset PolyZero
	PrevStackElem	edi,SinCos	;edi points to second result location
	mov	EMSEG:[CURstk],edi
	mov	EMSEG:[Result],edi
;Load x^2 back into registers
	mov	ecx,EMSEG:[FloatTemp].ExpSgn
	mov	ebx,EMSEG:[FloatTemp].lManHi
	mov	esi,EMSEG:[FloatTemp].lManLo
	mov	EMSEG:[ArgTemp].bSgn,ah	;Save sign
	test	al,011B			;Look for octants 0,3,4,7
	jpo	FastSine		;Use sine if not
	mov	edi,offset tCosPoly
	call	EvalPoly		;In emftran.asm
	mov	ch,EMSEG:[ArgTemp].bSgn	;Get sign we already figured out
	jmp	TransUnround

FastSine:
	mov	edi,offset tSinPoly
	push	offset SineFinish
	jmp	EvalPoly		;In emftran.asm

TinySinCos:
;ch = sign of sine
;ah = sign of cosine
;ebx:esi,high ecx = reduced argument
;edi = [CURstk]
	test	al,011B			;Look for octants 0,3,4,7
	jpo	TinyCosSin		;Take cosine first if not
	push	eax
	call	SaveTinySin		;For sine, arg is result
	pop	ecx
;edi = [CURstk]
;ch = sign of cosine
;Set cosine to 1.0
	PrevStackElem	edi,TinySinCos	;edi points to second result location
	mov	EMSEG:[CURstk],edi
	mov	EMSEG:[Result],edi
CosReturnOne:
;Cosine is nearly equal to 1.0.  Put in next smaller value and round it.
	mov	ebx,-1
	mov	esi,ebx			;Set mantissa to -1
	mov	eax,ebx			;Set up rounding bits
.erre	TexpBias eq 0
	and	ecx,bSign shl 8		;Keep only sign
	sub	ecx,1 shl 16		;Exponent of -1
;A jump through [TransRound] is only valid if the number is known not to
;underflow.  Unmasked underflow requires [RoundMode] be set.
	jmp	EMSEG:[TransRound]

	PrevStackWrap	edi,TinySinCos

	PrevStackWrap	edi,TinyCosSin

TinyCosSin:
;Sine is nearly 1.0, cosine is argument
;
;ch = sign of sine
;ah = sign of cosine
;ebx:esi,high ecx = reduced argument
;edi = [CURstk]
	xchg	ah,ch			;Cosine sign to ch, sine sign to ah
	push	edi			;Save place for sine
	PrevStackElem	edi,TinyCosSin	;edi points to second result location
	mov	EMSEG:[CURstk],edi
	mov	EMSEG:[Result],edi
	push	eax
	call	SaveTinySin		;For sine, arg is result
	pop	ecx
;ch = sign of sine
	pop	EMSEG:[Result]		;Set up location for sine
	jmp	CosReturnOne

;*******************************************************************************

;********************* Polynomial Coefficients *********************

;These polynomial coefficients were all taken from "Computer Approximations"
;by J.F. Hart (reprinted 1978 w/corrections).  All calculations and 
;conversions to hexadecimal were done with a character-string calculator
;written in Visual Basic with precision set to 30 digits.  Once the constants
;were typed into this file, all transfers were done with cut-and-paste
;operations to and from the calculator to help eliminate any typographical
;errors.


tCosPoly	label	word

;These constants are derived from Hart #3824: cos(x) = P(x^2),
;accurate to 19.45 digits over interval [0, pi/4].  The original 
;constants in Hart required that the argument x be divided by pi/4.  
;These constants have been scaled so this is no longer required.
;Scaling is done by multiplying the constant by a power of 4/pi.
;The power is given in the table.

	dd	7			;Degree seven

;  Original Hart constant	      power	Scaled constant
;
;-0.38577 62037 2		 E-12  14  -0.113521232057839395845871741043E-10
;Hex value:    0.C7B56AF786699CF1BD13FD290 HFFDC
	dq	0C7B56AF786699CF2H
	dw	(bSign shl 8)+bTAG_VALID,0FFDCH-1

;+0.11500 49702 4263		  E-9  12  +0.208755551456778828747793797596E-8
;Hex value:    0.8F74AA3CCE49E68D6F5444A18 HFFE4
	dq	08F74AA3CCE49E68DH
	dw	bTAG_VALID,0FFE4H-1

;-0.24611 36382 63700 5		  E-7  10  -0.275573128656960822243472872247E-6
;Hex value:    0.93F27B7F10CC8A1703EFC8A04 HFFEB
	dq	093F27B7F10CC8A17H
	dw	(bSign shl 8)+bTAG_VALID,0FFEBH-1

;+0.35908 60445 88581 953	  E-5	8  +0.248015872828994630247806807317E-4
;Hex value:    0.D00D00CD6BB3ECD17E10D5830 HFFF1
	dq	0D00D00CD6BB3ECD1H
	dw	bTAG_VALID,0FFF1H-1

;-0.32599 18869 26687 55044	  E-3	6  -0.138888888888589604343951947246E-2
;Hex value:    0.B60B60B609B165894CFE522AC HFFF7
	dq	0B60B60B609B16589H
	dw	(bSign shl 8)+bTAG_VALID,0FFF7H-1

;+0.15854 34424 38154 10897 54	  E-1	4  +0.416666666666664302573692446873E-1
;Hex value:    0.AAAAAAAAAAA99A1AF53042B08 HFFFC
	dq	0AAAAAAAAAAA99A1BH
	dw	bTAG_VALID,0FFFCH-1

;-0.30842 51375 34042 45242 414	  E0	2  -0.499999999999999992843582920899E0
;Hex value:    0.FFFFFFFFFFFFFEF7F98D3BFA8 HFFFF
	dq	0FFFFFFFFFFFFFEF8H
	dw	(bSign shl 8)+bTAG_VALID,0FFFFH-1

;+0.99999 99999 99999 99996 415	  E0	0  (no change)
;Hex value     0.FFFFFFFFFFFFFFFF56B402618 H0
	dq	0FFFFFFFFFFFFFFFFH
	dw	bTAG_VALID,00H-1


tSinPoly	label	word

;These constants are derived from Hart #3044: sin(x) = x * P(x^2),
;accurate to 20.73 digits over interval [0, pi/4].  The original 
;constants in Hart required that the argument x be divided by pi/4.  
;These constants have been scaled so this is no longer required.
;Scaling is done by multiplying the constant by a power of 4/pi.
;The power is given in the table.

	dd	7-1			;Degree seven, but the last coefficient
					;is 1.0 and is not listed here.

;  Original Hart constant	      power	Scaled constant
;
;-0.20225 31292 93		 E-13  15  -0.757786788401271156262125540409E-12
;Hex value:    0.D54C4AF2B524F0F2D6411C90A HFFD8
	dq	0D54C4AF2B524F0F3H
	dw	(bSign shl 8)+bTAG_VALID,0FFD8H-1

;+0.69481 52035 0522		 E-11  13  +0.160583476232246065559545749398E-9
;Hex value:    0.B0903AF085DA66030F16E43BC HFFE0
	dq	0B0903AF085DA6603H
	dw	bTAG_VALID,0FFE0H-1

;-0.17572 47417 61708 06	  E-8  11  -0.250521047382673309542092418731E-7
;Hex value:    0.D73229320D2AF05971AC96FF4 HFFE7
	dq	0D73229320D2AF059H
	dw	(bSign shl 8)+bTAG_VALID,0FFE7H-1

;+0.31336 16889 17325 348	  E-6	9  +0.275573192133901687156480447942E-5
;Hex value:    0.B8EF1D2984D2FBA28A9CC9DEE HFFEE
	dq	0B8EF1D2984D2FBA3H
	dw	bTAG_VALID,0FFEEH-1

;-0.36576 20418 21464 00052 9	  E-4	7  -0.198412698412531058609618529749E-3
;Hex value:    0.D00D00D00C3FDDD7916E5CB28 HFFF4
	dq	0D00D00D00C3FDDD8H
	dw	(bSign shl 8)+bTAG_VALID,0FFF4H-1

;+0.24903 94570 19271 62752 519	  E-2	5  +0.83333333333333203341753387264E-2
;Hex value:    0.8888888888884C95D619A0343 HFFFA
	dq	08888888888884C96H
	dw	bTAG_VALID,0FFFAH-1

;-0.80745 51218 82807 81520 2582  E-1	3  -0.166666666666666666281276062229E0
;Hex value:    0.AAAAAAAAAAAAAA8E3AD80EAB8 HFFFE
	dq	0AAAAAAAAAAAAAA8EH
	dw	(bSign shl 8)+bTAG_VALID,0FFFEH-1

;+0.78539 81633 97448 30961 41845 E0	1  +0.99999999999999999999812025812E0
;Hex value:    0.FFFFFFFFFFFFFFFFF71F88110 H0
;	dq	8000000000000000H	;This constant of 1.0 omitted here.
;	dw	bTAG_VALID,0		;   It is handled in code.


tTanPoly	label	word

;These constants are derived from Hart #4286: tan(x) = x * P(x^2) / Q(x^2),
;accurate to 19.94 digits over interval [0, pi/4].  The original 
;constants in Hart required that the argument x be divided by pi/4.  
;These constants have been scaled so this is no longer required.
;Scaling is done by multiplying the constant by the same power of 4/pi
;as the power of x the constant is used on.  However, the highest
;degree coefficient of Q() is 1, and after scaling this way it would
;become (4/pi)^8.  In order to keep this coefficient equal to one,
;we scale everything again by (pi/4)^8.  This scaling is partially
;canceled by the original scaling by powers of 4/pi, and the net
;resulting power of pi/4 is given in the table.


	dd	3			;First poly is degree 3

;  Original Hart constant	        power	Scaled constant
;
;-.45649 31943 86656 31873 96113 7    E2  1  -35.8528916474714232910463077546
;Hex value:    0.8F695C6D93AF6F97B6E022AB3 H6
        dq      08F695C6D93AF6F98H
        dw      (bSign shl 8)+bTAG_VALID,06H-1

;+.14189 85425 27617 78388 00394 831  E5  3  +6874.60229709782436592720603503
;Hex value:    0.D6D4D181240D0D08C88DF4AA6 HD
        dq      0D6D4D181240D0D09H
        dw      bTAG_VALID,0DH-1

;-.89588 84400 67680 41087 29639 541  E6  5  -267733.884797157298951145495276
;Hex value:    0.82BABC504220C62B1D0722684 H13
        dq      082BABC504220C62BH
        dw      (bSign shl 8)+bTAG_VALID,013H-1

;+.10888 60043 72816 87521 38857 983  E8  7  +2007248.9111748838841548144685
;Hex value:    0.F506874A160EB9C0994AADD6A H15
        dq      0F506874A160EB9C1H
        dw      bTAG_VALID,015H-1



	dd	4			;Second poly is degree 4
;NOTE: Eval2Poly assumes the first coefficient is 1.0, so it is omitted

;  Original Hart constant	        power	Scaled constant
;
;-.10146 56190 25288 53387 54401 947  E4  2  -625.890950057027419879480354834
;Hex value:    0.9C790553635355A95241A5324 HA
        dq      09C790553635355A9H
        dw      (bSign shl 8)+bTAG_VALID,0AH-1

;+.13538 27128 05119 09382 89294 872  E6  4  +51513.6992033752080924797647367
;Hex value:    0.C939B2FEFE0DC585E649870FE H10
        dq      0C939B2FEFE0DC586H
        dw      bTAG_VALID,010H-1

;-.39913 09518 03516 51504 43427 94   E7  6  -936816.855188785264866481436899
;Hex value:    0.E4B70DAEDA6F89E5A7CE626FA H14
        dq      0E4B70DAEDA6F89E6H
        dw      (bSign shl 8)+bTAG_VALID,014H-1

;+.13863 79666 35676 29165 33913 361  E8  8  +2007248.91117488388417770850458
;Hex value:    0.F506874A160EB9C0CCD8313BC H15
        dq      0F506874A160EB9C1H
        dw      bTAG_VALID,015H-1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\nt386npx.inc ===
NPX_CONTEXT_FULL		EQU 00001000Fh	;/ Full context

ContextFlags equ CsContextFlags
ctx_env      equ CsFloatSave
ctx_stack    equ CsFloatSave+FpRegisterArea  ;need to change this puppy
ctx_Cr0NpxState equ CsFloatSave+FpCr0NpxState
ctx_SegGs    equ CsSegGs
ctx_SegFs    equ CsSegFs
ctx_SegEs    equ CsSegEs
ctx_SegDs    equ CsSegDs
ctx_RegEdi   equ CsEdi
ctx_RegEsi   equ CsEsi
ctx_RegEbp   equ CsEbp
ctx_RegEbx   equ CsEbx
ctx_RegEdx   equ CsEdx
ctx_RegEcx   equ CsEcx
ctx_RegEax   equ CsEax
ctx_RegEip   equ CsEip
ctx_SegCs    equ CsSegCs
ctx_EFlags   equ CsEflags
ctx_RegEsp   equ CsEsp
ctx_SegSs    equ CsSegSs

XCPT_FLOAT_INVALID_OPERATION    EQU STATUS_FLOAT_INVALID_OPERATION
XCPT_FLOAT_DENORMAL_OPERAND     EQU STATUS_FLOAT_DENORMAL_OPERAND
XCPT_FLOAT_DIVIDE_BY_ZERO       EQU STATUS_FLOAT_DIVIDE_BY_ZERO
XCPT_FLOAT_OVERFLOW             EQU STATUS_FLOAT_OVERFLOW
XCPT_FLOAT_UNDERFLOW            EQU STATUS_FLOAT_UNDERFLOW
XCPT_FLOAT_INEXACT_RESULT       EQU STATUS_FLOAT_INEXACT_RESULT
XCPT_FLOAT_STACK_CHECK          EQU STATUS_FLOAT_STACK_CHECK

ExceptionNum                equ ErExceptionCode
FHandlerFlags               equ ErExceptionFlags
NestedExceptionReportRecord equ ErExceptionRecord
ExceptionAddress            equ ErExceptionAddress
CParameters                 equ ErNumberParameters


Em87Busy    equ     1
Em87Idle    equ     0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntdll\i386\emxtract.asm ===
subttl	emxtract - FXTRACT and FSCALE instructions
        page
;*******************************************************************************
;emxtract - FXTRACT and FSCALE instructions
;
;        Microsoft Confidential
;
;	 Copyright (c) Microsoft Corporation 1991
;        All Rights Reserved
;
;Inputs:
;	edi = [CURstk]
;
;Revision History:
;
; []	09/05/91  TP	Initial 32-bit version.
;
;*******************************************************************************


XtractStackOver:
	mov	EMSEG:[SWcc],C1		;Flag stack overflow
XtractEmpty:
;Result is two Indefinites (if exception masked)
	call	StackError		;Put first indefinite at [edi] = ST(0)
	jz	XtractExit		;Error was unmasked--just exit
	mov	EMSEG:[CURstk],edi
        mov     eax,EMSEG:[edi].ExpSgn
        mov     EMSEG:[esi].ExpSgn,eax
        mov     eax,EMSEG:[edi].lManHi
        mov     EMSEG:[esi].lManHi,eax
        mov     eax,EMSEG:[edi].lManLo
        mov     EMSEG:[esi].lManLo,eax
	ret

	PrevStackWrap	edi,Xtract

EM_ENTRY eFXTRACT
eFXTRACT:
;edi = [CURstk]
	mov	esi,edi			;Save current ST
	PrevStackElem	edi,Xtract
;edi = ST(0)
;esi = ST(1) (operand)
	mov	eax,EMSEG:[esi].ExpSgn
;Exception priority requires reporting stack underflow (i.e., using an EMPTY)
;before stack overflow (i.e., no place for result).  Yes, both can happen
;together if they've messed with the stack! (ST empty when ST(-1) isn't).
	cmp	al,bTAG_EMPTY		;Is operand empty?
	jz	XtractEmpty
	cmp	EMSEG:[edi].bTag,bTAG_EMPTY	;Is there an empty spot?
	jnz	XtractStackOver
	cmp	al,bTAG_ZERO		;Is it special?
	jae	XtractSpclOrZero
XtractNormal:
	mov	EMSEG:[CURstk],edi
.erre   TexpBias eq 0
        movzx   ebx,ax                  ;Zero exponent
;Save mantissa in ST(0)
        mov     EMSEG:[edi].ExpSgn,ebx
        mov     ebx,EMSEG:[esi].lManHi
        mov     EMSEG:[edi].lManHi,ebx
        mov     ebx,EMSEG:[esi].lManLo
        mov     EMSEG:[edi].lManLo,ebx
	mov	edi,esi			;Save ST(1) pointer in edi
	shr	eax,16			;Move exponent down
	call	NormInt16		;in emload.asm
;mantissa in ebx:esi, exponent in high ecx, sign in ch bit 7, tag in cl
	mov	EMSEG:[edi].lManLo,esi
	mov	EMSEG:[edi].lManHi,ebx
	mov	EMSEG:[edi].ExpSgn,ecx
XtractExit:
	ret

XtractSpcl:
	cmp	al,bTAG_INF
	jz	XtractInf
	cmp	al,bTAG_NAN
	jz	XtractNAN
;Must be denormal.  Change tag to VALID or SNGL.
	cmp	EMSEG:[esi].lManLo,0		;Any bits in low half?
.erre	bTAG_VALID eq 1
.erre	bTAG_SNGL eq 0
	setnz	al			;if low half==0 then al=0 else al=1
	mov	EMSEG:[CURerr],Denormal
	test	EMSEG:[CWmask],Denormal	;Is it masked?
	jnz	XtractNormal		;If so, ignore denormalization
	ret

XtractSpclOrZero:
	ja	XtractSpcl
;Operand is zero.  Result is ST(0) = 0 (same sign), ST(1) = -infinity
	mov	EMSEG:[CURerr],ZeroDivide
	test	EMSEG:[CWmask],ZeroDivide	;Exception masked?
	jz	XtractExit
	mov	EMSEG:[CURstk],edi
        mov     EMSEG:[edi].ExpSgn,eax
        mov     eax,EMSEG:[esi].lManHi
        mov     EMSEG:[edi].lManHi,eax
        mov     eax,EMSEG:[esi].lManLo
        mov     EMSEG:[edi].lManLo,eax
	mov	EMSEG:[esi].ExpSgn,(IexpMax-IexpBias+TexpBias) shl 16 + bSign shl 8 + bTAG_INF
	mov	EMSEG:[esi].bMan7,80H	;Change zero to infinity
	ret

XtractInf:
;Result is ST(0) = infinity (same sign), ST(1) = +infinity
        mov     EMSEG:[esi].bSgn,0            ;Ensure ST(1) is positive
XtractQNAN:
        mov     EMSEG:[CURstk],edi
        mov     EMSEG:[edi].ExpSgn,eax
        mov     eax,EMSEG:[esi].lManHi
        mov     EMSEG:[edi].lManHi,eax
        mov     eax,EMSEG:[esi].lManLo
        mov     EMSEG:[edi].lManLo,eax
        ret

XtractNAN:
;Result is two QNANs, signal Invalid Operation if SNAN
	test	EMSEG:[esi].bMan7,40H		;Is it SNAN?
	jnz	XtractQNAN
	mov	EMSEG:[CURerr],Invalid
	test	EMSEG:[CWmask],Invalid
	jz	XtractExit
	or	EMSEG:[esi].bMan7,40H		;Change to QNAN
        jmp     XtractQNAN

;*******************************************************************************
;
;FSCALE instruction

;Actual instruction entry point is in emarith.asm

;Dispatch table for scale
;
;One operand has been loaded into ecx:ebx:esi ("source"), the other is
;pointed to by edi ("dest").  
;
;Tag of source is shifted.  Tag values are as follows:

.erre	TAG_SNGL	eq	0	;SINGLE: low 32 bits are zero
.erre	TAG_VALID	eq	1
.erre	TAG_ZERO	eq	2
.erre	TAG_SPCL	eq	3	;NAN, Infinity, Denormal, Empty

;Any special case routines not found in this file are in emarith.asm

tFscaleDisp	label	